{"code":"(this.webpackJsonpcreatingjsxcomponent=this.webpackJsonpcreatingjsxcomponent||[]).push([[1810],{3238:function(e,i,n){\"use strict\";n.r(i),n.d(i,\"getServerVisibilityLoader\",(function(){return g})),n.d(i,\"addServerVisibilityLoaderToCtx\",(function(){return y}));var t=n(12),a=n(3041),c=n.n(a),r=n(38),o=n(39),s=n.n(o),d=n(11),l=n(277),u=new s.a(\"async\");let b={};b={debouncePromise:function(e,i,n){var t=null,a=null,c=[],r=!1,o=function(){var i=c;return t=null,c=[],e(i)};return function(e){t||(t=d.a.instance.defer()),a&&l.a.instance.cancel(a),c.push(e);var s=function(){n?n.isUnlocked()?r?(u(\"Debounce is unlocked restarting timer\",i),r=!1,a=l.a.instance(s,i)):(u(\"Debounce is unlocked doing action\",i),o()):(u(\"Debounce is locked\",i),r=!0,a=l.a.instance(s,i)):o()};return u(\"New item added resetting timer\",i,e),a=l.a.instance(s,i),t.promise}}};var m=b;const v=new s.a(\"command:tcCommandVisibilityService2\");var f=function(){return 0===Object(r.b)()||(v(\"Visibility service is locked - SOA is active\"),!1)};const g=()=>new c.a((async e=>{const i={getVisibleCommandsInfo:e};v(\"Making batched SOA call to load visibility\",i);const n=await Object(r.c)(\"Internal-AWS2-2016-03-UiConfig\",\"getVisibleCommands\",i,{});return e.map((()=>n.visibleCommandsInfo))}),{cache:!1,batchScheduleFn:e=>m.debouncePromise(e,100,{isUnlocked:f})()}),y=()=>{v(\"Adding shared visibility loader to ctx\"),t.default.registerPartialCtx(\"services.awCommandVisibilityLoader\",g())};i.default={addServerVisibilityLoaderToCtx:y,getServerVisibilityLoader:g}}}]);","name":"static/js/1810.3895ff71.chunk.js","input":"(this[\"webpackJsonpcreatingjsxcomponent\"] = this[\"webpackJsonpcreatingjsxcomponent\"] || []).push([[1810],{\n\n/***/ 3238:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"getServerVisibilityLoader\", function() { return /* binding */ getServerVisibilityLoader; });\n__webpack_require__.d(__webpack_exports__, \"addServerVisibilityLoaderToCtx\", function() { return /* binding */ addServerVisibilityLoaderToCtx; });\n\n// EXTERNAL MODULE: ./node_modules/@swf/core/src/declarativeui/src/js/appCtxService.js\nvar appCtxService = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./node_modules/dataloader/index.js\nvar dataloader = __webpack_require__(3041);\nvar dataloader_default = /*#__PURE__*/__webpack_require__.n(dataloader);\n\n// EXTERNAL MODULE: ./node_modules/@swf/core/src/kernel/src/js/soa/kernel/soaService.js + 1 modules\nvar soaService = __webpack_require__(38);\n\n// EXTERNAL MODULE: ./node_modules/debug/src/browser.js\nvar browser = __webpack_require__(39);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n\n// EXTERNAL MODULE: ./node_modules/@swf/core/src/services/src/js/awPromiseService.js\nvar awPromiseService = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/@swf/core/src/services/src/js/awTimeoutService.js\nvar awTimeoutService = __webpack_require__(277);\n\n// CONCATENATED MODULE: ./node_modules/@swf/core/src/kernel/src/js/async.service.js\n// Copyright (c) 2020 Siemens\n/**\n * Defines {@link NgServices.async} which provides a set of utilities for handling async methods\n *\n * @module js/async.service\n */var trace=new browser_default.a('async');/* eslint-disable-next-line valid-jsdoc*/let async_service_exports={};/**\n * Get an api capable of executing the given api async\n *\n * @param {Function<List<a>>} methodToExecute Method to call. Input will be a list of a where a is the input to the debounced method\n * @param {Number} debounceTime How long to debounce method calls\n * @param {Lock} lock A \"lock\" with a \"isUnlocked\" function. Allows external control of call on top of debounce\n * @returns {Function<a>} A debounced version of the method that supports individual calls\n */var debouncePromise=function(methodToExecute,debounceTime,lock){/**\n     * Promise tracking any currently active batch.\n     *\n     * Resolved once the method is actually executed.\n     */var deferred=null;/**\n     * The current active timer. If allowed to complete the method will be executed.\n     */var debounceTimer=null;/**\n     * Items to pass to the network\n     */var items=[];/**\n     * Flag tracking if the service was previously locked\n     */var wasLocked=false;/**\n     * Actually execute the action\n     *\n     * @returns {Promise} Promise resolved after execution\n     */var doAction=function(){// Clear the reference to current batch - set to null to prevent additions to current batch post timeout\nvar currentDefer=deferred;var currentItems=items;deferred=null;items=[];// Actually do the method\nreturn methodToExecute(currentItems);};/**\n     * Add a new item to batch\n     *\n     * Returns a promise resolved when the method is actually executed.\n     *\n     * @param {a} item The item to add\n     * @returns {Promise} Promise resolved when action is actually executed\n     */return function(item){// If a batch is not already active create a new one\nif(!deferred){deferred=awPromiseService[\"a\" /* default */].instance.defer();}// If the timer is running cancel it\nif(debounceTimer){awTimeoutService[\"a\" /* default */].instance.cancel(debounceTimer);}// Add item to batch and start a new timer\nitems.push(item);var timerComplete=function(){if(lock){if(lock.isUnlocked()){if(!wasLocked){trace('Debounce is unlocked doing action',debounceTime);// Debounce after unlock has finished, safe to do action\ndoAction();}else{trace('Debounce is unlocked restarting timer',debounceTime);wasLocked=false;// Unlock just happened, restart regular debounce\ndebounceTimer=awTimeoutService[\"a\" /* default */].instance(timerComplete,debounceTime);}}else{trace('Debounce is locked',debounceTime);wasLocked=true;// Locked, reset timer and check again after debounce\ndebounceTimer=awTimeoutService[\"a\" /* default */].instance(timerComplete,debounceTime);}}else{// No extra lock, just do the action\ndoAction();}};trace('New item added resetting timer',debounceTime,item);debounceTimer=awTimeoutService[\"a\" /* default */].instance(timerComplete,debounceTime);// Return the \"shared\" promise\nreturn deferred.promise;};};async_service_exports={debouncePromise};/* harmony default export */ var async_service = (async_service_exports);\n// CONCATENATED MODULE: ./node_modules/@swf/core/src/command/src/js/tcCommandVisibilityService2.js\n// Copyright (c) 2020 Siemens\n/**\n * @module js/tcCommandVisibilityService2\n *//**\n * How long to wait after the last \"request\" to load visibility before actually making the SOA call.\n * Because command bars will not render if server visibility is not ready this is also the minimum\n * delay before a command bar will appear.\n *\n * Will probably be reworked in the future\n */const commandBatchLoadTime=100;const tcCommandVisibilityService2_trace=new browser_default.a('command:tcCommandVisibilityService2');/**\n  * Unlock detection function\n  *\n  * @returns {Boolean} If the service is unlocked\n  */var unlockFunction=function(){if(Object(soaService[\"b\" /* getPendingRequestsCount */])()!==0){tcCommandVisibilityService2_trace('Visibility service is locked - SOA is active');return false;}return true;};/**\n * Get a dataloader that batches up calls to the getVisibleCommands SOA\n * @returns {DataLoader} Server visibility dataloader\n */const getServerVisibilityLoader=()=>{return new dataloader_default.a(async getVisibleCommandsInfo=>{const input={getVisibleCommandsInfo};tcCommandVisibilityService2_trace('Making batched SOA call to load visibility',input);const response=await Object(soaService[\"c\" /* postUnchecked */])('Internal-AWS2-2016-03-UiConfig','getVisibleCommands',input,{});//New SOA is needed to fully support this use case. SOA accepts multiple sets of info as input but only returns a single list of visible commands\nreturn getVisibleCommandsInfo.map(()=>response.visibleCommandsInfo);},{//Only batching of requests done at this level. Caching managed at lower levels (ex sublocation)\ncache:false,batchScheduleFn:callback=>{return async_service.debouncePromise(callback,commandBatchLoadTime,{isUnlocked:unlockFunction})();}});};/**\n * Startup function to create a shared dataloader and add to ctx\n */const addServerVisibilityLoaderToCtx=()=>{tcCommandVisibilityService2_trace('Adding shared visibility loader to ctx');appCtxService[\"default\"].registerPartialCtx('services.awCommandVisibilityLoader',getServerVisibilityLoader());};/* harmony default export */ var tcCommandVisibilityService2 = __webpack_exports__[\"default\"] = ({addServerVisibilityLoaderToCtx,getServerVisibilityLoader});\n\n/***/ })\n\n}]);","inputSourceMap":null}