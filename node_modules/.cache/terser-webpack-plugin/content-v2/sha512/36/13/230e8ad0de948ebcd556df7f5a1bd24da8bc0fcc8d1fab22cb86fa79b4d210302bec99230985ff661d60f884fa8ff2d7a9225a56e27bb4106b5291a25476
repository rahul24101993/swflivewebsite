{"code":"(this.webpackJsonpcreatingjsxcomponent=this.webpackJsonpcreatingjsxcomponent||[]).push([[20],{266:function(t,e,n){\"use strict\";let r={},a=(t,e,n)=>{let r=\"HORIZONTAL\"===e?\"offsetTop\":\"offsetLeft\";var a=n;if(!a){let e=t?t.querySelectorAll(\".sw-tabContainer>.sw-tab\"):void 0;a=e?e[e.length-1]:void 0}return!(!t||!a)&&a[r]>t[r]};r={overflowBreakPointCalculatorForTabs:function(){var t,e=0;return function(n,r){if(!n)return e;t=n.querySelectorAll(\".sw-tabContainer>.sw-tab\"),e=t.length;for(var i=t.length-1;i>=0;i--)if(!a(n,r,t[i])){e=i+1;break}return e}},hasOverflowForTabs:a,updateTabIndexOnOverflow:function(t,e){let n=t.querySelectorAll(\".sw-tabContainer >.sw-tab\");for(var r=n.length-1;r>=0;r--){var i=n[r].querySelector(\"a:not(.disabled)\");i&&(a(t,e,n[r])?i.setAttribute(\"tabindex\",-1):i.setAttribute(\"tabindex\",0))}},calculateBreakIndex:function(){var t,e=0;return function(n,r,a){if(!r)return e;t=r.querySelectorAll(\".sw-tabContainer>.sw-tab\");let i=[...t];if(a&&function(t,e,n){let r=0;for(var a=0;a<e.length;a++)r+=e[a].getClientRects()[0].width+n;return Math.round(r)>t.clientWidth}(r,i,16)){let t=i.find((t=>{const e=t.getElementsByTagName(\"a\")[0];return!!e&&e.getAttribute(\"name\")===String(a.pageId)})),l=16,s=0;t&&(s=t.getClientRects()[0].width+16+l);for(var o=0;o<n.length;o++){let t=i.find((t=>{const e=t.getElementsByTagName(\"a\")[0];return!!e&&e.getAttribute(\"name\")===String(n[o].pageId)}));if(t&&(s+=t.getClientRects()[0].width+16),s>r.clientWidth){e=o;break}}return e}}}},e.a=r}}]);","name":"static/js/20.be78bbfb.chunk.js","input":"(this[\"webpackJsonpcreatingjsxcomponent\"] = this[\"webpackJsonpcreatingjsxcomponent\"] || []).push([[20],{\n\n/***/ 266:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export hasOverflowForTabs */\n/* unused harmony export overflowBreakPointCalculatorForTabs */\n/* unused harmony export updateTabIndexOnOverflow */\n/* unused harmony export calculateBreakIndex */\n// Copyright (c) 2020 Siemens\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */ /**\n * Tab Overflow Service to manage tabs.\n */let exports={};/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */let hasOverflowForTabs=(tabContainerElem,tabContainerAlignment,tabElem)=>{let propName=tabContainerAlignment==='HORIZONTAL'?'offsetTop':'offsetLeft';var tabElement=tabElem;if(!tabElement){let currentTabElems=tabContainerElem?tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab'):undefined;tabElement=currentTabElems?currentTabElems[currentTabElems.length-1]:undefined;}//We just check the element's offsetTop against the container's offset top to determine if there's an overflow\nif(!tabContainerElem||!tabElement){return false;}return tabElement[propName]>tabContainerElem[propName];};/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */let overflowBreakPointCalculatorForTabs=function(){var tabElems;var breakIndex=0;return function(tabContainerElem,tabContainerAlignment){if(!tabContainerElem){return breakIndex;}tabElems=tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');breakIndex=tabElems.length;for(var i=tabElems.length-1;i>=0;i--){// find the first tab which doesn't have overflow in reverse order\nif(!hasOverflowForTabs(tabContainerElem,tabContainerAlignment,tabElems[i])){breakIndex=i+1;break;}}return breakIndex;};};let updateTabIndexOnOverflow=function(tabContainerElement,tabContainerAlignment){let tabElements=tabContainerElement.querySelectorAll('.sw-tabContainer >.sw-tab');for(var i=tabElements.length-1;i>=0;i--){var tabElementAnchor=tabElements[i].querySelector('a:not(.disabled)');if(tabElementAnchor){if(hasOverflowForTabs(tabContainerElement,tabContainerAlignment,tabElements[i])){tabElementAnchor.setAttribute('tabindex',-1);}else{tabElementAnchor.setAttribute('tabindex',0);}}}};/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */const isTabsOverflown=function(tabContainerElem,tabElems,tabPadding){let totalWidth=0;for(var i=0;i<tabElems.length;i++){totalWidth+=tabElems[i].getClientRects()[0].width+tabPadding;}return Math.round(totalWidth)>tabContainerElem.clientWidth;};/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */let calculateBreakIndex=function(){var tabElems;var breakIndex=0;return function(tabsModelForContainer,tabContainerElem,selectedTabModel){if(!tabContainerElem){return breakIndex;}tabElems=tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');let arr=[...tabElems];var tabPadding=16;if(selectedTabModel&&isTabsOverflown(tabContainerElem,arr,tabPadding)){let selectedTabObject=arr.find(element=>{const anchor=element.getElementsByTagName('a')[0];if(anchor){return anchor.getAttribute('name')===String(selectedTabModel.pageId);}return false;});let initialTabPadding=16;let totalWidth=0;if(selectedTabObject){totalWidth=selectedTabObject.getClientRects()[0].width+tabPadding+initialTabPadding;}for(var i=0;i<tabsModelForContainer.length;i++){let currentTabObject=arr.find(element=>{const anchor=element.getElementsByTagName('a')[0];if(anchor){return anchor.getAttribute('name')===String(tabsModelForContainer[i].pageId);}return false;});if(currentTabObject){totalWidth+=currentTabObject.getClientRects()[0].width+tabPadding;}if(totalWidth>tabContainerElem.clientWidth){breakIndex=i;break;}}return breakIndex;}};};exports={overflowBreakPointCalculatorForTabs,hasOverflowForTabs,updateTabIndexOnOverflow,calculateBreakIndex};/* harmony default export */ __webpack_exports__[\"a\"] = (exports);\n\n/***/ })\n\n}]);","inputSourceMap":null}