{"code":"(this.webpackJsonpcreatingjsxcomponent=this.webpackJsonpcreatingjsxcomponent||[]).push([[1817],{2869:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"constants\",(function(){return c})),n.d(t,\"activeSplitterData\",(function(){return d})),n.d(t,\"initSplitter\",(function(){return v})),n.d(t,\"mouseDownEvent\",(function(){return w})),n.d(t,\"mouseUpEventHandler\",(function(){return g})),n.d(t,\"mouseMoveEventHandler\",(function(){return y})),n.d(t,\"updateActiveSplitter\",(function(){return x})),n.d(t,\"updateAreaSize\",(function(){return h})),n.d(t,\"splitterLimit\",(function(){return E})),n.d(t,\"reportError\",(function(){return z})),n.d(t,\"updateViewMode\",(function(){return A}));var i=n(7),r=n(32),a=n(6),o=n(1),l=n.n(o),s=n(82);let u;const c={minSize1:20,minSize2:20};let d=null,p=null,m=l.a.debounce((function(e,t,n){p&&p({splitter:e.splitter,area1:t,area2:n}),i.a.publish(\"aw-splitter-update\",{splitter:e.splitter,area1:t,area2:n})}),1e3,{maxWait:2e4,trailing:!0,leading:!1});const v=(e,t,n)=>{let i=t;var a;let o=e.get(\"splitter\").current;var l=o.previousElementSibling,s=o.nextElementSibling;if(!l&&!s){let e=o.closest(\".aw-xrt-columnContentPanel\");e&&(l=e.previousElementSibling,s=e.nextElementSibling,e.style[\"min-width\"]=\"16px\",e.style.width=\"16px\",e.style[\"max-width\"]=\"16px\",e.style.padding=\"0px\",e.style.overflow=\"hidden\",e.parentElement.style.flexWrap=\"nowrap\",e.parentElement.style.height=\"100%\",e.parentElement.parentElement.style.height=\"100%\",l.style.minWidth=\"0px\",s.style.minWidth=\"0px\",o.style.height=window.getComputedStyle(e).getPropertyValue(\"height\"))}i.direction&&\"HORIZONTAL\"===i.direction.toUpperCase()?o.style.cursor=\"row-resize\":o.style.cursor=\"col-resize\",o.onmousedown=e=>u.mouseDownEvent(e,t.action),o.ontouchstart=e=>u.mouseDownEvent(e,t.action),\"true\"===i.isPrimarySplitter&&(n&&(u.viewModeContext=n),r.default.get(u.viewModeContext)&&(a=JSON.parse(r.default.get(u.viewModeContext)))&&l&&s&&(l.style.flexBasis=a.area1Size+\"px\",l.style.webkitFlexBasis=a.area1Size+\"px\",l.style.flexGrow=\"1\",l.style.flexShrink=\"1\",s.style.flexBasis=a.area2Size+\"px\",s.style.webkitFlexBasis=a.area2Size+\"px\"))};let S=function(e){var t=e.contentWindow.onmousemove;e.contentWindow.onmousemove=function(n){t&&t(n);var i=document.createEvent(\"MouseEvents\"),r=e.getBoundingClientRect();i.initMouseEvent(\"mousemove\",!0,!1,window,n.detail,n.screenX,n.screenY,n.clientX+r.left,n.clientY+r.top,n.ctrlKey,n.altKey,n.shiftKey,n.metaKey,n.button,null),e.dispatchEvent(i)},e.contentWindow.onmouseup=function(t){var n=document.createEvent(\"MouseEvents\"),i=e.getBoundingClientRect();n.initMouseEvent(\"mouseup\",!0,!1,window,t.detail,t.screenX,t.screenY,t.clientX+i.left,t.clientY+i.top,t.ctrlKey,t.altKey,t.shiftKey,t.metaKey,t.button,null),e.dispatchEvent(n)}},f=function(e){try{return\"onmousemove\"in e.contentWindow}catch(t){return!1}},w=function(e,t){if(e=e||window.event,window.getSelection){var n=window.getSelection();null!==n.focusNode&&n.removeAllRanges()}else document.selection&&document.selection.empty();e.stopPropagation(),e.preventDefault();var i=e.clientX,r=e.clientY;i||r||(i=e.touches[0].clientX,r=e.touches[0].clientY);var a=e.currentTarget,o=a.previousElementSibling,l=a.nextElementSibling;if(!o&&!l){let e=a.closest(\".aw-xrt-columnContentPanel\");e&&(o=e.previousElementSibling,l=e.nextElementSibling)}var s=parseInt(a.getAttribute(\"min-size-1\")),c=parseInt(a.getAttribute(\"min-size-2\")),d=a.getAttribute(\"isPrimarySplitter\"),m=a.getAttribute(\"viewMode\");s||c||(s=u.constants.minSize1,c=u.constants.minSize2);var v=a.style.cursor;u.activeSplitterData={splitter:a,area1:o,area2:l,minSize1:s,minSize2:c,direction:v,isPrimarySplitter:d,viewMode:m,x:i,y:r},p=t;for(var w=document.getElementsByTagName(\"iframe\"),x=0;x<w.length;x++)f(w[x])&&S(w[x]);document.addEventListener(\"mousemove\",y),document.addEventListener(\"mouseup\",g),document.addEventListener(\"touchmove\",y),document.addEventListener(\"touchend\",g),document.addEventListener(\"touchcancel\",g)},g=function(){document.removeEventListener(\"mousemove\",y),document.removeEventListener(\"mouseup\",g),document.removeEventListener(\"touchmove\",y),document.removeEventListener(\"touchend\",g),document.removeEventListener(\"touchcancel\",g);for(var e,t=document.getElementsByTagName(\"iframe\"),n=0;n<t.length;n++)f(t[n])&&((e=t[n]).contentWindow.onmousemove=null,e.contentWindow.onmouseup=null);if(u.activeSplitterData.viewMode&&(u.viewModeContext=u.activeSplitterData.viewMode),u.activeSplitterData.isPrimarySplitter&&u.viewModeContext){u.activeSplitterData.area1.style.flexGrow=\"1\",u.activeSplitterData.area1.style.flexShrink=\"1\";var i=u.activeSplitterData.area1.clientWidth,a=u.activeSplitterData.area2.clientWidth,o={area1Size:i,area2Size:a};r.default.publish(u.viewModeContext,JSON.stringify(o)),((e,t)=>{let n={sanAnalyticsType:\"Splitter\",sanCommandId:\"Splitter\",sanCommandTitle:\"Splitter\"};n.sanPrimaryPercentage=(e/(e+t)*100).toFixed(2),n.sanPixelSize=e,s.a.logCommands(n)})(i,a)}u.activeSplitterData=null},y=function(e){if(e=e||window.event,null!==u.activeSplitterData){e.preventDefault();var t=e.clientX,n=e.clientY;if(!t&&!n){var i=e.originalEvent.touches[0];t=i.clientX,n=i.clientY}u.updateActiveSplitter(t,n)}},x=function(e,t){var n=u.activeSplitterData;if(n){var i=e-n.x,r=t-n.y;if(0!==i||0!==r){var a=n.area1,o=n.area2,l=n.minSize1,s=n.minSize2,c=parseFloat(a.style.flexGrow),d=parseFloat(o.style.flexGrow);if(\"row-resize\"===n.direction){var p=a.clientHeight,v=o.clientHeight;if(u.splitterLimit(p,v,r,l,s))return void(c||d||(r>0&&v!==s?(u.updateAreaSize(a,c,p,v-s),u.updateAreaSize(o,d,s,\"\")):r<0&&p!==l&&(u.updateAreaSize(a,c,l,\"\"),u.updateAreaSize(o,d,v,p-l)),n.y=n.splitter.getBoundingClientRect().top-10,n.x=e));u.updateAreaSize(a,c,p,r),u.updateAreaSize(o,d,v,-r)}else{var S=a.offsetWidth,f=o.offsetWidth;if(u.splitterLimit(S,f,i,l,s))return void(c||d||(i>0&&f!==s?(u.updateAreaSize(a,c,S,f-s),u.updateAreaSize(o,d,s,\"\")):i<0&&S!==l&&(u.updateAreaSize(a,c,l,\"\"),u.updateAreaSize(o,d,f,S-l)),n.x=n.splitter.getBoundingClientRect().right-10,n.y=t));u.updateAreaSize(a,c,S,i),u.updateAreaSize(o,d,f,-i)}n.x=e,n.y=t,m(n,a,o)}}},h=function(e,t,n,i){var r=n+i;e.getAttribute(\"when\")&&(e.style.maxWidth=\"100%\"),e.style.flexBasis=r.toString()+\"px\",e.style.webkitFlexBasis=r.toString()+\"px\"},E=function(e,t,n,i,r){if(n>0){if(t-n<r)return!0}else if(e+n<i)return!0;return!1},z=function(e){a.a.warn(\"awSplitterService:\"+e)},A=function(e){return e};u={constants:c,activeSplitterData:d,initSplitter:v,mouseDownEvent:w,mouseUpEventHandler:g,mouseMoveEventHandler:y,updateActiveSplitter:x,updateAreaSize:h,splitterLimit:E,reportError:z,updateViewMode:A},t.default=u}}]);","name":"static/js/1817.132a34bc.chunk.js","input":"(this[\"webpackJsonpcreatingjsxcomponent\"] = this[\"webpackJsonpcreatingjsxcomponent\"] || []).push([[1817],{\n\n/***/ 2869:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"constants\", function() { return constants; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"activeSplitterData\", function() { return activeSplitterData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initSplitter\", function() { return initSplitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseDownEvent\", function() { return mouseDownEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseUpEventHandler\", function() { return mouseUpEventHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseMoveEventHandler\", function() { return mouseMoveEventHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateActiveSplitter\", function() { return updateActiveSplitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateAreaSize\", function() { return updateAreaSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitterLimit\", function() { return splitterLimit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reportError\", function() { return reportError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateViewMode\", function() { return updateViewMode; });\n/* harmony import */ var js_eventBus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);\n/* harmony import */ var js_localStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);\n/* harmony import */ var js_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var js_analyticsService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82);\n// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * @module js/awSplitterService\n */ // module\nlet exports;const constants={minSize1:20,minSize2:20};// A structure set when a splitter is activated (only one splitter an be active at any time)\n// See exports.mouseDownEvent for structure definition\nlet activeSplitterData=null;let splitterAction=null;// Tell the world the areas have changed size through a debounce function.\nlet publishNotification=lodash__WEBPACK_IMPORTED_MODULE_3___default.a.debounce(function(splitterData,area1,area2){splitterAction&&splitterAction({splitter:splitterData.splitter,area1:area1,area2:area2});js_eventBus__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].publish('aw-splitter-update',{splitter:splitterData.splitter,area1:area1,area2:area2});},1000,{maxWait:20000,trailing:true,leading:false});/**\n * Method to publish analytics to server\n * @param {Number} area1Size - size of area1 in the UI (in pixels)\n * @param {Number} area2Size - size of area2 in the UI (in pixels)\n */const publishAnalytics=(area1Size,area2Size)=>{let splitterEventData={};splitterEventData.sanAnalyticsType='Splitter';splitterEventData.sanCommandId='Splitter';splitterEventData.sanCommandTitle='Splitter';splitterEventData.sanPrimaryPercentage=(area1Size/(area1Size+area2Size)*100).toFixed(2);splitterEventData.sanPixelSize=area1Size;js_analyticsService__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"].logCommands(splitterEventData);};/**\n * Initialize a Given Splitter\n *\n * Set the onmousedown event for the splitter and establishes the type of splitter\n *\n * @param {object} elementRefList - The elements used to define the splitter\n * @param {object} prop - The React props defined on the splitter\n * @param {object} viewMode - The current viewMode on time on init\n */const initSplitter=(elementRefList,prop,viewMode)=>{let attributes=prop;var initialSplitterState;let splitter=elementRefList.get('splitter').current;var area1=splitter.previousElementSibling;var area2=splitter.nextElementSibling;if(!area1&&!area2){// xrt-splitter\nlet colSplit=splitter.closest('.aw-xrt-columnContentPanel');if(colSplit){area1=colSplit.previousElementSibling;area2=colSplit.nextElementSibling;colSplit.style['min-width']='16px';colSplit.style.width='16px';colSplit.style['max-width']='16px';colSplit.style.padding='0px';colSplit.style.overflow='hidden';colSplit.parentElement.style.flexWrap='nowrap';colSplit.parentElement.style.height='100%';colSplit.parentElement.parentElement.style.height='100%';area1.style.minWidth='0px';area2.style.minWidth='0px';splitter.style.height=window.getComputedStyle(colSplit).getPropertyValue('height');}}// If user defines a direction use that. If not, check for row/column on each side. Else default to vertical\nif(attributes.direction&&attributes.direction.toUpperCase()==='HORIZONTAL'){splitter.style.cursor='row-resize';}else{splitter.style.cursor='col-resize';}splitter.onmousedown=event=>exports.mouseDownEvent(event,prop.action);splitter.ontouchstart=event=>exports.mouseDownEvent(event,prop.action);// If this is the primary sash, load its previous position for a specific view.\nif(attributes.isPrimarySplitter==='true'){if(viewMode){exports.viewModeContext=viewMode;}if(js_localStorage__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(exports.viewModeContext)){initialSplitterState=JSON.parse(js_localStorage__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(exports.viewModeContext));if(initialSplitterState&&area1&&area2){area1.style.flexBasis=initialSplitterState.area1Size+'px';area1.style.webkitFlexBasis=initialSplitterState.area1Size+'px';area1.style.flexGrow='1';area1.style.flexShrink='1';area2.style.flexBasis=initialSplitterState.area2Size+'px';area2.style.webkitFlexBasis=initialSplitterState.area2Size+'px';}}}};// Setup mousemove/mouseup event listeners for iframes\nlet bubbleIframeMouseMove=function(iframe){var existingOnMouseMove=iframe.contentWindow.onmousemove;iframe.contentWindow.onmousemove=function(e){// Fire any existing onmousemove listener\nif(existingOnMouseMove){existingOnMouseMove(e);}var evt=document.createEvent('MouseEvents');var boundingClientRect=iframe.getBoundingClientRect();evt.initMouseEvent('mousemove',true,// true bubbles the event\nfalse,// not cancelable\nwindow,e.detail,e.screenX,e.screenY,e.clientX+boundingClientRect.left,e.clientY+boundingClientRect.top,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,null// no related element\n);iframe.dispatchEvent(evt);};iframe.contentWindow.onmouseup=function(e){var evt=document.createEvent('MouseEvents');var boundingClientRect=iframe.getBoundingClientRect();evt.initMouseEvent('mouseup',true,// true bubbles the event\nfalse,// not cancelable\nwindow,e.detail,e.screenX,e.screenY,e.clientX+boundingClientRect.left,e.clientY+boundingClientRect.top,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,null// no related element\n);iframe.dispatchEvent(evt);};};// Removes iframe mouse event listeners\nlet removebubbleIframeMouseEvent=function(iframe){iframe.contentWindow.onmousemove=null;iframe.contentWindow.onmouseup=null;};// handling DOM exception: if we try to access any event(e.g. onmouseup,onmousedown,etc) for cross-origin, we get DOM exception.\nlet canAccessIFrame=function(iframe){try{return'onmousemove'in iframe.contentWindow;}catch(err){return false;}};/**\n * Mouse Down Event - initialize the active splitter\n *\n * @param {object} event - mouse down event object\n */let mouseDownEvent=function(event,action){// Do not allow accidental text selection - which will cause the splitter to lockup\n// Note that there are various CSS properties to control this but not a common one yet (as far as I can tell)\n// Look for user-select: none (also ms-user-select and webkit-user-select and moz-user-select)\n// Until there is a common way to prevent accidental selection - here is the workaround\nevent=event||window.event;if(window.getSelection){var selection=window.getSelection();var node=selection.focusNode;if(node!==null){selection.removeAllRanges();}}else{if(document.selection){document.selection.empty();}}event.stopPropagation();event.preventDefault();// Create the active splitter data structure\nvar x=event.clientX;var y=event.clientY;if(!x&&!y){x=event.touches[0].clientX;y=event.touches[0].clientY;}var splitter=event.currentTarget;var area1=splitter.previousElementSibling;var area2=splitter.nextElementSibling;if(!area1&&!area2){// xrt-splitter\nlet colSplit=splitter.closest('.aw-xrt-columnContentPanel');if(colSplit){area1=colSplit.previousElementSibling;area2=colSplit.nextElementSibling;}}var minSize1=parseInt(splitter.getAttribute('min-size-1'));var minSize2=parseInt(splitter.getAttribute('min-size-2'));var isPrimarySplitter=splitter.getAttribute('isPrimarySplitter');var viewMode=splitter.getAttribute('viewMode');// If user did not define minimum sizes, default to 20\nif(!minSize1&&!minSize2){minSize1=exports.constants.minSize1;minSize2=exports.constants.minSize2;}var direction=splitter.style.cursor;exports.activeSplitterData={splitter:splitter,// The splitter element\narea1:area1,// The element to the left or on top\narea2:area2,// The element to the right or on bottom\nminSize1:minSize1,// The element to the left or on top minimum length\nminSize2:minSize2,// The element to the right or on bottom minimum length\ndirection:direction,// row-resize or column-resize\nisPrimarySplitter:isPrimarySplitter,// If the current splitter is the primary to remember its position\nviewMode:viewMode,x:x,y:y};// Last mouse position used to update splitter\nsplitterAction=action;// iframes suppress mouse events so the iframe's mouse events need to be bubbled up to the document level\nvar iframes=document.getElementsByTagName('iframe');for(var i=0;i<iframes.length;i++){if(canAccessIFrame(iframes[i])){bubbleIframeMouseMove(iframes[i]);}}document.addEventListener('mousemove',mouseMoveEventHandler);document.addEventListener('mouseup',mouseUpEventHandler);document.addEventListener('touchmove',mouseMoveEventHandler);document.addEventListener('touchend',mouseUpEventHandler);document.addEventListener('touchcancel',mouseUpEventHandler);};/**\n * Mouse Up Event Handler - stop the active splitter\n *\n * @param {event} event - Event object\n */let mouseUpEventHandler=function(){document.removeEventListener('mousemove',mouseMoveEventHandler);document.removeEventListener('mouseup',mouseUpEventHandler);document.removeEventListener('touchmove',mouseMoveEventHandler);document.removeEventListener('touchend',mouseUpEventHandler);document.removeEventListener('touchcancel',mouseUpEventHandler);// Remove iframe mouse event listeners on mouseup\nvar iframes=document.getElementsByTagName('iframe');for(var i=0;i<iframes.length;i++){if(canAccessIFrame(iframes[i])){removebubbleIframeMouseEvent(iframes[i]);}}// Remember the sash's position for the specific view.\nif(exports.activeSplitterData.viewMode){exports.viewModeContext=exports.activeSplitterData.viewMode;}if(exports.activeSplitterData.isPrimarySplitter&&exports.viewModeContext){// After moving the primary splitter, we want the primary workarea to become a flex-item in order to resize on browser width changes.\nexports.activeSplitterData.area1.style.flexGrow='1';exports.activeSplitterData.area1.style.flexShrink='1';var area1Size=exports.activeSplitterData.area1.clientWidth;var area2Size=exports.activeSplitterData.area2.clientWidth;var data={area1Size:area1Size,area2Size:area2Size};js_localStorage__WEBPACK_IMPORTED_MODULE_1__[\"default\"].publish(exports.viewModeContext,JSON.stringify(data));publishAnalytics(area1Size,area2Size);}exports.activeSplitterData=null;};/**\n * Mouse Move Event Handler - update the active splitter\n *\n * @param {event} event - Event object\n */let mouseMoveEventHandler=function(event){event=event||window.event;if(exports.activeSplitterData===null){return;}event.preventDefault();var x=event.clientX;var y=event.clientY;if(!x&&!y){var touch=event.originalEvent.touches[0];x=touch.clientX;y=touch.clientY;}exports.updateActiveSplitter(x,y);};/**\n * Update Active Splitter\n *\n * For a given mouse position update the size of the associated DIV elements for the active splitter.\n *\n * @param {number} xPos - current mouse X position\n * @param {number} yPos - current mouse Y position\n */let updateActiveSplitter=function(xPos,yPos){var splitterData=exports.activeSplitterData;if(!splitterData){return;}var xDelta=xPos-splitterData.x;var yDelta=yPos-splitterData.y;if(xDelta===0&&yDelta===0){return;}var area1=splitterData.area1;var area2=splitterData.area2;var minSize1=splitterData.minSize1;var minSize2=splitterData.minSize2;var size1=parseFloat(area1.style.flexGrow);var size2=parseFloat(area2.style.flexGrow);var direction=splitterData.direction;if(direction==='row-resize'){var h1=area1.clientHeight;var h2=area2.clientHeight;if(exports.splitterLimit(h1,h2,yDelta,minSize1,minSize2)){// make max size/min size if we hit the limit, not at the limit yet & not using flex grow\nif(!size1&&!size2){if(yDelta>0&&h2!==minSize2){exports.updateAreaSize(area1,size1,h1,h2-minSize2);exports.updateAreaSize(area2,size2,minSize2,'');}else if(yDelta<0&&h1!==minSize1){exports.updateAreaSize(area1,size1,minSize1,'');exports.updateAreaSize(area2,size2,h2,h1-minSize1);}splitterData.y=splitterData.splitter.getBoundingClientRect().top-10;splitterData.x=xPos;}return;}exports.updateAreaSize(area1,size1,h1,yDelta);exports.updateAreaSize(area2,size2,h2,-yDelta);}else{// direction is column-resize\nvar w1=area1.offsetWidth;var w2=area2.offsetWidth;if(exports.splitterLimit(w1,w2,xDelta,minSize1,minSize2)){// make max size/min size if we hit the limit, not at the limit yet & not using flex grow\nif(!size1&&!size2){if(xDelta>0&&w2!==minSize2){exports.updateAreaSize(area1,size1,w1,w2-minSize2);exports.updateAreaSize(area2,size2,minSize2,'');}else if(xDelta<0&&w1!==minSize1){exports.updateAreaSize(area1,size1,minSize1,'');exports.updateAreaSize(area2,size2,w2,w1-minSize1);}splitterData.x=splitterData.splitter.getBoundingClientRect().right-10;splitterData.y=yPos;}return;}exports.updateAreaSize(area1,size1,w1,xDelta);exports.updateAreaSize(area2,size2,w2,-xDelta);}splitterData.x=xPos;splitterData.y=yPos;publishNotification(splitterData,area1,area2);};/**\n * Update Area Size\n *\n * Update the size of a given area based on a delta amount and the type of area (fixed or proportional)\n *\n * @param {object} area - a row or column element\n * @param {number} oldSize - the previous attribute size value for the row or column\n * @param {number} oldSizePx - the previous rendered size in px for the row or column\n * @param {number} deltaPx - the amount to change the area in px\n */let updateAreaSize=function(area,oldSize,oldSizePx,deltaPx){var newSizePx=oldSizePx+deltaPx;var when=area.getAttribute('when');// This is a fixed size\n// Note the size is no longer in units of em because the user has set a fix px size\nif(when){area.style.maxWidth='100%';}area.style.flexBasis=newSizePx.toString()+'px';area.style.webkitFlexBasis=newSizePx.toString()+'px';};/**\n * Splitter Limit - return true if a splitter has hit a limiting size\n *\n * Return true if the limit is being hit for one of the areas The test is done this way because it is possible for\n * areas to become smaller than the limit due to window resizing. We want to be able to grow areas that are too\n * small with a splitter but not continue to shrink those areas\n *\n * @param {number} size1 - Size (width or height) of left or top area for the active splitter\n * @param {number} size2 - Size (width or height) of right or bottom area for the active splitter\n * @param {number} delta - Amount the sizes are being changed\n * @param {number} minSize1 - Minimum size (width or height) of left or top area for the active splitter\n * @param {number} minSize2 - Minimum size (width or height) of right or bottom area for the active splitter\n *\n *\n * @return {boolean} - true if a limit would be hit by the delta change\n */let splitterLimit=function(size1,size2,delta,minSize1,minSize2){if(delta>0){// The right or bottom area is being reduced in size\nif(size2-delta<minSize2){return true;}}else{// delta < 0 - the left or top area is being reduced in size\nif(size1+delta<minSize1){return true;}}return false;};/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */let reportError=function(errorMessage){js_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].warn('awSplitterService:'+errorMessage);};/**\n * Update viewMode based on context\n *\n * @param {string} viewModeKey - ctx key for viewMode\n * @returns {string} viewMode\n */let updateViewMode=function(viewModeKey){return viewModeKey;};exports={constants,activeSplitterData,initSplitter,mouseDownEvent,mouseUpEventHandler,mouseMoveEventHandler,updateActiveSplitter,updateAreaSize,splitterLimit,reportError,updateViewMode};/* harmony default export */ __webpack_exports__[\"default\"] = (exports);\n\n/***/ })\n\n}]);","inputSourceMap":null}