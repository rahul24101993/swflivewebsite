{"code":"(this.webpackJsonpcreatingjsxcomponent=this.webpackJsonpcreatingjsxcomponent||[]).push([[10],{128:function(e,s,t){\"use strict\";let n={},r=null,o=new Map,i=()=>\"function\"===typeof window.ResizeObserver;n={observe:(e,s)=>(o.set(e,s),!r&&i()&&(r=new ResizeObserver((e=>{e.forEach((e=>{o.has(e.target)&&o.get(e.target)(e)}))}))),r.observe(e),()=>{r.unobserve(e),o.delete(e)}),supportsResizeObserver:i},s.a=n}}]);","name":"static/js/10.5b1187aa.chunk.js","input":"(this[\"webpackJsonpcreatingjsxcomponent\"] = this[\"webpackJsonpcreatingjsxcomponent\"] || []).push([[10],{\n\n/***/ 128:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export supportsResizeObserver */\n/* unused harmony export observe */\n// Copyright (c) 2020 Siemens\n/**\n * Defines {@link NgServices.resizeObserverService} which manages element callbacks and resize observe/unobserve.\n *\n * @module js/resizeObserver.service\n */ /**\n * Resize observer service to manage element callbacks.\n */let exports={};// members\nlet _observerInstance=null;let _entryMap=new Map();/**\n * A helper service which allows performing custom actions when native DOM elements are resized.\n *\n *    const resizableElement = $element[ 0 ]; //The DOM element to observe\n *\n *    const observer = awResizeObserverService.observe( resizableElement, entry => {\n *      console.log( 'The element has been resized in DOM.' );\n *      console.log( entry.target ); // -> resizableElement\n *      console.log( entry.contentRect.width ); // -> e.g. '230px'\n *    } );\n *\n * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\n * under the hood. It does not support any polyfills for the browsers that don't support resize observer.\n */ /**\n * Returns if this browser supports resize observer API\n */let supportsResizeObserver=()=>{return typeof window.ResizeObserver==='function';};/**\n * Creates the single native observer shared across all `ResizeObserver` instances.\n *\n */let initializeResizeObserver=()=>{if(!_observerInstance&&supportsResizeObserver()){_observerInstance=new ResizeObserver(entries=>{entries.forEach(entry=>{if(_entryMap.has(entry.target)){_entryMap.get(entry.target)(entry);}});});}};/**\n * Registers a new resize callback for the DOM element.\n *\n * @param {HTMLElement} element\n * @param {Function} callback\n */let observe=(element,callback)=>{_entryMap.set(element,callback);initializeResizeObserver();_observerInstance.observe(element);/**\n     * Destroys the observer which disables the `callback` passed to the observe method.\n     */return()=>{_observerInstance.unobserve(element);_entryMap.delete(element);};};exports={observe,supportsResizeObserver};/* harmony default export */ __webpack_exports__[\"a\"] = (exports);\n\n/***/ })\n\n}]);","inputSourceMap":null}