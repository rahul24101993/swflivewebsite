{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to map the declarative resolve configuration to the ui router resolve state functionality.\n *\n\n * @module js/stateResolveService\n */\nimport _ from 'lodash';\nimport moduleLoader from 'js/moduleLoader';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport viewModelProcessingFactory from 'js/viewModelProcessingFactory';\nimport actionService from 'js/actionService';\n/**\n * Filter parameters that are not set and build the new object.\n *\n * @param {Object} stateParams - Routing state params.\n * @return {Object} params - processed paramater object.\n */\n\nvar processParameters = function (stateParams) {\n  return Object.keys(stateParams) // Filter parameters that are not set\n  .filter(function (param) {\n    return stateParams[param];\n  }) // Build the new object\n  .reduce(function (acc, nxt) {\n    acc[nxt] = stateParams[nxt];\n    return acc;\n  }, {});\n};\n/**\n * Get the state params object with processed params.\n *\n * @param {Object} stateParams - Routing state params.\n * @return {Object} params - Object of original state params and processed params.\n */\n\n\nvar getStateParamsObject = function (stateParams) {\n  return {\n    params: stateParams,\n    processed: processParameters(stateParams)\n  };\n};\n/**\n * Create declarative functions from resolveAction object and set it on the state.resolve\n *\n * @param {Object} state - Routing state.\n * @returns {Array} returns array of the resolveActions\n */\n\n\nexport const getResolvedActions = function (state) {\n  let resolveActions = [];\n\n  _.forEach(state.resolveActions, function (action, actionName) {\n    resolveActions.push({\n      token: `${actionName}Response`,\n      deps: ['$transition$'],\n      resolveFn: transition => {\n        //execute declarative action here\n        var defer = AwPromiseService.instance.defer();\n        var declarativeViewModelId = '__stateResolveSvc';\n        var declViewModel = viewModelProcessingFactory.createDeclViewModel({\n          _viewModelId: declarativeViewModelId\n        });\n        var dataCtxNode = {\n          ctx: appCtxService.ctx,\n          data: declViewModel\n        }; // Update the state params on app ctx.\n\n        dataCtxNode.ctx.state = getStateParamsObject(transition.params());\n        moduleLoader.loadDependentModule(action.deps).then(function (depModuleObj) {\n          actionService.executeAction(declViewModel, action, dataCtxNode, depModuleObj).then(function success(response) {\n            defer.resolve(response);\n          }, function reject(error) {\n            defer.reject(error);\n          }).finally(function () {\n            declViewModel._internal.destroy();\n          });\n        });\n        return defer.promise;\n      }\n    });\n  });\n\n  if (state.resolve) {\n    resolveActions = Array.isArray(state.resolve) ? state.resolve.concat(resolveActions) : resolveActions;\n  }\n\n  return resolveActions;\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/stateResolveService.js"],"names":["processParameters","stateParams","acc","getStateParamsObject","params","processed","getResolvedActions","resolveActions","_","state","token","actionName","deps","resolveFn","transition","defer","AwPromiseService","declarativeViewModelId","declViewModel","_viewModelId","dataCtxNode","ctx","appCtxService","data","moduleLoader","action","actionService","Array"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to map the declarative resolve configuration to the ui router resolve state functionality.\n *\n\n * @module js/stateResolveService\n */\nimport _ from 'lodash';\nimport moduleLoader from 'js/moduleLoader';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport viewModelProcessingFactory from 'js/viewModelProcessingFactory';\nimport actionService from 'js/actionService';\n\n/**\n * Filter parameters that are not set and build the new object.\n *\n * @param {Object} stateParams - Routing state params.\n * @return {Object} params - processed paramater object.\n */\nvar processParameters = function( stateParams ) {\n    return Object.keys( stateParams )\n        // Filter parameters that are not set\n        .filter( function( param ) {\n            return stateParams[ param ];\n        } )\n        // Build the new object\n        .reduce( function( acc, nxt ) {\n            acc[ nxt ] = stateParams[ nxt ];\n            return acc;\n        }, {} );\n};\n\n/**\n * Get the state params object with processed params.\n *\n * @param {Object} stateParams - Routing state params.\n * @return {Object} params - Object of original state params and processed params.\n */\nvar getStateParamsObject = function( stateParams ) {\n    return {\n        params: stateParams,\n        processed: processParameters( stateParams )\n    };\n};\n\n/**\n * Create declarative functions from resolveAction object and set it on the state.resolve\n *\n * @param {Object} state - Routing state.\n * @returns {Array} returns array of the resolveActions\n */\nexport const getResolvedActions = function( state ) {\n    let resolveActions = [];\n    _.forEach( state.resolveActions, function( action, actionName ) {\n        resolveActions.push( {\n            token: `${actionName}Response`,\n            deps: [ '$transition$' ],\n            resolveFn: ( transition ) => {\n                //execute declarative action here\n                var defer = AwPromiseService.instance.defer();\n                var declarativeViewModelId = '__stateResolveSvc';\n                var declViewModel = viewModelProcessingFactory.createDeclViewModel( {\n                    _viewModelId: declarativeViewModelId\n                } );\n                var dataCtxNode = {\n                    ctx: appCtxService.ctx,\n                    data: declViewModel\n                };\n                // Update the state params on app ctx.\n                dataCtxNode.ctx.state = getStateParamsObject( transition.params() );\n                moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObj ) {\n                    actionService.executeAction( declViewModel, action, dataCtxNode, depModuleObj ).then( function success( response ) {\n                        defer.resolve( response );\n                    }, function reject( error ) {\n                        defer.reject( error );\n                    } ).finally( function() {\n                        declViewModel._internal.destroy();\n                    } );\n                } );\n                return defer.promise;\n            }\n        } );\n    } );\n    if( state.resolve ) {\n        resolveActions = Array.isArray( state.resolve ) ? state.resolve.concat( resolveActions ) : resolveActions;\n    }\n    return resolveActions;\n};\n"]},"metadata":{},"sourceType":"module"}