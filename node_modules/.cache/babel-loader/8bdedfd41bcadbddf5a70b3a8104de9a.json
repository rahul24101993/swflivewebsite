{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines the {@link NgServices.leavePlaceService}\n *\n * @module js/leavePlace.service\n */\nimport logger from 'js/logger'; // => 'afx/src/kernel/src/js/logger'\n\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus'; // Service\n\nimport AwStateService from 'js/awStateService';\nimport AwPromiseService from 'js/awPromiseService';\nvar exports = {};\n/**\n * The currently registered handler.\n *\n * @private\n * @member _registeredAppHandler\n * @memberOf NgServices.leavePlaceService\n */\n\nlet _registeredAppHandler = null;\nlet _eventSubscriptions = [];\nexport let reset = function () {\n  _registeredAppHandler = null; // unsuscribe _eventSubscriptions if exists\n\n  _eventSubscriptions.forEach(s => {\n    eventBus.unsubscribe(s);\n  });\n\n  _eventSubscriptions = [];\n};\n/**\n * Initialization function, sets up the transition lifecycle hooks.\n * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation\n * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will\n * trigger navigation to the original target.\n *\n * @private\n * @function initializeRootScope\n * @memberOf NgServices.leavePlaceService\n * @param {Object} $rootScope - $rootScope\n */\n\nexport let loadConfiguration = function () {\n  reset();\n  let _persistAppHandler = false;\n  /**\n   * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.\n   */\n\n  AwStateService.instance.transitionHooks.onBefore({}, transition => {\n    if (isLocationChangeStartEvent(transition)) {\n      return locationChangeStart(transition);\n    }\n\n    if (isStateChangeStartEvent(transition)) {\n      return stateChangeStart(transition);\n    }\n  });\n\n  const locationChangeStart = transition => {\n    const defer = AwPromiseService.instance.defer();\n\n    if (_registeredAppHandler && !_persistAppHandler) {\n      let fromState = transition.from();\n      let fromParams = transition.params('from');\n      let toState = transition.to();\n      let toParams = transition.params();\n      let options = transition.options();\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // Functions to call after the okToLeave promise\n      // okToLeaveSuccess must be set, okToLeaveFailure can be null\n\n      let okToLeaveSuccess;\n      let okToLeaveFailure;\n\n      okToLeaveSuccess = () => {\n        // navigate to the target state using the current transition instance\n        transition.router.stateService.go(targetNavDetails.toState, targetNavDetails.toParams, targetNavDetails.options);\n        return true;\n      };\n\n      okToLeaveFailure = () => {\n        // Don't clear handler when the promise is rejected\n        logger.trace('Prevented navigation to ', targetNavDetails);\n        return true;\n      };\n\n      const {\n        targetNavInfo,\n        oldState,\n        newState\n      } = getOkToLeaveInfo(fromState, fromParams, toState, toParams); // Run the okToLeave handler\n\n      return _registeredAppHandler.okToLeave(targetNavInfo, oldState, newState).then(options => {\n        // Clear the handler\n        if (options && options.clearLeaveHandler === false) {\n          _persistAppHandler = true;\n        } else {\n          _registeredAppHandler = null;\n        }\n\n        return okToLeaveSuccess();\n      }, okToLeaveFailure);\n    }\n\n    defer.resolve();\n    _persistAppHandler = false;\n    return defer.promise;\n  };\n\n  const stateChangeStart = transition => {\n    const defer = AwPromiseService.instance.defer();\n\n    if (_registeredAppHandler) {\n      let fromState = transition.from();\n      let toState = transition.to();\n      let toParams = transition.params();\n      let options = transition.options();\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.fromState = fromState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // invoke the handler and setup up the promise continuation\n\n      return _registeredAppHandler.okToLeave(targetNavDetails).then(() => {\n        // clear the handler reference that ran to avoid recursion\n        _registeredAppHandler = null; // navigate to the target state using the current transition instance\n\n        transition.router.stateService.go(targetNavDetails.toState, targetNavDetails.toParams, targetNavDetails.options);\n        return true;\n      }, err => {\n        // eslint-disable-line no-unused-vars\n        logger.trace('Prevented navigation to ', targetNavDetails);\n        return true;\n      });\n    }\n\n    defer.resolve();\n    return defer.promise;\n  };\n\n  const getOkToLeaveInfo = (fromState, fromParams, toState, toParams) => {\n    return {\n      targetNavInfo: {},\n      oldState: {\n        params: fromParams,\n        state: {\n          name: fromState.name\n        }\n      },\n      newState: {\n        params: toParams,\n        state: {\n          name: toState.name\n        }\n      }\n    };\n  };\n};\n/**\n * Method used by application to create leave handler object from an api object that can perform the okToLeave check\n *\n * @function createAndRegisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} api - The object for the leave handler. Must have a method \"okToLeave\" that is called with a\n *            promise when the user attempts to change location / state.\n */\n\nexport let createAndRegisterLeaveHandler = function (api) {\n  var leaveHandler = {\n    api: api\n  };\n\n  leaveHandler.okToLeave = function () {\n    var deferred = AwPromiseService.instance.defer();\n    this.api.okToLeave(deferred);\n    return deferred.promise;\n  };\n\n  exports.registerLeaveHandler(leaveHandler);\n};\n/**\n * Method used for service consumer to register their handler function. Upon navigation, the \"okToLeave\" function\n * will be invoked. The function must return a promise, and when the handler logic completes the promise should be\n * resolved to allow navigation to continue or rejected to prevent the navigation.\n *\n * @function registerLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler Object function. Must have a \"okToLeave\" property which returns a\n *            promise.\n */\n\nexport let registerLeaveHandler = function (handler) {\n  if (handler && !handler.okToLeave) {\n    logger.error('Leave place handler', handler, 'does not have okToLeave property');\n  } else {\n    _registeredAppHandler = handler;\n  }\n};\n/**\n * Method used for deregister a given leave handler\n *\n * @function deregisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler to deregister\n */\n\nexport let deregisterLeaveHandler = function (handler) {\n  if (handler === _registeredAppHandler) {\n    _registeredAppHandler = null;\n  }\n};\nexport let isLocationChangeStartEvent = function (transition) {\n  if (_.isUndefined(transition) || _.isEmpty(transition)) {\n    return false;\n  } // page refresh case\n\n\n  if (transition.from().url === '^' && transition.from().name === '') {\n    return false;\n  } //invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params\n\n\n  if (_.isEqual(transition.from().name, transition.to().name) && !_.isEqual(transition.params('from'), transition.params('to'))) {\n    return true;\n  }\n\n  return false;\n};\nexport let isStateChangeStartEvent = function (transition) {\n  if (_.isUndefined(transition) || _.isEmpty(transition)) {\n    return false;\n  } // page refresh case\n\n\n  if (transition.from().url === '^' && transition.from().name === '') {\n    return false;\n  }\n\n  if (!_.isEqual(transition.from().name, transition.to().name)) {\n    return true;\n  }\n\n  return false;\n};\nexports = {\n  reset,\n  loadConfiguration,\n  createAndRegisterLeaveHandler,\n  registerLeaveHandler,\n  deregisterLeaveHandler,\n  isLocationChangeStartEvent,\n  isStateChangeStartEvent\n};\nexport default exports;\nloadConfiguration();","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/leavePlace.service.js"],"names":["exports","_registeredAppHandler","_eventSubscriptions","reset","s","eventBus","loadConfiguration","_persistAppHandler","AwStateService","transition","isLocationChangeStartEvent","locationChangeStart","isStateChangeStartEvent","stateChangeStart","defer","AwPromiseService","fromState","fromParams","toState","toParams","options","targetNavDetails","okToLeaveSuccess","okToLeaveFailure","logger","newState","getOkToLeaveInfo","err","targetNavInfo","oldState","params","state","name","createAndRegisterLeaveHandler","leaveHandler","api","deferred","registerLeaveHandler","handler","deregisterLeaveHandler","_"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAA,MAAA,MAAA,WAAA,C,CAAgC;;AAChC,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,QAAA,MAAA,aAAA,C,CAEA;;AACA,OAAA,cAAA,MAAA,mBAAA;AACA,OAAA,gBAAA,MAAA,qBAAA;AAEA,IAAIA,OAAO,GAAX,EAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,qBAAqB,GAAzB,IAAA;AAEA,IAAIC,mBAAmB,GAAvB,EAAA;AAEA,OAAO,IAAIC,KAAK,GAAG,YAAW;EAC1BF,qBAAqB,GADK,IAC1BA,CAD0B,CAG1B;;EACAC,mBAAmB,CAAnBA,OAAAA,CAA+BE,CAAF,IAAS;IAClCC,QAAQ,CAARA,WAAAA,CAAAA,CAAAA;EADJH,CAAAA;;EAIAA,mBAAmB,GAAnBA,EAAAA;AARG,CAAA;AAWP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,iBAAiB,GAAG,YAAW;EACtCH,KAAK;EACL,IAAII,kBAAkB,GAAtB,KAAA;EACA;AACJ;AACA;;EACIC,cAAc,CAAdA,QAAAA,CAAAA,eAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAwDC,UAAF,IAAkB;IACpE,IAAIC,0BAA0B,CAA9B,UAA8B,CAA9B,EAA+C;MAC3C,OAAOC,mBAAmB,CAA1B,UAA0B,CAA1B;IACH;;IACD,IAAIC,uBAAuB,CAA3B,UAA2B,CAA3B,EAA4C;MACxC,OAAOC,gBAAgB,CAAvB,UAAuB,CAAvB;IACH;EANLL,CAAAA;;EASA,MAAMG,mBAAmB,GAAKF,UAAF,IAAkB;IAC1C,MAAMK,KAAK,GAAGC,gBAAgB,CAAhBA,QAAAA,CAAd,KAAcA,EAAd;;IACA,IAAId,qBAAqB,IAAI,CAA7B,kBAAA,EAAmD;MAC/C,IAAIe,SAAS,GAAGP,UAAU,CAA1B,IAAgBA,EAAhB;MACA,IAAIQ,UAAU,GAAGR,UAAU,CAAVA,MAAAA,CAAjB,MAAiBA,CAAjB;MACA,IAAIS,OAAO,GAAGT,UAAU,CAAxB,EAAcA,EAAd;MACA,IAAIU,QAAQ,GAAGV,UAAU,CAAzB,MAAeA,EAAf;MACA,IAAIW,OAAO,GAAGX,UAAU,CAAxB,OAAcA,EAAd;MACA,IAAIY,gBAAgB,GAApB,EAAA;MACAA,gBAAgB,CAAhBA,OAAAA,GAAAA,OAAAA;MACAA,gBAAgB,CAAhBA,QAAAA,GAAAA,QAAAA;MACAA,gBAAgB,CAAhBA,OAAAA,GAT+C,OAS/CA,CAT+C,CAW/C;MACA;;MACA,IAAA,gBAAA;MACA,IAAA,gBAAA;;MACAC,gBAAgB,GAAG,MAAM;QACrB;QACAb,UAAU,CAAVA,MAAAA,CAAAA,YAAAA,CAAAA,EAAAA,CAAmCY,gBAAgB,CAAnDZ,OAAAA,EAA6DY,gBAAgB,CAA7EZ,QAAAA,EACIY,gBAAgB,CADpBZ,OAAAA;QAEA,OAAA,IAAA;MAJJa,CAAAA;;MAOAC,gBAAgB,GAAG,MAAM;QACrB;QACAC,MAAM,CAANA,KAAAA,CAAAA,0BAAAA,EAAAA,gBAAAA;QACA,OAAA,IAAA;MAHJD,CAAAA;;MAKA,MAAM;QAAA,aAAA;QAAA,QAAA;QAA2BE;MAA3B,IAAwCC,gBAAgB,CAAA,SAAA,EAAA,UAAA,EAAA,OAAA,EA3Bf,QA2Be,CAA9D,CA3B+C,CA4B/C;;MACA,OAAO,qBAAqB,CAArB,SAAA,CAAA,aAAA,EAAA,QAAA,EAAA,QAAA,EAAA,IAAA,CAA6EN,OAAF,IAAe;QAC7F;QACA,IAAIA,OAAO,IAAIA,OAAO,CAAPA,iBAAAA,KAAf,KAAA,EAAqD;UACjDb,kBAAkB,GAAlBA,IAAAA;QADJ,CAAA,MAEO;UACHN,qBAAqB,GAArBA,IAAAA;QACH;;QACD,OAAOqB,gBAAP,EAAA;MAPG,CAAA,EAAP,gBAAO,CAAP;IASH;;IACDR,KAAK,CAALA,OAAAA;IACAP,kBAAkB,GAAlBA,KAAAA;IACA,OAAOO,KAAK,CAAZ,OAAA;EA3CJ,CAAA;;EA8CA,MAAMD,gBAAgB,GAAKJ,UAAF,IAAkB;IACvC,MAAMK,KAAK,GAAGC,gBAAgB,CAAhBA,QAAAA,CAAd,KAAcA,EAAd;;IACA,IAAA,qBAAA,EAA4B;MACxB,IAAIC,SAAS,GAAGP,UAAU,CAA1B,IAAgBA,EAAhB;MACA,IAAIS,OAAO,GAAGT,UAAU,CAAxB,EAAcA,EAAd;MACA,IAAIU,QAAQ,GAAGV,UAAU,CAAzB,MAAeA,EAAf;MACA,IAAIW,OAAO,GAAGX,UAAU,CAAxB,OAAcA,EAAd;MACA,IAAIY,gBAAgB,GAApB,EAAA;MACAA,gBAAgB,CAAhBA,OAAAA,GAAAA,OAAAA;MACAA,gBAAgB,CAAhBA,SAAAA,GAAAA,SAAAA;MACAA,gBAAgB,CAAhBA,QAAAA,GAAAA,QAAAA;MACAA,gBAAgB,CAAhBA,OAAAA,GATwB,OASxBA,CATwB,CAWxB;;MACA,OAAO,qBAAqB,CAArB,SAAA,CAAA,gBAAA,EAAA,IAAA,CACH,MAAM;QACF;QACApB,qBAAqB,GAFnB,IAEFA,CAFE,CAGF;;QACAQ,UAAU,CAAVA,MAAAA,CAAAA,YAAAA,CAAAA,EAAAA,CAAmCY,gBAAgB,CAAnDZ,OAAAA,EAA6DY,gBAAgB,CAA7EZ,QAAAA,EACIY,gBAAgB,CADpBZ,OAAAA;QAEA,OAAA,IAAA;MAPD,CAAA,EASDkB,GAAF,IAAW;QAAE;QACTH,MAAM,CAANA,KAAAA,CAAAA,0BAAAA,EAAAA,gBAAAA;QACA,OAAA,IAAA;MAXR,CAAO,CAAP;IAaH;;IACDV,KAAK,CAALA,OAAAA;IACA,OAAOA,KAAK,CAAZ,OAAA;EA7BJ,CAAA;;EAgCA,MAAMY,gBAAgB,GAAG,CAAA,SAAA,EAAA,UAAA,EAAA,OAAA,EAAA,QAAA,KAAgD;IACrE,OAAO;MACHE,aAAa,EADV,EAAA;MAEHC,QAAQ,EAAE;QACNC,MAAM,EADA,UAAA;QAENC,KAAK,EAAE;UACHC,IAAI,EAAEhB,SAAS,CAACgB;QADb;MAFD,CAFP;MAQHP,QAAQ,EAAE;QACNK,MAAM,EADA,QAAA;QAENC,KAAK,EAAE;UACHC,IAAI,EAAEd,OAAO,CAACc;QADX;MAFD;IARP,CAAP;EADJ,CAAA;AA7FG,CAAA;AAgHP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,6BAA6B,GAAG,UAAA,GAAA,EAAgB;EACvD,IAAIC,YAAY,GAAG;IACfC,GAAG,EAAEA;EADU,CAAnB;;EAIAD,YAAY,CAAZA,SAAAA,GAAyB,YAAW;IAChC,IAAIE,QAAQ,GAAGrB,gBAAgB,CAAhBA,QAAAA,CAAf,KAAeA,EAAf;IACA,KAAA,GAAA,CAAA,SAAA,CAAA,QAAA;IACA,OAAOqB,QAAQ,CAAf,OAAA;EAHJF,CAAAA;;EAMAlC,OAAO,CAAPA,oBAAAA,CAAAA,YAAAA;AAXG,CAAA;AAcP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIqC,oBAAoB,GAAG,UAAA,OAAA,EAAoB;EAClD,IAAIC,OAAO,IAAI,CAACA,OAAO,CAAvB,SAAA,EAAoC;IAChCd,MAAM,CAANA,KAAAA,CAAAA,qBAAAA,EAAAA,OAAAA,EAAAA,kCAAAA;EADJ,CAAA,MAEO;IACHvB,qBAAqB,GAArBA,OAAAA;EACH;AALE,CAAA;AAQP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIsC,sBAAsB,GAAG,UAAA,OAAA,EAAoB;EACpD,IAAID,OAAO,KAAX,qBAAA,EAAwC;IACpCrC,qBAAqB,GAArBA,IAAAA;EACH;AAHE,CAAA;AAMP,OAAO,IAAIS,0BAA0B,GAAG,UAAA,UAAA,EAAuB;EAC3D,IAAI8B,CAAC,CAADA,WAAAA,CAAAA,UAAAA,KAA+BA,CAAC,CAADA,OAAAA,CAAnC,UAAmCA,CAAnC,EAA6D;IACzD,OAAA,KAAA;EAFuD,CAAA,CAI3D;;;EACA,IAAI/B,UAAU,CAAVA,IAAAA,GAAAA,GAAAA,KAAAA,GAAAA,IAAiCA,UAAU,CAAVA,IAAAA,GAAAA,IAAAA,KAArC,EAAA,EAAqE;IACjE,OAAA,KAAA;EANuD,CAAA,CAQ3D;;;EACA,IAAI+B,CAAC,CAADA,OAAAA,CAAW/B,UAAU,CAAVA,IAAAA,GAAX+B,IAAAA,EAAmC/B,UAAU,CAAVA,EAAAA,GAAnC+B,IAAAA,KAA6D,CAACA,CAAC,CAADA,OAAAA,CAAW/B,UAAU,CAAVA,MAAAA,CAAX+B,MAAW/B,CAAX+B,EAAwC/B,UAAU,CAAVA,MAAAA,CAA1G,IAA0GA,CAAxC+B,CAAlE,EAAwI;IACpI,OAAA,IAAA;EACH;;EACD,OAAA,KAAA;AAZG,CAAA;AAeP,OAAO,IAAI5B,uBAAuB,GAAG,UAAA,UAAA,EAAuB;EACxD,IAAI4B,CAAC,CAADA,WAAAA,CAAAA,UAAAA,KAA+BA,CAAC,CAADA,OAAAA,CAAnC,UAAmCA,CAAnC,EAA6D;IACzD,OAAA,KAAA;EAFoD,CAAA,CAIxD;;;EACA,IAAI/B,UAAU,CAAVA,IAAAA,GAAAA,GAAAA,KAAAA,GAAAA,IAAiCA,UAAU,CAAVA,IAAAA,GAAAA,IAAAA,KAArC,EAAA,EAAqE;IACjE,OAAA,KAAA;EACH;;EACD,IAAI,CAAC+B,CAAC,CAADA,OAAAA,CAAW/B,UAAU,CAAVA,IAAAA,GAAX+B,IAAAA,EAAmC/B,UAAU,CAAVA,EAAAA,GAAxC,IAAK+B,CAAL,EAAiE;IAC7D,OAAA,IAAA;EACH;;EACD,OAAA,KAAA;AAXG,CAAA;AAcPxC,OAAO,GAAG;EAAA,KAAA;EAAA,iBAAA;EAAA,6BAAA;EAAA,oBAAA;EAAA,sBAAA;EAAA,0BAAA;EAONY;AAPM,CAAVZ;AASA,eAAA,OAAA;AAEAM,iBAAiB","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines the {@link NgServices.leavePlaceService}\n *\n * @module js/leavePlace.service\n */\nimport logger from 'js/logger'; // => 'afx/src/kernel/src/js/logger'\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\n\n// Service\nimport AwStateService from 'js/awStateService';\nimport AwPromiseService from 'js/awPromiseService';\n\nvar exports = {};\n\n/**\n * The currently registered handler.\n *\n * @private\n * @member _registeredAppHandler\n * @memberOf NgServices.leavePlaceService\n */\nlet _registeredAppHandler = null;\n\nlet _eventSubscriptions = [];\n\nexport let reset = function() {\n    _registeredAppHandler = null;\n\n    // unsuscribe _eventSubscriptions if exists\n    _eventSubscriptions.forEach( ( s ) => {\n        eventBus.unsubscribe( s );\n    } );\n\n    _eventSubscriptions = [];\n};\n\n/**\n * Initialization function, sets up the transition lifecycle hooks.\n * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation\n * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will\n * trigger navigation to the original target.\n *\n * @private\n * @function initializeRootScope\n * @memberOf NgServices.leavePlaceService\n * @param {Object} $rootScope - $rootScope\n */\nexport let loadConfiguration = function() {\n    reset();\n    let _persistAppHandler = false;\n    /**\n     * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.\n     */\n    AwStateService.instance.transitionHooks.onBefore( {}, ( transition ) => {\n        if( isLocationChangeStartEvent( transition ) ) {\n            return locationChangeStart( transition );\n        }\n        if( isStateChangeStartEvent( transition ) ) {\n            return stateChangeStart( transition );\n        }\n    } );\n\n    const locationChangeStart = ( transition ) => {\n        const defer = AwPromiseService.instance.defer();\n        if( _registeredAppHandler && !_persistAppHandler ) {\n            let fromState = transition.from();\n            let fromParams = transition.params( 'from' );\n            let toState = transition.to();\n            let toParams = transition.params();\n            let options = transition.options();\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // Functions to call after the okToLeave promise\n            // okToLeaveSuccess must be set, okToLeaveFailure can be null\n            let okToLeaveSuccess;\n            let okToLeaveFailure;\n            okToLeaveSuccess = () => {\n                // navigate to the target state using the current transition instance\n                transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,\n                    targetNavDetails.options );\n                return true;\n            };\n\n            okToLeaveFailure = () => {\n                // Don't clear handler when the promise is rejected\n                logger.trace( 'Prevented navigation to ', targetNavDetails );\n                return true;\n            };\n            const { targetNavInfo, oldState, newState } = getOkToLeaveInfo( fromState, fromParams, toState, toParams );\n            // Run the okToLeave handler\n            return _registeredAppHandler.okToLeave( targetNavInfo, oldState, newState ).then( ( options ) => {\n                // Clear the handler\n                if( options && options.clearLeaveHandler === false ) {\n                    _persistAppHandler = true;\n                } else {\n                    _registeredAppHandler = null;\n                }\n                return okToLeaveSuccess();\n            }, okToLeaveFailure );\n        }\n        defer.resolve();\n        _persistAppHandler = false;\n        return defer.promise;\n    };\n\n    const stateChangeStart = ( transition ) => {\n        const defer = AwPromiseService.instance.defer();\n        if( _registeredAppHandler ) {\n            let fromState = transition.from();\n            let toState = transition.to();\n            let toParams = transition.params();\n            let options = transition.options();\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.fromState = fromState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // invoke the handler and setup up the promise continuation\n            return _registeredAppHandler.okToLeave( targetNavDetails ).then(\n                () => {\n                    // clear the handler reference that ran to avoid recursion\n                    _registeredAppHandler = null;\n                    // navigate to the target state using the current transition instance\n                    transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,\n                        targetNavDetails.options );\n                    return true;\n                },\n                ( err ) => { // eslint-disable-line no-unused-vars\n                    logger.trace( 'Prevented navigation to ', targetNavDetails );\n                    return true;\n                } );\n        }\n        defer.resolve();\n        return defer.promise;\n    };\n\n    const getOkToLeaveInfo = ( fromState, fromParams, toState, toParams ) => {\n        return {\n            targetNavInfo: {},\n            oldState: {\n                params: fromParams,\n                state: {\n                    name: fromState.name\n                }\n            },\n            newState: {\n                params: toParams,\n                state: {\n                    name: toState.name\n                }\n            }\n        };\n    };\n};\n\n/**\n * Method used by application to create leave handler object from an api object that can perform the okToLeave check\n *\n * @function createAndRegisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} api - The object for the leave handler. Must have a method \"okToLeave\" that is called with a\n *            promise when the user attempts to change location / state.\n */\nexport let createAndRegisterLeaveHandler = function( api ) {\n    var leaveHandler = {\n        api: api\n    };\n\n    leaveHandler.okToLeave = function() {\n        var deferred = AwPromiseService.instance.defer();\n        this.api.okToLeave( deferred );\n        return deferred.promise;\n    };\n\n    exports.registerLeaveHandler( leaveHandler );\n};\n\n/**\n * Method used for service consumer to register their handler function. Upon navigation, the \"okToLeave\" function\n * will be invoked. The function must return a promise, and when the handler logic completes the promise should be\n * resolved to allow navigation to continue or rejected to prevent the navigation.\n *\n * @function registerLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler Object function. Must have a \"okToLeave\" property which returns a\n *            promise.\n */\nexport let registerLeaveHandler = function( handler ) {\n    if( handler && !handler.okToLeave ) {\n        logger.error( 'Leave place handler', handler, 'does not have okToLeave property' );\n    } else {\n        _registeredAppHandler = handler;\n    }\n};\n\n/**\n * Method used for deregister a given leave handler\n *\n * @function deregisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler to deregister\n */\nexport let deregisterLeaveHandler = function( handler ) {\n    if( handler === _registeredAppHandler ) {\n        _registeredAppHandler = null;\n    }\n};\n\nexport let isLocationChangeStartEvent = function( transition ) {\n    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {\n        return false;\n    }\n    // page refresh case\n    if( transition.from().url === '^' && transition.from().name === '' ) {\n        return false;\n    }\n    //invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params\n    if( _.isEqual( transition.from().name, transition.to().name ) && !_.isEqual( transition.params( 'from' ), transition.params( 'to' ) ) ) {\n        return true;\n    }\n    return false;\n};\n\nexport let isStateChangeStartEvent = function( transition ) {\n    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {\n        return false;\n    }\n    // page refresh case\n    if( transition.from().url === '^' && transition.from().name === '' ) {\n        return false;\n    }\n    if( !_.isEqual( transition.from().name, transition.to().name ) ) {\n        return true;\n    }\n    return false;\n};\n\nexports = {\n    reset,\n    loadConfiguration,\n    createAndRegisterLeaveHandler,\n    registerLeaveHandler,\n    deregisterLeaveHandler,\n    isLocationChangeStartEvent,\n    isStateChangeStartEvent\n};\nexport default exports;\n\nloadConfiguration();\n"]},"metadata":{},"sourceType":"module"}