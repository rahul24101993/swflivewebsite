{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\nimport { evalExpression } from 'js/serviceUtils';\nimport { render, unmountComponentAtNode } from 'react-dom';\n/**\n * fastest way to copy a pure JSON object, use on your own risk\n * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript\n *\n * @param {Object} obj Current DOM Element\n * @returns {Object} new cloned object\n */\n\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function cloneDeepJsonObject(obj) {\n  return obj ? JSON.parse(JSON.stringify(obj)) : obj;\n}\n/**\n * parse data path to scope + subPatoh\n * @param {string} pathStr path string like 'ctx.a.b'\n * @returns {object} path structure like:\n * {\n *     scope: 'ctx'\n *     path: 'a.b'\n * }\n */\n\nexport function parseDataPath(pathStr) {\n  const match = pathStr.match(/[.[]/);\n\n  if (match) {\n    return {\n      scope: pathStr.substr(0, match.index),\n      path: pathStr.substr(match[0] === '[' ? match.index : match.index + 1)\n    };\n  }\n\n  return {\n    scope: pathStr\n  };\n}\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Object} scope parameters as name value pair\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n */\n\nexport function evalInScope(expr, scope, ignoreError, applyObject) {\n  const params = scope ? Object.keys(scope) : [];\n  const values = scope ? Object.values(scope) : [];\n  return evalExpression(expr, params, values, ignoreError, applyObject);\n}\n/**\n * get value from scope\n * @param {object} data scope for evaluation\n * @param {string} path string as path/expression\n * @returns {*} result\n */\n\nexport function getValue(data, path) {\n  return evalInScope(path, data, true);\n}\n/**\n * parse expr {{aa.bb}} to get aa.bb\n * @param {string} str input string\n * @returns {string} the expression inside {{}}\n */\n\nexport function parseExpr(str) {\n  let match = str.match(/^{{(.*)}}$/);\n  return match ? match[1] : undefined;\n}\n/**\n * Evaluate from data definition like:\n * {\n *    attr1: {{data.curVal}}\n * }\n * @param {JSON} input data definition\n * @param {JSON} scope scope for evaluation\n * @param {number} level used for recursive call internally\n * @returns {JSON} evaluated input object\n */\n\nexport function evalDataDefinition(input, scope) {\n  let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // Make the method to be immutable at top level\n  let obj = level > 0 ? input : cloneDeepJsonObject(input);\n\n  for (let key in obj) {\n    let value = obj[key];\n\n    if (typeof value === 'string') {\n      let template = parseExpr(value);\n\n      if (template) {\n        obj[key] = getValue(scope, template);\n      }\n    } else {\n      evalDataDefinition(obj[key], scope, level + 1);\n    }\n  }\n\n  return obj;\n}\n/**\n * parse i18n definition. Given:\n * {\n *     myData: {\n *         value1: \"a\",\n *         value2: \"{{i18n.myVal}}\"\n *     }\n * }\n * returns:\n * {\n *     \"myData.value2\": \"{{i18n.myVal}}\"\n * }\n * NODE: No usage for now, keep it here for reference\n * @param {JSON} dataDef data definition\n * @param {Array} stack JSON path stack\n * @returns {JSON} i18n defintions in path-expr pair\n */\n\nfunction getExprsFromDataDef(dataDef) {\n  let stack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const res = {};\n\n  for (let key in dataDef) {\n    stack.push(key);\n    let value = dataDef[key];\n\n    if (typeof value === 'string') {\n      let template = parseExpr(value);\n\n      if (/^i18n\\./.test(template)) {\n        res[stack.join('.')] = value;\n      }\n    } else {\n      Object.assign(res, getExprsFromDataDef(value, stack));\n    }\n\n    stack.pop();\n  }\n\n  return res;\n}\n/**\n * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.\n * @param {object} component React component.\n * @param {DOMElement} renderedElement The container element on which the component will be rendered.\n * @param {Function} callback callback function that will be executed by render method. This is optional.\n */\n\n\nexport function renderComponent(component, renderedElement, callback) {\n  if (component && renderedElement) {\n    render( /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: component\n    }, void 0, false), renderedElement, callback);\n  }\n}\n/**\n * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.\n * These elements will then be unmounted if they have a react element mounted.\n * @param {HTMLElement} baseElement The base element to use\n * @param {String} [selector] CSS selector used to search for nodes from the base element\n */\n\nexport function unmountComponents(baseElement, selector) {\n  // get the container elements that could potentially have a component\n  let components;\n\n  if (!selector) {\n    components = [baseElement];\n  } else {\n    components = baseElement.querySelectorAll(selector);\n  }\n\n  for (let i = 0; i < components.length; i++) {\n    unmountComponentAtNode(components[i]);\n  }\n}","map":{"version":3,"names":["evalExpression","render","unmountComponentAtNode","cloneDeepJsonObject","obj","JSON","parse","stringify","parseDataPath","pathStr","match","scope","substr","index","path","evalInScope","expr","ignoreError","applyObject","params","Object","keys","values","getValue","data","parseExpr","str","undefined","evalDataDefinition","input","level","key","value","template","getExprsFromDataDef","dataDef","stack","res","push","test","join","assign","pop","renderComponent","component","renderedElement","callback","unmountComponents","baseElement","selector","components","querySelectorAll","i","length"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declReactUtils.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\nimport { evalExpression } from 'js/serviceUtils';\nimport { render, unmountComponentAtNode } from 'react-dom';\n\n/**\n * fastest way to copy a pure JSON object, use on your own risk\n * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript\n *\n * @param {Object} obj Current DOM Element\n * @returns {Object} new cloned object\n */\nexport function cloneDeepJsonObject( obj ) {\n    return obj ? JSON.parse( JSON.stringify( obj ) ) : obj;\n}\n\n/**\n * parse data path to scope + subPatoh\n * @param {string} pathStr path string like 'ctx.a.b'\n * @returns {object} path structure like:\n * {\n *     scope: 'ctx'\n *     path: 'a.b'\n * }\n */\nexport function parseDataPath( pathStr ) {\n    const match = pathStr.match( /[.[]/ );\n    if( match ) {\n        return {\n            scope: pathStr.substr( 0, match.index ),\n            path: pathStr.substr( match[ 0 ] === '[' ? match.index : match.index + 1 )\n        };\n    }\n    return { scope: pathStr };\n}\n\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Object} scope parameters as name value pair\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n */\nexport function evalInScope( expr, scope, ignoreError, applyObject ) {\n    const params = scope ? Object.keys( scope ) : [];\n    const values = scope ? Object.values( scope ) : [];\n    return evalExpression( expr, params, values, ignoreError, applyObject );\n}\n\n/**\n * get value from scope\n * @param {object} data scope for evaluation\n * @param {string} path string as path/expression\n * @returns {*} result\n */\nexport function getValue( data, path ) {\n    return evalInScope( path, data, true );\n}\n\n/**\n * parse expr {{aa.bb}} to get aa.bb\n * @param {string} str input string\n * @returns {string} the expression inside {{}}\n */\nexport function parseExpr( str ) {\n    let match = str.match( /^{{(.*)}}$/ );\n    return match ? match[ 1 ] : undefined;\n}\n\n/**\n * Evaluate from data definition like:\n * {\n *    attr1: {{data.curVal}}\n * }\n * @param {JSON} input data definition\n * @param {JSON} scope scope for evaluation\n * @param {number} level used for recursive call internally\n * @returns {JSON} evaluated input object\n */\nexport function evalDataDefinition( input, scope, level = 0 ) {\n    // Make the method to be immutable at top level\n    let obj = level > 0 ? input : cloneDeepJsonObject( input );\n\n    for( let key in obj ) {\n        let value = obj[ key ];\n        if( typeof value === 'string' ) {\n            let template = parseExpr( value );\n            if( template ) {\n                obj[ key ] = getValue( scope, template );\n            }\n        } else {\n            evalDataDefinition( obj[ key ], scope, level + 1 );\n        }\n    }\n    return obj;\n}\n\n/**\n * parse i18n definition. Given:\n * {\n *     myData: {\n *         value1: \"a\",\n *         value2: \"{{i18n.myVal}}\"\n *     }\n * }\n * returns:\n * {\n *     \"myData.value2\": \"{{i18n.myVal}}\"\n * }\n * NODE: No usage for now, keep it here for reference\n * @param {JSON} dataDef data definition\n * @param {Array} stack JSON path stack\n * @returns {JSON} i18n defintions in path-expr pair\n */\nfunction getExprsFromDataDef( dataDef, stack = [] ) {\n    const res = {};\n    for( let key in dataDef ) {\n        stack.push( key );\n        let value = dataDef[ key ];\n        if( typeof value === 'string' ) {\n            let template = parseExpr( value );\n            if( /^i18n\\./.test( template ) ) {\n                res[ stack.join( '.' ) ] = value;\n            }\n        } else {\n            Object.assign( res, getExprsFromDataDef( value, stack ) );\n        }\n        stack.pop();\n    }\n    return res;\n}\n\n/**\n * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.\n * @param {object} component React component.\n * @param {DOMElement} renderedElement The container element on which the component will be rendered.\n * @param {Function} callback callback function that will be executed by render method. This is optional.\n */\nexport function renderComponent( component, renderedElement, callback ) {\n    if( component && renderedElement ) {\n        render( <>{ component }</>, renderedElement, callback );\n    }\n}\n\n/**\n * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.\n * These elements will then be unmounted if they have a react element mounted.\n * @param {HTMLElement} baseElement The base element to use\n * @param {String} [selector] CSS selector used to search for nodes from the base element\n */\nexport function unmountComponents( baseElement, selector ) {\n    // get the container elements that could potentially have a component\n    let components;\n    if( !selector ) {\n        components = [ baseElement ];\n    } else {\n        components = baseElement.querySelectorAll( selector );\n    }\n\n    for( let i = 0; i < components.length; i++ ) {\n        unmountComponentAtNode( components[ i ] );\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}