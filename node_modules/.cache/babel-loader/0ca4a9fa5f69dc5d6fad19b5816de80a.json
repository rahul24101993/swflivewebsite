{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * @module js/editHandlerService\n */import AwPromiseService from'js/awPromiseService';import appCtxSvc from'js/appCtxService';import eventBus from'js/eventBus';var exports={};// Map the context to the edit handler info\nvar m_context2EditHandlerInfo={};/** The last edit handler context activated */var m_activeEditHandlerContext={};/**\n * Set the current edit handler\n *\n * @param {Object} handler - current edit handler\n * @param {Object} editHandlerContext - context\n */export let setEditHandler=function(handler,editHandlerContext){if(!handler||!editHandlerContext){return;}var info=m_context2EditHandlerInfo[editHandlerContext];appCtxSvc.ctx[editHandlerContext]=handler;if(!info||handler!==info.editHandler){if(!info){info={};}info.editHandler=handler;info.enable=true;m_context2EditHandlerInfo[editHandlerContext]=info;if(handler.hasOwnProperty('hasWrapper')){handler.addListener(this);}eventBus.publish('aw.setEditHandler',{});}};/**\n * Get the default edit handler\n *\n * @param {String} editHandlerContext - edit handler context\n * @return the default edit handler\n */export let getEditHandler=function(editHandlerContext){var info=m_context2EditHandlerInfo[editHandlerContext];if(!info){return null;}return info.editHandler;};/**\n * Set the edit handler enabled/disabled\n *\n * @param enabled is enabled?\n * @param editHandlerContext is enabled?\n * @returns true if enabled changed, false otherwise\n */export let setEditHandlerEnabled=function(enabled,editHandlerContext){var info=m_context2EditHandlerInfo[editHandlerContext];if(info&&info.enable!==enabled){info.enable=enabled;m_context2EditHandlerInfo[editHandlerContext]=info;return true;}return false;};/**\n * Get the current state of the edit handler, enabled/disabled\n *\n * @return True if edit is enabled, False otherwise\n */export let isEditEnabled=function(editHandlerContext){var info=m_context2EditHandlerInfo[editHandlerContext];if(!info){return false;}return info.enable;};/**\n * Remove an edit handler\n *\n * @param editHandlerContext context associated with the edit handler\n */export let removeEditHandler=function(editHandlerContext){appCtxSvc.unRegisterCtx(editHandlerContext);var info=m_context2EditHandlerInfo[editHandlerContext];if(info&&info.editHandler&&info.editHandler.destroy){info.editHandler.destroy();}delete m_context2EditHandlerInfo[editHandlerContext];};/**\n * Get all of the current edit handlers\n *\n * @return All of the current edit handlers\n */export let getAllEditHandlers=function(){var editHandlers=[];for(var i in m_context2EditHandlerInfo){var info=m_context2EditHandlerInfo[i];if(info&&info.editHandler!==null){editHandlers.push(info.editHandler);}}return editHandlers;};export let setActiveEditHandlerContext=function(context){m_activeEditHandlerContext=context;};export let getActiveEditHandler=function(){if(m_context2EditHandlerInfo[m_activeEditHandlerContext]&&m_context2EditHandlerInfo[m_activeEditHandlerContext].editHandler){return m_context2EditHandlerInfo[m_activeEditHandlerContext].editHandler;}return null;};export let getActiveEditHandlerContext=function(){return m_activeEditHandlerContext;};/**\n * Check for dirty edits\n *\n * @return {Object} with a boolean flag isDirty, TRUE if there is an activeEditHandler and dirty edits for it\n */export let isDirty=function(){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler&&activeEditHandler.isNative){return activeEditHandler.isDirty().then(function(isDirty){return{isDirty:isDirty};});}else if(activeEditHandler){return AwPromiseService.instance.when({isDirty:activeEditHandler.isDirty()});}return AwPromiseService.instance.when({isDirty:false});};/**\n * Check for edit in progress\n *\n * @return {Object} with a boolean flag editInProgress, TRUE if there is an activeEditHandler and edit in progress\n */export let editInProgress=function(){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler){return{editInProgress:activeEditHandler.editInProgress()};}return{editInProgress:false};};/**\n * Start edits\n *\n * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n * @return {Promise} A promise object\n */export let startEdit=function(editOptions){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler){return activeEditHandler.startEdit(editOptions);}return AwPromiseService.instance.reject('No active EditHandler');};/**\n * Save edits\n *\n * @param {String} context - parameter for getting commandHandler (Optional)\n * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n * @return {Promise} A promise object\n */export let saveEdits=function(context,isPartialSaveDisabled,isAutoSave){var activeEditHandler;if(context){activeEditHandler=exports.getEditHandler(context);}else{activeEditHandler=exports.getActiveEditHandler();}if(activeEditHandler){return activeEditHandler.saveEdits(isPartialSaveDisabled,isAutoSave);}return AwPromiseService.instance.reject('No active EditHandler');};/**\n * Perform the actions post Save Edit\n *\n * @param {Boolean} saveSuccess - Whether the save edit was successful or not\n */export let saveEditsPostActions=function(saveSuccess){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler){activeEditHandler.saveEditsPostActions(saveSuccess);}};/**\n * Cancel edits\n */export let cancelEdits=function(){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler){activeEditHandler.cancelEdits();}};/**\n * Leave confirmation. Returns a promise that is resolved when it is ok to leave.\n */export let leaveConfirmation=function(){var activeEditHandler=exports.getActiveEditHandler();if(activeEditHandler){return AwPromiseService.instance(function(resolve){activeEditHandler.leaveConfirmation(resolve);});}return AwPromiseService.instance.resolve();};/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */export let updateStates=function(editHandler,context){if(m_context2EditHandlerInfo&&m_context2EditHandlerInfo[context]){var info=m_context2EditHandlerInfo[context];if(info&&info.editHandler){info.editHandler.canEdit=info.editHandler.canStartEdit();editHandler.canEdit=info.editHandler.canStartEdit();}}};/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */export let updateStates2=function(viewModel){if(m_context2EditHandlerInfo){for(var i in m_context2EditHandlerInfo){var info=m_context2EditHandlerInfo[i];if(info&&info.editHandler){const dataSource=info.editHandler.getDataSource();const dataProvider=dataSource.getDataProvider();const declViewModel=dataSource.getDeclViewModel();let isEditHandlerOfViewModel=false;if(dataProvider){for(const dataProviderName in viewModel.dataProviders){if(dataProvider===viewModel.dataProviders[dataProviderName]){isEditHandlerOfViewModel=true;break;}}}else if(declViewModel===viewModel){isEditHandlerOfViewModel=true;}if(isEditHandlerOfViewModel){info.editHandler.canEdit=info.editHandler.canStartEdit();}}}}};exports={setEditHandler,getEditHandler,setEditHandlerEnabled,isEditEnabled,removeEditHandler,getAllEditHandlers,setActiveEditHandlerContext,getActiveEditHandler,getActiveEditHandlerContext,isDirty,editInProgress,startEdit,saveEdits,saveEditsPostActions,cancelEdits,leaveConfirmation,updateStates,updateStates2};export default exports;","map":null,"metadata":{},"sourceType":"module"}