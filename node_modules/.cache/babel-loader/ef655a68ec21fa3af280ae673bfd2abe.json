{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Command service to manage commands.\n *\n * @module js/command.service\n *\n * @namespace commandService\n */import appCtxService from'js/appCtxService';import preferenceService from'soa/preferenceService';import{getCommand as getCommandInternal,getCommands as getCommandsInternal}from'./commandConfigurationService';import conditionService from'js/conditionService';import{DerivedStateResult}from'js/derivedContextService';import{parseCondition,parseStringCondition}from'js/conditionParser.service';import{concat,flatten,get,uniq}from'lodash';import debugService from'js/debugService';import AwParseService from'js/awParseService';import{getStringBetweenDoubleMustaches}from'js/parsingUtils';/**\n  * Get a function to check if a command should be visible in the given workspace\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @returns {Function} Function to determine if command should be visible\n  */const getWorkspaceCommandValidator=function(){let workspace=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(workspace.workspaceType==='Exclusive'){const{includedCommands,excludedCommands}=workspace;if(includedCommands&&excludedCommands){return command=>includedCommands.includes(command.id)&&!excludedCommands.includes(command.id);}else if(includedCommands){return command=>includedCommands.includes(command.id);}else if(excludedCommands){return command=>!excludedCommands.includes(command.id);}}//if not exclusive workspace don't filter commands\nreturn()=>true;};/**\n  * Filter any commands that should be hidden based on the given workspace and preference\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @param {[String]} hiddenCommandPreference Hidden command preference value\n  * @returns {Function} Function to determine if the command should be visible\n  */const filterHiddenCommands=function(workspace,hiddenCommandPreference){const isValidWorkspaceCommand=getWorkspaceCommandValidator(workspace);return command=>!hiddenCommandPreference.includes(command.id)&&isValidWorkspaceCommand(command);};/**\n  * Get the command overlays for the commands matching the given inputs. Calls the getCommands method on each\n  * contributed provider and then return the aggregate result.\n  *\n  * @function getCommands\n  * @memberOf commandService\n  * @param {String} commandAreaNameTokens - Comma separated list of command area name tokens, eg. Navigation, Onestep, etc\n  * @param {Object} context - Additional context to use in command evaluation\n  * @param {Object} commandStateUpdater - A hook to update the command state\n  *\n  * @return {Promise} A promise containing the array of command overlays\n  */export const getCommands=async function(commandAreaNameTokens){const overlays=await getCommandsInternal(commandAreaNameTokens);const hiddenCommandPreference=await preferenceService.getStringValues('AWC_HiddenCommands');const workspace=appCtxService.getCtx('workspace');return overlays.filter(filterHiddenCommands(workspace,hiddenCommandPreference||[]));};/**\n  * Get a CommandOverlay for the given command.\n  *\n  * @function getCommand\n  * @memberOf commandService\n  * @param {String} commandId - Command id\n  * @return {CommandOverlay} The unresolved overlay for the command\n  */export const getCommand=getCommandInternal;/**\n  * Get the command for the command with the given commandId and executes it if it is visible\n  *\n  * @function executeCommandIfVisibleAndEnabled\n  * @memberOf commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {Object} commandContext - Additional context to use in command evaluation\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */export const executeCommandIfVisibleAndEnabled=async function(commandId,commandContext,runActionWithViewModel){if(!runActionWithViewModel){return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');}const command=await getCommand(commandId);const scope={ctx:appCtxService.ctx,commandContext:{...commandContext}};const commandRender=getCommandRender(scope,command);return commandRender.visible?commandRender.execute(runActionWithViewModel):Promise.resolve();};/**\n  * Execute a command with the given arguments\n  *\n  * @function executeCommand\n  * @memberof commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {String|String[]} commandArgs - (Optional) (Deprecated) Command arguments. Should only be used for GWT commands.\n  * @param {Object} context - (Optional) Context to execute the command in. Required for zero compile commands.\n  * @param {Object} commandContext - (Optional) (Deprecated) Additional data to set into context. Should not be used.\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */export const executeCommand=async function(commandId,commandArgs,context){let commandContext=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let runActionWithViewModel=arguments.length>4?arguments[4]:undefined;if(!runActionWithViewModel){return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');}const command=await getCommand(commandId);const scope={ctx:appCtxService.ctx,...context,commandContext:{commandArgs,...commandContext}};const commandRender=getCommandRender(scope,command);return commandRender.execute(runActionWithViewModel);};/**************************** CommandRender creation logic ****************************/ /**\n  * All of the data that AwCommand needs to render a command\n  *\n  * All properties should be the \"end result\" that AwCommand can directly use. For example\n  * \"title\" can be either \"title\" or \"selectedTitle\" based on selection state and\n  * \"hasPopup\" can be true or false for group commands depending on child command states\n  *\n  * @param {Object} info Command display information\n  * @param {CommandHandler} handler The current handler for the command\n  * @param {Object} state The current state of the command\n  * @param {Object} scope The evaluation context this result was computed in\n  */const CommandRender=function(_ref,handler,_ref2,scope){let{id,title='',description='',icon='',extendedTooltip,decorator,cellDisplay=null}=_ref;let{hasPopup,visible,enabled,selected}=_ref2;/**\n      * ID of the command\n      */this.id=id;/**\n      * The handler that is currently active for this command\n      */this.handler=handler;/**\n      * (Optional) The evaluated title of the command\n      */this.title=typeof title==='string'?title:null;/**\n      * (Optional) The evaluated description of the command\n      */this.description=description;/**\n      * (Optional) ID of the icon currently used\n      */this.icon=icon;/**\n      * (Optional) Evaluated JSX to include in the command display\n      */this.decorator=decorator;/**\n      * (Optional) Evaluated extended tooltip configuration\n      */this.extendedTooltip=extendedTooltip;/**\n      * (Optional) Cell display information configured on placement\n      */this.cellDisplay=cellDisplay;/**\n      * Execute this command in its current state\n      *\n      * @param {Function} runActionWithViewModel View model service api\n      * @param {Object} commandContext Context to execute the command in\n      * @returns {Promise} Promise resolved when execution is complete\n      */this.execute=function(runActionWithViewModel,commandContext){debugService.debug('commands',this.id);// command menus are \"executed\" by AwCommand\n// enhanced per Cory:\n//     - cover the case where a ribbon command has been configured to execute a non popup action\nif(this.hasPopup&&handler.action.actionType==='popup'){return handler.action;}return handler.execute.apply(handler,[runActionWithViewModel,scope,commandContext]);};/**\n      * Whether this command will open a popup when clicked\n      */this.hasPopup=hasPopup;/**\n      * Whether this command is currently visible\n      */this.visible=visible;/**\n      * Whether this command is currently enabled\n      */this.enabled=enabled;/**\n      * Whether this command is currently selected\n      */this.selected=selected;};/**\n  * Sidenav areas that will cause commands to be automatically selected\n  */const supportedPanelAreas=['activeToolsAndInfoCommand','activeNavigationCommand','sidenavCommandId'];/**\n   * Get the ID of the panel that is currently opened\n   *\n   * @param {Object} scope Evaluation context\n   * @returns {String|null} ID of the opened panel\n   */const getActivePanelId=scope=>{for(const area of supportedPanelAreas){if(scope.ctx[area]&&scope.ctx[area].commandId){return scope.ctx[area].commandId;}}return null;};/**\n  * Determine if a command should be currently selected\n  *\n  * @param {Condition} selectWhen Select when condition for the command\n  * @param {String} id Command ID\n  * @param {Object} scope Command evaluation context\n  * @returns {Boolean} Latest state for this command\n  */const isCommandSelected=function(selectWhen,id,scope){const activePanelId=getActivePanelId(scope);if(selectWhen){return Boolean(conditionService.evaluateCondition({},selectWhen.expression,scope));}else if(activePanelId===id){return true;}return false;};/**\n  * Get a resolver to switch between selected/not selected properties\n  *\n  * @param {String} propName primary property name\n  * @param {String} selectedPropName selected property name\n  * @returns {Function} Resolver method\n  */const getSelectedPropResolver=(propName,selectedPropName)=>{const getResolvedParameters=(command,scope,selected)=>{const getParameter=x=>{return AwParseService.instance(getStringBetweenDoubleMustaches(x))(scope);};if(command[selectedPropName]&&selected){return command[selectedPropName].parameters.map(getParameter);}if(command[propName]&&command[propName].parameters&&propName!=='decorator'){return command[propName].parameters.map(getParameter);}if(command[propName]&&command[propName].text&&command[propName].text.parameters&&propName==='decorator'){return command[propName].text.parameters.map(getParameter);}return[];};return(command,scope,selected)=>{const parameters=getResolvedParameters(command,scope,selected);if(command[selectedPropName]&&selected&&command[selectedPropName].value){return command[selectedPropName].value.format(...parameters);}if(command[propName]&&command[propName].value&&propName!=='decorator'){return command[propName].value.format(...parameters);}if(command[propName]&&command[propName].text&&command[propName].text.value&&propName==='decorator'){return command[propName].text.value.format(...parameters);}return'';};};/**\n  * Get the resolved title for a command\n  */const getTitle=getSelectedPropResolver('title','selectedTitle');/**\n  * Get the resolved title for a command\n  */const getDescription=getSelectedPropResolver('description','selectedDescription');/**\n  * Get the resolved decorator for a command\n  */const getDecorator=getSelectedPropResolver('decorator',null);/**\n  * Get the latest state for a standard command\n  *\n  * Supported command types: BASE, TOGGLE, RIBBON\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */const getBaseCommandRender=(scope,command)=>{for(const handler of command.handlers){const isActive=Boolean(conditionService.evaluateCondition({},handler.activeWhen.expression,scope));if(isActive){command.trace('Active handler is',handler);debugService.debugUpdateHandlerOnCommand(command.id,handler);const enabled=handler.enableWhen?Boolean(conditionService.evaluateCondition({},handler.enableWhen.expression,scope)):true;const selected=isCommandSelected(handler.selectWhen,command.id,scope);//TODO: Check if visibleWhen is required in schema and validate default if not required\nconst visible=handler.visibleWhen?Boolean(conditionService.evaluateCondition({},handler.visibleWhen.expression,scope)):true;const id=command.id;//TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\nconst title=getTitle(command,scope,selected);const description=getDescription(command,scope,selected);const icon=command.selectedIcon&&selected?command.selectedIcon:command.icon;const hasPopup=command.type==='RIBBON';const cellDisplay=command.cellDisplay;const currentTooltip=selected&&command.selectedExtendedTooltip?command.selectedExtendedTooltip:command.extendedTooltip;const decorator={};decorator.text=getDecorator(command,scope,selected);decorator.className=command.decorator&&command.decorator.class?command.decorator.class:null;decorator.visibleWhen=command.decorator&&command.decorator.visibleWhen?Boolean(conditionService.evaluateCondition({},command.decorator.visibleWhen.expression,scope)):true;return new CommandRender({id,description,title,icon,extendedTooltip:currentTooltip,decorator,cellDisplay},handler,{enabled,selected,visible,hasPopup},scope);}}command.trace('Command has no active handler');return new CommandRender(command,null,{enabled:false,selected:false,visible:false},scope);};/**\n  * Get the latest state for a group command\n  *\n  * Supported types: GROUP\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */const getGroupCommandRender=(scope,command)=>{const{showGroupSelected=true}=command;const childCommandStates=command.children.map(child=>getCommandRender(scope,child));command.trace('Child command states',childCommandStates);const visibleChildCommands=childCommandStates.filter(x=>x.visible);const groupCommandState=visibleChildCommands.reduce((_ref3,childCommandState)=>{let{enabled,selected}=_ref3;return{enabled:enabled||childCommandState.enabled,selected:showGroupSelected&&(selected||childCommandState.enabled&&childCommandState.selected)};},{enabled:false,selected:false});const id=command.id;//TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\nconst title=getTitle(command,scope,groupCommandState.selected);const description=getDescription(command,scope,groupCommandState.selected);const icon=command.selectedIcon&&groupCommandState.selected?command.selectedIcon:command.icon;const visible=visibleChildCommands.length>0;const hasPopup=visibleChildCommands.length>1;return new CommandRender({id,title,description,icon,extendedTooltip:command.extendedTooltip,decorator:null},visibleChildCommands.length===1?visibleChildCommands[0].handler:command.handlers[0],{...groupCommandState,hasPopup,visible},scope);};/**\n  * Get the latest state for a shuttle command\n  *\n  * Supported types: SHUTTLE\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */const getShuttleCommandRender=(scope,command)=>{// pass into command object\n// pull show group selected property out of command (shuttle should always be false)\nconst showGroupSelected=false;// pull all child command states (ctx)\n// throw logic onto child commands pull selected properties\n// .map call function on specific items that creates new array with result of function\n// passes child state into getCommandRender\nconst childCommandStates=command.children.map(child=>getCommandRender(scope,child));//  find all of the commands that are visible\n// .filter creates new array (visibleChildCommands) which has commands w/ property visible = true\nconst visibleChildCommands=childCommandStates.filter(x=>x.visible);// adding selected child commands? find commands that are selected\n// list of current child commands selected & visible\n// get first selected child out of filtered list (child command 0)\nconst selectedChildCommands=visibleChildCommands.filter(x=>x.selected);// groupcommandstate = reduced visible commands, pass to child command state\nconst groupCommandState=visibleChildCommands.reduce((_ref4,childCommandState)=>{let{enabled}=_ref4;return{enabled:enabled||childCommandState.enabled,selected:showGroupSelected};},{enabled:false,selected:false});const id=command.id;const firstSelectedChild=selectedChildCommands[0];const getShuttleTitle=()=>{if(firstSelectedChild){return firstSelectedChild.title;}return getTitle(command,scope,groupCommandState.selected);};const getShuttleDescription=()=>{//TODO: Should shuttle commands also inherit description?\n//View mode command with description of a specific view model seems wrong\nif(firstSelectedChild){return firstSelectedChild.description;}return getDescription(command,scope,groupCommandState.selected);};const getShuttleIcon=()=>{if(firstSelectedChild){return firstSelectedChild.icon;}return command.selectedIcon&&groupCommandState.selected?command.selectedIcon:command.icon;};const getShuttleExtendedTooltip=()=>{// If tooltip configured on parent command use that\nif(command.extendedTooltip){return command.extendedTooltip;}// If no tooltip and active child has tooltip use that\nif(firstSelectedChild&&firstSelectedChild.extendedTooltip){return firstSelectedChild.extendedTooltip;}// If no tooltip and active child does not have tooltip use title/description of child\nreturn null;};const title=getShuttleTitle();const description=getShuttleDescription();const icon=getShuttleIcon();const visible=visibleChildCommands.length>0;const hasPopup=visibleChildCommands.length>1;return new CommandRender({id,title,description,icon,extendedTooltip:getShuttleExtendedTooltip(),decorator:null},visibleChildCommands.length===1?visibleChildCommands[0].handler:command.handlers[0],{...groupCommandState,hasPopup,visible},scope);};/**\n  * Map of command type to the render function for it\n  */const commandTypeToRenderer={BASE:getBaseCommandRender,RIBBON:getBaseCommandRender,GROUP:getGroupCommandRender,SHUTTLE:getShuttleCommandRender};/**\n  * Get the latest render data based on the new command state\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {Object} command The unprocessed command data\n  * @returns {CommandRender} Latest render data for the command\n  */export const getCommandRender=(scope,command)=>{const renderFunction=commandTypeToRenderer[command.type]||commandTypeToRenderer.BASE;command.trace('Getting current command state',scope,command,renderFunction);const renderResult=renderFunction(scope,command);command.trace('Command state',renderResult);debugService.debugCommandRender(command,renderResult);return renderResult;};/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */const getBaseCommandParameters=command=>{const staticCommandParameters=['activeToolsAndInfoCommand.commandId','activeNavigationCommand.commandId','sidenavCommandId.commandId'];const{ctxParameters:titleParameters,additionalParameters:titleContextParameters}=getCommandI18nParameters(command);return(command.handlers||[]).reduce((acc,handler)=>{const conditionDeps=[parseCondition(handler.activeWhen),parseCondition(handler.visibleWhen),parseCondition(handler.enableWhen),parseCondition(handler.selectWhen)];return{ctxParameters:uniq(concat(flatten(conditionDeps.map(x=>x.ctxParameters)),acc.ctxParameters)),additionalParameters:concat(acc.additionalParameters,flatten(conditionDeps.map(x=>x.additionalParameters)))};},{ctxParameters:[...titleParameters,...staticCommandParameters],additionalParameters:[command,...titleContextParameters]});};/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */const getGroupCommandParameters=command=>{const{ctxParameters:titleParameters,additionalParameters:titleContextParameters}=getCommandI18nParameters(command);return command.children.reduce((acc,child)=>{const childParameters=getCommandParameters(child);return{ctxParameters:uniq(concat(childParameters.ctxParameters,acc.ctxParameters)),additionalParameters:concat(acc.additionalParameters,childParameters.additionalParameters)};},{ctxParameters:[...titleParameters],additionalParameters:[command,...titleContextParameters]});};const commandTypeToParameterMapper={BASE:getBaseCommandParameters,RIBBON:getBaseCommandParameters,GROUP:getGroupCommandParameters,SHUTTLE:getGroupCommandParameters};/**\n  * Get ctx/other parameters for a property of a command\n  *\n  * @param {CommandOverlay} command command being parsed\n  * @param {String} propName property name\n  * @returns {Object} dependencies\n  */const getI18nParameters=(command,propName)=>{if(command[propName]){return command[propName].parameters.reduce((acc,x)=>{const{ctxParameters,additionalParameters}=parseStringCondition(x);return{ctxParameters:[...acc.ctxParameters,...ctxParameters],additionalParameters:[...acc.additionalParameters,...additionalParameters]};},{ctxParameters:[],additionalParameters:[]});}return{ctxParameters:[],additionalParameters:[]};};/**\n  * Get parameters for any localized properties that support \"parameter format\"\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx parameters\n  */const getCommandI18nParameters=command=>{return['title','selectedTitle','description','selectedDescription'].reduce((acc,propName)=>{const{ctxParameters,additionalParameters}=getI18nParameters(command,propName);return{ctxParameters:[...acc.ctxParameters,...ctxParameters],additionalParameters:[...acc.additionalParameters,...additionalParameters]};},{ctxParameters:[],additionalParameters:[]});};/**\n  * Get anything in ctx that this command depends on\n  *\n  * TODO: Additional parameters will need to be \"resolved\" before returning\n  *\n  * @param {CommandOverlay} command Command to get the information for\n  * @returns {List<Path>} List of lodash get paths (array or string)\n  */export const getCommandParameters=command=>(commandTypeToParameterMapper[command.type]||commandTypeToParameterMapper.BASE)(command);/**\n  * Get all of the Derived States for the given commands\n  *\n  * @param {Object} vmDef View model definition\n  * @param {Object} props Component properties\n  * @returns {List<DerivedStateResult>} Derived state configurations for commands\n  */export const getCommandStates=(vmDef,_ref5)=>{let{commandList=[],commandContext={},visibleServerCommands={}}=_ref5;const scope={commandContext,visibleServerCommands};//The list of \"additionalParameters\" is just strings initially, need to pull actual values from props\nconst getFromProps=path=>get(scope,path);return commandList.map(cmd=>{const{ctxParameters,additionalParameters:additionalParametersRefs}=cmd.parameters||getCommandParameters({...cmd});cmd.parameters={ctxParameters,additionalParameters:additionalParametersRefs};const additionalParameters=[additionalParametersRefs[0],...additionalParametersRefs.slice(1).map(getFromProps)];return new DerivedStateResult({ctxParameters,additionalParameters,compute:_ref6=>{let{ctx}=_ref6;return getCommandRender({commandContext,ctx:{...ctx,//Fakes visibleServerCommands being in CTX even though it actually local to this command bar\nvisibleServerCommands}},additionalParameters[0]);}});});};export default{getCommands,getCommand,executeCommand,executeCommandIfVisibleAndEnabled};","map":null,"metadata":{},"sourceType":"module"}