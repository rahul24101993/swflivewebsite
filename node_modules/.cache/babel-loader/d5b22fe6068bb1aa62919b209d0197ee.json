{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to manage AngularJS Scope\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/declarativeDataCtxService\n */\nimport dynamicPropertySvc from 'js/dynamicPropertyService';\nimport awConstantsSvc from 'js/awConstantsService';\nimport AwInterpolateService from 'js/awInterpolateService';\nimport adapterService from 'js/adapterService';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport logger from 'js/logger';\n/**\n * Cached reference to dependent services\n */\n\n/**\n * Cached reference to adapter service\n */\n\n/**\n * {Boolean} TRUE if use of the $interpolate API should be logged.\n */\n\nvar _debug_logInterpolatingActivity;\n/**\n * {Boolean} TRUE if we are NOT able to find a property on the $scope when referenced in a data binding expression.\n */\n\n\nvar _debug_logMissingProperties;\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\n\n\nvar exports = {};\n\nvar parametersList = function (funcToCall, $scope) {\n  var funcParams = funcToCall.parameters;\n  var params = [];\n  var i;\n\n  if (funcParams) {\n    for (i = 0; i < funcParams.length; i++) {\n      var param = funcParams[i];\n      var results2 = param.match(parsingUtils.REGEX_DATABINDING);\n\n      if (results2 && results2.length === 4) {\n        var newParam = results2[2];\n        var realizedFuncParam = parsingUtils.parentGet($scope, newParam);\n        params.push(realizedFuncParam);\n      } else {\n        params.push(param);\n      }\n    }\n  }\n\n  return params;\n};\n/**\n * Apply the scope object of the input.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {Object} inputDataToUpdate - The 'inputData' from an 'action' who's properties are to be updated with\n *            current values from the 'declViewModel' and/or dependent function calls.\n *\n * @param {Object} functionsList - List of functions read from JSON\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n */\n\n\nexport let applyScope = function (declViewModel, inputDataToUpdate, functionsList, dataCtxNode, depModuleObj) {\n  if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    return;\n  }\n\n  assert(inputDataToUpdate, 'Missing \"inputDataToUpdate\" parameter'); // eslint-disable-next-line consistent-return\n\n  _.forEach(inputDataToUpdate, function (propValue, propName) {\n    // eslint-disable-line complexity\n    if (!propValue) {\n      return true;\n    }\n\n    var propValueType = typeof propValue;\n    /**\n     * Check if propValue is undefined or a simple string\n     */\n\n    if (propValueType === 'string') {\n      /**\n       * Check if it is a replacement case\n       * <P>\n       * Note: The regex will only extract 4 segments w/the following for [1] & [3]<BR>\n       * results[1] === '{{' && results[3] === '}}'\n       */\n      var results = propValue.match(parsingUtils.REGEX_DATABINDING);\n\n      if (results && results.length === 4) {\n        var newVal = results[2];\n\n        if (!/^(function:|dataParseDefinitions:|Constants.|ports:|dragAndDropParams)/.test(newVal)) {\n          // dataCtxNode.ctx is always old,\n          // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/504\n          // var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n          var val2 = parsingUtils.parentGet({ ...dataCtxNode,\n            ctx: { ...dataCtxNode.ctx,\n              ...appCtxService.ctx\n            }\n          }, newVal);\n          inputDataToUpdate[propName] = val2;\n\n          if (_debug_logMissingProperties && val2 === undefined) {\n            logger.warn('Unable to find property on the current $scope: ' + newVal);\n          }\n        } else if (_.startsWith(newVal, 'dragAndDropParams')) {\n          var val2 = parsingUtils.parentGet(dataCtxNode, newVal);\n          inputDataToUpdate[propName] = val2;\n        } else if (_.startsWith(newVal, 'function:')) {\n          var functionName = newVal.replace('function:', '');\n          var funcToCall = functionsList[functionName];\n\n          if (!funcToCall) {\n            assert(funcToCall, 'Missing function: ' + functionName);\n          }\n\n          var params = parametersList(funcToCall, dataCtxNode);\n\n          if (depModuleObj) {\n            if (depModuleObj[funcToCall.functionName]) {\n              inputDataToUpdate[propName] = depModuleObj[funcToCall.functionName].apply(depModuleObj, params);\n            } else {\n              _.forEach(depModuleObj, function (value, key) {\n                if (funcToCall.deps.includes(key)) {\n                  inputDataToUpdate[propName] = depModuleObj[key][funcToCall.functionName].apply(depModuleObj[key], params);\n                }\n              });\n            }\n          } else {\n            inputDataToUpdate[propName] = undefined;\n          }\n        } else if (_.startsWith(newVal, 'dataParseDefinitions:')) {\n          if (declViewModel._internal.dataParseDefinitions) {\n            var parseDefName = newVal.replace('dataParseDefinitions:', '');\n\n            var dynmData = _.get(declViewModel._internal.dataParseDefinitions, parseDefName);\n\n            if (dynmData) {\n              inputDataToUpdate[propName] = dynamicPropertySvc.processDataParseDefination(dynmData, dataCtxNode);\n            }\n          }\n        } else if (_.startsWith(newVal, 'Constants.')) {\n          var val = awConstantsSvc.getConstant(newVal);\n\n          if (val) {\n            inputDataToUpdate[propName] = val;\n          }\n        } else if (_.startsWith(newVal, 'ports:')) {\n          if (declViewModel._internal.ports) {\n            var resolvedInput = _.get(declViewModel._internal.ports, newVal.replace('ports:', ''));\n\n            if (resolvedInput) {\n              inputDataToUpdate[propName] = resolvedInput;\n            }\n          }\n        }\n      } else if (propValue === 'undefined') {\n        inputDataToUpdate[propName] = undefined;\n      } else if (propValue.match(/\\{\\{.*}}/g)) {\n        if (_debug_logInterpolatingActivity) {\n          logger.info('Interpolating ' + propName + ': ' + propValue);\n        } // If * was used to intentionally trigger interpolation remove it\n\n\n        if (propValue.charAt(0) === '*') {\n          propValue = propValue.substr(1);\n        }\n\n        inputDataToUpdate[propName] = AwInterpolateService.instance(propValue)({ ...dataCtxNode,\n          i18n: dataCtxNode.data.i18n\n        });\n      }\n    } else if (propValueType === 'object') {\n      /**\n       * Recurse to handle lower levels of {{ }} replacements\n       */\n      exports.applyScope(declViewModel, propValue, functionsList, dataCtxNode, depModuleObj);\n    } else {\n      return true;\n    }\n\n    return undefined;\n  });\n};\n/**\n * Resolve a specific response value based on the input parameters.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to process response into.\n *\n * @param {Object} response - The 'response' from a previous operation that will be used to determine the returned\n *            value based on the given input expression..\n *\n * @param {String} inputExpression - The expression that identifies where/how to determine the returned value (e.g.\n *            \"{{function:processTemplates}}\" \"{{templatesOutput[0].workflowTemplates}}\",\n *            \"{{dataParseDefinitions:xxxxxxxx}}\")\n *\n * @param {Object} depModuleObj - Module object that contains any functions to execute based on the\n *            'inputExpression' contents.\n * @param {Object} dataCtxNode - localContext\n *\n * @return {Object} The resolved value based on the given input parameters.\n */\n\nexport let getOutput = function (declViewModel, response, inputExpression, depModuleObj, dataCtxNode) {\n  var expression = parsingUtils.getStringBetweenDoubleMustaches(inputExpression);\n\n  if (_.startsWith(expression, 'function:')) {\n    var functionName = expression.replace('function:', '');\n    var functionsList = declViewModel._internal.functions;\n\n    if (functionsList) {\n      var funcToCall = functionsList[functionName];\n\n      if (!funcToCall) {\n        return depModuleObj[functionName](response);\n      }\n\n      var params = parametersList(funcToCall, dataCtxNode);\n      params.unshift(response); // evaluate function\n\n      if (depModuleObj && depModuleObj[funcToCall.functionName]) {\n        return depModuleObj[funcToCall.functionName].apply(depModuleObj, params);\n      } else if (depModuleObj) {\n        var funcDependancies = Object.keys(depModuleObj);\n\n        for (var index = 0; index < funcDependancies.length; index++) {\n          var key = funcDependancies[index];\n\n          if (funcToCall.deps && funcToCall.deps.includes(key)) {\n            return depModuleObj[key][funcToCall.functionName].apply(depModuleObj, params);\n          }\n        }\n      }\n    } // evaluate function\n\n\n    return depModuleObj[functionName](response);\n  } else if (_.startsWith(expression, 'dataParseDefinitions:')) {\n    if (declViewModel._internal.dataParseDefinitions) {\n      var parseDefName = expression.replace('dataParseDefinitions:', '');\n\n      var dynmData = _.get(declViewModel._internal.dataParseDefinitions, parseDefName);\n\n      if (dynmData) {\n        return dynamicPropertySvc.processDataParseDefination(dynmData, declViewModel, response);\n      }\n    }\n  } else if (_.startsWith(expression, 'json:')) {\n    var jsonStringVariable = expression.replace('json:', '');\n\n    var jsonString = _.get(response, jsonStringVariable);\n\n    return parsingUtils.parseJsonString(jsonString);\n  }\n\n  if (_.isString(inputExpression)) {\n    return _.get(response, inputExpression);\n  } // support plain primitive JavaScript type in expression\n\n\n  return inputExpression;\n};\n/**\n * Apply an expression object of inout.\n *\n * @param {Object} inputDataToUpdate - The object containing an expression.(e.g. \"$adapt\" : \"{{ctx.mselected}}\")\n *\n * @return {Promise} A promise object resolved with the results of the action.\n */\n\nexport let applyExpression = function (inputDataToUpdate) {\n  var adaptedPromises = {};\n\n  if (inputDataToUpdate) {\n    _.forEach(inputDataToUpdate, function (paramVal, paramKey) {\n      if (typeof paramVal === 'object' && paramVal && paramVal.$adapt !== undefined) {\n        var input = [];\n\n        if (Array.isArray(paramVal.$adapt)) {\n          input = paramVal.$adapt;\n        } else {\n          input.push(paramVal.$adapt);\n        }\n\n        var path = null;\n\n        if (paramVal.path !== undefined) {\n          path = paramVal.path;\n        }\n\n        var adaptPlaceHolder = {\n          paramKey: paramKey,\n          paramPath: path,\n          paramValArray: Array.isArray(paramVal.$adapt)\n        };\n        adaptedPromises[JSON.stringify(adaptPlaceHolder)] = adapterService.getAdaptedObjects(input, paramVal.isFullyAdapted);\n      }\n    });\n  } else {\n    inputDataToUpdate = {};\n  }\n\n  return AwPromiseService.instance.all(adaptedPromises).then(function (results) {\n    _.forEach(results, function (resultVal, resultKey) {\n      var resultKeyObj = JSON.parse(resultKey);\n\n      if (resultVal && resultVal.length > 0) {\n        if (resultKeyObj.paramPath) {\n          var assignedValues = [];\n\n          _.forEach(resultVal, function (resultObj) {\n            assignedValues.push(_.get(resultObj, resultKeyObj.paramPath));\n          });\n\n          inputDataToUpdate[resultKeyObj.paramKey] = resultKeyObj.paramValArray ? assignedValues : assignedValues[0];\n        } else {\n          inputDataToUpdate[resultKeyObj.paramKey] = resultKeyObj.paramValArray ? resultVal : resultVal[0];\n        }\n      } else {\n        delete inputDataToUpdate[resultKeyObj.paramKey];\n      }\n    });\n\n    return;\n  });\n};\nexports = {\n  applyScope,\n  getOutput,\n  applyExpression\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/declarativeDataCtxService.js"],"names":["exports","parametersList","funcParams","funcToCall","params","i","param","results2","parsingUtils","newParam","realizedFuncParam","applyScope","declUtils","assert","_","propValueType","results","propValue","newVal","val2","ctx","dataCtxNode","appCtxService","inputDataToUpdate","_debug_logMissingProperties","logger","functionName","functionsList","depModuleObj","declViewModel","parseDefName","dynmData","dynamicPropertySvc","val","awConstantsSvc","resolvedInput","i18n","getOutput","expression","funcDependancies","Object","index","key","jsonStringVariable","jsonString","applyExpression","adaptedPromises","paramVal","input","Array","path","adaptPlaceHolder","paramKey","paramPath","paramValArray","JSON","adapterService","resultKeyObj","resultVal","assignedValues"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to manage AngularJS Scope\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/declarativeDataCtxService\n */\nimport dynamicPropertySvc from 'js/dynamicPropertyService';\nimport awConstantsSvc from 'js/awConstantsService';\nimport AwInterpolateService from 'js/awInterpolateService';\nimport adapterService from 'js/adapterService';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport logger from 'js/logger';\n\n/**\n * Cached reference to dependent services\n */\n\n/**\n * Cached reference to adapter service\n */\n\n/**\n * {Boolean} TRUE if use of the $interpolate API should be logged.\n */\nvar _debug_logInterpolatingActivity;\n\n/**\n * {Boolean} TRUE if we are NOT able to find a property on the $scope when referenced in a data binding expression.\n */\nvar _debug_logMissingProperties;\n\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\nvar exports = {};\nvar parametersList = function( funcToCall, $scope ) {\n    var funcParams = funcToCall.parameters;\n    var params = [];\n    var i;\n    if( funcParams ) {\n        for( i = 0; i < funcParams.length; i++ ) {\n            var param = funcParams[ i ];\n\n            var results2 = param.match( parsingUtils.REGEX_DATABINDING );\n\n            if( results2 && results2.length === 4 ) {\n                var newParam = results2[ 2 ];\n\n                var realizedFuncParam = parsingUtils.parentGet( $scope, newParam );\n\n                params.push( realizedFuncParam );\n            } else {\n                params.push( param );\n            }\n        }\n    }\n    return params;\n};\n\n/**\n * Apply the scope object of the input.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {Object} inputDataToUpdate - The 'inputData' from an 'action' who's properties are to be updated with\n *            current values from the 'declViewModel' and/or dependent function calls.\n *\n * @param {Object} functionsList - List of functions read from JSON\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n */\nexport let applyScope = function( declViewModel, inputDataToUpdate, functionsList, dataCtxNode, depModuleObj ) {\n    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        return;\n    }\n\n    assert( inputDataToUpdate, 'Missing \"inputDataToUpdate\" parameter' );\n\n    // eslint-disable-next-line consistent-return\n    _.forEach( inputDataToUpdate, function( propValue, propName ) { // eslint-disable-line complexity\n        if( !propValue ) {\n            return true;\n        }\n\n        var propValueType = typeof propValue;\n\n        /**\n         * Check if propValue is undefined or a simple string\n         */\n        if( propValueType === 'string' ) {\n            /**\n             * Check if it is a replacement case\n             * <P>\n             * Note: The regex will only extract 4 segments w/the following for [1] & [3]<BR>\n             * results[1] === '{{' && results[3] === '}}'\n             */\n            var results = propValue.match( parsingUtils.REGEX_DATABINDING );\n\n            if( results && results.length === 4 ) {\n                var newVal = results[ 2 ];\n\n                if( !/^(function:|dataParseDefinitions:|Constants.|ports:|dragAndDropParams)/.test( newVal ) ) {\n                    // dataCtxNode.ctx is always old,\n                    // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/504\n                    // var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n                    var val2 = parsingUtils.parentGet( { ...dataCtxNode, ctx: { ...dataCtxNode.ctx, ...appCtxService.ctx } }, newVal );\n\n                    inputDataToUpdate[ propName ] = val2;\n\n                    if( _debug_logMissingProperties && val2 === undefined ) {\n                        logger.warn( 'Unable to find property on the current $scope: ' + newVal );\n                    }\n                } else if( _.startsWith( newVal, 'dragAndDropParams' ) ) {\n                    var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n                    inputDataToUpdate[ propName ] = val2;\n                } else if( _.startsWith( newVal, 'function:' ) ) {\n                    var functionName = newVal.replace( 'function:', '' );\n                    var funcToCall = functionsList[ functionName ];\n                    if( !funcToCall ) {\n                        assert( funcToCall, 'Missing function: ' + functionName );\n                    }\n                    var params = parametersList( funcToCall, dataCtxNode );\n\n                    if( depModuleObj ) {\n                        if( depModuleObj[ funcToCall.functionName ] ) {\n                            inputDataToUpdate[ propName ] = depModuleObj[ funcToCall.functionName ]\n                                .apply( depModuleObj, params );\n                        } else {\n                            _.forEach( depModuleObj, function( value, key ) {\n                                if( funcToCall.deps.includes( key ) ) {\n                                    inputDataToUpdate[ propName ] = depModuleObj[ key ][ funcToCall.functionName ]\n                                        .apply( depModuleObj[ key ], params );\n                                }\n                            } );\n                        }\n                    } else {\n                        inputDataToUpdate[ propName ] = undefined;\n                    }\n                } else if( _.startsWith( newVal, 'dataParseDefinitions:' ) ) {\n                    if( declViewModel._internal.dataParseDefinitions ) {\n                        var parseDefName = newVal.replace( 'dataParseDefinitions:', '' );\n                        var dynmData = _.get( declViewModel._internal.dataParseDefinitions, parseDefName );\n                        if( dynmData ) {\n                            inputDataToUpdate[ propName ] = dynamicPropertySvc.processDataParseDefination( dynmData,\n                                dataCtxNode );\n                        }\n                    }\n                } else if( _.startsWith( newVal, 'Constants.' ) ) {\n                    var val = awConstantsSvc.getConstant( newVal );\n                    if( val ) {\n                        inputDataToUpdate[ propName ] = val;\n                    }\n                } else if( _.startsWith( newVal, 'ports:' ) ) {\n                    if( declViewModel._internal.ports ) {\n                        var resolvedInput = _.get( declViewModel._internal.ports, newVal.replace( 'ports:', '' ) );\n                        if( resolvedInput ) {\n                            inputDataToUpdate[ propName ] = resolvedInput;\n                        }\n                    }\n                }\n            } else if( propValue === 'undefined' ) {\n                inputDataToUpdate[ propName ] = undefined;\n            } else if( propValue.match( /\\{\\{.*}}/g ) ) {\n                if( _debug_logInterpolatingActivity ) {\n                    logger.info( 'Interpolating ' + propName + ': ' + propValue );\n                }\n                // If * was used to intentionally trigger interpolation remove it\n                if( propValue.charAt( 0 ) === '*' ) {\n                    propValue = propValue.substr( 1 );\n                }\n                inputDataToUpdate[ propName ] = AwInterpolateService.instance( propValue )( { ...dataCtxNode, i18n: dataCtxNode.data.i18n } );\n            }\n        } else if( propValueType === 'object' ) {\n            /**\n             * Recurse to handle lower levels of {{ }} replacements\n             */\n            exports.applyScope( declViewModel, propValue, functionsList, dataCtxNode, depModuleObj );\n        } else {\n            return true;\n        }\n        return undefined;\n    } );\n};\n\n/**\n * Resolve a specific response value based on the input parameters.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to process response into.\n *\n * @param {Object} response - The 'response' from a previous operation that will be used to determine the returned\n *            value based on the given input expression..\n *\n * @param {String} inputExpression - The expression that identifies where/how to determine the returned value (e.g.\n *            \"{{function:processTemplates}}\" \"{{templatesOutput[0].workflowTemplates}}\",\n *            \"{{dataParseDefinitions:xxxxxxxx}}\")\n *\n * @param {Object} depModuleObj - Module object that contains any functions to execute based on the\n *            'inputExpression' contents.\n * @param {Object} dataCtxNode - localContext\n *\n * @return {Object} The resolved value based on the given input parameters.\n */\nexport let getOutput = function( declViewModel, response, inputExpression, depModuleObj, dataCtxNode ) {\n    var expression = parsingUtils.getStringBetweenDoubleMustaches( inputExpression );\n\n    if( _.startsWith( expression, 'function:' ) ) {\n        var functionName = expression.replace( 'function:', '' );\n        var functionsList = declViewModel._internal.functions;\n        if( functionsList ) {\n            var funcToCall = functionsList[ functionName ];\n\n            if( !funcToCall ) {\n                return depModuleObj[ functionName ]( response );\n            }\n            var params = parametersList( funcToCall, dataCtxNode );\n            params.unshift( response );\n            // evaluate function\n            if( depModuleObj && depModuleObj[ funcToCall.functionName ] ) {\n                return depModuleObj[ funcToCall.functionName ].apply( depModuleObj, params );\n            } else if( depModuleObj ) {\n                var funcDependancies = Object.keys( depModuleObj );\n                for( var index = 0; index < funcDependancies.length; index++ ) {\n                    var key = funcDependancies[ index ];\n                    if( funcToCall.deps && funcToCall.deps.includes( key ) ) {\n                        return depModuleObj[ key ][ funcToCall.functionName ].apply( depModuleObj, params );\n                    }\n                }\n            }\n        }\n        // evaluate function\n        return depModuleObj[ functionName ]( response );\n    } else if( _.startsWith( expression, 'dataParseDefinitions:' ) ) {\n        if( declViewModel._internal.dataParseDefinitions ) {\n            var parseDefName = expression.replace( 'dataParseDefinitions:', '' );\n\n            var dynmData = _.get( declViewModel._internal.dataParseDefinitions, parseDefName );\n\n            if( dynmData ) {\n                return dynamicPropertySvc.processDataParseDefination( dynmData, declViewModel, response );\n            }\n        }\n    } else if( _.startsWith( expression, 'json:' ) ) {\n        var jsonStringVariable = expression.replace( 'json:', '' );\n        var jsonString = _.get( response, jsonStringVariable );\n        return parsingUtils.parseJsonString( jsonString );\n    }\n\n    if( _.isString( inputExpression ) ) {\n        return _.get( response, inputExpression );\n    }\n    // support plain primitive JavaScript type in expression\n    return inputExpression;\n};\n\n/**\n * Apply an expression object of inout.\n *\n * @param {Object} inputDataToUpdate - The object containing an expression.(e.g. \"$adapt\" : \"{{ctx.mselected}}\")\n *\n * @return {Promise} A promise object resolved with the results of the action.\n */\nexport let applyExpression = function( inputDataToUpdate ) {\n    var adaptedPromises = {};\n    if( inputDataToUpdate ) {\n        _.forEach( inputDataToUpdate, function( paramVal, paramKey ) {\n            if( typeof paramVal === 'object' && paramVal && paramVal.$adapt !== undefined ) {\n                var input = [];\n                if( Array.isArray( paramVal.$adapt ) ) {\n                    input = paramVal.$adapt;\n                } else {\n                    input.push( paramVal.$adapt );\n                }\n                var path = null;\n                if( paramVal.path !== undefined ) {\n                    path = paramVal.path;\n                }\n                var adaptPlaceHolder = {\n                    paramKey: paramKey,\n                    paramPath: path,\n                    paramValArray: Array.isArray( paramVal.$adapt )\n                };\n                adaptedPromises[ JSON.stringify( adaptPlaceHolder ) ] = adapterService.getAdaptedObjects( input, paramVal.isFullyAdapted );\n            }\n        } );\n    } else {\n        inputDataToUpdate = {};\n    }\n\n    return AwPromiseService.instance.all( adaptedPromises ).then( function( results ) {\n        _.forEach( results, function( resultVal, resultKey ) {\n            var resultKeyObj = JSON.parse( resultKey );\n            if( resultVal && resultVal.length > 0 ) {\n                if( resultKeyObj.paramPath ) {\n                    var assignedValues = [];\n                    _.forEach( resultVal, function( resultObj ) {\n                        assignedValues.push( _.get( resultObj, resultKeyObj.paramPath ) );\n                    } );\n                    inputDataToUpdate[ resultKeyObj.paramKey ] =\n                        resultKeyObj.paramValArray ? assignedValues : assignedValues[ 0 ];\n                } else {\n                    inputDataToUpdate[ resultKeyObj.paramKey ] = resultKeyObj.paramValArray ? resultVal : resultVal[ 0 ];\n                }\n            } else {\n                delete inputDataToUpdate[ resultKeyObj.paramKey ];\n            }\n        } );\n        return;\n    } );\n};\n\nexports = {\n    applyScope,\n    getOutput,\n    applyExpression\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}