{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * The native session manager service. This is the coordination/orchestration component which manages the\n * authentication state and authentication processing for signIn and signOut session behavior. The chosen\n * Authenticator performs the actual mechanics of any authentication.\n *\n * This represents the session tracking and authentication detection.\n * @module js/sessionManager.service\n */\nimport cfgSvc from 'js/configurationService';\nimport contributionSvc from 'js/contribution.service';\nimport postLgnPipeLneSvc from 'js/postLoginPipeline.service';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport sessionState from 'js/sessionState';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport analyticsSvc from 'js/analyticsService';\nimport moduleLoader from 'js/moduleLoader';\nimport cas from 'js/centralAggregationService'; // Service\n\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService'; // revisitme: uncomment following imports once available\n\nimport splmStatsService from 'js/splmStatsService'; // import analyticsSvc from 'js/analyticsService';\n\nvar _debug_logAuthActivity = browserUtils.getUrlAttributes().logAuthActivity !== undefined; // service and module references\n// members\n\n\nvar _savedNavTarget;\n\nvar _targetAuthenticator; // flag to suppress location reload during logoff; required for SSO support (ie11 + IIS)\n\n\nvar _suppressReload = false; // prop set/get functions\n\nvar exports = {};\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} isAuth - Whether or not session is currently authenticated.\n */\n\nexport let setAuthStatus = function (isAuth) {\n  sessionState.setAuthStatus(isAuth);\n};\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is session currently authenticated\n */\n\nexport let getAuthStatus = function () {\n  return sessionState.getIsAuthenticated();\n};\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is authentication in progress\n */\n\nexport let isAuthenticationInProgress = function () {\n  return sessionState.isAuthenticationInProgress();\n};\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} inProg - is authentication currently in progress.\n */\n\nexport let setAuthenticationInProgress = function (inProg) {\n  sessionState.setAuthenticationInProgress(inProg);\n};\n/**\n * responsible for choosing the appropriate authenticator logic to be used. resolve the promise with the\n * appropriate authenticator. This needs more work to account for the various authenticators....\n *\n * how do we get the list of authenticators? logic to pick which one?\n *\n * @return {Promise} returns a promise to be resolved once the correct authenticator is chosen.\n */\n\nexport let pickAuthenticator = function () {\n  // determine how to \"contribute\" the different authenticators,\n  if (_targetAuthenticator) {\n    // if an authenticator is already set, just use it.\n    return AwPromiseService.instance.resolve(_targetAuthenticator);\n  }\n\n  var name;\n  return cfgSvc.getCfg('solutionDef').then(function (solution) {\n    name = solution.authenticator;\n    return cfgSvc.getCfg('authenticator');\n  }).then(function (authenticators) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: pickAuthenticator: ' + name);\n    }\n\n    return moduleLoader.loadDependentModule(authenticators[name].dep);\n  }).then(function (module) {\n    if (!module) {\n      throw new Error('No authenticator provided!');\n    }\n\n    return module.getAuthenticator();\n  }).then(function (authenticator) {\n    _targetAuthenticator = authenticator;\n    return _targetAuthenticator;\n  });\n}; // Sign out related functions/behavior\n\n/**\n * logic to invoke the authenticator signOut functionality.\n *\n * @return {Promise} promise\n */\n\nvar callAuthSignOut = function () {\n  if (_targetAuthenticator) {\n    return _targetAuthenticator.signOut().then(function () {\n      exports.postSignOut();\n    }).catch(function () {\n      // signOut error, but just continue the path\n      logger.error('SM: authenticator signOut() err');\n      exports.postSignOut();\n    });\n  }\n\n  logger.error('SM:ERROR - processing signOut, but no Authenticator is available');\n};\n/**\n * method to begin the session termination flow. Starts the signOut process.\n *\n * @return {Promise} promise\n */\n\n\nexport let terminateSession = function () {\n  sessionStorage.clear(); // clearing the sessionStorage once session is terminated\n\n  return exports.pickAuthenticator().then(function () {\n    return callAuthSignOut();\n  });\n};\n/**\n * Wrapper function around the window location reset method to allow for unit test execution.\n *\n * Having a distinct method allows test logic to mock out the actual call.\n */\n\nexport let setLocationToDefault = function () {\n  // need to reload the whole location, not just the $state() to refresh content.\n  // Force a refresh of the page to clear memory.\n  // This adds in security & memory leaks.\n  // should go back to the default or startup page.  Use the base URL\n  var base = location.origin + location.pathname + location.search;\n\n  if (_targetAuthenticator && _targetAuthenticator.getPostSignOutURL) {\n    base = _targetAuthenticator.getPostSignOutURL();\n    _suppressReload = true;\n  }\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: setLocationToDefault - target URL: ' + base);\n  }\n\n  exports.locationReplace(base);\n};\n/**\n * To support unit test, we need a wrapper function which can be mocked to support Jasmine unit tests.\n *\n * @param {String} url - URL to set.\n */\n\nexport let locationReplace = function (url) {\n  // eslint-disable-next-line no-debugger\n  debugger;\n  _suppressReload = true;\n  location.replace(url);\n};\n/**\n * This is the post authenticator signOut stage. At this point there is no longer a valid session. Update state\n * and trigger refresh navigation.\n */\n\nexport let postSignOut = function () {\n  exports.setAuthStatus(false);\n  exports.setAuthenticationInProgress(false);\n  localStrg.publish('signingOut', 'true');\n  exports.setLocationToDefault();\n};\nlocalStrg.subscribe('signingOut', () => {\n  setLocationToDefault();\n});\n/**\n * this resolves the in-doubt state of the session, calls detection soa to see if there is a valid session or\n * not. If there is, continue navigation to target and mark session as authenticated. If no active session,\n * start the authentication processing.\n *\n * NOTE - this runs DURING initialization as part of the first state change, and the angular is not yet\n * initialized.\n *\n * @param {Object} navigationTarget - structure with data for the ui-router request.\n * @return {Promise} promise\n */\n\nexport let checkSessionValid = function (navigationTarget) {\n  _savedNavTarget = navigationTarget; // save for post auth.\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: checkSessionValid: ' + 'navigationTarget=' + navigationTarget);\n  }\n\n  localStrg.removeItem('signingOut'); // 1) get the correct authenticator, then defer to the authenticator.\n  //    SSO & userPW will share some of the getSessionInfo3 path for updating session details.\n  // the pick authenticator will determine which of the authenticators to use.\n  // the way pickAuthenticator is called from route resolve, we have to pass it the promise\n\n  var deferred = AwPromiseService.instance.defer();\n  exports.pickAuthenticator().then(function (authenticator) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: authenticator chosen');\n    }\n\n    authenticator.checkIfSessionAuthenticated().then(function () {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: auth check Good! already authenticated');\n      }\n\n      exports.setAuthStatus(true);\n      var allStagesAuthenticated = postLgnPipeLneSvc.checkPostLoginAuthenticatedStages();\n\n      if (allStagesAuthenticated) {\n        exports.runNavToState();\n        eventBus.publish('authentication.complete', {\n          status: 'OK'\n        });\n      } else {\n        exports.runPostLoginBlocking().then(function () {\n          exports.runNavToState();\n          eventBus.publish('authentication.complete', {\n            status: 'OK'\n          });\n        }, function () {\n          if (_debug_logAuthActivity) {\n            logger.info('SM: end runPostLoginBlocking Stage - but ERROR');\n          }\n\n          exports.runNavToState();\n          eventBus.publish('authentication.complete', {\n            status: 'OK'\n          });\n        });\n      }\n\n      deferred.resolve();\n    }).catch(function (err) {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: auth check exception: ' + '\\n' + JSON.stringify(err, null, 2) + '\\n' + ' SM: Go to \"checkAuthentication\" state');\n      }\n\n      if (err && err.cause && err.cause.status === 500) {\n        // \"Internal Server Error\" which typically means that this API isn't available on the server\n        logger.error(err);\n        window.location.replace(browserUtils.getBaseURL() + 'serverError.html');\n      }\n\n      exports.setAuthenticationInProgress(true); // indicator that in-process of authenticating\n\n      AwStateService.instance.go('checkAuthentication');\n      eventBus.publish('authentication.complete', {\n        status: 'Failed'\n      });\n      deferred.resolve();\n    });\n  }, function (err) {\n    logger.error('SM: Unable to pick an authenticator - serious configuration error!');\n    eventBus.publish('authentication.complete', {\n      status: 'Failed'\n    });\n    deferred.reject(err);\n  });\n  return deferred.promise;\n};\n/**\n * Stage 2 of the authentication flow. Owned by the session manager.\n *\n * fires the session.signIn event\n *\n * used as the post authentication common flow. Mark the authentication state complete, continue with the login\n * flow/pipeline.\n *\n * @return {Promise} promise\n */\n\nexport let authenticationSuccessful = function () {\n  exports.setAuthStatus(true);\n  exports.setAuthenticationInProgress(false);\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: authSuccessful, fire \"session.signIn\" event');\n  } // Used to fire this event ONLY for User/PW SOA call, fire it here for ALL authenticators\n  // this is the point in the session state flow that the authentication is known to be OK.\n\n\n  eventBus.publish('session.signIn', {}); // initial authentication is complete.  Let the authenticator do any initialization,\n  // then see if there is postLogin pipeline content to be executed...\n\n  return exports.runPostAuthInit().then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runPostAuthInit Stage complete - continue to next Auth step');\n    }\n\n    return exports.runPostLoginBlocking();\n  }).then(function () {\n    return exports.runNavToState();\n  });\n};\n/**\n * Reset PipeLine while signing in\n */\n\nexport let resetPipeLine = function () {\n  if (_debug_logAuthActivity) {\n    logger.info('SM: resetPipeLine');\n  }\n\n  postLgnPipeLneSvc.resetPostLoginStages();\n};\n/**\n * next stage of the authentication path. This is a spot for the authenticator to run any specific logic. At\n * this point we've successfully authenticated and any specific initialization can be done.\n *\n * @return {Promise} a promise which is resolved when the authenticator initialization is complete.\n */\n\nexport let runPostAuthInit = function () {\n  return exports.pickAuthenticator().then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runPostAuthInit');\n    }\n\n    analyticsSvc.authenticationSuccessful();\n    return _targetAuthenticator ? _targetAuthenticator.postAuthInitialization() : AwPromiseService.instance.resolve();\n  });\n};\n/**\n * This function is responsible for invoking a single pipeline step definition.\n *\n * A step definition can either identify a route to run OR provide a work function. If the \"routeName\" is\n * provided, that takes precedence and that route will be called.\n *\n * The continuation promise is passed along to the route as part of the custom data structure with a member name\n * of \"nextContinuation\". for the work function, the promise is passed as a function argument.\n *\n * In either case, the route OR the work function MUST either resolve or reject the promise. Resolve path\n * continues pipeline execution, reject will immediately exit the pipeline and not invoke any of the remaining\n * tasks.\n *\n * @param {Object} stepDefn - a step definition for running a single contributed \"step\"\n * @param {Object} curIdx - index of the current step definition in the list\n * @param {Function} fOK - success function to invoke\n * @param {Function} fErr - error function to invoke\n */\n\nvar runOneStep = function (stepDefn, curIdx, fOK, fErr) {\n  // TODO - assert the inputs, non-null stepDefn, fOk & fErr are functions.\n  if (_debug_logAuthActivity) {\n    logger.info('SM: running on steps for idx: ' + curIdx + ' name: ' + stepDefn.name);\n  } // if not active, skip it altogether\n\n\n  if (!stepDefn.active) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: not active, skipping step: ' + stepDefn.name);\n    }\n\n    fOK(curIdx);\n  } // the stepPromise represents the continuation for the pipeline step.\n\n\n  var stepPromise = AwPromiseService.instance.defer();\n  stepPromise.promise.then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: done with pipeline Step continue. ' + stepDefn.name);\n    }\n\n    fOK(curIdx);\n  }, function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: done with pipeline Step - REJECT ' + stepDefn.name);\n    }\n\n    fErr(curIdx);\n  }); // branch to either routeName for a route, or call the workFunction\n\n  if (stepDefn.routeName && stepDefn.routeName.length > 0) {\n    // invoke the route\n    var stName = stepDefn.routeName;\n    var options = {\n      notify: true,\n      // notify must be true..\n      location: false\n    };\n    var myState = AwStateService.instance.get(stName); // pass the continuation promise as custom data.\n\n    if (myState) {\n      if (myState.data) {\n        myState.data.nextContinuation = stepPromise;\n      } else {\n        myState.data = {\n          nextContinuation: stepPromise\n        };\n      }\n    }\n\n    AwStateService.instance.go(stName, {}, options);\n  } else {\n    // call the work function\n    if (stepDefn.workFunction) {\n      stepDefn.workFunction(stepDefn, stepPromise);\n    } else {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: No work function, assume fOK path');\n      }\n\n      fOK(curIdx);\n    }\n  }\n};\n/**\n * This is the pipeline execution stage - the session manager blocks on any post logic processes. This is a\n * configuration point to execute any contributed post authentication logic.\n *\n * The \"postLoginPipeline\" named contributions are used to obtain pipeline \"step\" definitions which identify the\n * logic or route to be run.\n *\n * @return {Promise} promise\n */\n\n\nexport let runPostLoginBlocking = function () {\n  var postLogInPiplinePromise = AwPromiseService.instance.defer(); // 1) get the list of contributors (0..n)\n  // 2) get the stepDefinitions from each\n  // 3) sort the stepDefinitions by priority value\n  // 4) invoke each in order.  If one rejects then break the chain. ??? or NOT\n  // 5) when all have run, then continue with the next stage step.\n\n  contributionSvc.loadContributions('postLoginPipeline').then(function (contributors) {\n    if (contributors && contributors.length > 0) {\n      var pipeLineSteps = postLgnPipeLneSvc.sortPostLoginPipeline(contributors); // iterate and call each step,\n      // upon last one, continue the postLogInPiplinePromise\n\n      if (pipeLineSteps && pipeLineSteps.length > 0) {\n        var fNext = null;\n        var fErr = null;\n\n        fNext = function (compStepIdx) {\n          pipeLineSteps[compStepIdx].status = true;\n          localStrg.publish('postLoginStagesKey', JSON.stringify(pipeLineSteps));\n          var nextIdx = compStepIdx + 1;\n\n          if (nextIdx >= pipeLineSteps.length) {\n            // done with the last one,\n            if (_debug_logAuthActivity) {\n              logger.info('SM: done with last step, continue post promise');\n            }\n\n            postLogInPiplinePromise.resolve();\n          } else {\n            // run next one\n            runOneStep(pipeLineSteps[nextIdx], nextIdx, fNext, fErr);\n          }\n        };\n\n        fErr = function (compStepIdx) {\n          // step failure, do we fail the pipeline, or continue with the other steps?\n          // could log the issue and fall into the fNext() ...\n          pipeLineSteps[compStepIdx].status = false;\n          localStrg.publish('postLoginStagesKey', JSON.stringify(pipeLineSteps));\n\n          if (_debug_logAuthActivity) {\n            logger.info('SM: one of the steps had an error: ' + compStepIdx);\n          }\n\n          postLogInPiplinePromise.reject();\n        };\n\n        var pipeLineStepToExecute = null;\n        var stepIndex = 0;\n\n        for (; stepIndex < pipeLineSteps.length; stepIndex++) {\n          // find the step that has status false\n          if (!pipeLineSteps[stepIndex].status) {\n            pipeLineStepToExecute = pipeLineSteps[stepIndex];\n            break;\n          }\n        } // start running the steps if step to execute is not null\n\n\n        if (pipeLineStepToExecute) {\n          runOneStep(pipeLineStepToExecute, stepIndex, fNext, fErr);\n        } else {\n          // this means all steps have been successfully executed. resolve the promise\n          postLogInPiplinePromise.resolve();\n        }\n      } else {\n        // no pipeLine steps, continue on.\n        postLogInPiplinePromise.resolve();\n      }\n    } else {\n      // no contributors\n      postLogInPiplinePromise.resolve();\n    }\n  }, function () {\n    // some reject on the contribution service - continue on.\n    logger.error('SM: contribution service error for postLoginPipeline');\n    postLogInPiplinePromise.resolve();\n  }); // the full pipeline promise - when all step definition handlers have completed.\n\n  return postLogInPiplinePromise.promise;\n};\n/**\n * This is the final authentication stage. At this point all handlers have run, the authenticator has done it's\n * initialization, we can now navigate to the desired target state.\n */\n\nexport let runNavToState = function () {\n  if (_savedNavTarget) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runNavToState Stage - redirect to original target: ' + _savedNavTarget.toState);\n    }\n\n    AwStateService.instance.go(_savedNavTarget.toState, _savedNavTarget.toParams, _savedNavTarget.options);\n  } else {\n    logger.error('SM: post auth, runNavToState - NO saved Nav Target!!'); // what to do in this situation?  what is the \"default\" state?\n  }\n};\n/**\n * location reload\n */\n\nfunction reload() {\n  if (!_suppressReload) {\n    location.reload(false);\n  }\n}\n/**\n * init set up for localStorage\n */\n\n\nexport let initLocalStorage = function () {\n  /**\n   * Setup to listed to changes in any associated browser's session state.\n   */\n  localStrg.subscribe('awSession', reload);\n};\nexport let reset = function () {\n  _targetAuthenticator = null;\n}; // No dependency on appCtxService, but need the service initialized for event registration\n\n/**\n * Since this module can be loaded GWT-side by the ModuleLoader class we need to return an object indicating\n * which service should be injected to provide the API for this module.\n */\n\nexports = {\n  setAuthStatus,\n  getAuthStatus,\n  isAuthenticationInProgress,\n  setAuthenticationInProgress,\n  pickAuthenticator,\n  terminateSession,\n  setLocationToDefault,\n  locationReplace,\n  postSignOut,\n  checkSessionValid,\n  authenticationSuccessful,\n  resetPipeLine,\n  runPostAuthInit,\n  runPostLoginBlocking,\n  runNavToState,\n  initLocalStorage,\n  reset\n};\nexport default exports;\ninitLocalStorage(); // setup analytics profiler.\n\nsplmStatsService.initProfiler(); // setup global click listener.\n\ncas.initClickListener();","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/sessionManager.service.js"],"names":["_debug_logAuthActivity","browserUtils","_suppressReload","exports","setAuthStatus","sessionState","getAuthStatus","isAuthenticationInProgress","setAuthenticationInProgress","pickAuthenticator","AwPromiseService","name","solution","cfgSvc","logger","moduleLoader","authenticators","module","_targetAuthenticator","callAuthSignOut","terminateSession","sessionStorage","setLocationToDefault","base","location","locationReplace","postSignOut","localStrg","checkSessionValid","_savedNavTarget","deferred","authenticator","allStagesAuthenticated","postLgnPipeLneSvc","eventBus","status","JSON","err","window","AwStateService","authenticationSuccessful","resetPipeLine","runPostAuthInit","analyticsSvc","runOneStep","stepDefn","fOK","stepPromise","fErr","stName","options","notify","myState","nextContinuation","runPostLoginBlocking","postLogInPiplinePromise","contributionSvc","contributors","pipeLineSteps","fNext","nextIdx","compStepIdx","pipeLineStepToExecute","stepIndex","runNavToState","initLocalStorage","reset","splmStatsService","cas"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * The native session manager service. This is the coordination/orchestration component which manages the\n * authentication state and authentication processing for signIn and signOut session behavior. The chosen\n * Authenticator performs the actual mechanics of any authentication.\n *\n * This represents the session tracking and authentication detection.\n * @module js/sessionManager.service\n */\nimport cfgSvc from 'js/configurationService';\nimport contributionSvc from 'js/contribution.service';\nimport postLgnPipeLneSvc from 'js/postLoginPipeline.service';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport sessionState from 'js/sessionState';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport analyticsSvc from 'js/analyticsService';\nimport moduleLoader from 'js/moduleLoader';\nimport cas from 'js/centralAggregationService';\n\n// Service\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\n\n// revisitme: uncomment following imports once available\nimport splmStatsService from 'js/splmStatsService';\n// import analyticsSvc from 'js/analyticsService';\n\nvar _debug_logAuthActivity = browserUtils.getUrlAttributes().logAuthActivity !== undefined;\n\n// service and module references\n\n// members\nvar _savedNavTarget;\nvar _targetAuthenticator;\n\n// flag to suppress location reload during logoff; required for SSO support (ie11 + IIS)\nvar _suppressReload = false;\n\n// prop set/get functions\n\nvar exports = {};\n\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} isAuth - Whether or not session is currently authenticated.\n */\nexport let setAuthStatus = function( isAuth ) {\n    sessionState.setAuthStatus( isAuth );\n};\n\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is session currently authenticated\n */\nexport let getAuthStatus = function() {\n    return sessionState.getIsAuthenticated();\n};\n\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is authentication in progress\n */\nexport let isAuthenticationInProgress = function() {\n    return sessionState.isAuthenticationInProgress();\n};\n\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} inProg - is authentication currently in progress.\n */\nexport let setAuthenticationInProgress = function( inProg ) {\n    sessionState.setAuthenticationInProgress( inProg );\n};\n\n/**\n * responsible for choosing the appropriate authenticator logic to be used. resolve the promise with the\n * appropriate authenticator. This needs more work to account for the various authenticators....\n *\n * how do we get the list of authenticators? logic to pick which one?\n *\n * @return {Promise} returns a promise to be resolved once the correct authenticator is chosen.\n */\nexport let pickAuthenticator = function() {\n    // determine how to \"contribute\" the different authenticators,\n    if( _targetAuthenticator ) {\n        // if an authenticator is already set, just use it.\n        return AwPromiseService.instance.resolve( _targetAuthenticator );\n    }\n\n    var name;\n\n    return cfgSvc.getCfg( 'solutionDef' ).then( function( solution ) {\n        name = solution.authenticator;\n        return cfgSvc.getCfg( 'authenticator' );\n    } ).then( function( authenticators ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: pickAuthenticator: ' + name );\n        }\n\n        return moduleLoader.loadDependentModule( authenticators[ name ].dep );\n    } ).then( function( module ) {\n        if( !module ) {\n            throw new Error( 'No authenticator provided!' );\n        }\n\n        return module.getAuthenticator();\n    } ).then( function( authenticator ) {\n        _targetAuthenticator = authenticator;\n\n        return _targetAuthenticator;\n    } );\n};\n\n// Sign out related functions/behavior\n\n/**\n * logic to invoke the authenticator signOut functionality.\n *\n * @return {Promise} promise\n */\nvar callAuthSignOut = function() {\n    if( _targetAuthenticator ) {\n        return _targetAuthenticator.signOut().then( function() {\n            exports.postSignOut();\n        } ).catch( function() {\n            // signOut error, but just continue the path\n            logger.error( 'SM: authenticator signOut() err' );\n            exports.postSignOut();\n        } );\n    }\n\n    logger.error( 'SM:ERROR - processing signOut, but no Authenticator is available' );\n};\n\n/**\n * method to begin the session termination flow. Starts the signOut process.\n *\n * @return {Promise} promise\n */\nexport let terminateSession = function() {\n    sessionStorage.clear(); // clearing the sessionStorage once session is terminated\n    return exports.pickAuthenticator().then( function() {\n        return callAuthSignOut();\n    } );\n};\n\n/**\n * Wrapper function around the window location reset method to allow for unit test execution.\n *\n * Having a distinct method allows test logic to mock out the actual call.\n */\nexport let setLocationToDefault = function() {\n    // need to reload the whole location, not just the $state() to refresh content.\n    // Force a refresh of the page to clear memory.\n    // This adds in security & memory leaks.\n    // should go back to the default or startup page.  Use the base URL\n    var base = location.origin + location.pathname + location.search;\n    if( _targetAuthenticator && _targetAuthenticator.getPostSignOutURL ) {\n        base = _targetAuthenticator.getPostSignOutURL();\n        _suppressReload = true;\n    }\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: setLocationToDefault - target URL: ' + base );\n    }\n\n    exports.locationReplace( base );\n};\n\n/**\n * To support unit test, we need a wrapper function which can be mocked to support Jasmine unit tests.\n *\n * @param {String} url - URL to set.\n */\nexport let locationReplace = function( url ) {\n    // eslint-disable-next-line no-debugger\n    debugger;\n\n    _suppressReload = true;\n    location.replace( url );\n};\n\n/**\n * This is the post authenticator signOut stage. At this point there is no longer a valid session. Update state\n * and trigger refresh navigation.\n */\nexport let postSignOut = function() {\n    exports.setAuthStatus( false );\n    exports.setAuthenticationInProgress( false );\n    localStrg.publish( 'signingOut', 'true' );\n    exports.setLocationToDefault();\n};\n\nlocalStrg.subscribe( 'signingOut', () => {\n    setLocationToDefault();\n} );\n\n/**\n * this resolves the in-doubt state of the session, calls detection soa to see if there is a valid session or\n * not. If there is, continue navigation to target and mark session as authenticated. If no active session,\n * start the authentication processing.\n *\n * NOTE - this runs DURING initialization as part of the first state change, and the angular is not yet\n * initialized.\n *\n * @param {Object} navigationTarget - structure with data for the ui-router request.\n * @return {Promise} promise\n */\nexport let checkSessionValid = function( navigationTarget ) {\n    _savedNavTarget = navigationTarget; // save for post auth.\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: checkSessionValid: ' + 'navigationTarget=' + navigationTarget );\n    }\n\n    localStrg.removeItem( 'signingOut' );\n\n    // 1) get the correct authenticator, then defer to the authenticator.\n    //    SSO & userPW will share some of the getSessionInfo3 path for updating session details.\n    // the pick authenticator will determine which of the authenticators to use.\n\n    // the way pickAuthenticator is called from route resolve, we have to pass it the promise\n    var deferred = AwPromiseService.instance.defer();\n\n    exports.pickAuthenticator().then( function( authenticator ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: authenticator chosen' );\n        }\n\n        authenticator.checkIfSessionAuthenticated().then( function() {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: auth check Good! already authenticated' );\n            }\n\n            exports.setAuthStatus( true );\n\n            var allStagesAuthenticated = postLgnPipeLneSvc.checkPostLoginAuthenticatedStages();\n\n            if( allStagesAuthenticated ) {\n                exports.runNavToState();\n                eventBus.publish( 'authentication.complete', { status: 'OK' } );\n            } else {\n                exports.runPostLoginBlocking().then( function() {\n                    exports.runNavToState();\n                    eventBus.publish( 'authentication.complete', { status: 'OK' } );\n                }, function() {\n                    if( _debug_logAuthActivity ) {\n                        logger.info( 'SM: end runPostLoginBlocking Stage - but ERROR' );\n                    }\n\n                    exports.runNavToState();\n                    eventBus.publish( 'authentication.complete', { status: 'OK' } );\n                } );\n            }\n\n            deferred.resolve();\n        } ).catch( function( err ) {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: auth check exception: ' + '\\n' + JSON.stringify( err, null, 2 ) + '\\n' + ' SM: Go to \"checkAuthentication\" state' );\n            }\n\n            if( err && err.cause && err.cause.status === 500 ) {\n                // \"Internal Server Error\" which typically means that this API isn't available on the server\n                logger.error( err );\n                window.location.replace( browserUtils.getBaseURL() + 'serverError.html' );\n            }\n\n            exports.setAuthenticationInProgress( true ); // indicator that in-process of authenticating\n\n            AwStateService.instance.go( 'checkAuthentication' );\n            eventBus.publish( 'authentication.complete', { status: 'Failed' } );\n\n            deferred.resolve();\n        } );\n    }, function( err ) {\n        logger.error( 'SM: Unable to pick an authenticator - serious configuration error!' );\n\n        eventBus.publish( 'authentication.complete', { status: 'Failed' } );\n        deferred.reject( err );\n    } );\n\n    return deferred.promise;\n};\n\n/**\n * Stage 2 of the authentication flow. Owned by the session manager.\n *\n * fires the session.signIn event\n *\n * used as the post authentication common flow. Mark the authentication state complete, continue with the login\n * flow/pipeline.\n *\n * @return {Promise} promise\n */\nexport let authenticationSuccessful = function() {\n    exports.setAuthStatus( true );\n    exports.setAuthenticationInProgress( false );\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: authSuccessful, fire \"session.signIn\" event' );\n    }\n\n    // Used to fire this event ONLY for User/PW SOA call, fire it here for ALL authenticators\n    // this is the point in the session state flow that the authentication is known to be OK.\n    eventBus.publish( 'session.signIn', {} );\n\n    // initial authentication is complete.  Let the authenticator do any initialization,\n    // then see if there is postLogin pipeline content to be executed...\n    return exports.runPostAuthInit().then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runPostAuthInit Stage complete - continue to next Auth step' );\n        }\n\n        return exports.runPostLoginBlocking();\n    } ).then( function() {\n        return exports.runNavToState();\n    } );\n};\n\n/**\n * Reset PipeLine while signing in\n */\nexport let resetPipeLine = function() {\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: resetPipeLine' );\n    }\n\n    postLgnPipeLneSvc.resetPostLoginStages();\n};\n\n/**\n * next stage of the authentication path. This is a spot for the authenticator to run any specific logic. At\n * this point we've successfully authenticated and any specific initialization can be done.\n *\n * @return {Promise} a promise which is resolved when the authenticator initialization is complete.\n */\nexport let runPostAuthInit = function() {\n    return exports.pickAuthenticator().then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runPostAuthInit' );\n        }\n\n        analyticsSvc.authenticationSuccessful();\n\n        return _targetAuthenticator ? _targetAuthenticator.postAuthInitialization() : AwPromiseService.instance.resolve();\n    } );\n};\n\n/**\n * This function is responsible for invoking a single pipeline step definition.\n *\n * A step definition can either identify a route to run OR provide a work function. If the \"routeName\" is\n * provided, that takes precedence and that route will be called.\n *\n * The continuation promise is passed along to the route as part of the custom data structure with a member name\n * of \"nextContinuation\". for the work function, the promise is passed as a function argument.\n *\n * In either case, the route OR the work function MUST either resolve or reject the promise. Resolve path\n * continues pipeline execution, reject will immediately exit the pipeline and not invoke any of the remaining\n * tasks.\n *\n * @param {Object} stepDefn - a step definition for running a single contributed \"step\"\n * @param {Object} curIdx - index of the current step definition in the list\n * @param {Function} fOK - success function to invoke\n * @param {Function} fErr - error function to invoke\n */\nvar runOneStep = function( stepDefn, curIdx, fOK, fErr ) {\n    // TODO - assert the inputs, non-null stepDefn, fOk & fErr are functions.\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: running on steps for idx: ' + curIdx + ' name: ' + stepDefn.name );\n    }\n\n    // if not active, skip it altogether\n    if( !stepDefn.active ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: not active, skipping step: ' + stepDefn.name );\n        }\n\n        fOK( curIdx );\n    }\n\n    // the stepPromise represents the continuation for the pipeline step.\n    var stepPromise = AwPromiseService.instance.defer();\n\n    stepPromise.promise.then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: done with pipeline Step continue. ' + stepDefn.name );\n        }\n\n        fOK( curIdx );\n    }, function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: done with pipeline Step - REJECT ' + stepDefn.name );\n        }\n\n        fErr( curIdx );\n    } );\n\n    // branch to either routeName for a route, or call the workFunction\n    if( stepDefn.routeName && stepDefn.routeName.length > 0 ) {\n        // invoke the route\n        var stName = stepDefn.routeName;\n\n        var options = {\n            notify: true, // notify must be true..\n            location: false\n        };\n\n        var myState = AwStateService.instance.get( stName );\n\n        // pass the continuation promise as custom data.\n        if( myState ) {\n            if( myState.data ) {\n                myState.data.nextContinuation = stepPromise;\n            } else {\n                myState.data = {\n                    nextContinuation: stepPromise\n                };\n            }\n        }\n\n        AwStateService.instance.go( stName, {}, options );\n    } else {\n        // call the work function\n        if( stepDefn.workFunction ) {\n            stepDefn.workFunction( stepDefn, stepPromise );\n        } else {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: No work function, assume fOK path' );\n            }\n\n            fOK( curIdx );\n        }\n    }\n};\n\n/**\n * This is the pipeline execution stage - the session manager blocks on any post logic processes. This is a\n * configuration point to execute any contributed post authentication logic.\n *\n * The \"postLoginPipeline\" named contributions are used to obtain pipeline \"step\" definitions which identify the\n * logic or route to be run.\n *\n * @return {Promise} promise\n */\nexport let runPostLoginBlocking = function() {\n    var postLogInPiplinePromise = AwPromiseService.instance.defer();\n\n    // 1) get the list of contributors (0..n)\n    // 2) get the stepDefinitions from each\n    // 3) sort the stepDefinitions by priority value\n    // 4) invoke each in order.  If one rejects then break the chain. ??? or NOT\n    // 5) when all have run, then continue with the next stage step.\n\n    contributionSvc.loadContributions( 'postLoginPipeline' ).then( function( contributors ) {\n        if( contributors && contributors.length > 0 ) {\n            var pipeLineSteps = postLgnPipeLneSvc.sortPostLoginPipeline( contributors );\n\n            // iterate and call each step,\n            // upon last one, continue the postLogInPiplinePromise\n            if( pipeLineSteps && pipeLineSteps.length > 0 ) {\n                var fNext = null;\n                var fErr = null;\n\n                fNext = function( compStepIdx ) {\n                    pipeLineSteps[ compStepIdx ].status = true;\n\n                    localStrg.publish( 'postLoginStagesKey', JSON.stringify( pipeLineSteps ) );\n\n                    var nextIdx = compStepIdx + 1;\n\n                    if( nextIdx >= pipeLineSteps.length ) {\n                        // done with the last one,\n                        if( _debug_logAuthActivity ) {\n                            logger.info( 'SM: done with last step, continue post promise' );\n                        }\n\n                        postLogInPiplinePromise.resolve();\n                    } else {\n                        // run next one\n                        runOneStep( pipeLineSteps[ nextIdx ], nextIdx, fNext, fErr );\n                    }\n                };\n\n                fErr = function( compStepIdx ) {\n                    // step failure, do we fail the pipeline, or continue with the other steps?\n                    // could log the issue and fall into the fNext() ...\n                    pipeLineSteps[ compStepIdx ].status = false;\n\n                    localStrg.publish( 'postLoginStagesKey', JSON.stringify( pipeLineSteps ) );\n\n                    if( _debug_logAuthActivity ) {\n                        logger.info( 'SM: one of the steps had an error: ' + compStepIdx );\n                    }\n\n                    postLogInPiplinePromise.reject();\n                };\n\n                var pipeLineStepToExecute = null;\n                var stepIndex = 0;\n\n                for( ; stepIndex < pipeLineSteps.length; stepIndex++ ) {\n                    // find the step that has status false\n                    if( !pipeLineSteps[ stepIndex ].status ) {\n                        pipeLineStepToExecute = pipeLineSteps[ stepIndex ];\n                        break;\n                    }\n                }\n\n                // start running the steps if step to execute is not null\n                if( pipeLineStepToExecute ) {\n                    runOneStep( pipeLineStepToExecute, stepIndex, fNext, fErr );\n                } else {\n                    // this means all steps have been successfully executed. resolve the promise\n                    postLogInPiplinePromise.resolve();\n                }\n            } else {\n                // no pipeLine steps, continue on.\n                postLogInPiplinePromise.resolve();\n            }\n        } else {\n            // no contributors\n            postLogInPiplinePromise.resolve();\n        }\n    }, function() {\n        // some reject on the contribution service - continue on.\n        logger.error( 'SM: contribution service error for postLoginPipeline' );\n\n        postLogInPiplinePromise.resolve();\n    } );\n\n    // the full pipeline promise - when all step definition handlers have completed.\n    return postLogInPiplinePromise.promise;\n};\n\n/**\n * This is the final authentication stage. At this point all handlers have run, the authenticator has done it's\n * initialization, we can now navigate to the desired target state.\n */\nexport let runNavToState = function() {\n    if( _savedNavTarget ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runNavToState Stage - redirect to original target: ' + _savedNavTarget.toState );\n        }\n\n        AwStateService.instance.go( _savedNavTarget.toState, _savedNavTarget.toParams, _savedNavTarget.options );\n    } else {\n        logger.error( 'SM: post auth, runNavToState - NO saved Nav Target!!' );\n        // what to do in this situation?  what is the \"default\" state?\n    }\n};\n\n/**\n * location reload\n */\nfunction reload() {\n    if( !_suppressReload ) {\n        location.reload( false );\n    }\n}\n\n/**\n * init set up for localStorage\n */\nexport let initLocalStorage = function() {\n    /**\n     * Setup to listed to changes in any associated browser's session state.\n     */\n    localStrg.subscribe( 'awSession', reload );\n};\n\nexport let reset = function() {\n    _targetAuthenticator = null;\n};\n\n// No dependency on appCtxService, but need the service initialized for event registration\n\n/**\n * Since this module can be loaded GWT-side by the ModuleLoader class we need to return an object indicating\n * which service should be injected to provide the API for this module.\n */\nexports = {\n    setAuthStatus,\n    getAuthStatus,\n    isAuthenticationInProgress,\n    setAuthenticationInProgress,\n    pickAuthenticator,\n    terminateSession,\n    setLocationToDefault,\n    locationReplace,\n    postSignOut,\n    checkSessionValid,\n    authenticationSuccessful,\n    resetPipeLine,\n    runPostAuthInit,\n    runPostLoginBlocking,\n    runNavToState,\n    initLocalStorage,\n    reset\n};\nexport default exports;\n\ninitLocalStorage();\n\n// setup analytics profiler.\nsplmStatsService.initProfiler();\n// setup global click listener.\ncas.initClickListener();\n"]},"metadata":{},"sourceType":"module"}