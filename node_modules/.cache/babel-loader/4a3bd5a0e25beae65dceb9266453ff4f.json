{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to manage AngularJS Scope\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/declarativeDataCtxService\n */\nimport dynamicPropertySvc from 'js/dynamicPropertyService';\nimport awConstantsSvc from 'js/awConstantsService';\nimport AwInterpolateService from 'js/awInterpolateService';\nimport adapterService from 'js/adapterService';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport logger from 'js/logger';\n/**\n * Cached reference to dependent services\n */\n\n/**\n * Cached reference to adapter service\n */\n\n/**\n * {Boolean} TRUE if use of the $interpolate API should be logged.\n */\n\nvar _debug_logInterpolatingActivity;\n/**\n * {Boolean} TRUE if we are NOT able to find a property on the $scope when referenced in a data binding expression.\n */\n\n\nvar _debug_logMissingProperties;\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\n\n\nvar exports = {};\n\nvar parametersList = function (funcToCall, $scope) {\n  var funcParams = funcToCall.parameters;\n  var params = [];\n  var i;\n\n  if (funcParams) {\n    for (i = 0; i < funcParams.length; i++) {\n      var param = funcParams[i];\n      var results2 = param.match(parsingUtils.REGEX_DATABINDING);\n\n      if (results2 && results2.length === 4) {\n        var newParam = results2[2];\n        var realizedFuncParam = parsingUtils.parentGet($scope, newParam);\n        params.push(realizedFuncParam);\n      } else {\n        params.push(param);\n      }\n    }\n  }\n\n  return params;\n};\n/**\n * Apply the scope object of the input.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {Object} inputDataToUpdate - The 'inputData' from an 'action' who's properties are to be updated with\n *            current values from the 'declViewModel' and/or dependent function calls.\n *\n * @param {Object} functionsList - List of functions read from JSON\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n */\n\n\nexport let applyScope = function (declViewModel, inputDataToUpdate, functionsList, dataCtxNode, depModuleObj) {\n  if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    return;\n  }\n\n  assert(inputDataToUpdate, 'Missing \"inputDataToUpdate\" parameter'); // eslint-disable-next-line consistent-return\n\n  _.forEach(inputDataToUpdate, function (propValue, propName) {\n    // eslint-disable-line complexity\n    if (!propValue) {\n      return true;\n    }\n\n    var propValueType = typeof propValue;\n    /**\n     * Check if propValue is undefined or a simple string\n     */\n\n    if (propValueType === 'string') {\n      /**\n       * Check if it is a replacement case\n       * <P>\n       * Note: The regex will only extract 4 segments w/the following for [1] & [3]<BR>\n       * results[1] === '{{' && results[3] === '}}'\n       */\n      var results = propValue.match(parsingUtils.REGEX_DATABINDING);\n\n      if (results && results.length === 4) {\n        var newVal = results[2];\n\n        if (!/^(function:|dataParseDefinitions:|Constants.|ports:|dragAndDropParams)/.test(newVal)) {\n          // dataCtxNode.ctx is always old,\n          // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/504\n          // var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n          var val2 = parsingUtils.parentGet({ ...dataCtxNode,\n            ctx: { ...dataCtxNode.ctx,\n              ...appCtxService.ctx\n            }\n          }, newVal);\n          inputDataToUpdate[propName] = val2;\n\n          if (_debug_logMissingProperties && val2 === undefined) {\n            logger.warn('Unable to find property on the current $scope: ' + newVal);\n          }\n        } else if (_.startsWith(newVal, 'dragAndDropParams')) {\n          var val2 = parsingUtils.parentGet(dataCtxNode, newVal);\n          inputDataToUpdate[propName] = val2;\n        } else if (_.startsWith(newVal, 'function:')) {\n          var functionName = newVal.replace('function:', '');\n          var funcToCall = functionsList[functionName];\n\n          if (!funcToCall) {\n            assert(funcToCall, 'Missing function: ' + functionName);\n          }\n\n          var params = parametersList(funcToCall, dataCtxNode);\n\n          if (depModuleObj) {\n            if (depModuleObj[funcToCall.functionName]) {\n              inputDataToUpdate[propName] = depModuleObj[funcToCall.functionName].apply(depModuleObj, params);\n            } else {\n              _.forEach(depModuleObj, function (value, key) {\n                if (funcToCall.deps.includes(key)) {\n                  inputDataToUpdate[propName] = depModuleObj[key][funcToCall.functionName].apply(depModuleObj[key], params);\n                }\n              });\n            }\n          } else {\n            inputDataToUpdate[propName] = undefined;\n          }\n        } else if (_.startsWith(newVal, 'dataParseDefinitions:')) {\n          if (declViewModel._internal.dataParseDefinitions) {\n            var parseDefName = newVal.replace('dataParseDefinitions:', '');\n\n            var dynmData = _.get(declViewModel._internal.dataParseDefinitions, parseDefName);\n\n            if (dynmData) {\n              inputDataToUpdate[propName] = dynamicPropertySvc.processDataParseDefination(dynmData, dataCtxNode);\n            }\n          }\n        } else if (_.startsWith(newVal, 'Constants.')) {\n          var val = awConstantsSvc.getConstant(newVal);\n\n          if (val) {\n            inputDataToUpdate[propName] = val;\n          }\n        } else if (_.startsWith(newVal, 'ports:')) {\n          if (declViewModel._internal.ports) {\n            var resolvedInput = _.get(declViewModel._internal.ports, newVal.replace('ports:', ''));\n\n            if (resolvedInput) {\n              inputDataToUpdate[propName] = resolvedInput;\n            }\n          }\n        }\n      } else if (propValue === 'undefined') {\n        inputDataToUpdate[propName] = undefined;\n      } else if (propValue.match(/\\{\\{.*}}/g)) {\n        if (_debug_logInterpolatingActivity) {\n          logger.info('Interpolating ' + propName + ': ' + propValue);\n        } // If * was used to intentionally trigger interpolation remove it\n\n\n        if (propValue.charAt(0) === '*') {\n          propValue = propValue.substr(1);\n        }\n\n        inputDataToUpdate[propName] = AwInterpolateService.instance(propValue)({ ...dataCtxNode,\n          i18n: dataCtxNode.data.i18n\n        });\n      }\n    } else if (propValueType === 'object') {\n      /**\n       * Recurse to handle lower levels of {{ }} replacements\n       */\n      exports.applyScope(declViewModel, propValue, functionsList, dataCtxNode, depModuleObj);\n    } else {\n      return true;\n    }\n\n    return undefined;\n  });\n};\n/**\n * Resolve a specific response value based on the input parameters.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to process response into.\n *\n * @param {Object} response - The 'response' from a previous operation that will be used to determine the returned\n *            value based on the given input expression..\n *\n * @param {String} inputExpression - The expression that identifies where/how to determine the returned value (e.g.\n *            \"{{function:processTemplates}}\" \"{{templatesOutput[0].workflowTemplates}}\",\n *            \"{{dataParseDefinitions:xxxxxxxx}}\")\n *\n * @param {Object} depModuleObj - Module object that contains any functions to execute based on the\n *            'inputExpression' contents.\n * @param {Object} dataCtxNode - localContext\n *\n * @return {Object} The resolved value based on the given input parameters.\n */\n\nexport let getOutput = function (declViewModel, response, inputExpression, depModuleObj, dataCtxNode) {\n  var expression = parsingUtils.getStringBetweenDoubleMustaches(inputExpression);\n\n  if (_.startsWith(expression, 'function:')) {\n    var functionName = expression.replace('function:', '');\n    var functionsList = declViewModel._internal.functions;\n\n    if (functionsList) {\n      var funcToCall = functionsList[functionName];\n\n      if (!funcToCall) {\n        return depModuleObj[functionName](response);\n      }\n\n      var params = parametersList(funcToCall, dataCtxNode);\n      params.unshift(response); // evaluate function\n\n      if (depModuleObj && depModuleObj[funcToCall.functionName]) {\n        return depModuleObj[funcToCall.functionName].apply(depModuleObj, params);\n      } else if (depModuleObj) {\n        var funcDependancies = Object.keys(depModuleObj);\n\n        for (var index = 0; index < funcDependancies.length; index++) {\n          var key = funcDependancies[index];\n\n          if (funcToCall.deps && funcToCall.deps.includes(key)) {\n            return depModuleObj[key][funcToCall.functionName].apply(depModuleObj, params);\n          }\n        }\n      }\n    } // evaluate function\n\n\n    return depModuleObj[functionName](response);\n  } else if (_.startsWith(expression, 'dataParseDefinitions:')) {\n    if (declViewModel._internal.dataParseDefinitions) {\n      var parseDefName = expression.replace('dataParseDefinitions:', '');\n\n      var dynmData = _.get(declViewModel._internal.dataParseDefinitions, parseDefName);\n\n      if (dynmData) {\n        return dynamicPropertySvc.processDataParseDefination(dynmData, declViewModel, response);\n      }\n    }\n  } else if (_.startsWith(expression, 'json:')) {\n    var jsonStringVariable = expression.replace('json:', '');\n\n    var jsonString = _.get(response, jsonStringVariable);\n\n    return parsingUtils.parseJsonString(jsonString);\n  }\n\n  if (_.isString(inputExpression)) {\n    return _.get(response, inputExpression);\n  } // support plain primitive JavaScript type in expression\n\n\n  return inputExpression;\n};\n/**\n * Apply an expression object of inout.\n *\n * @param {Object} inputDataToUpdate - The object containing an expression.(e.g. \"$adapt\" : \"{{ctx.mselected}}\")\n *\n * @return {Promise} A promise object resolved with the results of the action.\n */\n\nexport let applyExpression = function (inputDataToUpdate) {\n  var adaptedPromises = {};\n\n  if (inputDataToUpdate) {\n    _.forEach(inputDataToUpdate, function (paramVal, paramKey) {\n      if (typeof paramVal === 'object' && paramVal && paramVal.$adapt !== undefined) {\n        var input = [];\n\n        if (Array.isArray(paramVal.$adapt)) {\n          input = paramVal.$adapt;\n        } else {\n          input.push(paramVal.$adapt);\n        }\n\n        var path = null;\n\n        if (paramVal.path !== undefined) {\n          path = paramVal.path;\n        }\n\n        var adaptPlaceHolder = {\n          paramKey: paramKey,\n          paramPath: path,\n          paramValArray: Array.isArray(paramVal.$adapt)\n        };\n        adaptedPromises[JSON.stringify(adaptPlaceHolder)] = adapterService.getAdaptedObjects(input, paramVal.isFullyAdapted);\n      }\n    });\n  } else {\n    inputDataToUpdate = {};\n  }\n\n  return AwPromiseService.instance.all(adaptedPromises).then(function (results) {\n    _.forEach(results, function (resultVal, resultKey) {\n      var resultKeyObj = JSON.parse(resultKey);\n\n      if (resultVal && resultVal.length > 0) {\n        if (resultKeyObj.paramPath) {\n          var assignedValues = [];\n\n          _.forEach(resultVal, function (resultObj) {\n            assignedValues.push(_.get(resultObj, resultKeyObj.paramPath));\n          });\n\n          inputDataToUpdate[resultKeyObj.paramKey] = resultKeyObj.paramValArray ? assignedValues : assignedValues[0];\n        } else {\n          inputDataToUpdate[resultKeyObj.paramKey] = resultKeyObj.paramValArray ? resultVal : resultVal[0];\n        }\n      } else {\n        delete inputDataToUpdate[resultKeyObj.paramKey];\n      }\n    });\n\n    return;\n  });\n};\nexports = {\n  applyScope,\n  getOutput,\n  applyExpression\n};\nexport default exports;","map":{"version":3,"names":["dynamicPropertySvc","awConstantsSvc","AwInterpolateService","adapterService","AwPromiseService","appCtxService","assert","_","declUtils","parsingUtils","logger","_debug_logInterpolatingActivity","_debug_logMissingProperties","exports","parametersList","funcToCall","$scope","funcParams","parameters","params","i","length","param","results2","match","REGEX_DATABINDING","newParam","realizedFuncParam","parentGet","push","applyScope","declViewModel","inputDataToUpdate","functionsList","dataCtxNode","depModuleObj","isValidModelAndDataCtxNode","forEach","propValue","propName","propValueType","results","newVal","test","val2","ctx","undefined","warn","startsWith","functionName","replace","apply","value","key","deps","includes","_internal","dataParseDefinitions","parseDefName","dynmData","get","processDataParseDefination","val","getConstant","ports","resolvedInput","info","charAt","substr","instance","i18n","data","getOutput","response","inputExpression","expression","getStringBetweenDoubleMustaches","functions","unshift","funcDependancies","Object","keys","index","jsonStringVariable","jsonString","parseJsonString","isString","applyExpression","adaptedPromises","paramVal","paramKey","$adapt","input","Array","isArray","path","adaptPlaceHolder","paramPath","paramValArray","JSON","stringify","getAdaptedObjects","isFullyAdapted","all","then","resultVal","resultKey","resultKeyObj","parse","assignedValues","resultObj"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/declarativeDataCtxService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to manage AngularJS Scope\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/declarativeDataCtxService\n */\nimport dynamicPropertySvc from 'js/dynamicPropertyService';\nimport awConstantsSvc from 'js/awConstantsService';\nimport AwInterpolateService from 'js/awInterpolateService';\nimport adapterService from 'js/adapterService';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport logger from 'js/logger';\n\n/**\n * Cached reference to dependent services\n */\n\n/**\n * Cached reference to adapter service\n */\n\n/**\n * {Boolean} TRUE if use of the $interpolate API should be logged.\n */\nvar _debug_logInterpolatingActivity;\n\n/**\n * {Boolean} TRUE if we are NOT able to find a property on the $scope when referenced in a data binding expression.\n */\nvar _debug_logMissingProperties;\n\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\nvar exports = {};\nvar parametersList = function( funcToCall, $scope ) {\n    var funcParams = funcToCall.parameters;\n    var params = [];\n    var i;\n    if( funcParams ) {\n        for( i = 0; i < funcParams.length; i++ ) {\n            var param = funcParams[ i ];\n\n            var results2 = param.match( parsingUtils.REGEX_DATABINDING );\n\n            if( results2 && results2.length === 4 ) {\n                var newParam = results2[ 2 ];\n\n                var realizedFuncParam = parsingUtils.parentGet( $scope, newParam );\n\n                params.push( realizedFuncParam );\n            } else {\n                params.push( param );\n            }\n        }\n    }\n    return params;\n};\n\n/**\n * Apply the scope object of the input.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {Object} inputDataToUpdate - The 'inputData' from an 'action' who's properties are to be updated with\n *            current values from the 'declViewModel' and/or dependent function calls.\n *\n * @param {Object} functionsList - List of functions read from JSON\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n */\nexport let applyScope = function( declViewModel, inputDataToUpdate, functionsList, dataCtxNode, depModuleObj ) {\n    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        return;\n    }\n\n    assert( inputDataToUpdate, 'Missing \"inputDataToUpdate\" parameter' );\n\n    // eslint-disable-next-line consistent-return\n    _.forEach( inputDataToUpdate, function( propValue, propName ) { // eslint-disable-line complexity\n        if( !propValue ) {\n            return true;\n        }\n\n        var propValueType = typeof propValue;\n\n        /**\n         * Check if propValue is undefined or a simple string\n         */\n        if( propValueType === 'string' ) {\n            /**\n             * Check if it is a replacement case\n             * <P>\n             * Note: The regex will only extract 4 segments w/the following for [1] & [3]<BR>\n             * results[1] === '{{' && results[3] === '}}'\n             */\n            var results = propValue.match( parsingUtils.REGEX_DATABINDING );\n\n            if( results && results.length === 4 ) {\n                var newVal = results[ 2 ];\n\n                if( !/^(function:|dataParseDefinitions:|Constants.|ports:|dragAndDropParams)/.test( newVal ) ) {\n                    // dataCtxNode.ctx is always old,\n                    // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/504\n                    // var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n                    var val2 = parsingUtils.parentGet( { ...dataCtxNode, ctx: { ...dataCtxNode.ctx, ...appCtxService.ctx } }, newVal );\n\n                    inputDataToUpdate[ propName ] = val2;\n\n                    if( _debug_logMissingProperties && val2 === undefined ) {\n                        logger.warn( 'Unable to find property on the current $scope: ' + newVal );\n                    }\n                } else if( _.startsWith( newVal, 'dragAndDropParams' ) ) {\n                    var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\n                    inputDataToUpdate[ propName ] = val2;\n                } else if( _.startsWith( newVal, 'function:' ) ) {\n                    var functionName = newVal.replace( 'function:', '' );\n                    var funcToCall = functionsList[ functionName ];\n                    if( !funcToCall ) {\n                        assert( funcToCall, 'Missing function: ' + functionName );\n                    }\n                    var params = parametersList( funcToCall, dataCtxNode );\n\n                    if( depModuleObj ) {\n                        if( depModuleObj[ funcToCall.functionName ] ) {\n                            inputDataToUpdate[ propName ] = depModuleObj[ funcToCall.functionName ]\n                                .apply( depModuleObj, params );\n                        } else {\n                            _.forEach( depModuleObj, function( value, key ) {\n                                if( funcToCall.deps.includes( key ) ) {\n                                    inputDataToUpdate[ propName ] = depModuleObj[ key ][ funcToCall.functionName ]\n                                        .apply( depModuleObj[ key ], params );\n                                }\n                            } );\n                        }\n                    } else {\n                        inputDataToUpdate[ propName ] = undefined;\n                    }\n                } else if( _.startsWith( newVal, 'dataParseDefinitions:' ) ) {\n                    if( declViewModel._internal.dataParseDefinitions ) {\n                        var parseDefName = newVal.replace( 'dataParseDefinitions:', '' );\n                        var dynmData = _.get( declViewModel._internal.dataParseDefinitions, parseDefName );\n                        if( dynmData ) {\n                            inputDataToUpdate[ propName ] = dynamicPropertySvc.processDataParseDefination( dynmData,\n                                dataCtxNode );\n                        }\n                    }\n                } else if( _.startsWith( newVal, 'Constants.' ) ) {\n                    var val = awConstantsSvc.getConstant( newVal );\n                    if( val ) {\n                        inputDataToUpdate[ propName ] = val;\n                    }\n                } else if( _.startsWith( newVal, 'ports:' ) ) {\n                    if( declViewModel._internal.ports ) {\n                        var resolvedInput = _.get( declViewModel._internal.ports, newVal.replace( 'ports:', '' ) );\n                        if( resolvedInput ) {\n                            inputDataToUpdate[ propName ] = resolvedInput;\n                        }\n                    }\n                }\n            } else if( propValue === 'undefined' ) {\n                inputDataToUpdate[ propName ] = undefined;\n            } else if( propValue.match( /\\{\\{.*}}/g ) ) {\n                if( _debug_logInterpolatingActivity ) {\n                    logger.info( 'Interpolating ' + propName + ': ' + propValue );\n                }\n                // If * was used to intentionally trigger interpolation remove it\n                if( propValue.charAt( 0 ) === '*' ) {\n                    propValue = propValue.substr( 1 );\n                }\n                inputDataToUpdate[ propName ] = AwInterpolateService.instance( propValue )( { ...dataCtxNode, i18n: dataCtxNode.data.i18n } );\n            }\n        } else if( propValueType === 'object' ) {\n            /**\n             * Recurse to handle lower levels of {{ }} replacements\n             */\n            exports.applyScope( declViewModel, propValue, functionsList, dataCtxNode, depModuleObj );\n        } else {\n            return true;\n        }\n        return undefined;\n    } );\n};\n\n/**\n * Resolve a specific response value based on the input parameters.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to process response into.\n *\n * @param {Object} response - The 'response' from a previous operation that will be used to determine the returned\n *            value based on the given input expression..\n *\n * @param {String} inputExpression - The expression that identifies where/how to determine the returned value (e.g.\n *            \"{{function:processTemplates}}\" \"{{templatesOutput[0].workflowTemplates}}\",\n *            \"{{dataParseDefinitions:xxxxxxxx}}\")\n *\n * @param {Object} depModuleObj - Module object that contains any functions to execute based on the\n *            'inputExpression' contents.\n * @param {Object} dataCtxNode - localContext\n *\n * @return {Object} The resolved value based on the given input parameters.\n */\nexport let getOutput = function( declViewModel, response, inputExpression, depModuleObj, dataCtxNode ) {\n    var expression = parsingUtils.getStringBetweenDoubleMustaches( inputExpression );\n\n    if( _.startsWith( expression, 'function:' ) ) {\n        var functionName = expression.replace( 'function:', '' );\n        var functionsList = declViewModel._internal.functions;\n        if( functionsList ) {\n            var funcToCall = functionsList[ functionName ];\n\n            if( !funcToCall ) {\n                return depModuleObj[ functionName ]( response );\n            }\n            var params = parametersList( funcToCall, dataCtxNode );\n            params.unshift( response );\n            // evaluate function\n            if( depModuleObj && depModuleObj[ funcToCall.functionName ] ) {\n                return depModuleObj[ funcToCall.functionName ].apply( depModuleObj, params );\n            } else if( depModuleObj ) {\n                var funcDependancies = Object.keys( depModuleObj );\n                for( var index = 0; index < funcDependancies.length; index++ ) {\n                    var key = funcDependancies[ index ];\n                    if( funcToCall.deps && funcToCall.deps.includes( key ) ) {\n                        return depModuleObj[ key ][ funcToCall.functionName ].apply( depModuleObj, params );\n                    }\n                }\n            }\n        }\n        // evaluate function\n        return depModuleObj[ functionName ]( response );\n    } else if( _.startsWith( expression, 'dataParseDefinitions:' ) ) {\n        if( declViewModel._internal.dataParseDefinitions ) {\n            var parseDefName = expression.replace( 'dataParseDefinitions:', '' );\n\n            var dynmData = _.get( declViewModel._internal.dataParseDefinitions, parseDefName );\n\n            if( dynmData ) {\n                return dynamicPropertySvc.processDataParseDefination( dynmData, declViewModel, response );\n            }\n        }\n    } else if( _.startsWith( expression, 'json:' ) ) {\n        var jsonStringVariable = expression.replace( 'json:', '' );\n        var jsonString = _.get( response, jsonStringVariable );\n        return parsingUtils.parseJsonString( jsonString );\n    }\n\n    if( _.isString( inputExpression ) ) {\n        return _.get( response, inputExpression );\n    }\n    // support plain primitive JavaScript type in expression\n    return inputExpression;\n};\n\n/**\n * Apply an expression object of inout.\n *\n * @param {Object} inputDataToUpdate - The object containing an expression.(e.g. \"$adapt\" : \"{{ctx.mselected}}\")\n *\n * @return {Promise} A promise object resolved with the results of the action.\n */\nexport let applyExpression = function( inputDataToUpdate ) {\n    var adaptedPromises = {};\n    if( inputDataToUpdate ) {\n        _.forEach( inputDataToUpdate, function( paramVal, paramKey ) {\n            if( typeof paramVal === 'object' && paramVal && paramVal.$adapt !== undefined ) {\n                var input = [];\n                if( Array.isArray( paramVal.$adapt ) ) {\n                    input = paramVal.$adapt;\n                } else {\n                    input.push( paramVal.$adapt );\n                }\n                var path = null;\n                if( paramVal.path !== undefined ) {\n                    path = paramVal.path;\n                }\n                var adaptPlaceHolder = {\n                    paramKey: paramKey,\n                    paramPath: path,\n                    paramValArray: Array.isArray( paramVal.$adapt )\n                };\n                adaptedPromises[ JSON.stringify( adaptPlaceHolder ) ] = adapterService.getAdaptedObjects( input, paramVal.isFullyAdapted );\n            }\n        } );\n    } else {\n        inputDataToUpdate = {};\n    }\n\n    return AwPromiseService.instance.all( adaptedPromises ).then( function( results ) {\n        _.forEach( results, function( resultVal, resultKey ) {\n            var resultKeyObj = JSON.parse( resultKey );\n            if( resultVal && resultVal.length > 0 ) {\n                if( resultKeyObj.paramPath ) {\n                    var assignedValues = [];\n                    _.forEach( resultVal, function( resultObj ) {\n                        assignedValues.push( _.get( resultObj, resultKeyObj.paramPath ) );\n                    } );\n                    inputDataToUpdate[ resultKeyObj.paramKey ] =\n                        resultKeyObj.paramValArray ? assignedValues : assignedValues[ 0 ];\n                } else {\n                    inputDataToUpdate[ resultKeyObj.paramKey ] = resultKeyObj.paramValArray ? resultVal : resultVal[ 0 ];\n                }\n            } else {\n                delete inputDataToUpdate[ resultKeyObj.paramKey ];\n            }\n        } );\n        return;\n    } );\n};\n\nexports = {\n    applyScope,\n    getOutput,\n    applyExpression\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}