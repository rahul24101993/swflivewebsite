{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Command service to manage commands.\n *\n * @module js/command.service\n *\n * @namespace commandService\n */\nimport appCtxService from 'js/appCtxService';\nimport preferenceService from 'soa/preferenceService';\nimport { getCommand as getCommandInternal, getCommands as getCommandsInternal } from './commandConfigurationService';\nimport conditionService from 'js/conditionService';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition, parseStringCondition } from 'js/conditionParser.service';\nimport { concat, flatten, get, uniq } from 'lodash';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\n/**\n  * Get a function to check if a command should be visible in the given workspace\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @returns {Function} Function to determine if command should be visible\n  */\n\nconst getWorkspaceCommandValidator = function () {\n  let workspace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (workspace.workspaceType === 'Exclusive') {\n    const {\n      includedCommands,\n      excludedCommands\n    } = workspace;\n\n    if (includedCommands && excludedCommands) {\n      return command => includedCommands.includes(command.id) && !excludedCommands.includes(command.id);\n    } else if (includedCommands) {\n      return command => includedCommands.includes(command.id);\n    } else if (excludedCommands) {\n      return command => !excludedCommands.includes(command.id);\n    }\n  } //if not exclusive workspace don't filter commands\n\n\n  return () => true;\n};\n/**\n  * Filter any commands that should be hidden based on the given workspace and preference\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @param {[String]} hiddenCommandPreference Hidden command preference value\n  * @returns {Function} Function to determine if the command should be visible\n  */\n\n\nconst filterHiddenCommands = function (workspace, hiddenCommandPreference) {\n  const isValidWorkspaceCommand = getWorkspaceCommandValidator(workspace);\n  return command => !hiddenCommandPreference.includes(command.id) && isValidWorkspaceCommand(command);\n};\n/**\n  * Get the command overlays for the commands matching the given inputs. Calls the getCommands method on each\n  * contributed provider and then return the aggregate result.\n  *\n  * @function getCommands\n  * @memberOf commandService\n  * @param {String} commandAreaNameTokens - Comma separated list of command area name tokens, eg. Navigation, Onestep, etc\n  * @param {Object} context - Additional context to use in command evaluation\n  * @param {Object} commandStateUpdater - A hook to update the command state\n  *\n  * @return {Promise} A promise containing the array of command overlays\n  */\n\n\nexport const getCommands = async function (commandAreaNameTokens) {\n  const overlays = await getCommandsInternal(commandAreaNameTokens);\n  const hiddenCommandPreference = await preferenceService.getStringValues('AWC_HiddenCommands');\n  const workspace = appCtxService.getCtx('workspace');\n  return overlays.filter(filterHiddenCommands(workspace, hiddenCommandPreference || []));\n};\n/**\n  * Get a CommandOverlay for the given command.\n  *\n  * @function getCommand\n  * @memberOf commandService\n  * @param {String} commandId - Command id\n  * @return {CommandOverlay} The unresolved overlay for the command\n  */\n\nexport const getCommand = getCommandInternal;\n/**\n  * Get the command for the command with the given commandId and executes it if it is visible\n  *\n  * @function executeCommandIfVisibleAndEnabled\n  * @memberOf commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {Object} commandContext - Additional context to use in command evaluation\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\n\nexport const executeCommandIfVisibleAndEnabled = async function (commandId, commandContext, runActionWithViewModel) {\n  if (!runActionWithViewModel) {\n    return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');\n  }\n\n  const command = await getCommand(commandId);\n  const scope = {\n    ctx: appCtxService.ctx,\n    commandContext: { ...commandContext\n    }\n  };\n  const commandRender = getCommandRender(scope, command);\n  return commandRender.visible ? commandRender.execute(runActionWithViewModel) : Promise.resolve();\n};\n/**\n  * Execute a command with the given arguments\n  *\n  * @function executeCommand\n  * @memberof commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {String|String[]} commandArgs - (Optional) (Deprecated) Command arguments. Should only be used for GWT commands.\n  * @param {Object} context - (Optional) Context to execute the command in. Required for zero compile commands.\n  * @param {Object} commandContext - (Optional) (Deprecated) Additional data to set into context. Should not be used.\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\n\nexport const executeCommand = async function (commandId, commandArgs, context) {\n  let commandContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let runActionWithViewModel = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!runActionWithViewModel) {\n    return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');\n  }\n\n  const command = await getCommand(commandId);\n  const scope = {\n    ctx: appCtxService.ctx,\n    ...context,\n    commandContext: {\n      commandArgs,\n      ...commandContext\n    }\n  };\n  const commandRender = getCommandRender(scope, command);\n  return commandRender.execute(runActionWithViewModel);\n};\n/**************************** CommandRender creation logic ****************************/\n\n/**\n  * All of the data that AwCommand needs to render a command\n  *\n  * All properties should be the \"end result\" that AwCommand can directly use. For example\n  * \"title\" can be either \"title\" or \"selectedTitle\" based on selection state and\n  * \"hasPopup\" can be true or false for group commands depending on child command states\n  *\n  * @param {Object} info Command display information\n  * @param {CommandHandler} handler The current handler for the command\n  * @param {Object} state The current state of the command\n  * @param {Object} scope The evaluation context this result was computed in\n  */\n\nconst CommandRender = function (_ref, handler, _ref2, scope) {\n  let {\n    id,\n    title = '',\n    description = '',\n    icon = '',\n    extendedTooltip,\n    decorator,\n    cellDisplay = null\n  } = _ref;\n  let {\n    hasPopup,\n    visible,\n    enabled,\n    selected\n  } = _ref2;\n\n  /**\n    * ID of the command\n    */\n  this.id = id;\n  /**\n    * The handler that is currently active for this command\n    */\n\n  this.handler = handler;\n  /**\n    * (Optional) The evaluated title of the command\n    */\n\n  this.title = typeof title === 'string' ? title : null;\n  /**\n    * (Optional) The evaluated description of the command\n    */\n\n  this.description = description;\n  /**\n    * (Optional) ID of the icon currently used\n    */\n\n  this.icon = icon;\n  /**\n    * (Optional) Evaluated JSX to include in the command display\n    */\n\n  this.decorator = decorator;\n  /**\n    * (Optional) Evaluated extended tooltip configuration\n    */\n\n  this.extendedTooltip = extendedTooltip;\n  /**\n    * (Optional) Cell display information configured on placement\n    */\n\n  this.cellDisplay = cellDisplay;\n  /**\n    * Execute this command in its current state\n    *\n    * @param {Function} runActionWithViewModel View model service api\n    * @param {Object} commandContext Context to execute the command in\n    * @returns {Promise} Promise resolved when execution is complete\n    */\n\n  this.execute = function (runActionWithViewModel, commandContext) {\n    debugService.debug('commands', this.id); // command menus are \"executed\" by AwCommand\n    // enhanced per Cory:\n    //     - cover the case where a ribbon command has been configured to execute a non popup action\n\n    if (this.hasPopup && handler.action.actionType === 'popup') {\n      return handler.action;\n    }\n\n    return handler.execute.apply(handler, [runActionWithViewModel, scope, commandContext]);\n  };\n  /**\n    * Whether this command will open a popup when clicked\n    */\n\n\n  this.hasPopup = hasPopup;\n  /**\n    * Whether this command is currently visible\n    */\n\n  this.visible = visible;\n  /**\n    * Whether this command is currently enabled\n    */\n\n  this.enabled = enabled;\n  /**\n    * Whether this command is currently selected\n    */\n\n  this.selected = selected;\n};\n/**\n  * Sidenav areas that will cause commands to be automatically selected\n  */\n\n\n_c = CommandRender;\nconst supportedPanelAreas = ['activeToolsAndInfoCommand', 'activeNavigationCommand', 'sidenavCommandId'];\n/**\n   * Get the ID of the panel that is currently opened\n   *\n   * @param {Object} scope Evaluation context\n   * @returns {String|null} ID of the opened panel\n   */\n\nconst getActivePanelId = scope => {\n  for (const area of supportedPanelAreas) {\n    if (scope.ctx[area] && scope.ctx[area].commandId) {\n      return scope.ctx[area].commandId;\n    }\n  }\n\n  return null;\n};\n/**\n  * Determine if a command should be currently selected\n  *\n  * @param {Condition} selectWhen Select when condition for the command\n  * @param {String} id Command ID\n  * @param {Object} scope Command evaluation context\n  * @returns {Boolean} Latest state for this command\n  */\n\n\nconst isCommandSelected = function (selectWhen, id, scope) {\n  const activePanelId = getActivePanelId(scope);\n\n  if (selectWhen) {\n    return Boolean(conditionService.evaluateCondition({}, selectWhen.expression, scope));\n  } else if (activePanelId === id) {\n    return true;\n  }\n\n  return false;\n};\n/**\n  * Get a resolver to switch between selected/not selected properties\n  *\n  * @param {String} propName primary property name\n  * @param {String} selectedPropName selected property name\n  * @returns {Function} Resolver method\n  */\n\n\nconst getSelectedPropResolver = (propName, selectedPropName) => {\n  const getResolvedParameters = (command, scope, selected) => {\n    const getParameter = x => {\n      return AwParseService.instance(getStringBetweenDoubleMustaches(x))(scope);\n    };\n\n    if (command[selectedPropName] && selected) {\n      return command[selectedPropName].parameters.map(getParameter);\n    }\n\n    if (command[propName] && command[propName].parameters && propName !== 'decorator') {\n      return command[propName].parameters.map(getParameter);\n    }\n\n    if (command[propName] && command[propName].text && command[propName].text.parameters && propName === 'decorator') {\n      return command[propName].text.parameters.map(getParameter);\n    }\n\n    return [];\n  };\n\n  return (command, scope, selected) => {\n    const parameters = getResolvedParameters(command, scope, selected);\n\n    if (command[selectedPropName] && selected && command[selectedPropName].value) {\n      return command[selectedPropName].value.format(...parameters);\n    }\n\n    if (command[propName] && command[propName].value && propName !== 'decorator') {\n      return command[propName].value.format(...parameters);\n    }\n\n    if (command[propName] && command[propName].text && command[propName].text.value && propName === 'decorator') {\n      return command[propName].text.value.format(...parameters);\n    }\n\n    return '';\n  };\n};\n/**\n  * Get the resolved title for a command\n  */\n\n\nconst getTitle = getSelectedPropResolver('title', 'selectedTitle');\n/**\n  * Get the resolved title for a command\n  */\n\nconst getDescription = getSelectedPropResolver('description', 'selectedDescription');\n/**\n  * Get the resolved decorator for a command\n  */\n\nconst getDecorator = getSelectedPropResolver('decorator', null);\n/**\n  * Get the latest state for a standard command\n  *\n  * Supported command types: BASE, TOGGLE, RIBBON\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\nconst getBaseCommandRender = (scope, command) => {\n  for (const handler of command.handlers) {\n    const isActive = Boolean(conditionService.evaluateCondition({}, handler.activeWhen.expression, scope));\n\n    if (isActive) {\n      command.trace('Active handler is', handler);\n      debugService.debugUpdateHandlerOnCommand(command.id, handler);\n      const enabled = handler.enableWhen ? Boolean(conditionService.evaluateCondition({}, handler.enableWhen.expression, scope)) : true;\n      const selected = isCommandSelected(handler.selectWhen, command.id, scope); //TODO: Check if visibleWhen is required in schema and validate default if not required\n\n      const visible = handler.visibleWhen ? Boolean(conditionService.evaluateCondition({}, handler.visibleWhen.expression, scope)) : true;\n      const id = command.id; //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n\n      const title = getTitle(command, scope, selected);\n      const description = getDescription(command, scope, selected);\n      const icon = command.selectedIcon && selected ? command.selectedIcon : command.icon;\n      const hasPopup = command.type === 'RIBBON';\n      const cellDisplay = command.cellDisplay;\n      const currentTooltip = selected && command.selectedExtendedTooltip ? command.selectedExtendedTooltip : command.extendedTooltip;\n      const decorator = {};\n      decorator.text = getDecorator(command, scope, selected);\n      decorator.className = command.decorator && command.decorator.class ? command.decorator.class : null;\n      decorator.visibleWhen = command.decorator && command.decorator.visibleWhen ? Boolean(conditionService.evaluateCondition({}, command.decorator.visibleWhen.expression, scope)) : true;\n      return new CommandRender({\n        id,\n        description,\n        title,\n        icon,\n        extendedTooltip: currentTooltip,\n        decorator,\n        cellDisplay\n      }, handler, {\n        enabled,\n        selected,\n        visible,\n        hasPopup\n      }, scope);\n    }\n  }\n\n  command.trace('Command has no active handler');\n  return new CommandRender(command, null, {\n    enabled: false,\n    selected: false,\n    visible: false\n  }, scope);\n};\n/**\n  * Get the latest state for a group command\n  *\n  * Supported types: GROUP\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\n\nconst getGroupCommandRender = (scope, command) => {\n  const {\n    showGroupSelected = true\n  } = command;\n  const childCommandStates = command.children.map(child => getCommandRender(scope, child));\n  command.trace('Child command states', childCommandStates);\n  const visibleChildCommands = childCommandStates.filter(x => x.visible);\n  const groupCommandState = visibleChildCommands.reduce((_ref3, childCommandState) => {\n    let {\n      enabled,\n      selected\n    } = _ref3;\n    return {\n      enabled: enabled || childCommandState.enabled,\n      selected: showGroupSelected && (selected || childCommandState.enabled && childCommandState.selected)\n    };\n  }, {\n    enabled: false,\n    selected: false\n  });\n  const id = command.id; //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n\n  const title = getTitle(command, scope, groupCommandState.selected);\n  const description = getDescription(command, scope, groupCommandState.selected);\n  const icon = command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n  const visible = visibleChildCommands.length > 0;\n  const hasPopup = visibleChildCommands.length > 1;\n  return new CommandRender({\n    id,\n    title,\n    description,\n    icon,\n    extendedTooltip: command.extendedTooltip,\n    decorator: null\n  }, visibleChildCommands.length === 1 ? visibleChildCommands[0].handler : command.handlers[0], { ...groupCommandState,\n    hasPopup,\n    visible\n  }, scope);\n};\n/**\n  * Get the latest state for a shuttle command\n  *\n  * Supported types: SHUTTLE\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\n\nconst getShuttleCommandRender = (scope, command) => {\n  // pass into command object\n  // pull show group selected property out of command (shuttle should always be false)\n  const showGroupSelected = false; // pull all child command states (ctx)\n  // throw logic onto child commands pull selected properties\n  // .map call function on specific items that creates new array with result of function\n  // passes child state into getCommandRender\n\n  const childCommandStates = command.children.map(child => getCommandRender(scope, child)); //  find all of the commands that are visible\n  // .filter creates new array (visibleChildCommands) which has commands w/ property visible = true\n\n  const visibleChildCommands = childCommandStates.filter(x => x.visible); // adding selected child commands? find commands that are selected\n  // list of current child commands selected & visible\n  // get first selected child out of filtered list (child command 0)\n\n  const selectedChildCommands = visibleChildCommands.filter(x => x.selected); // groupcommandstate = reduced visible commands, pass to child command state\n\n  const groupCommandState = visibleChildCommands.reduce((_ref4, childCommandState) => {\n    let {\n      enabled\n    } = _ref4;\n    return {\n      enabled: enabled || childCommandState.enabled,\n      selected: showGroupSelected\n    };\n  }, {\n    enabled: false,\n    selected: false\n  });\n  const id = command.id;\n  const firstSelectedChild = selectedChildCommands[0];\n\n  const getShuttleTitle = () => {\n    if (firstSelectedChild) {\n      return firstSelectedChild.title;\n    }\n\n    return getTitle(command, scope, groupCommandState.selected);\n  };\n\n  const getShuttleDescription = () => {\n    //TODO: Should shuttle commands also inherit description?\n    //View mode command with description of a specific view model seems wrong\n    if (firstSelectedChild) {\n      return firstSelectedChild.description;\n    }\n\n    return getDescription(command, scope, groupCommandState.selected);\n  };\n\n  const getShuttleIcon = () => {\n    if (firstSelectedChild) {\n      return firstSelectedChild.icon;\n    }\n\n    return command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n  };\n\n  const getShuttleExtendedTooltip = () => {\n    // If tooltip configured on parent command use that\n    if (command.extendedTooltip) {\n      return command.extendedTooltip;\n    } // If no tooltip and active child has tooltip use that\n\n\n    if (firstSelectedChild && firstSelectedChild.extendedTooltip) {\n      return firstSelectedChild.extendedTooltip;\n    } // If no tooltip and active child does not have tooltip use title/description of child\n\n\n    return null;\n  };\n\n  const title = getShuttleTitle();\n  const description = getShuttleDescription();\n  const icon = getShuttleIcon();\n  const visible = visibleChildCommands.length > 0;\n  const hasPopup = visibleChildCommands.length > 1;\n  return new CommandRender({\n    id,\n    title,\n    description,\n    icon,\n    extendedTooltip: getShuttleExtendedTooltip(),\n    decorator: null\n  }, visibleChildCommands.length === 1 ? visibleChildCommands[0].handler : command.handlers[0], { ...groupCommandState,\n    hasPopup,\n    visible\n  }, scope);\n};\n/**\n  * Map of command type to the render function for it\n  */\n\n\nconst commandTypeToRenderer = {\n  BASE: getBaseCommandRender,\n  RIBBON: getBaseCommandRender,\n  GROUP: getGroupCommandRender,\n  SHUTTLE: getShuttleCommandRender\n};\n/**\n  * Get the latest render data based on the new command state\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {Object} command The unprocessed command data\n  * @returns {CommandRender} Latest render data for the command\n  */\n\nexport const getCommandRender = (scope, command) => {\n  const renderFunction = commandTypeToRenderer[command.type] || commandTypeToRenderer.BASE;\n  command.trace('Getting current command state', scope, command, renderFunction);\n  const renderResult = renderFunction(scope, command);\n  command.trace('Command state', renderResult);\n  debugService.debugCommandRender(command, renderResult);\n  return renderResult;\n};\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\n\nconst getBaseCommandParameters = command => {\n  const staticCommandParameters = ['activeToolsAndInfoCommand.commandId', 'activeNavigationCommand.commandId', 'sidenavCommandId.commandId'];\n  const {\n    ctxParameters: titleParameters,\n    additionalParameters: titleContextParameters\n  } = getCommandI18nParameters(command);\n  return (command.handlers || []).reduce((acc, handler) => {\n    const conditionDeps = [parseCondition(handler.activeWhen), parseCondition(handler.visibleWhen), parseCondition(handler.enableWhen), parseCondition(handler.selectWhen)];\n    return {\n      ctxParameters: uniq(concat(flatten(conditionDeps.map(x => x.ctxParameters)), acc.ctxParameters)),\n      additionalParameters: concat(acc.additionalParameters, flatten(conditionDeps.map(x => x.additionalParameters)))\n    };\n  }, {\n    ctxParameters: [...titleParameters, ...staticCommandParameters],\n    additionalParameters: [command, ...titleContextParameters]\n  });\n};\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\n\n\nconst getGroupCommandParameters = command => {\n  const {\n    ctxParameters: titleParameters,\n    additionalParameters: titleContextParameters\n  } = getCommandI18nParameters(command);\n  return command.children.reduce((acc, child) => {\n    const childParameters = getCommandParameters(child);\n    return {\n      ctxParameters: uniq(concat(childParameters.ctxParameters, acc.ctxParameters)),\n      additionalParameters: concat(acc.additionalParameters, childParameters.additionalParameters)\n    };\n  }, {\n    ctxParameters: [...titleParameters],\n    additionalParameters: [command, ...titleContextParameters]\n  });\n};\n\nconst commandTypeToParameterMapper = {\n  BASE: getBaseCommandParameters,\n  RIBBON: getBaseCommandParameters,\n  GROUP: getGroupCommandParameters,\n  SHUTTLE: getGroupCommandParameters\n};\n/**\n  * Get ctx/other parameters for a property of a command\n  *\n  * @param {CommandOverlay} command command being parsed\n  * @param {String} propName property name\n  * @returns {Object} dependencies\n  */\n\nconst getI18nParameters = (command, propName) => {\n  if (command[propName]) {\n    return command[propName].parameters.reduce((acc, x) => {\n      const {\n        ctxParameters,\n        additionalParameters\n      } = parseStringCondition(x);\n      return {\n        ctxParameters: [...acc.ctxParameters, ...ctxParameters],\n        additionalParameters: [...acc.additionalParameters, ...additionalParameters]\n      };\n    }, {\n      ctxParameters: [],\n      additionalParameters: []\n    });\n  }\n\n  return {\n    ctxParameters: [],\n    additionalParameters: []\n  };\n};\n/**\n  * Get parameters for any localized properties that support \"parameter format\"\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx parameters\n  */\n\n\nconst getCommandI18nParameters = command => {\n  return ['title', 'selectedTitle', 'description', 'selectedDescription'].reduce((acc, propName) => {\n    const {\n      ctxParameters,\n      additionalParameters\n    } = getI18nParameters(command, propName);\n    return {\n      ctxParameters: [...acc.ctxParameters, ...ctxParameters],\n      additionalParameters: [...acc.additionalParameters, ...additionalParameters]\n    };\n  }, {\n    ctxParameters: [],\n    additionalParameters: []\n  });\n};\n/**\n  * Get anything in ctx that this command depends on\n  *\n  * TODO: Additional parameters will need to be \"resolved\" before returning\n  *\n  * @param {CommandOverlay} command Command to get the information for\n  * @returns {List<Path>} List of lodash get paths (array or string)\n  */\n\n\nexport const getCommandParameters = command => (commandTypeToParameterMapper[command.type] || commandTypeToParameterMapper.BASE)(command);\n/**\n  * Get all of the Derived States for the given commands\n  *\n  * @param {Object} vmDef View model definition\n  * @param {Object} props Component properties\n  * @returns {List<DerivedStateResult>} Derived state configurations for commands\n  */\n\nexport const getCommandStates = (vmDef, _ref5) => {\n  let {\n    commandList = [],\n    commandContext = {},\n    visibleServerCommands = {}\n  } = _ref5;\n  const scope = {\n    commandContext,\n    visibleServerCommands\n  }; //The list of \"additionalParameters\" is just strings initially, need to pull actual values from props\n\n  const getFromProps = path => get(scope, path);\n\n  return commandList.map(cmd => {\n    const {\n      ctxParameters,\n      additionalParameters: additionalParametersRefs\n    } = cmd.parameters || getCommandParameters({ ...cmd\n    });\n    cmd.parameters = {\n      ctxParameters,\n      additionalParameters: additionalParametersRefs\n    };\n    const additionalParameters = [additionalParametersRefs[0], ...additionalParametersRefs.slice(1).map(getFromProps)];\n    return new DerivedStateResult({\n      ctxParameters,\n      additionalParameters,\n      compute: _ref6 => {\n        let {\n          ctx\n        } = _ref6;\n        return getCommandRender({\n          commandContext,\n          ctx: { ...ctx,\n            //Fakes visibleServerCommands being in CTX even though it actually local to this command bar\n            visibleServerCommands\n          }\n        }, additionalParameters[0]);\n      }\n    });\n  });\n};\nexport default {\n  getCommands,\n  getCommand,\n  executeCommand,\n  executeCommandIfVisibleAndEnabled\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"CommandRender\");","map":{"version":3,"names":["appCtxService","preferenceService","getCommand","getCommandInternal","getCommands","getCommandsInternal","conditionService","DerivedStateResult","parseCondition","parseStringCondition","concat","flatten","get","uniq","debugService","AwParseService","getStringBetweenDoubleMustaches","getWorkspaceCommandValidator","workspace","workspaceType","includedCommands","excludedCommands","command","includes","id","filterHiddenCommands","hiddenCommandPreference","isValidWorkspaceCommand","commandAreaNameTokens","overlays","getStringValues","getCtx","filter","executeCommandIfVisibleAndEnabled","commandId","commandContext","runActionWithViewModel","Promise","reject","scope","ctx","commandRender","getCommandRender","visible","execute","resolve","executeCommand","commandArgs","context","CommandRender","handler","title","description","icon","extendedTooltip","decorator","cellDisplay","hasPopup","enabled","selected","debug","action","actionType","apply","supportedPanelAreas","getActivePanelId","area","isCommandSelected","selectWhen","activePanelId","Boolean","evaluateCondition","expression","getSelectedPropResolver","propName","selectedPropName","getResolvedParameters","getParameter","x","instance","parameters","map","text","value","format","getTitle","getDescription","getDecorator","getBaseCommandRender","handlers","isActive","activeWhen","trace","debugUpdateHandlerOnCommand","enableWhen","visibleWhen","selectedIcon","type","currentTooltip","selectedExtendedTooltip","className","class","getGroupCommandRender","showGroupSelected","childCommandStates","children","child","visibleChildCommands","groupCommandState","reduce","childCommandState","length","getShuttleCommandRender","selectedChildCommands","firstSelectedChild","getShuttleTitle","getShuttleDescription","getShuttleIcon","getShuttleExtendedTooltip","commandTypeToRenderer","BASE","RIBBON","GROUP","SHUTTLE","renderFunction","renderResult","debugCommandRender","getBaseCommandParameters","staticCommandParameters","ctxParameters","titleParameters","additionalParameters","titleContextParameters","getCommandI18nParameters","acc","conditionDeps","getGroupCommandParameters","childParameters","getCommandParameters","commandTypeToParameterMapper","getI18nParameters","getCommandStates","vmDef","commandList","visibleServerCommands","getFromProps","path","cmd","additionalParametersRefs","slice","compute"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/command.service.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Command service to manage commands.\n *\n * @module js/command.service\n *\n * @namespace commandService\n */\nimport appCtxService from 'js/appCtxService';\nimport preferenceService from 'soa/preferenceService';\nimport { getCommand as getCommandInternal, getCommands as getCommandsInternal } from './commandConfigurationService';\nimport conditionService from 'js/conditionService';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition, parseStringCondition } from 'js/conditionParser.service';\nimport { concat, flatten, get, uniq } from 'lodash';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\n\n/**\n  * Get a function to check if a command should be visible in the given workspace\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @returns {Function} Function to determine if command should be visible\n  */\nconst getWorkspaceCommandValidator = ( workspace = {} ) => {\n    if( workspace.workspaceType === 'Exclusive' ) {\n        const { includedCommands, excludedCommands } = workspace;\n        if( includedCommands && excludedCommands ) {\n            return ( command ) => includedCommands.includes( command.id ) && !excludedCommands.includes( command.id );\n        } else if( includedCommands ) {\n            return ( command ) => includedCommands.includes( command.id );\n        }else if( excludedCommands ) {\n            return ( command ) => !excludedCommands.includes( command.id );\n        }\n    }\n    //if not exclusive workspace don't filter commands\n    return () => true;\n};\n\n/**\n  * Filter any commands that should be hidden based on the given workspace and preference\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @param {[String]} hiddenCommandPreference Hidden command preference value\n  * @returns {Function} Function to determine if the command should be visible\n  */\nconst filterHiddenCommands = function( workspace, hiddenCommandPreference ) {\n    const isValidWorkspaceCommand = getWorkspaceCommandValidator( workspace );\n    return command => !hiddenCommandPreference.includes( command.id ) && isValidWorkspaceCommand( command );\n};\n\n/**\n  * Get the command overlays for the commands matching the given inputs. Calls the getCommands method on each\n  * contributed provider and then return the aggregate result.\n  *\n  * @function getCommands\n  * @memberOf commandService\n  * @param {String} commandAreaNameTokens - Comma separated list of command area name tokens, eg. Navigation, Onestep, etc\n  * @param {Object} context - Additional context to use in command evaluation\n  * @param {Object} commandStateUpdater - A hook to update the command state\n  *\n  * @return {Promise} A promise containing the array of command overlays\n  */\nexport const getCommands = async function( commandAreaNameTokens ) {\n    const overlays = await getCommandsInternal( commandAreaNameTokens );\n    const hiddenCommandPreference = await preferenceService.getStringValues( 'AWC_HiddenCommands' );\n    const workspace = appCtxService.getCtx( 'workspace' );\n    return overlays.filter( filterHiddenCommands( workspace, hiddenCommandPreference || [] ) );\n};\n\n/**\n  * Get a CommandOverlay for the given command.\n  *\n  * @function getCommand\n  * @memberOf commandService\n  * @param {String} commandId - Command id\n  * @return {CommandOverlay} The unresolved overlay for the command\n  */\nexport const getCommand = getCommandInternal;\n\n/**\n  * Get the command for the command with the given commandId and executes it if it is visible\n  *\n  * @function executeCommandIfVisibleAndEnabled\n  * @memberOf commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {Object} commandContext - Additional context to use in command evaluation\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\nexport const executeCommandIfVisibleAndEnabled = async function( commandId, commandContext, runActionWithViewModel ) {\n    if( !runActionWithViewModel ) {\n        return Promise.reject( 'executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component' );\n    }\n    const command = await getCommand( commandId );\n    const scope = {\n        ctx: appCtxService.ctx,\n        commandContext: {\n            ...commandContext\n        }\n    };\n    const commandRender = getCommandRender( scope, command );\n    return commandRender.visible ? commandRender.execute( runActionWithViewModel ) : Promise.resolve();\n};\n\n/**\n  * Execute a command with the given arguments\n  *\n  * @function executeCommand\n  * @memberof commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {String|String[]} commandArgs - (Optional) (Deprecated) Command arguments. Should only be used for GWT commands.\n  * @param {Object} context - (Optional) Context to execute the command in. Required for zero compile commands.\n  * @param {Object} commandContext - (Optional) (Deprecated) Additional data to set into context. Should not be used.\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\nexport const executeCommand = async function( commandId, commandArgs, context, commandContext = {}, runActionWithViewModel ) {\n    if( !runActionWithViewModel ) {\n        return Promise.reject( 'executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component' );\n    }\n    const command = await getCommand( commandId );\n    const scope = {\n        ctx: appCtxService.ctx,\n        ...context,\n        commandContext: {\n            commandArgs,\n            ...commandContext\n        }\n    };\n    const commandRender = getCommandRender( scope, command );\n    return commandRender.execute( runActionWithViewModel );\n};\n\n/**************************** CommandRender creation logic ****************************/\n\n/**\n  * All of the data that AwCommand needs to render a command\n  *\n  * All properties should be the \"end result\" that AwCommand can directly use. For example\n  * \"title\" can be either \"title\" or \"selectedTitle\" based on selection state and\n  * \"hasPopup\" can be true or false for group commands depending on child command states\n  *\n  * @param {Object} info Command display information\n  * @param {CommandHandler} handler The current handler for the command\n  * @param {Object} state The current state of the command\n  * @param {Object} scope The evaluation context this result was computed in\n  */\nconst CommandRender = function( {\n    id,\n    title = '',\n    description = '',\n    icon = '',\n    extendedTooltip,\n    decorator,\n    cellDisplay = null\n}, handler, {\n    hasPopup,\n    visible,\n    enabled,\n    selected\n}, scope ) {\n    /**\n      * ID of the command\n      */\n    this.id = id;\n\n    /**\n      * The handler that is currently active for this command\n      */\n    this.handler = handler;\n\n    /**\n      * (Optional) The evaluated title of the command\n      */\n    this.title = typeof title === 'string' ? title : null;\n\n    /**\n      * (Optional) The evaluated description of the command\n      */\n    this.description = description;\n\n    /**\n      * (Optional) ID of the icon currently used\n      */\n    this.icon = icon;\n\n    /**\n      * (Optional) Evaluated JSX to include in the command display\n      */\n    this.decorator = decorator;\n\n    /**\n      * (Optional) Evaluated extended tooltip configuration\n      */\n    this.extendedTooltip = extendedTooltip;\n\n    /**\n      * (Optional) Cell display information configured on placement\n      */\n    this.cellDisplay = cellDisplay;\n\n    /**\n      * Execute this command in its current state\n      *\n      * @param {Function} runActionWithViewModel View model service api\n      * @param {Object} commandContext Context to execute the command in\n      * @returns {Promise} Promise resolved when execution is complete\n      */\n    this.execute = function( runActionWithViewModel, commandContext ) {\n        debugService.debug( 'commands', this.id );\n        // command menus are \"executed\" by AwCommand\n        // enhanced per Cory:\n        //     - cover the case where a ribbon command has been configured to execute a non popup action\n        if( this.hasPopup && handler.action.actionType === 'popup' ) {\n            return handler.action;\n        }\n        return handler.execute.apply( handler, [ runActionWithViewModel, scope, commandContext ] );\n    };\n\n    /**\n      * Whether this command will open a popup when clicked\n      */\n    this.hasPopup = hasPopup;\n\n    /**\n      * Whether this command is currently visible\n      */\n    this.visible = visible;\n\n    /**\n      * Whether this command is currently enabled\n      */\n    this.enabled = enabled;\n\n    /**\n      * Whether this command is currently selected\n      */\n    this.selected = selected;\n};\n\n/**\n  * Sidenav areas that will cause commands to be automatically selected\n  */\nconst supportedPanelAreas = [ 'activeToolsAndInfoCommand', 'activeNavigationCommand', 'sidenavCommandId' ];\n\n/**\n   * Get the ID of the panel that is currently opened\n   *\n   * @param {Object} scope Evaluation context\n   * @returns {String|null} ID of the opened panel\n   */\nconst getActivePanelId = ( scope ) => {\n    for( const area of supportedPanelAreas ) {\n        if( scope.ctx[area] && scope.ctx[area].commandId ) {\n            return scope.ctx[area].commandId;\n        }\n    }\n    return null;\n};\n\n/**\n  * Determine if a command should be currently selected\n  *\n  * @param {Condition} selectWhen Select when condition for the command\n  * @param {String} id Command ID\n  * @param {Object} scope Command evaluation context\n  * @returns {Boolean} Latest state for this command\n  */\nconst isCommandSelected = function( selectWhen, id, scope ) {\n    const activePanelId = getActivePanelId( scope );\n    if( selectWhen ) {\n        return Boolean( conditionService.evaluateCondition( {}, selectWhen.expression, scope ) );\n    } else if( activePanelId === id ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n  * Get a resolver to switch between selected/not selected properties\n  *\n  * @param {String} propName primary property name\n  * @param {String} selectedPropName selected property name\n  * @returns {Function} Resolver method\n  */\nconst getSelectedPropResolver = ( propName, selectedPropName ) => {\n    const getResolvedParameters = ( command, scope, selected ) => {\n        const getParameter = x => {\n            return AwParseService.instance( getStringBetweenDoubleMustaches( x ) )( scope );\n        };\n        if ( command[selectedPropName] && selected ) {\n            return command[selectedPropName].parameters.map( getParameter );\n        }\n        if ( command[propName] && command[propName].parameters && propName !== 'decorator' ) {\n            return command[propName].parameters.map( getParameter );\n        }\n        if ( command[propName] && command[propName].text && command[propName].text.parameters && propName === 'decorator' ) {\n            return command[propName].text.parameters.map( getParameter );\n        }\n        return [];\n    };\n    return ( command, scope, selected ) => {\n        const parameters = getResolvedParameters( command, scope, selected );\n        if ( command[selectedPropName] && selected && command[selectedPropName].value ) {\n            return command[selectedPropName].value.format( ...parameters );\n        }\n        if ( command[propName] && command[propName].value && propName !== 'decorator' ) {\n            return command[propName].value.format( ...parameters );\n        }\n        if ( command[propName] && command[propName].text && command[propName].text.value && propName === 'decorator' ) {\n            return command[propName].text.value.format( ...parameters );\n        }\n        return '';\n    };\n};\n\n/**\n  * Get the resolved title for a command\n  */\nconst getTitle = getSelectedPropResolver( 'title', 'selectedTitle' );\n\n/**\n  * Get the resolved title for a command\n  */\nconst getDescription = getSelectedPropResolver( 'description', 'selectedDescription' );\n\n/**\n  * Get the resolved decorator for a command\n  */\nconst getDecorator = getSelectedPropResolver( 'decorator', null );\n\n/**\n  * Get the latest state for a standard command\n  *\n  * Supported command types: BASE, TOGGLE, RIBBON\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getBaseCommandRender = ( scope, command ) => {\n    for( const handler of command.handlers ) {\n        const isActive = Boolean( conditionService.evaluateCondition( {}, handler.activeWhen.expression, scope ) );\n        if( isActive ) {\n            command.trace( 'Active handler is', handler );\n            debugService.debugUpdateHandlerOnCommand( command.id, handler );\n            const enabled = handler.enableWhen ? Boolean( conditionService.evaluateCondition( {}, handler.enableWhen.expression, scope ) ) : true;\n            const selected = isCommandSelected( handler.selectWhen, command.id, scope );\n            //TODO: Check if visibleWhen is required in schema and validate default if not required\n            const visible = handler.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, handler.visibleWhen.expression, scope ) ) : true;\n            const id = command.id;\n            //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n            const title = getTitle( command, scope, selected );\n            const description = getDescription( command, scope, selected );\n            const icon = command.selectedIcon && selected ? command.selectedIcon : command.icon;\n            const hasPopup = command.type === 'RIBBON';\n            const cellDisplay = command.cellDisplay;\n            const currentTooltip = selected && command.selectedExtendedTooltip ? command.selectedExtendedTooltip : command.extendedTooltip;\n            const decorator = {};\n            decorator.text =  getDecorator( command, scope, selected );\n            decorator.className = command.decorator && command.decorator.class ? command.decorator.class : null;\n            decorator.visibleWhen = command.decorator && command.decorator.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, command.decorator.visibleWhen.expression, scope ) ) : true;\n\n            return new CommandRender( {\n                id,\n                description,\n                title,\n                icon,\n                extendedTooltip: currentTooltip,\n                decorator,\n                cellDisplay\n            }, handler, {\n                enabled,\n                selected,\n                visible,\n                hasPopup\n            }, scope );\n        }\n    }\n    command.trace( 'Command has no active handler' );\n    return new CommandRender( command, null, {\n        enabled: false,\n        selected: false,\n        visible: false\n    }, scope );\n};\n\n/**\n  * Get the latest state for a group command\n  *\n  * Supported types: GROUP\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getGroupCommandRender = ( scope, command ) => {\n    const { showGroupSelected = true } = command;\n    const childCommandStates = command.children.map( child => getCommandRender( scope, child ) );\n    command.trace( 'Child command states', childCommandStates );\n    const visibleChildCommands = childCommandStates.filter( x => x.visible );\n    const groupCommandState = visibleChildCommands.reduce( ( { enabled, selected }, childCommandState ) => {\n        return {\n            enabled: enabled || childCommandState.enabled,\n            selected: showGroupSelected && ( selected || childCommandState.enabled && childCommandState.selected )\n        };\n    }, {\n        enabled: false,\n        selected: false\n    } );\n    const id = command.id;\n    //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n    const title = getTitle( command, scope, groupCommandState.selected );\n    const description = getDescription( command, scope, groupCommandState.selected );\n    const icon = command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n    const visible = visibleChildCommands.length > 0;\n    const hasPopup = visibleChildCommands.length > 1;\n    return new CommandRender( {\n        id,\n        title,\n        description,\n        icon,\n        extendedTooltip: command.extendedTooltip,\n        decorator: null\n    }, visibleChildCommands.length === 1 ? visibleChildCommands[ 0 ].handler : command.handlers[ 0 ], {\n        ...groupCommandState,\n        hasPopup,\n        visible\n    }, scope );\n};\n\n/**\n  * Get the latest state for a shuttle command\n  *\n  * Supported types: SHUTTLE\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getShuttleCommandRender = ( scope, command ) => {\n    // pass into command object\n    // pull show group selected property out of command (shuttle should always be false)\n    const showGroupSelected = false;\n    // pull all child command states (ctx)\n    // throw logic onto child commands pull selected properties\n    // .map call function on specific items that creates new array with result of function\n    // passes child state into getCommandRender\n    const childCommandStates = command.children.map( child => getCommandRender( scope, child ) );\n    //  find all of the commands that are visible\n    // .filter creates new array (visibleChildCommands) which has commands w/ property visible = true\n    const visibleChildCommands = childCommandStates.filter( x => x.visible );\n    // adding selected child commands? find commands that are selected\n    // list of current child commands selected & visible\n    // get first selected child out of filtered list (child command 0)\n    const selectedChildCommands = visibleChildCommands.filter( x => x.selected );\n    // groupcommandstate = reduced visible commands, pass to child command state\n    const groupCommandState = visibleChildCommands.reduce( ( { enabled }, childCommandState ) => {\n        return {\n            enabled: enabled || childCommandState.enabled,\n            selected: showGroupSelected\n        };\n    }, {\n        enabled: false,\n        selected: false\n    } );\n\n    const id = command.id;\n    const firstSelectedChild = selectedChildCommands[ 0 ];\n\n    const getShuttleTitle = () => {\n        if( firstSelectedChild ) {\n            return firstSelectedChild.title;\n        }\n        return getTitle( command, scope, groupCommandState.selected );\n    };\n    const getShuttleDescription = () => {\n        //TODO: Should shuttle commands also inherit description?\n        //View mode command with description of a specific view model seems wrong\n        if( firstSelectedChild ) {\n            return firstSelectedChild.description;\n        }\n        return getDescription( command, scope, groupCommandState.selected );\n    };\n    const getShuttleIcon = () => {\n        if( firstSelectedChild ) {\n            return firstSelectedChild.icon;\n        }\n        return command.selectedIcon && groupCommandState.selected ?\n            command.selectedIcon :\n            command.icon;\n    };\n    const getShuttleExtendedTooltip = () => {\n        // If tooltip configured on parent command use that\n        if( command.extendedTooltip ) {\n            return command.extendedTooltip;\n        }\n        // If no tooltip and active child has tooltip use that\n        if( firstSelectedChild && firstSelectedChild.extendedTooltip ) {\n            return firstSelectedChild.extendedTooltip;\n        }\n        // If no tooltip and active child does not have tooltip use title/description of child\n        return null;\n    };\n    const title = getShuttleTitle();\n    const description = getShuttleDescription();\n    const icon = getShuttleIcon();\n\n    const visible = visibleChildCommands.length > 0;\n    const hasPopup = visibleChildCommands.length > 1;\n    return new CommandRender( {\n        id,\n        title,\n        description,\n        icon,\n        extendedTooltip: getShuttleExtendedTooltip(),\n        decorator: null\n    }, visibleChildCommands.length === 1 ? visibleChildCommands[ 0 ].handler : command.handlers[ 0 ], {\n        ...groupCommandState,\n        hasPopup,\n        visible\n    }, scope );\n};\n\n/**\n  * Map of command type to the render function for it\n  */\nconst commandTypeToRenderer = {\n    BASE: getBaseCommandRender,\n    RIBBON: getBaseCommandRender,\n    GROUP: getGroupCommandRender,\n    SHUTTLE: getShuttleCommandRender\n};\n\n/**\n  * Get the latest render data based on the new command state\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {Object} command The unprocessed command data\n  * @returns {CommandRender} Latest render data for the command\n  */\nexport const getCommandRender = ( scope, command ) => {\n    const renderFunction = commandTypeToRenderer[ command.type ] || commandTypeToRenderer.BASE;\n    command.trace( 'Getting current command state', scope, command, renderFunction );\n    const renderResult = renderFunction( scope, command );\n    command.trace( 'Command state', renderResult );\n    debugService.debugCommandRender( command, renderResult );\n    return renderResult;\n};\n\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\nconst getBaseCommandParameters = ( command ) => {\n    const staticCommandParameters = [ 'activeToolsAndInfoCommand.commandId', 'activeNavigationCommand.commandId', 'sidenavCommandId.commandId' ];\n\n    const {\n        ctxParameters: titleParameters,\n        additionalParameters: titleContextParameters\n    } = getCommandI18nParameters( command );\n    return ( command.handlers || [] ).reduce( ( acc, handler ) => {\n        const conditionDeps = [\n            parseCondition( handler.activeWhen ),\n            parseCondition( handler.visibleWhen ),\n            parseCondition( handler.enableWhen ),\n            parseCondition( handler.selectWhen )\n        ];\n        return {\n            ctxParameters: uniq( concat( flatten( conditionDeps.map( x => x.ctxParameters ) ), acc.ctxParameters ) ),\n            additionalParameters: concat( acc.additionalParameters, flatten( conditionDeps.map( x => x.additionalParameters ) ) )\n        };\n    }, {\n        ctxParameters: [ ...titleParameters, ...staticCommandParameters ],\n        additionalParameters: [ command, ...titleContextParameters  ]\n    } );\n};\n\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\nconst getGroupCommandParameters = ( command ) => {\n    const {\n        ctxParameters: titleParameters,\n        additionalParameters: titleContextParameters\n    } = getCommandI18nParameters( command );\n    return command.children.reduce( ( acc, child ) => {\n        const childParameters = getCommandParameters( child );\n        return {\n            ctxParameters: uniq( concat( childParameters.ctxParameters, acc.ctxParameters ) ),\n            additionalParameters: concat( acc.additionalParameters, childParameters.additionalParameters )\n        };\n    }, {\n        ctxParameters: [ ...titleParameters ],\n        additionalParameters: [ command, ...titleContextParameters ]\n    } );\n};\n\nconst commandTypeToParameterMapper = {\n    BASE: getBaseCommandParameters,\n    RIBBON: getBaseCommandParameters,\n    GROUP: getGroupCommandParameters,\n    SHUTTLE: getGroupCommandParameters\n};\n\n/**\n  * Get ctx/other parameters for a property of a command\n  *\n  * @param {CommandOverlay} command command being parsed\n  * @param {String} propName property name\n  * @returns {Object} dependencies\n  */\nconst getI18nParameters = ( command, propName ) => {\n    if( command[propName] ) {\n        return command[propName].parameters.reduce( ( acc, x ) => {\n            const {\n                ctxParameters,\n                additionalParameters\n            } = parseStringCondition( x );\n            return {\n                ctxParameters: [ ...acc.ctxParameters, ...ctxParameters ],\n                additionalParameters: [ ...acc.additionalParameters, ...additionalParameters ]\n            };\n        }, {\n            ctxParameters: [],\n            additionalParameters: []\n        } );\n    }\n    return {\n        ctxParameters: [],\n        additionalParameters: []\n    };\n};\n\n/**\n  * Get parameters for any localized properties that support \"parameter format\"\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx parameters\n  */\nconst getCommandI18nParameters = ( command ) => {\n    return [ 'title', 'selectedTitle', 'description', 'selectedDescription' ].reduce( ( acc, propName ) => {\n        const {\n            ctxParameters,\n            additionalParameters\n        } = getI18nParameters( command, propName );\n        return {\n            ctxParameters: [ ...acc.ctxParameters, ...ctxParameters ],\n            additionalParameters: [ ...acc.additionalParameters, ...additionalParameters ]\n        };\n    }, {\n        ctxParameters: [],\n        additionalParameters: []\n    } );\n};\n\n/**\n  * Get anything in ctx that this command depends on\n  *\n  * TODO: Additional parameters will need to be \"resolved\" before returning\n  *\n  * @param {CommandOverlay} command Command to get the information for\n  * @returns {List<Path>} List of lodash get paths (array or string)\n  */\nexport const getCommandParameters = ( command ) => ( commandTypeToParameterMapper[ command.type ] || commandTypeToParameterMapper.BASE )( command );\n\n/**\n  * Get all of the Derived States for the given commands\n  *\n  * @param {Object} vmDef View model definition\n  * @param {Object} props Component properties\n  * @returns {List<DerivedStateResult>} Derived state configurations for commands\n  */\nexport const getCommandStates = ( vmDef, { commandList = [], commandContext = {}, visibleServerCommands = {} } ) => {\n    const scope = {\n        commandContext,\n        visibleServerCommands\n    };\n    //The list of \"additionalParameters\" is just strings initially, need to pull actual values from props\n    const getFromProps = ( path ) => get( scope, path );\n    return commandList.map( cmd => {\n        const {\n            ctxParameters,\n            additionalParameters: additionalParametersRefs\n        } = cmd.parameters || getCommandParameters( { ...cmd } );\n        cmd.parameters = {\n            ctxParameters,\n            additionalParameters: additionalParametersRefs\n        };\n        const additionalParameters = [ additionalParametersRefs[ 0 ], ...additionalParametersRefs.slice( 1 ).map( getFromProps ) ];\n        return new DerivedStateResult( {\n            ctxParameters,\n            additionalParameters,\n            compute: ( { ctx } ) => getCommandRender( {\n                commandContext,\n                ctx: {\n                    ...ctx,\n                    //Fakes visibleServerCommands being in CTX even though it actually local to this command bar\n                    visibleServerCommands\n                }\n            }, additionalParameters[ 0 ] )\n        } );\n    } );\n};\n\nexport default {\n    getCommands,\n    getCommand,\n    executeCommand,\n    executeCommandIfVisibleAndEnabled\n};\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,aAAP,MAA0B,kBAA1B;AACA,OAAOC,iBAAP,MAA8B,uBAA9B;AACA,SAASC,UAAU,IAAIC,kBAAvB,EAA2CC,WAAW,IAAIC,mBAA1D,QAAqF,+BAArF;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AACA,SAASC,kBAAT,QAAmC,0BAAnC;AACA,SAASC,cAAT,EAAyBC,oBAAzB,QAAqD,4BAArD;AACA,SAASC,MAAT,EAAiBC,OAAjB,EAA0BC,GAA1B,EAA+BC,IAA/B,QAA2C,QAA3C;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,cAAP,MAA2B,mBAA3B;AACA,SAASC,+BAAT,QAAgD,iBAAhD;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,4BAA4B,GAAG,YAAsB;EAAA,IAApBC,SAAoB,uEAAR,EAAQ;;EACvD,IAAIA,SAAS,CAACC,aAAV,KAA4B,WAAhC,EAA8C;IAC1C,MAAM;MAAEC,gBAAF;MAAoBC;IAApB,IAAyCH,SAA/C;;IACA,IAAIE,gBAAgB,IAAIC,gBAAxB,EAA2C;MACvC,OAASC,OAAF,IAAeF,gBAAgB,CAACG,QAAjB,CAA2BD,OAAO,CAACE,EAAnC,KAA2C,CAACH,gBAAgB,CAACE,QAAjB,CAA2BD,OAAO,CAACE,EAAnC,CAAlE;IACH,CAFD,MAEO,IAAIJ,gBAAJ,EAAuB;MAC1B,OAASE,OAAF,IAAeF,gBAAgB,CAACG,QAAjB,CAA2BD,OAAO,CAACE,EAAnC,CAAtB;IACH,CAFM,MAED,IAAIH,gBAAJ,EAAuB;MACzB,OAASC,OAAF,IAAe,CAACD,gBAAgB,CAACE,QAAjB,CAA2BD,OAAO,CAACE,EAAnC,CAAvB;IACH;EACJ,CAVsD,CAWvD;;;EACA,OAAO,MAAM,IAAb;AACH,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,oBAAoB,GAAG,UAAUP,SAAV,EAAqBQ,uBAArB,EAA+C;EACxE,MAAMC,uBAAuB,GAAGV,4BAA4B,CAAEC,SAAF,CAA5D;EACA,OAAOI,OAAO,IAAI,CAACI,uBAAuB,CAACH,QAAxB,CAAkCD,OAAO,CAACE,EAA1C,CAAD,IAAmDG,uBAAuB,CAAEL,OAAF,CAA5F;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMlB,WAAW,GAAG,gBAAgBwB,qBAAhB,EAAwC;EAC/D,MAAMC,QAAQ,GAAG,MAAMxB,mBAAmB,CAAEuB,qBAAF,CAA1C;EACA,MAAMF,uBAAuB,GAAG,MAAMzB,iBAAiB,CAAC6B,eAAlB,CAAmC,oBAAnC,CAAtC;EACA,MAAMZ,SAAS,GAAGlB,aAAa,CAAC+B,MAAd,CAAsB,WAAtB,CAAlB;EACA,OAAOF,QAAQ,CAACG,MAAT,CAAiBP,oBAAoB,CAAEP,SAAF,EAAaQ,uBAAuB,IAAI,EAAxC,CAArC,CAAP;AACH,CALM;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMxB,UAAU,GAAGC,kBAAnB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAM8B,iCAAiC,GAAG,gBAAgBC,SAAhB,EAA2BC,cAA3B,EAA2CC,sBAA3C,EAAoE;EACjH,IAAI,CAACA,sBAAL,EAA8B;IAC1B,OAAOC,OAAO,CAACC,MAAR,CAAgB,2HAAhB,CAAP;EACH;;EACD,MAAMhB,OAAO,GAAG,MAAMpB,UAAU,CAAEgC,SAAF,CAAhC;EACA,MAAMK,KAAK,GAAG;IACVC,GAAG,EAAExC,aAAa,CAACwC,GADT;IAEVL,cAAc,EAAE,EACZ,GAAGA;IADS;EAFN,CAAd;EAMA,MAAMM,aAAa,GAAGC,gBAAgB,CAAEH,KAAF,EAASjB,OAAT,CAAtC;EACA,OAAOmB,aAAa,CAACE,OAAd,GAAwBF,aAAa,CAACG,OAAd,CAAuBR,sBAAvB,CAAxB,GAA0EC,OAAO,CAACQ,OAAR,EAAjF;AACH,CAbM;AAeP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,cAAc,GAAG,gBAAgBZ,SAAhB,EAA2Ba,WAA3B,EAAwCC,OAAxC,EAA+F;EAAA,IAA9Cb,cAA8C,uEAA7B,EAA6B;EAAA,IAAzBC,sBAAyB;;EACzH,IAAI,CAACA,sBAAL,EAA8B;IAC1B,OAAOC,OAAO,CAACC,MAAR,CAAgB,2HAAhB,CAAP;EACH;;EACD,MAAMhB,OAAO,GAAG,MAAMpB,UAAU,CAAEgC,SAAF,CAAhC;EACA,MAAMK,KAAK,GAAG;IACVC,GAAG,EAAExC,aAAa,CAACwC,GADT;IAEV,GAAGQ,OAFO;IAGVb,cAAc,EAAE;MACZY,WADY;MAEZ,GAAGZ;IAFS;EAHN,CAAd;EAQA,MAAMM,aAAa,GAAGC,gBAAgB,CAAEH,KAAF,EAASjB,OAAT,CAAtC;EACA,OAAOmB,aAAa,CAACG,OAAd,CAAuBR,sBAAvB,CAAP;AACH,CAfM;AAiBP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMa,aAAa,GAAG,gBAQnBC,OARmB,SAanBX,KAbmB,EAaX;EAAA,IAbqB;IAC5Bf,EAD4B;IAE5B2B,KAAK,GAAG,EAFoB;IAG5BC,WAAW,GAAG,EAHc;IAI5BC,IAAI,GAAG,EAJqB;IAK5BC,eAL4B;IAM5BC,SAN4B;IAO5BC,WAAW,GAAG;EAPc,CAarB;EAAA,IALC;IACRC,QADQ;IAERd,OAFQ;IAGRe,OAHQ;IAIRC;EAJQ,CAKD;;EACP;AACJ;AACA;EACI,KAAKnC,EAAL,GAAUA,EAAV;EAEA;AACJ;AACA;;EACI,KAAK0B,OAAL,GAAeA,OAAf;EAEA;AACJ;AACA;;EACI,KAAKC,KAAL,GAAa,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,IAAjD;EAEA;AACJ;AACA;;EACI,KAAKC,WAAL,GAAmBA,WAAnB;EAEA;AACJ;AACA;;EACI,KAAKC,IAAL,GAAYA,IAAZ;EAEA;AACJ;AACA;;EACI,KAAKE,SAAL,GAAiBA,SAAjB;EAEA;AACJ;AACA;;EACI,KAAKD,eAAL,GAAuBA,eAAvB;EAEA;AACJ;AACA;;EACI,KAAKE,WAAL,GAAmBA,WAAnB;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKZ,OAAL,GAAe,UAAUR,sBAAV,EAAkCD,cAAlC,EAAmD;IAC9DrB,YAAY,CAAC8C,KAAb,CAAoB,UAApB,EAAgC,KAAKpC,EAArC,EAD8D,CAE9D;IACA;IACA;;IACA,IAAI,KAAKiC,QAAL,IAAiBP,OAAO,CAACW,MAAR,CAAeC,UAAf,KAA8B,OAAnD,EAA6D;MACzD,OAAOZ,OAAO,CAACW,MAAf;IACH;;IACD,OAAOX,OAAO,CAACN,OAAR,CAAgBmB,KAAhB,CAAuBb,OAAvB,EAAgC,CAAEd,sBAAF,EAA0BG,KAA1B,EAAiCJ,cAAjC,CAAhC,CAAP;EACH,CATD;EAWA;AACJ;AACA;;;EACI,KAAKsB,QAAL,GAAgBA,QAAhB;EAEA;AACJ;AACA;;EACI,KAAKd,OAAL,GAAeA,OAAf;EAEA;AACJ;AACA;;EACI,KAAKe,OAAL,GAAeA,OAAf;EAEA;AACJ;AACA;;EACI,KAAKC,QAAL,GAAgBA,QAAhB;AACH,CA3FD;AA6FA;AACA;AACA;;;KA/FMV,a;AAgGN,MAAMe,mBAAmB,GAAG,CAAE,2BAAF,EAA+B,yBAA/B,EAA0D,kBAA1D,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAK1B,KAAF,IAAa;EAClC,KAAK,MAAM2B,IAAX,IAAmBF,mBAAnB,EAAyC;IACrC,IAAIzB,KAAK,CAACC,GAAN,CAAU0B,IAAV,KAAmB3B,KAAK,CAACC,GAAN,CAAU0B,IAAV,EAAgBhC,SAAvC,EAAmD;MAC/C,OAAOK,KAAK,CAACC,GAAN,CAAU0B,IAAV,EAAgBhC,SAAvB;IACH;EACJ;;EACD,OAAO,IAAP;AACH,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiC,iBAAiB,GAAG,UAAUC,UAAV,EAAsB5C,EAAtB,EAA0Be,KAA1B,EAAkC;EACxD,MAAM8B,aAAa,GAAGJ,gBAAgB,CAAE1B,KAAF,CAAtC;;EACA,IAAI6B,UAAJ,EAAiB;IACb,OAAOE,OAAO,CAAEhE,gBAAgB,CAACiE,iBAAjB,CAAoC,EAApC,EAAwCH,UAAU,CAACI,UAAnD,EAA+DjC,KAA/D,CAAF,CAAd;EACH,CAFD,MAEO,IAAI8B,aAAa,KAAK7C,EAAtB,EAA2B;IAC9B,OAAO,IAAP;EACH;;EACD,OAAO,KAAP;AACH,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiD,uBAAuB,GAAG,CAAEC,QAAF,EAAYC,gBAAZ,KAAkC;EAC9D,MAAMC,qBAAqB,GAAG,CAAEtD,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,KAAgC;IAC1D,MAAMkB,YAAY,GAAGC,CAAC,IAAI;MACtB,OAAO/D,cAAc,CAACgE,QAAf,CAAyB/D,+BAA+B,CAAE8D,CAAF,CAAxD,EAAiEvC,KAAjE,CAAP;IACH,CAFD;;IAGA,IAAKjB,OAAO,CAACqD,gBAAD,CAAP,IAA6BhB,QAAlC,EAA6C;MACzC,OAAOrC,OAAO,CAACqD,gBAAD,CAAP,CAA0BK,UAA1B,CAAqCC,GAArC,CAA0CJ,YAA1C,CAAP;IACH;;IACD,IAAKvD,OAAO,CAACoD,QAAD,CAAP,IAAqBpD,OAAO,CAACoD,QAAD,CAAP,CAAkBM,UAAvC,IAAqDN,QAAQ,KAAK,WAAvE,EAAqF;MACjF,OAAOpD,OAAO,CAACoD,QAAD,CAAP,CAAkBM,UAAlB,CAA6BC,GAA7B,CAAkCJ,YAAlC,CAAP;IACH;;IACD,IAAKvD,OAAO,CAACoD,QAAD,CAAP,IAAqBpD,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAvC,IAA+C5D,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAlB,CAAuBF,UAAtE,IAAoFN,QAAQ,KAAK,WAAtG,EAAoH;MAChH,OAAOpD,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAlB,CAAuBF,UAAvB,CAAkCC,GAAlC,CAAuCJ,YAAvC,CAAP;IACH;;IACD,OAAO,EAAP;EACH,CAdD;;EAeA,OAAO,CAAEvD,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,KAAgC;IACnC,MAAMqB,UAAU,GAAGJ,qBAAqB,CAAEtD,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,CAAxC;;IACA,IAAKrC,OAAO,CAACqD,gBAAD,CAAP,IAA6BhB,QAA7B,IAAyCrC,OAAO,CAACqD,gBAAD,CAAP,CAA0BQ,KAAxE,EAAgF;MAC5E,OAAO7D,OAAO,CAACqD,gBAAD,CAAP,CAA0BQ,KAA1B,CAAgCC,MAAhC,CAAwC,GAAGJ,UAA3C,CAAP;IACH;;IACD,IAAK1D,OAAO,CAACoD,QAAD,CAAP,IAAqBpD,OAAO,CAACoD,QAAD,CAAP,CAAkBS,KAAvC,IAAgDT,QAAQ,KAAK,WAAlE,EAAgF;MAC5E,OAAOpD,OAAO,CAACoD,QAAD,CAAP,CAAkBS,KAAlB,CAAwBC,MAAxB,CAAgC,GAAGJ,UAAnC,CAAP;IACH;;IACD,IAAK1D,OAAO,CAACoD,QAAD,CAAP,IAAqBpD,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAvC,IAA+C5D,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAlB,CAAuBC,KAAtE,IAA+ET,QAAQ,KAAK,WAAjG,EAA+G;MAC3G,OAAOpD,OAAO,CAACoD,QAAD,CAAP,CAAkBQ,IAAlB,CAAuBC,KAAvB,CAA6BC,MAA7B,CAAqC,GAAGJ,UAAxC,CAAP;IACH;;IACD,OAAO,EAAP;EACH,CAZD;AAaH,CA7BD;AA+BA;AACA;AACA;;;AACA,MAAMK,QAAQ,GAAGZ,uBAAuB,CAAE,OAAF,EAAW,eAAX,CAAxC;AAEA;AACA;AACA;;AACA,MAAMa,cAAc,GAAGb,uBAAuB,CAAE,aAAF,EAAiB,qBAAjB,CAA9C;AAEA;AACA;AACA;;AACA,MAAMc,YAAY,GAAGd,uBAAuB,CAAE,WAAF,EAAe,IAAf,CAA5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMe,oBAAoB,GAAG,CAAEjD,KAAF,EAASjB,OAAT,KAAsB;EAC/C,KAAK,MAAM4B,OAAX,IAAsB5B,OAAO,CAACmE,QAA9B,EAAyC;IACrC,MAAMC,QAAQ,GAAGpB,OAAO,CAAEhE,gBAAgB,CAACiE,iBAAjB,CAAoC,EAApC,EAAwCrB,OAAO,CAACyC,UAAR,CAAmBnB,UAA3D,EAAuEjC,KAAvE,CAAF,CAAxB;;IACA,IAAImD,QAAJ,EAAe;MACXpE,OAAO,CAACsE,KAAR,CAAe,mBAAf,EAAoC1C,OAApC;MACApC,YAAY,CAAC+E,2BAAb,CAA0CvE,OAAO,CAACE,EAAlD,EAAsD0B,OAAtD;MACA,MAAMQ,OAAO,GAAGR,OAAO,CAAC4C,UAAR,GAAqBxB,OAAO,CAAEhE,gBAAgB,CAACiE,iBAAjB,CAAoC,EAApC,EAAwCrB,OAAO,CAAC4C,UAAR,CAAmBtB,UAA3D,EAAuEjC,KAAvE,CAAF,CAA5B,GAAiH,IAAjI;MACA,MAAMoB,QAAQ,GAAGQ,iBAAiB,CAAEjB,OAAO,CAACkB,UAAV,EAAsB9C,OAAO,CAACE,EAA9B,EAAkCe,KAAlC,CAAlC,CAJW,CAKX;;MACA,MAAMI,OAAO,GAAGO,OAAO,CAAC6C,WAAR,GAAsBzB,OAAO,CAAEhE,gBAAgB,CAACiE,iBAAjB,CAAoC,EAApC,EAAwCrB,OAAO,CAAC6C,WAAR,CAAoBvB,UAA5D,EAAwEjC,KAAxE,CAAF,CAA7B,GAAmH,IAAnI;MACA,MAAMf,EAAE,GAAGF,OAAO,CAACE,EAAnB,CAPW,CAQX;;MACA,MAAM2B,KAAK,GAAGkC,QAAQ,CAAE/D,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,CAAtB;MACA,MAAMP,WAAW,GAAGkC,cAAc,CAAEhE,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,CAAlC;MACA,MAAMN,IAAI,GAAG/B,OAAO,CAAC0E,YAAR,IAAwBrC,QAAxB,GAAmCrC,OAAO,CAAC0E,YAA3C,GAA0D1E,OAAO,CAAC+B,IAA/E;MACA,MAAMI,QAAQ,GAAGnC,OAAO,CAAC2E,IAAR,KAAiB,QAAlC;MACA,MAAMzC,WAAW,GAAGlC,OAAO,CAACkC,WAA5B;MACA,MAAM0C,cAAc,GAAGvC,QAAQ,IAAIrC,OAAO,CAAC6E,uBAApB,GAA8C7E,OAAO,CAAC6E,uBAAtD,GAAgF7E,OAAO,CAACgC,eAA/G;MACA,MAAMC,SAAS,GAAG,EAAlB;MACAA,SAAS,CAAC2B,IAAV,GAAkBK,YAAY,CAAEjE,OAAF,EAAWiB,KAAX,EAAkBoB,QAAlB,CAA9B;MACAJ,SAAS,CAAC6C,SAAV,GAAsB9E,OAAO,CAACiC,SAAR,IAAqBjC,OAAO,CAACiC,SAAR,CAAkB8C,KAAvC,GAA+C/E,OAAO,CAACiC,SAAR,CAAkB8C,KAAjE,GAAyE,IAA/F;MACA9C,SAAS,CAACwC,WAAV,GAAwBzE,OAAO,CAACiC,SAAR,IAAqBjC,OAAO,CAACiC,SAAR,CAAkBwC,WAAvC,GAAqDzB,OAAO,CAAEhE,gBAAgB,CAACiE,iBAAjB,CAAoC,EAApC,EAAwCjD,OAAO,CAACiC,SAAR,CAAkBwC,WAAlB,CAA8BvB,UAAtE,EAAkFjC,KAAlF,CAAF,CAA5D,GAA4J,IAApL;MAEA,OAAO,IAAIU,aAAJ,CAAmB;QACtBzB,EADsB;QAEtB4B,WAFsB;QAGtBD,KAHsB;QAItBE,IAJsB;QAKtBC,eAAe,EAAE4C,cALK;QAMtB3C,SANsB;QAOtBC;MAPsB,CAAnB,EAQJN,OARI,EAQK;QACRQ,OADQ;QAERC,QAFQ;QAGRhB,OAHQ;QAIRc;MAJQ,CARL,EAaJlB,KAbI,CAAP;IAcH;EACJ;;EACDjB,OAAO,CAACsE,KAAR,CAAe,+BAAf;EACA,OAAO,IAAI3C,aAAJ,CAAmB3B,OAAnB,EAA4B,IAA5B,EAAkC;IACrCoC,OAAO,EAAE,KAD4B;IAErCC,QAAQ,EAAE,KAF2B;IAGrChB,OAAO,EAAE;EAH4B,CAAlC,EAIJJ,KAJI,CAAP;AAKH,CA7CD;AA+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM+D,qBAAqB,GAAG,CAAE/D,KAAF,EAASjB,OAAT,KAAsB;EAChD,MAAM;IAAEiF,iBAAiB,GAAG;EAAtB,IAA+BjF,OAArC;EACA,MAAMkF,kBAAkB,GAAGlF,OAAO,CAACmF,QAAR,CAAiBxB,GAAjB,CAAsByB,KAAK,IAAIhE,gBAAgB,CAAEH,KAAF,EAASmE,KAAT,CAA/C,CAA3B;EACApF,OAAO,CAACsE,KAAR,CAAe,sBAAf,EAAuCY,kBAAvC;EACA,MAAMG,oBAAoB,GAAGH,kBAAkB,CAACxE,MAAnB,CAA2B8C,CAAC,IAAIA,CAAC,CAACnC,OAAlC,CAA7B;EACA,MAAMiE,iBAAiB,GAAGD,oBAAoB,CAACE,MAArB,CAA6B,QAAyBC,iBAAzB,KAAgD;IAAA,IAA9C;MAAEpD,OAAF;MAAWC;IAAX,CAA8C;IACnG,OAAO;MACHD,OAAO,EAAEA,OAAO,IAAIoD,iBAAiB,CAACpD,OADnC;MAEHC,QAAQ,EAAE4C,iBAAiB,KAAM5C,QAAQ,IAAImD,iBAAiB,CAACpD,OAAlB,IAA6BoD,iBAAiB,CAACnD,QAAjE;IAFxB,CAAP;EAIH,CALyB,EAKvB;IACCD,OAAO,EAAE,KADV;IAECC,QAAQ,EAAE;EAFX,CALuB,CAA1B;EASA,MAAMnC,EAAE,GAAGF,OAAO,CAACE,EAAnB,CAdgD,CAehD;;EACA,MAAM2B,KAAK,GAAGkC,QAAQ,CAAE/D,OAAF,EAAWiB,KAAX,EAAkBqE,iBAAiB,CAACjD,QAApC,CAAtB;EACA,MAAMP,WAAW,GAAGkC,cAAc,CAAEhE,OAAF,EAAWiB,KAAX,EAAkBqE,iBAAiB,CAACjD,QAApC,CAAlC;EACA,MAAMN,IAAI,GAAG/B,OAAO,CAAC0E,YAAR,IAAwBY,iBAAiB,CAACjD,QAA1C,GAAqDrC,OAAO,CAAC0E,YAA7D,GAA4E1E,OAAO,CAAC+B,IAAjG;EACA,MAAMV,OAAO,GAAGgE,oBAAoB,CAACI,MAArB,GAA8B,CAA9C;EACA,MAAMtD,QAAQ,GAAGkD,oBAAoB,CAACI,MAArB,GAA8B,CAA/C;EACA,OAAO,IAAI9D,aAAJ,CAAmB;IACtBzB,EADsB;IAEtB2B,KAFsB;IAGtBC,WAHsB;IAItBC,IAJsB;IAKtBC,eAAe,EAAEhC,OAAO,CAACgC,eALH;IAMtBC,SAAS,EAAE;EANW,CAAnB,EAOJoD,oBAAoB,CAACI,MAArB,KAAgC,CAAhC,GAAoCJ,oBAAoB,CAAE,CAAF,CAApB,CAA0BzD,OAA9D,GAAwE5B,OAAO,CAACmE,QAAR,CAAkB,CAAlB,CAPpE,EAO2F,EAC9F,GAAGmB,iBAD2F;IAE9FnD,QAF8F;IAG9Fd;EAH8F,CAP3F,EAWJJ,KAXI,CAAP;AAYH,CAjCD;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMyE,uBAAuB,GAAG,CAAEzE,KAAF,EAASjB,OAAT,KAAsB;EAClD;EACA;EACA,MAAMiF,iBAAiB,GAAG,KAA1B,CAHkD,CAIlD;EACA;EACA;EACA;;EACA,MAAMC,kBAAkB,GAAGlF,OAAO,CAACmF,QAAR,CAAiBxB,GAAjB,CAAsByB,KAAK,IAAIhE,gBAAgB,CAAEH,KAAF,EAASmE,KAAT,CAA/C,CAA3B,CARkD,CASlD;EACA;;EACA,MAAMC,oBAAoB,GAAGH,kBAAkB,CAACxE,MAAnB,CAA2B8C,CAAC,IAAIA,CAAC,CAACnC,OAAlC,CAA7B,CAXkD,CAYlD;EACA;EACA;;EACA,MAAMsE,qBAAqB,GAAGN,oBAAoB,CAAC3E,MAArB,CAA6B8C,CAAC,IAAIA,CAAC,CAACnB,QAApC,CAA9B,CAfkD,CAgBlD;;EACA,MAAMiD,iBAAiB,GAAGD,oBAAoB,CAACE,MAArB,CAA6B,QAAeC,iBAAf,KAAsC;IAAA,IAApC;MAAEpD;IAAF,CAAoC;IACzF,OAAO;MACHA,OAAO,EAAEA,OAAO,IAAIoD,iBAAiB,CAACpD,OADnC;MAEHC,QAAQ,EAAE4C;IAFP,CAAP;EAIH,CALyB,EAKvB;IACC7C,OAAO,EAAE,KADV;IAECC,QAAQ,EAAE;EAFX,CALuB,CAA1B;EAUA,MAAMnC,EAAE,GAAGF,OAAO,CAACE,EAAnB;EACA,MAAM0F,kBAAkB,GAAGD,qBAAqB,CAAE,CAAF,CAAhD;;EAEA,MAAME,eAAe,GAAG,MAAM;IAC1B,IAAID,kBAAJ,EAAyB;MACrB,OAAOA,kBAAkB,CAAC/D,KAA1B;IACH;;IACD,OAAOkC,QAAQ,CAAE/D,OAAF,EAAWiB,KAAX,EAAkBqE,iBAAiB,CAACjD,QAApC,CAAf;EACH,CALD;;EAMA,MAAMyD,qBAAqB,GAAG,MAAM;IAChC;IACA;IACA,IAAIF,kBAAJ,EAAyB;MACrB,OAAOA,kBAAkB,CAAC9D,WAA1B;IACH;;IACD,OAAOkC,cAAc,CAAEhE,OAAF,EAAWiB,KAAX,EAAkBqE,iBAAiB,CAACjD,QAApC,CAArB;EACH,CAPD;;EAQA,MAAM0D,cAAc,GAAG,MAAM;IACzB,IAAIH,kBAAJ,EAAyB;MACrB,OAAOA,kBAAkB,CAAC7D,IAA1B;IACH;;IACD,OAAO/B,OAAO,CAAC0E,YAAR,IAAwBY,iBAAiB,CAACjD,QAA1C,GACHrC,OAAO,CAAC0E,YADL,GAEH1E,OAAO,CAAC+B,IAFZ;EAGH,CAPD;;EAQA,MAAMiE,yBAAyB,GAAG,MAAM;IACpC;IACA,IAAIhG,OAAO,CAACgC,eAAZ,EAA8B;MAC1B,OAAOhC,OAAO,CAACgC,eAAf;IACH,CAJmC,CAKpC;;;IACA,IAAI4D,kBAAkB,IAAIA,kBAAkB,CAAC5D,eAA7C,EAA+D;MAC3D,OAAO4D,kBAAkB,CAAC5D,eAA1B;IACH,CARmC,CASpC;;;IACA,OAAO,IAAP;EACH,CAXD;;EAYA,MAAMH,KAAK,GAAGgE,eAAe,EAA7B;EACA,MAAM/D,WAAW,GAAGgE,qBAAqB,EAAzC;EACA,MAAM/D,IAAI,GAAGgE,cAAc,EAA3B;EAEA,MAAM1E,OAAO,GAAGgE,oBAAoB,CAACI,MAArB,GAA8B,CAA9C;EACA,MAAMtD,QAAQ,GAAGkD,oBAAoB,CAACI,MAArB,GAA8B,CAA/C;EACA,OAAO,IAAI9D,aAAJ,CAAmB;IACtBzB,EADsB;IAEtB2B,KAFsB;IAGtBC,WAHsB;IAItBC,IAJsB;IAKtBC,eAAe,EAAEgE,yBAAyB,EALpB;IAMtB/D,SAAS,EAAE;EANW,CAAnB,EAOJoD,oBAAoB,CAACI,MAArB,KAAgC,CAAhC,GAAoCJ,oBAAoB,CAAE,CAAF,CAApB,CAA0BzD,OAA9D,GAAwE5B,OAAO,CAACmE,QAAR,CAAkB,CAAlB,CAPpE,EAO2F,EAC9F,GAAGmB,iBAD2F;IAE9FnD,QAF8F;IAG9Fd;EAH8F,CAP3F,EAWJJ,KAXI,CAAP;AAYH,CAlFD;AAoFA;AACA;AACA;;;AACA,MAAMgF,qBAAqB,GAAG;EAC1BC,IAAI,EAAEhC,oBADoB;EAE1BiC,MAAM,EAAEjC,oBAFkB;EAG1BkC,KAAK,EAAEpB,qBAHmB;EAI1BqB,OAAO,EAAEX;AAJiB,CAA9B;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMtE,gBAAgB,GAAG,CAAEH,KAAF,EAASjB,OAAT,KAAsB;EAClD,MAAMsG,cAAc,GAAGL,qBAAqB,CAAEjG,OAAO,CAAC2E,IAAV,CAArB,IAAyCsB,qBAAqB,CAACC,IAAtF;EACAlG,OAAO,CAACsE,KAAR,CAAe,+BAAf,EAAgDrD,KAAhD,EAAuDjB,OAAvD,EAAgEsG,cAAhE;EACA,MAAMC,YAAY,GAAGD,cAAc,CAAErF,KAAF,EAASjB,OAAT,CAAnC;EACAA,OAAO,CAACsE,KAAR,CAAe,eAAf,EAAgCiC,YAAhC;EACA/G,YAAY,CAACgH,kBAAb,CAAiCxG,OAAjC,EAA0CuG,YAA1C;EACA,OAAOA,YAAP;AACH,CAPM;AASP;AACA;AACA;AACA;AACA;AACA;;AACA,MAAME,wBAAwB,GAAKzG,OAAF,IAAe;EAC5C,MAAM0G,uBAAuB,GAAG,CAAE,qCAAF,EAAyC,mCAAzC,EAA8E,4BAA9E,CAAhC;EAEA,MAAM;IACFC,aAAa,EAAEC,eADb;IAEFC,oBAAoB,EAAEC;EAFpB,IAGFC,wBAAwB,CAAE/G,OAAF,CAH5B;EAIA,OAAO,CAAEA,OAAO,CAACmE,QAAR,IAAoB,EAAtB,EAA2BoB,MAA3B,CAAmC,CAAEyB,GAAF,EAAOpF,OAAP,KAAoB;IAC1D,MAAMqF,aAAa,GAAG,CAClB/H,cAAc,CAAE0C,OAAO,CAACyC,UAAV,CADI,EAElBnF,cAAc,CAAE0C,OAAO,CAAC6C,WAAV,CAFI,EAGlBvF,cAAc,CAAE0C,OAAO,CAAC4C,UAAV,CAHI,EAIlBtF,cAAc,CAAE0C,OAAO,CAACkB,UAAV,CAJI,CAAtB;IAMA,OAAO;MACH6D,aAAa,EAAEpH,IAAI,CAAEH,MAAM,CAAEC,OAAO,CAAE4H,aAAa,CAACtD,GAAd,CAAmBH,CAAC,IAAIA,CAAC,CAACmD,aAA1B,CAAF,CAAT,EAAwDK,GAAG,CAACL,aAA5D,CAAR,CADhB;MAEHE,oBAAoB,EAAEzH,MAAM,CAAE4H,GAAG,CAACH,oBAAN,EAA4BxH,OAAO,CAAE4H,aAAa,CAACtD,GAAd,CAAmBH,CAAC,IAAIA,CAAC,CAACqD,oBAA1B,CAAF,CAAnC;IAFzB,CAAP;EAIH,CAXM,EAWJ;IACCF,aAAa,EAAE,CAAE,GAAGC,eAAL,EAAsB,GAAGF,uBAAzB,CADhB;IAECG,oBAAoB,EAAE,CAAE7G,OAAF,EAAW,GAAG8G,sBAAd;EAFvB,CAXI,CAAP;AAeH,CAtBD;AAwBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,yBAAyB,GAAKlH,OAAF,IAAe;EAC7C,MAAM;IACF2G,aAAa,EAAEC,eADb;IAEFC,oBAAoB,EAAEC;EAFpB,IAGFC,wBAAwB,CAAE/G,OAAF,CAH5B;EAIA,OAAOA,OAAO,CAACmF,QAAR,CAAiBI,MAAjB,CAAyB,CAAEyB,GAAF,EAAO5B,KAAP,KAAkB;IAC9C,MAAM+B,eAAe,GAAGC,oBAAoB,CAAEhC,KAAF,CAA5C;IACA,OAAO;MACHuB,aAAa,EAAEpH,IAAI,CAAEH,MAAM,CAAE+H,eAAe,CAACR,aAAlB,EAAiCK,GAAG,CAACL,aAArC,CAAR,CADhB;MAEHE,oBAAoB,EAAEzH,MAAM,CAAE4H,GAAG,CAACH,oBAAN,EAA4BM,eAAe,CAACN,oBAA5C;IAFzB,CAAP;EAIH,CANM,EAMJ;IACCF,aAAa,EAAE,CAAE,GAAGC,eAAL,CADhB;IAECC,oBAAoB,EAAE,CAAE7G,OAAF,EAAW,GAAG8G,sBAAd;EAFvB,CANI,CAAP;AAUH,CAfD;;AAiBA,MAAMO,4BAA4B,GAAG;EACjCnB,IAAI,EAAEO,wBAD2B;EAEjCN,MAAM,EAAEM,wBAFyB;EAGjCL,KAAK,EAAEc,yBAH0B;EAIjCb,OAAO,EAAEa;AAJwB,CAArC;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMI,iBAAiB,GAAG,CAAEtH,OAAF,EAAWoD,QAAX,KAAyB;EAC/C,IAAIpD,OAAO,CAACoD,QAAD,CAAX,EAAwB;IACpB,OAAOpD,OAAO,CAACoD,QAAD,CAAP,CAAkBM,UAAlB,CAA6B6B,MAA7B,CAAqC,CAAEyB,GAAF,EAAOxD,CAAP,KAAc;MACtD,MAAM;QACFmD,aADE;QAEFE;MAFE,IAGF1H,oBAAoB,CAAEqE,CAAF,CAHxB;MAIA,OAAO;QACHmD,aAAa,EAAE,CAAE,GAAGK,GAAG,CAACL,aAAT,EAAwB,GAAGA,aAA3B,CADZ;QAEHE,oBAAoB,EAAE,CAAE,GAAGG,GAAG,CAACH,oBAAT,EAA+B,GAAGA,oBAAlC;MAFnB,CAAP;IAIH,CATM,EASJ;MACCF,aAAa,EAAE,EADhB;MAECE,oBAAoB,EAAE;IAFvB,CATI,CAAP;EAaH;;EACD,OAAO;IACHF,aAAa,EAAE,EADZ;IAEHE,oBAAoB,EAAE;EAFnB,CAAP;AAIH,CApBD;AAsBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,wBAAwB,GAAK/G,OAAF,IAAe;EAC5C,OAAO,CAAE,OAAF,EAAW,eAAX,EAA4B,aAA5B,EAA2C,qBAA3C,EAAmEuF,MAAnE,CAA2E,CAAEyB,GAAF,EAAO5D,QAAP,KAAqB;IACnG,MAAM;MACFuD,aADE;MAEFE;IAFE,IAGFS,iBAAiB,CAAEtH,OAAF,EAAWoD,QAAX,CAHrB;IAIA,OAAO;MACHuD,aAAa,EAAE,CAAE,GAAGK,GAAG,CAACL,aAAT,EAAwB,GAAGA,aAA3B,CADZ;MAEHE,oBAAoB,EAAE,CAAE,GAAGG,GAAG,CAACH,oBAAT,EAA+B,GAAGA,oBAAlC;IAFnB,CAAP;EAIH,CATM,EASJ;IACCF,aAAa,EAAE,EADhB;IAECE,oBAAoB,EAAE;EAFvB,CATI,CAAP;AAaH,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMO,oBAAoB,GAAKpH,OAAF,IAAe,CAAEqH,4BAA4B,CAAErH,OAAO,CAAC2E,IAAV,CAA5B,IAAgD0C,4BAA4B,CAACnB,IAA/E,EAAuFlG,OAAvF,CAA5C;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMuH,gBAAgB,GAAG,CAAEC,KAAF,YAAoF;EAAA,IAA3E;IAAEC,WAAW,GAAG,EAAhB;IAAoB5G,cAAc,GAAG,EAArC;IAAyC6G,qBAAqB,GAAG;EAAjE,CAA2E;EAChH,MAAMzG,KAAK,GAAG;IACVJ,cADU;IAEV6G;EAFU,CAAd,CADgH,CAKhH;;EACA,MAAMC,YAAY,GAAKC,IAAF,IAAYtI,GAAG,CAAE2B,KAAF,EAAS2G,IAAT,CAApC;;EACA,OAAOH,WAAW,CAAC9D,GAAZ,CAAiBkE,GAAG,IAAI;IAC3B,MAAM;MACFlB,aADE;MAEFE,oBAAoB,EAAEiB;IAFpB,IAGFD,GAAG,CAACnE,UAAJ,IAAkB0D,oBAAoB,CAAE,EAAE,GAAGS;IAAL,CAAF,CAH1C;IAIAA,GAAG,CAACnE,UAAJ,GAAiB;MACbiD,aADa;MAEbE,oBAAoB,EAAEiB;IAFT,CAAjB;IAIA,MAAMjB,oBAAoB,GAAG,CAAEiB,wBAAwB,CAAE,CAAF,CAA1B,EAAiC,GAAGA,wBAAwB,CAACC,KAAzB,CAAgC,CAAhC,EAAoCpE,GAApC,CAAyCgE,YAAzC,CAApC,CAA7B;IACA,OAAO,IAAI1I,kBAAJ,CAAwB;MAC3B0H,aAD2B;MAE3BE,oBAF2B;MAG3BmB,OAAO,EAAE;QAAA,IAAE;UAAE9G;QAAF,CAAF;QAAA,OAAeE,gBAAgB,CAAE;UACtCP,cADsC;UAEtCK,GAAG,EAAE,EACD,GAAGA,GADF;YAED;YACAwG;UAHC;QAFiC,CAAF,EAOrCb,oBAAoB,CAAE,CAAF,CAPiB,CAA/B;MAAA;IAHkB,CAAxB,CAAP;EAYH,CAtBM,CAAP;AAuBH,CA9BM;AAgCP,eAAe;EACX/H,WADW;EAEXF,UAFW;EAGX4C,cAHW;EAIXb;AAJW,CAAf"},"metadata":{},"sourceType":"module"}