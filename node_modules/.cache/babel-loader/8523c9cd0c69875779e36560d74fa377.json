{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides high level functionalities to work with view model.\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport declViewModProcFact from 'js/viewModelProcessingFactory';\nimport messagingSvc from 'js/messagingService';\nimport actionSvc from 'js/actionService';\nimport conditionSvc from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport declDataCtxService from 'js/declarativeDataCtxService';\nimport Debug from 'debug';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport declUtils from './declUtils';\nimport debugService from 'js/debugService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { loadDynModule } from 'js/moduleLoader';\nvar trace = new Debug('viewModel');\nvar exports = {};\n\nconst eveulateEventCondition = function (eventObj, declViewModel, matched, props, context, fields) {\n  var conditionResult = false;\n\n  if (eventObj.condition) {\n    var conditionExpression = null;\n\n    if (_.startsWith(eventObj.condition, 'conditions.')) {\n      var conditionObject = _.get(declViewModel._internal, eventObj.condition);\n\n      conditionExpression = conditionObject.expression;\n    } else {\n      conditionExpression = eventObj.condition;\n    }\n\n    let currContext = null;\n\n    if (context) {\n      if (context.scope) {\n        currContext = context.scope;\n      } else {\n        currContext = context;\n      }\n    } else {\n      currContext = {\n        data: declViewModel,\n        props: props,\n        subPanelContext: props.subPanelContext,\n        fields\n      };\n    }\n\n    conditionResult = conditionSvc.evaluateCondition(declUtils.getLatestContext(currContext, declViewModel), conditionExpression, context); // if conditionResult is undefined or null we should consider result as false.\n\n    if (!conditionResult) {\n      conditionResult = false;\n    }\n  }\n\n  return eventObj.condition && conditionResult || eventObj.criteria && matched || !(eventObj.condition || eventObj.criteria);\n};\n\nconst processMessageOnEvent = function (declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields) {\n  var allMessages = _.cloneDeep(declViewModel._internal.messages);\n\n  if (!context.scope) {\n    context.scope = {\n      data: declViewModel,\n      ctx: appCtxSvc.ctx,\n      props,\n      getProps,\n      parameters: inputArgs ? inputArgs : null,\n      fields,\n      getFields\n    };\n    context.scope.parameters = context.scope.parameters ? { ...context.scope.parameters,\n      commandActionExecutor: {\n        runActionWithViewModel\n      }\n    } : {\n      commandActionExecutor: {\n        runActionWithViewModel\n      }\n    };\n  }\n\n  messagingSvc.reportNotyMessage(declViewModel, allMessages, eventObj.message, context.scope);\n};\n\nconst processActionOnEventHavingScope = function (context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields) {\n  context.scope.parameters = inputArgs ? inputArgs : null;\n  context.scope.parameters = context.scope.parameters ? { ...context.scope.parameters,\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  } : {\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  };\n  context.scope.props = props;\n  context.scope.getProps = getProps;\n  context.scope.fields = fields;\n  context.scope.getFields = getFields;\n  exports.executeCommand(declViewModel, eventObj.action, context.scope);\n};\n\nconst processActionOnEventWithScope = function (declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields) {\n  var scope = {\n    data: declViewModel,\n    ctx: appCtxSvc.ctx,\n    parameters: inputArgs ? inputArgs : null,\n    subPanelContext: subPanelContext,\n    props,\n    getProps,\n    fields,\n    getFields\n  };\n  scope.parameters = scope.parameters ? { ...scope.parameters,\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  } : {\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  };\n  exports.executeCommand(declViewModel, eventObj.action, scope);\n};\n\nconst reteriveInputParOfEvent = function (context, inputArgs, eventObj, declViewModel) {\n  var contextObj = {\n    eventData: context\n  };\n  inputArgs = _.cloneDeep(eventObj.inputArgs);\n\n  if (inputArgs) {\n    try {\n      declDataCtxService.applyScope(declViewModel, inputArgs, null, contextObj, null);\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  return inputArgs;\n};\n\nconst handleEventDataCache = function (eventObj, declViewModel, context) {\n  if (eventObj.eventId) {\n    if (!declViewModel.eventMap) {\n      declViewModel.eventMap = {};\n    }\n\n    const key = eventObj.eventId;\n    const value = {};\n    value[key] = context;\n    declViewModel.eventMap[eventObj.eventId] = value[key];\n    declViewModel.data.eventMap = { ...declViewModel.eventMap\n    };\n  }\n\n  declViewModel.eventData = context;\n  declViewModel.data.eventData = context;\n}; // eslint-disable-next-line complexity\n\n\nexport let handleRegisteredEvent = function (context, declViewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields) {\n  if (declViewModel.getData && _.isFunction(declViewModel.getData)) {\n    declViewModel.data = declViewModel.getData();\n  }\n\n  const props = getProps();\n  const fields = getFields();\n  const subPanelContext = props.subPanelContext;\n  debugService.debug('events', declViewModel._internal.panelId, eventObj.eventId);\n\n  if (limitEventScope && context._source !== declViewModel._internal.modelId) {\n    return;\n  } // Check if the event source is set to 'current' and _source id is available.\n  // If yes, make event listeners only listen to events fired by the current view model instance.\n\n\n  if (eventObj.eventSource === 'current' && context._source && context._source !== declViewModel._internal.modelId) {\n    return;\n  }\n\n  if (!declUtils.isValidModelAndEventData(declViewModel, context)) {\n    logger.error('_processEventRegistration: ' + 'Invalid input: eventId=' + eventObj.eventId);\n    return;\n  }\n\n  var matched = true;\n  /**\n   * @deprecated : 'criteria' is deprecated we should use condition instead.\n   */\n\n  _.forEach(eventObj.criteria, function (value, key) {\n    // For panel change events, the context doesn't have a scope, so check the properties on context directly.\n    if (_.get(context.scope, key) !== value && _.get(context, key) !== value) {\n      matched = false;\n    }\n  });\n  /**\n   * \"onEvent\": [ { \"eventId\": \"someEvent\", \"condition\": \"conditions.shouldIDoSomething\",\n   * \"action\":\"doSomething\" } ]\n   */\n\n\n  var isEventExecutable = eveulateEventCondition(eventObj, declViewModel, matched, props, context, fields);\n\n  if (logger.isDeclarativeLogEnabled()) {\n    debugService.debugEventSub(eventObj, declViewModel, context, isEventExecutable);\n  }\n\n  if (isEventExecutable) {\n    var inputArgs = null; // Store the context eventData on declViewModel's eventData\n\n    if (eventObj.cacheEventData) {\n      // const { dispatch } = declViewModel;\n      // let finalObj = {};\n      handleEventDataCache(eventObj, declViewModel, context);\n    } // If an event has some eventData and the same eventdata is required in the action,\n    // associated with event, then user can construct inputArgs.\n    // \"eventId\": \"AWEvent.test\",\n    //     \"action\": \"fireSaveEdit\",\n    //         \"inputArgs\": {\n    //         \"param1\": \"{{eventData.operation1}}\",\n    //         \"param3\": {\n    //             \"param4\": \"{{eventData.operation4}}\",\n    //             \"param5\": \"{{eventData.operation5}}\"\n    //         }\n    //     }\n    // Later the same input Args can be reused in action through {{parameters.param1}}.\n\n\n    if (eventObj.inputArgs) {\n      inputArgs = reteriveInputParOfEvent(context, inputArgs, eventObj, declViewModel);\n    }\n\n    if (eventObj.message) {\n      processMessageOnEvent(declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields);\n    } else if (context && context.scope) {\n      processActionOnEventHavingScope(context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields);\n    } else {\n      processActionOnEventWithScope(declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields);\n    }\n  }\n};\n/**\n * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with\n * any data that is bound to various values including localized messages.\n *\n * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.\n *            <P>\n *            Note: The JSON contents are actually represented in the 'data' property of this object.\n *\n * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be\n *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)\n *\n * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a\n *            sub-panel\n * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by\n *            the current view model\n * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.\n *\n * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive\n *\n * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's\n *         JSON.\n */\n\nexport let populateViewModelPropertiesFromJson = function (declViewModelJson, declViewModelTarget, subPanelId, limitEventScope, cacheI18nKey, subPanelContext) {\n  if (!declViewModelJson) {\n    return AwPromiseService.instance.reject('No ViewModel JSON object specified');\n  }\n\n  if (declViewModelTarget) {\n    if (!declViewModelTarget._internal.eventSubscriptions) {\n      return AwPromiseService.instance.reject('Target ViewModel missing required event property');\n    }\n\n    if (!declViewModelTarget._internal.origDeclViewModelJson) {\n      return AwPromiseService.instance.reject('Target ViewModel missing required JSON object property');\n    }\n  }\n  /**\n   * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved\n   * 'declViewModel'.\n   */\n\n\n  var newDeclViewModel = declViewModProcFact.processViewModel(declViewModelJson, subPanelContext);\n  var jsonData = declViewModelJson;\n  /**\n   * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')\n   */\n\n  var resDeclViewModel;\n\n  if (declViewModelTarget) {\n    resDeclViewModel = declViewModelTarget;\n    /**\n     * Consolidate 'fresh' JSON properties into the given 'target'\n     * <P>\n     * Move all of the now populated 'data' properties into the 'target'\n     */\n\n    _.forEach(jsonData.data, function (propValue, propName) {\n      resDeclViewModel[propName] = newDeclViewModel[propName];\n    });\n\n    resDeclViewModel.dataProviders = declUtils.consolidateObjects(resDeclViewModel.dataProviders, newDeclViewModel.dataProviders);\n    resDeclViewModel.grids = declUtils.consolidateObjects(resDeclViewModel.grids, newDeclViewModel.grids);\n    resDeclViewModel.columnProviders = declUtils.consolidateObjects(resDeclViewModel.columnProviders, newDeclViewModel.columnProviders);\n    resDeclViewModel.chartProviders = declUtils.consolidateObjects(resDeclViewModel.chartProviders, newDeclViewModel.chartProviders);\n    resDeclViewModel.commands = declUtils.consolidateObjects(resDeclViewModel.commands, newDeclViewModel.commands);\n    resDeclViewModel.commandHandlers = declUtils.consolidateObjects(resDeclViewModel.commandHandlers, newDeclViewModel.commandHandlers);\n    resDeclViewModel.commandPlacements = declUtils.consolidateObjects(resDeclViewModel.commandPlacements, newDeclViewModel.commandPlacements); // Consolidate all properties from view model object in newDeclViewModel\n\n    var vmo = newDeclViewModel.vmo;\n\n    if (vmo) {\n      if (jsonData.data.objects) {\n        // Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.\n        //                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {\n        //                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,\n        //                                    jsonData.data.owningObjUid, dataPropValue[0] );\n        //                                if( dataPropValue[0].selected ) {\n        //                                    resDeclViewModel.vmo = newVmo;\n        //                                }\n        //                            } );\n        // The above code is no longer required. As there is no need to create a separate viewModelobject instance of\n        // of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),\n        // we already created  resDeclViewModel.vmo instance while forming the\n        // newDeclViewModel.\n        // Also difficult to determine which widgets are binded to which viewModel Object\n        resDeclViewModel.vmo = newDeclViewModel.vmo;\n        resDeclViewModel = declUtils.consolidateObjects(resDeclViewModel, newDeclViewModel.vmo.props);\n        resDeclViewModel.attachEvents();\n      } else {\n        resDeclViewModel.vmo = resDeclViewModel.attachModelObject(vmo.uid, jsonData.data.operationName, jsonData.data.owningObjUid);\n      }\n    }\n\n    resDeclViewModel._internal.consolidateJsonData(jsonData);\n\n    newDeclViewModel._internal.destroy(false);\n  } else {\n    resDeclViewModel = newDeclViewModel;\n    /**\n     * Move over fresh JSON properties\n     */\n\n    resDeclViewModel._internal.setJsonData(jsonData);\n    /**\n     * Object used to hold details of context changes that are being delayed (debounced).\n     */\n\n\n    resDeclViewModel._internal.pendingContextChanges = {};\n    /**\n     * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things\n     * calm down a bit.\n     *\n     * When running in test mode this function will not be debounced\n     *\n     * @private\n     */\n    // revisitme charu\n    // resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {\n    //     maxWait: 10000,\n    //     trailing: true,\n    //     leading: false\n    // } );\n\n    /**\n    * revisitme Shaishav\n    * Hint: It was agreed that we do not need these event subscriptions are not required anymore.\n    * Keeping comments till we support all the usecases in new declarative engine\n    /**\n     * Listener for appCtx registration events\n    var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {\n        if( context ) {\n            if( _logCtxPathActivity_1 ) {\n                logger.info( 'appCtx.register Subscribe: ' + context.name );\n            }\n             resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;\n             resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );\n        }\n    }, 'viewModelService' );\n     /**\n     * Listener for command panel 'reveal' events\n    var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {\n        /**\n         * Only call the default \"reveal\" action on reveal of main panel which doesn't have a panel ID\n         * in this context. Check if the view model available on scope is same as the result view model.\n         * In case two declarative panels are displayed on a page, then it results in two subscriptions\n         * to the panel reveal event. Use the decl view model comparison to execute action against\n         * reveal for appropriate panel\n        if( context.scope && !context.scope.panelId ) {\n            var declViewModel = context.scope.data;\n             if( declViewModel === resDeclViewModel ) {\n                exports.executeCommand( declViewModel, 'reveal', context.scope );\n            }\n        }\n    }, 'viewModelService' );\n     /**\n     * Remember these subscriptions to allow unsubscribe later.\n    resDeclViewModel._internal.eventSubscriptions.push( subDef1 );\n    resDeclViewModel._internal.eventSubscriptions.push( subDef2 );\n    */\n  }\n  /**\n   * Register any fresh 'eventBus' conditions\n   */\n\n  /**\n   * revisitme Shaishav\n   * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService\n  if( jsonData.onEvent ) {\n      var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,\n          limitEventScope, subPanelContext );\n      if( !declUtils.isNil( subPanelId ) ) {\n          if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {\n              resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;\n          } else {\n              _.forEach( eventSubscriptions, function( eventSubs ) {\n                  resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );\n              } );\n          }\n      } else {\n          resDeclViewModel._internal.eventSubscriptions = _.union(\n              resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );\n      }\n  }\n   */\n\n  /**\n   * Queue up loading and processing of the other model resources\n   */\n\n  /**\n   * revisitme Shaishav\n  * Hint: It was agreed that\n  * 1) We do not need load imports as we will rely on ES6 import / export\n  * 2) i18n population is already happening in the declreact/viewModelService.js\n  * 3) We have to populate TC preferences into the same flow when this revisitme is removed\n  * 4) Keeping comments till we support all the usecases in new declarative engine\n  var importsPromise = null;\n   if( jsonData.imports ) {\n      importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );\n  }\n   var prefPromise = null;\n   if( jsonData.preferences && jsonData.preferences.length > 0 ) {\n      prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );\n  }\n   var i18nPromise = null;\n   if( jsonData.i18n ) {\n      i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );\n  }\n   /**\n   * Wait for them all to complete\n  return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(\n      function( results ) {\n          resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,\n              results[ 1 ] );\n           resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );\n           declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );\n           return resDeclViewModel;\n      } );\n   */\n\n\n  return resDeclViewModel;\n};\n/**\n * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the\n *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.\n *\n * @param {DeclViewModel} declViewModel -\n */\n\nexport let setupLifeCycle = function (dataCtxNode, declViewModel) {\n  dataCtxNode.data = declViewModel;\n  dataCtxNode.i18n = declViewModel.i18n;\n  dataCtxNode.ctx = appCtxSvc.ctx;\n\n  if (!dataCtxNode.conditions) {\n    dataCtxNode.conditions = declViewModel.getConditionStates();\n  }\n\n  debugService.debug('lifeCycles', declViewModel._internal.panelId, 'mount');\n\n  if (declViewModel._internal.ports) {\n    if (!syncViewModelCacheService.get('syncViewModelCache')) {\n      syncViewModelCacheService.set('syncViewModelCache', {});\n    }\n\n    const id = dataCtxNode.data._internal.modelId;\n    const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n\n    if (syncViewModelCacheService.get(path) === null || syncViewModelCacheService.get(path) === undefined) {\n      syncViewModelCacheService.set('syncViewModelCache', Object.assign(syncViewModelCacheService.get('syncViewModelCache'), {\n        [dataCtxNode.data._internal.viewId]: {\n          [id]: dataCtxNode\n        }\n      }));\n    } else {\n      syncViewModelCacheService.set(path, { ...syncViewModelCacheService.get(path),\n        [id]: dataCtxNode\n      });\n    }\n\n    dataCtxNode.ports = declViewModel._internal.ports;\n  }\n  /**\n   * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)\n   * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be\n   * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the\n   * declViewModel.\n   * <P>\n   * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very\n   * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The\n   * process will use this reference to the 'original' to resolve the event processing.\n   * <P>\n   * This property is nulled out when this declViewModel is destroyed.\n   * <P>\n   * **** This property should not be used for any other purpose until we can determine it won't cause more memory\n   * issues. *****\n   */\n\n\n  if (!dataCtxNode.data._internal.dataCtxNodeId) {\n    dataCtxNode.data._internal.dataCtxNodeId = dataCtxNode.$id;\n    dataCtxNode.data._internal.origCtxNode = dataCtxNode;\n  }\n  /**\n   * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.\n   */\n\n\n  var handleDestroyEvent = function () {\n    var declViewModel2 = dataCtxNode.data;\n\n    var cleanupDataCtxNode = function () {\n      // remove vm from the syncViewModelCacheService\n      if (declViewModel2 && declViewModel2._internal && declViewModel2._internal.ports) {\n        syncViewModelCacheService.set('syncViewModelCache.' + declViewModel2._internal.viewId, null);\n      }\n      /**\n       * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be\n       * destroyed.\n       */\n\n\n      if (declViewModel2 && declViewModel2._internal.dataCtxNodeId !== dataCtxNode.$id) {\n        dataCtxNode.data = null;\n        dataCtxNode.conditions = null;\n        dataCtxNode.ctx = null;\n        dataCtxNode.i18n = null;\n        dataCtxNode.dataProvider = null;\n        dataCtxNode.eventMap = null;\n        dataCtxNode.eventData = null;\n        dataCtxNode.subPanelContext = null;\n        return;\n      }\n\n      if (declViewModel2) {\n        if (declViewModel2._internal.destroy) {\n          declViewModel2._internal.destroy(true);\n        } else {\n          logger.warn('Attempt to delete a \"dataCtxNode.data\" that did not have a destroy method: ' + declViewModel2);\n        }\n\n        dataCtxNode.conditions = null;\n        dataCtxNode.data = null;\n        dataCtxNode.ctx = null;\n        dataCtxNode.i18n = null;\n        dataCtxNode.dataProvider = null;\n        dataCtxNode.eventMap = null;\n        dataCtxNode.eventData = null;\n        dataCtxNode.subPanelContext = null;\n      }\n    };\n\n    debugService.debug('lifeCycles', declViewModel._internal.panelId, 'destroy');\n\n    var onUnmountAction = _.get(declViewModel, '_internal.lifecycleHooks.onUnmount');\n\n    if (onUnmountAction) {\n      declViewModel.isUnmounting = true;\n      exports.executeCommand(declViewModel, onUnmountAction, dataCtxNode).then(function () {\n        cleanupDataCtxNode();\n      });\n    } else {\n      cleanupDataCtxNode();\n    }\n  };\n\n  if (dataCtxNode.$$destroyed) {\n    trace('View model attached to destroyed scope', declViewModel, dataCtxNode);\n    handleDestroyEvent();\n  } else {\n    /** revisitme Shaishav: What's the alternative for the whole if / else block?\n        dataCtxNode.$on( '$destroy', handleDestroyEvent );\n    */\n  }\n\n  var onInitAction = _.get(declViewModel, '_internal.lifecycleHooks.onInit');\n\n  if (onInitAction) {\n    exports.executeCommand(declViewModel, onInitAction, dataCtxNode);\n  }\n};\n/**\n * return true for actionType dataProvider otherwise false\n * @param {string} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\nvar _isDataProviderAction = function (actionOrProviderId, declViewModel) {\n  if (declViewModel._internal.actions) {\n    var action = declViewModel._internal.actions[actionOrProviderId];\n\n    if (action && action.actionType === 'dataProvider' && declViewModel.dataProviders) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * return true for actionType other than dataProvider\n * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\n\nvar _isAnAction = function (actionOrProviderId, declViewModel) {\n  return declViewModel._internal.actions && declViewModel._internal.actions[actionOrProviderId];\n};\n/**\n *\n * return true for dataProvider and false for action\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\n\nvar _isDataProvider = function (actionOrProviderId, declViewModel) {\n  return declViewModel.dataProviders && declViewModel.dataProviders[actionOrProviderId];\n};\n/**\n * Execute command\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {String} dataCtxNode - The AngularJS scope of this action command\n *\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n *\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @returns {null|Promise} ...\n */\n\n\nexport let executeCommand = function (declViewModel, actionOrProviderId, dataCtxNode, prop, viewData) {\n  if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    return AwPromiseService.instance.resolve();\n  }\n\n  var action = null;\n\n  if (declViewModel._internal.actions) {\n    action = declViewModel._internal.actions[actionOrProviderId];\n  }\n  /**\n   * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>\n   * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.\n   */\n\n\n  if (_isDataProviderAction(actionOrProviderId, declViewModel) && action) {\n    /** action ID will be used for better logging */\n    action.actionId = actionOrProviderId;\n    return actionSvc.performDataProviderAction(declViewModel, action, dataCtxNode);\n  } else if (_isAnAction(actionOrProviderId, declViewModel)) {\n    declViewModel.getToken().addAction(action);\n    /** action ID will be used for better logging */\n\n    action.actionId = actionOrProviderId;\n\n    if (action.deps) {\n      var doAction = function (depModuleObj) {\n        /**\n         * Check if the declViewModel got destroyed while we were waiting for the dependent module to be\n         * loaded. This can happen, for example, when multiple subscribers are listening to a common\n         * event like 'selection' and one of them (I'm look at you GWT) causes the panel the\n         * declViewModel is associated with to close (thus destroying the $scope and the declViewModel\n         * associated with it).\n         * <P>\n         * If so: There is nothing more that can be done with the declViewModel and we just want to log\n         * a warning about the situation and move on.\n         */\n        if (declViewModel.isDestroyed()) {\n          declUtils.logLifeCycleIssue(declViewModel, action, 'The command action was therefore not executed.', 'executeCommand');\n        } else {\n          /**\n           * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n           * event processing was started.\n           */\n          var localDataCtx = declUtils.resolveLocalDataCtx(declViewModel, dataCtxNode); // _deps will be undefined when try to load viewModelService inside itself\n\n          var _depModuleObj = depModuleObj;\n\n          if (!depModuleObj && action.deps === 'js/viewModelService') {\n            _depModuleObj = exports;\n          }\n\n          return actionSvc.executeAction(declViewModel, action, localDataCtx, _depModuleObj, null, prop, viewData).then(function () {\n            declViewModel.getToken().removeAction(action);\n          }).catch(function (x) {\n            declViewModel.getToken().removeAction(action);\n            trace('exception', x);\n            logger.error('exception', x); //return AwPromiseService.instance.reject( x );\n          });\n        }\n\n        return undefined;\n      };\n      /**\n      * revisitme Jesse\n      * Hint: This needs to be uncommented once we have afxWeakImport supported\n      * Keeping comments till we support all the usecases in new declarative engine\n      var depModuleObj = moduleLoader.getDependentModule( action.deps );\n       if( depModuleObj ) {\n          return doAction( depModuleObj );\n      }\n       return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {\n          return doAction( depModuleObject );\n      } );\n      */\n\n\n      return loadDynModule(action.deps).then(function (depModuleObject) {\n        return doAction(depModuleObject);\n      });\n    }\n\n    return actionSvc.executeAction(declViewModel, action, dataCtxNode, null, null, prop, viewData).then(function () {\n      declViewModel.getToken().removeAction(action);\n    }).catch(function (x) {\n      declViewModel.getToken().removeAction(action);\n      trace('exception', x);\n      logger.error('exception: ' + x); //return AwPromiseService.instance.reject( x );\n    });\n  } else if (_isDataProvider(actionOrProviderId, declViewModel)) {\n    action = {};\n    action.actionType = 'dataProvider';\n    action.method = actionOrProviderId;\n    return actionSvc.performDataProviderAction(declViewModel, action, dataCtxNode);\n  }\n\n  return AwPromiseService.instance.resolve();\n};\nexports = {\n  populateViewModelPropertiesFromJson,\n  setupLifeCycle,\n  executeCommand\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","declViewModProcFact","messagingSvc","actionSvc","conditionSvc","appCtxSvc","declDataCtxService","Debug","_","logger","declUtils","debugService","syncViewModelCacheService","loadDynModule","trace","exports","eveulateEventCondition","eventObj","declViewModel","matched","props","context","fields","conditionResult","condition","conditionExpression","startsWith","conditionObject","get","_internal","expression","currContext","scope","data","subPanelContext","evaluateCondition","getLatestContext","criteria","processMessageOnEvent","getProps","inputArgs","runActionWithViewModel","getFields","allMessages","cloneDeep","messages","ctx","parameters","commandActionExecutor","reportNotyMessage","message","processActionOnEventHavingScope","executeCommand","action","processActionOnEventWithScope","reteriveInputParOfEvent","contextObj","eventData","applyScope","error","Error","handleEventDataCache","eventId","eventMap","key","value","handleRegisteredEvent","limitEventScope","getData","isFunction","debug","panelId","_source","modelId","eventSource","isValidModelAndEventData","forEach","isEventExecutable","isDeclarativeLogEnabled","debugEventSub","cacheEventData","populateViewModelPropertiesFromJson","declViewModelJson","declViewModelTarget","subPanelId","cacheI18nKey","instance","reject","eventSubscriptions","origDeclViewModelJson","newDeclViewModel","processViewModel","jsonData","resDeclViewModel","propValue","propName","dataProviders","consolidateObjects","grids","columnProviders","chartProviders","commands","commandHandlers","commandPlacements","vmo","objects","attachEvents","attachModelObject","uid","operationName","owningObjUid","consolidateJsonData","destroy","setJsonData","pendingContextChanges","setupLifeCycle","dataCtxNode","i18n","conditions","getConditionStates","ports","set","id","path","viewId","undefined","Object","assign","dataCtxNodeId","$id","origCtxNode","handleDestroyEvent","declViewModel2","cleanupDataCtxNode","dataProvider","warn","onUnmountAction","isUnmounting","then","$$destroyed","onInitAction","_isDataProviderAction","actionOrProviderId","actions","actionType","_isAnAction","_isDataProvider","prop","viewData","isValidModelAndDataCtxNode","resolve","actionId","performDataProviderAction","getToken","addAction","deps","doAction","depModuleObj","isDestroyed","logLifeCycleIssue","localDataCtx","resolveLocalDataCtx","_depModuleObj","executeAction","removeAction","catch","x","depModuleObject","method"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/viewModelService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides high level functionalities to work with view model.\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport declViewModProcFact from 'js/viewModelProcessingFactory';\nimport messagingSvc from 'js/messagingService';\nimport actionSvc from 'js/actionService';\nimport conditionSvc from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport declDataCtxService from 'js/declarativeDataCtxService';\nimport Debug from 'debug';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport declUtils from './declUtils';\nimport debugService from 'js/debugService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { loadDynModule } from 'js/moduleLoader';\n\nvar trace = new Debug( 'viewModel' );\n\nvar exports = {};\n\nconst eveulateEventCondition = function( eventObj, declViewModel, matched, props, context, fields ) {\n    var conditionResult = false;\n\n    if( eventObj.condition ) {\n        var conditionExpression = null;\n\n        if( _.startsWith( eventObj.condition, 'conditions.' ) ) {\n            var conditionObject = _.get( declViewModel._internal, eventObj.condition );\n\n            conditionExpression = conditionObject.expression;\n        } else {\n            conditionExpression = eventObj.condition;\n        }\n        let currContext = null;\n        if( context ) {\n            if( context.scope ) {\n                currContext = context.scope;\n            } else {\n                currContext = context;\n            }\n        } else {\n            currContext = { data: declViewModel, props: props, subPanelContext: props.subPanelContext, fields };\n        }\n        conditionResult = conditionSvc.evaluateCondition( declUtils.getLatestContext( currContext, declViewModel ), conditionExpression, context );\n\n        // if conditionResult is undefined or null we should consider result as false.\n        if( !conditionResult ) {\n            conditionResult = false;\n        }\n    }\n    return eventObj.condition && conditionResult || eventObj.criteria && matched ||\n        !( eventObj.condition || eventObj.criteria );\n};\n\nconst processMessageOnEvent = function( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields ) {\n    var allMessages = _.cloneDeep( declViewModel._internal.messages );\n    if( !context.scope ) {\n        context.scope = {\n            data: declViewModel,\n            ctx: appCtxSvc.ctx,\n            props,\n            getProps,\n            parameters: inputArgs ? inputArgs : null,\n            fields,\n            getFields\n        };\n        context.scope.parameters = context.scope.parameters ? {\n            ...context.scope.parameters,\n            commandActionExecutor: {\n                runActionWithViewModel\n            }\n        } : {\n            commandActionExecutor: {\n                runActionWithViewModel\n            }\n        };\n    }\n    messagingSvc.reportNotyMessage( declViewModel, allMessages, eventObj.message,\n        context.scope );\n};\n\nconst processActionOnEventHavingScope = function( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields ) {\n    context.scope.parameters = inputArgs ? inputArgs : null;\n    context.scope.parameters = context.scope.parameters ? {\n        ...context.scope.parameters,\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    } : {\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    };\n    context.scope.props = props;\n    context.scope.getProps = getProps;\n    context.scope.fields = fields;\n    context.scope.getFields = getFields;\n\n    exports.executeCommand( declViewModel, eventObj.action, context.scope );\n};\n\nconst processActionOnEventWithScope = function( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields ) {\n    var scope = {\n        data: declViewModel,\n        ctx: appCtxSvc.ctx,\n        parameters: inputArgs ? inputArgs : null,\n        subPanelContext: subPanelContext,\n        props,\n        getProps,\n        fields,\n        getFields\n    };\n    scope.parameters = scope.parameters ? {\n        ...scope.parameters,\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    } : {\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    };\n    exports.executeCommand( declViewModel, eventObj.action, scope );\n};\n\nconst reteriveInputParOfEvent = function( context, inputArgs, eventObj, declViewModel ) {\n    var contextObj = {\n        eventData: context\n    };\n    inputArgs = _.cloneDeep( eventObj.inputArgs );\n    if( inputArgs ) {\n        try {\n            declDataCtxService.applyScope( declViewModel, inputArgs, null, contextObj, null );\n        } catch ( error ) {\n            throw new Error( error );\n        }\n    }\n    return inputArgs;\n};\n\nconst handleEventDataCache = function( eventObj, declViewModel, context ) {\n    if( eventObj.eventId ) {\n        if( !declViewModel.eventMap ) {\n            declViewModel.eventMap = {};\n        }\n\n        const key = eventObj.eventId;\n        const value = {};\n        value[ key ] = context;\n        declViewModel.eventMap[ eventObj.eventId ] = value[ key ];\n        declViewModel.data.eventMap = { ...declViewModel.eventMap };\n    }\n\n    declViewModel.eventData = context;\n    declViewModel.data.eventData = context;\n};\n\n// eslint-disable-next-line complexity\nexport let handleRegisteredEvent = function( context, declViewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields ) {\n    if( declViewModel.getData && _.isFunction( declViewModel.getData ) ) {\n        declViewModel.data = declViewModel.getData();\n    }\n    const props = getProps();\n    const fields = getFields();\n    const subPanelContext = props.subPanelContext;\n    debugService.debug( 'events', declViewModel._internal.panelId, eventObj.eventId );\n\n    if( limitEventScope && context._source !== declViewModel._internal.modelId ) {\n        return;\n    }\n\n    // Check if the event source is set to 'current' and _source id is available.\n    // If yes, make event listeners only listen to events fired by the current view model instance.\n    if( eventObj.eventSource === 'current' && context._source && context._source !== declViewModel._internal.modelId ) {\n        return;\n    }\n\n    if( !declUtils.isValidModelAndEventData( declViewModel, context ) ) {\n        logger.error( '_processEventRegistration: ' + 'Invalid input: eventId=' + eventObj.eventId );\n        return;\n    }\n\n    var matched = true;\n\n    /**\n     * @deprecated : 'criteria' is deprecated we should use condition instead.\n     */\n    _.forEach( eventObj.criteria, function( value, key ) {\n        // For panel change events, the context doesn't have a scope, so check the properties on context directly.\n        if( _.get( context.scope, key ) !== value && _.get( context, key ) !== value ) {\n            matched = false;\n        }\n    } );\n\n    /**\n     * \"onEvent\": [ { \"eventId\": \"someEvent\", \"condition\": \"conditions.shouldIDoSomething\",\n     * \"action\":\"doSomething\" } ]\n     */\n\n    var isEventExecutable = eveulateEventCondition( eventObj, declViewModel, matched, props, context, fields );\n\n    if( logger.isDeclarativeLogEnabled() ) {\n        debugService.debugEventSub( eventObj, declViewModel, context, isEventExecutable );\n    }\n    if( isEventExecutable ) {\n        var inputArgs = null;\n        // Store the context eventData on declViewModel's eventData\n        if( eventObj.cacheEventData ) {\n            // const { dispatch } = declViewModel;\n            // let finalObj = {};\n            handleEventDataCache( eventObj, declViewModel, context );\n        }\n        // If an event has some eventData and the same eventdata is required in the action,\n        // associated with event, then user can construct inputArgs.\n        // \"eventId\": \"AWEvent.test\",\n        //     \"action\": \"fireSaveEdit\",\n        //         \"inputArgs\": {\n        //         \"param1\": \"{{eventData.operation1}}\",\n        //         \"param3\": {\n        //             \"param4\": \"{{eventData.operation4}}\",\n        //             \"param5\": \"{{eventData.operation5}}\"\n        //         }\n        //     }\n        // Later the same input Args can be reused in action through {{parameters.param1}}.\n\n        if( eventObj.inputArgs ) {\n            inputArgs = reteriveInputParOfEvent( context, inputArgs, eventObj, declViewModel );\n        }\n\n        if( eventObj.message ) {\n            processMessageOnEvent( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields );\n        } else if( context && context.scope ) {\n            processActionOnEventHavingScope( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields );\n        } else {\n            processActionOnEventWithScope( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields );\n        }\n    }\n};\n\n/**\n * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with\n * any data that is bound to various values including localized messages.\n *\n * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.\n *            <P>\n *            Note: The JSON contents are actually represented in the 'data' property of this object.\n *\n * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be\n *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)\n *\n * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a\n *            sub-panel\n * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by\n *            the current view model\n * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.\n *\n * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive\n *\n * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's\n *         JSON.\n */\nexport let populateViewModelPropertiesFromJson = function( declViewModelJson, declViewModelTarget, subPanelId,\n    limitEventScope, cacheI18nKey, subPanelContext ) {\n    if( !declViewModelJson ) {\n        return AwPromiseService.instance.reject( 'No ViewModel JSON object specified' );\n    }\n\n    if( declViewModelTarget ) {\n        if( !declViewModelTarget._internal.eventSubscriptions ) {\n            return AwPromiseService.instance.reject( 'Target ViewModel missing required event property' );\n        }\n\n        if( !declViewModelTarget._internal.origDeclViewModelJson ) {\n            return AwPromiseService.instance.reject( 'Target ViewModel missing required JSON object property' );\n        }\n    }\n\n    /**\n     * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved\n     * 'declViewModel'.\n     */\n    var newDeclViewModel = declViewModProcFact.processViewModel( declViewModelJson, subPanelContext );\n    var jsonData = declViewModelJson;\n\n    /**\n     * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')\n     */\n    var resDeclViewModel;\n\n    if( declViewModelTarget ) {\n        resDeclViewModel = declViewModelTarget;\n\n        /**\n         * Consolidate 'fresh' JSON properties into the given 'target'\n         * <P>\n         * Move all of the now populated 'data' properties into the 'target'\n         */\n        _.forEach( jsonData.data, function( propValue, propName ) {\n            resDeclViewModel[ propName ] = newDeclViewModel[ propName ];\n        } );\n\n        resDeclViewModel.dataProviders = declUtils.consolidateObjects( resDeclViewModel.dataProviders,\n            newDeclViewModel.dataProviders );\n\n        resDeclViewModel.grids = declUtils.consolidateObjects( resDeclViewModel.grids,\n            newDeclViewModel.grids );\n\n        resDeclViewModel.columnProviders = declUtils.consolidateObjects( resDeclViewModel.columnProviders,\n            newDeclViewModel.columnProviders );\n\n        resDeclViewModel.chartProviders = declUtils.consolidateObjects( resDeclViewModel.chartProviders,\n            newDeclViewModel.chartProviders );\n\n        resDeclViewModel.commands = declUtils.consolidateObjects( resDeclViewModel.commands,\n            newDeclViewModel.commands );\n\n        resDeclViewModel.commandHandlers = declUtils.consolidateObjects( resDeclViewModel.commandHandlers,\n            newDeclViewModel.commandHandlers );\n\n        resDeclViewModel.commandPlacements = declUtils.consolidateObjects(\n            resDeclViewModel.commandPlacements, newDeclViewModel.commandPlacements );\n\n        // Consolidate all properties from view model object in newDeclViewModel\n        var vmo = newDeclViewModel.vmo;\n        if( vmo ) {\n            if( jsonData.data.objects ) {\n                // Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.\n                //                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {\n                //                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,\n                //                                    jsonData.data.owningObjUid, dataPropValue[0] );\n                //                                if( dataPropValue[0].selected ) {\n                //                                    resDeclViewModel.vmo = newVmo;\n                //                                }\n                //                            } );\n                // The above code is no longer required. As there is no need to create a separate viewModelobject instance of\n                // of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),\n                // we already created  resDeclViewModel.vmo instance while forming the\n                // newDeclViewModel.\n                // Also difficult to determine which widgets are binded to which viewModel Object\n                resDeclViewModel.vmo = newDeclViewModel.vmo;\n                resDeclViewModel = declUtils.consolidateObjects( resDeclViewModel,\n                    newDeclViewModel.vmo.props );\n                resDeclViewModel.attachEvents();\n            } else {\n                resDeclViewModel.vmo = resDeclViewModel.attachModelObject( vmo.uid,\n                    jsonData.data.operationName, jsonData.data.owningObjUid );\n            }\n        }\n\n        resDeclViewModel._internal.consolidateJsonData( jsonData );\n        newDeclViewModel._internal.destroy( false );\n    } else {\n        resDeclViewModel = newDeclViewModel;\n\n        /**\n         * Move over fresh JSON properties\n         */\n        resDeclViewModel._internal.setJsonData( jsonData );\n\n        /**\n         * Object used to hold details of context changes that are being delayed (debounced).\n         */\n        resDeclViewModel._internal.pendingContextChanges = {};\n\n        /**\n         * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things\n         * calm down a bit.\n         *\n         * When running in test mode this function will not be debounced\n         *\n         * @private\n         */\n        // revisitme charu\n        // resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {\n        //     maxWait: 10000,\n        //     trailing: true,\n        //     leading: false\n        // } );\n\n        /**\n        * revisitme Shaishav\n        * Hint: It was agreed that we do not need these event subscriptions are not required anymore.\n        * Keeping comments till we support all the usecases in new declarative engine\n        /**\n         * Listener for appCtx registration events\n        var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {\n            if( context ) {\n                if( _logCtxPathActivity_1 ) {\n                    logger.info( 'appCtx.register Subscribe: ' + context.name );\n                }\n\n                resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;\n\n                resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Listener for command panel 'reveal' events\n        var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {\n            /**\n             * Only call the default \"reveal\" action on reveal of main panel which doesn't have a panel ID\n             * in this context. Check if the view model available on scope is same as the result view model.\n             * In case two declarative panels are displayed on a page, then it results in two subscriptions\n             * to the panel reveal event. Use the decl view model comparison to execute action against\n             * reveal for appropriate panel\n            if( context.scope && !context.scope.panelId ) {\n                var declViewModel = context.scope.data;\n\n                if( declViewModel === resDeclViewModel ) {\n                    exports.executeCommand( declViewModel, 'reveal', context.scope );\n                }\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Remember these subscriptions to allow unsubscribe later.\n        resDeclViewModel._internal.eventSubscriptions.push( subDef1 );\n        resDeclViewModel._internal.eventSubscriptions.push( subDef2 );\n        */\n    }\n\n    /**\n     * Register any fresh 'eventBus' conditions\n     */\n    /**\n     * revisitme Shaishav\n     * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService\n    if( jsonData.onEvent ) {\n        var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,\n            limitEventScope, subPanelContext );\n        if( !declUtils.isNil( subPanelId ) ) {\n            if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {\n                resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;\n            } else {\n                _.forEach( eventSubscriptions, function( eventSubs ) {\n                    resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );\n                } );\n            }\n        } else {\n            resDeclViewModel._internal.eventSubscriptions = _.union(\n                resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );\n        }\n    }\n     */\n\n    /**\n     * Queue up loading and processing of the other model resources\n     */\n    /**\n     * revisitme Shaishav\n    * Hint: It was agreed that\n    * 1) We do not need load imports as we will rely on ES6 import / export\n    * 2) i18n population is already happening in the declreact/viewModelService.js\n    * 3) We have to populate TC preferences into the same flow when this revisitme is removed\n    * 4) Keeping comments till we support all the usecases in new declarative engine\n    var importsPromise = null;\n\n    if( jsonData.imports ) {\n        importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );\n    }\n\n    var prefPromise = null;\n\n    if( jsonData.preferences && jsonData.preferences.length > 0 ) {\n        prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );\n    }\n\n    var i18nPromise = null;\n\n    if( jsonData.i18n ) {\n        i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );\n    }\n\n    /**\n     * Wait for them all to complete\n    return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(\n        function( results ) {\n            resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,\n                results[ 1 ] );\n\n            resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );\n\n            declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );\n\n            return resDeclViewModel;\n        } );\n     */\n    return resDeclViewModel;\n};\n\n/**\n * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the\n *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.\n *\n * @param {DeclViewModel} declViewModel -\n */\nexport let setupLifeCycle = function( dataCtxNode, declViewModel ) {\n    dataCtxNode.data = declViewModel;\n    dataCtxNode.i18n = declViewModel.i18n;\n    dataCtxNode.ctx = appCtxSvc.ctx;\n\n    if( !dataCtxNode.conditions ) {\n        dataCtxNode.conditions = declViewModel.getConditionStates();\n    }\n\n    debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'mount' );\n\n    if( declViewModel._internal.ports ) {\n        if( !syncViewModelCacheService.get( 'syncViewModelCache' ) ) {\n            syncViewModelCacheService.set( 'syncViewModelCache', {} );\n        }\n        const id = dataCtxNode.data._internal.modelId;\n        const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n        if( syncViewModelCacheService.get( path ) === null || syncViewModelCacheService.get( path ) === undefined ) {\n            syncViewModelCacheService.set( 'syncViewModelCache', Object.assign( syncViewModelCacheService.get( 'syncViewModelCache' ), {\n                [ dataCtxNode.data._internal.viewId ]: {\n                    [ id ]: dataCtxNode\n                }\n            } ) );\n        } else {\n            syncViewModelCacheService.set( path, { ...syncViewModelCacheService.get( path ), [ id ]: dataCtxNode } );\n        }\n        dataCtxNode.ports = declViewModel._internal.ports;\n    }\n\n    /**\n     * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)\n     * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be\n     * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the\n     * declViewModel.\n     * <P>\n     * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very\n     * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The\n     * process will use this reference to the 'original' to resolve the event processing.\n     * <P>\n     * This property is nulled out when this declViewModel is destroyed.\n     * <P>\n     * **** This property should not be used for any other purpose until we can determine it won't cause more memory\n     * issues. *****\n     */\n    if( !dataCtxNode.data._internal.dataCtxNodeId ) {\n        dataCtxNode.data._internal.dataCtxNodeId = dataCtxNode.$id;\n        dataCtxNode.data._internal.origCtxNode = dataCtxNode;\n    }\n\n    /**\n     * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.\n     */\n    var handleDestroyEvent = function() {\n        var declViewModel2 = dataCtxNode.data;\n        var cleanupDataCtxNode = function() {\n            // remove vm from the syncViewModelCacheService\n            if( declViewModel2 && declViewModel2._internal && declViewModel2._internal.ports ) {\n                syncViewModelCacheService.set( 'syncViewModelCache.' + declViewModel2._internal.viewId, null );\n            }\n\n            /**\n             * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be\n             * destroyed.\n             */\n            if( declViewModel2 && declViewModel2._internal.dataCtxNodeId !== dataCtxNode.$id ) {\n                dataCtxNode.data = null;\n                dataCtxNode.conditions = null;\n                dataCtxNode.ctx = null;\n                dataCtxNode.i18n = null;\n                dataCtxNode.dataProvider = null;\n                dataCtxNode.eventMap = null;\n                dataCtxNode.eventData = null;\n                dataCtxNode.subPanelContext = null;\n                return;\n            }\n\n            if( declViewModel2 ) {\n                if( declViewModel2._internal.destroy ) {\n                    declViewModel2._internal.destroy( true );\n                } else {\n                    logger.warn( 'Attempt to delete a \"dataCtxNode.data\" that did not have a destroy method: ' +\n                        declViewModel2 );\n                }\n                dataCtxNode.conditions = null;\n                dataCtxNode.data = null;\n                dataCtxNode.ctx = null;\n                dataCtxNode.i18n = null;\n                dataCtxNode.dataProvider = null;\n                dataCtxNode.eventMap = null;\n                dataCtxNode.eventData = null;\n                dataCtxNode.subPanelContext = null;\n            }\n        };\n        debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'destroy' );\n        var onUnmountAction = _.get( declViewModel, '_internal.lifecycleHooks.onUnmount' );\n        if( onUnmountAction ) {\n            declViewModel.isUnmounting = true;\n            exports.executeCommand( declViewModel, onUnmountAction, dataCtxNode ).then( function() {\n                cleanupDataCtxNode();\n            } );\n        } else {\n            cleanupDataCtxNode();\n        }\n    };\n\n    if( dataCtxNode.$$destroyed ) {\n        trace( 'View model attached to destroyed scope', declViewModel, dataCtxNode );\n        handleDestroyEvent();\n    } else {\n        /** revisitme Shaishav: What's the alternative for the whole if / else block?\n            dataCtxNode.$on( '$destroy', handleDestroyEvent );\n        */\n    }\n\n    var onInitAction = _.get( declViewModel, '_internal.lifecycleHooks.onInit' );\n    if( onInitAction ) {\n        exports.executeCommand( declViewModel, onInitAction, dataCtxNode );\n    }\n};\n\n/**\n * return true for actionType dataProvider otherwise false\n * @param {string} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isDataProviderAction = function( actionOrProviderId, declViewModel ) {\n    if( declViewModel._internal.actions ) {\n        var action = declViewModel._internal.actions[ actionOrProviderId ];\n        if( action && action.actionType === 'dataProvider' && declViewModel.dataProviders ) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * return true for actionType other than dataProvider\n * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isAnAction = function( actionOrProviderId, declViewModel ) {\n    return declViewModel._internal.actions && declViewModel._internal.actions[ actionOrProviderId ];\n};\n\n/**\n *\n * return true for dataProvider and false for action\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isDataProvider = function( actionOrProviderId, declViewModel ) {\n    return declViewModel.dataProviders && declViewModel.dataProviders[ actionOrProviderId ];\n};\n\n/**\n * Execute command\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {String} dataCtxNode - The AngularJS scope of this action command\n *\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n *\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @returns {null|Promise} ...\n */\nexport let executeCommand = function( declViewModel, actionOrProviderId, dataCtxNode, prop, viewData ) {\n    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        return AwPromiseService.instance.resolve();\n    }\n\n    var action = null;\n\n    if( declViewModel._internal.actions ) {\n        action = declViewModel._internal.actions[ actionOrProviderId ];\n    }\n\n    /**\n     * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>\n     * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.\n     */\n\n    if( _isDataProviderAction( actionOrProviderId, declViewModel ) && action ) {\n        /** action ID will be used for better logging */\n        action.actionId = actionOrProviderId;\n        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );\n    } else if( _isAnAction( actionOrProviderId, declViewModel ) ) {\n        declViewModel.getToken().addAction( action );\n        /** action ID will be used for better logging */\n        action.actionId = actionOrProviderId;\n        if( action.deps ) {\n            var doAction = function( depModuleObj ) {\n                /**\n                 * Check if the declViewModel got destroyed while we were waiting for the dependent module to be\n                 * loaded. This can happen, for example, when multiple subscribers are listening to a common\n                 * event like 'selection' and one of them (I'm look at you GWT) causes the panel the\n                 * declViewModel is associated with to close (thus destroying the $scope and the declViewModel\n                 * associated with it).\n                 * <P>\n                 * If so: There is nothing more that can be done with the declViewModel and we just want to log\n                 * a warning about the situation and move on.\n                 */\n                if( declViewModel.isDestroyed() ) {\n                    declUtils.logLifeCycleIssue( declViewModel, action, 'The command action was therefore not executed.',\n                        'executeCommand' );\n                } else {\n                    /**\n                     * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n                     * event processing was started.\n                     */\n                    var localDataCtx = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );\n\n                    // _deps will be undefined when try to load viewModelService inside itself\n                    var _depModuleObj = depModuleObj;\n\n                    if( !depModuleObj && action.deps === 'js/viewModelService' ) {\n                        _depModuleObj = exports;\n                    }\n\n                    return actionSvc.executeAction( declViewModel, action, localDataCtx, _depModuleObj, null, prop, viewData ).then( function() {\n                        declViewModel.getToken().removeAction( action );\n                    } ).catch( function( x ) {\n                        declViewModel.getToken().removeAction( action );\n                        trace( 'exception', x );\n                        logger.error( 'exception', x );\n                        //return AwPromiseService.instance.reject( x );\n                    } );\n                }\n                return undefined;\n            };\n\n            /**\n            * revisitme Jesse\n            * Hint: This needs to be uncommented once we have afxWeakImport supported\n            * Keeping comments till we support all the usecases in new declarative engine\n            var depModuleObj = moduleLoader.getDependentModule( action.deps );\n\n            if( depModuleObj ) {\n                return doAction( depModuleObj );\n            }\n\n            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {\n                return doAction( depModuleObject );\n            } );\n            */\n            return loadDynModule( action.deps ).then( function( depModuleObject ) {\n                return doAction( depModuleObject );\n            } );\n        }\n        return actionSvc.executeAction( declViewModel, action, dataCtxNode, null, null, prop, viewData ).then( function() {\n            declViewModel.getToken().removeAction( action );\n        } ).catch( function( x ) {\n            declViewModel.getToken().removeAction( action );\n            trace( 'exception', x );\n            logger.error( 'exception: ' + x );\n            //return AwPromiseService.instance.reject( x );\n        } );\n    } else if( _isDataProvider( actionOrProviderId, declViewModel ) ) {\n        action = {};\n        action.actionType = 'dataProvider';\n        action.method = actionOrProviderId;\n        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );\n    }\n\n    return AwPromiseService.instance.resolve();\n};\n\nexports = {\n    populateViewModelPropertiesFromJson,\n    setupLifeCycle,\n    executeCommand\n};\nexport default exports;\n"],"mappings":"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BAAnB;IAEA;AACR;AACA;;IACQG,gBAAgB,CAAChE,SAAjB,CAA2BoF,WAA3B,CAAwCrB,QAAxC;IAEA;AACR;AACA;;;IACQC,gBAAgB,CAAChE,SAAjB,CAA2BqF,qBAA3B,GAAmD,EAAnD;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ;IACA;IACA;IACA;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAMK;EAED;AACJ;AACA;;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAUI,OAAOrB,gBAAP;AACH,CApOM;AAsOP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIsB,cAAc,GAAG,UAAUC,WAAV,EAAuBlG,aAAvB,EAAuC;EAC/DkG,WAAW,CAACnF,IAAZ,GAAmBf,aAAnB;EACAkG,WAAW,CAACC,IAAZ,GAAmBnG,aAAa,CAACmG,IAAjC;EACAD,WAAW,CAACtE,GAAZ,GAAkBzC,SAAS,CAACyC,GAA5B;;EAEA,IAAI,CAACsE,WAAW,CAACE,UAAjB,EAA8B;IAC1BF,WAAW,CAACE,UAAZ,GAAyBpG,aAAa,CAACqG,kBAAd,EAAzB;EACH;;EAED5G,YAAY,CAAC2D,KAAb,CAAoB,YAApB,EAAkCpD,aAAa,CAACW,SAAd,CAAwB0C,OAA1D,EAAmE,OAAnE;;EAEA,IAAIrD,aAAa,CAACW,SAAd,CAAwB2F,KAA5B,EAAoC;IAChC,IAAI,CAAC5G,yBA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"},"metadata":{},"sourceType":"module"}