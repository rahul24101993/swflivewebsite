{"ast":null,"code":"/* eslint-disable complexity */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2021 Siemens\n\n/**\n * Data provider factory\n *\n * @module js/dataProviderFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport viewModelCollectionFactory from 'js/viewModelCollectionFactory';\nimport localeSvc from 'js/localeService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport dataSourceService from 'js/dataSourceService';\nimport dataCtxService from 'js/declarativeDataCtxService';\nimport declModelRegistrySvc from 'js/declModelRegistryService';\nimport editUtilsService from 'js/editUtilsService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport debugService from 'js/debugService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport awTableSvc from 'js/awTableService';\nimport editHandlerFactory from 'js/editHandlerFactory';\nimport declDataProviderSvc from 'js/declDataProviderService';\nimport cfgSvc from 'js/configurationService';\nconst jsonData = cfgSvc.getCfgCached('lovDataProvider');\nimport Debug from 'debug';\nconst trace = new Debug('selection');\n/**\n * {StringArray} Collection of valid properties in the 'inputData' property of dataProvider's JSON definition.\n */\n\nvar _modifiablePropertiesViaInputData = ['selectionModel', 'accessMode', 'topNodeUid', 'editSupportParamKeys'];\n/**\n * {Boolean} TRUE if tree node insertion details should be logged.\n */\n\nvar _debug_logTreeLoadActivity = false;\n/**\n * Constructs an object that wraps access to a 'viewModelCollection' created by the\n * 'viewModelCollectionFactory'.\n *\n * @class UwDataProvider\n *\n * @param {QueueService} $q - Queue service to use.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {ViewModelCollection} viewModelCollection - The 'viewModelCollection' used to hold all\n *            ViewModelObjects managed by this DataProvider.\n *\n * @param {StringMap} actionMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n */\n\nvar UwDataProvider = function ($q, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, viewModelCollection, actionMap) {\n  var dpSelf = this; // eslint-disable-line consistent-this\n\n  /**\n   * Data that is passed into the data provider constructor from outside of the view model.\n   */\n\n  var _ctorInputData = dataProviderJson ? dataProviderJson.inputData : null;\n  /**\n   *  This private variable would contain the pagination options and non-modifibale from outside.\n   */\n\n\n  let paginationOption = null;\n  /**\n   *  The filter string to be used in getFirstPage/getNextPage APi's\n   */\n\n  let filterStr = null;\n  let propsCallback = null;\n  /**\n   *  selectionModelDispatcher : Dispatcher to update the selection Model on the fly.\n   */\n\n  let selectionModelDispatcher;\n  /**\n   *\n   */\n\n  let lovEntryRef = null;\n  /**\n   *  This private variable would contain the reference of the top level referenceElement of list/table/ user defined widget\n   *  using data-provider\n   */\n\n  let referenceElement = null;\n  /**\n   * {Boolean} TRUE if 'destroy' has been invoked on this instance.\n   */\n\n  dpSelf._isDestroyed = false;\n  /**\n   * @property {String} noResultsFound - Localized message stating 'No results found'.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.noResultsFound = null;\n  /**\n   * @property {String} isLoading - Localized message stating 'loading'.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.isLoading = null;\n  /**\n   * @property {Boolean} cacheCollapse - cache collapse infomation to reuse in next expand.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.cacheCollapse = false;\n  /**\n   * @property {Object} someDataProviderSvc - Some API object where 'getFirstPage', 'getNextPage', et al.\n   *           methods are implemented (e.g. 'js/declDataProviderService').\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.someDataProviderSvc = someDataProviderSvc;\n  /**\n   * @property {String} name - name of data provider object\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.name = dataProviderName;\n  /**\n   * @property {ViewModelCollection} viewModelCollection - viewModelCollection which maintains the loaded\n   *           ViewModelObjects and also have APIs to access the information of collection.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.viewModelCollection = viewModelCollection;\n  /**\n   * @property {Number} startIndex - Start/Next index into a virtual list.\n   *           <P>\n   *           Note: This property is accessed by some declViewModel bindings and 'glue' code. While it is\n   *           somewhat analogous to the data in the newer 'cursorObject', it is necessary to keep it exposed\n   *           for support of these earlier uses of it.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.startIndex = 0;\n  /**\n   * @property {DeclAction} action - The 'declAction' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.action = null;\n  /**\n   * @property {DeclAction} action - The 'declAction' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.focusAction = null;\n  /**\n   * @property {DeclDataProviderJson} json - The 'UwDataProvider' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.json = null;\n  /**\n   * @property {Object} policy - The Currently set property policy object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.policy = null;\n  /**\n   * @property {Object} selectionModel - Object which maintains all the selection objects stuff and provides\n   *           APIs to access information.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n  // dpSelf.selectionModel = selectionModelFactory\n  //     .buildSelectionModel( dataProviderJson ? dataProviderJson.selectionModelMode : null );\n\n  /**\n   * @property {Boolean} noResults - Flag decides whether to show no results message if there are no values\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.noResults = false;\n  /**\n   * @property {ObjectArray} sortCriteria - Array of ordered sort criteria objects.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.sortCriteria = [];\n  /**\n   * @property {Object} filiterMap - A map (string, list of SearchFilter) containing the list of search\n   *           filters for each search filter field. The key in the map is the property name that represents\n   *           the filter category. It is in the format \"TypeName.PropertyName\". e.g\n   *           WorkspaceObject.object_type\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.filterMap = {};\n  /**\n   * @property {ViewModelTreeNode} The ViewModelTReeNode which is the logical (but unseen) 'top' node in any\n   *           hierarchy being managed by this UwDataProvider\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.topTreeNode = null;\n  /**\n   * Selected objects\n   */\n\n  dpSelf.selectedObjects = [];\n  /**\n   * {Boolean} TRUE if any editHandler associated with this UwDataProvider has been registered.\n   */\n\n  var _editHandlerRegistered;\n\n  const updateDataCtxNodeWithProps = function (dataCtxNode) {\n    if (propsCallback) {\n      dataCtxNode.props = propsCallback();\n      dataCtxNode.getProps = propsCallback;\n    }\n  }; // Toggle the display of Cell Decorators.\n\n\n  dpSelf.toggleDecoratorsEvent = eventBus.subscribe(dpSelf.name + '.toggleCellDecorators', function (eventData) {\n    if (eventData) {\n      dpSelf.showDecorators = eventData.toggleState;\n    } else {\n      if (dpSelf.showDecorators) {\n        dpSelf.showDecorators = false;\n      } else {\n        dpSelf.showDecorators = true;\n      }\n    }\n  });\n\n  const saveRowExpanded = function (dataCtxNode, node) {\n    if (node.isExpanded === true) {\n      var declViewModel = declUtils.findViewModel(dataCtxNode);\n      var grids = declViewModel.grids;\n      awTableStateSvc.saveRowExpanded(declViewModel, grids[Object.keys(grids)[0]].gridid, node);\n    }\n  };\n  /**\n   * Fire modelObjects updated event using data provider name space\n   *\n   * @param {Object} dataCtxNode - The 'scope' to use.\n   * @param {Object} eventData - Event data containing data to include in notify.\n   */\n\n\n  var _notifyModelObjectsUpdate = function (dataCtxNode, eventData) {\n    if (dataCtxNode) {\n      dpSelf.syncSelectionModel(dataCtxNode);\n    }\n\n    eventData = eventData || {}; // Set standard data\n\n    eventData.viewModelObjects = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    eventData.noResults = dpSelf.noResults; // Publish event\n\n    eventBus.publish(dpSelf.name + '.modelObjectsUpdated', eventData);\n  };\n\n  dpSelf.notifyModelObjectsUpdate = _notifyModelObjectsUpdate;\n  /**\n   * Insert the given array of ViewModelObjects into the given viewModelCollection starting after the given\n   * 'cursor' ViewModelObject ID.\n   *\n   * @param {ViewModelCollection} vmCollection - The ViewModelCollection to update.\n   * @param {String} cursorId - ID of the object The ViewModelObject in the collection to insert after.\n   * @param {ViewModelObjectArray} vmosToInsert - The ViewModelObjects to insert.\n   * @param {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n   *            (Default: TRUE)\n   */\n\n  function _insertModelObjects(vmCollection, cursorId, vmosToInsert, addAfter) {\n    var cursorNdx = vmCollection.findViewModelObjectById(cursorId);\n    var cursorNode = cursorNdx === -1 ? null : vmCollection.getViewModelObject(cursorNdx);\n    var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n\n    if (_debug_logTreeLoadActivity) {\n      logger.info('_insertModelObjects: ' + '\\n' + //\n      'n1stLevelFound : ' + vmCollection.totalFound + '\\n' + //\n      'n1stLevelLoaded: ' + vmCollection.totalObjectsLoaded + '\\n' + //\n      'nLoadedOverall : ' + loadedVMOs.length + '\\n' + //\n      'cursorId       : ' + cursorId + '\\n' + //\n      'nVMOsToInsert  : ' + vmosToInsert.length + '\\n' + //\n      'addAfter       : ' + addAfter + '\\n' + //\n      'cursorNdx      : ' + cursorNdx + '\\n' + //\n      'cursorNode     : ' + cursorNode);\n    }\n    /**\n     * Check if we found where to insert and it is NOT the top level node.\n     * <P>\n     * Note: This function purposefully does not maintain the 'totalObjectsLoaded' for the overall\n     * viewModelCollection since that value only makes sense for the 'top' node.\n     */\n\n\n    if (cursorNode && cursorNode.levelNdx !== -1) {\n      var childNdxOffset;\n\n      if (addAfter) {\n        /**\n         * Check if the VMOs being inserted are from the same level of the tree.<BR>\n         * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n         * property is helpful when debugging.\n         */\n        if (cursorNode.levelNdx === vmosToInsert[0].levelNdx) {\n          childNdxOffset = loadedVMOs[cursorNdx].childNdx + 1;\n\n          for (var ndx1 = 0; ndx1 < vmosToInsert.length; ndx1++) {\n            vmosToInsert[ndx1].childNdx = childNdxOffset + ndx1;\n          }\n        }\n        /**\n         * AW-49335 - Jumping to target does not work when page is refreshed...\n         * <P>\n         * Check if the 'cursor' node has any children<br>\n         * If so: We need to account for them before we insert\n         * <P>\n         * Note: We look forward until we find a node at the same (or 'above') level.\n         */\n\n\n        var insertNdx = cursorNdx;\n\n        for (var ndx3 = cursorNdx + 1; ndx3 < loadedVMOs.length; ndx3++) {\n          if (loadedVMOs[ndx3].levelNdx <= cursorNode.levelNdx) {\n            break;\n          }\n\n          insertNdx++;\n        }\n\n        arrayUtils.insert(loadedVMOs, insertNdx, vmosToInsert);\n      } else {\n        /**\n         * Check if the VMOs being inserted are from the same level of the tree.<BR>\n         * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n         * property is helpful when debugging.\n         */\n        if (cursorNode.levelNdx === vmosToInsert[0].levelNdx) {\n          childNdxOffset = loadedVMOs[cursorNdx].childNdx - vmosToInsert.length;\n\n          for (var ndx2 = 0; ndx2 < vmosToInsert.length; ndx2++) {\n            vmosToInsert[ndx2].childNdx = childNdxOffset + ndx2;\n          }\n        }\n        /**\n         * Insert just before the 'cursor' node.\n         * <P>\n         * Note: Even if the 'cursor' node is preceded by any children from an earlier 'sibling' (i.e. a\n         * node at the same tree level) we do NOT need to account for them before we insert since the\n         * 'cursor' position defines the correct break in the tree level.\n         */\n\n\n        arrayUtils.insertBefore(loadedVMOs, cursorNdx, vmosToInsert);\n      }\n    }\n  } // _insertModelObjects\n\n  /**\n   * Locate the 'child' in the given 'parent' based on the 'child' node's ID.\n   *\n   * @param {ViewModelTreeNode} parentNode - The 'parent' who's 'children' to search.\n   * @param {String} cursorNodeId - The ID of the 'child' node to find.\n   * @returns {Number} Index to the 'child' node (or -1 if not found)\n   */\n\n\n  function _findChildNdx(parentNode, cursorNodeId) {\n    var nChild = parentNode.children ? parentNode.children.length : 0;\n\n    if (cursorNodeId) {\n      for (var ndx = 0; ndx < nChild; ndx++) {\n        if (parentNode.children[ndx].id === cursorNodeId) {\n          return ndx;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Insert the results into the ViewModelCollection array starting at the current location of the 'cursor'\n   * node.\n   *\n   * @param {TreeLoadInput} treeLoadInput - The original input parameters used to generate the response we are\n   *            processing now.\n   *\n   * @param {Object} responseObj - Object returned from the associated load 'action'\n   *\n   * @param {Object} dataCtxNode - Data context used for selection model sync.\n   *\n   * @param {Object} origCursorObj - The cursorObject of the 'parent' node BEFORE the load operation.\n   *\n   * @return {ViewModelCollection} A reference to the updated ViewModelCollection object.\n   */\n\n\n  function _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj) {\n    // eslint-disable-line\n    assert(responseObj, 'Action did not return a ResponseResult Object');\n    var treeLoadResult = responseObj.treeLoadResult;\n    let vmCollection = dpSelf.viewModelCollection;\n    assert(treeLoadResult, 'Action did not return a TreeLoadResult Object');\n    /**\n     * Move the 'parent' and 'viewModelCollection' into handier variables.\n     */\n\n    var resultParentNode = treeLoadResult.parentNode;\n    let response = {\n      totalFound: vmCollection.totalFound,\n      loadedVMObjects: vmCollection.loadedVMObjects\n    };\n    /**\n     * Determine if we are working on the very top node of the tree.\n     */\n\n    var isParentRoot = resultParentNode && resultParentNode.levelNdx === -1;\n    /**\n     * Optionally log some useful information\n     */\n\n    if (_debug_logTreeLoadActivity && !_.isEmpty(treeLoadResult.childNodes)) {\n      logger.info('_processLoadTreeNodePageResponse' + '\\n' + 'parentNode: ' + resultParentNode + ' isParentRoot: ' + isParentRoot + '\\n' + '# children returned: ' + treeLoadResult.childNodes.length);\n    }\n    /**\n     * AW-47271 - bash_PI1712-2 : Can Not expand Sub Assembly in tree View in a spcific scenario\n     * <P>\n     * Find the original 'parent' node in the vmCollection and see if it is still expanded.\n     * <P>\n     * Note: If we are working on the 'root', skip this check since the 'root' cannot actually be collapsed.\n     */\n\n\n    if (!isParentRoot) {\n      /**\n       * Check if NOT expanded<BR>\n       * If so: No need to continue. Return current vmCollection unchanged.\n       * <P>\n       * Note: The 'parent' node returned from the async processing can sometimes be a clone made during\n       * processing. It is best to go back to the original to be sure we do not miss the latest state.\n       */\n      var origParentNdx = vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(resultParentNode));\n\n      if (origParentNdx === -1 || !vmCollection.getViewModelObject(origParentNdx).isExpanded) {\n        if (_debug_logTreeLoadActivity) {\n          logger.info('_processLoadTreeNodePageResponse: Skipping insertion of child nodes into collapsed or missing parent' + '\\n' + 'parent: ' + resultParentNode + '\\n' + 'index: ' + origParentNdx);\n        }\n\n        return {\n          totalFound: vmCollection.getTotalObjectsFound(),\n          loadedVMObjects: vmCollection.getLoadedViewModelObjects()\n        };\n      }\n    }\n    /**\n     * Check if we actually have results to insert.\n     */\n\n\n    var newTopNode;\n    var moreAboveFirst;\n    var moreBelowLast;\n\n    if (treeLoadResult.totalChildCount > 0 && !_.isEmpty(treeLoadResult.childNodes)) {\n      /**\n       * If this is the 'top' level node we now know IT is NOT empty.\n       */\n      if (isParentRoot) {\n        dpSelf.noResults = false;\n      }\n\n      var expectantParentNode = resultParentNode;\n      /**\n       * Get the effective 'parent' node from the paths (if necessary)\n       */\n\n      var nRootPaths = _.isEmpty(treeLoadResult.rootPathNodes) ? 0 : treeLoadResult.rootPathNodes.length;\n      var usedPathParent;\n\n      if (nRootPaths > 0) {\n        /**\n         * Get the 'top' node based on the path but do not override the current 'expectantParentNode'\n         * unless it refers to a different object.\n         */\n        var resultTopNode = _.last(treeLoadResult.rootPathNodes);\n\n        if (resultParentNode.uid !== resultTopNode.uid) {\n          expectantParentNode = resultTopNode;\n          usedPathParent = true;\n        }\n      }\n      /**\n       * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n       * <P>\n       * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n       * 'top' children into the ViewModelCollection. Do not do this!\n       */\n\n\n      newTopNode = treeLoadResult.newTopNode;\n\n      if (newTopNode && newTopNode.levelNdx === -1) {\n        dpSelf.topTreeNode = newTopNode;\n        dpSelf.topTreeNode.children = null;\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n        if (!usedPathParent) {\n          resultParentNode = treeLoadResult.newTopNode;\n        }\n      }\n      /**\n       * Determine if we are inserting before or after the 'start' or 'cursor' node.\n       */\n\n\n      var addAfter = declUtils.isNil(treeLoadInput.addAfter) ? true : treeLoadInput.addAfter;\n      /**\n       * Check for the trivial case of 1st-time children\n       * <P>\n       * Note: We do a shallow clone to make sure it is not the same array as the result.\n       */\n\n      var newParent = _.isEmpty(expectantParentNode.children);\n\n      if (newParent) {\n        expectantParentNode.children = _.clone(treeLoadResult.childNodes);\n      } else {\n        /**\n         * Insert the new 'child' nodes into the 'children' array property of the 'parent' node.\n         * <P>\n         * Try to use the 'cursor' node to locate exactly where in the 'parent' to insert the new\n         * 'child' nodes.\n         * <P>\n         * If no 'cursor' then just trust the previous index as a 'best guess' (works in a downward list\n         * scenario).\n         * <P>\n         * Note: We have to do this since some cases where the children were inserted out of order or\n         * even had duplicates. Relocating the 'cursor' locks it in for at least 'this' thread pass.\n         */\n        var cursorChildNdx = _findChildNdx(expectantParentNode, treeLoadResult.cursorNodeId);\n\n        var insertionChildNdx = cursorChildNdx;\n\n        if (addAfter) {\n          /**\n           * Reset the 'start' info of the 'parent' node (Server bug? we should not have to do this)\n           */\n          if (origCursorObj) {\n            expectantParentNode.cursorObject.startIndex = origCursorObj.startIndex;\n            expectantParentNode.cursorObject.startOccUid = origCursorObj.startOccUid;\n            expectantParentNode.cursorObject.startReached = origCursorObj.startReached;\n          }\n          /**\n           * First new 'child' node inserted AFTER another cannot be an 'incompleteHead'.\n           */\n\n\n          _.first(treeLoadResult.childNodes).incompleteHead = false;\n          /**\n           * Insert new 'child' nodes into 'parent' AFTER cursor 'child' node.\n           * <P>\n           * Note: Original cursor 'child' can no longer be an 'incompleteTail'.\n           */\n\n          if (insertionChildNdx === -1) {\n            insertionChildNdx = treeLoadResult.startChildNdx;\n          } else {\n            expectantParentNode.children[cursorChildNdx].incompleteTail = false;\n            insertionChildNdx++;\n          }\n\n          arrayUtils.insert(expectantParentNode.children, insertionChildNdx, treeLoadResult.childNodes);\n        } else {\n          /**\n           * Reset the 'end' info of the 'parent' node (Server bug? we should not have to do this)\n           */\n          if (origCursorObj) {\n            expectantParentNode.cursorObject.endIndex = origCursorObj.endIndex;\n            expectantParentNode.cursorObject.endOccUid = origCursorObj.endOccUid;\n            expectantParentNode.cursorObject.endReached = origCursorObj.endReached;\n          }\n          /**\n           * Last new 'child' node inserted BEFORE another cannot be an 'incompleteTail'\n           */\n\n\n          _.last(treeLoadResult.childNodes).incompleteTail = false;\n          /**\n           * Insert new 'child' nodes into 'parent' BEFORE cursor 'child' node.\n           * <P>\n           * Note: Original cursor 'child' can no longer be an 'incompleteHead'.\n           */\n\n          if (insertionChildNdx === -1) {\n            insertionChildNdx = treeLoadResult.startChildNdx;\n          } else {\n            expectantParentNode.children[cursorChildNdx].incompleteHead = false;\n          }\n\n          arrayUtils.insertBefore(expectantParentNode.children, insertionChildNdx, treeLoadResult.childNodes);\n        }\n      }\n      /**\n       * Fire a 'resetState' event, sourced to this uwDataProvider, for all tree-table 'focused load'\n       * cases.\n       */\n\n\n      if (!treeLoadResult.retainTreeExpansionStates) {\n        if (isParentRoot && treeLoadResult.isFocusedLoad) {\n          eventBus.publish(dpSelf.name + '.resetState', {});\n        }\n      }\n      /**\n       * Check if we were given a non-trivial path to a root (the new 'child' nodes are to be added to the\n       * bottom of).\n       */\n\n\n      if (nRootPaths > 1 && newParent) {\n        dpSelf.topTreeNode = _.first(treeLoadResult.rootPathNodes);\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n        if (!treeLoadResult.vmNodesInTreeHierarchyLevels) {\n          var newNodes = [];\n          var prevParentNode = treeLoadResult.rootPathNodes[0];\n\n          for (var ndx = 1; ndx < treeLoadResult.rootPathNodes.length; ndx++) {\n            var parent = treeLoadResult.rootPathNodes[ndx];\n            newNodes.push(parent);\n            prevParentNode.children = [parent];\n            /**\n             * If expansion states are cleared after 'resetState' event, tree hierarchy that we are\n             * creating while building tree using rootPathNodes, those rootPathNodes should be saved in\n             * expansion state as they are expanded.\n             * <P>\n             * This is required for tree refresh scenarios (the level the user is working on should get\n             * restored after refresh)\n             */\n\n            saveRowExpanded(dataCtxNode, parent);\n            prevParentNode = parent;\n          }\n          /**\n           * Mark the children to be 1 level below the 'expectant' parent\n           */\n\n\n          var nextLevelNdx = _.last(treeLoadResult.rootPathNodes).levelNdx + 1;\n\n          for (var ndx2 = 0; ndx2 < treeLoadResult.childNodes.length; ndx2++) {\n            var child = treeLoadResult.childNodes[ndx2];\n            child.levelNdx = nextLevelNdx;\n            child.$$treeLevel = nextLevelNdx;\n            newNodes.push(child);\n          }\n          /**\n           * Put all the 'parent' path + 'child' nodes as the sole content of the collection\n           */\n\n\n          response.totalFound = treeLoadResult.rootPathNodes.length - 1 + treeLoadResult.totalChildCount;\n          response.loadedVMObjects = newNodes;\n        } else {\n          var currentlyLoadedRootPathNodeVMO = null;\n          var startLevelIndex = 0;\n          var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n          var numberOfLevelsToBeInserted = 0; // Check if there is request to merge new ViewModelTreeNodes from TreeLoadResult into existing loaded VMOs.\n\n          if (treeLoadResult.mergeNewNodesInCurrentlyLoadedTree && loadedVMOs) {\n            for (startLevelIndex = treeLoadResult.rootPathNodes.length; startLevelIndex >= 1; startLevelIndex--) {\n              currentlyLoadedRootPathNodeVMO = loadedVMOs.filter(function (vmo) {\n                return treeLoadResult.rootPathNodes[startLevelIndex - 1] && vmo.id === treeLoadResult.rootPathNodes[startLevelIndex - 1].id;\n              })[0];\n              /**\n               * currentlyLoadedRootPathNodeVMO is the parent node which is currently loaded in\n               * VMO and its also present in response structure.\n               */\n\n              if (currentlyLoadedRootPathNodeVMO) {\n                numberOfLevelsToBeInserted++;\n                currentlyLoadedRootPathNodeVMO.nextLevelInsert = true;\n                break;\n              }\n            }\n          }\n          /**\n           * 1)vmNodesInTreeHierarchyLevels is an array of arrays. Each array index represents vmNodes\n           * at given level (index 0 in array represents level -1 which is not displayed, index 1\n           * level 0 and so on). Each level will have node where next level nodes need to be inserted.\n           *\n           * 2)rootPathNodes contain array of parents with one or more having children under it.\n           *\n           * 3)At each level, you will have parent below which next level is supposed to be inserted.\n           */\n          // Iterate through all levels\n\n\n          for (ndx = startLevelIndex; ndx < treeLoadResult.vmNodesInTreeHierarchyLevels.length; ndx++) {\n            var vmNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ndx]; // Get parent node below which next level needs to be inserted.\n\n            var nextLevelParentNode = vmNodes.filter(function (vmo) {\n              return treeLoadResult.rootPathNodes[ndx] && vmo.id === treeLoadResult.rootPathNodes[ndx].id;\n            })[0];\n\n            if (nextLevelParentNode) {\n              nextLevelParentNode.nextLevelInsert = true;\n              numberOfLevelsToBeInserted++;\n            }\n          }\n\n          const viewModelObjects = getViewModelCollectionInTreeHierarchyFormat(treeLoadResult, vmCollection, currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode);\n          response.loadedVMObjects = viewModelObjects;\n          response.totalFound = viewModelObjects.length;\n        }\n      } else if (treeLoadResult.nonRootPathHierarchicalData) {\n        /**\n         * If we are given multiple expanded nodes which are all not necessarily on the \"rootPath\"\n         */\n        const viewModelObjects = getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult, vmCollection, dataCtxNode);\n\n        if (viewModelObjects) {\n          response.loadedVMObjects = viewModelObjects;\n          response.totalFound = viewModelObjects.length;\n        }\n      } else {\n        /**\n         * Check if we are processing the unseen 'root' node.<br>\n         * If so: Just add the results as the only items in the collection.<BR>\n         * If not: Insert the results in at the correct location.\n         */\n        if (isParentRoot && treeLoadResult.startChildNdx === 0) {\n          response.totalFound = treeLoadResult.totalChildCount;\n          response.loadedVMObjects = _.clone(treeLoadResult.childNodes);\n        } else {\n          if (treeLoadResult.cursorNodeId) {\n            _insertModelObjects(vmCollection, treeLoadResult.cursorNodeId, treeLoadResult.childNodes, addAfter);\n          } else {\n            if (treeLoadResult.startChildNdx === 0) {\n              _insertModelObjects(vmCollection, uwUtilSvc.getEvaluatedId(expectantParentNode), treeLoadResult.childNodes, addAfter);\n            } else {\n              var insertionNode = expectantParentNode.children[treeLoadResult.startChildNdx - 1];\n\n              _insertModelObjects(vmCollection, uwUtilSvc.getEvaluatedId(insertionNode), treeLoadResult.childNodes, addAfter);\n            }\n          }\n        }\n        /**\n         * Update the totalNumber of known 'child' nodes.\n         */\n\n\n        expectantParentNode.totalChildCount = treeLoadResult.totalChildCount;\n      }\n      /**\n       * Fire a 'modelObjectsUpdated' event, sourced to this uwDataProvider, but only for changes to the\n       * outer-most level. This event includes the entire ViewModelCollection. This event is required to\n       * have the aw-table controller know when to update the information in the GridWrapper.\n       */\n\n\n      if (isParentRoot) {\n        var nChild = resultParentNode.children ? resultParentNode.children.length : 0;\n        moreAboveFirst = false;\n        moreBelowLast = false;\n\n        if (resultParentNode.cursorObject) {\n          moreAboveFirst = !resultParentNode.cursorObject.startReached;\n          moreBelowLast = !resultParentNode.cursorObject.endReached;\n        } else {\n          moreBelowLast = resultParentNode.totalChildCount > nChild;\n        }\n\n        _notifyModelObjectsUpdate(dataCtxNode, {\n          prevPage: moreAboveFirst,\n          nextPage: moreBelowLast\n        });\n      } else {\n        dpSelf.syncSelectionModel(dataCtxNode);\n      }\n      /**\n       * Fire a 'treeNodesLoaded' event, sourced to this uwDataProvider, for all tree-table changes. This\n       * event includes only the input/result structures for the current load operation. This event is\n       * used to load additional properties in an async fashion.\n       */\n\n\n      eventBus.publish(dpSelf.name + '.treeNodesLoaded', {\n        treeLoadInput: treeLoadInput,\n        treeLoadResult: treeLoadResult\n      });\n      /**\n       * Check if the response indicates we should make sure the parent is expanded.\n       */\n\n      if (treeLoadResult.expandParent) {\n        eventBus.publish(dpSelf.name + '.expandTreeNode', {\n          parentNode: resultParentNode\n        });\n      }\n    } else if (isParentRoot) {\n      /**\n       * If this is the 'top' level node we now know it IS empty.\n       */\n      dpSelf.noResults = true;\n      /**\n       * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n       * <P>\n       * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n       * 'top' children into the ViewModelCollection. Do not do this!\n       */\n\n      newTopNode = treeLoadResult.newTopNode;\n\n      if (newTopNode && newTopNode.levelNdx === -1) {\n        dpSelf.topTreeNode = newTopNode;\n        dpSelf.topTreeNode.children = null;\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n      }\n      /**\n       * If empty child nodes are passed to provider, they should be honored and should get updated in UI.\n       */\n\n\n      if (treeLoadResult.startChildNdx === 0) {\n        /**\n         * This change is when we delete a single row from the tree table\n         */\n        moreAboveFirst = false;\n        moreBelowLast = false;\n        /**\n         * Determine if this node is NOT an 'incompleteHead' or 'incompleteTail'\n         */\n\n        if (resultParentNode.cursorObject) {\n          moreAboveFirst = !resultParentNode.cursorObject.startReached;\n          moreBelowLast = !resultParentNode.cursorObject.endReached;\n        }\n\n        var emptyChildNodes = !moreAboveFirst && !moreBelowLast;\n\n        if (emptyChildNodes) {\n          response.totalFound = treeLoadResult.totalChildCount;\n          response.loadedVMObjects = _.clone(treeLoadResult.childNodes);\n\n          _notifyModelObjectsUpdate(dataCtxNode, {\n            prevPage: moreAboveFirst,\n            nextPage: moreBelowLast\n          });\n        }\n      }\n    }\n\n    return response;\n  }\n  /**\n   * @param {TreeLoadResult} treeLoadResult - Object containing result/status information.\n   * @param {ViewModelObjectArray} vmCollection - VMO array to set\n   * @param {ViewModelObject} currentlyLoadedRootPathNodeVMO - ...\n   * @param {Number} startLevelIndex -\n   * @param {Number} numberOfLevelsToBeInserted -\n   */\n\n\n  function getViewModelCollectionInTreeHierarchyFormat(treeLoadResult, vmCollection, currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode) {\n    var finalVMOs = [];\n    var lvlNdx = startLevelIndex;\n    var numberOfLevelsInserted = 0;\n    var indx = 0;\n\n    if (currentlyLoadedRootPathNodeVMO) {\n      /**\n       * currentlyLoadedRootPathNodeVMO is populated. That means parentNode that has come in\n       * TreeLoadResult is already loaded in vmCollection. In that case , restore existing VMOs, merge new\n       * VMOs that we got in response in currently loaded VMOs.\n       */\n      arrayUtils.insert(finalVMOs, 0, vmCollection.getLoadedViewModelObjects());\n      indx = finalVMOs.indexOf(currentlyLoadedRootPathNodeVMO);\n    } else {\n      // Build Final ViewModelTreeNodes array. Add zeroth level , iterate, check for next level insertion point,\n      // and add new level there.Keep building and iterating through whole list.\n      arrayUtils.insert(finalVMOs, 0, treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx++]);\n    }\n\n    while (indx < finalVMOs.length && numberOfLevelsInserted < numberOfLevelsToBeInserted) {\n      var vmo = finalVMOs[indx];\n\n      if (vmo.nextLevelInsert) {\n        vmo.isExpanded = true;\n\n        for (let vmNodeInTreeHierarchyLevel of treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]) {\n          var finalVMOIndex = 0;\n\n          for (let finalVMO of finalVMOs) {\n            if (finalVMO && finalVMO.id === vmNodeInTreeHierarchyLevel.id) {\n              finalVMOs.splice(finalVMOIndex, 1);\n            }\n\n            finalVMOIndex++;\n          }\n        }\n\n        arrayUtils.insert(finalVMOs, indx, treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]); // Next level nodes should be stored as children under current level parent.\n\n        vmo.children = _.clone(treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]);\n        vmo.totalChildCount = vmo.children.length;\n        vmo.isLeaf = false; // Store parent as expanded in state/local storage.\n\n        saveRowExpanded(dataCtxNode, vmo);\n        delete vmo.nextLevelInsert;\n        lvlNdx++;\n        numberOfLevelsInserted++;\n      }\n\n      indx++;\n    } // filter out vmo with treeLevel -1 as we don't show topLevel Node.\n\n\n    finalVMOs = finalVMOs.filter(function (vmo) {\n      return vmo.$$treeLevel !== -1;\n    });\n    return finalVMOs;\n  }\n  /**\n   * @param {TreeLoadResult} treeLoadResult object containing result/status information.\n   * @param {ViewModelObjectArray} vmCollection VMO array to set\n   */\n\n\n  function getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult, vmCollection, dataCtxNode) {\n    let finalVMOs = [];\n\n    if (treeLoadResult.mergeNewNodesInCurrentlyLoadedTree) {\n      finalVMOs = vmCollection.getLoadedViewModelObjects();\n    }\n\n    for (let index = 0; index < treeLoadResult.vmNodesInTreeHierarchyLevels.length; index++) {\n      let currentNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[index];\n\n      for (let node = 0; node < currentNodes.length; node++) {\n        let vmoIndex = -1;\n        let levelIndex = 0;\n        let currentNode = currentNodes[node];\n        finalVMOs.forEach((vmo, index) => {\n          if (currentNode) {\n            if (vmo.id === currentNode.id) {\n              vmoIndex = index;\n            }\n\n            if (vmo.id === currentNode.parentUid) {\n              levelIndex = index;\n            }\n          }\n        });\n\n        if (vmoIndex !== -1) {\n          _.assign(finalVMOs[vmoIndex], currentNode);\n        } else {\n          arrayUtils.insert(finalVMOs, levelIndex + node, [currentNode]);\n        }\n\n        saveRowExpanded(dataCtxNode, currentNode);\n      }\n    }\n\n    if (!treeLoadResult.mergeNewNodesInCurrentlyLoadedTree) {\n      return finalVMOs;\n    }\n  }\n  /**\n   * @param {ViewModelTreeNode} parentNode - (Optional) The 'parent' to use when determining input.\n   *\n   * @param {String} cursorNodeId - (Optional) The ID of the node to insert above/below\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @return {Object} The resolved input object to pass to 'createTreeLoadInput'.\n   */\n\n\n  function _determineInput(parentNode, cursorNodeId, addAfter) {\n    /**\n     * Determine 'child' index to use as basis for loading.\n     *\n     * <pre>\n     * Handle various cases of 'parent' and/or 'cursorNodeId' validity:\n     * 1) 'parent' and 'cursorNodeId' valid:             Locate the 'cursorNodeId' in the 'parent' and use its index.\n     * 2) 'parent' valid and 'cursorNodeId' not valid:   Use either end of the 'parent' children as the index.\n     * 3) 'parent' NOT valid and the 'cursor' is valid:  Locate the 'parent' of the 'cursor' and use the 'cursor' index.\n     * 4) 'parent' NOT valid and the 'cursor' NOT valid: Fail assertion.\n     * Note: Case 3) is used when dynamically loading the next page of 'children' directly after/before the\n     * 'cursor' node.\n     * </pre>\n     */\n    var startChildNdx = -1;\n\n    if (parentNode) {\n      if (cursorNodeId) {\n        startChildNdx = _findChildNdx(parentNode, cursorNodeId);\n\n        if (startChildNdx !== -1) {\n          startChildNdx++;\n        }\n      } else {\n        if (addAfter) {\n          var nChild = parentNode.children ? parentNode.children.length : 0;\n          startChildNdx = nChild;\n        } else {\n          startChildNdx = 0;\n        }\n      }\n    } else if (cursorNodeId) {\n      var vmCollection = dpSelf.viewModelCollection;\n      var cursorNdx = vmCollection.findViewModelObjectById(cursorNodeId);\n\n      if (cursorNdx !== -1) {\n        var cursorNode = vmCollection.getViewModelObject(cursorNdx);\n        var parentLevelNdx = cursorNode.levelNdx - 1;\n        startChildNdx = 1;\n\n        for (var ndx = cursorNdx - 1; ndx >= 0; ndx--) {\n          var currRow = vmCollection.getViewModelObject(ndx);\n\n          if (currRow.levelNdx === parentLevelNdx) {\n            parentNode = currRow; //Locate the 'parent' of the 'cursor' and use the Parent 'cursor' index.\n\n            if (parentNode.cursorObject && parentNode.cursorObject.endIndex) {\n              startChildNdx = parentNode.cursorObject.endIndex + 1;\n            }\n\n            break;\n          }\n\n          startChildNdx++;\n        }\n      }\n    }\n\n    assert(parentNode, 'Unable to determine \\'parent\\' node');\n    assert(startChildNdx !== -1, 'Unable to determine location in \\'parent\\' to insert loaded \\'child\\' nodes');\n    return {\n      parentNode: parentNode,\n      startChildNdx: startChildNdx\n    };\n  }\n  /**\n   * Log a warning that there was an access to this UwDataProvider after it was destroyed.\n   *\n   * @param {String} functionName - Name of the function being accessed.\n   */\n\n\n  function _reportAccessToZombieDataProvider(functionName) {\n    logger.warn('Attempt to execute a function on a UwDataProvider after it was destroyed...' + '\\n' + //\n    'Function was therefore not executed...continuing.' + '\\n' + //\n    'UwDataProvider: ' + dpSelf.name + '\\n' + //\n    'Function: ' + functionName);\n  }\n  /**\n   * Override the default implementation to return more helpful information.\n   *\n   * @return {String} Text used to identify the ID of the UsDataProvider (e.g. 'modelId' + an optional\n   *         'name').\n   */\n\n\n  dpSelf.toString = function () {\n    if (dpSelf) {\n      if (dpSelf.name) {\n        return dpSelf._modelId + '  name: ' + dpSelf.name;\n      }\n\n      return dpSelf._internal.modelId + '  name: ' + '???';\n    }\n\n    return 'UwDataProvider (destroyed)';\n  };\n  /**\n   * Get all of the loaded objects that are currently selected.\n   *\n   * @return {IModelObjectArray} Array of selected {IModelObject}.\n   */\n\n\n  dpSelf.getSelectedObjects = function () {\n    if (dpSelf.selectionModel) {\n      var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n      if (dpSelf.vmCollectionObj && dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0) {\n        loadedVMO = [...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices];\n      }\n\n      return dpSelf.selectionModel.getSortedSelection(loadedVMO);\n    }\n\n    return [];\n  };\n  /**\n   * Get the indices of the selected objects.\n   *\n   * @returns {NumberArray} Resolved with the indicies of the selected objects in the ViewModelCollection.\n   */\n\n\n  dpSelf.getSelectedIndices = function () {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    return dpSelf.getSelectedObjects().map(function (vmo) {\n      return loadedVMO.indexOf(vmo);\n    });\n  }; // Define with this 'incorrect' spelling as well.\n\n\n  dpSelf.getSelectedIndexes = dpSelf.getSelectedIndices;\n  /**\n   * Change the selection range\n   *\n   * @param {Number} start - String index in collection to add/remove/toggle.\n   * @param {Number} end -  Ending index in collection to add/remove/toggle.\n   * @param {Boolean} select - (Optional) TRUE, 'select'...FALSE, 'unselect'...UNDEFINED, 'toggle'.\n   */\n\n  dpSelf.changeObjectsSelection = function (start, end, select) {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects(); // Going down : Going up\n\n    var e = start > end ? start : end;\n    var s = start > end ? end : start;\n    var objects = loadedVMO.slice(s, e + 1);\n\n    if (select === true) {\n      if (dpSelf.selectionModel.multiSelectEnabled || objects.length > 1) {\n        dpSelf.selectionModel.addToSelection(objects);\n      } else {\n        dpSelf.selectionModel.setSelection(objects);\n      }\n    } else if (select === false) {\n      dpSelf.selectionModel.removeFromSelection(objects);\n    } else {\n      dpSelf.selectionModel.toggleSelection(objects);\n    }\n  }; // activates multi Select mode on selection Model = multiple.\n\n\n  dpSelf.multiSelectModeEvent = eventBus.subscribe(dpSelf.name + '.multiSelectModeAction', function (eventData) {\n    if (eventData && eventData.multiSelect) {\n      dpSelf.enableMultiSelect();\n    } else {\n      dpSelf.disableMultiSelect();\n    }\n  });\n  let _selectionModelDataCtxNode = null; // Event to expose various selection APIs on the selection model.\n\n  dpSelf.selectActionEvent = eventBus.subscribe(dpSelf.name + '.selectAction', function (eventData) {\n    if (dpSelf.selectionModel) {\n      const oldSelection = dpSelf.selectionModel.getSelection();\n\n      if (eventData) {\n        if (eventData.selectAll === true) {\n          dpSelf.selectAll();\n        }\n\n        if (eventData.selectAll === false) {\n          dpSelf.selectNone();\n        }\n\n        if (eventData.select) {\n          dpSelf.selectionModel.addToSelection(eventData.select);\n        }\n\n        if (eventData.deselect) {\n          dpSelf.selectionModel.removeFromSelection(eventData.deselect);\n        }\n\n        if (eventData.setSelection) {\n          dpSelf.selectionModel.setSelection(eventData.setSelection);\n        }\n      }\n\n      const newSelection = dpSelf.selectionModel.getSelection();\n      dpSelf.syncSelectionModel(_selectionModelDataCtxNode, newSelection, oldSelection);\n    }\n  });\n  /**\n   * Enable MultiSelect\n   */\n\n  dpSelf.enableMultiSelect = function () {\n    if (dpSelf.selectionModel) {\n      dpSelf.selectionModel.setMultiSelectionEnabled(true);\n    }\n  };\n  /**\n   * disable MultiSelect\n   */\n\n\n  dpSelf.disableMultiSelect = function () {\n    if (dpSelf.selectionModel) {\n      dpSelf.selectionModel.setMultiSelectionEnabled(false);\n      dpSelf.selectNone();\n    }\n  };\n  /**\n   * Select all loaded objects\n   */\n\n\n  dpSelf.selectAll = function () {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    dpSelf.selectionModel.addToSelection(loadedVMO);\n    eventBus.publish(dpSelf.name + '.selectAll', {});\n  };\n  /**\n   * Clear selection\n   */\n\n\n  dpSelf.selectNone = function () {\n    dpSelf.selectionModel.setSelection([]);\n    eventBus.publish(dpSelf.name + '.selectNone', {});\n  };\n\n  dpSelf.setSelectionEnabled = function (isSelectionEnabled) {\n    dpSelf.selectionModel.setSelectionEnabled(isSelectionEnabled);\n    eventBus.publish(dpSelf.name + '.isSelectionEnabledChanged', {\n      isSelectionEnabled: isSelectionEnabled\n    });\n  };\n  /**\n   * Sync the view with the updated selection model.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {StringArray} newSelection -\n   * @param {StringArray} oldSelection -\n   */\n\n\n  dpSelf.syncSelectionModel = function (dataCtxNode, newSelection, oldSelection) {\n    // Ensure the selection state is correct\n    //zarq9k: Once we sync up the old viewModel and new Collection, this line would not be required.\n    // issue reported - https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/56\n    // We never worked on it.\n    var loadedVMO = dpSelf.vmCollectionObj.vmCollection.getLoadedViewModelObjects(); //var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n    if (dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0) {\n      loadedVMO = [...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices];\n    }\n\n    loadedVMO.map(function (vmo) {\n      vmo.selected = dpSelf.selectionModel.isSelected(vmo);\n    }); // Put the selected objects on the data provider\n    // Makes binding in view models simpler\n\n    var prevSelectedObjects = dpSelf.selectedObjects;\n    dpSelf.selectedObjects = loadedVMO.filter(function (vmo) {\n      return vmo.selected;\n    });\n\n    var emitEvents = function () {\n      //This check ensures notification is triggered only if there a selection change\n      if (!_.isEqual(prevSelectedObjects, dpSelf.selectedObjects)) {\n        if (dpSelf.selectionModel && dpSelf.selectionModel.selectionData) {\n          dpSelf.selectionModel.selectionData.update({\n            selected: dpSelf.getSelectedObjects(),\n            source: dpSelf.validSourceTypes,\n            id: dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name,\n            _modelId: dpSelf._modelId\n          });\n          trace('Selection Changed for ', dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name, dpSelf.selectedObjects);\n        }\n\n        let eventObj = {\n          selectedObjects: dpSelf.getSelectedObjects(),\n          selectedUids: dpSelf.selectionModel.getSelection(),\n          scope: dataCtxNode,\n          selectionModel: dpSelf.selectionModel,\n          selected: dpSelf.getSelectedObjects(),\n          dataProviderName: dpSelf.name,\n          dataProvider: dpSelf\n        }; // Always notify through event bus\n\n        eventBus.publish(dpSelf.name + '.selectionChangeEvent', eventObj);\n      }\n    }; // Handle case where something is selected that is not in data provider\n\n\n    if (dpSelf.focusAction) {\n      var shouldEmitSelectionEvent = true; // Ignore the simple sync to mark objects as selected\n\n      if (newSelection && oldSelection) {\n        var newlySelected = newSelection.filter(function (x) {\n          return oldSelection.indexOf(x) === -1;\n        }); // If a single new object was selected attempt to focus\n\n        if (newlySelected.length === 1) {\n          // Try to get object from current list\n          var newlySelectedObject = dpSelf.selectedObjects.filter(function (vmo) {\n            return prevSelectedObjects.indexOf(vmo) === -1;\n          })[0]; // If not found clear current list and focus\n\n          if (!newlySelectedObject) {\n            shouldEmitSelectionEvent = false; // Reset cursor\n\n            if (dpSelf.cursorObject) {\n              dpSelf.cursorObject = null;\n            }\n\n            dpSelf.pageDispatcher({\n              type: 'FOCUS_PAGE'\n            });\n            dpSelf.vmCollectionDispatcher({\n              type: 'FOCUSING',\n              focusing: true\n            });\n          } else {\n            eventBus.publish(dpSelf.name + '.focusSelection');\n          }\n        }\n      }\n\n      if (shouldEmitSelectionEvent) {\n        emitEvents();\n      }\n    } else {\n      var uidSet = new Set();\n\n      _.forEach(dpSelf.selectedObjects, function (obj) {\n        var uid;\n\n        if (typeof obj === 'object') {\n          uid = obj.uid;\n        } else {\n          uid = obj;\n        }\n\n        uidSet.add(uid);\n      }); //If the selectionModel is shared, there is possibility that the selectionModel can have\n      //stale/invalid selection stored.\n      //Give precedence to dataprovider selection in case of shared selectionModel\n\n\n      const isSharedSelectionModel = _ctorInputData && _ctorInputData.selectionModel;\n\n      if (isSharedSelectionModel && uidSet.size !== dpSelf.selectionModel.getCurrentSelectedCount()) {\n        // Default behavior is to remove any object not found from the selection model\n        dpSelf.selectionModel.setSelection(dpSelf.selectedObjects);\n      } //Notify selection change in the same render cycle\n\n\n      emitEvents();\n    } // Check selection state\n\n\n    dpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);\n  };\n  /**\n   * Detach the selection model from the data provider. Should only be done when re-initializing.\n   */\n\n\n  dpSelf.detachSelectionModel = function () {\n    if (dpSelf.syncSelectionEvent) {\n      dpSelf.syncSelectionEvent();\n      dpSelf.syncSelectionEvent = null;\n    }\n  };\n  /**\n   * Attach the data provider to its current selection model. Ensures re-initialization of the data provider\n   * will not result in duplicate event listeners / watches.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   */\n  // dpSelf.attachSelectionModel = function( dataCtxNode ) {\n  //     // _selectionModelDataCtxNode = dataCtxNode;\n  //     // Remove previous watch if it is still setup\n  //     // dpSelf.detachSelectionModel();\n  //     // dpSelf.selectionModel.syncSelections = function( oldVal, newVal ) {\n  //     //     dpSelf.syncSelectionModel( dataCtxNode, newVal, oldVal );\n  //     // };\n  // };\n\n  /**\n   * Attach the selection model immediately. Will be detached / reattached if data provider is initialized.\n   * However cannot assume data provider is ever initialized.\n   */\n  //dpSelf.attachSelectionModel( {} );\n\n  /**\n   * Swap selection model with the new selection model provided as input. Detach current selection model and\n   * attach the new one\n   *\n   * @param {Object} newSelectionModel - new selection model which is required to swap\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   */\n\n\n  dpSelf.swapSelectionModel = function (newSelectionModel, dataCtxNode) {\n    // Detach the selection model while initializing\n    dpSelf.detachSelectionModel();\n    dpSelf.selectionModel = newSelectionModel;\n    dpSelf.attachSelectionModel(dataCtxNode);\n  }; // ======================== Edit Handler Interface ===================================================//\n\n  /**\n   *\n   * @param {*} stateName current state of edit\n   * @param {*} dpSelf data provider instance\n   */\n\n\n  var _notifyEditStateChange = function (stateName, dpSelf) {\n    dpSelf._editingState = stateName;\n    dpSelf._editing = stateName === 'starting'; // Add to the appCtx about the editing state\n\n    appCtxService.updateCtx(dpSelf._appCtxEditInProgress, dpSelf._editing);\n    eventBus.publish(dpSelf._eventTopicEditInProgress, dpSelf._editing);\n  };\n\n  if (!dpSelf._appCtxEditInProgress) {\n    dpSelf._appCtxEditInProgress = dpSelf.name + '_editInProgress';\n    dpSelf._eventTopicEditInProgress = dpSelf.name + '.editInProgress';\n  }\n  /**\n   * isDirty implementation of edit-handler interface.\n   * It check if any of the view model property inside view model object is modified.\n   * @returns {*} AwPromiseService.instance with promise true/false        *\n   */\n\n\n  dpSelf.isDirty = function () {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    return editUtilsService._isDirty(viewModelCollection);\n  };\n  /**\n   * Determines if prop edit is enabled for this dataprovider\n   * @param {Object} declViewModel the declarative view model\n   * @returns {*} true if individual prop editing is enabled\n   */\n\n\n  dpSelf.isPropEditEnabled = function (declViewModel) {\n    if (dpSelf.json && dpSelf.json.enablePropEdit) {\n      // If boolean is used return it directly otherwise evaluate the value as a condition\n      if (typeof dpSelf.json.enablePropEdit === 'boolean') {\n        return dpSelf.json.enablePropEdit;\n      }\n\n      const evaluationEnv = {\n        data: declViewModel,\n        ctx: appCtxService.ctx,\n        conditions: declViewModel._internal.conditionStates\n      };\n      return declUtils.evaluateCondition(declViewModel, dpSelf.json.enablePropEdit, evaluationEnv);\n    } else if (dpSelf.json && dpSelf.json.enablePropEdit === false) {\n      return false;\n    } // Default is true if enablePropEdit is not defined\n\n\n    return true;\n  };\n  /**\n   * This function implements the start edit function edit handler interface\n   * @param {*} dataCtxNode data ctx Node.\n   * @param {*} declViewModel declarative ViewModel.\n   * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n   * @return {*} AwPromiseService.instance with promise.\n   */\n\n\n  dpSelf.startEdit = function (dataCtxNode, declViewModel, editOptions) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    editConfig.sourceModel = dpSelf.name;\n\n    const saveEditStateChangeCallback = function () {\n      _notifyEditStateChange('saved', dpSelf);\n    };\n\n    return editUtilsService._startEdit(dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback, editOptions).then(function () {\n      if (!editOptions) {\n        _notifyEditStateChange('starting', dpSelf);\n      }\n    });\n  };\n  /**\n   * This is the cancel edits implementation of edit-handler interface.\n   * @param  {*} dataCtxNode data ctx Node.\n   * @param  {*} declViewModel declarative ViewModel.\n   * @return {*} AwPromiseService.instance with promise\n   */\n\n\n  dpSelf.cancelEdits = function (dataCtxNode, declViewModel) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    return editUtilsService._cancelEdits(dataCtxNode, declViewModel, viewModelCollection, editConfig).then(function () {\n      _notifyEditStateChange('canceling', dpSelf);\n    });\n  };\n  /**\n   * This function implements the save edits function edit handler interface\n   * @param {*} dataCtxNode data ctx Node.\n   * @param {*} declViewModel declarative ViewModel.\n   * @return {*} AwPromiseService.instance with promise.\n   */\n\n\n  dpSelf.saveEdits = function (dataCtxNode, declViewModel) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    return editUtilsService._saveEdits(dataCtxNode, declViewModel, viewModelCollection, editConfig).then(function () {\n      _notifyEditStateChange('saved', dpSelf);\n    });\n  };\n  /**\n   * @returns {*} boolean true/false\n   */\n\n\n  dpSelf.editInProgress = function () {\n    return dpSelf._editing;\n  };\n\n  dpSelf.setFilterString = filterVal => {\n    filterStr = filterVal;\n  };\n\n  dpSelf.getFilterString = () => {\n    return filterStr;\n  }; // ======================== End of Edit Handler Interface ===================================================//\n\n  /**\n   * Initialize and trigger first page of results.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @return {Promise} A promise object resolved with the ViewModelCollection returned by the current\n   *         DataProviderService.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.initialize = function (dataCtxNode) {\n    var promise;\n\n    if (dpSelf.cursorObject) {\n      dpSelf.cursorObject = null;\n    }\n\n    dpSelf.setFilterString(filterStr);\n    /**\n     * If the constructor was told there would be some additional input data passed in from the data ctx\n     * node attempt to get it at this point.\n     * <P>\n     * Note: The input data from the scope can only override specific properties.\n     */\n\n    if (!_.isEmpty(_ctorInputData)) {\n      var declViewModel = declUtils.findViewModel(dataCtxNode);\n      dataCtxService.applyScope(declViewModel, _ctorInputData, null, dataCtxNode);\n\n      _.forEach(_ctorInputData, function (value, name) {\n        if (_modifiablePropertiesViaInputData.indexOf(name) !== -1) {\n          dpSelf[name] = value;\n        }\n      });\n    }\n    /** editHandler */\n\n\n    if (dpSelf.json.editContext) {\n      let reusableEditHandler = editHandlerSvc.getEditHandler(dpSelf.json.editContext); // If editHandler already exists don't create a new one - which overwrites the old one\n\n      if (!reusableEditHandler) {\n        editHandlerSvc.setEditHandler(editHandlerFactory.createEditHandler(dataSourceService.createNewDataSource({\n          dataProvider: dpSelf\n        }), dpSelf.editSupportParamKeys), dpSelf.json.editContext); // set this handler active\n\n        editHandlerSvc.setActiveEditHandlerContext(dpSelf.json.editContext);\n        _editHandlerRegistered = true;\n      }\n    }\n\n    promise = Promise.resolve(dpSelf.resetDataProvider()); // Detach the selection model while initializing\n    // dpSelf.detachSelectionModel();\n\n    /** revisitme Shaishav: This should be dead code in future because we delegated this responsibility to dataProviderUtils js\n     *  Keeping the code for now to ensure we do not miss any functionality while migrating\n     if( dpSelf.accessMode === 'tree' ) {\n        dpSelf.topTreeNode = _determineTopTreeNode( dpSelf.topNodeUid );\n         promise = dpSelf.getTreeNodeInitial( dataCtxNode, dpSelf.topTreeNode, null, true,\n            dpSelf.topTreeNode ).then( function( response ) {\n            dpSelf.attachSelectionModel( dataCtxNode );\n             return response;\n        } );\n    } else {\n        dpSelf.startIndex = 0;\n         var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, false, dataCtxNode.filterStr );\n         var actionRequestObj = {\n            listLoadInput: listLoadInput\n        };\n         var action = dpSelf.initializeAction ? dpSelf.initializeAction : dpSelf.action;\n         if( logger.isDeclarativeLogEnabled() ) {\n            debugService.debugDataProviderInitialize( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj, _ctorInputData );\n        }\n         promise = dpSelf.someDataProviderSvc.getFirstPage( action, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then(\n            function( response ) {\n                eventBus.publish( dpSelf.name + '.resetScroll', {} );\n                var vmCollection = dpSelf.viewModelCollection;\n                 vmCollection.clear();\n                vmCollection.setTotalObjectsFound( response.totalFound );\n                 if( response.totalFound > 0 && response.results ) {\n                    dpSelf.noResults = false;\n                     vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                        dpSelf.preSelection );\n                     /**\n                     * Determine if the last node in the collection is an 'incompleteTail' because we know\n                     * there are more found than currently loaded.\n                    if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                        vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                        _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                    }\n                } else {\n                    dpSelf.noResults = true;\n                    // assigning no result found string if there is no data from rest service\n                    if( dpSelf.json.noResultsFound ) {\n                        var i18nkey = dpSelf.json.noResultsFound;\n                        i18nkey = parsingUtils.geti18nKey( i18nkey );\n                        dpSelf.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                    }\n                }\n                 // dpSelf.attachSelectionModel( dataCtxNode );\n                 _notifyModelObjectsUpdate( null, {\n                    firstPage: true\n                } );\n                 return response;\n            },\n            function( err ) {\n                logger.warn( err );\n            } );\n    }\n    */\n    // Attach selection model once first page is loaded\n\n    promise.then(function (response) {\n      if (dpSelf.selectionModel && dpSelf.selectionModel.getSelection().length > 0) {\n        /**\n         * Fire modelObjects updated event using data provider name space\n         */\n        eventBus.publish(dpSelf.name + '.focusSelection');\n      }\n      /**\n       * Note: Not all dataCtxNodes are actually AngularJS $scopes. So we have to check if the $scope API\n       * exists before we try to use it.\n       */\n\n\n      if (dataCtxNode.$on) {\n        dataCtxNode.$on('dataProvider.selectAction', function (event, data) {\n          if (data && data.selectAll) {\n            dpSelf.selectAll();\n          } else {\n            dpSelf.selectNone();\n          }\n        });\n        dataCtxNode.$on('dataProvider.multiSelectAction', function (event, data) {\n          if (data && data.multiSelect) {\n            dpSelf.enableMultiSelect();\n          } else {\n            dpSelf.disableMultiSelect();\n          }\n        });\n      }\n\n      return response;\n    });\n    return promise;\n  }; // initialize\n\n\n  dpSelf.setDataUpdater = (pageDispatcher, vmCollectionDispatcher) => {\n    dpSelf.pageDispatcher = pageDispatcher;\n    dpSelf.vmCollectionDispatcher = vmCollectionDispatcher;\n  };\n\n  dpSelf.setSelectionModel = _ref => {\n    let {\n      selectionModel,\n      selectionDispatcher\n    } = _ref;\n    dpSelf.selectionModel = selectionModel;\n    selectionModelDispatcher = selectionDispatcher;\n  };\n\n  dpSelf.setRootReference = ref => {\n    referenceElement = ref;\n  };\n\n  dpSelf.setPropsCallback = getProps => {\n    propsCallback = getProps;\n  };\n\n  dpSelf.getRootReference = () => {\n    return referenceElement;\n  };\n\n  dpSelf.setLovEntryRef = ref => {\n    lovEntryRef = ref;\n  };\n\n  dpSelf.getLovEntryRef = () => {\n    return lovEntryRef;\n  };\n\n  dpSelf.setPagination = pageOption => {\n    if (!paginationOption) {\n      paginationOption = pageOption;\n    }\n  };\n\n  dpSelf.getPagination = () => {\n    return paginationOption ? paginationOption : null;\n  };\n\n  dpSelf.resetDataProvider = () => {\n    dpSelf.vmCollectionDispatcher({\n      type: 'COLLECTION_RESET'\n    });\n    dpSelf.pageDispatcher({\n      type: 'PAGE_RESET'\n    });\n    dpSelf.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    }); // Spare the selection model reset, if it is shared one.\n\n    if (_ctorInputData && !_ctorInputData.selectionModel || !_ctorInputData) {\n      dpSelf.selectNone();\n    }\n  };\n  /**\n   * validate the lovValueSections if it needs to call the \"validateLOVValueSelections\" soa\n   *\n   * @param {array} lovEntry - the lovEntry which is gotten from \"getinitialValues\" SOA and it's the selected\n   *            item\n   * @param {Object} dataCtxNode - The angular scope of this data provider\n   * @return {Promise} A promise object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.validateLOV = function (_ref2, dataCtxNode) {\n    let {\n      lovEntries,\n      vmo,\n      viewModelProp\n    } = _ref2;\n\n    try {\n      let action = dpSelf.validateAction;\n      return dpSelf.someDataProviderSvc.validateLOVSelection({\n        lovEntries,\n        vmo,\n        viewModelProp\n      }, dataCtxNode, action, dpSelf.json);\n    } catch (e) {\n      //In Table, when user edits LOV manually and clicks outside, widget is destroyed and hence LOV dataprovider as well\n      //Due to this, if user clicks outside, dpSelf is coming as NULL and dpSelf.validateAction throws exception\n      // Because of this behavior, user is not able to save even valid values.\n      //To fix this we have to remove LOV validation outside\n      return Promise.resolve({\n        valid: true\n      });\n    }\n  };\n  /**\n   * Set the currently loaded view model objects based on the model object (or uid data) in the given array of\n   * 'result' objects.\n   *\n   * @param {ViewModelObjectArray} newVMOs - Array of ViewModelObjects to set.\n   * @param {Number} totalFound - total found\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.update = function (newVMOs, totalFound) {\n    if (newVMOs) {\n      let updatedVMOs = newVMOs; //create a new reference only if there is an existing VMOs array to trigger update else use the same.\n\n      if (!newVMOs.objects) {\n        updatedVMOs = [...newVMOs];\n      }\n\n      let totalFoundIn = totalFound;\n\n      if (_.isUndefined(totalFoundIn)) {\n        totalFoundIn = updatedVMOs.length;\n      }\n\n      dpSelf.noResults = totalFoundIn === 0;\n      let vmCollection = dpSelf.viewModelCollection;\n      vmCollection.clear();\n      vmCollection.setTotalObjectsFound(totalFoundIn);\n\n      if (dpSelf.accessMode === 'tree') {\n        vmCollection.loadedVMObjects = updatedVMOs;\n      } else {\n        vmCollection.updateModelObjects(updatedVMOs, dpSelf.uidInResponse, dpSelf.preSelection);\n        /**\n         * Determine if the last node in the collection is an 'incompleteTail' because we know there are\n         * more found than currently loaded.\n         */\n\n        if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n          _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n        }\n        /**\n         * Maintain selections based on the new VMOs.\n         */\n\n\n        const selectedObjects = dpSelf.getSelectedObjects();\n        dpSelf.selectionModel.setSelection(selectedObjects);\n\n        _notifyModelObjectsUpdate();\n      }\n\n      dpSelf.vmCollectionDispatcher({\n        type: 'COLLECTION_REPLACE',\n        viewModelObjects: vmCollection.loadedVMObjects,\n        totalFound: vmCollection.loadedVMObjects.length\n      });\n    }\n  };\n\n  dpSelf.viewModelCollection.update = dpSelf.update;\n  /**\n   * Required. Get item at specified index\n   *\n   * @param {Number} index - index of the list\n   * @param {Object} dataCtxNode - The angular scope of this data provider\n   * @return {Object} object specified at the given index\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.getItemAtIndex = function (index, dataCtxNode) {\n    if (index > dpSelf.viewModelCollection.getTotalObjectsLoaded()) {\n      dpSelf.getNextPage(dataCtxNode);\n      return null;\n    }\n\n    return dpSelf.viewModelCollection.getViewModelObject(index);\n  };\n  /**\n   * Get ViewModelCollection being managed by this UwDataProvider.\n   *\n   * @return {ViewModelCollection} Reference to the ViewModelCollection being managed by this UwDataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getViewModelCollection = function () {\n    return dpSelf.viewModelCollection;\n  }; // 20201010 Per tec meeting discussion, dataProvider should never have types, data parser has the role to process data source.\n  // /**\n  //  * return the same data structure of the list items in the link-with-popup window\n  //  * <P>\n  //  * Note: Used for aw-link-with-popup.directive<BR>\n  //  *\n  //  * @memberof module:js/dataProviderFactory~UwDataProvider\n  //  *\n  //  * @param {Number} index - index of the list\n  //  * @param {Object} dataCtxNode - The data context the queryy is occurring within.\n  //  * @param {String} dataProviderType - The types of dataProvider: \"static\" \"TcLOV\" \"Action\"\n  //  *\n  //  * @return {Object} The same data structure of the list items in the link-with-popup window.\n  //  */\n  // dpSelf.createPopupObject = function( index, dataCtxNode, dataProviderType ) {\n  //     if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n  //         dpSelf.getNextPage( dataCtxNode );\n  //         return null;\n  //     }\n  //     var listElement = {\n  //         listElementDisplayValue: '',\n  //         listElementObject: ''\n  //     };\n  //     var displayValue;\n  //     var viewModelObject = dpSelf.getItemAtIndex( index, dataCtxNode );\n  //     if( !viewModelObject ) {\n  //         return listElement;\n  //     }\n  //     if( dataProviderType ) {\n  //         if( dataProviderType === 'TcLOV' ) {\n  //             displayValue = viewModelObject.propDisplayValue;\n  //         } else if( dataProviderType === 'Action' ) {\n  //             var displayStr;\n  //             if( dataCtxNode.displayProperty ) {\n  //                 displayStr = _.get( viewModelObject, dataCtxNode.displayProperty );\n  //             } else {\n  //                 displayStr = _.get( viewModelObject.props, 'object_string' );\n  //             }\n  //             displayValue = displayStr.uiValue;\n  //         } else if( dataProviderType === 'Static' ) {\n  //             if( viewModelObject.staticDisplayValue && viewModelObject.staticElementObject ) {\n  //                 displayValue = viewModelObject.staticDisplayValue;\n  //                 viewModelObject = viewModelObject.staticElementObject;\n  //             } else {\n  //                 displayValue = viewModelObject;\n  //             }\n  //         } else {\n  //             displayValue = viewModelObject;\n  //         }\n  //     } else {\n  //         displayValue = viewModelObject;\n  //     }\n  //     listElement.listElementDisplayValue = displayValue;\n  //     listElement.listElementObject = viewModelObject;\n  //     if( dpSelf.viewModelCollection.getTotalObjectsFound() ) {\n  //         var totalFound = 0;\n  //     }\n  //     if( !viewModelObject && !totalFound ) {\n  //         // no result found\n  //         listElement.listElementDisplayValue = dataCtxNode.prop.uiValue;\n  //         listElement.listElementObject = dataCtxNode.prop.dbValue;\n  //     }\n  //     if( dataCtxNode.isLoading ) {\n  //         // no result found\n  //         listElement.listElementDisplayValue = dpSelf.isLoading;\n  //         listElement.listElementObject = dpSelf.isLoading;\n  //     }\n  //     return listElement;\n  // }; // createPopupObject\n\n  /**\n   * Required. For infinite scroll behavior, we always return a slightly higher number than the previously\n   * loaded items.\n   *\n   * @return {Number} number of objects loaded.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getLength = function () {\n    return dpSelf.viewModelCollection.getVirtualLength();\n  };\n  /**\n   * Check if there is more data to load\n   *\n   * @return {Boolean} True if there are more objects to load\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.hasMorePages = function () {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('hasMorePages');\n\n      return false;\n    }\n    /**\n     * Check if acting as a 'tree'<BR>\n     * If so: We can only used the 'top' node cursor.\n     */\n\n\n    if (dpSelf.accessMode === 'tree') {\n      if (dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject) {\n        return !dpSelf.topTreeNode.cursorObject.endReached;\n      }\n\n      return false;\n    }\n    /**\n     * Check if we have a 'cursor' object.<BR>\n     * If so: Use its state for whether there is more data.\n     */\n\n\n    if (dpSelf.cursorObject) {\n      return !dpSelf.cursorObject.endReached;\n    }\n\n    return dpSelf.viewModelCollection.getTotalObjectsFound() > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n  };\n  /**\n   * Check if there is more data to load before current position.\n   *\n   * @return {Boolean} True if there are more objects to load\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.hasMorePagesUp = function () {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('hasMorePagesUp');\n\n      return false;\n    }\n    /**\n     * Check if acting as a 'tree'<BR>\n     * If so: We can only used the 'top' node cursor.\n     */\n\n\n    if (dpSelf.accessMode === 'tree') {\n      if (dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject) {\n        return !dpSelf.topTreeNode.cursorObject.startReached;\n      }\n\n      return false;\n    }\n    /**\n     * Check if we have a 'cursor' object.<BR>\n     * If so: Use its state for whether there is more data.\n     */\n\n\n    if (dpSelf.cursorObject) {\n      return !dpSelf.cursorObject.startReached;\n    }\n\n    return false;\n  };\n  /**\n   * Finds and returns a vmo with an incomplete head/tail in the given range.\n   * @param { Number } startIdx - index of the first node in the range\n   * @param { Number } endIdx - index of the last node in the range\n   *\n   * @return {Object} The node with an incomplete head/tail\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.findIncompleteNodeInRange = function (startIdx, endIdx) {\n    for (var i = startIdx; i <= endIdx; i++) {\n      var vmNode = dpSelf.viewModelCollection.loadedVMObjects[i];\n\n      if (vmNode && (vmNode.incompleteHead === true || vmNode.incompleteTail)) {\n        return vmNode;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get previous page of results\n   *\n   * @param {Object} dataCtxNode - The data context the query is occurring within.\n   *\n   * @return {Promise} A promise resolved when the previous page is loaded and the viewModelCollection is\n   *         updated. Resolved object is a reference to the 'viewModelColection' object associated with this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getPreviousPage = function (dataCtxNode) {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('getPreviousPage');\n\n      return $q.reject('Access to destroyed UwDataProvider.');\n    }\n\n    assert(dpSelf.previousAction, 'Invalid action specified');\n\n    if (dpSelf.accessMode === 'tree') {\n      var cursorNode = _.first(dpSelf.topTreeNode.children);\n\n      if (cursorNode) {\n        return dpSelf.getTreeNodePage(dataCtxNode, dpSelf.topTreeNode, cursorNode.id, false, dpSelf.topTreeNode);\n      }\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    }\n\n    var listLoadInput = awTableSvc.createListLoadInput(null, 0, null, false, true);\n    var actionRequestObj = {\n      listLoadInput: listLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.previousAction, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n      dpSelf.viewModelCollection.setTotalObjectsFound(response.totalFound);\n\n      if (response.totalFound > 0) {\n        dpSelf.viewModelCollection.updateModelObjects(response.results, dpSelf.uidInResponse, dpSelf.preSelection, true);\n      }\n\n      _notifyModelObjectsUpdate(dataCtxNode, {\n        prevPage: true\n      });\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    });\n  };\n  /**\n   * Get next page of results\n   *\n   * @param {Object} dataCtxNode - The data context the query is occurring within.\n   *\n   * @return {Promise} A promise resolved when the next page is loaded and the viewModelCollection is updated.\n   *         Resolved object is a reference to the 'viewModelColection' object associated with this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getNextPage = function (dataCtxNode) {\n    // revisit me - temp fix to make dataProvider instance consistent\n    const dpSelf = this;\n\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('getNextPage');\n\n      return $q.reject('Access to destroyed UwDataProvider.');\n    }\n\n    if (dpSelf.accessMode === 'tree') {\n      var cursorNode = _.last(dpSelf.topTreeNode.children);\n\n      if (cursorNode) {\n        return dpSelf.getTreeNodePage(dataCtxNode, dpSelf.topTreeNode, cursorNode.id, true, dpSelf.topTreeNode);\n      }\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    }\n\n    var totalFound = dpSelf.viewModelCollection.getTotalObjectsFound();\n    var totalUniqueLoaded = dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n\n    if (totalFound > totalUniqueLoaded || dpSelf.cursorObject && !dpSelf.cursorObject.endReached) {\n      dpSelf.startIndex = totalUniqueLoaded;\n      var listLoadInput = awTableSvc.createListLoadInput(null, dpSelf.startIndex, null, true, true, dataCtxNode.filterStr);\n      var actionRequestObj = {\n        listLoadInput: listLoadInput\n      };\n      var action = dpSelf.nextAction ? dpSelf.nextAction : dpSelf.action;\n\n      if (logger.isDeclarativeLogEnabled()) {\n        debugService.debugDataProviderNextPage(dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj);\n      }\n\n      return dpSelf.someDataProviderSvc.getNextPage(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n        var vmCollection = dpSelf.viewModelCollection;\n        vmCollection.setTotalObjectsFound(response.totalFound);\n\n        if (response.totalFound > 0) {\n          vmCollection.updateModelObjects(response.results, dpSelf.uidInResponse, dpSelf.preSelection);\n        }\n\n        _notifyModelObjectsUpdate(dataCtxNode, {\n          nextPage: true\n        });\n\n        if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n          _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n        }\n\n        if (dpSelf.accessMode === 'lov') {\n          // lov api expects incremental response, not the entire collection\n          return response;\n        }\n\n        return vmCollection;\n      });\n    }\n\n    return $q.resolve(dpSelf.viewModelCollection);\n  };\n  /**\n   * Validate selection\n   *\n   * @param {Object} lovScope - lov context\n   * @param {Array} selected - selected object/s to validate\n   * @param {Boolean} suggestion - does selected contain a suggested value?\n   *\n   * @return {Promise} Promise that is resolved upon completion of validateion.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.validateSelections = function (lovScope, selected, suggestion) {\n    var action = dpSelf.validateAction;\n\n    if (action) {\n      var actionRequestObj = {\n        selected: selected,\n        suggestion: suggestion\n      };\n      return dpSelf.someDataProviderSvc.validateSelections(action, dpSelf.json, lovScope, actionRequestObj).then(function (resp) {\n        if (!resp.valid) {\n          resp.cause = {\n            partialErrors: true\n          };\n          throw resp;\n        }\n\n        eventBus.publish(dpSelf.name + '.validSelectionEvent', {\n          selectedObjects: selected\n        });\n        return resp;\n      });\n    } // if validate action is not defined, assume all valid\n\n\n    eventBus.publish(dpSelf.name + '.validSelectionEvent', {\n      selectedObjects: selected\n    });\n    return AwPromiseService.instance.resolve({\n      valid: true\n    });\n  };\n  /**\n   * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n   *\n   * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n   * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any new nodes.\n   *\n   * @return {Promise} A promise resolved when the expansion is complete and the ViewModelCollection is\n   *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.expandObject = function (dataCtxNode, parentNode) {\n    var begNdx = -1;\n\n    if (dpSelf.cacheCollapse) {\n      var vmNodes = dpSelf.viewModelCollection.loadedVMObjects; // BMW: can use _, I am lazy now for prototype\n\n      for (var ndx = 0; ndx < vmNodes.length; ndx++) {\n        if (vmNodes[ndx].id === parentNode.id) {\n          begNdx = ndx + 1;\n          break;\n        }\n      }\n    } // BMW: Load __expendState if dpSelf.cacheCollapse == true\n\n\n    if (begNdx >= 0 && parentNode.__expandState && dpSelf.cacheCollapse) {\n      // Apply __expandState.expandedNodes to vmoCollection\n      var vmos = dpSelf.viewModelCollection.loadedVMObjects;\n      vmos.splice.apply(vmos, [begNdx, 0].concat(parentNode.__expandState.expandedNodes));\n      dpSelf.viewModelCollection.setTotalObjectsFound(vmos.length); // Load parentNode context back\n\n      parentNode.children = parentNode.__expandState.children;\n      parentNode.startChildNdx = parentNode.__expandState.startChildNdx;\n      parentNode.totalChildCount = parentNode.__expandState.totalChildCount;\n      parentNode.cursorObject = parentNode.__expandState.cursorObject; // Clean up and return\n\n      delete parentNode.__expandState;\n      return $q.resolve(dpSelf.viewModelCollection);\n    } // BMW: Clean up __expendState if dpSelf.cacheCollapse == false\n\n\n    if (!dpSelf.cacheCollapse && parentNode.__expandState) {\n      delete parentNode.__expandState;\n    }\n\n    return dpSelf.getTreeNodePage(dataCtxNode, parentNode, null, true, dpSelf.topTreeNode);\n  };\n\n  let _initialCacheCollapseState = false;\n  /**\n   *\n   * Function to restore collapse cache to the initial value\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.restoreInitialCacheCollapseState = function () {\n    if (!_initialCacheCollapseState) {\n      dpSelf.cacheCollapse = false;\n      dpSelf.resetCollapseCache();\n    } else {\n      dpSelf.cacheCollapse = true;\n    }\n  };\n  /**\n   *\n   * Function to reset collapse cache when needed\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.resetCollapseCache = function () {\n    if (!dpSelf.viewModelCollection || !dpSelf.viewModelCollection.loadedVMObjects) {\n      return;\n    }\n\n    _.forEach(dpSelf.viewModelCollection.loadedVMObjects, function (vmo) {\n      if (vmo.__expandState) {\n        delete vmo.__expandState;\n      }\n    });\n  };\n  /**\n   * Set valid source types for data provider, this is used for drag and drop usage\n   *\n   * @param {Object} validSourceTypes - valid source types for dataprovider which are set from xrt objectset\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.setValidSourceTypes = function (validSourceTypes) {\n    dpSelf.validSourceTypes = validSourceTypes;\n  };\n  /**\n   * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n   *\n   * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n   * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any 'child' nodes being removed as\n   *            part of the collapse.\n   * @return {Promise} A promise resolved when the collapse is complete and the ViewModelCollection is\n   *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.collapseObject = function (dataCtxNode, parentNode) {\n    /**\n     * Remove all 'child' nodes of this 'parent' from the 'loadedVMObjects' of the ViewModelCollection and\n     * reset it's internal 'children' array.\n     */\n    var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n    var begNdx = -1;\n    var nDelete = 0; // BMW Issue #5: add document to this algorithm.\n    // - Loop through the whole vmoCollection\n    // - When find the parent node, set state to start ( begNdx )\n    // - Keep going, when hits node which node.level <= parent.level, stop ( next sibling )\n    // - record all as nDelete.\n    //\n    // So we don't have to clen parentNode.children here...anyway it will be done later\n\n    for (var ndx = 0; ndx < vmNodes.length; ndx++) {\n      if (uwUtilSvc.getEvaluatedId(vmNodes[ndx]) === uwUtilSvc.getEvaluatedId(parentNode)) {\n        begNdx = ndx + 1;\n        nDelete = 0;\n      } else if (begNdx >= 0) {\n        if (vmNodes[ndx].levelNdx > parentNode.levelNdx) {\n          nDelete++;\n        } else {\n          // BMW Issue #5:\n          // parentNode.children = null;\n          break;\n        }\n      }\n    }\n\n    if (nDelete > 0) {\n      var collapsedNodes = vmNodes.splice(begNdx, nDelete); // BMW Issue #7: When any of the node is in loading status, don't cache\n\n      var collapesdNodesIsLoading = _.reduce(collapsedNodes, function (sum, node) {\n        return sum ? sum : node.loadingStatus;\n      }, false); // BMW: Cache collapse object here\n\n\n      if (dpSelf.cacheCollapse && !collapesdNodesIsLoading) {\n        parentNode.__expandState = {\n          children: parentNode.children,\n          startChildNdx: parentNode.startChildNdx,\n          totalChildCount: parentNode.totalChildCount,\n          // BMW #5: actually cursorObject cache here is not needed since\n          // it is anyway leaking in current system when collapse. But for\n          // safe we can cache and load it too.\n          cursorObject: parentNode.cursorObject,\n          expandedNodes: collapsedNodes\n        };\n      }\n\n      parentNode.children = null;\n      parentNode.startChildNdx = 0;\n      parentNode.totalChildCount = null;\n    } // Re-evaluate selection state, since we have removed children selection state have changed.\n\n\n    dpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);\n    return $q.resolve(dpSelf.viewModelCollection);\n  }; // collapseObject\n\n  /**\n   * Access a page of 'child' nodes of the given 'parent' node and place the results into the\n   * ViewModelColection of this UwDataProvider.\n   * <P>\n   * Note: Paging information stored in the 'parent' node is used to determine which 'child' nodes to get.\n   * This paging information is then updated to be ready for any subsequent call to this API.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   *\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @param {ViewModelTreeNode} rootNode - Root Node opened\n   *\n   * @param {Boolean} focusLoadAction - (Optional) TRUE if action is triggered to load selected object in tree\n   *\n   * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNodePage = function (dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode, focusLoadAction) {\n    var action = addAfter ? dpSelf.nextAction || dpSelf.action : dpSelf.previousAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput,\n      loadIDs: {\n        t_uid: dpSelf.topTreeNode.uid,\n        o_uid: treeLoadInput.parentNode.uid\n      }\n    }; // focusLoadAction will be true when object present in selection model needs to be loaded in tree.\n    // (cross select between PWA and other sources e.g. Search Panel)\n\n    if (focusLoadAction) {\n      action = dpSelf.focusAction ? dpSelf.focusAction : null;\n      treeLoadInput.focusLoadAction = focusLoadAction;\n    }\n\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    var origCursorObj = _.clone(treeLoadInput.parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * Access the initial page of data.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   *\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @param {ViewModelTreeNode} rootNode - Root Node opened\n   *\n   * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNodeInitial = function (dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode) {\n    var action = dpSelf.initializeAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n\n    var origCursorObj = _.clone(treeLoadInput.parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * Access a page of 'child' nodes of the given 'parent' node (starting at a specific 'child' node) and place\n   * the results into the ViewModelColection of this UwDataProvider.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   * @param {String} startChildId - ID of a node in the 'parent' to start loading at.\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   * @param {Number} pageSize - Maximum number of 'child' nodes to return (including the 'startChild').\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @return {Promise} A promise object resolved with a reference to the updated ViewModelColection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNode = function (dataCtxNode, parentNode, startChildId, cursorNodeId, pageSize, addAfter) {\n    var action = addAfter ? dpSelf.nextAction : dpSelf.previousAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, startChildId, cursorNodeId, pageSize, addAfter);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput\n    };\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    var origCursorObj = _.clone(parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {PropertyLoadInput} propertyLoadInput - The object containing the PropertyLoadRequest(s) to\n   *            process.\n   *\n   * @return {Promise} The Promise is resolved with a PropertyLoadResult object when the operation is\n   *         complete.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getProperties = function (dataCtxNode, propertyLoadInput) {\n    assert(dpSelf.action, 'Invalid action specified');\n    var actionRequestObj = {\n      propertyLoadInput: propertyLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n      return response.propertyLoadResult;\n    });\n  };\n\n  dpSelf.getFilterFacets = function (viewModel, filterFacetInput) {\n    var action = dpSelf.filterFacetAction;\n    var dataCtxNode = {\n      data: viewModel,\n      filterFacetInput: filterFacetInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    if (action) {\n      return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode).then(function (response) {\n        return response.filterFacetResults;\n      });\n    }\n\n    return $q.resolve();\n  };\n  /**\n   * Free up all resources held by this object.\n   * <P>\n   * Note: After this function, no API call should be considered valid. This function is intended to be called\n   * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event),\n   * any objects managed by this class may be considered a 'memory leak'.\n   */\n\n\n  dpSelf.destroy = function () {\n    dpSelf._isDestroyed = true;\n    declModelRegistrySvc.unregisterModel('UwDataProvider', dpSelf, 'name', '_modelId');\n\n    if (dpSelf._appCtxEditInProgress) {\n      appCtxService.unRegisterCtx(dpSelf._appCtxEditInProgress);\n    }\n\n    if (dpSelf.selectionModel) {\n      dpSelf.detachSelectionModel();\n      dpSelf.selectionModel = null;\n    }\n\n    if (dpSelf.viewModelCollection) {\n      dpSelf.viewModelCollection.destroy();\n      dpSelf.viewModelCollection = null;\n    }\n\n    if (dpSelf.someDataProviderSvc && dpSelf.someDataProviderSvc.destroy) {\n      dpSelf.someDataProviderSvc.destroy();\n      dpSelf.someDataProviderSvc = null;\n    }\n\n    if (dpSelf.json.editContext && _editHandlerRegistered) {\n      editHandlerSvc.removeEditHandler(dpSelf.json.editContext);\n    }\n\n    const editConfig = dpSelf.json.editConfig;\n\n    if (editConfig) {\n      editUtilsService._removeListeners(editConfig.sourceModel);\n    }\n\n    dpSelf.cols = null;\n    dpSelf.topTreeNode = null;\n    dpSelf.actionObj = null;\n    dpSelf.json = null;\n    dpSelf.ttState = null;\n    dpSelf.policy = null;\n    dpSelf.validSourceTypes = null;\n    eventBus.unsubscribe(dpSelf.toggleDecoratorsEvent);\n    eventBus.unsubscribe(dpSelf.multiSelectModeEvent);\n    eventBus.unsubscribe(dpSelf.selectActionEvent);\n    dpSelf.toggleDecoratorsEvent = null;\n    dpSelf.multiSelectModeEvent = null;\n    dpSelf.selectActionEvent = null;\n    dpSelf.setRootReference(null); // detach dispatcher\n\n    dpSelf.vmCollectionDispatcher = null;\n    dpSelf.pageDispatcher = null;\n    dpSelf.selectionModel = null;\n    referenceElement = null;\n    selectionModelDispatcher = null;\n    dpSelf = null;\n  }; // destroy\n\n  /**\n   * ---------------------------------------------------------------------------<BR>\n   * Property & Function definition complete....Finish initialization. <BR>\n   * ---------------------------------------------------------------------------<BR>\n   */\n\n\n  declModelRegistrySvc.registerModel('UwDataProvider', dpSelf, 'name', '_modelId');\n  /**\n   * Load localized text for when we encounter cases of no results and loading .\n   *\n   * @param localTextBundle\n   */\n\n  localeSvc.getTextPromise().then(function (localTextBundle) {\n    if (dpSelf) {\n      if (declUtils.isNil(dpSelf.isLoading)) {\n        dpSelf.isLoading = localTextBundle.LOADING_TEXT;\n      }\n    }\n  });\n\n  if (actionObj) {\n    dpSelf.action = actionObj;\n  }\n\n  _.forEach(actionMap, function (actionDef, actionName) {\n    dpSelf[actionName] = actionDef;\n  });\n\n  if (dataProviderJson) {\n    dpSelf.json = dataProviderJson;\n    dpSelf.policy = dataProviderJson.policy;\n    /** tree page size */\n\n    if (dataProviderJson.treePageSize) {\n      dpSelf.treePageSize = dataProviderJson.treePageSize;\n    }\n    /** Row or Cell selection scope ? */\n\n\n    if (dataProviderJson.selectionModelScope) {\n      dpSelf.selectionModel.scope = dataProviderJson.selectionModelScope;\n    }\n    /**\n     * Only set the default text values if they are not already set in the dataProvider JSON definition.\n     */\n\n\n    if (dataProviderJson.noResultsFound) {\n      dpSelf.noResultsFound = dataProviderJson.noResultsFound;\n    }\n\n    if (dataProviderJson.isLoading) {\n      dpSelf.isLoading = dataProviderJson.isLoading;\n    }\n\n    if (dataProviderJson.cacheCollapse) {\n      _initialCacheCollapseState = dataProviderJson.cacheCollapse;\n      dpSelf.cacheCollapse = _initialCacheCollapseState;\n    }\n  }\n  /**\n   * Get the editable object from the data provider\n   *\n   * In case of list, it sends the selected object.<BR>\n   * In case of Table, it send the all the loaded objects.\n   *\n   * @return {object} viewModelObject - View model object(s).\n   */\n\n\n  dpSelf.getEditableObjects = function () {\n    if (dataProviderJson && dataProviderJson.editContext) {\n      if (dataProviderJson.editContext === 'LIST_CELL_CONTEXT') {\n        if (dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single') {\n          return dpSelf.getSelectedObjects();\n        }\n      } else {\n        var vmc = dpSelf.viewModelCollection;\n        return vmc.getLoadedViewModelObjects();\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get a list of property names form the dataprovider\n   *\n   * @return {Array} propNames - list of property Names\n   */\n\n\n  dpSelf.getPropertyNames = function () {\n    var propNames = [];\n\n    if (dataProviderJson.editContext === 'LIST_CELL_CONTEXT') {\n      if (dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single') {\n        var selectedObject = dpSelf.getSelectedObjects();\n\n        if (selectedObject !== null) {\n          _.forEach(selectedObject, function (viewModelObject) {\n            _.forEach(viewModelObject.props, function (props) {\n              if (props && props.type) {\n                propNames.push(props.propertyName);\n              }\n            });\n          });\n        }\n      }\n    } else {\n      if (dpSelf.cols) {\n        _.forEach(dpSelf.cols, function (col) {\n          if (col && col.typeName && !col.isTreeNavigation) {\n            propNames.push(col.propertyName);\n          }\n        });\n      }\n    }\n\n    return propNames;\n  };\n  /**\n   * Gets the edit configuration object\n   * @return {Object} The edit configuration object\n   */\n\n\n  dpSelf.getEditConfiguration = function () {\n    return dpSelf.json.editConfig;\n  };\n  /**\n   * Get the command override anchors set in viewModel.\n   *\n   * @return {Object} All possible override anchor strings\n   */\n\n\n  dpSelf.getCommandOverrides = function () {\n    return {\n      gridMenuCommandsAnchor: dpSelf.json.gridMenuCommandsAnchor,\n      contextMenuCommandsAnchor: dpSelf.json.contextMenuCommandsAnchor,\n      columnMenuCommandsAnchor: dpSelf.json.columnMenuCommandsAnchor\n    };\n  };\n}; // UwDataProvider\n\n/**\n * ---------------------------------------------------------------------------<BR>\n * Define the public API for the 'dataProviderFactory' Service<BR>\n * ---------------------------------------------------------------------------<BR>\n */\n\n\n_c2 = UwDataProvider;\n_c = UwDataProvider;\nvar exports = {};\n/**\n * Create a new DeclDataProvider object to manage and access List, LOV, flat-table and tree-table structured\n * ViewModelObjects.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {StringMap} actionsMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n *\n * @return {UwDataProvider} The newly created DeclDataProvider object.\n *\n * @memberof module:js/dataProviderFactory\n */\n\nexport let createDataProvider = function (dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, actionsMap) {\n  var viewModelCollection = viewModelCollectionFactory.createViewModelCollection(dataProviderName);\n  return new UwDataProvider(AwPromiseService.instance, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, viewModelCollection, actionsMap);\n};\n/**\n * Using the given UID, determine which IModelObject should be set as the 'top' node (if any). That object\n * will be set as a new 'top' ViewModelTreeNode on the given dataProvider.\n * <P>\n * Note: The 'top' node is generally hidden from the user and is used only to access 'child' nodes and other\n * properties.\n *\n * @param {String} topNodeUid - (Optional) The ID of the 'top' (if known)\n *\n * @return {ViewModelTreeNode} The new 'top' node.\n */\n\nfunction _determineTopTreeNode(topNodeUid) {\n  /**\n   * Create a 'straw' top node to use just in case.\n   */\n  var topTreeNode = {\n    nodeId: 'top',\n    nodeType: 'rootType',\n    displayName: 'top',\n    levelNdx: -1,\n    childNdx: 0\n  };\n\n  if (!_.isEmpty(topNodeUid)) {\n    topTreeNode.nodeId = topNodeUid;\n    topTreeNode.nodeType = 'unknown';\n  }\n\n  return awTableSvc.createViewModelTreeNode(topTreeNode.nodeId, topTreeNode.nodeType, topTreeNode.displayName, topTreeNode.levelNdx, topTreeNode.childNdx, null);\n} // _determineTopTreeNode\n\n\nlet initPreferredChoices = [];\nexport const loadAction = async (dataProvider, dataCtxNode, vmCollection, startIndex, pageObject) => {\n  // revisitme Subhajit: To keep the backward compatibility.. we need to work on declDataCtxService\n  dataProvider.startIndex = startIndex;\n  let pageActionType = pageObject.pageActionType; // tree - for pagination needs improvement\n\n  if (dataProvider.accessMode === 'tree') {\n    let results;\n\n    switch (pageActionType) {\n      case 'NEXT_PAGE':\n        results = await dataProvider.getNextPage(dataCtxNode);\n        break;\n\n      case 'PREVIOUS_PAGE':\n        results = await dataProvider.getPreviousPage(dataCtxNode);\n        break;\n\n      case 'PAGE_RESET':\n        dataProvider.topTreeNode = _determineTopTreeNode(dataProvider.topNodeUid);\n        results = await dataProvider.getTreeNodeInitial(dataCtxNode, dataProvider.topTreeNode, null, true, dataProvider.topTreeNode); //PAGE_RESET - This means the dataprovider is re-initialized\n        //Clear the previous data in vmCollection before updating the new data\n\n        dataProvider.viewModelCollection.clear();\n        break;\n\n      case 'FOCUS_PAGE':\n        var focusLoadAction = true;\n        dataProvider.topTreeNode = _determineTopTreeNode(dataProvider.topNodeUid);\n        results = await dataProvider.getTreeNodePage(dataCtxNode, dataProvider.topTreeNode, null, true, dataProvider.topTreeNode, focusLoadAction);\n        break;\n    } //Verify if the component is still mounted\n\n\n    if (!dataProvider.vmCollectionDispatcher) {\n      return;\n    } // totalFound and hasMoreValuesExist are mutually exclusive keys.\n\n\n    dataProvider.vmCollectionDispatcher({\n      type: 'COLLECTION_UPDATE',\n      viewModelObjects: results.loadedVMObjects,\n      totalFound: results.totalFound,\n      cursorObject: dataProvider.topTreeNode.cursorObject,\n      pageObject: pageObject\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'FOCUSING',\n      focusing: false\n    });\n\n    if (pageActionType === 'FOCUS_PAGE') {\n      dataProvider.syncSelectionModel(dataCtxNode);\n    }\n  } else {\n    let action;\n\n    switch (pageActionType) {\n      case 'PAGE_RESET':\n        dataProvider.startIndex = 0;\n        action = dataProvider.initializeAction ? dataProvider.initializeAction : dataProvider.action;\n        break;\n\n      case 'NEXT_PAGE':\n        action = dataProvider.nextAction ? dataProvider.nextAction : dataProvider.action;\n        break;\n\n      case 'PREVIOUS_PAGE':\n        action = dataProvider.previousAction ? dataProvider.previousAction : dataProvider.action;\n        break;\n\n      case 'FOCUS_PAGE':\n        dataProvider.startIndex = 0;\n        dataProvider.vmCollectionDispatcher({\n          type: 'COLLECTION_RESET'\n        });\n        action = dataProvider.focusAction ? dataProvider.focusAction : null;\n        break;\n    }\n\n    let listLoadInput = awTableSvc.createListLoadInput(null, dataProvider.startIndex, null, true);\n    let actionRequestObj = {\n      listLoadInput\n    };\n    const response = await dataProvider.someDataProviderSvc.executeLoadAction(action, dataProvider.json, dataCtxNode, actionRequestObj); //Verify if the component is still mounted\n\n    if (!dataProvider.vmCollectionDispatcher) {\n      return;\n    }\n\n    let viewModelObjects = vmCollection.createModelObjects(response.results || []);\n\n    if (pageActionType === 'NEXT_PAGE') {\n      viewModelObjects = vmCollection.getLoadedViewModelObjects().concat(viewModelObjects);\n    } else if (pageActionType === 'PREVIOUS_PAGE') {\n      viewModelObjects = viewModelObjects.concat(vmCollection.getLoadedViewModelObjects());\n    } else if (pageActionType === 'PAGE_RESET') {\n      // PAGE_RESET - This means the dataprovider is re-initialized\n      // retrieve preferred vals if defined\n      if (dataProvider.preferredChoicesAction) {\n        const preferredChoiceResp = await dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.preferredChoicesAction, dataProvider.json, dataCtxNode);\n        initPreferredChoices = preferredChoiceResp.actionResultObj.responseObj.preferredChoices;\n      } // Clear the previous data in vmCollection before updating the new data\n\n\n      if (response.hasOwnProperty('lovUsage')) {\n        dataProvider.lovUsage = response.lovUsage;\n      }\n\n      if (response) {\n        dataProvider.viewModelCollection.clear();\n      }\n\n      if (response.totalFound > 0 && response.results) {\n        dataProvider.noResults = false;\n      } else {\n        dataProvider.noResults = true; // assigning no result found string if there is no data from rest service\n\n        if (dataProvider.json.noResultsFound) {\n          var i18nkey = dataProvider.json.noResultsFound;\n          i18nkey = parsingUtils.geti18nKey(i18nkey);\n          dataProvider.noResultsFound = dataCtxNode.data.i18n[i18nkey];\n        }\n      }\n    } // totalFound and hasMoreValuesExist are mutually exclusive keys.\n\n\n    let totalFound = response.hasOwnProperty('moreValuesExist') ? -1 : response.totalFound;\n    let hasMoreValuesExist = response.hasOwnProperty('moreValuesExist') ? response.moreValuesExist : null; // set preferred vals if defined\n\n    if (dataProvider.preferredChoicesAction) {\n      response.preferredChoices = initPreferredChoices;\n    }\n\n    dataProvider.vmCollectionDispatcher({\n      type: 'COLLECTION_UPDATE',\n      viewModelObjects: viewModelObjects,\n      totalFound,\n      hasMoreValuesExist,\n      cursorObject: dataProvider.cursorObject,\n      pageObject: pageObject,\n      preferredChoices: response.preferredChoices\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    });\n    dataProvider.notifyModelObjectsUpdate();\n    /**\n     * Determine if the last node in the collection is an 'incompleteTail' because we know\n     * there are more found than currently loaded.\n     */\n\n    if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n      _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n    }\n    /**\n     * Determine if the first node in the collection is an 'incompleteHead'\n     */\n\n\n    if (!_.isEmpty(vmCollection.loadedVMObjects) && dataProvider.cursorObject && dataProvider.cursorObject.startReached === false) {\n      _.head(vmCollection.loadedVMObjects).incompleteHead = true;\n    }\n  }\n\n  if (pageActionType === 'FOCUS_PAGE') {\n    //  revisitme Shaishav: In old focus action following variables were getting set.\n    //  We might need them when TC tables are supported.\n    //  Keeping is commented to not lose track of them\n    // if( response.totalFound > 0 && response.results ) {\n    //     dpSelf.noResults = false;\n    //     vmCollection.updateModelObjects( response.results,\n    //         dpSelf.uidInResponse, dpSelf.preSelection );\n    // } else {\n    //     dpSelf.noResults = true;\n    // }\n    eventBus.publish(dataProvider.name + '.focusSelection');\n  }\n};\n/**\n *\n * @param {*} param0\n * @param {*} dataProvider\n * @param {*} dataCtxNode\n */\n\nexport const validateLovAction = (_ref3, dataProvider, dataCtxNode) => {\n  let {\n    lovEntries,\n    vmo,\n    viewModelProp\n  } = _ref3;\n  return dataProvider.validateLOV({\n    lovEntries,\n    vmo,\n    viewModelProp\n  }, dataCtxNode);\n};\n/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {UwDataProvider} The DeclDataProvider from the given arguments (or undefined if not found)\n */\n\nexport let findDataProvider = function (argsIn) {\n  for (var ndx = 0; ndx < argsIn.length; ndx++) {\n    var arg = argsIn[ndx];\n\n    if (exports.isDataProvider(arg)) {\n      return arg;\n    }\n  }\n\n  return undefined;\n};\n/**\n * Test if the given object 'is-a' UwDataProvider created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a DeclDataProvider.\n */\n\nexport let isDataProvider = function (objectToTest) {\n  return objectToTest instanceof UwDataProvider;\n};\n/**\n * Select all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\n\nexport let selectAll = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.selectAll();\n  }\n};\n/**\n * Deselect all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\n\nexport let selectNone = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.selectNone();\n  }\n};\n/**\n * Enable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\n\nexport let dataProviderEnableMultiSelect = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.enableMultiSelect();\n  }\n};\n/**\n * Disable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\n\nexport let dataProviderDisableMultiSelect = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.disableMultiSelect();\n  }\n};\n\nfunction loadDebugOption() {\n  var urlAttrs = browserUtils.getUrlAttributes();\n  _debug_logTreeLoadActivity = urlAttrs.logTreeLoadActivity !== undefined;\n}\n/**\n * createDynamicDataProvider based on jsonData specified by src\\propertyrender\\lovDataProvider.json\n * @param {int} index - the index to return\n * @return {Object} dataProvider the dataProvider\n */\n\n\nexport let createDynamicDataProvider = function () {\n  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let dataProviders = [];\n\n  let _processAction = (jsonData, jsonDataProvider, dpName, actionName, actionMap) => {\n    var actionRef = jsonDataProvider[actionName];\n\n    if (actionRef && jsonData.actions) {\n      actionMap[actionName] = jsonData.actions[actionRef];\n    }\n  };\n\n  if (jsonData.dataProviders) {\n    var dataProvidersClone = _.cloneDeep(jsonData.dataProviders);\n\n    _.forEach(dataProvidersClone, function (jsonDataProvider, dpName) {\n      var actionMap = {};\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'action', actionMap); // legacy init/getNext action\n\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'initializeAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'nextAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'previousAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'focusAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'expandAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'validateAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'filterFacetAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'preferredChoicesAction', actionMap);\n\n      let dataProviderInstance = createDataProvider(jsonDataProvider, actionMap.action, dpName, declDataProviderSvc, actionMap);\n      dataProviderInstance.dynamicDp = true;\n      dataProviderInstance.debugId = Math.floor(Math.random() * 100);\n      dataProviders.push(dataProviderInstance);\n    });\n  }\n\n  return dataProviders[index];\n};\nexports = {\n  createDataProvider,\n  createDynamicDataProvider,\n  findDataProvider,\n  isDataProvider,\n  loadAction,\n  selectAll,\n  selectNone,\n  dataProviderEnableMultiSelect,\n  dataProviderDisableMultiSelect,\n  validateLovAction\n};\nexport default exports;\nloadDebugOption();\n\nvar _c;\n\n$RefreshReg$(_c, \"UwDataProvider\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"UwDataProvider\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/dataProviderFactory.js"],"names":["jsonData","cfgSvc","trace","_modifiablePropertiesViaInputData","_debug_logTreeLoadActivity","UwDataProvider","dpSelf","_ctorInputData","dataProviderJson","paginationOption","filterStr","propsCallback","lovEntryRef","referenceElement","updateDataCtxNodeWithProps","dataCtxNode","eventData","saveRowExpanded","node","declViewModel","declUtils","grids","awTableStateSvc","Object","_notifyModelObjectsUpdate","eventBus","cursorNdx","vmCollection","cursorNode","loadedVMOs","logger","vmosToInsert","childNdxOffset","ndx1","insertNdx","ndx3","arrayUtils","ndx2","nChild","parentNode","ndx","assert","treeLoadResult","responseObj","resultParentNode","response","totalFound","loadedVMObjects","isParentRoot","_","origParentNdx","uwUtilSvc","expectantParentNode","nRootPaths","resultTopNode","usedPathParent","newTopNode","addAfter","treeLoadInput","newParent","cursorChildNdx","_findChildNdx","insertionChildNdx","origCursorObj","newNodes","prevParentNode","parent","nextLevelNdx","child","currentlyLoadedRootPathNodeVMO","startLevelIndex","numberOfLevelsToBeInserted","vmo","vmNodes","nextLevelParentNode","viewModelObjects","getViewModelCollectionInTreeHierarchyFormat","getViewModelCollectionInTreeHierarchyFormatForTopDown","_insertModelObjects","insertionNode","moreAboveFirst","moreBelowLast","prevPage","nextPage","emptyChildNodes","finalVMOs","lvlNdx","numberOfLevelsInserted","indx","finalVMOIndex","finalVMO","vmNodeInTreeHierarchyLevel","index","currentNodes","vmoIndex","levelIndex","currentNode","startChildNdx","parentLevelNdx","currRow","loadedVMO","e","start","s","objects","select","_selectionModelDataCtxNode","oldSelection","newSelection","isSelectionEnabled","prevSelectedObjects","emitEvents","selected","source","id","_modelId","eventObj","selectedObjects","selectedUids","scope","selectionModel","dataProviderName","dataProvider","shouldEmitSelectionEvent","newlySelected","newlySelectedObject","type","focusing","uidSet","uid","obj","isSharedSelectionModel","_notifyEditStateChange","stateName","appCtxService","viewModelCollection","editUtilsService","evaluationEnv","data","ctx","conditions","conditionStates","editConfig","saveEditStateChangeCallback","filterVal","dataCtxService","reusableEditHandler","editHandlerSvc","_editHandlerRegistered","promise","Promise","selectionDispatcher","selectionModelDispatcher","ref","getProps","pageOption","fetching","viewModelProp","action","valid","updatedVMOs","newVMOs","totalFoundIn","length","_reportAccessToZombieDataProvider","i","vmNode","$q","listLoadInput","awTableSvc","actionRequestObj","totalUniqueLoaded","debugService","suggestion","resp","partialErrors","begNdx","vmos","_initialCacheCollapseState","nDelete","collapsedNodes","collapesdNodesIsLoading","sum","children","totalChildCount","cursorObject","expandedNodes","inputData","_determineInput","loadIDs","t_uid","o_uid","_processLoadTreeNodePageResponse","propertyLoadInput","filterFacetInput","declModelRegistrySvc","localeSvc","localTextBundle","vmc","propNames","selectedObject","viewModelObject","props","col","gridMenuCommandsAnchor","contextMenuCommandsAnchor","columnMenuCommandsAnchor","exports","createDataProvider","viewModelCollectionFactory","AwPromiseService","topTreeNode","nodeId","nodeType","displayName","levelNdx","childNdx","initPreferredChoices","loadAction","pageActionType","pageObject","results","_determineTopTreeNode","focusLoadAction","preferredChoiceResp","i18nkey","parsingUtils","hasMoreValuesExist","preferredChoices","validateLovAction","findDataProvider","argsIn","arg","isDataProvider","objectToTest","selectAll","selectNone","dataProviderEnableMultiSelect","dataProviderDisableMultiSelect","urlAttrs","browserUtils","createDynamicDataProvider","dataProviders","_processAction","actionRef","jsonDataProvider","actionMap","dataProvidersClone","dataProviderInstance","Math","loadDebugOption"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable max-lines */\n// Copyright (c) 2021 Siemens\n\n/**\n * Data provider factory\n *\n * @module js/dataProviderFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport viewModelCollectionFactory from 'js/viewModelCollectionFactory';\nimport localeSvc from 'js/localeService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport dataSourceService from 'js/dataSourceService';\nimport dataCtxService from 'js/declarativeDataCtxService';\nimport declModelRegistrySvc from 'js/declModelRegistryService';\nimport editUtilsService from 'js/editUtilsService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport debugService from 'js/debugService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport awTableSvc from 'js/awTableService';\nimport editHandlerFactory from 'js/editHandlerFactory';\nimport declDataProviderSvc from 'js/declDataProviderService';\nimport cfgSvc from 'js/configurationService';\nconst jsonData = cfgSvc.getCfgCached( 'lovDataProvider' );\nimport Debug from 'debug';\n\nconst trace = new Debug( 'selection' );\n\n/**\n * {StringArray} Collection of valid properties in the 'inputData' property of dataProvider's JSON definition.\n */\nvar _modifiablePropertiesViaInputData = [ 'selectionModel', 'accessMode', 'topNodeUid', 'editSupportParamKeys' ];\n\n/**\n * {Boolean} TRUE if tree node insertion details should be logged.\n */\nvar _debug_logTreeLoadActivity = false;\n\n/**\n * Constructs an object that wraps access to a 'viewModelCollection' created by the\n * 'viewModelCollectionFactory'.\n *\n * @class UwDataProvider\n *\n * @param {QueueService} $q - Queue service to use.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {ViewModelCollection} viewModelCollection - The 'viewModelCollection' used to hold all\n *            ViewModelObjects managed by this DataProvider.\n *\n * @param {StringMap} actionMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n */\nvar UwDataProvider = function( $q, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n    viewModelCollection, actionMap ) {\n    var dpSelf = this; // eslint-disable-line consistent-this\n\n    /**\n     * Data that is passed into the data provider constructor from outside of the view model.\n     */\n    var _ctorInputData = dataProviderJson ? dataProviderJson.inputData : null;\n\n    /**\n     *  This private variable would contain the pagination options and non-modifibale from outside.\n     */\n    let paginationOption = null;\n    /**\n     *  The filter string to be used in getFirstPage/getNextPage APi's\n     */\n    let filterStr = null;\n\n    let propsCallback = null;\n\n    /**\n     *  selectionModelDispatcher : Dispatcher to update the selection Model on the fly.\n     */\n    let selectionModelDispatcher;\n\n    /**\n     *\n     */\n    let lovEntryRef = null;\n\n    /**\n     *  This private variable would contain the reference of the top level referenceElement of list/table/ user defined widget\n     *  using data-provider\n     */\n    let referenceElement = null;\n    /**\n     * {Boolean} TRUE if 'destroy' has been invoked on this instance.\n     */\n    dpSelf._isDestroyed = false;\n\n    /**\n     * @property {String} noResultsFound - Localized message stating 'No results found'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.noResultsFound = null;\n\n    /**\n     * @property {String} isLoading - Localized message stating 'loading'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.isLoading = null;\n\n    /**\n     * @property {Boolean} cacheCollapse - cache collapse infomation to reuse in next expand.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.cacheCollapse = false;\n\n    /**\n     * @property {Object} someDataProviderSvc - Some API object where 'getFirstPage', 'getNextPage', et al.\n     *           methods are implemented (e.g. 'js/declDataProviderService').\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.someDataProviderSvc = someDataProviderSvc;\n\n    /**\n     * @property {String} name - name of data provider object\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.name = dataProviderName;\n\n    /**\n     * @property {ViewModelCollection} viewModelCollection - viewModelCollection which maintains the loaded\n     *           ViewModelObjects and also have APIs to access the information of collection.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.viewModelCollection = viewModelCollection;\n\n    /**\n     * @property {Number} startIndex - Start/Next index into a virtual list.\n     *           <P>\n     *           Note: This property is accessed by some declViewModel bindings and 'glue' code. While it is\n     *           somewhat analogous to the data in the newer 'cursorObject', it is necessary to keep it exposed\n     *           for support of these earlier uses of it.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.startIndex = 0;\n\n    /**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.action = null;\n\n    /**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.focusAction = null;\n\n    /**\n     * @property {DeclDataProviderJson} json - The 'UwDataProvider' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.json = null;\n\n    /**\n     * @property {Object} policy - The Currently set property policy object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.policy = null;\n\n    /**\n     * @property {Object} selectionModel - Object which maintains all the selection objects stuff and provides\n     *           APIs to access information.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    // dpSelf.selectionModel = selectionModelFactory\n    //     .buildSelectionModel( dataProviderJson ? dataProviderJson.selectionModelMode : null );\n\n    /**\n     * @property {Boolean} noResults - Flag decides whether to show no results message if there are no values\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.noResults = false;\n\n    /**\n     * @property {ObjectArray} sortCriteria - Array of ordered sort criteria objects.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.sortCriteria = [];\n\n    /**\n     * @property {Object} filiterMap - A map (string, list of SearchFilter) containing the list of search\n     *           filters for each search filter field. The key in the map is the property name that represents\n     *           the filter category. It is in the format \"TypeName.PropertyName\". e.g\n     *           WorkspaceObject.object_type\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.filterMap = {};\n\n    /**\n     * @property {ViewModelTreeNode} The ViewModelTReeNode which is the logical (but unseen) 'top' node in any\n     *           hierarchy being managed by this UwDataProvider\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.topTreeNode = null;\n\n    /**\n     * Selected objects\n     */\n    dpSelf.selectedObjects = [];\n\n    /**\n     * {Boolean} TRUE if any editHandler associated with this UwDataProvider has been registered.\n     */\n    var _editHandlerRegistered;\n\n    const updateDataCtxNodeWithProps = function( dataCtxNode ) {\n        if( propsCallback ) {\n            dataCtxNode.props = propsCallback();\n            dataCtxNode.getProps = propsCallback;\n        }\n    };\n\n    // Toggle the display of Cell Decorators.\n    dpSelf.toggleDecoratorsEvent = eventBus.subscribe( dpSelf.name + '.toggleCellDecorators', function(\n        eventData ) {\n        if( eventData ) {\n            dpSelf.showDecorators = eventData.toggleState;\n        } else {\n            if( dpSelf.showDecorators ) {\n                dpSelf.showDecorators = false;\n            } else {\n                dpSelf.showDecorators = true;\n            }\n        }\n    } );\n\n    const saveRowExpanded = function( dataCtxNode, node ) {\n        if( node.isExpanded === true ) {\n            var declViewModel = declUtils.findViewModel( dataCtxNode );\n            var grids = declViewModel.grids;\n            awTableStateSvc.saveRowExpanded( declViewModel, grids[Object.keys( grids )[0]].gridid, node );\n        }\n    };\n\n    /**\n     * Fire modelObjects updated event using data provider name space\n     *\n     * @param {Object} dataCtxNode - The 'scope' to use.\n     * @param {Object} eventData - Event data containing data to include in notify.\n     */\n    var _notifyModelObjectsUpdate = function( dataCtxNode, eventData ) {\n        if( dataCtxNode ) {\n            dpSelf.syncSelectionModel( dataCtxNode );\n        }\n\n        eventData = eventData || {};\n\n        // Set standard data\n        eventData.viewModelObjects = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        eventData.noResults = dpSelf.noResults;\n\n        // Publish event\n        eventBus.publish( dpSelf.name + '.modelObjectsUpdated', eventData );\n    };\n\n    dpSelf.notifyModelObjectsUpdate = _notifyModelObjectsUpdate;\n\n    /**\n     * Insert the given array of ViewModelObjects into the given viewModelCollection starting after the given\n     * 'cursor' ViewModelObject ID.\n     *\n     * @param {ViewModelCollection} vmCollection - The ViewModelCollection to update.\n     * @param {String} cursorId - ID of the object The ViewModelObject in the collection to insert after.\n     * @param {ViewModelObjectArray} vmosToInsert - The ViewModelObjects to insert.\n     * @param {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n     *            (Default: TRUE)\n     */\n    function _insertModelObjects( vmCollection, cursorId, vmosToInsert, addAfter ) {\n        var cursorNdx = vmCollection.findViewModelObjectById( cursorId );\n\n        var cursorNode = cursorNdx === -1 ? null : vmCollection.getViewModelObject( cursorNdx );\n\n        var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n\n        if( _debug_logTreeLoadActivity ) {\n            logger.info( '_insertModelObjects: ' + '\\n' + //\n                'n1stLevelFound : ' + vmCollection.totalFound + '\\n' + //\n                'n1stLevelLoaded: ' + vmCollection.totalObjectsLoaded + '\\n' + //\n                'nLoadedOverall : ' + loadedVMOs.length + '\\n' + //\n                'cursorId       : ' + cursorId + '\\n' + //\n                'nVMOsToInsert  : ' + vmosToInsert.length + '\\n' + //\n                'addAfter       : ' + addAfter + '\\n' + //\n                'cursorNdx      : ' + cursorNdx + '\\n' + //\n                'cursorNode     : ' + cursorNode );\n        }\n\n        /**\n         * Check if we found where to insert and it is NOT the top level node.\n         * <P>\n         * Note: This function purposefully does not maintain the 'totalObjectsLoaded' for the overall\n         * viewModelCollection since that value only makes sense for the 'top' node.\n         */\n        if( cursorNode && cursorNode.levelNdx !== -1 ) {\n            var childNdxOffset;\n\n            if( addAfter ) {\n                /**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */\n                if( cursorNode.levelNdx === vmosToInsert[ 0 ].levelNdx ) {\n                    childNdxOffset = loadedVMOs[ cursorNdx ].childNdx + 1;\n\n                    for( var ndx1 = 0; ndx1 < vmosToInsert.length; ndx1++ ) {\n                        vmosToInsert[ ndx1 ].childNdx = childNdxOffset + ndx1;\n                    }\n                }\n\n                /**\n                 * AW-49335 - Jumping to target does not work when page is refreshed...\n                 * <P>\n                 * Check if the 'cursor' node has any children<br>\n                 * If so: We need to account for them before we insert\n                 * <P>\n                 * Note: We look forward until we find a node at the same (or 'above') level.\n                 */\n                var insertNdx = cursorNdx;\n\n                for( var ndx3 = cursorNdx + 1; ndx3 < loadedVMOs.length; ndx3++ ) {\n                    if( loadedVMOs[ ndx3 ].levelNdx <= cursorNode.levelNdx ) {\n                        break;\n                    }\n\n                    insertNdx++;\n                }\n\n                arrayUtils.insert( loadedVMOs, insertNdx, vmosToInsert );\n            } else {\n                /**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */\n                if( cursorNode.levelNdx === vmosToInsert[ 0 ].levelNdx ) {\n                    childNdxOffset = loadedVMOs[ cursorNdx ].childNdx - vmosToInsert.length;\n\n                    for( var ndx2 = 0; ndx2 < vmosToInsert.length; ndx2++ ) {\n                        vmosToInsert[ ndx2 ].childNdx = childNdxOffset + ndx2;\n                    }\n                }\n\n                /**\n                 * Insert just before the 'cursor' node.\n                 * <P>\n                 * Note: Even if the 'cursor' node is preceded by any children from an earlier 'sibling' (i.e. a\n                 * node at the same tree level) we do NOT need to account for them before we insert since the\n                 * 'cursor' position defines the correct break in the tree level.\n                 */\n                arrayUtils.insertBefore( loadedVMOs, cursorNdx, vmosToInsert );\n            }\n        }\n    } // _insertModelObjects\n\n    /**\n     * Locate the 'child' in the given 'parent' based on the 'child' node's ID.\n     *\n     * @param {ViewModelTreeNode} parentNode - The 'parent' who's 'children' to search.\n     * @param {String} cursorNodeId - The ID of the 'child' node to find.\n     * @returns {Number} Index to the 'child' node (or -1 if not found)\n     */\n    function _findChildNdx( parentNode, cursorNodeId ) {\n        var nChild = parentNode.children ? parentNode.children.length : 0;\n\n        if( cursorNodeId ) {\n            for( var ndx = 0; ndx < nChild; ndx++ ) {\n                if( parentNode.children[ ndx ].id === cursorNodeId ) {\n                    return ndx;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Insert the results into the ViewModelCollection array starting at the current location of the 'cursor'\n     * node.\n     *\n     * @param {TreeLoadInput} treeLoadInput - The original input parameters used to generate the response we are\n     *            processing now.\n     *\n     * @param {Object} responseObj - Object returned from the associated load 'action'\n     *\n     * @param {Object} dataCtxNode - Data context used for selection model sync.\n     *\n     * @param {Object} origCursorObj - The cursorObject of the 'parent' node BEFORE the load operation.\n     *\n     * @return {ViewModelCollection} A reference to the updated ViewModelCollection object.\n     */\n    function _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode, origCursorObj ) { // eslint-disable-line\n        assert( responseObj, 'Action did not return a ResponseResult Object' );\n\n        var treeLoadResult = responseObj.treeLoadResult;\n        let vmCollection = dpSelf.viewModelCollection;\n\n        assert( treeLoadResult, 'Action did not return a TreeLoadResult Object' );\n\n        /**\n         * Move the 'parent' and 'viewModelCollection' into handier variables.\n         */\n        var resultParentNode = treeLoadResult.parentNode;\n\n        let response = {\n            totalFound: vmCollection.totalFound,\n            loadedVMObjects: vmCollection.loadedVMObjects\n        };\n\n        /**\n         * Determine if we are working on the very top node of the tree.\n         */\n        var isParentRoot = resultParentNode && resultParentNode.levelNdx === -1;\n\n        /**\n         * Optionally log some useful information\n         */\n        if( _debug_logTreeLoadActivity && !_.isEmpty( treeLoadResult.childNodes ) ) {\n            logger.info( '_processLoadTreeNodePageResponse' + '\\n' + 'parentNode: ' + resultParentNode +\n                ' isParentRoot: ' + isParentRoot + '\\n' + '# children returned: ' +\n                treeLoadResult.childNodes.length );\n        }\n\n        /**\n         * AW-47271 - bash_PI1712-2 : Can Not expand Sub Assembly in tree View in a spcific scenario\n         * <P>\n         * Find the original 'parent' node in the vmCollection and see if it is still expanded.\n         * <P>\n         * Note: If we are working on the 'root', skip this check since the 'root' cannot actually be collapsed.\n         */\n        if( !isParentRoot ) {\n            /**\n             * Check if NOT expanded<BR>\n             * If so: No need to continue. Return current vmCollection unchanged.\n             * <P>\n             * Note: The 'parent' node returned from the async processing can sometimes be a clone made during\n             * processing. It is best to go back to the original to be sure we do not miss the latest state.\n             */\n            var origParentNdx = vmCollection.findViewModelObjectById( uwUtilSvc.getEvaluatedId( resultParentNode ) );\n            if( origParentNdx === -1 || !vmCollection.getViewModelObject( origParentNdx ).isExpanded ) {\n                if( _debug_logTreeLoadActivity ) {\n                    logger\n                        .info( '_processLoadTreeNodePageResponse: Skipping insertion of child nodes into collapsed or missing parent' +\n                            '\\n' + 'parent: ' + resultParentNode + '\\n' + 'index: ' + origParentNdx );\n                }\n\n                return {\n                    totalFound: vmCollection.getTotalObjectsFound(),\n                    loadedVMObjects: vmCollection.getLoadedViewModelObjects()\n                };\n            }\n        }\n\n        /**\n         * Check if we actually have results to insert.\n         */\n        var newTopNode;\n        var moreAboveFirst;\n        var moreBelowLast;\n\n        if( treeLoadResult.totalChildCount > 0 && !_.isEmpty( treeLoadResult.childNodes ) ) {\n            /**\n             * If this is the 'top' level node we now know IT is NOT empty.\n             */\n            if( isParentRoot ) {\n                dpSelf.noResults = false;\n            }\n\n            var expectantParentNode = resultParentNode;\n\n            /**\n             * Get the effective 'parent' node from the paths (if necessary)\n             */\n            var nRootPaths = _.isEmpty( treeLoadResult.rootPathNodes ) ? 0 :\n                treeLoadResult.rootPathNodes.length;\n\n            var usedPathParent;\n\n            if( nRootPaths > 0 ) {\n                /**\n                 * Get the 'top' node based on the path but do not override the current 'expectantParentNode'\n                 * unless it refers to a different object.\n                 */\n                var resultTopNode = _.last( treeLoadResult.rootPathNodes );\n\n                if( resultParentNode.uid !== resultTopNode.uid ) {\n                    expectantParentNode = resultTopNode;\n                    usedPathParent = true;\n                }\n            }\n\n            /**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */\n            newTopNode = treeLoadResult.newTopNode;\n\n            if( newTopNode && newTopNode.levelNdx === -1 ) {\n                dpSelf.topTreeNode = newTopNode;\n                dpSelf.topTreeNode.children = null;\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n                if( !usedPathParent ) {\n                    resultParentNode = treeLoadResult.newTopNode;\n                }\n            }\n\n            /**\n             * Determine if we are inserting before or after the 'start' or 'cursor' node.\n             */\n            var addAfter = declUtils.isNil( treeLoadInput.addAfter ) ? true : treeLoadInput.addAfter;\n\n            /**\n             * Check for the trivial case of 1st-time children\n             * <P>\n             * Note: We do a shallow clone to make sure it is not the same array as the result.\n             */\n            var newParent = _.isEmpty( expectantParentNode.children );\n\n            if( newParent ) {\n                expectantParentNode.children = _.clone( treeLoadResult.childNodes );\n            } else {\n                /**\n                 * Insert the new 'child' nodes into the 'children' array property of the 'parent' node.\n                 * <P>\n                 * Try to use the 'cursor' node to locate exactly where in the 'parent' to insert the new\n                 * 'child' nodes.\n                 * <P>\n                 * If no 'cursor' then just trust the previous index as a 'best guess' (works in a downward list\n                 * scenario).\n                 * <P>\n                 * Note: We have to do this since some cases where the children were inserted out of order or\n                 * even had duplicates. Relocating the 'cursor' locks it in for at least 'this' thread pass.\n                 */\n                var cursorChildNdx = _findChildNdx( expectantParentNode, treeLoadResult.cursorNodeId );\n                var insertionChildNdx = cursorChildNdx;\n\n                if( addAfter ) {\n                    /**\n                     * Reset the 'start' info of the 'parent' node (Server bug? we should not have to do this)\n                     */\n                    if( origCursorObj ) {\n                        expectantParentNode.cursorObject.startIndex = origCursorObj.startIndex;\n                        expectantParentNode.cursorObject.startOccUid = origCursorObj.startOccUid;\n                        expectantParentNode.cursorObject.startReached = origCursorObj.startReached;\n                    }\n                    /**\n                     * First new 'child' node inserted AFTER another cannot be an 'incompleteHead'.\n                     */\n                    _.first( treeLoadResult.childNodes ).incompleteHead = false;\n\n                    /**\n                     * Insert new 'child' nodes into 'parent' AFTER cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteTail'.\n                     */\n                    if( insertionChildNdx === -1 ) {\n                        insertionChildNdx = treeLoadResult.startChildNdx;\n                    } else {\n                        expectantParentNode.children[ cursorChildNdx ].incompleteTail = false;\n\n                        insertionChildNdx++;\n                    }\n\n                    arrayUtils.insert( expectantParentNode.children, insertionChildNdx,\n                        treeLoadResult.childNodes );\n                } else {\n                    /**\n                     * Reset the 'end' info of the 'parent' node (Server bug? we should not have to do this)\n                     */\n                    if( origCursorObj ) {\n                        expectantParentNode.cursorObject.endIndex = origCursorObj.endIndex;\n                        expectantParentNode.cursorObject.endOccUid = origCursorObj.endOccUid;\n                        expectantParentNode.cursorObject.endReached = origCursorObj.endReached;\n                    }\n                    /**\n                     * Last new 'child' node inserted BEFORE another cannot be an 'incompleteTail'\n                     */\n                    _.last( treeLoadResult.childNodes ).incompleteTail = false;\n\n                    /**\n                     * Insert new 'child' nodes into 'parent' BEFORE cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteHead'.\n                     */\n                    if( insertionChildNdx === -1 ) {\n                        insertionChildNdx = treeLoadResult.startChildNdx;\n                    } else {\n                        expectantParentNode.children[ cursorChildNdx ].incompleteHead = false;\n                    }\n\n                    arrayUtils.insertBefore( expectantParentNode.children, insertionChildNdx,\n                        treeLoadResult.childNodes );\n                }\n            }\n\n            /**\n             * Fire a 'resetState' event, sourced to this uwDataProvider, for all tree-table 'focused load'\n             * cases.\n             */\n            if( !treeLoadResult.retainTreeExpansionStates ) {\n                if( isParentRoot && treeLoadResult.isFocusedLoad ) {\n                    eventBus.publish( dpSelf.name + '.resetState', {} );\n                }\n            }\n\n            /**\n             * Check if we were given a non-trivial path to a root (the new 'child' nodes are to be added to the\n             * bottom of).\n             */\n            if( nRootPaths > 1 && newParent ) {\n                dpSelf.topTreeNode = _.first( treeLoadResult.rootPathNodes );\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n                if( !treeLoadResult.vmNodesInTreeHierarchyLevels ) {\n                    var newNodes = [];\n\n                    var prevParentNode = treeLoadResult.rootPathNodes[ 0 ];\n\n                    for( var ndx = 1; ndx < treeLoadResult.rootPathNodes.length; ndx++ ) {\n                        var parent = treeLoadResult.rootPathNodes[ ndx ];\n\n                        newNodes.push( parent );\n\n                        prevParentNode.children = [ parent ];\n\n                        /**\n                         * If expansion states are cleared after 'resetState' event, tree hierarchy that we are\n                         * creating while building tree using rootPathNodes, those rootPathNodes should be saved in\n                         * expansion state as they are expanded.\n                         * <P>\n                         * This is required for tree refresh scenarios (the level the user is working on should get\n                         * restored after refresh)\n                         */\n                        saveRowExpanded( dataCtxNode, parent );\n\n                        prevParentNode = parent;\n                    }\n\n                    /**\n                     * Mark the children to be 1 level below the 'expectant' parent\n                     */\n                    var nextLevelNdx = _.last( treeLoadResult.rootPathNodes ).levelNdx + 1;\n\n                    for( var ndx2 = 0; ndx2 < treeLoadResult.childNodes.length; ndx2++ ) {\n                        var child = treeLoadResult.childNodes[ ndx2 ];\n\n                        child.levelNdx = nextLevelNdx;\n                        child.$$treeLevel = nextLevelNdx;\n\n                        newNodes.push( child );\n                    }\n\n                    /**\n                     * Put all the 'parent' path + 'child' nodes as the sole content of the collection\n                     */\n                    response.totalFound = treeLoadResult.rootPathNodes.length - 1 + treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = newNodes;\n                } else {\n                    var currentlyLoadedRootPathNodeVMO = null;\n                    var startLevelIndex = 0;\n                    var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n                    var numberOfLevelsToBeInserted = 0;\n\n                    // Check if there is request to merge new ViewModelTreeNodes from TreeLoadResult into existing loaded VMOs.\n                    if( treeLoadResult.mergeNewNodesInCurrentlyLoadedTree && loadedVMOs ) {\n                        for( startLevelIndex = treeLoadResult.rootPathNodes.length; startLevelIndex >= 1; startLevelIndex-- ) {\n                            currentlyLoadedRootPathNodeVMO = loadedVMOs\n                                .filter( function( vmo ) {\n                                    return treeLoadResult.rootPathNodes[ startLevelIndex - 1 ] && vmo.id === treeLoadResult.rootPathNodes[ startLevelIndex - 1 ].id;\n                                } )[ 0 ];\n\n                            /**\n                             * currentlyLoadedRootPathNodeVMO is the parent node which is currently loaded in\n                             * VMO and its also present in response structure.\n                             */\n                            if( currentlyLoadedRootPathNodeVMO ) {\n                                numberOfLevelsToBeInserted++;\n                                currentlyLoadedRootPathNodeVMO.nextLevelInsert = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    /**\n                     * 1)vmNodesInTreeHierarchyLevels is an array of arrays. Each array index represents vmNodes\n                     * at given level (index 0 in array represents level -1 which is not displayed, index 1\n                     * level 0 and so on). Each level will have node where next level nodes need to be inserted.\n                     *\n                     * 2)rootPathNodes contain array of parents with one or more having children under it.\n                     *\n                     * 3)At each level, you will have parent below which next level is supposed to be inserted.\n                     */\n                    // Iterate through all levels\n                    for( ndx = startLevelIndex; ndx < treeLoadResult.vmNodesInTreeHierarchyLevels.length; ndx++ ) {\n                        var vmNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ ndx ];\n\n                        // Get parent node below which next level needs to be inserted.\n                        var nextLevelParentNode = vmNodes\n                            .filter( function( vmo ) {\n                                return treeLoadResult.rootPathNodes[ ndx ] && vmo.id === treeLoadResult.rootPathNodes[ ndx ].id;\n                            } )[ 0 ];\n\n                        if( nextLevelParentNode ) {\n                            nextLevelParentNode.nextLevelInsert = true;\n                            numberOfLevelsToBeInserted++;\n                        }\n                    }\n\n                    const viewModelObjects = getViewModelCollectionInTreeHierarchyFormat( treeLoadResult, vmCollection,\n                        currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode );\n                    response.loadedVMObjects = viewModelObjects;\n                    response.totalFound = viewModelObjects.length;\n                }\n            } else if( treeLoadResult.nonRootPathHierarchicalData ) {\n                /**\n                 * If we are given multiple expanded nodes which are all not necessarily on the \"rootPath\"\n                 */\n                const viewModelObjects = getViewModelCollectionInTreeHierarchyFormatForTopDown( treeLoadResult, vmCollection, dataCtxNode );\n                if( viewModelObjects ) {\n                    response.loadedVMObjects = viewModelObjects;\n                    response.totalFound = viewModelObjects.length;\n                }\n            } else {\n                /**\n                 * Check if we are processing the unseen 'root' node.<br>\n                 * If so: Just add the results as the only items in the collection.<BR>\n                 * If not: Insert the results in at the correct location.\n                 */\n                if( isParentRoot && treeLoadResult.startChildNdx === 0 ) {\n                    response.totalFound = treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = _.clone( treeLoadResult.childNodes );\n                } else {\n                    if( treeLoadResult.cursorNodeId ) {\n                        _insertModelObjects( vmCollection, treeLoadResult.cursorNodeId,\n                            treeLoadResult.childNodes, addAfter );\n                    } else {\n                        if( treeLoadResult.startChildNdx === 0 ) {\n                            _insertModelObjects( vmCollection, uwUtilSvc.getEvaluatedId( expectantParentNode ),\n                                treeLoadResult.childNodes, addAfter );\n                        } else {\n                            var insertionNode = expectantParentNode.children[ treeLoadResult.startChildNdx - 1 ];\n\n                            _insertModelObjects( vmCollection, uwUtilSvc.getEvaluatedId( insertionNode ), treeLoadResult.childNodes,\n                                addAfter );\n                        }\n                    }\n                }\n\n                /**\n                 * Update the totalNumber of known 'child' nodes.\n                 */\n                expectantParentNode.totalChildCount = treeLoadResult.totalChildCount;\n            }\n\n            /**\n             * Fire a 'modelObjectsUpdated' event, sourced to this uwDataProvider, but only for changes to the\n             * outer-most level. This event includes the entire ViewModelCollection. This event is required to\n             * have the aw-table controller know when to update the information in the GridWrapper.\n             */\n            if( isParentRoot ) {\n                var nChild = resultParentNode.children ? resultParentNode.children.length : 0;\n\n                moreAboveFirst = false;\n                moreBelowLast = false;\n\n                if( resultParentNode.cursorObject ) {\n                    moreAboveFirst = !resultParentNode.cursorObject.startReached;\n                    moreBelowLast = !resultParentNode.cursorObject.endReached;\n                } else {\n                    moreBelowLast = resultParentNode.totalChildCount > nChild;\n                }\n\n                _notifyModelObjectsUpdate( dataCtxNode, {\n                    prevPage: moreAboveFirst,\n                    nextPage: moreBelowLast\n                } );\n            } else {\n                dpSelf.syncSelectionModel( dataCtxNode );\n            }\n\n            /**\n             * Fire a 'treeNodesLoaded' event, sourced to this uwDataProvider, for all tree-table changes. This\n             * event includes only the input/result structures for the current load operation. This event is\n             * used to load additional properties in an async fashion.\n             */\n            eventBus.publish( dpSelf.name + '.treeNodesLoaded', {\n                treeLoadInput: treeLoadInput,\n                treeLoadResult: treeLoadResult\n            } );\n\n            /**\n             * Check if the response indicates we should make sure the parent is expanded.\n             */\n            if( treeLoadResult.expandParent ) {\n                eventBus.publish( dpSelf.name + '.expandTreeNode', {\n                    parentNode: resultParentNode\n                } );\n            }\n        } else if( isParentRoot ) {\n            /**\n             * If this is the 'top' level node we now know it IS empty.\n             */\n            dpSelf.noResults = true;\n\n            /**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */\n            newTopNode = treeLoadResult.newTopNode;\n\n            if( newTopNode && newTopNode.levelNdx === -1 ) {\n                dpSelf.topTreeNode = newTopNode;\n                dpSelf.topTreeNode.children = null;\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n            }\n\n            /**\n             * If empty child nodes are passed to provider, they should be honored and should get updated in UI.\n             */\n            if( treeLoadResult.startChildNdx === 0 ) {\n                /**\n                 * This change is when we delete a single row from the tree table\n                 */\n                moreAboveFirst = false;\n                moreBelowLast = false;\n                /**\n                 * Determine if this node is NOT an 'incompleteHead' or 'incompleteTail'\n                 */\n                if( resultParentNode.cursorObject ) {\n                    moreAboveFirst = !resultParentNode.cursorObject.startReached;\n                    moreBelowLast = !resultParentNode.cursorObject.endReached;\n                }\n\n                var emptyChildNodes = !moreAboveFirst && !moreBelowLast;\n\n                if( emptyChildNodes ) {\n                    response.totalFound = treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = _.clone( treeLoadResult.childNodes );\n                    _notifyModelObjectsUpdate( dataCtxNode, {\n                        prevPage: moreAboveFirst,\n                        nextPage: moreBelowLast\n                    } );\n                }\n            }\n        }\n\n        return response;\n    }\n\n    /**\n     * @param {TreeLoadResult} treeLoadResult - Object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection - VMO array to set\n     * @param {ViewModelObject} currentlyLoadedRootPathNodeVMO - ...\n     * @param {Number} startLevelIndex -\n     * @param {Number} numberOfLevelsToBeInserted -\n     */\n    function getViewModelCollectionInTreeHierarchyFormat( treeLoadResult, vmCollection,\n        currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode ) {\n        var finalVMOs = [];\n        var lvlNdx = startLevelIndex;\n        var numberOfLevelsInserted = 0;\n        var indx = 0;\n\n        if( currentlyLoadedRootPathNodeVMO ) {\n            /**\n             * currentlyLoadedRootPathNodeVMO is populated. That means parentNode that has come in\n             * TreeLoadResult is already loaded in vmCollection. In that case , restore existing VMOs, merge new\n             * VMOs that we got in response in currently loaded VMOs.\n             */\n            arrayUtils.insert( finalVMOs, 0, vmCollection.getLoadedViewModelObjects() );\n            indx = finalVMOs.indexOf( currentlyLoadedRootPathNodeVMO );\n        } else {\n            // Build Final ViewModelTreeNodes array. Add zeroth level , iterate, check for next level insertion point,\n            // and add new level there.Keep building and iterating through whole list.\n            arrayUtils.insert( finalVMOs, 0, treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx++ ] );\n        }\n\n        while( indx < finalVMOs.length && numberOfLevelsInserted < numberOfLevelsToBeInserted ) {\n            var vmo = finalVMOs[ indx ];\n\n            if( vmo.nextLevelInsert ) {\n                vmo.isExpanded = true;\n\n                for( let vmNodeInTreeHierarchyLevel of treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx] ) {\n                    var finalVMOIndex = 0;\n                    for ( let finalVMO of finalVMOs ) {\n                        if ( finalVMO && finalVMO.id === vmNodeInTreeHierarchyLevel.id ) {\n                            finalVMOs.splice( finalVMOIndex, 1 );\n                        }\n                        finalVMOIndex++;\n                    }\n                }\n\n                arrayUtils.insert( finalVMOs, indx, treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx ] );\n\n                // Next level nodes should be stored as children under current level parent.\n                vmo.children = _.clone( treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx ] );\n                vmo.totalChildCount = vmo.children.length;\n                vmo.isLeaf = false;\n\n                // Store parent as expanded in state/local storage.\n                saveRowExpanded( dataCtxNode, vmo );\n                delete vmo.nextLevelInsert;\n                lvlNdx++;\n                numberOfLevelsInserted++;\n            }\n\n            indx++;\n        }\n\n        // filter out vmo with treeLevel -1 as we don't show topLevel Node.\n        finalVMOs = finalVMOs.filter( function( vmo ) {\n            return vmo.$$treeLevel !== -1;\n        } );\n        return finalVMOs;\n    }\n\n    /**\n     * @param {TreeLoadResult} treeLoadResult object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection VMO array to set\n     */\n    function getViewModelCollectionInTreeHierarchyFormatForTopDown( treeLoadResult, vmCollection, dataCtxNode ) {\n        let finalVMOs = [];\n\n        if( treeLoadResult.mergeNewNodesInCurrentlyLoadedTree ) {\n            finalVMOs = vmCollection.getLoadedViewModelObjects();\n        }\n\n        for( let index = 0; index < treeLoadResult.vmNodesInTreeHierarchyLevels.length; index++ ) {\n            let currentNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ index ];\n\n            for( let node = 0; node < currentNodes.length; node++ ) {\n                let vmoIndex = -1;\n                let levelIndex = 0;\n                let currentNode = currentNodes[ node ];\n                finalVMOs.forEach( ( vmo, index ) => {\n                    if( currentNode ) {\n                        if( vmo.id === currentNode.id ) {\n                            vmoIndex = index;\n                        }\n                        if( vmo.id === currentNode.parentUid ) {\n                            levelIndex = index;\n                        }\n                    }\n                } );\n\n                if( vmoIndex !== -1 ) {\n                    _.assign( finalVMOs[ vmoIndex ], currentNode );\n                } else {\n                    arrayUtils.insert( finalVMOs, levelIndex + node, [ currentNode ] );\n                }\n\n                saveRowExpanded( dataCtxNode, currentNode );\n            }\n        }\n\n        if( !treeLoadResult.mergeNewNodesInCurrentlyLoadedTree ) {\n            return finalVMOs;\n        }\n    }\n\n    /**\n     * @param {ViewModelTreeNode} parentNode - (Optional) The 'parent' to use when determining input.\n     *\n     * @param {String} cursorNodeId - (Optional) The ID of the node to insert above/below\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Object} The resolved input object to pass to 'createTreeLoadInput'.\n     */\n    function _determineInput( parentNode, cursorNodeId, addAfter ) {\n        /**\n         * Determine 'child' index to use as basis for loading.\n         *\n         * <pre>\n         * Handle various cases of 'parent' and/or 'cursorNodeId' validity:\n         * 1) 'parent' and 'cursorNodeId' valid:             Locate the 'cursorNodeId' in the 'parent' and use its index.\n         * 2) 'parent' valid and 'cursorNodeId' not valid:   Use either end of the 'parent' children as the index.\n         * 3) 'parent' NOT valid and the 'cursor' is valid:  Locate the 'parent' of the 'cursor' and use the 'cursor' index.\n         * 4) 'parent' NOT valid and the 'cursor' NOT valid: Fail assertion.\n         * Note: Case 3) is used when dynamically loading the next page of 'children' directly after/before the\n         * 'cursor' node.\n         * </pre>\n         */\n        var startChildNdx = -1;\n\n        if( parentNode ) {\n            if( cursorNodeId ) {\n                startChildNdx = _findChildNdx( parentNode, cursorNodeId );\n                if( startChildNdx !== -1 ) {\n                    startChildNdx++;\n                }\n            } else {\n                if( addAfter ) {\n                    var nChild = parentNode.children ? parentNode.children.length : 0;\n\n                    startChildNdx = nChild;\n                } else {\n                    startChildNdx = 0;\n                }\n            }\n        } else if( cursorNodeId ) {\n            var vmCollection = dpSelf.viewModelCollection;\n\n            var cursorNdx = vmCollection.findViewModelObjectById( cursorNodeId );\n\n            if( cursorNdx !== -1 ) {\n                var cursorNode = vmCollection.getViewModelObject( cursorNdx );\n\n                var parentLevelNdx = cursorNode.levelNdx - 1;\n\n                startChildNdx = 1;\n\n                for( var ndx = cursorNdx - 1; ndx >= 0; ndx-- ) {\n                    var currRow = vmCollection.getViewModelObject( ndx );\n\n                    if( currRow.levelNdx === parentLevelNdx ) {\n                        parentNode = currRow;\n                        //Locate the 'parent' of the 'cursor' and use the Parent 'cursor' index.\n                        if( parentNode.cursorObject && parentNode.cursorObject.endIndex ) {\n                            startChildNdx = parentNode.cursorObject.endIndex + 1;\n                        }\n                        break;\n                    }\n                    startChildNdx++;\n                }\n            }\n        }\n\n        assert( parentNode, 'Unable to determine \\'parent\\' node' );\n        assert( startChildNdx !== -1, 'Unable to determine location in \\'parent\\' to insert loaded \\'child\\' nodes' );\n\n        return {\n            parentNode: parentNode,\n            startChildNdx: startChildNdx\n        };\n    }\n\n    /**\n     * Log a warning that there was an access to this UwDataProvider after it was destroyed.\n     *\n     * @param {String} functionName - Name of the function being accessed.\n     */\n    function _reportAccessToZombieDataProvider( functionName ) {\n        logger.warn( 'Attempt to execute a function on a UwDataProvider after it was destroyed...' + '\\n' + //\n            'Function was therefore not executed...continuing.' + '\\n' + //\n            'UwDataProvider: ' + dpSelf.name + '\\n' + //\n            'Function: ' + functionName );\n    }\n\n    /**\n     * Override the default implementation to return more helpful information.\n     *\n     * @return {String} Text used to identify the ID of the UsDataProvider (e.g. 'modelId' + an optional\n     *         'name').\n     */\n    dpSelf.toString = function() {\n        if( dpSelf ) {\n            if( dpSelf.name ) {\n                return dpSelf._modelId + '  name: ' + dpSelf.name;\n            }\n\n            return dpSelf._internal.modelId + '  name: ' + '???';\n        }\n\n        return 'UwDataProvider (destroyed)';\n    };\n\n    /**\n     * Get all of the loaded objects that are currently selected.\n     *\n     * @return {IModelObjectArray} Array of selected {IModelObject}.\n     */\n    dpSelf.getSelectedObjects = function() {\n        if( dpSelf.selectionModel ) {\n            var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n            if( dpSelf.vmCollectionObj && dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0  ) {\n                loadedVMO = [ ...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices ];\n            }\n            return dpSelf.selectionModel.getSortedSelection( loadedVMO );\n        }\n        return [];\n    };\n\n    /**\n     * Get the indices of the selected objects.\n     *\n     * @returns {NumberArray} Resolved with the indicies of the selected objects in the ViewModelCollection.\n     */\n    dpSelf.getSelectedIndices = function() {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n        return dpSelf.getSelectedObjects().map( function( vmo ) {\n            return loadedVMO.indexOf( vmo );\n        } );\n    };\n\n    // Define with this 'incorrect' spelling as well.\n    dpSelf.getSelectedIndexes = dpSelf.getSelectedIndices;\n\n    /**\n     * Change the selection range\n     *\n     * @param {Number} start - String index in collection to add/remove/toggle.\n     * @param {Number} end -  Ending index in collection to add/remove/toggle.\n     * @param {Boolean} select - (Optional) TRUE, 'select'...FALSE, 'unselect'...UNDEFINED, 'toggle'.\n     */\n    dpSelf.changeObjectsSelection = function( start, end, select ) {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        // Going down : Going up\n        var e = start > end ? start : end;\n        var s = start > end ? end : start;\n\n        var objects = loadedVMO.slice( s, e + 1 );\n        if( select === true ) {\n            if( dpSelf.selectionModel.multiSelectEnabled || objects.length > 1 ) {\n                dpSelf.selectionModel.addToSelection( objects );\n            } else {\n                dpSelf.selectionModel.setSelection( objects );\n            }\n        } else if( select === false ) {\n            dpSelf.selectionModel.removeFromSelection( objects );\n        } else {\n            dpSelf.selectionModel.toggleSelection( objects );\n        }\n    };\n\n    // activates multi Select mode on selection Model = multiple.\n    dpSelf.multiSelectModeEvent = eventBus.subscribe( dpSelf.name + '.multiSelectModeAction', function(\n        eventData ) {\n        if( eventData && eventData.multiSelect ) {\n            dpSelf.enableMultiSelect();\n        } else {\n            dpSelf.disableMultiSelect();\n        }\n    } );\n\n    let _selectionModelDataCtxNode = null;\n\n    // Event to expose various selection APIs on the selection model.\n    dpSelf.selectActionEvent = eventBus.subscribe( dpSelf.name + '.selectAction', function(\n        eventData ) {\n        if( dpSelf.selectionModel ) {\n            const oldSelection = dpSelf.selectionModel.getSelection();\n            if( eventData ) {\n                if( eventData.selectAll === true ) {\n                    dpSelf.selectAll();\n                }\n\n                if( eventData.selectAll === false ) {\n                    dpSelf.selectNone();\n                }\n\n                if( eventData.select ) {\n                    dpSelf.selectionModel.addToSelection( eventData.select );\n                }\n\n                if( eventData.deselect ) {\n                    dpSelf.selectionModel.removeFromSelection( eventData.deselect );\n                }\n\n                if( eventData.setSelection ) {\n                    dpSelf.selectionModel.setSelection( eventData.setSelection );\n                }\n            }\n\n            const newSelection = dpSelf.selectionModel.getSelection();\n            dpSelf.syncSelectionModel( _selectionModelDataCtxNode, newSelection, oldSelection );\n        }\n    } );\n\n    /**\n     * Enable MultiSelect\n     */\n    dpSelf.enableMultiSelect = function() {\n        if( dpSelf.selectionModel ) {\n            dpSelf.selectionModel.setMultiSelectionEnabled( true );\n        }\n    };\n\n    /**\n     * disable MultiSelect\n     */\n    dpSelf.disableMultiSelect = function() {\n        if( dpSelf.selectionModel ) {\n            dpSelf.selectionModel.setMultiSelectionEnabled( false );\n            dpSelf.selectNone();\n        }\n    };\n\n    /**\n     * Select all loaded objects\n     */\n    dpSelf.selectAll = function() {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        dpSelf.selectionModel.addToSelection( loadedVMO );\n        eventBus.publish( dpSelf.name + '.selectAll', {} );\n    };\n\n    /**\n     * Clear selection\n     */\n    dpSelf.selectNone = function() {\n        dpSelf.selectionModel.setSelection( [] );\n        eventBus.publish( dpSelf.name + '.selectNone', {} );\n    };\n\n    dpSelf.setSelectionEnabled = function( isSelectionEnabled ) {\n        dpSelf.selectionModel.setSelectionEnabled( isSelectionEnabled );\n\n        eventBus.publish( dpSelf.name + '.isSelectionEnabledChanged', {\n            isSelectionEnabled: isSelectionEnabled\n        } );\n    };\n\n    /**\n     * Sync the view with the updated selection model.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {StringArray} newSelection -\n     * @param {StringArray} oldSelection -\n     */\n    dpSelf.syncSelectionModel = function( dataCtxNode, newSelection, oldSelection ) {\n        // Ensure the selection state is correct\n        //zarq9k: Once we sync up the old viewModel and new Collection, this line would not be required.\n        // issue reported - https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/56\n        // We never worked on it.\n        var loadedVMO = dpSelf.vmCollectionObj.vmCollection.getLoadedViewModelObjects();\n        //var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        if( dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0  ) {\n            loadedVMO = [ ...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices ];\n        }\n\n        loadedVMO.map( function( vmo ) {\n            vmo.selected = dpSelf.selectionModel.isSelected( vmo );\n        } );\n\n        // Put the selected objects on the data provider\n        // Makes binding in view models simpler\n        var prevSelectedObjects = dpSelf.selectedObjects;\n\n        dpSelf.selectedObjects = loadedVMO.filter( function( vmo ) {\n            return vmo.selected;\n        } );\n\n        var emitEvents = function() {\n            //This check ensures notification is triggered only if there a selection change\n            if( !_.isEqual( prevSelectedObjects, dpSelf.selectedObjects ) ) {\n                if( dpSelf.selectionModel && dpSelf.selectionModel.selectionData ) {\n                    dpSelf.selectionModel.selectionData.update( {\n                        selected: dpSelf.getSelectedObjects(),\n                        source: dpSelf.validSourceTypes,\n                        id: dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name,\n                        _modelId: dpSelf._modelId\n                    } );\n                    trace( 'Selection Changed for ', dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name, dpSelf.selectedObjects );\n                }\n                let eventObj = {\n                    selectedObjects: dpSelf.getSelectedObjects(),\n                    selectedUids: dpSelf.selectionModel.getSelection(),\n                    scope: dataCtxNode,\n                    selectionModel: dpSelf.selectionModel,\n                    selected: dpSelf.getSelectedObjects(),\n                    dataProviderName: dpSelf.name,\n                    dataProvider: dpSelf\n                };\n                // Always notify through event bus\n                eventBus.publish( dpSelf.name + '.selectionChangeEvent', eventObj );\n            }\n        };\n\n        // Handle case where something is selected that is not in data provider\n        if( dpSelf.focusAction ) {\n            var shouldEmitSelectionEvent = true;\n\n            // Ignore the simple sync to mark objects as selected\n            if( newSelection && oldSelection ) {\n                var newlySelected = newSelection.filter( function( x ) {\n                    return oldSelection.indexOf( x ) === -1;\n                } );\n\n                // If a single new object was selected attempt to focus\n                if( newlySelected.length === 1 ) {\n                    // Try to get object from current list\n                    var newlySelectedObject = dpSelf.selectedObjects.filter( function( vmo ) {\n                        return prevSelectedObjects.indexOf( vmo ) === -1;\n                    } )[ 0 ];\n\n                    // If not found clear current list and focus\n                    if( !newlySelectedObject ) {\n                        shouldEmitSelectionEvent = false;\n\n                        // Reset cursor\n                        if( dpSelf.cursorObject ) {\n                            dpSelf.cursorObject = null;\n                        }\n\n                        dpSelf.pageDispatcher( { type: 'FOCUS_PAGE' } );\n                        dpSelf.vmCollectionDispatcher( { type: 'FOCUSING', focusing: true } );\n                    } else {\n                        eventBus.publish( dpSelf.name + '.focusSelection' );\n                    }\n                }\n            }\n\n            if( shouldEmitSelectionEvent ) {\n                emitEvents();\n            }\n        } else {\n            var uidSet = new Set();\n            _.forEach( dpSelf.selectedObjects, function( obj ) {\n                var uid;\n                if( typeof obj === 'object' ) {\n                    uid = obj.uid;\n                } else {\n                    uid = obj;\n                }\n                uidSet.add( uid );\n            } );\n\n            //If the selectionModel is shared, there is possibility that the selectionModel can have\n            //stale/invalid selection stored.\n            //Give precedence to dataprovider selection in case of shared selectionModel\n            const isSharedSelectionModel = _ctorInputData && _ctorInputData.selectionModel;\n            if( isSharedSelectionModel && uidSet.size !== dpSelf.selectionModel.getCurrentSelectedCount() ) {\n                // Default behavior is to remove any object not found from the selection model\n                dpSelf.selectionModel.setSelection( dpSelf.selectedObjects );\n            }\n            //Notify selection change in the same render cycle\n            emitEvents();\n        }\n\n        // Check selection state\n        dpSelf.selectionModel.evaluateSelectionStatusSummary( dpSelf );\n    };\n\n    /**\n     * Detach the selection model from the data provider. Should only be done when re-initializing.\n     */\n    dpSelf.detachSelectionModel = function() {\n        if( dpSelf.syncSelectionEvent ) {\n            dpSelf.syncSelectionEvent();\n            dpSelf.syncSelectionEvent = null;\n        }\n    };\n\n    /**\n     * Attach the data provider to its current selection model. Ensures re-initialization of the data provider\n     * will not result in duplicate event listeners / watches.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */\n    // dpSelf.attachSelectionModel = function( dataCtxNode ) {\n    //     // _selectionModelDataCtxNode = dataCtxNode;\n    //     // Remove previous watch if it is still setup\n    //     // dpSelf.detachSelectionModel();\n\n    //     // dpSelf.selectionModel.syncSelections = function( oldVal, newVal ) {\n    //     //     dpSelf.syncSelectionModel( dataCtxNode, newVal, oldVal );\n    //     // };\n    // };\n\n    /**\n     * Attach the selection model immediately. Will be detached / reattached if data provider is initialized.\n     * However cannot assume data provider is ever initialized.\n     */\n    //dpSelf.attachSelectionModel( {} );\n\n    /**\n     * Swap selection model with the new selection model provided as input. Detach current selection model and\n     * attach the new one\n     *\n     * @param {Object} newSelectionModel - new selection model which is required to swap\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */\n    dpSelf.swapSelectionModel = function( newSelectionModel, dataCtxNode ) {\n        // Detach the selection model while initializing\n        dpSelf.detachSelectionModel();\n\n        dpSelf.selectionModel = newSelectionModel;\n\n        dpSelf.attachSelectionModel( dataCtxNode );\n    };\n\n    // ======================== Edit Handler Interface ===================================================//\n    /**\n     *\n     * @param {*} stateName current state of edit\n     * @param {*} dpSelf data provider instance\n     */\n    var _notifyEditStateChange = function( stateName, dpSelf ) {\n        dpSelf._editingState = stateName;\n        dpSelf._editing = stateName === 'starting';\n\n        // Add to the appCtx about the editing state\n        appCtxService.updateCtx( dpSelf._appCtxEditInProgress, dpSelf._editing );\n        eventBus.publish( dpSelf._eventTopicEditInProgress, dpSelf._editing );\n    };\n\n    if( !dpSelf._appCtxEditInProgress ) {\n        dpSelf._appCtxEditInProgress = dpSelf.name + '_editInProgress';\n        dpSelf._eventTopicEditInProgress = dpSelf.name + '.editInProgress';\n    }\n\n    /**\n     * isDirty implementation of edit-handler interface.\n     * It check if any of the view model property inside view model object is modified.\n     * @returns {*} AwPromiseService.instance with promise true/false        *\n     */\n    dpSelf.isDirty = function() {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        return editUtilsService._isDirty( viewModelCollection );\n    };\n    /**\n     * Determines if prop edit is enabled for this dataprovider\n     * @param {Object} declViewModel the declarative view model\n     * @returns {*} true if individual prop editing is enabled\n     */\n    dpSelf.isPropEditEnabled = function( declViewModel ) {\n        if( dpSelf.json && dpSelf.json.enablePropEdit ) {\n            // If boolean is used return it directly otherwise evaluate the value as a condition\n            if( typeof dpSelf.json.enablePropEdit === 'boolean' ) {\n                return dpSelf.json.enablePropEdit;\n            }\n\n            const evaluationEnv = {\n                data: declViewModel,\n                ctx: appCtxService.ctx,\n                conditions: declViewModel._internal.conditionStates\n            };\n            return declUtils.evaluateCondition( declViewModel, dpSelf.json.enablePropEdit, evaluationEnv );\n        } else if( dpSelf.json && dpSelf.json.enablePropEdit === false ) {\n            return false;\n        }\n        // Default is true if enablePropEdit is not defined\n        return true;\n    };\n\n    /**\n     * This function implements the start edit function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n     * @return {*} AwPromiseService.instance with promise.\n     */\n    dpSelf.startEdit = function( dataCtxNode, declViewModel, editOptions ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        editConfig.sourceModel = dpSelf.name;\n        const saveEditStateChangeCallback = function() {\n            _notifyEditStateChange( 'saved', dpSelf );\n        };\n        return editUtilsService._startEdit( dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback, editOptions ).then( function() {\n            if( !editOptions ) {\n                _notifyEditStateChange( 'starting', dpSelf );\n            }\n        } );\n    };\n\n    /**\n     * This is the cancel edits implementation of edit-handler interface.\n     * @param  {*} dataCtxNode data ctx Node.\n     * @param  {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise\n     */\n    dpSelf.cancelEdits = function( dataCtxNode, declViewModel ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        return editUtilsService._cancelEdits( dataCtxNode, declViewModel, viewModelCollection, editConfig ).then( function() {\n            _notifyEditStateChange( 'canceling', dpSelf );\n        } );\n    };\n\n    /**\n     * This function implements the save edits function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise.\n     */\n    dpSelf.saveEdits = function( dataCtxNode, declViewModel ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        return editUtilsService._saveEdits( dataCtxNode, declViewModel, viewModelCollection, editConfig ).then( function() {\n            _notifyEditStateChange( 'saved', dpSelf );\n        } );\n    };\n\n    /**\n     * @returns {*} boolean true/false\n     */\n    dpSelf.editInProgress = function() {\n        return dpSelf._editing;\n    };\n\n    dpSelf.setFilterString = ( filterVal ) => {\n        filterStr = filterVal;\n    };\n\n    dpSelf.getFilterString = () => {\n        return filterStr;\n    };\n\n    // ======================== End of Edit Handler Interface ===================================================//\n\n    /**\n     * Initialize and trigger first page of results.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @return {Promise} A promise object resolved with the ViewModelCollection returned by the current\n     *         DataProviderService.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.initialize = function( dataCtxNode ) {\n        var promise;\n\n        if( dpSelf.cursorObject ) {\n            dpSelf.cursorObject = null;\n        }\n\n        dpSelf.setFilterString( filterStr );\n\n        /**\n         * If the constructor was told there would be some additional input data passed in from the data ctx\n         * node attempt to get it at this point.\n         * <P>\n         * Note: The input data from the scope can only override specific properties.\n         */\n        if( !_.isEmpty( _ctorInputData ) ) {\n            var declViewModel = declUtils.findViewModel( dataCtxNode );\n            dataCtxService.applyScope( declViewModel, _ctorInputData, null, dataCtxNode );\n            _.forEach( _ctorInputData, function( value, name ) {\n                if( _modifiablePropertiesViaInputData.indexOf( name ) !== -1 ) {\n                    dpSelf[ name ] = value;\n                }\n            } );\n        }\n        /** editHandler */\n        if( dpSelf.json.editContext ) {\n            let reusableEditHandler = editHandlerSvc.getEditHandler( dpSelf.json.editContext );\n            // If editHandler already exists don't create a new one - which overwrites the old one\n            if( !reusableEditHandler ) {\n                editHandlerSvc.setEditHandler( editHandlerFactory.createEditHandler( dataSourceService\n                    .createNewDataSource( {\n                        dataProvider: dpSelf\n                    } ), dpSelf.editSupportParamKeys ), dpSelf.json.editContext );\n                // set this handler active\n                editHandlerSvc.setActiveEditHandlerContext( dpSelf.json.editContext );\n\n                _editHandlerRegistered = true;\n            }\n        }\n\n        promise = Promise.resolve( dpSelf.resetDataProvider() );\n\n        // Detach the selection model while initializing\n        // dpSelf.detachSelectionModel();\n\n        /** revisitme Shaishav: This should be dead code in future because we delegated this responsibility to dataProviderUtils js\n         *  Keeping the code for now to ensure we do not miss any functionality while migrating\n\n        if( dpSelf.accessMode === 'tree' ) {\n            dpSelf.topTreeNode = _determineTopTreeNode( dpSelf.topNodeUid );\n\n            promise = dpSelf.getTreeNodeInitial( dataCtxNode, dpSelf.topTreeNode, null, true,\n                dpSelf.topTreeNode ).then( function( response ) {\n                dpSelf.attachSelectionModel( dataCtxNode );\n\n                return response;\n            } );\n        } else {\n            dpSelf.startIndex = 0;\n\n            var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, false, dataCtxNode.filterStr );\n\n            var actionRequestObj = {\n                listLoadInput: listLoadInput\n            };\n\n            var action = dpSelf.initializeAction ? dpSelf.initializeAction : dpSelf.action;\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugDataProviderInitialize( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj, _ctorInputData );\n            }\n\n            promise = dpSelf.someDataProviderSvc.getFirstPage( action, dpSelf.json, dataCtxNode,\n                actionRequestObj ).then(\n                function( response ) {\n                    eventBus.publish( dpSelf.name + '.resetScroll', {} );\n                    var vmCollection = dpSelf.viewModelCollection;\n\n                    vmCollection.clear();\n                    vmCollection.setTotalObjectsFound( response.totalFound );\n\n                    if( response.totalFound > 0 && response.results ) {\n                        dpSelf.noResults = false;\n\n                        vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                            dpSelf.preSelection );\n\n                        /**\n                         * Determine if the last node in the collection is an 'incompleteTail' because we know\n                         * there are more found than currently loaded.\n                        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                            vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                        }\n                    } else {\n                        dpSelf.noResults = true;\n                        // assigning no result found string if there is no data from rest service\n                        if( dpSelf.json.noResultsFound ) {\n                            var i18nkey = dpSelf.json.noResultsFound;\n                            i18nkey = parsingUtils.geti18nKey( i18nkey );\n                            dpSelf.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                        }\n                    }\n\n                    // dpSelf.attachSelectionModel( dataCtxNode );\n\n                    _notifyModelObjectsUpdate( null, {\n                        firstPage: true\n                    } );\n\n                    return response;\n                },\n                function( err ) {\n                    logger.warn( err );\n                } );\n        }\n        */\n\n        // Attach selection model once first page is loaded\n        promise.then( function( response ) {\n            if( dpSelf.selectionModel && dpSelf.selectionModel.getSelection().length > 0 ) {\n                /**\n                 * Fire modelObjects updated event using data provider name space\n                 */\n                eventBus.publish( dpSelf.name + '.focusSelection' );\n            }\n\n            /**\n             * Note: Not all dataCtxNodes are actually AngularJS $scopes. So we have to check if the $scope API\n             * exists before we try to use it.\n             */\n            if( dataCtxNode.$on ) {\n                dataCtxNode.$on( 'dataProvider.selectAction', function( event, data ) {\n                    if( data && data.selectAll ) {\n                        dpSelf.selectAll();\n                    } else {\n                        dpSelf.selectNone();\n                    }\n                } );\n\n                dataCtxNode.$on( 'dataProvider.multiSelectAction', function( event, data ) {\n                    if( data && data.multiSelect ) {\n                        dpSelf.enableMultiSelect();\n                    } else {\n                        dpSelf.disableMultiSelect();\n                    }\n                } );\n            }\n\n            return response;\n        } );\n\n        return promise;\n    }; // initialize\n\n    dpSelf.setDataUpdater = ( pageDispatcher, vmCollectionDispatcher ) => {\n        dpSelf.pageDispatcher = pageDispatcher;\n        dpSelf.vmCollectionDispatcher = vmCollectionDispatcher;\n    };\n\n    dpSelf.setSelectionModel = ( { selectionModel, selectionDispatcher } ) => {\n        dpSelf.selectionModel = selectionModel;\n        selectionModelDispatcher = selectionDispatcher;\n    };\n\n    dpSelf.setRootReference = ( ref ) => {\n        referenceElement = ref;\n    };\n\n    dpSelf.setPropsCallback = ( getProps ) => {\n        propsCallback = getProps;\n    };\n\n    dpSelf.getRootReference = () => {\n        return referenceElement;\n    };\n\n    dpSelf.setLovEntryRef = ( ref ) => {\n        lovEntryRef = ref;\n    };\n\n    dpSelf.getLovEntryRef = () => {\n        return lovEntryRef;\n    };\n\n    dpSelf.setPagination = ( pageOption ) => {\n        if( !paginationOption ) {\n            paginationOption = pageOption;\n        }\n    };\n\n    dpSelf.getPagination = () => {\n        return paginationOption ? paginationOption : null;\n    };\n\n    dpSelf.resetDataProvider = () => {\n        dpSelf.vmCollectionDispatcher( { type: 'COLLECTION_RESET' } );\n        dpSelf.pageDispatcher( { type: 'PAGE_RESET' } );\n        dpSelf.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        // Spare the selection model reset, if it is shared one.\n        if( _ctorInputData && !_ctorInputData.selectionModel || !_ctorInputData ) {\n            dpSelf.selectNone();\n        }\n    };\n\n    /**\n     * validate the lovValueSections if it needs to call the \"validateLOVValueSelections\" soa\n     *\n     * @param {array} lovEntry - the lovEntry which is gotten from \"getinitialValues\" SOA and it's the selected\n     *            item\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Promise} A promise object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.validateLOV = function( { lovEntries, vmo, viewModelProp }, dataCtxNode ) {\n        try {\n            let action = dpSelf.validateAction;\n            return dpSelf.someDataProviderSvc.validateLOVSelection( { lovEntries, vmo, viewModelProp }, dataCtxNode, action, dpSelf.json );\n        } catch ( e ) {\n            //In Table, when user edits LOV manually and clicks outside, widget is destroyed and hence LOV dataprovider as well\n            //Due to this, if user clicks outside, dpSelf is coming as NULL and dpSelf.validateAction throws exception\n            // Because of this behavior, user is not able to save even valid values.\n            //To fix this we have to remove LOV validation outside\n            return Promise.resolve( { valid: true } );\n        }\n    };\n\n    /**\n     * Set the currently loaded view model objects based on the model object (or uid data) in the given array of\n     * 'result' objects.\n     *\n     * @param {ViewModelObjectArray} newVMOs - Array of ViewModelObjects to set.\n     * @param {Number} totalFound - total found\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.update = function( newVMOs, totalFound ) {\n        if( newVMOs ) {\n            let updatedVMOs = newVMOs;\n            //create a new reference only if there is an existing VMOs array to trigger update else use the same.\n            if( !newVMOs.objects ) {\n                updatedVMOs = [ ...newVMOs ];\n            }\n            let totalFoundIn = totalFound;\n\n            if( _.isUndefined( totalFoundIn ) ) {\n                totalFoundIn = updatedVMOs.length;\n            }\n\n            dpSelf.noResults = totalFoundIn === 0;\n\n            let vmCollection = dpSelf.viewModelCollection;\n\n            vmCollection.clear();\n            vmCollection.setTotalObjectsFound( totalFoundIn );\n\n            if( dpSelf.accessMode === 'tree' ) {\n                vmCollection.loadedVMObjects = updatedVMOs;\n            } else {\n                vmCollection.updateModelObjects( updatedVMOs, dpSelf.uidInResponse, dpSelf.preSelection );\n                /**\n                 * Determine if the last node in the collection is an 'incompleteTail' because we know there are\n                 * more found than currently loaded.\n                 */\n                if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                    vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                    _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                }\n\n                /**\n                 * Maintain selections based on the new VMOs.\n                 */\n                const selectedObjects = dpSelf.getSelectedObjects();\n\n                dpSelf.selectionModel.setSelection( selectedObjects );\n                _notifyModelObjectsUpdate();\n            }\n            dpSelf.vmCollectionDispatcher( {\n                type: 'COLLECTION_REPLACE',\n                viewModelObjects: vmCollection.loadedVMObjects,\n                totalFound: vmCollection.loadedVMObjects.length\n            } );\n        }\n    };\n\n    dpSelf.viewModelCollection.update = dpSelf.update;\n\n    /**\n     * Required. Get item at specified index\n     *\n     * @param {Number} index - index of the list\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Object} object specified at the given index\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getItemAtIndex = function( index, dataCtxNode ) {\n        if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n            dpSelf.getNextPage( dataCtxNode );\n            return null;\n        }\n\n        return dpSelf.viewModelCollection.getViewModelObject( index );\n    };\n\n    /**\n     * Get ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @return {ViewModelCollection} Reference to the ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getViewModelCollection = function() {\n        return dpSelf.viewModelCollection;\n    };\n\n    // 20201010 Per tec meeting discussion, dataProvider should never have types, data parser has the role to process data source.\n    // /**\n    //  * return the same data structure of the list items in the link-with-popup window\n    //  * <P>\n    //  * Note: Used for aw-link-with-popup.directive<BR>\n    //  *\n    //  * @memberof module:js/dataProviderFactory~UwDataProvider\n    //  *\n    //  * @param {Number} index - index of the list\n    //  * @param {Object} dataCtxNode - The data context the queryy is occurring within.\n    //  * @param {String} dataProviderType - The types of dataProvider: \"static\" \"TcLOV\" \"Action\"\n    //  *\n    //  * @return {Object} The same data structure of the list items in the link-with-popup window.\n    //  */\n    // dpSelf.createPopupObject = function( index, dataCtxNode, dataProviderType ) {\n    //     if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n    //         dpSelf.getNextPage( dataCtxNode );\n    //         return null;\n    //     }\n\n    //     var listElement = {\n    //         listElementDisplayValue: '',\n    //         listElementObject: ''\n    //     };\n\n    //     var displayValue;\n    //     var viewModelObject = dpSelf.getItemAtIndex( index, dataCtxNode );\n\n    //     if( !viewModelObject ) {\n    //         return listElement;\n    //     }\n\n    //     if( dataProviderType ) {\n    //         if( dataProviderType === 'TcLOV' ) {\n    //             displayValue = viewModelObject.propDisplayValue;\n    //         } else if( dataProviderType === 'Action' ) {\n    //             var displayStr;\n    //             if( dataCtxNode.displayProperty ) {\n    //                 displayStr = _.get( viewModelObject, dataCtxNode.displayProperty );\n    //             } else {\n    //                 displayStr = _.get( viewModelObject.props, 'object_string' );\n    //             }\n    //             displayValue = displayStr.uiValue;\n    //         } else if( dataProviderType === 'Static' ) {\n    //             if( viewModelObject.staticDisplayValue && viewModelObject.staticElementObject ) {\n    //                 displayValue = viewModelObject.staticDisplayValue;\n    //                 viewModelObject = viewModelObject.staticElementObject;\n    //             } else {\n    //                 displayValue = viewModelObject;\n    //             }\n    //         } else {\n    //             displayValue = viewModelObject;\n    //         }\n    //     } else {\n    //         displayValue = viewModelObject;\n    //     }\n\n    //     listElement.listElementDisplayValue = displayValue;\n    //     listElement.listElementObject = viewModelObject;\n\n    //     if( dpSelf.viewModelCollection.getTotalObjectsFound() ) {\n    //         var totalFound = 0;\n    //     }\n\n    //     if( !viewModelObject && !totalFound ) {\n    //         // no result found\n    //         listElement.listElementDisplayValue = dataCtxNode.prop.uiValue;\n    //         listElement.listElementObject = dataCtxNode.prop.dbValue;\n    //     }\n\n    //     if( dataCtxNode.isLoading ) {\n    //         // no result found\n    //         listElement.listElementDisplayValue = dpSelf.isLoading;\n    //         listElement.listElementObject = dpSelf.isLoading;\n    //     }\n\n    //     return listElement;\n    // }; // createPopupObject\n\n    /**\n     * Required. For infinite scroll behavior, we always return a slightly higher number than the previously\n     * loaded items.\n     *\n     * @return {Number} number of objects loaded.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getLength = function() {\n        return dpSelf.viewModelCollection.getVirtualLength();\n    };\n\n    /**\n     * Check if there is more data to load\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.hasMorePages = function() {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'hasMorePages' );\n            return false;\n        }\n\n        /**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */\n        if( dpSelf.accessMode === 'tree' ) {\n            if( dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject ) {\n                return !dpSelf.topTreeNode.cursorObject.endReached;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */\n        if( dpSelf.cursorObject ) {\n            return !dpSelf.cursorObject.endReached;\n        }\n\n        return dpSelf.viewModelCollection.getTotalObjectsFound() > dpSelf.viewModelCollection\n            .getTotalUniqueObjectsLoaded();\n    };\n\n    /**\n     * Check if there is more data to load before current position.\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.hasMorePagesUp = function() {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'hasMorePagesUp' );\n            return false;\n        }\n\n        /**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */\n        if( dpSelf.accessMode === 'tree' ) {\n            if( dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject ) {\n                return !dpSelf.topTreeNode.cursorObject.startReached;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */\n        if( dpSelf.cursorObject ) {\n            return !dpSelf.cursorObject.startReached;\n        }\n\n        return false;\n    };\n\n    /**\n     * Finds and returns a vmo with an incomplete head/tail in the given range.\n     * @param { Number } startIdx - index of the first node in the range\n     * @param { Number } endIdx - index of the last node in the range\n     *\n     * @return {Object} The node with an incomplete head/tail\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.findIncompleteNodeInRange = function( startIdx, endIdx ) {\n        for( var i = startIdx; i <= endIdx; i++ ) {\n            var vmNode = dpSelf.viewModelCollection.loadedVMObjects[ i ];\n            if( vmNode && ( vmNode.incompleteHead === true || vmNode.incompleteTail ) ) {\n                return vmNode;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Get previous page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the previous page is loaded and the viewModelCollection is\n     *         updated. Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getPreviousPage = function( dataCtxNode ) {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'getPreviousPage' );\n            return $q.reject( 'Access to destroyed UwDataProvider.' );\n        }\n\n        assert( dpSelf.previousAction, 'Invalid action specified' );\n\n        if( dpSelf.accessMode === 'tree' ) {\n            var cursorNode = _.first( dpSelf.topTreeNode.children );\n\n            if( cursorNode ) {\n                return dpSelf.getTreeNodePage( dataCtxNode, dpSelf.topTreeNode, cursorNode.id, false,\n                    dpSelf.topTreeNode );\n            }\n\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        var listLoadInput = awTableSvc.createListLoadInput( null, 0, null, false, true );\n\n        var actionRequestObj = {\n            listLoadInput: listLoadInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        return dpSelf.someDataProviderSvc.executeLoadAction( dpSelf.previousAction, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then(\n            function( response ) {\n                dpSelf.viewModelCollection.setTotalObjectsFound( response.totalFound );\n\n                if( response.totalFound > 0 ) {\n                    dpSelf.viewModelCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                        dpSelf.preSelection, true );\n                }\n\n                _notifyModelObjectsUpdate( dataCtxNode, {\n                    prevPage: true\n                } );\n\n                return $q.resolve( dpSelf.viewModelCollection );\n            } );\n    };\n\n    /**\n     * Get next page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the next page is loaded and the viewModelCollection is updated.\n     *         Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getNextPage = function( dataCtxNode ) {\n        // revisit me - temp fix to make dataProvider instance consistent\n        const dpSelf = this;\n\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'getNextPage' );\n            return $q.reject( 'Access to destroyed UwDataProvider.' );\n        }\n\n        if( dpSelf.accessMode === 'tree' ) {\n            var cursorNode = _.last( dpSelf.topTreeNode.children );\n\n            if( cursorNode ) {\n                return dpSelf.getTreeNodePage( dataCtxNode, dpSelf.topTreeNode, cursorNode.id, true,\n                    dpSelf.topTreeNode );\n            }\n\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        var totalFound = dpSelf.viewModelCollection.getTotalObjectsFound();\n        var totalUniqueLoaded = dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n\n        if( totalFound > totalUniqueLoaded || dpSelf.cursorObject && !dpSelf.cursorObject.endReached ) {\n            dpSelf.startIndex = totalUniqueLoaded;\n\n            var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, true, dataCtxNode.filterStr );\n\n            var actionRequestObj = {\n                listLoadInput: listLoadInput\n            };\n\n            var action = dpSelf.nextAction ? dpSelf.nextAction : dpSelf.action;\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugDataProviderNextPage( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj );\n            }\n\n            return dpSelf.someDataProviderSvc.getNextPage( action, dpSelf.json, dataCtxNode, actionRequestObj )\n                .then(\n                    function( response ) {\n                        var vmCollection = dpSelf.viewModelCollection;\n\n                        vmCollection.setTotalObjectsFound( response.totalFound );\n\n                        if( response.totalFound > 0 ) {\n                            vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                                dpSelf.preSelection );\n                        }\n\n                        _notifyModelObjectsUpdate( dataCtxNode, {\n                            nextPage: true\n                        } );\n\n                        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                            vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                        }\n\n                        if( dpSelf.accessMode === 'lov' ) {\n                            // lov api expects incremental response, not the entire collection\n                            return response;\n                        }\n\n                        return vmCollection;\n                    } );\n        }\n\n        return $q.resolve( dpSelf.viewModelCollection );\n    };\n\n    /**\n     * Validate selection\n     *\n     * @param {Object} lovScope - lov context\n     * @param {Array} selected - selected object/s to validate\n     * @param {Boolean} suggestion - does selected contain a suggested value?\n     *\n     * @return {Promise} Promise that is resolved upon completion of validateion.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.validateSelections = function( lovScope, selected, suggestion ) {\n        var action = dpSelf.validateAction;\n\n        if( action ) {\n            var actionRequestObj = { selected: selected, suggestion: suggestion };\n            return dpSelf.someDataProviderSvc.validateSelections( action, dpSelf.json, lovScope, actionRequestObj ).then( function( resp ) {\n                if( !resp.valid ) {\n                    resp.cause = { partialErrors: true };\n                    throw resp;\n                }\n                eventBus.publish( dpSelf.name + '.validSelectionEvent', {\n                    selectedObjects: selected\n                } );\n                return resp;\n            } );\n        }\n\n        // if validate action is not defined, assume all valid\n        eventBus.publish( dpSelf.name + '.validSelectionEvent', {\n            selectedObjects: selected\n        } );\n        return AwPromiseService.instance.resolve( { valid: true } );\n    };\n\n    /**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any new nodes.\n     *\n     * @return {Promise} A promise resolved when the expansion is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.expandObject = function( dataCtxNode, parentNode ) {\n        var begNdx = -1;\n\n        if( dpSelf.cacheCollapse ) {\n            var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n            // BMW: can use _, I am lazy now for prototype\n            for( var ndx = 0; ndx < vmNodes.length; ndx++ ) {\n                if( vmNodes[ ndx ].id === parentNode.id ) {\n                    begNdx = ndx + 1;\n                    break;\n                }\n            }\n        }\n\n        // BMW: Load __expendState if dpSelf.cacheCollapse == true\n        if( begNdx >= 0 && parentNode.__expandState && dpSelf.cacheCollapse ) {\n            // Apply __expandState.expandedNodes to vmoCollection\n            var vmos = dpSelf.viewModelCollection.loadedVMObjects;\n            vmos.splice.apply( vmos, [ begNdx, 0 ].concat( parentNode.__expandState.expandedNodes ) );\n            dpSelf.viewModelCollection.setTotalObjectsFound( vmos.length );\n\n            // Load parentNode context back\n            parentNode.children = parentNode.__expandState.children;\n            parentNode.startChildNdx = parentNode.__expandState.startChildNdx;\n            parentNode.totalChildCount = parentNode.__expandState.totalChildCount;\n            parentNode.cursorObject = parentNode.__expandState.cursorObject;\n\n            // Clean up and return\n            delete parentNode.__expandState;\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        // BMW: Clean up __expendState if dpSelf.cacheCollapse == false\n        if( !dpSelf.cacheCollapse && parentNode.__expandState ) {\n            delete parentNode.__expandState;\n        }\n\n        return dpSelf.getTreeNodePage( dataCtxNode, parentNode, null, true, dpSelf.topTreeNode );\n    };\n\n    let _initialCacheCollapseState = false;\n\n    /**\n     *\n     * Function to restore collapse cache to the initial value\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.restoreInitialCacheCollapseState = function() {\n        if( !_initialCacheCollapseState ) {\n            dpSelf.cacheCollapse = false;\n            dpSelf.resetCollapseCache();\n        } else {\n            dpSelf.cacheCollapse = true;\n        }\n    };\n\n    /**\n     *\n     * Function to reset collapse cache when needed\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.resetCollapseCache = function() {\n        if( !dpSelf.viewModelCollection || !dpSelf.viewModelCollection.loadedVMObjects ) {\n            return;\n        }\n        _.forEach( dpSelf.viewModelCollection.loadedVMObjects, function( vmo ) {\n            if( vmo.__expandState ) {\n                delete vmo.__expandState;\n            }\n        } );\n    };\n\n    /**\n     * Set valid source types for data provider, this is used for drag and drop usage\n     *\n     * @param {Object} validSourceTypes - valid source types for dataprovider which are set from xrt objectset\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.setValidSourceTypes = function( validSourceTypes ) {\n        dpSelf.validSourceTypes = validSourceTypes;\n    };\n\n    /**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any 'child' nodes being removed as\n     *            part of the collapse.\n     * @return {Promise} A promise resolved when the collapse is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.collapseObject = function( dataCtxNode, parentNode ) {\n        /**\n         * Remove all 'child' nodes of this 'parent' from the 'loadedVMObjects' of the ViewModelCollection and\n         * reset it's internal 'children' array.\n         */\n        var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n\n        var begNdx = -1;\n        var nDelete = 0;\n\n        // BMW Issue #5: add document to this algorithm.\n        // - Loop through the whole vmoCollection\n        // - When find the parent node, set state to start ( begNdx )\n        // - Keep going, when hits node which node.level <= parent.level, stop ( next sibling )\n        // - record all as nDelete.\n        //\n        // So we don't have to clen parentNode.children here...anyway it will be done later\n        for( var ndx = 0; ndx < vmNodes.length; ndx++ ) {\n            if( uwUtilSvc.getEvaluatedId( vmNodes[ ndx ] ) === uwUtilSvc.getEvaluatedId( parentNode ) ) {\n                begNdx = ndx + 1;\n                nDelete = 0;\n            } else if( begNdx >= 0 ) {\n                if( vmNodes[ ndx ].levelNdx > parentNode.levelNdx ) {\n                    nDelete++;\n                } else {\n                    // BMW Issue #5:\n                    // parentNode.children = null;\n                    break;\n                }\n            }\n        }\n\n        if( nDelete > 0 ) {\n            var collapsedNodes = vmNodes.splice( begNdx, nDelete );\n\n            // BMW Issue #7: When any of the node is in loading status, don't cache\n            var collapesdNodesIsLoading = _.reduce( collapsedNodes, function( sum, node ) {\n                return sum ? sum : node.loadingStatus;\n            }, false );\n\n            // BMW: Cache collapse object here\n            if( dpSelf.cacheCollapse && !collapesdNodesIsLoading ) {\n                parentNode.__expandState = {\n                    children: parentNode.children,\n                    startChildNdx: parentNode.startChildNdx,\n                    totalChildCount: parentNode.totalChildCount,\n                    // BMW #5: actually cursorObject cache here is not needed since\n                    // it is anyway leaking in current system when collapse. But for\n                    // safe we can cache and load it too.\n                    cursorObject: parentNode.cursorObject,\n                    expandedNodes: collapsedNodes\n                };\n            }\n\n            parentNode.children = null;\n            parentNode.startChildNdx = 0;\n            parentNode.totalChildCount = null;\n        }\n\n        // Re-evaluate selection state, since we have removed children selection state have changed.\n        dpSelf.selectionModel.evaluateSelectionStatusSummary( dpSelf );\n\n        return $q.resolve( dpSelf.viewModelCollection );\n    }; // collapseObject\n\n    /**\n     * Access a page of 'child' nodes of the given 'parent' node and place the results into the\n     * ViewModelColection of this UwDataProvider.\n     * <P>\n     * Note: Paging information stored in the 'parent' node is used to determine which 'child' nodes to get.\n     * This paging information is then updated to be ready for any subsequent call to this API.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @param {Boolean} focusLoadAction - (Optional) TRUE if action is triggered to load selected object in tree\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNodePage = function( dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode,\n        focusLoadAction ) {\n        var action = addAfter ? dpSelf.nextAction || dpSelf.action : dpSelf.previousAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput,\n            loadIDs: {\n                t_uid: dpSelf.topTreeNode.uid,\n                o_uid: treeLoadInput.parentNode.uid\n            }\n        };\n\n        // focusLoadAction will be true when object present in selection model needs to be loaded in tree.\n        // (cross select between PWA and other sources e.g. Search Panel)\n        if( focusLoadAction ) {\n            action = dpSelf.focusAction ? dpSelf.focusAction : null;\n            treeLoadInput.focusLoadAction = focusLoadAction;\n        }\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        var origCursorObj = _.clone( treeLoadInput.parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * Access the initial page of data.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNodeInitial = function( dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode ) {\n        var action = dpSelf.initializeAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput\n        };\n\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n\n        var origCursorObj = _.clone( treeLoadInput.parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * Access a page of 'child' nodes of the given 'parent' node (starting at a specific 'child' node) and place\n     * the results into the ViewModelColection of this UwDataProvider.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     * @param {String} startChildId - ID of a node in the 'parent' to start loading at.\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     * @param {Number} pageSize - Maximum number of 'child' nodes to return (including the 'startChild').\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Promise} A promise object resolved with a reference to the updated ViewModelColection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNode = function( dataCtxNode, parentNode, startChildId, cursorNodeId, pageSize, addAfter ) {\n        var action = addAfter ? dpSelf.nextAction : dpSelf.previousAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            startChildId, cursorNodeId, pageSize, addAfter );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput\n        };\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        var origCursorObj = _.clone( parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {PropertyLoadInput} propertyLoadInput - The object containing the PropertyLoadRequest(s) to\n     *            process.\n     *\n     * @return {Promise} The Promise is resolved with a PropertyLoadResult object when the operation is\n     *         complete.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getProperties = function( dataCtxNode, propertyLoadInput ) {\n        assert( dpSelf.action, 'Invalid action specified' );\n\n        var actionRequestObj = {\n            propertyLoadInput: propertyLoadInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        return dpSelf.someDataProviderSvc.executeLoadAction( dpSelf.action, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then( function( response ) {\n            return response.propertyLoadResult;\n        } );\n    };\n\n    dpSelf.getFilterFacets = function( viewModel, filterFacetInput ) {\n        var action = dpSelf.filterFacetAction;\n\n        var dataCtxNode = {\n            data: viewModel,\n            filterFacetInput: filterFacetInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        if( action ) {\n            return dpSelf.someDataProviderSvc.executeLoadAction( action, dpSelf.json, dataCtxNode ).then( function( response ) {\n                return response.filterFacetResults;\n            } );\n        }\n        return $q.resolve();\n    };\n\n    /**\n     * Free up all resources held by this object.\n     * <P>\n     * Note: After this function, no API call should be considered valid. This function is intended to be called\n     * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event),\n     * any objects managed by this class may be considered a 'memory leak'.\n     */\n    dpSelf.destroy = function() {\n        dpSelf._isDestroyed = true;\n\n        declModelRegistrySvc.unregisterModel( 'UwDataProvider', dpSelf, 'name', '_modelId' );\n\n        if( dpSelf._appCtxEditInProgress ) {\n            appCtxService.unRegisterCtx( dpSelf._appCtxEditInProgress );\n        }\n\n        if( dpSelf.selectionModel ) {\n            dpSelf.detachSelectionModel();\n            dpSelf.selectionModel = null;\n        }\n\n        if( dpSelf.viewModelCollection ) {\n            dpSelf.viewModelCollection.destroy();\n            dpSelf.viewModelCollection = null;\n        }\n\n        if( dpSelf.someDataProviderSvc && dpSelf.someDataProviderSvc.destroy ) {\n            dpSelf.someDataProviderSvc.destroy();\n            dpSelf.someDataProviderSvc = null;\n        }\n\n        if( dpSelf.json.editContext && _editHandlerRegistered ) {\n            editHandlerSvc.removeEditHandler( dpSelf.json.editContext );\n        }\n\n        const editConfig = dpSelf.json.editConfig;\n        if( editConfig ) {\n            editUtilsService._removeListeners( editConfig.sourceModel );\n        }\n\n        dpSelf.cols = null;\n        dpSelf.topTreeNode = null;\n        dpSelf.actionObj = null;\n        dpSelf.json = null;\n\n        dpSelf.ttState = null;\n        dpSelf.policy = null;\n        dpSelf.validSourceTypes = null;\n\n        eventBus.unsubscribe( dpSelf.toggleDecoratorsEvent );\n        eventBus.unsubscribe( dpSelf.multiSelectModeEvent );\n        eventBus.unsubscribe( dpSelf.selectActionEvent );\n        dpSelf.toggleDecoratorsEvent = null;\n        dpSelf.multiSelectModeEvent = null;\n        dpSelf.selectActionEvent = null;\n\n        dpSelf.setRootReference( null );\n\n        // detach dispatcher\n        dpSelf.vmCollectionDispatcher = null;\n        dpSelf.pageDispatcher = null;\n        dpSelf.selectionModel = null;\n        referenceElement = null;\n        selectionModelDispatcher = null;\n        dpSelf = null;\n    }; // destroy\n\n    /**\n     * ---------------------------------------------------------------------------<BR>\n     * Property & Function definition complete....Finish initialization. <BR>\n     * ---------------------------------------------------------------------------<BR>\n     */\n\n    declModelRegistrySvc.registerModel( 'UwDataProvider', dpSelf, 'name', '_modelId' );\n\n    /**\n     * Load localized text for when we encounter cases of no results and loading .\n     *\n     * @param localTextBundle\n     */\n    localeSvc.getTextPromise().then( function( localTextBundle ) {\n        if( dpSelf ) {\n            if( declUtils.isNil( dpSelf.isLoading ) ) {\n                dpSelf.isLoading = localTextBundle.LOADING_TEXT;\n            }\n        }\n    } );\n\n    if( actionObj ) {\n        dpSelf.action = actionObj;\n    }\n\n    _.forEach( actionMap, function( actionDef, actionName ) {\n        dpSelf[ actionName ] = actionDef;\n    } );\n\n    if( dataProviderJson ) {\n        dpSelf.json = dataProviderJson;\n        dpSelf.policy = dataProviderJson.policy;\n\n        /** tree page size */\n        if( dataProviderJson.treePageSize ) {\n            dpSelf.treePageSize = dataProviderJson.treePageSize;\n        }\n\n        /** Row or Cell selection scope ? */\n        if( dataProviderJson.selectionModelScope ) {\n            dpSelf.selectionModel.scope = dataProviderJson.selectionModelScope;\n        }\n\n        /**\n         * Only set the default text values if they are not already set in the dataProvider JSON definition.\n         */\n        if( dataProviderJson.noResultsFound ) {\n            dpSelf.noResultsFound = dataProviderJson.noResultsFound;\n        }\n\n        if( dataProviderJson.isLoading ) {\n            dpSelf.isLoading = dataProviderJson.isLoading;\n        }\n\n        if( dataProviderJson.cacheCollapse ) {\n            _initialCacheCollapseState = dataProviderJson.cacheCollapse;\n            dpSelf.cacheCollapse = _initialCacheCollapseState;\n        }\n    }\n\n    /**\n     * Get the editable object from the data provider\n     *\n     * In case of list, it sends the selected object.<BR>\n     * In case of Table, it send the all the loaded objects.\n     *\n     * @return {object} viewModelObject - View model object(s).\n     */\n    dpSelf.getEditableObjects = function() {\n        if( dataProviderJson && dataProviderJson.editContext ) {\n            if( dataProviderJson.editContext === 'LIST_CELL_CONTEXT' ) {\n                if( dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single' ) {\n                    return dpSelf.getSelectedObjects();\n                }\n            } else {\n                var vmc = dpSelf.viewModelCollection;\n                return vmc.getLoadedViewModelObjects();\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Get a list of property names form the dataprovider\n     *\n     * @return {Array} propNames - list of property Names\n     */\n    dpSelf.getPropertyNames = function() {\n        var propNames = [];\n\n        if( dataProviderJson.editContext === 'LIST_CELL_CONTEXT' ) {\n            if( dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single' ) {\n                var selectedObject = dpSelf.getSelectedObjects();\n                if( selectedObject !== null ) {\n                    _.forEach( selectedObject, function( viewModelObject ) {\n                        _.forEach( viewModelObject.props, function( props ) {\n                            if( props && props.type ) {\n                                propNames.push( props.propertyName );\n                            }\n                        } );\n                    } );\n                }\n            }\n        } else {\n            if( dpSelf.cols ) {\n                _.forEach( dpSelf.cols, function( col ) {\n                    if( col && col.typeName && !col.isTreeNavigation ) {\n                        propNames.push( col.propertyName );\n                    }\n                } );\n            }\n        }\n\n        return propNames;\n    };\n\n    /**\n     * Gets the edit configuration object\n     * @return {Object} The edit configuration object\n     */\n    dpSelf.getEditConfiguration = function() {\n        return dpSelf.json.editConfig;\n    };\n\n    /**\n     * Get the command override anchors set in viewModel.\n     *\n     * @return {Object} All possible override anchor strings\n     */\n    dpSelf.getCommandOverrides = function() {\n        return {\n            gridMenuCommandsAnchor: dpSelf.json.gridMenuCommandsAnchor,\n            contextMenuCommandsAnchor: dpSelf.json.contextMenuCommandsAnchor,\n            columnMenuCommandsAnchor: dpSelf.json.columnMenuCommandsAnchor\n        };\n    };\n}; // UwDataProvider\n\n/**\n * ---------------------------------------------------------------------------<BR>\n * Define the public API for the 'dataProviderFactory' Service<BR>\n * ---------------------------------------------------------------------------<BR>\n */\n\nvar exports = {};\n\n/**\n * Create a new DeclDataProvider object to manage and access List, LOV, flat-table and tree-table structured\n * ViewModelObjects.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {StringMap} actionsMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n *\n * @return {UwDataProvider} The newly created DeclDataProvider object.\n *\n * @memberof module:js/dataProviderFactory\n */\nexport let createDataProvider = function( dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n    actionsMap ) {\n    var viewModelCollection = viewModelCollectionFactory.createViewModelCollection( dataProviderName );\n\n    return new UwDataProvider( AwPromiseService.instance, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n        viewModelCollection, actionsMap );\n};\n\n/**\n * Using the given UID, determine which IModelObject should be set as the 'top' node (if any). That object\n * will be set as a new 'top' ViewModelTreeNode on the given dataProvider.\n * <P>\n * Note: The 'top' node is generally hidden from the user and is used only to access 'child' nodes and other\n * properties.\n *\n * @param {String} topNodeUid - (Optional) The ID of the 'top' (if known)\n *\n * @return {ViewModelTreeNode} The new 'top' node.\n */\nfunction _determineTopTreeNode( topNodeUid ) {\n    /**\n     * Create a 'straw' top node to use just in case.\n     */\n    var topTreeNode = {\n        nodeId: 'top',\n        nodeType: 'rootType',\n        displayName: 'top',\n        levelNdx: -1,\n        childNdx: 0\n    };\n\n    if( !_.isEmpty( topNodeUid ) ) {\n        topTreeNode.nodeId = topNodeUid;\n        topTreeNode.nodeType = 'unknown';\n    }\n\n    return awTableSvc.createViewModelTreeNode( topTreeNode.nodeId, topTreeNode.nodeType,\n        topTreeNode.displayName, topTreeNode.levelNdx, topTreeNode.childNdx, null );\n} // _determineTopTreeNode\n\nlet initPreferredChoices = [];\n\nexport const loadAction = async( dataProvider, dataCtxNode, vmCollection, startIndex, pageObject ) => {\n    // revisitme Subhajit: To keep the backward compatibility.. we need to work on declDataCtxService\n    dataProvider.startIndex = startIndex;\n    let pageActionType = pageObject.pageActionType;\n    // tree - for pagination needs improvement\n    if( dataProvider.accessMode === 'tree' ) {\n        let results;\n        switch ( pageActionType ) {\n            case 'NEXT_PAGE':\n                results = await dataProvider.getNextPage( dataCtxNode );\n                break;\n            case 'PREVIOUS_PAGE':\n                results = await dataProvider.getPreviousPage( dataCtxNode );\n                break;\n            case 'PAGE_RESET':\n                dataProvider.topTreeNode = _determineTopTreeNode( dataProvider.topNodeUid );\n                results = await dataProvider.getTreeNodeInitial( dataCtxNode, dataProvider.topTreeNode, null, true,\n                    dataProvider.topTreeNode );\n                //PAGE_RESET - This means the dataprovider is re-initialized\n                //Clear the previous data in vmCollection before updating the new data\n                dataProvider.viewModelCollection.clear();\n                break;\n            case 'FOCUS_PAGE':\n                var focusLoadAction = true;\n                dataProvider.topTreeNode = _determineTopTreeNode( dataProvider.topNodeUid );\n                results = await dataProvider.getTreeNodePage( dataCtxNode, dataProvider.topTreeNode, null, true,\n                    dataProvider.topTreeNode, focusLoadAction );\n                break;\n        }\n\n        //Verify if the component is still mounted\n        if( !dataProvider.vmCollectionDispatcher ) {\n            return;\n        }\n\n        // totalFound and hasMoreValuesExist are mutually exclusive keys.\n        dataProvider.vmCollectionDispatcher( {\n            type: 'COLLECTION_UPDATE',\n            viewModelObjects: results.loadedVMObjects,\n            totalFound: results.totalFound,\n            cursorObject: dataProvider.topTreeNode.cursorObject,\n            pageObject: pageObject\n        } );\n        dataProvider.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        dataProvider.vmCollectionDispatcher( { type: 'FOCUSING', focusing: false } );\n        if( pageActionType === 'FOCUS_PAGE' ) {\n            dataProvider.syncSelectionModel( dataCtxNode );\n        }\n    } else {\n        let action;\n        switch ( pageActionType ) {\n            case 'PAGE_RESET':\n                dataProvider.startIndex = 0;\n                action = dataProvider.initializeAction ? dataProvider.initializeAction : dataProvider.action;\n                break;\n            case 'NEXT_PAGE':\n                action = dataProvider.nextAction ? dataProvider.nextAction : dataProvider.action;\n                break;\n            case 'PREVIOUS_PAGE':\n                action = dataProvider.previousAction ? dataProvider.previousAction : dataProvider.action;\n                break;\n            case 'FOCUS_PAGE':\n                dataProvider.startIndex = 0;\n                dataProvider.vmCollectionDispatcher( {\n                    type: 'COLLECTION_RESET'\n                } );\n                action = dataProvider.focusAction ? dataProvider.focusAction : null;\n                break;\n        }\n\n        let listLoadInput = awTableSvc.createListLoadInput( null, dataProvider.startIndex, null, true );\n        let actionRequestObj = { listLoadInput };\n\n        const response = await dataProvider.someDataProviderSvc.executeLoadAction( action, dataProvider.json,\n            dataCtxNode, actionRequestObj );\n        //Verify if the component is still mounted\n        if( !dataProvider.vmCollectionDispatcher ) {\n            return;\n        }\n\n        let viewModelObjects = vmCollection.createModelObjects( response.results || [] );\n        if( pageActionType === 'NEXT_PAGE' ) {\n            viewModelObjects = vmCollection.getLoadedViewModelObjects().concat( viewModelObjects );\n        } else if( pageActionType === 'PREVIOUS_PAGE' ) {\n            viewModelObjects = viewModelObjects.concat( vmCollection.getLoadedViewModelObjects() );\n        } else if( pageActionType === 'PAGE_RESET' ) {\n            // PAGE_RESET - This means the dataprovider is re-initialized\n            // retrieve preferred vals if defined\n            if ( dataProvider.preferredChoicesAction ) {\n                const preferredChoiceResp = await dataProvider.someDataProviderSvc.executeLoadAction( dataProvider.preferredChoicesAction, dataProvider.json, dataCtxNode );\n                initPreferredChoices = preferredChoiceResp.actionResultObj.responseObj.preferredChoices;\n            }\n\n            // Clear the previous data in vmCollection before updating the new data\n            if( response.hasOwnProperty( 'lovUsage' ) ) {\n                dataProvider.lovUsage = response.lovUsage;\n            }\n            if( response ) { dataProvider.viewModelCollection.clear(); }\n            if( response.totalFound > 0 && response.results ) {\n                dataProvider.noResults = false;\n            } else {\n                dataProvider.noResults = true;\n                // assigning no result found string if there is no data from rest service\n                if( dataProvider.json.noResultsFound ) {\n                    var i18nkey = dataProvider.json.noResultsFound;\n                    i18nkey = parsingUtils.geti18nKey( i18nkey );\n                    dataProvider.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                }\n            }\n        }\n        // totalFound and hasMoreValuesExist are mutually exclusive keys.\n        let totalFound = response.hasOwnProperty( 'moreValuesExist' ) ? -1 : response.totalFound;\n        let hasMoreValuesExist = response.hasOwnProperty( 'moreValuesExist' ) ? response.moreValuesExist : null;\n\n        // set preferred vals if defined\n        if ( dataProvider.preferredChoicesAction ) {\n            response.preferredChoices = initPreferredChoices;\n        }\n\n        dataProvider.vmCollectionDispatcher( {\n            type: 'COLLECTION_UPDATE',\n            viewModelObjects: viewModelObjects,\n            totalFound,\n            hasMoreValuesExist,\n            cursorObject: dataProvider.cursorObject,\n            pageObject: pageObject,\n            preferredChoices: response.preferredChoices\n        } );\n        dataProvider.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        dataProvider.notifyModelObjectsUpdate();\n        /**\n         * Determine if the last node in the collection is an 'incompleteTail' because we know\n         * there are more found than currently loaded.\n         */\n        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n            vmCollection.totalFound > dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n        }\n\n        /**\n         * Determine if the first node in the collection is an 'incompleteHead'\n         */\n        if( !_.isEmpty( vmCollection.loadedVMObjects ) && dataProvider.cursorObject &&\n            dataProvider.cursorObject.startReached === false ) {\n            _.head( vmCollection.loadedVMObjects ).incompleteHead = true;\n        }\n    }\n    if( pageActionType === 'FOCUS_PAGE' ) {\n        //  revisitme Shaishav: In old focus action following variables were getting set.\n        //  We might need them when TC tables are supported.\n        //  Keeping is commented to not lose track of them\n        // if( response.totalFound > 0 && response.results ) {\n        //     dpSelf.noResults = false;\n\n        //     vmCollection.updateModelObjects( response.results,\n        //         dpSelf.uidInResponse, dpSelf.preSelection );\n        // } else {\n        //     dpSelf.noResults = true;\n        // }\n\n        eventBus.publish( dataProvider.name + '.focusSelection' );\n    }\n};\n\n/**\n *\n * @param {*} param0\n * @param {*} dataProvider\n * @param {*} dataCtxNode\n */\nexport const validateLovAction = ( { lovEntries, vmo, viewModelProp }, dataProvider, dataCtxNode ) => {\n    return dataProvider.validateLOV( { lovEntries, vmo, viewModelProp }, dataCtxNode );\n};\n\n/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {UwDataProvider} The DeclDataProvider from the given arguments (or undefined if not found)\n */\nexport let findDataProvider = function( argsIn ) {\n    for( var ndx = 0; ndx < argsIn.length; ndx++ ) {\n        var arg = argsIn[ ndx ];\n\n        if( exports.isDataProvider( arg ) ) {\n            return arg;\n        }\n    }\n    return undefined;\n};\n\n/**\n * Test if the given object 'is-a' UwDataProvider created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a DeclDataProvider.\n */\nexport let isDataProvider = function( objectToTest ) {\n    return objectToTest instanceof UwDataProvider;\n};\n\n/**\n * Select all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\nexport let selectAll = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.selectAll();\n    }\n};\n\n/**\n * Deselect all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\nexport let selectNone = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.selectNone();\n    }\n};\n\n/**\n * Enable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\nexport let dataProviderEnableMultiSelect = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.enableMultiSelect();\n    }\n};\n\n/**\n * Disable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\nexport let dataProviderDisableMultiSelect = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.disableMultiSelect();\n    }\n};\n\nfunction loadDebugOption() {\n    var urlAttrs = browserUtils.getUrlAttributes();\n\n    _debug_logTreeLoadActivity = urlAttrs.logTreeLoadActivity !== undefined;\n}\n\n/**\n * createDynamicDataProvider based on jsonData specified by src\\propertyrender\\lovDataProvider.json\n * @param {int} index - the index to return\n * @return {Object} dataProvider the dataProvider\n */\nexport let createDynamicDataProvider = ( index = 0 ) => {\n    let dataProviders = [];\n    let _processAction = ( jsonData, jsonDataProvider, dpName, actionName, actionMap ) => {\n        var actionRef = jsonDataProvider[ actionName ];\n        if( actionRef && jsonData.actions ) {\n            actionMap[ actionName ] = jsonData.actions[ actionRef ];\n        }\n    };\n    if( jsonData.dataProviders ) {\n        var dataProvidersClone = _.cloneDeep( jsonData.dataProviders );\n        _.forEach( dataProvidersClone, function( jsonDataProvider, dpName ) {\n            var actionMap = {};\n            _processAction( jsonData, jsonDataProvider, dpName, 'action', actionMap ); // legacy init/getNext action\n            _processAction( jsonData, jsonDataProvider, dpName, 'initializeAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'nextAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'previousAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'focusAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'expandAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'validateAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'filterFacetAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'preferredChoicesAction', actionMap );\n\n            let dataProviderInstance = createDataProvider( jsonDataProvider, actionMap.action, dpName, declDataProviderSvc, actionMap );\n            dataProviderInstance.dynamicDp = true;\n            dataProviderInstance.debugId = Math.floor( Math.random() * 100 );\n            dataProviders.push( dataProviderInstance );\n        } );\n    }\n\n    return dataProviders[ index ];\n};\n\nexports = {\n    createDataProvider,\n    createDynamicDataProvider,\n    findDataProvider,\n    isDataProvider,\n    loadAction,\n    selectAll,\n    selectNone,\n    dataProviderEnableMultiSelect,\n    dataProviderDisableMultiSelect,\n    validateLovAction\n};\nexport default exports;\n\nloadDebugOption();\n"]},"metadata":{},"sourceType":"module"}