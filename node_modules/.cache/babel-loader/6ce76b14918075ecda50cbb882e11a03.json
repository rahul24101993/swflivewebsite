{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSPLMTableNativeService\n */\nimport * as eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport splmTableFactory from 'js/splmTableFactory';\nimport awTableSvc from 'js/awTableService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport columnFilterService from 'js/awColumnFilterService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport viewModelObjectService from 'js/viewModelObjectService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport * as cfgSvc from 'js/awConfiguration';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport util from 'js/splmTableUtils';\nexport const initializeTable = function (element, viewModelCollection, dataCtxNode, declGridParam, runActionWithViewModel) {\n  // revisitme:\n  // tstark - leave for refactor\n  // - viewModelCollection has no use here.\n  // - passing element as ref can save one factor of memory leak.\n  // - But the dataCtxNode and declGridParam is too complex, we have viewModel -> data -> dataProvider,\n  //   almost impossible to know where the closure is getting hold. The fact I know is by dummy the data,\n  //   the symptom will go away\n  let tableCallbacks = {};\n  let declGridObj = { ...declGridParam\n  };\n  const gridid = declGridObj.gridid;\n  const dataProvider = declGridObj.dataProviderInstance;\n  const columnProvider = declGridObj.columnProviderInstance;\n  declarativeDataCtxService.applyScope(dataCtxNode.data, declGridObj.gridOptions, null, dataCtxNode, null);\n  let gridOptions = declGridObj.gridOptions;\n  let declViewModel = dataCtxNode.data;\n  var instanceEventSubcr = [];\n  var tableInstance = null;\n  let tableElem = null;\n  var _previousSelections = [];\n  const tableInstanceCallbacks = {};\n  columnProvider.setColumnFilters([]);\n  /**\n    * Refresh the table content by invoking the action to reload first page of data provider\n    */\n\n  var reloadDataProvider = function () {\n    if (gridid) {\n      if (dataProvider && dataProvider.json && dataProvider.json.firstPage) {\n        delete dataProvider.json.firstPage;\n      }\n\n      dataProvider.resetDataProvider();\n      /**\n        * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n        * tstark - leave for refactor\n        * Delete firstPage results only on dataProvider reset\n       if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n           delete dataProvider.json.firstPage;\n       }\n       viewModelSvc.executeCommand( declViewModel, dataProvider, dataCtxNode );\n        */\n    }\n  };\n\n  if (gridid) {\n    var propertyProvider = declViewModel.dataProviders[declGridObj.propertyProvider];\n\n    if (!columnProvider.sortCallback) {\n      columnProvider.sortCallback = function () {\n        reloadDataProvider();\n      };\n    } // Attach enableArrangeMenu to gridOptions because we are not passing grid into splmTable\n\n\n    gridOptions = gridOptions || {};\n    gridOptions.enableArrangeMenu = declGridObj.enableArrangeMenu;\n    gridOptions.showContextMenu = !_.isNil(declGridObj.showContextMenu) ? declGridObj.showContextMenu : gridOptions.showContextMenu;\n    gridOptions.showDecorators = declGridObj.showDecorators;\n    gridOptions.useTree = declGridObj.useTree; // Turn on grid menu if arrange command is enabled, only if not set by grid\n\n    if (gridOptions.enableGridMenu === undefined && gridOptions.enableArrangeMenu) {\n      gridOptions.enableGridMenu = true;\n    } // Turn on XXLARGE header height if enableHeaderIcon is enabled\n\n\n    if (gridOptions.enableHeaderIcon === true) {\n      gridOptions.headerHeight = 'XXLARGE';\n    }\n\n    var _loadTreeProperties = function (propertyLoadRequest) {\n      var propertyLoadInput = awTableSvc.createPropertyLoadInput([propertyLoadRequest]);\n      return propertyProvider.getProperties(dataCtxNode, propertyLoadInput).then(function (propertyLoadResult) {\n        if (dataProvider.topNodeUid) {\n          _.forEach(propertyLoadResult.updatedNodes, function (vmo) {\n            if (vmo.uid === dataProvider.topNodeUid) {\n              // Assign on props doesn't work if it's undefined, doing this for now to make it work.\n              if (dataProvider.topTreeNode.props === undefined) {\n                dataProvider.topTreeNode.props = {};\n              }\n\n              _.assign(dataProvider.topTreeNode.props, vmo.props);\n            } // Reset edit state since props have loaded\n\n\n            viewModelObjectService.setEditState(vmo, false);\n            delete vmo.isPropLoading;\n          });\n\n          if (propertyLoadResult.updatedNodes) {\n            tableInstance.refresh();\n          }\n        }\n\n        if (!propertyLoadResult.columnConfig) {\n          // Notify table to refresh if no columnConfig change to reflect new prop values in vmos\n          tableInstance.refresh();\n        } else if (propertyLoadResult.columnConfig.columns.length !== dataProvider.cols.length) {\n          /** revisitme Shaishav: Can we make the new condition similar to old condition? Will there\n             * be extra refreshes because of new condition?\n             * tstark - leave for refactor\n          //} else if( !_.isEqual( propertyLoadResult.columnConfig.columns, dataProvider.columnConfig.columns ) ) {\n             */\n          // LCS-178290 - Redundant refresh in page load\n          // Do column Refresh only in the case we have new columnConfig from server\n          columnProvider.buildDynamicColumns(propertyLoadResult.columnConfig.columns, true).then(() => {\n            tableInstance.resetColumns();\n          });\n        }\n\n        if (util.shouldRequestStartEditPropsLoaded(tableElem)) {\n          util.requestStartEdit(tableElem);\n        }\n      });\n    };\n\n    var _loadProps = _.debounce(function (emptyVMOs) {\n      /**\n        * Since debounced functions have a slight chance of being fired off after a maxWait and after the\n        * declViewModelhas been destroyed (and before the debounce 'cancel' function is called), we want to\n        * check for that case here.\n        */\n      if (declViewModel.isDestroyed()) {\n        return;\n      }\n      /**\n        * Include 'top' node if it does not have 'props' set yet.\n        */\n\n\n      if (!dataProvider.topTreeNode.props) {\n        var topNodeUid = dataProvider.topTreeNode.uid;\n        var foundTop = false;\n\n        for (var i = 0; i < emptyVMOs.length; i++) {\n          if (emptyVMOs[i].uid === topNodeUid) {\n            foundTop = true;\n            break;\n          }\n        }\n\n        if (!foundTop) {\n          emptyVMOs.push(dataProvider.topTreeNode);\n        }\n      } // Return if there are no props to load\n\n\n      if (emptyVMOs.length === 0) {\n        return;\n      }\n\n      var columnInfos = [];\n\n      _.forEach(dataProvider.cols, function (columnInfo) {\n        if (!columnInfo.isTreeNavigation) {\n          columnInfos.push(columnInfo);\n        }\n      });\n\n      _.forEach(emptyVMOs, function (vmo) {\n        vmo.isPropLoading = true;\n      });\n\n      var propertyLoadRequest = {\n        parentNode: null,\n        childNodes: emptyVMOs,\n        columnInfos: columnInfos\n      };\n\n      _loadTreeProperties(propertyLoadRequest);\n    }, 500, {\n      maxWait: 10000,\n      trailing: true,\n      leading: false\n    });\n\n    var initializeProvider = function (dataProvider, columnProvider, passedState) {\n      return columnProvider.initialize(passedState).then(function (dynamicColumns) {\n        dataProvider.cols = dataProvider.cols ? dataProvider.cols : dynamicColumns;\n        /**\n          * Dont re-initialize DP if it already exists => Doesn't matter if empty table or table with rows\n          */\n\n        if (dataProvider.json && dataProvider.json.firstPage) {\n          /**\n            * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n            * tstark - leave for refactor\n            * Delete firstPage results only on dataProvider reset\n           // If first page but no data loaded in loadedVMObjects, try viewModelSvc executing the dataprovider\n           if( dataProvider.json.firstPage.length > 0 && dataProvider.viewModelCollection &&\n               dataProvider.viewModelCollection.loadedVMObjects && dataProvider.viewModelCollection.loadedVMObjects.length === 0 ) {\n                   viewModelSvc.executeCommand( declViewModel, declGrid.dataProvider, $scope );\n           }\n           */\n          // Do Nothing\n          return null;\n        }\n\n        return dataProvider.initialize(dataCtxNode).then(function () {\n          if (!dataProvider.cols || dataProvider.cols.length === 0) {\n            if (!dataProvider.columnConfig) {\n              return Promise.reject(new Error('Column config not loaded'));\n            }\n\n            return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns, true);\n          }\n\n          return null;\n        });\n      });\n    };\n\n    tableCallbacks.completeInitialization = () => {\n      if (dataProvider.columnConfig) {\n        dataProvider.initializationComplete = 'InProgress';\n        return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns, true).then(() => {\n          var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n\n          if (declGridObj.reusable) {\n            gridContextDispatcher = declGridObj.gridContextDispatcher;\n          }\n\n          tableInstance = splmTableFactory.createTableObject(element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight, gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox);\n          tableInstance.showCheckBox = declGridObj.showCheckBox;\n          tableInstance.resetColumns();\n          tableInstance.viewModelCollection = viewModelCollection;\n          tableInstance.refresh();\n          initializeObserver();\n          tableElem = tableInstance.getTableElement();\n          dataProvider.initializationComplete = true;\n\n          if (declGridObj.containerHeight) {\n            tableInstance.updateContainerHeight(declGridObj.containerHeight);\n          } // Event Interface to rerender the table with data currently on the client\n\n\n          instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.clientRefresh', function () {\n            _.defer(function () {\n              tableInstance.showCheckBox = declGridObj.showCheckBox;\n\n              if (tableElem && tableElem._tableInstance) {\n                tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n              }\n\n              util.cleanupComponents(element);\n              tableInstance.refresh();\n            });\n          }));\n        });\n      }\n    };\n\n    tableCallbacks.updateTableColumns = updatedColumns => {\n      if (updatedColumns && updatedColumns.length > 0) {\n        columnProvider.buildDynamicColumns(updatedColumns, true).then(() => {\n          if (tableInstance !== null) {\n            tableInstance.resetColumns();\n          }\n        });\n      }\n    };\n\n    tableCallbacks.updateContentRowSelection = () => {\n      tableInstance && tableInstance.updateContentRowSelection();\n    };\n\n    tableCallbacks.selectTableColumn = columnDef => {\n      if (columnDef) {\n        splmTableSelectionHelper.selectColumnCells(tableInstance.getTableElement(), columnDef.field);\n      }\n    };\n\n    tableCallbacks.updateSortDirection = (currentColumnIndex, newColumnIndex, sortDirection) => {\n      if (newColumnIndex > -1) {\n        tableInstance && tableInstance.updateSortDirection(currentColumnIndex, newColumnIndex, sortDirection);\n        reloadDataProvider();\n      }\n    };\n\n    tableCallbacks.updateDynamicRowHeight = dynamicRowHeightStatus => {\n      tableInstance && tableInstance.updateDynamicRowHeight(dynamicRowHeightStatus);\n    };\n\n    tableCallbacks.updatePinColumn = (columnDef, isFreezeAction, defaultColumnPinIndex) => {\n      if (columnDef && defaultColumnPinIndex > -1) {\n        tableInstance && tableInstance.updatePinColumn(columnDef, isFreezeAction, defaultColumnPinIndex);\n      }\n    };\n\n    tableCallbacks.hideColumn = columnDef => {\n      if (columnDef) {\n        tableInstance && tableInstance.hideColumn(columnDef);\n      }\n    };\n\n    tableCallbacks.columnFilterApplied = columnFilterInfo => {\n      // viewModel columnProvider needed because columnFilters with be needed by the viewModel action inputs\n      // revisitme - Send event to all application listeners, remove when converted\n      const eventData = {\n        isInternalTableEvent: true,\n        gridId: gridid,\n        ...columnFilterInfo\n      };\n      eventBus.publish('pltable.columnFilterApplied', eventData);\n      const menuService = util.getTableMenuService(tableElem);\n      menuService.ensureAllTableMenusDismissed();\n\n      if (columnFilterInfo.filters && columnFilterInfo.filters.length) {\n        columnFilterService.setFilters(columnProvider, dataProvider, columnFilterInfo.filters, columnFilterInfo.column);\n      } else if (columnFilterInfo.column) {\n        columnFilterService.removeFilter(columnFilterInfo.column, columnProvider, dataProvider);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n\n      dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied(dataProvider);\n      const columnName = columnFilterInfo.column ? columnFilterInfo.column.field : null;\n      tableInstance.updateFilterIcons(columnName);\n      reloadDataProvider();\n    };\n\n    tableCallbacks.editStateUpdated = () => {\n      const data = {\n        dataSource: dataProvider,\n        state: dataProvider._editingState\n      };\n      tableInstance.updateEditState(data);\n    };\n\n    tableCallbacks.updateEditState = async props => {\n      if (props && props.tableContext) {\n        if (props.tableContext.startEdit && props.tableContext.startEdit.value === true) {\n          await dataProvider.startEdit(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.startEdit.update) {\n            props.tableContext.startEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(true);\n          }\n        } else if (props.tableContext.cancelEdit && props.tableContext.cancelEdit.value === true) {\n          await dataProvider.cancelEdits(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.cancelEdit.update) {\n            props.tableContext.cancelEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(false);\n          }\n        } else if (props.tableContext.saveEdit && props.tableContext.saveEdit.value === true) {\n          await dataProvider.saveEdits(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.saveEdit.update) {\n            props.tableContext.saveEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(false);\n          }\n        }\n      }\n    };\n\n    const initializeObserver = () => {\n      if (resizeObserverSvc.supportsResizeObserver()) {\n        const callback = _.debounce(() => {\n          eventBus.publish(gridid + '.plTable.resizeCheck');\n        }, 200, {\n          maxWait: 10000,\n          trailing: true,\n          leading: false\n        });\n\n        resizeObserverSvc.observe(element, callback);\n      }\n    };\n\n    if (gridOptions.useTree === true) {\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.loadProps', function (eventData) {\n        _loadProps(eventData.VMOs);\n      }));\n      instanceEventSubcr.push(eventBus.subscribe('primaryWorkarea.reloadTop', function (event) {\n        var clearAllStates = !(event && event.retainAllStates);\n\n        if (clearAllStates) {\n          awTableStateSvc.clearAllStates(declViewModel, gridid);\n        }\n        /*\n          * delete firstPage results if any before re-initializing dataProvider\n          */\n\n\n        if (dataProvider.json.firstPage) {\n          delete dataProvider.json.firstPage;\n        }\n\n        dataProvider.initialize(dataCtxNode);\n      }));\n\n      const toggleTreeNode = function (node) {\n        if (!node.loadingStatus) {\n          node.loadingStatus = true;\n          tableInstance.updateTreeCellIcon(node); // get the current copy of data\n\n          Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n\n          if (node.isExpanded === true) {\n            tableInstance.setNodeExpansionInProgress(true);\n            node._expandRequested = true;\n            var preExpandVMObjectsLength = dataProvider.viewModelCollection.loadedVMObjects.length;\n            dataProvider.expandObject(dataCtxNode, node).then(function (updatedViewModelCollection) {\n              // LCS-180794: If Expand did not return any new objects or\n              //if node has previous expansion state and dataProvider.cacheCollapse=true which means it didn't get new objects from server,\n              // continue updating the rest of the table\n              tableInstance.setNodeExpansionInProgress(false);\n\n              if (preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length) {\n                delete node.loadingStatus;\n                tableInstance.refresh();\n              } //view model collection is updated so update table with new set of VMOs.\n\n\n              dataProvider.update(updatedViewModelCollection.loadedVMObjects);\n            }).finally(function () {\n              // Make sure even when errored that the expansion in progress is set to false\n              tableInstance.setNodeExpansionInProgress(false); //ensure properties are loaded after expansion\n              // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n              // render the rows. The row rendering will then occur once they props have been loaded.\n\n              tableInstance.loadMissingProps();\n              delete node.loadingStatus;\n              delete node._expandRequested;\n              tableInstance.updateTreeCellIcon(node);\n              tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n\n              if (util.shouldRequestStartEditTreeExpand(tableElem, node, propertyProvider)) {\n                util.requestStartEdit(tableElem);\n              }\n            });\n            awTableStateSvc.saveRowExpanded(declViewModel, gridid, node);\n          } else {\n            dataProvider.collapseObject(dataCtxNode, node).then(function (updatedViewModelCollection) {\n              dataProvider.update(updatedViewModelCollection.loadedVMObjects);\n\n              if (preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length) {\n                tableInstance.refresh();\n              }\n            }).finally(function () {\n              delete node.loadingStatus;\n              tableInstance.updateTreeCellIcon(node);\n              tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n            });\n            awTableStateSvc.saveRowCollapsed(declViewModel, gridid, node);\n          }\n        }\n      };\n\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.toggleTreeNode', toggleTreeNode));\n\n      if (declGridObj.reusable) {\n        tableInstanceCallbacks.toggleTreeNode = toggleTreeNode;\n      }\n\n      const doFocusPlaceHolder = function (vmNode) {\n        var vmCollection = dataProvider.viewModelCollection;\n        var cursorNdx = vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(vmNode));\n        /**\n         * Find 'parent' node of the 'placeholder' node in the vmCollection\n         */\n\n        var phParentNode = null;\n        var cursorNode = vmCollection.getViewModelObject(cursorNdx);\n        var parentLevelNdx = cursorNode.levelNdx - 1;\n\n        if (parentLevelNdx === -1) {\n          phParentNode = dataProvider.topTreeNode;\n        } else {\n          for (var rowNdx = cursorNdx - 1; rowNdx >= 0; rowNdx--) {\n            var currRow = vmCollection.getViewModelObject(rowNdx);\n\n            if (currRow.levelNdx === parentLevelNdx) {\n              phParentNode = currRow;\n              break;\n            }\n          }\n        }\n\n        if (phParentNode === null) {\n          return null;\n        }\n        /**\n         * Load, using the 'focusAction', the siblings of the 'placeholder' in the context of its immediate\n         * 'parent'.\n         * <P>\n         * Note: We want to use a smaller page size here to minimize the loading.\n         */\n\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput(phParentNode, 0, null, vmNode.id, dataProvider.treePageSize, true, null);\n        var loadIDs = {\n          t_uid: dataProvider.topTreeNode.uid,\n          o_uid: phParentNode.uid,\n          c_uid: vmNode.uid,\n          uid: null\n        };\n        var actionRequestObj = {\n          treeLoadInput: treeLoadInput,\n          loadIDs: loadIDs\n        };\n        /**\n         * Change 'suffix' text to indicate we are attempting to load more rows.\n         */\n\n        vmNode.loadingStatus = true; // get the current copy of data\n\n        Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n        return dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.nextAction, dataProvider.json, dataCtxNode, actionRequestObj).then(function (response) {\n          /**\n           * Locate cursor node in original collection & find/collect all contained 'child' nodes.\n           */\n          var cursorId = uwUtilSvc.getEvaluatedId(cursorNode);\n          var cursorLevel = cursorNode.levelNdx;\n          var vmCollection = dataProvider.viewModelCollection;\n          var cursorNdxInOrig = vmCollection.findViewModelObjectById(cursorId);\n          var loadedVMObjects = vmCollection.loadedVMObjects;\n          var cursorVMObjects = [loadedVMObjects[cursorNdxInOrig]];\n\n          for (var l = cursorNdxInOrig + 1; l < loadedVMObjects.length; l++) {\n            var currNode = loadedVMObjects[l];\n\n            if (currNode.levelNdx <= cursorLevel) {\n              break;\n            }\n\n            cursorVMObjects.push(currNode);\n          }\n          /**\n           * Re-order the childNdx values of the sibling nodes relative to initial placeholder as 0;\n           */\n\n\n          var treeLoadResult = response.actionResultObj.responseObj.treeLoadResult;\n          var newVMObjects = treeLoadResult.childNodes;\n          var cursorNdxInNew = 0;\n\n          for (var i = 0; i < newVMObjects.length; i++) {\n            if (newVMObjects[i].id === cursorId) {\n              cursorNdxInNew = i;\n              break;\n            }\n          }\n\n          for (var j = 0; j < newVMObjects.length; j++) {\n            newVMObjects[j].childNdx = j - cursorNdxInNew;\n          }\n          /**\n           * Check if the 'fresh' cursor node is at either end of the 'sibling' list and is now known to be an\n           * 'incompleteHead' or 'incompleteTail'\n           * <P>\n           * If so: Move that status over to the 'original' cursor node.\n           * <P>\n           * Note: We are about to replace the 'fresh' node in the set of its siblings just returned and we do\n           * not want to lose this important information.\n           */\n\n\n          if (cursorNdxInNew === 0 && newVMObjects[0].incompleteHead) {\n            cursorNode.incompleteHead = true;\n          }\n\n          var lastNodeNdx = newVMObjects.length - 1;\n\n          if (cursorNdxInNew === lastNodeNdx && newVMObjects[lastNodeNdx].incompleteTail) {\n            cursorNode.incompleteTail = true;\n          }\n          /**\n           * Make sure the placeholder 'parent' node gets its 'children' set (a shallow clone is good enough).\n           * <P>\n           * Replace the 'fresh' cursor node with the 'original' cursor node since it holds important state\n           * and hierarchy info.\n           */\n\n\n          phParentNode.children = _.clone(newVMObjects);\n          phParentNode.children[cursorNdxInNew] = cursorNode;\n          /**\n           * Remove the 'fresh' cursor node from the array of its siblings.\n           * <P>\n           * Insert the cursor node (and all of its children from the original array) into the array of new\n           * nodes.\n           * <P>\n           * Remove the cursor node (and all of its children) from the original array\n           * <P>\n           * Insert the new nodes (updated with the cursor node and all of its children from the original\n           * array) into the vmCollection array of nodes.\n           * <P>\n           * Clear the loading status of the cursor node.\n           */\n\n          newVMObjects.splice(cursorNdxInNew, 1); // LCS-230184 - In the case where no changes are made to the loadedVMObjects, we must manually refresh\n          // so that the table can process the remaining rendered nodes for more focus placeholder, expansion\n          // restoration, or prop loading.\n\n          if (newVMObjects.length === 0) {\n            delete vmNode.loadingStatus;\n            delete vmNode._focusRequested;\n            tableInstance.refresh();\n            return;\n          }\n\n          var insertNdx = cursorNdxInNew - 1;\n          arrayUtils.insert(newVMObjects, insertNdx, cursorVMObjects);\n          loadedVMObjects.splice(cursorNdxInOrig, cursorVMObjects.length);\n          arrayUtils.insert(loadedVMObjects, cursorNdxInOrig - 1, newVMObjects);\n          delete vmNode.loadingStatus;\n          delete vmNode._focusRequested;\n          dataProvider.update(loadedVMObjects);\n          /**\n           * Fire a 'treeNodesLoaded' event, sourced to the uwDataProvider, for all tree-table changes. This\n           * event includes only the input/result structures for the current load operation. This event is\n           * used to load additional properties in an async fashion.\n           */\n\n          eventBus.publish(dataProvider.name + '.treeNodesLoaded', {\n            treeLoadInput: treeLoadInput,\n            treeLoadResult: treeLoadResult\n          });\n          /**\n           * Fire a 'modelObjectsUpdated' event, sourced to the uwDataProvider, for all tree-table changes.\n           * This event includes the complete array of nodes in the collection.\n           */\n\n          eventBus.publish(dataProvider.name + '.modelObjectsUpdated', {\n            viewModelObjects: loadedVMObjects,\n            noResults: false\n          });\n        });\n      };\n\n      tableInstanceCallbacks.doFocusPlaceHolder = doFocusPlaceHolder;\n    } else {\n      instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.modelObjectsUpdated', function (event) {\n        if (event && !event.arrangeColumnEvent) {\n          tableCallbacks.columnsArranged(event);\n        }\n      }));\n    }\n\n    tableCallbacks.columnsArranged = columnArrangeData => {\n      if (columnArrangeData.arrangeType && columnArrangeData.arrangeType === 'saveColumnAndLoadAction' && columnArrangeData.viewModelObjects) {\n        // Just update data provider with vmos changed by columnArrangeService\n        tableInstance.resetInfiniteScroll();\n        dataProvider.update(columnArrangeData.viewModelObjects, columnArrangeData.totalFound); // Need to refresh the table since there is no watch anymore on loadedVMObjects\n\n        tableInstance.refresh();\n      }\n    };\n    /**\n      * Subscribe to resetState. Clear all states and set isFocusedLoad to true.\n      */\n\n\n    instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.resetState', function () {\n      awTableStateSvc.clearAllStates(declViewModel, gridid);\n      dataProvider.isFocusedLoad = true;\n    }));\n    cfgSvc.get('propertyRendererTemplates');\n    initializeProvider(dataProvider, columnProvider, dataCtxNode).then(() => {\n      var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n\n      if (declGridObj.reusable) {\n        gridContextDispatcher = declGridObj.gridContextDispatcher;\n      }\n\n      tableInstance = splmTableFactory.createTableObject(element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight, gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox);\n      tableInstance.showCheckBox = declGridObj.showCheckBox;\n      tableElem = tableInstance.getTableElement();\n      initializeObserver(); // Following refresh is for cases like object sets. Where first page is already loaded by stylesheet SOA\n\n      tableInstance.viewModelCollection = viewModelCollection;\n      tableInstance.refresh();\n      dataProvider.initializationComplete = true;\n\n      if (declGridObj.containerHeight) {\n        tableInstance.updateContainerHeight(declGridObj.containerHeight);\n      } // Event Interface to rerender the table with data currently on the client\n\n\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.clientRefresh', function () {\n        _.defer(function () {\n          tableInstance.showCheckBox = declGridObj.showCheckBox;\n\n          if (tableElem && tableElem._tableInstance) {\n            tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n          }\n\n          util.cleanupComponents(element);\n          tableInstance.refresh();\n        });\n      }));\n    }, error => {\n      dataProvider.initializationComplete = false;\n      logger.trace(error);\n    });\n  }\n\n  instanceEventSubcr.push(eventBus.subscribe('columnArrange', function (eventData) {\n    if (eventData.name === gridid || eventData.columnConfigId && dataProvider.columnConfig && eventData.columnConfigId === dataProvider.columnConfig.columnConfigId) {\n      if (eventData.columns.length) {\n        tableInstance.removeStaleFilters(eventData.columns);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n    }\n\n    if (tableInstance.getDynamicRowHeightStatus()) {\n      tableInstance.resetDynamicRowHeights();\n    }\n  }));\n  var relatedModifiedEvent = eventBus.subscribe('cdm.relatedModified', function (eventData) {\n    tableInstance.relatedModified();\n  });\n  instanceEventSubcr.push(relatedModifiedEvent); // Event Interface to rerender table with reloaded data from the dataprovider\n\n  instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.reload', reloadDataProvider)); // revisitme - tstark - Need to keep event until all application teams convert away from events\n\n  instanceEventSubcr.push(eventBus.subscribe('pltable.columnFilterApplied', function (eventData) {\n    if (gridid === eventData.gridId && eventData.isInternalTableEvent !== true) {\n      if (eventData.filters && eventData.filters.length) {\n        columnFilterService.setFilters(columnProvider, dataProvider, eventData.filters, eventData.column);\n      } else if (eventData.column) {\n        columnFilterService.removeFilter(eventData.column, columnProvider, dataProvider);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n\n      dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied(dataProvider);\n      const columnName = eventData.column ? eventData.column.field : null;\n      tableInstance.updateFilterIcons(columnName);\n      reloadDataProvider();\n    }\n  }));\n\n  tableCallbacks.updateColumnMenuData = function (columnMenuData) {\n    _.forEach(dataProvider.cols, function (currentColumn) {\n      if (columnMenuData.columnName === currentColumn.field) {\n        currentColumn.filter = { ...currentColumn.filter,\n          ...columnMenuData\n        };\n        currentColumn.filter.columnMenuData = columnMenuData;\n\n        if (currentColumn.filter.showFilters) {\n          if (currentColumn.filter.showFilters.dbValue && currentColumn.filter.showFilters.dbValue !== 'false') {\n            currentColumn.filter.showFilterFacets = true;\n          } else {\n            currentColumn.filter.showFilterFacets = false;\n          }\n        }\n\n        return false;\n      }\n    });\n  }; // revisitme - tstark - Need to keep event until all application teams convert away from events\n\n\n  instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.setFilterDisability', function (eventData) {\n    if (gridid === eventData.gridId) {\n      tableInstance.setFilterDisability(eventData.isFilterDisabled);\n    }\n  }));\n  /**\n    *  destroy the table\n    */\n\n  tableCallbacks.destroy = function () {\n    var columns = [];\n\n    if (dataProvider.columnConfig && dataProvider.columnConfig.columns) {\n      columns = dataProvider.columnConfig.columns;\n    }\n\n    _.forEach(instanceEventSubcr, function (eventBusSub) {\n      eventBus.unsubscribe(eventBusSub);\n    });\n\n    splmTableFactory.destroyTable(gridid, element, columns);\n  };\n\n  tableCallbacks.updateVmCollection = viewModelCollection => {\n    if (tableInstance) {\n      tableInstance.viewModelCollection = viewModelCollection;\n\n      if (util.shouldRequestStartEditPagination(tableElem)) {\n        util.requestStartEdit(tableElem);\n      }\n\n      tableInstance.refresh();\n    }\n  };\n\n  tableCallbacks.updateDeclGridObject = declGridParam => {\n    declGridObj = declGridParam;\n  };\n\n  tableCallbacks.updateMenuContext = menuContext => {\n    declGridObj.menuContext = menuContext;\n  };\n\n  tableCallbacks.updateState = newState => {\n    declViewModel = newState;\n\n    if (tableInstance) {\n      tableInstance.updateInstanceState(newState);\n    }\n  };\n\n  tableCallbacks.refreshTable = () => {\n    if (tableInstance) {\n      tableInstance.refresh();\n    }\n  };\n\n  tableCallbacks.updateGridOptionsForTableInstance = props => {\n    if (tableElem && tableElem._tableInstance && props && props.showCheckBox !== undefined) {\n      tableElem._tableInstance.showCheckBox = props.showCheckBox;\n    }\n  };\n  /**\n    * Setup to react to changes in selection within the dataProvider.\n    *\n    * @param {Object} event -\n    * @param {Object} data -\n    */\n\n\n  instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.selectionChangeEvent', function (event) {\n    var selections = event.selectionModel.getSelection(); // Set scroll to row in progress\n\n    if (dataProvider.isFocusedLoad === true && selections.length > 0) {\n      dataProvider.isFocusedLoad = false;\n      dataProvider.scrollToRow = true;\n    }\n\n    if (selections.length > 0 && selections.length >= _previousSelections.length && _.isEqual(_previousSelections, selections) === false || dataProvider.scrollToRow === true) {\n      dataProvider.scrollToRow = true;\n      eventBus.publish('plTable.scrollToRow', {\n        gridId: gridid,\n        rowUids: selections\n      });\n    }\n\n    _previousSelections = selections.slice();\n  }));\n  var pageLoadInProgress = false;\n\n  const getTreeNodePageCallback = function (results) {\n    logger.trace('AW simple table: Loaded next tree page data');\n    pageLoadInProgress = false;\n\n    if (util.shouldRequestStartEditTreePagination(tableElem, propertyProvider)) {\n      util.requestStartEdit(tableElem);\n    }\n\n    dataProvider.update(results.loadedVMObjects, results.totalFound);\n  }; // eslint-disable-next-line complexity\n\n\n  const loadMorePages = function (eventData) {\n    if (tableInstance.viewModelCollection) {\n      var lastItemIndex = eventData.lastRenderedItem.index; // get the current copy of data\n\n      Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n\n      if (lastItemIndex !== 0 && lastItemIndex === tableInstance.viewModelCollection.loadedVMObjects.length - 1) {\n        if (dataProvider.nextAction || dataProvider.action) {\n          var lastNode = dataProvider.viewModelCollection.loadedVMObjects[lastItemIndex];\n\n          if (dataProvider.hasMorePages() && lastNode.incompleteTail) {\n            delete lastNode.incompleteTail;\n\n            if (eventData.lastRenderedItem.levelNdx > 0) {\n              pageLoadInProgress = true;\n              dataProvider.getTreeNodePage(dataCtxNode, null, eventData.lastRenderedItem.uid, true, null).then(getTreeNodePageCallback);\n              return;\n            }\n\n            pageLoadInProgress = true;\n            dataProvider.pageDispatcher({\n              type: 'NEXT_PAGE'\n            });\n            return;\n          }\n\n          logger.trace('AW simple table: Rendering of all rows below completed');\n        }\n      }\n\n      var firstItemIndex = eventData.firstRenderedItem.index;\n\n      if (firstItemIndex === 0) {\n        if (dataProvider.previousAction) {\n          var firstNode = dataProvider.viewModelCollection.loadedVMObjects[firstItemIndex];\n\n          if (dataProvider.hasMorePagesUp() && firstNode.incompleteHead) {\n            delete firstNode.incompleteHead;\n            tableInstance.maintainScrollPosition();\n\n            if (eventData.firstRenderedItem.levelNdx > 0) {\n              pageLoadInProgress = true;\n              dataProvider.getTreeNodePage(dataCtxNode, null, eventData.firstRenderedItem.uid, false, null).then(getTreeNodePageCallback);\n              return;\n            }\n\n            pageLoadInProgress = true;\n            dataProvider.pageDispatcher({\n              type: 'PREVIOUS_PAGE'\n            });\n            return;\n          }\n\n          logger.trace('AW simple table: Rendering of all rows above completed');\n        }\n      } // Check for incomplete head/tail on tree node in rendered range\n\n\n      if (gridOptions.useTree === true) {\n        var incompleteNode = dataProvider.findIncompleteNodeInRange(firstItemIndex, lastItemIndex);\n\n        if (incompleteNode !== null && incompleteNode.levelNdx > 0) {\n          var loadNextPage = incompleteNode.incompleteTail === true;\n\n          if (loadNextPage === true && !(dataProvider.nextAction || dataProvider.action)) {\n            return;\n          } else if (loadNextPage === false && !dataProvider.previousAction) {\n            return;\n          }\n\n          delete incompleteNode.incompleteHead;\n          delete incompleteNode.incompleteTail;\n          pageLoadInProgress = true;\n          dataProvider.getTreeNodePage(dataCtxNode, null, incompleteNode.uid, loadNextPage, null).then(getTreeNodePageCallback);\n          return;\n        }\n      }\n    }\n    /** revisitme Radhika: We havesome logic below around pageLoadInProgress. We might need some\n       * tstark - leave for refactor\n           * in the new system. The code needs to be cleaned up and the necessary lines needs to be reused\n          if( dataProvider.viewModelCollection && pageLoadInProgress === false ) {\n              // Check if next page should be loaded\n              var lastItemIndex = eventData.lastRenderedItem.index;\n              if( lastItemIndex !== 0 && lastItemIndex === dataProvider.viewModelCollection.loadedVMObjects.length - 1 ) {\n                  if( dataProvider.nextAction || dataProvider.action ) {\n                      var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                      if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                          delete lastNode.incompleteTail;\n                          if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                              pageLoadInProgress = true;\n                              dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                              return;\n                          }\n                          /**\n                           * REFACTOR: This is how UI Grid checks to see if we actually have more pages to load or not since\n                           * dataProvider.hasMorePages() will always return true, because it sets dataProvider.update(firstPageObjs, firstPageObjs.length + 1)\n                           * in dataProviderFactory and uses these two values for checking for if more pages to load or not.\n                           * Will remove this code in 4.2 when all UIgrid replaced by PL Table\n                          var maxToLoad;\n                          if( dataProvider.action && dataProvider.action.inputData ) {\n                              var actionInputData = dataProvider.action.inputData;\n                              if( actionInputData.searchInput ) {\n                                  maxToLoad = actionInputData.searchInput.maxToLoad;\n                              }\n                          }\n                           /**\n                           *\n                           * If we have a firstPage and its length is less than maxToLoad, we dont need to load another page.\n                           * All other cases, handle like normally => Try to get next page of data\n                           *\n                          if( maxToLoad && dataProvider.json.firstPage && dataProvider.json.firstPage.length < maxToLoad ) {\n                              logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                          } else {\n                              pageLoadInProgress = true;\n                              dataProvider.getNextPage( dataCtxNode ).then( function() {\n                                  logger.trace( 'AW simple table: Loaded next page data' );\n                                  pageLoadInProgress = false;\n                                  if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                      util.requestStartEdit( tableElem );\n                                  }\n                              } );\n                              return;\n                          }\n                      } else {\n                          logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                      }\n                  }\n              }\n               // Check if previous page should be loaded as long as next page has not already been requested\n              var firstItemIndex = eventData.firstRenderedItem.index;\n              if( firstItemIndex === 0 ) {\n                  if( dataProvider.previousAction ) {\n                      var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                      if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                          delete firstNode.incompleteHead;\n                          eventBus.publish( dataProvider.name + '.plTable.maintainScrollPosition' );\n                          if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                              pageLoadInProgress = true;\n                              dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                              return;\n                          }\n                           pageLoadInProgress = true;\n                          dataProvider.getPreviousPage( dataCtxNode ).then( function() {\n                              logger.trace( 'AW simple table: Loaded previous page data' );\n                              pageLoadInProgress = false;\n                              if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                  util.requestStartEdit( tableElem );\n                              }\n                          } );\n                          return;\n                      }\n                       logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                  }\n              }\n               // Check for incomplete head/tail on tree node in rendered range\n              if( gridOptions.useTree === true ) {\n                  var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                  if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                      var loadNextPage = incompleteNode.incompleteTail === true;\n                      if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                          return;\n                      } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                          return;\n                      }\n                      delete incompleteNode.incompleteHead;\n                      delete incompleteNode.incompleteTail;\n                      pageLoadInProgress = true;\n                      dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                      return;\n                  }\n              }\n          }\n      */\n\n  };\n\n  tableInstanceCallbacks.loadMorePages = loadMorePages;\n\n  let unsetScrollToRowIndex = function () {\n    tableInstance.unsetScrollToRowIndex();\n  };\n\n  tableInstanceCallbacks.unsetScrollToRowIndex = unsetScrollToRowIndex;\n\n  let columnsRearranged = function (eventData) {\n    tableInstance.columnsRearranged(eventData);\n  };\n\n  tableInstanceCallbacks.columnsRearranged = columnsRearranged;\n\n  let columnsResized = function (eventData) {\n    tableInstance.columnsResized(eventData);\n  };\n\n  tableInstanceCallbacks.columnsResized = columnsResized;\n  return tableCallbacks;\n};\nexport default {\n  initializeTable\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/awSPLMTableNativeService.js"],"names":["initializeTable","tableCallbacks","declGridObj","declGridParam","gridid","dataProvider","columnProvider","declarativeDataCtxService","dataCtxNode","gridOptions","declViewModel","instanceEventSubcr","tableInstance","tableElem","_previousSelections","tableInstanceCallbacks","reloadDataProvider","propertyProvider","_","_loadTreeProperties","propertyLoadInput","awTableSvc","propertyLoadResult","vmo","viewModelObjectService","util","_loadProps","topNodeUid","foundTop","i","emptyVMOs","columnInfos","columnInfo","propertyLoadRequest","parentNode","childNodes","maxWait","trailing","leading","initializeProvider","Promise","gridContextDispatcher","splmTableFactory","initializeObserver","updatedColumns","columnDef","splmTableSelectionHelper","newColumnIndex","dynamicRowHeightStatus","defaultColumnPinIndex","columnFilterInfo","eventData","isInternalTableEvent","gridId","eventBus","menuService","columnFilterService","columnName","data","dataSource","state","_editingState","props","resizeObserverSvc","callback","clearAllStates","event","awTableStateSvc","toggleTreeNode","node","Object","preExpandVMObjectsLength","updatedViewModelCollection","doFocusPlaceHolder","vmCollection","cursorNdx","uwUtilSvc","phParentNode","cursorNode","parentLevelNdx","rowNdx","currRow","treeLoadInput","vmNode","loadIDs","t_uid","o_uid","c_uid","uid","actionRequestObj","cursorId","cursorLevel","cursorNdxInOrig","loadedVMObjects","cursorVMObjects","l","currNode","treeLoadResult","response","newVMObjects","cursorNdxInNew","j","lastNodeNdx","insertNdx","arrayUtils","viewModelObjects","noResults","columnArrangeData","cfgSvc","error","logger","relatedModifiedEvent","columnMenuData","currentColumn","columns","viewModelCollection","menuContext","newState","selections","rowUids","pageLoadInProgress","getTreeNodePageCallback","results","loadMorePages","lastItemIndex","lastNode","type","firstItemIndex","firstNode","incompleteNode","loadNextPage","unsetScrollToRowIndex","columnsRearranged","columnsResized"],"mappings":"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O4H,cAAc,CAArB,cAAA;UACA,OAAOA,cAAc,CAArB,cAAA;UACAT,kBAAkB,GAAlBA,IAAAA;UACAnH,YAAY,CAAZA,eAAAA,CAAAA,WAAAA,EAAAA,IAAAA,EAAiD4H,cAAc,CAA/D5H,GAAAA,EAAAA,YAAAA,EAAAA,IAAAA,EAAAA,IAAAA,CAAAA,uBAAAA;UACA;QACH;MACJ;IACJ;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EA1JI,CAAA;;EAiKAU,sBAAsB,CAAtBA,aAAAA,GAAAA,aAAAA;;EAEA,IAAIoH,qBAAqB,GAAG,YAAW;IACnCvH,aAAa,CAAbA,qBAAAA;EADJ,CAAA;;EAIAG,sBAAsB,CAAtBA,qBAAAA,GAAAA,qBAAAA;;EAGA,IAAIqH,iBAAiB,GAAG,UAAA,SAAA,EAAsB;IAC1CxH,aAAa,CAAbA,iBAAAA,CAAAA,SAAAA;EADJ,CAAA;;EAIAG,sBAAsB,CAAtBA,iBAAAA,GAAAA,iBAAAA;;EAEA,IAAIsH,cAAc,GAAG,UAAA,SAAA,EAAsB;IACvCzH,aAAa,CAAbA,cAAAA,CAAAA,SAAAA;EADJ,CAAA;;EAIAG,sBAAsB,CAAtBA,cAAAA,GAAAA,cAAAA;EAEA,OAAA,cAAA;AAl+BG,CAAA;AAq+BP,eAAe;EACXf;AADW,CAAf","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSPLMTableNativeService\n */\nimport * as eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport splmTableFactory from 'js/splmTableFactory';\nimport awTableSvc from 'js/awTableService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport columnFilterService from 'js/awColumnFilterService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport viewModelObjectService from 'js/viewModelObjectService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport * as cfgSvc from 'js/awConfiguration';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport util from 'js/splmTableUtils';\n\n\nexport const initializeTable = function( element, viewModelCollection, dataCtxNode, declGridParam, runActionWithViewModel ) {\n    // revisitme:\n    // tstark - leave for refactor\n    // - viewModelCollection has no use here.\n    // - passing element as ref can save one factor of memory leak.\n    // - But the dataCtxNode and declGridParam is too complex, we have viewModel -> data -> dataProvider,\n    //   almost impossible to know where the closure is getting hold. The fact I know is by dummy the data,\n    //   the symptom will go away\n    let tableCallbacks = {};\n    let declGridObj = { ...declGridParam };\n    const gridid = declGridObj.gridid;\n    const dataProvider = declGridObj.dataProviderInstance;\n    const columnProvider = declGridObj.columnProviderInstance;\n    declarativeDataCtxService.applyScope( dataCtxNode.data, declGridObj.gridOptions, null, dataCtxNode, null );\n    let gridOptions = declGridObj.gridOptions;\n    let declViewModel = dataCtxNode.data;\n\n    var instanceEventSubcr = [];\n    var tableInstance = null;\n    let tableElem = null;\n    var _previousSelections = [];\n    const tableInstanceCallbacks = {};\n\n    columnProvider.setColumnFilters( [] );\n\n    /**\n      * Refresh the table content by invoking the action to reload first page of data provider\n      */\n    var reloadDataProvider = function() {\n        if( gridid ) {\n            if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n                delete dataProvider.json.firstPage;\n            }\n            dataProvider.resetDataProvider();\n            /**\n              * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n              * tstark - leave for refactor\n              * Delete firstPage results only on dataProvider reset\n             if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n                 delete dataProvider.json.firstPage;\n             }\n             viewModelSvc.executeCommand( declViewModel, dataProvider, dataCtxNode );\n              */\n        }\n    };\n\n    if( gridid ) {\n        var propertyProvider = declViewModel.dataProviders[ declGridObj.propertyProvider ];\n\n        if( !columnProvider.sortCallback ) {\n            columnProvider.sortCallback = function() {\n                reloadDataProvider();\n            };\n        }\n\n        // Attach enableArrangeMenu to gridOptions because we are not passing grid into splmTable\n        gridOptions = gridOptions || {};\n        gridOptions.enableArrangeMenu = declGridObj.enableArrangeMenu;\n        gridOptions.showContextMenu = !_.isNil( declGridObj.showContextMenu ) ? declGridObj.showContextMenu : gridOptions.showContextMenu;\n        gridOptions.showDecorators = declGridObj.showDecorators;\n        gridOptions.useTree = declGridObj.useTree;\n\n        // Turn on grid menu if arrange command is enabled, only if not set by grid\n        if( gridOptions.enableGridMenu === undefined && gridOptions.enableArrangeMenu ) {\n            gridOptions.enableGridMenu = true;\n        }\n\n        // Turn on XXLARGE header height if enableHeaderIcon is enabled\n        if( gridOptions.enableHeaderIcon === true ) {\n            gridOptions.headerHeight = 'XXLARGE';\n        }\n\n        var _loadTreeProperties = function( propertyLoadRequest ) {\n            var propertyLoadInput = awTableSvc.createPropertyLoadInput( [ propertyLoadRequest ] );\n            return propertyProvider.getProperties( dataCtxNode, propertyLoadInput ).then( function( propertyLoadResult ) {\n                if( dataProvider.topNodeUid ) {\n                    _.forEach( propertyLoadResult.updatedNodes, function( vmo ) {\n                        if( vmo.uid === dataProvider.topNodeUid ) {\n                            // Assign on props doesn't work if it's undefined, doing this for now to make it work.\n                            if( dataProvider.topTreeNode.props === undefined ) {\n                                dataProvider.topTreeNode.props = {};\n                            }\n\n                            _.assign( dataProvider.topTreeNode.props, vmo.props );\n                        }\n                        // Reset edit state since props have loaded\n                        viewModelObjectService.setEditState( vmo, false );\n                        delete vmo.isPropLoading;\n                    } );\n                    if( propertyLoadResult.updatedNodes ) {\n                        tableInstance.refresh();\n                    }\n                }\n                if( !propertyLoadResult.columnConfig ) {\n                    // Notify table to refresh if no columnConfig change to reflect new prop values in vmos\n                    tableInstance.refresh();\n                } else if( propertyLoadResult.columnConfig.columns.length !== dataProvider.cols.length ) {\n                    /** revisitme Shaishav: Can we make the new condition similar to old condition? Will there\n                       * be extra refreshes because of new condition?\n                       * tstark - leave for refactor\n                  //} else if( !_.isEqual( propertyLoadResult.columnConfig.columns, dataProvider.columnConfig.columns ) ) {\n                       */\n                    // LCS-178290 - Redundant refresh in page load\n                    // Do column Refresh only in the case we have new columnConfig from server\n                    columnProvider.buildDynamicColumns( propertyLoadResult.columnConfig.columns, true ).then( () => {\n                        tableInstance.resetColumns();\n                    } );\n                }\n\n                if( util.shouldRequestStartEditPropsLoaded( tableElem ) ) {\n                    util.requestStartEdit( tableElem );\n                }\n            } );\n        };\n\n        var _loadProps = _.debounce( function( emptyVMOs ) {\n            /**\n              * Since debounced functions have a slight chance of being fired off after a maxWait and after the\n              * declViewModelhas been destroyed (and before the debounce 'cancel' function is called), we want to\n              * check for that case here.\n              */\n\n            if( declViewModel.isDestroyed() ) {\n                return;\n            }\n\n            /**\n              * Include 'top' node if it does not have 'props' set yet.\n              */\n            if( !dataProvider.topTreeNode.props ) {\n                var topNodeUid = dataProvider.topTreeNode.uid;\n\n                var foundTop = false;\n\n                for( var i = 0; i < emptyVMOs.length; i++ ) {\n                    if( emptyVMOs[ i ].uid === topNodeUid ) {\n                        foundTop = true;\n                        break;\n                    }\n                }\n\n                if( !foundTop ) {\n                    emptyVMOs.push( dataProvider.topTreeNode );\n                }\n            }\n\n            // Return if there are no props to load\n            if( emptyVMOs.length === 0 ) {\n                return;\n            }\n\n            var columnInfos = [];\n\n            _.forEach( dataProvider.cols, function( columnInfo ) {\n                if( !columnInfo.isTreeNavigation ) {\n                    columnInfos.push( columnInfo );\n                }\n            } );\n\n            _.forEach( emptyVMOs, function( vmo ) {\n                vmo.isPropLoading = true;\n            } );\n\n            var propertyLoadRequest = {\n                parentNode: null,\n                childNodes: emptyVMOs,\n                columnInfos: columnInfos\n            };\n\n            _loadTreeProperties( propertyLoadRequest );\n        }, 500, {\n            maxWait: 10000,\n            trailing: true,\n            leading: false\n        } );\n\n        var initializeProvider = function( dataProvider, columnProvider, passedState ) {\n            return columnProvider.initialize( passedState ).then( function( dynamicColumns ) {\n                dataProvider.cols = dataProvider.cols ? dataProvider.cols : dynamicColumns;\n                /**\n                  * Dont re-initialize DP if it already exists => Doesn't matter if empty table or table with rows\n                  */\n                if( dataProvider.json && dataProvider.json.firstPage ) {\n                    /**\n                      * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n                      * tstark - leave for refactor\n                      * Delete firstPage results only on dataProvider reset\n                     // If first page but no data loaded in loadedVMObjects, try viewModelSvc executing the dataprovider\n                     if( dataProvider.json.firstPage.length > 0 && dataProvider.viewModelCollection &&\n                         dataProvider.viewModelCollection.loadedVMObjects && dataProvider.viewModelCollection.loadedVMObjects.length === 0 ) {\n                             viewModelSvc.executeCommand( declViewModel, declGrid.dataProvider, $scope );\n                     }\n                     */\n                    // Do Nothing\n                    return null;\n                }\n\n                return dataProvider.initialize( dataCtxNode ).then( function() {\n                    if( !dataProvider.cols || dataProvider.cols.length === 0 ) {\n                        if( !dataProvider.columnConfig ) {\n                            return Promise.reject( new Error( 'Column config not loaded' ) );\n                        }\n                        return columnProvider.buildDynamicColumns( dataProvider.columnConfig.columns, true );\n                    }\n                    return null;\n                } );\n            } );\n        };\n\n        tableCallbacks.completeInitialization = () => {\n            if( dataProvider.columnConfig ) {\n                dataProvider.initializationComplete = 'InProgress';\n                return columnProvider.buildDynamicColumns( dataProvider.columnConfig.columns, true ).then( () => {\n                    var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n                    if( declGridObj.reusable ) {\n                        gridContextDispatcher = declGridObj.gridContextDispatcher;\n                    }\n                    tableInstance = splmTableFactory.createTableObject(\n                        element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight,\n                        gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox\n                    );\n                    tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    tableInstance.resetColumns();\n                    tableInstance.viewModelCollection = viewModelCollection;\n                    tableInstance.refresh();\n                    initializeObserver();\n                    tableElem = tableInstance.getTableElement();\n                    dataProvider.initializationComplete = true;\n                    if( declGridObj.containerHeight ) {\n                        tableInstance.updateContainerHeight( declGridObj.containerHeight );\n                    }\n                    // Event Interface to rerender the table with data currently on the client\n                    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.clientRefresh', function() {\n                        _.defer( function() {\n                            tableInstance.showCheckBox = declGridObj.showCheckBox;\n                            if ( tableElem && tableElem._tableInstance ) {\n                                tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n                            }\n                            util.cleanupComponents( element );\n                            tableInstance.refresh();\n                        } );\n                    } ) );\n                } );\n            }\n        };\n\n        tableCallbacks.updateTableColumns = ( updatedColumns ) => {\n            if( updatedColumns && updatedColumns.length > 0 ) {\n                columnProvider.buildDynamicColumns( updatedColumns, true ).then( () => {\n                    if( tableInstance !== null ) {\n                        tableInstance.resetColumns();\n                    }\n                } );\n            }\n        };\n\n        tableCallbacks.updateContentRowSelection = () => {\n            tableInstance && tableInstance.updateContentRowSelection();\n        };\n\n        tableCallbacks.selectTableColumn = ( columnDef ) => {\n            if( columnDef ) {\n                splmTableSelectionHelper.selectColumnCells( tableInstance.getTableElement(), columnDef.field );\n            }\n        };\n\n        tableCallbacks.updateSortDirection = ( currentColumnIndex, newColumnIndex, sortDirection ) => {\n            if( newColumnIndex > -1 ) {\n                tableInstance && tableInstance.updateSortDirection( currentColumnIndex, newColumnIndex, sortDirection );\n                reloadDataProvider();\n            }\n        };\n\n        tableCallbacks.updateDynamicRowHeight = ( dynamicRowHeightStatus ) => {\n            tableInstance && tableInstance.updateDynamicRowHeight( dynamicRowHeightStatus );\n        };\n\n        tableCallbacks.updatePinColumn = ( columnDef, isFreezeAction, defaultColumnPinIndex ) => {\n            if( columnDef && defaultColumnPinIndex > -1 ) {\n                tableInstance && tableInstance.updatePinColumn( columnDef, isFreezeAction, defaultColumnPinIndex );\n            }\n        };\n\n        tableCallbacks.hideColumn = ( columnDef ) => {\n            if( columnDef ) {\n                tableInstance && tableInstance.hideColumn( columnDef );\n            }\n        };\n\n        tableCallbacks.columnFilterApplied = ( columnFilterInfo ) => {\n            // viewModel columnProvider needed because columnFilters with be needed by the viewModel action inputs\n            // revisitme - Send event to all application listeners, remove when converted\n            const eventData = {\n                isInternalTableEvent: true,\n                gridId: gridid,\n                ...columnFilterInfo\n            };\n            eventBus.publish( 'pltable.columnFilterApplied', eventData );\n            const menuService = util.getTableMenuService( tableElem );\n            menuService.ensureAllTableMenusDismissed();\n            if( columnFilterInfo.filters && columnFilterInfo.filters.length ) {\n                columnFilterService.setFilters( columnProvider, dataProvider, columnFilterInfo.filters, columnFilterInfo.column );\n            } else if( columnFilterInfo.column ) {\n                columnFilterService.removeFilter( columnFilterInfo.column, columnProvider, dataProvider );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n            dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied( dataProvider );\n            const columnName = columnFilterInfo.column ? columnFilterInfo.column.field : null;\n            tableInstance.updateFilterIcons( columnName );\n            reloadDataProvider();\n        };\n\n        tableCallbacks.editStateUpdated = () => {\n            const data = {\n                dataSource: dataProvider,\n                state: dataProvider._editingState\n            };\n            tableInstance.updateEditState( data );\n        };\n\n        tableCallbacks.updateEditState = async( props ) => {\n            if( props && props.tableContext ) {\n                if ( props.tableContext.startEdit && props.tableContext.startEdit.value === true ) {\n                    await dataProvider.startEdit( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.startEdit.update ) {\n                        props.tableContext.startEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( true );\n                    }\n                } else if ( props.tableContext.cancelEdit && props.tableContext.cancelEdit.value === true ) {\n                    await dataProvider.cancelEdits( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.cancelEdit.update ) {\n                        props.tableContext.cancelEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( false );\n                    }\n                } else if ( props.tableContext.saveEdit && props.tableContext.saveEdit.value === true ) {\n                    await dataProvider.saveEdits( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.saveEdit.update ) {\n                        props.tableContext.saveEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( false );\n                    }\n                }\n            }\n        };\n\n        const initializeObserver = () => {\n            if( resizeObserverSvc.supportsResizeObserver() ) {\n                const callback = _.debounce( () => {\n                    eventBus.publish( gridid + '.plTable.resizeCheck' );\n                }, 200, {\n                    maxWait: 10000,\n                    trailing: true,\n                    leading: false\n                } );\n                resizeObserverSvc.observe( element, callback );\n            }\n        };\n\n        if( gridOptions.useTree === true ) {\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.loadProps', function( eventData ) {\n                _loadProps( eventData.VMOs );\n            } ) );\n\n            instanceEventSubcr.push( eventBus.subscribe( 'primaryWorkarea.reloadTop', function( event ) {\n                var clearAllStates = !( event && event.retainAllStates );\n\n                if( clearAllStates ) {\n                    awTableStateSvc.clearAllStates( declViewModel, gridid );\n                }\n\n                /*\n                  * delete firstPage results if any before re-initializing dataProvider\n                  */\n                if( dataProvider.json.firstPage ) {\n                    delete dataProvider.json.firstPage;\n                }\n\n                dataProvider.initialize( dataCtxNode );\n            } ) );\n\n            const toggleTreeNode = function( node ) {\n                if( !node.loadingStatus ) {\n                    node.loadingStatus = true;\n                    tableInstance.updateTreeCellIcon( node );\n                    // get the current copy of data\n                    Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n                    if( node.isExpanded === true ) {\n                        tableInstance.setNodeExpansionInProgress( true );\n                        node._expandRequested = true;\n                        var preExpandVMObjectsLength = dataProvider.viewModelCollection.loadedVMObjects.length;\n                        dataProvider.expandObject( dataCtxNode, node ).then( function( updatedViewModelCollection ) {\n                            // LCS-180794: If Expand did not return any new objects or\n                            //if node has previous expansion state and dataProvider.cacheCollapse=true which means it didn't get new objects from server,\n                            // continue updating the rest of the table\n                            tableInstance.setNodeExpansionInProgress( false );\n                            if( preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length ) {\n                                delete node.loadingStatus;\n                                tableInstance.refresh();\n                            }\n                            //view model collection is updated so update table with new set of VMOs.\n                            dataProvider.update( updatedViewModelCollection.loadedVMObjects );\n                        } ).finally( function() {\n                            // Make sure even when errored that the expansion in progress is set to false\n                            tableInstance.setNodeExpansionInProgress( false );\n                            //ensure properties are loaded after expansion\n                            // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n                            // render the rows. The row rendering will then occur once they props have been loaded.\n                            tableInstance.loadMissingProps();\n                            delete node.loadingStatus;\n                            delete node._expandRequested;\n                            tableInstance.updateTreeCellIcon( node );\n                            tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n                            if( util.shouldRequestStartEditTreeExpand( tableElem, node, propertyProvider ) ) {\n                                util.requestStartEdit( tableElem );\n                            }\n                        } );\n                        awTableStateSvc.saveRowExpanded( declViewModel, gridid, node );\n                    } else {\n                        dataProvider.collapseObject( dataCtxNode, node ).then( function( updatedViewModelCollection ) {\n                            dataProvider.update( updatedViewModelCollection.loadedVMObjects );\n                            if( preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length ) {\n                                tableInstance.refresh();\n                            }\n                        } ).finally( function() {\n                            delete node.loadingStatus;\n                            tableInstance.updateTreeCellIcon( node );\n                            tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n                        } );\n                        awTableStateSvc.saveRowCollapsed( declViewModel, gridid, node );\n                    }\n                }\n            };\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.toggleTreeNode', toggleTreeNode ) );\n            if( declGridObj.reusable ) {\n                tableInstanceCallbacks.toggleTreeNode = toggleTreeNode;\n            }\n\n            const doFocusPlaceHolder = function( vmNode ) {\n                var vmCollection = dataProvider.viewModelCollection;\n                var cursorNdx = vmCollection.findViewModelObjectById( uwUtilSvc.getEvaluatedId( vmNode ) );\n                /**\n                 * Find 'parent' node of the 'placeholder' node in the vmCollection\n                 */\n                var phParentNode = null;\n                var cursorNode = vmCollection.getViewModelObject( cursorNdx );\n                var parentLevelNdx = cursorNode.levelNdx - 1;\n                if( parentLevelNdx === -1 ) {\n                    phParentNode = dataProvider.topTreeNode;\n                } else {\n                    for( var rowNdx = cursorNdx - 1; rowNdx >= 0; rowNdx-- ) {\n                        var currRow = vmCollection.getViewModelObject( rowNdx );\n                        if( currRow.levelNdx === parentLevelNdx ) {\n                            phParentNode = currRow;\n                            break;\n                        }\n                    }\n                }\n                if( phParentNode === null ) {\n                    return null;\n                }\n                /**\n                 * Load, using the 'focusAction', the siblings of the 'placeholder' in the context of its immediate\n                 * 'parent'.\n                 * <P>\n                 * Note: We want to use a smaller page size here to minimize the loading.\n                 */\n                var treeLoadInput = awTableSvc.createTreeLoadInput( phParentNode, 0, null, vmNode.id, dataProvider.treePageSize, true, null );\n                var loadIDs = {\n                    t_uid: dataProvider.topTreeNode.uid,\n                    o_uid: phParentNode.uid,\n                    c_uid: vmNode.uid,\n                    uid: null\n                };\n                var actionRequestObj = {\n                    treeLoadInput: treeLoadInput,\n                    loadIDs: loadIDs\n                };\n                /**\n                 * Change 'suffix' text to indicate we are attempting to load more rows.\n                 */\n                vmNode.loadingStatus = true;\n                // get the current copy of data\n                Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n                return dataProvider.someDataProviderSvc.executeLoadAction( dataProvider.nextAction,\n                    dataProvider.json, dataCtxNode, actionRequestObj ).then( function( response ) {\n                    /**\n                     * Locate cursor node in original collection & find/collect all contained 'child' nodes.\n                     */\n                    var cursorId = uwUtilSvc.getEvaluatedId( cursorNode );\n                    var cursorLevel = cursorNode.levelNdx;\n                    var vmCollection = dataProvider.viewModelCollection;\n                    var cursorNdxInOrig = vmCollection.findViewModelObjectById( cursorId );\n                    var loadedVMObjects = vmCollection.loadedVMObjects;\n                    var cursorVMObjects = [ loadedVMObjects[ cursorNdxInOrig ] ];\n                    for( var l = cursorNdxInOrig + 1; l < loadedVMObjects.length; l++ ) {\n                        var currNode = loadedVMObjects[ l ];\n                        if( currNode.levelNdx <= cursorLevel ) {\n                            break;\n                        }\n                        cursorVMObjects.push( currNode );\n                    }\n                    /**\n                     * Re-order the childNdx values of the sibling nodes relative to initial placeholder as 0;\n                     */\n                    var treeLoadResult = response.actionResultObj.responseObj.treeLoadResult;\n                    var newVMObjects = treeLoadResult.childNodes;\n                    var cursorNdxInNew = 0;\n                    for( var i = 0; i < newVMObjects.length; i++ ) {\n                        if( newVMObjects[ i ].id === cursorId ) {\n                            cursorNdxInNew = i;\n                            break;\n                        }\n                    }\n                    for( var j = 0; j < newVMObjects.length; j++ ) {\n                        newVMObjects[ j ].childNdx = j - cursorNdxInNew;\n                    }\n                    /**\n                     * Check if the 'fresh' cursor node is at either end of the 'sibling' list and is now known to be an\n                     * 'incompleteHead' or 'incompleteTail'\n                     * <P>\n                     * If so: Move that status over to the 'original' cursor node.\n                     * <P>\n                     * Note: We are about to replace the 'fresh' node in the set of its siblings just returned and we do\n                     * not want to lose this important information.\n                     */\n                    if( cursorNdxInNew === 0 && newVMObjects[ 0 ].incompleteHead ) {\n                        cursorNode.incompleteHead = true;\n                    }\n                    var lastNodeNdx = newVMObjects.length - 1;\n                    if( cursorNdxInNew === lastNodeNdx && newVMObjects[ lastNodeNdx ].incompleteTail ) {\n                        cursorNode.incompleteTail = true;\n                    }\n                    /**\n                     * Make sure the placeholder 'parent' node gets its 'children' set (a shallow clone is good enough).\n                     * <P>\n                     * Replace the 'fresh' cursor node with the 'original' cursor node since it holds important state\n                     * and hierarchy info.\n                     */\n                    phParentNode.children = _.clone( newVMObjects );\n                    phParentNode.children[ cursorNdxInNew ] = cursorNode;\n                    /**\n                     * Remove the 'fresh' cursor node from the array of its siblings.\n                     * <P>\n                     * Insert the cursor node (and all of its children from the original array) into the array of new\n                     * nodes.\n                     * <P>\n                     * Remove the cursor node (and all of its children) from the original array\n                     * <P>\n                     * Insert the new nodes (updated with the cursor node and all of its children from the original\n                     * array) into the vmCollection array of nodes.\n                     * <P>\n                     * Clear the loading status of the cursor node.\n                     */\n                    newVMObjects.splice( cursorNdxInNew, 1 );\n                    // LCS-230184 - In the case where no changes are made to the loadedVMObjects, we must manually refresh\n                    // so that the table can process the remaining rendered nodes for more focus placeholder, expansion\n                    // restoration, or prop loading.\n                    if( newVMObjects.length === 0 ) {\n                        delete vmNode.loadingStatus;\n                        delete vmNode._focusRequested;\n                        tableInstance.refresh();\n                        return;\n                    }\n                    var insertNdx = cursorNdxInNew - 1;\n                    arrayUtils.insert( newVMObjects, insertNdx, cursorVMObjects );\n                    loadedVMObjects.splice( cursorNdxInOrig, cursorVMObjects.length );\n                    arrayUtils.insert( loadedVMObjects, cursorNdxInOrig - 1, newVMObjects );\n                    delete vmNode.loadingStatus;\n                    delete vmNode._focusRequested;\n                    dataProvider.update( loadedVMObjects );\n                    /**\n                     * Fire a 'treeNodesLoaded' event, sourced to the uwDataProvider, for all tree-table changes. This\n                     * event includes only the input/result structures for the current load operation. This event is\n                     * used to load additional properties in an async fashion.\n                     */\n                    eventBus.publish( dataProvider.name + '.treeNodesLoaded', {\n                        treeLoadInput: treeLoadInput,\n                        treeLoadResult: treeLoadResult\n                    } );\n                    /**\n                     * Fire a 'modelObjectsUpdated' event, sourced to the uwDataProvider, for all tree-table changes.\n                     * This event includes the complete array of nodes in the collection.\n                     */\n                    eventBus.publish( dataProvider.name + '.modelObjectsUpdated', {\n                        viewModelObjects: loadedVMObjects,\n                        noResults: false\n                    } );\n                } );\n            };\n            tableInstanceCallbacks.doFocusPlaceHolder = doFocusPlaceHolder;\n        } else {\n            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.modelObjectsUpdated', function( event ) {\n                if ( event && !event.arrangeColumnEvent ) {\n                    tableCallbacks.columnsArranged( event );\n                }\n            } ) );\n        }\n\n        tableCallbacks.columnsArranged = ( columnArrangeData ) => {\n            if( columnArrangeData.arrangeType && columnArrangeData.arrangeType === 'saveColumnAndLoadAction' && columnArrangeData.viewModelObjects ) {\n                // Just update data provider with vmos changed by columnArrangeService\n                tableInstance.resetInfiniteScroll();\n                dataProvider.update( columnArrangeData.viewModelObjects, columnArrangeData.totalFound );\n                // Need to refresh the table since there is no watch anymore on loadedVMObjects\n                tableInstance.refresh();\n            }\n        };\n\n        /**\n          * Subscribe to resetState. Clear all states and set isFocusedLoad to true.\n          */\n        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.resetState', function() {\n            awTableStateSvc.clearAllStates( declViewModel, gridid );\n            dataProvider.isFocusedLoad = true;\n        } ) );\n\n        cfgSvc.get( 'propertyRendererTemplates' );\n        initializeProvider( dataProvider, columnProvider, dataCtxNode ).then( () => {\n            var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n            if( declGridObj.reusable ) {\n                gridContextDispatcher = declGridObj.gridContextDispatcher;\n            }\n            tableInstance = splmTableFactory.createTableObject(\n                element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight,\n                gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox\n            );\n            tableInstance.showCheckBox = declGridObj.showCheckBox;\n            tableElem = tableInstance.getTableElement();\n            initializeObserver();\n            // Following refresh is for cases like object sets. Where first page is already loaded by stylesheet SOA\n            tableInstance.viewModelCollection = viewModelCollection;\n            tableInstance.refresh();\n\n            dataProvider.initializationComplete = true;\n\n            if( declGridObj.containerHeight ) {\n                tableInstance.updateContainerHeight( declGridObj.containerHeight );\n            }\n\n            // Event Interface to rerender the table with data currently on the client\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.clientRefresh', function() {\n                _.defer( function() {\n                    tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    if ( tableElem && tableElem._tableInstance ) {\n                        tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    }\n                    util.cleanupComponents( element );\n                    tableInstance.refresh();\n                } );\n            } ) );\n        }, error => {\n            dataProvider.initializationComplete = false;\n            logger.trace( error );\n        } );\n    }\n\n    instanceEventSubcr.push( eventBus.subscribe( 'columnArrange', function( eventData ) {\n        if( eventData.name === gridid || eventData.columnConfigId && dataProvider.columnConfig && eventData.columnConfigId === dataProvider.columnConfig.columnConfigId ) {\n            if( eventData.columns.length ) {\n                tableInstance.removeStaleFilters( eventData.columns );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n        }\n        if ( tableInstance.getDynamicRowHeightStatus() ) {\n            tableInstance.resetDynamicRowHeights();\n        }\n    } ) );\n\n    var relatedModifiedEvent = eventBus.subscribe( 'cdm.relatedModified', function( eventData ) {\n        tableInstance.relatedModified();\n    } );\n\n    instanceEventSubcr.push( relatedModifiedEvent );\n\n    // Event Interface to rerender table with reloaded data from the dataprovider\n    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.reload', reloadDataProvider ) );\n\n    // revisitme - tstark - Need to keep event until all application teams convert away from events\n    instanceEventSubcr.push( eventBus.subscribe( 'pltable.columnFilterApplied', function( eventData ) {\n        if( gridid === eventData.gridId && eventData.isInternalTableEvent !== true ) {\n            if( eventData.filters && eventData.filters.length ) {\n                columnFilterService.setFilters( columnProvider, dataProvider, eventData.filters, eventData.column );\n            } else if( eventData.column ) {\n                columnFilterService.removeFilter( eventData.column, columnProvider, dataProvider );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n            dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied( dataProvider );\n            const columnName = eventData.column ? eventData.column.field : null;\n            tableInstance.updateFilterIcons( columnName );\n            reloadDataProvider();\n        }\n    } ) );\n\n    tableCallbacks.updateColumnMenuData = function( columnMenuData ) {\n        _.forEach( dataProvider.cols, function( currentColumn ) {\n            if( columnMenuData.columnName === currentColumn.field ) {\n                currentColumn.filter = { ...currentColumn.filter, ...columnMenuData };\n                currentColumn.filter.columnMenuData = columnMenuData;\n                if ( currentColumn.filter.showFilters ) {\n                    if( currentColumn.filter.showFilters.dbValue && currentColumn.filter.showFilters.dbValue !== 'false' ) {\n                        currentColumn.filter.showFilterFacets = true;\n                    } else {\n                        currentColumn.filter.showFilterFacets = false;\n                    }\n                }\n                return false;\n            }\n        } );\n    };\n\n    // revisitme - tstark - Need to keep event until all application teams convert away from events\n    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.setFilterDisability', function( eventData ) {\n        if( gridid === eventData.gridId ) {\n            tableInstance.setFilterDisability( eventData.isFilterDisabled );\n        }\n    } ) );\n\n    /**\n      *  destroy the table\n      */\n    tableCallbacks.destroy = function() {\n        var columns = [];\n        if( dataProvider.columnConfig && dataProvider.columnConfig.columns ) {\n            columns = dataProvider.columnConfig.columns;\n        }\n        _.forEach( instanceEventSubcr, function( eventBusSub ) {\n            eventBus.unsubscribe( eventBusSub );\n        } );\n        splmTableFactory.destroyTable( gridid, element, columns );\n    };\n\n    tableCallbacks.updateVmCollection = ( viewModelCollection ) => {\n        if( tableInstance ) {\n            tableInstance.viewModelCollection = viewModelCollection;\n            if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                util.requestStartEdit( tableElem );\n            }\n            tableInstance.refresh();\n        }\n    };\n\n    tableCallbacks.updateDeclGridObject = ( declGridParam ) => {\n        declGridObj = declGridParam;\n    };\n\n    tableCallbacks.updateMenuContext = ( menuContext ) => {\n        declGridObj.menuContext = menuContext;\n    };\n\n    tableCallbacks.updateState = ( newState ) => {\n        declViewModel = newState;\n        if( tableInstance ) {\n            tableInstance.updateInstanceState( newState );\n        }\n    };\n\n    tableCallbacks.refreshTable = () => {\n        if( tableInstance ) {\n            tableInstance.refresh();\n        }\n    };\n\n    tableCallbacks.updateGridOptionsForTableInstance = ( props ) => {\n        if( tableElem && tableElem._tableInstance && props && props.showCheckBox !== undefined ) {\n            tableElem._tableInstance.showCheckBox = props.showCheckBox;\n        }\n    };\n\n    /**\n      * Setup to react to changes in selection within the dataProvider.\n      *\n      * @param {Object} event -\n      * @param {Object} data -\n      */\n    instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectionChangeEvent', function( event ) {\n        var selections = event.selectionModel.getSelection();\n        // Set scroll to row in progress\n        if( dataProvider.isFocusedLoad === true && selections.length > 0 ) {\n            dataProvider.isFocusedLoad = false;\n            dataProvider.scrollToRow = true;\n        }\n\n        if( selections.length > 0 && selections.length >= _previousSelections.length && _.isEqual( _previousSelections, selections ) === false ||\n             dataProvider.scrollToRow === true ) {\n            dataProvider.scrollToRow = true;\n            eventBus.publish( 'plTable.scrollToRow', {\n                gridId: gridid,\n                rowUids: selections\n            } );\n        }\n        _previousSelections = selections.slice();\n    } ) );\n    var pageLoadInProgress = false;\n\n    const getTreeNodePageCallback = function( results ) {\n        logger.trace( 'AW simple table: Loaded next tree page data' );\n        pageLoadInProgress = false;\n        if( util.shouldRequestStartEditTreePagination( tableElem, propertyProvider ) ) {\n            util.requestStartEdit( tableElem );\n        }\n        dataProvider.update( results.loadedVMObjects, results.totalFound );\n    };\n\n    // eslint-disable-next-line complexity\n    const loadMorePages = function( eventData ) {\n        if( tableInstance.viewModelCollection ) {\n            var lastItemIndex = eventData.lastRenderedItem.index;\n            // get the current copy of data\n            Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n            if( lastItemIndex !== 0 && lastItemIndex === tableInstance.viewModelCollection.loadedVMObjects.length - 1 ) {\n                if( dataProvider.nextAction || dataProvider.action ) {\n                    var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                    if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                        delete lastNode.incompleteTail;\n                        if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                            pageLoadInProgress = true;\n                            dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                            return;\n                        }\n                        pageLoadInProgress = true;\n                        dataProvider.pageDispatcher( { type: 'NEXT_PAGE' } );\n                        return;\n                    }\n                    logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                }\n            }\n            var firstItemIndex = eventData.firstRenderedItem.index;\n            if( firstItemIndex === 0 ) {\n                if( dataProvider.previousAction ) {\n                    var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                    if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                        delete firstNode.incompleteHead;\n                        tableInstance.maintainScrollPosition();\n                        if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                            pageLoadInProgress = true;\n                            dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                            return;\n                        }\n                        pageLoadInProgress = true;\n                        dataProvider.pageDispatcher( { type: 'PREVIOUS_PAGE' } );\n                        return;\n                    }\n                    logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                }\n            }\n            // Check for incomplete head/tail on tree node in rendered range\n            if( gridOptions.useTree === true ) {\n                var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                    var loadNextPage = incompleteNode.incompleteTail === true;\n                    if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                        return;\n                    } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                        return;\n                    }\n                    delete incompleteNode.incompleteHead;\n                    delete incompleteNode.incompleteTail;\n                    pageLoadInProgress = true;\n                    dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                    return;\n                }\n            }\n        }\n        /** revisitme Radhika: We havesome logic below around pageLoadInProgress. We might need some\n           * tstark - leave for refactor\n               * in the new system. The code needs to be cleaned up and the necessary lines needs to be reused\n              if( dataProvider.viewModelCollection && pageLoadInProgress === false ) {\n                  // Check if next page should be loaded\n                  var lastItemIndex = eventData.lastRenderedItem.index;\n                  if( lastItemIndex !== 0 && lastItemIndex === dataProvider.viewModelCollection.loadedVMObjects.length - 1 ) {\n                      if( dataProvider.nextAction || dataProvider.action ) {\n                          var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                          if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                              delete lastNode.incompleteTail;\n                              if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n                              /**\n                               * REFACTOR: This is how UI Grid checks to see if we actually have more pages to load or not since\n                               * dataProvider.hasMorePages() will always return true, because it sets dataProvider.update(firstPageObjs, firstPageObjs.length + 1)\n                               * in dataProviderFactory and uses these two values for checking for if more pages to load or not.\n                               * Will remove this code in 4.2 when all UIgrid replaced by PL Table\n                              var maxToLoad;\n                              if( dataProvider.action && dataProvider.action.inputData ) {\n                                  var actionInputData = dataProvider.action.inputData;\n                                  if( actionInputData.searchInput ) {\n                                      maxToLoad = actionInputData.searchInput.maxToLoad;\n                                  }\n                              }\n\n                              /**\n                               *\n                               * If we have a firstPage and its length is less than maxToLoad, we dont need to load another page.\n                               * All other cases, handle like normally => Try to get next page of data\n                               *\n                              if( maxToLoad && dataProvider.json.firstPage && dataProvider.json.firstPage.length < maxToLoad ) {\n                                  logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                              } else {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getNextPage( dataCtxNode ).then( function() {\n                                      logger.trace( 'AW simple table: Loaded next page data' );\n                                      pageLoadInProgress = false;\n                                      if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                          util.requestStartEdit( tableElem );\n                                      }\n                                  } );\n                                  return;\n                              }\n                          } else {\n                              logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                          }\n                      }\n                  }\n\n                  // Check if previous page should be loaded as long as next page has not already been requested\n                  var firstItemIndex = eventData.firstRenderedItem.index;\n                  if( firstItemIndex === 0 ) {\n                      if( dataProvider.previousAction ) {\n                          var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                          if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                              delete firstNode.incompleteHead;\n                              eventBus.publish( dataProvider.name + '.plTable.maintainScrollPosition' );\n                              if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n\n                              pageLoadInProgress = true;\n                              dataProvider.getPreviousPage( dataCtxNode ).then( function() {\n                                  logger.trace( 'AW simple table: Loaded previous page data' );\n                                  pageLoadInProgress = false;\n                                  if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                      util.requestStartEdit( tableElem );\n                                  }\n                              } );\n                              return;\n                          }\n\n                          logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                      }\n                  }\n\n                  // Check for incomplete head/tail on tree node in rendered range\n                  if( gridOptions.useTree === true ) {\n                      var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                      if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                          var loadNextPage = incompleteNode.incompleteTail === true;\n                          if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                              return;\n                          } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                              return;\n                          }\n                          delete incompleteNode.incompleteHead;\n                          delete incompleteNode.incompleteTail;\n                          pageLoadInProgress = true;\n                          dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                          return;\n                      }\n                  }\n              }\n          */\n    };\n    tableInstanceCallbacks.loadMorePages = loadMorePages;\n\n    let unsetScrollToRowIndex = function() {\n        tableInstance.unsetScrollToRowIndex();\n    };\n\n    tableInstanceCallbacks.unsetScrollToRowIndex = unsetScrollToRowIndex;\n\n\n    let columnsRearranged = function( eventData ) {\n        tableInstance.columnsRearranged( eventData );\n    };\n\n    tableInstanceCallbacks.columnsRearranged = columnsRearranged;\n\n    let columnsResized = function( eventData ) {\n        tableInstance.columnsResized( eventData );\n    };\n\n    tableInstanceCallbacks.columnsResized = columnsResized;\n\n    return tableCallbacks;\n};\n\nexport default {\n    initializeTable\n};\n"]},"metadata":{},"sourceType":"module"}