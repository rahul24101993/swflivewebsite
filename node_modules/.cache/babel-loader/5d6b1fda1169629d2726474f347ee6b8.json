{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-disable require-jsdoc */ /**\n * @module js/reactPopup\n */import AwPromiseService from'js/awPromiseService';import{consolidateOptions}from'js/popupService';import{Tooltip}from'js/tooltip';import React,{useState,useRef,useEffect}from'react';import{useInitHook}from'js/reactHelper';import _ from'lodash';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";const hasStaticReference=reference=>reference&&(_.isString(reference)||Boolean(reference.nodeName));const usePopupInternal=initialOptions=>{// the reference element which has the popup - could be static or dynamic\n// 1, static - existed, selector or native dom element, eg: 'div.sw-logoImage'\n// 2, dynamic - will be generated, vdom element\nlet reference=useRef(null);if(hasStaticReference(initialOptions.reference)){reference=initialOptions.reference;}let uuid=useRef(null);// the popup element\nlet popupReference=useRef(null);// enable popup api return promise\nlet[showDeferred,hideDeferred]=[useRef(null),useRef(null)];// popup options - only initialize once, call updateOptions to update the options\nlet baseOptions=consolidateOptions({...initialOptions,popupReference,reference,showDeferred,hideDeferred,uuid},hide,updateOptions);// could change incrementally\nlet currentOptions=baseOptions;const[options,setOptions]=useState(baseOptions);useEffect(()=>{if(options.open&&popupReference.current){let componentWillUnMounted=options.componentMounted(options,popupReference.current);return()=>componentWillUnMounted();}return undefined;},[options.open]);// support dynamic popup reference\nuseEffect(()=>{updateOptions({reference});},[reference.current]);function show(){let newOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// avoid event being passed in, cases of <Component action={popup.show} />\nnewOptions&&newOptions.type&&(newOptions=null);// always use base options for global popup\nconst base=baseOptions.global?baseOptions:options;// mix-in new options if any\nnewOptions&&Object.keys(newOptions).length>0&&(currentOptions=consolidateOptions({...base,...newOptions}));// run beforeOpen check to ensure whether need to change state\n// `force === true` to skip beforeOpen check\nlet condition=force||currentOptions.beforeOpen();// exclude toggleMode case  - null\n// exclude multiple case    - popupRef\nif(condition===true){updateOptions(Object.assign(currentOptions,{open:true}));}showDeferred.current=AwPromiseService.instance.defer();hideDeferred.current=AwPromiseService.instance.defer();return showDeferred.current.promise;}function hide(){updateOptions({open:false});// case null hideDeferred.current - means already being closed, return directly\nreturn hideDeferred.current?hideDeferred.current.promise:Promise.resolve(true);}function updateOptions(newOptions){setOptions(prev=>{// always return independent options for global case\nif(newOptions.global){return newOptions;}return{...prev,...newOptions};});}return{// popup state and options\nopen:options&&options.open,options,// getter - the reference element which owns the popup\nreference,// popup APIs - the apis to show / hide popup\nshow,hide,update:updateOptions};};const usePopup=function(initialOptions){initialOptions=initialOptions||{};const popup=usePopupInternal(initialOptions);popup.userOptions=useRef(null);// mount\nuseInitHook(()=>{if(initialOptions.preset==='tooltip'){// tipWrapper.hooks to support tooltip move-in feature\n// popup.userOptions - dynamic user options\n// for debug: to quick enable / disable tooltip\n// let show = () => null;\n// let hide = () => null;\nlet show=()=>popup.show({...tipWrapper.hooks,...popup.userOptions.current},true);let hide=()=>popup.hide();const tipWrapper=new Tooltip(popup.reference.current,popup.options,show,hide);// return unmount fn inside of `tipWrapper.configure`\nreturn tipWrapper.configure(tipWrapper);}return undefined;},popup.reference.current);return popup;};const handler={get:(target,key)=>{return target.prototype[key];}};// initialize popups for viewModel based on it's popup actions\nconst usePopups=function(viewModel){const initialOptionsMap=_.reduce(viewModel.declViewModelJson.actions,(result,_ref,actionId)=>{let{actionType,options,inputData}=_ref;actionType==='popup'&&(result[actionId]=inputData&&inputData.options||options);return result;},{});// fixed loop, safe to use.\n// https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function\n_.each(initialOptionsMap,function useLoop(initialOptions,actionId){let fn=initialOptions&&initialOptions.preset==='test'?useTestContent:usePopup;let action=viewModel.actions[actionId];let actionHandler=fn(initialOptions);if(!initialOptions||initialOptions.preset!=='test'){// extend action by proxy\naction.prototype=actionHandler;actionHandler=new Proxy(action,handler);}viewModel.actions[actionId]=actionHandler;});};// test harness for popup, purpose to provide dynamic/rich content to demonstrate the reactivity of popup.\n// remove in future.\nlet i=1;const title=/*#__PURE__*/_jsx(\"div\",{className:\"header-label\",children:\"Lorem ipsum\"});// eslint-disable-next-line max-len\nconst lorem='Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure cillum dolore pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';const testActions=[{action:setter=>()=>setter(prev=>{return{...prev,...{body:generateContent()}};}),label:'Load More Data'},{action:setter=>()=>setter(prev=>{return{...prev,...{body:generateContent(true)}};}),label:'Reset Data'},{action:target=>()=>target.hide(),label:'Close',path:'target'}];const actions=(setter,target,ActionComponent)=>{return/*#__PURE__*/_jsx(\"div\",{children:testActions.map(_ref2=>{let{action,label,path}=_ref2;return/*#__PURE__*/_jsx(ActionComponent,{action:path?action(target):action(setter),className:\"small sample-btn\",children:label},label);})});};const generateContent=function(){let reset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(reset){i=0;}i+=1;const items=Array.from({length:i},(v,i)=>i);return items.reduce((total,item)=>{total.push(/*#__PURE__*/_jsxs(\"p\",{children:[lorem,/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{})]},item));return total;},[]);};// simulate dynamic binding data\n// content could be changed anytime by actions\nconst useTestContent=()=>ActionComponent=>{// eslint-disable-next-line react-hooks/rules-of-hooks\nconst[content,setContent]=useState({header:title,actions:target=>actions(setContent,target,ActionComponent),body:/*#__PURE__*/_jsxs(\"p\",{children:[lorem,/*#__PURE__*/_jsx(\"br\",{}),/*#__PURE__*/_jsx(\"br\",{})]},-1)});return content;};export{usePopup,usePopups,useTestContent};","map":null,"metadata":{},"sourceType":"module"}