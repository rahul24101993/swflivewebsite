{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Module for condition/expression parser utilities\n *\n * @module js/expressionParserUtils\n */import _ from'lodash';import parsingUtils from'js/parsingUtils';import dateParserUtils from'js/dateParserUtils';import Debug from'debug';import AwParseService from'js/awParseService';var trace=new Debug('expressionParserUtils');var exports={};/**\n * Reference to operators in expression objects\n */export let $SOURCE='$source';export let $QUERY='$query';export let $ADAPT='$adapt';export let $ALL='$all';export let $AND='$and';export let $OR='$or';export let $EVENTSOURCE='$eventSource';export let $NOT='$not';/**\n * Map used to point to the utility function name based on the expression\n */var _map_expr2Function={$eq:'equalTo',$lt:'lessThan',$lte:'lessThanOrEqualTo',$gt:'greaterThan',$gte:'greaterThanOrEqualTo',$ne:'notEqualTo',$neq:'notEqualsTo',$in:'within',$notin:'notIn',$isNull:'isNull',$notNull:'notNull',$vlookup:'vlookup',$regexp:'regexp',$notinrange:'notInRange',$notinregexp:'notInRegexp',$typeOf:'typeOf'};/**\n * Gets dbValue for a non array property.\n *\n * @param {Object} prop - property object\n *\n * @return {Object} dbValue of the property\n */var _getDbValueForProp=function(prop){var propValue=null;if(prop&&prop.dbValue){propValue=prop.dbValue;}else if(prop&&prop.dbValues&&prop.dbValues.length>0){propValue=prop.dbValues[0];}return propValue;};/**\n * Traverses given path in the received object and returns the value\n * @param {String} path dot separated path\n * @param {Object} obj object to be traversed for finding the value against received path\n *\n * @return {Object} returns object as resolved by traversing the path inside the object\n */export let resolve=function(path,obj){var resolvedObj;if(path&&_.isString(path)&&obj&&_.isObject(obj)){resolvedObj=path.split('.').reduce(function(prev,curr){return prev?prev=_.get(prev,curr):undefined;},obj);}return resolvedObj;};/**\n * Update dynamic values against the query operator. Ex: \"$eq\": \"{{ctx.selected.props.object_string.dbValues[0]}}\"\n * @param {Object} query Object containing operator as key and value that needs to be resolved from data node\n * @param {Object} dataNode Object used to resolve the values\n * @return {Object} updated query\n */export let updateDynamicValues=function(query,dataNode){// LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n// Do copy only at level 0\n// LCS-168813 - AW404-Comparison use cases fails as color swab is not made available\n// _.clone( var, true ) is not in lodash any more...we should use _.cloneDeep\n// there are still several usage for _.clone(var, true), it gets copied here and that\n// is why we cause the regression.\nvar updatedQuery=_.cloneDeep(query);return updateDynamicValuesInternal(updatedQuery,dataNode);};/**\n *get expression data type\n *\n * @param {object} value - date object\n *\n * @return {String} dataType like - date,string,number\n */export let getExpressionDataType=function(value){try{var dataType;if(value){if(dateParserUtils.isDate(value)){dataType='Date';}else if(_.isNumber(value[0])&&_.isNumber(value[1])){dataType='Number';}else if(_.isString(value[0])&&_.isString(value[1])){dataType='String';}}return dataType;}catch(e){trace('Error in expression',e,value);return undefined;}};var updateDynamicValuesInternal=function(updatedQuery,dataNode){var expression={};var expressionDataType;_.forEach(updatedQuery,function(value,key){if(key==='$notinrange'||dateParserUtils.isDate(value)){expressionDataType=exports.getExpressionDataType(value);if(expressionDataType){expression=dateParserUtils.getExpressionDateValue(value,expressionDataType);updatedQuery.expressionType=expressionDataType;value=expression.value;updatedQuery[key]=expression.value;}}if(_.isString(value)&&_.startsWith(value,'{{')){var dynamicValToResolve=parsingUtils.getStringBetweenDoubleMustaches(value);updatedQuery[key]=exports.resolve(dynamicValToResolve,dataNode);}else if(_.isObject(value)){updatedQuery[key]=exports.updateDynamicValues(value,dataNode);}});return updatedQuery;};/**\n * Evaluates eventSource expression\n * @param {Object} exp eventSource expression\n * @param {Object} contextObj context object\n * @return {Boolean} verdict of expression evaluation\n */export let evaluateEventSourceExpression=function(exp,contextObj){let eventSourceVal=exp[exports.$EVENTSOURCE];let evalResult=false;if(contextObj&&contextObj.data&&contextObj._source){let{data,_source}=contextObj;// need to check self/view-id/view-name\nif(_source===data._internal.modelId&&(eventSourceVal==='self'||eventSourceVal===data._internal.viewId||eventSourceVal===data._internal.panelId)){evalResult=true;}}return evalResult;};let checkOperatorResult=function(performAND,performOR,performNOT,evalCheckResult,result){if(performAND){return evalCheckResult&&result;}else if(performOR){return evalCheckResult||result;}else if(performNOT){return!result;}return result;};/**\n * Evaluates checks using expression parser utils\n * @param {Object} query Object definition containing query details to be evaluated on received object\n * @param {Array} objects Array of objects against which the query needs to be evaluated\n * @param {Object} adapterSvc Adapter service\n * @return {Boolean} verdict of expression evaluation\n */export let evaluateExpressions=function(query,objects,adapterSvc){var newValue=false;var queryToUse=query;var values=objects;if(!_.isArray(objects)){values=[objects];}// determine whether all or atleast one result(s) should match\nvar matchAll=queryToUse[exports.$ALL];// fetch the inner query that is value of $all\nqueryToUse=matchAll||queryToUse;// evaluate the check on each of the value\nnewValue=values.reduce(function(valReduceResult,value){// determine existence of multiple checks against same source inside the query\nvar performAND=queryToUse[exports.$AND]||queryToUse[exports.$ALL];var performOR=queryToUse[exports.$OR];var performNOT=queryToUse[exports.$NOT];// create array of checks to be evaluated on the source\nvar evalChecks=performAND||performOR||[queryToUse];evalChecks=performNOT?[performNOT]:evalChecks;var verdict=evalChecks.reduce(function(evalCheckResult,evalCheck){var path=exports.resolve(exports.$SOURCE,evalCheck);// path i.e. $source can optionally have $adapt indicating the propValue needs to be adapted before use\nvar shouldAdapt=path&&path[exports.$ADAPT];path=shouldAdapt||path;if(!path&&evalCheck&&evalCheck[exports.$EVENTSOURCE]){const evalResult=evaluateEventSourceExpression(evalCheck,value);return checkOperatorResult(performAND,performOR,performNOT,evalCheckResult,evalResult);}var condition=exports.resolve(exports.$QUERY,evalCheck)||evalCheck;var propValue=path?exports.resolve(path,value):value;if(evalCheck.__useSourceParsing){propValue=AwParseService.instance(path)(value);}if(shouldAdapt){var valuesToAdapt=_.isArray(propValue)?propValue:[propValue];propValue=adapterSvc.getAdaptedObjectsSync(valuesToAdapt);}// determine whether the query has nested queries with $all / $and / $or / $source\nvar recurseExpressionEvaluation=condition&&(condition[exports.$NOT]||condition[exports.$ALL]||condition[exports.$AND]||condition[exports.$OR]||condition[exports.$SOURCE]);var result;if(recurseExpressionEvaluation){result=exports.evaluateExpressions(condition,propValue,adapterSvc);}else{result=exports.evaluateConditionExpression(condition,null,propValue);}return checkOperatorResult(performAND,performOR,performNOT,evalCheckResult,result);},performAND);return matchAll?valReduceResult&&verdict:valReduceResult||verdict;},matchAll);/**  When query contains nested $all and the values object is empty it returns the matAll query back to parseExpression API\n     *   which converts it to boolean ie. true and gives wrong output\n     *   for example\n     *   {\n     *      \"$source\": \"ctx.mselected\",\n     *      \"$query\":{\n     *         \"$all\":{\n     *            \"$source\":\"moduleType.typeHierarchyArray\",\n     *            \"$query\":{\n     *               \"$in\":[\n     *                   \"ItemRevision\"\n     *               ]\n     *            }\n     *         }\n     *       }\n     *   }\n     *   In this case is ctx.mselected is empty array i.e no selection in UI then above query returns true.\n     *   Below is the fix for the same.\n     */return values.length===0&&matchAll?false:newValue;};/**\n * Evaluate conditions eg. 1. \"conditions\": { \"subscriptionId\": { \"$eq\": \"{{uid}}\" } } eg. 2. \"conditions\": {\n * \"object_desc\": { \"$eq\": \"Plane\" }, \"object_name\": { \"$eq\": \"Plane001\" } }\n *\n * @param {Object} conditions - map of conditions\n * @param { Object } vmoObj - view model object properties map\n * @return {Boolean} TRUE if all conditions are valid\n */export let evaluateConditions=function(conditions,vmoObj){var isValid=true;var vmoProps=vmoObj.props;for(var propName in conditions){if(conditions[propName]){if(_.isObject(conditions[propName])){var condition=conditions[propName];var vmoProp=vmoProps[propName];var propValue=_getDbValueForProp(vmoProp);var compareTo={};for(var key in condition){var value=condition[key];var propKey=propName+'@'+key;if(_.startsWith(value,'{{')){var propToCompare=parsingUtils.getStringBetweenDoubleMustaches(value);var prop=vmoProps[propToCompare];if(!prop){compareTo[propKey]=vmoObj[propToCompare];}else{compareTo[propKey]=_getDbValueForProp(prop);}}else{compareTo[propKey]=value;}}isValid=exports.evaluateConditionExpression(condition,propName,propValue,compareTo);}else{isValid=false;}}// break if even one condition is invalid\nif(!isValid){break;}}return isValid;};/**\n * Evaluate condition expression\n *\n * @param {Object} condition - condition object\n * @param {Object} propName - property name\n * @param {Object} propValue - real value of the property\n * @param {Object} compareTo - real value of the property\n * @return {Boolean} TRUE if conditions are valid\n */export let evaluateConditionExpression=function(condition,propName,propValue,compareTo){var isValid=false;var resolvedPropValue=null;if(condition){for(var key in condition){if(key!=='expressionType'){if(_.startsWith(key,'$')&&_.has(_map_expr2Function,key)){var functionName=_map_expr2Function[key];if(_.startsWith(condition[key],'{{')){resolvedPropValue=compareTo[propName+'@'+key];}else{resolvedPropValue=condition[key];}if(condition.expressionType==='Date'&&propValue&&resolvedPropValue){var parsedDates=dateParserUtils.getParsedDates(propValue,resolvedPropValue);resolvedPropValue=parsedDates.queryDate;propValue=parsedDates.sourceDate;}isValid=exports[functionName](resolvedPropValue,propValue,condition.expressionType);}else{isValid=false;}}}}return isValid;};/**\n * Evaluating whether condition value is equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */export let equalTo=function(condValue,propValue){var isValid=false;if(condValue&&propValue){isValid=condValue.toString()===propValue.toString();}else{isValid=condValue===propValue;}return isValid;};/**\n * Evaluating whether viewmodel property is of a particular type .\n *\n * @param {Object} vmo - viewmodel object\n * @param {String} type - type of property.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */export let typeOf=function(type,vmo){var typeHieararchyArray=[];if(vmo){if(vmo.modelType&&_.isArray(vmo.modelType.typeHierarchyArray)){typeHieararchyArray=vmo.modelType.typeHierarchyArray;}else if(_.isArray(vmo.typeHierarchy)){typeHieararchyArray=vmo.typeHierarchy;}else if(vmo.type){typeHieararchyArray=vmo.type;}}return typeHieararchyArray.includes(type);};/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */export let within=function(condValue,propValue){var isValid=false;var testValue=_.isArray(propValue)?propValue:[propValue];var values=_.isArray(condValue)?condValue:[condValue];isValid=values.some(function(value){return _.indexOf(testValue,value)>=0;});return isValid;};/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */export let notInRange=function(condValue,propValue,type){var isNotInRange=false;var isConditionValid=false;if(condValue&&condValue.length===2&&propValue&&type){var conditionLeft=condValue[0];var conditionRight=condValue[1];switch(type){case'Date':if(_.isFinite(conditionLeft)&&_.isFinite(conditionRight)&&_.isFinite(propValue)){isConditionValid=true;}break;case'Number':conditionLeft=Number(conditionLeft);conditionRight=Number(conditionRight);propValue=Number(propValue);isConditionValid=true;break;case'String':conditionLeft=conditionLeft.toString();conditionRight=conditionRight.toString();isConditionValid=true;break;}if(isConditionValid&&conditionLeft>propValue||conditionRight<propValue){isNotInRange=true;}}return isNotInRange;};/**\n * Evaluating whether property value is not in the condition value array.\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition values do not contain property value\n */export let notIn=function(condValue,propValue){var verdict=exports.within(condValue,propValue);return!verdict;};/**\n * Evaluating whether condition value is less than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than condition value\n */export let lessThan=function(condValue,propValue){var isValid=false;var condValueIn=Number(condValue);var propValueIn=Number(propValue);if(_.isFinite(condValueIn)&&_.isFinite(propValueIn)){if(propValueIn<condValueIn){isValid=true;}}return isValid;};/**\n * Evaluating whether condition value is less than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than or equal to condition value\n */export let lessThanOrEqualTo=function(condValue,propValue){var isValid=false;var condValueIn=Number(condValue);var propValueIn=Number(propValue);if(_.isFinite(condValueIn)&&_.isFinite(propValueIn)){if(propValueIn<=condValueIn){isValid=true;}}return isValid;};/**\n * Evaluating whether condition value is greater than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than condition value\n */export let greaterThan=function(condValue,propValue){var isValid=false;var condValueIn=Number(condValue);var propValueIn=Number(propValue);if(_.isFinite(condValueIn)&&_.isFinite(propValueIn)){if(propValueIn>condValueIn){isValid=true;}}return isValid;};/**\n * Evaluating whether condition value is greater than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than or equal to condition value\n */export let greaterThanOrEqualTo=function(condValue,propValue){var isValid=false;var condValueIn=Number(condValue);var propValueIn=Number(propValue);if(_.isFinite(condValueIn)&&_.isFinite(propValueIn)){if(propValueIn>=condValueIn){isValid=true;}}return isValid;};/**\n * Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */export let notEqualTo=function(condValue,propValue){var isValid=false;if(condValue&&propValue){isValid=condValue.toString()!==propValue.toString();}else{isValid=condValue!==propValue;}return isValid;};/**\n * Applicable for validation criteria -  Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */export let notEqualsTo=function(condValue,propValue){var isValid=false;if(condValue&&propValue){isValid=condValue.toString()!==propValue.toString();}return isValid;};/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */export let regexp=function(condValue,propValue){var isValid=false;var regexp;var value=propValue?String(propValue):'';if(_.isString(condValue)){regexp=new RegExp(condValue);}else if(_.isObject(condValue)&&condValue.$pattern){try{regexp=new RegExp(condValue.$pattern,condValue.$options);}catch(err){// Invalid options\nisValid=false;}}if(regexp){isValid=regexp.test(value);}return isValid;};/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */export let notInRegexp=function(condValue,propValue){if(condValue&&propValue){return!exports.regexp(condValue,propValue);}return false;};/**\n * Enables looking up a value in given range and matching another value with the value at the same index but\n * different column in the range\n *\n * Example: Range is an array of arrays where first array holds objects and second array holds array of values.\n * range : [\n *   [ {\"uid\":\"v1\"}, {\"uid\":\"v11\"}, {\"uid\":\"v111\"} ],\n *   [ [\"color1\"], [\"color2\"], [\"color3\"] ]\n * }\n *\n * Calling vlookup with following inputs will return true:\n * vlookupInput = {\n *  \"lookupValue\" : \"v11\",\n *  \"lookupValueKey\" : \"uid\",\n *  \"matchKey\" : 1,\n *  \"matchValue\": \"color2\"\n * }\n * vlookup( vlookupInput, range ) :: returns true\n *\n * @param {Object} vlookupInput - Javascript object holding the lookupValue, lookupValueKey, matchKey and matchValue\n * @param {Object} range -        Javascript object with each value as array of string/int/boolean or objects OR\n *                                    array of string/int/boolean or object arrays\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */export let vlookup=function(vlookupInput,range){var lookupValueKey=vlookupInput.lookupValueKey;var lookupValue=vlookupInput.lookupValue;var matchKey=vlookupInput.matchKey;var matchValue=vlookupInput.matchValue;var valToMatchFromRange;// determine the lookup strategy based on type of range object\nif(_.isArray(range)){// range is an array of arrays\nvar matchIndex=-1;_.forEach(range,function(value){var values=_.isArray(value)?value:[value];_.forEach(values,function(currVal,arrPos){if(currVal){var lookupValToMatch=lookupValueKey?currVal[lookupValueKey]:currVal;if(lookupValue===lookupValToMatch){matchIndex=arrPos;return false;}}return undefined;});if(matchIndex>-1){valToMatchFromRange=matchKey?range[matchKey][matchIndex]:Object.keys(range)[matchIndex];valToMatchFromRange=valToMatchFromRange&&_.isArray(valToMatchFromRange)&&valToMatchFromRange.length>0?valToMatchFromRange[0]:valToMatchFromRange;return false;}return undefined;});}else{// range is an object with key value pair\n_.forEach(range,function(value,key){if(key===lookupValue){valToMatchFromRange=value;return false;}return undefined;});}return valToMatchFromRange===matchValue;};/* Gets eval function to cache for quicker evals in future */ /**\n *\n * @param {String} condKey - $in\n * @param {String} propKey - modelType.typeHierarchy\n */export let getEvaluationFn=function(condKey,propKey){if(condKey[0]==='$'){return exports[_map_expr2Function[condKey]];}return function(){return false;};};/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */export let isNull=function(condValue,propValue){return!propValue;};/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */export let notNull=function(condValue,propValue){return!exports.isNull(condValue,propValue);};exports={$SOURCE,$QUERY,$ADAPT,$ALL,$AND,$OR,$EVENTSOURCE,$NOT,resolve,updateDynamicValues,evaluateExpressions,evaluateConditions,evaluateConditionExpression,evaluateEventSourceExpression,equalTo,within,notInRange,notIn,lessThan,lessThanOrEqualTo,greaterThan,greaterThanOrEqualTo,notEqualTo,notEqualsTo,regexp,notInRegexp,vlookup,isNull,notNull,getExpressionDataType,typeOf,getEvaluationFn};export default exports;","map":null,"metadata":{},"sourceType":"module"}