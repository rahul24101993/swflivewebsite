{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines the {@link NgServices.leavePlaceService}\n *\n * @module js/leavePlace.service\n */\nimport logger from 'js/logger'; // => 'afx/src/kernel/src/js/logger'\n\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus'; // Service\n\nimport AwStateService from 'js/awStateService';\nimport AwPromiseService from 'js/awPromiseService';\nvar exports = {};\n/**\n * The currently registered handler.\n *\n * @private\n * @member _registeredAppHandler\n * @memberOf NgServices.leavePlaceService\n */\n\nlet _registeredAppHandler = null;\nlet _eventSubscriptions = [];\nexport let reset = function () {\n  _registeredAppHandler = null; // unsuscribe _eventSubscriptions if exists\n\n  _eventSubscriptions.forEach(s => {\n    eventBus.unsubscribe(s);\n  });\n\n  _eventSubscriptions = [];\n};\n/**\n * Initialization function, sets up the transition lifecycle hooks.\n * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation\n * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will\n * trigger navigation to the original target.\n *\n * @private\n * @function initializeRootScope\n * @memberOf NgServices.leavePlaceService\n * @param {Object} $rootScope - $rootScope\n */\n\nexport let loadConfiguration = function () {\n  reset();\n  let _persistAppHandler = false;\n  /**\n   * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.\n   */\n\n  AwStateService.instance.transitionHooks.onBefore({}, transition => {\n    if (isLocationChangeStartEvent(transition)) {\n      return locationChangeStart(transition);\n    }\n\n    if (isStateChangeStartEvent(transition)) {\n      return stateChangeStart(transition);\n    }\n  });\n\n  const locationChangeStart = transition => {\n    const defer = AwPromiseService.instance.defer();\n\n    if (_registeredAppHandler && !_persistAppHandler) {\n      let fromState = transition.from();\n      let fromParams = transition.params('from');\n      let toState = transition.to();\n      let toParams = transition.params();\n      let options = transition.options();\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // Functions to call after the okToLeave promise\n      // okToLeaveSuccess must be set, okToLeaveFailure can be null\n\n      let okToLeaveSuccess;\n      let okToLeaveFailure;\n\n      okToLeaveSuccess = () => {\n        // navigate to the target state using the current transition instance\n        transition.router.stateService.go(targetNavDetails.toState, targetNavDetails.toParams, targetNavDetails.options);\n        return true;\n      };\n\n      okToLeaveFailure = () => {\n        // Don't clear handler when the promise is rejected\n        logger.trace('Prevented navigation to ', targetNavDetails);\n        return true;\n      };\n\n      const {\n        targetNavInfo,\n        oldState,\n        newState\n      } = getOkToLeaveInfo(fromState, fromParams, toState, toParams); // Run the okToLeave handler\n\n      return _registeredAppHandler.okToLeave(targetNavInfo, oldState, newState).then(options => {\n        // Clear the handler\n        if (options && options.clearLeaveHandler === false) {\n          _persistAppHandler = true;\n        } else {\n          _registeredAppHandler = null;\n        }\n\n        return okToLeaveSuccess();\n      }, okToLeaveFailure);\n    }\n\n    defer.resolve();\n    _persistAppHandler = false;\n    return defer.promise;\n  };\n\n  const stateChangeStart = transition => {\n    const defer = AwPromiseService.instance.defer();\n\n    if (_registeredAppHandler) {\n      let fromState = transition.from();\n      let toState = transition.to();\n      let toParams = transition.params();\n      let options = transition.options();\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.fromState = fromState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // invoke the handler and setup up the promise continuation\n\n      return _registeredAppHandler.okToLeave(targetNavDetails).then(() => {\n        // clear the handler reference that ran to avoid recursion\n        _registeredAppHandler = null; // navigate to the target state using the current transition instance\n\n        transition.router.stateService.go(targetNavDetails.toState, targetNavDetails.toParams, targetNavDetails.options);\n        return true;\n      }, err => {\n        // eslint-disable-line no-unused-vars\n        logger.trace('Prevented navigation to ', targetNavDetails);\n        return true;\n      });\n    }\n\n    defer.resolve();\n    return defer.promise;\n  };\n\n  const getOkToLeaveInfo = (fromState, fromParams, toState, toParams) => {\n    return {\n      targetNavInfo: {},\n      oldState: {\n        params: fromParams,\n        state: {\n          name: fromState.name\n        }\n      },\n      newState: {\n        params: toParams,\n        state: {\n          name: toState.name\n        }\n      }\n    };\n  };\n};\n/**\n * Method used by application to create leave handler object from an api object that can perform the okToLeave check\n *\n * @function createAndRegisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} api - The object for the leave handler. Must have a method \"okToLeave\" that is called with a\n *            promise when the user attempts to change location / state.\n */\n\nexport let createAndRegisterLeaveHandler = function (api) {\n  var leaveHandler = {\n    api: api\n  };\n\n  leaveHandler.okToLeave = function () {\n    var deferred = AwPromiseService.instance.defer();\n    this.api.okToLeave(deferred);\n    return deferred.promise;\n  };\n\n  exports.registerLeaveHandler(leaveHandler);\n};\n/**\n * Method used for service consumer to register their handler function. Upon navigation, the \"okToLeave\" function\n * will be invoked. The function must return a promise, and when the handler logic completes the promise should be\n * resolved to allow navigation to continue or rejected to prevent the navigation.\n *\n * @function registerLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler Object function. Must have a \"okToLeave\" property which returns a\n *            promise.\n */\n\nexport let registerLeaveHandler = function (handler) {\n  if (handler && !handler.okToLeave) {\n    logger.error('Leave place handler', handler, 'does not have okToLeave property');\n  } else {\n    _registeredAppHandler = handler;\n  }\n};\n/**\n * Method used for deregister a given leave handler\n *\n * @function deregisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler to deregister\n */\n\nexport let deregisterLeaveHandler = function (handler) {\n  if (handler === _registeredAppHandler) {\n    _registeredAppHandler = null;\n  }\n};\nexport let isLocationChangeStartEvent = function (transition) {\n  if (_.isUndefined(transition) || _.isEmpty(transition)) {\n    return false;\n  } // page refresh case\n\n\n  if (transition.from().url === '^' && transition.from().name === '') {\n    return false;\n  } //invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params\n\n\n  if (_.isEqual(transition.from().name, transition.to().name) && !_.isEqual(transition.params('from'), transition.params('to'))) {\n    return true;\n  }\n\n  return false;\n};\nexport let isStateChangeStartEvent = function (transition) {\n  if (_.isUndefined(transition) || _.isEmpty(transition)) {\n    return false;\n  } // page refresh case\n\n\n  if (transition.from().url === '^' && transition.from().name === '') {\n    return false;\n  }\n\n  if (!_.isEqual(transition.from().name, transition.to().name)) {\n    return true;\n  }\n\n  return false;\n};\nexports = {\n  reset,\n  loadConfiguration,\n  createAndRegisterLeaveHandler,\n  registerLeaveHandler,\n  deregisterLeaveHandler,\n  isLocationChangeStartEvent,\n  isStateChangeStartEvent\n};\nexport default exports;\nloadConfiguration();","map":{"version":3,"names":["logger","_","eventBus","AwStateService","AwPromiseService","exports","_registeredAppHandler","_eventSubscriptions","reset","forEach","s","unsubscribe","loadConfiguration","_persistAppHandler","instance","transitionHooks","onBefore","transition","isLocationChangeStartEvent","locationChangeStart","isStateChangeStartEvent","stateChangeStart","defer","fromState","from","fromParams","params","toState","to","toParams","options","targetNavDetails","okToLeaveSuccess","okToLeaveFailure","router","stateService","go","trace","targetNavInfo","oldState","newState","getOkToLeaveInfo","okToLeave","then","clearLeaveHandler","resolve","promise","err","state","name","createAndRegisterLeaveHandler","api","leaveHandler","deferred","registerLeaveHandler","handler","error","deregisterLeaveHandler","isUndefined","isEmpty","url","isEqual"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/leavePlace.service.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines the {@link NgServices.leavePlaceService}\n *\n * @module js/leavePlace.service\n */\nimport logger from 'js/logger'; // => 'afx/src/kernel/src/js/logger'\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\n\n// Service\nimport AwStateService from 'js/awStateService';\nimport AwPromiseService from 'js/awPromiseService';\n\nvar exports = {};\n\n/**\n * The currently registered handler.\n *\n * @private\n * @member _registeredAppHandler\n * @memberOf NgServices.leavePlaceService\n */\nlet _registeredAppHandler = null;\n\nlet _eventSubscriptions = [];\n\nexport let reset = function() {\n    _registeredAppHandler = null;\n\n    // unsuscribe _eventSubscriptions if exists\n    _eventSubscriptions.forEach( ( s ) => {\n        eventBus.unsubscribe( s );\n    } );\n\n    _eventSubscriptions = [];\n};\n\n/**\n * Initialization function, sets up the transition lifecycle hooks.\n * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation\n * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will\n * trigger navigation to the original target.\n *\n * @private\n * @function initializeRootScope\n * @memberOf NgServices.leavePlaceService\n * @param {Object} $rootScope - $rootScope\n */\nexport let loadConfiguration = function() {\n    reset();\n    let _persistAppHandler = false;\n    /**\n     * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.\n     */\n    AwStateService.instance.transitionHooks.onBefore( {}, ( transition ) => {\n        if( isLocationChangeStartEvent( transition ) ) {\n            return locationChangeStart( transition );\n        }\n        if( isStateChangeStartEvent( transition ) ) {\n            return stateChangeStart( transition );\n        }\n    } );\n\n    const locationChangeStart = ( transition ) => {\n        const defer = AwPromiseService.instance.defer();\n        if( _registeredAppHandler && !_persistAppHandler ) {\n            let fromState = transition.from();\n            let fromParams = transition.params( 'from' );\n            let toState = transition.to();\n            let toParams = transition.params();\n            let options = transition.options();\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // Functions to call after the okToLeave promise\n            // okToLeaveSuccess must be set, okToLeaveFailure can be null\n            let okToLeaveSuccess;\n            let okToLeaveFailure;\n            okToLeaveSuccess = () => {\n                // navigate to the target state using the current transition instance\n                transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,\n                    targetNavDetails.options );\n                return true;\n            };\n\n            okToLeaveFailure = () => {\n                // Don't clear handler when the promise is rejected\n                logger.trace( 'Prevented navigation to ', targetNavDetails );\n                return true;\n            };\n            const { targetNavInfo, oldState, newState } = getOkToLeaveInfo( fromState, fromParams, toState, toParams );\n            // Run the okToLeave handler\n            return _registeredAppHandler.okToLeave( targetNavInfo, oldState, newState ).then( ( options ) => {\n                // Clear the handler\n                if( options && options.clearLeaveHandler === false ) {\n                    _persistAppHandler = true;\n                } else {\n                    _registeredAppHandler = null;\n                }\n                return okToLeaveSuccess();\n            }, okToLeaveFailure );\n        }\n        defer.resolve();\n        _persistAppHandler = false;\n        return defer.promise;\n    };\n\n    const stateChangeStart = ( transition ) => {\n        const defer = AwPromiseService.instance.defer();\n        if( _registeredAppHandler ) {\n            let fromState = transition.from();\n            let toState = transition.to();\n            let toParams = transition.params();\n            let options = transition.options();\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.fromState = fromState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // invoke the handler and setup up the promise continuation\n            return _registeredAppHandler.okToLeave( targetNavDetails ).then(\n                () => {\n                    // clear the handler reference that ran to avoid recursion\n                    _registeredAppHandler = null;\n                    // navigate to the target state using the current transition instance\n                    transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,\n                        targetNavDetails.options );\n                    return true;\n                },\n                ( err ) => { // eslint-disable-line no-unused-vars\n                    logger.trace( 'Prevented navigation to ', targetNavDetails );\n                    return true;\n                } );\n        }\n        defer.resolve();\n        return defer.promise;\n    };\n\n    const getOkToLeaveInfo = ( fromState, fromParams, toState, toParams ) => {\n        return {\n            targetNavInfo: {},\n            oldState: {\n                params: fromParams,\n                state: {\n                    name: fromState.name\n                }\n            },\n            newState: {\n                params: toParams,\n                state: {\n                    name: toState.name\n                }\n            }\n        };\n    };\n};\n\n/**\n * Method used by application to create leave handler object from an api object that can perform the okToLeave check\n *\n * @function createAndRegisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} api - The object for the leave handler. Must have a method \"okToLeave\" that is called with a\n *            promise when the user attempts to change location / state.\n */\nexport let createAndRegisterLeaveHandler = function( api ) {\n    var leaveHandler = {\n        api: api\n    };\n\n    leaveHandler.okToLeave = function() {\n        var deferred = AwPromiseService.instance.defer();\n        this.api.okToLeave( deferred );\n        return deferred.promise;\n    };\n\n    exports.registerLeaveHandler( leaveHandler );\n};\n\n/**\n * Method used for service consumer to register their handler function. Upon navigation, the \"okToLeave\" function\n * will be invoked. The function must return a promise, and when the handler logic completes the promise should be\n * resolved to allow navigation to continue or rejected to prevent the navigation.\n *\n * @function registerLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler Object function. Must have a \"okToLeave\" property which returns a\n *            promise.\n */\nexport let registerLeaveHandler = function( handler ) {\n    if( handler && !handler.okToLeave ) {\n        logger.error( 'Leave place handler', handler, 'does not have okToLeave property' );\n    } else {\n        _registeredAppHandler = handler;\n    }\n};\n\n/**\n * Method used for deregister a given leave handler\n *\n * @function deregisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler to deregister\n */\nexport let deregisterLeaveHandler = function( handler ) {\n    if( handler === _registeredAppHandler ) {\n        _registeredAppHandler = null;\n    }\n};\n\nexport let isLocationChangeStartEvent = function( transition ) {\n    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {\n        return false;\n    }\n    // page refresh case\n    if( transition.from().url === '^' && transition.from().name === '' ) {\n        return false;\n    }\n    //invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params\n    if( _.isEqual( transition.from().name, transition.to().name ) && !_.isEqual( transition.params( 'from' ), transition.params( 'to' ) ) ) {\n        return true;\n    }\n    return false;\n};\n\nexport let isStateChangeStartEvent = function( transition ) {\n    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {\n        return false;\n    }\n    // page refresh case\n    if( transition.from().url === '^' && transition.from().name === '' ) {\n        return false;\n    }\n    if( !_.isEqual( transition.from().name, transition.to().name ) ) {\n        return true;\n    }\n    return false;\n};\n\nexports = {\n    reset,\n    loadConfiguration,\n    createAndRegisterLeaveHandler,\n    registerLeaveHandler,\n    deregisterLeaveHandler,\n    isLocationChangeStartEvent,\n    isStateChangeStartEvent\n};\nexport default exports;\n\nloadConfiguration();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}