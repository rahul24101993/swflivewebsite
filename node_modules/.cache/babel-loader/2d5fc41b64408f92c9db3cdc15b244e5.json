{"ast":null,"code":"/* eslint-disable valid-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n *\n * @module js/commandConfigurationService\n */\nimport _, { uniqBy } from 'lodash';\nimport logger from 'js/logger';\nimport 'js/iconService';\nimport ccu from 'js/commandConfigUtils.service';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\nimport { getLocalizedText } from 'js/localeService';\nimport Debug from 'debug';\nimport debugService from 'js/debugService';\nimport conditionService from 'js/conditionService';\nimport htmlUtils from 'js/htmlUtils';\nconst trace = new Debug('command:AwCommandBar'); //TODO: Global state that should not be managed in a service - revisit later\n\nlet dynamicPlacements = [];\nconst handlerCache = {};\n\nconst getHandlersForCommand = (id, commandsViewModel, useCache) => {\n  if (!handlerCache[id] || !useCache) {\n    handlerCache[id] = Object.entries(commandsViewModel.commandHandlers).filter(_ref => {\n      let [, v] = _ref;\n      return v.id === id;\n    });\n  }\n\n  return handlerCache[id];\n};\n\nconst DeclarativeCondition = function (condition, commandsViewModel) {\n  this.id = condition.split('.').slice(-1)[0];\n  this.expression = ccu.getConditionExpression(commandsViewModel, condition);\n};\n\n_c4 = DeclarativeCondition;\n_c = DeclarativeCondition;\n\nconst getHandlerAction = (handler, commandsViewModel, _ref2) => {\n  let {\n    isRibbon\n  } = _ref2;\n\n  if (isRibbon) {\n    //Ribbon commands use their configured action or open popup with child commands if not configured\n    return commandsViewModel.actions[handler.action || 'openCommandGroup'];\n  }\n\n  if (handler.action) {\n    //Base commands use their configured action\n    return commandsViewModel.actions[handler.action];\n  }\n\n  return null;\n};\n/**\n * Command handler information from commandsViewModel\n *\n * Will be used by AwCommand to setup any necessary hooks and process\n */\n\n\nconst CommandHandler = function (id, handler, commandsViewModel, definition) {\n  // String :: ID of the command handler\n  this.id = id; // DeclarativeCondition :: Active condition for this handler\n\n  this.activeWhen = new DeclarativeCondition(handler.activeWhen.condition, commandsViewModel); // Number :: Priority of the command handler (length of the activeWhen condition)\n\n  this.priority = ccu.getExpressionLength(this.activeWhen.expression, commandsViewModel); // DeclarativeCondition :: Enabled state condition for this handler\n\n  this.enableWhen = handler.enableWhen ? new DeclarativeCondition(handler.enableWhen.condition, commandsViewModel) : null; // DeclarativeCondition :: Selected state condition for this handler\n\n  this.selectWhen = handler.selectWhen ? new DeclarativeCondition(handler.selectWhen.condition, commandsViewModel) : null; // DeclarativeCondition :: Visibility condition for this handler\n\n  this.visibleWhen = handler.visibleWhen ? new DeclarativeCondition(handler.visibleWhen.condition, commandsViewModel) : null;\n  /**\n   * The action that this handler will execute\n   */\n\n  this.action = getHandlerAction(handler, commandsViewModel, definition);\n  /**\n   * Callback function to execute this command handler\n   *\n   * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model\n   * @returns {CommandExecutionResult}\n   */\n\n  this.execute = async (runActionWithViewModel, scope, commandContext) => {\n    scope.commandContext = commandContext || scope.commandContext;\n    return runActionWithViewModel(commandsViewModel, handler.action, scope);\n  };\n};\n/**\n * The raw data from commands view model that will be used to determine the current command state\n */\n\n\n_c5 = CommandHandler;\n_c2 = CommandHandler;\nexport const CommandOverlay = function (_ref3) {\n  let {\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    showGroupSelected = true,\n    cellDisplay\n  } = _ref3; // String! :: ID of the command\n\n  this.id = id; // [CommandHandler] :: Handlers for this command\n\n  this.handlers = handlers; // I18nReference :: Title definition of the command\n\n  this.title = title;\n  this.selectedTitle = selectedTitle; // String :: ID of the command icon\n\n  this.icon = icon;\n  this.selectedIcon = selectedIcon;\n  this.decorator = decorator;\n  this.extendedTooltip = extendedTooltip;\n  this.selectedExtendedTooltip = selectedExtendedTooltip;\n  this.description = description;\n  this.selectedDescription = selectedDescription;\n  this.type = type;\n  this.children = children;\n  this.showGroupSelected = showGroupSelected;\n  this.cellDisplay = cellDisplay;\n  this.trace = new Debug(`command:${id}`);\n  this.trace('Overlay created', this);\n};\n/**\n * Get the i18n string configured in the given view model\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String} key Key within the i18n section\n * @param {Object} viewModel View model json\n * @returns {String} The localized text value\n */\n\n_c6 = CommandOverlay;\n_c3 = CommandOverlay;\n\nconst getI18nValue = async (key, viewModel) => {\n  const resource = viewModel.i18n[key] ? viewModel.i18n[key][0] : '';\n  return getLocalizedText(resource, key);\n};\n/**\n * Resolve an i18n reference\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String|Object} i18nRef Reference information\n * @param {Object} viewModel View model json\n * @returns {Object} The string value and a list of any parameters it may have\n */\n\n\nconst resolveI18n = async (i18nRef, viewModel) => {\n  if (typeof i18nRef === 'string') {\n    const reference = getStringBetweenDoubleMustaches(i18nRef);\n    const value = reference.startsWith('i18n.') ? await getI18nValue(reference.slice(5), viewModel) : reference;\n    return {\n      value,\n      parameters: []\n    };\n  }\n\n  if (typeof i18nRef === 'object') {\n    const {\n      value\n    } = await resolveI18n(i18nRef.text, viewModel);\n    return {\n      value,\n      parameters: i18nRef.params || i18nRef.parameters\n    };\n  }\n\n  return null;\n};\n/**\n * Get the type of a command\n *\n * @param {Object} definition Command definition\n * @returns {String} Command type\n */\n\n\nconst getCommandType = definition => {\n  if (definition.isShuttle) {\n    return 'SHUTTLE';\n  }\n\n  if (definition.isRibbon) {\n    return 'RIBBON';\n  }\n\n  if (definition.isGroup) {\n    return 'GROUP';\n  }\n\n  if (definition.isToggle) {\n    return 'TOGGLE';\n  }\n\n  return 'BASE';\n};\n/**\n * Get a command overlay\n *\n * @param {String} id ID of the command\n * @returns {CommandOverlay} Overlay for the command\n */\n\n\nexport const getCommand = async (id, useCache) => {\n  const commandsViewModel = await ccu.getCommandsViewModel();\n  return getCommandInternal(id, commandsViewModel, null, useCache);\n};\n\nconst getDecoratorObject = async (template, commandsViewModel) => {\n  const checkVisbleWhenConditionForConversion = visibleWhen => {\n    if (visibleWhen && visibleWhen.condition) {\n      return visibleWhen.condition;\n    }\n\n    if (visibleWhen === false) {\n      return 'conditions.false';\n    }\n\n    return 'conditions.true';\n  };\n\n  let value = getStringBetweenDoubleMustaches(template.text);\n\n  if (value.startsWith('i18n.')) {\n    return {\n      text: await resolveI18n(template.text, commandsViewModel),\n      visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen), commandsViewModel) : null,\n      class: template.class ? template.class : null\n    };\n  }\n\n  return {\n    text: {\n      value: '{0}',\n      parameters: [template.text]\n    },\n    visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen), commandsViewModel) : null,\n    class: template.class ? template.class : null\n  };\n};\n/**\n * Load the necessary data to create a CommandOverlay and return it\n *\n * @param {String} id ID of the command\n * @param {Object} commandsViewModel Commands view model json\n * @param {Object} placement (Optional) Placement information\n */\n\n\nconst getCommandInternal = async function (id, commandsViewModel) {\n  let placement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let useCache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const definition = commandsViewModel.commands[id];\n\n  if (!definition) {\n    logger.error(`Missing command definition for ${id}`);\n  }\n\n  const type = getCommandType(definition);\n  const handlers = type === 'GROUP' || type === 'SHUTTLE' ? [new CommandHandler('GroupCommandHandler', {\n    activeWhen: {\n      condition: 'conditions.true'\n    },\n    action: 'openCommandGroup'\n  }, commandsViewModel, definition)] : getHandlersForCommand(id, commandsViewModel, useCache).map(_ref4 => {\n    let [handlerId, value] = _ref4;\n    return new CommandHandler(handlerId, value, commandsViewModel, definition);\n  }).sort((a, b) => b.priority - a.priority);\n  const icon = definition.iconId;\n  const selectedIcon = definition.selected ? definition.selected.iconId : null; //TODO: Some stuff (i18n) may need to be resolved here\n\n  const extendedTooltip = definition.extendedTooltip;\n  const selectedExtendedTooltip = definition.selected && definition.selected.extendedTooltip ? definition.selected.extendedTooltip : null;\n  const [title, selectedTitle, description, selectedDescription, decorator] = await Promise.all([resolveI18n(definition.title, commandsViewModel), definition.selected && definition.selected.title ? resolveI18n(definition.selected.title, commandsViewModel) : null, definition.description ? await resolveI18n(definition.description, commandsViewModel) : null, definition.selected && definition.selected.description ? resolveI18n(definition.selected.description, commandsViewModel) : null, definition.template && definition.template.text ? getDecoratorObject(definition.template, commandsViewModel) : null]);\n  const children = type === 'GROUP' || type === 'SHUTTLE' ? await getCommands(id) : [];\n  return new CommandOverlay({\n    showGroupSelected: !placement || placement.showGroupSelected !== false,\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    cellDisplay: placement ? placement.cellDisplay : null\n  });\n};\n/**\n * Sort the placements based on relativeTo and priority. Priority is 0 if not set.\n *\n * @param {[CommandPlacement]} placements - placements\n * @return {[CommandPlacement]} Sorted list of command placements\n */\n\n\nconst sortPlacements = function (placements) {\n  // Assign a priority to any placement that doesn't have one\n  placements.forEach(function (cmd) {\n    cmd.priority = cmd.priority || 0;\n  }); // Split based on whether placement is relative or absolute\n\n  const p = _.partition(placements, function (cmd) {\n    return cmd.relativeTo;\n  }); // Sort the commands with only priority\n\n\n  const priorityCommands = _.sortBy(p[1], 'priority'); // Group the relative commands by the relativeTo property\n\n\n  const allRelativeCmds = _.groupBy(p[0], 'relativeTo');\n\n  const commandsWithRelativeAdded = priorityCommands.reduce((acc, placement) => {\n    // Split into before / after based on negative / positive priority\n    const p2 = _.partition(allRelativeCmds[placement.id] || [], function (cmd) {\n      return cmd.priority > 0;\n    });\n\n    const afterPlacements = _.sortBy(p2[0], 'priority');\n\n    const beforePlacements = _.sortBy(p2[1], 'priority'); //side effect, could be refactored later\n\n\n    delete allRelativeCmds[placement.id];\n    return [...acc, ...beforePlacements, placement, ...afterPlacements];\n  }, []); //Add any placement with relativeTo that is not in this command bar to the end\n\n  return Object.values(allRelativeCmds).reduce((acc, missingRelativeSet) => {\n    logger.debug(`Unable to find relative command ${missingRelativeSet[0].id}. Commands will be placed at end of list.`, missingRelativeSet);\n    return [...acc, ...missingRelativeSet];\n  }, commandsWithRelativeAdded);\n};\n/**\n * Get the commands for the given anchor\n *\n * @param {String} anchor anchor\n * @returns {[CommandOverlay]} Command overlays for the anchor\n */\n\n\nexport const getCommands = async (anchor, useCache) => {\n  const commandsViewModel = await ccu.getCommandsViewModel();\n  const anchors = anchor.split(',');\n  const allPlacements = [...dynamicPlacements, ...Object.values(commandsViewModel.commandPlacements)];\n  const placements = uniqBy(anchors.reduce((fullPlacementList, nextAnchor) => {\n    const newPlacements = allPlacements.filter(placement => !placement.parentGroupId && placement.uiAnchor === nextAnchor && commandsViewModel.commands[placement.id]);\n    return [...fullPlacementList, ...newPlacements];\n  }, []), 'id');\n  let placementsSorted = sortPlacements(placements);\n  const commands = await Promise.all(placementsSorted.map(placement => getCommandInternal(placement.id, commandsViewModel, placement, useCache)));\n\n  if (anchor) {\n    debugService.debugGetCommandsForAnchor(anchor, commands);\n    debugService.reduceData(anchor, commands);\n  }\n\n  return commands;\n};\n/**\n * Add a placement for a command at runtime. All placements\n * must be defined before the AwCommandBar with the matching\n * anchor is rendered\n *\n * @param {[CommandPlacement]} placements Placements to add\n * @returns {Object} Tracking information to all for removal of the placements\n */\n\nexport const addPlacements = placements => {\n  trace('Dynamic placements added', placements);\n  dynamicPlacements = [...dynamicPlacements, ...placements];\n  return {\n    placements,\n    remove: () => {\n      dynamicPlacements = dynamicPlacements.filter(x => !placements.includes(x));\n      trace('Dynamic placements removed', placements);\n    }\n  };\n};\n/**\n * Get the commandContext of a given command bar/group\n *\n * @param {String} grpCmdAnchor - the group id/anchor for a given command group\n * @param {String} commandBarAnchor - the anchor for a given command bar\n * @returns {Object} commandContext for given command group or command bar\n */\n\nexport const getCommandContext = function (grpCmdAnchor, commandBarAnchor) {\n  let commandBarXPath = `//div[contains(@class, 'aw-command-bar') and @anchor='${grpCmdAnchor ? grpCmdAnchor : commandBarAnchor}']`;\n  let commandBar = htmlUtils.getElementByXpath(commandBarXPath, document.body);\n\n  if (commandBar) {\n    const key = Object.keys(commandBar).find(key => {\n      return key.startsWith('__reactFiber$');\n    });\n    const commandBarFiber = commandBar[key];\n\n    if (commandBarFiber.return.memoizedProps.commandContext) {\n      return commandBarFiber.return.memoizedProps.commandContext;\n    } // get parent toolbar which has command context\n\n\n    let toolbarFiber = commandBarFiber.return;\n\n    while (typeof toolbarFiber.type === 'string') {\n      toolbarFiber = toolbarFiber.return;\n    }\n\n    return toolbarFiber.return.memoizedProps.commandContext;\n  }\n\n  return null;\n};\n/**\n * Given the array of handlers for a command get the activeHandler\n *\n * @param {Array<Handler>} handlers - array of command handlers\n * @param {Object} scope - evaluation scope\n * @returns {Handler} the active handler\n */\n\nexport const getActiveCommandHandler = function (handlers, scope) {\n  for (const handler of handlers) {\n    const isActive = Boolean(conditionService.evaluateCondition({}, handler.activeWhen.expression, scope));\n\n    if (isActive) {\n      return handler;\n    }\n  }\n\n  return null;\n};\n/**\n * Check whether a command is enabled and visible\n *\n * @param {Object} activeHandler - active command handler\n * @param {Object} scope - evaluation scope\n * @returns {Boolean} visbleWhen and enableWhen\n */\n\nexport const getCommandAndCheckVisibility = function (activeHandler, scope) {\n  const visibleWhen = activeHandler.visibleWhen ? Boolean(conditionService.evaluateCondition({}, activeHandler.visibleWhen.expression, scope)) : true;\n  const enableWhen = activeHandler.enableWhen ? Boolean(conditionService.evaluateCondition({}, activeHandler.enableWhen.expression, scope)) : true;\n  return visibleWhen && enableWhen;\n};\nexport default {\n  getCommand,\n  getCommands,\n  getCommandContext,\n  getActiveCommandHandler,\n  getCommandAndCheckVisibility\n};\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"DeclarativeCondition\");\n$RefreshReg$(_c2, \"CommandHandler\");\n$RefreshReg$(_c3, \"CommandOverlay\");\n\nvar _c4, _c5, _c6;\n\n$RefreshReg$(_c4, \"DeclarativeCondition\");\n$RefreshReg$(_c5, \"CommandHandler\");\n$RefreshReg$(_c6, \"CommandOverlay\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/commandConfigurationService.js"],"names":["trace","dynamicPlacements","handlerCache","getHandlersForCommand","commandsViewModel","v","DeclarativeCondition","condition","ccu","getHandlerAction","isRibbon","handler","CommandHandler","scope","commandContext","runActionWithViewModel","CommandOverlay","showGroupSelected","cellDisplay","id","getI18nValue","resource","viewModel","getLocalizedText","resolveI18n","reference","getStringBetweenDoubleMustaches","value","parameters","i18nRef","getCommandType","definition","getCommand","getCommandInternal","getDecoratorObject","checkVisbleWhenConditionForConversion","visibleWhen","template","text","class","placement","useCache","logger","type","handlers","activeWhen","action","b","a","icon","selectedIcon","extendedTooltip","selectedExtendedTooltip","Promise","children","getCommands","sortPlacements","placements","cmd","p","priorityCommands","_","allRelativeCmds","commandsWithRelativeAdded","p2","afterPlacements","beforePlacements","missingRelativeSet","anchors","anchor","allPlacements","Object","uniqBy","newPlacements","placementsSorted","commands","debugService","addPlacements","remove","x","getCommandContext","commandBarXPath","grpCmdAnchor","commandBarAnchor","commandBar","htmlUtils","document","key","commandBarFiber","toolbarFiber","getActiveCommandHandler","isActive","Boolean","conditionService","getCommandAndCheckVisibility","activeHandler","enableWhen"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAA,CAAA,IAAA,MAAA,QAAA,QAAA;AACA,OAAA,MAAA,MAAA,WAAA;AACA,OAAA,gBAAA;AACA,OAAA,GAAA,MAAA,+BAAA;AACA,SAAA,+BAAA,QAAA,iBAAA;AACA,SAAA,gBAAA,QAAA,kBAAA;AACA,OAAA,KAAA,MAAA,OAAA;AACA,OAAA,YAAA,MAAA,iBAAA;AACA,OAAA,gBAAA,MAAA,qBAAA;AACA,OAAA,SAAA,MAAA,cAAA;AACA,MAAMA,KAAK,GAAG,IAAA,KAAA,CAAd,sBAAc,CAAd,C,CAEA;;AACA,IAAIC,iBAAiB,GAArB,EAAA;AACA,MAAMC,YAAY,GAAlB,EAAA;;AACA,MAAMC,qBAAqB,GAAG,CAAA,EAAA,EAAA,iBAAA,EAAA,QAAA,KAAuC;EACjE,IAAI,CAACD,YAAY,CAAb,EAAa,CAAb,IAAuB,CAA3B,QAAA,EAAuC;IACnCA,YAAY,CAAZA,EAAY,CAAZA,GAAqB,MAAM,CAAN,OAAA,CAAgBE,iBAAiB,CAAjC,eAAA,EAAA,MAAA,CACR,IAAA,IAAA;MAAA,IAAE,GAAF,CAAE,IAAF,IAAA;MAAA,OAAeC,CAAC,CAADA,EAAAA,KAAf,EAAA;IADbH,CAAqB,CAArBA;EAEH;;EACD,OAAOA,YAAY,CAAnB,EAAmB,CAAnB;AALJ,CAAA;;AAQA,MAAMI,oBAAoB,GAAG,UAAA,SAAA,EAAA,iBAAA,EAAyC;EAClE,KAAA,EAAA,GAAUC,SAAS,CAATA,KAAAA,CAAAA,GAAAA,EAAAA,KAAAA,CAA8B,CAA9BA,CAAAA,EAAV,CAAUA,CAAV;EACA,KAAA,UAAA,GAAkBC,GAAG,CAAHA,sBAAAA,CAAAA,iBAAAA,EAAlB,SAAkBA,CAAlB;AAFJ,CAAA;;MAAMF,oB;KAAAA,oB;;AAKN,MAAMG,gBAAgB,GAAG,CAAA,OAAA,EAAA,iBAAA,EAAA,KAAA,KAAgD;EAAA,IAAlB;IAAEC;EAAF,IAAkB,KAAA;;EACrE,IAAA,QAAA,EAAe;IACX;IACA,OAAON,iBAAiB,CAAjBA,OAAAA,CAA2BO,OAAO,CAAPA,MAAAA,IAAlC,kBAAOP,CAAP;EACH;;EACD,IAAIO,OAAO,CAAX,MAAA,EAAqB;IACjB;IACA,OAAOP,iBAAiB,CAAjBA,OAAAA,CAA2BO,OAAO,CAAzC,MAAOP,CAAP;EACH;;EACD,OAAA,IAAA;AATJ,CAAA;AAYA;AACA;AACA;AACA;AACA;;;AACA,MAAMQ,cAAc,GAAG,UAAA,EAAA,EAAA,OAAA,EAAA,iBAAA,EAAA,UAAA,EAAuD;EAC1E;EACA,KAAA,EAAA,GAF0E,EAE1E,CAF0E,CAG1E;;EACA,KAAA,UAAA,GAAkB,IAAA,oBAAA,CAA0BD,OAAO,CAAPA,UAAAA,CAA1B,SAAA,EAJwD,iBAIxD,CAAlB,CAJ0E,CAK1E;;EACA,KAAA,QAAA,GAAgBH,GAAG,CAAHA,mBAAAA,CAAyB,KAAA,UAAA,CAAzBA,UAAAA,EAN0D,iBAM1DA,CAAhB,CAN0E,CAO1E;;EACA,KAAA,UAAA,GAAkBG,OAAO,CAAPA,UAAAA,GAAqB,IAAA,oBAAA,CAA0BA,OAAO,CAAPA,UAAAA,CAA1B,SAAA,EAArBA,iBAAqB,CAArBA,GARwD,IAQ1E,CAR0E,CAS1E;;EACA,KAAA,UAAA,GAAkBA,OAAO,CAAPA,UAAAA,GAAqB,IAAA,oBAAA,CAA0BA,OAAO,CAAPA,UAAAA,CAA1B,SAAA,EAArBA,iBAAqB,CAArBA,GAVwD,IAU1E,CAV0E,CAW1E;;EACA,KAAA,WAAA,GAAmBA,OAAO,CAAPA,WAAAA,GAAsB,IAAA,oBAAA,CAA0BA,OAAO,CAAPA,WAAAA,CAA1B,SAAA,EAAtBA,iBAAsB,CAAtBA,GAAnB,IAAA;EAEA;AACJ;AACA;;EACI,KAAA,MAAA,GAAcF,gBAAgB,CAAA,OAAA,EAAA,iBAAA,EAA9B,UAA8B,CAA9B;EAEA;AACJ;AACA;AACA;AACA;AACA;;EACI,KAAA,OAAA,GAAe,OAAA,sBAAA,EAAA,KAAA,EAAA,cAAA,KAA0D;IACrEI,KAAK,CAALA,cAAAA,GAAuBC,cAAc,IAAID,KAAK,CAA9CA,cAAAA;IACA,OAAOE,sBAAsB,CAAA,iBAAA,EAAqBJ,OAAO,CAA5B,MAAA,EAA7B,KAA6B,CAA7B;EAFJ,CAAA;AAzBJ,CAAA;AA+BA;AACA;AACA;;;MAjCMC,c;MAAAA,c;AAkCN,OAAO,MAAMI,cAAc,GAAG,UAAA,KAAA,EAgB1B;EAAA,IAhBoC;IAAA,EAAA;IAAA,QAAA;IAAA,KAAA;IAAA,aAAA;IAAA,IAAA;IAAA,YAAA;IAAA,SAAA;IAAA,eAAA;IAAA,uBAAA;IAAA,WAAA;IAAA,mBAAA;IAAA,IAAA;IAAA,QAAA;IAcpCC,iBAAiB,GAdmB,IAAA;IAepCC;EAfoC,IAgBpC,KAAA,CAAA,CACA;;EACA,KAAA,EAAA,GAFA,EAEA,CAFA,CAIA;;EACA,KAAA,QAAA,GALA,QAKA,CALA,CAOA;;EACA,KAAA,KAAA,GAAA,KAAA;EACA,KAAA,aAAA,GATA,aASA,CATA,CAWA;;EACA,KAAA,IAAA,GAAA,IAAA;EACA,KAAA,YAAA,GAAA,YAAA;EACA,KAAA,SAAA,GAAA,SAAA;EACA,KAAA,eAAA,GAAA,eAAA;EACA,KAAA,uBAAA,GAAA,uBAAA;EACA,KAAA,WAAA,GAAA,WAAA;EACA,KAAA,mBAAA,GAAA,mBAAA;EACA,KAAA,IAAA,GAAA,IAAA;EAEA,KAAA,QAAA,GAAA,QAAA;EAEA,KAAA,iBAAA,GAAA,iBAAA;EACA,KAAA,WAAA,GAAA,WAAA;EAEA,KAAA,KAAA,GAAa,IAAA,KAAA,CAAY,WAAUC,EAAnC,EAAa,CAAb;EACA,KAAA,KAAA,CAAA,iBAAA,EAAA,IAAA;AA3CG,CAAA;AA8CP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MAtDaH,c;MAAAA,c;;AAuDb,MAAMI,YAAY,GAAG,OAAA,GAAA,EAAA,SAAA,KAA2B;EAC5C,MAAMC,QAAQ,GAAGC,SAAS,CAATA,IAAAA,CAAAA,GAAAA,IAAwBA,SAAS,CAATA,IAAAA,CAAAA,GAAAA,EAAxBA,CAAwBA,CAAxBA,GAAjB,EAAA;EACA,OAAOC,gBAAgB,CAAA,QAAA,EAAvB,GAAuB,CAAvB;AAFJ,CAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG,OAAA,OAAA,EAAA,SAAA,KAA+B;EAC/C,IAAI,OAAA,OAAA,KAAJ,QAAA,EAAkC;IAC9B,MAAMC,SAAS,GAAGC,+BAA+B,CAAjD,OAAiD,CAAjD;IACA,MAAMC,KAAK,GAAGF,SAAS,CAATA,UAAAA,CAAAA,OAAAA,IAAkC,MAAML,YAAY,CAAEK,SAAS,CAATA,KAAAA,CAAF,CAAEA,CAAF,EAApDA,SAAoD,CAApDA,GAAd,SAAA;IACA,OAAO;MAAA,KAAA;MAEHG,UAAU,EAAE;IAFT,CAAP;EAIH;;EACD,IAAI,OAAA,OAAA,KAAJ,QAAA,EAAkC;IAC9B,MAAM;MAAED;IAAF,IAAY,MAAMH,WAAW,CAAEK,OAAO,CAAT,IAAA,EAAnC,SAAmC,CAAnC;IACA,OAAO;MAAA,KAAA;MAEHD,UAAU,EAAEC,OAAO,CAAPA,MAAAA,IAAkBA,OAAO,CAACD;IAFnC,CAAP;EAIH;;EACD,OAAA,IAAA;AAhBJ,CAAA;AAmBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,cAAc,GAAGC,UAAU,IAAI;EACjC,IAAIA,UAAU,CAAd,SAAA,EAA2B;IACvB,OAAA,SAAA;EACH;;EACD,IAAIA,UAAU,CAAd,QAAA,EAA0B;IACtB,OAAA,QAAA;EACH;;EACD,IAAIA,UAAU,CAAd,OAAA,EAAyB;IACrB,OAAA,OAAA;EACH;;EACD,IAAIA,UAAU,CAAd,QAAA,EAA0B;IACtB,OAAA,QAAA;EACH;;EACD,OAAA,MAAA;AAbJ,CAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,UAAU,GAAG,OAAA,EAAA,EAAA,QAAA,KAAyB;EAC/C,MAAM5B,iBAAiB,GAAG,MAAMI,GAAG,CAAnC,oBAAgCA,EAAhC;EACA,OAAOyB,kBAAkB,CAAA,EAAA,EAAA,iBAAA,EAAA,IAAA,EAAzB,QAAyB,CAAzB;AAFG,CAAA;;AAKP,MAAMC,kBAAkB,GAAG,OAAA,QAAA,EAAA,iBAAA,KAAwC;EAC/D,MAAMC,qCAAqC,GAAKC,WAAF,IAAmB;IAC7D,IAAIA,WAAW,IAAIA,WAAW,CAA9B,SAAA,EAA2C;MACvC,OAAOA,WAAW,CAAlB,SAAA;IACH;;IACD,IAAIA,WAAW,KAAf,KAAA,EAA4B;MACxB,OAAA,kBAAA;IACH;;IACD,OAAA,iBAAA;EAPJ,CAAA;;EAUA,IAAIT,KAAK,GAAGD,+BAA+B,CAAEW,QAAQ,CAArD,IAA2C,CAA3C;;EACA,IAAIV,KAAK,CAALA,UAAAA,CAAJ,OAAIA,CAAJ,EAAkC;IAC9B,OAAO;MACHW,IAAI,EAAE,MAAMd,WAAW,CAAEa,QAAQ,CAAV,IAAA,EADpB,iBACoB,CADpB;MAEHD,WAAW,EAAE,OAAOC,QAAQ,CAAf,WAAA,KAAA,SAAA,GAA4C,IAAA,oBAAA,CAA0BF,qCAAqC,CAAEE,QAAQ,CAAzE,WAA+D,CAA/D,EAA5C,iBAA4C,CAA5C,GAFV,IAAA;MAGHE,KAAK,EAAEF,QAAQ,CAARA,KAAAA,GAAiBA,QAAQ,CAAzBA,KAAAA,GAAkC;IAHtC,CAAP;EAKH;;EAED,OAAO;IACHC,IAAI,EAAE;MACFX,KAAK,EADH,KAAA;MAEFC,UAAU,EAAE,CAAES,QAAQ,CAAV,IAAA;IAFV,CADH;IAKHD,WAAW,EAAE,OAAOC,QAAQ,CAAf,WAAA,KAAA,SAAA,GAA4C,IAAA,oBAAA,CAA0BF,qCAAqC,CAAEE,QAAQ,CAAzE,WAA+D,CAA/D,EAA5C,iBAA4C,CAA5C,GALV,IAAA;IAMHE,KAAK,EAAEF,QAAQ,CAARA,KAAAA,GAAiBA,QAAQ,CAAzBA,KAAAA,GAAkC;EANtC,CAAP;AApBJ,CAAA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMJ,kBAAkB,GAAG,gBAAA,EAAA,EAAA,iBAAA,EAAqE;EAAA,IAAvCO,SAAuC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA3B,IAA2B;EAAA,IAArBC,QAAqB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAV,IAAU;EAC5F,MAAMV,UAAU,GAAG3B,iBAAiB,CAAjBA,QAAAA,CAAnB,EAAmBA,CAAnB;;EACA,IAAI,CAAJ,UAAA,EAAkB;IACdsC,MAAM,CAANA,KAAAA,CAAe,kCAAiCvB,EAAhDuB,EAAAA;EACH;;EACD,MAAMC,IAAI,GAAGb,cAAc,CAA3B,UAA2B,CAA3B;EAEA,MAAMc,QAAQ,GAAGD,IAAI,KAAJA,OAAAA,IAAoBA,IAAI,KAAxBA,SAAAA,GAAyC,CAAE,IAAA,cAAA,CAAA,qBAAA,EAA2C;IACnGE,UAAU,EAAE;MACRtC,SAAS,EAAE;IADH,CADuF;IAInGuC,MAAM,EAAE;EAJ2F,CAA3C,EAAA,iBAAA,EAA3CH,UAA2C,CAAF,CAAzCA,GAKsB,qBAAqB,CAAA,EAAA,EAAA,iBAAA,EAArB,QAAqB,CAArB,CAAA,GAAA,CAC7B,KAAA,IAAA;IAAA,IAAE,CAAA,SAAA,EAAF,KAAE,IAAF,KAAA;IAAA,OAA4B,IAAA,cAAA,CAAA,SAAA,EAAA,KAAA,EAAA,iBAAA,EAA5B,UAA4B,CAA5B;EAD6B,CAAA,EAAA,IAAA,CAE5B,CAAA,CAAA,EAAA,CAAA,KAAYI,CAAC,CAADA,QAAAA,GAAaC,CAAC,CAPrC,QAKuC,CALvC;EASA,MAAMC,IAAI,GAAGlB,UAAU,CAAvB,MAAA;EACA,MAAMmB,YAAY,GAAGnB,UAAU,CAAVA,QAAAA,GAAsBA,UAAU,CAAVA,QAAAA,CAAtBA,MAAAA,GAjBuE,IAiB5F,CAjB4F,CAmB5F;;EACA,MAAMoB,eAAe,GAAGpB,UAAU,CAAlC,eAAA;EACA,MAAMqB,uBAAuB,GAAGrB,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAvBA,eAAAA,GAA6DA,UAAU,CAAVA,QAAAA,CAA7DA,eAAAA,GAAhC,IAAA;EAEA,MAAM,CAAA,KAAA,EAAA,aAAA,EAAA,WAAA,EAAA,mBAAA,EAAA,SAAA,IAAwE,MAAMsB,OAAO,CAAPA,GAAAA,CAAa,CAC7F7B,WAAW,CAAEO,UAAU,CAAZ,KAAA,EADkF,iBAClF,CADkF,EAE7FA,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAvBA,KAAAA,GAAmDP,WAAW,CAAEO,UAAU,CAAVA,QAAAA,CAAF,KAAA,EAA9DA,iBAA8D,CAA9DA,GAF6F,IAAA,EAG7FA,UAAU,CAAVA,WAAAA,GAAyB,MAAMP,WAAW,CAAEO,UAAU,CAAZ,WAAA,EAA1CA,iBAA0C,CAA1CA,GAH6F,IAAA,EAI7FA,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAvBA,WAAAA,GAAyDP,WAAW,CAAEO,UAAU,CAAVA,QAAAA,CAAF,WAAA,EAApEA,iBAAoE,CAApEA,GAJ6F,IAAA,EAK7FA,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAvBA,IAAAA,GAAkDG,kBAAkB,CAAEH,UAAU,CAAZ,QAAA,EAApEA,iBAAoE,CAApEA,GALJ,IAAiG,CAAbsB,CAApF;EAQA,MAAMC,QAAQ,GAAGX,IAAI,KAAJA,OAAAA,IAAoBA,IAAI,KAAxBA,SAAAA,GAAyC,MAAMY,WAAW,CAA1DZ,EAA0D,CAA1DA,GAAjB,EAAA;EAEA,OAAO,IAAA,cAAA,CAAoB;IACvB1B,iBAAiB,EAAE,CAAA,SAAA,IAAcuB,SAAS,CAATA,iBAAAA,KADV,KAAA;IAAA,EAAA;IAAA,QAAA;IAAA,KAAA;IAAA,aAAA;IAAA,IAAA;IAAA,YAAA;IAAA,SAAA;IAAA,eAAA;IAAA,uBAAA;IAAA,WAAA;IAAA,mBAAA;IAAA,IAAA;IAAA,QAAA;IAevBtB,WAAW,EAAEsB,SAAS,GAAGA,SAAS,CAAZ,WAAA,GAA2B;EAf1B,CAApB,CAAP;AAjCJ,CAAA;AAoDA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,cAAc,GAAG,UAAA,UAAA,EAAuB;EAC1C;EACAC,UAAU,CAAVA,OAAAA,CAAoB,UAAA,GAAA,EAAgB;IAChCC,GAAG,CAAHA,QAAAA,GAAeA,GAAG,CAAHA,QAAAA,IAAfA,CAAAA;EAHsC,CAE1CD,EAF0C,CAM1C;;EACA,MAAME,CAAC,GAAG,CAAC,CAAD,SAAA,CAAA,UAAA,EAAyB,UAAA,GAAA,EAAgB;IAC/C,OAAOD,GAAG,CAAV,UAAA;EARsC,CAOhC,CAAV,CAP0C,CAU1C;;;EACA,MAAME,gBAAgB,GAAGC,CAAC,CAADA,MAAAA,CAAUF,CAAC,CAAXE,CAAW,CAAXA,EAXiB,UAWjBA,CAAzB,CAX0C,CAa1C;;;EACA,MAAMC,eAAe,GAAGD,CAAC,CAADA,OAAAA,CAAWF,CAAC,CAAZE,CAAY,CAAZA,EAAxB,YAAwBA,CAAxB;;EAEA,MAAME,yBAAyB,GAAG,gBAAgB,CAAhB,MAAA,CAAyB,CAAA,GAAA,EAAA,SAAA,KAAsB;IAC7E;IACA,MAAMC,EAAE,GAAG,CAAC,CAAD,SAAA,CAAaF,eAAe,CAAEtB,SAAS,CAA1BsB,EAAe,CAAfA,IAAb,EAAA,EAAoD,UAAA,GAAA,EAAgB;MAC3E,OAAOJ,GAAG,CAAHA,QAAAA,GAAP,CAAA;IADJ,CAAW,CAAX;;IAGA,MAAMO,eAAe,GAAGJ,CAAC,CAADA,MAAAA,CAAUG,EAAE,CAAZH,CAAY,CAAZA,EAAxB,UAAwBA,CAAxB;;IACA,MAAMK,gBAAgB,GAAGL,CAAC,CAADA,MAAAA,CAAUG,EAAE,CAAZH,CAAY,CAAZA,EANoD,UAMpDA,CAAzB,CAN6E,CAO7E;;;IACA,OAAOC,eAAe,CAAEtB,SAAS,CAAjC,EAAsB,CAAtB;IACA,OAAO,CAAE,GAAF,GAAA,EAAU,GAAV,gBAAA,EAAA,SAAA,EAA0C,GAAjD,eAAO,CAAP;EAT8B,CAAA,EAhBQ,EAgBR,CAAlC,CAhB0C,CA4B1C;;EACA,OAAO,MAAM,CAAN,MAAA,CAAA,eAAA,EAAA,MAAA,CAAyC,CAAA,GAAA,EAAA,kBAAA,KAA+B;IAC3EE,MAAM,CAANA,KAAAA,CAAe,mCAAkCyB,kBAAkB,CAAlBA,CAAkB,CAAlBA,CAAsBhD,EAAvEuB,2CAAAA,EAAAA,kBAAAA;IACA,OAAO,CAAE,GAAF,GAAA,EAAU,GAAjB,kBAAO,CAAP;EAFG,CAAA,EAAP,yBAAO,CAAP;AA7BJ,CAAA;AAmCA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMa,WAAW,GAAG,OAAA,MAAA,EAAA,QAAA,KAA6B;EACpD,MAAMnD,iBAAiB,GAAG,MAAMI,GAAG,CAAnC,oBAAgCA,EAAhC;EACA,MAAM4D,OAAO,GAAGC,MAAM,CAANA,KAAAA,CAAhB,GAAgBA,CAAhB;EACA,MAAMC,aAAa,GAAG,CAAE,GAAF,iBAAA,EAAwB,GAAGC,MAAM,CAANA,MAAAA,CAAenE,iBAAiB,CAAjF,iBAAiDmE,CAA3B,CAAtB;EACA,MAAMd,UAAU,GAAGe,MAAM,CAAE,OAAO,CAAP,MAAA,CAAgB,CAAA,iBAAA,EAAA,UAAA,KAAqC;IAC5E,MAAMC,aAAa,GAAGH,aAAa,CAAbA,MAAAA,CACT9B,SAAS,IAAI,CAACA,SAAS,CAAV,aAAA,IAA4BA,SAAS,CAATA,QAAAA,KAA5B,UAAA,IAAiEpC,iBAAiB,CAAjBA,QAAAA,CAA4BoC,SAAS,CADhI,EAC2FpC,CADrEkE,CAAtB;IAEA,OAAO,CAAE,GAAF,iBAAA,EAAwB,GAA/B,aAAO,CAAP;EAHuB,CAAA,EAAF,EAAE,CAAF,EAAzB,IAAyB,CAAzB;EAMA,IAAII,gBAAgB,GAAGlB,cAAc,CAArC,UAAqC,CAArC;EAGA,MAAMmB,QAAQ,GAAG,MAAMtB,OAAO,CAAPA,GAAAA,CAAaqB,gBAAgB,CAAhBA,GAAAA,CAAsBlC,SAAS,IAAIP,kBAAkB,CAAEO,SAAS,CAAX,EAAA,EAAA,iBAAA,EAAA,SAAA,EAAzF,QAAyF,CAArDkC,CAAbrB,CAAvB;;EACA,IAAA,MAAA,EAAa;IACTuB,YAAY,CAAZA,yBAAAA,CAAAA,MAAAA,EAAAA,QAAAA;IACAA,YAAY,CAAZA,UAAAA,CAAAA,MAAAA,EAAAA,QAAAA;EACH;;EACD,OAAA,QAAA;AAlBG,CAAA;AAqBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAKpB,UAAF,IAAkB;EAC3CzD,KAAK,CAAA,0BAAA,EAALA,UAAK,CAALA;EACAC,iBAAiB,GAAG,CAAE,GAAF,iBAAA,EAAwB,GAA5CA,UAAoB,CAApBA;EACA,OAAO;IAAA,UAAA;IAEH6E,MAAM,EAAE,MAAM;MACV7E,iBAAiB,GAAGA,iBAAiB,CAAjBA,MAAAA,CAA0B8E,CAAC,IAAI,CAACtB,UAAU,CAAVA,QAAAA,CAApDxD,CAAoDwD,CAAhCxD,CAApBA;MACAD,KAAK,CAAA,4BAAA,EAALA,UAAK,CAALA;IACH;EALE,CAAP;AAHG,CAAA;AAYP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMgF,iBAAiB,GAAG,UAAA,YAAA,EAAA,gBAAA,EAA2C;EACxE,IAAIC,eAAe,GAAI,yDAAwDC,YAAY,GAAA,YAAA,GAAkBC,gBAA7G,IAAA;EACA,IAAIC,UAAU,GAAGC,SAAS,CAATA,iBAAAA,CAAAA,eAAAA,EAA8CC,QAAQ,CAAvE,IAAiBD,CAAjB;;EACA,IAAA,UAAA,EAAiB;IACb,MAAME,GAAG,GAAG,MAAM,CAAN,IAAA,CAAA,UAAA,EAAA,IAAA,CAAgCA,GAAG,IAAI;MAC/C,OAAOA,GAAG,CAAHA,UAAAA,CAAP,eAAOA,CAAP;IADJ,CAAY,CAAZ;IAGA,MAAMC,eAAe,GAAGJ,UAAU,CAAlC,GAAkC,CAAlC;;IACA,IAAII,eAAe,CAAfA,MAAAA,CAAAA,aAAAA,CAAJ,cAAA,EAA0D;MACtD,OAAOA,eAAe,CAAfA,MAAAA,CAAAA,aAAAA,CAAP,cAAA;IANS,CAAA,CAQb;;;IACA,IAAIC,YAAY,GAAGD,eAAe,CAAlC,MAAA;;IACA,OAAO,OAAOC,YAAY,CAAnB,IAAA,KAAP,QAAA,EAA+C;MAC3CA,YAAY,GAAGA,YAAY,CAA3BA,MAAAA;IACH;;IACD,OAAOA,YAAY,CAAZA,MAAAA,CAAAA,aAAAA,CAAP,cAAA;EACH;;EACD,OAAA,IAAA;AAlBG,CAAA;AAsBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAuB,GAAG,UAAA,QAAA,EAAA,KAAA,EAA4B;EAC/D,KAAK,MAAL,OAAA,IAAA,QAAA,EAAiC;IAC7B,MAAMC,QAAQ,GAAGC,OAAO,CAAEC,gBAAgB,CAAhBA,iBAAAA,CAAAA,EAAAA,EAAwClF,OAAO,CAAPA,UAAAA,CAAxCkF,UAAAA,EAA1B,KAA0BA,CAAF,CAAxB;;IACA,IAAA,QAAA,EAAe;MACX,OAAA,OAAA;IACH;EACJ;;EACD,OAAA,IAAA;AAPG,CAAA;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,4BAA4B,GAAG,UAAA,aAAA,EAAA,KAAA,EAAiC;EACzE,MAAM1D,WAAW,GAAI2D,aAAa,CAAbA,WAAAA,GAA4BH,OAAO,CAAEC,gBAAgB,CAAhBA,iBAAAA,CAAAA,EAAAA,EAAwCE,aAAa,CAAbA,WAAAA,CAAxCF,UAAAA,EAArCE,KAAqCF,CAAF,CAAnCE,GAArB,IAAA;EACA,MAAMC,UAAU,GAAGD,aAAa,CAAbA,UAAAA,GAA2BH,OAAO,CAAEC,gBAAgB,CAAhBA,iBAAAA,CAAAA,EAAAA,EAAwCE,aAAa,CAAbA,UAAAA,CAAxCF,UAAAA,EAApCE,KAAoCF,CAAF,CAAlCE,GAAnB,IAAA;EACA,OAAO3D,WAAW,IAAlB,UAAA;AAHG,CAAA;AAMP,eAAe;EAAA,UAAA;EAAA,WAAA;EAAA,iBAAA;EAAA,uBAAA;EAKX0D;AALW,CAAf","sourcesContent":["/* eslint-disable valid-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n *\n * @module js/commandConfigurationService\n */\nimport _, { uniqBy } from 'lodash';\nimport logger from 'js/logger';\nimport 'js/iconService';\nimport ccu from 'js/commandConfigUtils.service';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\nimport { getLocalizedText } from 'js/localeService';\nimport Debug from 'debug';\nimport debugService from 'js/debugService';\nimport conditionService from 'js/conditionService';\nimport htmlUtils from 'js/htmlUtils';\nconst trace = new Debug( 'command:AwCommandBar' );\n\n//TODO: Global state that should not be managed in a service - revisit later\nlet dynamicPlacements = [];\nconst handlerCache = {};\nconst getHandlersForCommand = ( id, commandsViewModel, useCache ) => {\n    if( !handlerCache[ id ] || !useCache ) {\n        handlerCache[ id ] = Object.entries( commandsViewModel.commandHandlers )\n            .filter( ( [ , v ] ) => v.id === id );\n    }\n    return handlerCache[ id ];\n};\n\nconst DeclarativeCondition = function( condition, commandsViewModel ) {\n    this.id = condition.split( '.' ).slice( -1 )[ 0 ];\n    this.expression = ccu.getConditionExpression( commandsViewModel, condition );\n};\n\nconst getHandlerAction = ( handler, commandsViewModel, { isRibbon } ) => {\n    if( isRibbon ) {\n        //Ribbon commands use their configured action or open popup with child commands if not configured\n        return commandsViewModel.actions[ handler.action || 'openCommandGroup' ];\n    }\n    if( handler.action ) {\n        //Base commands use their configured action\n        return commandsViewModel.actions[ handler.action ];\n    }\n    return null;\n};\n\n/**\n * Command handler information from commandsViewModel\n *\n * Will be used by AwCommand to setup any necessary hooks and process\n */\nconst CommandHandler = function( id, handler, commandsViewModel, definition ) {\n    // String :: ID of the command handler\n    this.id = id;\n    // DeclarativeCondition :: Active condition for this handler\n    this.activeWhen = new DeclarativeCondition( handler.activeWhen.condition, commandsViewModel );\n    // Number :: Priority of the command handler (length of the activeWhen condition)\n    this.priority = ccu.getExpressionLength( this.activeWhen.expression, commandsViewModel );\n    // DeclarativeCondition :: Enabled state condition for this handler\n    this.enableWhen = handler.enableWhen ? new DeclarativeCondition( handler.enableWhen.condition, commandsViewModel ) : null;\n    // DeclarativeCondition :: Selected state condition for this handler\n    this.selectWhen = handler.selectWhen ? new DeclarativeCondition( handler.selectWhen.condition, commandsViewModel ) : null;\n    // DeclarativeCondition :: Visibility condition for this handler\n    this.visibleWhen = handler.visibleWhen ? new DeclarativeCondition( handler.visibleWhen.condition, commandsViewModel ) : null;\n\n    /**\n     * The action that this handler will execute\n     */\n    this.action = getHandlerAction( handler, commandsViewModel, definition );\n\n    /**\n     * Callback function to execute this command handler\n     *\n     * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model\n     * @returns {CommandExecutionResult}\n     */\n    this.execute = async( runActionWithViewModel, scope, commandContext ) => {\n        scope.commandContext = commandContext || scope.commandContext;\n        return runActionWithViewModel( commandsViewModel, handler.action, scope );\n    };\n};\n\n/**\n * The raw data from commands view model that will be used to determine the current command state\n */\nexport const CommandOverlay = function( {\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    showGroupSelected = true,\n    cellDisplay\n} ) {\n    // String! :: ID of the command\n    this.id = id;\n\n    // [CommandHandler] :: Handlers for this command\n    this.handlers = handlers;\n\n    // I18nReference :: Title definition of the command\n    this.title = title;\n    this.selectedTitle = selectedTitle;\n\n    // String :: ID of the command icon\n    this.icon = icon;\n    this.selectedIcon = selectedIcon;\n    this.decorator = decorator;\n    this.extendedTooltip = extendedTooltip;\n    this.selectedExtendedTooltip = selectedExtendedTooltip;\n    this.description = description;\n    this.selectedDescription = selectedDescription;\n    this.type = type;\n\n    this.children = children;\n\n    this.showGroupSelected = showGroupSelected;\n    this.cellDisplay = cellDisplay;\n\n    this.trace = new Debug( `command:${id}` );\n    this.trace( 'Overlay created', this );\n};\n\n/**\n * Get the i18n string configured in the given view model\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String} key Key within the i18n section\n * @param {Object} viewModel View model json\n * @returns {String} The localized text value\n */\nconst getI18nValue = async( key, viewModel ) => {\n    const resource = viewModel.i18n[ key ] ? viewModel.i18n[ key ][ 0 ] : '';\n    return getLocalizedText( resource, key );\n};\n\n/**\n * Resolve an i18n reference\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String|Object} i18nRef Reference information\n * @param {Object} viewModel View model json\n * @returns {Object} The string value and a list of any parameters it may have\n */\nconst resolveI18n = async( i18nRef, viewModel ) => {\n    if( typeof i18nRef === 'string' ) {\n        const reference = getStringBetweenDoubleMustaches( i18nRef );\n        const value = reference.startsWith( 'i18n.' ) ? await getI18nValue( reference.slice( 5 ), viewModel ) : reference;\n        return {\n            value,\n            parameters: []\n        };\n    }\n    if( typeof i18nRef === 'object' ) {\n        const { value } = await resolveI18n( i18nRef.text, viewModel );\n        return {\n            value,\n            parameters: i18nRef.params || i18nRef.parameters\n        };\n    }\n    return null;\n};\n\n/**\n * Get the type of a command\n *\n * @param {Object} definition Command definition\n * @returns {String} Command type\n */\nconst getCommandType = definition => {\n    if( definition.isShuttle ) {\n        return 'SHUTTLE';\n    }\n    if( definition.isRibbon ) {\n        return 'RIBBON';\n    }\n    if( definition.isGroup ) {\n        return 'GROUP';\n    }\n    if( definition.isToggle ) {\n        return 'TOGGLE';\n    }\n    return 'BASE';\n};\n\n/**\n * Get a command overlay\n *\n * @param {String} id ID of the command\n * @returns {CommandOverlay} Overlay for the command\n */\nexport const getCommand = async( id, useCache ) => {\n    const commandsViewModel = await ccu.getCommandsViewModel();\n    return getCommandInternal( id, commandsViewModel, null, useCache );\n};\n\nconst getDecoratorObject = async( template, commandsViewModel ) => {\n    const checkVisbleWhenConditionForConversion = ( visibleWhen ) => {\n        if( visibleWhen && visibleWhen.condition ) {\n            return visibleWhen.condition;\n        }\n        if( visibleWhen === false ) {\n            return 'conditions.false';\n        }\n        return 'conditions.true';\n    };\n\n    let value = getStringBetweenDoubleMustaches( template.text );\n    if( value.startsWith( 'i18n.' ) ) {\n        return {\n            text: await resolveI18n( template.text, commandsViewModel ),\n            visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,\n            class: template.class ? template.class : null\n        };\n    }\n\n    return {\n        text: {\n            value: '{0}',\n            parameters: [ template.text ]\n        },\n        visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,\n        class: template.class ? template.class : null\n    };\n};\n\n/**\n * Load the necessary data to create a CommandOverlay and return it\n *\n * @param {String} id ID of the command\n * @param {Object} commandsViewModel Commands view model json\n * @param {Object} placement (Optional) Placement information\n */\nconst getCommandInternal = async( id, commandsViewModel, placement = null, useCache = true ) => {\n    const definition = commandsViewModel.commands[ id ];\n    if( !definition ) {\n        logger.error( `Missing command definition for ${id}` );\n    }\n    const type = getCommandType( definition );\n\n    const handlers = type === 'GROUP' || type === 'SHUTTLE' ? [ new CommandHandler( 'GroupCommandHandler', {\n        activeWhen: {\n            condition: 'conditions.true'\n        },\n        action: 'openCommandGroup'\n    }, commandsViewModel, definition ) ] : getHandlersForCommand( id, commandsViewModel, useCache )\n        .map( ( [ handlerId, value ] ) => new CommandHandler( handlerId, value, commandsViewModel, definition ) )\n        .sort( ( a, b ) => b.priority - a.priority );\n\n    const icon = definition.iconId;\n    const selectedIcon = definition.selected ? definition.selected.iconId : null;\n\n    //TODO: Some stuff (i18n) may need to be resolved here\n    const extendedTooltip = definition.extendedTooltip;\n    const selectedExtendedTooltip = definition.selected && definition.selected.extendedTooltip ? definition.selected.extendedTooltip : null;\n\n    const [ title, selectedTitle, description, selectedDescription, decorator ] = await Promise.all( [\n        resolveI18n( definition.title, commandsViewModel ),\n        definition.selected && definition.selected.title ? resolveI18n( definition.selected.title, commandsViewModel ) : null,\n        definition.description ? await resolveI18n( definition.description, commandsViewModel ) : null,\n        definition.selected && definition.selected.description ? resolveI18n( definition.selected.description, commandsViewModel ) : null,\n        definition.template && definition.template.text ? getDecoratorObject( definition.template, commandsViewModel ) : null\n    ] );\n\n    const children = type === 'GROUP' || type === 'SHUTTLE' ? await getCommands( id ) : [];\n\n    return new CommandOverlay( {\n        showGroupSelected: !placement || placement.showGroupSelected !== false,\n        id,\n        handlers,\n        title,\n        selectedTitle,\n        icon,\n        selectedIcon,\n        decorator,\n        extendedTooltip,\n        selectedExtendedTooltip,\n        description,\n        selectedDescription,\n        type,\n        children,\n        cellDisplay: placement ? placement.cellDisplay : null\n    } );\n};\n\n/**\n * Sort the placements based on relativeTo and priority. Priority is 0 if not set.\n *\n * @param {[CommandPlacement]} placements - placements\n * @return {[CommandPlacement]} Sorted list of command placements\n */\nconst sortPlacements = function( placements ) {\n    // Assign a priority to any placement that doesn't have one\n    placements.forEach( function( cmd ) {\n        cmd.priority = cmd.priority || 0;\n    } );\n\n    // Split based on whether placement is relative or absolute\n    const p = _.partition( placements, function( cmd ) {\n        return cmd.relativeTo;\n    } );\n    // Sort the commands with only priority\n    const priorityCommands = _.sortBy( p[ 1 ], 'priority' );\n\n    // Group the relative commands by the relativeTo property\n    const allRelativeCmds = _.groupBy( p[ 0 ], 'relativeTo' );\n\n    const commandsWithRelativeAdded = priorityCommands.reduce( ( acc, placement ) => {\n        // Split into before / after based on negative / positive priority\n        const p2 = _.partition( allRelativeCmds[ placement.id ] || [], function( cmd ) {\n            return cmd.priority > 0;\n        } );\n        const afterPlacements = _.sortBy( p2[ 0 ], 'priority' );\n        const beforePlacements = _.sortBy( p2[ 1 ], 'priority' );\n        //side effect, could be refactored later\n        delete allRelativeCmds[ placement.id ];\n        return [ ...acc, ...beforePlacements, placement, ...afterPlacements ];\n    }, [] );\n\n    //Add any placement with relativeTo that is not in this command bar to the end\n    return Object.values( allRelativeCmds ).reduce( ( acc, missingRelativeSet ) => {\n        logger.debug( `Unable to find relative command ${missingRelativeSet[0].id}. Commands will be placed at end of list.`, missingRelativeSet );\n        return [ ...acc, ...missingRelativeSet ];\n    }, commandsWithRelativeAdded );\n};\n\n/**\n * Get the commands for the given anchor\n *\n * @param {String} anchor anchor\n * @returns {[CommandOverlay]} Command overlays for the anchor\n */\nexport const getCommands = async( anchor, useCache ) => {\n    const commandsViewModel = await ccu.getCommandsViewModel();\n    const anchors = anchor.split( ',' );\n    const allPlacements = [ ...dynamicPlacements, ...Object.values( commandsViewModel.commandPlacements ) ];\n    const placements = uniqBy( anchors.reduce( ( fullPlacementList, nextAnchor ) => {\n        const newPlacements = allPlacements\n            .filter( placement => !placement.parentGroupId && placement.uiAnchor === nextAnchor && commandsViewModel.commands[ placement.id ] );\n        return [ ...fullPlacementList, ...newPlacements ];\n    }, [] ), 'id' );\n\n    let placementsSorted = sortPlacements( placements );\n\n\n    const commands = await Promise.all( placementsSorted.map( placement => getCommandInternal( placement.id, commandsViewModel, placement, useCache ) ) );\n    if( anchor ) {\n        debugService.debugGetCommandsForAnchor( anchor, commands );\n        debugService.reduceData( anchor, commands );\n    }\n    return commands;\n};\n\n/**\n * Add a placement for a command at runtime. All placements\n * must be defined before the AwCommandBar with the matching\n * anchor is rendered\n *\n * @param {[CommandPlacement]} placements Placements to add\n * @returns {Object} Tracking information to all for removal of the placements\n */\nexport const addPlacements = ( placements ) => {\n    trace( 'Dynamic placements added', placements );\n    dynamicPlacements = [ ...dynamicPlacements, ...placements ];\n    return {\n        placements,\n        remove: () => {\n            dynamicPlacements = dynamicPlacements.filter( x => !placements.includes( x ) );\n            trace( 'Dynamic placements removed', placements );\n        }\n    };\n};\n\n/**\n * Get the commandContext of a given command bar/group\n *\n * @param {String} grpCmdAnchor - the group id/anchor for a given command group\n * @param {String} commandBarAnchor - the anchor for a given command bar\n * @returns {Object} commandContext for given command group or command bar\n */\nexport const getCommandContext = function( grpCmdAnchor, commandBarAnchor ) {\n    let commandBarXPath = `//div[contains(@class, 'aw-command-bar') and @anchor='${grpCmdAnchor ? grpCmdAnchor : commandBarAnchor}']`;\n    let commandBar = htmlUtils.getElementByXpath( commandBarXPath, document.body );\n    if( commandBar ) {\n        const key = Object.keys( commandBar ).find( key => {\n            return key.startsWith( '__reactFiber$' );\n        } );\n        const commandBarFiber = commandBar[ key ];\n        if( commandBarFiber.return.memoizedProps.commandContext ) {\n            return commandBarFiber.return.memoizedProps.commandContext;\n        }\n        // get parent toolbar which has command context\n        let toolbarFiber = commandBarFiber.return;\n        while( typeof toolbarFiber.type === 'string' ) {\n            toolbarFiber = toolbarFiber.return;\n        }\n        return toolbarFiber.return.memoizedProps.commandContext;\n    }\n    return null;\n};\n\n\n/**\n * Given the array of handlers for a command get the activeHandler\n *\n * @param {Array<Handler>} handlers - array of command handlers\n * @param {Object} scope - evaluation scope\n * @returns {Handler} the active handler\n */\nexport const getActiveCommandHandler = function( handlers, scope ) {\n    for( const handler of handlers ) {\n        const isActive = Boolean( conditionService.evaluateCondition( {}, handler.activeWhen.expression, scope ) );\n        if( isActive ) {\n            return handler;\n        }\n    }\n    return null;\n};\n\n/**\n * Check whether a command is enabled and visible\n *\n * @param {Object} activeHandler - active command handler\n * @param {Object} scope - evaluation scope\n * @returns {Boolean} visbleWhen and enableWhen\n */\nexport const getCommandAndCheckVisibility = function( activeHandler, scope ) {\n    const visibleWhen =  activeHandler.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.visibleWhen.expression, scope ) ) : true;\n    const enableWhen = activeHandler.enableWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.enableWhen.expression, scope ) ) : true;\n    return visibleWhen && enableWhen;\n};\n\nexport default {\n    getCommand,\n    getCommands,\n    getCommandContext,\n    getActiveCommandHandler,\n    getCommandAndCheckVisibility\n};\n"]},"metadata":{},"sourceType":"module"}