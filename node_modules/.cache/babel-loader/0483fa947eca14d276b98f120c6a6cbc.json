{"ast":null,"code":"// Copyright (c) 2022 Siemens\n/**\n * A simple and inexpensive HTML Sanitizer which detects and/or eliminates HTML that can cause potential cross-site\n * scripting (XSS) and other UI issues.\n *\n * @module js/sanitizer\n */import _ from'lodash';import localeSvc from'js/localeService';/**\n * HTML 'anchor' regular expression\n *\n * @private\n */var REGEX_FRAGMENT_ANCHOR_SCRIPT=/href=\"[^\"]*?java[^\"]*?\"/;/**\n * HTML 'src=java' regular expression\n *\n * @private\n */var REGEX_FRAGMENT_SRC_SCRIPT=/src=java*/;/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */var REGEX_FRAGMENT_STYLE_SCRIPT=/style=\"[^\"]*?java[^\"]*?\"/;/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */var REGEX_FRAGMENT_STYLE_WEIRD=/style=\"[^\"]*?&[^\"]*?\"/;/**\n * HTML '<style on*=' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */var REGEX_FRAGMENT_STYLE_ATTR=/<style.*(on\\S+)(\\s*)=/;/**\n * HTML entity regular expression\n *\n * @private\n */var REGEX_HTML_ENTITY=/[a-z]+|#[0-9]+|#x[0-9a-fA-F]+/i;/**\n * HTML 'on*' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */var REGEX_IMG_ATTR=/(\\b)(on\\S+)(\\s*)=/i;/**\n * HTML 'base64' regular expression (e.g. 'data:image/jpeg;base64').\n *\n * @private\n */var REGEX_BASE64_IMG=/(\\b)(src=\"data:image\\S+)(\\s*)base64/i;/**\n * HTML escaped entity regular expression\n *\n * @private\n */var REGEX_HTML_ESCAPED_ENTITY=/&[a-z]+;|&#[0-9]+;/i;/**\n * {RegEx} Matches external links\n */var REGEX_URL_PATTERN=/http(|s):\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+#()[\\]\\-])?|http(|s):\\/\\/([\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+\\*#()[\\]\\-])?/gi;// eslint-disable-line no-useless-escape\n/**\n * HTML 'image' regular expression\n *\n * @private\n */var REGEX_INVALID_HTML=new RegExp(REGEX_FRAGMENT_ANCHOR_SCRIPT.source+'|'//\n+REGEX_FRAGMENT_SRC_SCRIPT.source+'|'//\n+REGEX_FRAGMENT_STYLE_SCRIPT.source+'|'//\n+REGEX_FRAGMENT_STYLE_ATTR.source+'|'//\n+REGEX_FRAGMENT_STYLE_WEIRD.source,'i');/**\n * Global array of HTML black list tags used for sanitization\n *\n * @private\n */var TAG_BLACKLIST=['applet','audio','body','embed','fieldset','form','frame','frameset','input','iframe','meta','object','output','param','script','style','textarea','video'];/**\n * Global reference to invalid HTML locale string\n *\n * @private\n */var _invalidHtmlMessage=null;/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */let exports;/**\n * HTML escapes a character. HTML meta characters will be escaped.\n *\n * @private\n *\n * @param {String} unsafe - unsafe HTML String which needs to be escaped.\n *\n * @return {String} Returns escaped and safe HTML String.\n */function _escapeHtml(unsafe){if(!/['\"<>&]+/.test(unsafe)){return unsafe;}return unsafe.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;');}/**\n * HTML meta characters will be un-escaped. This method should be used only after sanitizing the input.\n *\n * @private\n *\n * @param {String} escapedSafe - escapedSafe HTML String which needs to be un-escaped.\n *\n * @return {String} Returns un-escaped and safe HTML String.\n */function _unEscapeHtml(escapedSafe){// eslint-disable-line no-unused-vars\nreturn escapedSafe.replace(/&amp;/ig,'&').replace(/&lt;/ig,'<').replace(/&gt;/ig,'>').replace(/&quot;/ig,'\"').replace(/&#39;/ig,'\\'');}/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n *\n * @param {Boolean} replaceAnchors - TRUE if any HTTP type external references should be wrapped in an HTML <a\n *            href=\"XXXXX\"></a> (i.e. 'anchors').\n *\n * @param {Boolean} replaceNewLines - TRUE if any newline characters should be replaced by an HTML '<BR>'\n *\n * @return {String} Returns escaped and safe HTML.\n */export let htmlEscapeAllowEntities=function(value,replaceAnchors,replaceNewLines){if(_.isString(value)&&value.length>0){if(!/(['\"<>&]+|(http)+|\\n)/i.test(value)){return value;}var escaped;if(!/&+/.test(value)){escaped=_escapeHtml(value);}else{var splitArray=value.split('&',-1);var nSegment=splitArray.length;for(var ndx=0;ndx<nSegment;ndx++){var currSegment=splitArray[ndx];/**\n                 * The first segment is never part of a valid tag;\n                 * <P>\n                 * Note that if the input string starts with a tag, we will get an empty segment at the\n                 * beginning.\n                 */if(ndx===0){escaped=_escapeHtml(currSegment);continue;}var entityEnd=currSegment.indexOf(';');if(entityEnd>0&&REGEX_HTML_ENTITY.test(currSegment.substring(0,entityEnd))){// Concatenate the entity without escaping.\nescaped=escaped.concat('&').concat(currSegment.substring(0,entityEnd+1));// Concatenate the rest of the segment, escaped.\nescaped=escaped.concat(_escapeHtml(currSegment.substring(entityEnd+1)));}else{// The segment did not start with an entity reference, so escape the whole segment.\nescaped=escaped.concat('&amp;').concat(_escapeHtml(currSegment));}}}if(replaceAnchors&&escaped){// replaces url text to hyperlinks\nescaped=escaped.replace(REGEX_URL_PATTERN,'<a href=\"$&\">$&</a>');}if(replaceNewLines&&escaped){// replaces new lines to <br> tags\nescaped=escaped.replace(/\\n/g,'<br/>');}return escaped;}return'';};/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list\n * tags.\n *\n * @param {StringArray} values - Array of HTML Strings which needs to be sanitized.\n *\n * @return {StringArray} Returns sanitized HTML string array.\n */export let sanitizeHtmlValues=function(values){if(values&&values.length>0){for(var ii=values.length-1;ii>=0;ii--){var originalHtml=values[ii];var sanitizedHtml=exports.sanitizeHtmlValue(originalHtml);if(sanitizedHtml&&originalHtml!==sanitizedHtml){values[ii]=sanitizedHtml;}}}return values;};/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n *\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */export let sanitizeHtmlValue=function(rawValue){var sanitized='';var decodedValue='';if(_.isString(rawValue)){// load _invalidHtmlMessage if it is not loaded\nif(!_invalidHtmlMessage){exports.setInvalidHtmlMessage(localeSvc.getLoadedText().INVALID_HTML);}/**\n         * Decode html escaped entity characters before applying sanitization, so that it will also catch\n         * escaped XSS vulnerability attacks.\n         */if(REGEX_HTML_ESCAPED_ENTITY.test(rawValue)){decodedValue=_.unescape(rawValue);}else{decodedValue=rawValue;}/**\n         * Break the string into n+1 segments based on any HTML tags\n         * <P>\n         * Loop for each of these segments.\n         */var splitArray=decodedValue.split('<',-1);var nSplit=splitArray.length;for(var ndx=0;ndx<nSplit;ndx++){var currSegment=splitArray[ndx];/**\n             * The first segment is never part of a valid tag;\n             * <P>\n             * Note that if the input string starts with a tag, we will get an empty segment at the beginning.\n             */if(ndx===0){sanitized=sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));continue;}/**\n             * Determine if the current segment is the start of an attribute-free tag or end-tag in our\n             * whitelist.\n             */var tagStart=0;// will be 1 if this turns out to be an end tag.\nvar tagEnd=currSegment.indexOf('>');var tag=null;var isValidTag=true;var selfClosingTag=false;if(tagEnd>0){if(currSegment.charAt(0)==='/'){tagStart=1;}// for self closing tags ex: '<br />'\nif(currSegment.charAt(tagEnd-1)==='/'){selfClosingTag=true;tagEnd-=1;}tag=currSegment.substring(tagStart,tagEnd);var exist=tag.replace(/\\s(\\w|\\D).*/ig,'');// for attributes\nif(TAG_BLACKLIST.indexOf(exist.toLowerCase().trim())!==-1){isValidTag=false;}if(isValidTag){// concat the tag, not escaping it\nif(tagStart===0){/**\n                         * Check for image attribute script <BR>\n                         * <img src=\"\" onerror=\"alert('securityIssue_img');\"/>\n                         */if(REGEX_BASE64_IMG.test(tag)){// split tag into attributes, and process individually\n// to avoid false positives.\nvar attributes=tag.match(/[\\w-]+=\"[^\"]*\"/g);for(var i=0;i<attributes.length;i++){if(attributes[i].indexOf('src=')<0&&REGEX_IMG_ATTR.test(attributes[i])){return _invalidHtmlMessage;}}}else if(REGEX_IMG_ATTR.test(tag)){return _invalidHtmlMessage;}sanitized=sanitized.concat('<');}else{// we had seen an end-tag\nsanitized=sanitized.concat('</');}if(selfClosingTag){sanitized=sanitized.concat(tag).concat('/>');// concat the rest of the segment, escaping it\nsanitized=sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd+2)));}else{sanitized=sanitized.concat(tag).concat('>');// concat the rest of the segment, escaping it\nsanitized=sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd+1)));}}else{return _invalidHtmlMessage;}}else{sanitized=sanitized.concat('<');sanitized=sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));}}/**\n         * Check for weird style stuff\n         */if(REGEX_INVALID_HTML.test(sanitized)){return _invalidHtmlMessage;}}return rawValue;};/**\n * Set the message that is seen when invalid HTML content is found.\n * <P>\n * Note: This message is normally set based on the value returned by the 'localeService'. This method is marked\n * 'private' and is intended to be used during testing to allow a preditable value to be returned.\n *\n * @private (this method should be used for unit test only)\n *\n * @param {String} message - Localized text to return from 'sanitizeHtmlValue' when some issue is found.\n */export let setInvalidHtmlMessage=function(message){_invalidHtmlMessage=message;};/**\n * Escape markup which Highcharts will unescape internally\n *\n * Full sanitize is not necessary (and causes issues) because Highcharts internally sets as\n * text on DOM element (does not create element from string)\n *\n * @param {String} x Value to escape\n * @returns {String} Escaped value\n */export const escapeMarkup=x=>x.replace(/</g,'&lt;').replace(/>/g,'&gt;');/**\n * This API sanitizes props to be sent to native html elements to avoid console warnings.\n * It however allows to bypass few custom-attributes if mentioned in argument.\n * Use this if any valid custom attributes to be excluded from being filtered out.\n *\n *\n * @param {Object} props - props coming from component.\n * @param {String} htmlElement - name of htmlElement for which a sanitization is requried\n * @returns {Object} sanitizedProps - Returns valid sanitized props good to use on native html element.\n */export const sanitizeHTMLTagProps=(props,htmlElement)=>{//placeHolder to allow custom attributes on given html tag.\n//maintain a list of custom attributes or exception props that are required to bypass sanitization check.\n//Make sure this list shouldn't contribute to react console warnings.\nlet customAttributes;let excludeAttributes=[];switch(htmlElement){case'input':customAttributes=['label','data-locator','onKeyDown','dirty','checked'];break;case'span':customAttributes=['data-locator','value'];excludeAttributes=['aria-label','aria-required'];break;case'div':case'nav':case'main':case'textarea':default:customAttributes=['data-locator'];}let sanitizedProps={};let dummyHtmlElem=document.createElement(htmlElement);let filteredAttribs=Object.keys(props).filter(propName=>!excludeAttributes.includes(propName)&&(propName in dummyHtmlElem||propName.toLowerCase()in dummyHtmlElem||_.camelCase(propName)in dummyHtmlElem||customAttributes.includes(propName)));filteredAttribs.forEach(key=>sanitizedProps[key]=props[key]);return sanitizedProps;};exports={htmlEscapeAllowEntities,sanitizeHtmlValues,sanitizeHtmlValue,setInvalidHtmlMessage,escapeMarkup,sanitizeHTMLTagProps};export default exports;","map":null,"metadata":{},"sourceType":"module"}