{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/uwLovDataService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport eventBus from 'js/eventBus';\nimport dateTimeSvc from 'js/dateTimeService';\nimport _ from 'lodash';\nexport const performLOVOperation = (_ref, operation) => {\n  let {\n    uiProperty,\n    vmo,\n    lovEntry,\n    dataProvider,\n    createUpdateValue,\n    checkLovEntries,\n    dateApi\n  } = _ref;\n\n  if (dateApi) {\n    uwPropertySvc.setDateApi(uiProperty, dateApi);\n  }\n\n  let isPropertyUpdateReqd = false;\n\n  if (operation === 'resetFilterStr') {\n    uiProperty.filterString = null;\n    return Promise.resolve({\n      newProp: null,\n      isPropertyUpdateReqd\n    });\n  } else if (operation === 'filter') {\n    let isDateAndTimeProp = ['DATE', 'DATEARRAY', 'DATETIME'].includes(uiProperty.type);\n\n    if (!isDateAndTimeProp && (lovEntry.isSearchable === true || uiProperty.renderingHint === 'checkboxoptionlov')) {\n      uiProperty.filterString = lovEntry.filterString;\n      return Promise.resolve({\n        newProp: { ...uiProperty\n        },\n        isPropertyUpdateReqd\n      });\n    }\n\n    let lovEntries = dataProvider.vmCollectionObj.vmCollection.loadedVMObjects;\n\n    if (isDateAndTimeProp) {\n      dateApi = uiProperty.dateApi;\n      dateApi.timeValue = lovEntry.propInternalValue;\n      uwPropertySvc.setDateApi(uiProperty, dateApi);\n\n      for (var ndx = 0; ndx < lovEntries.length; ndx++) {\n        if (lovEntries[ndx].propDisplayValue === lovEntry.propDisplayValue) {\n          lovEntry.propInternalValue = lovEntries[ndx].propInternalValue;\n          break;\n        }\n      }\n\n      return Promise.resolve({\n        newProp: { ...uiProperty\n        },\n        isPropertyUpdateReqd: true\n      });\n    } else if (uiProperty.type === 'OBJECT' || uiProperty.type === 'OBJECTARRAY') {\n      // we can't set the dbValue for an object based on filter text, but we can check to see if the\n      // input\n      // has been cleared\n      if (!uiProperty.uiValue) {\n        uiProperty.dbValue = '';\n      }\n    } else if (uiProperty.type === 'STRING') {\n      uiProperty.dbValue = lovEntry.propInternalValue;\n    } else {\n      uiProperty.uiValue = lovEntry.propDisplayValue;\n    }\n\n    if (!uiProperty.isArray) {\n      uiProperty.uiValues = [lovEntry.propDisplayValue];\n      uiProperty.uiValue = lovEntry.propDisplayValue;\n\n      if (uiProperty.type !== 'OBJECT' && uiProperty.type !== 'OBJECTARRAY') {\n        //For Reference property internal value is same as UI value so dont\n        //process it for OBJECT type\n        uiProperty.dbValues = [lovEntry.propInternalValue];\n        uiProperty.dbValue = lovEntry.propInternalValue;\n      }\n    }\n\n    uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;\n    uiProperty.valueUpdated = true;\n    return Promise.resolve({\n      newProp: { ...uiProperty\n      },\n      isPropertyUpdateReqd\n    });\n  } else if (operation === 'validate') {\n    let createInput = function () {\n      let lovEntries = [];\n\n      if (uiProperty.isArray && uiProperty.dbValue instanceof Array) {\n        uiProperty.dbValue.forEach((item, index) => {\n          lovEntries.push({\n            propInternalValue: item,\n            propDisplayValue: uiProperty.displayValues[index]\n          });\n        });\n      } else {\n        lovEntries.push(lovEntry);\n      }\n\n      return lovEntries;\n    };\n\n    let input = {\n      lovEntries: createInput(),\n      viewModelProp: uiProperty,\n      vmo\n    };\n\n    if (uiProperty.type === 'DATEARRAY') {\n      dateApi = uiProperty.dateApi;\n      dateApi.timeValue = lovEntry.propDisplayValue;\n      uwPropertySvc.setDateApi(uiProperty, dateApi);\n    }\n\n    return dataProvider.validateLovAction(input).then(validationResult => {\n      uiProperty.dbOriginalValue = uiProperty.dbValue;\n      uiProperty.uiOriginalValue = uiProperty.uiValue;\n      uwPropertySvc.updateValidationResult(lovEntry, validationResult, uiProperty);\n      eventBus.publish(dataProvider.name + '.validSelectionEvent', {\n        selectedObjects: input.lovEntries,\n        viewModelProp: uiProperty,\n        vmo\n      });\n      return Promise.resolve({\n        newProp: { ...uiProperty\n        },\n        isPropertyUpdateReqd: true\n      });\n    }, validationError => {\n      uwPropertySvc.setServerValidationError(uiProperty, true);\n      uiProperty.error = validationError.message;\n      return Promise.resolve({\n        newProp: uiProperty,\n        isPropertyUpdateReqd\n      });\n    });\n  } else if (operation === 'validateandadd') {\n    let createInput = function () {\n      //get selected LOV entries\n      let lovEntries = [];\n\n      if (uiProperty.isArray && uiProperty.dbValue instanceof Array) {\n        uiProperty.dbValue.forEach((item, index) => {\n          lovEntries.push({\n            propInternalValue: item,\n            propDisplayValue: uiProperty.displayValues[index]\n          });\n        });\n\n        if (!_.isNil(lovEntry.propInternalValue)) {\n          //Add in selected LOV entries so that it can be validated\n          lovEntries.push({\n            propInternalValue: lovEntry.propInternalValue,\n            propDisplayValue: lovEntry.propDisplayValue\n          });\n        }\n      } else {\n        lovEntries.push(lovEntry);\n      }\n\n      return lovEntries;\n    }; //uiProperty.filterString = _.isNil( lovEntry.filterString ) ? lovEntry.propDisplayValue : lovEntry.filterString;\n    //Cascase LOV selecting from Array:Test CFx_Property_Support_Item Cascade Array LOV and Cascade Suggestive Array LOV Properties\n\n\n    uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;\n    uiProperty.filteredLOVEntries = lovEntry.filteredLOVEntries;\n    let input = {\n      lovEntries: createInput(),\n      //selected LOV entries = existing + newly selected values\n      viewModelProp: uiProperty,\n      vmo\n    };\n    return dataProvider.validateLovAction(input).then(validationResult => {\n      let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;\n\n      if (changed) {\n        uwPropertySvc.updateValidationResult(lovEntry, validationResult, uiProperty);\n        eventBus.publish(dataProvider.name + '.validSelectionEvent', {\n          selectedObjects: input.lovEntries,\n          viewModelProp: uiProperty,\n          vmo\n        });\n        return uwPropertySvc.updateLov({ ...uiProperty\n        }, lovEntry, createUpdateValue, operation, checkLovEntries).then(newProperty => {\n          uiProperty.dbOriginalValue = uiProperty.dbValue;\n          uiProperty.uiOriginalValue = uiProperty.uiValue;\n          uiProperty.filterString = '';\n          return Promise.resolve({\n            newProp: newProperty,\n            isPropertyUpdateReqd: true\n          });\n        });\n      }\n\n      return Promise.resolve({\n        newProp: uiProperty,\n        isPropertyUpdateReqd\n      });\n    }, validationError => {\n      uwPropertySvc.setServerValidationError(uiProperty, true);\n      uiProperty.error = validationError.message;\n      return Promise.resolve({\n        newProp: uiProperty,\n        isPropertyUpdateReqd\n      });\n    });\n  }\n\n  let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;\n\n  if (changed) {\n    return uwPropertySvc.updateLov({ ...uiProperty\n    }, lovEntry, createUpdateValue, operation, checkLovEntries).then(newProperty => {\n      return Promise.resolve({\n        newProp: newProperty,\n        isPropertyUpdateReqd: true\n      });\n    });\n  }\n\n  return Promise.resolve({\n    newProp: uiProperty,\n    isPropertyUpdateReqd\n  });\n};\n/**\n * Initialize the lov api using a data provider from the view-model\n * @param {Object} lovScope - scope object for the lov\n */\n\nexport const initLovApi = function (lovScope) {\n  //revisitme : Prasad $scope usage\n  if (lovScope.prop.dataProvider) {\n    lovScope.prop.lovApi = {}; // retrieve the initialized dataProvider object for this lov property\n\n    var listProvider = lovScope.prop.getViewModel().dataProviders[lovScope.prop.dataProvider];\n\n    if (!listProvider.initializeAction && !listProvider.action) {\n      lovScope.prop.lovApi.type = 'static';\n    } // map the lovApi to use the provider's initialize method\n\n\n    lovScope.prop.lovApi.getInitialValues = function (filterStr, deferred) {\n      lovScope.filterStr = filterStr; // reset the lov type if necessary\n\n      if ((listProvider.initializeAction || listProvider.action) && lovScope.prop && lovScope.prop.lovApi.type === 'static') {\n        lovScope.prop.lovApi.type = '';\n      }\n\n      listProvider.initialize(lovScope).then(function (initProviderResp) {\n        if (initProviderResp.moreValuesExist === false) {\n          // since we have all the values, treat as static (enables simplified filtering)\n          lovScope.prop.lovApi.type = 'static';\n        } // conforming to existing data structure here, but note for future:\n        // moreValuesExist should probably be moved off of results since it's not valid json\n\n\n        if (initProviderResp.hasOwnProperty('moreValuesExist')) {\n          initProviderResp.results.moreValuesExist = initProviderResp.moreValuesExist;\n        }\n\n        deferred.resolve(initProviderResp.results);\n      });\n    }; // use the provider's getNext method\n\n\n    lovScope.prop.lovApi.getNextValues = function (promise) {\n      listProvider.accessMode = 'lov';\n      listProvider.getNextPage(lovScope).then(function (nextProviderResp) {\n        if (nextProviderResp.moreValuesExist === false) {\n          lovScope.prop.lovApi.type = 'static';\n        }\n\n        if (nextProviderResp.hasOwnProperty('moreValuesExist')) {\n          nextProviderResp.results.moreValuesExist = nextProviderResp.moreValuesExist;\n        }\n\n        promise.resolve(nextProviderResp.results);\n      });\n    }; // use the provider's validate method\n\n\n    lovScope.prop.lovApi.validateLOVValueSelections = function (selected) {\n      // are the selected value(s) in lovScope.lovEntries?\n      // if not, a new value is being suggested which may or may not be allowed\n      var suggestion = false;\n      selected.forEach(function (sel) {\n        if (sel.suggested) {\n          suggestion = sel.propDisplayValue;\n        }\n      }); // make server call via lov data provider interface: returns a promise\n\n      return listProvider.validateSelections(lovScope, selected, suggestion);\n    };\n  }\n};\n/**\n * Returns an AngularJS promise to fetch the initial LOV values.\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {String} filterStr - Filter to apply to the results before being returned.\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Promise} - Returns an AngularJS promise to fetch the initial LOV values.\n */\n\nexport const promiseInitialValues = function (lovApi, filterStr, name) {\n  var deferred = AwPromiseService.instance.defer(); // make server call via lov data provider interface\n\n  lovApi.getInitialValues(filterStr, deferred, name);\n  return deferred.promise;\n};\n/**\n * Returns an AngularJS promise to fetch the 'next' set of LOV values.\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Promise} - Returns an AngularJS promise to fetch the 'next' set of LOV values.\n */\n\nexport const promiseNextValues = function (lovApi, name) {\n  var deferred = AwPromiseService.instance.defer(); // make server call via lov data provider interface\n\n  lovApi.getNextValues(deferred, name);\n  return deferred.promise;\n};\n/**\n * Validate the given LOV entry value(s).\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {LovEntryArray} lovEntries - set lov vals\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Void} -\n */\n\nexport const validateLOVValueSelections = function (lovApi, lovEntries, name) {\n  // make server call via lov data provider interface\n  return lovApi.validateLOVValueSelections(lovEntries, name);\n};\nconst exports = {\n  initLovApi,\n  promiseInitialValues,\n  promiseNextValues,\n  validateLOVValueSelections\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/propertyrender/src/js/uwLovDataService.js"],"names":["performLOVOperation","dateApi","uwPropertySvc","isPropertyUpdateReqd","operation","uiProperty","newProp","isDateAndTimeProp","lovEntry","lovEntries","dataProvider","ndx","createInput","propInternalValue","propDisplayValue","input","viewModelProp","vmo","validationResult","eventBus","selectedObjects","validationError","_","changed","newProperty","initLovApi","lovScope","listProvider","initProviderResp","deferred","nextProviderResp","promise","suggestion","selected","sel","promiseInitialValues","AwPromiseService","lovApi","promiseNextValues","validateLOVValueSelections","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/uwLovDataService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport eventBus from 'js/eventBus';\nimport dateTimeSvc from 'js/dateTimeService';\nimport _ from 'lodash';\n\nexport const performLOVOperation = ( { uiProperty, vmo, lovEntry, dataProvider, createUpdateValue, checkLovEntries, dateApi }, operation ) => {\n    if( dateApi ) {\n        uwPropertySvc.setDateApi( uiProperty, dateApi );\n    }\n    let isPropertyUpdateReqd = false;\n\n    if( operation === 'resetFilterStr' ) {\n        uiProperty.filterString = null;\n        return Promise.resolve( { newProp: null, isPropertyUpdateReqd } );\n    } else if( operation === 'filter' ) {\n        let isDateAndTimeProp = [ 'DATE', 'DATEARRAY', 'DATETIME' ].includes( uiProperty.type );\n        if( !isDateAndTimeProp && ( lovEntry.isSearchable === true || uiProperty.renderingHint === 'checkboxoptionlov' ) ) {\n            uiProperty.filterString = lovEntry.filterString;\n            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd } );\n        }\n        let lovEntries = dataProvider.vmCollectionObj.vmCollection.loadedVMObjects;\n        if( isDateAndTimeProp ) {\n            dateApi = uiProperty.dateApi;\n            dateApi.timeValue = lovEntry.propInternalValue;\n            uwPropertySvc.setDateApi( uiProperty, dateApi );\n            for( var ndx = 0; ndx < lovEntries.length; ndx++ ) {\n                if( lovEntries[ ndx ].propDisplayValue === lovEntry.propDisplayValue ) {\n                    lovEntry.propInternalValue = lovEntries[ ndx ].propInternalValue;\n                    break;\n                }\n            }\n            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd: true } );\n        } else if( uiProperty.type === 'OBJECT' || uiProperty.type === 'OBJECTARRAY' ) {\n            // we can't set the dbValue for an object based on filter text, but we can check to see if the\n            // input\n            // has been cleared\n            if( !uiProperty.uiValue ) {\n                uiProperty.dbValue = '';\n            }\n        } else if( uiProperty.type === 'STRING' ) {\n            uiProperty.dbValue = lovEntry.propInternalValue;\n        } else {\n            uiProperty.uiValue = lovEntry.propDisplayValue;\n        }\n\n        if( !uiProperty.isArray ) {\n            uiProperty.uiValues = [ lovEntry.propDisplayValue ];\n            uiProperty.uiValue = lovEntry.propDisplayValue;\n            if( uiProperty.type !== 'OBJECT' && uiProperty.type !== 'OBJECTARRAY' ) {\n                //For Reference property internal value is same as UI value so dont\n                //process it for OBJECT type\n                uiProperty.dbValues = [ lovEntry.propInternalValue ];\n                uiProperty.dbValue = lovEntry.propInternalValue;\n            }\n        }\n        uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;\n        uiProperty.valueUpdated = true;\n        return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd } );\n    } else if( operation === 'validate' ) {\n        let createInput = function() {\n            let lovEntries = [];\n            if( uiProperty.isArray && uiProperty.dbValue instanceof Array ) {\n                uiProperty.dbValue.forEach( ( item, index ) => {\n                    lovEntries.push( { propInternalValue: item, propDisplayValue: uiProperty.displayValues[ index ] } );\n                } );\n            } else {\n                lovEntries.push( lovEntry );\n            }\n            return lovEntries;\n        };\n        let input = {\n            lovEntries: createInput(),\n            viewModelProp: uiProperty,\n            vmo\n        };\n        if( uiProperty.type === 'DATEARRAY' ) {\n            dateApi = uiProperty.dateApi;\n            dateApi.timeValue = lovEntry.propDisplayValue;\n            uwPropertySvc.setDateApi( uiProperty, dateApi );\n        }\n        return dataProvider.validateLovAction( input ).then( ( validationResult ) => {\n            uiProperty.dbOriginalValue = uiProperty.dbValue;\n            uiProperty.uiOriginalValue = uiProperty.uiValue;\n            uwPropertySvc.updateValidationResult( lovEntry, validationResult, uiProperty );\n            eventBus.publish( dataProvider.name + '.validSelectionEvent', {\n                selectedObjects: input.lovEntries,\n                viewModelProp: uiProperty,\n                vmo\n            } );\n            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd: true } );\n        }, ( validationError ) => {\n            uwPropertySvc.setServerValidationError( uiProperty, true );\n            uiProperty.error = validationError.message;\n            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );\n        } );\n    } else if( operation === 'validateandadd' ) {\n        let createInput = function() {\n            //get selected LOV entries\n            let lovEntries = [];\n            if( uiProperty.isArray && uiProperty.dbValue instanceof Array ) {\n                uiProperty.dbValue.forEach( ( item, index ) => {\n                    lovEntries.push( { propInternalValue: item, propDisplayValue: uiProperty.displayValues[ index ] } );\n                } );\n                if( !_.isNil( lovEntry.propInternalValue ) ) {\n                //Add in selected LOV entries so that it can be validated\n                    lovEntries.push( { propInternalValue: lovEntry.propInternalValue, propDisplayValue: lovEntry.propDisplayValue } );\n                }\n            } else {\n                lovEntries.push( lovEntry );\n            }\n\n            return lovEntries;\n        };\n        //uiProperty.filterString = _.isNil( lovEntry.filterString ) ? lovEntry.propDisplayValue : lovEntry.filterString;\n        //Cascase LOV selecting from Array:Test CFx_Property_Support_Item Cascade Array LOV and Cascade Suggestive Array LOV Properties\n        uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;\n\n        uiProperty.filteredLOVEntries = lovEntry.filteredLOVEntries;\n        let input = {\n            lovEntries: createInput(), //selected LOV entries = existing + newly selected values\n            viewModelProp: uiProperty,\n            vmo\n        };\n        return dataProvider.validateLovAction( input ).then( ( validationResult ) => {\n            let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;\n            if( changed ) {\n                uwPropertySvc.updateValidationResult( lovEntry, validationResult, uiProperty );\n                eventBus.publish( dataProvider.name + '.validSelectionEvent', {\n                    selectedObjects: input.lovEntries,\n                    viewModelProp: uiProperty,\n                    vmo\n                } );\n                return uwPropertySvc.updateLov( { ...uiProperty }, lovEntry, createUpdateValue, operation, checkLovEntries )\n                    .then( ( newProperty ) => {\n                        uiProperty.dbOriginalValue = uiProperty.dbValue;\n                        uiProperty.uiOriginalValue = uiProperty.uiValue;\n                        uiProperty.filterString = '';\n                        return Promise.resolve( { newProp: newProperty, isPropertyUpdateReqd: true } );\n                    } );\n            }\n            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );\n        }, ( validationError ) => {\n            uwPropertySvc.setServerValidationError( uiProperty, true );\n            uiProperty.error = validationError.message;\n            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );\n        } );\n    }\n    let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;\n    if( changed ) {\n        return uwPropertySvc.updateLov( { ...uiProperty }, lovEntry, createUpdateValue, operation, checkLovEntries )\n            .then( ( newProperty ) => {\n                return Promise.resolve( { newProp: newProperty, isPropertyUpdateReqd: true } );\n            } );\n    }\n    return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );\n};\n/**\n * Initialize the lov api using a data provider from the view-model\n * @param {Object} lovScope - scope object for the lov\n */\nexport const initLovApi = function( lovScope ) {\n    //revisitme : Prasad $scope usage\n    if( lovScope.prop.dataProvider ) {\n        lovScope.prop.lovApi = {};\n\n        // retrieve the initialized dataProvider object for this lov property\n        var listProvider = lovScope.prop.getViewModel().dataProviders[ lovScope.prop.dataProvider ];\n\n        if( !listProvider.initializeAction && !listProvider.action ) {\n            lovScope.prop.lovApi.type = 'static';\n        }\n\n        // map the lovApi to use the provider's initialize method\n        lovScope.prop.lovApi.getInitialValues = function( filterStr, deferred ) {\n            lovScope.filterStr = filterStr;\n\n            // reset the lov type if necessary\n            if( ( listProvider.initializeAction || listProvider.action ) && lovScope.prop && lovScope.prop.lovApi.type === 'static' ) {\n                lovScope.prop.lovApi.type = '';\n            }\n\n            listProvider.initialize( lovScope )\n                .then( function( initProviderResp ) {\n                    if( initProviderResp.moreValuesExist === false ) {\n                        // since we have all the values, treat as static (enables simplified filtering)\n                        lovScope.prop.lovApi.type = 'static';\n                    }\n                    // conforming to existing data structure here, but note for future:\n                    // moreValuesExist should probably be moved off of results since it's not valid json\n                    if( initProviderResp.hasOwnProperty( 'moreValuesExist' ) ) {\n                        initProviderResp.results.moreValuesExist = initProviderResp.moreValuesExist;\n                    }\n                    deferred.resolve( initProviderResp.results );\n                } );\n        };\n\n        // use the provider's getNext method\n        lovScope.prop.lovApi.getNextValues = function( promise ) {\n            listProvider.accessMode = 'lov';\n\n            listProvider.getNextPage( lovScope )\n                .then( function( nextProviderResp ) {\n                    if( nextProviderResp.moreValuesExist === false ) {\n                        lovScope.prop.lovApi.type = 'static';\n                    }\n\n                    if( nextProviderResp.hasOwnProperty( 'moreValuesExist' ) ) {\n                        nextProviderResp.results.moreValuesExist = nextProviderResp.moreValuesExist;\n                    }\n                    promise.resolve( nextProviderResp.results );\n                } );\n        };\n\n        // use the provider's validate method\n        lovScope.prop.lovApi.validateLOVValueSelections = function( selected ) {\n            // are the selected value(s) in lovScope.lovEntries?\n            // if not, a new value is being suggested which may or may not be allowed\n            var suggestion = false;\n            selected.forEach( function( sel ) {\n                if( sel.suggested ) {\n                    suggestion = sel.propDisplayValue;\n                }\n            } );\n\n            // make server call via lov data provider interface: returns a promise\n            return listProvider.validateSelections( lovScope, selected, suggestion );\n        };\n    }\n};\n\n/**\n * Returns an AngularJS promise to fetch the initial LOV values.\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {String} filterStr - Filter to apply to the results before being returned.\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Promise} - Returns an AngularJS promise to fetch the initial LOV values.\n */\nexport const promiseInitialValues = function( lovApi, filterStr, name ) {\n    var deferred = AwPromiseService.instance.defer();\n    // make server call via lov data provider interface\n    lovApi.getInitialValues( filterStr, deferred, name );\n    return deferred.promise;\n};\n\n/**\n * Returns an AngularJS promise to fetch the 'next' set of LOV values.\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Promise} - Returns an AngularJS promise to fetch the 'next' set of LOV values.\n */\nexport const promiseNextValues = function( lovApi, name ) {\n    var deferred = AwPromiseService.instance.defer();\n    // make server call via lov data provider interface\n    lovApi.getNextValues( deferred, name );\n    return deferred.promise;\n};\n\n/**\n * Validate the given LOV entry value(s).\n *\n * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.\n *\n * @param {LovEntryArray} lovEntries - set lov vals\n *\n * @param {String} name - Name of the property we are requesting LOV entries for.\n *\n * @returns {Void} -\n */\nexport const validateLOVValueSelections = function( lovApi, lovEntries, name ) {\n    // make server call via lov data provider interface\n    return lovApi.validateLOVValueSelections( lovEntries, name );\n};\n\nconst exports = {\n    initLovApi,\n    promiseInitialValues,\n    promiseNextValues,\n    validateLOVValueSelections\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}