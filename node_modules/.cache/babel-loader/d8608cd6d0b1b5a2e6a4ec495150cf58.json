{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch extended type icons Requires typeIconsRegistry.json definition at each module level.\n *\n * @module js/typeIconsRegistryService\n */\nimport cmm from 'soa/kernel/clientMetaModel';\nimport cdm from 'soa/kernel/clientDataModel';\nimport adapterService from 'js/adapterService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nlet exports;\n\nlet _typeIconsRegistry;\n/**\n * Returns the custom icon registered against current vmo\n * @param {Object} type --- json type\n * @param {Object} modelType -- ModelType name or array\n * @param { viewmodelObject } obj --- In case of dataparser when modelType and typeHierarchy provided on VMO\n *\n * @return {String} Name of icon to be used against current vmo\n */\n\n\nexport let isObjOfAnyTypeNames = function (type, modelType, obj) {\n  var isValid = false;\n\n  if (type.names) {\n    for (var i = 0; i < type.names.length; i++) {\n      let typeName = type.names[i]; // If the type is purely a client view model object\n\n      if (type.isClientViewModelObject === true && modelType === typeName) {\n        isValid = true;\n      } else {\n        isValid = cmm.isInstanceOf(typeName, modelType);\n      }\n\n      if (!isValid && obj && obj.typeHierarchy && obj.typeHierarchy.indexOf(typeName) > -1) {\n        isValid = true;\n      }\n\n      if (isValid) {\n        return true;\n      }\n    }\n  }\n\n  return isValid;\n};\nexport let getIconForType = function (type, obj) {\n  if (type.names && obj && obj.modelType && obj.modelType.name && obj.props) {\n    // If the type configured in json matches with the object which is being evaluated\n    var isValid = exports.isObjOfAnyTypeNames(type, obj.modelType, obj);\n\n    if (isValid) {\n      /* -\n       * If its a valid sub type,( in order)\n       *     1. check if a icon file name has been associated\n       *     2. if a property has been mentioned\n       *     3. If a condition has been mentioned to evaluate the property\n       *     4. If a nested type has been mentioned for a property\n      -*/\n      if (type.iconFileName) {\n        return type.iconFileName + '.svg';\n      } else if (type.prop && type.prop.names) {\n        var prop = type.prop;\n        var propNames = prop.names;\n        var conditionVerdict = false;\n\n        for (var index in propNames) {\n          var propName = propNames[index];\n          var vmoPropVal = obj.props[propName];\n\n          if (vmoPropVal) {\n            if (prop.conditions && prop.iconFileName) {\n              conditionVerdict = expressionParserUtils.evaluateConditions(prop.conditions, obj);\n\n              if (conditionVerdict) {\n                break;\n              }\n            } else if (prop.type) {\n              // it expects a property to have a OBJECT type of value only\n              var refObjUid = null;\n\n              if (vmoPropVal.dbValue) {\n                refObjUid = vmoPropVal.dbValue;\n              } else if (vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0) {\n                refObjUid = vmoPropVal.dbValues[0];\n              }\n\n              var isType = cmm.isTypeUid(refObjUid);\n\n              if (isType) {\n                var typeObj = cmm.getType(refObjUid);\n\n                if (typeObj) {\n                  return cmm.getTypeIconFileName(typeObj);\n                }\n              } else {\n                var refObj = cdm.getObject(refObjUid);\n\n                if (refObj) {\n                  //call getCustomIcon to ensure type icon configuration on \"nested\" type is honored\n                  //if that returns null revert to previous behavior\n                  return exports.getIconForType(prop.type, refObj);\n                }\n              }\n            }\n          } else {// this means property is not loaded in client\n          }\n        }\n\n        if (prop.conditions && prop.iconFileName) {\n          if (conditionVerdict) {\n            return prop.iconFileName + '.svg';\n          }\n        }\n      } else {\n        return cmm.getTypeIconFileName(obj.modelType);\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the custom thumbnail current vmo based on thumbnail configuration\n * @param {Object} type - the registry entry\n * @param {Object} obj - the vmo\n *\n * @return {Object} vmo containing the thumbnail information\n */\n\nexport let getVmoForThumbnail = function (type, obj) {\n  if (type.names && obj && obj.modelType) {\n    // If the type configured in json matches with the object which is being evaluated\n    var isValid = exports.isObjOfAnyTypeNames(type, obj.modelType, obj);\n\n    if (isValid) {\n      if (type.prop && type.prop.names) {\n        var prop = type.prop;\n        var propNames = prop.names;\n\n        for (var index in propNames) {\n          var propName = propNames[index];\n          var vmoPropVal = obj.props[propName];\n\n          if (vmoPropVal) {\n            if (prop.type) {\n              // it expects a property to have a OBJECT type of value only\n              var refObjUid = null;\n\n              if (vmoPropVal.dbValue) {\n                refObjUid = vmoPropVal.dbValue;\n              } else if (vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0) {\n                refObjUid = vmoPropVal.dbValues[0];\n              }\n\n              var isType = cmm.isTypeUid(refObjUid);\n\n              if (isType) {// invalid case\n              } else {\n                var refObj = cdm.getObject(refObjUid);\n\n                if (refObj) {\n                  return exports.getVmoForThumbnail(prop.type, refObj);\n                }\n              }\n            }\n          } else {// this means property is not loaded in client\n          }\n        }\n      } else {\n        return obj;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the custom thumbnail registered against current vmo\n *\n * @param {Object} vmo - the vmo to get custom thumbnail for\n *\n * @return {Object} vmo on which thumbnail information is present\n */\n\nexport let getCustomVmoForThumbnail = function (vmo) {\n  var customVmo = null;\n\n  if (vmo && vmo.modelType) {\n    _.forEach(_typeIconsRegistry, function (typeObj) {\n      if (typeObj && typeObj.thumbnail) {\n        customVmo = exports.getVmoForThumbnail(typeObj.thumbnail, vmo);\n\n        if (customVmo) {\n          return false; // break\n        }\n      }\n\n      return undefined;\n    });\n  }\n\n  return customVmo;\n};\n/**\n * Returns the custom icon registered against current vmo\n *\n * @param {Object} vmo - the vmo to check\n *\n * @return {String} Name of icon to be used against current vmo\n */\n\nexport let getCustomIcon = function (vmo) {\n  var finalTypeIconFileName = null;\n  var finalPriority = -1;\n  let adaptedObj = null;\n  let adaptedRequired = vmo.type !== getPropsObjectType(vmo);\n\n  if (adaptedRequired) {\n    adaptedObj = adapterService.getAdaptedObjectsSync([vmo])[0];\n  }\n\n  let relevantDefinitions = getRelevantDefs(vmo, adaptedObj);\n\n  if (vmo && vmo.modelType && relevantDefinitions.length > 0) {\n    relevantDefinitions.sort(function (def1, def2) {\n      let priority1 = def1.priority ? def1.priority : 1;\n      let priority2 = def2.priority ? def2.priority : 1;\n      return priority1 < priority2 ? 1 : -1;\n    });\n\n    _.forEach(relevantDefinitions, function (typeObj) {\n      if (typeObj && typeObj.type) {\n        /* If the current priority is greater than priority of any consecutive definitions, don't need to evaluate... */\n        var currPriority = typeObj.priority ? typeObj.priority : 1;\n\n        if (finalPriority > currPriority) {\n          return;\n        }\n\n        var currTypeIconName = null;\n\n        if (adaptedRequired) {\n          var adaptedIcon = exports.getIconForType(typeObj.type, adaptedObj);\n\n          if (adaptedIcon) {\n            currTypeIconName = adaptedIcon;\n            currPriority = typeObj.priority ? typeObj.priority : currPriority + 1;\n          }\n        }\n\n        if (!currTypeIconName) {\n          currTypeIconName = exports.getIconForType(typeObj.type, vmo);\n        }\n\n        if (currTypeIconName && currPriority > finalPriority) {\n          finalPriority = currPriority;\n          finalTypeIconFileName = currTypeIconName;\n        }\n      }\n    });\n  }\n\n  return finalTypeIconFileName;\n};\n/**\n * Example Case ( List with Summary View, Summary view has 1 objectset table )\n * --------------------------------------------------\n * | Home Folder           |    XRT Objectset Table |\n * |                       |                        |\n * |     SomeItemName123   |        SomeItemName123 |\n * |                       |                        |\n * |                       |                        |\n * --------------------------------------------------\n *\n * Inside of PWA ( List ) the type of \"SomeItemName123\" = ItemRevision\n * Inside of SWA ( Objectset table ) the type of \"SomeItemName123\" = Awp0XRTObjectSet\n *\n * Both items need to be able to utilize the custom icon definition for \"ItemRevision\"\n * Adapting objects is expensive, so check to see if needs to be adapted before doing it anyway.\n * If vmo.props.object_type is equal to vmo.type, adaption is not needed\n * If somewhere along the path is not defined, adaption may be required.\n * If path is present and vmo.type !== vmo.props.object_type, adaption is definitely required.\n * @param {Object} vmo - the vmo to check\n *\n * @returns {String} - undefined or string type of VMO adapted options\n */\n\nfunction getPropsObjectType(vmo) {\n  let objectType;\n\n  if (vmo.props && vmo.props.object_type) {\n    let ot = vmo.props.object_type;\n\n    if (ot.dbValue) {\n      objectType = ot.dbValue;\n    } else if (ot.dbValues && ot.dbValues.length > 0) {\n      objectType = ot.dbValues[0];\n    }\n  }\n\n  if (!objectType && vmo.modelType && vmo.modelType.parentTypeName) {\n    objectType = vmo.modelType.parentTypeName;\n  }\n\n  return objectType;\n}\n/**\n * Gets the typeHierarchy array from object\n * @param {Object} dataObject - The VMO/Object to get type Hierarchy array from\n *\n * @returns {Array|null} - Returns the typeHierarchyArry or null if non-existent\n */\n\n\nlet getTypeHierarchyArray = function (dataObject) {\n  if (dataObject) {\n    if (dataObject.modelType && dataObject.modelType.typeHierarchyArray) {\n      return dataObject.modelType.typeHierarchyArray;\n    } else if (dataObject.typeHierarchy) {\n      return dataObject.typeHierarchy;\n    } else if (dataObject.type) {\n      return [dataObject.type];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets the relevant definitions from teh typeIconsRegistry\n *\n * @param {Object} vmo - the view model object\n * @param {Object|null} adaptedObj - The adaptedObject or null\n *\n * @returns {Object[]} - relevant typeIconsRegistry definitions\n */\n\n\nlet getRelevantDefs = function (vmo, adaptedObj) {\n  const typesToCheck = new Set();\n  const vmoTypeHierarchyArr = getTypeHierarchyArray(vmo);\n\n  if (vmoTypeHierarchyArr) {\n    for (let i = 0; i < vmoTypeHierarchyArr.length; i++) {\n      typesToCheck.add(vmoTypeHierarchyArr[i]);\n    }\n  }\n\n  if (adaptedObj) {\n    let adaptedTypeHierarchyArr = getTypeHierarchyArray(adaptedObj);\n\n    if (adaptedTypeHierarchyArr) {\n      for (let j = 0; j < adaptedTypeHierarchyArr.length; j++) {\n        typesToCheck.add(adaptedTypeHierarchyArr[j]);\n      }\n    }\n  }\n\n  return _typeIconsRegistry.filter(o => {\n    if (o.type && o.type.names) {\n      // Check if any items in set are valid here, best way is loop through the registry entry names,\n      // Since there are generally only one or two items in each, so this will be faster\n      for (let k = 0; k < o.type.names.length; k++) {\n        if (typesToCheck.has(o.type.names[k])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  });\n};\n/**\n * Loads the type Icons registry configuration\n */\n\n\nexport let loadConfiguration = function () {\n  //  FIXME this should be loaded async but before the sync API below that uses it is called\n  const typeIconsRegistryCfg = cfgSvc.getCfgCached('typeIconsRegistry');\n  _typeIconsRegistry = typeIconsRegistryCfg ? typeIconsRegistryCfg : [];\n};\nexports = {\n  isObjOfAnyTypeNames,\n  getIconForType,\n  getVmoForThumbnail,\n  getCustomVmoForThumbnail,\n  getCustomIcon,\n  loadConfiguration\n};\nexport default exports;\nloadConfiguration();","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/typeIconsRegistryService.js"],"names":["isObjOfAnyTypeNames","isValid","type","i","typeName","modelType","cmm","obj","getIconForType","exports","prop","propNames","conditionVerdict","propName","vmoPropVal","expressionParserUtils","refObjUid","isType","typeObj","refObj","cdm","getVmoForThumbnail","getCustomVmoForThumbnail","customVmo","vmo","_","getCustomIcon","finalTypeIconFileName","finalPriority","adaptedObj","adaptedRequired","getPropsObjectType","adapterService","relevantDefinitions","getRelevantDefs","priority1","def1","priority2","def2","currPriority","currTypeIconName","adaptedIcon","ot","objectType","getTypeHierarchyArray","dataObject","typesToCheck","vmoTypeHierarchyArr","adaptedTypeHierarchyArr","j","o","k","loadConfiguration","typeIconsRegistryCfg","cfgSvc","_typeIconsRegistry"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAA,GAAA,MAAA,4BAAA;AACA,OAAA,GAAA,MAAA,4BAAA;AACA,OAAA,cAAA,MAAA,mBAAA;AACA,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,qBAAA,MAAA,0BAAA;AACA,OAAA,MAAA,MAAA,yBAAA;AAEA,IAAA,OAAA;;AAEA,IAAA,kBAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIA,mBAAmB,GAAG,UAAA,IAAA,EAAA,SAAA,EAAA,GAAA,EAAiC;EAC9D,IAAIC,OAAO,GAAX,KAAA;;EACA,IAAIC,IAAI,CAAR,KAAA,EAAiB;IACb,KAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,IAAI,CAAJA,KAAAA,CAApB,MAAA,EAAuCC,CAAvC,EAAA,EAA6C;MACzC,IAAIC,QAAQ,GAAGF,IAAI,CAAJA,KAAAA,CAD0B,CAC1BA,CAAf,CADyC,CAEzC;;MACA,IAAIA,IAAI,CAAJA,uBAAAA,KAAAA,IAAAA,IAAyCG,SAAS,KAAtD,QAAA,EAAsE;QAClEJ,OAAO,GAAPA,IAAAA;MADJ,CAAA,MAEO;QACHA,OAAO,GAAGK,GAAG,CAAHA,YAAAA,CAAAA,QAAAA,EAAVL,SAAUK,CAAVL;MACH;;MACD,IAAI,CAAA,OAAA,IAAA,GAAA,IAAmBM,GAAG,CAAtB,aAAA,IAAwCA,GAAG,CAAHA,aAAAA,CAAAA,OAAAA,CAAAA,QAAAA,IAAwC,CAApF,CAAA,EAAyF;QACrFN,OAAO,GAAPA,IAAAA;MACH;;MACD,IAAA,OAAA,EAAc;QACV,OAAA,IAAA;MACH;IACJ;EACJ;;EAED,OAAA,OAAA;AApBG,CAAA;AAuBP,OAAO,IAAIO,cAAc,GAAG,UAAA,IAAA,EAAA,GAAA,EAAsB;EAC9C,IAAIN,IAAI,CAAJA,KAAAA,IAAAA,GAAAA,IAAqBK,GAAG,CAAxBL,SAAAA,IAAsCK,GAAG,CAAHA,SAAAA,CAAtCL,IAAAA,IAA4DK,GAAG,CAAnE,KAAA,EAA4E;IACxE;IACA,IAAIN,OAAO,GAAGQ,OAAO,CAAPA,mBAAAA,CAAAA,IAAAA,EAAmCF,GAAG,CAAtCE,SAAAA,EAAd,GAAcA,CAAd;;IACA,IAAA,OAAA,EAAc;MACV;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,IAAIP,IAAI,CAAR,YAAA,EAAwB;QACpB,OAAOA,IAAI,CAAJA,YAAAA,GAAP,MAAA;MADJ,CAAA,MAEO,IAAIA,IAAI,CAAJA,IAAAA,IAAaA,IAAI,CAAJA,IAAAA,CAAjB,KAAA,EAAmC;QACtC,IAAIQ,IAAI,GAAGR,IAAI,CAAf,IAAA;QACA,IAAIS,SAAS,GAAGD,IAAI,CAApB,KAAA;QACA,IAAIE,gBAAgB,GAApB,KAAA;;QACA,KAAK,IAAL,KAAA,IAAA,SAAA,EAA8B;UAC1B,IAAIC,QAAQ,GAAGF,SAAS,CAAxB,KAAwB,CAAxB;UACA,IAAIG,UAAU,GAAGP,GAAG,CAAHA,KAAAA,CAAjB,QAAiBA,CAAjB;;UACA,IAAA,UAAA,EAAiB;YACb,IAAIG,IAAI,CAAJA,UAAAA,IAAmBA,IAAI,CAA3B,YAAA,EAA2C;cACvCE,gBAAgB,GAAGG,qBAAqB,CAArBA,kBAAAA,CAA0CL,IAAI,CAA9CK,UAAAA,EAAnBH,GAAmBG,CAAnBH;;cAEA,IAAA,gBAAA,EAAuB;gBACnB;cACH;YALL,CAAA,MAMO,IAAIF,IAAI,CAAR,IAAA,EAAgB;cACnB;cACA,IAAIM,SAAS,GAAb,IAAA;;cACA,IAAIF,UAAU,CAAd,OAAA,EAAyB;gBACrBE,SAAS,GAAGF,UAAU,CAAtBE,OAAAA;cADJ,CAAA,MAEO,IAAIF,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAAA,MAAAA,GAA3B,CAAA,EAA4D;gBAC/DE,SAAS,GAAGF,UAAU,CAAVA,QAAAA,CAAZE,CAAYF,CAAZE;cACH;;cAED,IAAIC,MAAM,GAAGX,GAAG,CAAHA,SAAAA,CAAb,SAAaA,CAAb;;cACA,IAAA,MAAA,EAAa;gBACT,IAAIY,OAAO,GAAGZ,GAAG,CAAHA,OAAAA,CAAd,SAAcA,CAAd;;gBACA,IAAA,OAAA,EAAc;kBACV,OAAOA,GAAG,CAAHA,mBAAAA,CAAP,OAAOA,CAAP;gBACH;cAJL,CAAA,MAKO;gBACH,IAAIa,MAAM,GAAGC,GAAG,CAAHA,SAAAA,CAAb,SAAaA,CAAb;;gBACA,IAAA,MAAA,EAAa;kBACT;kBACA;kBACA,OAAOX,OAAO,CAAPA,cAAAA,CAAwBC,IAAI,CAA5BD,IAAAA,EAAP,MAAOA,CAAP;gBACH;cACJ;YACJ;UA9BL,CAAA,MA+BO,CACH;UACH;QACJ;;QACD,IAAIC,IAAI,CAAJA,UAAAA,IAAmBA,IAAI,CAA3B,YAAA,EAA2C;UACvC,IAAA,gBAAA,EAAuB;YACnB,OAAOA,IAAI,CAAJA,YAAAA,GAAP,MAAA;UACH;QACJ;MA9CE,CAAA,MA+CA;QACH,OAAOJ,GAAG,CAAHA,mBAAAA,CAAyBC,GAAG,CAAnC,SAAOD,CAAP;MACH;IACJ;EACJ;;EACD,OAAA,IAAA;AAlEG,CAAA;AAqEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIe,kBAAkB,GAAG,UAAA,IAAA,EAAA,GAAA,EAAsB;EAClD,IAAInB,IAAI,CAAJA,KAAAA,IAAAA,GAAAA,IAAqBK,GAAG,CAA5B,SAAA,EAAyC;IACrC;IACA,IAAIN,OAAO,GAAGQ,OAAO,CAAPA,mBAAAA,CAAAA,IAAAA,EAAmCF,GAAG,CAAtCE,SAAAA,EAAd,GAAcA,CAAd;;IAEA,IAAA,OAAA,EAAc;MACV,IAAIP,IAAI,CAAJA,IAAAA,IAAaA,IAAI,CAAJA,IAAAA,CAAjB,KAAA,EAAmC;QAC/B,IAAIQ,IAAI,GAAGR,IAAI,CAAf,IAAA;QACA,IAAIS,SAAS,GAAGD,IAAI,CAApB,KAAA;;QACA,KAAK,IAAL,KAAA,IAAA,SAAA,EAA8B;UAC1B,IAAIG,QAAQ,GAAGF,SAAS,CAAxB,KAAwB,CAAxB;UACA,IAAIG,UAAU,GAAGP,GAAG,CAAHA,KAAAA,CAAjB,QAAiBA,CAAjB;;UACA,IAAA,UAAA,EAAiB;YACb,IAAIG,IAAI,CAAR,IAAA,EAAgB;cACZ;cACA,IAAIM,SAAS,GAAb,IAAA;;cACA,IAAIF,UAAU,CAAd,OAAA,EAAyB;gBACrBE,SAAS,GAAGF,UAAU,CAAtBE,OAAAA;cADJ,CAAA,MAEO,IAAIF,UAAU,CAAVA,QAAAA,IAAuBA,UAAU,CAAVA,QAAAA,CAAAA,MAAAA,GAA3B,CAAA,EAA4D;gBAC/DE,SAAS,GAAGF,UAAU,CAAVA,QAAAA,CAAZE,CAAYF,CAAZE;cACH;;cAED,IAAIC,MAAM,GAAGX,GAAG,CAAHA,SAAAA,CAAb,SAAaA,CAAb;;cACA,IAAA,MAAA,EAAa,CACT;cADJ,CAAA,MAEO;gBACH,IAAIa,MAAM,GAAGC,GAAG,CAAHA,SAAAA,CAAb,SAAaA,CAAb;;gBACA,IAAA,MAAA,EAAa;kBACT,OAAOX,OAAO,CAAPA,kBAAAA,CAA4BC,IAAI,CAAhCD,IAAAA,EAAP,MAAOA,CAAP;gBACH;cACJ;YACJ;UAnBL,CAAA,MAoBO,CACH;UACH;QACJ;MA7BL,CAAA,MA8BO;QACH,OAAA,GAAA;MACH;IACJ;EACJ;;EACD,OAAA,IAAA;AAzCG,CAAA;AA4CP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIa,wBAAwB,GAAG,UAAA,GAAA,EAAgB;EAClD,IAAIC,SAAS,GAAb,IAAA;;EACA,IAAIC,GAAG,IAAIA,GAAG,CAAd,SAAA,EAA2B;IACvBC,CAAC,CAADA,OAAAA,CAAAA,kBAAAA,EAA+B,UAAA,OAAA,EAAoB;MAC/C,IAAIP,OAAO,IAAIA,OAAO,CAAtB,SAAA,EAAmC;QAC/BK,SAAS,GAAGd,OAAO,CAAPA,kBAAAA,CAA4BS,OAAO,CAAnCT,SAAAA,EAAZc,GAAYd,CAAZc;;QACA,IAAA,SAAA,EAAgB;UACZ,OADY,KACZ,CADY,CACE;QACjB;MACJ;;MACD,OAAA,SAAA;IAPJE,CAAAA;EASH;;EACD,OAAA,SAAA;AAbG,CAAA;AAgBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,aAAa,GAAG,UAAA,GAAA,EAAgB;EACvC,IAAIC,qBAAqB,GAAzB,IAAA;EACA,IAAIC,aAAa,GAAG,CAApB,CAAA;EACA,IAAIC,UAAU,GAAd,IAAA;EACA,IAAIC,eAAe,GAAGN,GAAG,CAAHA,IAAAA,KAAaO,kBAAkB,CAArD,GAAqD,CAArD;;EAEA,IAAA,eAAA,EAAsB;IAClBF,UAAU,GAAGG,cAAc,CAAdA,qBAAAA,CAAsC,CAAtCA,GAAsC,CAAtCA,EAAbH,CAAaG,CAAbH;EACH;;EAED,IAAII,mBAAmB,GAAGC,eAAe,CAAA,GAAA,EAAzC,UAAyC,CAAzC;;EACA,IAAIV,GAAG,IAAIA,GAAG,CAAVA,SAAAA,IAAwBS,mBAAmB,CAAnBA,MAAAA,GAA5B,CAAA,EAA6D;IACzDA,mBAAmB,CAAnBA,IAAAA,CAA0B,UAAA,IAAA,EAAA,IAAA,EAAuB;MAC7C,IAAIE,SAAS,GAAGC,IAAI,CAAJA,QAAAA,GAAgBA,IAAI,CAApBA,QAAAA,GAAhB,CAAA;MACA,IAAIC,SAAS,GAAGC,IAAI,CAAJA,QAAAA,GAAgBA,IAAI,CAApBA,QAAAA,GAAhB,CAAA;MAEA,OAAOH,SAAS,GAATA,SAAAA,GAAAA,CAAAA,GAA4B,CAAnC,CAAA;IAJJF,CAAAA;;IAMAR,CAAC,CAADA,OAAAA,CAAAA,mBAAAA,EAAgC,UAAA,OAAA,EAAoB;MAChD,IAAIP,OAAO,IAAIA,OAAO,CAAtB,IAAA,EAA8B;QAC1B;QACA,IAAIqB,YAAY,GAAGrB,OAAO,CAAPA,QAAAA,GAAmBA,OAAO,CAA1BA,QAAAA,GAAnB,CAAA;;QACA,IAAIU,aAAa,GAAjB,YAAA,EAAmC;UAC/B;QACH;;QACD,IAAIY,gBAAgB,GAApB,IAAA;;QACA,IAAA,eAAA,EAAsB;UAClB,IAAIC,WAAW,GAAGhC,OAAO,CAAPA,cAAAA,CAAwBS,OAAO,CAA/BT,IAAAA,EAAlB,UAAkBA,CAAlB;;UACA,IAAA,WAAA,EAAkB;YACd+B,gBAAgB,GAAhBA,WAAAA;YACAD,YAAY,GAAGrB,OAAO,CAAPA,QAAAA,GAAmBA,OAAO,CAA1BA,QAAAA,GAAsCqB,YAAY,GAAjEA,CAAAA;UACH;QACJ;;QAED,IAAI,CAAJ,gBAAA,EAAwB;UACpBC,gBAAgB,GAAG/B,OAAO,CAAPA,cAAAA,CAAwBS,OAAO,CAA/BT,IAAAA,EAAnB+B,GAAmB/B,CAAnB+B;QACH;;QAED,IAAIA,gBAAgB,IAAID,YAAY,GAApC,aAAA,EAAuD;UACnDX,aAAa,GAAbA,YAAAA;UACAD,qBAAqB,GAArBA,gBAAAA;QACH;MACJ;IAxBLF,CAAAA;EA0BH;;EACD,OAAA,qBAAA;AA7CG,CAAA;AAgDP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAA,kBAAA,CAAA,GAAA,EAAmC;EAC/B,IAAA,UAAA;;EACA,IAAID,GAAG,CAAHA,KAAAA,IAAaA,GAAG,CAAHA,KAAAA,CAAjB,WAAA,EAAyC;IACrC,IAAIkB,EAAE,GAAGlB,GAAG,CAAHA,KAAAA,CAAT,WAAA;;IACA,IAAIkB,EAAE,CAAN,OAAA,EAAiB;MACbC,UAAU,GAAGD,EAAE,CAAfC,OAAAA;IADJ,CAAA,MAEO,IAAID,EAAE,CAAFA,QAAAA,IAAeA,EAAE,CAAFA,QAAAA,CAAAA,MAAAA,GAAnB,CAAA,EAA4C;MAC/CC,UAAU,GAAGD,EAAE,CAAFA,QAAAA,CAAbC,CAAaD,CAAbC;IACH;EACJ;;EACD,IAAI,CAAA,UAAA,IAAenB,GAAG,CAAlB,SAAA,IAAgCA,GAAG,CAAHA,SAAAA,CAApC,cAAA,EAAmE;IAC/DmB,UAAU,GAAGnB,GAAG,CAAHA,SAAAA,CAAbmB,cAAAA;EACH;;EACD,OAAA,UAAA;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,qBAAqB,GAAG,UAAA,UAAA,EAAuB;EAC/C,IAAA,UAAA,EAAiB;IACb,IAAIC,UAAU,CAAVA,SAAAA,IAAwBA,UAAU,CAAVA,SAAAA,CAA5B,kBAAA,EAAsE;MAClE,OAAOA,UAAU,CAAVA,SAAAA,CAAP,kBAAA;IADJ,CAAA,MAEO,IAAIA,UAAU,CAAd,aAAA,EAA+B;MAClC,OAAOA,UAAU,CAAjB,aAAA;IADG,CAAA,MAEA,IAAIA,UAAU,CAAd,IAAA,EAAsB;MACzB,OAAO,CAAEA,UAAU,CAAnB,IAAO,CAAP;IACH;EACJ;;EACD,OAAA,IAAA;AAVJ,CAAA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIX,eAAe,GAAG,UAAA,GAAA,EAAA,UAAA,EAA4B;EAC9C,MAAMY,YAAY,GAAG,IAArB,GAAqB,EAArB;EACA,MAAMC,mBAAmB,GAAGH,qBAAqB,CAAjD,GAAiD,CAAjD;;EAEA,IAAA,mBAAA,EAA0B;IACtB,KAAK,IAAIzC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG4C,mBAAmB,CAAvC,MAAA,EAAgD5C,CAAhD,EAAA,EAAsD;MAClD2C,YAAY,CAAZA,GAAAA,CAAkBC,mBAAmB,CAArCD,CAAqC,CAArCA;IACH;EACJ;;EAED,IAAA,UAAA,EAAiB;IACb,IAAIE,uBAAuB,GAAGJ,qBAAqB,CAAnD,UAAmD,CAAnD;;IACA,IAAA,uBAAA,EAA8B;MAC1B,KAAK,IAAIK,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,uBAAuB,CAA3C,MAAA,EAAoDC,CAApD,EAAA,EAA0D;QACtDH,YAAY,CAAZA,GAAAA,CAAkBE,uBAAuB,CAAzCF,CAAyC,CAAzCA;MACH;IACJ;EACJ;;EAED,OAAO,kBAAkB,CAAlB,MAAA,CAA6BI,CAAF,IAAS;IACvC,IAAIA,CAAC,CAADA,IAAAA,IAAUA,CAAC,CAADA,IAAAA,CAAd,KAAA,EAA6B;MACzB;MACA;MACA,KAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,CAAC,CAADA,IAAAA,CAAAA,KAAAA,CAApB,MAAA,EAAyCC,CAAzC,EAAA,EAA+C;QAC3C,IAAIL,YAAY,CAAZA,GAAAA,CAAkBI,CAAC,CAADA,IAAAA,CAAAA,KAAAA,CAAtB,CAAsBA,CAAlBJ,CAAJ,EAA4C;UACxC,OAAA,IAAA;QACH;MACJ;IACJ;;IACD,OAAA,KAAA;EAVJ,CAAO,CAAP;AAnBJ,CAAA;AAiCA;AACA;AACA;;;AACA,OAAO,IAAIM,iBAAiB,GAAG,YAAW;EACtC;EACA,MAAMC,oBAAoB,GAAGC,MAAM,CAANA,YAAAA,CAA7B,mBAA6BA,CAA7B;EACAC,kBAAkB,GAAGF,oBAAoB,GAAA,oBAAA,GAAzCE,EAAAA;AAHG,CAAA;AAMP9C,OAAO,GAAG;EAAA,mBAAA;EAAA,cAAA;EAAA,kBAAA;EAAA,wBAAA;EAAA,aAAA;EAMN2C;AANM,CAAV3C;AAQA,eAAA,OAAA;AAEA2C,iBAAiB","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch extended type icons Requires typeIconsRegistry.json definition at each module level.\n *\n * @module js/typeIconsRegistryService\n */\nimport cmm from 'soa/kernel/clientMetaModel';\nimport cdm from 'soa/kernel/clientDataModel';\nimport adapterService from 'js/adapterService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\n\nlet exports;\n\nlet _typeIconsRegistry;\n\n/**\n * Returns the custom icon registered against current vmo\n * @param {Object} type --- json type\n * @param {Object} modelType -- ModelType name or array\n * @param { viewmodelObject } obj --- In case of dataparser when modelType and typeHierarchy provided on VMO\n *\n * @return {String} Name of icon to be used against current vmo\n */\nexport let isObjOfAnyTypeNames = function( type, modelType, obj ) {\n    var isValid = false;\n    if( type.names ) {\n        for( var i = 0; i < type.names.length; i++ ) {\n            let typeName = type.names[ i ];\n            // If the type is purely a client view model object\n            if( type.isClientViewModelObject === true && modelType === typeName ) {\n                isValid = true;\n            } else {\n                isValid = cmm.isInstanceOf( typeName, modelType );\n            }\n            if( !isValid && obj && obj.typeHierarchy && obj.typeHierarchy.indexOf( typeName ) > -1 ) {\n                isValid = true;\n            }\n            if( isValid ) {\n                return true;\n            }\n        }\n    }\n\n    return isValid;\n};\n\nexport let getIconForType = function( type, obj ) {\n    if( type.names && obj && obj.modelType && obj.modelType.name && obj.props ) {\n        // If the type configured in json matches with the object which is being evaluated\n        var isValid = exports.isObjOfAnyTypeNames( type, obj.modelType, obj );\n        if( isValid ) {\n            /* -\n             * If its a valid sub type,( in order)\n             *     1. check if a icon file name has been associated\n             *     2. if a property has been mentioned\n             *     3. If a condition has been mentioned to evaluate the property\n             *     4. If a nested type has been mentioned for a property\n            -*/\n            if( type.iconFileName ) {\n                return type.iconFileName + '.svg';\n            } else if( type.prop && type.prop.names ) {\n                var prop = type.prop;\n                var propNames = prop.names;\n                var conditionVerdict = false;\n                for( var index in propNames ) {\n                    var propName = propNames[ index ];\n                    var vmoPropVal = obj.props[ propName ];\n                    if( vmoPropVal ) {\n                        if( prop.conditions && prop.iconFileName ) {\n                            conditionVerdict = expressionParserUtils.evaluateConditions( prop.conditions,\n                                obj );\n                            if( conditionVerdict ) {\n                                break;\n                            }\n                        } else if( prop.type ) {\n                            // it expects a property to have a OBJECT type of value only\n                            var refObjUid = null;\n                            if( vmoPropVal.dbValue ) {\n                                refObjUid = vmoPropVal.dbValue;\n                            } else if( vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0 ) {\n                                refObjUid = vmoPropVal.dbValues[ 0 ];\n                            }\n\n                            var isType = cmm.isTypeUid( refObjUid );\n                            if( isType ) {\n                                var typeObj = cmm.getType( refObjUid );\n                                if( typeObj ) {\n                                    return cmm.getTypeIconFileName( typeObj );\n                                }\n                            } else {\n                                var refObj = cdm.getObject( refObjUid );\n                                if( refObj ) {\n                                    //call getCustomIcon to ensure type icon configuration on \"nested\" type is honored\n                                    //if that returns null revert to previous behavior\n                                    return exports.getIconForType( prop.type, refObj );\n                                }\n                            }\n                        }\n                    } else {\n                        // this means property is not loaded in client\n                    }\n                }\n                if( prop.conditions && prop.iconFileName ) {\n                    if( conditionVerdict ) {\n                        return prop.iconFileName + '.svg';\n                    }\n                }\n            } else {\n                return cmm.getTypeIconFileName( obj.modelType );\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Returns the custom thumbnail current vmo based on thumbnail configuration\n * @param {Object} type - the registry entry\n * @param {Object} obj - the vmo\n *\n * @return {Object} vmo containing the thumbnail information\n */\nexport let getVmoForThumbnail = function( type, obj ) {\n    if( type.names && obj && obj.modelType ) {\n        // If the type configured in json matches with the object which is being evaluated\n        var isValid = exports.isObjOfAnyTypeNames( type, obj.modelType, obj );\n\n        if( isValid ) {\n            if( type.prop && type.prop.names ) {\n                var prop = type.prop;\n                var propNames = prop.names;\n                for( var index in propNames ) {\n                    var propName = propNames[ index ];\n                    var vmoPropVal = obj.props[ propName ];\n                    if( vmoPropVal ) {\n                        if( prop.type ) {\n                            // it expects a property to have a OBJECT type of value only\n                            var refObjUid = null;\n                            if( vmoPropVal.dbValue ) {\n                                refObjUid = vmoPropVal.dbValue;\n                            } else if( vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0 ) {\n                                refObjUid = vmoPropVal.dbValues[ 0 ];\n                            }\n\n                            var isType = cmm.isTypeUid( refObjUid );\n                            if( isType ) {\n                                // invalid case\n                            } else {\n                                var refObj = cdm.getObject( refObjUid );\n                                if( refObj ) {\n                                    return exports.getVmoForThumbnail( prop.type, refObj );\n                                }\n                            }\n                        }\n                    } else {\n                        // this means property is not loaded in client\n                    }\n                }\n            } else {\n                return obj;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Returns the custom thumbnail registered against current vmo\n *\n * @param {Object} vmo - the vmo to get custom thumbnail for\n *\n * @return {Object} vmo on which thumbnail information is present\n */\nexport let getCustomVmoForThumbnail = function( vmo ) {\n    var customVmo = null;\n    if( vmo && vmo.modelType ) {\n        _.forEach( _typeIconsRegistry, function( typeObj ) {\n            if( typeObj && typeObj.thumbnail ) {\n                customVmo = exports.getVmoForThumbnail( typeObj.thumbnail, vmo );\n                if( customVmo ) {\n                    return false; // break\n                }\n            }\n            return undefined;\n        } );\n    }\n    return customVmo;\n};\n\n/**\n * Returns the custom icon registered against current vmo\n *\n * @param {Object} vmo - the vmo to check\n *\n * @return {String} Name of icon to be used against current vmo\n */\nexport let getCustomIcon = function( vmo ) {\n    var finalTypeIconFileName = null;\n    var finalPriority = -1;\n    let adaptedObj = null;\n    let adaptedRequired = vmo.type !== getPropsObjectType( vmo );\n\n    if( adaptedRequired ) {\n        adaptedObj = adapterService.getAdaptedObjectsSync( [ vmo ] )[ 0 ];\n    }\n\n    let relevantDefinitions = getRelevantDefs( vmo, adaptedObj );\n    if( vmo && vmo.modelType && relevantDefinitions.length > 0 ) {\n        relevantDefinitions.sort( function( def1, def2 ) {\n            let priority1 = def1.priority ? def1.priority : 1;\n            let priority2 = def2.priority ? def2.priority : 1;\n\n            return priority1 < priority2 ? 1 : -1;\n        } );\n        _.forEach( relevantDefinitions, function( typeObj ) {\n            if( typeObj && typeObj.type ) {\n                /* If the current priority is greater than priority of any consecutive definitions, don't need to evaluate... */\n                var currPriority = typeObj.priority ? typeObj.priority : 1;\n                if( finalPriority > currPriority ) {\n                    return;\n                }\n                var currTypeIconName = null;\n                if( adaptedRequired ) {\n                    var adaptedIcon = exports.getIconForType( typeObj.type, adaptedObj );\n                    if( adaptedIcon ) {\n                        currTypeIconName = adaptedIcon;\n                        currPriority = typeObj.priority ? typeObj.priority : currPriority + 1;\n                    }\n                }\n\n                if( !currTypeIconName ) {\n                    currTypeIconName = exports.getIconForType( typeObj.type, vmo );\n                }\n\n                if( currTypeIconName && currPriority > finalPriority ) {\n                    finalPriority = currPriority;\n                    finalTypeIconFileName = currTypeIconName;\n                }\n            }\n        } );\n    }\n    return finalTypeIconFileName;\n};\n\n/**\n * Example Case ( List with Summary View, Summary view has 1 objectset table )\n * --------------------------------------------------\n * | Home Folder           |    XRT Objectset Table |\n * |                       |                        |\n * |     SomeItemName123   |        SomeItemName123 |\n * |                       |                        |\n * |                       |                        |\n * --------------------------------------------------\n *\n * Inside of PWA ( List ) the type of \"SomeItemName123\" = ItemRevision\n * Inside of SWA ( Objectset table ) the type of \"SomeItemName123\" = Awp0XRTObjectSet\n *\n * Both items need to be able to utilize the custom icon definition for \"ItemRevision\"\n * Adapting objects is expensive, so check to see if needs to be adapted before doing it anyway.\n * If vmo.props.object_type is equal to vmo.type, adaption is not needed\n * If somewhere along the path is not defined, adaption may be required.\n * If path is present and vmo.type !== vmo.props.object_type, adaption is definitely required.\n * @param {Object} vmo - the vmo to check\n *\n * @returns {String} - undefined or string type of VMO adapted options\n */\nfunction getPropsObjectType( vmo ) {\n    let objectType;\n    if( vmo.props && vmo.props.object_type ) {\n        let ot = vmo.props.object_type;\n        if( ot.dbValue ) {\n            objectType = ot.dbValue;\n        } else if( ot.dbValues && ot.dbValues.length > 0 ) {\n            objectType = ot.dbValues[ 0 ];\n        }\n    }\n    if( !objectType && vmo.modelType && vmo.modelType.parentTypeName ) {\n        objectType = vmo.modelType.parentTypeName;\n    }\n    return objectType;\n}\n\n/**\n * Gets the typeHierarchy array from object\n * @param {Object} dataObject - The VMO/Object to get type Hierarchy array from\n *\n * @returns {Array|null} - Returns the typeHierarchyArry or null if non-existent\n */\nlet getTypeHierarchyArray = function( dataObject ) {\n    if( dataObject ) {\n        if( dataObject.modelType && dataObject.modelType.typeHierarchyArray ) {\n            return dataObject.modelType.typeHierarchyArray;\n        } else if( dataObject.typeHierarchy ) {\n            return dataObject.typeHierarchy;\n        } else if( dataObject.type ) {\n            return [ dataObject.type ];\n        }\n    }\n    return null;\n};\n\n/**\n * Gets the relevant definitions from teh typeIconsRegistry\n *\n * @param {Object} vmo - the view model object\n * @param {Object|null} adaptedObj - The adaptedObject or null\n *\n * @returns {Object[]} - relevant typeIconsRegistry definitions\n */\nlet getRelevantDefs = function( vmo, adaptedObj ) {\n    const typesToCheck = new Set();\n    const vmoTypeHierarchyArr = getTypeHierarchyArray( vmo );\n\n    if( vmoTypeHierarchyArr ) {\n        for( let i = 0; i < vmoTypeHierarchyArr.length; i++ ) {\n            typesToCheck.add( vmoTypeHierarchyArr[ i ] );\n        }\n    }\n\n    if( adaptedObj ) {\n        let adaptedTypeHierarchyArr = getTypeHierarchyArray( adaptedObj );\n        if( adaptedTypeHierarchyArr ) {\n            for( let j = 0; j < adaptedTypeHierarchyArr.length; j++ ) {\n                typesToCheck.add( adaptedTypeHierarchyArr[ j ] );\n            }\n        }\n    }\n\n    return _typeIconsRegistry.filter( ( o ) => {\n        if( o.type && o.type.names ) {\n            // Check if any items in set are valid here, best way is loop through the registry entry names,\n            // Since there are generally only one or two items in each, so this will be faster\n            for( let k = 0; k < o.type.names.length; k++ ) {\n                if( typesToCheck.has( o.type.names[ k ] ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    } );\n};\n\n/**\n * Loads the type Icons registry configuration\n */\nexport let loadConfiguration = function() {\n    //  FIXME this should be loaded async but before the sync API below that uses it is called\n    const typeIconsRegistryCfg = cfgSvc.getCfgCached( 'typeIconsRegistry' );\n    _typeIconsRegistry = typeIconsRegistryCfg ? typeIconsRegistryCfg : [];\n};\n\nexports = {\n    isObjOfAnyTypeNames,\n    getIconForType,\n    getVmoForThumbnail,\n    getCustomVmoForThumbnail,\n    getCustomIcon,\n    loadConfiguration\n};\nexport default exports;\n\nloadConfiguration();\n"]},"metadata":{},"sourceType":"module"}