{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/clientMetaModel\n */\nimport iconMapSvc from 'js/iconMapService';\nimport _ from 'lodash';\n/**\n * Object used to implement a typeName-to-PropertyType cache map.\n */\n\nvar _name2modelType = {};\n/**\n * Reference to the 'iconService' set into this module and used to reuse type file information.\n * <P>\n * Note: We are trying to avoid a cyclic reference since 'iconService' required CMM to do its work.\n */\n\n/**\n * @type {Object} map of property descriptors for reuse; property name to PropertyDescriptor or PropertyDescriptor[]\n */\n\nvar _propertyDescriptors = {};\nlet exports;\n/**\n * Get the resolved filename of the SVG icon.\n *\n * @param {Object} modelType - The Teamcenter ModelObject's 'modelType' object which\n * @return {String} type icon file name\n */\n\nexport let getTypeIconFileName = function (modelType) {\n  for (var ii = 0; ii < modelType.typeHierarchyArray.length; ii++) {\n    var typeName = modelType.typeHierarchyArray[ii];\n    var typeFileName = iconMapSvc.getTypeFileName(typeName);\n\n    if (typeFileName) {\n      return typeFileName;\n    }\n  }\n\n  return iconMapSvc.getTypeFileName('MissingImage');\n};\n/**\n * @param {Object} modelTypeSOA - model type object returned from SOA\n */\n\nvar ModelType = function (modelTypeSOA) {\n  this.abstract = modelTypeSOA.abstract;\n  this.children = modelTypeSOA.children;\n  this.displayName = modelTypeSOA.displayName;\n  this.name = modelTypeSOA.name;\n  this.owningType = modelTypeSOA.owningType;\n  this.parentTypeName = modelTypeSOA.parentTypeName;\n  this.primary = modelTypeSOA.primary ? true : undefined;\n  this.references = modelTypeSOA.references;\n  this.typeHierarchyArray = modelTypeSOA.typeHierarchy ? modelTypeSOA.typeHierarchy.split(',') : null;\n  this.typeUid = modelTypeSOA.typeUid;\n  this.uid = modelTypeSOA.uid;\n  this.constantsMap = {};\n  this.propertyDescriptorsMap = {}; // To support property processing in CDM during model object caching, create a map of the property descriptors.\n\n  if (modelTypeSOA.propertyDescriptors) {\n    for (var jj = modelTypeSOA.propertyDescriptors.length - 1; jj >= 0; jj--) {\n      var propertyDescriptorSOA = modelTypeSOA.propertyDescriptors[jj];\n      var propName = propertyDescriptorSOA.name;\n      var pd = new PropertyDescriptor(propertyDescriptorSOA);\n      var cachedPD = _propertyDescriptors[propName];\n\n      if (cachedPD) {\n        if (_.isArray(cachedPD)) {\n          // is array\n          var foundPD = false;\n\n          _.forEach(cachedPD, function (pd2) {\n            if (_.isEqual(pd, pd2)) {\n              pd = pd2;\n              foundPD = true;\n              return false; // break\n            }\n          });\n\n          if (!foundPD) {\n            // not in array already, add new one\n            cachedPD.push(pd);\n          }\n        } else if (_.isEqual(pd, cachedPD)) {\n          // not array & equal to cached pd\n          pd = cachedPD;\n        } else {\n          // not equal to cached PD, so we create array to track both\n          _propertyDescriptors[propName] = [cachedPD, pd];\n        }\n      } else {\n        // first encounter of this property descriptor, so cache it\n        _propertyDescriptors[propName] = pd;\n      }\n\n      this.propertyDescriptorsMap[propName] = pd;\n    }\n  }\n\n  if (modelTypeSOA.constants) {\n    for (jj = modelTypeSOA.constants.length - 1; jj >= 0; jj--) {\n      var constant = modelTypeSOA.constants[jj];\n      this.constantsMap[constant.name] = constant.value;\n    }\n  }\n\n  if (!this.constantsMap.IconFileName && this.typeHierarchyArray) {\n    this.constantsMap.IconFileName = exports.getTypeIconFileName(this);\n  }\n};\n/**\n * @param {Object} propertyDescriptorSOA - property descriptor object returned from SOA\n */\n\n\n_c = ModelType;\n\nvar PropertyDescriptor = function (propertyDescriptorSOA) {\n  this.anArray = propertyDescriptorSOA.anArray ? true : undefined;\n  this.basedOn = propertyDescriptorSOA.basedOn;\n  this.compoundObjType = propertyDescriptorSOA.compoundObjType;\n  this.displayName = propertyDescriptorSOA.displayName;\n  this.fieldType = propertyDescriptorSOA.fieldType;\n  this.lovCategory = propertyDescriptorSOA.lovCategory;\n  this.maxArraySize = propertyDescriptorSOA.maxArraySize;\n  this.maxLength = propertyDescriptorSOA.maxLength;\n  this.minValue = propertyDescriptorSOA.minValue;\n  this.name = propertyDescriptorSOA.name;\n  this.propertyType = propertyDescriptorSOA.propertyType;\n  this.propertyType2 = propertyDescriptorSOA.propertyType2;\n  this.valueType = propertyDescriptorSOA.valueType;\n  this.constantsMap = {};\n\n  if (propertyDescriptorSOA.constants) {\n    for (var kk = propertyDescriptorSOA.constants.length - 1; kk >= 0; kk--) {\n      var constant = propertyDescriptorSOA.constants[kk];\n      this.constantsMap[constant.name] = constant.value;\n    }\n  }\n};\n/**\n * Does client meta model contain type?\n *\n * @param {String} name - property type name.\n * @return {Boolean} true if model type is contained within the CMM\n */\n\n\n_c2 = PropertyDescriptor;\nexport let containsType = function (name) {\n  return _name2modelType.hasOwnProperty(name);\n};\n/**\n * Get model type by type name.\n *\n * @param {String} name - type name (or UID)\n * @return {ModelType|null} model type if contained within CMM\n */\n\nexport let getType = function (name) {\n  if (exports.containsType(name)) {\n    return _name2modelType[name];\n  }\n\n  if (exports.isTypeUid(name)) {\n    return exports.getType(exports.extractTypeNameFromUID(name));\n  }\n\n  return null;\n};\n/**\n * @param {ModelObject} modelObject - ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject represents a 'type' object.\n */\n\nexport let isTypeObject = function (modelObject) {\n  /**\n   * Note: We do not want to cache 'types' in the model object cache.\n   */\n  return exports.isTypeUid(modelObject.uid);\n};\n/**\n * Returns True if this type is child of the give type.\n *\n * @param {String} typeName - name of class\n * @param {ModelType} modelType - view model object's model type.\n * @return {Boolean} true if this type is child of the give type.\n */\n\nexport let isInstanceOf = function (typeName, modelType) {\n  if (typeName && modelType) {\n    if (typeName === modelType.name || modelType.typeHierarchyArray && modelType.typeHierarchyArray.indexOf(typeName) > -1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject UID represents a 'type' object.\n */\n\nexport let isTypeUid = function (uid) {\n  /**\n   * Note: We do not want to cache 'types' in the model object cache.\n   */\n  return uid && /^TYPE::/i.test(uid);\n};\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {String} type name extracted from UID\n */\n\nexport let extractTypeNameFromUID = function (uid) {\n  return uid.split('::')[1];\n};\n/**\n * Cache model types into client meta model.\n *\n * @param {ModelType[]} modelTypes - Array of {ModelType} objects.\n */\n\nexport let cacheTypes = function (modelTypes) {\n  for (var ii = modelTypes.length - 1; ii >= 0; ii--) {\n    var modelType = modelTypes[ii]; // Don't update cache if a model type comes across again\n\n    if (!exports.containsType(modelType.name)) {\n      _name2modelType[modelType.name] = new ModelType(modelType);\n    }\n  }\n};\nexports = {\n  getTypeIconFileName,\n  containsType,\n  getType,\n  isTypeObject,\n  isInstanceOf,\n  isTypeUid,\n  extractTypeNameFromUID,\n  cacheTypes\n};\nexport default exports;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ModelType\");\n$RefreshReg$(_c2, \"PropertyDescriptor\");","map":{"version":3,"names":["iconMapSvc","_","_name2modelType","_propertyDescriptors","exports","getTypeIconFileName","modelType","ii","typeHierarchyArray","length","typeName","typeFileName","getTypeFileName","ModelType","modelTypeSOA","abstract","children","displayName","name","owningType","parentTypeName","primary","undefined","references","typeHierarchy","split","typeUid","uid","constantsMap","propertyDescriptorsMap","propertyDescriptors","jj","propertyDescriptorSOA","propName","pd","PropertyDescriptor","cachedPD","isArray","foundPD","forEach","pd2","isEqual","push","constants","constant","value","IconFileName","anArray","basedOn","compoundObjType","fieldType","lovCategory","maxArraySize","maxLength","minValue","propertyType","propertyType2","valueType","kk","containsType","hasOwnProperty","getType","isTypeUid","extractTypeNameFromUID","isTypeObject","modelObject","isInstanceOf","indexOf","test","cacheTypes","modelTypes"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/kernel/clientMetaModel.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/clientMetaModel\n */\nimport iconMapSvc from 'js/iconMapService';\nimport _ from 'lodash';\n\n/**\n * Object used to implement a typeName-to-PropertyType cache map.\n */\nvar _name2modelType = {};\n\n/**\n * Reference to the 'iconService' set into this module and used to reuse type file information.\n * <P>\n * Note: We are trying to avoid a cyclic reference since 'iconService' required CMM to do its work.\n */\n\n/**\n * @type {Object} map of property descriptors for reuse; property name to PropertyDescriptor or PropertyDescriptor[]\n */\nvar _propertyDescriptors = {};\n\nlet exports;\n\n/**\n * Get the resolved filename of the SVG icon.\n *\n * @param {Object} modelType - The Teamcenter ModelObject's 'modelType' object which\n * @return {String} type icon file name\n */\nexport let getTypeIconFileName = function( modelType ) {\n    for( var ii = 0; ii < modelType.typeHierarchyArray.length; ii++ ) {\n        var typeName = modelType.typeHierarchyArray[ ii ];\n        var typeFileName = iconMapSvc.getTypeFileName( typeName );\n        if( typeFileName ) {\n            return typeFileName;\n        }\n    }\n\n    return iconMapSvc.getTypeFileName( 'MissingImage' );\n};\n\n/**\n * @param {Object} modelTypeSOA - model type object returned from SOA\n */\nvar ModelType = function( modelTypeSOA ) {\n    this.abstract = modelTypeSOA.abstract;\n    this.children = modelTypeSOA.children;\n    this.displayName = modelTypeSOA.displayName;\n    this.name = modelTypeSOA.name;\n    this.owningType = modelTypeSOA.owningType;\n    this.parentTypeName = modelTypeSOA.parentTypeName;\n    this.primary = modelTypeSOA.primary ? true : undefined;\n    this.references = modelTypeSOA.references;\n    this.typeHierarchyArray = modelTypeSOA.typeHierarchy ? modelTypeSOA.typeHierarchy.split( ',' ) : null;\n    this.typeUid = modelTypeSOA.typeUid;\n    this.uid = modelTypeSOA.uid;\n\n    this.constantsMap = {};\n    this.propertyDescriptorsMap = {};\n\n    // To support property processing in CDM during model object caching, create a map of the property descriptors.\n    if( modelTypeSOA.propertyDescriptors ) {\n        for( var jj = modelTypeSOA.propertyDescriptors.length - 1; jj >= 0; jj-- ) {\n            var propertyDescriptorSOA = modelTypeSOA.propertyDescriptors[ jj ];\n            var propName = propertyDescriptorSOA.name;\n            var pd = new PropertyDescriptor( propertyDescriptorSOA );\n\n            var cachedPD = _propertyDescriptors[ propName ];\n            if( cachedPD ) {\n                if( _.isArray( cachedPD ) ) {\n                    // is array\n                    var foundPD = false;\n                    _.forEach( cachedPD, function( pd2 ) {\n                        if( _.isEqual( pd, pd2 ) ) {\n                            pd = pd2;\n                            foundPD = true;\n                            return false; // break\n                        }\n                    } );\n                    if( !foundPD ) {\n                        // not in array already, add new one\n                        cachedPD.push( pd );\n                    }\n                } else if( _.isEqual( pd, cachedPD ) ) {\n                    // not array & equal to cached pd\n                    pd = cachedPD;\n                } else {\n                    // not equal to cached PD, so we create array to track both\n                    _propertyDescriptors[ propName ] = [ cachedPD, pd ];\n                }\n            } else {\n                // first encounter of this property descriptor, so cache it\n                _propertyDescriptors[ propName ] = pd;\n            }\n\n            this.propertyDescriptorsMap[ propName ] = pd;\n        }\n    }\n\n    if( modelTypeSOA.constants ) {\n        for( jj = modelTypeSOA.constants.length - 1; jj >= 0; jj-- ) {\n            var constant = modelTypeSOA.constants[ jj ];\n            this.constantsMap[ constant.name ] = constant.value;\n        }\n    }\n\n    if( !this.constantsMap.IconFileName && this.typeHierarchyArray ) {\n        this.constantsMap.IconFileName = exports.getTypeIconFileName( this );\n    }\n};\n\n/**\n * @param {Object} propertyDescriptorSOA - property descriptor object returned from SOA\n */\nvar PropertyDescriptor = function( propertyDescriptorSOA ) {\n    this.anArray = propertyDescriptorSOA.anArray ? true : undefined;\n    this.basedOn = propertyDescriptorSOA.basedOn;\n    this.compoundObjType = propertyDescriptorSOA.compoundObjType;\n    this.displayName = propertyDescriptorSOA.displayName;\n    this.fieldType = propertyDescriptorSOA.fieldType;\n    this.lovCategory = propertyDescriptorSOA.lovCategory;\n    this.maxArraySize = propertyDescriptorSOA.maxArraySize;\n    this.maxLength = propertyDescriptorSOA.maxLength;\n    this.minValue = propertyDescriptorSOA.minValue;\n    this.name = propertyDescriptorSOA.name;\n    this.propertyType = propertyDescriptorSOA.propertyType;\n    this.propertyType2 = propertyDescriptorSOA.propertyType2;\n    this.valueType = propertyDescriptorSOA.valueType;\n\n    this.constantsMap = {};\n\n    if( propertyDescriptorSOA.constants ) {\n        for( var kk = propertyDescriptorSOA.constants.length - 1; kk >= 0; kk-- ) {\n            var constant = propertyDescriptorSOA.constants[ kk ];\n            this.constantsMap[ constant.name ] = constant.value;\n        }\n    }\n};\n\n/**\n * Does client meta model contain type?\n *\n * @param {String} name - property type name.\n * @return {Boolean} true if model type is contained within the CMM\n */\nexport let containsType = function( name ) {\n    return _name2modelType.hasOwnProperty( name );\n};\n\n/**\n * Get model type by type name.\n *\n * @param {String} name - type name (or UID)\n * @return {ModelType|null} model type if contained within CMM\n */\nexport let getType = function( name ) {\n    if( exports.containsType( name ) ) {\n        return _name2modelType[ name ];\n    }\n    if( exports.isTypeUid( name ) ) {\n        return exports.getType( exports.extractTypeNameFromUID( name ) );\n    }\n    return null;\n};\n\n/**\n * @param {ModelObject} modelObject - ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject represents a 'type' object.\n */\nexport let isTypeObject = function( modelObject ) {\n    /**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */\n    return exports.isTypeUid( modelObject.uid );\n};\n\n/**\n * Returns True if this type is child of the give type.\n *\n * @param {String} typeName - name of class\n * @param {ModelType} modelType - view model object's model type.\n * @return {Boolean} true if this type is child of the give type.\n */\nexport let isInstanceOf = function( typeName, modelType ) {\n    if( typeName && modelType ) {\n        if( typeName === modelType.name ||\n            modelType.typeHierarchyArray && modelType.typeHierarchyArray.indexOf( typeName ) > -1 ) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject UID represents a 'type' object.\n */\nexport let isTypeUid = function( uid ) {\n    /**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */\n    return uid && /^TYPE::/i.test( uid );\n};\n\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {String} type name extracted from UID\n */\nexport let extractTypeNameFromUID = function( uid ) {\n    return uid.split( '::' )[ 1 ];\n};\n\n/**\n * Cache model types into client meta model.\n *\n * @param {ModelType[]} modelTypes - Array of {ModelType} objects.\n */\nexport let cacheTypes = function( modelTypes ) {\n    for( var ii = modelTypes.length - 1; ii >= 0; ii-- ) {\n        var modelType = modelTypes[ ii ];\n        // Don't update cache if a model type comes across again\n        if( !exports.containsType( modelType.name ) ) {\n            _name2modelType[ modelType.name ] = new ModelType( modelType );\n        }\n    }\n};\n\nexports = {\n    getTypeIconFileName,\n    containsType,\n    getType,\n    isTypeObject,\n    isInstanceOf,\n    isTypeUid,\n    extractTypeNameFromUID,\n    cacheTypes\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}