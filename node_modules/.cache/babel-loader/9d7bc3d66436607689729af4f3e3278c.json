{"ast":null,"code":"/* eslint-disable require-jsdoc */ // Copyright (c) 2020 Siemens\n/**\n * Thue module defines helpful shared APIs and constants used throughout the popup code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/popupUtils\n */import _ from'lodash';import{DOMAPIs as dom}from'js/domUtils';import browserUtils from'js/browserUtils';// import eventBus from 'js/eventBus';\n// import panelContentService from 'js/panelContentService';\nimport{checkResize,resizeDetector}from'js/resizeDetector';import AwHttpService from'js/awHttpService';import AwPromiseService from'js/awPromiseService';import declUtils from'js/declUtils';import Draggable from'js/draggable';import keyCode from'js/keyCode';import wcagSvc from'js/wcagService';import{FLATPICKR_ID}from'js/dateTimeService';var exports={};var TOOLTIP_POPUP_CSS='sw-popup-tooltip sw_popup_easein';/**\n * The ammount the input box is allowed to move to the left/right before the UI popup (e.g. calendar, LOV ) is collapsed/hidden.\n */var _MAX_X=40;var _MAX_Y=40;var POPUP_ID_ATTRIBUTE='data-popup-id';// eslint-disable-next-line one-var\n/**\n * A reference to a created panel. This reference contains with properties/functions used to control the panel.\n * @param {!Object} panelEl the panelEl to wrap\n * @param {!Object} options the panel options\n * @final @constructor\n */function PanelRef(panelEl,options){this.id=getId(panelEl,options.forceUid);this.panelEl=panelEl;this.options=options;this.isAttached=false;this._removeListeners=[];this.interceptors={};}PanelRef.prototype.initialize=function(){this.updateBackReference(true);activateLifeCycleHooks(this);addEventListeners(this);processEnablers(this);processMultipleLevel(this);};PanelRef.prototype.clear=function(){this.updateBackReference();removeEventListeners(this);};PanelRef.prototype.attach=function(){this.initialize();this.triggerHook('open');// onMount && onMount();\nthis.isAttached=true;};PanelRef.prototype.detach=function(){this.clear();this.triggerHook('close');this.interceptors={};// Remove the DOM reference\nthis.panelEl=null;this.isAttached=false;};PanelRef.prototype.updateBackReference=function(isAdd){if(!this.options.reference){return;}var referenceEl=this.options.reference;var value=isAdd?this.id:'';referenceEl.setAttribute(POPUP_ID_ATTRIBUTE,value);};/**\n * Schedules an update. It will run on the next UI update available.\n */PanelRef.prototype.scheduleUpdate=function(){requestAnimationFrame(()=>{this.options.api.updatePosition();});};PanelRef.prototype.update=function(){let newOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return this.options.api.update(this,newOptions,force);};PanelRef.prototype.canClose=function(){return this.options&&!this.options.disableClose;};PanelRef.prototype.hide=function(){let force=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(force||!force&&this.canClose()){let popupRef=this;if(popupRef.parentPopup){//Update Next ref\nif(popupRef.nextPopup){popupRef.parentPopup.nextPopup=popupRef.nextPopup;popupRef.nextPopup.parentPopup=popupRef.parentPopup;}else{popupRef.parentPopup.nextPopup=null;}}return this.options.api.hide(this);}};PanelRef.prototype.triggerHook=function(type){if(['open','update','close'].indexOf(type)===-1){return;}_.each(this.interceptors[type],item=>{item(this);});};export{PanelRef};/**\n * A panel manager to track and manage all panel reference .\n * @final @constructor\n */function PopupManager(){this._previousPopupRef=null;this._popupMaps={};}PopupManager.prototype.get=function(id){if(id&&this._popupMaps[id]){return this._popupMaps[id];}return null;};PopupManager.prototype.add=function(panelRef){if(!panelRef){return;}var id=panelRef.id;let isPanelRefTooltip=panelRef.panelEl&&panelRef.panelEl.querySelector('.sw-popup-tooltip.sw-popup-easein')!==null;if(!this._popupMaps[id]){let validPanelRef=null;for(const k of Object.keys(this._popupMaps).reverse()){let validEl=dom.get('.aw-widgets-groupCommandStack',this._popupMaps[k].panelEl);// during keyboard navigation, reference of next and parent popup should not be\n// maintained if panelRef is an extended tooltip\n// reference of next and parent popup should not be maintained if panelRef is a tooltip\nif(validEl!==null&&!isPanelRefTooltip){validPanelRef=this._popupMaps[k];break;}}if(validPanelRef!==null){// Maintain reference of next and parent popup\nvalidPanelRef.nextPopup=panelRef;panelRef.parentPopup=validPanelRef;}this._popupMaps[id]=panelRef;}};PopupManager.prototype.remove=function(panelRef){if(!panelRef){return;}var id=panelRef.id;this._popupMaps[id]&&delete this._popupMaps[id];};Object.defineProperty(PopupManager.prototype,'previousPopupRef',{enumerable:true,configurable:true,get:function(){return this._previousPopupRef;},set:function(value){this._previousPopupRef=value;}});export{PopupManager};export let handleOpenedPopup=function(referenceEl,manager){let toggleMode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var id=referenceEl?referenceEl.getAttribute(POPUP_ID_ATTRIBUTE):null;var popupRef=manager.get(id);if(id&&toggleMode){popupRef.hide();return null;}else if(id){// force bring to foreground by hoist z-index or\n// force bring to foreground by re-append (safe and easy way)\ndom.append(popupRef.panelEl);return popupRef;}return true;};function removeEventListeners(panelRef){panelRef._removeListeners&&panelRef._removeListeners.forEach(function(removeFn){removeFn();});panelRef._removeListeners=[];}function processEnablers(popupRef){let options=popupRef.options;let{draggable,draggableInitializeDelay=200}=options;if(!draggable){return;}// contents maybe async loaded, handle maybe not ready(exist) yet.\nsetTimeout(()=>{let popupEl=popupRef.panelEl;if(popupEl){let dragElement=dom.get('.sw-popup-layout',popupEl);let headerElement=dom.get('.aw-layout-panelTitle, .panel-header',popupEl);let handle=undefined;if(options.handle){handle=dom.get(options.handle,popupEl);}else if(headerElement){handle=headerElement;}else{handle=dragElement;}let dragger=new Draggable(dragElement,{handle,limit:document.body,setCursor:true,className:options.draggableClassName||'sw-popup-draggable',// LCS-337929: expect popup to remain where it was dragged\n// add flag 'disableUpdate' to prevent auto update position if have been dragged\nonDragStart:function(){options.disableUpdate=true;// remove right / bottom to ensure element draggable\noptions.advancePositioning&&dom.setStyles(dragElement,{right:null,bottom:null});}});popupRef._removeListeners.push(dragger.destroy.bind(dragger));}},draggableInitializeDelay);}// MultipleLevel popup command bar case:\n// build cascade MultipleLevel popup menus\n// and define the event ignore list between them\nfunction processMultipleLevel(popupRef){let{options,panelEl}=popupRef;let{reference,manager,processNested,preset}=options;// exclude tooltip process\nif(preset&&preset==='tooltip'){return;}if(processNested===false||!reference||!manager){return;}// add current popup to ignore click list of all up Level popups\nlet parentPopup=dom.closest(reference,'div.sw-popup');while(parentPopup&&reference&&manager){let ref=manager.get(parentPopup.id);ref.options.ignoreClicksFrom=ref.options.ignoreClicksFrom||[];ref.options.ignoreClicksFrom.push(panelEl);// check upper level recursively\nreference=ref.options.reference;manager=ref.options.manager;parentPopup=dom.closest(reference,'div.sw-popup');}}function autoFocus(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;if(options.autoFocus!==false){getContainerElement(popupEl).focus();}}const hookHash={whenOpened:'open',whenUpdated:'update',whenClosed:'close'};const getHookKey=key=>key.replace(/whenOpened|whenUpdated|whenClosed/g,matched=>hookHash[matched]);function activateLifeCycleHooks(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;if(_.isObject(options.hooks)){var interceptors=popupRef.interceptors;// support hooks in array\n_.each(options.hooks,function(value,key){const v=[].concat(value||[]);const k=getHookKey(key);k&&(interceptors[k]=v);});}// TODO\n// // ensure close any orphan popup in case scope was destroyed\n// var scope = ngUtils.getElementScope( popupEl );\n// scope.$on( '$destroy', function () {\n//     // clear this flag so that this popup could be closed.\n//     delete options.disableClose;\n//     popupRef.panelEl && options.api.hide( popupEl );\n// } );\n}/**\n *\n * @param {JQLite} popupRef The panel element.\n */function addEventListeners(popupRef){configureAutoFocusAndLoopTabbable(popupRef);configureWatchSizeChange(popupRef);configureEscapeToClose(popupRef);configureClickOutsideToClose(popupRef);configureScrollListener(popupRef);configureResizeListener(popupRef);}function configureAutoFocusAndLoopTabbable(popupRef){const{options,panelEl,interceptors,_removeListeners}=popupRef;const{autoFocus}=options;if(autoFocus!==false){const dialogNode=getContentContainer(panelEl);const{removeHandlers,onClose}=wcagSvc.configureAutoFocus(dialogNode,popupRef);_removeListeners.push(...removeHandlers);interceptors.close.push(onClose);}}function configureWatchSizeChange(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;// ease the cost, or will cause mouseenter/mouseleave flickering issue in tooltip\nvar debouncedUpdatePosition=throttle(options.api.updatePosition);var listener=addWatchHandle(popupEl,function(){debouncedUpdatePosition();});// Queue remove listeners function\npopupRef._removeListeners.push(listener);}function configureEscapeToClose(popupRef){var options=popupRef.options;const handleEscape=event=>{if(popupRef&&popupRef.options&&popupRef.options.customClass!==TOOLTIP_POPUP_CSS){let key=event.key||event.keyCode;if(key===keyCode.ESCAPE&&options.closeWhenEsc!==false&&declUtils.isNil(popupRef.nextPopup)){event.stopPropagation();popupRef.hide();wcagSvc.skipToFirstFocusableElement(options.reference);}}};// Add listeners\ndocument.addEventListener('keyup',handleEscape);// Queue remove listeners function\npopupRef._removeListeners.push(()=>{document.removeEventListener('keyup',handleEscape);});}function checkIgnore(options,sourceEl){var set=options.ignoreClicksFrom||[];if(options.ignoreClicksFrom){// force convert to array\nset=[].concat(set);}if(options.ignoreReferenceClick&&options.reference){set.push(options.reference);}var found=set.find(item=>{let element=getElement(item);if(element&&(element===sourceEl||element.contains(sourceEl))){return true;}return false;});return Boolean(found);}function configureClickOutsideToClose(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;var target=options.parent;var reference=options.reference;if(options.clickOutsideToClose){var sourceEl;// Keep track of the element on which the mouse originally went down\n// so that we can only close the backdrop when the 'click' started on it.\n// A simple 'click' handler does not work, it sets the target object as the\n// element the mouse went down on.\n// var mousedownHandler = function( ev ) {\n//     sourceEl = ev.target;\n// };\n// We check if our original element and the target is the backdrop\n// because if the original was the backdrop and the target was inside the\n// panel we don't want to panel to close.\nvar clickHandler=function(ev){if(isTooltipClick(ev)||isNotyClick(ev)||isCalendarClick(ev)){return;}// We check if the sourceEl of the event is the panel element or one\n// of it's children. If it is not, then close the panel.\nsourceEl=ev.target;if(sourceEl!==popupEl&&!popupEl.contains(sourceEl)&&!isTooltipClick(sourceEl)){if(!checkIgnore(options,sourceEl)){options.api.hide(popupRef);}}};// Add listeners\ndom.on(target,'click,contextmenu',clickHandler,true);// Queue remove listeners function\npopupRef._removeListeners.push(function(){dom.off(target,'click,contextmenu',clickHandler,true);});}}const isTooltipClick=event=>dom.closest(event.target,'.sw-popup-tooltip');const isNotyClick=event=>dom.closest(event.target,'#noty_bottom_layout_container');const isCalendarClick=event=>dom.closest(event.target,FLATPICKR_ID);// function isTooltipClick( sourceEl ) {\n//     let tooltip = dom.closest( sourceEl, '.sw-popup-tooltip' );\n//     return Boolean( tooltip );\n// }\nfunction configureResizeListener(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;var handler=null;if(options.resizeToClose){var debouncedHide=throttle(options.api.hide);handler=()=>{debouncedHide(popupRef);};}else{var debouncedUpdatePosition=throttle(options.api.updatePosition);handler=()=>{debouncedUpdatePosition();};}// // Add listeners, use framework's event 'windowResize' instead of native event 'resize'\n// var scope = ngUtils.getElementScope( popupEl );\n// var removeListener = scope.$on( 'windowResize', handler );\n// // Queue remove listeners function\n// popupRef._removeListeners.push( function () {\n//     removeListener();\n// } );\n// if ( options.listenAreaChanges !== false ) {\n//     // FUTURE: use reference element's resize event, which needs framework's support.\n//     var sub = eventBus.subscribe( 'aw-splitter-update', handler );\n//     popupRef._removeListeners.push( () => { eventBus.unsubscribe( sub ); } );\n// }\n// FUTURE: use reference element's resize/move event, which needs framework's support.\n// Add listeners\nwindow.addEventListener('resize',handler);// Queue remove listeners function\npopupRef._removeListeners.push(()=>{window.removeEventListener('resize',handler);});}/**\n * Firefox and Qt browser have scroll issues: scroll event is firing multiple times even when mouse moves or hover on any element\n * Solution: for these browser, need to remember the last reported scroll position and check it against each new reported scroll position\n *\n * @returns {boolean} result - true for Firefox or Qt browser, false for others\n */function checkBrowser(){return browserUtils.isFirefox||browserUtils.isQt;}function checkOutsideScrollEvent(event,popupEl){var path=eventPath(event);return _.indexOf(path,popupEl)===-1;}function checkAncestorScrollEvent(event,popupEl,options){let{reference,useOutsideScrollEvent}=options;if(!reference||useOutsideScrollEvent){return checkOutsideScrollEvent(event,popupEl);}let path=composedPath(reference);return _.indexOf(path,event.target)!==-1;}function configureScrollListener(popupRef){var options=popupRef.options;var popupEl=popupRef.panelEl;var onScroll;var target=null;var onScrollWrapper=null;if(options.closeWhenParentScroll){var debouncedHide=throttle(options.api.hide);var processScrollEvent=function(event){debouncedHide(popupRef);};var checkScrollPosition=function(target){var oldY=target.scrollTop;var oldX=target.scrollLeft;var wrapper=function(event){if(event.target!==target){return;}var curY=event.target.scrollTop;var curX=event.target.scrollLeft;if(Math.abs(oldX-curX)>_MAX_X||Math.abs(oldY-curY)>_MAX_Y){oldX=curX;oldY=curY;processScrollEvent(event);}};window.removeEventListener('scroll',onScroll,true);target.addEventListener('scroll',wrapper,true);return wrapper;};onScroll=function(event){// skip if scroll happens inside any ancestor node or an input field (like sibling lov case)\nif(!checkAncestorScrollEvent(event,popupEl,options)||event.target.tagName==='INPUT'){return;}// Firefox issue: scroll event is firing multiple times even when mouse moves or hover on any element\n// Solution: need to remember the last reported scroll position and check it against each new reported scroll position\nif(checkBrowser()){target=event.target;onScrollWrapper=checkScrollPosition(target);return;}processScrollEvent(event);};}else if(options.followParentScroll){var debouncedUpdatePosition=throttle(options.api.updatePosition);onScroll=function(event){if(checkAncestorScrollEvent(event,popupEl,options)){debouncedUpdatePosition();}};}if(onScroll){// Add listeners.\nwindow.addEventListener('scroll',onScroll,true);// Queue remove listeners function.\npopupRef._removeListeners.push(function(){window.removeEventListener('scroll',onScroll,true);if(checkBrowser()&&target){target.removeEventListener('scroll',onScrollWrapper,true);}});}}export let getContainerElement=function(popupEl){return dom.get('.sw-popup-layout',popupEl);};const getContentContainer=function(popupEl){// eslint-disable-next-line sonarjs/no-duplicate-string\nreturn dom.get('.sw-popup-contentContainer',popupEl);};export let processOptions=function(popupEl,options){var container=getContainerElement(popupEl);if(!container){return;}if(options.customClass){let customClasses=options.customClass.split(/\\s+|,/);customClasses.forEach(i=>{dom.addClass(container,i);});}var sizeCss={};var needUpdateStyle=false;if(options.containerWidth){sizeCss.width=options.containerWidth;sizeCss['max-width']=null;needUpdateStyle=true;}if(options.containerHeight){sizeCss.height=options.containerHeight;sizeCss['max-height']=null;needUpdateStyle=true;}needUpdateStyle&&dom.setStyles(container,sizeCss);};export let getTemplateFromUrl=function(url){return AwHttpService.instance.get(url,{cache:true}).then(response=>response.data).catch(()=>AwPromiseService.instance.reject(url+' type \"url\" not found! please check your resource!'));};export let getTemplateFromView=function(viewId,contextScope){// var subPanelContext = contextScope ? contextScope.subPanelContext : null;\n// return panelContentService.getPanelContent( viewId )\n//     .catch( () => AwPromiseService.instance.reject( viewId + ' type \"declView\" not found! please check your resource!' ) )\n//     .then( ( viewAndViewModelResponse ) => {\n//         return viewModelService.populateViewModelPropertiesFromJson( viewAndViewModelResponse.viewModel, false, null, null, null, subPanelContext )\n//             .then( ( declarativeViewModel ) => {\n//                 viewModelService.setupLifeCycle( contextScope, declarativeViewModel );\n//                 // align lifecycleHooks\n//                 contextScope._onMount = () => {\n//                     let onMountAction = _.get( contextScope, 'data._internal.lifecycleHooks.onMount' );\n//                     onMountAction && viewModelService.executeCommand( contextScope.data, onMountAction, contextScope );\n//                 };\n//                 // Legacy compatible: application are listening this event to retrieve data for that view\n//                 let modelId = _.get( contextScope, 'data._internal.modelId' ) || '?';\n//                 eventBus.publish( viewId + '.contentLoaded', { scope: contextScope, _source: modelId } );\n//                 return AwPromiseService.instance.resolve( viewAndViewModelResponse.view );\n//             } );\n//     } );\n};function getId(panelEl,forceUid){if(!panelEl){return null;}// force generate uid if\n// 1, not have a id\n// 2, multiple mode open\nif(forceUid&&panelEl.id){panelEl.id='';}if(!panelEl.id){dom.uniqueId(panelEl);}return panelEl.id;}/**\n * get the element\n *\n * @param {Element | String} element - can be an Element, or query string\n * @returns {Element} element\n */export let getElement=function(element){if(_.isString(element)){element=dom.get(element);}return element;};// ONLY FOR declarative usage due to principle: CSS selectors should not be exposed to view model\n// extend selector by add id sign\nexport let extendSelector=function(element){var reValidSelector=/^(\\.|#|aw)/i;if(_.isString(element)&&!reValidSelector.test(element)){element=element+', #'+element;}return element;};export let getArrowElement=function(popupEl){return dom.get('.sw-popup-arrow',popupEl);};function addWatchHandle(popupEl,cb){let containerEl=getContainerElement(popupEl);let fn=()=>{if(cb&&_.isFunction(cb)){cb();}};return resizeDetector(containerEl,fn);}// provide opportunity for user to specify the resizeContainer selector\nexport let getResizeContainer=function(element,containerSelector){if(containerSelector&&dom.match(element,containerSelector)){return element;}let selector=containerSelector||'.aw-base-scrollPanel';if(!containerSelector&&dom.get('.sw-popup-contentContainer',element)){selector='.sw-popup-contentContainer';}return dom.get(selector,element);};export let getMousePosition=function(event){let target={clientX:0,clientY:0};if(event){target=event;if(_.isUndefined(event.clientX)){target=event.touches[0];}}let{clientX,clientY}=target;return{x:clientX,y:clientY};};// it implements a window frame based throttle function to ease intensively triggered window events.\n// motivation is to improve performance, to ensure callback will only be fired once per frame for intensively triggered window events.\n// references: $mdDialog using a throttle decorator to decorate $$rAF service. popper.js implement it's own window frame based throttle method.\nfunction throttle(fn){var isBrowser=typeof window!=='undefined'&&typeof document!=='undefined';var supportsMicroTasks=isBrowser&&window.Promise;// eslint-disable-next-line one-var\nvar queuedArgs,alreadyQueued,queueCb,context;var microtaskThrottle=function(fn){alreadyQueued=false;return function throttled(){queuedArgs=arguments;context=this;queueCb=fn;if(alreadyQueued){return;}alreadyQueued=true;window.Promise.resolve().then(()=>{alreadyQueued=false;queueCb.apply(context,Array.prototype.slice.call(queuedArgs));});};};var taskThrottle=function(fn){var scheduled=false;var task=window.requestAnimationFrame||window.setTimeout;return function throttled(){var queuedArgs=arguments;context=this;queueCb=fn;if(!scheduled){scheduled=true;task(()=>{scheduled=false;queueCb.apply(context,Array.prototype.slice.call(queuedArgs));});}};};return(supportsMicroTasks?microtaskThrottle:taskThrottle)(fn);}function composedPath(el){let path=[];while(el){path.push(el);if(el.tagName==='HTML'){path.push(document);path.push(window);return path;}el=el.parentElement;}return path;}// get the event path in dom event bubbling\nfunction eventPath(event){var path=event.path||event.composedPath&&event.composedPath();// event.path always has wrong value for Qt browser\nif(!path||browserUtils.isQt){return composedPath(event.target);}return path;}// return the first clean node by skip any comment node.\nexport let cleanNode=nodesArray=>{let result=null;if(nodesArray&&nodesArray.length>0){result=_.find(nodesArray,item=>{return item.nodeType!==HTMLElement.COMMENT_NODE;});}return result;};// verify whether have any plain string content loaded\nlet verifyText=node=>{return Boolean((node.innerText||'').replace(/\\s|\\r|\\n/g,''));};// verify whether have any media content loaded\nlet verifyMedia=node=>{return Boolean(dom.get('img, svg',node));};export let tooltipAdapteStyle=node=>{// tooltip expected parent element to have \"display: block\" other than \"display: flex\"\ndom.removeClass(node,'aw-layout-flexbox');dom.setStyle(node,'overflow','hidden');};// getLoadingStatus by check transclude / plainHtml contents\n// used for balloon and tooltip\nlet getLoadingStatus=(container,adapteStyle)=>{let[container_css,transclude_css]=['.aw-layout-flexColumnContainer','aw-include>div.aw-layout-include, div.aw-base-scrollPanel>ng-transclude'];var content=dom.get(container_css,container);if(!content){return false;}var transclude=dom.get(transclude_css,content);var transcluded=Boolean(transclude)&&Boolean(cleanNode(transclude.childNodes));if(transcluded&&adapteStyle){tooltipAdapteStyle(transclude);}return verifyText(content)||verifyMedia(content);};export let runLoadingCheck=function(context,container){let adapteStyle=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let loaded=()=>getLoadingStatus(container,adapteStyle);let apply=function(){let loading=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;context.loading=loading;context.$apply&&context.$apply();};return new Promise(resolve=>{// defer to next cycle to avoid show loading in cache case\nsetTimeout(()=>{let loading=!loaded();apply(loading);if(!loading){resolve();return;}let timer=setInterval(()=>{if(loaded()){apply(false);}if(!context.loading||!dom.inDOM(container)){clearInterval(timer);resolve();}},50);});});};const RESIZE_POLLING_TIMEOUT=500;export let runResizeCheck=container=>{let oldSize={width:container.offsetWidth,height:container.offsetHeight};let noResizeTimeStart=Date.now();return new Promise(resolve=>{let timer=setInterval(()=>{if(checkResize(container,oldSize)()){noResizeTimeStart=Date.now();}else{let noResizeTime=Date.now()-noResizeTimeStart;// size got stable till now, safe to resolve.\nif(noResizeTime>RESIZE_POLLING_TIMEOUT){clearInterval(timer);resolve();}}},50);});};export let tooltipProgressCheck=(cb,progress)=>{let timer=setInterval(()=>{if(!progress.busy){clearInterval(timer);cb&&cb();}},50);};export let closeExistingTooltip=()=>{let nodes=dom.getAll('div.aw-popup-tooltip');let results=dom.getParent(nodes);results&&results.length>0&&dom.remove(results);};let checkWithinRightSide=node=>{return window.innerWidth/3-node.getBoundingClientRect().left<0;};export let tooltipAdapteOption=(raw,target)=>{let result=Object.assign({},raw);// backward compatible\nif(raw.alignment&&!raw.placement){if(raw.alignment==='VERTICAL'){result.placement='right';// if target element locate at the right side of the page, then flip the placement\nif(checkWithinRightSide(target)){result.placement='left';}}else if(/^(RIGHT|LEFT)/.test(raw.alignment)){result.placement='right';}else if(/^(TOP|BOTTOM)/.test(raw.alignment)){result.placement='top';}}return result;};export let processTooltipOptions=(rawOptions,target,popupOpenedCb,popupClosedCb)=>{let options={ownContainer:true,placement:['top','bottom','right','left'],flipBehavior:'opposite',whenParentScrolls:'close',adaptiveShift:true,// prevent tooltip cut off in corner case\nresizeToClose:true,advancePositioning:true,// prevent overlap or flash when popup content growing\nhasArrow:true,padding:{x:4,y:4},arrowOptions:{alignment:'center'},reference:target,minSize:5,forceCloseOthers:false,customClass:'aw-popup-tooltip aw_popup_easein',hooks:{whenOpened:element=>{popupOpenedCb&&popupOpenedCb(element);},whenClosed:element=>{popupClosedCb&&popupClosedCb(element);}}};if(_.keys(rawOptions).length>0){Object.assign(options,tooltipAdapteOption(rawOptions,target));}return options;};export let removeNativeTitle=node=>{dom.removeAttribute(node,'title');let results=dom.getAll('[title]',node);results.length>0&&dom.removeAttribute(results,'title');};exports={POPUP_ID_ATTRIBUTE,PanelRef,PopupManager,handleOpenedPopup,processOptions,getTemplateFromUrl,getTemplateFromView,getElement,checkIgnore,extendSelector,getContainerElement,getArrowElement,getResizeContainer,getMousePosition,cleanNode,runLoadingCheck,runResizeCheck,tooltipProgressCheck,closeExistingTooltip,tooltipAdapteOption,tooltipAdapteStyle,processTooltipOptions,removeNativeTitle,getContentContainer};export default exports;","map":null,"metadata":{},"sourceType":"module"}