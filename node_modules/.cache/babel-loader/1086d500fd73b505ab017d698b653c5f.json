{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * @module js/awSplitterService\n */\n// module\nimport eventBus from 'js/eventBus';\nimport localStorage from 'js/localStorage';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport analyticsSvc from 'js/analyticsService';\nlet exports;\nexport const constants = {\n  minSize1: 20,\n  minSize2: 20\n}; // A structure set when a splitter is activated (only one splitter an be active at any time)\n// See exports.mouseDownEvent for structure definition\n\nexport let activeSplitterData = null;\nlet splitterAction = null; // Tell the world the areas have changed size through a debounce function.\n\nlet publishNotification = _.debounce(function (splitterData, area1, area2) {\n  splitterAction && splitterAction({\n    splitter: splitterData.splitter,\n    area1: area1,\n    area2: area2\n  });\n  eventBus.publish('aw-splitter-update', {\n    splitter: splitterData.splitter,\n    area1: area1,\n    area2: area2\n  });\n}, 1000, {\n  maxWait: 20000,\n  trailing: true,\n  leading: false\n});\n/**\n * Method to publish analytics to server\n * @param {Number} area1Size - size of area1 in the UI (in pixels)\n * @param {Number} area2Size - size of area2 in the UI (in pixels)\n */\n\n\nconst publishAnalytics = (area1Size, area2Size) => {\n  let splitterEventData = {};\n  splitterEventData.sanAnalyticsType = 'Splitter';\n  splitterEventData.sanCommandId = 'Splitter';\n  splitterEventData.sanCommandTitle = 'Splitter';\n  splitterEventData.sanPrimaryPercentage = (area1Size / (area1Size + area2Size) * 100).toFixed(2);\n  splitterEventData.sanPixelSize = area1Size;\n  analyticsSvc.logCommands(splitterEventData);\n};\n/**\n * Initialize a Given Splitter\n *\n * Set the onmousedown event for the splitter and establishes the type of splitter\n *\n * @param {object} elementRefList - The elements used to define the splitter\n * @param {object} prop - The React props defined on the splitter\n * @param {object} viewMode - The current viewMode on time on init\n */\n\n\nexport const initSplitter = (elementRefList, prop, viewMode) => {\n  let attributes = prop;\n  var initialSplitterState;\n  let splitter = elementRefList.get('splitter').current;\n  var area1 = splitter.previousElementSibling;\n  var area2 = splitter.nextElementSibling;\n\n  if (!area1 && !area2) {\n    // xrt-splitter\n    let colSplit = splitter.closest('.aw-xrt-columnContentPanel');\n\n    if (colSplit) {\n      area1 = colSplit.previousElementSibling;\n      area2 = colSplit.nextElementSibling;\n      colSplit.style['min-width'] = '16px';\n      colSplit.style.width = '16px';\n      colSplit.style['max-width'] = '16px';\n      colSplit.style.padding = '0px';\n      colSplit.style.overflow = 'hidden';\n      colSplit.parentElement.style.flexWrap = 'nowrap';\n      colSplit.parentElement.style.height = '100%';\n      colSplit.parentElement.parentElement.style.height = '100%';\n      area1.style.minWidth = '0px';\n      area2.style.minWidth = '0px';\n      splitter.style.height = window.getComputedStyle(colSplit).getPropertyValue('height');\n    }\n  } // If user defines a direction use that. If not, check for row/column on each side. Else default to vertical\n\n\n  if (attributes.direction && attributes.direction.toUpperCase() === 'HORIZONTAL') {\n    splitter.style.cursor = 'row-resize';\n  } else {\n    splitter.style.cursor = 'col-resize';\n  }\n\n  splitter.onmousedown = event => exports.mouseDownEvent(event, prop.action);\n\n  splitter.ontouchstart = event => exports.mouseDownEvent(event, prop.action); // If this is the primary sash, load its previous position for a specific view.\n\n\n  if (attributes.isPrimarySplitter === 'true') {\n    if (viewMode) {\n      exports.viewModeContext = viewMode;\n    }\n\n    if (localStorage.get(exports.viewModeContext)) {\n      initialSplitterState = JSON.parse(localStorage.get(exports.viewModeContext));\n\n      if (initialSplitterState && area1 && area2) {\n        area1.style.flexBasis = initialSplitterState.area1Size + 'px';\n        area1.style.webkitFlexBasis = initialSplitterState.area1Size + 'px';\n        area1.style.flexGrow = '1';\n        area1.style.flexShrink = '1';\n        area2.style.flexBasis = initialSplitterState.area2Size + 'px';\n        area2.style.webkitFlexBasis = initialSplitterState.area2Size + 'px';\n      }\n    }\n  }\n}; // Setup mousemove/mouseup event listeners for iframes\n\nlet bubbleIframeMouseMove = function (iframe) {\n  var existingOnMouseMove = iframe.contentWindow.onmousemove;\n\n  iframe.contentWindow.onmousemove = function (e) {\n    // Fire any existing onmousemove listener\n    if (existingOnMouseMove) {\n      existingOnMouseMove(e);\n    }\n\n    var evt = document.createEvent('MouseEvents');\n    var boundingClientRect = iframe.getBoundingClientRect();\n    evt.initMouseEvent('mousemove', true, // true bubbles the event\n    false, // not cancelable\n    window, e.detail, e.screenX, e.screenY, e.clientX + boundingClientRect.left, e.clientY + boundingClientRect.top, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, null // no related element\n    );\n    iframe.dispatchEvent(evt);\n  };\n\n  iframe.contentWindow.onmouseup = function (e) {\n    var evt = document.createEvent('MouseEvents');\n    var boundingClientRect = iframe.getBoundingClientRect();\n    evt.initMouseEvent('mouseup', true, // true bubbles the event\n    false, // not cancelable\n    window, e.detail, e.screenX, e.screenY, e.clientX + boundingClientRect.left, e.clientY + boundingClientRect.top, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, null // no related element\n    );\n    iframe.dispatchEvent(evt);\n  };\n}; // Removes iframe mouse event listeners\n\n\nlet removebubbleIframeMouseEvent = function (iframe) {\n  iframe.contentWindow.onmousemove = null;\n  iframe.contentWindow.onmouseup = null;\n}; // handling DOM exception: if we try to access any event(e.g. onmouseup,onmousedown,etc) for cross-origin, we get DOM exception.\n\n\nlet canAccessIFrame = function (iframe) {\n  try {\n    return 'onmousemove' in iframe.contentWindow;\n  } catch (err) {\n    return false;\n  }\n};\n/**\n * Mouse Down Event - initialize the active splitter\n *\n * @param {object} event - mouse down event object\n */\n\n\nexport let mouseDownEvent = function (event, action) {\n  // Do not allow accidental text selection - which will cause the splitter to lockup\n  // Note that there are various CSS properties to control this but not a common one yet (as far as I can tell)\n  // Look for user-select: none (also ms-user-select and webkit-user-select and moz-user-select)\n  // Until there is a common way to prevent accidental selection - here is the workaround\n  event = event || window.event;\n\n  if (window.getSelection) {\n    var selection = window.getSelection();\n    var node = selection.focusNode;\n\n    if (node !== null) {\n      selection.removeAllRanges();\n    }\n  } else {\n    if (document.selection) {\n      document.selection.empty();\n    }\n  }\n\n  event.stopPropagation();\n  event.preventDefault(); // Create the active splitter data structure\n\n  var x = event.clientX;\n  var y = event.clientY;\n\n  if (!x && !y) {\n    x = event.touches[0].clientX;\n    y = event.touches[0].clientY;\n  }\n\n  var splitter = event.currentTarget;\n  var area1 = splitter.previousElementSibling;\n  var area2 = splitter.nextElementSibling;\n\n  if (!area1 && !area2) {\n    // xrt-splitter\n    let colSplit = splitter.closest('.aw-xrt-columnContentPanel');\n\n    if (colSplit) {\n      area1 = colSplit.previousElementSibling;\n      area2 = colSplit.nextElementSibling;\n    }\n  }\n\n  var minSize1 = parseInt(splitter.getAttribute('min-size-1'));\n  var minSize2 = parseInt(splitter.getAttribute('min-size-2'));\n  var isPrimarySplitter = splitter.getAttribute('isPrimarySplitter');\n  var viewMode = splitter.getAttribute('viewMode'); // If user did not define minimum sizes, default to 20\n\n  if (!minSize1 && !minSize2) {\n    minSize1 = exports.constants.minSize1;\n    minSize2 = exports.constants.minSize2;\n  }\n\n  var direction = splitter.style.cursor;\n  exports.activeSplitterData = {\n    splitter: splitter,\n    // The splitter element\n    area1: area1,\n    // The element to the left or on top\n    area2: area2,\n    // The element to the right or on bottom\n    minSize1: minSize1,\n    // The element to the left or on top minimum length\n    minSize2: minSize2,\n    // The element to the right or on bottom minimum length\n    direction: direction,\n    // row-resize or column-resize\n    isPrimarySplitter: isPrimarySplitter,\n    // If the current splitter is the primary to remember its position\n    viewMode: viewMode,\n    x: x,\n    y: y\n  }; // Last mouse position used to update splitter\n\n  splitterAction = action; // iframes suppress mouse events so the iframe's mouse events need to be bubbled up to the document level\n\n  var iframes = document.getElementsByTagName('iframe');\n\n  for (var i = 0; i < iframes.length; i++) {\n    if (canAccessIFrame(iframes[i])) {\n      bubbleIframeMouseMove(iframes[i]);\n    }\n  }\n\n  document.addEventListener('mousemove', mouseMoveEventHandler);\n  document.addEventListener('mouseup', mouseUpEventHandler);\n  document.addEventListener('touchmove', mouseMoveEventHandler);\n  document.addEventListener('touchend', mouseUpEventHandler);\n  document.addEventListener('touchcancel', mouseUpEventHandler);\n};\n/**\n * Mouse Up Event Handler - stop the active splitter\n *\n * @param {event} event - Event object\n */\n\nexport let mouseUpEventHandler = function () {\n  document.removeEventListener('mousemove', mouseMoveEventHandler);\n  document.removeEventListener('mouseup', mouseUpEventHandler);\n  document.removeEventListener('touchmove', mouseMoveEventHandler);\n  document.removeEventListener('touchend', mouseUpEventHandler);\n  document.removeEventListener('touchcancel', mouseUpEventHandler); // Remove iframe mouse event listeners on mouseup\n\n  var iframes = document.getElementsByTagName('iframe');\n\n  for (var i = 0; i < iframes.length; i++) {\n    if (canAccessIFrame(iframes[i])) {\n      removebubbleIframeMouseEvent(iframes[i]);\n    }\n  } // Remember the sash's position for the specific view.\n\n\n  if (exports.activeSplitterData.viewMode) {\n    exports.viewModeContext = exports.activeSplitterData.viewMode;\n  }\n\n  if (exports.activeSplitterData.isPrimarySplitter && exports.viewModeContext) {\n    // After moving the primary splitter, we want the primary workarea to become a flex-item in order to resize on browser width changes.\n    exports.activeSplitterData.area1.style.flexGrow = '1';\n    exports.activeSplitterData.area1.style.flexShrink = '1';\n    var area1Size = exports.activeSplitterData.area1.clientWidth;\n    var area2Size = exports.activeSplitterData.area2.clientWidth;\n    var data = {\n      area1Size: area1Size,\n      area2Size: area2Size\n    };\n    localStorage.publish(exports.viewModeContext, JSON.stringify(data));\n    publishAnalytics(area1Size, area2Size);\n  }\n\n  exports.activeSplitterData = null;\n};\n/**\n * Mouse Move Event Handler - update the active splitter\n *\n * @param {event} event - Event object\n */\n\nexport let mouseMoveEventHandler = function (event) {\n  event = event || window.event;\n\n  if (exports.activeSplitterData === null) {\n    return;\n  }\n\n  event.preventDefault();\n  var x = event.clientX;\n  var y = event.clientY;\n\n  if (!x && !y) {\n    var touch = event.originalEvent.touches[0];\n    x = touch.clientX;\n    y = touch.clientY;\n  }\n\n  exports.updateActiveSplitter(x, y);\n};\n/**\n * Update Active Splitter\n *\n * For a given mouse position update the size of the associated DIV elements for the active splitter.\n *\n * @param {number} xPos - current mouse X position\n * @param {number} yPos - current mouse Y position\n */\n\nexport let updateActiveSplitter = function (xPos, yPos) {\n  var splitterData = exports.activeSplitterData;\n\n  if (!splitterData) {\n    return;\n  }\n\n  var xDelta = xPos - splitterData.x;\n  var yDelta = yPos - splitterData.y;\n\n  if (xDelta === 0 && yDelta === 0) {\n    return;\n  }\n\n  var area1 = splitterData.area1;\n  var area2 = splitterData.area2;\n  var minSize1 = splitterData.minSize1;\n  var minSize2 = splitterData.minSize2;\n  var size1 = parseFloat(area1.style.flexGrow);\n  var size2 = parseFloat(area2.style.flexGrow);\n  var direction = splitterData.direction;\n\n  if (direction === 'row-resize') {\n    var h1 = area1.clientHeight;\n    var h2 = area2.clientHeight;\n\n    if (exports.splitterLimit(h1, h2, yDelta, minSize1, minSize2)) {\n      // make max size/min size if we hit the limit, not at the limit yet & not using flex grow\n      if (!size1 && !size2) {\n        if (yDelta > 0 && h2 !== minSize2) {\n          exports.updateAreaSize(area1, size1, h1, h2 - minSize2);\n          exports.updateAreaSize(area2, size2, minSize2, '');\n        } else if (yDelta < 0 && h1 !== minSize1) {\n          exports.updateAreaSize(area1, size1, minSize1, '');\n          exports.updateAreaSize(area2, size2, h2, h1 - minSize1);\n        }\n\n        splitterData.y = splitterData.splitter.getBoundingClientRect().top - 10;\n        splitterData.x = xPos;\n      }\n\n      return;\n    }\n\n    exports.updateAreaSize(area1, size1, h1, yDelta);\n    exports.updateAreaSize(area2, size2, h2, -yDelta);\n  } else {\n    // direction is column-resize\n    var w1 = area1.offsetWidth;\n    var w2 = area2.offsetWidth;\n\n    if (exports.splitterLimit(w1, w2, xDelta, minSize1, minSize2)) {\n      // make max size/min size if we hit the limit, not at the limit yet & not using flex grow\n      if (!size1 && !size2) {\n        if (xDelta > 0 && w2 !== minSize2) {\n          exports.updateAreaSize(area1, size1, w1, w2 - minSize2);\n          exports.updateAreaSize(area2, size2, minSize2, '');\n        } else if (xDelta < 0 && w1 !== minSize1) {\n          exports.updateAreaSize(area1, size1, minSize1, '');\n          exports.updateAreaSize(area2, size2, w2, w1 - minSize1);\n        }\n\n        splitterData.x = splitterData.splitter.getBoundingClientRect().right - 10;\n        splitterData.y = yPos;\n      }\n\n      return;\n    }\n\n    exports.updateAreaSize(area1, size1, w1, xDelta);\n    exports.updateAreaSize(area2, size2, w2, -xDelta);\n  }\n\n  splitterData.x = xPos;\n  splitterData.y = yPos;\n  publishNotification(splitterData, area1, area2);\n};\n/**\n * Update Area Size\n *\n * Update the size of a given area based on a delta amount and the type of area (fixed or proportional)\n *\n * @param {object} area - a row or column element\n * @param {number} oldSize - the previous attribute size value for the row or column\n * @param {number} oldSizePx - the previous rendered size in px for the row or column\n * @param {number} deltaPx - the amount to change the area in px\n */\n\nexport let updateAreaSize = function (area, oldSize, oldSizePx, deltaPx) {\n  var newSizePx = oldSizePx + deltaPx;\n  var when = area.getAttribute('when'); // This is a fixed size\n  // Note the size is no longer in units of em because the user has set a fix px size\n\n  if (when) {\n    area.style.maxWidth = '100%';\n  }\n\n  area.style.flexBasis = newSizePx.toString() + 'px';\n  area.style.webkitFlexBasis = newSizePx.toString() + 'px';\n};\n/**\n * Splitter Limit - return true if a splitter has hit a limiting size\n *\n * Return true if the limit is being hit for one of the areas The test is done this way because it is possible for\n * areas to become smaller than the limit due to window resizing. We want to be able to grow areas that are too\n * small with a splitter but not continue to shrink those areas\n *\n * @param {number} size1 - Size (width or height) of left or top area for the active splitter\n * @param {number} size2 - Size (width or height) of right or bottom area for the active splitter\n * @param {number} delta - Amount the sizes are being changed\n * @param {number} minSize1 - Minimum size (width or height) of left or top area for the active splitter\n * @param {number} minSize2 - Minimum size (width or height) of right or bottom area for the active splitter\n *\n *\n * @return {boolean} - true if a limit would be hit by the delta change\n */\n\nexport let splitterLimit = function (size1, size2, delta, minSize1, minSize2) {\n  if (delta > 0) {\n    // The right or bottom area is being reduced in size\n    if (size2 - delta < minSize2) {\n      return true;\n    }\n  } else {\n    // delta < 0 - the left or top area is being reduced in size\n    if (size1 + delta < minSize1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\n\nexport let reportError = function (errorMessage) {\n  logger.warn('awSplitterService:' + errorMessage);\n};\n/**\n * Update viewMode based on context\n *\n * @param {string} viewModeKey - ctx key for viewMode\n * @returns {string} viewMode\n */\n\nexport let updateViewMode = function (viewModeKey) {\n  return viewModeKey;\n};\nexports = {\n  constants,\n  activeSplitterData,\n  initSplitter,\n  mouseDownEvent,\n  mouseUpEventHandler,\n  mouseMoveEventHandler,\n  updateActiveSplitter,\n  updateAreaSize,\n  splitterLimit,\n  reportError,\n  updateViewMode\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/awSplitterService.js"],"names":["constants","minSize1","minSize2","activeSplitterData","splitterAction","publishNotification","splitter","splitterData","area1","area2","eventBus","maxWait","trailing","leading","publishAnalytics","splitterEventData","area1Size","analyticsSvc","initSplitter","attributes","elementRefList","colSplit","window","event","exports","prop","localStorage","initialSplitterState","JSON","bubbleIframeMouseMove","existingOnMouseMove","iframe","evt","document","boundingClientRect","e","removebubbleIframeMouseEvent","canAccessIFrame","mouseDownEvent","selection","node","x","y","parseInt","isPrimarySplitter","viewMode","direction","iframes","i","mouseUpEventHandler","area2Size","data","mouseMoveEventHandler","touch","updateActiveSplitter","xDelta","xPos","yDelta","yPos","size1","parseFloat","size2","h1","h2","w1","w2","updateAreaSize","newSizePx","oldSizePx","when","area","splitterLimit","delta","reportError","logger","updateViewMode"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * @module js/awSplitterService\n */\n\n// module\nimport eventBus from 'js/eventBus';\nimport localStorage from 'js/localStorage';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport analyticsSvc from 'js/analyticsService';\n\nlet exports;\n\nexport const constants = {\n    minSize1: 20,\n    minSize2: 20\n};\n\n// A structure set when a splitter is activated (only one splitter an be active at any time)\n// See exports.mouseDownEvent for structure definition\nexport let activeSplitterData = null;\nlet splitterAction = null;\n\n// Tell the world the areas have changed size through a debounce function.\nlet publishNotification = _.debounce( function( splitterData, area1, area2 ) {\n    splitterAction && splitterAction( {\n        splitter: splitterData.splitter,\n        area1: area1,\n        area2: area2\n    } );\n    eventBus.publish( 'aw-splitter-update', {\n        splitter: splitterData.splitter,\n        area1: area1,\n        area2: area2\n    } );\n}, 1000, {\n    maxWait: 20000,\n    trailing: true,\n    leading: false\n} );\n\n/**\n * Method to publish analytics to server\n * @param {Number} area1Size - size of area1 in the UI (in pixels)\n * @param {Number} area2Size - size of area2 in the UI (in pixels)\n */\nconst publishAnalytics = ( area1Size, area2Size ) => {\n    let splitterEventData = {};\n    splitterEventData.sanAnalyticsType = 'Splitter';\n    splitterEventData.sanCommandId = 'Splitter';\n    splitterEventData.sanCommandTitle = 'Splitter';\n    splitterEventData.sanPrimaryPercentage = ( area1Size / ( area1Size + area2Size ) * 100 ).toFixed( 2 );\n    splitterEventData.sanPixelSize = area1Size;\n    analyticsSvc.logCommands( splitterEventData );\n};\n\n/**\n * Initialize a Given Splitter\n *\n * Set the onmousedown event for the splitter and establishes the type of splitter\n *\n * @param {object} elementRefList - The elements used to define the splitter\n * @param {object} prop - The React props defined on the splitter\n * @param {object} viewMode - The current viewMode on time on init\n */\nexport const initSplitter = ( elementRefList, prop, viewMode ) => {\n    let attributes = prop;\n    var initialSplitterState;\n    let splitter = elementRefList.get( 'splitter' ).current;\n\n    var area1 = splitter.previousElementSibling;\n    var area2 = splitter.nextElementSibling;\n    if( !area1 && !area2 ) {\n        // xrt-splitter\n        let colSplit = splitter.closest( '.aw-xrt-columnContentPanel' );\n        if( colSplit ) {\n            area1 = colSplit.previousElementSibling;\n            area2 = colSplit.nextElementSibling;\n            colSplit.style[ 'min-width' ] = '16px';\n            colSplit.style.width = '16px';\n            colSplit.style[ 'max-width' ] = '16px';\n            colSplit.style.padding = '0px';\n            colSplit.style.overflow = 'hidden';\n            colSplit.parentElement.style.flexWrap = 'nowrap';\n            colSplit.parentElement.style.height = '100%';\n            colSplit.parentElement.parentElement.style.height = '100%';\n            area1.style.minWidth = '0px';\n            area2.style.minWidth = '0px';\n            splitter.style.height = window.getComputedStyle( colSplit ).getPropertyValue( 'height' );\n        }\n    }\n\n    // If user defines a direction use that. If not, check for row/column on each side. Else default to vertical\n    if( attributes.direction && attributes.direction.toUpperCase() === 'HORIZONTAL' ) {\n        splitter.style.cursor = 'row-resize';\n    } else {\n        splitter.style.cursor = 'col-resize';\n    }\n\n    splitter.onmousedown = ( event ) => exports.mouseDownEvent( event, prop.action );\n    splitter.ontouchstart = ( event ) => exports.mouseDownEvent( event, prop.action );\n\n    // If this is the primary sash, load its previous position for a specific view.\n    if( attributes.isPrimarySplitter === 'true' ) {\n        if( viewMode ) {\n            exports.viewModeContext = viewMode;\n        }\n        if( localStorage.get( exports.viewModeContext ) ) {\n            initialSplitterState = JSON.parse( localStorage.get( exports.viewModeContext ) );\n\n            if( initialSplitterState && area1 && area2 ) {\n                area1.style.flexBasis = initialSplitterState.area1Size + 'px';\n                area1.style.webkitFlexBasis = initialSplitterState.area1Size + 'px';\n                area1.style.flexGrow = '1';\n                area1.style.flexShrink = '1';\n\n                area2.style.flexBasis = initialSplitterState.area2Size + 'px';\n                area2.style.webkitFlexBasis = initialSplitterState.area2Size + 'px';\n            }\n        }\n    }\n};\n\n// Setup mousemove/mouseup event listeners for iframes\nlet bubbleIframeMouseMove = function( iframe ) {\n    var existingOnMouseMove = iframe.contentWindow.onmousemove;\n\n    iframe.contentWindow.onmousemove = function( e ) {\n        // Fire any existing onmousemove listener\n        if( existingOnMouseMove ) { existingOnMouseMove( e ); }\n\n        var evt = document.createEvent( 'MouseEvents' );\n\n        var boundingClientRect = iframe.getBoundingClientRect();\n\n        evt.initMouseEvent(\n            'mousemove',\n            true, // true bubbles the event\n            false, // not cancelable\n            window,\n            e.detail,\n            e.screenX,\n            e.screenY,\n            e.clientX + boundingClientRect.left,\n            e.clientY + boundingClientRect.top,\n            e.ctrlKey,\n            e.altKey,\n            e.shiftKey,\n            e.metaKey,\n            e.button,\n            null // no related element\n        );\n\n        iframe.dispatchEvent( evt );\n    };\n\n    iframe.contentWindow.onmouseup = function( e ) {\n        var evt = document.createEvent( 'MouseEvents' );\n\n        var boundingClientRect = iframe.getBoundingClientRect();\n\n        evt.initMouseEvent(\n            'mouseup',\n            true, // true bubbles the event\n            false, // not cancelable\n            window,\n            e.detail,\n            e.screenX,\n            e.screenY,\n            e.clientX + boundingClientRect.left,\n            e.clientY + boundingClientRect.top,\n            e.ctrlKey,\n            e.altKey,\n            e.shiftKey,\n            e.metaKey,\n            e.button,\n            null // no related element\n        );\n\n        iframe.dispatchEvent( evt );\n    };\n};\n\n// Removes iframe mouse event listeners\nlet removebubbleIframeMouseEvent = function( iframe ) {\n    iframe.contentWindow.onmousemove = null;\n    iframe.contentWindow.onmouseup = null;\n};\n\n// handling DOM exception: if we try to access any event(e.g. onmouseup,onmousedown,etc) for cross-origin, we get DOM exception.\nlet canAccessIFrame = function( iframe ) {\n    try {\n        return 'onmousemove' in iframe.contentWindow;\n    } catch ( err ) {\n        return false;\n    }\n};\n\n/**\n * Mouse Down Event - initialize the active splitter\n *\n * @param {object} event - mouse down event object\n */\nexport let mouseDownEvent = function( event, action ) {\n    // Do not allow accidental text selection - which will cause the splitter to lockup\n    // Note that there are various CSS properties to control this but not a common one yet (as far as I can tell)\n    // Look for user-select: none (also ms-user-select and webkit-user-select and moz-user-select)\n    // Until there is a common way to prevent accidental selection - here is the workaround\n    event = event || window.event;\n\n    if( window.getSelection ) {\n        var selection = window.getSelection();\n        var node = selection.focusNode;\n        if( node !== null ) {\n            selection.removeAllRanges();\n        }\n    } else {\n        if( document.selection ) {\n            document.selection.empty();\n        }\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Create the active splitter data structure\n    var x = event.clientX;\n    var y = event.clientY;\n    if( !x && !y ) {\n        x = event.touches[ 0 ].clientX;\n        y = event.touches[ 0 ].clientY;\n    }\n    var splitter = event.currentTarget;\n\n    var area1 = splitter.previousElementSibling;\n    var area2 = splitter.nextElementSibling;\n\n    if( !area1 && !area2 ) {\n        // xrt-splitter\n        let colSplit = splitter.closest( '.aw-xrt-columnContentPanel' );\n        if( colSplit ) {\n            area1 = colSplit.previousElementSibling;\n            area2 = colSplit.nextElementSibling;\n        }\n    }\n\n    var minSize1 = parseInt( splitter.getAttribute( 'min-size-1' ) );\n    var minSize2 = parseInt( splitter.getAttribute( 'min-size-2' ) );\n    var isPrimarySplitter = splitter.getAttribute( 'isPrimarySplitter' );\n    var viewMode = splitter.getAttribute( 'viewMode' );\n\n    // If user did not define minimum sizes, default to 20\n    if( !minSize1 && !minSize2 ) {\n        minSize1 = exports.constants.minSize1;\n        minSize2 = exports.constants.minSize2;\n    }\n\n    var direction = splitter.style.cursor;\n\n    exports.activeSplitterData = {\n        splitter: splitter, // The splitter element\n        area1: area1, // The element to the left or on top\n        area2: area2, // The element to the right or on bottom\n        minSize1: minSize1, // The element to the left or on top minimum length\n        minSize2: minSize2, // The element to the right or on bottom minimum length\n        direction: direction, // row-resize or column-resize\n        isPrimarySplitter: isPrimarySplitter, // If the current splitter is the primary to remember its position\n        viewMode: viewMode,\n        x: x,\n        y: y\n    }; // Last mouse position used to update splitter\n\n    splitterAction = action;\n    // iframes suppress mouse events so the iframe's mouse events need to be bubbled up to the document level\n    var iframes = document.getElementsByTagName( 'iframe' );\n    for( var i = 0; i < iframes.length; i++ ) {\n        if( canAccessIFrame( iframes[ i ] ) ) {\n            bubbleIframeMouseMove( iframes[ i ] );\n        }\n    }\n\n    document.addEventListener( 'mousemove', mouseMoveEventHandler );\n    document.addEventListener( 'mouseup', mouseUpEventHandler );\n\n    document.addEventListener( 'touchmove', mouseMoveEventHandler );\n    document.addEventListener( 'touchend', mouseUpEventHandler );\n    document.addEventListener( 'touchcancel', mouseUpEventHandler );\n};\n\n/**\n * Mouse Up Event Handler - stop the active splitter\n *\n * @param {event} event - Event object\n */\nexport let mouseUpEventHandler = function() {\n    document.removeEventListener( 'mousemove', mouseMoveEventHandler );\n    document.removeEventListener( 'mouseup', mouseUpEventHandler );\n\n    document.removeEventListener( 'touchmove', mouseMoveEventHandler );\n    document.removeEventListener( 'touchend', mouseUpEventHandler );\n    document.removeEventListener( 'touchcancel', mouseUpEventHandler );\n\n    // Remove iframe mouse event listeners on mouseup\n    var iframes = document.getElementsByTagName( 'iframe' );\n    for( var i = 0; i < iframes.length; i++ ) {\n        if( canAccessIFrame( iframes[ i ] ) ) {\n            removebubbleIframeMouseEvent( iframes[ i ] );\n        }\n    }\n\n    // Remember the sash's position for the specific view.\n    if( exports.activeSplitterData.viewMode ) {\n        exports.viewModeContext = exports.activeSplitterData.viewMode;\n    }\n    if( exports.activeSplitterData.isPrimarySplitter && exports.viewModeContext ) {\n        // After moving the primary splitter, we want the primary workarea to become a flex-item in order to resize on browser width changes.\n        exports.activeSplitterData.area1.style.flexGrow = '1';\n        exports.activeSplitterData.area1.style.flexShrink = '1';\n        var area1Size = exports.activeSplitterData.area1.clientWidth;\n        var area2Size = exports.activeSplitterData.area2.clientWidth;\n        var data = {\n            area1Size: area1Size,\n            area2Size: area2Size\n        };\n        localStorage.publish( exports.viewModeContext, JSON.stringify( data ) );\n        publishAnalytics( area1Size, area2Size );\n    }\n\n    exports.activeSplitterData = null;\n};\n\n/**\n * Mouse Move Event Handler - update the active splitter\n *\n * @param {event} event - Event object\n */\nexport let mouseMoveEventHandler = function( event ) {\n    event = event || window.event;\n    if( exports.activeSplitterData === null ) {\n        return;\n    }\n\n    event.preventDefault();\n\n    var x = event.clientX;\n    var y = event.clientY;\n    if( !x && !y ) {\n        var touch = event.originalEvent.touches[ 0 ];\n        x = touch.clientX;\n        y = touch.clientY;\n    }\n\n    exports.updateActiveSplitter( x, y );\n};\n\n/**\n * Update Active Splitter\n *\n * For a given mouse position update the size of the associated DIV elements for the active splitter.\n *\n * @param {number} xPos - current mouse X position\n * @param {number} yPos - current mouse Y position\n */\nexport let updateActiveSplitter = function( xPos, yPos ) {\n    var splitterData = exports.activeSplitterData;\n    if( !splitterData ) {\n        return;\n    }\n\n    var xDelta = xPos - splitterData.x;\n    var yDelta = yPos - splitterData.y;\n    if( xDelta === 0 && yDelta === 0 ) {\n        return;\n    }\n\n    var area1 = splitterData.area1;\n    var area2 = splitterData.area2;\n\n    var minSize1 = splitterData.minSize1;\n    var minSize2 = splitterData.minSize2;\n\n    var size1 = parseFloat( area1.style.flexGrow );\n    var size2 = parseFloat( area2.style.flexGrow );\n\n    var direction = splitterData.direction;\n\n    if( direction === 'row-resize' ) {\n        var h1 = area1.clientHeight;\n        var h2 = area2.clientHeight;\n\n        if( exports.splitterLimit( h1, h2, yDelta, minSize1, minSize2 ) ) {\n            // make max size/min size if we hit the limit, not at the limit yet & not using flex grow\n            if( !size1 && !size2 ) {\n                if( yDelta > 0 && h2 !== minSize2 ) {\n                    exports.updateAreaSize( area1, size1, h1, h2 - minSize2 );\n                    exports.updateAreaSize( area2, size2, minSize2, '' );\n                } else if( yDelta < 0 && h1 !== minSize1 ) {\n                    exports.updateAreaSize( area1, size1, minSize1, '' );\n                    exports.updateAreaSize( area2, size2, h2, h1 - minSize1 );\n                }\n                splitterData.y = splitterData.splitter.getBoundingClientRect().top - 10;\n                splitterData.x = xPos;\n            }\n            return;\n        }\n\n        exports.updateAreaSize( area1, size1, h1, yDelta );\n        exports.updateAreaSize( area2, size2, h2, -yDelta );\n    } else {\n        // direction is column-resize\n        var w1 = area1.offsetWidth;\n        var w2 = area2.offsetWidth;\n\n        if( exports.splitterLimit( w1, w2, xDelta, minSize1, minSize2 ) ) {\n            // make max size/min size if we hit the limit, not at the limit yet & not using flex grow\n            if( !size1 && !size2 ) {\n                if( xDelta > 0 && w2 !== minSize2 ) {\n                    exports.updateAreaSize( area1, size1, w1, w2 - minSize2 );\n                    exports.updateAreaSize( area2, size2, minSize2, '' );\n                } else if( xDelta < 0 && w1 !== minSize1 ) {\n                    exports.updateAreaSize( area1, size1, minSize1, '' );\n                    exports.updateAreaSize( area2, size2, w2, w1 - minSize1 );\n                }\n                splitterData.x = splitterData.splitter.getBoundingClientRect().right - 10;\n                splitterData.y = yPos;\n            }\n            return;\n        }\n\n        exports.updateAreaSize( area1, size1, w1, xDelta );\n        exports.updateAreaSize( area2, size2, w2, -xDelta );\n    }\n    splitterData.x = xPos;\n    splitterData.y = yPos;\n    publishNotification( splitterData, area1, area2 );\n};\n\n/**\n * Update Area Size\n *\n * Update the size of a given area based on a delta amount and the type of area (fixed or proportional)\n *\n * @param {object} area - a row or column element\n * @param {number} oldSize - the previous attribute size value for the row or column\n * @param {number} oldSizePx - the previous rendered size in px for the row or column\n * @param {number} deltaPx - the amount to change the area in px\n */\nexport let updateAreaSize = function( area, oldSize, oldSizePx, deltaPx ) {\n    var newSizePx = oldSizePx + deltaPx;\n    var when = area.getAttribute( 'when' );\n\n    // This is a fixed size\n    // Note the size is no longer in units of em because the user has set a fix px size\n    if( when ) {\n        area.style.maxWidth = '100%';\n    }\n    area.style.flexBasis = newSizePx.toString() + 'px';\n    area.style.webkitFlexBasis = newSizePx.toString() + 'px';\n};\n\n/**\n * Splitter Limit - return true if a splitter has hit a limiting size\n *\n * Return true if the limit is being hit for one of the areas The test is done this way because it is possible for\n * areas to become smaller than the limit due to window resizing. We want to be able to grow areas that are too\n * small with a splitter but not continue to shrink those areas\n *\n * @param {number} size1 - Size (width or height) of left or top area for the active splitter\n * @param {number} size2 - Size (width or height) of right or bottom area for the active splitter\n * @param {number} delta - Amount the sizes are being changed\n * @param {number} minSize1 - Minimum size (width or height) of left or top area for the active splitter\n * @param {number} minSize2 - Minimum size (width or height) of right or bottom area for the active splitter\n *\n *\n * @return {boolean} - true if a limit would be hit by the delta change\n */\nexport let splitterLimit = function( size1, size2, delta, minSize1, minSize2 ) {\n    if( delta > 0 ) { // The right or bottom area is being reduced in size\n        if( size2 - delta < minSize2 ) {\n            return true;\n        }\n    } else { // delta < 0 - the left or top area is being reduced in size\n        if( size1 + delta < minSize1 ) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\nexport let reportError = function( errorMessage ) {\n    logger.warn( 'awSplitterService:' + errorMessage );\n};\n\n/**\n * Update viewMode based on context\n *\n * @param {string} viewModeKey - ctx key for viewMode\n * @returns {string} viewMode\n */\nexport let updateViewMode = function( viewModeKey ) {\n    return viewModeKey;\n};\n\nexports = {\n    constants,\n    activeSplitterData,\n    initSplitter,\n    mouseDownEvent,\n    mouseUpEventHandler,\n    mouseMoveEventHandler,\n    updateActiveSplitter,\n    updateAreaSize,\n    splitterLimit,\n    reportError,\n    updateViewMode\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}