{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module is part of declarative UI framework and provides high level functionalities to work with view model.\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelService\n */import AwPromiseService from'js/awPromiseService';import declViewModProcFact from'js/viewModelProcessingFactory';import messagingSvc from'js/messagingService';import actionSvc from'js/actionService';import conditionSvc from'js/conditionService';import appCtxSvc from'js/appCtxService';import declDataCtxService from'js/declarativeDataCtxService';import Debug from'debug';import _ from'lodash';import logger from'js/logger';import declUtils from'./declUtils';import debugService from'js/debugService';import syncViewModelCacheService from'js/syncViewModelCacheService';import{loadDynModule}from'js/moduleLoader';var trace=new Debug('viewModel');var exports={};const eveulateEventCondition=function(eventObj,declViewModel,matched,props,context,fields){var conditionResult=false;if(eventObj.condition){var conditionExpression=null;if(_.startsWith(eventObj.condition,'conditions.')){var conditionObject=_.get(declViewModel._internal,eventObj.condition);conditionExpression=conditionObject.expression;}else{conditionExpression=eventObj.condition;}let currContext=null;if(context){if(context.scope){currContext=context.scope;}else{currContext=context;}}else{currContext={data:declViewModel,props:props,subPanelContext:props.subPanelContext,fields};}conditionResult=conditionSvc.evaluateCondition(declUtils.getLatestContext(currContext,declViewModel),conditionExpression,context);// if conditionResult is undefined or null we should consider result as false.\nif(!conditionResult){conditionResult=false;}}return eventObj.condition&&conditionResult||eventObj.criteria&&matched||!(eventObj.condition||eventObj.criteria);};const processMessageOnEvent=function(declViewModel,context,props,getProps,inputArgs,runActionWithViewModel,eventObj,fields,getFields){var allMessages=_.cloneDeep(declViewModel._internal.messages);if(!context.scope){context.scope={data:declViewModel,ctx:appCtxSvc.ctx,props,getProps,parameters:inputArgs?inputArgs:null,fields,getFields};context.scope.parameters=context.scope.parameters?{...context.scope.parameters,commandActionExecutor:{runActionWithViewModel}}:{commandActionExecutor:{runActionWithViewModel}};}messagingSvc.reportNotyMessage(declViewModel,allMessages,eventObj.message,context.scope);};const processActionOnEventHavingScope=function(context,inputArgs,runActionWithViewModel,props,getProps,declViewModel,eventObj,fields,getFields){context.scope.parameters=inputArgs?inputArgs:null;context.scope.parameters=context.scope.parameters?{...context.scope.parameters,commandActionExecutor:{runActionWithViewModel}}:{commandActionExecutor:{runActionWithViewModel}};context.scope.props=props;context.scope.getProps=getProps;context.scope.fields=fields;context.scope.getFields=getFields;exports.executeCommand(declViewModel,eventObj.action,context.scope);};const processActionOnEventWithScope=function(declViewModel,inputArgs,subPanelContext,props,getProps,runActionWithViewModel,eventObj,fields,getFields){var scope={data:declViewModel,ctx:appCtxSvc.ctx,parameters:inputArgs?inputArgs:null,subPanelContext:subPanelContext,props,getProps,fields,getFields};scope.parameters=scope.parameters?{...scope.parameters,commandActionExecutor:{runActionWithViewModel}}:{commandActionExecutor:{runActionWithViewModel}};exports.executeCommand(declViewModel,eventObj.action,scope);};const reteriveInputParOfEvent=function(context,inputArgs,eventObj,declViewModel){var contextObj={eventData:context};inputArgs=_.cloneDeep(eventObj.inputArgs);if(inputArgs){try{declDataCtxService.applyScope(declViewModel,inputArgs,null,contextObj,null);}catch(error){throw new Error(error);}}return inputArgs;};const handleEventDataCache=function(eventObj,declViewModel,context){if(eventObj.eventId){if(!declViewModel.eventMap){declViewModel.eventMap={};}const key=eventObj.eventId;const value={};value[key]=context;declViewModel.eventMap[eventObj.eventId]=value[key];declViewModel.data.eventMap={...declViewModel.eventMap};}declViewModel.eventData=context;declViewModel.data.eventData=context;};// eslint-disable-next-line complexity\nexport let handleRegisteredEvent=function(context,declViewModel,eventObj,limitEventScope,getProps,runActionWithViewModel,getFields){if(declViewModel.getData&&_.isFunction(declViewModel.getData)){declViewModel.data=declViewModel.getData();}const props=getProps();const fields=getFields();const subPanelContext=props.subPanelContext;debugService.debug('events',declViewModel._internal.panelId,eventObj.eventId);if(limitEventScope&&context._source!==declViewModel._internal.modelId){return;}// Check if the event source is set to 'current' and _source id is available.\n// If yes, make event listeners only listen to events fired by the current view model instance.\nif(eventObj.eventSource==='current'&&context._source&&context._source!==declViewModel._internal.modelId){return;}if(!declUtils.isValidModelAndEventData(declViewModel,context)){logger.error('_processEventRegistration: '+'Invalid input: eventId='+eventObj.eventId);return;}var matched=true;/**\n     * @deprecated : 'criteria' is deprecated we should use condition instead.\n     */_.forEach(eventObj.criteria,function(value,key){// For panel change events, the context doesn't have a scope, so check the properties on context directly.\nif(_.get(context.scope,key)!==value&&_.get(context,key)!==value){matched=false;}});/**\n     * \"onEvent\": [ { \"eventId\": \"someEvent\", \"condition\": \"conditions.shouldIDoSomething\",\n     * \"action\":\"doSomething\" } ]\n     */var isEventExecutable=eveulateEventCondition(eventObj,declViewModel,matched,props,context,fields);if(logger.isDeclarativeLogEnabled()){debugService.debugEventSub(eventObj,declViewModel,context,isEventExecutable);}if(isEventExecutable){var inputArgs=null;// Store the context eventData on declViewModel's eventData\nif(eventObj.cacheEventData){// const { dispatch } = declViewModel;\n// let finalObj = {};\nhandleEventDataCache(eventObj,declViewModel,context);}// If an event has some eventData and the same eventdata is required in the action,\n// associated with event, then user can construct inputArgs.\n// \"eventId\": \"AWEvent.test\",\n//     \"action\": \"fireSaveEdit\",\n//         \"inputArgs\": {\n//         \"param1\": \"{{eventData.operation1}}\",\n//         \"param3\": {\n//             \"param4\": \"{{eventData.operation4}}\",\n//             \"param5\": \"{{eventData.operation5}}\"\n//         }\n//     }\n// Later the same input Args can be reused in action through {{parameters.param1}}.\nif(eventObj.inputArgs){inputArgs=reteriveInputParOfEvent(context,inputArgs,eventObj,declViewModel);}if(eventObj.message){processMessageOnEvent(declViewModel,context,props,getProps,inputArgs,runActionWithViewModel,eventObj,fields,getFields);}else if(context&&context.scope){processActionOnEventHavingScope(context,inputArgs,runActionWithViewModel,props,getProps,declViewModel,eventObj,fields,getFields);}else{processActionOnEventWithScope(declViewModel,inputArgs,subPanelContext,props,getProps,runActionWithViewModel,eventObj,fields,getFields);}}};/**\n * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with\n * any data that is bound to various values including localized messages.\n *\n * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.\n *            <P>\n *            Note: The JSON contents are actually represented in the 'data' property of this object.\n *\n * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be\n *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)\n *\n * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a\n *            sub-panel\n * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by\n *            the current view model\n * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.\n *\n * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive\n *\n * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's\n *         JSON.\n */export let populateViewModelPropertiesFromJson=function(declViewModelJson,declViewModelTarget,subPanelId,limitEventScope,cacheI18nKey,subPanelContext){if(!declViewModelJson){return AwPromiseService.instance.reject('No ViewModel JSON object specified');}if(declViewModelTarget){if(!declViewModelTarget._internal.eventSubscriptions){return AwPromiseService.instance.reject('Target ViewModel missing required event property');}if(!declViewModelTarget._internal.origDeclViewModelJson){return AwPromiseService.instance.reject('Target ViewModel missing required JSON object property');}}/**\n     * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved\n     * 'declViewModel'.\n     */var newDeclViewModel=declViewModProcFact.processViewModel(declViewModelJson,subPanelContext);var jsonData=declViewModelJson;/**\n     * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')\n     */var resDeclViewModel;if(declViewModelTarget){resDeclViewModel=declViewModelTarget;/**\n         * Consolidate 'fresh' JSON properties into the given 'target'\n         * <P>\n         * Move all of the now populated 'data' properties into the 'target'\n         */_.forEach(jsonData.data,function(propValue,propName){resDeclViewModel[propName]=newDeclViewModel[propName];});resDeclViewModel.dataProviders=declUtils.consolidateObjects(resDeclViewModel.dataProviders,newDeclViewModel.dataProviders);resDeclViewModel.grids=declUtils.consolidateObjects(resDeclViewModel.grids,newDeclViewModel.grids);resDeclViewModel.columnProviders=declUtils.consolidateObjects(resDeclViewModel.columnProviders,newDeclViewModel.columnProviders);resDeclViewModel.chartProviders=declUtils.consolidateObjects(resDeclViewModel.chartProviders,newDeclViewModel.chartProviders);resDeclViewModel.commands=declUtils.consolidateObjects(resDeclViewModel.commands,newDeclViewModel.commands);resDeclViewModel.commandHandlers=declUtils.consolidateObjects(resDeclViewModel.commandHandlers,newDeclViewModel.commandHandlers);resDeclViewModel.commandPlacements=declUtils.consolidateObjects(resDeclViewModel.commandPlacements,newDeclViewModel.commandPlacements);// Consolidate all properties from view model object in newDeclViewModel\nvar vmo=newDeclViewModel.vmo;if(vmo){if(jsonData.data.objects){// Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.\n//                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {\n//                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,\n//                                    jsonData.data.owningObjUid, dataPropValue[0] );\n//                                if( dataPropValue[0].selected ) {\n//                                    resDeclViewModel.vmo = newVmo;\n//                                }\n//                            } );\n// The above code is no longer required. As there is no need to create a separate viewModelobject instance of\n// of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),\n// we already created  resDeclViewModel.vmo instance while forming the\n// newDeclViewModel.\n// Also difficult to determine which widgets are binded to which viewModel Object\nresDeclViewModel.vmo=newDeclViewModel.vmo;resDeclViewModel=declUtils.consolidateObjects(resDeclViewModel,newDeclViewModel.vmo.props);resDeclViewModel.attachEvents();}else{resDeclViewModel.vmo=resDeclViewModel.attachModelObject(vmo.uid,jsonData.data.operationName,jsonData.data.owningObjUid);}}resDeclViewModel._internal.consolidateJsonData(jsonData);newDeclViewModel._internal.destroy(false);}else{resDeclViewModel=newDeclViewModel;/**\n         * Move over fresh JSON properties\n         */resDeclViewModel._internal.setJsonData(jsonData);/**\n         * Object used to hold details of context changes that are being delayed (debounced).\n         */resDeclViewModel._internal.pendingContextChanges={};/**\n         * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things\n         * calm down a bit.\n         *\n         * When running in test mode this function will not be debounced\n         *\n         * @private\n         */ // revisitme charu\n// resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {\n//     maxWait: 10000,\n//     trailing: true,\n//     leading: false\n// } );\n/**\n        * revisitme Shaishav\n        * Hint: It was agreed that we do not need these event subscriptions are not required anymore.\n        * Keeping comments till we support all the usecases in new declarative engine\n        /**\n         * Listener for appCtx registration events\n        var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {\n            if( context ) {\n                if( _logCtxPathActivity_1 ) {\n                    logger.info( 'appCtx.register Subscribe: ' + context.name );\n                }\n\n                resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;\n\n                resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Listener for command panel 'reveal' events\n        var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {\n            /**\n             * Only call the default \"reveal\" action on reveal of main panel which doesn't have a panel ID\n             * in this context. Check if the view model available on scope is same as the result view model.\n             * In case two declarative panels are displayed on a page, then it results in two subscriptions\n             * to the panel reveal event. Use the decl view model comparison to execute action against\n             * reveal for appropriate panel\n            if( context.scope && !context.scope.panelId ) {\n                var declViewModel = context.scope.data;\n\n                if( declViewModel === resDeclViewModel ) {\n                    exports.executeCommand( declViewModel, 'reveal', context.scope );\n                }\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Remember these subscriptions to allow unsubscribe later.\n        resDeclViewModel._internal.eventSubscriptions.push( subDef1 );\n        resDeclViewModel._internal.eventSubscriptions.push( subDef2 );\n        */}/**\n     * Register any fresh 'eventBus' conditions\n     */ /**\n     * revisitme Shaishav\n     * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService\n    if( jsonData.onEvent ) {\n        var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,\n            limitEventScope, subPanelContext );\n        if( !declUtils.isNil( subPanelId ) ) {\n            if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {\n                resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;\n            } else {\n                _.forEach( eventSubscriptions, function( eventSubs ) {\n                    resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );\n                } );\n            }\n        } else {\n            resDeclViewModel._internal.eventSubscriptions = _.union(\n                resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );\n        }\n    }\n     */ /**\n     * Queue up loading and processing of the other model resources\n     */ /**\n     * revisitme Shaishav\n    * Hint: It was agreed that\n    * 1) We do not need load imports as we will rely on ES6 import / export\n    * 2) i18n population is already happening in the declreact/viewModelService.js\n    * 3) We have to populate TC preferences into the same flow when this revisitme is removed\n    * 4) Keeping comments till we support all the usecases in new declarative engine\n    var importsPromise = null;\n\n    if( jsonData.imports ) {\n        importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );\n    }\n\n    var prefPromise = null;\n\n    if( jsonData.preferences && jsonData.preferences.length > 0 ) {\n        prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );\n    }\n\n    var i18nPromise = null;\n\n    if( jsonData.i18n ) {\n        i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );\n    }\n\n    /**\n     * Wait for them all to complete\n    return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(\n        function( results ) {\n            resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,\n                results[ 1 ] );\n\n            resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );\n\n            declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );\n\n            return resDeclViewModel;\n        } );\n     */return resDeclViewModel;};/**\n * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the\n *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.\n *\n * @param {DeclViewModel} declViewModel -\n */export let setupLifeCycle=function(dataCtxNode,declViewModel){dataCtxNode.data=declViewModel;dataCtxNode.i18n=declViewModel.i18n;dataCtxNode.ctx=appCtxSvc.ctx;if(!dataCtxNode.conditions){dataCtxNode.conditions=declViewModel.getConditionStates();}debugService.debug('lifeCycles',declViewModel._internal.panelId,'mount');if(declViewModel._internal.ports){if(!syncViewModelCacheService.get('syncViewModelCache')){syncViewModelCacheService.set('syncViewModelCache',{});}const id=dataCtxNode.data._internal.modelId;const path='syncViewModelCache.'+dataCtxNode.data._internal.viewId;if(syncViewModelCacheService.get(path)===null||syncViewModelCacheService.get(path)===undefined){syncViewModelCacheService.set('syncViewModelCache',Object.assign(syncViewModelCacheService.get('syncViewModelCache'),{[dataCtxNode.data._internal.viewId]:{[id]:dataCtxNode}}));}else{syncViewModelCacheService.set(path,{...syncViewModelCacheService.get(path),[id]:dataCtxNode});}dataCtxNode.ports=declViewModel._internal.ports;}/**\n     * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)\n     * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be\n     * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the\n     * declViewModel.\n     * <P>\n     * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very\n     * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The\n     * process will use this reference to the 'original' to resolve the event processing.\n     * <P>\n     * This property is nulled out when this declViewModel is destroyed.\n     * <P>\n     * **** This property should not be used for any other purpose until we can determine it won't cause more memory\n     * issues. *****\n     */if(!dataCtxNode.data._internal.dataCtxNodeId){dataCtxNode.data._internal.dataCtxNodeId=dataCtxNode.$id;dataCtxNode.data._internal.origCtxNode=dataCtxNode;}/**\n     * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.\n     */var handleDestroyEvent=function(){var declViewModel2=dataCtxNode.data;var cleanupDataCtxNode=function(){// remove vm from the syncViewModelCacheService\nif(declViewModel2&&declViewModel2._internal&&declViewModel2._internal.ports){syncViewModelCacheService.set('syncViewModelCache.'+declViewModel2._internal.viewId,null);}/**\n             * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be\n             * destroyed.\n             */if(declViewModel2&&declViewModel2._internal.dataCtxNodeId!==dataCtxNode.$id){dataCtxNode.data=null;dataCtxNode.conditions=null;dataCtxNode.ctx=null;dataCtxNode.i18n=null;dataCtxNode.dataProvider=null;dataCtxNode.eventMap=null;dataCtxNode.eventData=null;dataCtxNode.subPanelContext=null;return;}if(declViewModel2){if(declViewModel2._internal.destroy){declViewModel2._internal.destroy(true);}else{logger.warn('Attempt to delete a \"dataCtxNode.data\" that did not have a destroy method: '+declViewModel2);}dataCtxNode.conditions=null;dataCtxNode.data=null;dataCtxNode.ctx=null;dataCtxNode.i18n=null;dataCtxNode.dataProvider=null;dataCtxNode.eventMap=null;dataCtxNode.eventData=null;dataCtxNode.subPanelContext=null;}};debugService.debug('lifeCycles',declViewModel._internal.panelId,'destroy');var onUnmountAction=_.get(declViewModel,'_internal.lifecycleHooks.onUnmount');if(onUnmountAction){declViewModel.isUnmounting=true;exports.executeCommand(declViewModel,onUnmountAction,dataCtxNode).then(function(){cleanupDataCtxNode();});}else{cleanupDataCtxNode();}};if(dataCtxNode.$$destroyed){trace('View model attached to destroyed scope',declViewModel,dataCtxNode);handleDestroyEvent();}else{/** revisitme Shaishav: What's the alternative for the whole if / else block?\n            dataCtxNode.$on( '$destroy', handleDestroyEvent );\n        */}var onInitAction=_.get(declViewModel,'_internal.lifecycleHooks.onInit');if(onInitAction){exports.executeCommand(declViewModel,onInitAction,dataCtxNode);}};/**\n * return true for actionType dataProvider otherwise false\n * @param {string} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */var _isDataProviderAction=function(actionOrProviderId,declViewModel){if(declViewModel._internal.actions){var action=declViewModel._internal.actions[actionOrProviderId];if(action&&action.actionType==='dataProvider'&&declViewModel.dataProviders){return true;}}return false;};/**\n * return true for actionType other than dataProvider\n * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */var _isAnAction=function(actionOrProviderId,declViewModel){return declViewModel._internal.actions&&declViewModel._internal.actions[actionOrProviderId];};/**\n *\n * return true for dataProvider and false for action\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */var _isDataProvider=function(actionOrProviderId,declViewModel){return declViewModel.dataProviders&&declViewModel.dataProviders[actionOrProviderId];};/**\n * Execute command\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {String} dataCtxNode - The AngularJS scope of this action command\n *\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n *\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @returns {null|Promise} ...\n */export let executeCommand=function(declViewModel,actionOrProviderId,dataCtxNode,prop,viewData){if(!declUtils.isValidModelAndDataCtxNode(declViewModel,dataCtxNode)){return AwPromiseService.instance.resolve();}var action=null;if(declViewModel._internal.actions){action=declViewModel._internal.actions[actionOrProviderId];}/**\n     * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>\n     * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.\n     */if(_isDataProviderAction(actionOrProviderId,declViewModel)&&action){/** action ID will be used for better logging */action.actionId=actionOrProviderId;return actionSvc.performDataProviderAction(declViewModel,action,dataCtxNode);}else if(_isAnAction(actionOrProviderId,declViewModel)){declViewModel.getToken().addAction(action);/** action ID will be used for better logging */action.actionId=actionOrProviderId;if(action.deps){var doAction=function(depModuleObj){/**\n                 * Check if the declViewModel got destroyed while we were waiting for the dependent module to be\n                 * loaded. This can happen, for example, when multiple subscribers are listening to a common\n                 * event like 'selection' and one of them (I'm look at you GWT) causes the panel the\n                 * declViewModel is associated with to close (thus destroying the $scope and the declViewModel\n                 * associated with it).\n                 * <P>\n                 * If so: There is nothing more that can be done with the declViewModel and we just want to log\n                 * a warning about the situation and move on.\n                 */if(declViewModel.isDestroyed()){declUtils.logLifeCycleIssue(declViewModel,action,'The command action was therefore not executed.','executeCommand');}else{/**\n                     * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n                     * event processing was started.\n                     */var localDataCtx=declUtils.resolveLocalDataCtx(declViewModel,dataCtxNode);// _deps will be undefined when try to load viewModelService inside itself\nvar _depModuleObj=depModuleObj;if(!depModuleObj&&action.deps==='js/viewModelService'){_depModuleObj=exports;}return actionSvc.executeAction(declViewModel,action,localDataCtx,_depModuleObj,null,prop,viewData).then(function(){declViewModel.getToken().removeAction(action);}).catch(function(x){declViewModel.getToken().removeAction(action);trace('exception',x);logger.error('exception',x);//return AwPromiseService.instance.reject( x );\n});}return undefined;};/**\n            * revisitme Jesse\n            * Hint: This needs to be uncommented once we have afxWeakImport supported\n            * Keeping comments till we support all the usecases in new declarative engine\n            var depModuleObj = moduleLoader.getDependentModule( action.deps );\n\n            if( depModuleObj ) {\n                return doAction( depModuleObj );\n            }\n\n            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {\n                return doAction( depModuleObject );\n            } );\n            */return loadDynModule(action.deps).then(function(depModuleObject){return doAction(depModuleObject);});}return actionSvc.executeAction(declViewModel,action,dataCtxNode,null,null,prop,viewData).then(function(){declViewModel.getToken().removeAction(action);}).catch(function(x){declViewModel.getToken().removeAction(action);trace('exception',x);logger.error('exception: '+x);//return AwPromiseService.instance.reject( x );\n});}else if(_isDataProvider(actionOrProviderId,declViewModel)){action={};action.actionType='dataProvider';action.method=actionOrProviderId;return actionSvc.performDataProviderAction(declViewModel,action,dataCtxNode);}return AwPromiseService.instance.resolve();};exports={populateViewModelPropertiesFromJson,setupLifeCycle,executeCommand};export default exports;","map":null,"metadata":{},"sourceType":"module"}