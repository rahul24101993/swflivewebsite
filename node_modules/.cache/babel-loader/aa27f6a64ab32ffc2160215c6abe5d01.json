{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This service is for exposing the native js data provider behavior. The module supports loading the module from GWT\n * and getting the native JS code invoked.\n *\n * @module js/splmTableInfiniteScrollService\n */import logger from'js/logger';import browserUtils from'js/browserUtils';import SPLMTableMomentumScrolling from'js/splmTableMomentumScrolling';import _ from'lodash';import Const from'js/splmTableConstants';/**\n * Native infinite scroll.\n *\n * @constructor\n * @param {Number} containerHeight the container height\n */let SPLMTableInfiniteScroll=function(containerHeight){let self=this;let settings={};let currentScrollTop=0;// Holds the last scroll position to detect scroll down or up\nlet previousScrollTop=0;let rowElements=[];// contains cache of rendered list\nlet rowHeightCache=[];let initialized=false;let containerHeightInitialized=false;let _containerHeight=containerHeight;let _visibleAreaHeight=_containerHeight-settings.headerHeight;let initialRowIndex=0;let extraVisibleRowCount=14;// keep it even for easier scrolling/calculations\nlet visibleRowsCount=0;let currentScrollLeft=0;let scrollToRowInProgress=false;let scrollToRowScrollTop=null;let maintainScrollPosition=false;let disablePinScrollEvent=false;let userPinScrollsDetected=0;let scrollContainerWidth=0;let verticalScrollDebounceTime=browserUtils.isIE||browserUtils.isFirefox?200:0;let horizontalScrollDebounceTime=browserUtils.isIE?500:0;let verticalScrollDebounceMaxWait=browserUtils.isIE||browserUtils.isFirefox?Infinity:0;let momentumScrolling=new SPLMTableMomentumScrolling();let lastScrollTimeStamp=new Date();let elapsedMSSinceLastScroll=0;// LCS-133249 Scrolling performance issue\n// Do scroll syncing at very beginning\nlet extraTop=0;let horizontalScrollDebounceEvent=_.debounce(function(){if(settings.scrollViewportElem&&settings.scrollViewportElem.offsetWidth){scrollContainerWidth=settings.scrollViewportElem.offsetWidth;}settings.updateScrollColumnsInView(currentScrollLeft,scrollContainerWidth);settings.updateVisibleCells(settings.scrollParentElem);},horizontalScrollDebounceTime);let verticalScrollDebounceEvent=_.debounce(function(){handleScrollEventInternal();},verticalScrollDebounceTime,{maxWait:verticalScrollDebounceMaxWait});self.initializeGrid=function(obj){settings=obj;settings.pinParentElem=settings.pinViewportElem.children[0];settings.scrollParentElem=settings.scrollViewportElem.children[0];settings.totalFound=settings.loadedVMObjects.length;settings.dynamicRowHeightStatus=settings.dynamicRowHeightStatus||false;initializeEvents();momentumScrolling.enable(settings.pinViewportElem,settings.scrollViewportElem);initialized=true;};/**\n     * Calculates the visible area of the table\n     * @returns {Number} the visible height\n     */let calculateVisibleAreaHeight=function(){return _containerHeight-settings.headerHeight;};self.checkForResize=_.debounce(async function(){elapsedMSSinceLastScroll=new Date()-lastScrollTimeStamp;if(elapsedMSSinceLastScroll<200){return;}let newClientWidth=settings.scrollViewportElem.offsetWidth;if(newClientWidth!==scrollContainerWidth){if(newClientWidth>scrollContainerWidth){scrollContainerWidth=newClientWidth;settings.updateScrollColumnsInView(currentScrollLeft);}else{scrollContainerWidth=newClientWidth;settings.updateScrollColumnsInView(currentScrollLeft,scrollContainerWidth);}settings.updateVisibleCells(settings.scrollParentElem);self.handlePinViewportScrollbarPadding();}if(settings.directiveElem.clientHeight!==_containerHeight){_containerHeight=settings.directiveElem.clientHeight;let rowContainerHeight=settings.scrollViewportElem.clientHeight||settings.pinViewportElem.clientHeight||_containerHeight;let rowCount=Math.floor(rowContainerHeight/settings.rowHeight);_visibleAreaHeight=calculateVisibleAreaHeight();setVisibleRowsCount(rowCount);await self.handleScroll();}},200);self.isInitialized=function(){return initialized;};/**\n     * Renders the initial rows on initialization once table div has been rendered so that\n     * the height can be computed properly\n     */self.renderInitialRows=function(){self.initializeProperties();settings.initialRowIndex=initialRowIndex;self.handleScroll();};self.getFirstRenderedItemIndex=function(){var firstRenderedItemIndex=0;var firstElem=rowElements[0];firstRenderedItemIndex=parseInt(firstElem.getAttribute('data-indexNumber'));return firstRenderedItemIndex;};self.getLastRenderedItemIndex=function(){var lastRenderedItemIndex=0;var lastElem=rowElements[rowElements.length-1];lastRenderedItemIndex=parseInt(lastElem.getAttribute('data-indexNumber'));return lastRenderedItemIndex;};/**\n     * set the object set height\n     * @param {Number} heightVal The container height\n     */self.setContainerHeight=function(heightVal){_containerHeight=heightVal;_visibleAreaHeight=calculateVisibleAreaHeight();// LCS-140092 - AW UxRefresh does not allow scrolling in Qt WebEngine Browser\n// 100% is not working in Qt WebEngine, use heightVal here\nsettings.scrollViewportElem.style.maxHeight=String(_visibleAreaHeight)+'px';settings.pinViewportElem.style.maxHeight=String(_visibleAreaHeight)+'px';};/**\n     * Set if dynamic row height is enabled or not\n     *\n     * @param {Boolean} isEnabled if DRH is enabled or not\n     */self.setDynamicRowHeight=function(isEnabled){settings.dynamicRowHeightStatus=isEnabled;if(settings.tableElem._tableInstance){settings.tableElem._tableInstance.dynamicRowHeightStatus=isEnabled;}};/**\n     * Sets the extra visible row count 10 < x < 30\n     *\n     * @param {Number} rowCount The number of rows to set\n     */function setExtraVisibleRowCount(rowCount){extraVisibleRowCount=Math.max(10,Math.min(30,rowCount));}/**\n     * Sets the visible row count\n     *\n     * @param {Number} rowCount the number of visible rows\n     */function setVisibleRowsCount(rowCount){visibleRowsCount=rowCount;setExtraVisibleRowCount(rowCount);}/**\n     * Convenience method to get certain row height from cache\n     *\n     * @param {Number} index The row's index\n     * @returns {Number} the row's height\n     */function getHeightFromCache(index){if(rowHeightCache[index]){if(index===rowHeightCache.length-1){return rowHeightCache[index];}return rowHeightCache[index]-1;// The -1 is because of the -1 margin added to the rows. May change in future\n}return settings.rowHeight;}/**\n     * Calculates the element's top position (scrollTop or just top)\n     * using the row height cache and its index\n     *\n     * @param {Number} elementIdx The element's index\n     * @returns {Number} the top position for the element\n     */function calculateElementTopPosition(elementIdx){let runningTop=0;for(let idx=0;idx<elementIdx;idx++){runningTop+=getHeightFromCache(idx);}return runningTop;}/**\n     * Calculates the row index based off of the scrollTop. Uses the row height cache\n     * and will return the index that the scrollTop reaches to.\n     *\n     * @param {Number} scrollTop The scroll top to calculate the element idx start from\n     * @returns {Number} the element's idx\n     */function calculateElementIndexFromScrollTop(scrollTop){let runningTotal=0;let index=0;while(runningTotal<scrollTop){runningTotal+=getHeightFromCache(index);index++;}return index;}/**\n     * Calculates the last visible row's index\n     *\n     * @returns {Number} the last visible row's index\n     */function calculateLastVisibleRowIndex(){return calculateElementIndexFromScrollTop(currentScrollTop+_visibleAreaHeight)-1;}/**\n     * Initialize scroll properties\n     */self.initializeProperties=function(){// Clear the row height cache\nrowHeightCache=[];// LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n// Use given clientHeight to save one computed CSS reading\nif(_containerHeight===undefined){_containerHeight=containerHeight>0?containerHeight:settings.directiveElem.clientHeight;_visibleAreaHeight=calculateVisibleAreaHeight();}else if(containerHeightInitialized===false){self.setContainerHeight(_containerHeight);}containerHeightInitialized=true;// Table should have height of at least one row.\nsettings.scrollViewportElem.style.minHeight=String(settings.rowHeight)+'px';settings.pinViewportElem.style.minHeight=String(settings.rowHeight)+'px';let scrollCanvasHeight=_visibleAreaHeight;if(scrollCanvasHeight<0){scrollCanvasHeight=0;}let rowCount=Math.floor(scrollCanvasHeight/settings.rowHeight);setVisibleRowsCount(rowCount);logger.trace('Table scroll service: Visible row count - '+visibleRowsCount);};/**\n     * Updates the container and top space heights so the rows are positioned correctly\n     */self.updateRowAlignment=function(){let topHeight=0;if(rowElements){let firstElement=rowElements[0];if(firstElement&&firstElement.getAttribute('data-indexNumber')){let firstElementIdx=parseInt(firstElement.getAttribute('data-indexNumber'));if(settings.treeTableEditSettings){topHeight=(firstElementIdx-settings.treeTableEditSettings.firstIndex)*settings.rowHeight;}else{topHeight=calculateElementTopPosition(firstElementIdx);}}}settings.pinParentElem.style.top=topHeight+'px';settings.scrollParentElem.style.top=topHeight+'px';let scrollContentHeight;// If tree table and editing, use treeEditSettings.lastIndex - the first index to get number of rows in total\nif(settings.treeTableEditSettings){scrollContentHeight=(settings.treeTableEditSettings.lastIndex-settings.treeTableEditSettings.firstIndex+1)*settings.rowHeight-topHeight;}else{scrollContentHeight=calculateElementTopPosition(settings.totalFound)-topHeight;}settings.pinParentElem.style.height=scrollContentHeight+'px';settings.scrollParentElem.style.height=scrollContentHeight+'px';};/**\n     * Returns the row height as an int\n     * @returns {Number} The row Height\n     */self.getRowHeight=function(){return settings.rowHeight;};/**\n     * Scrolls the table up/down one row.\n     *\n     * @param {Boolean} isScrollDown - scroll down indicator, false for scroll up\n     * @returns {Number} returns the new scrollTop of the scrollViewportElement\n     */self.manualScroll=function(isScrollDown){let scrollDistance=isScrollDown?self.getRowHeight():-self.getRowHeight();settings.scrollViewportElem.scrollTop+=scrollDistance;return settings.scrollViewportElem.scrollTop;};/**\n     * Get scrollTop of the scroll viewport.\n     *\n     * @returns {Number} returns the scrollTop of the scrollViewportElement\n     */self.getScrollTop=function(){return settings.scrollViewportElem.scrollTop;};/**\n     * Sets the row height\n     *\n     *  @param {int} rowHeight - the height of the row in pixels\n     */self.setRowHeight=function(rowHeight){settings.rowHeight=rowHeight;};/**\n     * Gets the total objects found\n     * @returns {Number} The total number of objects found\n     */self.getTotalFound=function(){return settings.totalFound;};/**\n     * Sets the loaded view model objects\n     *\n     *  @param {[ViewModelObject]} loadedViewModelObjects - the collection of view model objects\n     */self.setLoadedVMObjects=function(loadedViewModelObjects){// Maintain the scroll position\nif(maintainScrollPosition===true){// This will set the variables for maintaining scroll position.\n// The values are used when handleScroll is called again.\nsetValuesForMaintainingScroll(loadedViewModelObjects.length-settings.totalFound);}settings.loadedVMObjects=loadedViewModelObjects;settings.totalFound=loadedViewModelObjects.length;};self.setScrollPositionToBeMaintained=function(){maintainScrollPosition=true;};/**\n     * Sets the proper variables to maintain the scroll position\n     * @param {integer} rowDifferenceCount - the difference in rows used to calculate maintained scroll position\n     */function setValuesForMaintainingScroll(rowDifferenceCount){maintainScrollPosition=false;scrollToRowInProgress=true;let currentRow=calculateElementIndexFromScrollTop(settings.scrollViewportElem.scrollTop);let scrollToRow=currentRow+rowDifferenceCount;scrollToRowScrollTop=calculateElementTopPosition(scrollToRow);}self.isScrollToRowInProgress=function(){return scrollToRowInProgress;};let scrollEndTimer;/**\n     * Handles Scroll End logic\n     * Deletes excess rows when user has stopped scrolling for 500ms\n     * This prevents excessive deleting while trying to also create new rows and scroll table\n     */function handleScrollEndEvent(){if(scrollEndTimer){clearTimeout(scrollEndTimer);}scrollEndTimer=setTimeout(function(){removeExtraRows();},300);}/**\n     * Initialize Scroll Event to table\n     */function initializeEvents(){settings.scrollViewportElem.removeEventListener('scroll',handleScrollEvent);settings.scrollViewportElem.removeEventListener('scroll',handleScrollEndEvent);settings.pinViewportElem.removeEventListener('scroll',handlePinScrollEvent);settings.scrollViewportElem.addEventListener('scroll',handleScrollEvent);settings.scrollViewportElem.addEventListener('scroll',handleScrollEndEvent);settings.pinViewportElem.addEventListener('scroll',handlePinScrollEvent);}/**\n     * Add a padding to the pin viewport to align pin rows with content rows\n     * when scrolled to the bottom.\n     *\n     * @param {Number} tempExtraTop - amount of padding in pixels\n     */function addPinViewportScrollbarPadding(tempExtraTop){settings.pinViewportElem.style.top=String(tempExtraTop*-1)+'px';extraTop=tempExtraTop;}/**\n     * Remove the padding to the pin viewport used for row alignment.\n     */function removePinViewportScrollbarPadding(){settings.pinViewportElem.style.top='0px';extraTop=0;}/**\n     * Apply/remove extra top for pinViewport if the scrollViewport is now visible/invisible\n     */self.handlePinViewportScrollbarPadding=function(){const pinViewportElem=settings.pinViewportElem;const scrollViewportElem=settings.scrollViewportElem;if(currentScrollTop>=0){if(pinViewportElem.style.top==='0px'&&scrollViewportElem.clientWidth>0){let tempExtraTop=pinViewportElem.offsetHeight+currentScrollTop-pinViewportElem.scrollHeight;if(tempExtraTop>0){addPinViewportScrollbarPadding(tempExtraTop);}}else if(pinViewportElem.style.top!=='0px'&&scrollViewportElem.clientWidth<=0){removePinViewportScrollbarPadding();}}};/**\n     * Scroll Event Handler\n     */function handleScrollEvent(e){lastScrollTimeStamp=new Date();let oldScrollTop=currentScrollTop;currentScrollTop=settings.scrollViewportElem.scrollTop;let oldScrollLeft=currentScrollLeft;currentScrollLeft=settings.scrollViewportElem.scrollLeft;if(oldScrollTop===currentScrollTop&&currentScrollTop<0&&oldScrollLeft===currentScrollLeft&&currentScrollLeft<0){e.preventDefault();e.stopPropagation();}// LCS-133249 Scrolling performance issue\n// Do scroll syncing at very beginning\nlet pinViewportElem=settings.pinViewportElem;if(userPinScrollsDetected===0&&(oldScrollTop!==currentScrollTop||currentScrollTop===0)){disablePinScrollEvent=true;pinViewportElem.scrollTop=currentScrollTop;}settings.onStartScroll();if(oldScrollLeft!==currentScrollLeft&&currentScrollLeft>=0){settings.syncHeader(false,currentScrollLeft);horizontalScrollDebounceEvent();}if(oldScrollTop!==currentScrollTop&&currentScrollTop>=0){let tempExtraTop=pinViewportElem.offsetHeight+currentScrollTop-pinViewportElem.scrollHeight;if(tempExtraTop>0){if(settings.scrollViewportElem.clientWidth>0){addPinViewportScrollbarPadding(tempExtraTop);}}else if(extraTop>0){// For non IE/Edge, need to set top back when scroll up\nremovePinViewportScrollbarPadding();}verticalScrollDebounceEvent();}userPinScrollsDetected-=1;if(userPinScrollsDetected<0){userPinScrollsDetected=0;}}/**\n     * Real processing method for scroll event after debounce/requestAnimationFrame\n     */function handleScrollEventInternal(){let func;let isScrollDown=currentScrollTop>previousScrollTop;if(isScrollDown){func=self.handleScrollDown;}else{func=handleScrollUp;}previousScrollTop=currentScrollTop;// Do scroll shadow\nif(currentScrollTop>0){if(!settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)){settings.tableElem.classList.add(Const.CLASS_TABLE_SCROLLED);}}else{if(settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)){settings.tableElem.classList.remove(Const.CLASS_TABLE_SCROLLED);}}func.call();}/**\n     * Method to handle scroll down\n     */self.handleScrollDown=function(){if(rowElements&&rowElements.length){let lastChildElem=rowElements[rowElements.length-1];let lastIndexNumber=parseInt(lastChildElem.getAttribute('data-indexNumber'));let lastItemBottomPosition;if(settings.treeTableEditSettings){lastItemBottomPosition=(lastIndexNumber-settings.treeTableEditSettings.firstIndex)*settings.rowHeight+settings.rowHeight;}else{lastItemBottomPosition=calculateElementTopPosition(lastIndexNumber+1);}let lastVisibleRowIndex=calculateLastVisibleRowIndex();let lastItemAboveTop=lastItemBottomPosition<currentScrollTop;if(lastItemAboveTop===true){// Check if all the elements are rendered.\nif(lastIndexNumber+1<settings.totalFound){// Last element went up and page is empty. Need to calculate the page number now\nself.handleScroll();}}else if(lastItemBottomPosition<calculateElementTopPosition(lastVisibleRowIndex+extraVisibleRowCount)){let extraBlankRowsInView=lastVisibleRowIndex-lastIndexNumber;extraBlankRowsInView=extraBlankRowsInView<0?0:extraBlankRowsInView;// Last element went up and element is still in the page. Can do continuous rendering\nlet startCount=lastIndexNumber+1;let endCount=startCount+extraVisibleRowCount+extraBlankRowsInView;renderPageData(startCount,endCount);}}else{self.handleScroll();}};/**\n     * Method to handle wheel scroll event\n     *\n     * @param {Object} e - the event\n     */function handlePinScrollEvent(e){if(disablePinScrollEvent===true){disablePinScrollEvent=false;return;}var currentPinScrollLeft=settings.pinViewportElem.scrollLeft;settings.syncHeader(true,currentPinScrollLeft);// If scrollTop is same as currentScrollTop then nothing else needs to be done.\nif(settings.pinViewportElem.scrollTop===currentScrollTop){return;}userPinScrollsDetected+=1;if(settings.pinViewportElem.scrollTop!==settings.pinViewportElem.scrollHeight-settings.pinViewportElem.offsetHeight){settings.scrollViewportElem.scrollTop=settings.pinViewportElem.scrollTop;}else{settings.scrollViewportElem.scrollTop=settings.pinViewportElem.scrollTop+40;}// Prevent scrolling the parent div\ne.preventDefault();}/**\n     * Method call by handleScrollUp and handleScrollDown which processing page rendering\n     *\n     */self.handleScroll=function(){var currentStartIndex;if(settings.initialRowIndex){self.updateRowAlignment();var newScrollIdx=calculateElementIndexFromScrollTop(calculateElementTopPosition(settings.initialRowIndex)-_visibleAreaHeight*0.75);var newScrollTop=calculateElementTopPosition(newScrollIdx);delete settings.initialRowIndex;currentScrollTop=newScrollTop<0?0:newScrollTop;currentStartIndex=newScrollIdx;settings.scrollViewportElem.scrollTop=currentScrollTop;}if(scrollToRowInProgress===true){self.updateRowAlignment();settings.scrollViewportElem.scrollTop=scrollToRowScrollTop;scrollToRowInProgress=false;scrollToRowScrollTop=null;}if(!currentStartIndex){currentStartIndex=calculateElementIndexFromScrollTop(currentScrollTop);}var start=currentStartIndex-extraVisibleRowCount;var end=currentStartIndex+visibleRowsCount+extraVisibleRowCount;if(end>settings.totalFound-1){var offset=end-settings.totalFound-1;end-=offset;start-=offset;}renderPageData(start,end,true);previousScrollTop=currentScrollTop;};/**\n     * Method to handle scroll up\n     */function handleScrollUp(){if(rowElements&&rowElements.length){var firstChildElem=rowElements[0];var firstItemIndex=parseInt(firstChildElem.getAttribute('data-indexNumber'));var firstItemTopPosition;if(settings.treeTableEditSettings){firstItemTopPosition=(firstItemIndex-settings.treeTableEditSettings.firstIndex)*settings.rowHeight;}else{firstItemTopPosition=calculateElementTopPosition(firstItemIndex);}var firstVisibleElem=calculateElementIndexFromScrollTop(currentScrollTop);var firstItemBelowBottom=firstItemTopPosition>currentScrollTop+_visibleAreaHeight;if(firstItemBelowBottom===true){self.handleScroll();}else if(firstItemTopPosition>calculateElementTopPosition(firstVisibleElem-extraVisibleRowCount)){var extraBlankRowsInView=firstItemIndex-firstVisibleElem;extraBlankRowsInView=extraBlankRowsInView<0?0:extraBlankRowsInView;var endCount=firstItemIndex-1;var startCount=endCount-extraVisibleRowCount-extraBlankRowsInView;renderPageData(startCount,endCount);}}else{self.handleScroll();}}/**\n     * Sets up scrolling for trees while in edit mode\n     * @param {Boolean} isEditing if the table is in edit mode or not\n     */self.setupTreeEditScroll=function(isEditing){if(!isEditing){if(settings.treeTableEditSettings){// Find our current scroll position\nvar relativeIdx=settings.scrollViewportElem.scrollTop/self.getRowHeight();var scrollTop=(relativeIdx+settings.treeTableEditSettings.firstIndex-1)*self.getRowHeight();// Remove tree Edit settings\ndelete settings.treeTableEditSettings;// Reset alignment/rows\nself.updateRowAlignment();self.handleScroll();// Reset our scroll position to what we were at\nsettings.pinViewportElem.scrollTop=scrollTop;settings.scrollViewportElem.scrollTop=scrollTop;}return;}// If no element in table, return\nif(!rowElements||!rowElements[0]){return;}// Find first row that contains data\nvar firstChildElem=rowElements[0];var firstIndex=parseInt(firstChildElem.getAttribute('data-indexNumber'));var hasProps=settings.loadedVMObjects[firstIndex].props;while(hasProps&&firstIndex>0){hasProps=settings.loadedVMObjects[firstIndex-1].props;if(hasProps){firstIndex--;}}// Find last row that contains data\nvar lastChildElem=rowElements[rowElements.length-1];var lastIndex=parseInt(lastChildElem.getAttribute('data-indexNumber'));hasProps=settings.loadedVMObjects[lastIndex].props;while(hasProps&&lastIndex<settings.totalFound-1){hasProps=settings.loadedVMObjects[lastIndex+1].props;if(hasProps){lastIndex++;}}settings.treeTableEditSettings={firstIndex:firstIndex,lastIndex:lastIndex,totalDataLength:lastIndex+1};// update the container height\nself.updateRowAlignment();};/**\n     *  Remove rows from lower-bound to upper-bound\n     *\n     * @param {Object} upperCountIdx - event\n     * @param {Object} lowerCounterIdx - event\n     */function removeRows(upperCountIdx,lowerCounterIdx){settings.removeRows(upperCountIdx,lowerCounterIdx);rowElements=settings.scrollParentElem.querySelectorAll(settings.rowSelector);}/**\n     *  Resets infinite scroll back to a starting state\n     */self.resetInfiniteScroll=function(){self.setLoadedVMObjects([]);self.resetInitialRowIndex();rowHeightCache=[];settings.scrollViewportElem.scrollTop=0;settings.pinViewportElem.style.top='0px';settings.scrollViewportElem.style.top='0px';currentScrollTop=0;self.handleScroll();};/**\n     * Resets the row height cache\n     */self.resetRowHeightCache=function(){rowHeightCache=[];};/**\n     * Method to render rows\n     *\n     * @param {Number} startIndex Start render index\n     * @param {Number} endIndex End render Index\n     */function renderRows(startIndex,endIndex){settings.renderRows(startIndex,endIndex);rowElements=settings.scrollParentElem.querySelectorAll(settings.rowSelector);if(settings.dynamicRowHeightStatus){// check if last value of rowHeightCache is in new set of rendered data, otherwise can cause off by 1.\nlet lastCacheIdx=rowHeightCache.length-1;let firstElemIdx=rowElements[0].getAttribute('data-indexnumber');let lastElemIdx=rowElements[rowElements.length-1].getAttribute('data-indexnumber');if(lastCacheIdx<firstElemIdx||lastCacheIdx>lastElemIdx){// Delete last cache value to prevent off by 1 caused by margin\nrowHeightCache[rowHeightCache.length-1]=null;}// Loop through rowElements to update row cache\nfor(let rowElement of rowElements){let index=parseInt(rowElement.getAttribute('data-indexnumber'));rowHeightCache[index]=rowElement.offsetHeight;}}}/**\n     * Method to render rows\n     *\n     * @param {int} startCount - event\n     * @param {int} endCount - event\n     * @param {int} removeAllChild - event\n     */function renderPageData(startCount,endCount,removeAllChild){var totalDataLength;// Check if table is tree table and is editing\nif(settings.treeTableEditSettings){if(startCount<settings.treeTableEditSettings.firstIndex){startCount=settings.treeTableEditSettings.firstIndex;}if(endCount>settings.treeTableEditSettings.lastIndex){endCount=settings.treeTableEditSettings.lastIndex;}totalDataLength=settings.treeTableEditSettings.totalDataLength;}else{// Check to avoid negative indexing\nif(startCount<0){startCount=0;}totalDataLength=settings.totalFound;}if(startCount>=totalDataLength){if(totalDataLength===0){// if collection becomes empty, then remove all the existing list rows\nremoveRows(rowElements.length-1,0);self.updateRowAlignment();}else{settings.updateScrollColumnsInView(currentScrollLeft,scrollContainerWidth);renderRows(startCount,endCount);}if(startCount===totalDataLength){logger.trace('Table scroll service: Rendering of page data complete. No more data to render.');return;}}// check to avoid wrong indexing for startCount\nif(startCount>totalDataLength){endCount-=startCount;startCount=0;}// check to avoid wrong indexing for endCount\nif(endCount>=totalDataLength){endCount=totalDataLength-1;}if(removeAllChild){// remove the elements from the dom tree.\nremoveRows(rowElements.length-1,0);}renderRows(startCount,endCount);self.updateRowAlignment();afterGridRender();}/**\n     * Remove extra rows\n     */function removeExtraRows(){const rowParentElem=settings.scrollParentElem;rowElements=rowParentElem.querySelectorAll(settings.rowSelector);if(rowElements.length===0){logger.error('Rendering error');}else{let extraChildCount;let invisibleRowsCount;let invisibleRowsHeight;const firstElem=rowElements[0];const firstRenderedItemIndex=parseInt(firstElem.getAttribute('data-indexNumber'));if(settings.treeTableEditSettings){invisibleRowsHeight=(firstRenderedItemIndex-settings.treeTableEditSettings.firstIndex)*settings.rowHeight-currentScrollTop;}else{// Simply checking if there are invisible rows, actual height doesn't matter as is not used\ninvisibleRowsHeight=calculateElementTopPosition(firstRenderedItemIndex)-currentScrollTop;}if(invisibleRowsHeight<0){invisibleRowsCount=Math.abs(calculateElementIndexFromScrollTop(currentScrollTop)-firstRenderedItemIndex);extraChildCount=invisibleRowsCount-extraVisibleRowCount;if(extraChildCount>0){// remove the elements from the dom tree.\nremoveRows(extraChildCount,0);}}const lastElem=rowElements[rowElements.length-1];const lastRenderedItemIndex=parseInt(lastElem.getAttribute('data-indexNumber'));const visRowsHeight=visibleRowsCount*settings.rowHeight+currentScrollTop;const lastVisibleRowIndex=calculateLastVisibleRowIndex();if(settings.treeTableEditSettings){invisibleRowsHeight=(lastRenderedItemIndex-settings.treeTableEditSettings.firstIndex)*settings.rowHeight+settings.rowHeight-visRowsHeight;}else{// Simply checking if there are invisible rows, so actual height doesn't matter here as it will not be used.\ninvisibleRowsHeight=lastRenderedItemIndex-lastVisibleRowIndex;}if(invisibleRowsHeight>0){invisibleRowsCount=lastRenderedItemIndex-lastVisibleRowIndex;extraChildCount=invisibleRowsCount-extraVisibleRowCount;if(extraChildCount>0){removeRows(rowElements.length-1,rowElements.length-extraChildCount-1);}}}self.updateRowAlignment();}/**\n     * After grid rendered\n     */function afterGridRender(){var firstRenderedItemIndex=0;var lastRenderedItemIndex=0;var firstElem=rowElements[0];firstRenderedItemIndex=parseInt(firstElem.getAttribute('data-indexNumber'));var lastElem=rowElements[rowElements.length-1];lastRenderedItemIndex=parseInt(lastElem.getAttribute('data-indexNumber'));var firstRenderedItem={index:firstRenderedItemIndex,uid:firstElem.vmo.uid,levelNdx:firstElem.vmo.levelNdx};var lastRenderedItem={index:lastRenderedItemIndex,uid:lastElem.vmo.uid,levelNdx:lastElem.vmo.levelNdx};settings.afterGridRenderCallback(firstRenderedItem,lastRenderedItem);}self.destroyGrid=function(){settings.scrollViewportElem&&settings.scrollViewportElem.removeEventListener('scroll',handleScrollEvent);settings.scrollViewportElem&&settings.scrollViewportElem.removeEventListener('scroll',handleScrollEndEvent);settings.pinViewportElem&&settings.pinViewportElem.removeEventListener('scroll',handlePinScrollEvent);momentumScrolling.disable();self.checkForResize.cancel();horizontalScrollDebounceEvent.cancel();verticalScrollDebounceEvent.cancel();};/**\n     * Scrolls to the given row\n     *\n     * @param {integer[]} rowIndexes Index to scroll to\n     * @returns {boolean} returns false if a row is in view\n     */self.scrollToRowIndex=function(rowIndexes){// Only scroll to row if it is out of view\nif(self.isInitialized()===true){var scrollToRowElementPosition=null;var firstRowElementIndex=0;var lastIndexNumber=0;if(rowElements.length>0){firstRowElementIndex=Number(rowElements[0].getAttribute('data-indexnumber'));lastIndexNumber=Number(rowElements[rowElements.length-1].getAttribute('data-indexnumber'));}var scrollCanvasRect=settings.scrollViewportElem.getBoundingClientRect();for(var i=0;i<rowIndexes.length;i++){var rowIndex=rowIndexes[i];if(rowElements.length>0){if(rowIndex>lastIndexNumber||rowIndex<firstRowElementIndex){initialRowIndex=rowIndex;continue;}scrollToRowElementPosition=rowElements[rowIndex-firstRowElementIndex].getBoundingClientRect();if(scrollToRowElementPosition.top<scrollCanvasRect.top||scrollToRowElementPosition.bottom>scrollCanvasRect.bottom){initialRowIndex=rowIndex;continue;}initialRowIndex=rowIndex;}return false;}// Check if attempting to scroll past maximum scrollTop, if so set flag\nvar maxScrollTop=settings.scrollViewportElem.scrollHeight-settings.scrollViewportElem.clientHeight;var newScrollTop=Math.floor(calculateElementTopPosition(initialRowIndex)-_visibleAreaHeight*0.75);var initialRowIndexOnDom=initialRowIndex-firstRowElementIndex;if(rowElements[initialRowIndexOnDom]){scrollToRowElementPosition=rowElements[initialRowIndexOnDom].getBoundingClientRect();if(scrollToRowElementPosition.top<scrollCanvasRect.top&&scrollToRowElementPosition.bottom>scrollCanvasRect.top){newScrollTop=calculateElementTopPosition(initialRowIndex);}else if(scrollToRowElementPosition.top<scrollCanvasRect.bottom&&scrollToRowElementPosition.bottom>scrollCanvasRect.bottom){newScrollTop=settings.scrollViewportElem.scrollTop+(scrollToRowElementPosition.bottom-scrollCanvasRect.bottom);}}if(newScrollTop>maxScrollTop){scrollToRowInProgress=true;scrollToRowScrollTop=newScrollTop;}settings.scrollViewportElem.scrollTop=newScrollTop;}else{initialRowIndex=rowIndexes[0];}return true;};/**\n     * Scrolls to scroll container column\n     * @param {Object} column - The column to scroll to\n     */self.scrollToColumn=function(column){if(column.startPosition<=currentScrollLeft||column.startPosition>currentScrollLeft+scrollContainerWidth){settings.scrollViewportElem.scrollLeft=column.startPosition-10;}};self.isInitialRowIndexInView=function(){let firstRowElementIndex=Number(rowElements[0].getAttribute('data-indexnumber'));let initialRowElement=rowElements[initialRowIndex-firstRowElementIndex];if(initialRowElement===undefined){return false;}let initialRowElementIndex=initialRowElement.getAttribute('data-indexnumber');let firstVisibleIndex=calculateElementIndexFromScrollTop(currentScrollTop);let lastVisibleIndex=calculateLastVisibleRowIndex();if(initialRowElementIndex<firstVisibleIndex||initialRowIndex>lastVisibleIndex){return false;}return true;};/**\n     * Resets the initial row index to 0 so that infinite scroll service will\n     * start the rendering of rows at the top.\n     */self.resetInitialRowIndex=function(){initialRowIndex=0;};};export default SPLMTableInfiniteScroll;","map":null,"metadata":{},"sourceType":"module"}