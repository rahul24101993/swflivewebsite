{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editHandlerFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport appCtxSvc from 'js/appCtxService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport dms from 'soa/dataManagementService';\nimport editEventsService from 'js/editEventsService';\nimport eventBus from 'js/eventBus';\nimport leavePlaceService from 'js/leavePlace.service';\nimport localeSvc from 'js/localeService';\nimport logger from 'js/logger';\nimport messagingSvc from 'js/messagingService';\nimport notySvc from 'js/NotyModule';\nimport parsingUtils from 'js/parsingUtils';\nimport policySvc from 'soa/kernel/propertyPolicyService';\nimport saveHandlerService from 'js/saveHandlerService';\nimport soaSvc from 'soa/kernel/soaService';\nimport uwPropertyService from 'js/uwPropertyService';\nimport vmsvc from 'js/viewModelObjectService'; // Various services\n\nvar exports = {};\nlet preSaveActionsCounter = 0; //  Registration counter for preSave Actions.\n\nlet preSaveActions = {};\n/**\n * Create edit handler\n *\n * @param {Object} dataSource - the dataSource we're associating the edit handler with\n * @param {Array} editSupportParamKeys - the url parameters which are allowed to change during edit mode\n *\n * @return {Object} edit handler object\n */\n\nexport let createEditHandler = function (dataSourceArg, editSupportParamKeys) {\n  var editHandler = {\n    // Mark this handler as native - checked from GWT jsni code\n    isNative: true,\n    _editing: false,\n    canEdit: false\n  };\n  var dataSource = dataSourceArg;\n  var _singleLeaveConfirmation = null;\n  var _multiLeaveConfirmation = null;\n  var _saveTxt = null;\n  var _discardTxt = null;\n  var _validationError = null;\n  var _xrtViewModelSvc = null;\n  let _isDestroyed = false;\n  let _leaveHandler = null;\n\n  if (localeSvc) {\n    localeSvc.getLocalizedTextFromKey('XRTMessages.navigationConfirmationSingle').then(result => _singleLeaveConfirmation = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.navigationConfirmationMultiple').then(result => _multiLeaveConfirmation = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.save').then(result => _saveTxt = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.discard').then(result => _discardTxt = result);\n    localeSvc.getLocalizedTextFromKey('editHandlerMessages.validationError').then(result => _validationError = result);\n  }\n\n  let saveEditsListener = null;\n\n  const removeSaveListener = function () {\n    document.removeEventListener('keydown', saveEditsListener);\n  };\n\n  const addSaveListener = function (editOptions) {\n    removeSaveListener();\n\n    if (editOptions && editOptions.autoSave) {\n      saveEditsListener = editEventsService.saveEditsListener(editHandler, removeSaveListener);\n    } else {\n      saveEditsListener = editEventsService.saveEditsListener(null, removeSaveListener);\n    }\n\n    document.addEventListener('keydown', saveEditsListener);\n  };\n  /**\n   * Notify the save state changes\n   *\n   * @param {String} stateName - edit state name ('starting', 'saved', 'cancelling')\n   * @param {Boolean} fireEvents - fire modelObjectsUpdated events\n   * @param {Array} failureUids - the object uids that failed to save\n   * @param {Object} modifiedPropsMap - modified properties map\n   */\n\n\n  function _notifySaveStateChanged(stateName, fireEvents, failureUids, modifiedPropsMap) {\n    switch (stateName) {\n      case 'starting':\n        dataSource.checkEditableOnProperties();\n        addSaveListener();\n        break;\n\n      case 'saved':\n        dataSource.saveEditiableStates();\n        removeSaveListener();\n        break;\n\n      case 'canceling':\n        dataSource.resetEditiableStates();\n        removeSaveListener();\n        break;\n\n      case 'partialSave':\n        dataSource.updatePartialEditState(failureUids, modifiedPropsMap);\n        break;\n\n      default:\n        logger.error('Unexpected stateName value: ' + stateName);\n    }\n\n    if (fireEvents) {\n      var dataProvider = dataSource.getDataProvider();\n\n      if (dataProvider && dataProvider.viewModelCollection) {\n        eventBus.publish(dataProvider.name + '.modelObjectsUpdated', {\n          viewModelObjects: dataProvider.viewModelCollection.getLoadedViewModelObjects(),\n          totalObjectsFound: dataProvider.viewModelCollection.getTotalObjectsLoaded()\n        });\n      }\n    }\n\n    editHandler._editing = stateName === 'starting' || stateName === 'partialSave';\n\n    if (editHandler.editStateChangeDispatcher) {\n      editHandler.editStateChangeDispatcher({\n        type: 'SET_EDIT_STATE_CHANGED',\n        value: editHandler._editing\n      });\n    } // Add to the appCtx about the editing state\n\n\n    appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n    var context = {\n      state: stateName\n    };\n    context.dataSource = dataSource.getSourceObject();\n    context.failureUids = failureUids;\n    eventBus.publish('editHandlerStateChange', context);\n  }\n\n  const onlyEditSupportParamsChanging = function (newLocation, oldLocation, editSupportParamKeys) {\n    const newParams = newLocation.params;\n    const oldParams = oldLocation.params; // Return false if state name is changing\n\n    if (newLocation.state.name !== oldLocation.state.name) {\n      return false;\n    }\n\n    let selectionParamsSame = true;\n\n    for (let i = 0; i < editSupportParamKeys.length; i++) {\n      let param = editSupportParamKeys[i];\n\n      if (newParams[param] !== oldParams[param]) {\n        selectionParamsSame = false;\n      }\n    }\n\n    if (selectionParamsSame) {\n      return false;\n    } // Return false if the keys are not equal ( excluding the editSupportParamKeys )\n\n\n    let newParamsClone = JSON.parse(JSON.stringify(newParams));\n    let oldParamsClone = JSON.parse(JSON.stringify(oldParams));\n\n    for (let i = 0; i < editSupportParamKeys.length; i++) {\n      let param = editSupportParamKeys[i];\n      delete newParamsClone[param];\n      delete oldParamsClone[param];\n    }\n\n    if (!_.isEqual(Object.keys(newParamsClone), Object.keys(oldParamsClone))) {\n      return false;\n    } // Return false if one of the param values has changed ( excluding the v )\n\n\n    for (let key in newParamsClone) {\n      if (newParamsClone[key] !== oldParamsClone[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Reregisters the existing leaveHandler with the leavePlaceService\n   */\n\n\n  editHandler.reregisterLeaveHandler = function () {\n    leavePlaceService.registerLeaveHandler(_leaveHandler);\n  };\n  /**\n   * Start editing\n   *\n   * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n   * @return {Promise} response\n   */\n\n\n  editHandler.startEdit = function (editOptions) {\n    // Register with leave place service\n    _leaveHandler = {\n      okToLeave: function (targetNavDetails, newLocation, oldLocation) {\n        // Skip leaveConfirmation if editSupportParamKeys are the only part of the url that is changing.\n        if (editSupportParamKeys && newLocation && oldLocation && onlyEditSupportParamsChanging(newLocation, oldLocation, editSupportParamKeys)) {\n          return Promise.resolve({\n            clearLeaveHandler: false\n          });\n        }\n\n        return editHandler.leaveConfirmation();\n      }\n    };\n    leavePlaceService.registerLeaveHandler(_leaveHandler);\n    const isPropEditing = Boolean(editOptions);\n\n    if (!editOptions) {\n      editHandler._editing = true;\n    }\n\n    var viewModelObjectList = dataSource.getLoadedViewModelObjects(); // Get list of UIDs\n\n    var uidToVMMap = {};\n\n    if (isPropEditing) {\n      _.forEach(editOptions.vmos, function (viewModelObject) {\n        if (!uidToVMMap[viewModelObject.uid]) {\n          uidToVMMap[viewModelObject.uid] = [viewModelObject];\n        }\n      });\n    } else if (viewModelObjectList !== null) {\n      _.forEach(viewModelObjectList, function (viewModelObject) {\n        if (uidToVMMap[viewModelObject.uid]) {\n          var existingVMOs = uidToVMMap[viewModelObject.uid];\n          existingVMOs.push(viewModelObject);\n        } else {\n          uidToVMMap[viewModelObject.uid] = [viewModelObject];\n        }\n      });\n    }\n\n    let propMap = {};\n\n    if (isPropEditing) {\n      _.forEach(editOptions.vmos, function (vmo) {\n        propMap[vmo.uid] = editOptions.propertyNames;\n      });\n    } else {\n      propMap = dataSource.getPropertyMap();\n    }\n\n    var propPolicy = {\n      types: [{\n        name: 'BusinessObject',\n        properties: [{\n          name: 'is_modifiable'\n        }]\n      }]\n    };\n    var policyId = policySvc.register(propPolicy, 'startEditHandler_Policy', 'selected');\n    var input = {\n      inputs: []\n    };\n\n    if (propMap) {\n      _.forEach(propMap, function (value, key) {\n        dms.getLoadViewModelForEditingInput(input, key, value);\n      });\n    }\n\n    return dms.loadViewModelForEditing2(input.inputs).then(function (response) {\n      if (_isDestroyed) {\n        return;\n      }\n\n      let propNamesToUpdate = editOptions ? editOptions.propertyNames : [];\n      processJsonStringResponse(response.viewModelObjectsJsonStrings, uidToVMMap, propNamesToUpdate);\n\n      if (isPropEditing) {\n        for (let j = 0; j < editOptions.vmos.length; j++) {\n          for (let i = 0; i < editOptions.propertyNames.length; i++) {\n            const prop = editOptions.vmos[j].props[editOptions.propertyNames[i]];\n            uwPropertyService.setEditable(prop, true);\n            uwPropertyService.setEditState(prop, true, true, true);\n          }\n        }\n\n        addSaveListener(editOptions);\n      } else {\n        _notifySaveStateChanged('starting', true);\n      }\n\n      policySvc.unregister(policyId);\n      return response;\n    }, function (error) {\n      editHandler._editing = false;\n      policySvc.unregister(policyId);\n    });\n  };\n  /**\n   * This function processes the response and replace the existing viewModelObject with the newly created VMO\n   * @param {String[]} viewModelObjectsInJsonString - The viewModel objects json strings array\n   * @param {Object[]} uidToVMMap - the Ui to VM object map\n   * @param {String[]} [propsToUpdate] - (Optional) If provided, only these properties on the vmos with be updated\n   */\n\n\n  function processJsonStringResponse(viewModelObjectsInJsonString, uidToVMMap, propsToUpdate) {\n    var loadedObjects = dataSource.getLoadedViewModelObjects();\n\n    _.forEach(viewModelObjectsInJsonString, function (viewModelObjectJsonString) {\n      var responseObject = parsingUtils.parseJsonString(viewModelObjectJsonString);\n\n      if (responseObject && responseObject.objects && responseObject.objects.length > 0) {\n        _.forEach(responseObject.objects, function (serverVMO) {\n          var uid = serverVMO.uid;\n          var exisitingVMOs = uidToVMMap[uid] ? uidToVMMap[uid] : loadedObjects;\n          var updatedVMO = vmsvc.createViewModelObject(uid, 'EDIT', null, serverVMO);\n          vmsvc.updateSourceObjectPropertiesByViewModelObject(updatedVMO, exisitingVMOs, propsToUpdate);\n        });\n      }\n    });\n  }\n  /**\n   * Can we start editing?\n   *\n   * @return {Boolean} true if we can start editing\n   */\n\n\n  editHandler.canStartEdit = function () {\n    return dataSource.canStartEdit();\n  };\n  /**\n   * Is an edit in progress?\n   *\n   * @return {Boolean} true if we're editing\n   */\n\n\n  editHandler.editInProgress = function () {\n    return this._editing;\n  };\n  /**\n   * Cancel the current edit\n   *\n   * @param {Boolean} noPendingModifications - are there pending modifications? (optional)\n   * @param {Boolean} ignoreLeaveHandler - don't remove leave handler\n   */\n\n\n  editHandler.cancelEdits = function (noPendingModifications, ignoreLeaveHandler) {\n    if (!ignoreLeaveHandler) {\n      leavePlaceService.registerLeaveHandler(null);\n    }\n\n    _notifySaveStateChanged('canceling', !noPendingModifications);\n  };\n  /**\n   * Perform the actions post Save Edit\n   *\n   * @param {Boolean} saveSuccess Whether the save edit was successful\n   */\n\n\n  editHandler.saveEditsPostActions = function (saveSuccess) {\n    if (saveSuccess) {\n      leavePlaceService.registerLeaveHandler(null);\n    }\n\n    _notifySaveStateChanged('saved', saveSuccess);\n  };\n  /**\n   * Register preSaveAction.\n   * @param {String} preSaveActionName - The preSave function to be executed.\n   * @return {String} preSaveAction ID\n   */\n\n\n  editHandler.registerPreSaveAction = function (preSaveActionName) {\n    var nextId = ++preSaveActionsCounter;\n    var preSaveActionID = 'preSaveAction_' + nextId;\n    preSaveActions[preSaveActionID] = preSaveActionName;\n    return preSaveActionID;\n  };\n  /**\n   * unregister preSaveAction.\n   * @param {String} preSaveActionID - preSaveActionID\n   */\n\n\n  editHandler.unregisterPreSaveAction = function (preSaveActionID) {\n    if (preSaveActions && preSaveActions[preSaveActionID]) {\n      delete preSaveActions[preSaveActionID];\n    }\n  };\n\n  editHandler.setDataUpdater = editStateChangeDispatcher => {\n    editHandler.editStateChangeDispatcher = editStateChangeDispatcher;\n  };\n  /**\n   * Save the current edits\n   * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n   * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n   * @return {Promise} Promise that is resolved when save edit is complete\n   */\n\n\n  editHandler.saveEdits = function (isPartialSaveDisabled, isAutoSave) {\n    // Do not save edit if there are validation errors\n    // Execute preSaveActions if there are any.\n    _.forEach(preSaveActions, function (value) {\n      value();\n    });\n\n    let hasValidationErrors = false;\n    let editableViewModelProperties = dataSource.getAllEditableProperties();\n\n    for (let prop of editableViewModelProperties) {\n      if (prop.error && prop.error.length > 0) {\n        hasValidationErrors = true;\n        break;\n      }\n    }\n\n    if (hasValidationErrors) {\n      messagingSvc.showError(_validationError);\n\n      if (isPartialSaveDisabled) {\n        _notifySaveStateChanged('canceling', false);\n      }\n\n      return AwPromiseService.instance.reject(_validationError);\n    } // Get all properties that are modified\n\n\n    let modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n    let modifiedPropsMap = dataSource.getModifiedPropertiesMap(modifiedViewModelProperties); // Prepare the SOA input\n\n    let inputs = [];\n\n    _.forEach(modifiedPropsMap, modifiedObj => {\n      let viewModelObject = modifiedObj.viewModelObject;\n\n      if (!viewModelObject || !viewModelObject.uid) {\n        viewModelObject = {\n          uid: cdm.NULL_UID,\n          type: 'unknownType'\n        };\n      }\n\n      let viewModelProps = modifiedObj.viewModelProps; // 'sourceObjectLastSavedDate' and 'srcObjectTypeName' should be defined in viewModelProperty, if not then\n      // we need to extract that info from viewModelObject and assign it.\n\n      _.forEach(viewModelProps, prop => {\n        if (!prop.sourceObjectLastSavedDate && viewModelObject.props && viewModelObject.props.last_mod_date) {\n          prop.sourceObjectLastSavedDate = viewModelObject.props.last_mod_date.dbValues;\n        }\n\n        if (!prop.srcObjectTypeName && dataSource.getDataProvider() && dataSource.getDataProvider().columnConfig) {\n          let columns = dataSource.getDataProvider().columnConfig.columns;\n          let propInfo = columns.find(element => element.propertyName === prop.propertyName);\n\n          if (propInfo) {\n            prop.srcObjectTypeName = propInfo.typeName;\n          }\n        }\n      });\n\n      let input = dms.getSaveViewModelEditAndSubmitToWorkflowInput(viewModelObject);\n\n      _.forEach(viewModelProps, props => dms.pushViewModelProperty(input, props));\n\n      inputs.push(input);\n    }); // Ensure editing flag is set temporarily to ensure correct saveHandler is retrieved\n\n\n    if (isAutoSave) {\n      editHandler._editing = true;\n      appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n    }\n\n    let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ? dataSource.getDeclViewModel().getAtomicData() : null;\n    let evaluationContext = atomicData ? {\n      pageContext: atomicData.pageContext\n    } : {\n      pageContext: null\n    };\n    let saveHandlerPromise = saveHandlerService.getSaveServiceHandlers([dataSource.getContextVMO()], evaluationContext);\n    let saveHandler = null;\n    return saveHandlerPromise.then(saveHandlers => {\n      // Unset editing flag now that saveHandlers are retrieved and to prevent save/cancel edit command appearing\n      if (isAutoSave) {\n        editHandler._editing = false;\n        appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n      }\n\n      let appSaveHandler = saveHandlers ? saveHandlers[0] : [];\n\n      if (appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty) {\n        saveHandler = appSaveHandler;\n      }\n    }).then(() => {\n      if (saveHandler) {\n        return saveHandler.isDirty(dataSource);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(isDirty => {\n      if (saveHandler && isDirty) {\n        return saveHandler.saveEdits(dataSource, inputs);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(() => {\n      if (saveHandler) {\n        editHandler.saveEditsPostActions(true);\n        return false;\n      }\n\n      return true;\n    }).then(saveHandlerActive => {\n      if (saveHandlerActive && inputs.length > 0) {\n        dataSource.registerPropPolicy();\n        return dms.saveViewModelEditAndSubmitWorkflow(inputs);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(response => {\n      if (response) {\n        let error = null;\n\n        if (response.partialErrors || response.PartialErrors) {\n          error = soaSvc.createError(response);\n        } else if (response.ServiceData && response.ServiceData.partialErrors) {\n          error = soaSvc.createError(response.ServiceData);\n        }\n\n        if (error) {\n          let failureUids = [];\n\n          _.forEach(error.cause.partialErrors, partialError => failureUids.push(partialError.clientId));\n\n          updateLsdForPartialSavedVmos(response.viewModelObjectsJsonString, modifiedPropsMap);\n\n          if (isPartialSaveDisabled) {\n            _notifySaveStateChanged('canceling', false);\n          } else {\n            _notifySaveStateChanged('partialSave', false, failureUids, modifiedPropsMap);\n          }\n\n          let errMessage = messagingSvc.getSOAErrorMessage(error);\n          messagingSvc.showError(errMessage);\n          dataSource.unregisterPropPolicy();\n          return AwPromiseService.instance.resolve();\n        }\n      }\n\n      editHandler.saveEditsPostActions(true);\n      dataSource.unregisterPropPolicy();\n      return AwPromiseService.instance.resolve();\n    }, error => {\n      dataSource.unregisterPropPolicy();\n\n      if (error) {\n        if (isPartialSaveDisabled) {\n          _notifySaveStateChanged('canceling', false);\n        }\n\n        return AwPromiseService.instance.reject(error);\n      }\n    });\n  };\n  /**\n   * In case of partial save, update the LSD for partiaqlly saved view model objects\n   *\n   * @param {String} viewModelObjectsJsonString - VMO JSON string\n   * @param {Object} modifiedPropsMap - Map of modified properties\n   */\n\n\n  function updateLsdForPartialSavedVmos(viewModelObjectsJsonString, modifiedPropsMap) {\n    _.forEach(viewModelObjectsJsonString, function (viewModelObjectJsonString) {\n      var responseObject = parsingUtils.parseJsonString(viewModelObjectJsonString);\n\n      if (responseObject && responseObject.objects && responseObject.objects.length > 0) {\n        _.forEach(responseObject.objects, function (serverVMO) {\n          var uid = serverVMO.uid;\n\n          if (modifiedPropsMap[uid]) {\n            var modifiedProps = modifiedPropsMap[uid].viewModelProps;\n\n            _.forEach(modifiedProps, function _iterateModifiedVmoProps(modifiedProp) {\n              var serverVmoProp = serverVMO.props[modifiedProp.propertyName];\n\n              if (serverVmoProp) {\n                modifiedProp.sourceObjectLastSavedDate = serverVmoProp.srcObjLsd;\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n  /**\n   * Create noty button\n   *\n   * @param {String} label\n   * @param {Function} callback\n   *\n   * @return {Object} button object\n   */\n\n\n  function createButton(label, callback) {\n    return {\n      addClass: 'btn btn-notify',\n      text: label,\n      onClick: callback\n    };\n  }\n  /**\n   * Check for dirty edits.\n   *\n   * @return {boolean} value based on viewmodel has some unsaved edits\n   */\n\n\n  editHandler.isDirty = function () {\n    var self = this;\n    var isDirty = false;\n\n    if (self.editInProgress()) {\n      var modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n      var gwtViewModels = dataSource.getGwtVMs();\n\n      if (modifiedViewModelProperties && modifiedViewModelProperties.length > 0) {\n        return AwPromiseService.instance.when(true);\n      }\n\n      if (dataSource.hasxrtBasedViewModel() && !isDirty && gwtViewModels.length > 0 && _xrtViewModelSvc) {\n        _.forEach(gwtViewModels, function (gwtVM) {\n          isDirty = _xrtViewModelSvc.isViewModelDirty(gwtVM);\n\n          if (isDirty) {\n            return false; // to break the loop\n          }\n        });\n\n        return AwPromiseService.instance.when(isDirty);\n      }\n\n      let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ? dataSource.getDeclViewModel().getAtomicData() : null;\n      let evaluationContext = atomicData ? {\n        pageContext: atomicData.pageContext\n      } : {\n        pageContext: null\n      };\n      var saveHandlerPromise = saveHandlerService.getSaveServiceHandlers([dataSource.getContextVMO()], evaluationContext);\n      return saveHandlerPromise.then(function (saveHandlers) {\n        var appSaveHandler = saveHandlers ? saveHandlers[0] : null;\n\n        if (appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty) {\n          return appSaveHandler;\n        }\n      }).then(function (saveHandler) {\n        if (saveHandler) {\n          return saveHandler.isDirty(dataSource);\n        }\n\n        return AwPromiseService.instance.when(false);\n      });\n    }\n\n    return AwPromiseService.instance.when(false);\n  };\n  /**\n   * get the datasource from the xrt\n   *\n   * @return {Object} dataSource - dataSource of the modified page\n   */\n\n\n  editHandler.getDataSource = function () {\n    return dataSource;\n  };\n\n  editHandler.setDataSource = function (newDataSource) {\n    dataSource = newDataSource;\n    editHandler.checkCanEdit();\n  };\n  /**\n   * Display a notification message. Prevents duplicate popups from being active at the same time.\n   *\n   * @return {Promise} A promise resolved when option in popup is selected\n   */\n\n\n  var displayNotyMessage = function () {\n    // If a popup is already active just return existing promise\n    if (!editHandler._deferredPopup) {\n      editHandler._deferredPopup = AwPromiseService.instance.defer();\n      var message = _multiLeaveConfirmation;\n      var modifiedObject = null;\n      var multipleObjects = false;\n      var modifiedViewModelProperties = dataSource.getAllModifiedPropertiesWithVMO();\n\n      if (modifiedViewModelProperties !== null) {\n        _.forEach(modifiedViewModelProperties, function (modifiedProperty) {\n          var currentModifiedObject = modifiedProperty.viewModelObject;\n\n          if (modifiedObject === null) {\n            modifiedObject = currentModifiedObject;\n          } else if (modifiedObject !== null && modifiedObject !== currentModifiedObject) {\n            multipleObjects = true;\n          }\n        });\n      }\n\n      if (!multipleObjects) {\n        if (!modifiedObject) {\n          modifiedObject = dataSource.getSourceObject().vmo;\n\n          if (!modifiedObject && dataSource.getSourceObject().getAtomicData) {\n            modifiedObject = dataSource.getSourceObject().getAtomicData().xrtVMO;\n          }\n        }\n        /*\n           In case of the objects where object_string is empty , make use of the object_name if it is present on the VMO.\n           else it will show the defualt message.\n        */\n\n\n        if (modifiedObject) {\n          var objectDataToReplace = modifiedObject.props.object_string && modifiedObject.props.object_string.uiValue || modifiedObject.props.object_name && modifiedObject.props.object_name.uiValue;\n\n          if (objectDataToReplace) {\n            message = _singleLeaveConfirmation.replace('{0}', objectDataToReplace);\n          }\n        }\n      }\n\n      var buttonArray = [];\n      buttonArray.push(createButton(_discardTxt, function ($noty) {\n        $noty.close();\n        editHandler.cancelEdits();\n\n        editHandler._deferredPopup.resolve();\n\n        editHandler._deferredPopup = null;\n      }));\n      buttonArray.push(createButton(_saveTxt, function ($noty) {\n        $noty.close(); // partial save is disabled, because after save it will be navigating away \n\n        editHandler.saveEdits(true).then(function () {\n          editHandler._deferredPopup.resolve();\n\n          editHandler._deferredPopup = null;\n        }, function () {\n          editHandler._deferredPopup.resolve();\n\n          editHandler._deferredPopup = null;\n        });\n      }));\n      notySvc.showWarning(message, buttonArray);\n      return editHandler._deferredPopup.promise;\n    }\n\n    return editHandler._deferredPopup.promise;\n  };\n  /**\n   * Leave confirmation. If passed a callback will call the callback once it is ok to leave. Returns a promise\n   * that is resolved when it is ok to leave.\n   *\n   * @param {Object} callback - async callback\n   * @return {Promise} - promise that is resolved when leaveConfirmation is complete\n   */\n\n\n  editHandler.leaveConfirmation = function (callback) {\n    var self = this;\n    return self.isDirty().then(function (isDirty) {\n      return isDirty;\n    }).then(function (isDirty) {\n      if (isDirty) {\n        return displayNotyMessage().then(function () {\n          if (_.isFunction(callback)) {\n            callback();\n          }\n        });\n      } else if (dataSource && dataSource.hasxrtBasedViewModel() && self.editInProgress()) {\n        if (_xrtViewModelSvc && dataSource.getSourceObject().xrtData.xrtViewModel) {\n          _xrtViewModelSvc.checkEditHandler(dataSource.getSourceObject().xrtData.xrtViewModel).then(function () {\n            _notifySaveStateChanged('saved', false);\n\n            if (_.isFunction(callback)) {\n              callback();\n            }\n          });\n        }\n      } else {\n        editHandler.cancelEdits(true);\n\n        if (_.isFunction(callback)) {\n          callback();\n        }\n      }\n\n      return AwPromiseService.instance.resolve();\n    });\n  };\n\n  editHandler.canEditSubLocationObjects = function () {\n    return true;\n  };\n\n  editHandler.getSelection = function () {\n    var contextVMO = dataSource.getContextVMO();\n\n    if (contextVMO) {\n      return cdm.getObject(contextVMO.uid);\n    }\n\n    return null;\n  };\n\n  editHandler.destroy = function () {\n    // Only deregister the leave handler if we are sure this edit handler's leave handler is the one registered\n    leavePlaceService.deregisterLeaveHandler(_leaveHandler);\n    removeSaveListener();\n    dataSource = null;\n    _isDestroyed = true;\n    editHandler.canEdit = false;\n    editHandler._editing = false;\n  }; //update status here\n\n\n  editHandler.checkCanEdit = function () {\n    editHandler.canEdit = dataSource.canStartEdit();\n    appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n  };\n\n  return editHandler;\n};\nexports = {\n  createEditHandler\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/editHandlerFactory.js"],"names":["exports","preSaveActionsCounter","preSaveActions","createEditHandler","editHandler","isNative","_editing","canEdit","dataSource","_singleLeaveConfirmation","_multiLeaveConfirmation","_saveTxt","_discardTxt","_validationError","_xrtViewModelSvc","_isDestroyed","_leaveHandler","localeSvc","result","saveEditsListener","removeSaveListener","document","addSaveListener","editOptions","editEventsService","logger","dataProvider","eventBus","viewModelObjects","totalObjectsFound","stateName","type","value","appCtxSvc","context","state","onlyEditSupportParamsChanging","newParams","newLocation","oldParams","oldLocation","selectionParamsSame","i","editSupportParamKeys","param","newParamsClone","JSON","oldParamsClone","_","Object","leavePlaceService","okToLeave","clearLeaveHandler","isPropEditing","Boolean","viewModelObjectList","uidToVMMap","viewModelObject","existingVMOs","propMap","vmo","propPolicy","types","name","properties","policyId","policySvc","input","inputs","dms","propNamesToUpdate","processJsonStringResponse","response","j","prop","uwPropertyService","_notifySaveStateChanged","loadedObjects","responseObject","parsingUtils","uid","serverVMO","exisitingVMOs","updatedVMO","vmsvc","nextId","preSaveActionID","editStateChangeDispatcher","hasValidationErrors","editableViewModelProperties","messagingSvc","AwPromiseService","modifiedViewModelProperties","modifiedPropsMap","modifiedObj","cdm","viewModelProps","columns","propInfo","element","props","atomicData","evaluationContext","pageContext","saveHandlerPromise","saveHandlerService","saveHandler","saveHandlers","appSaveHandler","isDirty","saveHandlerActive","error","soaSvc","failureUids","partialError","updateLsdForPartialSavedVmos","errMessage","modifiedProps","serverVmoProp","modifiedProp","addClass","text","onClick","callback","self","gwtViewModels","displayNotyMessage","message","modifiedObject","multipleObjects","currentModifiedObject","modifiedProperty","objectDataToReplace","buttonArray","createButton","$noty","notySvc","contextVMO"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editHandlerFactory\n */\n\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport appCtxSvc from 'js/appCtxService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport dms from 'soa/dataManagementService';\nimport editEventsService from 'js/editEventsService';\nimport eventBus from 'js/eventBus';\nimport leavePlaceService from 'js/leavePlace.service';\nimport localeSvc from 'js/localeService';\nimport logger from 'js/logger';\nimport messagingSvc from 'js/messagingService';\nimport notySvc from 'js/NotyModule';\nimport parsingUtils from 'js/parsingUtils';\nimport policySvc from 'soa/kernel/propertyPolicyService';\nimport saveHandlerService from 'js/saveHandlerService';\nimport soaSvc from 'soa/kernel/soaService';\nimport uwPropertyService from 'js/uwPropertyService';\nimport vmsvc from 'js/viewModelObjectService';\n\n// Various services\n\nvar exports = {};\nlet preSaveActionsCounter = 0; //  Registration counter for preSave Actions.\nlet preSaveActions = {};\n\n/**\n * Create edit handler\n *\n * @param {Object} dataSource - the dataSource we're associating the edit handler with\n * @param {Array} editSupportParamKeys - the url parameters which are allowed to change during edit mode\n *\n * @return {Object} edit handler object\n */\nexport let createEditHandler = function( dataSourceArg, editSupportParamKeys ) {\n    var editHandler = {\n        // Mark this handler as native - checked from GWT jsni code\n        isNative: true,\n        _editing: false,\n        canEdit: false\n    };\n    var dataSource = dataSourceArg;\n    var _singleLeaveConfirmation = null;\n    var _multiLeaveConfirmation = null;\n    var _saveTxt = null;\n    var _discardTxt = null;\n    var _validationError = null;\n    var _xrtViewModelSvc = null;\n    let _isDestroyed = false;\n    let _leaveHandler = null;\n\n    if( localeSvc ) {\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.navigationConfirmationSingle' ).then( result => _singleLeaveConfirmation = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.navigationConfirmationMultiple' ).then( result => _multiLeaveConfirmation = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.save' ).then( result => _saveTxt = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.discard' ).then( result => _discardTxt = result );\n        localeSvc.getLocalizedTextFromKey( 'editHandlerMessages.validationError' ).then( result => _validationError = result );\n    }\n\n    let saveEditsListener = null;\n\n    const removeSaveListener = function() {\n        document.removeEventListener( 'keydown', saveEditsListener );\n    };\n\n    const addSaveListener = function( editOptions ) {\n        removeSaveListener();\n        if( editOptions && editOptions.autoSave ) {\n            saveEditsListener = editEventsService.saveEditsListener( editHandler, removeSaveListener );\n        } else {\n            saveEditsListener = editEventsService.saveEditsListener( null, removeSaveListener );\n        }\n        document.addEventListener( 'keydown', saveEditsListener );\n    };\n\n    /**\n     * Notify the save state changes\n     *\n     * @param {String} stateName - edit state name ('starting', 'saved', 'cancelling')\n     * @param {Boolean} fireEvents - fire modelObjectsUpdated events\n     * @param {Array} failureUids - the object uids that failed to save\n     * @param {Object} modifiedPropsMap - modified properties map\n     */\n    function _notifySaveStateChanged( stateName, fireEvents, failureUids, modifiedPropsMap ) {\n        switch ( stateName ) {\n            case 'starting':\n                dataSource.checkEditableOnProperties();\n                addSaveListener();\n                break;\n            case 'saved':\n                dataSource.saveEditiableStates();\n                removeSaveListener();\n                break;\n            case 'canceling':\n                dataSource.resetEditiableStates();\n                removeSaveListener();\n                break;\n            case 'partialSave':\n                dataSource.updatePartialEditState( failureUids, modifiedPropsMap );\n                break;\n            default:\n                logger.error( 'Unexpected stateName value: ' + stateName );\n        }\n\n        if( fireEvents ) {\n            var dataProvider = dataSource.getDataProvider();\n            if( dataProvider && dataProvider.viewModelCollection ) {\n                eventBus.publish( dataProvider.name + '.modelObjectsUpdated', {\n                    viewModelObjects: dataProvider.viewModelCollection.getLoadedViewModelObjects(),\n                    totalObjectsFound: dataProvider.viewModelCollection.getTotalObjectsLoaded()\n                } );\n            }\n        }\n\n        editHandler._editing = stateName === 'starting' || stateName === 'partialSave';\n        if( editHandler.editStateChangeDispatcher ) {\n            editHandler.editStateChangeDispatcher( {\n                type: 'SET_EDIT_STATE_CHANGED',\n                value: editHandler._editing\n            } );\n        }\n\n        // Add to the appCtx about the editing state\n        appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n\n        var context = {\n            state: stateName\n        };\n\n        context.dataSource = dataSource.getSourceObject();\n        context.failureUids = failureUids;\n        eventBus.publish( 'editHandlerStateChange', context );\n    }\n\n    const onlyEditSupportParamsChanging = function( newLocation, oldLocation, editSupportParamKeys ) {\n        const newParams = newLocation.params;\n        const oldParams = oldLocation.params;\n\n        // Return false if state name is changing\n        if( newLocation.state.name !== oldLocation.state.name ) {\n            return false;\n        }\n\n        let selectionParamsSame = true;\n        for( let i = 0; i < editSupportParamKeys.length; i++ ) {\n            let param = editSupportParamKeys[ i ];\n            if( newParams[ param ] !== oldParams[ param ] ) {\n                selectionParamsSame = false;\n            }\n        }\n        if( selectionParamsSame ) {\n            return false;\n        }\n\n        // Return false if the keys are not equal ( excluding the editSupportParamKeys )\n        let newParamsClone = JSON.parse( JSON.stringify( newParams ) );\n        let oldParamsClone = JSON.parse( JSON.stringify( oldParams ) );\n        for( let i = 0; i < editSupportParamKeys.length; i++ ) {\n            let param = editSupportParamKeys[ i ];\n            delete newParamsClone[ param ];\n            delete oldParamsClone[ param ];\n        }\n        if( !_.isEqual( Object.keys( newParamsClone ), Object.keys( oldParamsClone ) ) ) {\n            return false;\n        }\n\n        // Return false if one of the param values has changed ( excluding the v )\n        for( let key in newParamsClone ) {\n            if( newParamsClone[ key ] !== oldParamsClone[ key ] ) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Reregisters the existing leaveHandler with the leavePlaceService\n     */\n    editHandler.reregisterLeaveHandler = function() {\n        leavePlaceService.registerLeaveHandler( _leaveHandler );\n    };\n\n    /**\n     * Start editing\n     *\n     * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n     * @return {Promise} response\n     */\n    editHandler.startEdit = function( editOptions ) {\n        // Register with leave place service\n        _leaveHandler = {\n            okToLeave: function( targetNavDetails, newLocation, oldLocation ) {\n                // Skip leaveConfirmation if editSupportParamKeys are the only part of the url that is changing.\n                if( editSupportParamKeys && newLocation && oldLocation && onlyEditSupportParamsChanging( newLocation, oldLocation, editSupportParamKeys ) ) {\n                    return Promise.resolve( { clearLeaveHandler: false } );\n                }\n                return editHandler.leaveConfirmation();\n            }\n        };\n        leavePlaceService.registerLeaveHandler( _leaveHandler );\n\n        const isPropEditing = Boolean( editOptions );\n\n        if( !editOptions ) {\n            editHandler._editing = true;\n        }\n        var viewModelObjectList = dataSource.getLoadedViewModelObjects();\n\n        // Get list of UIDs\n        var uidToVMMap = {};\n        if( isPropEditing ) {\n            _.forEach( editOptions.vmos, function( viewModelObject ) {\n                if( !uidToVMMap[ viewModelObject.uid ] ) {\n                    uidToVMMap[ viewModelObject.uid ] = [ viewModelObject ];\n                }\n            } );\n        } else if( viewModelObjectList !== null ) {\n            _.forEach( viewModelObjectList, function( viewModelObject ) {\n                if( uidToVMMap[ viewModelObject.uid ] ) {\n                    var existingVMOs = uidToVMMap[ viewModelObject.uid ];\n                    existingVMOs.push( viewModelObject );\n                } else {\n                    uidToVMMap[ viewModelObject.uid ] = [ viewModelObject ];\n                }\n            } );\n        }\n\n        let propMap = {};\n        if( isPropEditing ) {\n            _.forEach( editOptions.vmos, function( vmo ) {\n                propMap[ vmo.uid ] = editOptions.propertyNames;\n            } );\n        } else {\n            propMap = dataSource.getPropertyMap();\n        }\n\n        var propPolicy = {\n            types: [ {\n                name: 'BusinessObject',\n                properties: [ {\n                    name: 'is_modifiable'\n                } ]\n            } ]\n        };\n\n        var policyId = policySvc.register( propPolicy, 'startEditHandler_Policy', 'selected' );\n\n        var input = {\n            inputs: []\n        };\n        if( propMap ) {\n            _.forEach( propMap, function( value, key ) {\n                dms.getLoadViewModelForEditingInput( input, key, value );\n            } );\n        }\n\n        return dms.loadViewModelForEditing2( input.inputs ).then( function( response ) {\n            if( _isDestroyed ) {\n                return;\n            }\n            let propNamesToUpdate = editOptions ? editOptions.propertyNames : [];\n            processJsonStringResponse( response.viewModelObjectsJsonStrings, uidToVMMap, propNamesToUpdate );\n            if( isPropEditing ) {\n                for( let j = 0; j < editOptions.vmos.length; j++ ) {\n                    for( let i = 0; i < editOptions.propertyNames.length; i++ ) {\n                        const prop = editOptions.vmos[ j ].props[ editOptions.propertyNames[ i ] ];\n                        uwPropertyService.setEditable( prop, true );\n                        uwPropertyService.setEditState( prop, true, true, true );\n                    }\n                }\n                addSaveListener( editOptions );\n            } else {\n                _notifySaveStateChanged( 'starting', true );\n            }\n            policySvc.unregister( policyId );\n            return response;\n        }, function( error ) {\n            editHandler._editing = false;\n            policySvc.unregister( policyId );\n        } );\n    };\n\n    /**\n     * This function processes the response and replace the existing viewModelObject with the newly created VMO\n     * @param {String[]} viewModelObjectsInJsonString - The viewModel objects json strings array\n     * @param {Object[]} uidToVMMap - the Ui to VM object map\n     * @param {String[]} [propsToUpdate] - (Optional) If provided, only these properties on the vmos with be updated\n     */\n    function processJsonStringResponse( viewModelObjectsInJsonString, uidToVMMap, propsToUpdate ) {\n        var loadedObjects = dataSource.getLoadedViewModelObjects();\n        _.forEach( viewModelObjectsInJsonString, function( viewModelObjectJsonString ) {\n            var responseObject = parsingUtils.parseJsonString( viewModelObjectJsonString );\n            if( responseObject && responseObject.objects && responseObject.objects.length > 0 ) {\n                _.forEach( responseObject.objects, function( serverVMO ) {\n                    var uid = serverVMO.uid;\n                    var exisitingVMOs = uidToVMMap[ uid ] ? uidToVMMap[ uid ] : loadedObjects;\n                    var updatedVMO = vmsvc.createViewModelObject( uid, 'EDIT', null, serverVMO );\n                    vmsvc.updateSourceObjectPropertiesByViewModelObject( updatedVMO, exisitingVMOs, propsToUpdate );\n                } );\n            }\n        } );\n    }\n\n    /**\n     * Can we start editing?\n     *\n     * @return {Boolean} true if we can start editing\n     */\n    editHandler.canStartEdit = function() {\n        return dataSource.canStartEdit();\n    };\n\n    /**\n     * Is an edit in progress?\n     *\n     * @return {Boolean} true if we're editing\n     */\n    editHandler.editInProgress = function() {\n        return this._editing;\n    };\n\n    /**\n     * Cancel the current edit\n     *\n     * @param {Boolean} noPendingModifications - are there pending modifications? (optional)\n     * @param {Boolean} ignoreLeaveHandler - don't remove leave handler\n     */\n    editHandler.cancelEdits = function( noPendingModifications, ignoreLeaveHandler ) {\n        if( !ignoreLeaveHandler ) {\n            leavePlaceService.registerLeaveHandler( null );\n        }\n        _notifySaveStateChanged( 'canceling', !noPendingModifications );\n    };\n\n    /**\n     * Perform the actions post Save Edit\n     *\n     * @param {Boolean} saveSuccess Whether the save edit was successful\n     */\n    editHandler.saveEditsPostActions = function( saveSuccess ) {\n        if( saveSuccess ) {\n            leavePlaceService.registerLeaveHandler( null );\n        }\n        _notifySaveStateChanged( 'saved', saveSuccess );\n    };\n\n    /**\n     * Register preSaveAction.\n     * @param {String} preSaveActionName - The preSave function to be executed.\n     * @return {String} preSaveAction ID\n     */\n    editHandler.registerPreSaveAction = function( preSaveActionName ) {\n        var nextId = ++preSaveActionsCounter;\n        var preSaveActionID = 'preSaveAction_' + nextId;\n        preSaveActions[ preSaveActionID ] = preSaveActionName;\n        return preSaveActionID;\n    };\n\n    /**\n     * unregister preSaveAction.\n     * @param {String} preSaveActionID - preSaveActionID\n     */\n    editHandler.unregisterPreSaveAction = function( preSaveActionID ) {\n        if( preSaveActions && preSaveActions[ preSaveActionID ] ) {\n            delete preSaveActions[ preSaveActionID ];\n        }\n    };\n\n    editHandler.setDataUpdater = ( editStateChangeDispatcher ) => {\n        editHandler.editStateChangeDispatcher = editStateChangeDispatcher;\n    };\n\n    /**\n     * Save the current edits\n     * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n     * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n     * @return {Promise} Promise that is resolved when save edit is complete\n     */\n    editHandler.saveEdits = function( isPartialSaveDisabled, isAutoSave ) {\n        // Do not save edit if there are validation errors\n\n        // Execute preSaveActions if there are any.\n        _.forEach( preSaveActions, function( value ) {\n            value();\n        } );\n        let hasValidationErrors = false;\n        let editableViewModelProperties = dataSource.getAllEditableProperties();\n        for( let prop of editableViewModelProperties ) {\n            if( prop.error && prop.error.length > 0 ) {\n                hasValidationErrors = true;\n                break;\n            }\n        }\n\n        if( hasValidationErrors ) {\n            messagingSvc.showError( _validationError );\n            if( isPartialSaveDisabled ) {\n                _notifySaveStateChanged( 'canceling', false );\n            }\n            return AwPromiseService.instance.reject( _validationError );\n        }\n\n        // Get all properties that are modified\n        let modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n        let modifiedPropsMap = dataSource.getModifiedPropertiesMap( modifiedViewModelProperties );\n\n        // Prepare the SOA input\n        let inputs = [];\n        _.forEach( modifiedPropsMap, modifiedObj => {\n            let viewModelObject = modifiedObj.viewModelObject;\n            if( !viewModelObject || !viewModelObject.uid ) {\n                viewModelObject = {\n                    uid: cdm.NULL_UID,\n                    type: 'unknownType'\n                };\n            }\n\n            let viewModelProps = modifiedObj.viewModelProps;\n\n            // 'sourceObjectLastSavedDate' and 'srcObjectTypeName' should be defined in viewModelProperty, if not then\n            // we need to extract that info from viewModelObject and assign it.\n            _.forEach( viewModelProps, prop => {\n                if( !prop.sourceObjectLastSavedDate && viewModelObject.props && viewModelObject.props.last_mod_date ) {\n                    prop.sourceObjectLastSavedDate = viewModelObject.props.last_mod_date.dbValues;\n                }\n                if( !prop.srcObjectTypeName && dataSource.getDataProvider() && dataSource.getDataProvider().columnConfig ) {\n                    let columns = dataSource.getDataProvider().columnConfig.columns;\n                    let propInfo = columns.find( element => element.propertyName === prop.propertyName );\n                    if( propInfo ) {\n                        prop.srcObjectTypeName = propInfo.typeName;\n                    }\n                }\n            } );\n\n            let input = dms.getSaveViewModelEditAndSubmitToWorkflowInput( viewModelObject );\n            _.forEach( viewModelProps, props => dms.pushViewModelProperty( input, props ) );\n            inputs.push( input );\n        } );\n\n        // Ensure editing flag is set temporarily to ensure correct saveHandler is retrieved\n        if( isAutoSave ) {\n            editHandler._editing = true;\n            appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n        }\n\n        let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ?\n            dataSource.getDeclViewModel().getAtomicData() : null;\n        let evaluationContext = atomicData ? { pageContext: atomicData.pageContext } : { pageContext: null };\n        let saveHandlerPromise = saveHandlerService.getSaveServiceHandlers( [ dataSource.getContextVMO() ], evaluationContext );\n        let saveHandler = null;\n\n        return saveHandlerPromise.then( saveHandlers => {\n            // Unset editing flag now that saveHandlers are retrieved and to prevent save/cancel edit command appearing\n            if( isAutoSave ) {\n                editHandler._editing = false;\n                appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n            }\n            let appSaveHandler = saveHandlers ? saveHandlers[ 0 ] : [];\n            if( appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty ) {\n                saveHandler = appSaveHandler;\n            }\n        } ).then( () => {\n            if( saveHandler ) {\n                return saveHandler.isDirty( dataSource );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( isDirty => {\n            if( saveHandler && isDirty ) {\n                return saveHandler.saveEdits( dataSource, inputs );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( () => {\n            if( saveHandler ) {\n                editHandler.saveEditsPostActions( true );\n                return false;\n            }\n            return true;\n        } ).then( saveHandlerActive => {\n            if( saveHandlerActive && inputs.length > 0 ) {\n                dataSource.registerPropPolicy();\n                return dms.saveViewModelEditAndSubmitWorkflow( inputs );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( response => {\n            if( response ) {\n                let error = null;\n                if( response.partialErrors || response.PartialErrors ) {\n                    error = soaSvc.createError( response );\n                } else if( response.ServiceData && response.ServiceData.partialErrors ) {\n                    error = soaSvc.createError( response.ServiceData );\n                }\n\n                if( error ) {\n                    let failureUids = [];\n                    _.forEach( error.cause.partialErrors, partialError => failureUids.push( partialError.clientId ) );\n\n                    updateLsdForPartialSavedVmos( response.viewModelObjectsJsonString, modifiedPropsMap );\n                    if( isPartialSaveDisabled ) {\n                        _notifySaveStateChanged( 'canceling', false );\n                    } else {\n                        _notifySaveStateChanged( 'partialSave', false, failureUids, modifiedPropsMap );\n                    }\n\n                    let errMessage = messagingSvc.getSOAErrorMessage( error );\n                    messagingSvc.showError( errMessage );\n                    dataSource.unregisterPropPolicy();\n                    return AwPromiseService.instance.resolve();\n                }\n            }\n            editHandler.saveEditsPostActions( true );\n            dataSource.unregisterPropPolicy();\n            return AwPromiseService.instance.resolve();\n        }, error => {\n            dataSource.unregisterPropPolicy();\n            if( error ) {\n                if( isPartialSaveDisabled ) {\n                    _notifySaveStateChanged( 'canceling', false );\n                }\n                return AwPromiseService.instance.reject( error );\n            }\n        } );\n    };\n\n    /**\n     * In case of partial save, update the LSD for partiaqlly saved view model objects\n     *\n     * @param {String} viewModelObjectsJsonString - VMO JSON string\n     * @param {Object} modifiedPropsMap - Map of modified properties\n     */\n    function updateLsdForPartialSavedVmos( viewModelObjectsJsonString, modifiedPropsMap ) {\n        _.forEach( viewModelObjectsJsonString, function( viewModelObjectJsonString ) {\n            var responseObject = parsingUtils.parseJsonString( viewModelObjectJsonString );\n            if( responseObject && responseObject.objects && responseObject.objects.length > 0 ) {\n                _.forEach( responseObject.objects, function( serverVMO ) {\n                    var uid = serverVMO.uid;\n                    if( modifiedPropsMap[ uid ] ) {\n                        var modifiedProps = modifiedPropsMap[ uid ].viewModelProps;\n                        _.forEach( modifiedProps, function _iterateModifiedVmoProps( modifiedProp ) {\n                            var serverVmoProp = serverVMO.props[ modifiedProp.propertyName ];\n                            if( serverVmoProp ) {\n                                modifiedProp.sourceObjectLastSavedDate = serverVmoProp.srcObjLsd;\n                            }\n                        } );\n                    }\n                } );\n            }\n        } );\n    }\n\n    /**\n     * Create noty button\n     *\n     * @param {String} label\n     * @param {Function} callback\n     *\n     * @return {Object} button object\n     */\n    function createButton( label, callback ) {\n        return {\n            addClass: 'btn btn-notify',\n            text: label,\n            onClick: callback\n        };\n    }\n\n    /**\n     * Check for dirty edits.\n     *\n     * @return {boolean} value based on viewmodel has some unsaved edits\n     */\n    editHandler.isDirty = function() {\n        var self = this;\n        var isDirty = false;\n\n        if( self.editInProgress() ) {\n            var modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n            var gwtViewModels = dataSource.getGwtVMs();\n            if( modifiedViewModelProperties && modifiedViewModelProperties.length > 0 ) {\n                return AwPromiseService.instance.when( true );\n            }\n\n            if( dataSource.hasxrtBasedViewModel() && !isDirty && gwtViewModels.length > 0 && _xrtViewModelSvc ) {\n                _.forEach( gwtViewModels, function( gwtVM ) {\n                    isDirty = _xrtViewModelSvc.isViewModelDirty( gwtVM );\n                    if( isDirty ) {\n                        return false; // to break the loop\n                    }\n                } );\n                return AwPromiseService.instance.when( isDirty );\n            }\n\n            let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ?\n                dataSource.getDeclViewModel().getAtomicData() : null;\n            let evaluationContext = atomicData ? { pageContext: atomicData.pageContext } : { pageContext: null };\n            var saveHandlerPromise = saveHandlerService\n                .getSaveServiceHandlers( [ dataSource.getContextVMO() ], evaluationContext );\n            return saveHandlerPromise.then( function( saveHandlers ) {\n                var appSaveHandler = saveHandlers ? saveHandlers[ 0 ] : null;\n                if( appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty ) {\n                    return appSaveHandler;\n                }\n            } ).then( function( saveHandler ) {\n                if( saveHandler ) {\n                    return saveHandler.isDirty( dataSource );\n                }\n                return AwPromiseService.instance.when( false );\n            } );\n        }\n        return AwPromiseService.instance.when( false );\n    };\n\n    /**\n     * get the datasource from the xrt\n     *\n     * @return {Object} dataSource - dataSource of the modified page\n     */\n    editHandler.getDataSource = function() {\n        return dataSource;\n    };\n\n    editHandler.setDataSource = function( newDataSource ) {\n        dataSource = newDataSource;\n        editHandler.checkCanEdit();\n    };\n\n    /**\n     * Display a notification message. Prevents duplicate popups from being active at the same time.\n     *\n     * @return {Promise} A promise resolved when option in popup is selected\n     */\n    var displayNotyMessage = function() {\n        // If a popup is already active just return existing promise\n        if( !editHandler._deferredPopup ) {\n            editHandler._deferredPopup = AwPromiseService.instance.defer();\n\n            var message = _multiLeaveConfirmation;\n            var modifiedObject = null;\n            var multipleObjects = false;\n\n            var modifiedViewModelProperties = dataSource.getAllModifiedPropertiesWithVMO();\n            if( modifiedViewModelProperties !== null ) {\n                _.forEach( modifiedViewModelProperties, function( modifiedProperty ) {\n                    var currentModifiedObject = modifiedProperty.viewModelObject;\n                    if( modifiedObject === null ) {\n                        modifiedObject = currentModifiedObject;\n                    } else if( modifiedObject !== null && modifiedObject !== currentModifiedObject ) {\n                        multipleObjects = true;\n                    }\n                } );\n            }\n\n            if( !multipleObjects ) {\n                if( !modifiedObject ) {\n                    modifiedObject = dataSource.getSourceObject().vmo;\n                    if( !modifiedObject && dataSource.getSourceObject().getAtomicData ) {\n                        modifiedObject = dataSource.getSourceObject().getAtomicData().xrtVMO;\n                    }\n                }\n                /*\n                   In case of the objects where object_string is empty , make use of the object_name if it is present on the VMO.\n                   else it will show the defualt message.\n                */\n                if( modifiedObject ) {\n                    var objectDataToReplace = modifiedObject.props.object_string && modifiedObject.props.object_string.uiValue ||\n                        modifiedObject.props.object_name && modifiedObject.props.object_name.uiValue;\n                    if( objectDataToReplace ) {\n                        message = _singleLeaveConfirmation.replace( '{0}', objectDataToReplace );\n                    }\n                }\n            }\n\n            var buttonArray = [];\n            buttonArray.push( createButton( _discardTxt, function( $noty ) {\n                $noty.close();\n                editHandler.cancelEdits();\n                editHandler._deferredPopup.resolve();\n                editHandler._deferredPopup = null;\n            } ) );\n            buttonArray.push( createButton( _saveTxt, function( $noty ) {\n                $noty.close();\n                // partial save is disabled, because after save it will be navigating away \n                editHandler.saveEdits( true ).then( function() {\n                    editHandler._deferredPopup.resolve();\n                    editHandler._deferredPopup = null;\n                }, function() {\n                    editHandler._deferredPopup.resolve();\n                    editHandler._deferredPopup = null;\n                } );\n            } ) );\n            notySvc.showWarning( message, buttonArray );\n\n            return editHandler._deferredPopup.promise;\n        }\n\n        return editHandler._deferredPopup.promise;\n    };\n\n    /**\n     * Leave confirmation. If passed a callback will call the callback once it is ok to leave. Returns a promise\n     * that is resolved when it is ok to leave.\n     *\n     * @param {Object} callback - async callback\n     * @return {Promise} - promise that is resolved when leaveConfirmation is complete\n     */\n    editHandler.leaveConfirmation = function( callback ) {\n        var self = this;\n        return self.isDirty().then( function( isDirty ) {\n            return isDirty;\n        } ).then(\n            function( isDirty ) {\n                if( isDirty ) {\n                    return displayNotyMessage().then( function() {\n                        if( _.isFunction( callback ) ) {\n                            callback();\n                        }\n                    } );\n                } else if( dataSource && dataSource.hasxrtBasedViewModel() && self.editInProgress() ) {\n                    if( _xrtViewModelSvc && dataSource.getSourceObject().xrtData.xrtViewModel ) {\n                        _xrtViewModelSvc.checkEditHandler( dataSource.getSourceObject().xrtData.xrtViewModel )\n                            .then( function() {\n                                _notifySaveStateChanged( 'saved', false );\n                                if( _.isFunction( callback ) ) {\n                                    callback();\n                                }\n                            } );\n                    }\n                } else {\n                    editHandler.cancelEdits( true );\n                    if( _.isFunction( callback ) ) {\n                        callback();\n                    }\n                }\n                return AwPromiseService.instance.resolve();\n            } );\n    };\n\n    editHandler.canEditSubLocationObjects = function() {\n        return true;\n    };\n\n    editHandler.getSelection = function() {\n        var contextVMO = dataSource.getContextVMO();\n        if( contextVMO ) {\n            return cdm.getObject( contextVMO.uid );\n        }\n        return null;\n    };\n\n    editHandler.destroy = function() {\n        // Only deregister the leave handler if we are sure this edit handler's leave handler is the one registered\n        leavePlaceService.deregisterLeaveHandler( _leaveHandler );\n        removeSaveListener();\n        dataSource = null;\n        _isDestroyed = true;\n        editHandler.canEdit = false;\n        editHandler._editing = false;\n    };\n\n    //update status here\n    editHandler.checkCanEdit = function() {\n        editHandler.canEdit = dataSource.canStartEdit();\n        appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n    };\n\n    return editHandler;\n};\n\nexports = {\n    createEditHandler\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}