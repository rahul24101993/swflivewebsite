{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This is the integration logic with the route change events.\n *\n * NOTE - since this is loaded PRIOR to app.initModule() it can't use the typical angular resolution patterns. Needs to\n * be treated as a ES6 only module.\n *\n * @module js/routeChangeHandler\n */import sessionState from'js/sessionState';import AwPromiseService from'js/awPromiseService';import AwStateService from'js/awStateService';import workspaceValService from'js/workspaceValidationService';import pageService from'js/page.service';import postLoginPipeLineSvc from'js/postLoginPipeline.service';import awConfiguration from'js/awConfiguration';import eventBus from'js/eventBus';var exports={};/**\n * state change handler function called when the router is about to transition states. Leverages the\n * authentication state information to determine whether or not to prevent the current route change, and trigger\n * the authentication path.\n *\n * If session state shows already authenticated, allow the transition.\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n * @param {Object} options ui-router navigation options\n */export let routeStateChangeStart=function(toState,toParams,fromState,fromParams,options){// this gets run prior to bootstrap finishing, so there is no angular resolution available.\nconst defer=AwPromiseService.instance.defer();if(!sessionState.getIsAuthenticated()){if(!sessionState.isAuthenticationInProgress()){// save these for future nav trigger -- NOT SURE about SSO case.\nvar targetNavDetails={};targetNavDetails.toState=toState;targetNavDetails.toParams=toParams;targetNavDetails.options=options;// the session may be ok, but until we ask the server we don't know.\n// event.preventDefault();\ndefer.reject('routeChangeHandler: prevent State');// From this point, we can trigger async load behavior since the event has been updated.\n// check if there is a valid current session, if so continue, otherwise trigger\n// the authentication path.\nsessionState.performValidSessionCheck(targetNavDetails);}else{// during authInProgress true, Only page that without auth\n// can be accessed.\nif(!toState.noAuth){sessionState.setAuthStatus(false);sessionState.setAuthenticationInProgress(false);// event.preventDefault();\ndefer.reject('routeChangeHandler: prevent State');// stop the auth processing of the current flow, stop the nav request for\n// this new URL, but trigger a state change to the new target route.\nsessionState.forceNavigation(toState,toParams);}}defer.resolve();}else{workspaceValService.isValidPageAsync(toState.name).then(function(changeState){var defRoutePath=awConfiguration.get('defaultRoutePath');// If the page being navigated to is not a valid page (i.e. not in the list of available pages for the workspace),\n// go to the default page. If it is a valid page, we might be here because the user has switched his workspace and the\n// page user was on is no longer a valid page in the new workspace. So go to the default page.\nif(!changeState||toParams.validateDefaultRoutePath==='true'&&toState.name!==defRoutePath){// event.preventDefault();\ndefer.reject('routeChangeHandler: prevent State');AwStateService.instance.go(defRoutePath);}});defer.resolve();}return defer.promise;};/**\n * Invoked when the state change was successful from UI router\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n */export let routeStateChangeSuccess=function(toState,toParams,fromState,fromParams){var allStagesAuthenticated=postLoginPipeLineSvc.checkPostLoginAuthenticatedStages();if(sessionState&&sessionState.getIsAuthenticated()){if(allStagesAuthenticated){sessionState.routeStateChangeSuccess(toState,toParams,fromState,fromParams);pageService.navigateToDefaultSubPage(toState,toParams);}else{sessionState.runPostLoginStages();}}};/**\n * delegates from the route resolution down into the session state ES6 module. This simply wraps the load\n * and call to the session manager.\n *\n * @param {Object} $q - promise Q\n * @return {Promise} promise\n */export let pickAuthenticator=function(){return sessionState.pickAuthenticator();};eventBus.subscribe('transitionHooks',_ref=>{let{transitionService}=_ref;/**\n     * Replacement of $stateChangeSuccess\n     */transitionService.onSuccess({},function(transition){exports.routeStateChangeSuccess(transition.to(),transition.params(),transition.from(),transition.params('from'));});/**\n     * Replacement of $stateChangeStart\n     */transitionService.onEnter({},function(transition){return exports.routeStateChangeStart(transition.to(),transition.params(),transition.from(),transition.params('from'),transition.options());});});exports={routeStateChangeStart,routeStateChangeSuccess,pickAuthenticator};export default exports;","map":null,"metadata":{},"sourceType":"module"}