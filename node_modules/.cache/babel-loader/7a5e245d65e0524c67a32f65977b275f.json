{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This service is used to parse the mongo-db like expression.\n *\n * @module js/adapterParserService\n *\n * @namespace adapterParserService\n */import AwPromiseService from'js/awPromiseService';import cdm from'soa/kernel/clientDataModel';import _ from'lodash';import assert from'js/assert';import expressionParserUtils from'js/expressionParserUtils';import moduleLoader from'js/moduleLoader';var _adapterConfigObject;var exports={};var OP_ARRAY=['$and','$or'];var _conditionQuickEval={};/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n */ /**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n *\n * @returns {ObjectArray} objects adapted from source using adapter configuration.\n */export let getAdaptedObjectsSync=function(sourceObjects,adapterConfigObject){var adaptedObjects=[];adaptedObjects=adaptedObjects.concat(sourceObjects);assert(adapterConfigObject,'The Adapter Config service is not loaded');_adapterConfigObject=adapterConfigObject;if(!_.isEmpty(_adapterConfigObject)){var adoptees=[];_.forEach(sourceObjects,function(sourceObject){var verdictObj=exports.applyConditions(sourceObject);if(verdictObj&&verdictObj.verdict){var targetProp=_adapterConfigObject[verdictObj.index].target;if(targetProp.prop){var propObjs=sourceObject.props[targetProp.prop];propObjs=_.isArray(propObjs)?propObjs:[propObjs];_.forEach(propObjs,function(prop){if(prop&&prop.dbValues){_.forEach(prop.dbValues,function(dbValue){var modelObject=cdm.getObject(dbValue);if(modelObject){adoptees.push(modelObject);}else{adoptees.push(sourceObject);}});}});}}});if(adoptees&&adoptees.length>0){adaptedObjects=adoptees;}}return adaptedObjects;};/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n * @param {Boolean} isFullyAdapted - if object should be recursively adapted\n *\n * @return {Promise} Resolved with an array of adapted objects containing the results of the operation.\n */export let getAdaptedObjects=function(sourceObjects,adapterConfigObject,isFullyAdapted){assert(adapterConfigObject,'The Adapter Config service is not loaded');_adapterConfigObject=adapterConfigObject;if(!_.isEmpty(_adapterConfigObject)){var promises=[];var adoptees=[];_.forEach(sourceObjects,function(sourceObject){promises.push(_getAdaptedObjectSource(sourceObject,isFullyAdapted));});return AwPromiseService.instance.all(promises).then(function(results){_.forEach(results,function(result){adoptees=adoptees.concat(result);});return adoptees;});}return AwPromiseService.instance.resolve(sourceObjects);};/**\n * This is to set the adapter config object\n *\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n */export let setConfiguration=function(adapterConfigObject){_adapterConfigObject=adapterConfigObject;};/**\n * This method apply and evaluate the conditions on the source object and returns boolean value accordingly.\n *\n * @param {Object} sourceObject - source object\n * @param {Object} configObject - solution config object in case this function is called from a different context\n * @returns {Object} verdict object\n */export let applyConditions=function(sourceObject,configObject){var index=0;var verdict=false;if(!_.isUndefined(configObject)){_adapterConfigObject=configObject;}while(index<_adapterConfigObject.length){var adaptrObjConf=_adapterConfigObject[index];var adaptrObjConfConds=adaptrObjConf.conditions;if(adaptrObjConfConds){var condKeys=_.keys(adaptrObjConfConds)[0];if(_.indexOf(OP_ARRAY,condKeys)>=0){verdict=_traverseQueryTree(adaptrObjConfConds,sourceObject)[0];}else{verdict=_evaluateLeafNodes(adaptrObjConfConds,sourceObject);}}if(verdict){break;}index++;}var verdictObj={};verdictObj.index=index;verdictObj.verdict=verdict;return verdictObj;};/**\n * @param {Object} sourceObject - source object\n * @param {Object} verdictObj - verdict object\n *\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */var _getAdoptees=function(sourceObject,verdictObj){var deferred=AwPromiseService.instance.defer();var allAdoptees=[];if(verdictObj.verdict){var targetProp=_adapterConfigObject[verdictObj.index].target;if(targetProp.prop){var adaptedObjs=sourceObject.props[targetProp.prop];if(adaptedObjs instanceof Array&&adaptedObjs.length>0){allAdoptees=allAdoptees.concat(adaptedObjs);}else if(adaptedObjs){allAdoptees.push(adaptedObjs);}}if((targetProp.method||targetProp.methodAsync)&&targetProp.deps){moduleLoader.loadDependentModule(targetProp.deps).then(function(depModuleObj){// _deps will be undefined when try to load adapterService inside itself\nvar _depModuleObj=depModuleObj;if(!depModuleObj&&targetProp.deps==='js/adapterService'){_depModuleObj=exports;}if(targetProp.method){var ret=_depModuleObj[targetProp.method].apply(_depModuleObj,[allAdoptees]);deferred.resolve(ret);}else{var retPromise=_depModuleObj[targetProp.methodAsync].apply(_depModuleObj,[allAdoptees]);retPromise.then(function(response){deferred.resolve(response);},function(error){deferred.reject(error);});}});}else{deferred.resolve(allAdoptees);}}else{allAdoptees.push(sourceObject);deferred.resolve(allAdoptees);}return deferred.promise;};/**\n * private object, not exposed out of service This is placeholder of two functions\n */var _logicalOperator={};/**\n * This takes array of boolean values and evaluate it in AND mode.\n *\n * @param {Object} values - values\n * @return {boolean} verdict\n */_logicalOperator.$and=function(values){assert(values instanceof Array,'Values is not an array');var verdict=true;_.forEach(values,function(val){if(!val){verdict=false;return false;// to break the loop, not return value\n}});return verdict;};/**\n * This takes array of boolean values and evaluate it in OR mode\n *\n * @param {Object} values - values\n * @return {Boolean} verdict\n */_logicalOperator.$or=function(values){assert(values instanceof Array,'Values is not an array');var verdict=false;_.forEach(values,function(val){if(val){verdict=true;return false;// to break the loop, not return value\n}});return verdict;};/**\n *\n * This method traverses the adapter condition file recursively to evaluate it against the source object\n *\n * @param {Object} rootObj - root object\n * @param {Object} sourceObject - source object\n * @return {Array} values\n */var _traverseQueryTree=function(rootObj,sourceObject){var values=[];_.forEach(rootObj,function(childObj,logicalOps){if(_.indexOf(OP_ARRAY,logicalOps)>=0){assert(childObj instanceof Array,'The value of and/or logical operators should be in Array');values.push(_logicalOperator[logicalOps](_traverseQueryTree(childObj,sourceObject)));}else if(_.intersection(OP_ARRAY,_.keys(childObj)).length>0){values=values.concat(_traverseQueryTree(childObj,sourceObject));}else{var val=_evaluateLeafNodes(childObj,sourceObject);if(!_.isUndefined(val)){values.push(val);}}});return values;};/**\n * @param {Object} leafNode - leaf node\n * @param {Object} sourceObject - source object\n * @return {Boolean|null} TRUE if conditions are valid\n */var _evaluateLeafNodes=function(leafNode,sourceObject){var propKey=_.keys(leafNode)[0];assert(_.indexOf(OP_ARRAY,propKey)<0,'These are not the leaf level nodes to evaluate');if(_.indexOf(OP_ARRAY,propKey)<0){var propRealValue=_.get(sourceObject,propKey);var condition=_.get(leafNode,propKey);var condKey=_.keys(condition)[0];var condVal=_.get(condition,condKey);var compareToKey=propKey+'@'+condKey;// modelType.typeHierarchy@$in\nvar compareTo={};compareTo[compareToKey]=condVal;if(!_conditionQuickEval[compareToKey]){_conditionQuickEval[compareToKey]=expressionParserUtils.getEvaluationFn(condKey,propKey,compareTo);}return _conditionQuickEval[compareToKey](condVal,propRealValue);}return null;};/**\n * Retrieves the adapted object recursively.\n *\n * @param {*} sourceObject - source object\n * @param {*} isFullyAdapted - if object should be recursively adapted\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */var _getAdaptedObjectSource=function(sourceObject,isFullyAdapted){var deferred=AwPromiseService.instance.defer();var adaptedReturnObjects=[];var verdictObject=exports.applyConditions(sourceObject);if(verdictObject.verdict){var adaptedObjectPromise=_getAdoptees(sourceObject,verdictObject);adaptedObjectPromise.then(function(adaptedObjects){if(isFullyAdapted){var deferredPromises=[];_.forEach(adaptedObjects,function(adaptedObject){deferredPromises.push(_getAdaptedObjectSource(adaptedObject,isFullyAdapted));});AwPromiseService.instance.all(deferredPromises).then(function(results){_.forEach(results,function(result){adaptedReturnObjects=adaptedReturnObjects.concat(result);});deferred.resolve(adaptedReturnObjects);});}else{deferred.resolve(adaptedObjects);}});}else{adaptedReturnObjects.push(sourceObject);deferred.resolve(adaptedReturnObjects);}return deferred.promise;};exports={getAdaptedObjectsSync,getAdaptedObjects,setConfiguration,applyConditions};export default exports;","map":null,"metadata":{},"sourceType":"module"}