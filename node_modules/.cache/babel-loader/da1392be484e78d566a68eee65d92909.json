{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do debugging.\n *\n * @module js/breakpointService\n * @namespace breakpointService\n */\n\n/**\n *  Below is the sample input for breakpoints.\n */\nlet sampleInput = {\n  b1: {\n    lifeCycles: {\n      vmName0: ['init', 'mount'],\n      vmName1: ['destroy']\n    },\n    actions: {\n      vmName0: {\n        actionId0: ['pre'],\n        actionId1: ['post']\n      }\n    },\n    globalEvents: {\n      'aw.include': {\n        data1: 'data1',\n        data2: 'data2'\n      },\n      'aw.*': {\n        data1: 'data1',\n        data2: 'data2'\n      }\n    },\n    ctx: {\n      'aw.test': ['register', 'unregister', 'modify']\n    },\n    commands: ['cm1', 'cmd2']\n  },\n  b2: {\n    lifeCycles: {\n      vmName0: ['init', 'mount'],\n      vmName1: ['destroy']\n    },\n    actions: {\n      vmName0: {\n        actionId0: ['pre'],\n        actionId1: ['post']\n      }\n    },\n    globalEvents: {\n      'aw.include': {\n        data1: 'data1',\n        data2: 'data2'\n      },\n      'aw.*': {\n        data1: 'data1',\n        data2: 'data2'\n      }\n    },\n    ctx: {\n      'aw.test': ['register', 'unregister', 'modify']\n    }\n  }\n};\nlet breakpointsModel = {};\nlet optBrkModel = new Map();\nlet enableBrkPoints = true;\nlet isUnminified = /comment/.test(function () {\n  /*\n      comment\n  */\n});\n/**\n *\n * @param {*} isEnable boolean true or false to enable or disable the breakpoint.\n */\n\nexport let enableBreakPoints = isEnable => {\n  enableBrkPoints = isEnable;\n};\n/**\n *  This function is used to give back all the exiting breakpoints\n *  to the chrome extension to re-generate the breakpoint UI.\n *  @returns {*} returns the breakPoinModel Object.\n */\n\nexport let getAllBreakPoints = () => {\n  return breakpointsModel;\n};\n/**\n * This is a immutable function, which takes two array merge them, remove the\n * duplicates and return a new array.\n * @param {*} array1 The first input array. The array should only contain strings.\n * @param {*} array2 The second input array. The array should only contain strings.\n * @returns {*} a new concatinated array.\n */\n\nlet mergeAndRemoveDuplicates = (array1, array2) => {\n  let concatArray = [...array1, ...array2];\n  return concatArray.reduce((finalArray, item) => {\n    if (finalArray.includes(item)) {\n      return finalArray;\n    }\n\n    return [...finalArray, item];\n  }, []);\n};\n/**\n *\n * @param {*} model  The input model\n * @param {*} holder the holder object\n */\n\n\nlet processInputModel = (model, holder) => {\n  let keys = Object.keys(model);\n  keys.forEach(key => {\n    let objValue = model[key] instanceof Array ? model[key] : [model[key]];\n\n    if (!holder.has(key)) {\n      holder.set(key, objValue);\n    } else {\n      let srcValue = holder.get(key);\n      let finalArray = mergeAndRemoveDuplicates(srcValue, objValue);\n      holder.set(key, finalArray);\n    }\n  });\n};\n/**\n *\n * @param {*} structure The input structure for breakpoints.\n */\n\n\nexport let addBreakPoint = structure => {\n  Object.keys(structure).forEach(breakPointName => {\n    breakpointsModel[breakPointName] = structure[breakPointName];\n  });\n  generateOptimizedModel();\n};\n/**\n * This API is to remove the breakpoint.\n * @param {*} breakPointName name of the breakpoint\n */\n\nexport let removeBreakPoint = breakPointName => {\n  if (breakpointsModel[breakPointName]) {\n    delete breakpointsModel[breakPointName];\n    generateOptimizedModel();\n  }\n};\nexport let removeAllBreakPoints = () => {\n  breakpointsModel = {};\n  generateOptimizedModel();\n};\n/**\n * This API should be used to check if any condtion\n * matches with any exisitng breakpoint condtions.\n *\n * @param {*} breakpointType Name of the breakpoint type\n * @param  {...any} args This differs for breakpoint types\n * @returns {true/false} boolean\n */\n\nexport let hasConditionSatisfied = function (breakpointType) {\n  let isCondMatched = false;\n  let eventName;\n  let actionId;\n  let stage;\n  let panelId;\n  let ctxKey;\n  let commandName;\n  let fromState;\n  let toState;\n  let dataParserId;\n\n  if (!isUnminified || !enableBrkPoints) {\n    return false;\n  }\n\n  switch (breakpointType) {\n    case 'lifeCycles':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      stage = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('lifeCycles') ? optBrkModel.get('lifeCycles').breakPointCondSatisfied(panelId, stage) : false;\n      break;\n\n    case 'actions':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      actionId = arguments.length <= 2 ? undefined : arguments[2];\n      stage = arguments.length <= 3 ? undefined : arguments[3];\n      isCondMatched = optBrkModel.has('actions') ? optBrkModel.get('actions').breakPointCondSatisfied(panelId, actionId, stage) : false;\n      break;\n\n    case 'events':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      eventName = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('events') ? optBrkModel.get('events').breakPointCondSatisfied(panelId, eventName) : false;\n      break;\n\n    case 'dataParsers':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      dataParserId = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('dataParsers') ? optBrkModel.get('dataParsers').breakPointCondSatisfied(panelId, dataParserId) : false;\n      break;\n\n    case 'globalEvents':\n      eventName = arguments.length <= 1 ? undefined : arguments[1];\n      isCondMatched = optBrkModel.has('globalEvents') ? optBrkModel.get('globalEvents').breakPointCondSatisfied(eventName) : false;\n      break;\n\n    case 'ctx':\n      ctxKey = arguments.length <= 1 ? undefined : arguments[1];\n      stage = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('ctx') ? optBrkModel.get('ctx').breakPointCondSatisfied(ctxKey, stage) : false;\n      break;\n\n    case 'commands':\n      commandName = arguments.length <= 1 ? undefined : arguments[1];\n      isCondMatched = optBrkModel.has('commands') ? optBrkModel.get('commands').breakPointCondSatisfied(commandName) : false;\n      break;\n\n    case 'routes':\n      fromState = arguments.length <= 1 ? undefined : arguments[1];\n      toState = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('routes') ? optBrkModel.get('routes').breakPointCondSatisfied(fromState, toState) : false;\n      break;\n  }\n\n  return isCondMatched;\n};\n/**\n * This optimized model holds a class object (singleton class) against every breakpoint type.\n * example\n *      {\n *          \"lifeCycles\" : new LifeCycleModel(),\n *          \"actions\" : new ActionModel(),\n *          \"globalEvents\" : new GlobalEventsModel(),\n *          \"ctx\" : new CtxModel() *\n *       }\n */\n\nlet generateOptimizedModel = () => {\n  let breakPointTypes = ['lifeCycles', 'actions', 'globalEvents', 'ctx', 'commands', 'events', 'routes', 'dataParsers'];\n  /**\n   *  Whenever we re-generate the optimized view-model\n   *  we should take care to clear all the exiting breakpoints.\n   */\n\n  for (let breakPointType of breakPointTypes) {\n    if (optBrkModel.has(breakPointType)) {\n      // Every class from optBrkModel.get( breakPointType ) has clear() method implemented.\n      optBrkModel.get(breakPointType).clearConditions();\n    }\n  }\n\n  for (let breakPointName in breakpointsModel) {\n    let breakPointObj = breakpointsModel[breakPointName];\n\n    for (let breakPointType of breakPointTypes) {\n      switch (breakPointType) {\n        case 'lifeCycles':\n          generateLifeCycleModel(breakPointObj.lifeCycles);\n          break;\n\n        case 'actions':\n          generateActionModel(breakPointObj.actions);\n          break;\n\n        case 'globalEvents':\n          generateGlobalEventsModel(breakPointObj.globalEvents);\n          break;\n\n        case 'events':\n          generateEventModel(breakPointObj.events);\n          break;\n\n        case 'dataParsers':\n          generateDataParserModel(breakPointObj.dataParsers);\n          break;\n\n        case 'ctx':\n          generateCtxModel(breakPointObj.ctx);\n          break;\n\n        case 'commands':\n          generateCommandsModel(breakPointObj.commands);\n          break;\n\n        case 'routes':\n          generateRoutesModel(breakPointObj.routes);\n          break;\n      }\n    }\n  }\n};\n/**\n * This is a singleton 'lifeCycles' class, which holds all the breakpoint\n * information related to lifecycles for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n *  @param {*} model the input model to create breakpoints for viewmodel lifeCycle.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n *\n */\n\n\nlet generateLifeCycleModel = model => {\n  class LifeCycleModel {\n    constructor() {\n      if (LifeCycleModel.instance) {\n        return LifeCycleModel.instance;\n      }\n\n      LifeCycleModel.instance = this;\n      this.holder = new Map();\n      return this;\n    }\n\n    addInput(lifeCycleInput) {\n      processInputModel(lifeCycleInput, this.holder);\n    }\n\n    hasPanelId(panelId) {\n      return this.holder.has(panelId);\n    }\n\n    getStage(panelId) {\n      return this.holder.get(panelId);\n    }\n\n    breakPointCondSatisfied(panelId, stage) {\n      if (this.hasPanelId(panelId)) {\n        return this.holder.get(panelId).includes(stage);\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('lifeCycles')) {\n    optBrkModel.set('lifeCycles', new LifeCycleModel());\n  }\n\n  if (model) {\n    optBrkModel.get('lifeCycles').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for viewmodel actions.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateActionModel = model => {\n  class ActionModel {\n    constructor() {\n      if (ActionModel.instance) {\n        return ActionModel.instance;\n      }\n\n      ActionModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(actionInputModel) {\n      let panelNames = Object.keys(actionInputModel);\n\n      for (let panelName of panelNames) {\n        if (!this.modelHolder.has(panelName)) {\n          let actionModel = new Map();\n          let actionObj = actionInputModel[panelName];\n          Object.keys(actionObj).forEach(actionName => {\n            let actionStage = actionObj[actionName] instanceof Array ? actionObj[actionName] : [actionObj[actionName]];\n            actionModel.set(actionName, actionStage);\n          });\n          this.modelHolder.set(panelName, actionModel);\n        } else {\n          let srcActionModel = this.modelHolder.get(panelName);\n          let newActionModel = actionInputModel[panelName];\n          processInputModel(newActionModel, srcActionModel);\n        }\n      }\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasActionId(panelId, actionId) {\n      if (this.modelHolder.has(panelId)) {\n        return this.modelHolder.get(panelId).has(actionId);\n      }\n\n      return false;\n    }\n\n    breakPointCondSatisfied(panelId, actionId, stage) {\n      if (this.hasActionId(panelId, actionId)) {\n        return this.modelHolder.get(panelId).get(actionId).includes(stage);\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('actions')) {\n    optBrkModel.set('actions', new ActionModel());\n  }\n\n  if (model) {\n    optBrkModel.get('actions').addInput(model);\n  }\n};\n\nlet generateEventModel = model => {\n  class EventModel {\n    constructor() {\n      if (EventModel.instance) {\n        return EventModel.instance;\n      }\n\n      EventModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(eventInputModel) {\n      processInputModel(eventInputModel, this.modelHolder);\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasEventName(panelId, eventName) {\n      try {\n        if (this.hasPanelId(panelId)) {\n          let eventNames = this.modelHolder.get(panelId); // If user provides an incorrect regular expression\n          // the RegExp constructor throws an exception.\n          // We do not want to throw any exception due to user error\n          // hence, eating up the exception and throwing false.\n          //let regexp = RegExp( eventName, 'g' );\n          //return eventNames.some( e => regexp.test( e ) );\n\n          return eventNames.some(e => {\n            try {\n              let regexp = RegExp(e, 'g');\n              return regexp.test(eventName);\n            } catch (e) {\n              return false;\n            }\n          });\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(panelId, eventName) {\n      return this.hasEventName(panelId, eventName);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('events')) {\n    optBrkModel.set('events', new EventModel());\n  }\n\n  if (model) {\n    optBrkModel.get('events').addInput(model);\n  }\n};\n\nlet generateDataParserModel = model => {\n  class DataParserModel {\n    constructor() {\n      if (DataParserModel.instance) {\n        return DataParserModel.instance;\n      }\n\n      DataParserModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(eventInputModel) {\n      processInputModel(eventInputModel, this.modelHolder);\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasDataParser(panelId, dataParserId) {\n      try {\n        if (this.hasPanelId(panelId)) {\n          let dataParsers = this.modelHolder.get(panelId); // If user provides an incorrect regular expression\n          // the RegExp constructor throws an exception.\n          // We do not want to throw any exception due to user error\n          // hence, eating up the exception and throwing false.\n          //let regexp = RegExp( eventName, 'g' );\n          //return eventNames.some( e => regexp.test( e ) );\n\n          return dataParsers.some(e => {\n            try {\n              let regexp = RegExp(e, 'g');\n              return regexp.test(dataParserId);\n            } catch (e) {\n              return false;\n            }\n          });\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(panelId, dataParserId) {\n      return this.hasDataParser(panelId, dataParserId);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('dataParsers')) {\n    optBrkModel.set('dataParsers', new DataParserModel());\n  }\n\n  if (model) {\n    optBrkModel.get('dataParsers').addInput(model);\n  }\n};\n/**\n * This is a singleton 'globalEvents' class, which holds all the breakpoint\n * information related to global events for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n * @param {*} model\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateGlobalEventsModel = model => {\n  class GlobalEventsModel {\n    constructor() {\n      if (GlobalEventsModel.instance) {\n        return GlobalEventsModel.instance;\n      }\n\n      GlobalEventsModel.instance = this; // ModelHolder is not being used currently. It would be used\n      // once we provide the support for matching the eventData\n\n      this.modelHolder = new Map();\n      this.eventNames = [];\n      return this;\n    }\n\n    addInput(GlobalEventsModel) {\n      Object.keys(GlobalEventsModel).forEach(eventName => {\n        let eventData = GlobalEventsModel[eventName];\n        this.modelHolder.set(eventName, eventData);\n        this.eventNames.push(eventName);\n      });\n    }\n\n    hasEventName(eventName) {\n      try {\n        // If user provides an incorrect regular expression\n        // the RegExp constructor throws an exception.\n        // We do not want to throw any exception due to user error\n        // hence, eating up the exception and throwing false.\n        return this.eventNames.some(e => {\n          try {\n            let regexp = RegExp(e, 'g');\n            return regexp.test(eventName);\n          } catch (e) {\n            return false;\n          }\n        });\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(eventName) {\n      return this.hasEventName(eventName);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n      this.eventNames.length = 0;\n    }\n\n  }\n\n  if (!optBrkModel.has('globalEvents')) {\n    optBrkModel.set('globalEvents', new GlobalEventsModel());\n  }\n\n  if (model) {\n    optBrkModel.get('globalEvents').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for app context changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateCtxModel = model => {\n  class CtxModel {\n    constructor() {\n      if (CtxModel.instance) {\n        return CtxModel.instance;\n      }\n\n      CtxModel.instance = this;\n      this.holder = new Map();\n      this.ctxKeys = [];\n      return this;\n    }\n\n    addInput(ctxInput) {\n      processInputModel(ctxInput, this.holder);\n      Object.keys(ctxInput).forEach(ctxkey => {\n        this.ctxKeys.push(ctxkey);\n      });\n    }\n\n    hasCtxKey(userKey, stage) {\n      try {\n        let userKeyExist = ctxKey => {\n          try {\n            let regexp = RegExp(ctxKey, 'g');\n            return regexp.test(userKey);\n          } catch {\n            return false;\n          }\n        };\n\n        if (this.ctxKeys.some(userKeyExist)) {\n          return this.holder.get(userKey).includes(stage);\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    getStage(panelId) {\n      return this.holder.get(panelId);\n    }\n\n    breakPointCondSatisfied(ctxKey, stage) {\n      return this.hasCtxKey(ctxKey, stage);\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('ctx')) {\n    optBrkModel.set('ctx', new CtxModel());\n  }\n\n  if (model) {\n    optBrkModel.get('ctx').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for commands.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateCommandsModel = model => {\n  class CommandsModel {\n    constructor() {\n      if (CommandsModel.instance) {\n        return CommandsModel.instance;\n      }\n\n      CommandsModel.instance = this;\n      this.holder = [];\n      return this;\n    }\n\n    addInput(commands) {\n      if (commands instanceof Array) {\n        this.holder = [...this.holder, ...commands];\n      }\n\n      this.holder.push(commands);\n    }\n\n    hasCommandName(commandName) {\n      return this.holder.includes(commandName);\n    }\n\n    breakPointCondSatisfied(commandName) {\n      return this.hasCommandName(commandName);\n    }\n\n    clearConditions() {\n      this.holder.length = 0;\n    }\n\n  }\n\n  if (!optBrkModel.has('commands')) {\n    optBrkModel.set('commands', new CommandsModel());\n  }\n\n  if (model) {\n    optBrkModel.get('commands').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for route changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateRoutesModel = model => {\n  class RoutesModel {\n    constructor() {\n      if (RoutesModel.instance) {\n        return RoutesModel.instance;\n      }\n\n      RoutesModel.instance = this;\n      this.holder = new Map();\n      return this;\n    }\n\n    addInput(model) {\n      Object.keys(model).forEach(fromState => {\n        let toState = model[fromState] ? model[fromState] : null;\n        this.holder.set(fromState, toState);\n      });\n    }\n\n    breakPointCondSatisfied(fromState, toState) {\n      if (this.holder.has(fromState)) {\n        if (!this.holder.get(fromState)) {\n          return true;\n        }\n\n        return this.holder.get(fromState) === toState;\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('routes')) {\n    optBrkModel.set('routes', new RoutesModel());\n  }\n\n  if (model) {\n    optBrkModel.get('routes').addInput(model);\n  }\n};\n\nlet breakpointSvc = {\n  addBreakPoint,\n  removeBreakPoint,\n  removeAllBreakPoints,\n  hasConditionSatisfied,\n  enableBreakPoints,\n  getAllBreakPoints\n};\nexport default breakpointSvc;\nwindow.breakpointSvc = breakpointSvc;","map":{"version":3,"names":["sampleInput","b1","lifeCycles","vmName0","vmName1","actions","actionId0","actionId1","globalEvents","data1","data2","ctx","commands","b2","breakpointsModel","optBrkModel","Map","enableBrkPoints","isUnminified","test","enableBreakPoints","isEnable","getAllBreakPoints","mergeAndRemoveDuplicates","array1","array2","concatArray","reduce","finalArray","item","includes","processInputModel","model","holder","keys","Object","forEach","key","objValue","Array","has","set","srcValue","get","addBreakPoint","structure","breakPointName","generateOptimizedModel","removeBreakPoint","removeAllBreakPoints","hasConditionSatisfied","breakpointType","isCondMatched","eventName","actionId","stage","panelId","ctxKey","commandName","fromState","toState","dataParserId","breakPointCondSatisfied","breakPointTypes","breakPointType","clearConditions","breakPointObj","generateLifeCycleModel","generateActionModel","generateGlobalEventsModel","generateEventModel","events","generateDataParserModel","dataParsers","generateCtxModel","generateCommandsModel","generateRoutesModel","routes","LifeCycleModel","constructor","instance","addInput","lifeCycleInput","hasPanelId","getStage","clear","ActionModel","modelHolder","actionInputModel","panelNames","panelName","actionModel","actionObj","actionName","actionStage","srcActionModel","newActionModel","hasActionId","EventModel","eventInputModel","hasEventName","eventNames","some","e","regexp","RegExp","DataParserModel","hasDataParser","GlobalEventsModel","eventData","push","length","CtxModel","ctxKeys","ctxInput","ctxkey","hasCtxKey","userKey","userKeyExist","CommandsModel","hasCommandName","RoutesModel","breakpointSvc","window"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/breakpointService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do debugging.\n *\n * @module js/breakpointService\n * @namespace breakpointService\n */\n\n/**\n *  Below is the sample input for breakpoints.\n */\nlet sampleInput = {\n    b1: {\n        lifeCycles: {\n            vmName0: [ 'init', 'mount' ],\n            vmName1: [ 'destroy' ]\n        },\n        actions: {\n            vmName0: {\n                actionId0: [ 'pre' ],\n                actionId1: [ 'post' ]\n            }\n        },\n        globalEvents: {\n            'aw.include': {\n                data1: 'data1',\n                data2: 'data2'\n            },\n            'aw.*': {\n                data1: 'data1',\n                data2: 'data2'\n            }\n        },\n        ctx: {\n            'aw.test': [ 'register', 'unregister', 'modify' ]\n        },\n        commands: [ 'cm1', 'cmd2' ]\n    },\n\n    b2: {\n        lifeCycles: {\n            vmName0: [ 'init', 'mount' ],\n            vmName1: [ 'destroy' ]\n        },\n        actions: {\n            vmName0: {\n                actionId0: [ 'pre' ],\n                actionId1: [ 'post' ]\n            }\n        },\n        globalEvents: {\n            'aw.include': {\n                data1: 'data1',\n                data2: 'data2'\n            },\n            'aw.*': {\n                data1: 'data1',\n                data2: 'data2'\n            }\n        },\n        ctx: {\n            'aw.test': [ 'register', 'unregister', 'modify' ]\n        }\n    }\n};\n\nlet breakpointsModel = {};\nlet optBrkModel = new Map();\nlet enableBrkPoints = true;\n\nlet isUnminified = /comment/.test( function() {\n    /*\n        comment\n    */\n} );\n\n/**\n *\n * @param {*} isEnable boolean true or false to enable or disable the breakpoint.\n */\nexport let enableBreakPoints = ( isEnable ) => {\n    enableBrkPoints = isEnable;\n};\n\n/**\n *  This function is used to give back all the exiting breakpoints\n *  to the chrome extension to re-generate the breakpoint UI.\n *  @returns {*} returns the breakPoinModel Object.\n */\nexport let getAllBreakPoints = () => {\n    return breakpointsModel;\n};\n/**\n * This is a immutable function, which takes two array merge them, remove the\n * duplicates and return a new array.\n * @param {*} array1 The first input array. The array should only contain strings.\n * @param {*} array2 The second input array. The array should only contain strings.\n * @returns {*} a new concatinated array.\n */\nlet mergeAndRemoveDuplicates = ( array1, array2 ) => {\n    let concatArray = [ ...array1, ...array2 ];\n    return concatArray.reduce( ( finalArray, item ) => {\n        if( finalArray.includes( item ) ) {\n            return finalArray;\n        }\n        return [ ...finalArray, item ];\n    }, [] );\n};\n\n/**\n *\n * @param {*} model  The input model\n * @param {*} holder the holder object\n */\nlet processInputModel = ( model, holder ) => {\n    let keys = Object.keys( model );\n    keys.forEach( ( key ) => {\n        let objValue = model[ key ] instanceof Array ? model[ key ] : [ model[ key ] ];\n        if( !holder.has( key ) ) {\n            holder.set( key, objValue );\n        } else {\n            let srcValue = holder.get( key );\n            let finalArray = mergeAndRemoveDuplicates( srcValue, objValue );\n            holder.set( key, finalArray );\n        }\n    } );\n};\n\n/**\n *\n * @param {*} structure The input structure for breakpoints.\n */\nexport let addBreakPoint = ( structure ) => {\n    Object.keys( structure ).forEach( ( breakPointName ) => {\n        breakpointsModel[ breakPointName ] = structure[ breakPointName ];\n    } );\n    generateOptimizedModel();\n};\n\n/**\n * This API is to remove the breakpoint.\n * @param {*} breakPointName name of the breakpoint\n */\nexport let removeBreakPoint = ( breakPointName ) => {\n    if( breakpointsModel[ breakPointName ] ) {\n        delete breakpointsModel[ breakPointName ];\n        generateOptimizedModel();\n    }\n};\n\nexport let removeAllBreakPoints = () => {\n    breakpointsModel = {};\n    generateOptimizedModel();\n};\n\n/**\n * This API should be used to check if any condtion\n * matches with any exisitng breakpoint condtions.\n *\n * @param {*} breakpointType Name of the breakpoint type\n * @param  {...any} args This differs for breakpoint types\n * @returns {true/false} boolean\n */\nexport let hasConditionSatisfied = ( breakpointType, ...args ) => {\n    let isCondMatched = false;\n    let eventName;\n    let actionId;\n    let stage;\n    let panelId;\n    let ctxKey;\n    let commandName;\n    let fromState;\n    let toState;\n    let dataParserId;\n    if( !isUnminified || !enableBrkPoints ) {\n        return false;\n    }\n    switch ( breakpointType ) {\n        case 'lifeCycles':\n            panelId = args[ 0 ];\n            stage = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'lifeCycles' ) ?\n                optBrkModel.get( 'lifeCycles' ).breakPointCondSatisfied( panelId, stage ) : false;\n            break;\n\n        case 'actions':\n            panelId = args[ 0 ];\n            actionId = args[ 1 ];\n            stage = args[ 2 ];\n            isCondMatched = optBrkModel.has( 'actions' ) ?\n                optBrkModel.get( 'actions' ).breakPointCondSatisfied( panelId, actionId, stage ) : false;\n            break;\n\n        case 'events':\n            panelId = args[ 0 ];\n            eventName = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'events' ) ?\n                optBrkModel.get( 'events' ).breakPointCondSatisfied( panelId, eventName ) : false;\n            break;\n\n        case 'dataParsers':\n            panelId = args[ 0 ];\n            dataParserId = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'dataParsers' ) ?\n                optBrkModel.get( 'dataParsers' ).breakPointCondSatisfied( panelId, dataParserId ) : false;\n            break;\n\n        case 'globalEvents':\n            eventName = args[ 0 ];\n            isCondMatched = optBrkModel.has( 'globalEvents' ) ?\n                optBrkModel.get( 'globalEvents' ).breakPointCondSatisfied( eventName ) : false;\n            break;\n\n        case 'ctx':\n            ctxKey = args[ 0 ];\n            stage = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'ctx' ) ?\n                optBrkModel.get( 'ctx' ).breakPointCondSatisfied( ctxKey, stage ) : false;\n            break;\n\n        case 'commands':\n            commandName = args[ 0 ];\n            isCondMatched = optBrkModel.has( 'commands' ) ?\n                optBrkModel.get( 'commands' ).breakPointCondSatisfied( commandName ) : false;\n            break;\n\n        case 'routes':\n            fromState = args[ 0 ];\n            toState = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'routes' ) ?\n                optBrkModel.get( 'routes' ).breakPointCondSatisfied( fromState, toState ) : false;\n            break;\n    }\n    return isCondMatched;\n};\n\n/**\n * This optimized model holds a class object (singleton class) against every breakpoint type.\n * example\n *      {\n *          \"lifeCycles\" : new LifeCycleModel(),\n *          \"actions\" : new ActionModel(),\n *          \"globalEvents\" : new GlobalEventsModel(),\n *          \"ctx\" : new CtxModel() *\n *       }\n */\nlet generateOptimizedModel = () => {\n    let breakPointTypes = [ 'lifeCycles', 'actions', 'globalEvents', 'ctx', 'commands', 'events', 'routes', 'dataParsers' ];\n    /**\n     *  Whenever we re-generate the optimized view-model\n     *  we should take care to clear all the exiting breakpoints.\n     */\n    for( let breakPointType of breakPointTypes ) {\n        if( optBrkModel.has( breakPointType ) ) {\n            // Every class from optBrkModel.get( breakPointType ) has clear() method implemented.\n            optBrkModel.get( breakPointType ).clearConditions();\n        }\n    }\n\n    for( let breakPointName in breakpointsModel ) {\n        let breakPointObj = breakpointsModel[ breakPointName ];\n        for( let breakPointType of breakPointTypes ) {\n            switch ( breakPointType ) {\n                case 'lifeCycles':\n                    generateLifeCycleModel( breakPointObj.lifeCycles );\n                    break;\n                case 'actions':\n                    generateActionModel( breakPointObj.actions );\n                    break;\n                case 'globalEvents':\n                    generateGlobalEventsModel( breakPointObj.globalEvents );\n                    break;\n                case 'events':\n                    generateEventModel( breakPointObj.events );\n                    break;\n                case 'dataParsers':\n                    generateDataParserModel( breakPointObj.dataParsers );\n                    break;\n                case 'ctx':\n                    generateCtxModel( breakPointObj.ctx );\n                    break;\n                case 'commands':\n                    generateCommandsModel( breakPointObj.commands );\n                    break;\n                case 'routes':\n                    generateRoutesModel( breakPointObj.routes );\n                    break;\n            }\n        }\n    }\n};\n\n/**\n * This is a singleton 'lifeCycles' class, which holds all the breakpoint\n * information related to lifecycles for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n *  @param {*} model the input model to create breakpoints for viewmodel lifeCycle.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n *\n */\nlet generateLifeCycleModel = ( model ) => {\n    class LifeCycleModel {\n        constructor() {\n            if( LifeCycleModel.instance ) {\n                return LifeCycleModel.instance;\n            }\n            LifeCycleModel.instance = this;\n            this.holder = new Map();\n            return this;\n        }\n        addInput( lifeCycleInput ) {\n            processInputModel( lifeCycleInput, this.holder );\n        }\n        hasPanelId( panelId ) {\n            return this.holder.has( panelId );\n        }\n        getStage( panelId ) {\n            return this.holder.get( panelId );\n        }\n        breakPointCondSatisfied( panelId, stage ) {\n            if( this.hasPanelId( panelId ) ) {\n                return this.holder.get( panelId ).includes( stage );\n            }\n            return false;\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'lifeCycles' ) ) {\n        optBrkModel.set( 'lifeCycles', new LifeCycleModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'lifeCycles' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for viewmodel actions.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateActionModel = ( model ) => {\n    class ActionModel {\n        constructor() {\n            if( ActionModel.instance ) {\n                return ActionModel.instance;\n            }\n            ActionModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( actionInputModel ) {\n            let panelNames = Object.keys( actionInputModel );\n            for( let panelName of panelNames ) {\n                if( !this.modelHolder.has( panelName ) ) {\n                    let actionModel = new Map();\n                    let actionObj = actionInputModel[ panelName ];\n                    Object.keys( actionObj ).forEach( ( actionName ) => {\n                        let actionStage = actionObj[ actionName ] instanceof Array ? actionObj[ actionName ] : [ actionObj[ actionName ] ];\n                        actionModel.set( actionName, actionStage );\n                    } );\n                    this.modelHolder.set( panelName, actionModel );\n                } else {\n                    let srcActionModel = this.modelHolder.get( panelName );\n                    let newActionModel = actionInputModel[ panelName ];\n                    processInputModel( newActionModel, srcActionModel );\n                }\n            }\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n\n        hasActionId( panelId, actionId ) {\n            if( this.modelHolder.has( panelId ) ) {\n                return this.modelHolder.get( panelId ).has( actionId );\n            }\n            return false;\n        }\n\n        breakPointCondSatisfied( panelId, actionId, stage ) {\n            if( this.hasActionId( panelId, actionId ) ) {\n                return this.modelHolder.get( panelId ).get( actionId ).includes( stage );\n            }\n            return false;\n        }\n\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'actions' ) ) {\n        optBrkModel.set( 'actions', new ActionModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'actions' ).addInput( model );\n    }\n};\n\nlet generateEventModel = ( model ) => {\n    class EventModel {\n        constructor() {\n            if( EventModel.instance ) {\n                return EventModel.instance;\n            }\n            EventModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( eventInputModel ) {\n            processInputModel( eventInputModel, this.modelHolder );\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n        hasEventName( panelId, eventName ) {\n            try {\n                if( this.hasPanelId( panelId ) ) {\n                    let eventNames = this.modelHolder.get( panelId );\n                    // If user provides an incorrect regular expression\n                    // the RegExp constructor throws an exception.\n                    // We do not want to throw any exception due to user error\n                    // hence, eating up the exception and throwing false.\n                    //let regexp = RegExp( eventName, 'g' );\n                    //return eventNames.some( e => regexp.test( e ) );\n                    return eventNames.some( e => {\n                        try {\n                            let regexp = RegExp( e, 'g' );\n                            return regexp.test( eventName );\n                        } catch ( e ) {\n                            return false;\n                        }\n                    } );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        breakPointCondSatisfied( panelId, eventName ) {\n            return this.hasEventName( panelId, eventName );\n        }\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'events' ) ) {\n        optBrkModel.set( 'events', new EventModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'events' ).addInput( model );\n    }\n};\n\nlet generateDataParserModel = ( model ) => {\n    class DataParserModel {\n        constructor() {\n            if( DataParserModel.instance ) {\n                return DataParserModel.instance;\n            }\n            DataParserModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( eventInputModel ) {\n            processInputModel( eventInputModel, this.modelHolder );\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n        hasDataParser( panelId, dataParserId ) {\n            try {\n                if( this.hasPanelId( panelId ) ) {\n                    let dataParsers = this.modelHolder.get( panelId );\n                    // If user provides an incorrect regular expression\n                    // the RegExp constructor throws an exception.\n                    // We do not want to throw any exception due to user error\n                    // hence, eating up the exception and throwing false.\n                    //let regexp = RegExp( eventName, 'g' );\n                    //return eventNames.some( e => regexp.test( e ) );\n                    return dataParsers.some( e => {\n                        try {\n                            let regexp = RegExp( e, 'g' );\n                            return regexp.test( dataParserId );\n                        } catch ( e ) {\n                            return false;\n                        }\n                    } );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        breakPointCondSatisfied( panelId, dataParserId ) {\n            return this.hasDataParser( panelId, dataParserId );\n        }\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'dataParsers' ) ) {\n        optBrkModel.set( 'dataParsers', new DataParserModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'dataParsers' ).addInput( model );\n    }\n};\n\n/**\n * This is a singleton 'globalEvents' class, which holds all the breakpoint\n * information related to global events for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n * @param {*} model\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateGlobalEventsModel = ( model ) => {\n    class GlobalEventsModel {\n        constructor() {\n            if( GlobalEventsModel.instance ) {\n                return GlobalEventsModel.instance;\n            }\n            GlobalEventsModel.instance = this;\n            // ModelHolder is not being used currently. It would be used\n            // once we provide the support for matching the eventData\n            this.modelHolder = new Map();\n            this.eventNames = [];\n            return this;\n        }\n        addInput( GlobalEventsModel ) {\n            Object.keys( GlobalEventsModel ).forEach( ( eventName ) => {\n                let eventData = GlobalEventsModel[ eventName ];\n                this.modelHolder.set( eventName, eventData );\n                this.eventNames.push( eventName );\n            } );\n        }\n        hasEventName( eventName ) {\n            try {\n                // If user provides an incorrect regular expression\n                // the RegExp constructor throws an exception.\n                // We do not want to throw any exception due to user error\n                // hence, eating up the exception and throwing false.\n                return this.eventNames.some( e => {\n                    try {\n                        let regexp = RegExp( e, 'g' );\n                        return regexp.test( eventName );\n                    } catch ( e ) {\n                        return false;\n                    }\n                } );\n            } catch ( e ) {\n                return false;\n            }\n        }\n\n        breakPointCondSatisfied( eventName ) {\n            return this.hasEventName( eventName );\n        }\n\n        clearConditions() {\n            this.modelHolder.clear();\n            this.eventNames.length = 0;\n        }\n    }\n\n    if( !optBrkModel.has( 'globalEvents' ) ) {\n        optBrkModel.set( 'globalEvents', new GlobalEventsModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'globalEvents' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for app context changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateCtxModel = ( model ) => {\n    class CtxModel {\n        constructor() {\n            if( CtxModel.instance ) {\n                return CtxModel.instance;\n            }\n            CtxModel.instance = this;\n            this.holder = new Map();\n            this.ctxKeys = [];\n            return this;\n        }\n        addInput( ctxInput ) {\n            processInputModel( ctxInput, this.holder );\n            Object.keys( ctxInput ).forEach( ( ctxkey ) => {\n                this.ctxKeys.push( ctxkey );\n            } );\n        }\n        hasCtxKey( userKey, stage ) {\n            try {\n                let userKeyExist = ( ctxKey ) => {\n                    try {\n                        let regexp = RegExp( ctxKey, 'g' );\n                        return regexp.test( userKey );\n                    } catch {\n                        return false;\n                    }\n                };\n                if( this.ctxKeys.some( userKeyExist ) ) {\n                    return this.holder.get( userKey ).includes( stage );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        getStage( panelId ) {\n            return this.holder.get( panelId );\n        }\n        breakPointCondSatisfied( ctxKey, stage ) {\n            return this.hasCtxKey( ctxKey, stage );\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'ctx' ) ) {\n        optBrkModel.set( 'ctx', new CtxModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'ctx' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for commands.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateCommandsModel = ( model ) => {\n    class CommandsModel {\n        constructor() {\n            if( CommandsModel.instance ) {\n                return CommandsModel.instance;\n            }\n            CommandsModel.instance = this;\n            this.holder = [];\n            return this;\n        }\n        addInput( commands ) {\n            if( commands instanceof Array ) {\n                this.holder = [ ...this.holder, ...commands ];\n            }\n            this.holder.push( commands );\n        }\n        hasCommandName( commandName ) {\n            return this.holder.includes( commandName );\n        }\n        breakPointCondSatisfied( commandName ) {\n            return this.hasCommandName( commandName );\n        }\n        clearConditions() {\n            this.holder.length = 0;\n        }\n    }\n    if( !optBrkModel.has( 'commands' ) ) {\n        optBrkModel.set( 'commands', new CommandsModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'commands' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for route changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateRoutesModel = ( model ) => {\n    class RoutesModel {\n        constructor() {\n            if( RoutesModel.instance ) {\n                return RoutesModel.instance;\n            }\n            RoutesModel.instance = this;\n            this.holder = new Map();\n            return this;\n        }\n        addInput( model ) {\n            Object.keys( model ).forEach( ( fromState ) => {\n                let toState = model[ fromState ] ? model[ fromState ] : null;\n                this.holder.set( fromState, toState );\n            } );\n        }\n        breakPointCondSatisfied( fromState, toState ) {\n            if( this.holder.has( fromState ) ) {\n                if( !this.holder.get( fromState ) ) {\n                    return true;\n                }\n                return this.holder.get( fromState ) === toState;\n            }\n            return false;\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'routes' ) ) {\n        optBrkModel.set( 'routes', new RoutesModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'routes' ).addInput( model );\n    }\n};\n\nlet breakpointSvc = {\n    addBreakPoint,\n    removeBreakPoint,\n    removeAllBreakPoints,\n    hasConditionSatisfied,\n    enableBreakPoints,\n    getAllBreakPoints\n};\nexport default breakpointSvc;\nwindow.breakpointSvc = breakpointSvc;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}