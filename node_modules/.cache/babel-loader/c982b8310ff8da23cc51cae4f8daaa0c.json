{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context\n *\n * @publishedApolloService\n *\n * @module js/conditionService\n */import _ from'lodash';import logger from'js/logger';import eventBus from'js/eventBus';import debugService from'js/debugService';import AwParseService from'js/awParseService';import adapterService from'js/adapterService';import expressionParserUtils from'js/expressionParserUtils';var exports={};/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Any} The evaluated expression result.\n */export let parseExpression=function(declViewModel,expression,evaluationEnv,depModuleObj){var evaluationContext={};_.assign(evaluationContext,declViewModel,evaluationEnv,depModuleObj);if(_.isObject(expression)){// loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values\nvar updatedExpression=expressionParserUtils.updateDynamicValues(expression,evaluationContext);return expressionParserUtils.evaluateExpressions(updatedExpression,evaluationContext,adapterService);}return AwParseService.instance(expression)(evaluationContext);};/**\n * Evaluate condition expression and ensure a boolean is returned\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Boolean} The evaluated condition result.\n */export let evaluateCondition=function(declViewModel,expression,evaluationEnv,depModuleObj){return Boolean(exports.parseExpression(declViewModel,expression,evaluationEnv,depModuleObj));};const _evaluateConditionBasedExpression=function(condition,declViewModel,evaluateDepParams){var finalConditionExpression;if(_.startsWith(condition,'conditions.')){if(declViewModel._internal){finalConditionExpression=_.get(declViewModel._internal,condition);}else{finalConditionExpression=_.get(evaluateDepParams.conditionList,condition);}}// for condition\": 'ctx.xyz || ctx.abc' or condition\": '!ctx.xyz' or condition\": '!conditions.xyz'\nif(finalConditionExpression===undefined){finalConditionExpression=condition;}else if(finalConditionExpression.expression){finalConditionExpression=finalConditionExpression.expression;}if(evaluateDepParams){return evaluateCondition(declViewModel,finalConditionExpression,evaluateDepParams.evaluationEnv,evaluateDepParams.depModuleObj);}return evaluateCondition(declViewModel,finalConditionExpression);};/**\n * Evaluate all variants of condition\n *\n * @param {String} condition - condition to evaluate\n * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object\n * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb\n *                                {Object} conditionList- Conditions object of viewmodel\n *                                {String} clauseName -\"activewhen\",\"visiblewhen\"\n *                                {Object} evaluationEnv -specific data required for this call like ctx.\n *                                {Object} depModuleObj\n * @return {Boolean} return true, if expression evalutes to true.\n */export let evaluateConditionExpression=function(condition,declViewModel,evaluateDepParams){if(evaluateDepParams&&typeof condition[evaluateDepParams.clauseName]==='boolean'){return condition[evaluateDepParams.clauseName];/*\n         *    activewhen: true\n         */}else if(evaluateDepParams&&condition[evaluateDepParams.clauseName]){condition=_.get(condition,evaluateDepParams.clauseName+'.condition');if(typeof condition==='boolean'){return condition;}}if(condition&&condition.length){/*\n          evaluate * conditions expression\n          *: {\n              condition: \"conditions.xyz\"\n          }\n          */return _evaluateConditionBasedExpression(condition,declViewModel,evaluateDepParams);}return false;};/**\n * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of\n * the condition differs from the old value\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} queries - The array of objects containing query definitions\n * @param {Array} values - The array of objects of changed value to be used for each of the query object\n * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage\n * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed\n * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.\n * @param {Object} trackValues - Whether or not to track expression value changes.\n */let processWatch=function(conditionStates,conditionName,queries,values,adaptExpressions,performAnd,conditionExpressions,trackValues,viewModelName){var oldValue=conditionStates[conditionName];var newValue=queries.reduce(function(prevVerdict,currQuery,queryIndex){var verdict;var valuesToUse=values[queryIndex];if(currQuery&&_.isObject(currQuery)&&values&&values.length===queries.length){// determine whether object requires to be adapted\nif(adaptExpressions[queryIndex]){var valuesToAdapt=_.isArray(valuesToUse)?valuesToUse:[valuesToUse];valuesToUse=adapterService.getAdaptedObjectsSync(valuesToAdapt);}// expression is an object, hence process the query object inside it\nverdict=expressionParserUtils.evaluateExpressions(currQuery,valuesToUse,adapterService);}else{// expression is simple string with boolean result\nverdict=Boolean(values&&valuesToUse);}var newExpressionValue=valuesToUse;var conditionVal;if(conditionExpressions){conditionVal=conditionExpressions[conditionName];}if(trackValues&&conditionExpressions&&conditionVal[0]!==newExpressionValue){eventBus.publish('condition.expressionValueChanged',{condition:'conditions.'+conditionName,oldValue:conditionExpressions[conditionName],newValue:newExpressionValue});}return performAnd?prevVerdict&&verdict:prevVerdict||verdict;},performAnd);if(logger.isDeclarativeLogEnabled()){debugService.debugConditions(conditionName,newValue,queries,viewModelName);}if(oldValue!==newValue){eventBus.publish('condition.valueChanged',{condition:'conditions.'+conditionName,oldValue:oldValue,newValue:newValue});}};/**\n * Register a watch for given expression on provided scope and update conditionStates[conditionName] when\n * expression's value changes.\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} expressions - Array of expression to be watched for value change.\n * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.\n * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression\n * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback\n * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not\n * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing\n */export let registerWatch=function(conditionStates,dataCtxNode,conditionName,expressions,conditionExpressions,queries,adaptExpressions,deepWatch,performAnd){if(!queries){var watchQueryAdaptInfo={watchers:[],queries:[],adapt:[]};var multiAttributeANDExpression;var multiAttributeORExpression;_.forEach(expressions,function(expr){multiAttributeANDExpression=expr[expressionParserUtils.$AND];multiAttributeORExpression=expr[expressionParserUtils.$OR];var expressionsFinal=multiAttributeANDExpression||multiAttributeORExpression||expressions;_.forEach(expressionsFinal,function(finalExpr){var sourceToWatch=expressionParserUtils.resolve(expressionParserUtils.$SOURCE,finalExpr);var needsToAdapt=sourceToWatch&&sourceToWatch[expressionParserUtils.$ADAPT];sourceToWatch=needsToAdapt||sourceToWatch||finalExpr;var executeQuery=expressionParserUtils.resolve(expressionParserUtils.$QUERY,finalExpr);watchQueryAdaptInfo.watchers.push(sourceToWatch);watchQueryAdaptInfo.queries.push(executeQuery||finalExpr);watchQueryAdaptInfo.adapt.push(Boolean(needsToAdapt));});});exports.registerWatch(conditionStates,dataCtxNode,conditionName,watchQueryAdaptInfo.watchers,conditionExpressions,watchQueryAdaptInfo.queries,watchQueryAdaptInfo.adapt,true,multiAttributeANDExpression);}else{// process expressions, queries and adaptExpressions array\nvar dynamicValueResolvedQueries=queries.map(function(query){return expressionParserUtils.updateDynamicValues(query,dataCtxNode);});// revisitme Charu - add support for trackChanges\nprocessWatch(conditionStates,conditionName,dynamicValueResolvedQueries,dataCtxNode.expressions[conditionName],adaptExpressions,performAnd,conditionExpressions,dataCtxNode.declViewModelJson.conditions[conditionName].trackValues,dataCtxNode.declViewModelJson._viewModelId);}};/**\n * Expand a string based expression to include nested conditions\n *\n * @param {String} expression - a string expression to evaluate\n * @param {Object} internalViewModel - the object containing other expressions\n * @returns {String} the new string expression\n */export let getRealExpression=function(expression,internalViewModel){//Since getRealExpression() api operates on string expressions, object types should be filtered.\nif(_.isString(expression)){var conditionIndex=expression.indexOf('conditions.');if(conditionIndex>-1){var substring=expression.substring(conditionIndex);var endConditionIndex=substring.search('[^a-zA-Z0-9._]');endConditionIndex=endConditionIndex>-1?conditionIndex+endConditionIndex:expression.length;var referenceCondition=expression.substring(conditionIndex,endConditionIndex);var evaluatedCondition=_.get(internalViewModel,referenceCondition)||{};var returnExpression=null;if(_.isString(evaluatedCondition.expression)){returnExpression=expression.replace(referenceCondition,'('+evaluatedCondition.expression+')');}else{return evaluatedCondition.expression;}return getRealExpression(returnExpression,internalViewModel);}return expression;}return undefined;};exports={parseExpression,registerWatch,evaluateCondition,evaluateConditionExpression,getRealExpression};export default exports;","map":null,"metadata":{},"sourceType":"module"}