{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/* eslint-disable require-jsdoc */\n\n/* eslint-disable valid-jsdoc */\n\n/**\n * aw Number and Currency Filter Service\n * Formats a number as text.\n * Formats a number as a currency (ie $1,234.56).\n * \n * @module js/awNumberAndCurrencyFilterService\n */\nconst NUMBER_FORMATS = {\n  CURRENCY_SYM: '$',\n  DECIMAL_SEP: '.',\n  GROUP_SEP: ',',\n  PATTERNS: [{\n    gSize: 3,\n    lgSize: 3,\n    maxFrac: 3,\n    minFrac: 0,\n    minInt: 1,\n    negPre: '-',\n    negSuf: '',\n    posPre: '',\n    posSuf: ''\n  }, {\n    gSize: 3,\n    lgSize: 3,\n    maxFrac: 2,\n    minFrac: 2,\n    minInt: 1,\n    negPre: '-\\u00a4',\n    negSuf: '',\n    posPre: '\\u00a4',\n    posSuf: ''\n  }]\n};\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changed the parsedNumber in-place\n */\n\n\nfunction roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {\n  var digits = parsedNumber.d;\n  var fractionLen = digits.length - parsedNumber.i; // determine fractionSize if it is not specified; `+fractionSize` converts it to a number\n\n  fractionSize = typeof fractionSize === 'undefined' ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : Number(fractionSize); // The index of the digit to where rounding is to occur\n\n  var roundAt = fractionSize + parsedNumber.i;\n  var digit = digits[roundAt];\n\n  if (roundAt > 0) {\n    // Drop fractional digits beyond `roundAt`\n    digits.splice(Math.max(parsedNumber.i, roundAt)); // Set non-fractional digits beyond `roundAt` to 0\n\n    for (var j = roundAt; j < digits.length; j++) {\n      digits[j] = 0;\n    }\n  } else {\n    // We rounded to zero so reset the parsedNumber\n    fractionLen = Math.max(0, fractionLen);\n    parsedNumber.i = 1;\n    digits.length = Math.max(1, roundAt = fractionSize + 1);\n    digits[0] = 0;\n\n    for (var i = 1; i < roundAt; i++) {\n      digits[i] = 0;\n    }\n  }\n\n  if (digit >= 5) {\n    if (roundAt - 1 < 0) {\n      for (var k = 0; k > roundAt; k--) {\n        digits.unshift(0);\n        parsedNumber.i++;\n      }\n\n      digits.unshift(1);\n      parsedNumber.i++;\n    } else {\n      digits[roundAt - 1]++;\n    }\n  } // Pad out with zeros to get the required fraction length\n\n\n  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) {\n    digits.push(0);\n  } // Do any carrying, e.g. a digit was rounded up to 10\n\n\n  var carry = digits.reduceRight(function (carry, d, i, digits) {\n    d += carry;\n    digits[i] = d % 10;\n    return Math.floor(d / 10);\n  }, 0);\n\n  if (carry) {\n    digits.unshift(carry);\n    parsedNumber.i++;\n  }\n}\n/**\n * Parse a number (as a string) into three components that can be used\n * for formatting the number.\n *\n * (Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/)\n *\n * @param  {string} numStr The number to parse\n * @return {object} An object describing this number, containing the following keys:\n *  - d : an array of digits containing leading zeros as necessary\n *  - i : the number of the digits in `d` that are to the left of the decimal point\n *  - e : the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n *\n */\n\n\nfunction parse(numStr) {\n  var exponent = 0;\n  var digits;\n  var numberOfIntegerDigits;\n  var i;\n  var j;\n  var zeros; // Decimal point?\n\n  if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {\n    numStr = numStr.replace(DECIMAL_SEP, '');\n  } // Exponential form?\n\n\n  if ((i = numStr.search(/e/i)) > 0) {\n    // Work out the exponent.\n    if (numberOfIntegerDigits < 0) {\n      numberOfIntegerDigits = i;\n    }\n\n    numberOfIntegerDigits += Number(numStr.slice(i + 1));\n    numStr = numStr.substring(0, i);\n  } else if (numberOfIntegerDigits < 0) {\n    // There was no decimal point or exponent so it is an integer.\n    numberOfIntegerDigits = numStr.length;\n  } // Count the number of leading zeros.\n\n\n  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {\n    /* empty */\n  }\n\n  if (i === (zeros = numStr.length)) {\n    // The digits are all zero.\n    digits = [0];\n    numberOfIntegerDigits = 1;\n  } else {\n    // Count the number of trailing zeros\n    zeros--;\n\n    while (numStr.charAt(zeros) === ZERO_CHAR) {\n      zeros--;\n    } // Trailing zeros are insignificant so ignore them\n\n\n    numberOfIntegerDigits -= i;\n    digits = []; // Convert string to array of digits without leading/trailing zeros.\n\n    for (j = 0; i <= zeros; i++, j++) {\n      digits[j] = Number(numStr.charAt(i));\n    }\n  } // If the number overflows the maximum allowed digits then use an exponent.\n\n\n  if (numberOfIntegerDigits > MAX_DIGITS) {\n    digits = digits.splice(0, MAX_DIGITS - 1);\n    exponent = numberOfIntegerDigits - 1;\n    numberOfIntegerDigits = 1;\n  }\n\n  return {\n    d: digits,\n    e: exponent,\n    i: numberOfIntegerDigits\n  };\n}\n/**\n * Format a number into a string\n * @param  {number} number       The number to format\n * @param  {{\n *           minFrac, // the minimum number of digits required in the fraction part of the number\n *           maxFrac, // the maximum number of digits required in the fraction part of the number\n *           gSize,   // number of digits in each group of separated digits\n *           lgSize,  // number of digits in the last group of digits before the decimal separator\n *           negPre,  // the string to go in front of a negative number (e.g. `-` or `(`))\n *           posPre,  // the string to go in front of a positive number\n *           negSuf,  // the string to go after a negative number (e.g. `)`)\n *           posSuf   // the string to go after a positive number\n *         }} pattern\n * @param  {string} groupSep The string to separate groups of number (e.g. `,`)\n * @param  {string} decimalSep The string to act as the decimal separator (e.g. `.`)\n * @param  {[type]} fractionSize The size of the fractional part of the number\n * @return {string} The number formatted as a string\n */\n\n\nfunction formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {\n  if (!(isString(number) || isNumber(number)) || isNaN(number)) {\n    return '';\n  }\n\n  var isInfinity = !isFinite(number);\n  var isZero = false;\n  var numStr = String(Math.abs(number));\n  var formattedText = '';\n  var parsedNumber;\n\n  if (isInfinity) {\n    formattedText = '\\u221e';\n  } else {\n    parsedNumber = parse(numStr);\n    roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);\n    var digits = parsedNumber.d;\n    var integerLen = parsedNumber.i;\n    var exponent = parsedNumber.e;\n    var decimals = [];\n    isZero = digits.reduce(function (isZero, d) {\n      return isZero && !d;\n    }, true); // pad zeros for small numbers\n\n    while (integerLen < 0) {\n      digits.unshift(0);\n      integerLen++;\n    } // extract decimals digits\n\n\n    if (integerLen > 0) {\n      decimals = digits.splice(integerLen, digits.length);\n    } else {\n      decimals = digits;\n      digits = [0];\n    } // format the integer digits with grouping separators\n\n\n    var groups = [];\n\n    if (digits.length >= pattern.lgSize) {\n      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));\n    }\n\n    while (digits.length > pattern.gSize) {\n      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));\n    }\n\n    if (digits.length) {\n      groups.unshift(digits.join(''));\n    }\n\n    formattedText = groups.join(groupSep); // append the decimal digits\n\n    if (decimals.length) {\n      formattedText += decimalSep + decimals.join('');\n    }\n\n    if (exponent) {\n      formattedText += 'e+' + exponent;\n    }\n  }\n\n  if (number < 0 && !isZero) {\n    return pattern.negPre + formattedText + pattern.negSuf;\n  }\n\n  return pattern.posPre + formattedText + pattern.posSuf;\n}\n\nfunction numberFilter(number, fractionSize) {\n  // if null or undefined pass it through\n  return number === null ? number : formatNumber(number, NUMBER_FORMATS.PATTERNS[0], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize);\n}\n\nfunction currencyFilter(amount, currencySymbol, fractionSize) {\n  if (typeof currencySymbol === 'undefined') {\n    currencySymbol = NUMBER_FORMATS.CURRENCY_SYM;\n  }\n\n  if (typeof fractionSize === 'undefined') {\n    fractionSize = NUMBER_FORMATS.PATTERNS[1].maxFrac;\n  } // If the currency symbol is empty, trim whitespace around the symbol\n\n\n  var currencySymbolRe = !currencySymbol ? /\\s*\\u00A4\\s*/g : /\\u00A4/g; // if null or undefined pass it through\n\n  return amount === null ? amount : formatNumber(amount, NUMBER_FORMATS.PATTERNS[1], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);\n}\n\nexport default {\n  numberFilter,\n  currencyFilter\n};","map":{"version":3,"names":["NUMBER_FORMATS","CURRENCY_SYM","DECIMAL_SEP","GROUP_SEP","PATTERNS","gSize","lgSize","maxFrac","minFrac","minInt","negPre","negSuf","posPre","posSuf","MAX_DIGITS","ZERO_CHAR","isString","value","isNumber","roundNumber","parsedNumber","fractionSize","digits","d","fractionLen","length","i","Math","min","max","Number","roundAt","digit","splice","j","k","unshift","push","carry","reduceRight","floor","parse","numStr","exponent","numberOfIntegerDigits","zeros","indexOf","replace","search","slice","substring","charAt","e","formatNumber","number","pattern","groupSep","decimalSep","isNaN","isInfinity","isFinite","isZero","String","abs","formattedText","integerLen","decimals","reduce","groups","join","numberFilter","currencyFilter","amount","currencySymbol","currencySymbolRe"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/awNumberAndCurrencyFilterService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n/* eslint-disable require-jsdoc */\n/* eslint-disable valid-jsdoc */\n\n/**\n * aw Number and Currency Filter Service\n * Formats a number as text.\n * Formats a number as a currency (ie $1,234.56).\n * \n * @module js/awNumberAndCurrencyFilterService\n */\n\nconst NUMBER_FORMATS = {\n    CURRENCY_SYM: '$',\n    DECIMAL_SEP: '.',\n    GROUP_SEP: ',',\n    PATTERNS: [ {\n            gSize: 3,\n            lgSize: 3,\n            maxFrac: 3,\n            minFrac: 0,\n            minInt: 1,\n            negPre: '-',\n            negSuf: '',\n            posPre: '',\n            posSuf: ''\n        },\n        {\n            gSize: 3,\n            lgSize: 3,\n            maxFrac: 2,\n            minFrac: 2,\n            minInt: 1,\n            negPre: '-\\u00a4',\n            negSuf: '',\n            posPre: '\\u00a4',\n            posSuf: ''\n        }\n    ]\n};\n\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\n\nfunction isString( value ) {\n    return typeof value === 'string';\n}\n\nfunction isNumber( value ) {\n    return typeof value === 'number';\n}\n\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changed the parsedNumber in-place\n */\nfunction roundNumber( parsedNumber, fractionSize, minFrac, maxFrac ) {\n    var digits = parsedNumber.d;\n    var fractionLen = digits.length - parsedNumber.i;\n\n    // determine fractionSize if it is not specified; `+fractionSize` converts it to a number\n    fractionSize = typeof fractionSize === 'undefined' ? Math.min( Math.max( minFrac, fractionLen ), maxFrac ) : Number( fractionSize );\n\n    // The index of the digit to where rounding is to occur\n    var roundAt = fractionSize + parsedNumber.i;\n    var digit = digits[ roundAt ];\n\n    if( roundAt > 0 ) {\n        // Drop fractional digits beyond `roundAt`\n        digits.splice( Math.max( parsedNumber.i, roundAt ) );\n\n        // Set non-fractional digits beyond `roundAt` to 0\n        for( var j = roundAt; j < digits.length; j++ ) {\n            digits[ j ] = 0;\n        }\n    } else {\n        // We rounded to zero so reset the parsedNumber\n        fractionLen = Math.max( 0, fractionLen );\n        parsedNumber.i = 1;\n        digits.length = Math.max( 1, roundAt = fractionSize + 1 );\n        digits[ 0 ] = 0;\n        for( var i = 1; i < roundAt; i++ ) {\n            digits[ i ] = 0;\n        }\n    }\n\n    if( digit >= 5 ) {\n        if( roundAt - 1 < 0 ) {\n            for( var k = 0; k > roundAt; k-- ) {\n                digits.unshift( 0 );\n                parsedNumber.i++;\n            }\n            digits.unshift( 1 );\n            parsedNumber.i++;\n        } else {\n            digits[ roundAt - 1 ]++;\n        }\n    }\n\n    // Pad out with zeros to get the required fraction length\n    for( ; fractionLen < Math.max( 0, fractionSize ); fractionLen++ ) {\n        digits.push( 0 );\n    }\n    // Do any carrying, e.g. a digit was rounded up to 10\n    var carry = digits.reduceRight( function( carry, d, i, digits ) {\n        d += carry;\n        digits[ i ] = d % 10;\n        return Math.floor( d / 10 );\n    }, 0 );\n    if( carry ) {\n        digits.unshift( carry );\n        parsedNumber.i++;\n    }\n}\n\n/**\n * Parse a number (as a string) into three components that can be used\n * for formatting the number.\n *\n * (Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/)\n *\n * @param  {string} numStr The number to parse\n * @return {object} An object describing this number, containing the following keys:\n *  - d : an array of digits containing leading zeros as necessary\n *  - i : the number of the digits in `d` that are to the left of the decimal point\n *  - e : the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n *\n */\nfunction parse( numStr ) {\n    var exponent = 0;\n    var digits;\n    var numberOfIntegerDigits;\n    var i;\n    var j;\n    var zeros;\n\n    // Decimal point?\n    if( ( numberOfIntegerDigits = numStr.indexOf( DECIMAL_SEP ) ) > -1 ) {\n        numStr = numStr.replace( DECIMAL_SEP, '' );\n    }\n\n    // Exponential form?\n    if( ( i = numStr.search( /e/i ) ) > 0 ) {\n        // Work out the exponent.\n        if( numberOfIntegerDigits < 0 ) {\n            numberOfIntegerDigits = i;\n        }\n        numberOfIntegerDigits += Number( numStr.slice( i + 1 ) );\n        numStr = numStr.substring( 0, i );\n    } else if( numberOfIntegerDigits < 0 ) {\n        // There was no decimal point or exponent so it is an integer.\n        numberOfIntegerDigits = numStr.length;\n    }\n\n    // Count the number of leading zeros.\n    for( i = 0; numStr.charAt( i ) === ZERO_CHAR; i++ ) { /* empty */ }\n\n    if( i === ( zeros = numStr.length ) ) {\n        // The digits are all zero.\n        digits = [ 0 ];\n        numberOfIntegerDigits = 1;\n    } else {\n        // Count the number of trailing zeros\n        zeros--;\n        while( numStr.charAt( zeros ) === ZERO_CHAR ) { zeros--; }\n\n        // Trailing zeros are insignificant so ignore them\n        numberOfIntegerDigits -= i;\n        digits = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for( j = 0; i <= zeros; i++, j++ ) {\n            digits[ j ] = Number( numStr.charAt( i ) );\n        }\n    }\n\n    // If the number overflows the maximum allowed digits then use an exponent.\n    if( numberOfIntegerDigits > MAX_DIGITS ) {\n        digits = digits.splice( 0, MAX_DIGITS - 1 );\n        exponent = numberOfIntegerDigits - 1;\n        numberOfIntegerDigits = 1;\n    }\n\n    return { d: digits, e: exponent, i: numberOfIntegerDigits };\n}\n/**\n * Format a number into a string\n * @param  {number} number       The number to format\n * @param  {{\n *           minFrac, // the minimum number of digits required in the fraction part of the number\n *           maxFrac, // the maximum number of digits required in the fraction part of the number\n *           gSize,   // number of digits in each group of separated digits\n *           lgSize,  // number of digits in the last group of digits before the decimal separator\n *           negPre,  // the string to go in front of a negative number (e.g. `-` or `(`))\n *           posPre,  // the string to go in front of a positive number\n *           negSuf,  // the string to go after a negative number (e.g. `)`)\n *           posSuf   // the string to go after a positive number\n *         }} pattern\n * @param  {string} groupSep The string to separate groups of number (e.g. `,`)\n * @param  {string} decimalSep The string to act as the decimal separator (e.g. `.`)\n * @param  {[type]} fractionSize The size of the fractional part of the number\n * @return {string} The number formatted as a string\n */\nfunction formatNumber( number, pattern, groupSep, decimalSep, fractionSize ) {\n    if( !( isString( number ) || isNumber( number ) ) || isNaN( number ) ) { return ''; }\n\n    var isInfinity = !isFinite( number );\n    var isZero = false;\n    var numStr = String( Math.abs( number ) );\n    var formattedText = '';\n    var parsedNumber;\n\n    if( isInfinity ) {\n        formattedText = '\\u221e';\n    } else {\n        parsedNumber = parse( numStr );\n\n        roundNumber( parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac );\n\n        var digits = parsedNumber.d;\n        var integerLen = parsedNumber.i;\n        var exponent = parsedNumber.e;\n        var decimals = [];\n        isZero = digits.reduce( function( isZero, d ) { return isZero && !d; }, true );\n\n        // pad zeros for small numbers\n        while( integerLen < 0 ) {\n            digits.unshift( 0 );\n            integerLen++;\n        }\n\n        // extract decimals digits\n        if( integerLen > 0 ) {\n            decimals = digits.splice( integerLen, digits.length );\n        } else {\n            decimals = digits;\n            digits = [ 0 ];\n        }\n\n        // format the integer digits with grouping separators\n        var groups = [];\n        if( digits.length >= pattern.lgSize ) {\n            groups.unshift( digits.splice( -pattern.lgSize, digits.length ).join( '' ) );\n        }\n        while( digits.length > pattern.gSize ) {\n            groups.unshift( digits.splice( -pattern.gSize, digits.length ).join( '' ) );\n        }\n        if( digits.length ) {\n            groups.unshift( digits.join( '' ) );\n        }\n        formattedText = groups.join( groupSep );\n\n        // append the decimal digits\n        if( decimals.length ) {\n            formattedText += decimalSep + decimals.join( '' );\n        }\n\n        if( exponent ) {\n            formattedText += 'e+' + exponent;\n        }\n    }\n    if( number < 0 && !isZero ) {\n        return pattern.negPre + formattedText + pattern.negSuf;\n    }\n    return pattern.posPre + formattedText + pattern.posSuf;\n}\n\nfunction numberFilter( number, fractionSize ) {\n    // if null or undefined pass it through\n    return number === null ? number : formatNumber( number, NUMBER_FORMATS.PATTERNS[ 0 ], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP,\n        fractionSize );\n}\n\nfunction currencyFilter( amount, currencySymbol, fractionSize ) {\n    if( typeof currencySymbol === 'undefined' ) {\n        currencySymbol = NUMBER_FORMATS.CURRENCY_SYM;\n    }\n\n    if( typeof fractionSize === 'undefined' ) {\n        fractionSize = NUMBER_FORMATS.PATTERNS[ 1 ].maxFrac;\n    }\n\n    // If the currency symbol is empty, trim whitespace around the symbol\n    var currencySymbolRe = !currencySymbol ? /\\s*\\u00A4\\s*/g : /\\u00A4/g;\n\n    // if null or undefined pass it through\n    return amount === null ? amount : formatNumber( amount, NUMBER_FORMATS.PATTERNS[ 1 ], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize ).replace( currencySymbolRe, currencySymbol );\n}\n\nexport default {\n    numberFilter,\n    currencyFilter\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}