{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * @module js/awSplitterService\n */ // module\nimport eventBus from'js/eventBus';import localStorage from'js/localStorage';import logger from'js/logger';import _ from'lodash';import analyticsSvc from'js/analyticsService';let exports;export const constants={minSize1:20,minSize2:20};// A structure set when a splitter is activated (only one splitter an be active at any time)\n// See exports.mouseDownEvent for structure definition\nexport let activeSplitterData=null;let splitterAction=null;// Tell the world the areas have changed size through a debounce function.\nlet publishNotification=_.debounce(function(splitterData,area1,area2){splitterAction&&splitterAction({splitter:splitterData.splitter,area1:area1,area2:area2});eventBus.publish('aw-splitter-update',{splitter:splitterData.splitter,area1:area1,area2:area2});},1000,{maxWait:20000,trailing:true,leading:false});/**\n * Method to publish analytics to server\n * @param {Number} area1Size - size of area1 in the UI (in pixels)\n * @param {Number} area2Size - size of area2 in the UI (in pixels)\n */const publishAnalytics=(area1Size,area2Size)=>{let splitterEventData={};splitterEventData.sanAnalyticsType='Splitter';splitterEventData.sanCommandId='Splitter';splitterEventData.sanCommandTitle='Splitter';splitterEventData.sanPrimaryPercentage=(area1Size/(area1Size+area2Size)*100).toFixed(2);splitterEventData.sanPixelSize=area1Size;analyticsSvc.logCommands(splitterEventData);};/**\n * Initialize a Given Splitter\n *\n * Set the onmousedown event for the splitter and establishes the type of splitter\n *\n * @param {object} elementRefList - The elements used to define the splitter\n * @param {object} prop - The React props defined on the splitter\n * @param {object} viewMode - The current viewMode on time on init\n */export const initSplitter=(elementRefList,prop,viewMode)=>{let attributes=prop;var initialSplitterState;let splitter=elementRefList.get('splitter').current;var area1=splitter.previousElementSibling;var area2=splitter.nextElementSibling;if(!area1&&!area2){// xrt-splitter\nlet colSplit=splitter.closest('.aw-xrt-columnContentPanel');if(colSplit){area1=colSplit.previousElementSibling;area2=colSplit.nextElementSibling;colSplit.style['min-width']='16px';colSplit.style.width='16px';colSplit.style['max-width']='16px';colSplit.style.padding='0px';colSplit.style.overflow='hidden';colSplit.parentElement.style.flexWrap='nowrap';colSplit.parentElement.style.height='100%';colSplit.parentElement.parentElement.style.height='100%';area1.style.minWidth='0px';area2.style.minWidth='0px';splitter.style.height=window.getComputedStyle(colSplit).getPropertyValue('height');}}// If user defines a direction use that. If not, check for row/column on each side. Else default to vertical\nif(attributes.direction&&attributes.direction.toUpperCase()==='HORIZONTAL'){splitter.style.cursor='row-resize';}else{splitter.style.cursor='col-resize';}splitter.onmousedown=event=>exports.mouseDownEvent(event,prop.action);splitter.ontouchstart=event=>exports.mouseDownEvent(event,prop.action);// If this is the primary sash, load its previous position for a specific view.\nif(attributes.isPrimarySplitter==='true'){if(viewMode){exports.viewModeContext=viewMode;}if(localStorage.get(exports.viewModeContext)){initialSplitterState=JSON.parse(localStorage.get(exports.viewModeContext));if(initialSplitterState&&area1&&area2){area1.style.flexBasis=initialSplitterState.area1Size+'px';area1.style.webkitFlexBasis=initialSplitterState.area1Size+'px';area1.style.flexGrow='1';area1.style.flexShrink='1';area2.style.flexBasis=initialSplitterState.area2Size+'px';area2.style.webkitFlexBasis=initialSplitterState.area2Size+'px';}}}};// Setup mousemove/mouseup event listeners for iframes\nlet bubbleIframeMouseMove=function(iframe){var existingOnMouseMove=iframe.contentWindow.onmousemove;iframe.contentWindow.onmousemove=function(e){// Fire any existing onmousemove listener\nif(existingOnMouseMove){existingOnMouseMove(e);}var evt=document.createEvent('MouseEvents');var boundingClientRect=iframe.getBoundingClientRect();evt.initMouseEvent('mousemove',true,// true bubbles the event\nfalse,// not cancelable\nwindow,e.detail,e.screenX,e.screenY,e.clientX+boundingClientRect.left,e.clientY+boundingClientRect.top,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,null// no related element\n);iframe.dispatchEvent(evt);};iframe.contentWindow.onmouseup=function(e){var evt=document.createEvent('MouseEvents');var boundingClientRect=iframe.getBoundingClientRect();evt.initMouseEvent('mouseup',true,// true bubbles the event\nfalse,// not cancelable\nwindow,e.detail,e.screenX,e.screenY,e.clientX+boundingClientRect.left,e.clientY+boundingClientRect.top,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,null// no related element\n);iframe.dispatchEvent(evt);};};// Removes iframe mouse event listeners\nlet removebubbleIframeMouseEvent=function(iframe){iframe.contentWindow.onmousemove=null;iframe.contentWindow.onmouseup=null;};// handling DOM exception: if we try to access any event(e.g. onmouseup,onmousedown,etc) for cross-origin, we get DOM exception.\nlet canAccessIFrame=function(iframe){try{return'onmousemove'in iframe.contentWindow;}catch(err){return false;}};/**\n * Mouse Down Event - initialize the active splitter\n *\n * @param {object} event - mouse down event object\n */export let mouseDownEvent=function(event,action){// Do not allow accidental text selection - which will cause the splitter to lockup\n// Note that there are various CSS properties to control this but not a common one yet (as far as I can tell)\n// Look for user-select: none (also ms-user-select and webkit-user-select and moz-user-select)\n// Until there is a common way to prevent accidental selection - here is the workaround\nevent=event||window.event;if(window.getSelection){var selection=window.getSelection();var node=selection.focusNode;if(node!==null){selection.removeAllRanges();}}else{if(document.selection){document.selection.empty();}}event.stopPropagation();event.preventDefault();// Create the active splitter data structure\nvar x=event.clientX;var y=event.clientY;if(!x&&!y){x=event.touches[0].clientX;y=event.touches[0].clientY;}var splitter=event.currentTarget;var area1=splitter.previousElementSibling;var area2=splitter.nextElementSibling;if(!area1&&!area2){// xrt-splitter\nlet colSplit=splitter.closest('.aw-xrt-columnContentPanel');if(colSplit){area1=colSplit.previousElementSibling;area2=colSplit.nextElementSibling;}}var minSize1=parseInt(splitter.getAttribute('min-size-1'));var minSize2=parseInt(splitter.getAttribute('min-size-2'));var isPrimarySplitter=splitter.getAttribute('isPrimarySplitter');var viewMode=splitter.getAttribute('viewMode');// If user did not define minimum sizes, default to 20\nif(!minSize1&&!minSize2){minSize1=exports.constants.minSize1;minSize2=exports.constants.minSize2;}var direction=splitter.style.cursor;exports.activeSplitterData={splitter:splitter,// The splitter element\narea1:area1,// The element to the left or on top\narea2:area2,// The element to the right or on bottom\nminSize1:minSize1,// The element to the left or on top minimum length\nminSize2:minSize2,// The element to the right or on bottom minimum length\ndirection:direction,// row-resize or column-resize\nisPrimarySplitter:isPrimarySplitter,// If the current splitter is the primary to remember its position\nviewMode:viewMode,x:x,y:y};// Last mouse position used to update splitter\nsplitterAction=action;// iframes suppress mouse events so the iframe's mouse events need to be bubbled up to the document level\nvar iframes=document.getElementsByTagName('iframe');for(var i=0;i<iframes.length;i++){if(canAccessIFrame(iframes[i])){bubbleIframeMouseMove(iframes[i]);}}document.addEventListener('mousemove',mouseMoveEventHandler);document.addEventListener('mouseup',mouseUpEventHandler);document.addEventListener('touchmove',mouseMoveEventHandler);document.addEventListener('touchend',mouseUpEventHandler);document.addEventListener('touchcancel',mouseUpEventHandler);};/**\n * Mouse Up Event Handler - stop the active splitter\n *\n * @param {event} event - Event object\n */export let mouseUpEventHandler=function(){document.removeEventListener('mousemove',mouseMoveEventHandler);document.removeEventListener('mouseup',mouseUpEventHandler);document.removeEventListener('touchmove',mouseMoveEventHandler);document.removeEventListener('touchend',mouseUpEventHandler);document.removeEventListener('touchcancel',mouseUpEventHandler);// Remove iframe mouse event listeners on mouseup\nvar iframes=document.getElementsByTagName('iframe');for(var i=0;i<iframes.length;i++){if(canAccessIFrame(iframes[i])){removebubbleIframeMouseEvent(iframes[i]);}}// Remember the sash's position for the specific view.\nif(exports.activeSplitterData.viewMode){exports.viewModeContext=exports.activeSplitterData.viewMode;}if(exports.activeSplitterData.isPrimarySplitter&&exports.viewModeContext){// After moving the primary splitter, we want the primary workarea to become a flex-item in order to resize on browser width changes.\nexports.activeSplitterData.area1.style.flexGrow='1';exports.activeSplitterData.area1.style.flexShrink='1';var area1Size=exports.activeSplitterData.area1.clientWidth;var area2Size=exports.activeSplitterData.area2.clientWidth;var data={area1Size:area1Size,area2Size:area2Size};localStorage.publish(exports.viewModeContext,JSON.stringify(data));publishAnalytics(area1Size,area2Size);}exports.activeSplitterData=null;};/**\n * Mouse Move Event Handler - update the active splitter\n *\n * @param {event} event - Event object\n */export let mouseMoveEventHandler=function(event){event=event||window.event;if(exports.activeSplitterData===null){return;}event.preventDefault();var x=event.clientX;var y=event.clientY;if(!x&&!y){var touch=event.originalEvent.touches[0];x=touch.clientX;y=touch.clientY;}exports.updateActiveSplitter(x,y);};/**\n * Update Active Splitter\n *\n * For a given mouse position update the size of the associated DIV elements for the active splitter.\n *\n * @param {number} xPos - current mouse X position\n * @param {number} yPos - current mouse Y position\n */export let updateActiveSplitter=function(xPos,yPos){var splitterData=exports.activeSplitterData;if(!splitterData){return;}var xDelta=xPos-splitterData.x;var yDelta=yPos-splitterData.y;if(xDelta===0&&yDelta===0){return;}var area1=splitterData.area1;var area2=splitterData.area2;var minSize1=splitterData.minSize1;var minSize2=splitterData.minSize2;var size1=parseFloat(area1.style.flexGrow);var size2=parseFloat(area2.style.flexGrow);var direction=splitterData.direction;if(direction==='row-resize'){var h1=area1.clientHeight;var h2=area2.clientHeight;if(exports.splitterLimit(h1,h2,yDelta,minSize1,minSize2)){// make max size/min size if we hit the limit, not at the limit yet & not using flex grow\nif(!size1&&!size2){if(yDelta>0&&h2!==minSize2){exports.updateAreaSize(area1,size1,h1,h2-minSize2);exports.updateAreaSize(area2,size2,minSize2,'');}else if(yDelta<0&&h1!==minSize1){exports.updateAreaSize(area1,size1,minSize1,'');exports.updateAreaSize(area2,size2,h2,h1-minSize1);}splitterData.y=splitterData.splitter.getBoundingClientRect().top-10;splitterData.x=xPos;}return;}exports.updateAreaSize(area1,size1,h1,yDelta);exports.updateAreaSize(area2,size2,h2,-yDelta);}else{// direction is column-resize\nvar w1=area1.offsetWidth;var w2=area2.offsetWidth;if(exports.splitterLimit(w1,w2,xDelta,minSize1,minSize2)){// make max size/min size if we hit the limit, not at the limit yet & not using flex grow\nif(!size1&&!size2){if(xDelta>0&&w2!==minSize2){exports.updateAreaSize(area1,size1,w1,w2-minSize2);exports.updateAreaSize(area2,size2,minSize2,'');}else if(xDelta<0&&w1!==minSize1){exports.updateAreaSize(area1,size1,minSize1,'');exports.updateAreaSize(area2,size2,w2,w1-minSize1);}splitterData.x=splitterData.splitter.getBoundingClientRect().right-10;splitterData.y=yPos;}return;}exports.updateAreaSize(area1,size1,w1,xDelta);exports.updateAreaSize(area2,size2,w2,-xDelta);}splitterData.x=xPos;splitterData.y=yPos;publishNotification(splitterData,area1,area2);};/**\n * Update Area Size\n *\n * Update the size of a given area based on a delta amount and the type of area (fixed or proportional)\n *\n * @param {object} area - a row or column element\n * @param {number} oldSize - the previous attribute size value for the row or column\n * @param {number} oldSizePx - the previous rendered size in px for the row or column\n * @param {number} deltaPx - the amount to change the area in px\n */export let updateAreaSize=function(area,oldSize,oldSizePx,deltaPx){var newSizePx=oldSizePx+deltaPx;var when=area.getAttribute('when');// This is a fixed size\n// Note the size is no longer in units of em because the user has set a fix px size\nif(when){area.style.maxWidth='100%';}area.style.flexBasis=newSizePx.toString()+'px';area.style.webkitFlexBasis=newSizePx.toString()+'px';};/**\n * Splitter Limit - return true if a splitter has hit a limiting size\n *\n * Return true if the limit is being hit for one of the areas The test is done this way because it is possible for\n * areas to become smaller than the limit due to window resizing. We want to be able to grow areas that are too\n * small with a splitter but not continue to shrink those areas\n *\n * @param {number} size1 - Size (width or height) of left or top area for the active splitter\n * @param {number} size2 - Size (width or height) of right or bottom area for the active splitter\n * @param {number} delta - Amount the sizes are being changed\n * @param {number} minSize1 - Minimum size (width or height) of left or top area for the active splitter\n * @param {number} minSize2 - Minimum size (width or height) of right or bottom area for the active splitter\n *\n *\n * @return {boolean} - true if a limit would be hit by the delta change\n */export let splitterLimit=function(size1,size2,delta,minSize1,minSize2){if(delta>0){// The right or bottom area is being reduced in size\nif(size2-delta<minSize2){return true;}}else{// delta < 0 - the left or top area is being reduced in size\nif(size1+delta<minSize1){return true;}}return false;};/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */export let reportError=function(errorMessage){logger.warn('awSplitterService:'+errorMessage);};/**\n * Update viewMode based on context\n *\n * @param {string} viewModeKey - ctx key for viewMode\n * @returns {string} viewMode\n */export let updateViewMode=function(viewModeKey){return viewModeKey;};exports={constants,activeSplitterData,initSplitter,mouseDownEvent,mouseUpEventHandler,mouseMoveEventHandler,updateActiveSplitter,updateAreaSize,splitterLimit,reportError,updateViewMode};export default exports;","map":null,"metadata":{},"sourceType":"module"}