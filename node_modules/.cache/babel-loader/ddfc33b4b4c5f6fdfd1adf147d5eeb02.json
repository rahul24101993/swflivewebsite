{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * render function for AwBreadCrumb\n * @deprecated afx@4.2.0.\n * @alternative <br>\n * @obsoleteIn afx@5.1.0\n * @returns {JSX.Element} react component\n */import AwBreadcrumbItem from'viewmodel/AwNavigateBreadcrumbItemViewModel';import analyticsSvc from'js/analyticsService';import resizeObserverSvc from'js/resizeObserver.service';import _ from'lodash';import{jsx as _jsx}from\"react/jsx-runtime\";export const handleOverflow=(props,viewModel,elementRefList)=>{const{crumbs}=props;const{data,dispatch}=viewModel;const ref=elementRefList.get('breadcrumb');const calcOverflow=()=>{if(!ref.current.children){return;}let containerWidth=ref.current.parentContainer.clientWidth;const allChildren=ref.current.children.filter(x=>x).map(x=>x.clientWidth);const MARGIN=8;// default margin-right: 8px is for each crumb\nlet updatedState;if(allChildren&&allChildren.length){// check how much space each crumb takes in ui\nconst childrenTotalWidth=allChildren.reduce((total,width)=>total+width,0);if(containerWidth<childrenTotalWidth+MARGIN*allChildren.length){// need to check, how many crumbs come inside overflowChevron\ncontainerWidth-=allChildren[0]+MARGIN*allChildren.length;let overflowIndex=-1;for(let i=allChildren.length-1;i>0;i--){if(containerWidth<allChildren[i]){overflowIndex=i;break;}else{crumbs[i].visible=true;}containerWidth-=allChildren[i];}if(overflowIndex>-1){const overflowedCrumb=[];for(let i=1;i<=overflowIndex;i++){crumbs[i].visible=false;overflowedCrumb.push(crumbs[i]);}updatedState={index:overflowIndex,crumbs:overflowedCrumb};}else{updatedState={index:-1,crumbs:[]};}}else{updatedState={index:-1,crumbs:[]};}}if(updatedState){dispatch&&dispatch({path:'data.overflow',value:updatedState});}};if(data.overflow.index!==-1){dispatch&&dispatch({path:'data',value:{...data,resize:data.resize==='true'?'false':'true',overflow:{index:-1,crumbs:[]}}});}else{calcOverflow();}};export const attachResizeObserver=(viewModel,elementRefList)=>{const{dispatch}=viewModel;const ref=elementRefList.get('breadcrumb');const addResizeObserver=()=>{if(resizeObserverSvc.supportsResizeObserver()){const callback=_.debounce(()=>{if(ref.current.parentContainer){const data=viewModel.getData();dispatch&&dispatch({path:'data',value:{...data,resize:data.resize==='true'?'false':'true',overflow:{index:-1,crumbs:[]}}});}},200,{maxWait:1000,trailing:true,leading:false});ref.current.resizeObserver=resizeObserverSvc.observe(ref.current.parentContainer,callback);}};addResizeObserver();};export const onUnMount=elementRefList=>{// TODO: Future ref. not working as value of current updated in mount, not reflecting in unmount\nif(elementRefList){const ref=elementRefList.get('breadcrumb');ref.current&&ref.current.resizeObserver&&ref.current.resizeObserver();}};/**\n * Method to publish analytics to server\n * @param {*} crumbs - array of all the related crumbs\n * @param {*} index - index of the crumb whose checvron is clicked\n */const publishAnalytics=(crumbs,index)=>{let sanEvent={sanAnalyticsType:'Breadcrumb',sanCommandId:'clickBreadcrumbChevron',sanCommandTitle:crumbs[index].displayName};analyticsSvc.logCommands(sanEvent);};export const awNavigateBreadcrumbRenderFn=props=>{const{popuplist,crumbs,compact,viewModel:{data,dispatch}}=props;const ref=props.elementRefList.get('breadcrumb');const handleChevronClick=index=>{dispatch&&dispatch({path:'data.rotateChevronIndex',value:data.rotateChevronIndex===index?null:index});if(index!==-1){publishAnalytics(crumbs,index);}};const createCrumbs=bcCrumbs=>{if(bcCrumbs){const{overflow}=data;const attachingChildRef=(el,index)=>{if(!ref.current){ref.current={};}if(!ref.current.children){ref.current.children=[];}ref.current.children[index]=el;};bcCrumbs.forEach(c=>{c.visible=!(c.index<=overflow.index&&c.index!==0);});return bcCrumbs.map((crumb,index)=>{crumb.index=index;crumb.rotate=data.rotateChevronIndex===index?!crumb.rotate:false;let iconId=crumb.showArrow?'miscChevronRight':'';if(overflow.index>-1&&index===0){crumb.rotate=false;iconId='miscChevronLeftDouble';}if(crumb.visible===false){return null;}if(index===0){return/*#__PURE__*/_jsx(\"div\",{className:\"sw-breadcrumb-item\",ref:el=>attachingChildRef(el,index),children:/*#__PURE__*/_jsx(AwBreadcrumbItem,{crumb:crumb,popuplist:popuplist,chevronClick:handleChevronClick,iconId:iconId,overflowedCrumbs:overflow.crumbs})},crumb.displayName);}return/*#__PURE__*/_jsx(\"div\",{className:\"sw-breadcrumb-item\",ref:el=>attachingChildRef(el,index),children:/*#__PURE__*/_jsx(AwBreadcrumbItem,{crumb:crumb,popuplist:popuplist,chevronClick:handleChevronClick,iconId:iconId})},crumb.displayName);});}};const getClassNames=()=>{const classNames=['aw-layout-fxbreadCrumbs','aw-layout-flexColumn'];if(compact){classNames.push('aw-widgets-breadCrumbCompact');}return classNames.join(' ');};const attachingParentRef=el=>{if(!ref.current){ref.current={};}ref.current.parentContainer=el;};if(ref.current&&ref.current.resizeObserver===undefined){//if no observer attached, attach one\nattachResizeObserver(props.viewModel,props.elementRefList);}//If no crumbs defined, h1 remains empty so conditionally return h1\nreturn crumbs&&crumbs.length&&/*#__PURE__*/_jsx(\"h1\",{className:getClassNames(),ref:el=>attachingParentRef(el),children:/*#__PURE__*/_jsx(\"div\",{className:\"sw-row justify-left\",children:createCrumbs(crumbs)})});};","map":null,"metadata":{},"sourceType":"module"}