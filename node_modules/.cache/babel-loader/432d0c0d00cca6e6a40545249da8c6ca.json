{"ast":null,"code":"/* eslint-disable max-statements-per-line */\n\n/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * @module js/positionService\n */\nimport _ from 'lodash';\nimport popupUtils from 'js/popupUtils';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport logger from 'js/logger';\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @type {Array}\n * @enum {String}\n */\n\nconst placements = ['top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n/**\n * the predefined arrow size in px\n */\n\nconst arrowSize = 10;\n/**\n *\n * @param {Element} reference - the reference element\n * @param {Element} popup - the popup element\n * @param {String} options - the placement related option\n *\n * @returns {Object} the expected offsets\n */\n\nconst calculateOffsets = function (reference, popup, options) {\n  if (!reference || !popup) {\n    logger.error(`Invalid element for reference or popup: reference - ${reference}, popup - ${popup}`);\n    return;\n  }\n\n  if (!dom.inDOM(reference)) {\n    logger.warn(`Invalid reference element: ${reference}`);\n  }\n\n  let {\n    placement,\n    alternativePlacements,\n    flipBehavior,\n    hasArrow,\n    arrowOptions,\n    minSize,\n    marginBufferSize\n  } = options;\n\n  if (placements.indexOf(placement) === -1) {\n    logger.warn('Error parameter `placement` ', placement, '. Please use a valid option: ' + placements);\n    return undefined;\n  }\n\n  let data = {\n    options,\n    placement,\n    alternativePlacements,\n    flipBehavior,\n    hasArrow,\n    arrowSize,\n    arrowOptions,\n    minSize,\n    marginBufferSize,\n    offsets: {}\n  };\n  data.offsets.boundaries = getBoundaries(options);\n  data.offsets.reference = getReferenceOffsets(reference, options); // apply placementAttribute if has arrow.\n\n  updatePlacementAttribute(popup, data, Boolean(data.hasArrow)); // compute auto placement to support smart position, store placement inside the data object\n\n  let oldPlacement = placement;\n  data.placement = computeAutoPlacement(popup, data); // if placement changed, need to apply placementAttribute again.\n\n  if (oldPlacement !== data.placement) {\n    updatePlacementAttribute(popup, data, Boolean(data.hasArrow));\n  }\n\n  data.offsets.popup = getPopupOffsets(popup, data);\n  const shiftvariation = data.placement.split('-')[1];\n\n  if (shiftvariation) {\n    let shiftOffsets = calculateShiftOffsets(data);\n    data.offsets.popup = { ...data.offsets.popup,\n      ...shiftOffsets[shiftvariation]\n    };\n  } // if defined overlapOnReference\n\n\n  options.overlapOnReference && applyOverlap(data); // final to getArrowOffsets\n\n  data.hasArrow && (data.offsets.arrow = getArrowOffsets(data));\n  return data.offsets;\n};\n\nfunction applyOverlap(data) {\n  let {\n    popup,\n    reference\n  } = data.offsets;\n  const basePlacement = data.placement.split('-')[0];\n  const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n\n  if (isVertical) {\n    let sign = basePlacement === 'top' ? 1 : -1;\n    popup.top += reference.height * sign;\n  }\n}\n\nfunction updatePlacementAttribute(popup, data) {\n  let add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let name = 'x-placement';\n\n  if (add) {\n    let basePlacement = data.placement.split('-')[0];\n    popup.setAttribute(name, basePlacement);\n  } else {\n    popup.removeAttribute(name);\n  }\n}\n\nfunction getPopupSide(popup, side, boundaries) {\n  let value = 0;\n\n  if (_.has(popup, side)) {\n    value = popup[side];\n  } else {\n    const isLeft = side === 'left';\n    const start = isLeft ? 'right' : 'bottom';\n    const measurement = isLeft ? 'width' : 'height';\n    value = boundaries[measurement] - popup[measurement] - popup[start];\n  }\n\n  return value;\n}\n\nfunction calculateShiftOffsets(data) {\n  const {\n    placement,\n    options\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const basePlacement = placement.split('-')[0];\n  const shiftvariation = placement.split('-')[1];\n  let shiftOffsets = null; // if shift shiftvariation is specified, run the modifier\n\n  if (shiftvariation) {\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const padding = isVertical ? 'x' : 'y';\n    let offset = options && options.padding ? options.padding[padding] || 0 : 0;\n    let targetSide = side;\n    let start = reference[side] + offset;\n    let end = reference[side] + reference[measurement] - popup[measurement] - offset;\n    const mainSideFlipped = !_.has(popup, side);\n\n    if (options.advancePositioning && mainSideFlipped) {\n      const popupSideValue = getPopupSide(popup, side, boundaries);\n      targetSide = getOppositePlacement(side);\n      start = popup[targetSide] + (popupSideValue - reference[side]) - offset;\n      end = popup[targetSide] + (popupSideValue + popup[measurement] - reference[side] - reference[measurement]) + offset;\n    } // override top / left or bottom / right based on mainSide flip flag\n    // if mainSide flipped: means popup was positioned by bottom / right due to content growth, hence override these target side\n\n\n    shiftOffsets = {\n      start: {\n        [targetSide]: start\n      },\n      end: {\n        [targetSide]: end\n      }\n    };\n  }\n\n  return shiftOffsets;\n}\n\nfunction getReferenceOffsets(reference, options) {\n  // TODO: viewport case need to take case parent container element\n  let offset = dom.getOffset(reference);\n  let referenceRect = getOuterSizes(reference); // support padding\n\n  if (options && options.padding) {\n    let {\n      x = 0,\n      y = 0\n    } = options.padding;\n    offset.left -= x;\n    offset.top -= y;\n    referenceRect.width += 2 * x;\n    referenceRect.height += 2 * y;\n  }\n\n  const offsets = { ...offset,\n    ...referenceRect\n  };\n  return getClientRect(offsets);\n}\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @param {String} placement - A valid placement\n * @param {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements\n */\n\n\nfunction clockwise(placement) {\n  let counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const index = placements.indexOf(placement);\n  let arr = placements.slice(0, index);\n  let result = placements.slice(index + 1).concat(arr);\n  return !counter ? result : result.reverse();\n}\n\nfunction getBoundaries(options) {\n  const boundary = options.boundary; // align with `dom.getOffset()`, use viewPort as available space\n\n  let offsets = {\n    // top: window.pageYOffset,\n    // left: window.pageXOffset,\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n\n  if (boundary) {\n    offsets = { ...dom.getOffset(boundary),\n      ...getOuterSizes(boundary)\n    };\n  }\n\n  return getClientRect(offsets);\n}\n\nfunction getSearchOrder(placement, flipBehavior, alternativePlacements) {\n  let searchOrder = [placement];\n  let alternatives = [];\n  let leadAlternatives = [];\n  alternativePlacements && (alternatives = alternativePlacements.slice(0));\n\n  if (flipBehavior === 'opposite') {\n    let op = getOppositePlacement(placement);\n    leadAlternatives = placement.split('-')[1] ? [getOppositeAlignment(placement), op, getOppositeAlignment(op)] : [op];\n  } else if (flipBehavior !== 'fixed') {\n    leadAlternatives = clockwise(placement, flipBehavior === 'counterclockwise');\n  }\n\n  return searchOrder.concat(leadAlternatives, alternatives);\n}\n\nfunction getArea(_ref) {\n  let {\n    width,\n    height\n  } = _ref;\n  return width * height;\n}\n\nfunction checkSpace(rect, popper) {\n  let minSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let res = false;\n\n  if (rect && rect.width >= Math.max(popper.width, minSize) && rect.height >= Math.max(popper.height, minSize)) {\n    res = true;\n  }\n\n  return res;\n}\n\nfunction getPlacement(popup, placement, avaliableRects, flipBehavior, data) {\n  let computedPlacement = null;\n  const searchOrder = getSearchOrder(placement, flipBehavior, data.alternativePlacements);\n  const searchRects = searchOrder.reduce((result, item) => {\n    if (avaliableRects[item]) {\n      result[item] = avaliableRects[item];\n      return result;\n    }\n  }, {}); // Get popper node sizes\n  // support dynamic update when parent resize or window resize,\n  // need to get original popup content size, not the current size.\n\n  clearResize(popup, data);\n  const popper = getOuterSizes(popup, data); // find an available space with no resize required\n\n  computedPlacement = searchOrder.find(key => {\n    let rect = searchRects[key];\n\n    if (checkSpace(rect, popper, data.minSize)) {\n      return key;\n    }\n\n    return null;\n  }); // then try to find an available space with resize required\n\n  if (!computedPlacement) {\n    const sortedAreas = Object.keys(searchRects).map(key => ({\n      key,\n      ...searchRects[key],\n      area: getArea(searchRects[key])\n    })).sort((a, b) => b.area - a.area);\n    applyResize(popup, sortedAreas[0], data);\n    computedPlacement = sortedAreas[0].key;\n  }\n\n  return computedPlacement ? computedPlacement : placement;\n}\n\nfunction getDefaultConstraints(container, css) {\n  let result = {};\n  css.forEach(key => {\n    let key2 = `data-${key}`;\n    result[key] = container.getAttribute(key2) || null;\n  });\n  return result;\n}\n\nfunction clearResize(popup, data) {\n  const container = popupUtils.getResizeContainer(popup, data.options.resizeContainer);\n\n  if (!container) {\n    return;\n  } // horner data-max constraints if defined\n\n\n  const css = ['max-width', 'max-height', 'min-width', 'min-height'];\n  dom.setStyles(container, getDefaultConstraints(container, css));\n}\n\nfunction getArrowMargin(placement, data) {\n  let result = {\n    width: 0,\n    height: 0\n  };\n\n  if (data.hasArrow && data.arrowSize) {\n    const basePlacement = placement.split('-')[0];\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const measurement = !isVertical ? 'width' : 'height';\n    result[measurement] = data.arrowSize;\n  }\n\n  return result;\n}\n\nfunction applyResize(popup, area, data) {\n  const marginBufferSize = data.marginBufferSize || 0;\n  const container = popupUtils.getResizeContainer(popup, data.options.resizeContainer);\n\n  if (!container) {\n    return;\n  }\n\n  const styles = dom.getComputedStyle(container);\n  let css = {};\n  const props = ['width', 'height'];\n  const arrowMargin = getArrowMargin(area.key, data);\n  props.forEach(item => {\n    let available = area[item] - arrowMargin[item]; // unless space is highly limited, leave a gap for the drop shadow, etc\n\n    if (item === 'height' && marginBufferSize > 0) {\n      available = Math.max(available - marginBufferSize, 0);\n    }\n\n    let expected = parseInt(styles[item]);\n    let maxItem = 'max-' + item;\n    let minItem = 'min-' + item;\n    let overflowItem = 'overflow-' + (item === 'width' ? 'x' : 'y');\n\n    if (available < expected) {\n      css[maxItem] = available;\n      css[overflowItem] = 'auto';\n\n      if (styles[minItem] && parseInt(styles[minItem]) > available) {\n        css[minItem] = available;\n      }\n    }\n  });\n\n  if (Object.keys(css).length > 0) {\n    dom.setStyles(container, css);\n  }\n}\n\nfunction getArrowOffsets(data) {\n  const {\n    placement,\n    arrowSize,\n    arrowOptions\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const [basePlacement, shiftvariation] = placement.split('-');\n  let overrideOffsets = null;\n  const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n  const side = isVertical ? 'left' : 'top';\n  const measurement = isVertical ? 'width' : 'height'; // should shift based on reference in this narrow case\n\n  if (reference[measurement] < popup[measurement]) {\n    let base = reference[side] - getPopupSide(popup, side, boundaries);\n    overrideOffsets = {\n      [side]: Math.min(Math.max(base + reference[measurement] / 2 - arrowSize, 0), popup[measurement] - arrowSize * 2)\n    };\n  }\n\n  let shiftOffsets = {}; // arrowOptions should be null by default,\n\n  if (arrowOptions && arrowOptions.alignment) {\n    let alignment = arrowOptions.alignment; // based on the popup alignment, arrow should be smart position itself.\n\n    if (alignment === 'auto') {\n      alignment = shiftvariation ? shiftvariation : 'center';\n    }\n\n    shiftOffsets = getArrowShiftOffsets(data); // return directly got audit error: TypeError: Cannot read property 'name' of undefined\n\n    return { ...overrideOffsets,\n      ...shiftOffsets[alignment]\n    };\n  }\n\n  return overrideOffsets;\n}\n\nfunction getArrowShiftOffsets(data) {\n  const {\n    placement,\n    arrowSize,\n    arrowOptions\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const basePlacement = placement.split('-')[0];\n  const shiftvariation = arrowOptions.alignment;\n  let shiftOffsets = null; // if shift shiftvariation is specified, run the modifier\n\n  if (shiftvariation) {\n    // could be positive / negative\n    let offset = parseInt(arrowOptions.offset) || 0; //  only accept positive values.\n\n    let shift = Math.max(parseInt(arrowOptions.shift) || 0, 0);\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const base = reference[side] - getPopupSide(popup, side, boundaries);\n    const rectifyOffset = Math.min(offset, popup[measurement], reference[measurement]);\n    const padding = rectifyOffset + 2 * arrowSize;\n    const min = Math.min(shift, popup[measurement] - arrowSize, reference[measurement] - arrowSize);\n    const [lowBound, highBound] = [min, positive(shift, Math.max(popup[measurement] - arrowSize * 2 - shift, shift), reference[measurement] + base - arrowSize)];\n    shiftOffsets = {\n      start: {\n        [side]: positive(lowBound, highBound, base + rectifyOffset)\n      },\n      center: {\n        [side]: positive(0, Math.max(popup[measurement], reference[measurement]), // lowBound, highBound,\n        base + reference[measurement] / 2 - arrowSize)\n      },\n      // + offset\n      end: {\n        [side]: positive(lowBound, highBound, base + reference[measurement] - padding)\n      }\n    };\n  }\n\n  return shiftOffsets;\n}\n\nfunction positive(lowBound, highBound) {\n  for (var _len = arguments.length, items = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    items[_key - 2] = arguments[_key];\n  }\n\n  return Math.min(Math.max(lowBound, ...items), highBound);\n}\n\nfunction getPopupOffsets(popup, data) {\n  const {\n    reference,\n    boundaries\n  } = data.offsets;\n  let placement = data.placement;\n  placement = placement.split('-')[0]; // Get popper node sizes\n\n  const popperRect = getOuterSizes(popup, data); // Add position, width and height to our offsets object\n\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  }; // depending by the popper placement we have to compute its offsets slightly differently\n\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width'; // center aligned offsets\n\n  let center = Math.max(0, reference[mainSide] + (reference[measurement] - popperRect[measurement]) / 2);\n  popperOffsets[mainSide] = center; // support adaptive shift\n\n  if (data.options.adaptiveShift) {\n    let exceed = center + popperRect[measurement] - boundaries[measurement];\n    let adaptive = exceed < 0 ? center : Math.max(0, center - exceed);\n    popperOffsets[mainSide] = adaptive;\n\n    if (data.options.advancePositioning) {\n      // when popup content growing in corner case, we should flip the mainSide in positioning to enable it grows and gets natural size. Ref: LCS-352837\n      if (exceed >= -50) {\n        delete popperOffsets[mainSide];\n        popperOffsets[getOppositePlacement(mainSide)] = exceed < 0 ? -exceed : 0;\n      }\n    }\n  } // support flip\n\n\n  let secondaryOppositeSide = getOppositePlacement(secondarySide);\n\n  if (placement === secondarySide) {\n    if (data.options.advancePositioning) {\n      // for traditional top/left positioning, when popup content growing, it could be overlap on reference element,\n      // to prevent that, we do this improvement to ensure no overlap:\n      // for left placement, calculate top/right for popup\n      // for top placement, calculate left/bottom for popup\n      popperOffsets[secondaryOppositeSide] = Math.max(0, boundaries[secondaryOppositeSide] - reference[secondarySide]);\n    } else {\n      popperOffsets[secondarySide] = Math.max(0, reference[secondarySide] - popperRect[secondaryMeasurement]);\n    }\n  } else {\n    popperOffsets[secondarySide] = Math.max(0, reference[secondaryOppositeSide]);\n  } // center aligned offsets\n\n\n  return popperOffsets;\n}\n/**\n * Get the opposite placement of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\n\n\nfunction getOppositePlacement(placement) {\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n/**\n * Get the opposite alignment of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\n\n\nfunction getOppositeAlignment(placement) {\n  const hash = {\n    start: 'end',\n    end: 'start'\n  };\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @param {Object} offsets - the offsets\n * @returns {Object} ClientRect like output\n */\n\n\nfunction getClientRect(offsets) {\n  return { ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {Element} element - the element\n * @param {Object} data - the data object\n * @returns {Object} object containing width and height properties\n */\n\n\nfunction getOuterSizes(element, data) {\n  let [x, y] = [0, 0];\n\n  if (data && data.hasArrow) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window.getComputedStyle(element);\n    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  } // offsetHeight only works for block element, using getBoundingClientRect().height to get height for inline element\n\n\n  const boundingRect = element.getBoundingClientRect();\n  return {\n    width: boundingRect.width + y,\n    height: boundingRect.height + x\n  };\n}\n\nfunction computeAutoPlacement(popup, data) {\n  const {\n    reference,\n    boundaries\n  } = data.offsets;\n  let {\n    placement,\n    flipBehavior\n  } = data;\n  const h1 = reference.top - boundaries.top;\n  const h2 = boundaries.bottom - reference.bottom;\n  const h3 = boundaries.height;\n  const w1 = reference.left - boundaries.left;\n  const w2 = boundaries.right - reference.right;\n  const w3 = boundaries.width;\n  const rects = {\n    top: {\n      width: w3,\n      height: h1\n    },\n    'top-start': {\n      width: boundaries.right - reference.left,\n      height: h1\n    },\n    'top-end': {\n      width: reference.right,\n      height: h1\n    },\n    right: {\n      width: w2,\n      height: h3\n    },\n    'right-start': {\n      width: w2,\n      height: boundaries.bottom - reference.top\n    },\n    'right-end': {\n      width: w2,\n      height: reference.bottom\n    },\n    bottom: {\n      width: w3,\n      height: h2\n    },\n    'bottom-start': {\n      width: boundaries.right - reference.left,\n      height: h2\n    },\n    'bottom-end': {\n      width: reference.right,\n      height: h2\n    },\n    left: {\n      width: w1,\n      height: h3\n    },\n    'left-start': {\n      width: w1,\n      height: boundaries.bottom - reference.top\n    },\n    'left-end': {\n      width: w1,\n      height: reference.bottom\n    }\n  };\n  return getPlacement(popup, placement, rects, flipBehavior, data);\n}\n\nfunction getMax(type, boundaries, refRect) {\n  const isHeight = type === 'height';\n  const side = isHeight ? 'bottom' : 'right';\n  const secondarySide = !isHeight ? 'top' : 'left';\n  const measurement = isHeight ? 'height' : 'width';\n  const space = Math.min(boundaries[side] - refRect[side], refRect[secondarySide] - boundaries[secondarySide]);\n  return 2 * space + refRect[measurement];\n}\n\nexport const positionService = {\n  placements,\n  calculateOffsets\n};\nexport default positionService;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/popup/src/js/positionService.js"],"names":["DOMAPIs","placements","arrowSize","calculateOffsets","logger","reference","popup","dom","marginBufferSize","data","offsets","getBoundaries","getReferenceOffsets","updatePlacementAttribute","Boolean","oldPlacement","computeAutoPlacement","getPopupOffsets","shiftvariation","shiftOffsets","calculateShiftOffsets","options","applyOverlap","getArrowOffsets","basePlacement","isVertical","sign","add","name","value","_","isLeft","side","start","measurement","boundaries","placement","padding","offset","targetSide","end","mainSideFlipped","popupSideValue","getPopupSide","getOppositePlacement","referenceRect","getOuterSizes","x","y","getClientRect","counter","index","arr","result","boundary","top","left","width","window","height","innerHeight","searchOrder","alternatives","leadAlternatives","alternativePlacements","flipBehavior","op","getOppositeAlignment","clockwise","minSize","res","rect","Math","popper","computedPlacement","getSearchOrder","searchRects","avaliableRects","clearResize","key","checkSpace","sortedAreas","area","getArea","b","a","applyResize","css","key2","container","popupUtils","getDefaultConstraints","styles","props","arrowMargin","getArrowMargin","item","available","expected","parseInt","maxItem","minItem","overflowItem","Object","arrowOptions","overrideOffsets","base","alignment","getArrowShiftOffsets","shift","rectifyOffset","min","positive","center","items","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","secondaryMeasurement","exceed","adaptive","secondaryOppositeSide","hash","right","bottom","matched","element","parseFloat","boundingRect","h1","h2","h3","w1","w2","w3","rects","getPlacement","isHeight","type","space","refRect","positionService"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements-per-line */\n/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * @module js/positionService\n */\nimport _ from 'lodash';\nimport popupUtils from 'js/popupUtils';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport logger from 'js/logger';\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @type {Array}\n * @enum {String}\n */\nconst placements = [\n    'top-start',\n    'top',\n    'top-end',\n    'right-start',\n    'right',\n    'right-end',\n    'bottom-end',\n    'bottom',\n    'bottom-start',\n    'left-end',\n    'left',\n    'left-start'\n];\n\n/**\n * the predefined arrow size in px\n */\nconst arrowSize = 10;\n/**\n *\n * @param {Element} reference - the reference element\n * @param {Element} popup - the popup element\n * @param {String} options - the placement related option\n *\n * @returns {Object} the expected offsets\n */\nconst calculateOffsets = function( reference, popup, options ) {\n    if( !reference || !popup ) {\n        logger.error( `Invalid element for reference or popup: reference - ${reference}, popup - ${popup}` );\n        return;\n    }\n    if( !dom.inDOM( reference ) ) { logger.warn( `Invalid reference element: ${reference}` ); }\n    let { placement, alternativePlacements, flipBehavior, hasArrow, arrowOptions, minSize, marginBufferSize } = options;\n    if( placements.indexOf( placement ) === -1 ) {\n        logger.warn( 'Error parameter `placement` ', placement, '. Please use a valid option: ' + placements );\n        return undefined;\n    }\n    let data = {\n        options,\n        placement,\n        alternativePlacements,\n        flipBehavior,\n        hasArrow,\n        arrowSize,\n        arrowOptions,\n        minSize,\n        marginBufferSize,\n        offsets: {}\n    };\n\n    data.offsets.boundaries = getBoundaries( options );\n    data.offsets.reference = getReferenceOffsets( reference, options );\n    // apply placementAttribute if has arrow.\n    updatePlacementAttribute( popup, data, Boolean( data.hasArrow ) );\n    // compute auto placement to support smart position, store placement inside the data object\n    let oldPlacement = placement;\n    data.placement = computeAutoPlacement( popup, data );\n    // if placement changed, need to apply placementAttribute again.\n    if( oldPlacement !== data.placement ) { updatePlacementAttribute( popup, data, Boolean( data.hasArrow ) ); }\n    data.offsets.popup = getPopupOffsets( popup, data );\n    const shiftvariation = data.placement.split( '-' )[ 1 ];\n    if( shiftvariation ) {\n        let shiftOffsets = calculateShiftOffsets( data );\n        data.offsets.popup = { ...data.offsets.popup, ...shiftOffsets[ shiftvariation ] };\n    }\n    // if defined overlapOnReference\n    options.overlapOnReference && applyOverlap( data );\n    // final to getArrowOffsets\n    data.hasArrow && ( data.offsets.arrow = getArrowOffsets( data ) );\n    return data.offsets;\n};\n\nfunction applyOverlap( data ) {\n    let { popup, reference } = data.offsets;\n    const basePlacement = data.placement.split( '-' )[ 0 ];\n    const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n    if( isVertical ) {\n        let sign = basePlacement === 'top' ? 1 : -1;\n        popup.top += reference.height * sign;\n    }\n}\n\nfunction updatePlacementAttribute( popup, data, add = true ) {\n    let name = 'x-placement';\n    if( add ) {\n        let basePlacement = data.placement.split( '-' )[ 0 ];\n        popup.setAttribute( name, basePlacement );\n    } else {\n        popup.removeAttribute( name );\n    }\n}\n\nfunction getPopupSide( popup, side, boundaries ) {\n    let value = 0;\n    if( _.has( popup, side ) ) {\n        value = popup[ side ];\n    } else {\n        const isLeft = side === 'left';\n        const start = isLeft ? 'right' : 'bottom';\n        const measurement = isLeft ? 'width' : 'height';\n        value = boundaries[ measurement ] - popup[ measurement ] - popup[ start ];\n    }\n    return value;\n}\n\nfunction calculateShiftOffsets( data ) {\n    const { placement, options } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const basePlacement = placement.split( '-' )[ 0 ];\n    const shiftvariation = placement.split( '-' )[ 1 ];\n    let shiftOffsets = null;\n    // if shift shiftvariation is specified, run the modifier\n    if( shiftvariation ) {\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const padding = isVertical ? 'x' : 'y';\n\n        let offset = options && options.padding ? options.padding[ padding ] || 0 : 0;\n        let targetSide = side;\n        let start = reference[ side ] + offset;\n        let end = reference[ side ] + reference[ measurement ] - popup[ measurement ] - offset;\n\n        const mainSideFlipped = !_.has( popup, side );\n        if( options.advancePositioning && mainSideFlipped ) {\n            const popupSideValue = getPopupSide( popup, side, boundaries );\n            targetSide = getOppositePlacement( side );\n            start = popup[ targetSide ] + ( popupSideValue - reference[ side ] ) - offset;\n            end = popup[ targetSide ] + ( popupSideValue + popup[ measurement ] - reference[ side ] - reference[ measurement ] ) + offset;\n        }\n\n        // override top / left or bottom / right based on mainSide flip flag\n        // if mainSide flipped: means popup was positioned by bottom / right due to content growth, hence override these target side\n        shiftOffsets = {\n            start: {\n                [ targetSide ]: start\n            },\n            end: {\n                [ targetSide ]: end\n            }\n        };\n    }\n    return shiftOffsets;\n}\n\nfunction getReferenceOffsets( reference, options ) {\n    // TODO: viewport case need to take case parent container element\n    let offset = dom.getOffset( reference );\n    let referenceRect = getOuterSizes( reference );\n    // support padding\n    if( options && options.padding ) {\n        let { x = 0, y = 0 } = options.padding;\n        offset.left -= x;\n        offset.top -= y;\n        referenceRect.width += 2 * x;\n        referenceRect.height += 2 * y;\n    }\n    const offsets = {\n        ...offset,\n        ...referenceRect\n    };\n    return getClientRect( offsets );\n}\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @param {String} placement - A valid placement\n * @param {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements\n */\nfunction clockwise( placement, counter = false ) {\n    const index = placements.indexOf( placement );\n    let arr = placements.slice( 0, index );\n    let result = placements.slice( index + 1 ).concat( arr );\n    return !counter ? result : result.reverse();\n}\n\nfunction getBoundaries( options ) {\n    const boundary = options.boundary;\n    // align with `dom.getOffset()`, use viewPort as available space\n    let offsets = {\n        // top: window.pageYOffset,\n        // left: window.pageXOffset,\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight\n    };\n    if( boundary ) {\n        offsets = {\n            ...dom.getOffset( boundary ),\n            ...getOuterSizes( boundary )\n        };\n    }\n    return getClientRect( offsets );\n}\n\nfunction getSearchOrder( placement, flipBehavior, alternativePlacements ) {\n    let searchOrder = [ placement ];\n    let alternatives = [];\n    let leadAlternatives = [];\n    alternativePlacements && ( alternatives = alternativePlacements.slice( 0 ) );\n    if( flipBehavior === 'opposite' ) {\n        let op = getOppositePlacement( placement );\n        leadAlternatives = placement.split( '-' )[ 1 ] ? [ getOppositeAlignment( placement ), op, getOppositeAlignment( op ) ] : [ op ];\n    } else if( flipBehavior !== 'fixed' ) {\n        leadAlternatives = clockwise( placement, flipBehavior === 'counterclockwise' );\n    }\n    return searchOrder.concat( leadAlternatives, alternatives );\n}\n\nfunction getArea( { width, height } ) {\n    return width * height;\n}\n\nfunction checkSpace( rect, popper, minSize = 0 ) {\n    let res = false;\n    if( rect &&\n        rect.width >= Math.max( popper.width, minSize ) &&\n        rect.height >= Math.max( popper.height, minSize )\n    ) {\n        res = true;\n    }\n    return res;\n}\n\nfunction getPlacement( popup, placement, avaliableRects, flipBehavior, data ) {\n    let computedPlacement = null;\n    const searchOrder = getSearchOrder( placement, flipBehavior, data.alternativePlacements );\n    const searchRects = searchOrder.reduce( ( result, item ) => {\n        if( avaliableRects[ item ] ) {\n            result[ item ] = avaliableRects[ item ];\n            return result;\n        }\n    }, {} );\n    // Get popper node sizes\n    // support dynamic update when parent resize or window resize,\n    // need to get original popup content size, not the current size.\n    clearResize( popup, data );\n    const popper = getOuterSizes( popup, data );\n    // find an available space with no resize required\n    computedPlacement = searchOrder.find( ( key ) => {\n        let rect = searchRects[ key ];\n        if( checkSpace( rect, popper, data.minSize ) ) {\n            return key;\n        }\n        return null;\n    } );\n\n    // then try to find an available space with resize required\n    if( !computedPlacement ) {\n        const sortedAreas = Object.keys( searchRects )\n            .map( key => ( {\n                key,\n                ...searchRects[ key ],\n                area: getArea( searchRects[ key ] )\n            } ) )\n            .sort( ( a, b ) => b.area - a.area );\n        applyResize( popup, sortedAreas[ 0 ], data );\n        computedPlacement = sortedAreas[ 0 ].key;\n    }\n    return computedPlacement ? computedPlacement : placement;\n}\n\nfunction getDefaultConstraints( container, css ) {\n    let result = {};\n    css.forEach( ( key )=>{\n        let key2 = `data-${key}`;\n        result[key] = container.getAttribute( key2 ) || null;\n    } );\n    return result;\n}\n\nfunction clearResize( popup, data ) {\n    const container = popupUtils.getResizeContainer( popup, data.options.resizeContainer );\n    if( !container ) { return; }\n    // horner data-max constraints if defined\n    const css = [ 'max-width', 'max-height', 'min-width', 'min-height' ];\n    dom.setStyles( container, getDefaultConstraints( container, css ) );\n}\n\nfunction getArrowMargin( placement, data ) {\n    let result = { width: 0, height: 0 };\n    if( data.hasArrow && data.arrowSize ) {\n        const basePlacement = placement.split( '-' )[ 0 ];\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const measurement = !isVertical ? 'width' : 'height';\n        result[ measurement ] = data.arrowSize;\n    }\n    return result;\n}\n\nfunction applyResize( popup, area, data ) {\n    const marginBufferSize = data.marginBufferSize || 0;\n    const container = popupUtils.getResizeContainer( popup, data.options.resizeContainer );\n    if( !container ) { return; }\n    const styles = dom.getComputedStyle( container );\n    let css = {};\n    const props = [ 'width', 'height' ];\n    const arrowMargin = getArrowMargin( area.key, data );\n    props.forEach( ( item ) => {\n        let available = area[ item ] - arrowMargin[ item ];\n        // unless space is highly limited, leave a gap for the drop shadow, etc\n        if( item === 'height' && marginBufferSize > 0 ) { available = Math.max( available - marginBufferSize, 0 ); }\n        let expected = parseInt( styles[ item ] );\n        let maxItem = 'max-' + item;\n        let minItem = 'min-' + item;\n        let overflowItem = 'overflow-' + ( item === 'width' ? 'x' : 'y' );\n\n        if( available < expected ) {\n            css[ maxItem ] = available;\n            css[ overflowItem ] = 'auto';\n            if( styles[ minItem ] && parseInt( styles[ minItem ] ) > available ) {\n                css[ minItem ] = available;\n            }\n        }\n    } );\n    if( Object.keys( css ).length > 0 ) {\n        dom.setStyles( container, css );\n    }\n}\n\nfunction getArrowOffsets( data ) {\n    const { placement, arrowSize, arrowOptions } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const [ basePlacement, shiftvariation ] = placement.split( '-' );\n    let overrideOffsets = null;\n    const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    // should shift based on reference in this narrow case\n    if( reference[ measurement ] < popup[ measurement ] ) {\n        let base = reference[ side ] - getPopupSide( popup, side, boundaries );\n        overrideOffsets = {\n            [ side ]: Math.min(\n                Math.max( base + reference[ measurement ] / 2 - arrowSize, 0 ),\n                popup[ measurement ] - arrowSize * 2\n            )\n        };\n    }\n    let shiftOffsets = {};\n    // arrowOptions should be null by default,\n    if( arrowOptions && arrowOptions.alignment ) {\n        let alignment = arrowOptions.alignment;\n        // based on the popup alignment, arrow should be smart position itself.\n        if( alignment === 'auto' ) {\n            alignment = shiftvariation ? shiftvariation : 'center';\n        }\n        shiftOffsets = getArrowShiftOffsets( data );\n        // return directly got audit error: TypeError: Cannot read property 'name' of undefined\n        return { ...overrideOffsets, ...shiftOffsets[ alignment ] };\n    }\n    return overrideOffsets;\n}\n\nfunction getArrowShiftOffsets( data ) {\n    const { placement, arrowSize, arrowOptions } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const basePlacement = placement.split( '-' )[ 0 ];\n    const shiftvariation = arrowOptions.alignment;\n    let shiftOffsets = null;\n    // if shift shiftvariation is specified, run the modifier\n    if( shiftvariation ) {\n        // could be positive / negative\n        let offset = parseInt( arrowOptions.offset ) || 0;\n        //  only accept positive values.\n        let shift = Math.max( parseInt( arrowOptions.shift ) || 0, 0 );\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const base = reference[ side ] - getPopupSide( popup, side, boundaries );\n        const rectifyOffset = Math.min( offset, popup[ measurement ], reference[ measurement ] );\n        const padding = rectifyOffset + 2 * arrowSize;\n        const min = Math.min( shift, popup[ measurement ] - arrowSize, reference[ measurement ] - arrowSize );\n        const [ lowBound, highBound ] = [ min, positive(\n            shift, Math.max( popup[ measurement ] - arrowSize * 2 - shift, shift ),\n            reference[ measurement ] + base - arrowSize ) ];\n        shiftOffsets = {\n            start: {\n                [ side ]: positive( lowBound, highBound,\n                    base + rectifyOffset )\n            },\n            center: {\n                [ side ]: positive( 0, Math.max( popup[ measurement ], reference[ measurement ] ), // lowBound, highBound,\n                    base + reference[ measurement ] / 2 - arrowSize )\n            }, // + offset\n            end: {\n                [ side ]: positive( lowBound, highBound,\n                    base + reference[ measurement ] - padding )\n            }\n        };\n    }\n    return shiftOffsets;\n}\n\nfunction positive( lowBound, highBound, ...items ) {\n    return Math.min( Math.max( lowBound, ...items ), highBound );\n}\n\nfunction getPopupOffsets( popup, data ) {\n    const { reference, boundaries } = data.offsets;\n    let placement = data.placement;\n    placement = placement.split( '-' )[ 0 ];\n    // Get popper node sizes\n    const popperRect = getOuterSizes( popup, data );\n    // Add position, width and height to our offsets object\n    const popperOffsets = {\n        width: popperRect.width,\n        height: popperRect.height\n    };\n    // depending by the popper placement we have to compute its offsets slightly differently\n    const isHoriz = [ 'right', 'left' ].indexOf( placement ) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    // center aligned offsets\n    let center = Math.max( 0, reference[ mainSide ] + ( reference[ measurement ] - popperRect[ measurement ] ) / 2 );\n    popperOffsets[ mainSide ] = center;\n    // support adaptive shift\n    if( data.options.adaptiveShift ) {\n        let exceed = center + popperRect[ measurement ] - boundaries[ measurement ];\n        let adaptive = exceed < 0 ? center : Math.max( 0, center - exceed );\n        popperOffsets[ mainSide ] = adaptive;\n        if( data.options.advancePositioning ) {\n            // when popup content growing in corner case, we should flip the mainSide in positioning to enable it grows and gets natural size. Ref: LCS-352837\n            if( exceed >= -50 ) {\n                delete popperOffsets[ mainSide ];\n                popperOffsets[ getOppositePlacement( mainSide ) ] = exceed < 0 ? -exceed : 0;\n            }\n        }\n    }\n    // support flip\n    let secondaryOppositeSide = getOppositePlacement( secondarySide );\n    if( placement === secondarySide ) {\n        if( data.options.advancePositioning ) {\n            // for traditional top/left positioning, when popup content growing, it could be overlap on reference element,\n            // to prevent that, we do this improvement to ensure no overlap:\n            // for left placement, calculate top/right for popup\n            // for top placement, calculate left/bottom for popup\n            popperOffsets[ secondaryOppositeSide ] = Math.max( 0,\n                boundaries[ secondaryOppositeSide ] - reference[ secondarySide ] );\n        } else {\n            popperOffsets[ secondarySide ] = Math.max( 0,\n                reference[ secondarySide ] - popperRect[ secondaryMeasurement ] );\n        }\n    } else {\n        popperOffsets[ secondarySide ] = Math.max( 0,\n            reference[ secondaryOppositeSide ] );\n    }\n    // center aligned offsets\n    return popperOffsets;\n}\n/**\n * Get the opposite placement of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement( placement ) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace( /left|right|bottom|top/g, matched => hash[ matched ] );\n}\n/**\n * Get the opposite alignment of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\nfunction getOppositeAlignment( placement ) {\n    const hash = { start: 'end', end: 'start' };\n    return placement.replace( /start|end/g, matched => hash[ matched ] );\n}\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @param {Object} offsets - the offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect( offsets ) {\n    return {\n        ...offsets,\n        right: offsets.left + offsets.width,\n        bottom: offsets.top + offsets.height\n    };\n}\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {Element} element - the element\n * @param {Object} data - the data object\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes( element, data ) {\n    let [ x, y ] = [ 0, 0 ];\n    if( data && data.hasArrow ) {\n        const window = element.ownerDocument.defaultView;\n        const styles = window.getComputedStyle( element );\n        x = parseFloat( styles.marginTop || 0 ) + parseFloat( styles.marginBottom || 0 );\n        y = parseFloat( styles.marginLeft || 0 ) + parseFloat( styles.marginRight || 0 );\n    }\n    // offsetHeight only works for block element, using getBoundingClientRect().height to get height for inline element\n    const boundingRect = element.getBoundingClientRect();\n    return {\n        width: boundingRect.width + y,\n        height: boundingRect.height + x\n    };\n}\n\nfunction computeAutoPlacement( popup, data ) {\n    const { reference, boundaries } = data.offsets;\n    let { placement, flipBehavior } = data;\n    const h1 = reference.top - boundaries.top;\n    const h2 = boundaries.bottom - reference.bottom;\n    const h3 = boundaries.height;\n    const w1 = reference.left - boundaries.left;\n    const w2 = boundaries.right - reference.right;\n    const w3 = boundaries.width;\n    const rects = {\n        top: {\n            width: w3,\n            height: h1\n        },\n        'top-start': {\n            width: boundaries.right - reference.left,\n            height: h1\n        },\n        'top-end': {\n            width: reference.right,\n            height: h1\n        },\n        right: {\n            width: w2,\n            height: h3\n        },\n        'right-start': {\n            width: w2,\n            height: boundaries.bottom - reference.top\n        },\n        'right-end': {\n            width: w2,\n            height: reference.bottom\n        },\n        bottom: {\n            width: w3,\n            height: h2\n        },\n        'bottom-start': {\n            width: boundaries.right - reference.left,\n            height: h2\n        },\n        'bottom-end': {\n            width: reference.right,\n            height: h2\n        },\n        left: {\n            width: w1,\n            height: h3\n        },\n        'left-start': {\n            width: w1,\n            height: boundaries.bottom - reference.top\n        },\n        'left-end': {\n            width: w1,\n            height: reference.bottom\n        }\n    };\n    return getPlacement( popup, placement, rects, flipBehavior, data );\n}\n\nfunction getMax( type, boundaries, refRect ) {\n    const isHeight = type === 'height';\n    const side = isHeight ? 'bottom' : 'right';\n    const secondarySide = !isHeight ? 'top' : 'left';\n    const measurement = isHeight ? 'height' : 'width';\n    const space = Math.min( boundaries[ side ] - refRect[ side ], refRect[ secondarySide ] - boundaries[ secondarySide ] );\n    return 2 * space + refRect[ measurement ];\n}\n\nexport const positionService = {\n    placements,\n    calculateOffsets\n};\n\nexport default positionService;\n"]},"metadata":{},"sourceType":"module"}