{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/actionService\n *\n * @namespace actionService\n */\nimport soaSvc from 'soa/kernel/soaService';\nimport declarativeDataCtxSvc from 'js/declarativeDataCtxService';\nimport propertyPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingSvc from 'js/messagingService';\nimport conditionSvc from 'js/conditionService';\nimport navigationService from 'js/navigationService';\nimport adapterSvc from 'js/adapterService';\nimport dataMapperSvc from 'js/dataMapperService';\nimport cfgSvc from 'js/configurationService';\nimport batchActionService from 'js/batchActionService';\n/** revisitme Shaishav\n * Hint: We need to bring following services\nimport wysModeSvc from 'js/wysiwygModeService';\n*/\n\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport declUtils from 'js/declUtils';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader'; // Services\n\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport ClipboardService from 'js/clipboardService';\nimport debugService from 'js/debugService';\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\n\nvar _actionPropsToLog = ['actionId', 'actionType', 'method', 'serviceName', 'deps', 'actionId'];\n/**\n * {Boolean} TRUE if 'action' activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current\n * document's URL.\n */\n\nvar _logActionActivity = browserUtils.getUrlAttributes().logActionActivity !== undefined;\n/**\n * {Boolean} TRUE if 'action' event activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current\n * document's URL.\n */\n\n\nvar _logActionEventActivity = browserUtils.getUrlAttributes().logActionEventActivity !== undefined;\n/**\n * Define public API\n */\n\n\nvar exports = {};\n/**\n * Makes SOA call with given action and inputData. return the promise object.\n *\n * @param {Object} action - The 'declAction' object.\n * @param {Object} inputData - The 'inputData' object.\n *\n * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a\n *         problem).\n */\n\nvar _callSOA = function (action, inputData, propertyPolicyOverride) {\n  var promise = null;\n\n  if (action.actionType === 'TcSoaService') {\n    if (action.serviceName) {\n      if (action.inputData) {\n        promise = soaSvc.postUnchecked(action.serviceName, action.method, inputData, propertyPolicyOverride, null, action.headerState);\n      } else {\n        promise = AwPromiseService.instance.reject('No TcSoaService input data specified');\n      }\n    } else {\n      promise = AwPromiseService.instance.reject('No TcSoaService service specified');\n    }\n  } else {\n    promise = AwPromiseService.instance.reject('Unknown action type: ' + action.actionType);\n  }\n\n  return promise;\n};\n\nvar actionInputDataLogging = function (action, inputData) {\n  /**\n   * Now that any binding has happened, log the current action (if necessary)\n   */\n  if (_logActionActivity) {\n    logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2));\n\n    if (action.actionType === 'RESTService') {\n      logger.info('RESTService.inputData: ' + '\\n' + JSON.stringify(inputData, null, 2));\n    } else if (action.actionType === 'GraphQL' || action.actionType === 'JSFunctionAsync' && action.method === 'callGraphQL') {\n      logger.info('GraphQL.inputData: ' + '\\n' + JSON.stringify(inputData, null, 2));\n\n      if (action.outputData) {\n        logger.info('GraphQL.outputData: ' + '\\n' + JSON.stringify(action.outputData, null, 2));\n      }\n    }\n  }\n};\n\nvar processActionTypeEvent = function (declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred) {\n  setTimeout(function () {\n    if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action not processed.', 'applyExpression');\n      return;\n    } // here needs updated info and eveulation context\n\n\n    let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n    /**\n     * Loop for each 'event' type action and publish the ones who's conditions are\n     * currently TRUE.\n     */\n\n    _.forEach(action.inputData.events, function (event) {\n      var conditionValue = true;\n\n      if (event.condition) {\n        conditionValue = conditionSvc.evaluateConditionExpression(event.condition, localContext.data, {\n          evaluationEnv: { ...localContext\n          },\n          depModuleObj\n        });\n      }\n\n      if (conditionValue) {\n        if (_logActionEventActivity) {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'ActionEvent: ' + event.name);\n        }\n\n        var eventDataToPublish = {};\n\n        if (event.eventData) {\n          eventDataToPublish = _.cloneDeep(event.eventData);\n          declarativeDataCtxSvc.applyScope(localContext.data, eventDataToPublish, functionsList, localContext, depModuleObj);\n        }\n\n        eventDataToPublish._source = declViewModel._internal.modelId;\n\n        if (event.excludeLocalDataCtx !== true) {\n          eventDataToPublish.scope = localContext;\n        }\n\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugEventPub(action, event, localContext.data, localContext, eventDataToPublish);\n        }\n\n        eventBus.publish(event.name, eventDataToPublish, true);\n      }\n    });\n\n    deferred.resolve();\n  }, 0);\n};\n\nvar processActionTypeJsFun = function (inputData, action, deferred, depModuleObj) {\n  var params = [];\n\n  _.forEach(inputData, function (param) {\n    params.push(param);\n  });\n\n  try {\n    const applyFn = depModuleObj[action.method].apply(depModuleObj, params);\n\n    if (typeof (applyFn === null || applyFn === void 0 ? void 0 : applyFn.then) === 'function') {\n      applyFn.then(resolved => {\n        deferred.resolve(resolved);\n      }, err => {\n        deferred.reject(err);\n      });\n    } else {\n      deferred.resolve(applyFn);\n    }\n  } catch (error) {\n    deferred.reject({\n      errorCode: error\n    });\n  }\n};\n\nvar getActionInputData = function (action, inputData) {\n  if (action.inputData) {\n    inputData = _.cloneDeep(action.inputData);\n  } else if (action.navigationParams) {\n    if (typeof action.navigationParams === 'string') {\n      inputData = {\n        navigationParams: action.navigationParams\n      };\n    } else {\n      inputData = _.cloneDeep(action.navigationParams);\n    }\n  }\n\n  return inputData;\n};\n\nvar eveulateActionParameters = function (dataCtxNode, action, inputData) {\n  // if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data\n  // does not exist. In that case we need to process the dataCtxNode.parameter section to get default value\n  // for the parameters We might have some inputdata, which is referring to parameters section. The\n  // below code scans the action.inputData for \"{{parameters\" keyword as value in action.inputdata.\n  // {action: parameters: { \"param1\": \"{{data.xyz}}\"}, inputdata : { \"key1\":\"{{parameter.param1}}\"}}\n  // and replaces them with the default value specified in parameters in action.inputdata :\n  // {\"key1\":\"{{data.param1}}\" later we resolve the inputData, this helps us not to use applyScope\n  // twice.\n  if (!dataCtxNode.parameters && action.parameters) {\n    var keySequence = [];\n    var pattern = /^{{parameters/;\n\n    _.forEach(action.inputData, function processInputData(value, key) {\n      if (value && _.isObject(value)) {\n        keySequence.push(key);\n\n        _.forEach(value, processInputData);\n\n        keySequence.pop();\n      } else if (value && _.isString(value) && pattern.test(value)) {\n        keySequence.push(key);\n        var eventMapKey = keySequence.join('.');\n        var parameterKey = parsingUtils.getStringBetweenDoubleMustaches(value);\n\n        _.set(inputData, eventMapKey, _.get(action, parameterKey, null));\n\n        keySequence.pop();\n      }\n    });\n  }\n};\n\nvar resolveInputData = function (inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError) {\n  if (inputData) {\n    if (declViewModel.isDestroyed()) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action results not applied to data context.', '_performAction');\n    } else {\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n      try {\n        declarativeDataCtxSvc.applyScope(localContext.data, inputData, functionsList, localContext, depModuleObj);\n      } catch (error) {\n        inputError = error;\n      }\n    }\n  }\n\n  return inputError;\n};\n\nvar _processAllDataProvider = function (dataProviderArray, declViewModel, dataCtxNode) {\n  var promises = [];\n\n  _.forEach(dataProviderArray, function (providerObj) {\n    var provider = providerObj.dataProvider;\n    /**\n     * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those\n     * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize\n     * the dataProvider and let it decide what to load.\n     */\n\n    if (provider.json.firstPage) {\n      var firstPageObjs = [];\n\n      _.forEach(provider.json.firstPage, function (uid) {\n        var vmos = declViewModel.objects[uid];\n\n        if (Array.isArray(vmos)) {\n          Array.prototype.push.apply(firstPageObjs, vmos);\n        } else if (vmos !== undefined) {\n          // LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.\n          firstPageObjs.push(vmos);\n        }\n      });\n      /**\n       * This code evaluates the page size to determine if we need to increment total. This is\n       * necessary for object sets, as we do not know the totalFound.\n       */\n\n\n      var maxToLoad;\n\n      if (provider.action && provider.action.inputData) {\n        var actionInputData = provider.action.inputData;\n\n        if (actionInputData.searchInput) {\n          maxToLoad = actionInputData.searchInput.maxToLoad;\n        }\n      }\n\n      var totalFound = firstPageObjs.length > 0 ? firstPageObjs.length + 1 : 0;\n\n      if (maxToLoad) {\n        totalFound = firstPageObjs.length === maxToLoad ? firstPageObjs.length + 1 : firstPageObjs.length;\n      }\n\n      provider.update(firstPageObjs, totalFound);\n    } else {\n      var args = [dataCtxNode, declViewModel];\n      promises.push(provider[providerObj.action].apply(provider, args));\n    }\n  });\n\n  return AwPromiseService.instance.all(promises);\n};\n/**\n * Execute the given 'dataprovider action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.\n */\n\n\nexport let performDataProviderAction = function (declViewModel, action, dataCtxNode) {\n  var dataProviderArray = [];\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel);\n\n  var createDataProviderInput = function (dataProvider, action) {\n    return {\n      dataProvider: dataProvider,\n      action: action ? action : 'initialize'\n    };\n  };\n\n  if (action.methods && _.isArray(action.methods)) {\n    _.forEach(action.methods, function (method) {\n      var dataProvider = declViewModel.dataProviders[method];\n      var dpAction = action.inputData && action.inputData.action ? action.inputData.action : 'initialize';\n\n      if (dataProvider) {\n        dataProviderArray.push(createDataProviderInput(dataProvider, dpAction));\n      }\n    });\n  } else if (action.method) {\n    if (action.inputData && action.inputData.action) {\n      // Table edit use case\n      var dpAction = action.inputData.action;\n      dataProviderArray.push(createDataProviderInput(declViewModel.dataProviders[action.method], dpAction));\n    } else {\n      // with the new implementation resetDataProvider will re-initialize the dataprovider.\n      declViewModel.dataProviders[action.method].resetDataProvider();\n    }\n  } else {\n    logger.warn('Missing action method(s) name for action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2));\n  }\n\n  if (!_.isEmpty(dataProviderArray)) {\n    const {\n      dispatch\n    } = declViewModel;\n    return _processAllDataProvider(dataProviderArray, declViewModel, dataCtxNode).then(() => {\n      // Rules to use dispatch:\n      // - Make sure it is 'immutable change' otherwise it is not getting rerender\n      // - Make sure 'immutable change' dosen't change the object type with no indention\n      //   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object\n      dispatch({\n        path: 'dataProviders',\n        value: { ...declViewModel.dataProviders\n        }\n      });\n    });\n  }\n\n  return 0;\n};\n\nvar processActionTypePopup = function (declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj) {\n  var _dataCtxNode$commandC;\n\n  let popupAction = declViewModel.actions[action.actionId];\n  let updateOptions = inputData && inputData.options || {}; // override popupAction if defined in commandContext - AwCommandService\n  // options could be overridden and customized\n\n  if ((_dataCtxNode$commandC = dataCtxNode.commandContext) !== null && _dataCtxNode$commandC !== void 0 && _dataCtxNode$commandC.popupAction) {\n    // case: it's a normal command\n    popupAction = dataCtxNode.commandContext.popupAction;\n  } else if (!popupAction.show) {\n    // case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.\n    popupAction = appCtxSvc.getCtx('globalPopup');\n  } // case customized popup actions - inject popupAction as last params for action.method\n  // application manages when / how to invoke show / hide\n\n\n  if (action.method && action.deps) {\n    let params = [];\n\n    _.forEach(inputData, function (param) {\n      params.push(param);\n    });\n\n    params.push(popupAction, updateOptions);\n\n    try {\n      const applyFn = depModuleObj[action.method].apply(depModuleObj, params);\n\n      if (typeof (applyFn === null || applyFn === void 0 ? void 0 : applyFn.then) === 'function') {\n        applyFn.then(resolved => {\n          deferred.resolve(resolved);\n        }, err => {\n          deferred.reject(err);\n        });\n      } else {\n        deferred.resolve(applyFn);\n      }\n    } catch (error) {\n      deferred.reject({\n        errorCode: error\n      });\n    } // default plain popup actions\n\n  } else {\n    // TODO: build params based on inputData, props, viewData\n    let evaluatedOptions = inputData && inputData.options || null; // only apply dynamic options\n    // if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {\n    //     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {\n    //         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );\n    //         return result;\n    //     }, {} );\n    // }\n\n    try {\n      popupAction.show(evaluatedOptions).then(function (resolved) {\n        deferred.resolve(resolved);\n      }, function (err) {\n        deferred.reject(err);\n      });\n    } catch (error2) {\n      deferred.reject({\n        errorCode: error2\n      });\n    }\n  }\n};\n\nvar processActionTypeCopy = function (inputData, promise) {\n  /**\n   * This actionType is needed when we are dealing with OS commands like copying to clipboard\n   * which needs to run without any defer mechanism. Since document.execCommand('copy') will\n   * be successful only when it runs through a user click event and not with defer and digest\n   * cycle event. we can use this actionType for other copy command too apart from shareURL\n   * since it calls the same document.execCommand('copy') function after copying it to\n   * awclipboard.\n   */\n\n  /**\n   * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.\n   */\n  if (inputData.copyType === 'URL') {\n    var adaptedObjects = adapterSvc.getAdaptedObjectsSync(inputData.objectToCopy);\n    ClipboardService.instance.copyUrlToClipboard(adaptedObjects);\n    promise = AwPromiseService.instance.when();\n  } else if (inputData.copyType === 'Object') {\n    ClipboardService.instance.copyHyperlinkToClipboard(inputData.objectToCopy);\n    promise = AwPromiseService.instance.when();\n  }\n\n  return promise;\n};\n\nvar processActionTypeNaviagte = function (action, inputData) {\n  if (action.navigateTo) {\n    if (inputData.navigationParams) {\n      inputData = inputData.navigationParams;\n    }\n\n    return navigationService.navigate(action, inputData);\n  }\n\n  return AwPromiseService.instance.reject('Missing navigate to in action type: ' + action.actionType + ' for actionId: ' + action.actionId);\n};\n\nvar processActionTypeEdit = function (action, declViewModel) {\n  var methods = ['startEdit', 'saveEdits', 'cancelEdits', 'isDirty'];\n\n  if (action.method && methods.indexOf(action.method) !== -1) {\n    return declViewModel[action.method].apply(declViewModel);\n  }\n\n  return AwPromiseService.instance.reject('Not a valid edit action : ' + action.method);\n};\n\nvar processActionTypeSync = function (action, inputData, declViewModel) {\n  if (inputData.port) {\n    return import('js/syncStrategyService').then(function (syncStrategyService) {\n      return syncStrategyService.updatePort(declViewModel, inputData, exports);\n    });\n  }\n\n  return AwPromiseService.instance.reject('Missing port to in action type: ' + action.actionType + ' for actionId: ' + action.actionId);\n};\n\nvar loadCustomActionDependentModule = function (customAction) {\n  var depModuleObj = moduleLoader.getDependentModule(customAction.deps);\n\n  if (depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }\n\n  return moduleLoader.loadDependentModule(customAction.deps).then(function success(depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }, function reject(error) {\n    return AwPromiseService.instance.reject(error);\n  });\n};\n/**\n * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will\n * be returned.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n * @param {Object} action - The 'declAction' to be executed.\n * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.\n * @param {Object} dataCtxNode - The data context node which holds interpolation values.\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n */\n\n\nvar _performAction = function (declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride) {\n  if (!action) {\n    return AwPromiseService.instance.reject('Missing action parameter');\n  }\n\n  if (!action.actionType) {\n    return AwPromiseService.instance.reject('Missing action type for actionId: ' + action.actionId);\n  }\n\n  var inputData = null;\n  var inputError = null;\n  /**\n   * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.\n   * <P>\n   * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the\n   * time the action is queued to be executed and when we get here.\n   */\n\n  if (action.altInputData) {\n    inputData = action.altInputData;\n  } else {\n    inputData = getActionInputData(action, inputData);\n    eveulateActionParameters(dataCtxNode, action, inputData);\n    inputError = resolveInputData(inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError);\n  }\n  /**\n   * Now that any binding has happened, log the current action (if necessary)\n   */\n\n\n  actionInputDataLogging(action, inputData);\n  /**\n   * Check for an input error\n   */\n\n  var promise = null;\n  var deferred;\n\n  if (inputError) {\n    promise = AwPromiseService.instance.reject({\n      errorCode: inputError\n    });\n    return promise;\n  }\n\n  return declarativeDataCtxSvc.applyExpression(inputData).then(function () {\n    debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel, inputData);\n\n    if (action.actionType === 'dataProvider') {\n      promise = exports.performDataProviderAction(declViewModel, action, dataCtxNode);\n    } else if (action.actionType === 'TcSoaService') {\n      promise = _callSOA(action, inputData, propertyPolicyOverride);\n    } else if (action.actionType === 'RESTService') {\n      promise = AwHttpService.instance(inputData.request);\n    } else if (action.actionType === 'Event') {\n      if (action.inputData) {\n        deferred = AwPromiseService.instance.defer();\n        processActionTypeEvent(declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred);\n        promise = deferred.promise;\n      }\n    } else if (action.actionType === 'JSFunction' || action.actionType === 'JSFunctionAsync') {\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypeJsFun(inputData, action, deferred, depModuleObj);\n    } else if (action.actionType === 'Test') {\n      /**\n       * This actionType is meant to allow automated testing without the need for a live server to\n       * load dependent modules. The resolved data for the deferred action is just the same object\n       * that was given as the 'inputData'.\n       */\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      deferred.resolve(inputData);\n    } else if (action.actionType === 'popup') {\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypePopup(declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj);\n    } else if (action.actionType === 'Copy') {\n      promise = processActionTypeCopy(inputData, promise);\n    } else if (action.actionType === 'Navigate') {\n      promise = processActionTypeNaviagte(action, inputData);\n    } else if (action.actionType === 'Edit') {\n      promise = processActionTypeEdit(action, declViewModel);\n    } else if (action.actionType === 'batchJob') {\n      promise = batchActionService.executeBatchActions(declViewModel, action, dataCtxNode, exports);\n    } else if (action.actionType === 'Sync') {\n      return processActionTypeSync(action, inputData, declViewModel);\n    } else {\n      // process custom Action Type\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypeCustom(action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj);\n    } // end of custom action\n\n\n    return promise;\n  });\n};\n\nvar processActionTypeCustom = function (action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj) {\n  cfgSvc.getCfg('actionTemplateDefs').then(function (actionTemplateDefs) {\n    if (actionTemplateDefs[action.actionType]) {\n      var customAction = _.cloneDeep(actionTemplateDefs[action.actionType]); // resolver for inputData defined at successive action template defs that include\n      // ctx, data and inputData\n\n\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n      var resolver = { ...localContext,\n        inputData: inputData\n      }; // load the dependent modules if deps is specified\n\n      if (customAction.deps) {\n        var depModuleObjPromise = loadCustomActionDependentModule(customAction);\n        depModuleObjPromise.then(function (depModuleObj) {\n          deferred.resolve(_performAction(declViewModel, customAction, functionsList, resolver, depModuleObj));\n        });\n      } else {\n        deferred.resolve(_performAction(declViewModel, customAction, functionsList, resolver, depModuleObj));\n      }\n    } else {\n      logger.error('error :: action type ->' + action.actionType + ' is missing.');\n      deferred.reject('Unknown action type: ' + action.actionType);\n    }\n  });\n};\n\nvar processDefaultErrorMsg = function (err, action) {\n  //var msg = null;\n  //var level = 1;\n  if (_.isString(err)) {\n    /**msg = err;\n    level = 3; */\n  } else if (err && err.message) {\n    /**msg = err.message.replace( /\\n/g, '<br>' );\n    level = err.level ? err.level : 3; */\n  } else {\n    /**msg = 'Unknown error message type for action ' + action.method;\n    level = 3;*/\n    logger.error(err);\n  }\n  /** revisitme Shaishav\n       * Hint: We need to bring wysiwygModeService\n       if( level <= 1 ) {\n           logger.info( msg );\n       } else {\n           wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );\n       }\n  */\n\n};\n\nvar processDefaultErrorTypeObject = function (err, isReported) {\n  var errInfo = null;\n\n  if (err.config && err.status && (err.status < 200 || err.status > 299)) {\n    /**\n     * Error from Angular's $http service.\n     */\n    errInfo = {\n      url: err.config.url,\n      method: err.config.method,\n      status: err.status,\n      statusText: err.statusText\n    };\n  } else if (err.cause && err.cause.config) {\n    /**\n     * Error due to lost network connectivity, server crash etc.\n     */\n    errInfo = {\n      url: err.cause.config.url,\n      method: err.cause.config.method,\n      status: err.cause.status,\n      statusText: err.cause.statusText\n    };\n  }\n\n  if (errInfo !== null) {\n    var errMsg = 'The HTTP \"' + errInfo.method + '\" method to url \"' + errInfo.url + '\" failed';\n\n    if (_.isString(errInfo.statusText) && errInfo.statusText.length > 0) {\n      errMsg = errMsg + ' (status = \"' + errInfo.statusText + '\").';\n    } else {\n      errMsg = errMsg + ' (status = \"' + errInfo.status + '\").';\n    }\n\n    isReported = true;\n    logger.error(errMsg);\n  }\n\n  return isReported;\n};\n\nconst parseConditonExp = (expression, evaluationEnv) => {\n  //This is not acomplete fix, needs to be revisited - LCS-565498\n  const exp = conditionSvc.getRealExpression(expression, evaluationEnv);\n\n  if (_.isString(exp)) {\n    return exp;\n  } //If the condition is object based, return the original expression\n\n\n  return expression;\n};\n/**\n * Process the events of the executed action\n *\n * @param {DeclViewModel} declViewModel - The declarative view model\n * @param {DeclAction} action - The declarative action.\n * @param {Object} events - The events of an action object on the View model\n * @param {Object} evaluationEnv - The environment on which to evaluate event conditions\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing\n *            action 'failure'.\n */\n\n\nvar _processActionEvents = function (declViewModel, action, events, evaluationEnv, dataCtxNode, depModuleObj, isSuccess) {\n  /**\n   * Check if there is no reason to continue.\n   */\n  if (_.isEmpty(events)) {\n    return;\n  } //new in afx 3.1.0\n\n\n  if (declViewModel.isDestroyed()) {\n    declUtils.logLifeCycleIssue(declViewModel, action, 'Action event(s) not processed.', '_processActionEvents');\n    return;\n  }\n\n  var functionsList = declViewModel._internal.functions;\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'events');\n\n  _.forEach(events, function (event) {\n    /**\n     * Fire event when condition value is true\n     */\n    var conditionValue = true;\n\n    if (event.condition) {\n      const expression = parseConditonExp(event.condition, declViewModel._internal);\n      conditionValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n        evaluationEnv,\n        depModuleObj\n      });\n    }\n\n    if (conditionValue) {\n      if (_logActionEventActivity) {\n        if (isSuccess) {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'SuccessEvent: ' + event.name);\n        } else {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'FailureEvent: ' + event.name);\n        }\n      }\n\n      var eventData = {};\n\n      if (event.eventData) {\n        eventData = _.cloneDeep(event.eventData);\n        declarativeDataCtxSvc.applyScope(declViewModel, eventData, functionsList, dataCtxNode, depModuleObj);\n      }\n\n      if (event.excludeLocalDataCtx !== true) {\n        eventData.scope = dataCtxNode;\n      }\n\n      eventData._source = declViewModel._internal.modelId;\n      eventBus.publish(event.name, eventData, true);\n\n      if (logger.isDeclarativeLogEnabled()) {\n        debugService.debugEventPub(action, event, declViewModel, dataCtxNode, eventData);\n      }\n    }\n  });\n};\n\nvar processActionFailureEvents = function (events, err, evaluationEnv, declViewModel, action, dataCtxNode, depModuleObj) {\n  if (events && events.failure) {\n    var _err$response;\n\n    if (err.cause && err.cause.partialErrors) {\n      /**\n       * Add the error in the evaluation env for each of the events\n       */\n      _.forEach(events.failure, function (failureEvt) {\n        _.forEach(err.cause.partialErrors, function (partialError) {\n          if (partialError.errorValues) {\n            _.forEach(partialError.errorValues, function (errorValue) {\n              if (errorValue.code) {\n                evaluationEnv.errorCode = errorValue;\n\n                if (!evaluationEnv.errorCodes) {\n                  evaluationEnv.errorCodes = [];\n                }\n\n                evaluationEnv.errorCodes.push(errorValue);\n              }\n            });\n          }\n        });\n\n        _processActionEvents(declViewModel, action, [failureEvt], evaluationEnv, dataCtxNode, depModuleObj, false);\n      }); // If REST call is failed with error\n\n    } else if (err.status || (_err$response = err.response) !== null && _err$response !== void 0 && _err$response.status) {\n      // Add the error in the evaluation env for each of the events\n      evaluationEnv.errorCode = err;\n\n      _processActionEvents(declViewModel, action, events.failure, evaluationEnv, dataCtxNode, depModuleObj, false);\n    } else {\n      // Process all events in bulk\n      _processActionEvents(declViewModel, action, events.failure, evaluationEnv, dataCtxNode, depModuleObj, false);\n    }\n  }\n};\n\nvar processPartialError = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj) {\n  let matchingMessages = [];\n\n  _.forEach(err.cause.partialErrors, function (partialError) {\n    if (partialError.errorValues) {\n      _.forEach(partialError.errorValues, function (errorValue) {\n        if (errorValue.code) {\n          _.forEach(actionMessages.failure, function (failureErr) {\n            var condValue = true;\n\n            if (failureErr.condition) {\n              evaluationEnv.errorCode = errorValue;\n              const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n              condValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n                evaluationEnv,\n                depModuleObj\n              });\n            }\n\n            if (condValue) {\n              if (!failureErr.errorCode) {\n                failureErr.errorCode = [];\n              }\n\n              failureErr.errorCode.push(errorValue);\n\n              if (matchingMessages.indexOf(failureErr) === -1) {\n                matchingMessages.push(failureErr);\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n\n  return matchingMessages;\n};\n\nvar processActionHavingCause = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj) {\n  let allMessages = null;\n  let isReported = false;\n\n  _.forEach(err.cause.messages, function (message) {\n    if (message.code) {\n      _.forEach(actionMessages.failure, function (failureErr) {\n        let conditionResult = false;\n\n        if (failureErr.condition) {\n          // two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123\n          evaluationEnv.errorCode = failureErr.condition.indexOf('.code') > -1 ? message : message.code;\n          const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n          conditionResult = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n            evaluationEnv,\n            depModuleObj\n          });\n        }\n\n        if (conditionResult || failureErr.message && failureErr.condition === undefined) {\n          isReported = true;\n\n          if (!allMessages) {\n            allMessages = _.cloneDeep(declViewModel._internal.messages);\n          }\n\n          evaluationEnv.errorCode = message.message;\n          messagingSvc.reportNotyMessage(declViewModel, allMessages, failureErr.message, evaluationEnv);\n        }\n      });\n    }\n  });\n\n  return isReported;\n};\n\nvar processActionHavingErrorCode = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode) {\n  var isReported = false;\n  var allMessages = null;\n  /**\n   * Notify error raised by a JS function call\n   */\n\n  _.forEach(actionMessages.failure, function (failureErr) {\n    var condValue = true;\n\n    if (failureErr.condition) {\n      var _err$response2;\n\n      if (err.status || (_err$response2 = err.response) !== null && _err$response2 !== void 0 && _err$response2.status) {\n        // In case failure is from REST call\n        evaluationEnv.errorCode = err;\n      } else {\n        evaluationEnv.errorCode = err.errorCode;\n      }\n\n      const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n      condValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n        evaluationEnv,\n        depModuleObj\n      });\n    }\n\n    if (condValue) {\n      isReported = true;\n\n      if (!allMessages) {\n        allMessages = _.cloneDeep(declViewModel._internal.messages);\n      }\n\n      messagingSvc.reportNotyMessage(declViewModel, allMessages, failureErr.message, dataCtxNode, depModuleObj);\n    }\n  });\n\n  return isReported;\n};\n\nvar processActionFailureMessage = function (actionMessages, err, evaluationEnv, declViewModel, depModuleObj, isReported, dataCtxNode) {\n  if (actionMessages && actionMessages.failure) {\n    var _err$response3;\n\n    if (err.cause && err.cause.partialErrors) {\n      // Notify error message when condition matched\n      var allMessages;\n\n      if (actionMessages.failure.length > 0) {\n        var matchingMessages = [];\n        var scopedAllMessages = [];\n\n        var reportError = function (failureErr, idx) {\n          evaluationEnv.errorCode = failureErr.errorCode.reduce((acc, err, index, arr) => {\n            acc += err.message + (arr.length - 1 === index ? '' : '<br/>');\n            return acc;\n          }, '');\n          messagingSvc.reportNotyMessage(declViewModel, scopedAllMessages[idx], failureErr.message, evaluationEnv);\n          failureErr.errorCode = null;\n        };\n\n        matchingMessages = processPartialError(err, actionMessages, evaluationEnv, declViewModel, depModuleObj);\n\n        if (!allMessages && matchingMessages.length > 0) {\n          allMessages = _.cloneDeep(declViewModel._internal.messages);\n          scopedAllMessages.push(allMessages);\n          isReported = true;\n        }\n\n        matchingMessages.forEach(function (message, index) {\n          reportError(message, index);\n        });\n      } else {\n        /**\n         * Notify SOA error message when no condition specified\n         var errMessage = messagingSvc.getSOAErrorMessage( err ); */\n        isReported = true;\n        /** revisitme Shaishav\n         * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module\n         * should not depend on layer 3 modules. We need to correct that.\n        wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );\n        */\n      }\n    } else if (err.cause && err.cause.messages) {\n      isReported = processActionHavingCause(err, actionMessages, evaluationEnv, declViewModel, depModuleObj);\n    } else if (err.errorCode || err.status || (_err$response3 = err.response) !== null && _err$response3 !== void 0 && _err$response3.status) {\n      isReported = processActionHavingErrorCode(err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode);\n    }\n  }\n\n  return isReported;\n};\n\nvar performOutputDataMapping = function (resolvedAssignments, declViewModel, prop) {\n  const {\n    dispatch,\n    updateAtomicData\n  } = declViewModel;\n  let finalObj = {};\n\n  for (prop in resolvedAssignments) {\n    // special property\n    const basePath = prop.split('.')[0];\n\n    if (declViewModel.atomicData && declViewModel.atomicData[basePath]) {\n      _.set(declViewModel.atomicData, prop, resolvedAssignments[prop]);\n\n      updateAtomicData[basePath](_.cloneDeep(declViewModel.atomicData[basePath]));\n    } else {\n      let key = `data.${prop}`;\n      finalObj[key] = resolvedAssignments[prop];\n    }\n  }\n\n  if (dispatch && Object.keys(finalObj).length > 0) {\n    dispatch({\n      value: finalObj\n    });\n\n    _.forEach(resolvedAssignments, function (fromPath, toPath) {\n      _.set(declViewModel, toPath, fromPath);\n    });\n  }\n};\n\nvar loadFuncDependency = function (action, declViewModel, depModuleObj) {\n  // load function deps\n  var functionDeps = declUtils.getFunctionDeps(action, declViewModel._internal); // Filter already loaded deps\n\n  _.forEach(depModuleObj, function (funcValue, funcKey) {\n    var loaded = _.find(functionDeps, function (funcDep) {\n      // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n      // funcKey here is module name, fundDep here is js/fileName\n      // luckly it is passing today\n      return funcDep.includes(funcKey);\n    });\n\n    if (loaded) {\n      _.remove(functionDeps, function (funcDep) {\n        return funcDep === loaded;\n      });\n    }\n  });\n\n  return functionDeps;\n};\n\nvar getActionPolicyInfo = function (action, declViewModel, functionsList, dataCtxNode, depModuleObj) {\n  if (action.policy && action.actionType === 'TcSoaService') {\n    var policy = _.cloneDeep(action.policy);\n\n    declarativeDataCtxSvc.applyScope(declViewModel, policy, functionsList, dataCtxNode, depModuleObj);\n\n    if (policy.override === true) {\n      return {\n        propertyPolicyOverride: {\n          types: policy.types\n        }\n      };\n    }\n\n    return {\n      actionPolicyId: propertyPolicySvc.register({\n        types: policy.types\n      }, action.method + '_Policy')\n    };\n  }\n\n  return {};\n};\n/**\n * Process the 'Success' part of the executed action\n *\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\n\n\nvar _processSuccess = function (declViewModel, action, dataCtxNode, depModuleObj) {\n  var events = action.events;\n  var actionMessages = action.actionMessages;\n  var allMessages;\n  let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n  if (events && events.success) {\n    _processActionEvents(localContext.data, action, events.success, localContext, localContext, depModuleObj, true);\n  }\n\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'actionMessages');\n\n  if (actionMessages && actionMessages.success) {\n    _.forEach(actionMessages.success, function (successMessage) {\n      if (successMessage) {\n        var condValue = true;\n\n        if (successMessage.condition) {\n          const expression = parseConditonExp(successMessage.condition, declViewModel._internal);\n          condValue = conditionSvc.evaluateConditionExpression(expression, localContext.data, {\n            evaluationEnv: { ...localContext\n            },\n            depModuleObj\n          });\n        }\n\n        if (condValue) {\n          if (!allMessages) {\n            allMessages = _.cloneDeep(declViewModel._internal.messages);\n          }\n\n          messagingSvc.reportNotyMessage(localContext.data, allMessages, successMessage.message, localContext);\n        }\n      } else {\n        logger.error('Invalid action successMessage:' + successMessage);\n      }\n    });\n  }\n};\n/**\n * Process the error and the 'Failure' part of the executed action\n *\n * @param {Object} err - JavaScript Error object\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\n\n\nvar _processError = function (err, declViewModel, action, dataCtxNode, depModuleObj) {\n  var events = action.events;\n  var actionMessages = action.actionMessages;\n  let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n  processActionFailureEvents(events, err, localContext, localContext.data, action, localContext, depModuleObj);\n  var isReported = false;\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'actionMessages');\n  isReported = processActionFailureMessage(actionMessages, err, localContext, localContext.data, depModuleObj, isReported, localContext);\n\n  if (!isReported && typeof err === 'object') {\n    isReported = processDefaultErrorTypeObject(err, isReported);\n  }\n  /**\n   * Fall back, report error if not raised till this point\n   */\n\n\n  if (!isReported) {\n    processDefaultErrorMsg(err, action);\n  }\n};\n/**\n * @param {DeclViewModel} declViewModel - Model that owns the action.\n * @param {DeclAction} action - Action to 'finish'.\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.\n * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.\n * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.\n */\n\n\nvar _finishAction = function (declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred) {\n  var err = null;\n\n  if (!_.isEmpty(actionResponseObj)) {\n    if (!_.isEmpty(actionResponseObj.partialErrors) || !_.isEmpty(actionResponseObj.PartialErrors)) {\n      err = soaSvc.createError(actionResponseObj);\n    }\n\n    if (actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors) {\n      err = soaSvc.createError(actionResponseObj.ServiceData);\n    }\n  }\n\n  if (err) {\n    _processError(err, declViewModel, action, dataCtxNode, depModuleObj);\n\n    deferred.reject(err);\n  } else {\n    _processSuccess(declViewModel, action, dataCtxNode, depModuleObj);\n\n    deferred.resolve(actionResponseObj);\n  }\n};\n\nvar performOutputDataMappingForBatch = function (resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred) {\n  var data = {\n    actionData: []\n  };\n\n  _.forEach(resolvedAssignments, function (fromPath, toPath) {\n    _.set(data.actionData, toPath, fromPath);\n  });\n\n  _finishAction(declViewModel, action, dataCtxNode, depModuleObj, data, deferred);\n};\n\nvar resolveActionOutputData = function (action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode) {\n  var deferredAssignments = {};\n  /**\n   * Loop for each mapping in the 'outputData' spec\n   */\n\n  var index = 0;\n\n  _.forEach(action.outputData, function (fromPath, toPath) {\n    var fromObj;\n\n    if (mapDataOnAction && action.outputArg) {\n      toPath = action.outputArg[index];\n    }\n\n    if (_.isBoolean(fromPath)) {\n      fromObj = fromPath;\n    } else if (_.isEmpty(fromPath)) {\n      /**\n       * To support action as JS function call, assign function return value as the result\n       * when empty value expression specified\n       */\n      fromObj = actionResponseObj;\n    } else if (_.isString(fromPath) && fromPath.indexOf('result.') === 0) {\n      /**\n       * If fromPath has a 'result.' prefix, parse the expression within fromPath to get\n       * the correct value.\n       */\n      var fromResultPath = fromPath.split('result.')[1];\n      fromObj = _.get(actionResponseObj, fromResultPath);\n    } else {\n      /**\n       * If fromPath is defined, parse the expression within fromPath to get the correct\n       * value.\n       */\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n      fromObj = declarativeDataCtxSvc.getOutput(declViewModel, actionResponseObj, fromPath, depModuleObj, localContext);\n    }\n    /**\n     * If the toPath starts with ctx. update the appCtxService\n     */\n\n\n    if (toPath.indexOf('ctx.') === 0) {\n      var toCtxName = toPath.split('ctx.')[1];\n      appCtxSvc.updatePartialCtx(toCtxName, fromObj);\n    } else if (_.startsWith(toPath, 'ports.')) {\n      if (dataCtxNode.ports) {\n        _.set(dataCtxNode.ports, toPath.replace('ports.', ''), fromObj);\n      }\n    } else {\n      // The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the\n      // case in cleaner way\n      deferredAssignments[toPath] = AwPromiseService.instance.when(fromObj);\n    }\n\n    index += 1;\n  });\n\n  return deferredAssignments;\n};\n/**\n * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.\n * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}\n * @param {DeclAction} action - {DeclAction} being performed\n * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on\n * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the\n * 'deferred' remains untouched.\n */\n\n\nvar _isViewModelDestroyed = function (declViewModel, actionResponseObj, action, deferred, methodName) {\n  /**\n   * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can\n   * happen, for example, when multiple subscribers are listening to a common event like 'selection' and\n   * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close\n   * (thus destroying the dataCtxNode and the declViewModel associated with it).\n   * <P>\n   * If so: There is nothing more that can be done with the declViewModel and we just want to log a\n   * warning about the life cycle issue and 'resolve' the given 'deferred'.\n   */\n  if (declViewModel.isDestroyed()) {\n    /**\n     * If the action is trying to actually do something with the response and the view model is\n     * destroyed log an error\n     */\n    if (actionResponseObj) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action was therefore not finished.', methodName);\n    } // Otherwise do nothing\n\n\n    deferred.resolve();\n    return true;\n  }\n\n  return false;\n};\n/**\n * Perform a SOA action. Support calling SOA service, return the response object.\n *\n * @param {Object} action - The 'declAction' to be executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n */\n\n\nexport let performSOAAction = function (action) {\n  var deferred = AwPromiseService.instance.defer();\n\n  _callSOA(action, action.inputData).then(function (actionResponseObj) {\n    if (!declUtils.isNil(actionResponseObj)) {\n      var err = null;\n\n      if (actionResponseObj.partialErrors || actionResponseObj.PartialErrors) {\n        err = soaSvc.createError(actionResponseObj);\n      }\n\n      if (actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors) {\n        err = soaSvc.createError(actionResponseObj.ServiceData);\n      }\n\n      if (err) {\n        deferred.reject(err);\n      } else if (!_.isEmpty(action.outputData)) {\n        deferred.resolve(actionResponseObj);\n      }\n    }\n  }, function (err) {\n    deferred.reject(err);\n  });\n\n  return deferred.promise;\n};\n/**\n * Perform a action synchronously. Specificly for 'syncFunction' actionType.\n * Returns nothing.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n *\n * @param {Object} action - The 'declAction' to be executed.\n *\n * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.\n *\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n *\n * @returns {Object} The result of the called function.\n */\n\nexport let performActionSync = function (declViewModel, action, dataCtxNode, depModuleObj) {\n  if (!action) {\n    logger.error('Missing action definition for actionId ' + action.actionId);\n    return null;\n  }\n\n  if (!action.actionType) {\n    logger.error('Missing action type for actionId: ' + action.actionId);\n    return null;\n  }\n\n  if (action.actionType !== 'syncFunction') {\n    logger.error('Invalid action type for actionId: ' + action.actionId);\n    return null;\n  }\n\n  var inputData = null;\n  let inputError = null;\n\n  if (action.inputData) {\n    inputData = _.cloneDeep(action.inputData);\n  }\n\n  if (inputData) {\n    if (declViewModel.isDestroyed()) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action results not applied to data context.', 'performActionSync');\n    } else {\n      try {\n        // this may require it  latest info update to latest\n        let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n        declarativeDataCtxSvc.applyScope(localContext.data, inputData, null, localContext, depModuleObj);\n      } catch (error) {\n        inputError = error;\n      }\n    }\n  }\n\n  if (inputError) {\n    return null;\n  }\n  /**\n   * Collect function parameters from input data\n   */\n\n\n  var params = [];\n\n  _.forEach(inputData, function (param) {\n    params.push(param);\n  });\n\n  try {\n    return depModuleObj[action.method].apply(depModuleObj, params);\n  } catch (err) {\n    logger.error('Action ' + action.actionId + ' cannot be executed\\n' + err);\n  }\n\n  return null;\n};\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in\n *            the execution.\n * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on\n * viewModel/ctx.\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.\n */\n\nexport let executeAction = function (declViewModel, action, dataCtxNode, depModuleObj, mapDataOnAction, prop) {\n  // Note: Clipboard Service is not following the correct\n  // another approach is we can try to create asyncLoad method\n  // for all these case and merge them with current thenable flow\n\n  /** revisitme Shaishav\n   * Hint: Need to find the reason for this line. It is failing to compile in afx-next\n  ClipboardService.instance;\n  */\n  declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, null, 'executeAction (a)');\n  var deferred = AwPromiseService.instance.defer();\n  var functionsList = declViewModel._internal.functions;\n  var {\n    actionPolicyId,\n    propertyPolicyOverride\n  } = getActionPolicyInfo(action, declViewModel, functionsList, dataCtxNode, depModuleObj); // load function deps\n\n  var functionDeps = loadFuncDependency(action, declViewModel, depModuleObj);\n  /**\n   * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.\n   * This should probably be made right in the future as part of better performance work.\n   */\n\n  moduleLoader.loadDependentModules(functionDeps).then(function (functionDependancies) {\n    _.forEach(functionDependancies, function (funcDepVal, funcDepKey) {\n      depModuleObj[funcDepKey] = funcDepVal;\n    });\n\n    var promise = _performAction(declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride);\n\n    if (!promise) {\n      deferred.resolved();\n      return;\n    }\n\n    promise.then(function (actionResponseObj) {\n      /**\n       * Remove any policies that were registered for this action.\n       */\n      if (actionPolicyId) {\n        propertyPolicySvc.unregister(actionPolicyId);\n      }\n\n      if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (b)')) {\n        return;\n      }\n      /**\n       * Check if we have a response and an output data map to work with.\n       * <P>\n       * If so: Process all the action output definitions and stick them on the dataCtxNode.\n       * <P>\n       * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action\n       * object to handle boolean or number type object responses (D-47571).\n       */\n\n\n      if (!declUtils.isNil(actionResponseObj) && !_.isEmpty(action.outputData)) {\n        var deferredAssignments = {};\n        /* If dataParsers are defined, then run the actionResponseObj through them before pipelining\n         * to outPutData.\n         */\n\n        if (_.isArray(action.dataParsers)) {\n          actionResponseObj = dataMapperSvc.applyDataParseDefinitions(actionResponseObj, declViewModel, action.dataParsers, dataCtxNode, depModuleObj);\n        }\n\n        deferredAssignments = resolveActionOutputData(action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode);\n        AwPromiseService.instance.all(deferredAssignments).then(function (resolvedAssignments) {\n          //new in afx 3.1.0\n          if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (c)')) {\n            return;\n          }\n\n          if (mapDataOnAction) {\n            performOutputDataMappingForBatch(resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred);\n          } else {\n            performOutputDataMapping(resolvedAssignments, declViewModel, prop); // Update binding when data changed\n\n            _.defer(function () {\n              //new in afx 3.1.0\n              if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (d)')) {\n                return;\n              }\n\n              _finishAction(declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred);\n            });\n          }\n\n          debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'post', action, declViewModel, resolvedAssignments);\n\n          if (logger.isTraceEnabled()) {\n            let actionName = action.actionId ? action.actionId : action.method;\n            let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n            logger.trace('Action: ', actionName2);\n          }\n        });\n      } else {\n        _finishAction(declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred);\n\n        if (logger.isTraceEnabled()) {\n          let actionName = action.actionId ? action.actionId : action.method;\n          let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n          logger.trace('Action: ', actionName2);\n        }\n      }\n    }, function (err) {\n      // Extract error message from response and store it in view model\n      var error = _.cloneDeep(err);\n\n      _.set(declViewModel, 'error', error);\n\n      if (actionPolicyId) {\n        propertyPolicySvc.unregister(actionPolicyId);\n      }\n\n      _processError(err, declViewModel, action, dataCtxNode, depModuleObj);\n\n      deferred.reject(err);\n    });\n  });\n  return deferred.promise;\n};\nexports = {\n  performSOAAction,\n  executeAction,\n  performDataProviderAction,\n  performActionSync\n};\nexport default exports;","map":{"version":3,"names":["soaSvc","declarativeDataCtxSvc","propertyPolicySvc","appCtxSvc","messagingSvc","conditionSvc","navigationService","adapterSvc","dataMapperSvc","cfgSvc","batchActionService","_","eventBus","browserUtils","parsingUtils","declUtils","logger","moduleLoader","AwHttpService","AwPromiseService","ClipboardService","debugService","_actionPropsToLog","_logActionActivity","getUrlAttributes","logActionActivity","undefined","_logActionEventActivity","logActionEventActivity","exports","_callSOA","action","inputData","propertyPolicyOverride","promise","actionType","serviceName","postUnchecked","method","headerState","instance","reject","actionInputDataLogging","info","JSON","stringify","outputData","processActionTypeEvent","declViewModel","dataCtxNode","functionsList","depModuleObj","deferred","setTimeout","isValidModelAndDataCtxNode","logLifeCycleIssue","localContext","getLatestContext","forEach","events","event","conditionValue","condition","evaluateConditionExpression","data","evaluationEnv","name","eventDataToPublish","eventData","cloneDeep","applyScope","_source","_internal","modelId","excludeLocalDataCtx","scope","isDeclarativeLogEnabled","debugEventPub","publish","resolve","processActionTypeJsFun","params","param","push","applyFn","apply","then","resolved","err","error","errorCode","getActionInputData","navigationParams","eveulateActionParameters","parameters","keySequence","pattern","processInputData","value","key","isObject","pop","isString","test","eventMapKey","join","parameterKey","getStringBetweenDoubleMustaches","set","get","resolveInputData","inputError","isDestroyed","_processAllDataProvider","dataProviderArray","promises","providerObj","provider","dataProvider","json","firstPage","firstPageObjs","uid","vmos","objects","Array","isArray","prototype","maxToLoad","actionInputData","searchInput","totalFound","length","update","args","all","performDataProviderAction","debug","panelId","actionId","createDataProviderInput","methods","dataProviders","dpAction","resetDataProvider","warn","isEmpty","dispatch","path","processActionTypePopup","popupAction","actions","updateOptions","options","commandContext","show","getCtx","deps","evaluatedOptions","error2","processActionTypeCopy","copyType","adaptedObjects","getAdaptedObjectsSync","objectToCopy","copyUrlToClipboard","when","copyHyperlinkToClipboard","processActionTypeNaviagte","navigateTo","navigate","processActionTypeEdit","indexOf","processActionTypeSync","port","syncStrategyService","updatePort","loadCustomActionDependentModule","customAction","getDependentModule","loadDependentModule","success","_performAction","altInputData","applyExpression","request","defer","executeBatchActions","processActionTypeCustom","getCfg","actionTemplateDefs","resolver","depModuleObjPromise","processDefaultErrorMsg","message","processDefaultErrorTypeObject","isReported","errInfo","config","status","url","statusText","cause","errMsg","parseConditonExp","expression","exp","getRealExpression","_processActionEvents","isSuccess","functions","processActionFailureEvents","failure","partialErrors","failureEvt","partialError","errorValues","errorValue","code","errorCodes","response","processPartialError","actionMessages","matchingMessages","failureErr","condValue","processActionHavingCause","allMessages","messages","conditionResult","reportNotyMessage","processActionHavingErrorCode","processActionFailureMessage","scopedAllMessages","reportError","idx","reduce","acc","index","arr","performOutputDataMapping","resolvedAssignments","prop","updateAtomicData","finalObj","basePath","split","atomicData","Object","keys","fromPath","toPath","loadFuncDependency","functionDeps","getFunctionDeps","funcValue","funcKey","loaded","find","funcDep","includes","remove","getActionPolicyInfo","policy","override","types","actionPolicyId","register","_processSuccess","successMessage","_processError","_finishAction","actionResponseObj","PartialErrors","createError","ServiceData","performOutputDataMappingForBatch","actionData","resolveActionOutputData","mapDataOnAction","deferredAssignments","fromObj","outputArg","isBoolean","fromResultPath","getOutput","toCtxName","updatePartialCtx","startsWith","ports","replace","_isViewModelDestroyed","methodName","performSOAAction","isNil","performActionSync","executeAction","assertValidModelDataCtxNodeAndAction2","loadDependentModules","functionDependancies","funcDepVal","funcDepKey","unregister","dataParsers","applyDataParseDefinitions","isTraceEnabled","actionName","actionName2","viewId","trace"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/actionService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/actionService\n *\n * @namespace actionService\n */\n\nimport soaSvc from 'soa/kernel/soaService';\nimport declarativeDataCtxSvc from 'js/declarativeDataCtxService';\nimport propertyPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingSvc from 'js/messagingService';\nimport conditionSvc from 'js/conditionService';\nimport navigationService from 'js/navigationService';\nimport adapterSvc from 'js/adapterService';\nimport dataMapperSvc from 'js/dataMapperService';\nimport cfgSvc from 'js/configurationService';\nimport batchActionService from 'js/batchActionService';\n/** revisitme Shaishav\n * Hint: We need to bring following services\nimport wysModeSvc from 'js/wysiwygModeService';\n*/\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport declUtils from 'js/declUtils';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n\n// Services\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport ClipboardService from 'js/clipboardService';\nimport debugService from 'js/debugService';\n\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\nvar _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'actionId' ];\n\n/**\n * {Boolean} TRUE if 'action' activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current\n * document's URL.\n */\nvar _logActionActivity = browserUtils.getUrlAttributes().logActionActivity !== undefined;\n\n/**\n * {Boolean} TRUE if 'action' event activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current\n * document's URL.\n */\nvar _logActionEventActivity = browserUtils.getUrlAttributes().logActionEventActivity !== undefined;\n\n/**\n * Define public API\n */\nvar exports = {};\n\n/**\n * Makes SOA call with given action and inputData. return the promise object.\n *\n * @param {Object} action - The 'declAction' object.\n * @param {Object} inputData - The 'inputData' object.\n *\n * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a\n *         problem).\n */\nvar _callSOA = function( action, inputData, propertyPolicyOverride ) {\n    var promise = null;\n    if( action.actionType === 'TcSoaService' ) {\n        if( action.serviceName ) {\n            if( action.inputData ) {\n                promise = soaSvc.postUnchecked( action.serviceName, action.method, inputData, propertyPolicyOverride, null, action.headerState );\n            } else {\n                promise = AwPromiseService.instance.reject( 'No TcSoaService input data specified' );\n            }\n        } else {\n            promise = AwPromiseService.instance.reject( 'No TcSoaService service specified' );\n        }\n    } else {\n        promise = AwPromiseService.instance.reject( 'Unknown action type: ' + action.actionType );\n    }\n    return promise;\n};\n\nvar actionInputDataLogging = function( action, inputData ) {\n    /**\n     * Now that any binding has happened, log the current action (if necessary)\n     */\n    if( _logActionActivity ) {\n        logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) );\n\n        if( action.actionType === 'RESTService' ) {\n            logger.info( 'RESTService.inputData: ' + '\\n' + JSON.stringify( inputData, null, 2 ) );\n        } else if( action.actionType === 'GraphQL' || action.actionType === 'JSFunctionAsync' && action.method === 'callGraphQL' ) {\n            logger.info( 'GraphQL.inputData: ' + '\\n' + JSON.stringify( inputData, null, 2 ) );\n            if( action.outputData ) {\n                logger.info( 'GraphQL.outputData: ' + '\\n' + JSON.stringify( action.outputData, null, 2 ) );\n            }\n        }\n    }\n};\n\nvar processActionTypeEvent = function( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred ) {\n    setTimeout( function() {\n        if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action not processed.',\n                'applyExpression' );\n            return;\n        }\n        // here needs updated info and eveulation context\n        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n        /**\n         * Loop for each 'event' type action and publish the ones who's conditions are\n         * currently TRUE.\n         */\n        _.forEach( action.inputData.events, function( event ) {\n            var conditionValue = true;\n\n            if( event.condition ) {\n                conditionValue = conditionSvc.evaluateConditionExpression( event.condition, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );\n            }\n\n            if( conditionValue ) {\n                if( _logActionEventActivity ) {\n                    logger.info( 'action: ' + '\\n' +\n                        JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'ActionEvent: ' + event.name );\n                }\n\n                var eventDataToPublish = {};\n\n                if( event.eventData ) {\n                    eventDataToPublish = _.cloneDeep( event.eventData );\n\n                    declarativeDataCtxSvc.applyScope( localContext.data, eventDataToPublish,\n                        functionsList, localContext, depModuleObj );\n                }\n\n                eventDataToPublish._source = declViewModel._internal.modelId;\n\n                if( event.excludeLocalDataCtx !== true ) {\n                    eventDataToPublish.scope = localContext;\n                }\n\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugEventPub( action, event, localContext.data, localContext, eventDataToPublish );\n                }\n\n                eventBus.publish( event.name, eventDataToPublish, true );\n            }\n        } );\n\n        deferred.resolve();\n    }, 0 );\n};\n\nvar processActionTypeJsFun = function( inputData, action, deferred, depModuleObj ) {\n    var params = [];\n    _.forEach( inputData, function( param ) {\n        params.push( param );\n    } );\n    try {\n        const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );\n        if( typeof applyFn?.then === 'function' ) {\n            applyFn.then(\n                resolved => {\n                    deferred.resolve( resolved );\n                },\n                err => {\n                    deferred.reject( err );\n                } );\n        } else {\n            deferred.resolve( applyFn );\n        }\n    } catch ( error ) {\n        deferred.reject( {\n            errorCode: error\n        } );\n    }\n};\n\nvar getActionInputData = function( action, inputData ) {\n    if( action.inputData ) {\n        inputData = _.cloneDeep( action.inputData );\n    } else if( action.navigationParams ) {\n        if( typeof action.navigationParams === 'string' ) {\n            inputData = { navigationParams: action.navigationParams };\n        } else {\n            inputData = _.cloneDeep( action.navigationParams );\n        }\n    }\n    return inputData;\n};\n\nvar eveulateActionParameters = function( dataCtxNode, action, inputData ) {\n    // if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data\n    // does not exist. In that case we need to process the dataCtxNode.parameter section to get default value\n    // for the parameters We might have some inputdata, which is referring to parameters section. The\n    // below code scans the action.inputData for \"{{parameters\" keyword as value in action.inputdata.\n    // {action: parameters: { \"param1\": \"{{data.xyz}}\"}, inputdata : { \"key1\":\"{{parameter.param1}}\"}}\n    // and replaces them with the default value specified in parameters in action.inputdata :\n    // {\"key1\":\"{{data.param1}}\" later we resolve the inputData, this helps us not to use applyScope\n    // twice.\n    if( !dataCtxNode.parameters && action.parameters ) {\n        var keySequence = [];\n        var pattern = /^{{parameters/;\n        _.forEach( action.inputData, function processInputData( value, key ) {\n            if( value && _.isObject( value ) ) {\n                keySequence.push( key );\n                _.forEach( value, processInputData );\n                keySequence.pop();\n            } else if( value && _.isString( value ) && pattern.test( value ) ) {\n                keySequence.push( key );\n                var eventMapKey = keySequence.join( '.' );\n                var parameterKey = parsingUtils.getStringBetweenDoubleMustaches( value );\n                _.set( inputData, eventMapKey, _.get( action, parameterKey, null ) );\n                keySequence.pop();\n            }\n        } );\n    }\n};\n\nvar resolveInputData = function( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError ) {\n    if( inputData ) {\n        if( declViewModel.isDestroyed() ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',\n                '_performAction' );\n        } else {\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            try {\n                declarativeDataCtxSvc.applyScope( localContext.data, inputData, functionsList, localContext,\n                    depModuleObj );\n            } catch ( error ) {\n                inputError = error;\n            }\n        }\n    }\n    return inputError;\n};\n\nvar _processAllDataProvider = function( dataProviderArray, declViewModel, dataCtxNode ) {\n    var promises = [];\n\n    _.forEach( dataProviderArray, function( providerObj ) {\n        var provider = providerObj.dataProvider;\n        /**\n         * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those\n         * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize\n         * the dataProvider and let it decide what to load.\n         */\n\n        if( provider.json.firstPage ) {\n            var firstPageObjs = [];\n\n            _.forEach( provider.json.firstPage, function( uid ) {\n                var vmos = declViewModel.objects[ uid ];\n                if( Array.isArray( vmos ) ) {\n                    Array.prototype.push.apply( firstPageObjs, vmos );\n                } else if( vmos !== undefined ) { // LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.\n                    firstPageObjs.push( vmos );\n                }\n            } );\n\n            /**\n             * This code evaluates the page size to determine if we need to increment total. This is\n             * necessary for object sets, as we do not know the totalFound.\n             */\n            var maxToLoad;\n            if( provider.action && provider.action.inputData ) {\n                var actionInputData = provider.action.inputData;\n                if( actionInputData.searchInput ) {\n                    maxToLoad = actionInputData.searchInput.maxToLoad;\n                }\n            }\n\n            var totalFound = firstPageObjs.length > 0 ? firstPageObjs.length + 1 : 0;\n            if( maxToLoad ) {\n                totalFound = firstPageObjs.length === maxToLoad ? firstPageObjs.length + 1 :\n                    firstPageObjs.length;\n            }\n\n            provider.update( firstPageObjs, totalFound );\n        } else {\n            var args = [ dataCtxNode, declViewModel ];\n            promises.push( provider[ providerObj.action ].apply( provider, args ) );\n        }\n    } );\n\n    return AwPromiseService.instance.all( promises );\n};\n\n/**\n * Execute the given 'dataprovider action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.\n */\nexport let performDataProviderAction = function( declViewModel, action, dataCtxNode ) {\n    var dataProviderArray = [];\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel );\n    var createDataProviderInput = function( dataProvider, action ) {\n        return {\n            dataProvider: dataProvider,\n            action: action ? action : 'initialize'\n        };\n    };\n\n    if( action.methods && _.isArray( action.methods ) ) {\n        _.forEach( action.methods, function( method ) {\n            var dataProvider = declViewModel.dataProviders[ method ];\n            var dpAction = action.inputData && action.inputData.action ? action.inputData.action : 'initialize';\n            if( dataProvider ) {\n                dataProviderArray.push( createDataProviderInput( dataProvider, dpAction ) );\n            }\n        } );\n    } else if( action.method ) {\n        if( action.inputData && action.inputData.action ) {\n            // Table edit use case\n            var dpAction = action.inputData.action;\n            dataProviderArray.push( createDataProviderInput( declViewModel.dataProviders[ action.method ], dpAction ) );\n        } else {\n            // with the new implementation resetDataProvider will re-initialize the dataprovider.\n            declViewModel.dataProviders[ action.method ].resetDataProvider();\n        }\n    } else {\n        logger.warn( 'Missing action method(s) name for action: ' + '\\n' +\n            JSON.stringify( action, _actionPropsToLog, 2 ) );\n    }\n\n    if( !_.isEmpty( dataProviderArray ) ) {\n        const { dispatch } = declViewModel;\n        return _processAllDataProvider( dataProviderArray, declViewModel, dataCtxNode )\n            .then( () => {\n                // Rules to use dispatch:\n                // - Make sure it is 'immutable change' otherwise it is not getting rerender\n                // - Make sure 'immutable change' dosen't change the object type with no indention\n                //   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object\n                dispatch( { path: 'dataProviders', value: { ...declViewModel.dataProviders } } );\n            } );\n    }\n    return 0;\n};\n\nvar processActionTypePopup = function( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj ) {\n    let popupAction = declViewModel.actions[ action.actionId ];\n    let updateOptions = inputData && inputData.options || {};\n    // override popupAction if defined in commandContext - AwCommandService\n    // options could be overridden and customized\n    if( dataCtxNode.commandContext?.popupAction ) {\n        // case: it's a normal command\n        popupAction = dataCtxNode.commandContext.popupAction;\n    } else if( !popupAction.show ) {\n        // case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.\n        popupAction = appCtxSvc.getCtx( 'globalPopup' );\n    }\n\n    // case customized popup actions - inject popupAction as last params for action.method\n    // application manages when / how to invoke show / hide\n    if( action.method && action.deps ) {\n        let params = [];\n        _.forEach( inputData, function( param ) {\n            params.push( param );\n        } );\n        params.push( popupAction, updateOptions );\n        try {\n            const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );\n            if( typeof applyFn?.then === 'function' ) {\n                applyFn.then(\n                    resolved => {\n                        deferred.resolve( resolved );\n                    },\n                    err => {\n                        deferred.reject( err );\n                    } );\n            } else {\n                deferred.resolve( applyFn );\n            }\n        } catch ( error ) {\n            deferred.reject( {\n                errorCode: error\n            } );\n        }\n        // default plain popup actions\n    } else {\n        // TODO: build params based on inputData, props, viewData\n        let evaluatedOptions = inputData && inputData.options || null;\n        // only apply dynamic options\n        // if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {\n        //     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {\n        //         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );\n        //         return result;\n        //     }, {} );\n        // }\n        try {\n            popupAction.show( evaluatedOptions ).then(\n                function( resolved ) {\n                    deferred.resolve( resolved );\n                },\n                function( err ) {\n                    deferred.reject( err );\n                } );\n        } catch ( error2 ) {\n            deferred.reject( {\n                errorCode: error2\n            } );\n        }\n    }\n};\n\nvar processActionTypeCopy = function( inputData, promise ) {\n    /**\n     * This actionType is needed when we are dealing with OS commands like copying to clipboard\n     * which needs to run without any defer mechanism. Since document.execCommand('copy') will\n     * be successful only when it runs through a user click event and not with defer and digest\n     * cycle event. we can use this actionType for other copy command too apart from shareURL\n     * since it calls the same document.execCommand('copy') function after copying it to\n     * awclipboard.\n     */\n    /**\n     * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.\n     */\n    if( inputData.copyType === 'URL' ) {\n        var adaptedObjects = adapterSvc.getAdaptedObjectsSync( inputData.objectToCopy );\n\n        ClipboardService.instance.copyUrlToClipboard( adaptedObjects );\n\n        promise = AwPromiseService.instance.when();\n    } else if( inputData.copyType === 'Object' ) {\n        ClipboardService.instance.copyHyperlinkToClipboard( inputData.objectToCopy );\n\n        promise = AwPromiseService.instance.when();\n    }\n    return promise;\n};\n\nvar processActionTypeNaviagte = function( action, inputData ) {\n    if( action.navigateTo ) {\n        if( inputData.navigationParams ) {\n            inputData = inputData.navigationParams;\n        }\n        return navigationService.navigate( action, inputData );\n    }\n    return AwPromiseService.instance.reject( 'Missing navigate to in action type: ' + action.actionType +\n        ' for actionId: ' + action.actionId );\n};\n\nvar processActionTypeEdit = function( action, declViewModel ) {\n    var methods = [ 'startEdit', 'saveEdits', 'cancelEdits', 'isDirty' ];\n\n    if( action.method && methods.indexOf( action.method ) !== -1 ) {\n        return declViewModel[ action.method ].apply( declViewModel );\n    }\n    return AwPromiseService.instance.reject( 'Not a valid edit action : ' + action.method );\n};\n\nvar processActionTypeSync = function( action, inputData, declViewModel ) {\n    if( inputData.port ) {\n        return import( 'js/syncStrategyService' ).then( function( syncStrategyService ) {\n            return syncStrategyService.updatePort( declViewModel, inputData, exports );\n        } );\n    }\n    return AwPromiseService.instance.reject( 'Missing port to in action type: ' + action.actionType + ' for actionId: ' + action.actionId );\n};\n\nvar loadCustomActionDependentModule = function( customAction ) {\n    var depModuleObj = moduleLoader.getDependentModule( customAction.deps );\n\n    if( depModuleObj ) {\n        return AwPromiseService.instance.resolve( depModuleObj );\n    }\n    return moduleLoader.loadDependentModule( customAction.deps ).then( function success( depModuleObj ) {\n        return AwPromiseService.instance.resolve( depModuleObj );\n    }, function reject( error ) {\n        return AwPromiseService.instance.reject( error );\n    } );\n};\n\n/**\n * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will\n * be returned.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n * @param {Object} action - The 'declAction' to be executed.\n * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.\n * @param {Object} dataCtxNode - The data context node which holds interpolation values.\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n */\nvar _performAction = function( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride ) {\n    if( !action ) {\n        return AwPromiseService.instance.reject( 'Missing action parameter' );\n    }\n\n    if( !action.actionType ) {\n        return AwPromiseService.instance.reject( 'Missing action type for actionId: ' + action.actionId );\n    }\n\n    var inputData = null;\n    var inputError = null;\n\n    /**\n     * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.\n     * <P>\n     * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the\n     * time the action is queued to be executed and when we get here.\n     */\n\n    if( action.altInputData ) {\n        inputData = action.altInputData;\n    } else {\n        inputData = getActionInputData( action, inputData );\n\n        eveulateActionParameters( dataCtxNode, action, inputData );\n\n        inputError = resolveInputData( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError );\n    }\n\n    /**\n     * Now that any binding has happened, log the current action (if necessary)\n     */\n    actionInputDataLogging( action, inputData );\n\n    /**\n     * Check for an input error\n     */\n    var promise = null;\n\n    var deferred;\n\n    if( inputError ) {\n        promise = AwPromiseService.instance.reject( {\n            errorCode: inputError\n        } );\n        return promise;\n    }\n\n    return declarativeDataCtxSvc.applyExpression( inputData ).then(\n        function() {\n            debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel, inputData );\n            if( action.actionType === 'dataProvider' ) {\n                promise = exports.performDataProviderAction( declViewModel, action, dataCtxNode );\n            } else if( action.actionType === 'TcSoaService' ) {\n                promise = _callSOA( action, inputData, propertyPolicyOverride );\n            } else if( action.actionType === 'RESTService' ) {\n                promise = AwHttpService.instance( inputData.request );\n            } else if( action.actionType === 'Event' ) {\n                if( action.inputData ) {\n                    deferred = AwPromiseService.instance.defer();\n                    processActionTypeEvent( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred );\n                    promise = deferred.promise;\n                }\n            } else if( action.actionType === 'JSFunction' || action.actionType === 'JSFunctionAsync' ) {\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypeJsFun( inputData, action, deferred, depModuleObj );\n            } else if( action.actionType === 'Test' ) {\n                /**\n                 * This actionType is meant to allow automated testing without the need for a live server to\n                 * load dependent modules. The resolved data for the deferred action is just the same object\n                 * that was given as the 'inputData'.\n                 */\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                deferred.resolve( inputData );\n            } else if( action.actionType === 'popup' ) {\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypePopup( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj );\n            } else if( action.actionType === 'Copy' ) {\n                promise = processActionTypeCopy( inputData, promise );\n            } else if( action.actionType === 'Navigate' ) {\n                promise = processActionTypeNaviagte( action, inputData );\n            } else if( action.actionType === 'Edit' ) {\n                promise = processActionTypeEdit( action, declViewModel );\n            } else if( action.actionType === 'batchJob' ) {\n                promise = batchActionService.executeBatchActions( declViewModel, action, dataCtxNode, exports );\n            } else if( action.actionType === 'Sync' ) {\n                return processActionTypeSync( action, inputData, declViewModel );\n            } else {\n                // process custom Action Type\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypeCustom( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj );\n            } // end of custom action\n            return promise;\n        } );\n};\n\nvar processActionTypeCustom = function( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj ) {\n    cfgSvc.getCfg( 'actionTemplateDefs' ).then( function( actionTemplateDefs ) {\n        if( actionTemplateDefs[ action.actionType ] ) {\n            var customAction = _.cloneDeep( actionTemplateDefs[ action.actionType ] );\n            // resolver for inputData defined at successive action template defs that include\n            // ctx, data and inputData\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            var resolver = {\n                ...localContext,\n                inputData: inputData\n            };\n            // load the dependent modules if deps is specified\n            if( customAction.deps ) {\n                var depModuleObjPromise = loadCustomActionDependentModule( customAction );\n\n                depModuleObjPromise.then( function( depModuleObj ) {\n                    deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );\n                } );\n            } else {\n                deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );\n            }\n        } else {\n            logger.error( 'error :: action type ->' + action.actionType + ' is missing.' );\n            deferred.reject( 'Unknown action type: ' + action.actionType );\n        }\n    } );\n};\n\nvar processDefaultErrorMsg = function( err, action ) {\n    //var msg = null;\n    //var level = 1;\n    if( _.isString( err ) ) {\n        /**msg = err;\n        level = 3; */\n    } else if( err && err.message ) {\n        /**msg = err.message.replace( /\\n/g, '<br>' );\n        level = err.level ? err.level : 3; */\n    } else {\n        /**msg = 'Unknown error message type for action ' + action.method;\n        level = 3;*/\n        logger.error( err );\n    }\n    /** revisitme Shaishav\n         * Hint: We need to bring wysiwygModeService\n         if( level <= 1 ) {\n             logger.info( msg );\n         } else {\n             wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );\n         }\n    */\n};\n\nvar processDefaultErrorTypeObject = function( err, isReported ) {\n    var errInfo = null;\n    if( err.config && err.status && ( err.status < 200 || err.status > 299 ) ) {\n        /**\n         * Error from Angular's $http service.\n         */\n        errInfo = {\n            url: err.config.url,\n            method: err.config.method,\n            status: err.status,\n            statusText: err.statusText\n        };\n    } else if( err.cause && err.cause.config ) {\n        /**\n         * Error due to lost network connectivity, server crash etc.\n         */\n        errInfo = {\n            url: err.cause.config.url,\n            method: err.cause.config.method,\n            status: err.cause.status,\n            statusText: err.cause.statusText\n        };\n    }\n\n    if( errInfo !== null ) {\n        var errMsg = 'The HTTP \"' + errInfo.method + '\" method to url \"' + errInfo.url + '\" failed';\n\n        if( _.isString( errInfo.statusText ) && errInfo.statusText.length > 0 ) {\n            errMsg = errMsg + ' (status = \"' + errInfo.statusText + '\").';\n        } else {\n            errMsg = errMsg + ' (status = \"' + errInfo.status + '\").';\n        }\n\n        isReported = true;\n\n        logger.error( errMsg );\n    }\n    return isReported;\n};\n\nconst parseConditonExp = ( expression, evaluationEnv ) => {\n    //This is not acomplete fix, needs to be revisited - LCS-565498\n    const exp = conditionSvc.getRealExpression( expression, evaluationEnv );\n    if( _.isString( exp ) ) {\n        return exp;\n    }\n    //If the condition is object based, return the original expression\n    return expression;\n};\n\n/**\n * Process the events of the executed action\n *\n * @param {DeclViewModel} declViewModel - The declarative view model\n * @param {DeclAction} action - The declarative action.\n * @param {Object} events - The events of an action object on the View model\n * @param {Object} evaluationEnv - The environment on which to evaluate event conditions\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing\n *            action 'failure'.\n */\nvar _processActionEvents = function( declViewModel, action, events, evaluationEnv, dataCtxNode, depModuleObj,\n    isSuccess ) {\n    /**\n     * Check if there is no reason to continue.\n     */\n    if( _.isEmpty( events ) ) {\n        return;\n    }\n\n    //new in afx 3.1.0\n    if( declViewModel.isDestroyed() ) {\n        declUtils.logLifeCycleIssue( declViewModel, action, 'Action event(s) not processed.', '_processActionEvents' );\n        return;\n    }\n\n    var functionsList = declViewModel._internal.functions;\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'events' );\n\n    _.forEach( events, function( event ) {\n        /**\n         * Fire event when condition value is true\n         */\n        var conditionValue = true;\n\n        if( event.condition ) {\n            const expression = parseConditonExp( event.condition, declViewModel._internal );\n            conditionValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n        }\n\n        if( conditionValue ) {\n            if( _logActionEventActivity ) {\n                if( isSuccess ) {\n                    logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'SuccessEvent: ' + event.name );\n                } else {\n                    logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'FailureEvent: ' + event.name );\n                }\n            }\n            var eventData = {};\n            if( event.eventData ) {\n                eventData = _.cloneDeep( event.eventData );\n                declarativeDataCtxSvc.applyScope( declViewModel, eventData, functionsList, dataCtxNode,\n                    depModuleObj );\n            }\n            if( event.excludeLocalDataCtx !== true ) {\n                eventData.scope = dataCtxNode;\n            }\n            eventData._source = declViewModel._internal.modelId;\n            eventBus.publish( event.name, eventData, true );\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugEventPub( action, event, declViewModel, dataCtxNode, eventData );\n            }\n        }\n    } );\n};\n\nvar processActionFailureEvents = function( events, err, evaluationEnv, declViewModel, action, dataCtxNode, depModuleObj ) {\n    if( events && events.failure ) {\n        if( err.cause && err.cause.partialErrors ) {\n            /**\n             * Add the error in the evaluation env for each of the events\n             */\n            _.forEach( events.failure, function( failureEvt ) {\n                _.forEach( err.cause.partialErrors, function( partialError ) {\n                    if( partialError.errorValues ) {\n                        _.forEach( partialError.errorValues, function( errorValue ) {\n                            if( errorValue.code ) {\n                                evaluationEnv.errorCode = errorValue;\n\n                                if( !evaluationEnv.errorCodes ) {\n                                    evaluationEnv.errorCodes = [];\n                                }\n\n                                evaluationEnv.errorCodes.push( errorValue );\n                            }\n                        } );\n                    }\n                } );\n\n                _processActionEvents( declViewModel, action, [ failureEvt ], evaluationEnv, dataCtxNode,\n                    depModuleObj, false );\n            } );\n\n            // If REST call is failed with error\n        } else if( err.status || err.response?.status  ) {\n            // Add the error in the evaluation env for each of the events\n            evaluationEnv.errorCode = err;\n\n            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,\n                depModuleObj, false );\n        } else {\n            // Process all events in bulk\n            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,\n                depModuleObj, false );\n        }\n    }\n};\n\nvar processPartialError = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {\n    let matchingMessages = [];\n    _.forEach( err.cause.partialErrors, function( partialError ) {\n        if( partialError.errorValues ) {\n            _.forEach( partialError.errorValues, function( errorValue ) {\n                if( errorValue.code ) {\n                    _.forEach( actionMessages.failure, function( failureErr ) {\n                        var condValue = true;\n\n                        if( failureErr.condition ) {\n                            evaluationEnv.errorCode = errorValue;\n                            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n                            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n                        }\n\n                        if( condValue ) {\n                            if( !failureErr.errorCode ) {\n                                failureErr.errorCode = [];\n                            }\n                            failureErr.errorCode.push( errorValue );\n\n                            if( matchingMessages.indexOf( failureErr ) === -1 ) {\n                                matchingMessages.push( failureErr );\n                            }\n                        }\n                    } );\n                }\n            } );\n        }\n    } );\n    return matchingMessages;\n};\n\nvar processActionHavingCause = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {\n    let allMessages = null;\n    let isReported = false;\n    _.forEach( err.cause.messages, function( message ) {\n        if( message.code ) {\n            _.forEach( actionMessages.failure, function( failureErr ) {\n                let conditionResult = false;\n                if( failureErr.condition ) {\n                    // two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123\n                    evaluationEnv.errorCode = failureErr.condition.indexOf( '.code' ) > -1 ? message : message.code;\n                    const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n                    conditionResult = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n                }\n                if( conditionResult || failureErr.message && failureErr.condition === undefined ) {\n                    isReported = true;\n\n                    if( !allMessages ) {\n                        allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    }\n\n                    evaluationEnv.errorCode = message.message;\n                    messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message, evaluationEnv );\n                }\n            } );\n        }\n    } );\n    return isReported;\n};\n\nvar processActionHavingErrorCode = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode ) {\n    var isReported = false;\n    var allMessages = null;\n    /**\n     * Notify error raised by a JS function call\n     */\n    _.forEach( actionMessages.failure, function( failureErr ) {\n        var condValue = true;\n        if( failureErr.condition ) {\n            if( err.status || err.response?.status ) {\n                // In case failure is from REST call\n                evaluationEnv.errorCode = err;\n            } else {\n                evaluationEnv.errorCode = err.errorCode;\n            }\n            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n        }\n        if( condValue ) {\n            isReported = true;\n\n            if( !allMessages ) {\n                allMessages = _.cloneDeep( declViewModel._internal.messages );\n            }\n\n            messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message,\n                dataCtxNode, depModuleObj );\n        }\n    } );\n\n    return isReported;\n};\n\nvar processActionFailureMessage = function( actionMessages, err, evaluationEnv, declViewModel, depModuleObj, isReported, dataCtxNode ) {\n    if( actionMessages && actionMessages.failure ) {\n        if( err.cause && err.cause.partialErrors ) {\n            // Notify error message when condition matched\n            var allMessages;\n            if( actionMessages.failure.length > 0 ) {\n                var matchingMessages = [];\n                var scopedAllMessages = [];\n                var reportError = function( failureErr, idx ) {\n                    evaluationEnv.errorCode = failureErr.errorCode.reduce( ( acc, err, index, arr ) => {\n                        acc += err.message + ( arr.length - 1 === index ? '' : '<br/>' );\n                        return acc;\n                    }, '' );\n\n                    messagingSvc.reportNotyMessage( declViewModel, scopedAllMessages[ idx ], failureErr.message,\n                        evaluationEnv );\n                    failureErr.errorCode = null;\n                };\n\n                matchingMessages = processPartialError( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );\n                if( !allMessages && matchingMessages.length > 0 ) {\n                    allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    scopedAllMessages.push( allMessages );\n                    isReported = true;\n                }\n                matchingMessages.forEach( function( message, index ) {\n                    reportError( message, index );\n                } );\n            } else {\n                /**\n                 * Notify SOA error message when no condition specified\n\n                var errMessage = messagingSvc.getSOAErrorMessage( err ); */\n                isReported = true;\n                /** revisitme Shaishav\n                 * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module\n                 * should not depend on layer 3 modules. We need to correct that.\n                wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );\n                */\n            }\n        } else if( err.cause && err.cause.messages ) {\n            isReported = processActionHavingCause( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );\n        } else if( err.errorCode || err.status || err.response?.status ) {\n            isReported = processActionHavingErrorCode( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode );\n        }\n    }\n    return isReported;\n};\n\nvar performOutputDataMapping = function( resolvedAssignments, declViewModel, prop ) {\n    const { dispatch, updateAtomicData } = declViewModel;\n    let finalObj = {};\n\n    for( prop in resolvedAssignments ) {\n        // special property\n        const basePath = prop.split( '.' )[ 0 ];\n        if( declViewModel.atomicData && declViewModel.atomicData[ basePath ] ) {\n            _.set( declViewModel.atomicData, prop, resolvedAssignments[ prop ] );\n            updateAtomicData[ basePath ]( _.cloneDeep( declViewModel.atomicData[ basePath ] ) );\n        } else {\n            let key = `data.${prop}`;\n            finalObj[ key ] = resolvedAssignments[ prop ];\n        }\n    }\n\n    if( dispatch && Object.keys( finalObj ).length > 0 ) {\n        dispatch( { value: finalObj } );\n\n        _.forEach( resolvedAssignments, function( fromPath, toPath ) {\n            _.set( declViewModel, toPath, fromPath );\n        } );\n    }\n};\n\nvar loadFuncDependency = function( action, declViewModel, depModuleObj ) {\n    // load function deps\n    var functionDeps = declUtils.getFunctionDeps( action, declViewModel._internal );\n\n    // Filter already loaded deps\n    _.forEach( depModuleObj, function( funcValue, funcKey ) {\n        var loaded = _.find( functionDeps, function( funcDep ) {\n            // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n            // funcKey here is module name, fundDep here is js/fileName\n            // luckly it is passing today\n            return funcDep.includes( funcKey );\n        } );\n        if( loaded ) {\n            _.remove( functionDeps, function( funcDep ) {\n                return funcDep === loaded;\n            } );\n        }\n    } );\n\n    return functionDeps;\n};\n\nvar getActionPolicyInfo = function( action, declViewModel, functionsList, dataCtxNode, depModuleObj ) {\n    if( action.policy && action.actionType === 'TcSoaService' ) {\n        var policy = _.cloneDeep( action.policy );\n\n        declarativeDataCtxSvc.applyScope( declViewModel, policy, functionsList, dataCtxNode, depModuleObj );\n        if( policy.override === true ) {\n            return { propertyPolicyOverride: { types: policy.types } };\n        }\n        return { actionPolicyId: propertyPolicySvc.register( { types: policy.types }, action.method + '_Policy' ) };\n    }\n    return {};\n};\n\n/**\n * Process the 'Success' part of the executed action\n *\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\nvar _processSuccess = function( declViewModel, action, dataCtxNode, depModuleObj ) {\n    var events = action.events;\n    var actionMessages = action.actionMessages;\n    var allMessages;\n\n    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n\n    if( events && events.success ) {\n        _processActionEvents( localContext.data, action, events.success, localContext, localContext, depModuleObj,\n            true );\n    }\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );\n\n    if( actionMessages && actionMessages.success ) {\n        _.forEach( actionMessages.success, function( successMessage ) {\n            if( successMessage ) {\n                var condValue = true;\n\n                if( successMessage.condition ) {\n                    const expression = parseConditonExp( successMessage.condition, declViewModel._internal );\n                    condValue = conditionSvc.evaluateConditionExpression( expression, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );\n                }\n\n                if( condValue ) {\n                    if( !allMessages ) {\n                        allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    }\n\n                    messagingSvc.reportNotyMessage( localContext.data, allMessages, successMessage.message,\n                        localContext );\n                }\n            } else {\n                logger.error( 'Invalid action successMessage:' + successMessage );\n            }\n        } );\n    }\n};\n\n/**\n * Process the error and the 'Failure' part of the executed action\n *\n * @param {Object} err - JavaScript Error object\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\nvar _processError = function( err, declViewModel, action, dataCtxNode, depModuleObj ) {\n    var events = action.events;\n    var actionMessages = action.actionMessages;\n    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n\n    processActionFailureEvents( events, err, localContext, localContext.data, action, localContext, depModuleObj );\n\n    var isReported = false;\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );\n\n    isReported = processActionFailureMessage( actionMessages, err, localContext, localContext.data, depModuleObj, isReported, localContext );\n\n    if( !isReported && typeof err === 'object' ) {\n        isReported = processDefaultErrorTypeObject( err, isReported );\n    }\n\n    /**\n     * Fall back, report error if not raised till this point\n     */\n    if( !isReported ) {\n        processDefaultErrorMsg( err, action );\n    }\n};\n\n/**\n * @param {DeclViewModel} declViewModel - Model that owns the action.\n * @param {DeclAction} action - Action to 'finish'.\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.\n * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.\n * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.\n */\nvar _finishAction = function( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred ) {\n    var err = null;\n\n    if( !_.isEmpty( actionResponseObj ) ) {\n        if( !_.isEmpty( actionResponseObj.partialErrors ) || !_.isEmpty( actionResponseObj.PartialErrors ) ) {\n            err = soaSvc.createError( actionResponseObj );\n        }\n\n        if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {\n            err = soaSvc.createError( actionResponseObj.ServiceData );\n        }\n    }\n\n    if( err ) {\n        _processError( err, declViewModel, action, dataCtxNode, depModuleObj );\n\n        deferred.reject( err );\n    } else {\n        _processSuccess( declViewModel, action, dataCtxNode, depModuleObj );\n\n        deferred.resolve( actionResponseObj );\n    }\n};\n\nvar performOutputDataMappingForBatch = function( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred ) {\n    var data = { actionData: [] };\n    _.forEach( resolvedAssignments, function( fromPath, toPath ) {\n        _.set( data.actionData, toPath, fromPath );\n    } );\n    _finishAction( declViewModel, action, dataCtxNode, depModuleObj, data,\n        deferred );\n};\n\nvar resolveActionOutputData = function( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode ) {\n    var deferredAssignments = {};\n    /**\n     * Loop for each mapping in the 'outputData' spec\n     */\n    var index = 0;\n    _.forEach( action.outputData, function( fromPath, toPath ) {\n        var fromObj;\n\n        if( mapDataOnAction && action.outputArg ) {\n            toPath = action.outputArg[ index ];\n        }\n\n        if( _.isBoolean( fromPath ) ) {\n            fromObj = fromPath;\n        } else if( _.isEmpty( fromPath ) ) {\n            /**\n             * To support action as JS function call, assign function return value as the result\n             * when empty value expression specified\n             */\n            fromObj = actionResponseObj;\n        } else if( _.isString( fromPath ) && fromPath.indexOf( 'result.' ) === 0 ) {\n            /**\n             * If fromPath has a 'result.' prefix, parse the expression within fromPath to get\n             * the correct value.\n             */\n            var fromResultPath = fromPath.split( 'result.' )[ 1 ];\n\n            fromObj = _.get( actionResponseObj, fromResultPath );\n        } else {\n            /**\n             * If fromPath is defined, parse the expression within fromPath to get the correct\n             * value.\n             */\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            fromObj = declarativeDataCtxSvc.getOutput( declViewModel, actionResponseObj, fromPath,\n                depModuleObj, localContext );\n        }\n\n        /**\n         * If the toPath starts with ctx. update the appCtxService\n         */\n        if( toPath.indexOf( 'ctx.' ) === 0 ) {\n            var toCtxName = toPath.split( 'ctx.' )[ 1 ];\n            appCtxSvc.updatePartialCtx( toCtxName, fromObj );\n        } else if( _.startsWith( toPath, 'ports.' ) ) {\n            if( dataCtxNode.ports ) {\n                _.set( dataCtxNode.ports, toPath.replace( 'ports.', '' ), fromObj );\n            }\n        } else {\n            // The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the\n            // case in cleaner way\n            deferredAssignments[ toPath ] = AwPromiseService.instance.when( fromObj );\n        }\n        index += 1;\n    } );\n\n    return deferredAssignments;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.\n * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}\n * @param {DeclAction} action - {DeclAction} being performed\n * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on\n * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the\n * 'deferred' remains untouched.\n */\nvar _isViewModelDestroyed = function( declViewModel, actionResponseObj, action, deferred, methodName ) {\n    /**\n     * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can\n     * happen, for example, when multiple subscribers are listening to a common event like 'selection' and\n     * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close\n     * (thus destroying the dataCtxNode and the declViewModel associated with it).\n     * <P>\n     * If so: There is nothing more that can be done with the declViewModel and we just want to log a\n     * warning about the life cycle issue and 'resolve' the given 'deferred'.\n     */\n    if( declViewModel.isDestroyed() ) {\n        /**\n         * If the action is trying to actually do something with the response and the view model is\n         * destroyed log an error\n         */\n        if( actionResponseObj ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action was therefore not finished.',\n                methodName );\n        }\n\n        // Otherwise do nothing\n        deferred.resolve();\n\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Perform a SOA action. Support calling SOA service, return the response object.\n *\n * @param {Object} action - The 'declAction' to be executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n */\nexport let performSOAAction = function( action ) {\n    var deferred = AwPromiseService.instance.defer();\n    _callSOA( action, action.inputData ).then( function( actionResponseObj ) {\n        if( !declUtils.isNil( actionResponseObj ) ) {\n            var err = null;\n            if( actionResponseObj.partialErrors || actionResponseObj.PartialErrors ) {\n                err = soaSvc.createError( actionResponseObj );\n            }\n\n            if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {\n                err = soaSvc.createError( actionResponseObj.ServiceData );\n            }\n            if( err ) {\n                deferred.reject( err );\n            } else if( !_.isEmpty( action.outputData ) ) {\n                deferred.resolve( actionResponseObj );\n            }\n        }\n    }, function( err ) {\n        deferred.reject( err );\n    } );\n    return deferred.promise;\n};\n\n/**\n * Perform a action synchronously. Specificly for 'syncFunction' actionType.\n * Returns nothing.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n *\n * @param {Object} action - The 'declAction' to be executed.\n *\n * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.\n *\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n *\n * @returns {Object} The result of the called function.\n */\nexport let performActionSync = function( declViewModel, action, dataCtxNode, depModuleObj ) {\n    if( !action ) {\n        logger.error( 'Missing action definition for actionId ' + action.actionId );\n        return null;\n    }\n\n    if( !action.actionType ) {\n        logger.error( 'Missing action type for actionId: ' + action.actionId );\n        return null;\n    }\n\n    if( action.actionType !== 'syncFunction' ) {\n        logger.error( 'Invalid action type for actionId: ' + action.actionId );\n        return null;\n    }\n    var inputData = null;\n    let inputError = null;\n\n    if( action.inputData ) {\n        inputData = _.cloneDeep( action.inputData );\n    }\n\n    if( inputData ) {\n        if( declViewModel.isDestroyed() ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',\n                'performActionSync' );\n        } else {\n            try {\n                // this may require it  latest info update to latest\n                let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n                declarativeDataCtxSvc.applyScope( localContext.data, inputData, null, localContext,\n                    depModuleObj );\n            } catch ( error ) {\n                inputError = error;\n            }\n        }\n    }\n\n    if( inputError ) {\n        return null;\n    }\n\n    /**\n     * Collect function parameters from input data\n     */\n    var params = [];\n\n    _.forEach( inputData, function( param ) {\n        params.push( param );\n    } );\n\n    try {\n        return depModuleObj[ action.method ].apply( depModuleObj, params );\n    } catch ( err ) {\n        logger.error( 'Action ' + action.actionId + ' cannot be executed\\n' + err );\n    }\n    return null;\n};\n\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in\n *            the execution.\n * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on\n * viewModel/ctx.\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.\n */\nexport let executeAction = function( declViewModel, action, dataCtxNode, depModuleObj, mapDataOnAction, prop ) {\n    // Note: Clipboard Service is not following the correct\n    // another approach is we can try to create asyncLoad method\n    // for all these case and merge them with current thenable flow\n    /** revisitme Shaishav\n     * Hint: Need to find the reason for this line. It is failing to compile in afx-next\n    ClipboardService.instance;\n    */\n\n    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, 'executeAction (a)' );\n\n    var deferred = AwPromiseService.instance.defer();\n\n    var functionsList = declViewModel._internal.functions;\n    var { actionPolicyId, propertyPolicyOverride } = getActionPolicyInfo( action, declViewModel, functionsList, dataCtxNode, depModuleObj );\n    // load function deps\n    var functionDeps = loadFuncDependency( action, declViewModel, depModuleObj );\n\n    /**\n     * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.\n     * This should probably be made right in the future as part of better performance work.\n     */\n    moduleLoader.loadDependentModules( functionDeps ).then( function( functionDependancies ) {\n        _.forEach( functionDependancies, function( funcDepVal, funcDepKey ) {\n            depModuleObj[ funcDepKey ] = funcDepVal;\n        } );\n\n        var promise = _performAction( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride );\n\n        if( !promise ) {\n            deferred.resolved();\n            return;\n        }\n\n        promise.then( function( actionResponseObj ) {\n            /**\n             * Remove any policies that were registered for this action.\n             */\n            if( actionPolicyId ) {\n                propertyPolicySvc.unregister( actionPolicyId );\n            }\n\n            if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (b)' ) ) {\n                return;\n            }\n\n            /**\n             * Check if we have a response and an output data map to work with.\n             * <P>\n             * If so: Process all the action output definitions and stick them on the dataCtxNode.\n             * <P>\n             * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action\n             * object to handle boolean or number type object responses (D-47571).\n             */\n            if( !declUtils.isNil( actionResponseObj ) && !_.isEmpty( action.outputData ) ) {\n                var deferredAssignments = {};\n\n                /* If dataParsers are defined, then run the actionResponseObj through them before pipelining\n                 * to outPutData.\n                 */\n                if( _.isArray( action.dataParsers ) ) {\n                    actionResponseObj = dataMapperSvc.applyDataParseDefinitions( actionResponseObj, declViewModel, action.dataParsers, dataCtxNode, depModuleObj );\n                }\n\n                deferredAssignments = resolveActionOutputData( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode );\n\n                AwPromiseService.instance.all( deferredAssignments ).then(\n                    function( resolvedAssignments ) {\n                        //new in afx 3.1.0\n                        if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (c)' ) ) {\n                            return;\n                        }\n\n                        if( mapDataOnAction ) {\n                            performOutputDataMappingForBatch( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred );\n                        } else {\n                            performOutputDataMapping( resolvedAssignments, declViewModel, prop );\n\n                            // Update binding when data changed\n                            _.defer( function() {\n                                //new in afx 3.1.0\n                                if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (d)' ) ) {\n                                    return;\n                                }\n\n                                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj,\n                                    deferred );\n                            } );\n                        }\n                        debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'post', action, declViewModel, resolvedAssignments );\n                        if( logger.isTraceEnabled() ) {\n                            let actionName = action.actionId ? action.actionId : action.method;\n                            let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n                            logger.trace( 'Action: ', actionName2 );\n                        }\n                    } );\n            } else {\n                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred );\n                if( logger.isTraceEnabled() ) {\n                    let actionName = action.actionId ? action.actionId : action.method;\n                    let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n                    logger.trace( 'Action: ', actionName2 );\n                }\n            }\n        }, function( err ) {\n            // Extract error message from response and store it in view model\n            var error = _.cloneDeep( err );\n            _.set( declViewModel, 'error', error );\n            if( actionPolicyId ) {\n                propertyPolicySvc.unregister( actionPolicyId );\n            }\n            _processError( err, declViewModel, action, dataCtxNode, depModuleObj );\n            deferred.reject( err );\n        } );\n    } );\n\n    return deferred.promise;\n};\n\nexports = {\n    performSOAAction,\n    executeAction,\n    performDataProviderAction,\n    performActionSync\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}