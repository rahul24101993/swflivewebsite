{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/* eslint-disable require-jsdoc */\n\n/* eslint-disable valid-jsdoc */\n\n/**\n * aw Number and Currency Filter Service\n * Formats a number as text.\n * Formats a number as a currency (ie $1,234.56).\n * \n * @module js/awNumberAndCurrencyFilterService\n */\nconst NUMBER_FORMATS = {\n  CURRENCY_SYM: '$',\n  DECIMAL_SEP: '.',\n  GROUP_SEP: ',',\n  PATTERNS: [{\n    gSize: 3,\n    lgSize: 3,\n    maxFrac: 3,\n    minFrac: 0,\n    minInt: 1,\n    negPre: '-',\n    negSuf: '',\n    posPre: '',\n    posSuf: ''\n  }, {\n    gSize: 3,\n    lgSize: 3,\n    maxFrac: 2,\n    minFrac: 2,\n    minInt: 1,\n    negPre: '-\\u00a4',\n    negSuf: '',\n    posPre: '\\u00a4',\n    posSuf: ''\n  }]\n};\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changed the parsedNumber in-place\n */\n\n\nfunction roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {\n  var digits = parsedNumber.d;\n  var fractionLen = digits.length - parsedNumber.i; // determine fractionSize if it is not specified; `+fractionSize` converts it to a number\n\n  fractionSize = typeof fractionSize === 'undefined' ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : Number(fractionSize); // The index of the digit to where rounding is to occur\n\n  var roundAt = fractionSize + parsedNumber.i;\n  var digit = digits[roundAt];\n\n  if (roundAt > 0) {\n    // Drop fractional digits beyond `roundAt`\n    digits.splice(Math.max(parsedNumber.i, roundAt)); // Set non-fractional digits beyond `roundAt` to 0\n\n    for (var j = roundAt; j < digits.length; j++) {\n      digits[j] = 0;\n    }\n  } else {\n    // We rounded to zero so reset the parsedNumber\n    fractionLen = Math.max(0, fractionLen);\n    parsedNumber.i = 1;\n    digits.length = Math.max(1, roundAt = fractionSize + 1);\n    digits[0] = 0;\n\n    for (var i = 1; i < roundAt; i++) {\n      digits[i] = 0;\n    }\n  }\n\n  if (digit >= 5) {\n    if (roundAt - 1 < 0) {\n      for (var k = 0; k > roundAt; k--) {\n        digits.unshift(0);\n        parsedNumber.i++;\n      }\n\n      digits.unshift(1);\n      parsedNumber.i++;\n    } else {\n      digits[roundAt - 1]++;\n    }\n  } // Pad out with zeros to get the required fraction length\n\n\n  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) {\n    digits.push(0);\n  } // Do any carrying, e.g. a digit was rounded up to 10\n\n\n  var carry = digits.reduceRight(function (carry, d, i, digits) {\n    d += carry;\n    digits[i] = d % 10;\n    return Math.floor(d / 10);\n  }, 0);\n\n  if (carry) {\n    digits.unshift(carry);\n    parsedNumber.i++;\n  }\n}\n/**\n * Parse a number (as a string) into three components that can be used\n * for formatting the number.\n *\n * (Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/)\n *\n * @param  {string} numStr The number to parse\n * @return {object} An object describing this number, containing the following keys:\n *  - d : an array of digits containing leading zeros as necessary\n *  - i : the number of the digits in `d` that are to the left of the decimal point\n *  - e : the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n *\n */\n\n\nfunction parse(numStr) {\n  var exponent = 0;\n  var digits;\n  var numberOfIntegerDigits;\n  var i;\n  var j;\n  var zeros; // Decimal point?\n\n  if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {\n    numStr = numStr.replace(DECIMAL_SEP, '');\n  } // Exponential form?\n\n\n  if ((i = numStr.search(/e/i)) > 0) {\n    // Work out the exponent.\n    if (numberOfIntegerDigits < 0) {\n      numberOfIntegerDigits = i;\n    }\n\n    numberOfIntegerDigits += Number(numStr.slice(i + 1));\n    numStr = numStr.substring(0, i);\n  } else if (numberOfIntegerDigits < 0) {\n    // There was no decimal point or exponent so it is an integer.\n    numberOfIntegerDigits = numStr.length;\n  } // Count the number of leading zeros.\n\n\n  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {\n    /* empty */\n  }\n\n  if (i === (zeros = numStr.length)) {\n    // The digits are all zero.\n    digits = [0];\n    numberOfIntegerDigits = 1;\n  } else {\n    // Count the number of trailing zeros\n    zeros--;\n\n    while (numStr.charAt(zeros) === ZERO_CHAR) {\n      zeros--;\n    } // Trailing zeros are insignificant so ignore them\n\n\n    numberOfIntegerDigits -= i;\n    digits = []; // Convert string to array of digits without leading/trailing zeros.\n\n    for (j = 0; i <= zeros; i++, j++) {\n      digits[j] = Number(numStr.charAt(i));\n    }\n  } // If the number overflows the maximum allowed digits then use an exponent.\n\n\n  if (numberOfIntegerDigits > MAX_DIGITS) {\n    digits = digits.splice(0, MAX_DIGITS - 1);\n    exponent = numberOfIntegerDigits - 1;\n    numberOfIntegerDigits = 1;\n  }\n\n  return {\n    d: digits,\n    e: exponent,\n    i: numberOfIntegerDigits\n  };\n}\n/**\n * Format a number into a string\n * @param  {number} number       The number to format\n * @param  {{\n *           minFrac, // the minimum number of digits required in the fraction part of the number\n *           maxFrac, // the maximum number of digits required in the fraction part of the number\n *           gSize,   // number of digits in each group of separated digits\n *           lgSize,  // number of digits in the last group of digits before the decimal separator\n *           negPre,  // the string to go in front of a negative number (e.g. `-` or `(`))\n *           posPre,  // the string to go in front of a positive number\n *           negSuf,  // the string to go after a negative number (e.g. `)`)\n *           posSuf   // the string to go after a positive number\n *         }} pattern\n * @param  {string} groupSep The string to separate groups of number (e.g. `,`)\n * @param  {string} decimalSep The string to act as the decimal separator (e.g. `.`)\n * @param  {[type]} fractionSize The size of the fractional part of the number\n * @return {string} The number formatted as a string\n */\n\n\nfunction formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {\n  if (!(isString(number) || isNumber(number)) || isNaN(number)) {\n    return '';\n  }\n\n  var isInfinity = !isFinite(number);\n  var isZero = false;\n  var numStr = String(Math.abs(number));\n  var formattedText = '';\n  var parsedNumber;\n\n  if (isInfinity) {\n    formattedText = '\\u221e';\n  } else {\n    parsedNumber = parse(numStr);\n    roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);\n    var digits = parsedNumber.d;\n    var integerLen = parsedNumber.i;\n    var exponent = parsedNumber.e;\n    var decimals = [];\n    isZero = digits.reduce(function (isZero, d) {\n      return isZero && !d;\n    }, true); // pad zeros for small numbers\n\n    while (integerLen < 0) {\n      digits.unshift(0);\n      integerLen++;\n    } // extract decimals digits\n\n\n    if (integerLen > 0) {\n      decimals = digits.splice(integerLen, digits.length);\n    } else {\n      decimals = digits;\n      digits = [0];\n    } // format the integer digits with grouping separators\n\n\n    var groups = [];\n\n    if (digits.length >= pattern.lgSize) {\n      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));\n    }\n\n    while (digits.length > pattern.gSize) {\n      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));\n    }\n\n    if (digits.length) {\n      groups.unshift(digits.join(''));\n    }\n\n    formattedText = groups.join(groupSep); // append the decimal digits\n\n    if (decimals.length) {\n      formattedText += decimalSep + decimals.join('');\n    }\n\n    if (exponent) {\n      formattedText += 'e+' + exponent;\n    }\n  }\n\n  if (number < 0 && !isZero) {\n    return pattern.negPre + formattedText + pattern.negSuf;\n  }\n\n  return pattern.posPre + formattedText + pattern.posSuf;\n}\n\nfunction numberFilter(number, fractionSize) {\n  // if null or undefined pass it through\n  return number === null ? number : formatNumber(number, NUMBER_FORMATS.PATTERNS[0], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize);\n}\n\nfunction currencyFilter(amount, currencySymbol, fractionSize) {\n  if (typeof currencySymbol === 'undefined') {\n    currencySymbol = NUMBER_FORMATS.CURRENCY_SYM;\n  }\n\n  if (typeof fractionSize === 'undefined') {\n    fractionSize = NUMBER_FORMATS.PATTERNS[1].maxFrac;\n  } // If the currency symbol is empty, trim whitespace around the symbol\n\n\n  var currencySymbolRe = !currencySymbol ? /\\s*\\u00A4\\s*/g : /\\u00A4/g; // if null or undefined pass it through\n\n  return amount === null ? amount : formatNumber(amount, NUMBER_FORMATS.PATTERNS[1], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);\n}\n\nexport default {\n  numberFilter,\n  currencyFilter\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/awNumberAndCurrencyFilterService.js"],"names":["NUMBER_FORMATS","CURRENCY_SYM","DECIMAL_SEP","GROUP_SEP","PATTERNS","gSize","lgSize","maxFrac","minFrac","minInt","negPre","negSuf","posPre","posSuf","MAX_DIGITS","ZERO_CHAR","digits","parsedNumber","fractionLen","fractionSize","Math","Number","roundAt","digit","j","i","k","carry","d","exponent","numberOfIntegerDigits","numStr","zeros","e","isString","isNumber","isNaN","isInfinity","isFinite","isZero","String","formattedText","parse","roundNumber","pattern","integerLen","decimals","groups","decimalSep","number","formatNumber","currencySymbol","currencySymbolRe","amount","currencyFilter"],"mappings":"AAAA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,cAAc,GAAG;EACnBC,YAAY,EADO,GAAA;EAEnBC,WAAW,EAFQ,GAAA;EAGnBC,SAAS,EAHU,GAAA;EAInBC,QAAQ,EAAE,CAAE;IACJC,KAAK,EADD,CAAA;IAEJC,MAAM,EAFF,CAAA;IAGJC,OAAO,EAHH,CAAA;IAIJC,OAAO,EAJH,CAAA;IAKJC,MAAM,EALF,CAAA;IAMJC,MAAM,EANF,GAAA;IAOJC,MAAM,EAPF,EAAA;IAQJC,MAAM,EARF,EAAA;IASJC,MAAM,EAAE;EATJ,CAAF,EAWN;IACIR,KAAK,EADT,CAAA;IAEIC,MAAM,EAFV,CAAA;IAGIC,OAAO,EAHX,CAAA;IAIIC,OAAO,EAJX,CAAA;IAKIC,MAAM,EALV,CAAA;IAMIC,MAAM,EANV,SAAA;IAOIC,MAAM,EAPV,EAAA;IAQIC,MAAM,EARV,QAAA;IASIC,MAAM,EAAE;EATZ,CAXM;AAJS,CAAvB;AA6BA,MAAMC,UAAU,GAAhB,EAAA;AACA,MAAMZ,WAAW,GAAjB,GAAA;AACA,MAAMa,SAAS,GAAf,GAAA;;AAEA,SAAA,QAAA,CAAA,KAAA,EAA2B;EACvB,OAAO,OAAA,KAAA,KAAP,QAAA;AACH;;AAED,SAAA,QAAA,CAAA,KAAA,EAA2B;EACvB,OAAO,OAAA,KAAA,KAAP,QAAA;AACH;AAED;AACA;AACA;AACA;;;AACA,SAAA,WAAA,CAAA,YAAA,EAAA,YAAA,EAAA,OAAA,EAAA,OAAA,EAAqE;EACjE,IAAIC,MAAM,GAAGC,YAAY,CAAzB,CAAA;EACA,IAAIC,WAAW,GAAGF,MAAM,CAANA,MAAAA,GAAgBC,YAAY,CAFmB,CAEjE,CAFiE,CAIjE;;EACAE,YAAY,GAAG,OAAA,YAAA,KAAA,WAAA,GAAsCC,IAAI,CAAJA,GAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAAAA,OAAAA,EAAVA,WAAUA,CAAVA,EAAtC,OAAsCA,CAAtC,GAA8FC,MAAM,CALlD,YAKkD,CAAnHF,CALiE,CAOjE;;EACA,IAAIG,OAAO,GAAGH,YAAY,GAAGF,YAAY,CAAzC,CAAA;EACA,IAAIM,KAAK,GAAGP,MAAM,CAAlB,OAAkB,CAAlB;;EAEA,IAAIM,OAAO,GAAX,CAAA,EAAkB;IACd;IACAN,MAAM,CAANA,MAAAA,CAAeI,IAAI,CAAJA,GAAAA,CAAUH,YAAY,CAAtBG,CAAAA,EAFD,OAECA,CAAfJ,EAFc,CAId;;IACA,KAAK,IAAIQ,CAAC,GAAV,OAAA,EAAsBA,CAAC,GAAGR,MAAM,CAAhC,MAAA,EAAyCQ,CAAzC,EAAA,EAA+C;MAC3CR,MAAM,CAANA,CAAM,CAANA,GAAAA,CAAAA;IACH;EAPL,CAAA,MAQO;IACH;IACAE,WAAW,GAAGE,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAdF,WAAcE,CAAdF;IACAD,YAAY,CAAZA,CAAAA,GAAAA,CAAAA;IACAD,MAAM,CAANA,MAAAA,GAAgBI,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAaE,OAAO,GAAGH,YAAY,GAAnDH,CAAgBI,CAAhBJ;IACAA,MAAM,CAANA,CAAM,CAANA,GAAAA,CAAAA;;IACA,KAAK,IAAIS,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,OAAA,EAA6BA,CAA7B,EAAA,EAAmC;MAC/BT,MAAM,CAANA,CAAM,CAANA,GAAAA,CAAAA;IACH;EACJ;;EAED,IAAIO,KAAK,IAAT,CAAA,EAAiB;IACb,IAAID,OAAO,GAAPA,CAAAA,GAAJ,CAAA,EAAsB;MAClB,KAAK,IAAII,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,OAAA,EAA6BA,CAA7B,EAAA,EAAmC;QAC/BV,MAAM,CAANA,OAAAA,CAAAA,CAAAA;QACAC,YAAY,CAAZA,CAAAA;MACH;;MACDD,MAAM,CAANA,OAAAA,CAAAA,CAAAA;MACAC,YAAY,CAAZA,CAAAA;IANJ,CAAA,MAOO;MACHD,MAAM,CAAEM,OAAO,GAAfN,CAAM,CAANA;IACH;EAxC4D,CAAA,CA2CjE;;;EACA,OAAOE,WAAW,GAAGE,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAArB,YAAqBA,CAArB,EAAkDF,WAAlD,EAAA,EAAkE;IAC9DF,MAAM,CAANA,IAAAA,CAAAA,CAAAA;EA7C6D,CAAA,CA+CjE;;;EACA,IAAIW,KAAK,GAAG,MAAM,CAAN,WAAA,CAAoB,UAAA,KAAA,EAAA,CAAA,EAAA,CAAA,EAAA,MAAA,EAAgC;IAC5DC,CAAC,IAADA,KAAAA;IACAZ,MAAM,CAANA,CAAM,CAANA,GAAcY,CAAC,GAAfZ,EAAAA;IACA,OAAOI,IAAI,CAAJA,KAAAA,CAAYQ,CAAC,GAApB,EAAOR,CAAP;EAHQ,CAAA,EAAZ,CAAY,CAAZ;;EAKA,IAAA,KAAA,EAAY;IACRJ,MAAM,CAANA,OAAAA,CAAAA,KAAAA;IACAC,YAAY,CAAZA,CAAAA;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,KAAA,CAAA,MAAA,EAAyB;EACrB,IAAIY,QAAQ,GAAZ,CAAA;EACA,IAAA,MAAA;EACA,IAAA,qBAAA;EACA,IAAA,CAAA;EACA,IAAA,CAAA;EACA,IANqB,KAMrB,CANqB,CAQrB;;EACA,IAAI,CAAEC,qBAAqB,GAAGC,MAAM,CAANA,OAAAA,CAA1B,WAA0BA,CAA1B,IAA4D,CAAhE,CAAA,EAAqE;IACjEA,MAAM,GAAGA,MAAM,CAANA,OAAAA,CAAAA,WAAAA,EAATA,EAASA,CAATA;EAViB,CAAA,CAarB;;;EACA,IAAI,CAAEN,CAAC,GAAGM,MAAM,CAANA,MAAAA,CAAN,IAAMA,CAAN,IAAJ,CAAA,EAAwC;IACpC;IACA,IAAID,qBAAqB,GAAzB,CAAA,EAAgC;MAC5BA,qBAAqB,GAArBA,CAAAA;IACH;;IACDA,qBAAqB,IAAIT,MAAM,CAAEU,MAAM,CAANA,KAAAA,CAAcN,CAAC,GAAhDK,CAAiCC,CAAF,CAA/BD;IACAC,MAAM,GAAGA,MAAM,CAANA,SAAAA,CAAAA,CAAAA,EAATA,CAASA,CAATA;EANJ,CAAA,MAOO,IAAID,qBAAqB,GAAzB,CAAA,EAAgC;IACnC;IACAA,qBAAqB,GAAGC,MAAM,CAA9BD,MAAAA;EAvBiB,CAAA,CA0BrB;;;EACA,KAAKL,CAAC,GAAN,CAAA,EAAYM,MAAM,CAANA,MAAAA,CAAAA,CAAAA,MAAZ,SAAA,EAA8CN,CAA9C,EAAA,EAAoD;IAAE;EAAa;;EAEnE,IAAIA,CAAC,MAAOO,KAAK,GAAGD,MAAM,CAA1B,MAAK,CAAL,EAAsC;IAClC;IACAf,MAAM,GAAG,CAATA,CAAS,CAATA;IACAc,qBAAqB,GAArBA,CAAAA;EAHJ,CAAA,MAIO;IACH;IACAE,KAAK;;IACL,OAAOD,MAAM,CAANA,MAAAA,CAAAA,KAAAA,MAAP,SAAA,EAA8C;MAAEC,KAAK;IAHlD,CAAA,CAKH;;;IACAF,qBAAqB,IAArBA,CAAAA;IACAd,MAAM,GAPH,EAOHA,CAPG,CAQH;;IACA,KAAKQ,CAAC,GAAN,CAAA,EAAYC,CAAC,IAAb,KAAA,EAAwBA,CAAC,IAAID,CAA7B,EAAA,EAAmC;MAC/BR,MAAM,CAANA,CAAM,CAANA,GAAcK,MAAM,CAAEU,MAAM,CAANA,MAAAA,CAAtBf,CAAsBe,CAAF,CAApBf;IACH;EA5CgB,CAAA,CA+CrB;;;EACA,IAAIc,qBAAqB,GAAzB,UAAA,EAAyC;IACrCd,MAAM,GAAGA,MAAM,CAANA,MAAAA,CAAAA,CAAAA,EAAkBF,UAAU,GAArCE,CAASA,CAATA;IACAa,QAAQ,GAAGC,qBAAqB,GAAhCD,CAAAA;IACAC,qBAAqB,GAArBA,CAAAA;EACH;;EAED,OAAO;IAAEF,CAAC,EAAH,MAAA;IAAaK,CAAC,EAAd,QAAA;IAA0BR,CAAC,EAAEK;EAA7B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,YAAA,CAAA,MAAA,EAAA,OAAA,EAAA,QAAA,EAAA,UAAA,EAAA,YAAA,EAA6E;EACzE,IAAI,EAAGI,QAAQ,CAARA,MAAQ,CAARA,IAAsBC,QAAQ,CAAjC,MAAiC,CAAjC,KAAiDC,KAAK,CAA1D,MAA0D,CAA1D,EAAuE;IAAE,OAAA,EAAA;EAAY;;EAErF,IAAIC,UAAU,GAAG,CAACC,QAAQ,CAA1B,MAA0B,CAA1B;EACA,IAAIC,MAAM,GAAV,KAAA;EACA,IAAIR,MAAM,GAAGS,MAAM,CAAEpB,IAAI,CAAJA,GAAAA,CAArB,MAAqBA,CAAF,CAAnB;EACA,IAAIqB,aAAa,GAAjB,EAAA;EACA,IAAA,YAAA;;EAEA,IAAA,UAAA,EAAiB;IACbA,aAAa,GAAbA,QAAAA;EADJ,CAAA,MAEO;IACHxB,YAAY,GAAGyB,KAAK,CAApBzB,MAAoB,CAApBA;IAEA0B,WAAW,CAAA,YAAA,EAAA,YAAA,EAA8BC,OAAO,CAArC,OAAA,EAA+CA,OAAO,CAAjED,OAAW,CAAXA;IAEA,IAAI3B,MAAM,GAAGC,YAAY,CAAzB,CAAA;IACA,IAAI4B,UAAU,GAAG5B,YAAY,CAA7B,CAAA;IACA,IAAIY,QAAQ,GAAGZ,YAAY,CAA3B,CAAA;IACA,IAAI6B,QAAQ,GAAZ,EAAA;IACAP,MAAM,GAAG,MAAM,CAAN,MAAA,CAAe,UAAA,MAAA,EAAA,CAAA,EAAsB;MAAE,OAAOA,MAAM,IAAI,CAAjB,CAAA;IAAvC,CAAA,EATN,IASM,CAATA,CATG,CAWH;;IACA,OAAOM,UAAU,GAAjB,CAAA,EAAwB;MACpB7B,MAAM,CAANA,OAAAA,CAAAA,CAAAA;MACA6B,UAAU;IAdX,CAAA,CAiBH;;;IACA,IAAIA,UAAU,GAAd,CAAA,EAAqB;MACjBC,QAAQ,GAAG9B,MAAM,CAANA,MAAAA,CAAAA,UAAAA,EAA2BA,MAAM,CAA5C8B,MAAW9B,CAAX8B;IADJ,CAAA,MAEO;MACHA,QAAQ,GAARA,MAAAA;MACA9B,MAAM,GAAG,CAATA,CAAS,CAATA;IAtBD,CAAA,CAyBH;;;IACA,IAAI+B,MAAM,GAAV,EAAA;;IACA,IAAI/B,MAAM,CAANA,MAAAA,IAAiB4B,OAAO,CAA5B,MAAA,EAAsC;MAClCG,MAAM,CAANA,OAAAA,CAAgB/B,MAAM,CAANA,MAAAA,CAAe,CAAC4B,OAAO,CAAvB5B,MAAAA,EAAgCA,MAAM,CAAtCA,MAAAA,EAAAA,IAAAA,CAAhB+B,EAAgB/B,CAAhB+B;IACH;;IACD,OAAO/B,MAAM,CAANA,MAAAA,GAAgB4B,OAAO,CAA9B,KAAA,EAAuC;MACnCG,MAAM,CAANA,OAAAA,CAAgB/B,MAAM,CAANA,MAAAA,CAAe,CAAC4B,OAAO,CAAvB5B,KAAAA,EAA+BA,MAAM,CAArCA,MAAAA,EAAAA,IAAAA,CAAhB+B,EAAgB/B,CAAhB+B;IACH;;IACD,IAAI/B,MAAM,CAAV,MAAA,EAAoB;MAChB+B,MAAM,CAANA,OAAAA,CAAgB/B,MAAM,CAANA,IAAAA,CAAhB+B,EAAgB/B,CAAhB+B;IACH;;IACDN,aAAa,GAAGM,MAAM,CAANA,IAAAA,CApCb,QAoCaA,CAAhBN,CApCG,CAsCH;;IACA,IAAIK,QAAQ,CAAZ,MAAA,EAAsB;MAClBL,aAAa,IAAIO,UAAU,GAAGF,QAAQ,CAARA,IAAAA,CAA9BL,EAA8BK,CAA9BL;IACH;;IAED,IAAA,QAAA,EAAe;MACXA,aAAa,IAAI,OAAjBA,QAAAA;IACH;EACJ;;EACD,IAAIQ,MAAM,GAANA,CAAAA,IAAc,CAAlB,MAAA,EAA4B;IACxB,OAAOL,OAAO,CAAPA,MAAAA,GAAAA,aAAAA,GAAiCA,OAAO,CAA/C,MAAA;EACH;;EACD,OAAOA,OAAO,CAAPA,MAAAA,GAAAA,aAAAA,GAAiCA,OAAO,CAA/C,MAAA;AACH;;AAED,SAAA,YAAA,CAAA,MAAA,EAAA,YAAA,EAA8C;EAC1C;EACA,OAAOK,MAAM,KAANA,IAAAA,GAAAA,MAAAA,GAA2BC,YAAY,CAAA,MAAA,EAAUlD,cAAc,CAAdA,QAAAA,CAAV,CAAUA,CAAV,EAAwCA,cAAc,CAAtD,SAAA,EAAkEA,cAAc,CAAhF,WAAA,EAA9C,YAA8C,CAA9C;AAEH;;AAED,SAAA,cAAA,CAAA,MAAA,EAAA,cAAA,EAAA,YAAA,EAAgE;EAC5D,IAAI,OAAA,cAAA,KAAJ,WAAA,EAA4C;IACxCmD,cAAc,GAAGnD,cAAc,CAA/BmD,YAAAA;EACH;;EAED,IAAI,OAAA,YAAA,KAAJ,WAAA,EAA0C;IACtChC,YAAY,GAAGnB,cAAc,CAAdA,QAAAA,CAAAA,CAAAA,EAAfmB,OAAAA;EANwD,CAAA,CAS5D;;;EACA,IAAIiC,gBAAgB,GAAG,CAAA,cAAA,GAAA,eAAA,GAVqC,SAU5D,CAV4D,CAY5D;;EACA,OAAOC,MAAM,KAANA,IAAAA,GAAAA,MAAAA,GAA2BH,YAAY,CAAA,MAAA,EAAUlD,cAAc,CAAdA,QAAAA,CAAV,CAAUA,CAAV,EAAwCA,cAAc,CAAtD,SAAA,EAAkEA,cAAc,CAAhF,WAAA,EAAZkD,YAAY,CAAZA,CAAAA,OAAAA,CAAAA,gBAAAA,EAAlC,cAAkCA,CAAlC;AACH;;AAED,eAAe;EAAA,YAAA;EAEXI;AAFW,CAAf","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n/* eslint-disable require-jsdoc */\n/* eslint-disable valid-jsdoc */\n\n/**\n * aw Number and Currency Filter Service\n * Formats a number as text.\n * Formats a number as a currency (ie $1,234.56).\n * \n * @module js/awNumberAndCurrencyFilterService\n */\n\nconst NUMBER_FORMATS = {\n    CURRENCY_SYM: '$',\n    DECIMAL_SEP: '.',\n    GROUP_SEP: ',',\n    PATTERNS: [ {\n            gSize: 3,\n            lgSize: 3,\n            maxFrac: 3,\n            minFrac: 0,\n            minInt: 1,\n            negPre: '-',\n            negSuf: '',\n            posPre: '',\n            posSuf: ''\n        },\n        {\n            gSize: 3,\n            lgSize: 3,\n            maxFrac: 2,\n            minFrac: 2,\n            minInt: 1,\n            negPre: '-\\u00a4',\n            negSuf: '',\n            posPre: '\\u00a4',\n            posSuf: ''\n        }\n    ]\n};\n\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\n\nfunction isString( value ) {\n    return typeof value === 'string';\n}\n\nfunction isNumber( value ) {\n    return typeof value === 'number';\n}\n\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changed the parsedNumber in-place\n */\nfunction roundNumber( parsedNumber, fractionSize, minFrac, maxFrac ) {\n    var digits = parsedNumber.d;\n    var fractionLen = digits.length - parsedNumber.i;\n\n    // determine fractionSize if it is not specified; `+fractionSize` converts it to a number\n    fractionSize = typeof fractionSize === 'undefined' ? Math.min( Math.max( minFrac, fractionLen ), maxFrac ) : Number( fractionSize );\n\n    // The index of the digit to where rounding is to occur\n    var roundAt = fractionSize + parsedNumber.i;\n    var digit = digits[ roundAt ];\n\n    if( roundAt > 0 ) {\n        // Drop fractional digits beyond `roundAt`\n        digits.splice( Math.max( parsedNumber.i, roundAt ) );\n\n        // Set non-fractional digits beyond `roundAt` to 0\n        for( var j = roundAt; j < digits.length; j++ ) {\n            digits[ j ] = 0;\n        }\n    } else {\n        // We rounded to zero so reset the parsedNumber\n        fractionLen = Math.max( 0, fractionLen );\n        parsedNumber.i = 1;\n        digits.length = Math.max( 1, roundAt = fractionSize + 1 );\n        digits[ 0 ] = 0;\n        for( var i = 1; i < roundAt; i++ ) {\n            digits[ i ] = 0;\n        }\n    }\n\n    if( digit >= 5 ) {\n        if( roundAt - 1 < 0 ) {\n            for( var k = 0; k > roundAt; k-- ) {\n                digits.unshift( 0 );\n                parsedNumber.i++;\n            }\n            digits.unshift( 1 );\n            parsedNumber.i++;\n        } else {\n            digits[ roundAt - 1 ]++;\n        }\n    }\n\n    // Pad out with zeros to get the required fraction length\n    for( ; fractionLen < Math.max( 0, fractionSize ); fractionLen++ ) {\n        digits.push( 0 );\n    }\n    // Do any carrying, e.g. a digit was rounded up to 10\n    var carry = digits.reduceRight( function( carry, d, i, digits ) {\n        d += carry;\n        digits[ i ] = d % 10;\n        return Math.floor( d / 10 );\n    }, 0 );\n    if( carry ) {\n        digits.unshift( carry );\n        parsedNumber.i++;\n    }\n}\n\n/**\n * Parse a number (as a string) into three components that can be used\n * for formatting the number.\n *\n * (Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/)\n *\n * @param  {string} numStr The number to parse\n * @return {object} An object describing this number, containing the following keys:\n *  - d : an array of digits containing leading zeros as necessary\n *  - i : the number of the digits in `d` that are to the left of the decimal point\n *  - e : the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n *\n */\nfunction parse( numStr ) {\n    var exponent = 0;\n    var digits;\n    var numberOfIntegerDigits;\n    var i;\n    var j;\n    var zeros;\n\n    // Decimal point?\n    if( ( numberOfIntegerDigits = numStr.indexOf( DECIMAL_SEP ) ) > -1 ) {\n        numStr = numStr.replace( DECIMAL_SEP, '' );\n    }\n\n    // Exponential form?\n    if( ( i = numStr.search( /e/i ) ) > 0 ) {\n        // Work out the exponent.\n        if( numberOfIntegerDigits < 0 ) {\n            numberOfIntegerDigits = i;\n        }\n        numberOfIntegerDigits += Number( numStr.slice( i + 1 ) );\n        numStr = numStr.substring( 0, i );\n    } else if( numberOfIntegerDigits < 0 ) {\n        // There was no decimal point or exponent so it is an integer.\n        numberOfIntegerDigits = numStr.length;\n    }\n\n    // Count the number of leading zeros.\n    for( i = 0; numStr.charAt( i ) === ZERO_CHAR; i++ ) { /* empty */ }\n\n    if( i === ( zeros = numStr.length ) ) {\n        // The digits are all zero.\n        digits = [ 0 ];\n        numberOfIntegerDigits = 1;\n    } else {\n        // Count the number of trailing zeros\n        zeros--;\n        while( numStr.charAt( zeros ) === ZERO_CHAR ) { zeros--; }\n\n        // Trailing zeros are insignificant so ignore them\n        numberOfIntegerDigits -= i;\n        digits = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for( j = 0; i <= zeros; i++, j++ ) {\n            digits[ j ] = Number( numStr.charAt( i ) );\n        }\n    }\n\n    // If the number overflows the maximum allowed digits then use an exponent.\n    if( numberOfIntegerDigits > MAX_DIGITS ) {\n        digits = digits.splice( 0, MAX_DIGITS - 1 );\n        exponent = numberOfIntegerDigits - 1;\n        numberOfIntegerDigits = 1;\n    }\n\n    return { d: digits, e: exponent, i: numberOfIntegerDigits };\n}\n/**\n * Format a number into a string\n * @param  {number} number       The number to format\n * @param  {{\n *           minFrac, // the minimum number of digits required in the fraction part of the number\n *           maxFrac, // the maximum number of digits required in the fraction part of the number\n *           gSize,   // number of digits in each group of separated digits\n *           lgSize,  // number of digits in the last group of digits before the decimal separator\n *           negPre,  // the string to go in front of a negative number (e.g. `-` or `(`))\n *           posPre,  // the string to go in front of a positive number\n *           negSuf,  // the string to go after a negative number (e.g. `)`)\n *           posSuf   // the string to go after a positive number\n *         }} pattern\n * @param  {string} groupSep The string to separate groups of number (e.g. `,`)\n * @param  {string} decimalSep The string to act as the decimal separator (e.g. `.`)\n * @param  {[type]} fractionSize The size of the fractional part of the number\n * @return {string} The number formatted as a string\n */\nfunction formatNumber( number, pattern, groupSep, decimalSep, fractionSize ) {\n    if( !( isString( number ) || isNumber( number ) ) || isNaN( number ) ) { return ''; }\n\n    var isInfinity = !isFinite( number );\n    var isZero = false;\n    var numStr = String( Math.abs( number ) );\n    var formattedText = '';\n    var parsedNumber;\n\n    if( isInfinity ) {\n        formattedText = '\\u221e';\n    } else {\n        parsedNumber = parse( numStr );\n\n        roundNumber( parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac );\n\n        var digits = parsedNumber.d;\n        var integerLen = parsedNumber.i;\n        var exponent = parsedNumber.e;\n        var decimals = [];\n        isZero = digits.reduce( function( isZero, d ) { return isZero && !d; }, true );\n\n        // pad zeros for small numbers\n        while( integerLen < 0 ) {\n            digits.unshift( 0 );\n            integerLen++;\n        }\n\n        // extract decimals digits\n        if( integerLen > 0 ) {\n            decimals = digits.splice( integerLen, digits.length );\n        } else {\n            decimals = digits;\n            digits = [ 0 ];\n        }\n\n        // format the integer digits with grouping separators\n        var groups = [];\n        if( digits.length >= pattern.lgSize ) {\n            groups.unshift( digits.splice( -pattern.lgSize, digits.length ).join( '' ) );\n        }\n        while( digits.length > pattern.gSize ) {\n            groups.unshift( digits.splice( -pattern.gSize, digits.length ).join( '' ) );\n        }\n        if( digits.length ) {\n            groups.unshift( digits.join( '' ) );\n        }\n        formattedText = groups.join( groupSep );\n\n        // append the decimal digits\n        if( decimals.length ) {\n            formattedText += decimalSep + decimals.join( '' );\n        }\n\n        if( exponent ) {\n            formattedText += 'e+' + exponent;\n        }\n    }\n    if( number < 0 && !isZero ) {\n        return pattern.negPre + formattedText + pattern.negSuf;\n    }\n    return pattern.posPre + formattedText + pattern.posSuf;\n}\n\nfunction numberFilter( number, fractionSize ) {\n    // if null or undefined pass it through\n    return number === null ? number : formatNumber( number, NUMBER_FORMATS.PATTERNS[ 0 ], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP,\n        fractionSize );\n}\n\nfunction currencyFilter( amount, currencySymbol, fractionSize ) {\n    if( typeof currencySymbol === 'undefined' ) {\n        currencySymbol = NUMBER_FORMATS.CURRENCY_SYM;\n    }\n\n    if( typeof fractionSize === 'undefined' ) {\n        fractionSize = NUMBER_FORMATS.PATTERNS[ 1 ].maxFrac;\n    }\n\n    // If the currency symbol is empty, trim whitespace around the symbol\n    var currencySymbolRe = !currencySymbol ? /\\s*\\u00A4\\s*/g : /\\u00A4/g;\n\n    // if null or undefined pass it through\n    return amount === null ? amount : formatNumber( amount, NUMBER_FORMATS.PATTERNS[ 1 ], NUMBER_FORMATS.GROUP_SEP, NUMBER_FORMATS.DECIMAL_SEP, fractionSize ).replace( currencySymbolRe, currencySymbol );\n}\n\nexport default {\n    numberFilter,\n    currencyFilter\n};\n"]},"metadata":{},"sourceType":"module"}