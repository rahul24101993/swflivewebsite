{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */\n\n/**\n * Tab Overflow Service to manage tabs.\n */\nlet exports = {};\n/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */\n\nexport let hasOverflowForTabs = (tabContainerElem, tabContainerAlignment, tabElem) => {\n  let propName = tabContainerAlignment === 'HORIZONTAL' ? 'offsetTop' : 'offsetLeft';\n  var tabElement = tabElem;\n\n  if (!tabElement) {\n    let currentTabElems = tabContainerElem ? tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab') : undefined;\n    tabElement = currentTabElems ? currentTabElems[currentTabElems.length - 1] : undefined;\n  } //We just check the element's offsetTop against the container's offset top to determine if there's an overflow\n\n\n  if (!tabContainerElem || !tabElement) {\n    return false;\n  }\n\n  return tabElement[propName] > tabContainerElem[propName];\n};\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\n\nexport let overflowBreakPointCalculatorForTabs = function () {\n  var tabElems;\n  var breakIndex = 0;\n  return function (tabContainerElem, tabContainerAlignment) {\n    if (!tabContainerElem) {\n      return breakIndex;\n    }\n\n    tabElems = tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');\n    breakIndex = tabElems.length;\n\n    for (var i = tabElems.length - 1; i >= 0; i--) {\n      // find the first tab which doesn't have overflow in reverse order\n      if (!hasOverflowForTabs(tabContainerElem, tabContainerAlignment, tabElems[i])) {\n        breakIndex = i + 1;\n        break;\n      }\n    }\n\n    return breakIndex;\n  };\n};\nexport let updateTabIndexOnOverflow = function (tabContainerElement, tabContainerAlignment) {\n  let tabElements = tabContainerElement.querySelectorAll('.sw-tabContainer >.sw-tab');\n\n  for (var i = tabElements.length - 1; i >= 0; i--) {\n    var tabElementAnchor = tabElements[i].querySelector('a:not(.disabled)');\n\n    if (tabElementAnchor) {\n      if (hasOverflowForTabs(tabContainerElement, tabContainerAlignment, tabElements[i])) {\n        tabElementAnchor.setAttribute('tabindex', -1);\n      } else {\n        tabElementAnchor.setAttribute('tabindex', 0);\n      }\n    }\n  }\n};\n/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */\n\nconst isTabsOverflown = function (tabContainerElem, tabElems, tabPadding) {\n  let totalWidth = 0;\n\n  for (var i = 0; i < tabElems.length; i++) {\n    totalWidth += tabElems[i].getClientRects()[0].width + tabPadding;\n  }\n\n  return Math.round(totalWidth) > tabContainerElem.clientWidth;\n};\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\n\n\nexport let calculateBreakIndex = function () {\n  var tabElems;\n  var breakIndex = 0;\n  return function (tabsModelForContainer, tabContainerElem, selectedTabModel) {\n    if (!tabContainerElem) {\n      return breakIndex;\n    }\n\n    tabElems = tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');\n    let arr = [...tabElems];\n    var tabPadding = 16;\n\n    if (selectedTabModel && isTabsOverflown(tabContainerElem, arr, tabPadding)) {\n      let selectedTabObject = arr.find(element => {\n        const anchor = element.getElementsByTagName('a')[0];\n\n        if (anchor) {\n          return anchor.getAttribute('name') === String(selectedTabModel.pageId);\n        }\n\n        return false;\n      });\n      let initialTabPadding = 16;\n      let totalWidth = 0;\n\n      if (selectedTabObject) {\n        totalWidth = selectedTabObject.getClientRects()[0].width + tabPadding + initialTabPadding;\n      }\n\n      for (var i = 0; i < tabsModelForContainer.length; i++) {\n        let currentTabObject = arr.find(element => {\n          const anchor = element.getElementsByTagName('a')[0];\n\n          if (anchor) {\n            return anchor.getAttribute('name') === String(tabsModelForContainer[i].pageId);\n          }\n\n          return false;\n        });\n\n        if (currentTabObject) {\n          totalWidth += currentTabObject.getClientRects()[0].width + tabPadding;\n        }\n\n        if (totalWidth > tabContainerElem.clientWidth) {\n          breakIndex = i;\n          break;\n        }\n      }\n\n      return breakIndex;\n    }\n  };\n};\nexports = {\n  overflowBreakPointCalculatorForTabs,\n  hasOverflowForTabs,\n  updateTabIndexOnOverflow,\n  calculateBreakIndex\n};\nexport default exports;","map":{"version":3,"names":["exports","hasOverflowForTabs","tabContainerElem","tabContainerAlignment","tabElem","propName","tabElement","currentTabElems","querySelectorAll","undefined","length","overflowBreakPointCalculatorForTabs","tabElems","breakIndex","i","updateTabIndexOnOverflow","tabContainerElement","tabElements","tabElementAnchor","querySelector","setAttribute","isTabsOverflown","tabPadding","totalWidth","getClientRects","width","Math","round","clientWidth","calculateBreakIndex","tabsModelForContainer","selectedTabModel","arr","selectedTabObject","find","element","anchor","getElementsByTagName","getAttribute","String","pageId","initialTabPadding","currentTabObject"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/tabOverflowService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */\n\n/**\n * Tab Overflow Service to manage tabs.\n */\nlet exports = {};\n\n/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */\nexport let hasOverflowForTabs = ( tabContainerElem, tabContainerAlignment, tabElem ) => {\n    let propName = tabContainerAlignment === 'HORIZONTAL' ? 'offsetTop' : 'offsetLeft';\n    var tabElement = tabElem;\n    if( !tabElement ) {\n        let currentTabElems = tabContainerElem ? tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' ) : undefined;\n        tabElement = currentTabElems ? currentTabElems[ currentTabElems.length - 1 ] : undefined;\n    }\n\n    //We just check the element's offsetTop against the container's offset top to determine if there's an overflow\n    if( !tabContainerElem || !tabElement ) {\n        return false;\n    }\n\n    return tabElement[ propName ] > tabContainerElem[ propName ];\n};\n\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\nexport let overflowBreakPointCalculatorForTabs = function() {\n    var tabElems;\n    var breakIndex = 0;\n\n    return function( tabContainerElem, tabContainerAlignment ) {\n        if( !tabContainerElem ) {\n            return breakIndex;\n        }\n\n        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n\n        breakIndex = tabElems.length;\n        for( var i = tabElems.length - 1; i >= 0; i-- ) {\n            // find the first tab which doesn't have overflow in reverse order\n            if( !hasOverflowForTabs( tabContainerElem, tabContainerAlignment, tabElems[ i ] ) ) {\n                breakIndex = i + 1;\n                break;\n            }\n        }\n\n        return breakIndex;\n    };\n};\n\nexport let updateTabIndexOnOverflow = function( tabContainerElement, tabContainerAlignment ) {\n    let tabElements = tabContainerElement.querySelectorAll( '.sw-tabContainer >.sw-tab' );\n    for( var i = tabElements.length - 1; i >= 0; i-- ) {\n        var tabElementAnchor = tabElements[ i ].querySelector( 'a:not(.disabled)' );\n        if( tabElementAnchor ) {\n            if( hasOverflowForTabs( tabContainerElement, tabContainerAlignment, tabElements[ i ] ) ) {\n                tabElementAnchor.setAttribute( 'tabindex', -1 );\n            } else {\n                tabElementAnchor.setAttribute( 'tabindex', 0 );\n            }\n        }\n    }\n};\n\n/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */\nconst isTabsOverflown = function( tabContainerElem, tabElems, tabPadding ) {\n    let totalWidth = 0;\n    for( var i = 0; i < tabElems.length; i++ ) {\n        totalWidth += tabElems[ i ].getClientRects()[ 0 ].width + tabPadding;\n    }\n    return Math.round( totalWidth ) > tabContainerElem.clientWidth;\n};\n\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\nexport let calculateBreakIndex = function() {\n    var tabElems;\n    var breakIndex = 0;\n\n    return function( tabsModelForContainer, tabContainerElem, selectedTabModel ) {\n        if( !tabContainerElem ) {\n            return breakIndex;\n        }\n\n        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n        let arr = [ ...tabElems ];\n        var tabPadding = 16;\n\n        if( selectedTabModel && isTabsOverflown( tabContainerElem, arr, tabPadding ) ) {\n            let selectedTabObject = arr.find( ( element ) => {\n                const anchor = element.getElementsByTagName( 'a' )[ 0 ];\n                if( anchor ) {\n                    return anchor.getAttribute( 'name' ) === String( selectedTabModel.pageId );\n                }\n                return false;\n            } );\n\n            let initialTabPadding = 16;\n            let totalWidth = 0;\n            if( selectedTabObject ) {\n                totalWidth = selectedTabObject.getClientRects()[ 0 ].width + tabPadding + initialTabPadding;\n            }\n\n            for( var i = 0; i < tabsModelForContainer.length; i++ ) {\n                let currentTabObject = arr.find( ( element ) => {\n                    const anchor = element.getElementsByTagName( 'a' )[ 0 ];\n                    if( anchor ) {\n                        return anchor.getAttribute( 'name' ) === String( tabsModelForContainer[ i ].pageId );\n                    }\n                    return false;\n                } );\n                if( currentTabObject ) {\n                    totalWidth += currentTabObject.getClientRects()[ 0 ].width + tabPadding;\n                }\n\n                if( totalWidth > tabContainerElem.clientWidth ) {\n                    breakIndex = i;\n                    break;\n                }\n            }\n\n            return breakIndex;\n        }\n    };\n};\n\nexports = {\n    overflowBreakPointCalculatorForTabs,\n    hasOverflowForTabs,\n    updateTabIndexOnOverflow,\n    calculateBreakIndex\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}