{"ast":null,"code":"/* eslint-disable complexity */ // Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * This module provides the utility functions for supporting aw service.\n *\n * @module js/serviceUtils\n */import _ from'lodash';/**\n * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */export function httpGet(theUrl){return new Promise((resolve,reject)=>{var xmlHttp=new XMLHttpRequest();xmlHttp.onreadystatechange=function(){if(xmlHttp.readyState===4&&xmlHttp.status===200){resolve(xmlHttp.responseText);}};xmlHttp.onerror=function(e){reject(e);};xmlHttp.open('GET',theUrl,true);// true for asynchronous\nxmlHttp.send(null);});}/**\n * simple http get for JSON specific and fake response data structure.\n * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */export function httpGetJsonObject(theUrl){return httpGet(theUrl).then(txt=>{return{data:JSON.parse(txt)};});}/**\n * Quick check for if the expression can be splitted or not.\n *\n * NOTE: it is strictly based on logic in parseExpression, only handle the case that\n * parseExpression can handle\n * @param {String} expression The expression to parse.\n * @returns {Boolean} true if expression can be splitted.\n */export const expressionCanSplit=expression=>{return expression.match(/[)(+\\-*/^!&|=><%?:]|\\['|'\\]/);};/**\n * Splits expression into sub expression\n * @param {String} expression - The expression which needs to broken\n * @returns {Array} - Array of sub expressions\n */export const processExpression=expression=>{// remove trailing newline character which is added automatically\nconst characters=Array.from(expression.replace(/(\\r\\n|\\n|\\r)/gm,'').trim());let stack=[];let expr='';let ignoreQuotes=false;characters.forEach((character,index)=>{if(character==='('){if(expr===''){stack.push('(');}else{expr=\"\".concat(expr).concat(character);}}else if(character===')'){const temp=\"\".concat(expr).concat(character);const openBrackets=temp.split('(').length-1;const closedBrackets=temp.split(')').length-1;if(openBrackets===0){if(expr!==''){stack.push({expr});expr='';}stack.push(')');}else if(openBrackets>0){if(openBrackets<closedBrackets){stack.push({expr});expr='';stack.push(')');}else{expr=\"\".concat(expr).concat(character);}}// stack.push( ')' );\n}else if(/(\\+|-|\\*|\\/|\\^|!|&|\\||=|>|<|%|\\?|:)/.test(character)){if(character!==':'){// handle such expression that contains equal to ex- \"ctx.message\" === \"\"Hello=World\"\nif(character==='='&&!(characters[index-1]==='='||characters[index-1]==='!'||characters[index-1]==='>'||characters[index-1]==='<'||characters[index+1]==='=')){expr=\"\".concat(expr).concat(character);}else{if(expr!==''){stack.push({expr});expr='';}stack.push(character);}}else{const qMark=_.filter(stack,element=>element==='?').length;const colans=_.filter(stack,element=>element===':').length;if(qMark-colans>0){if(expr!==''){stack.push({expr});expr='';}stack.push(character);}else{expr=\"\".concat(expr).concat(character);}}}else if(character==='['&&characters[index+1]==='\\''){expr=\"\".concat(expr,\".\");ignoreQuotes=true;}else if(character===']'&&characters[index-1]==='\\''){//DO not\nignoreQuotes=false;}else if(character==='\\''&&!ignoreQuotes){expr=\"\".concat(expr).concat(character);}else if(character.trim()!==''&&character.trim()!=='\\''){expr=\"\".concat(expr).concat(character);}if(index===characters.length-1){//process expr\nif(expr!==''){// expr = `${expr}${character}`;\nstack.push({expr});expr='';}}// if()\n});return stack;};/**\n * This API evaluates expression against the evaluation context using dynamic function.\n * @param {Array} params - The parameter name array\n * @param {Array} paramValues - The parameter value array\n * @param {Object} applyObject - The apply Object\n * @param {String} expression - The expression which needs to be evaluated\n * @returns {Object} result\n */export const parseNative=(params,paramValues,applyObject,expression)=>{if(params){params=params.map(param=>param.includes('-')?param.replace(/\\-/g,'_'):param);}return evalExpression(expression,params,paramValues,false,applyObject);};/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Array} params - The parameter name array\n * @param {Array} values - The parameter value array\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n *\n * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically\n */export const evalExpression=(expr,params,values,ignoreError,applyObject)=>{try{let sandBoxParams=['window','document','eval','setTimeout','setInterval','XMLHttpRequest','Function'];let sandBoxValues=[{},{},{},{},{},{},{}];//Replace all dot(.) as . are not valid arguments of function\nlet newParams=params.map(ele=>ele.indexOf('.')<0?ele:ele.replace(/\\./g,''));let func=new Function(...newParams,...sandBoxParams,\"return \".concat(expr,\";\"));return func.apply(applyObject,values,...sandBoxValues);}catch(e){if(!ignoreError){throw new Error(\"evalExpression('\".concat(expr,\"') => \").concat(e.message));}else{return undefined;}}};/**\n * This metthod splits an expression into Array of subExpressions.\n * @param {String} expression - The expression to be interpolated\n * @returns {Array} Array of sub expressions\n */export const splitExpressionForInterpolate=expression=>{const startSyntax='{{';if(expression.includes(startSyntax)===false){return expression;}const endSyntax='}}';const splits=expression.split(startSyntax);let finalSplits=[];_.forEach(splits,split=>{if(split.includes(endSyntax)){const subSplits=split.split(endSyntax);_.forEach(subSplits,(sSplit,index)=>{if(index===0){finalSplits.push({expr:sSplit});}else{finalSplits.push(sSplit);}});}else{finalSplits.push(split);}});return finalSplits;};/**\n * Decode value from string.\n * @param {String} val - decode string value\n * @returns {String} value String\n */export function valFromString(val){return val!==null?val.toString().replace(/(~~|~2F)/g,function(m){const constantMap={'~~':'~','~2F':'/'};return constantMap[m];}):val;}export default{httpGet,httpGetJsonObject,processExpression,expressionCanSplit,valFromString,evalExpression};","map":null,"metadata":{},"sourceType":"module"}