{"ast":null,"code":"/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the popup code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/popupUtils\n */\nimport _ from 'lodash';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport browserUtils from 'js/browserUtils'; // import eventBus from 'js/eventBus';\n// import panelContentService from 'js/panelContentService';\n\nimport { checkResize, resizeDetector } from 'js/resizeDetector';\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport declUtils from 'js/declUtils';\nimport Draggable from 'js/draggable';\nimport keyCode from 'js/keyCode';\nimport wcagSvc from 'js/wcagService';\nimport { FLATPICKR_ID } from 'js/dateTimeService';\nvar exports = {};\nvar TOOLTIP_POPUP_CSS = 'sw-popup-tooltip sw_popup_easein';\n/**\n * The ammount the input box is allowed to move to the left/right before the UI popup (e.g. calendar, LOV ) is collapsed/hidden.\n */\n\nvar _MAX_X = 40;\nvar _MAX_Y = 40;\nvar POPUP_ID_ATTRIBUTE = 'data-popup-id'; // eslint-disable-next-line one-var\n\n/**\n * A reference to a created panel. This reference contains with properties/functions used to control the panel.\n * @param {!Object} panelEl the panelEl to wrap\n * @param {!Object} options the panel options\n * @final @constructor\n */\n\nfunction PanelRef(panelEl, options) {\n  this.id = getId(panelEl, options.forceUid);\n  this.panelEl = panelEl;\n  this.options = options;\n  this.isAttached = false;\n  this._removeListeners = [];\n  this.interceptors = {};\n}\n\n_c = PanelRef;\n\nPanelRef.prototype.initialize = function () {\n  this.updateBackReference(true);\n  activateLifeCycleHooks(this);\n  addEventListeners(this);\n  processEnablers(this);\n  processMultipleLevel(this);\n};\n\nPanelRef.prototype.clear = function () {\n  this.updateBackReference();\n  removeEventListeners(this);\n};\n\nPanelRef.prototype.attach = function () {\n  this.initialize();\n  this.triggerHook('open'); // onMount && onMount();\n\n  this.isAttached = true;\n};\n\nPanelRef.prototype.detach = function () {\n  this.clear();\n  this.triggerHook('close');\n  this.interceptors = {}; // Remove the DOM reference\n\n  this.panelEl = null;\n  this.isAttached = false;\n};\n\nPanelRef.prototype.updateBackReference = function (isAdd) {\n  if (!this.options.reference) {\n    return;\n  }\n\n  var referenceEl = this.options.reference;\n  var value = isAdd ? this.id : '';\n  referenceEl.setAttribute(POPUP_ID_ATTRIBUTE, value);\n};\n/**\n * Schedules an update. It will run on the next UI update available.\n */\n\n\nPanelRef.prototype.scheduleUpdate = function () {\n  requestAnimationFrame(() => {\n    this.options.api.updatePosition();\n  });\n};\n\nPanelRef.prototype.update = function () {\n  let newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return this.options.api.update(this, newOptions, force);\n};\n\nPanelRef.prototype.canClose = function () {\n  return this.options && !this.options.disableClose;\n};\n\nPanelRef.prototype.hide = function () {\n  let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (force || !force && this.canClose()) {\n    let popupRef = this;\n\n    if (popupRef.parentPopup) {\n      //Update Next ref\n      if (popupRef.nextPopup) {\n        popupRef.parentPopup.nextPopup = popupRef.nextPopup;\n        popupRef.nextPopup.parentPopup = popupRef.parentPopup;\n      } else {\n        popupRef.parentPopup.nextPopup = null;\n      }\n    }\n\n    return this.options.api.hide(this);\n  }\n};\n\nPanelRef.prototype.triggerHook = function (type) {\n  if (['open', 'update', 'close'].indexOf(type) === -1) {\n    return;\n  }\n\n  _.each(this.interceptors[type], item => {\n    item(this);\n  });\n};\n\nexport { PanelRef };\n/**\n * A panel manager to track and manage all panel reference .\n * @final @constructor\n */\n\nfunction PopupManager() {\n  this._previousPopupRef = null;\n  this._popupMaps = {};\n}\n\n_c2 = PopupManager;\n\nPopupManager.prototype.get = function (id) {\n  if (id && this._popupMaps[id]) {\n    return this._popupMaps[id];\n  }\n\n  return null;\n};\n\nPopupManager.prototype.add = function (panelRef) {\n  if (!panelRef) {\n    return;\n  }\n\n  var id = panelRef.id;\n  let isPanelRefTooltip = panelRef.panelEl && panelRef.panelEl.querySelector('.sw-popup-tooltip.sw-popup-easein') !== null;\n\n  if (!this._popupMaps[id]) {\n    let validPanelRef = null;\n\n    for (const k of Object.keys(this._popupMaps).reverse()) {\n      let validEl = dom.get('.aw-widgets-groupCommandStack', this._popupMaps[k].panelEl); // during keyboard navigation, reference of next and parent popup should not be\n      // maintained if panelRef is an extended tooltip\n      // reference of next and parent popup should not be maintained if panelRef is a tooltip\n\n      if (validEl !== null && !isPanelRefTooltip) {\n        validPanelRef = this._popupMaps[k];\n        break;\n      }\n    }\n\n    if (validPanelRef !== null) {\n      // Maintain reference of next and parent popup\n      validPanelRef.nextPopup = panelRef;\n      panelRef.parentPopup = validPanelRef;\n    }\n\n    this._popupMaps[id] = panelRef;\n  }\n};\n\nPopupManager.prototype.remove = function (panelRef) {\n  if (!panelRef) {\n    return;\n  }\n\n  var id = panelRef.id;\n  this._popupMaps[id] && delete this._popupMaps[id];\n};\n\nObject.defineProperty(PopupManager.prototype, 'previousPopupRef', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return this._previousPopupRef;\n  },\n  set: function (value) {\n    this._previousPopupRef = value;\n  }\n});\nexport { PopupManager };\nexport let handleOpenedPopup = function (referenceEl, manager) {\n  let toggleMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var id = referenceEl ? referenceEl.getAttribute(POPUP_ID_ATTRIBUTE) : null;\n  var popupRef = manager.get(id);\n\n  if (id && toggleMode) {\n    popupRef.hide();\n    return null;\n  } else if (id) {\n    // force bring to foreground by hoist z-index or\n    // force bring to foreground by re-append (safe and easy way)\n    dom.append(popupRef.panelEl);\n    return popupRef;\n  }\n\n  return true;\n};\n\nfunction removeEventListeners(panelRef) {\n  panelRef._removeListeners && panelRef._removeListeners.forEach(function (removeFn) {\n    removeFn();\n  });\n  panelRef._removeListeners = [];\n}\n\nfunction processEnablers(popupRef) {\n  let options = popupRef.options;\n  let {\n    draggable,\n    draggableInitializeDelay = 200\n  } = options;\n\n  if (!draggable) {\n    return;\n  } // contents maybe async loaded, handle maybe not ready(exist) yet.\n\n\n  setTimeout(() => {\n    let popupEl = popupRef.panelEl;\n\n    if (popupEl) {\n      let dragElement = dom.get('.sw-popup-layout', popupEl);\n      let headerElement = dom.get('.aw-layout-panelTitle, .panel-header', popupEl);\n      let handle = undefined;\n\n      if (options.handle) {\n        handle = dom.get(options.handle, popupEl);\n      } else if (headerElement) {\n        handle = headerElement;\n      } else {\n        handle = dragElement;\n      }\n\n      let dragger = new Draggable(dragElement, {\n        handle,\n        limit: document.body,\n        setCursor: true,\n        className: options.draggableClassName || 'sw-popup-draggable',\n        // LCS-337929: expect popup to remain where it was dragged\n        // add flag 'disableUpdate' to prevent auto update position if have been dragged\n        onDragStart: function () {\n          options.disableUpdate = true; // remove right / bottom to ensure element draggable\n\n          options.advancePositioning && dom.setStyles(dragElement, {\n            right: null,\n            bottom: null\n          });\n        }\n      });\n\n      popupRef._removeListeners.push(dragger.destroy.bind(dragger));\n    }\n  }, draggableInitializeDelay);\n} // MultipleLevel popup command bar case:\n// build cascade MultipleLevel popup menus\n// and define the event ignore list between them\n\n\nfunction processMultipleLevel(popupRef) {\n  let {\n    options,\n    panelEl\n  } = popupRef;\n  let {\n    reference,\n    manager,\n    processNested,\n    preset\n  } = options; // exclude tooltip process\n\n  if (preset && preset === 'tooltip') {\n    return;\n  }\n\n  if (processNested === false || !reference || !manager) {\n    return;\n  } // add current popup to ignore click list of all up Level popups\n\n\n  let parentPopup = dom.closest(reference, 'div.sw-popup');\n\n  while (parentPopup && reference && manager) {\n    let ref = manager.get(parentPopup.id);\n    ref.options.ignoreClicksFrom = ref.options.ignoreClicksFrom || [];\n    ref.options.ignoreClicksFrom.push(panelEl); // check upper level recursively\n\n    reference = ref.options.reference;\n    manager = ref.options.manager;\n    parentPopup = dom.closest(reference, 'div.sw-popup');\n  }\n}\n\nfunction autoFocus(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n\n  if (options.autoFocus !== false) {\n    getContainerElement(popupEl).focus();\n  }\n}\n\nconst hookHash = {\n  whenOpened: 'open',\n  whenUpdated: 'update',\n  whenClosed: 'close'\n};\n\nconst getHookKey = key => key.replace(/whenOpened|whenUpdated|whenClosed/g, matched => hookHash[matched]);\n\nfunction activateLifeCycleHooks(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n\n  if (_.isObject(options.hooks)) {\n    var interceptors = popupRef.interceptors; // support hooks in array\n\n    _.each(options.hooks, function (value, key) {\n      const v = [].concat(value || []);\n      const k = getHookKey(key);\n      k && (interceptors[k] = v);\n    });\n  } // TODO\n  // // ensure close any orphan popup in case scope was destroyed\n  // var scope = ngUtils.getElementScope( popupEl );\n  // scope.$on( '$destroy', function () {\n  //     // clear this flag so that this popup could be closed.\n  //     delete options.disableClose;\n  //     popupRef.panelEl && options.api.hide( popupEl );\n  // } );\n\n}\n/**\n *\n * @param {JQLite} popupRef The panel element.\n */\n\n\nfunction addEventListeners(popupRef) {\n  configureAutoFocusAndLoopTabbable(popupRef);\n  configureWatchSizeChange(popupRef);\n  configureEscapeToClose(popupRef);\n  configureClickOutsideToClose(popupRef);\n  configureScrollListener(popupRef);\n  configureResizeListener(popupRef);\n}\n\nfunction configureAutoFocusAndLoopTabbable(popupRef) {\n  const {\n    options,\n    panelEl,\n    interceptors,\n    _removeListeners\n  } = popupRef;\n  const {\n    autoFocus\n  } = options;\n\n  if (autoFocus !== false) {\n    const dialogNode = getContentContainer(panelEl);\n    const {\n      removeHandlers,\n      onClose\n    } = wcagSvc.configureAutoFocus(dialogNode, popupRef);\n\n    _removeListeners.push(...removeHandlers);\n\n    interceptors.close.push(onClose);\n  }\n}\n\nfunction configureWatchSizeChange(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl; // ease the cost, or will cause mouseenter/mouseleave flickering issue in tooltip\n\n  var debouncedUpdatePosition = throttle(options.api.updatePosition);\n  var listener = addWatchHandle(popupEl, function () {\n    debouncedUpdatePosition();\n  }); // Queue remove listeners function\n\n  popupRef._removeListeners.push(listener);\n}\n\nfunction configureEscapeToClose(popupRef) {\n  var options = popupRef.options;\n\n  const handleEscape = event => {\n    if (popupRef && popupRef.options && popupRef.options.customClass !== TOOLTIP_POPUP_CSS) {\n      let key = event.key || event.keyCode;\n\n      if (key === keyCode.ESCAPE && options.closeWhenEsc !== false && declUtils.isNil(popupRef.nextPopup)) {\n        event.stopPropagation();\n        popupRef.hide();\n        wcagSvc.skipToFirstFocusableElement(options.reference);\n      }\n    }\n  }; // Add listeners\n\n\n  document.addEventListener('keyup', handleEscape); // Queue remove listeners function\n\n  popupRef._removeListeners.push(() => {\n    document.removeEventListener('keyup', handleEscape);\n  });\n}\n\nfunction checkIgnore(options, sourceEl) {\n  var set = options.ignoreClicksFrom || [];\n\n  if (options.ignoreClicksFrom) {\n    // force convert to array\n    set = [].concat(set);\n  }\n\n  if (options.ignoreReferenceClick && options.reference) {\n    set.push(options.reference);\n  }\n\n  var found = set.find(item => {\n    let element = getElement(item);\n\n    if (element && (element === sourceEl || element.contains(sourceEl))) {\n      return true;\n    }\n\n    return false;\n  });\n  return Boolean(found);\n}\n\nfunction configureClickOutsideToClose(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var target = options.parent;\n  var reference = options.reference;\n\n  if (options.clickOutsideToClose) {\n    var sourceEl; // Keep track of the element on which the mouse originally went down\n    // so that we can only close the backdrop when the 'click' started on it.\n    // A simple 'click' handler does not work, it sets the target object as the\n    // element the mouse went down on.\n    // var mousedownHandler = function( ev ) {\n    //     sourceEl = ev.target;\n    // };\n    // We check if our original element and the target is the backdrop\n    // because if the original was the backdrop and the target was inside the\n    // panel we don't want to panel to close.\n\n    var clickHandler = function (ev) {\n      if (isTooltipClick(ev) || isNotyClick(ev) || isCalendarClick(ev)) {\n        return;\n      } // We check if the sourceEl of the event is the panel element or one\n      // of it's children. If it is not, then close the panel.\n\n\n      sourceEl = ev.target;\n\n      if (sourceEl !== popupEl && !popupEl.contains(sourceEl) && !isTooltipClick(sourceEl)) {\n        if (!checkIgnore(options, sourceEl)) {\n          options.api.hide(popupRef);\n        }\n      }\n    }; // Add listeners\n\n\n    dom.on(target, 'click,contextmenu', clickHandler, true); // Queue remove listeners function\n\n    popupRef._removeListeners.push(function () {\n      dom.off(target, 'click,contextmenu', clickHandler, true);\n    });\n  }\n}\n\nconst isTooltipClick = event => dom.closest(event.target, '.sw-popup-tooltip');\n\nconst isNotyClick = event => dom.closest(event.target, '#noty_bottom_layout_container');\n\nconst isCalendarClick = event => dom.closest(event.target, FLATPICKR_ID); // function isTooltipClick( sourceEl ) {\n//     let tooltip = dom.closest( sourceEl, '.sw-popup-tooltip' );\n//     return Boolean( tooltip );\n// }\n\n\nfunction configureResizeListener(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var handler = null;\n\n  if (options.resizeToClose) {\n    var debouncedHide = throttle(options.api.hide);\n\n    handler = () => {\n      debouncedHide(popupRef);\n    };\n  } else {\n    var debouncedUpdatePosition = throttle(options.api.updatePosition);\n\n    handler = () => {\n      debouncedUpdatePosition();\n    };\n  } // // Add listeners, use framework's event 'windowResize' instead of native event 'resize'\n  // var scope = ngUtils.getElementScope( popupEl );\n  // var removeListener = scope.$on( 'windowResize', handler );\n  // // Queue remove listeners function\n  // popupRef._removeListeners.push( function () {\n  //     removeListener();\n  // } );\n  // if ( options.listenAreaChanges !== false ) {\n  //     // FUTURE: use reference element's resize event, which needs framework's support.\n  //     var sub = eventBus.subscribe( 'aw-splitter-update', handler );\n  //     popupRef._removeListeners.push( () => { eventBus.unsubscribe( sub ); } );\n  // }\n  // FUTURE: use reference element's resize/move event, which needs framework's support.\n  // Add listeners\n\n\n  window.addEventListener('resize', handler); // Queue remove listeners function\n\n  popupRef._removeListeners.push(() => {\n    window.removeEventListener('resize', handler);\n  });\n}\n/**\n * Firefox and Qt browser have scroll issues: scroll event is firing multiple times even when mouse moves or hover on any element\n * Solution: for these browser, need to remember the last reported scroll position and check it against each new reported scroll position\n *\n * @returns {boolean} result - true for Firefox or Qt browser, false for others\n */\n\n\nfunction checkBrowser() {\n  return browserUtils.isFirefox || browserUtils.isQt;\n}\n\nfunction checkOutsideScrollEvent(event, popupEl) {\n  var path = eventPath(event);\n  return _.indexOf(path, popupEl) === -1;\n}\n\nfunction checkAncestorScrollEvent(event, popupEl, options) {\n  let {\n    reference,\n    useOutsideScrollEvent\n  } = options;\n\n  if (!reference || useOutsideScrollEvent) {\n    return checkOutsideScrollEvent(event, popupEl);\n  }\n\n  let path = composedPath(reference);\n  return _.indexOf(path, event.target) !== -1;\n}\n\nfunction configureScrollListener(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var onScroll;\n  var target = null;\n  var onScrollWrapper = null;\n\n  if (options.closeWhenParentScroll) {\n    var debouncedHide = throttle(options.api.hide);\n\n    var processScrollEvent = function (event) {\n      debouncedHide(popupRef);\n    };\n\n    var checkScrollPosition = function (target) {\n      var oldY = target.scrollTop;\n      var oldX = target.scrollLeft;\n\n      var wrapper = function (event) {\n        if (event.target !== target) {\n          return;\n        }\n\n        var curY = event.target.scrollTop;\n        var curX = event.target.scrollLeft;\n\n        if (Math.abs(oldX - curX) > _MAX_X || Math.abs(oldY - curY) > _MAX_Y) {\n          oldX = curX;\n          oldY = curY;\n          processScrollEvent(event);\n        }\n      };\n\n      window.removeEventListener('scroll', onScroll, true);\n      target.addEventListener('scroll', wrapper, true);\n      return wrapper;\n    };\n\n    onScroll = function (event) {\n      // skip if scroll happens inside any ancestor node or an input field (like sibling lov case)\n      if (!checkAncestorScrollEvent(event, popupEl, options) || event.target.tagName === 'INPUT') {\n        return;\n      } // Firefox issue: scroll event is firing multiple times even when mouse moves or hover on any element\n      // Solution: need to remember the last reported scroll position and check it against each new reported scroll position\n\n\n      if (checkBrowser()) {\n        target = event.target;\n        onScrollWrapper = checkScrollPosition(target);\n        return;\n      }\n\n      processScrollEvent(event);\n    };\n  } else if (options.followParentScroll) {\n    var debouncedUpdatePosition = throttle(options.api.updatePosition);\n\n    onScroll = function (event) {\n      if (checkAncestorScrollEvent(event, popupEl, options)) {\n        debouncedUpdatePosition();\n      }\n    };\n  }\n\n  if (onScroll) {\n    // Add listeners.\n    window.addEventListener('scroll', onScroll, true); // Queue remove listeners function.\n\n    popupRef._removeListeners.push(function () {\n      window.removeEventListener('scroll', onScroll, true);\n\n      if (checkBrowser() && target) {\n        target.removeEventListener('scroll', onScrollWrapper, true);\n      }\n    });\n  }\n}\n\nexport let getContainerElement = function (popupEl) {\n  return dom.get('.sw-popup-layout', popupEl);\n};\n\nconst getContentContainer = function (popupEl) {\n  // eslint-disable-next-line sonarjs/no-duplicate-string\n  return dom.get('.sw-popup-contentContainer', popupEl);\n};\n\nexport let processOptions = function (popupEl, options) {\n  var container = getContainerElement(popupEl);\n\n  if (!container) {\n    return;\n  }\n\n  if (options.customClass) {\n    let customClasses = options.customClass.split(/\\s+|,/);\n    customClasses.forEach(i => {\n      dom.addClass(container, i);\n    });\n  }\n\n  var sizeCss = {};\n  var needUpdateStyle = false;\n\n  if (options.containerWidth) {\n    sizeCss.width = options.containerWidth;\n    sizeCss['max-width'] = null;\n    needUpdateStyle = true;\n  }\n\n  if (options.containerHeight) {\n    sizeCss.height = options.containerHeight;\n    sizeCss['max-height'] = null;\n    needUpdateStyle = true;\n  }\n\n  needUpdateStyle && dom.setStyles(container, sizeCss);\n};\nexport let getTemplateFromUrl = function (url) {\n  return AwHttpService.instance.get(url, {\n    cache: true\n  }).then(response => response.data).catch(() => AwPromiseService.instance.reject(url + ' type \"url\" not found! please check your resource!'));\n};\nexport let getTemplateFromView = function (viewId, contextScope) {// var subPanelContext = contextScope ? contextScope.subPanelContext : null;\n  // return panelContentService.getPanelContent( viewId )\n  //     .catch( () => AwPromiseService.instance.reject( viewId + ' type \"declView\" not found! please check your resource!' ) )\n  //     .then( ( viewAndViewModelResponse ) => {\n  //         return viewModelService.populateViewModelPropertiesFromJson( viewAndViewModelResponse.viewModel, false, null, null, null, subPanelContext )\n  //             .then( ( declarativeViewModel ) => {\n  //                 viewModelService.setupLifeCycle( contextScope, declarativeViewModel );\n  //                 // align lifecycleHooks\n  //                 contextScope._onMount = () => {\n  //                     let onMountAction = _.get( contextScope, 'data._internal.lifecycleHooks.onMount' );\n  //                     onMountAction && viewModelService.executeCommand( contextScope.data, onMountAction, contextScope );\n  //                 };\n  //                 // Legacy compatible: application are listening this event to retrieve data for that view\n  //                 let modelId = _.get( contextScope, 'data._internal.modelId' ) || '?';\n  //                 eventBus.publish( viewId + '.contentLoaded', { scope: contextScope, _source: modelId } );\n  //                 return AwPromiseService.instance.resolve( viewAndViewModelResponse.view );\n  //             } );\n  //     } );\n};\n\nfunction getId(panelEl, forceUid) {\n  if (!panelEl) {\n    return null;\n  } // force generate uid if\n  // 1, not have a id\n  // 2, multiple mode open\n\n\n  if (forceUid && panelEl.id) {\n    panelEl.id = '';\n  }\n\n  if (!panelEl.id) {\n    dom.uniqueId(panelEl);\n  }\n\n  return panelEl.id;\n}\n/**\n * get the element\n *\n * @param {Element | String} element - can be an Element, or query string\n * @returns {Element} element\n */\n\n\nexport let getElement = function (element) {\n  if (_.isString(element)) {\n    element = dom.get(element);\n  }\n\n  return element;\n}; // ONLY FOR declarative usage due to principle: CSS selectors should not be exposed to view model\n// extend selector by add id sign\n\nexport let extendSelector = function (element) {\n  var reValidSelector = /^(\\.|#|aw)/i;\n\n  if (_.isString(element) && !reValidSelector.test(element)) {\n    element = element + ', #' + element;\n  }\n\n  return element;\n};\nexport let getArrowElement = function (popupEl) {\n  return dom.get('.sw-popup-arrow', popupEl);\n};\n\nfunction addWatchHandle(popupEl, cb) {\n  let containerEl = getContainerElement(popupEl);\n\n  let fn = () => {\n    if (cb && _.isFunction(cb)) {\n      cb();\n    }\n  };\n\n  return resizeDetector(containerEl, fn);\n} // provide opportunity for user to specify the resizeContainer selector\n\n\nexport let getResizeContainer = function (element, containerSelector) {\n  if (containerSelector && dom.match(element, containerSelector)) {\n    return element;\n  }\n\n  let selector = containerSelector || '.aw-base-scrollPanel';\n\n  if (!containerSelector && dom.get('.sw-popup-contentContainer', element)) {\n    selector = '.sw-popup-contentContainer';\n  }\n\n  return dom.get(selector, element);\n};\nexport let getMousePosition = function (event) {\n  let target = {\n    clientX: 0,\n    clientY: 0\n  };\n\n  if (event) {\n    target = event;\n\n    if (_.isUndefined(event.clientX)) {\n      target = event.touches[0];\n    }\n  }\n\n  let {\n    clientX,\n    clientY\n  } = target;\n  return {\n    x: clientX,\n    y: clientY\n  };\n}; // it implements a window frame based throttle function to ease intensively triggered window events.\n// motivation is to improve performance, to ensure callback will only be fired once per frame for intensively triggered window events.\n// references: $mdDialog using a throttle decorator to decorate $$rAF service. popper.js implement it's own window frame based throttle method.\n\nfunction throttle(fn) {\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n  var supportsMicroTasks = isBrowser && window.Promise; // eslint-disable-next-line one-var\n\n  var queuedArgs, alreadyQueued, queueCb, context;\n\n  var microtaskThrottle = function (fn) {\n    alreadyQueued = false;\n    return function throttled() {\n      queuedArgs = arguments;\n      context = this;\n      queueCb = fn;\n\n      if (alreadyQueued) {\n        return;\n      }\n\n      alreadyQueued = true;\n      window.Promise.resolve().then(() => {\n        alreadyQueued = false;\n        queueCb.apply(context, Array.prototype.slice.call(queuedArgs));\n      });\n    };\n  };\n\n  var taskThrottle = function (fn) {\n    var scheduled = false;\n    var task = window.requestAnimationFrame || window.setTimeout;\n    return function throttled() {\n      var queuedArgs = arguments;\n      context = this;\n      queueCb = fn;\n\n      if (!scheduled) {\n        scheduled = true;\n        task(() => {\n          scheduled = false;\n          queueCb.apply(context, Array.prototype.slice.call(queuedArgs));\n        });\n      }\n    };\n  };\n\n  return (supportsMicroTasks ? microtaskThrottle : taskThrottle)(fn);\n}\n\nfunction composedPath(el) {\n  let path = [];\n\n  while (el) {\n    path.push(el);\n\n    if (el.tagName === 'HTML') {\n      path.push(document);\n      path.push(window);\n      return path;\n    }\n\n    el = el.parentElement;\n  }\n\n  return path;\n} // get the event path in dom event bubbling\n\n\nfunction eventPath(event) {\n  var path = event.path || event.composedPath && event.composedPath(); // event.path always has wrong value for Qt browser\n\n  if (!path || browserUtils.isQt) {\n    return composedPath(event.target);\n  }\n\n  return path;\n} // return the first clean node by skip any comment node.\n\n\nexport let cleanNode = nodesArray => {\n  let result = null;\n\n  if (nodesArray && nodesArray.length > 0) {\n    result = _.find(nodesArray, item => {\n      return item.nodeType !== HTMLElement.COMMENT_NODE;\n    });\n  }\n\n  return result;\n}; // verify whether have any plain string content loaded\n\nlet verifyText = node => {\n  return Boolean((node.innerText || '').replace(/\\s|\\r|\\n/g, ''));\n}; // verify whether have any media content loaded\n\n\nlet verifyMedia = node => {\n  return Boolean(dom.get('img, svg', node));\n};\n\nexport let tooltipAdapteStyle = node => {\n  // tooltip expected parent element to have \"display: block\" other than \"display: flex\"\n  dom.removeClass(node, 'aw-layout-flexbox');\n  dom.setStyle(node, 'overflow', 'hidden');\n}; // getLoadingStatus by check transclude / plainHtml contents\n// used for balloon and tooltip\n\nlet getLoadingStatus = (container, adapteStyle) => {\n  let [container_css, transclude_css] = ['.aw-layout-flexColumnContainer', 'aw-include>div.aw-layout-include, div.aw-base-scrollPanel>ng-transclude'];\n  var content = dom.get(container_css, container);\n\n  if (!content) {\n    return false;\n  }\n\n  var transclude = dom.get(transclude_css, content);\n  var transcluded = Boolean(transclude) && Boolean(cleanNode(transclude.childNodes));\n\n  if (transcluded && adapteStyle) {\n    tooltipAdapteStyle(transclude);\n  }\n\n  return verifyText(content) || verifyMedia(content);\n};\n\nexport let runLoadingCheck = function (context, container) {\n  let adapteStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  let loaded = () => getLoadingStatus(container, adapteStyle);\n\n  let apply = function () {\n    let loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    context.loading = loading;\n    context.$apply && context.$apply();\n  };\n\n  return new Promise(resolve => {\n    // defer to next cycle to avoid show loading in cache case\n    setTimeout(() => {\n      let loading = !loaded();\n      apply(loading);\n\n      if (!loading) {\n        resolve();\n        return;\n      }\n\n      let timer = setInterval(() => {\n        if (loaded()) {\n          apply(false);\n        }\n\n        if (!context.loading || !dom.inDOM(container)) {\n          clearInterval(timer);\n          resolve();\n        }\n      }, 50);\n    });\n  });\n};\nconst RESIZE_POLLING_TIMEOUT = 500;\nexport let runResizeCheck = container => {\n  let oldSize = {\n    width: container.offsetWidth,\n    height: container.offsetHeight\n  };\n  let noResizeTimeStart = Date.now();\n  return new Promise(resolve => {\n    let timer = setInterval(() => {\n      if (checkResize(container, oldSize)()) {\n        noResizeTimeStart = Date.now();\n      } else {\n        let noResizeTime = Date.now() - noResizeTimeStart; // size got stable till now, safe to resolve.\n\n        if (noResizeTime > RESIZE_POLLING_TIMEOUT) {\n          clearInterval(timer);\n          resolve();\n        }\n      }\n    }, 50);\n  });\n};\nexport let tooltipProgressCheck = (cb, progress) => {\n  let timer = setInterval(() => {\n    if (!progress.busy) {\n      clearInterval(timer);\n      cb && cb();\n    }\n  }, 50);\n};\nexport let closeExistingTooltip = () => {\n  let nodes = dom.getAll('div.aw-popup-tooltip');\n  let results = dom.getParent(nodes);\n  results && results.length > 0 && dom.remove(results);\n};\n\nlet checkWithinRightSide = node => {\n  return window.innerWidth / 3 - node.getBoundingClientRect().left < 0;\n};\n\nexport let tooltipAdapteOption = (raw, target) => {\n  let result = Object.assign({}, raw); // backward compatible\n\n  if (raw.alignment && !raw.placement) {\n    if (raw.alignment === 'VERTICAL') {\n      result.placement = 'right'; // if target element locate at the right side of the page, then flip the placement\n\n      if (checkWithinRightSide(target)) {\n        result.placement = 'left';\n      }\n    } else if (/^(RIGHT|LEFT)/.test(raw.alignment)) {\n      result.placement = 'right';\n    } else if (/^(TOP|BOTTOM)/.test(raw.alignment)) {\n      result.placement = 'top';\n    }\n  }\n\n  return result;\n};\nexport let processTooltipOptions = (rawOptions, target, popupOpenedCb, popupClosedCb) => {\n  let options = {\n    ownContainer: true,\n    placement: ['top', 'bottom', 'right', 'left'],\n    flipBehavior: 'opposite',\n    whenParentScrolls: 'close',\n    adaptiveShift: true,\n    // prevent tooltip cut off in corner case\n    resizeToClose: true,\n    advancePositioning: true,\n    // prevent overlap or flash when popup content growing\n    hasArrow: true,\n    padding: {\n      x: 4,\n      y: 4\n    },\n    arrowOptions: {\n      alignment: 'center'\n    },\n    reference: target,\n    minSize: 5,\n    forceCloseOthers: false,\n    customClass: 'aw-popup-tooltip aw_popup_easein',\n    hooks: {\n      whenOpened: element => {\n        popupOpenedCb && popupOpenedCb(element);\n      },\n      whenClosed: element => {\n        popupClosedCb && popupClosedCb(element);\n      }\n    }\n  };\n\n  if (_.keys(rawOptions).length > 0) {\n    Object.assign(options, tooltipAdapteOption(rawOptions, target));\n  }\n\n  return options;\n};\nexport let removeNativeTitle = node => {\n  dom.removeAttribute(node, 'title');\n  let results = dom.getAll('[title]', node);\n  results.length > 0 && dom.removeAttribute(results, 'title');\n};\nexports = {\n  POPUP_ID_ATTRIBUTE,\n  PanelRef,\n  PopupManager,\n  handleOpenedPopup,\n  processOptions,\n  getTemplateFromUrl,\n  getTemplateFromView,\n  getElement,\n  checkIgnore,\n  extendSelector,\n  getContainerElement,\n  getArrowElement,\n  getResizeContainer,\n  getMousePosition,\n  cleanNode,\n  runLoadingCheck,\n  runResizeCheck,\n  tooltipProgressCheck,\n  closeExistingTooltip,\n  tooltipAdapteOption,\n  tooltipAdapteStyle,\n  processTooltipOptions,\n  removeNativeTitle,\n  getContentContainer\n};\nexport default exports;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"PanelRef\");\n$RefreshReg$(_c2, \"PopupManager\");","map":{"version":3,"names":["_","DOMAPIs","dom","browserUtils","checkResize","resizeDetector","AwHttpService","AwPromiseService","declUtils","Draggable","keyCode","wcagSvc","FLATPICKR_ID","exports","TOOLTIP_POPUP_CSS","_MAX_X","_MAX_Y","POPUP_ID_ATTRIBUTE","PanelRef","panelEl","options","id","getId","forceUid","isAttached","_removeListeners","interceptors","prototype","initialize","updateBackReference","activateLifeCycleHooks","addEventListeners","processEnablers","processMultipleLevel","clear","removeEventListeners","attach","triggerHook","detach","isAdd","reference","referenceEl","value","setAttribute","scheduleUpdate","requestAnimationFrame","api","updatePosition","update","newOptions","force","canClose","disableClose","hide","popupRef","parentPopup","nextPopup","type","indexOf","each","item","PopupManager","_previousPopupRef","_popupMaps","get","add","panelRef","isPanelRefTooltip","querySelector","validPanelRef","k","Object","keys","reverse","validEl","remove","defineProperty","enumerable","configurable","set","handleOpenedPopup","manager","toggleMode","getAttribute","append","forEach","removeFn","draggable","draggableInitializeDelay","setTimeout","popupEl","dragElement","headerElement","handle","undefined","dragger","limit","document","body","setCursor","className","draggableClassName","onDragStart","disableUpdate","advancePositioning","setStyles","right","bottom","push","destroy","bind","processNested","preset","closest","ref","ignoreClicksFrom","autoFocus","getContainerElement","focus","hookHash","whenOpened","whenUpdated","whenClosed","getHookKey","key","replace","matched","isObject","hooks","v","concat","configureAutoFocusAndLoopTabbable","configureWatchSizeChange","configureEscapeToClose","configureClickOutsideToClose","configureScrollListener","configureResizeListener","dialogNode","getContentContainer","removeHandlers","onClose","configureAutoFocus","close","debouncedUpdatePosition","throttle","listener","addWatchHandle","handleEscape","event","customClass","ESCAPE","closeWhenEsc","isNil","stopPropagation","skipToFirstFocusableElement","addEventListener","removeEventListener","checkIgnore","sourceEl","ignoreReferenceClick","found","find","element","getElement","contains","Boolean","target","parent","clickOutsideToClose","clickHandler","ev","isTooltipClick","isNotyClick","isCalendarClick","on","off","handler","resizeToClose","debouncedHide","window","checkBrowser","isFirefox","isQt","checkOutsideScrollEvent","path","eventPath","checkAncestorScrollEvent","useOutsideScrollEvent","composedPath","onScroll","onScrollWrapper","closeWhenParentScroll","processScrollEvent","checkScrollPosition","oldY","scrollTop","oldX","scrollLeft","wrapper","curY","curX","Math","abs","tagName","followParentScroll","processOptions","container","customClasses","split","i","addClass","sizeCss","needUpdateStyle","containerWidth","width","containerHeight","height","getTemplateFromUrl","url","instance","cache","then","response","data","catch","reject","getTemplateFromView","viewId","contextScope","uniqueId","isString","extendSelector","reValidSelector","test","getArrowElement","cb","containerEl","fn","isFunction","getResizeContainer","containerSelector","match","selector","getMousePosition","clientX","clientY","isUndefined","touches","x","y","isBrowser","supportsMicroTasks","Promise","queuedArgs","alreadyQueued","queueCb","context","microtaskThrottle","throttled","arguments","resolve","apply","Array","slice","call","taskThrottle","scheduled","task","el","parentElement","cleanNode","nodesArray","result","length","nodeType","HTMLElement","COMMENT_NODE","verifyText","node","innerText","verifyMedia","tooltipAdapteStyle","removeClass","setStyle","getLoadingStatus","adapteStyle","container_css","transclude_css","content","transclude","transcluded","childNodes","runLoadingCheck","loaded","loading","$apply","timer","setInterval","inDOM","clearInterval","RESIZE_POLLING_TIMEOUT","runResizeCheck","oldSize","offsetWidth","offsetHeight","noResizeTimeStart","Date","now","noResizeTime","tooltipProgressCheck","progress","busy","closeExistingTooltip","nodes","getAll","results","getParent","checkWithinRightSide","innerWidth","getBoundingClientRect","left","tooltipAdapteOption","raw","assign","alignment","placement","processTooltipOptions","rawOptions","popupOpenedCb","popupClosedCb","ownContainer","flipBehavior","whenParentScrolls","adaptiveShift","hasArrow","padding","arrowOptions","minSize","forceCloseOthers","removeNativeTitle","removeAttribute"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/popup/src/js/popupUtils.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the popup code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/popupUtils\n */\nimport _ from 'lodash';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport browserUtils from 'js/browserUtils';\n// import eventBus from 'js/eventBus';\n// import panelContentService from 'js/panelContentService';\nimport { checkResize, resizeDetector } from 'js/resizeDetector';\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport declUtils from 'js/declUtils';\nimport Draggable from 'js/draggable';\nimport keyCode from 'js/keyCode';\nimport wcagSvc from 'js/wcagService';\nimport { FLATPICKR_ID } from 'js/dateTimeService';\n\nvar exports = {};\nvar TOOLTIP_POPUP_CSS = 'sw-popup-tooltip sw_popup_easein';\n\n/**\n * The ammount the input box is allowed to move to the left/right before the UI popup (e.g. calendar, LOV ) is collapsed/hidden.\n */\nvar _MAX_X = 40;\nvar _MAX_Y = 40;\n\nvar POPUP_ID_ATTRIBUTE = 'data-popup-id';\n\n// eslint-disable-next-line one-var\n\n/**\n * A reference to a created panel. This reference contains with properties/functions used to control the panel.\n * @param {!Object} panelEl the panelEl to wrap\n * @param {!Object} options the panel options\n * @final @constructor\n */\nfunction PanelRef( panelEl, options ) {\n    this.id = getId( panelEl, options.forceUid );\n    this.panelEl = panelEl;\n    this.options = options;\n    this.isAttached = false;\n    this._removeListeners = [];\n    this.interceptors = {};\n}\nPanelRef.prototype.initialize = function() {\n    this.updateBackReference( true );\n    activateLifeCycleHooks( this );\n    addEventListeners( this );\n    processEnablers( this );\n    processMultipleLevel( this );\n};\nPanelRef.prototype.clear = function() {\n    this.updateBackReference();\n    removeEventListeners( this );\n};\nPanelRef.prototype.attach = function() {\n    this.initialize();\n    this.triggerHook( 'open' );\n    // onMount && onMount();\n    this.isAttached = true;\n};\nPanelRef.prototype.detach = function() {\n    this.clear();\n    this.triggerHook( 'close' );\n    this.interceptors = {};\n    // Remove the DOM reference\n    this.panelEl = null;\n    this.isAttached = false;\n};\nPanelRef.prototype.updateBackReference = function( isAdd ) {\n    if( !this.options.reference ) { return; }\n    var referenceEl = this.options.reference;\n    var value = isAdd ? this.id : '';\n    referenceEl.setAttribute( POPUP_ID_ATTRIBUTE, value );\n};\n/**\n * Schedules an update. It will run on the next UI update available.\n */\nPanelRef.prototype.scheduleUpdate = function() {\n    requestAnimationFrame( () => {\n        this.options.api.updatePosition();\n    } );\n};\nPanelRef.prototype.update = function( newOptions = null, force = false ) {\n    return this.options.api.update( this, newOptions, force );\n};\nPanelRef.prototype.canClose = function() {\n    return this.options && !this.options.disableClose;\n};\nPanelRef.prototype.hide = function( force = false ) {\n    if( force || !force && this.canClose() ) {\n        let popupRef = this;\n        if( popupRef.parentPopup ) {\n            //Update Next ref\n            if( popupRef.nextPopup ) {\n                popupRef.parentPopup.nextPopup = popupRef.nextPopup;\n                popupRef.nextPopup.parentPopup = popupRef.parentPopup;\n            } else {\n                popupRef.parentPopup.nextPopup = null;\n            }\n        }\n        return this.options.api.hide( this );\n    }\n};\nPanelRef.prototype.triggerHook = function( type ) {\n    if( [ 'open', 'update', 'close' ].indexOf( type ) === -1 ) { return; }\n    _.each( this.interceptors[ type ], ( item ) => { item( this ); } );\n};\nexport { PanelRef as PanelRef };\n\n/**\n * A panel manager to track and manage all panel reference .\n * @final @constructor\n */\nfunction PopupManager() {\n    this._previousPopupRef = null;\n    this._popupMaps = {};\n}\nPopupManager.prototype.get = function( id ) {\n    if( id && this._popupMaps[ id ] ) {\n        return this._popupMaps[ id ];\n    }\n    return null;\n};\nPopupManager.prototype.add = function( panelRef ) {\n    if( !panelRef ) { return; }\n    var id = panelRef.id;\n    let isPanelRefTooltip = panelRef.panelEl && panelRef.panelEl.querySelector( '.sw-popup-tooltip.sw-popup-easein' ) !== null;\n    if( !this._popupMaps[ id ] ) {\n        let validPanelRef = null;\n        for( const k of Object.keys( this._popupMaps ).reverse() ) {\n            let validEl = dom.get( '.aw-widgets-groupCommandStack', this._popupMaps[ k ].panelEl );\n            // during keyboard navigation, reference of next and parent popup should not be\n            // maintained if panelRef is an extended tooltip\n            // reference of next and parent popup should not be maintained if panelRef is a tooltip\n            if( validEl !== null && !isPanelRefTooltip ) {\n                validPanelRef = this._popupMaps[ k ];\n                break;\n            }\n        }\n        if( validPanelRef !== null ) {\n            // Maintain reference of next and parent popup\n            validPanelRef.nextPopup = panelRef;\n            panelRef.parentPopup = validPanelRef;\n        }\n        this._popupMaps[ id ] = panelRef;\n    }\n};\n\nPopupManager.prototype.remove = function( panelRef ) {\n    if( !panelRef ) { return; }\n    var id = panelRef.id;\n    this._popupMaps[ id ] && delete this._popupMaps[ id ];\n};\nObject.defineProperty( PopupManager.prototype, 'previousPopupRef', {\n    enumerable: true,\n    configurable: true,\n    get: function() { return this._previousPopupRef; },\n    set: function( value ) {\n        this._previousPopupRef = value;\n    }\n} );\nexport { PopupManager as PopupManager };\n\nexport let handleOpenedPopup = function( referenceEl, manager, toggleMode = false ) {\n    var id = referenceEl ? referenceEl.getAttribute( POPUP_ID_ATTRIBUTE ) : null;\n    var popupRef = manager.get( id );\n\n    if( id && toggleMode ) {\n        popupRef.hide();\n        return null;\n    } else if( id ) {\n        // force bring to foreground by hoist z-index or\n        // force bring to foreground by re-append (safe and easy way)\n        dom.append( popupRef.panelEl );\n        return popupRef;\n    }\n    return true;\n};\n\nfunction removeEventListeners( panelRef ) {\n    panelRef._removeListeners && panelRef._removeListeners.forEach( function( removeFn ) {\n        removeFn();\n    } );\n    panelRef._removeListeners = [];\n}\n\nfunction processEnablers( popupRef ) {\n    let options = popupRef.options;\n    let { draggable, draggableInitializeDelay = 200 } = options;\n    if( !draggable ) { return; }\n\n    // contents maybe async loaded, handle maybe not ready(exist) yet.\n    setTimeout( ()=>{\n        let popupEl = popupRef.panelEl;\n        if( popupEl ) {\n            let dragElement = dom.get( '.sw-popup-layout', popupEl );\n            let headerElement = dom.get( '.aw-layout-panelTitle, .panel-header', popupEl );\n            let handle = undefined;\n            if( options.handle ) {\n                handle = dom.get( options.handle, popupEl );\n            } else if( headerElement ) {\n                handle = headerElement;\n            } else {\n                handle = dragElement;\n            }\n            let dragger = new Draggable( dragElement, {\n                handle,\n                limit: document.body,\n                setCursor: true,\n                className: options.draggableClassName || 'sw-popup-draggable',\n                // LCS-337929: expect popup to remain where it was dragged\n                // add flag 'disableUpdate' to prevent auto update position if have been dragged\n                onDragStart: function() {\n                    options.disableUpdate = true;\n                    // remove right / bottom to ensure element draggable\n                    options.advancePositioning && dom.setStyles( dragElement, { right: null, bottom: null } );\n                }\n            } );\n            popupRef._removeListeners.push( dragger.destroy.bind( dragger ) );\n        }\n    }, draggableInitializeDelay );\n}\n\n// MultipleLevel popup command bar case:\n// build cascade MultipleLevel popup menus\n// and define the event ignore list between them\nfunction processMultipleLevel( popupRef ) {\n    let { options, panelEl } = popupRef;\n    let { reference, manager, processNested, preset } = options;\n\n    // exclude tooltip process\n    if( preset && preset === 'tooltip' ) { return; }\n    if( processNested === false || !reference || !manager ) { return; }\n\n    // add current popup to ignore click list of all up Level popups\n    let parentPopup = dom.closest( reference, 'div.sw-popup' );\n    while( parentPopup && reference && manager ) {\n        let ref = manager.get( parentPopup.id );\n        ref.options.ignoreClicksFrom = ref.options.ignoreClicksFrom || [];\n        ref.options.ignoreClicksFrom.push( panelEl );\n\n        // check upper level recursively\n        reference = ref.options.reference;\n        manager = ref.options.manager;\n        parentPopup = dom.closest( reference, 'div.sw-popup' );\n    }\n}\n\nfunction autoFocus( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    if( options.autoFocus !== false ) {\n        getContainerElement( popupEl ).focus();\n    }\n}\n\nconst hookHash = { whenOpened: 'open', whenUpdated: 'update', whenClosed: 'close' };\nconst getHookKey = ( key ) => key.replace( /whenOpened|whenUpdated|whenClosed/g, matched => hookHash[ matched ] );\n\nfunction activateLifeCycleHooks( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    if( _.isObject( options.hooks ) ) {\n        var interceptors = popupRef.interceptors;\n        // support hooks in array\n        _.each( options.hooks, function( value, key ) {\n            const v = [].concat( value || [] );\n            const k = getHookKey( key );\n            k && ( interceptors[ k ] = v );\n        } );\n    }\n\n    // TODO\n    // // ensure close any orphan popup in case scope was destroyed\n    // var scope = ngUtils.getElementScope( popupEl );\n    // scope.$on( '$destroy', function () {\n    //     // clear this flag so that this popup could be closed.\n    //     delete options.disableClose;\n    //     popupRef.panelEl && options.api.hide( popupEl );\n    // } );\n}\n/**\n *\n * @param {JQLite} popupRef The panel element.\n */\nfunction addEventListeners( popupRef ) {\n    configureAutoFocusAndLoopTabbable( popupRef );\n    configureWatchSizeChange( popupRef );\n    configureEscapeToClose( popupRef );\n    configureClickOutsideToClose( popupRef );\n    configureScrollListener( popupRef );\n    configureResizeListener( popupRef );\n}\n\nfunction configureAutoFocusAndLoopTabbable( popupRef ) {\n    const { options, panelEl, interceptors, _removeListeners } = popupRef;\n    const { autoFocus } = options;\n\n    if( autoFocus !== false ) {\n        const dialogNode = getContentContainer( panelEl );\n        const { removeHandlers, onClose } = wcagSvc.configureAutoFocus( dialogNode, popupRef );\n        _removeListeners.push( ...removeHandlers );\n        interceptors.close.push( onClose );\n    }\n}\n\nfunction configureWatchSizeChange( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    // ease the cost, or will cause mouseenter/mouseleave flickering issue in tooltip\n    var debouncedUpdatePosition = throttle( options.api.updatePosition );\n    var listener = addWatchHandle( popupEl, function() {\n        debouncedUpdatePosition();\n    } );\n\n    // Queue remove listeners function\n    popupRef._removeListeners.push( listener );\n}\n\nfunction configureEscapeToClose( popupRef ) {\n    var options = popupRef.options;\n    const handleEscape = ( event ) => {\n        if( popupRef && popupRef.options && popupRef.options.customClass !== TOOLTIP_POPUP_CSS ) {\n            let key = event.key || event.keyCode;\n            if( key === keyCode.ESCAPE && options.closeWhenEsc !== false && declUtils.isNil( popupRef.nextPopup ) ) {\n                event.stopPropagation();\n                popupRef.hide();\n                wcagSvc.skipToFirstFocusableElement( options.reference );\n            }\n        }\n    };\n\n    // Add listeners\n    document.addEventListener( 'keyup', handleEscape );\n\n    // Queue remove listeners function\n    popupRef._removeListeners.push( () => {\n        document.removeEventListener( 'keyup', handleEscape );\n    } );\n}\n\nfunction checkIgnore( options, sourceEl ) {\n    var set = options.ignoreClicksFrom || [];\n    if( options.ignoreClicksFrom ) {\n        // force convert to array\n        set = [].concat( set );\n    }\n\n    if( options.ignoreReferenceClick && options.reference ) {\n        set.push( options.reference );\n    }\n\n    var found = set.find( ( item ) => {\n        let element = getElement( item );\n        if( element &&\n            ( element === sourceEl || element.contains( sourceEl ) )\n        ) {\n            return true;\n        }\n        return false;\n    } );\n\n    return Boolean( found );\n}\n\nfunction configureClickOutsideToClose( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var target = options.parent;\n    var reference = options.reference;\n    if( options.clickOutsideToClose ) {\n        var sourceEl;\n\n        // Keep track of the element on which the mouse originally went down\n        // so that we can only close the backdrop when the 'click' started on it.\n        // A simple 'click' handler does not work, it sets the target object as the\n        // element the mouse went down on.\n        // var mousedownHandler = function( ev ) {\n        //     sourceEl = ev.target;\n        // };\n\n        // We check if our original element and the target is the backdrop\n        // because if the original was the backdrop and the target was inside the\n        // panel we don't want to panel to close.\n        var clickHandler = function( ev ) {\n            if( isTooltipClick( ev ) || isNotyClick( ev ) || isCalendarClick( ev ) ) {\n                return;\n            }\n\n            // We check if the sourceEl of the event is the panel element or one\n            // of it's children. If it is not, then close the panel.\n            sourceEl = ev.target;\n            if( sourceEl !== popupEl && !popupEl.contains( sourceEl ) && !isTooltipClick( sourceEl ) ) {\n                if( !checkIgnore( options, sourceEl ) ) {\n                    options.api.hide( popupRef );\n                }\n            }\n        };\n\n        // Add listeners\n        dom.on( target, 'click,contextmenu', clickHandler, true );\n\n        // Queue remove listeners function\n        popupRef._removeListeners.push( function() {\n            dom.off( target, 'click,contextmenu', clickHandler, true );\n        } );\n    }\n}\n\nconst isTooltipClick = ( event ) => dom.closest( event.target, '.sw-popup-tooltip' );\nconst isNotyClick = ( event ) => dom.closest( event.target, '#noty_bottom_layout_container' );\nconst isCalendarClick = ( event ) => dom.closest( event.target, FLATPICKR_ID );\n\n// function isTooltipClick( sourceEl ) {\n//     let tooltip = dom.closest( sourceEl, '.sw-popup-tooltip' );\n//     return Boolean( tooltip );\n// }\n\nfunction configureResizeListener( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var handler = null;\n    if( options.resizeToClose ) {\n        var debouncedHide = throttle( options.api.hide );\n        handler = () => { debouncedHide( popupRef ); };\n    } else {\n        var debouncedUpdatePosition = throttle( options.api.updatePosition );\n        handler = () => { debouncedUpdatePosition(); };\n    }\n\n    // // Add listeners, use framework's event 'windowResize' instead of native event 'resize'\n    // var scope = ngUtils.getElementScope( popupEl );\n    // var removeListener = scope.$on( 'windowResize', handler );\n    // // Queue remove listeners function\n    // popupRef._removeListeners.push( function () {\n    //     removeListener();\n    // } );\n\n    // if ( options.listenAreaChanges !== false ) {\n    //     // FUTURE: use reference element's resize event, which needs framework's support.\n    //     var sub = eventBus.subscribe( 'aw-splitter-update', handler );\n    //     popupRef._removeListeners.push( () => { eventBus.unsubscribe( sub ); } );\n    // }\n    // FUTURE: use reference element's resize/move event, which needs framework's support.\n    // Add listeners\n    window.addEventListener( 'resize', handler );\n    // Queue remove listeners function\n    popupRef._removeListeners.push( () => {\n        window.removeEventListener( 'resize', handler );\n    } );\n}\n\n/**\n * Firefox and Qt browser have scroll issues: scroll event is firing multiple times even when mouse moves or hover on any element\n * Solution: for these browser, need to remember the last reported scroll position and check it against each new reported scroll position\n *\n * @returns {boolean} result - true for Firefox or Qt browser, false for others\n */\nfunction checkBrowser() {\n    return browserUtils.isFirefox || browserUtils.isQt;\n}\n\nfunction checkOutsideScrollEvent( event, popupEl ) {\n    var path = eventPath( event );\n    return _.indexOf( path, popupEl ) === -1;\n}\n\nfunction checkAncestorScrollEvent( event, popupEl, options ) {\n    let { reference, useOutsideScrollEvent } = options;\n    if( !reference || useOutsideScrollEvent ) {\n        return checkOutsideScrollEvent( event, popupEl );\n    }\n    let path = composedPath( reference );\n    return _.indexOf( path, event.target ) !== -1;\n}\n\nfunction configureScrollListener( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var onScroll;\n\n    var target = null;\n    var onScrollWrapper = null;\n    if( options.closeWhenParentScroll ) {\n        var debouncedHide = throttle( options.api.hide );\n\n        var processScrollEvent = function( event ) {\n            debouncedHide( popupRef );\n        };\n\n        var checkScrollPosition = function( target ) {\n            var oldY = target.scrollTop;\n            var oldX = target.scrollLeft;\n\n            var wrapper = function( event ) {\n                if( event.target !== target ) { return; }\n                var curY = event.target.scrollTop;\n                var curX = event.target.scrollLeft;\n\n                if( Math.abs( oldX - curX ) > _MAX_X || Math.abs( oldY - curY ) > _MAX_Y ) {\n                    oldX = curX;\n                    oldY = curY;\n                    processScrollEvent( event );\n                }\n            };\n\n            window.removeEventListener( 'scroll', onScroll, true );\n            target.addEventListener( 'scroll', wrapper, true );\n\n            return wrapper;\n        };\n\n        onScroll = function( event ) {\n            // skip if scroll happens inside any ancestor node or an input field (like sibling lov case)\n            if( !checkAncestorScrollEvent( event, popupEl, options ) || event.target.tagName === 'INPUT' ) { return; }\n\n            // Firefox issue: scroll event is firing multiple times even when mouse moves or hover on any element\n            // Solution: need to remember the last reported scroll position and check it against each new reported scroll position\n            if( checkBrowser() ) {\n                target = event.target;\n                onScrollWrapper = checkScrollPosition( target );\n                return;\n            }\n\n            processScrollEvent( event );\n        };\n    } else if( options.followParentScroll ) {\n        var debouncedUpdatePosition = throttle( options.api.updatePosition );\n        onScroll = function( event ) {\n            if( checkAncestorScrollEvent( event, popupEl, options ) ) { debouncedUpdatePosition(); }\n        };\n    }\n\n    if( onScroll ) {\n        // Add listeners.\n        window.addEventListener( 'scroll', onScroll, true );\n\n        // Queue remove listeners function.\n        popupRef._removeListeners.push( function() {\n            window.removeEventListener( 'scroll', onScroll, true );\n            if( checkBrowser() && target ) {\n                target.removeEventListener( 'scroll', onScrollWrapper, true );\n            }\n        } );\n    }\n}\n\nexport let getContainerElement = function( popupEl ) {\n    return dom.get( '.sw-popup-layout', popupEl );\n};\n\nconst getContentContainer = function( popupEl ) {\n    // eslint-disable-next-line sonarjs/no-duplicate-string\n    return dom.get( '.sw-popup-contentContainer', popupEl );\n};\n\nexport let processOptions = function( popupEl, options ) {\n    var container = getContainerElement( popupEl );\n    if( !container ) { return; }\n    if( options.customClass ) {\n        let customClasses = options.customClass.split( /\\s+|,/ );\n        customClasses.forEach( ( i ) => { dom.addClass( container, i ); } );\n    }\n    var sizeCss = {};\n    var needUpdateStyle = false;\n    if( options.containerWidth ) {\n        sizeCss.width = options.containerWidth;\n        sizeCss[ 'max-width' ] = null;\n        needUpdateStyle = true;\n    }\n    if( options.containerHeight ) {\n        sizeCss.height = options.containerHeight;\n        sizeCss[ 'max-height' ] = null;\n        needUpdateStyle = true;\n    }\n\n    needUpdateStyle && dom.setStyles( container, sizeCss );\n};\n\nexport let getTemplateFromUrl = function( url ) {\n    return AwHttpService.instance.get( url, { cache: true } )\n        .then( ( response ) => response.data )\n        .catch( () => AwPromiseService.instance.reject( url + ' type \"url\" not found! please check your resource!' ) );\n};\n\nexport let getTemplateFromView = function( viewId, contextScope ) {\n    // var subPanelContext = contextScope ? contextScope.subPanelContext : null;\n    // return panelContentService.getPanelContent( viewId )\n    //     .catch( () => AwPromiseService.instance.reject( viewId + ' type \"declView\" not found! please check your resource!' ) )\n    //     .then( ( viewAndViewModelResponse ) => {\n    //         return viewModelService.populateViewModelPropertiesFromJson( viewAndViewModelResponse.viewModel, false, null, null, null, subPanelContext )\n    //             .then( ( declarativeViewModel ) => {\n    //                 viewModelService.setupLifeCycle( contextScope, declarativeViewModel );\n    //                 // align lifecycleHooks\n    //                 contextScope._onMount = () => {\n    //                     let onMountAction = _.get( contextScope, 'data._internal.lifecycleHooks.onMount' );\n    //                     onMountAction && viewModelService.executeCommand( contextScope.data, onMountAction, contextScope );\n    //                 };\n    //                 // Legacy compatible: application are listening this event to retrieve data for that view\n    //                 let modelId = _.get( contextScope, 'data._internal.modelId' ) || '?';\n    //                 eventBus.publish( viewId + '.contentLoaded', { scope: contextScope, _source: modelId } );\n\n    //                 return AwPromiseService.instance.resolve( viewAndViewModelResponse.view );\n    //             } );\n    //     } );\n};\n\nfunction getId( panelEl, forceUid ) {\n    if( !panelEl ) { return null; }\n    // force generate uid if\n    // 1, not have a id\n    // 2, multiple mode open\n    if( forceUid && panelEl.id ) { panelEl.id = ''; }\n    if( !panelEl.id ) { dom.uniqueId( panelEl ); }\n    return panelEl.id;\n}\n\n/**\n * get the element\n *\n * @param {Element | String} element - can be an Element, or query string\n * @returns {Element} element\n */\nexport let getElement = function( element ) {\n    if( _.isString( element ) ) {\n        element = dom.get( element );\n    }\n    return element;\n};\n\n// ONLY FOR declarative usage due to principle: CSS selectors should not be exposed to view model\n// extend selector by add id sign\nexport let extendSelector = function( element ) {\n    var reValidSelector = /^(\\.|#|aw)/i;\n    if( _.isString( element ) && !reValidSelector.test( element ) ) {\n        element = element + ', #' + element;\n    }\n    return element;\n};\n\nexport let getArrowElement = function( popupEl ) {\n    return dom.get( '.sw-popup-arrow', popupEl );\n};\n\nfunction addWatchHandle( popupEl, cb ) {\n    let containerEl = getContainerElement( popupEl );\n    let fn = () => {\n        if( cb && _.isFunction( cb ) ) { cb(); }\n    };\n    return resizeDetector( containerEl, fn );\n}\n\n// provide opportunity for user to specify the resizeContainer selector\nexport let getResizeContainer = function( element, containerSelector ) {\n    if( containerSelector && dom.match( element, containerSelector ) ) {\n        return element;\n    }\n    let selector = containerSelector || '.aw-base-scrollPanel';\n    if( !containerSelector && dom.get( '.sw-popup-contentContainer', element ) ) {\n        selector = '.sw-popup-contentContainer';\n    }\n    return dom.get( selector, element );\n};\n\nexport let getMousePosition = function( event ) {\n    let target = { clientX: 0, clientY: 0 };\n    if( event ) {\n        target = event;\n        if( _.isUndefined( event.clientX ) ) { target = event.touches[ 0 ]; }\n    }\n    let { clientX, clientY } = target;\n    return { x: clientX, y: clientY };\n};\n\n// it implements a window frame based throttle function to ease intensively triggered window events.\n// motivation is to improve performance, to ensure callback will only be fired once per frame for intensively triggered window events.\n// references: $mdDialog using a throttle decorator to decorate $$rAF service. popper.js implement it's own window frame based throttle method.\nfunction throttle( fn ) {\n    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n    var supportsMicroTasks = isBrowser && window.Promise;\n    // eslint-disable-next-line one-var\n    var queuedArgs, alreadyQueued, queueCb, context;\n\n    var microtaskThrottle = function( fn ) {\n        alreadyQueued = false;\n        return function throttled() {\n            queuedArgs = arguments;\n            context = this;\n            queueCb = fn;\n            if( alreadyQueued ) {\n                return;\n            }\n            alreadyQueued = true;\n            window.Promise.resolve().then( () => {\n                alreadyQueued = false;\n                queueCb.apply( context, Array.prototype.slice.call( queuedArgs ) );\n            } );\n        };\n    };\n\n    var taskThrottle = function( fn ) {\n        var scheduled = false;\n        var task = window.requestAnimationFrame || window.setTimeout;\n        return function throttled() {\n            var queuedArgs = arguments;\n            context = this;\n            queueCb = fn;\n            if( !scheduled ) {\n                scheduled = true;\n                task( () => {\n                    scheduled = false;\n                    queueCb.apply( context, Array.prototype.slice.call( queuedArgs ) );\n                } );\n            }\n        };\n    };\n\n    return ( supportsMicroTasks ? microtaskThrottle : taskThrottle )( fn );\n}\n\nfunction composedPath( el ) {\n    let path = [];\n    while( el ) {\n        path.push( el );\n        if( el.tagName === 'HTML' ) {\n            path.push( document );\n            path.push( window );\n            return path;\n        }\n        el = el.parentElement;\n    }\n    return path;\n}\n\n// get the event path in dom event bubbling\nfunction eventPath( event ) {\n    var path = event.path || event.composedPath && event.composedPath();\n    // event.path always has wrong value for Qt browser\n    if( !path || browserUtils.isQt ) {\n        return composedPath( event.target );\n    }\n    return path;\n}\n\n// return the first clean node by skip any comment node.\nexport let cleanNode = ( nodesArray ) => {\n    let result = null;\n    if( nodesArray && nodesArray.length > 0 ) {\n        result = _.find( nodesArray, ( item ) => {\n            return item.nodeType !== HTMLElement.COMMENT_NODE;\n        } );\n    }\n    return result;\n};\n\n// verify whether have any plain string content loaded\nlet verifyText = ( node ) => {\n    return Boolean( ( node.innerText || '' ).replace( /\\s|\\r|\\n/g, '' ) );\n};\n\n// verify whether have any media content loaded\nlet verifyMedia = ( node ) => {\n    return Boolean( dom.get( 'img, svg', node ) );\n};\n\nexport let tooltipAdapteStyle = ( node ) => {\n    // tooltip expected parent element to have \"display: block\" other than \"display: flex\"\n    dom.removeClass( node, 'aw-layout-flexbox' );\n    dom.setStyle( node, 'overflow', 'hidden' );\n};\n\n// getLoadingStatus by check transclude / plainHtml contents\n// used for balloon and tooltip\nlet getLoadingStatus = ( container, adapteStyle ) => {\n    let [ container_css, transclude_css ] = [ '.aw-layout-flexColumnContainer',\n        'aw-include>div.aw-layout-include, div.aw-base-scrollPanel>ng-transclude'\n    ];\n    var content = dom.get( container_css, container );\n    if( !content ) { return false; }\n    var transclude = dom.get( transclude_css, content );\n    var transcluded = Boolean( transclude ) && Boolean( cleanNode( transclude.childNodes ) );\n    if( transcluded && adapteStyle ) { tooltipAdapteStyle( transclude ); }\n    return verifyText( content ) || verifyMedia( content );\n};\n\nexport let runLoadingCheck = ( context, container, adapteStyle = false ) => {\n    let loaded = () => getLoadingStatus( container, adapteStyle );\n    let apply = ( loading = false ) => {\n        context.loading = loading;\n        context.$apply && context.$apply();\n    };\n    return new Promise( ( resolve ) => {\n        // defer to next cycle to avoid show loading in cache case\n        setTimeout( () => {\n            let loading = !loaded();\n            apply( loading );\n            if( !loading ) {\n                resolve();\n                return;\n            }\n            let timer = setInterval( () => {\n                if( loaded() ) { apply( false ); }\n                if( !context.loading || !dom.inDOM( container ) ) {\n                    clearInterval( timer );\n                    resolve();\n                }\n            }, 50 );\n        } );\n    } );\n};\n\nconst RESIZE_POLLING_TIMEOUT = 500;\nexport let runResizeCheck = ( container ) => {\n    let oldSize = { width: container.offsetWidth, height: container.offsetHeight };\n    let noResizeTimeStart = Date.now();\n    return new Promise( ( resolve ) => {\n        let timer = setInterval( () => {\n            if( checkResize( container, oldSize )() ) {\n                noResizeTimeStart = Date.now();\n            } else {\n                let noResizeTime = Date.now() - noResizeTimeStart;\n                // size got stable till now, safe to resolve.\n                if( noResizeTime > RESIZE_POLLING_TIMEOUT ) {\n                    clearInterval( timer );\n                    resolve();\n                }\n            }\n        }, 50 );\n    } );\n};\n\nexport let tooltipProgressCheck = ( cb, progress ) => {\n    let timer = setInterval( () => {\n        if( !progress.busy ) {\n            clearInterval( timer );\n            cb && cb();\n        }\n    }, 50 );\n};\n\nexport let closeExistingTooltip = () => {\n    let nodes = dom.getAll( 'div.aw-popup-tooltip' );\n    let results = dom.getParent( nodes );\n    results && results.length > 0 && dom.remove( results );\n};\n\nlet checkWithinRightSide = ( node ) => {\n    return window.innerWidth / 3 - node.getBoundingClientRect().left < 0;\n};\nexport let tooltipAdapteOption = ( raw, target ) => {\n    let result = Object.assign( {}, raw );\n    // backward compatible\n    if( raw.alignment && !raw.placement ) {\n        if( raw.alignment === 'VERTICAL' ) {\n            result.placement = 'right';\n            // if target element locate at the right side of the page, then flip the placement\n            if( checkWithinRightSide( target ) ) { result.placement = 'left'; }\n        } else if( /^(RIGHT|LEFT)/.test( raw.alignment ) ) {\n            result.placement = 'right';\n        } else if( /^(TOP|BOTTOM)/.test( raw.alignment ) ) {\n            result.placement = 'top';\n        }\n    }\n    return result;\n};\n\nexport let processTooltipOptions = ( rawOptions, target, popupOpenedCb, popupClosedCb ) => {\n    let options = {\n        ownContainer: true,\n        placement: [ 'top', 'bottom', 'right', 'left' ],\n        flipBehavior: 'opposite',\n        whenParentScrolls: 'close',\n        adaptiveShift: true, // prevent tooltip cut off in corner case\n        resizeToClose: true,\n        advancePositioning: true, // prevent overlap or flash when popup content growing\n        hasArrow: true,\n        padding: { x: 4, y: 4 },\n        arrowOptions: {\n            alignment: 'center'\n        },\n        reference: target,\n        minSize: 5,\n        forceCloseOthers: false,\n        customClass: 'aw-popup-tooltip aw_popup_easein',\n        hooks: {\n            whenOpened: ( element ) => { popupOpenedCb && popupOpenedCb( element ); },\n            whenClosed: ( element ) => { popupClosedCb && popupClosedCb( element ); }\n        }\n    };\n    if( _.keys( rawOptions ).length > 0 ) { Object.assign( options, tooltipAdapteOption( rawOptions, target ) ); }\n    return options;\n};\n\nexport let removeNativeTitle = ( node ) => {\n    dom.removeAttribute( node, 'title' );\n    let results = dom.getAll( '[title]', node );\n    results.length > 0 && dom.removeAttribute( results, 'title' );\n};\n\nexports = {\n    POPUP_ID_ATTRIBUTE,\n    PanelRef,\n    PopupManager,\n    handleOpenedPopup,\n    processOptions,\n    getTemplateFromUrl,\n    getTemplateFromView,\n    getElement,\n    checkIgnore,\n    extendSelector,\n    getContainerElement,\n    getArrowElement,\n    getResizeContainer,\n    getMousePosition,\n    cleanNode,\n    runLoadingCheck,\n    runResizeCheck,\n    tooltipProgressCheck,\n    closeExistingTooltip,\n    tooltipAdapteOption,\n    tooltipAdapteStyle,\n    processTooltipOptions,\n    removeNativeTitle,\n    getContentContainer\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}