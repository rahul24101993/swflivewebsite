{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used for plTable as Column Rearrangement\n *\n * @module js/splmTableColumnRearrangement\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n/**\n * Instances of this class represent a column rearrangement utility for PL Table\n *\n * @class SPLMTableColumnRearrangement\n * @param {DOMElement} tableElem - HTML DOM Element for table\n */\n\nvar SPLMTableColumnRearrangement = function (tableElem) {\n  var _columnRearrangementInProgress = false;\n  var _columnsRearranged = false;\n  var self = this;\n  /**\n   * Switch the column indexes of the column definitions attached to the headers.\n   *\n   * @param {DOMElement} header1 - first header\n   * @param {DOMElement} header2 - second header\n   *\n   * @returns {Boolean} was column index switch successful?\n   */\n\n  var switchColumnDefIndexes = function (header1, header2) {\n    var header1ColumnDefElement = header1.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n    var header2ColumnDefElement = header2.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n\n    if (header1ColumnDefElement && header1ColumnDefElement.columnDef && header2ColumnDefElement && header2ColumnDefElement.columnDef) {\n      var tempColumnIndex = header1ColumnDefElement.columnDef.index;\n      header1ColumnDefElement.columnDef.index = header2ColumnDefElement.columnDef.index;\n      header2ColumnDefElement.columnDef.index = tempColumnIndex;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Rearrange the column headers if the position parameter is outside the bounds of the original header element.\n   *\n   * @param {HTMLElement} element - the header element\n   * @param {Number} positionX - The X position to check for position of drag\n   *\n   * @returns {Boolean} if the columns were rearranged\n   */\n\n\n  var rearrangeColumnHeaders = function (element, positionX) {\n    var elementBoundingBox = element.getBoundingClientRect();\n    var nextSibling = element.nextSibling;\n    var previousSibling = element.previousSibling;\n\n    if (nextSibling && positionX > elementBoundingBox.right + nextSibling.getBoundingClientRect().width / 3 && nextSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE) && switchColumnDefIndexes(nextSibling, element)) {\n      element.parentNode.insertBefore(nextSibling, element);\n      return true;\n    } else if (previousSibling && positionX < elementBoundingBox.left - previousSibling.getBoundingClientRect().width / 2 && previousSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE) && switchColumnDefIndexes(previousSibling, element)) {\n      element.parentNode.insertBefore(element, previousSibling);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Rearrange the content cells based on the columnDef indexes now.\n   * @param {Number} originalPosition - The original index of the column\n   * @param {Object} columnDef - the column definition\n   */\n\n\n  var rearrangeContent = function (originalPosition, columnDef) {\n    if (originalPosition === columnDef.index) {\n      return;\n    }\n\n    var targetIndex = originalPosition < columnDef.index ? -1 : 1;\n    var targetContentElements = util.getColumnContentCellElementsByIndex(tableElem, columnDef.index + targetIndex);\n    var draggedContentElements = util.getColumnContentCellElementsByIndex(tableElem, columnDef.index);\n\n    for (var i = 0; i < draggedContentElements.length; i++) {\n      var currentContentElement = draggedContentElements[i];\n      var currentTargetContentElement = targetContentElements[i];\n\n      if (originalPosition < columnDef.index) {\n        currentTargetContentElement = currentTargetContentElement.nextSibling;\n      }\n\n      currentContentElement.parentNode.insertBefore(currentContentElement, currentTargetContentElement);\n    }\n  };\n  /**\n   * Attaches the drag header events to the header element paramter.\n   *\n   * @param {DOMElement} element - header element to attach drag events\n   */\n\n\n  var attachDragHeader = function (element) {\n    var nextX = 0;\n    var currentX = 0;\n    var clonedElement;\n    var columnDef;\n    var originalPosition;\n    element.classList.add(Const.CLASS_HEADER_DRAGGABLE);\n    var columnDefElement = element.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n\n    var startDragElement = function (customEvent) {\n      // Clean up menu if exist\n      var menuService = util.getTableMenuService(tableElem);\n      menuService.ensureAllTableMenusDismissed();\n      var event = customEvent ? customEvent.detail : window.event;\n      clonedElement = element.cloneNode(true);\n      clonedElement.classList.add(Const.CLASS_UTILITY_HIDDEN);\n      clonedElement.setAttribute('id', clonedElement.id + 'ClonedHeader'); // Attachment to container because of rendering problems when attached to the row\n\n      var elementContainer = util.closestElement(element, '.' + Const.CLASS_PIN_CONTAINER + ',.' + Const.CLASS_SCROLL_CONTAINER);\n      var scrollLeft = elementContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0].scrollLeft;\n      elementContainer.appendChild(clonedElement);\n      clonedElement.style.left = element.offsetLeft - scrollLeft + 'px';\n      clonedElement.style.top = element.offsetTop + 'px';\n      currentX = event.clientX;\n\n      if (columnDefElement && columnDefElement.columnDef) {\n        columnDef = columnDefElement.columnDef;\n        originalPosition = columnDef.index;\n      }\n    };\n    /**\n     *  Event to run when movement of header is in progress. Moves the element and any headers it moves over.\n     *\n     * @param {DOMEvent} customEvent - event being sent ( wrapped from 'mousemove' )\n     */\n\n\n    var dragElement = function (customEvent) {\n      var event = customEvent ? customEvent.detail : window.event;\n\n      if (!_columnRearrangementInProgress) {\n        element.classList.add('stationaryHeader');\n        clonedElement.classList.add('dragHeader');\n        clonedElement.classList.remove(Const.CLASS_UTILITY_HIDDEN);\n        _columnRearrangementInProgress = true;\n      }\n\n      nextX = currentX - event.clientX;\n      currentX = event.clientX;\n      clonedElement.style.left = clonedElement.offsetLeft - nextX + 'px';\n      _columnsRearranged = rearrangeColumnHeaders(element, event.clientX) || _columnsRearranged;\n    };\n    /**\n     * End the drag movement and replace the original header element visibility.\n     *\n     */\n\n\n    var closeDragElement = function () {\n      element.classList.remove('stationaryHeader');\n      clonedElement.parentNode.removeChild(clonedElement);\n      _columnRearrangementInProgress = false;\n\n      if (_columnsRearranged) {\n        _columnsRearranged = false;\n        var eventData = {\n          name: columnDef.name,\n          originalPosition: originalPosition\n        };\n\n        tableElem._tableInstance.tableInstanceCallbacks.columnsRearranged(eventData);\n\n        rearrangeContent(originalPosition, columnDef);\n      }\n    }; // Column Header = Label + Sort Icon + Splitter\n    // Sort Icon will occupy all spaces by flex-grow\n\n\n    var contentsElement = element.getElementsByClassName(Const.CLASS_CELL_CONTENTS)[0];\n    splmTableDragHandler.enableDragging(contentsElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_START, startDragElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG, dragElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_END, closeDragElement);\n  };\n  /**\n   * Initializes the table with header column rearrangement by dragging.\n   */\n\n\n  self.initialize = function () {\n    var headerCellElements = tableElem.getElementsByClassName(Const.CLASS_HEADER_CELL);\n\n    _.forEach(headerCellElements, function (headerCellElement) {\n      var columnDefinition;\n      var foundElements = headerCellElement.getElementsByClassName(Const.CLASS_COLUMN_DEF);\n\n      if (foundElements.length > 0) {\n        columnDefinition = foundElements[0].columnDef;\n      }\n\n      if (columnDefinition && columnDefinition.enableColumnMoving !== false) {\n        attachDragHeader(headerCellElement);\n      }\n    });\n  };\n\n  self.initialize();\n  return self;\n};\n\n_c = SPLMTableColumnRearrangement;\nexport default SPLMTableColumnRearrangement;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableColumnRearrangement\");","map":{"version":3,"names":["_","eventBus","splmTableDragHandler","Const","util","SPLMTableColumnRearrangement","tableElem","_columnRearrangementInProgress","_columnsRearranged","self","switchColumnDefIndexes","header1","header2","header1ColumnDefElement","getElementsByClassName","CLASS_COLUMN_DEF","header2ColumnDefElement","columnDef","tempColumnIndex","index","rearrangeColumnHeaders","element","positionX","elementBoundingBox","getBoundingClientRect","nextSibling","previousSibling","right","width","classList","contains","CLASS_HEADER_DRAGGABLE","parentNode","insertBefore","left","rearrangeContent","originalPosition","targetIndex","targetContentElements","getColumnContentCellElementsByIndex","draggedContentElements","i","length","currentContentElement","currentTargetContentElement","attachDragHeader","nextX","currentX","clonedElement","add","columnDefElement","startDragElement","customEvent","menuService","getTableMenuService","ensureAllTableMenusDismissed","event","detail","window","cloneNode","CLASS_UTILITY_HIDDEN","setAttribute","id","elementContainer","closestElement","CLASS_PIN_CONTAINER","CLASS_SCROLL_CONTAINER","scrollLeft","CLASS_VIEWPORT","appendChild","style","offsetLeft","top","offsetTop","clientX","dragElement","remove","closeDragElement","removeChild","eventData","name","_tableInstance","tableInstanceCallbacks","columnsRearranged","contentsElement","CLASS_CELL_CONTENTS","enableDragging","addEventListener","EVENT_ON_ELEM_DRAG_START","EVENT_ON_ELEM_DRAG","EVENT_ON_ELEM_DRAG_END","initialize","headerCellElements","CLASS_HEADER_CELL","forEach","headerCellElement","columnDefinition","foundElements","enableColumnMoving"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableColumnRearrangement.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used for plTable as Column Rearrangement\n *\n * @module js/splmTableColumnRearrangement\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n\n/**\n * Instances of this class represent a column rearrangement utility for PL Table\n *\n * @class SPLMTableColumnRearrangement\n * @param {DOMElement} tableElem - HTML DOM Element for table\n */\nvar SPLMTableColumnRearrangement = function( tableElem ) {\n    var _columnRearrangementInProgress = false;\n    var _columnsRearranged = false;\n\n    var self = this;\n\n    /**\n     * Switch the column indexes of the column definitions attached to the headers.\n     *\n     * @param {DOMElement} header1 - first header\n     * @param {DOMElement} header2 - second header\n     *\n     * @returns {Boolean} was column index switch successful?\n     */\n    var switchColumnDefIndexes = function( header1, header2 ) {\n        var header1ColumnDefElement = header1.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n        var header2ColumnDefElement = header2.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n\n        if( header1ColumnDefElement && header1ColumnDefElement.columnDef && header2ColumnDefElement && header2ColumnDefElement.columnDef ) {\n            var tempColumnIndex = header1ColumnDefElement.columnDef.index;\n            header1ColumnDefElement.columnDef.index = header2ColumnDefElement.columnDef.index;\n            header2ColumnDefElement.columnDef.index = tempColumnIndex;\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Rearrange the column headers if the position parameter is outside the bounds of the original header element.\n     *\n     * @param {HTMLElement} element - the header element\n     * @param {Number} positionX - The X position to check for position of drag\n     *\n     * @returns {Boolean} if the columns were rearranged\n     */\n    var rearrangeColumnHeaders = function( element, positionX ) {\n        var elementBoundingBox = element.getBoundingClientRect();\n        var nextSibling = element.nextSibling;\n        var previousSibling = element.previousSibling;\n\n        if( nextSibling && positionX > elementBoundingBox.right + nextSibling.getBoundingClientRect().width / 3 && nextSibling.classList.contains( Const.CLASS_HEADER_DRAGGABLE ) &&\n            switchColumnDefIndexes( nextSibling, element ) ) {\n            element.parentNode.insertBefore( nextSibling, element );\n            return true;\n        } else if( previousSibling && positionX < elementBoundingBox.left - previousSibling.getBoundingClientRect().width / 2 && previousSibling.classList.contains( Const\n            .CLASS_HEADER_DRAGGABLE ) && switchColumnDefIndexes( previousSibling, element ) ) {\n            element.parentNode.insertBefore( element, previousSibling );\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Rearrange the content cells based on the columnDef indexes now.\n     * @param {Number} originalPosition - The original index of the column\n     * @param {Object} columnDef - the column definition\n     */\n    var rearrangeContent = function( originalPosition, columnDef ) {\n        if( originalPosition === columnDef.index ) {\n            return;\n        }\n        var targetIndex = originalPosition < columnDef.index ? -1 : 1;\n        var targetContentElements = util.getColumnContentCellElementsByIndex( tableElem, columnDef.index + targetIndex );\n        var draggedContentElements = util.getColumnContentCellElementsByIndex( tableElem, columnDef.index );\n\n        for( var i = 0; i < draggedContentElements.length; i++ ) {\n            var currentContentElement = draggedContentElements[ i ];\n            var currentTargetContentElement = targetContentElements[ i ];\n            if( originalPosition < columnDef.index ) {\n                currentTargetContentElement = currentTargetContentElement.nextSibling;\n            }\n            currentContentElement.parentNode.insertBefore( currentContentElement, currentTargetContentElement );\n        }\n    };\n\n    /**\n     * Attaches the drag header events to the header element paramter.\n     *\n     * @param {DOMElement} element - header element to attach drag events\n     */\n    var attachDragHeader = function( element ) {\n        var nextX = 0;\n        var currentX = 0;\n        var clonedElement;\n        var columnDef;\n        var originalPosition;\n        element.classList.add( Const.CLASS_HEADER_DRAGGABLE );\n        var columnDefElement = element.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n\n        var startDragElement = function( customEvent ) {\n            // Clean up menu if exist\n            var menuService = util.getTableMenuService( tableElem );\n            menuService.ensureAllTableMenusDismissed();\n\n            var event = customEvent ? customEvent.detail : window.event;\n\n            clonedElement = element.cloneNode( true );\n            clonedElement.classList.add( Const.CLASS_UTILITY_HIDDEN );\n\n            clonedElement.setAttribute( 'id', clonedElement.id + 'ClonedHeader' );\n            // Attachment to container because of rendering problems when attached to the row\n            var elementContainer = util.closestElement( element, '.' + Const.CLASS_PIN_CONTAINER + ',.' + Const.CLASS_SCROLL_CONTAINER );\n            var scrollLeft = elementContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ].scrollLeft;\n            elementContainer.appendChild( clonedElement );\n\n            clonedElement.style.left = element.offsetLeft - scrollLeft + 'px';\n            clonedElement.style.top = element.offsetTop + 'px';\n\n            currentX = event.clientX;\n\n            if( columnDefElement && columnDefElement.columnDef ) {\n                columnDef = columnDefElement.columnDef;\n                originalPosition = columnDef.index;\n            }\n        };\n\n        /**\n         *  Event to run when movement of header is in progress. Moves the element and any headers it moves over.\n         *\n         * @param {DOMEvent} customEvent - event being sent ( wrapped from 'mousemove' )\n         */\n        var dragElement = function( customEvent ) {\n            var event = customEvent ? customEvent.detail : window.event;\n\n            if( !_columnRearrangementInProgress ) {\n                element.classList.add( 'stationaryHeader' );\n                clonedElement.classList.add( 'dragHeader' );\n                clonedElement.classList.remove( Const.CLASS_UTILITY_HIDDEN );\n                _columnRearrangementInProgress = true;\n            }\n\n            nextX = currentX - event.clientX;\n            currentX = event.clientX;\n\n            clonedElement.style.left = clonedElement.offsetLeft - nextX + 'px';\n\n            _columnsRearranged = rearrangeColumnHeaders( element, event.clientX ) || _columnsRearranged;\n        };\n\n        /**\n         * End the drag movement and replace the original header element visibility.\n         *\n         */\n        var closeDragElement = function() {\n            element.classList.remove( 'stationaryHeader' );\n            clonedElement.parentNode.removeChild( clonedElement );\n            _columnRearrangementInProgress = false;\n\n            if( _columnsRearranged ) {\n                _columnsRearranged = false;\n                var eventData = {\n                    name: columnDef.name,\n                    originalPosition: originalPosition\n                };\n                tableElem._tableInstance.tableInstanceCallbacks.columnsRearranged( eventData );\n                rearrangeContent( originalPosition, columnDef );\n            }\n        };\n\n        // Column Header = Label + Sort Icon + Splitter\n        // Sort Icon will occupy all spaces by flex-grow\n        var contentsElement = element.getElementsByClassName( Const.CLASS_CELL_CONTENTS )[ 0 ];\n        splmTableDragHandler.enableDragging( contentsElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG_START, startDragElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG, dragElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG_END, closeDragElement );\n    };\n\n    /**\n     * Initializes the table with header column rearrangement by dragging.\n     */\n    self.initialize = function() {\n        var headerCellElements = tableElem.getElementsByClassName( Const.CLASS_HEADER_CELL );\n\n        _.forEach( headerCellElements, function( headerCellElement ) {\n            var columnDefinition;\n            var foundElements = headerCellElement.getElementsByClassName( Const.CLASS_COLUMN_DEF );\n            if( foundElements.length > 0 ) {\n                columnDefinition = foundElements[ 0 ].columnDef;\n            }\n\n            if( columnDefinition && columnDefinition.enableColumnMoving !== false ) {\n                attachDragHeader( headerCellElement );\n            }\n        } );\n    };\n\n    self.initialize();\n\n    return self;\n};\n\nexport default SPLMTableColumnRearrangement;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}