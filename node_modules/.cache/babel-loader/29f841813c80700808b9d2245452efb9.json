{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSearchSublocationService\n */\nimport _ from 'lodash';\nimport searchFilterService from 'js/aw.searchFilter.service';\nimport filterPanelUtils from 'js/filterPanelUtils';\nimport appCtxService from 'js/appCtxService';\nimport AwStateService from 'js/awStateService';\nimport localeService from 'js/localeService';\nimport searchStateHelperService from 'js/searchStateHelperService';\nimport { tabCallbackApi } from 'js/awSearchLocationService';\nimport selectionService from 'js/selection.service';\nimport Debug from 'debug';\nconst trace = new Debug('selection');\nexport const updateSearchContext = provider => {\n  // Set the sort criteria for sublocation if its not already populated in ctx.ClientScopeURI.sortCriteria\n  // This sort criteria will be shared across all views in a sublocation in a given session.\n  var sortCriteria = appCtxService.getCtx(provider.clientScopeURI + '.sortCriteria');\n\n  if (sortCriteria === undefined || sortCriteria === '') {\n    appCtxService.updatePartialCtx(provider.clientScopeURI + '.sortCriteria', []);\n    appCtxService.updatePartialCtx('sublocation.sortCriteria', []);\n  } else {\n    appCtxService.updatePartialCtx('sublocation.sortCriteria', sortCriteria);\n  }\n};\n/**\n * This API would re-create the VMO's from the URL on Mount of subLocation.\n * @param {*} searchString\n * @param {*} totalFound\n * @param {*} provider\n */\n\nexport const createStateFromUrl = (provider, searchStateProp, searchState, searchStateUpdater, skipURL, searchCriteria, pwaSelectionModel) => {\n  if (skipURL) {\n    return;\n  }\n\n  const [defaultSearchStateData, updateAtomicData] = getSearchState(searchStateProp, searchState, searchStateUpdater);\n  const stateProvider = AwStateService.instance;\n  const changedParams = stateProvider.params;\n  const searchContext = provider.context && provider.context.search ? provider.context.search : {};\n  const providerSelectionQueryParamKey = provider.selectionQueryParamKey ? provider.selectionQueryParamKey : 's_uid';\n  let selectionQueryParamValue;\n  let selectionQueryParamKey;\n  let searchString = '';\n  let filterStringFromUrl = '';\n\n  if (changedParams.hasOwnProperty('searchCriteria')) {\n    searchString = changedParams.searchCriteria ? changedParams.searchCriteria : searchString;\n  }\n\n  if (changedParams.hasOwnProperty('filter')) {\n    filterStringFromUrl = changedParams.filter ? changedParams.filter : filterStringFromUrl;\n  }\n\n  if (changedParams.hasOwnProperty(providerSelectionQueryParamKey)) {\n    selectionQueryParamValue = changedParams[providerSelectionQueryParamKey];\n    selectionQueryParamKey = providerSelectionQueryParamKey;\n  }\n\n  const bcLabel = stateProvider.current.data && stateProvider.current.data.label ? stateProvider.current.data.label : '';\n  let updatedSearchContext = searchStateHelperService.constructBaseSearchCriteria(searchContext, changedParams);\n  const searchStateData = { ...updatedSearchContext\n  };\n  const chartTitle = searchContext.chartTitle; // Need to evaluate from props.chartTitle i18n\n\n  let promise = chartTitle ? localeService.getLocalizedText(chartTitle.source, chartTitle.key) : new Promise(resolve => resolve());\n  let searchStr = searchStateData.criteria && searchStateData.criteria.hasOwnProperty('searchString') && searchStateData.criteria.searchString.length > 0 ? searchStateData.criteria.searchString : searchString;\n  return promise.then(chartTitleValue => {\n    const {\n      activeFilterMap\n    } = createSearchFilterMapFromUrl(provider);\n    const activeFilters = searchFilterService.getFilters();\n    searchStateData.criteria = Object.assign({}, searchStateData.criteria, searchCriteria);\n    searchStateData.criteria.searchString = searchStr;\n    let resolvedData = {\n      searchStringPrimary: searchStr,\n      searchStringSecondary: '',\n      label: bcLabel,\n      filterString: filterStringFromUrl,\n      totalFound: searchContext.showLoadingText ? undefined : 0,\n      loadDataAction: searchContext.loadDataAction,\n      provider: searchContext.provider,\n      sortType: searchContext.sortType,\n      chartTitle: chartTitleValue,\n      objectsGroupedByProperty: null,\n      activeFilters: activeFilters,\n      activeFilterMap: activeFilterMap,\n      searchInProgress: searchStr && searchStr.length > 0 || filterStringFromUrl && filterStringFromUrl.length > 0,\n      searchFilterMap: {},\n      selectionQueryParam: {\n        key: selectionQueryParamKey,\n        value: selectionQueryParamValue\n      }\n    };\n    Object.assign(searchStateData, resolvedData);\n\n    if (updateAtomicData) {\n      updateAtomicData(searchStateData);\n    } else {\n      defaultSearchStateData.update(searchStateData);\n    }\n\n    updateSearchPWASelectionModel(pwaSelectionModel, resolvedData.selectionQueryParam);\n  });\n};\nexport const createSearchFilterMapFromUrl = provider => {\n  let searchContext = searchFilterService.buildSearchFilters(provider.context);\n  return {\n    activeFilterMap: searchContext.activeFilterMap\n  };\n};\nexport const getSearchFilterStringFromActiveFilterMap = activeFilters => {\n  let searchFilterMap = {};\n\n  if (activeFilters && activeFilters.length > 0) {\n    for (let index = 0; index < activeFilters.length; index++) {\n      let eachActiveFilterCategory = activeFilters[index];\n      searchFilterMap[eachActiveFilterCategory.name] = eachActiveFilterCategory.values;\n    }\n  }\n\n  return searchFilterService.buildFilterString(searchFilterMap);\n};\nexport const getActiveFilters = searchFilterCategories => {\n  const allSelectedFilters = searchFilterCategories.map(category => {\n    if (category && category.filterValues && category.filterValues.length > 0) {\n      return category.filterValues.filter(filterObject => {\n        return filterObject.selected.value;\n      });\n    }\n\n    return [];\n  });\n  return _.flatten(allSelectedFilters);\n};\nexport const lazyUpdate = (searchState, updateAtomicData) => {\n  // update URL if there are selection in filter panel\n  if (searchState && searchState.activeFilters) {\n    let searchCriteria = AwStateService.instance.params.searchCriteria;\n    const filterString = searchFilterService.buildFilterString(searchState.activeFilters);\n\n    if (searchState.filterString !== filterString && (searchState.autoApplyFilters || searchState.bulkFiltersApplied)) {\n      const selectedFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState(searchState.activeFilters);\n      let updatedCriteria = searchStateHelperService.getCriteriaAfterFilterSelection(searchState);\n      let forceChart = searchStateHelperService.getForceChartParameterValue(searchState);\n      searchFilterService.doSearch(null, updatedCriteria ? updatedCriteria.searchString : null, searchState.activeFilters);\n\n      if (updateAtomicData) {\n        updateAtomicData({ ...searchState,\n          criteria: updatedCriteria,\n          forceChart: forceChart,\n          filterString: filterString,\n          activeFilterMap: selectedFiltersInfo.activeFilterMap,\n          searchInProgress: true,\n          categories: undefined,\n          additionalSearchString: undefined\n        });\n      } else {\n        let newSearchState = { ...searchState.value\n        };\n        newSearchState.criteria = updatedCriteria;\n        newSearchState.forceChart = forceChart;\n        newSearchState.filterString = filterString;\n        newSearchState.activeFilterMap = selectedFiltersInfo.activeFilterMap;\n        newSearchState.searchInProgress = true;\n        newSearchState.categories = undefined;\n        newSearchState.additionalSearchString = undefined;\n        searchState.update(newSearchState);\n      }\n    } else if (filterString !== searchState.selectedFiltersString && !searchState.autoApplyFilters && !searchState.bulkFiltersApplied) {\n      searchState.selectedFiltersString = filterString;\n      const pendingFilterMapInfo = searchFilterService.getPendingFiltersMap(searchState.activeFilters, searchState.activeFilterMap);\n      const positivePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState(pendingFilterMapInfo.positivePendingFilterMap);\n      const negativePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState(pendingFilterMapInfo.negativePendingFilterMap);\n\n      if (updateAtomicData) {\n        updateAtomicData({ ...searchState,\n          positivePendingFilters: positivePendingFiltersInfo.activeFilters,\n          negativePendingFilters: negativePendingFiltersInfo.activeFilters,\n          positivePendingFilterMap: positivePendingFiltersInfo.activeFilterMap,\n          negativePendingFilterMap: negativePendingFiltersInfo.activeFilterMap\n        });\n      } else {\n        let newSearchState = { ...searchState.value\n        };\n        newSearchState.positivePendingFilters = positivePendingFiltersInfo.activeFilters;\n        newSearchState.negativePendingFilters = negativePendingFiltersInfo.activeFilters;\n        newSearchState.positivePendingFilterMap = positivePendingFiltersInfo.activeFilterMap;\n        newSearchState.negativePendingFilterMap = negativePendingFiltersInfo.activeFilterMap;\n        searchState.update(newSearchState);\n      }\n    } else if (searchCriteria && searchState.criteria && searchState.criteria.searchString !== searchCriteria) {\n      searchFilterService.doSearch(null, searchState.criteria.searchString, searchState.activeFilters);\n\n      if (updateAtomicData) {\n        updateAtomicData({ ...searchState,\n          categories: undefined\n        });\n      } else {\n        let newSearchState = { ...searchState.value\n        };\n        newSearchState.categories = undefined;\n        searchState.update(newSearchState);\n      }\n    }\n  } else if (AwStateService.instance.params.filter) {\n    //Or no change in filter panel but prefilter is changed\n    if (searchState.filterString !== AwStateService.instance.params.filter) {\n      if (updateAtomicData) {\n        updateAtomicData({ ...searchState,\n          filterString: AwStateService.instance.params.filter\n        });\n      } else {\n        let newSearchState = { ...searchState.value\n        };\n        newSearchState.filterString = AwStateService.instance.params.filter;\n        searchState.update(newSearchState);\n      }\n    }\n  }\n};\n\nlet debounceUpdateURL = _.debounce((searchState, updateAtomicData) => {\n  lazyUpdate(searchState, updateAtomicData);\n}, 800);\n\nexport const updateURL = (searchStateProp, searchState, searchStateUpdater, skipURL) => {\n  if (skipURL) {\n    return;\n  }\n\n  const [searchStateData, updateAtomicData] = getSearchState(searchStateProp, searchState, searchStateUpdater);\n  debounceUpdateURL(searchStateData, updateAtomicData);\n};\nexport const updateSearchCriteria = (searchStateAtomicDataRef, searchStateUpdater, searchCriteria) => {\n  let searchState = searchStateAtomicDataRef.getAtomicData();\n  const criteria = Object.assign({}, searchState.criteria, searchCriteria);\n  searchStateUpdater.searchState({ ...searchState,\n    criteria\n  });\n};\n\nconst getSearchState = (searchStateProp, searchState, searchStateUpdater) => {\n  const searchStateData = searchStateProp ? searchStateProp : searchState;\n\n  if (searchStateProp && searchStateProp.update) {\n    return [searchStateData, undefined];\n  }\n\n  return [searchStateData, searchStateUpdater.searchState];\n};\n\nexport const syncStateFromUrl = (searchStateProp, searchStateData, searchStateUpdater) => {\n  const [searchState, updateAtomicData] = getSearchState(searchStateProp, searchStateData, searchStateUpdater);\n  const stateProvider = AwStateService.instance;\n  const changedParams = stateProvider.params;\n  let urlSearchString = null;\n  let urlFilterString = '';\n\n  if (changedParams.hasOwnProperty('searchCriteria')) {\n    urlSearchString = changedParams.searchCriteria;\n  }\n\n  if (changedParams.hasOwnProperty('filter')) {\n    urlFilterString = changedParams.filter ? changedParams.filter : urlFilterString;\n  }\n\n  if (urlSearchString && searchState && searchState.criteria && searchState.criteria.searchString !== urlSearchString || urlFilterString !== searchState.filterString) {\n    const prefilterMap = searchFilterService.getFilterMapWithPrefilters();\n    const activeFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState(prefilterMap);\n    let newSearchCriteria = {\n      criteria: searchStateHelperService.getCriteriaForNewSearch(searchState, urlSearchString),\n      searchStringPrimary: urlSearchString,\n      searchStringSecondary: '',\n      activeFilters: prefilterMap,\n      activeFilterMap: activeFiltersInfo.activeFilterMap,\n      categories: [],\n      filterString: urlFilterString,\n      searchFilterCategories: [],\n      categoriesExpandCollapseMap: undefined,\n      allCategoriesVisible: undefined,\n      searchInProgress: true,\n      totalFound: searchState.showLoadingText ? undefined : 0,\n      forceChart: searchStateHelperService.getForceChartParameterValue(searchState)\n    };\n    newSearchCriteria.criteriaJSONString = JSON.stringify(newSearchCriteria.criteria);\n\n    if (updateAtomicData) {\n      updateAtomicData({ ...searchState,\n        ...newSearchCriteria\n      });\n    } else {\n      let newSearchState = { ...searchState.value\n      };\n      Object.assign(newSearchState, newSearchCriteria);\n      searchState.update(newSearchState);\n    }\n  }\n};\nexport const getSelectedFiltersMap = categories => {\n  var searchFilterMap = {};\n\n  for (const [key, value] of Object.entries(categories)) {\n    if (value) {\n      let filtersForCurrentCategory = [];\n\n      if (value.filterValues && value.filterValues.length > 0) {\n        value.filterValues.forEach(val => {\n          if (val.selected.dbValue) {\n            switch (value.type) {\n              case 'NumericFilter':\n                {\n                  let numericValue = filterPanelUtils.INTERNAL_NUMERIC_FILTER + val.internalName;\n                  filtersForCurrentCategory.push(numericValue);\n                  break;\n                }\n\n              case 'DateFilter':\n                {\n                  let selectedDateFilters = searchFilterMap[val.categoryName] ? searchFilterMap[val.categoryName] : [];\n                  selectedDateFilters.push(val.internalName);\n                  searchFilterMap[val.categoryName] = selectedDateFilters;\n                  break;\n                }\n\n              default:\n                filtersForCurrentCategory.push(val.internalName);\n                break;\n            }\n          }\n        });\n      }\n\n      if (value.numericRangeString) {\n        filtersForCurrentCategory.push(value.numericRangeString);\n      }\n\n      if (value.dateRangeString) {\n        filtersForCurrentCategory.push(value.dateRangeString);\n      }\n\n      if (filtersForCurrentCategory.length) {\n        searchFilterMap[value.internalName] = filtersForCurrentCategory;\n      }\n    }\n  }\n\n  return searchFilterService.removeDependentDateFilters(searchFilterMap);\n};\n/**\n * update pwa selection model with selection query param value\n * @param {*} selectionModel selection model\n * @param {*} selectionQueryParam selection query param object with key, value\n */\n\nexport const updateSearchPWASelectionModel = (selectionModel, selectionQueryParam) => {\n  const pwaSelection = selectionModel.getSelection();\n\n  if (!pwaSelection.length && selectionQueryParam && selectionQueryParam.value) {\n    selectionModel.setSelection([selectionQueryParam.value]);\n  }\n};\nexport const getActiveSublocationTab = sublocationsTabs => {\n  let activeSublocTab = '';\n\n  if (sublocationsTabs && sublocationsTabs.length > 0) {\n    let activeSublocTabObj = sublocationsTabs.filter(tab => {\n      return tab.selectedTab;\n    })[0];\n    activeSublocTab = activeSublocTabObj.id || activeSublocTabObj.tabKey || activeSublocTabObj.name;\n  }\n\n  return activeSublocTab;\n};\n/**\n    * update charts data on selection change\n    * @param {*} searchStateProp search state from parent\n    * @param {*} searchState search state from view model data\n    * @param {*} searchStateUpdater search state updater\n*/\n\nexport const updateChartsDataOnSelectionChange = (searchStateProp, searchState, searchStateUpdater) => {\n  const [searchStateData, updateSearchState] = getSearchState(searchStateProp, searchState, searchStateUpdater);\n\n  if (searchStateData && searchStateData.pwaSelection) {\n    const selectedObjects = searchStateData.pwaSelection;\n    const forceChart = !selectedObjects || selectedObjects.length === 0;\n    const recreateChartProvider = forceChart ? 'true' : 'false';\n\n    if (updateSearchState) {\n      updateSearchState({ ...searchStateData,\n        forceChart,\n        recreateChartProvider\n      });\n    } else {\n      let newSearchStateData = { ...searchStateData.value\n      };\n      newSearchStateData.forceChart = forceChart;\n      newSearchStateData.recreateChartProvider = recreateChartProvider;\n      searchStateData.update(newSearchStateData);\n    }\n  }\n};\nexport const updateSublocationTabs = (sublocationsTabs, primarySublocTabState) => {\n  if (sublocationsTabs && primarySublocTabState.dbValue && primarySublocTabState.dbValue.primaryActiveTabId && primarySublocTabState.dbValue.primaryActiveTabId !== '') {\n    tabCallbackApi(undefined, primarySublocTabState.dbValue.primaryActiveTabId, sublocationsTabs);\n  }\n};\nexport const updateGlobalSelection = (localSelectionData, parentSelectionData) => {\n  if (!_.isEmpty(localSelectionData)) {\n    parentSelectionData ? parentSelectionData.update(localSelectionData) : selectionService.updateSelection(localSelectionData.selected, localSelectionData.pselected, localSelectionData.relationInfo);\n    trace('AwSearchSublocationService selectionData: ', localSelectionData);\n  }\n};\nexport const updateSelectionQueryParamInURL = (searchStateProp, searchState) => {\n  const searchStateData = searchStateProp ? searchStateProp : searchState; // update URL if selectionQueryParam applicable\n\n  if (searchStateData.selectionQueryParam && searchStateData.selectionQueryParam.key) {\n    let uid = searchStateData.pwaSelection && searchStateData.pwaSelection.length === 1 ? searchStateData.pwaSelection[0].uid : null;\n    AwStateService.instance.go('.', {\n      [searchStateData.selectionQueryParam.key]: uid\n    });\n  }\n};\nexport const updateSearchStateWithSelectionData = (searchStateProp, searchState, selectionData) => {\n  const searchStateData = searchStateProp ? searchStateProp : searchState;\n\n  if (!_.isEmpty(selectionData)) {\n    let newSearchState = searchStateData ? { ...searchStateData.value\n    } : undefined;\n\n    if (newSearchState) {\n      if (selectionData.source === 'primary') {\n        newSearchState.pwaSelection = selectionData.selected ? selectionData.selected : [];\n      } else if (selectionData.source === 'base' || selectionData.source === undefined) {\n        newSearchState.pwaSelection = [];\n      }\n\n      searchStateData.update(newSearchState);\n    }\n  }\n};\nconst awSearchSublocationService = {\n  updateSearchContext,\n  createStateFromUrl,\n  createSearchFilterMapFromUrl,\n  getSearchFilterStringFromActiveFilterMap,\n  getActiveFilters,\n  lazyUpdate,\n  updateURL,\n  updateSearchCriteria,\n  syncStateFromUrl,\n  getSelectedFiltersMap,\n  updateSearchPWASelectionModel,\n  getActiveSublocationTab,\n  updateChartsDataOnSelectionChange,\n  updateSublocationTabs,\n  updateGlobalSelection,\n  updateSearchStateWithSelectionData,\n  updateSelectionQueryParamInURL\n};\nexport default awSearchSublocationService;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/searchcore/src/js/awSearchSublocationService.js"],"names":["trace","updateSearchContext","provider","sortCriteria","appCtxService","createStateFromUrl","getSearchState","stateProvider","AwStateService","changedParams","searchContext","providerSelectionQueryParamKey","searchString","filterStringFromUrl","selectionQueryParamValue","selectionQueryParamKey","bcLabel","updatedSearchContext","searchStateHelperService","searchStateData","chartTitle","promise","localeService","resolve","searchStr","chartTitleValue","activeFilterMap","createSearchFilterMapFromUrl","activeFilters","searchFilterService","Object","resolvedData","searchStringPrimary","searchStringSecondary","label","filterString","totalFound","loadDataAction","sortType","objectsGroupedByProperty","searchInProgress","searchFilterMap","selectionQueryParam","key","value","updateAtomicData","defaultSearchStateData","updateSearchPWASelectionModel","getSearchFilterStringFromActiveFilterMap","index","eachActiveFilterCategory","getActiveFilters","searchFilterCategories","allSelectedFilters","category","filterObject","_","lazyUpdate","searchState","searchCriteria","selectedFiltersInfo","updatedCriteria","forceChart","criteria","categories","additionalSearchString","undefined","newSearchState","pendingFilterMapInfo","positivePendingFiltersInfo","negativePendingFiltersInfo","positivePendingFilters","negativePendingFilters","positivePendingFilterMap","negativePendingFilterMap","filter","debounceUpdateURL","updateURL","updateSearchCriteria","searchStateAtomicDataRef","searchStateUpdater","searchStateProp","syncStateFromUrl","urlSearchString","urlFilterString","prefilterMap","activeFiltersInfo","newSearchCriteria","categoriesExpandCollapseMap","allCategoriesVisible","JSON","getSelectedFiltersMap","filtersForCurrentCategory","val","numericValue","filterPanelUtils","selectedDateFilters","pwaSelection","selectionModel","getActiveSublocationTab","sublocationsTabs","activeSublocTab","activeSublocTabObj","tab","updateChartsDataOnSelectionChange","selectedObjects","recreateChartProvider","updateSearchState","newSearchStateData","updateSublocationTabs","primarySublocTabState","tabCallbackApi","updateGlobalSelection","parentSelectionData","selectionService","localSelectionData","updateSelectionQueryParamInURL","uid","updateSearchStateWithSelectionData","selectionData","awSearchSublocationService"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSearchSublocationService\n */\nimport _ from 'lodash';\nimport searchFilterService from 'js/aw.searchFilter.service';\nimport filterPanelUtils from 'js/filterPanelUtils';\nimport appCtxService from 'js/appCtxService';\nimport AwStateService from 'js/awStateService';\nimport localeService from 'js/localeService';\nimport searchStateHelperService from 'js/searchStateHelperService';\nimport { tabCallbackApi } from 'js/awSearchLocationService';\nimport selectionService from 'js/selection.service';\nimport Debug from 'debug';\n\nconst trace = new Debug( 'selection' );\n\nexport const updateSearchContext = ( provider ) => {\n    // Set the sort criteria for sublocation if its not already populated in ctx.ClientScopeURI.sortCriteria\n    // This sort criteria will be shared across all views in a sublocation in a given session.\n    var sortCriteria = appCtxService.getCtx( provider.clientScopeURI + '.sortCriteria' );\n    if( sortCriteria === undefined || sortCriteria === '' ) {\n        appCtxService.updatePartialCtx( provider.clientScopeURI + '.sortCriteria', [] );\n        appCtxService.updatePartialCtx( 'sublocation.sortCriteria', [] );\n    } else {\n        appCtxService.updatePartialCtx( 'sublocation.sortCriteria', sortCriteria );\n    }\n};\n\n/**\n * This API would re-create the VMO's from the URL on Mount of subLocation.\n * @param {*} searchString\n * @param {*} totalFound\n * @param {*} provider\n */\nexport const createStateFromUrl = ( provider, searchStateProp, searchState, searchStateUpdater, skipURL, searchCriteria, pwaSelectionModel ) => {\n    if( skipURL ) {\n        return;\n    }\n\n    const [ defaultSearchStateData, updateAtomicData ] = getSearchState( searchStateProp, searchState, searchStateUpdater );\n    const stateProvider = AwStateService.instance;\n    const changedParams = stateProvider.params;\n    const searchContext = provider.context && provider.context.search ? provider.context.search : {};\n    const providerSelectionQueryParamKey = provider.selectionQueryParamKey ? provider.selectionQueryParamKey : 's_uid';\n    let selectionQueryParamValue;\n    let selectionQueryParamKey;\n    let searchString = '';\n    let filterStringFromUrl = '';\n    if( changedParams.hasOwnProperty( 'searchCriteria' ) ) {\n        searchString = changedParams.searchCriteria ? changedParams.searchCriteria : searchString;\n    }\n    if( changedParams.hasOwnProperty( 'filter' ) ) {\n        filterStringFromUrl = changedParams.filter ? changedParams.filter : filterStringFromUrl;\n    }\n    if( changedParams.hasOwnProperty( providerSelectionQueryParamKey ) ) {\n        selectionQueryParamValue = changedParams[ providerSelectionQueryParamKey ];\n        selectionQueryParamKey = providerSelectionQueryParamKey;\n    }\n    const bcLabel = stateProvider.current.data && stateProvider.current.data.label ? stateProvider.current.data.label : '';\n    let updatedSearchContext = searchStateHelperService.constructBaseSearchCriteria( searchContext, changedParams );\n    const searchStateData = { ...updatedSearchContext };\n    const chartTitle = searchContext.chartTitle; // Need to evaluate from props.chartTitle i18n\n    let promise = chartTitle ? localeService.getLocalizedText( chartTitle.source, chartTitle.key ) : new Promise( ( resolve ) => resolve() );\n    let searchStr = searchStateData.criteria && searchStateData.criteria.hasOwnProperty( 'searchString' ) &&\n        searchStateData.criteria.searchString.length > 0 ? searchStateData.criteria.searchString : searchString;\n    return promise.then( ( chartTitleValue ) => {\n        const { activeFilterMap } = createSearchFilterMapFromUrl( provider );\n        const activeFilters = searchFilterService.getFilters();\n        searchStateData.criteria = Object.assign( {}, searchStateData.criteria, searchCriteria );\n        searchStateData.criteria.searchString = searchStr;\n        let resolvedData = {\n            searchStringPrimary: searchStr,\n            searchStringSecondary: '',\n            label: bcLabel,\n            filterString: filterStringFromUrl,\n            totalFound: searchContext.showLoadingText ? undefined : 0,\n            loadDataAction: searchContext.loadDataAction,\n            provider: searchContext.provider,\n            sortType: searchContext.sortType,\n            chartTitle: chartTitleValue,\n            objectsGroupedByProperty: null,\n            activeFilters: activeFilters,\n            activeFilterMap: activeFilterMap,\n            searchInProgress: searchStr && searchStr.length > 0 || filterStringFromUrl && filterStringFromUrl.length > 0,\n            searchFilterMap: {},\n            selectionQueryParam: {\n                key: selectionQueryParamKey,\n                value: selectionQueryParamValue\n            }\n        };\n        Object.assign( searchStateData, resolvedData );\n        if( updateAtomicData ) {\n            updateAtomicData( searchStateData );\n        } else {\n            defaultSearchStateData.update( searchStateData );\n        }\n        updateSearchPWASelectionModel( pwaSelectionModel, resolvedData.selectionQueryParam );\n    } );\n};\n\nexport const createSearchFilterMapFromUrl = ( provider ) => {\n    let searchContext = searchFilterService.buildSearchFilters( provider.context );\n    return {\n        activeFilterMap: searchContext.activeFilterMap\n    };\n};\n\nexport const getSearchFilterStringFromActiveFilterMap = ( activeFilters ) => {\n    let searchFilterMap = {};\n    if( activeFilters && activeFilters.length > 0 ) {\n        for( let index = 0; index < activeFilters.length; index++ ) {\n            let eachActiveFilterCategory = activeFilters[ index ];\n            searchFilterMap[ eachActiveFilterCategory.name ] = eachActiveFilterCategory.values;\n        }\n    }\n    return searchFilterService.buildFilterString( searchFilterMap );\n};\n\nexport const getActiveFilters = ( searchFilterCategories ) => {\n    const allSelectedFilters = searchFilterCategories.map( ( category ) => {\n        if( category && category.filterValues && category.filterValues.length > 0 ) {\n            return category.filterValues.filter( ( filterObject ) => {\n                return filterObject.selected.value;\n            } );\n        }\n        return [];\n    } );\n    return _.flatten( allSelectedFilters );\n};\n\nexport const lazyUpdate = ( searchState, updateAtomicData ) => {\n    // update URL if there are selection in filter panel\n    if( searchState && searchState.activeFilters ) {\n        let searchCriteria = AwStateService.instance.params.searchCriteria;\n        const filterString = searchFilterService.buildFilterString( searchState.activeFilters );\n        if( searchState.filterString !== filterString && ( searchState.autoApplyFilters || searchState.bulkFiltersApplied ) ) {\n            const selectedFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( searchState.activeFilters );\n            let updatedCriteria = searchStateHelperService.getCriteriaAfterFilterSelection( searchState );\n            let forceChart = searchStateHelperService.getForceChartParameterValue( searchState );\n            searchFilterService.doSearch( null, updatedCriteria ? updatedCriteria.searchString : null, searchState.activeFilters );\n            if( updateAtomicData ) {\n                updateAtomicData( {\n                    ...searchState,\n                    criteria: updatedCriteria,\n                    forceChart: forceChart,\n                    filterString: filterString,\n                    activeFilterMap: selectedFiltersInfo.activeFilterMap,\n                    searchInProgress: true,\n                    categories: undefined,\n                    additionalSearchString: undefined\n                } );\n            } else {\n                let newSearchState = { ...searchState.value };\n                newSearchState.criteria = updatedCriteria;\n                newSearchState.forceChart = forceChart;\n                newSearchState.filterString = filterString;\n                newSearchState.activeFilterMap = selectedFiltersInfo.activeFilterMap;\n                newSearchState.searchInProgress = true;\n                newSearchState.categories = undefined;\n                newSearchState.additionalSearchString = undefined;\n                searchState.update( newSearchState );\n            }\n        } else if( filterString !== searchState.selectedFiltersString && !searchState.autoApplyFilters && !searchState.bulkFiltersApplied ) {\n            searchState.selectedFiltersString = filterString;\n            const pendingFilterMapInfo = searchFilterService.getPendingFiltersMap( searchState.activeFilters, searchState.activeFilterMap );\n            const positivePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( pendingFilterMapInfo.positivePendingFilterMap );\n            const negativePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( pendingFilterMapInfo.negativePendingFilterMap );\n            if( updateAtomicData ) {\n                updateAtomicData( {\n                    ...searchState,\n                    positivePendingFilters: positivePendingFiltersInfo.activeFilters,\n                    negativePendingFilters: negativePendingFiltersInfo.activeFilters,\n                    positivePendingFilterMap: positivePendingFiltersInfo.activeFilterMap,\n                    negativePendingFilterMap: negativePendingFiltersInfo.activeFilterMap\n                } );\n            } else {\n                let newSearchState = { ...searchState.value };\n                newSearchState.positivePendingFilters = positivePendingFiltersInfo.activeFilters;\n                newSearchState.negativePendingFilters = negativePendingFiltersInfo.activeFilters;\n                newSearchState.positivePendingFilterMap = positivePendingFiltersInfo.activeFilterMap;\n                newSearchState.negativePendingFilterMap = negativePendingFiltersInfo.activeFilterMap;\n                searchState.update( newSearchState );\n            }\n        } else if( searchCriteria && searchState.criteria && searchState.criteria.searchString !== searchCriteria ) {\n            searchFilterService.doSearch( null, searchState.criteria.searchString, searchState.activeFilters );\n            if( updateAtomicData ) {\n                updateAtomicData( { ...searchState, categories: undefined } );\n            } else {\n                let newSearchState = { ...searchState.value };\n                newSearchState.categories = undefined;\n                searchState.update( newSearchState );\n            }\n        }\n    } else if( AwStateService.instance.params.filter ) {\n        //Or no change in filter panel but prefilter is changed\n        if( searchState.filterString !== AwStateService.instance.params.filter ) {\n            if( updateAtomicData ) {\n                updateAtomicData( { ...searchState, filterString: AwStateService.instance.params.filter } );\n            } else {\n                let newSearchState = { ...searchState.value };\n                newSearchState.filterString = AwStateService.instance.params.filter;\n                searchState.update( newSearchState );\n            }\n        }\n    }\n};\n\nlet debounceUpdateURL = _.debounce( ( searchState, updateAtomicData ) => {\n    lazyUpdate( searchState, updateAtomicData );\n}, 800 );\n\nexport const updateURL = ( searchStateProp, searchState, searchStateUpdater, skipURL ) => {\n    if( skipURL ) {\n        return;\n    }\n    const [ searchStateData, updateAtomicData ] = getSearchState( searchStateProp, searchState, searchStateUpdater );\n    debounceUpdateURL( searchStateData, updateAtomicData );\n};\n\nexport const updateSearchCriteria = ( searchStateAtomicDataRef, searchStateUpdater, searchCriteria ) => {\n    let searchState = searchStateAtomicDataRef.getAtomicData();\n    const criteria = Object.assign( {}, searchState.criteria, searchCriteria );\n    searchStateUpdater.searchState( { ...searchState, criteria } );\n};\n\nconst getSearchState = ( searchStateProp, searchState, searchStateUpdater ) => {\n    const searchStateData = searchStateProp ? searchStateProp : searchState;\n    if( searchStateProp && searchStateProp.update ) {\n        return [ searchStateData, undefined ];\n    }\n    return [ searchStateData, searchStateUpdater.searchState ];\n};\n\nexport const syncStateFromUrl = ( searchStateProp, searchStateData, searchStateUpdater ) => {\n    const [ searchState, updateAtomicData ] = getSearchState( searchStateProp, searchStateData, searchStateUpdater );\n    const stateProvider = AwStateService.instance;\n    const changedParams = stateProvider.params;\n    let urlSearchString = null;\n    let urlFilterString = '';\n    if( changedParams.hasOwnProperty( 'searchCriteria' ) ) {\n        urlSearchString = changedParams.searchCriteria;\n    }\n    if( changedParams.hasOwnProperty( 'filter' ) ) {\n        urlFilterString = changedParams.filter ? changedParams.filter : urlFilterString;\n    }\n    if( urlSearchString && searchState && searchState.criteria && searchState.criteria.searchString !== urlSearchString || urlFilterString !==\n        searchState.filterString ) {\n        const prefilterMap = searchFilterService.getFilterMapWithPrefilters();\n        const activeFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( prefilterMap );\n        let newSearchCriteria = {\n            criteria: searchStateHelperService.getCriteriaForNewSearch( searchState, urlSearchString ),\n            searchStringPrimary: urlSearchString,\n            searchStringSecondary: '',\n            activeFilters: prefilterMap,\n            activeFilterMap: activeFiltersInfo.activeFilterMap,\n            categories: [],\n            filterString: urlFilterString,\n            searchFilterCategories: [],\n            categoriesExpandCollapseMap: undefined,\n            allCategoriesVisible: undefined,\n            searchInProgress: true,\n            totalFound: searchState.showLoadingText ? undefined : 0,\n            forceChart: searchStateHelperService.getForceChartParameterValue( searchState )\n        };\n        newSearchCriteria.criteriaJSONString  = JSON.stringify( newSearchCriteria.criteria );\n        if( updateAtomicData ) {\n            updateAtomicData( { ...searchState, ...newSearchCriteria } );\n        } else {\n            let newSearchState = { ...searchState.value };\n            Object.assign( newSearchState, newSearchCriteria );\n            searchState.update( newSearchState );\n        }\n    }\n};\n\nexport const getSelectedFiltersMap = ( categories ) => {\n    var searchFilterMap = {};\n    for( const [ key, value ] of Object.entries( categories ) ) {\n        if( value ) {\n            let filtersForCurrentCategory = [];\n            if( value.filterValues && value.filterValues.length > 0 ) {\n                value.filterValues.forEach( ( val ) => {\n                    if( val.selected.dbValue ) {\n                        switch ( value.type ) {\n                            case 'NumericFilter': {\n                                let numericValue = filterPanelUtils.INTERNAL_NUMERIC_FILTER + val.internalName;\n                                filtersForCurrentCategory.push( numericValue );\n                                break;\n                            }\n                            case 'DateFilter': {\n                                let selectedDateFilters = searchFilterMap[ val.categoryName ] ? searchFilterMap[ val.categoryName ] : [];\n                                selectedDateFilters.push( val.internalName );\n                                searchFilterMap[ val.categoryName ] = selectedDateFilters;\n                                break;\n                            }\n                            default:\n                                filtersForCurrentCategory.push( val.internalName );\n                                break;\n                        }\n                    }\n                } );\n            }\n            if( value.numericRangeString ) {\n                filtersForCurrentCategory.push( value.numericRangeString );\n            }\n            if( value.dateRangeString ) {\n                filtersForCurrentCategory.push( value.dateRangeString );\n            }\n            if( filtersForCurrentCategory.length ) {\n                searchFilterMap[ value.internalName ] = filtersForCurrentCategory;\n            }\n        }\n    }\n    return searchFilterService.removeDependentDateFilters( searchFilterMap );\n};\n\n/**\n * update pwa selection model with selection query param value\n * @param {*} selectionModel selection model\n * @param {*} selectionQueryParam selection query param object with key, value\n */\nexport const updateSearchPWASelectionModel = ( selectionModel, selectionQueryParam ) => {\n    const pwaSelection = selectionModel.getSelection();\n    if( !pwaSelection.length && selectionQueryParam && selectionQueryParam.value ) {\n        selectionModel.setSelection( [ selectionQueryParam.value ] );\n    }\n};\n\nexport const getActiveSublocationTab = ( sublocationsTabs ) => {\n    let activeSublocTab = '';\n    if( sublocationsTabs && sublocationsTabs.length > 0 ) {\n        let activeSublocTabObj = sublocationsTabs.filter( ( tab ) => {\n            return tab.selectedTab;\n        } )[ 0 ];\n        activeSublocTab = activeSublocTabObj.id || activeSublocTabObj.tabKey || activeSublocTabObj.name;\n    }\n    return activeSublocTab;\n};\n\n/**\n    * update charts data on selection change\n    * @param {*} searchStateProp search state from parent\n    * @param {*} searchState search state from view model data\n    * @param {*} searchStateUpdater search state updater\n*/\nexport const updateChartsDataOnSelectionChange = ( searchStateProp, searchState, searchStateUpdater ) => {\n    const [ searchStateData, updateSearchState ] = getSearchState( searchStateProp, searchState, searchStateUpdater );\n    if( searchStateData && searchStateData.pwaSelection ) {\n        const selectedObjects = searchStateData.pwaSelection;\n        const forceChart = !selectedObjects || selectedObjects.length === 0;\n        const recreateChartProvider = forceChart ? 'true' : 'false';\n        if( updateSearchState ) {\n            updateSearchState( { ...searchStateData, forceChart, recreateChartProvider } );\n        } else {\n            let newSearchStateData = { ...searchStateData.value };\n            newSearchStateData.forceChart = forceChart;\n            newSearchStateData.recreateChartProvider = recreateChartProvider;\n            searchStateData.update( newSearchStateData );\n        }\n    }\n};\n\nexport const updateSublocationTabs = ( sublocationsTabs, primarySublocTabState ) => {\n    if( sublocationsTabs && primarySublocTabState.dbValue && primarySublocTabState.dbValue.primaryActiveTabId && primarySublocTabState.dbValue.primaryActiveTabId !== '' ) {\n        tabCallbackApi( undefined, primarySublocTabState.dbValue.primaryActiveTabId, sublocationsTabs );\n    }\n};\n\nexport const updateGlobalSelection = ( localSelectionData, parentSelectionData ) => {\n    if( !_.isEmpty( localSelectionData ) ) {\n        parentSelectionData ? parentSelectionData.update( localSelectionData ) : selectionService.updateSelection( localSelectionData.selected, localSelectionData.pselected, localSelectionData\n            .relationInfo );\n        trace( 'AwSearchSublocationService selectionData: ', localSelectionData );\n    }\n};\n\nexport const updateSelectionQueryParamInURL = ( searchStateProp, searchState ) => {\n    const searchStateData = searchStateProp ? searchStateProp : searchState;\n    // update URL if selectionQueryParam applicable\n    if( searchStateData.selectionQueryParam && searchStateData.selectionQueryParam.key ) {\n        let uid = searchStateData.pwaSelection && searchStateData.pwaSelection.length === 1 ? searchStateData.pwaSelection[ 0 ].uid : null;\n        AwStateService.instance.go( '.', {\n            [ searchStateData.selectionQueryParam.key ]: uid\n        } );\n    }\n};\n\nexport const updateSearchStateWithSelectionData = ( searchStateProp, searchState, selectionData ) => {\n    const searchStateData = searchStateProp ? searchStateProp : searchState;\n    if( !_.isEmpty( selectionData ) ) {\n        let newSearchState = searchStateData ? { ...searchStateData.value } : undefined;\n        if( newSearchState ) {\n            if( selectionData.source === 'primary' ) {\n                newSearchState.pwaSelection = selectionData.selected ? selectionData.selected : [];\n            } else if( selectionData.source === 'base' || selectionData.source === undefined ) {\n                newSearchState.pwaSelection = [];\n            }\n            searchStateData.update( newSearchState );\n        }\n    }\n};\n\nconst awSearchSublocationService = {\n    updateSearchContext,\n    createStateFromUrl,\n    createSearchFilterMapFromUrl,\n    getSearchFilterStringFromActiveFilterMap,\n    getActiveFilters,\n    lazyUpdate,\n    updateURL,\n    updateSearchCriteria,\n    syncStateFromUrl,\n    getSelectedFiltersMap,\n    updateSearchPWASelectionModel,\n    getActiveSublocationTab,\n    updateChartsDataOnSelectionChange,\n    updateSublocationTabs,\n    updateGlobalSelection,\n    updateSearchStateWithSelectionData,\n    updateSelectionQueryParamInURL\n};\n\nexport default awSearchSublocationService;\n"]},"metadata":{},"sourceType":"module"}