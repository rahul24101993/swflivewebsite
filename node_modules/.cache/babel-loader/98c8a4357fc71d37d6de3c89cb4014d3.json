{"ast":null,"code":"// Copyright (c) 2022 Siemens\n\n/**\n * @module js/utils\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport AwParseService from 'js/awParseService';\nimport workspaceUtils from 'js/workspaceUtils';\n/**\n * Polyfill to match dynamic import result back to ES5 supported module\n *\n * @param {Object} obj - function to evaluate after loading the dependencies.\n * @returns {Object} ES5 module object\n */\n\nexport function interopES6Default(obj) {\n  // for case like appCtxSerivce, for unknown reason, it has __esModule but no default\n  // In the case we will use module itself\n  // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n  // NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion\n  // it makes that we defined the moduleServiceNameToInject at top level for that practice, not class\n  // level.\n  // It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice\n  // the return is inconsistent for requireJS API:\n  // - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }\n  // - class without moduleServiceNameToInject => svcClass\n  // - non class => it doen't matter since module === module.default\n  // webpack and non-webpack mode will be same snce they have the same _interopES6Default\n  //\n  // Long term solution\n  // - stop supporting non-webpack build\n  // - see if we can remove this _interopES6Default when use dynamic import\n  //\n  // Short term solution (aw4.3)\n  // - Document this apperance difference for class service\n  // - it should be a minor minor case in regular practice\n  return obj && obj.__esModule && obj.default && !obj.moduleServiceNameToInject ? obj.default : obj;\n}\n/**\n * Set the \"isToggle\" flag on any commands that have a handler with a \"selectWhen\" condition\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\nfunction updateIsToggleFlag(viewModelJson) {\n  if (viewModelJson.commands) {\n    const cmdId2handlers = {};\n    let handlers = [];\n\n    for (const handler of Object.values(viewModelJson.commandHandlers)) {\n      handlers = cmdId2handlers[handler.id];\n\n      if (!handlers) {\n        handlers = [];\n        cmdId2handlers[handler.id] = handlers;\n      }\n\n      handlers.push(handler);\n    }\n\n    for (const cmdId in viewModelJson.commands) {\n      const command = viewModelJson.commands[cmdId]; // The handlers for the given command\n\n      handlers = cmdId2handlers[cmdId] || []; // If any handler for this command has selectWhen the command is a toggle command\n\n      command.isToggle = !command.isGroup && !command.isShuttle && handlers.reduce(function (acc, handler) {\n        return acc || handler.hasOwnProperty('selectWhen');\n      }, false) || false;\n    }\n  }\n}\n/**\n * @param {Object} objValue - destination object\n * @param {Object} srcValue source object\n * @return {Object|undefined} modified destination object\n */\n\n\nfunction mergeCustomizer(objValue, srcValue) {\n  if (_.isArray(objValue)) {\n    return objValue.concat(srcValue);\n  }\n}\n/**\n * @param {Object} obj1 object 1\n * @param {Object} obj2 object 2\n * @param {Object|null} check - optional checker object\n * @param {Number|null} depth - depth of merge\n * @type {module.exports.merge}\n */\n\n\nconst merge = (obj1, obj2, check, depth) => {\n  if (!depth) {\n    depth = 1;\n  }\n\n  if (_.isNull(obj2)) {// nothing to merge\n  } else if (_.isNull(obj1)) {\n    logger.error('Null object to merge!');\n  } else if (_.isArray(obj1) && _.isArray(obj2)) {\n    for (let element of obj2) {\n      // If there was a 'identity' test for the elements, we might be able to merge objects in the array.\n      if (!obj1.includes(element)) {\n        obj1.push(_.cloneDeep(element));\n      }\n    }\n  } else if (_.isObject(obj1) && _.isObject(obj2)) {\n    if (!check) {\n      _.mergeWith(obj1, obj2, mergeCustomizer);\n    } else {\n      for (const key in obj2) {\n        const field = obj2[key];\n\n        if (obj1.hasOwnProperty(key)) {\n          if (check) {\n            check.path.push(key);\n\n            if (check.uniqueDepth !== undefined && check.uniqueDepth === depth && !check.path.includes('i18n')) {\n              throw new Error('Name conflict in ' + check.file + '.json path=' + check.path.join('.') + ' for module ' + check.moduleName + ' (2nd occurrence)!');\n            }\n          }\n\n          merge(obj1[key], field, check, depth + 1);\n\n          if (check) {\n            check.path.pop();\n          }\n        } else {\n          obj1[key] = _.cloneDeep(field);\n        }\n      }\n    }\n  } else if (_.isArray(obj1) || _.isArray(obj2)) {\n    throw new Error('Invalid array merge!');\n  } else if (_.isObject(obj1) || _.isObject(obj2)) {\n    throw new Error('Invalid object merge!');\n  }\n};\n\nexport const processWorkspaces = (solutionDef, workspacesInfo) => {\n  let workspaceData = {};\n  const workspaceArray = solutionDef.workspaces;\n  let filteredWorkspaceContributions = [];\n\n  if (solutionDef && solutionDef.workspaces) {\n    let filteredWorkspaces = workspacesInfo.filter(function (workspaceInfo) {\n      if (/workspace_contribution.*/.test(workspaceInfo.name)) {\n        filteredWorkspaceContributions.push(workspaceInfo);\n        return false;\n      }\n\n      return true;\n    });\n\n    for (const data of Object.values(filteredWorkspaces)) {\n      const workspace = data.contents;\n\n      if (_.includes(workspaceArray, workspace.workspaceId) || workspace.scope === 'Internal' || workspace.includeInSolutions && workspace.includeInSolutions.includes(solutionDef.solutionId)) {\n        workspaceData[workspace.workspaceId] = workspace;\n      }\n    } //now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData\n\n\n    for (const data of Object.values(filteredWorkspaceContributions)) {\n      const workspace = data.contents;\n\n      if (workspaceData[workspace.workspaceId] !== undefined) {\n        _.mergeWith(workspaceData[workspace.workspaceId], workspace, function customizer(objValue, srcValue) {\n          if (_.isArray(objValue)) {\n            _.each(srcValue, function (item) {\n              if (objValue.indexOf(item) < 0) {\n                objValue.push(item);\n              }\n            });\n\n            return objValue;\n          }\n        });\n      }\n    }\n  }\n\n  return workspaceData;\n};\n/**\n * Add all the configurations from the exclusive kits to the workspaces.\n * @param {object} WorkspacesInfo all workspaces\n * @param {Object} allKitsJson - all kits\n * @param {Object} allStatesJson - all states\n */\n\nexport const processExclusiveKits = (WorkspacesInfo, allKitsJson, allModules2StatesJson) => {\n  for (var workspaceObject of Object.values(WorkspacesInfo)) {\n    workspaceUtils.resolveKitDefinitions(workspaceObject.contents, allKitsJson, allModules2StatesJson);\n  }\n\n  return;\n};\nexport const processJsonImports = function (name, importResArray) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let lazy = arguments.length > 3 ? arguments[3] : undefined;\n  let res = {};\n  let lazyLoadPromises = []; // have to put it here because of clojure\n\n  const reduceJsonContents = (sum, cur) => {\n    const [fullStr, moduleName, file] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n    merge(sum, cur.contents, config.uniqueDepth && {\n      moduleName,\n      file,\n      path: [],\n      uniqueDepth: config.uniqueDepth\n    });\n    return sum;\n  };\n\n  if (lazy) {\n    for (const imp of importResArray) {\n      if (typeof imp.contents.then === 'function') {\n        lazyLoadPromises.push(imp.contents.then(contents => {\n          return {\n            contents: interopES6Default(contents),\n            name: imp.name\n          };\n        }));\n      } else {\n        // require.context in mendix does not support lazy loading\n        // For now wrap the response in promise until we fix rollup-plugin-require-context2\n        lazyLoadPromises.push(new Promise(resolve => {\n          const contents = imp.contents;\n          return resolve({\n            contents: interopES6Default(contents),\n            name: imp.name\n          });\n        }));\n      }\n    }\n  } // revisitme - need to consider \"configuration.format === 'array'\" use case later\n\n\n  if (name === 'commandsViewModel') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      let res = importResArray.reduce(reduceJsonContents, {});\n      updateIsToggleFlag(res);\n      return res;\n    });\n  } else if (name === 'secondaryWorkareaTabs') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      return importResArray.reduce((sum, cur) => {\n        // old schema support\n        if (_.isArray(cur.contents)) {\n          sum.tabs.push(...cur.contents);\n        } else {\n          // new schema support\n          let {\n            tabs,\n            ...rest\n          } = cur.contents;\n          sum.tabs.push(...Object.values(tabs));\n          merge(sum, rest);\n        }\n\n        return sum;\n      }, {\n        tabs: []\n      });\n    });\n  } else if (name === 'layoutSlots' || name === 'navigationURLToken' || name === 'syncStrategy' || name === 'indicators' || name === 'adapters' || name === 'headerContributions' || name === 'saveHandlers') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      res = importResArray.reduce(reduceJsonContents, config.format === 'array' ? [] : {});\n      return res;\n    });\n  } else if (name === 'workspace') {\n    return importResArray;\n  } else if (name === 'states') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents) {\n        for (const stateName in cur.contents) {\n          const state = cur.contents[stateName];\n\n          if (state.type === 'location') {\n            if (!state.hasOwnProperty('abstract')) {\n              state.abstract = true;\n            }\n\n            if (!state.view) {\n              state.view = 'AwDefaultLocation';\n            }\n\n            if (!state.parent) {\n              state.parent = 'root';\n            }\n          } else if (state.type === 'subLocation') {\n            if (!state.view) {\n              state.view = 'AwDefaultSublocation';\n            }\n\n            if (!state.hasOwnProperty('reloadOnSearch')) {\n              state.reloadOnSearch = false;\n            }\n\n            if (!state.parent) {\n              throw new Error(`Sublocation state ${stateName} does not have parent location`);\n            }\n\n            if (!state.hasOwnProperty('url')) {\n              throw new Error(`No url defined for sublocation state ${stateName}`);\n            }\n          } else if (state.type === 'parameter') {\n            if (!state.params) {\n              throw new Error(`Parameter state ${stateName} must have parameters`);\n            } else if (Object.keys(state).length > 2) {\n              throw new Error(`Parameter state ${stateName} should only have type and params`);\n            } // Merging states is handled later\n\n          } else {\n            logger.debug(`No type or unknown type on state ${stateName} cannot validate state`);\n          }\n\n          if (state.params) {\n            for (let param in state.params) {\n              if (!state.params[param]) {\n                state.params[param] = {\n                  type: 'any'\n                };\n              }\n            }\n          } // Temporary hack to support states that have not set type (ex search)\n\n\n          if (state.type !== 'location' && !state.parent && state.controller === 'DefaultLocationCtrl') {\n            logger.warn(`${stateName} is using DefaultLocationCtrl but is not a location`);\n            state.parent = 'root';\n          }\n\n          if (!sum[stateName]) {\n            sum[stateName] = state;\n          } else {\n            if (sum[stateName].type === 'parameter' || state.type === 'parameter') {\n              // If the current state is just parameters merge it into the finalState\n              if (state.type === 'parameter') {\n                _.assign(sum[stateName].params, state.params);\n              } else {\n                // If the final state is currently just parameters and the new state is not merge into the new state\n                _.assign(state.params, sum[stateName].params);\n\n                sum[stateName] = state;\n              }\n            } else {\n              logger.error(`State name conflict with state ${stateName}`);\n            }\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } else if (name === 'aliasRegistry') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents) {\n        for (const iconName in cur.contents) {\n          const aliases = cur.contents[iconName];\n          let icoName = iconName;\n\n          if (aliases.length === 0) {\n            throw new Error(`No aliases provided for type icons declared for [${icoName}]`);\n          } // If not a type alias, then strip the size numbers at the end of the filename.\n\n\n          if (!/^type/.test(icoName)) {\n            icoName = icoName.replace(/[0-9]+$/, '');\n          }\n\n          const token = icoName.substring(0, 4);\n\n          for (const alias of aliases) {\n            const aliasToken = token + alias;\n\n            if (sum[aliasToken]) {\n              throw new Error(`Multiple aliases declared for ${aliasToken} [${icoName} & ${sum[aliasToken]}]`);\n            }\n\n            if (aliasToken === iconName) {\n              throw new Error(`Why map the same name to itself? ${alias}`);\n            }\n\n            sum[aliasToken] = icoName;\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } else if (name === 'typeProperties') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents && cur.contents.typeProperties) {\n        const typeProperties = cur.contents.typeProperties;\n\n        for (const key2 in typeProperties) {\n          const value = typeProperties[key2];\n\n          if (!sum[key2]) {\n            sum[key2] = value;\n          } else {\n            if (sum[key2].displayProperty && value.displayProperty && sum[key2].displayProperty !== value.displayProperty) {\n              logger.error(`TypeProperties displayProperty conflict with type ${key2}`);\n            } else if (value.displayProperty) {\n              sum[key2].displayProperty = value.displayProperty;\n            }\n\n            if (value.additionalProperties) {\n              if (!sum[key2].additionalProperties) {\n                sum[key2].additionalProperties = [];\n              }\n\n              for (const property of value.additionalProperties) {\n                const foundProp = _.find(sum[key2].additionalProperties, o => {\n                  return o.name === property.name;\n                });\n\n                if (!foundProp) {\n                  sum[key2].additionalProperties.push(property);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } // else\n\n\n  res = importResArray.reduce(reduceJsonContents, config.format === 'array' ? [] : {});\n  return res;\n};\nexport const processI10n = (name, imports) => {\n  const i18nAllFiles = {};\n  const MSG_PREFIX = 'processL10n: ';\n  let importResArray = imports.reduce((res, m) => res.concat(_.filter(m.keys(), path => {\n    let localeCode; // get base name\n\n    let fileName = path.split('/').reverse()[0].split('.json')[0];\n\n    if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'i18n_' + fileName.substring(fileName.length - 5);\n    } else if (/_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'i18n_' + fileName.substring(fileName.length - 2);\n    } else {\n      localeCode = 'i18n';\n    }\n\n    return localeCode === name || name !== 'i18n' && localeCode === 'i18n';\n  }).map(path => {\n    if (typeof m(path).then === 'function') {\n      return m(path).then(contents => {\n        return {\n          contents: interopES6Default(contents),\n          name: path\n        };\n      });\n    } // The plugin used in mendix integration does not support lazy m(path) i.e then api is missing\n\n\n    return new Promise(resolve => {\n      const contents = m(path);\n      return resolve({\n        contents: interopES6Default(contents),\n        name: path\n      });\n    });\n  })), []);\n  /**\n   * Add missing entries in the non-English localization with the English values.\n   *\n   * @param {Object} nonEnglish - non-English localization data\n   * @param {Object} english - English localization data\n   */\n\n  function backFillFromEnglish(nonEnglish, english) {\n    for (const bundleName in english) {\n      const bundle = english[bundleName];\n\n      if (!nonEnglish[bundleName]) {\n        nonEnglish[bundleName] = bundle;\n        continue;\n      }\n\n      for (const key in bundle) {\n        const value = bundle[bundleName];\n\n        if (!nonEnglish[bundleName][key]) {\n          nonEnglish[bundleName][key] = value;\n        }\n      }\n    }\n  }\n\n  return Promise.all(importResArray).then(i18nlanguages => {\n    for (const cur of i18nlanguages) {\n      let [fullStr, moduleName, fileName] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n      let localeName;\n\n      if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 5);\n        fileName = fileName.substring(0, fileName.length - 6);\n      } else if (/_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 2);\n        fileName = fileName.substring(0, fileName.length - 3);\n      } else {\n        localeName = 'en_US';\n      }\n\n      if (!i18nAllFiles[localeName]) {\n        i18nAllFiles[localeName] = {};\n      }\n\n      if (cur.contents) {\n        try {\n          i18nAllFiles[localeName][fileName] = cur.contents;\n        } catch (err) {\n          logger.error(`Unable to parse ${cur.name}`);\n          throw err;\n        }\n      }\n    }\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (locale !== 'en_US') {\n        backFillFromEnglish(json, i18nAllFiles.en_US);\n      }\n    }\n    /**\n     * Existing i18n logic: ( for all step below, en_US doesn't have suffix)\n     * - i18n src is defined as:\n     *   adobejsTooltipMessages_zh_CN ->\n     *   {\n     *       \"openInIllustrator\": \"Local test in Chinese\"\n     *   }\n     *\n     * - It will be reassemble as:\n     *   i18n_zh_CN.json ->\n     *   {\n     *       adobejsTooltipMessages: {\n     *           \"openInIllustrator\": \"Local test in Chinese\"\n     *       }\n     *   }\n     *\n     * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',\n     *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'\n     *\n     * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'\n     *\n     * - in the final cfgCache it will looks like:\n     *   {\n     *       actionTemplateDefs,\n     *       ....,\n     *       i18n_zh_CN: {\n     *           adobejsTooltipMessages: {\n     *               \"openInIllustrator\": \"Local test in Chinese\"\n     *           }\n     *       }\n     *   }\n     *\n     * - regarding to installedLocales:\n     *   - it depends on on how man JSON config our customer has in src\n     *   - it depends on war_mySite.json\n     *   We will check it later\n     */\n\n\n    let res;\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (name.endsWith(locale)) {\n        res = json;\n      }\n    } // load english by default\n    // revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will\n    // see how can we handle that later\n\n\n    return res ? res : i18nAllFiles.en_US;\n  });\n};\nexport const processLoginLocales = (name, imports) => {\n  const i18nAllFiles = {};\n  let importResArray = imports.reduce((res, m) => res.concat(_.filter(m.keys(), path => {\n    let localeCode; // get base name\n\n    let fileName = path.split('/').reverse()[0].split('.json')[0];\n\n    if (!fileName.startsWith('LoginLocale')) {\n      return false;\n    }\n\n    if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'LoginLocale_' + fileName.substring(fileName.length - 5);\n    } else if (/_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'LoginLocale_' + fileName.substring(fileName.length - 2);\n    } else {\n      localeCode = 'LoginLocale';\n    }\n\n    return localeCode === name || name !== 'LoginLocale' && localeCode === 'LoginLocale';\n  }).map(path => m(path).then(contents => {\n    return {\n      contents: interopES6Default(contents),\n      name: path\n    };\n  }))), []);\n  /**\n   * Add missing entries in the non-English localization with the English values.\n   *\n   * @param {Object} nonEnglish - non-English localization data\n   * @param {Object} english - English localization data\n   */\n\n  function backFillFromEnglish(nonEnglish, english) {\n    for (const bundleName in english) {\n      const bundle = english[bundleName];\n\n      if (!nonEnglish[bundleName]) {\n        nonEnglish[bundleName] = bundle;\n        continue;\n      }\n\n      for (const key in bundle) {\n        const value = bundle[bundleName];\n\n        if (!nonEnglish[bundleName][key]) {\n          nonEnglish[bundleName][key] = value;\n        }\n      }\n    }\n  }\n\n  return Promise.all(importResArray).then(i18nlanguages => {\n    for (const cur of i18nlanguages) {\n      let [fullStr, moduleName, fileName] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n      let localeName;\n\n      if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 5);\n        fileName = fileName.substring(0, fileName.length - 6);\n      } else if (/_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 2);\n        fileName = fileName.substring(0, fileName.length - 3);\n      } else {\n        localeName = 'en_US';\n      }\n\n      if (!i18nAllFiles[localeName]) {\n        i18nAllFiles[localeName] = {};\n      }\n\n      if (cur.contents) {\n        try {\n          i18nAllFiles[localeName][fileName] = cur.contents;\n        } catch (err) {\n          logger.error(`Unable to parse ${cur.name}`);\n          throw err;\n        }\n      }\n    }\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (locale !== 'en_US') {\n        backFillFromEnglish(json, i18nAllFiles.en_US);\n      }\n\n      if (json.LoginLocale && json.LoginLocale[locale]) {\n        for (const locale2 of Object.keys(i18nAllFiles)) {\n          _.set(i18nAllFiles, [locale2, 'LoginLocale', locale], json.LoginLocale[locale]);\n        }\n      }\n    }\n\n    let res;\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (name.endsWith(locale)) {\n        res = json;\n      }\n    }\n\n    return res ? res : i18nAllFiles.en_US;\n  });\n};\n/**\n * parse return value webpack.require.context to module object array\n * @param {Array} imports module structure return by webpack.require.context API\n * @returns {Object} module object array\n */\n\nexport const parseImports = imports => imports.reduce((res, m) => res.concat(m.keys().map(path => ({\n  name: path,\n  contents: interopES6Default(m(path))\n}))), []);\n/**\n * stitch JSON from require.context import\n * @param {String} name module structure return by webpack.require.context API\n * @param {Array} imports module structure return by webpack.require.context API\n * @param {Object} config JSON configuration definition\n * @returns {Object} stitched JSON object\n */\n\nexport const stitchJSON = function (name, imports) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let lazy = arguments.length > 3 ? arguments[3] : undefined;\n  return processJsonImports(name, parseImports(imports), config, lazy);\n};\n/**\n * Try to get field object from expr and field context\n * @param {String} expr field input expression\n * @param {Object} fields fields context\n * @param {String} $index $index context\n * @param {String} path fields context\n * @param {Object} context fields context\n * @returns {Object} field object consumed by universal widget\n */\n\nexport const getField = (expr, fields, $index, path, context) => {\n  if (path && $index) {\n    if (/^ctx\\./.test(path)) {\n      return AwParseService.instance(path.replace(/^ctx\\./, '').replace(/\\./g, '_'))(fields)[$index] || {\n        fielddata: {}\n      };\n    } // support the use case of atomic data with aw-repeat\n\n\n    if (path.startsWith('fields.')) {\n      return AwParseService.instance(expr)(context);\n    }\n\n    return AwParseService.instance(path.replace(/\\.props([.[][^.]+\\]?)$/, '$1').replace(/^data\\./, '').replace(/^props\\.|\\.props/, ''))(fields)[$index] || {\n      fielddata: {}\n    };\n  }\n\n  if (/^ctx\\./.test(expr)) {\n    return AwParseService.instance(expr.replace(/^ctx\\./, '').replace(/\\./g, '_'))(fields) || {\n      fielddata: {}\n    };\n  }\n\n  if (!_.isNil($index)) {\n    expr = expr.replace('$index', $index.toString());\n  }\n\n  if (expr.startsWith('fields.')) {\n    return AwParseService.instance(expr.replace(/^data\\./, '').replace(/^fields\\./, ''))(fields) || {\n      fielddata: {}\n    };\n  } // - put { fielddata: {} } as default value to match with widget design\n  // - Supported use case:\n  //   - data.myText => myText\n  //   - data.myObj.props.object_name => myObj.object_name\n\n\n  return AwParseService.instance(expr.replace(/\\.props([.[][^.]+\\]?)$/, '$1').replace(/^data\\./, '').replace(/^fields\\./, ''))(fields) || {\n    fielddata: {}\n  };\n};\n/**\n * Replace all instances of a given string within a larger string.\n *\n * @param {String} input - input string to replace content\n * @param {String} toFind - string to locate\n * @param {String} toReplace - string to replace\n * @return {String} modified string\n */\n\nexport const replaceAll = (input, toFind, toReplace) => {\n  let output = input;\n\n  if (output.indexOf(toFind) > -1) {\n    output = output.split(toFind).join(toReplace);\n  }\n\n  return output;\n};","map":{"version":3,"names":["_","logger","AwParseService","workspaceUtils","interopES6Default","obj","__esModule","default","moduleServiceNameToInject","updateIsToggleFlag","viewModelJson","commands","cmdId2handlers","handlers","handler","Object","values","commandHandlers","id","push","cmdId","command","isToggle","isGroup","isShuttle","reduce","acc","hasOwnProperty","mergeCustomizer","objValue","srcValue","isArray","concat","merge","obj1","obj2","check","depth","isNull","error","element","includes","cloneDeep","isObject","mergeWith","key","field","path","uniqueDepth","undefined","Error","file","join","moduleName","pop","processWorkspaces","solutionDef","workspacesInfo","workspaceData","workspaceArray","workspaces","filteredWorkspaceContributions","filteredWorkspaces","filter","workspaceInfo","test","name","data","workspace","contents","workspaceId","scope","includeInSolutions","solutionId","customizer","each","item","indexOf","processExclusiveKits","WorkspacesInfo","allKitsJson","allModules2StatesJson","workspaceObject","resolveKitDefinitions","processJsonImports","importResArray","config","lazy","res","lazyLoadPromises","reduceJsonContents","sum","cur","fullStr","match","imp","then","Promise","resolve","all","tabs","rest","format","stateName","state","type","abstract","view","parent","reloadOnSearch","params","keys","length","debug","param","controller","warn","assign","iconName","aliases","icoName","replace","token","substring","alias","aliasToken","typeProperties","key2","value","displayProperty","additionalProperties","property","foundProp","find","o","processI10n","imports","i18nAllFiles","MSG_PREFIX","m","localeCode","fileName","split","reverse","map","backFillFromEnglish","nonEnglish","english","bundleName","bundle","i18nlanguages","localeName","err","locale","json","en_US","endsWith","processLoginLocales","startsWith","LoginLocale","locale2","set","parseImports","stitchJSON","getField","expr","fields","$index","context","instance","fielddata","isNil","toString","replaceAll","input","toFind","toReplace","output"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/config/src/js/utils.js"],"sourcesContent":["// Copyright (c) 2022 Siemens\n\n/**\n * @module js/utils\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport AwParseService from 'js/awParseService';\nimport workspaceUtils from 'js/workspaceUtils';\n/**\n * Polyfill to match dynamic import result back to ES5 supported module\n *\n * @param {Object} obj - function to evaluate after loading the dependencies.\n * @returns {Object} ES5 module object\n */\nexport function interopES6Default( obj ) {\n    // for case like appCtxSerivce, for unknown reason, it has __esModule but no default\n    // In the case we will use module itself\n    // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n    // NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion\n    // it makes that we defined the moduleServiceNameToInject at top level for that practice, not class\n    // level.\n    // It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice\n    // the return is inconsistent for requireJS API:\n    // - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }\n    // - class without moduleServiceNameToInject => svcClass\n    // - non class => it doen't matter since module === module.default\n    // webpack and non-webpack mode will be same snce they have the same _interopES6Default\n    //\n    // Long term solution\n    // - stop supporting non-webpack build\n    // - see if we can remove this _interopES6Default when use dynamic import\n    //\n    // Short term solution (aw4.3)\n    // - Document this apperance difference for class service\n    // - it should be a minor minor case in regular practice\n    return obj && obj.__esModule && obj.default && !obj.moduleServiceNameToInject ? obj.default : obj;\n}\n\n/**\n * Set the \"isToggle\" flag on any commands that have a handler with a \"selectWhen\" condition\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nfunction updateIsToggleFlag( viewModelJson ) {\n    if( viewModelJson.commands ) {\n        const cmdId2handlers = {};\n        let handlers = [];\n        for( const handler of Object.values( viewModelJson.commandHandlers ) ) {\n            handlers = cmdId2handlers[ handler.id ];\n            if( !handlers ) {\n                handlers = [];\n                cmdId2handlers[ handler.id ] = handlers;\n            }\n            handlers.push( handler );\n        }\n        for( const cmdId in viewModelJson.commands ) {\n            const command = viewModelJson.commands[ cmdId ];\n            // The handlers for the given command\n            handlers = cmdId2handlers[ cmdId ] || [];\n            // If any handler for this command has selectWhen the command is a toggle command\n            command.isToggle = !command.isGroup && !command.isShuttle && handlers.reduce( function( acc, handler ) {\n                return acc || handler.hasOwnProperty( 'selectWhen' );\n            }, false ) || false;\n        }\n    }\n}\n\n/**\n * @param {Object} objValue - destination object\n * @param {Object} srcValue source object\n * @return {Object|undefined} modified destination object\n */\nfunction mergeCustomizer( objValue, srcValue ) {\n    if( _.isArray( objValue ) ) {\n        return objValue.concat( srcValue );\n    }\n}\n\n/**\n * @param {Object} obj1 object 1\n * @param {Object} obj2 object 2\n * @param {Object|null} check - optional checker object\n * @param {Number|null} depth - depth of merge\n * @type {module.exports.merge}\n */\nconst merge = ( obj1, obj2, check, depth ) => {\n    if( !depth ) { depth = 1; }\n    if( _.isNull( obj2 ) ) {\n        // nothing to merge\n    } else if( _.isNull( obj1 ) ) {\n        logger.error( 'Null object to merge!' );\n    } else if( _.isArray( obj1 ) && _.isArray( obj2 ) ) {\n        for( let element of obj2 ) {\n            // If there was a 'identity' test for the elements, we might be able to merge objects in the array.\n            if( !obj1.includes( element ) ) {\n                obj1.push( _.cloneDeep( element ) );\n            }\n        }\n    } else if( _.isObject( obj1 ) && _.isObject( obj2 ) ) {\n        if( !check ) {\n            _.mergeWith( obj1, obj2, mergeCustomizer );\n        } else {\n            for( const key in obj2 ) {\n                const field = obj2[ key ];\n                if( obj1.hasOwnProperty( key ) ) {\n                    if( check ) {\n                        check.path.push( key );\n                        if( check.uniqueDepth !== undefined &&\n                            check.uniqueDepth === depth &&\n                            !check.path.includes( 'i18n' ) ) {\n                            throw new Error( 'Name conflict in ' + check.file + '.json path=' + check.path.join( '.' ) + ' for module ' + check.moduleName + ' (2nd occurrence)!' );\n                        }\n                    }\n                    merge( obj1[ key ], field, check, depth + 1 );\n                    if( check ) { check.path.pop(); }\n                } else {\n                    obj1[ key ] = _.cloneDeep( field );\n                }\n            }\n        }\n    } else if( _.isArray( obj1 ) || _.isArray( obj2 ) ) {\n        throw new Error( 'Invalid array merge!' );\n    } else if( _.isObject( obj1 ) || _.isObject( obj2 ) ) {\n        throw new Error( 'Invalid object merge!' );\n    }\n};\n\nexport const processWorkspaces = ( solutionDef, workspacesInfo ) => {\n    let workspaceData = {};\n    const workspaceArray = solutionDef.workspaces;\n    let filteredWorkspaceContributions = [];\n    if( solutionDef && solutionDef.workspaces ) {\n        let filteredWorkspaces = workspacesInfo.filter( function( workspaceInfo ) {\n            if( /workspace_contribution.*/.test( workspaceInfo.name ) ) {\n                filteredWorkspaceContributions.push( workspaceInfo );\n                return false;\n            }\n            return true;\n        } );\n        for( const data of Object.values( filteredWorkspaces ) ) {\n            const workspace = data.contents;\n            if( _.includes( workspaceArray, workspace.workspaceId ) || workspace.scope === 'Internal' ||\n                workspace.includeInSolutions && workspace.includeInSolutions.includes( solutionDef.solutionId ) ) {\n                workspaceData[ workspace.workspaceId ] = workspace;\n            }\n        }\n        //now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData\n        for( const data of Object.values( filteredWorkspaceContributions ) ) {\n            const workspace = data.contents;\n            if( workspaceData[ workspace.workspaceId ] !== undefined ) {\n                _.mergeWith( workspaceData[ workspace.workspaceId ], workspace, function customizer( objValue, srcValue ) {\n                    if( _.isArray( objValue ) ) {\n                        _.each( srcValue, function( item ) {\n                            if( objValue.indexOf( item ) < 0 ) {\n                                objValue.push( item );\n                            }\n                        } );\n                        return objValue;\n                    }\n                } );\n            }\n        }\n    }\n    return workspaceData;\n};\n\n/**\n * Add all the configurations from the exclusive kits to the workspaces.\n * @param {object} WorkspacesInfo all workspaces\n * @param {Object} allKitsJson - all kits\n * @param {Object} allStatesJson - all states\n */\nexport const processExclusiveKits = ( WorkspacesInfo, allKitsJson, allModules2StatesJson ) => {\n    for( var workspaceObject of Object.values( WorkspacesInfo ) ) {\n        workspaceUtils.resolveKitDefinitions( workspaceObject.contents, allKitsJson, allModules2StatesJson );\n    }\n    return;\n};\nexport const processJsonImports = ( name, importResArray, config = {}, lazy ) => {\n    let res = {};\n    let lazyLoadPromises = [];\n    // have to put it here because of clojure\n    const reduceJsonContents = ( sum, cur ) => {\n        const [ fullStr, moduleName, file ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n\n        merge( sum, cur.contents, config.uniqueDepth && {\n            moduleName,\n            file,\n            path: [],\n            uniqueDepth: config.uniqueDepth\n        } );\n        return sum;\n    };\n\n    if( lazy ) {\n        for( const imp of importResArray ) {\n            if( typeof imp.contents.then === 'function' ) {\n                lazyLoadPromises.push( imp.contents.then( ( contents ) => {\n                    return { contents: interopES6Default( contents ), name: imp.name };\n                } ) );\n            } else {\n                // require.context in mendix does not support lazy loading\n                // For now wrap the response in promise until we fix rollup-plugin-require-context2\n                lazyLoadPromises.push( new Promise( resolve => {\n                    const contents = imp.contents;\n                    return resolve( { contents: interopES6Default( contents ), name: imp.name } );\n                } ) );\n            }\n        }\n    }\n    // revisitme - need to consider \"configuration.format === 'array'\" use case later\n    if( name === 'commandsViewModel' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            let res = importResArray.reduce( reduceJsonContents, {} );\n            updateIsToggleFlag( res );\n            return res;\n        } );\n    } else if( name === 'secondaryWorkareaTabs' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            return importResArray.reduce( ( sum, cur ) => {\n                // old schema support\n                if( _.isArray( cur.contents ) ) {\n                    sum.tabs.push( ...cur.contents );\n                } else {\n                    // new schema support\n                    let { tabs, ...rest } = cur.contents;\n                    sum.tabs.push( ...Object.values( tabs ) );\n                    merge( sum, rest );\n                }\n                return sum;\n            }, { tabs: [] } );\n        } );\n    } else if( name === 'layoutSlots' ||\n        name === 'navigationURLToken' ||\n        name === 'syncStrategy' ||\n        name === 'indicators' ||\n        name === 'adapters' ||\n        name === 'headerContributions' ||\n        name === 'saveHandlers' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );\n            return res;\n        } );\n    } else if( name === 'workspace' ) {\n        return importResArray;\n    } else if( name === 'states' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents ) {\n                for( const stateName in cur.contents ) {\n                    const state = cur.contents[ stateName ];\n                    if( state.type === 'location' ) {\n                        if( !state.hasOwnProperty( 'abstract' ) ) {\n                            state.abstract = true;\n                        }\n                        if( !state.view ) {\n                            state.view = 'AwDefaultLocation';\n                        }\n                        if( !state.parent ) {\n                            state.parent = 'root';\n                        }\n                    } else if( state.type === 'subLocation' ) {\n                        if( !state.view ) {\n                            state.view = 'AwDefaultSublocation';\n                        }\n                        if( !state.hasOwnProperty( 'reloadOnSearch' ) ) {\n                            state.reloadOnSearch = false;\n                        }\n                        if( !state.parent ) {\n                            throw new Error( `Sublocation state ${stateName} does not have parent location` );\n                        }\n                        if( !state.hasOwnProperty( 'url' ) ) {\n                            throw new Error( `No url defined for sublocation state ${stateName}` );\n                        }\n                    } else if( state.type === 'parameter' ) {\n                        if( !state.params ) {\n                            throw new Error( `Parameter state ${stateName} must have parameters` );\n                        } else if( Object.keys( state ).length > 2 ) {\n                            throw new Error( `Parameter state ${stateName} should only have type and params` );\n                        }\n                        // Merging states is handled later\n                    } else {\n                        logger.debug( `No type or unknown type on state ${stateName} cannot validate state` );\n                    }\n\n                    if( state.params ) {\n                        for( let param in state.params ) {\n                            if( !state.params[ param ] ) {\n                                state.params[ param ] = { type: 'any' };\n                            }\n                        }\n                    }\n                    // Temporary hack to support states that have not set type (ex search)\n                    if( state.type !== 'location' && !state.parent && state.controller === 'DefaultLocationCtrl' ) {\n                        logger.warn( `${stateName} is using DefaultLocationCtrl but is not a location` );\n                        state.parent = 'root';\n                    }\n                    if( !sum[ stateName ] ) {\n                        sum[ stateName ] = state;\n                    } else {\n                        if( sum[ stateName ].type === 'parameter' || state.type === 'parameter' ) {\n                            // If the current state is just parameters merge it into the finalState\n                            if( state.type === 'parameter' ) {\n                                _.assign( sum[ stateName ].params, state.params );\n                            } else {\n                                // If the final state is currently just parameters and the new state is not merge into the new state\n                                _.assign( state.params, sum[ stateName ].params );\n                                sum[ stateName ] = state;\n                            }\n                        } else {\n                            logger.error( `State name conflict with state ${stateName}` );\n                        }\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    } else if( name === 'aliasRegistry' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents ) {\n                for( const iconName in cur.contents ) {\n                    const aliases = cur.contents[ iconName ];\n                    let icoName = iconName;\n                    if( aliases.length === 0 ) {\n                        throw new Error( `No aliases provided for type icons declared for [${icoName}]` );\n                    }\n                    // If not a type alias, then strip the size numbers at the end of the filename.\n                    if( !/^type/.test( icoName ) ) { icoName = icoName.replace( /[0-9]+$/, '' ); }\n                    const token = icoName.substring( 0, 4 );\n                    for( const alias of aliases ) {\n                        const aliasToken = token + alias;\n                        if( sum[ aliasToken ] ) {\n                            throw new Error( `Multiple aliases declared for ${aliasToken} [${icoName} & ${sum[ aliasToken ]}]` );\n                        }\n                        if( aliasToken === iconName ) {\n                            throw new Error( `Why map the same name to itself? ${alias}` );\n                        }\n                        sum[ aliasToken ] = icoName;\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    } else if( name === 'typeProperties' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents && cur.contents.typeProperties ) {\n                const typeProperties = cur.contents.typeProperties;\n                for( const key2 in typeProperties ) {\n                    const value = typeProperties[ key2 ];\n                    if( !sum[ key2 ] ) {\n                        sum[ key2 ] = value;\n                    } else {\n                        if( sum[ key2 ].displayProperty &&\n                            value.displayProperty &&\n                            sum[ key2 ].displayProperty !== value.displayProperty ) {\n                            logger.error( `TypeProperties displayProperty conflict with type ${key2}` );\n                        } else if( value.displayProperty ) {\n                            sum[ key2 ].displayProperty = value.displayProperty;\n                        }\n                        if( value.additionalProperties ) {\n                            if( !sum[ key2 ].additionalProperties ) {\n                                sum[ key2 ].additionalProperties = [];\n                            }\n                            for( const property of value.additionalProperties ) {\n                                const foundProp = _.find( sum[ key2 ].additionalProperties, o => {\n                                    return o.name === property.name;\n                                } );\n                                if( !foundProp ) {\n                                    sum[ key2 ].additionalProperties.push( property );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    }\n    // else\n    res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );\n    return res;\n};\n\nexport const processI10n = ( name, imports ) => {\n    const i18nAllFiles = {};\n    const MSG_PREFIX = 'processL10n: ';\n    let importResArray = imports.reduce( ( res, m ) =>\n        res.concat(\n            _.filter( m.keys(), ( path ) => {\n                let localeCode;\n                // get base name\n                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];\n\n                if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'i18n_' + fileName.substring( fileName.length - 5 );\n                } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'i18n_' + fileName.substring( fileName.length - 2 );\n                } else {\n                    localeCode = 'i18n';\n                }\n                return localeCode === name || name !== 'i18n' && localeCode === 'i18n';\n            } ).map( path => {\n                if( typeof m( path ).then === 'function' ) {\n                    return m( path ).then( ( contents ) => {\n                        return { contents: interopES6Default( contents ), name: path };\n                    } );\n                }\n                // The plugin used in mendix integration does not support lazy m(path) i.e then api is missing\n                return new Promise( resolve => {\n                    const contents = m( path );\n                    return resolve( { contents: interopES6Default( contents ), name: path } );\n                } );\n            } ) ), []\n    );\n\n    /**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */\n    function backFillFromEnglish( nonEnglish, english ) {\n        for( const bundleName in english ) {\n            const bundle = english[ bundleName ];\n            if( !nonEnglish[ bundleName ] ) {\n                nonEnglish[ bundleName ] = bundle;\n                continue;\n            }\n            for( const key in bundle ) {\n                const value = bundle[ bundleName ];\n                if( !nonEnglish[ bundleName ][ key ] ) {\n                    nonEnglish[ bundleName ][ key ] = value;\n                }\n            }\n        }\n    }\n\n    return Promise.all( importResArray ).then( ( i18nlanguages ) => {\n        for( const cur of i18nlanguages ) {\n            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n            let localeName;\n            if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 5 );\n                fileName = fileName.substring( 0, fileName.length - 6 );\n            } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 2 );\n                fileName = fileName.substring( 0, fileName.length - 3 );\n            } else {\n                localeName = 'en_US';\n            }\n            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }\n            if( cur.contents ) {\n                try {\n                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;\n                } catch ( err ) {\n                    logger.error( `Unable to parse ${cur.name}` );\n                    throw err;\n                }\n            }\n        }\n\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }\n        }\n\n        /**\n         * Existing i18n logic: ( for all step below, en_US doesn't have suffix)\n         * - i18n src is defined as:\n         *   adobejsTooltipMessages_zh_CN ->\n         *   {\n         *       \"openInIllustrator\": \"Local test in Chinese\"\n         *   }\n         *\n         * - It will be reassemble as:\n         *   i18n_zh_CN.json ->\n         *   {\n         *       adobejsTooltipMessages: {\n         *           \"openInIllustrator\": \"Local test in Chinese\"\n         *       }\n         *   }\n         *\n         * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',\n         *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'\n         *\n         * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'\n         *\n         * - in the final cfgCache it will looks like:\n         *   {\n         *       actionTemplateDefs,\n         *       ....,\n         *       i18n_zh_CN: {\n         *           adobejsTooltipMessages: {\n         *               \"openInIllustrator\": \"Local test in Chinese\"\n         *           }\n         *       }\n         *   }\n         *\n         * - regarding to installedLocales:\n         *   - it depends on on how man JSON config our customer has in src\n         *   - it depends on war_mySite.json\n         *   We will check it later\n         */\n        let res;\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( name.endsWith( locale ) ) {\n                res = json;\n            }\n        }\n\n        // load english by default\n        // revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will\n        // see how can we handle that later\n        return res ? res : i18nAllFiles.en_US;\n    } );\n};\n\nexport const processLoginLocales = ( name, imports ) => {\n    const i18nAllFiles = {};\n    let importResArray = imports.reduce( ( res, m ) =>\n        res.concat(\n            _.filter( m.keys(), ( path ) => {\n                let localeCode;\n                // get base name\n                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];\n\n                if( !fileName.startsWith( 'LoginLocale' ) ) {\n                    return false;\n                }\n\n                if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 5 );\n                } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 2 );\n                } else {\n                    localeCode = 'LoginLocale';\n                }\n                return localeCode === name || name !== 'LoginLocale' && localeCode === 'LoginLocale';\n            } ).map( path => m( path ).then( ( contents ) => {\n                return { contents: interopES6Default( contents ), name: path };\n            } ) ) ), []\n    );\n\n    /**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */\n    function backFillFromEnglish( nonEnglish, english ) {\n        for( const bundleName in english ) {\n            const bundle = english[ bundleName ];\n            if( !nonEnglish[ bundleName ] ) {\n                nonEnglish[ bundleName ] = bundle;\n                continue;\n            }\n            for( const key in bundle ) {\n                const value = bundle[ bundleName ];\n                if( !nonEnglish[ bundleName ][ key ] ) {\n                    nonEnglish[ bundleName ][ key ] = value;\n                }\n            }\n        }\n    }\n\n    return Promise.all( importResArray ).then( ( i18nlanguages ) => {\n        for( const cur of i18nlanguages ) {\n            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n            let localeName;\n            if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 5 );\n                fileName = fileName.substring( 0, fileName.length - 6 );\n            } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 2 );\n                fileName = fileName.substring( 0, fileName.length - 3 );\n            } else {\n                localeName = 'en_US';\n            }\n            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }\n            if( cur.contents ) {\n                try {\n                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;\n                } catch ( err ) {\n                    logger.error( `Unable to parse ${cur.name}` );\n                    throw err;\n                }\n            }\n        }\n\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }\n            if( json.LoginLocale && json.LoginLocale[ locale ] ) {\n                for( const locale2 of Object.keys( i18nAllFiles ) ) {\n                    _.set( i18nAllFiles, [ locale2, 'LoginLocale', locale ], json.LoginLocale[ locale ] );\n                }\n            }\n        }\n\n        let res;\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( name.endsWith( locale ) ) {\n                res = json;\n            }\n        }\n\n        return res ? res : i18nAllFiles.en_US;\n    } );\n};\n\n/**\n * parse return value webpack.require.context to module object array\n * @param {Array} imports module structure return by webpack.require.context API\n * @returns {Object} module object array\n */\nexport const parseImports = imports => imports.reduce( ( res, m ) =>\n    res.concat( m.keys().map( path => ( {\n        name: path,\n        contents: interopES6Default( m( path ) )\n    } ) ) ), [] );\n\n/**\n * stitch JSON from require.context import\n * @param {String} name module structure return by webpack.require.context API\n * @param {Array} imports module structure return by webpack.require.context API\n * @param {Object} config JSON configuration definition\n * @returns {Object} stitched JSON object\n */\nexport const stitchJSON = ( name, imports, config = {}, lazy ) =>\n    processJsonImports( name, parseImports( imports ), config, lazy );\n\n/**\n * Try to get field object from expr and field context\n * @param {String} expr field input expression\n * @param {Object} fields fields context\n * @param {String} $index $index context\n * @param {String} path fields context\n * @param {Object} context fields context\n * @returns {Object} field object consumed by universal widget\n */\nexport const getField = ( expr, fields, $index, path, context ) => {\n    if( path && $index ) {\n        if( /^ctx\\./.test( path ) ) {\n            return AwParseService.instance( path.replace( /^ctx\\./, '' ).replace( /\\./g, '_' ) )( fields )[ $index ] || { fielddata: {} };\n        }\n        // support the use case of atomic data with aw-repeat\n        if( path.startsWith( 'fields.' ) ) {\n            return AwParseService.instance( expr )( context );\n        }\n        return AwParseService.instance( path.replace( /\\.props([.[][^.]+\\]?)$/, '$1' ).replace( /^data\\./, '' ).replace( /^props\\.|\\.props/, '' ) )( fields )[ $index ] || { fielddata: {} };\n    }\n    if( /^ctx\\./.test( expr ) ) {\n        return AwParseService.instance( expr.replace( /^ctx\\./, '' ).replace( /\\./g, '_' ) )( fields ) || { fielddata: {} };\n    }\n    if( !_.isNil( $index ) ) {\n        expr = expr.replace( '$index', $index.toString() );\n    }\n\n    if( expr.startsWith( 'fields.' ) ) {\n        return AwParseService.instance( expr.replace( /^data\\./, '' ).replace( /^fields\\./, '' ) )( fields ) || { fielddata: {} };\n    }\n\n    // - put { fielddata: {} } as default value to match with widget design\n    // - Supported use case:\n    //   - data.myText => myText\n    //   - data.myObj.props.object_name => myObj.object_name\n    return AwParseService.instance( expr.replace( /\\.props([.[][^.]+\\]?)$/, '$1' ).replace( /^data\\./, '' ).replace( /^fields\\./, '' ) )( fields ) || { fielddata: {} };\n};\n\n/**\n * Replace all instances of a given string within a larger string.\n *\n * @param {String} input - input string to replace content\n * @param {String} toFind - string to locate\n * @param {String} toReplace - string to replace\n * @return {String} modified string\n */\nexport const replaceAll = ( input, toFind, toReplace ) => {\n    let output = input;\n    if( output.indexOf( toFind ) > -1 ) {\n        output = output.split( toFind ).join( toReplace );\n    }\n    return output;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}