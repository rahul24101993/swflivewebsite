{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * Defines {@link centralAggregationService} .\n * @module js/centralAggregationService\n */import tabRegistryService from'js/tabRegistry.service';import commandHighlightService from'js/commandHighlightService';import appCtxService from'js/appCtxService';import localStorage from'js/localStorage';import htmlUtils from'js/htmlUtils';let _services=[];/**\n *\n * @param {String} xpath xpath to evaluate.\n * @param {DOMElement} contextNode element to evaluate upon.\n * @returns {DOMElement} null or the found html element.\n */export function getElement(xpath,contextNode){return htmlUtils.getElementByXpath(xpath,contextNode);}/**\n * Helper function to get the command bar + anchor of contextNode using xpath\n * to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @param {*} xpath - xpath to update the contextNode if needed\n * @returns {Object} command bar information. commandBarAnchor, the xpath to\n * the command bar, and the updated context node.\n */const getCommandBarInfo=(contextNode,xpath)=>{const cmdBarXpath='./ancestor::*[contains(@class, \\'aw-command-bar\\')]';const cmdBar=htmlUtils.getElementByXpath(cmdBarXpath,contextNode);if(cmdBar){const cmdBarAnchor=cmdBar.getAttribute('anchor');const cmdBarXpath='//*[contains(@class, \\'aw-command-bar\\') and @anchor=\\''+cmdBarAnchor+'\\']';return{cmdBarAnchor:cmdBarAnchor,xpath:cmdBarXpath,contextNode:contextNode};}let cmdBarAnchor='';const popupCmdBarXpath='./ancestor::*[contains(@class, \\'aw-popup-command-bar\\')]';const popupCmdBar=htmlUtils.getElementByXpath(popupCmdBarXpath,contextNode);if(popupCmdBar){cmdBarAnchor=popupCmdBar.getAttribute('anchor');}/**\n     * if there is no command bar from the clicked command, it is an overflow or group command\n     * check the command bar that the overflow command or group command is a part of\n     *      1. if it is an overflow command, find the actual hidden command in the DOM with it's anchor\n     *          a. singular command bar\n     *          b. multiple command bars\n     *      2. if it is a group command, find the group command id and anchor\n     */const overflowButtonXpath='//*[contains(@class,\\'aw-commands-moreButton\\')]//*[contains(@class, \\'aw-state-selected\\')]';const overflowButton=htmlUtils.getElementByXpath(overflowButtonXpath,document);if(overflowButton){// 1. if it is an overflow command, find the actual hidden command in the DOM with it's anchor\nconst cmdBar2=htmlUtils.getElementByXpath(cmdBarXpath,overflowButton);if(cmdBar2){const cmdBarAnchor2=cmdBar2.getAttribute('anchor');const cmdBarXpath2='//*[contains(@class, \\'aw-command-bar\\') and @anchor=\\''+cmdBarAnchor2+'\\']';return{cmdBarAnchor:cmdBarAnchor2,grpCmdBarAnchor:undefined,grpCmdId:undefined,xpath:cmdBarXpath2,contextNode:htmlUtils.getElementByXpath(cmdBarXpath+xpath,overflowButton)};}// singular command bar is not found, searching multiple command bars\nconst cmdBarsXpath='./ancestor::*[contains(@class, \\'aw-commandBars\\')]';const cmdBars=htmlUtils.getElementByXpath(cmdBarsXpath,overflowButton);if(cmdBars){const cmd=htmlUtils.getElementByXpath(xpath,cmdBars);if(cmd){const cmdBar3=htmlUtils.getElementByXpath(cmdBarXpath,cmd);if(cmdBar3){const cmdBarAnchor3=cmdBar3.getAttribute('anchor');const cmdBarXpath='//*[contains(@class, \\'aw-command-bar\\') and @anchor=\\''+cmdBarAnchor3+'\\']';return{cmdBarAnchor:cmdBarAnchor3,grpCmdBarAnchor:undefined,grpCmdId:undefined,xpath:cmdBarXpath,contextNode:cmd};}}}}else{const grpCmdXpath='//*[contains(@class, \\'aw-state-selected\\') and @data-command-id]//*[contains(@class, \\'aw-widgets-groupCommand\\')]/ancestor::*[@data-command-id]';const grpCmd=htmlUtils.getElementByXpath(grpCmdXpath,document);// 2. if it is a group command, find the group command id and anchor\nif(grpCmd){const grpCmdId=grpCmd.getAttribute('data-command-id');const grpCmdAnchorElem=htmlUtils.getElementByXpath(cmdBarXpath,grpCmd);let grpCmdAnchor=grpCmdAnchorElem?grpCmdAnchorElem.getAttribute('anchor'):undefined;return{cmdBarAnchor:cmdBarAnchor,grpCmdBarAnchor:grpCmdAnchor,grpCmdId:grpCmdId,xpath:'',contextNode:grpCmd};}}return{cmdBarAnchor:cmdBarAnchor,grpCmdBarAnchor:undefined,grpCmdId:undefined,xpath:'',contextNode:contextNode};};/**\n * Helper function to get the containing property of contextNode using xpath\n * to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @returns {Object} property information. Property name and its xpath.\n */const getPropertyInfo=contextNode=>{const propXpath='./ancestor::*[contains(@class, \\'sw-property\\')]//*[contains(@class, \\'sw-property-name\\')]';const propNameElement=htmlUtils.getElementByXpath(propXpath,contextNode);if(propNameElement){const propName=propNameElement.getInnerHTML();return{propName:propName,xpath:'//*[contains(@class, \\'sw-property-name\\') and text()=\\''+propName+'\\']/ancestor::*[contains(@class, \\'sw-property\\')]'};}return{propName:undefined,xpath:''};};/**\n * Helper function to get the containing section of contextNode using xpath\n * to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @returns {Object} section information. Section titleKey and its xpath.\n */const getSectionInfo=contextNode=>{const sectionXpath='./ancestor::*[contains(@class, \\'sw-section\\') and contains(@class, \\'aw-panelSection\\')]';const section=htmlUtils.getElementByXpath(sectionXpath,contextNode);if(section){const sectionTitleKey=section.getAttribute('titlekey');const sectionTitleKeyXpath='//*[contains(@class, \\'sw-section\\') and contains(@class, \\'aw-panelSection\\') and @titlekey=\\''+sectionTitleKey+'\\']';return{sectionTitleKey:sectionTitleKey,xpath:sectionTitleKeyXpath};}return{sectionTitleKey:undefined,xpath:''};};/**\n * Helper function to get the containing secondary workarea tab of contextNode\n * using xpath to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @returns {Object} secondary workarea tab information. Secondary workarea tab key\n * and its xpath.\n */const getSwaTabInfo=contextNode=>{const swaTabsXpath='./ancestor::*[contains(@class, \\'sw-secondary-workarea\\')]//*[contains(@class, \\'sw-tabContainer\\')]//*[contains(@class, \\'sw-tab-selected\\')]';const swaTab=htmlUtils.getElementByXpath(swaTabsXpath,contextNode);if(swaTab){const swaTabKey=swaTab.getAttribute('tabkey');const swaTabKeyXpath='//*[contains(@class, \\'sw-secondary-workarea\\')]//*[contains(@class, \\'sw-tabContainer\\')]//*[contains(@class, \\'sw-tab-selected\\') and @tabkey=\\''+swaTabKey+'\\']/ancestor::*[contains(@class, \\'sw-secondary-workarea\\')]';return{swaTabKey:swaTabKey,xpath:swaTabKeyXpath};}return{swaTabKey:undefined,xpath:''};};/**\n * Helper function to get the containing primary workarea tab of contextNode using xpath\n * to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @returns {Object} primary workarea information. Primary workarea tab key and its xpath.\n */const getPwaTabInfo=contextNode=>{const pwaTabsXpath='./ancestor::*[contains(@class, \\'sw-showobject-page\\')]//*[contains(@class, \\'aw-layout-subLocationTitles\\')]'+'//*[contains(@class, \\'sw-tabContainer\\')]//*[contains(@class, \\'sw-tab-selected\\')]';const pwaTab=htmlUtils.getElementByXpath(pwaTabsXpath,contextNode);if(pwaTab){const pwaTabName=pwaTab.getAttribute('tabkey');const pwaTabNameXpath='//*[contains(@class, \\'aw-layout-subLocationTitles\\')]//*[contains(@class, \\'sw-tabContainer\\')]//*[contains(@class, \\'sw-tab-selected\\') and @tabkey=\\''+pwaTabName+'\\']/ancestor::*[contains(@class, \\'sw-showobject-page\\')]';return{pwaTabName:pwaTabName,xpath:pwaTabNameXpath};}return{pwaTabName:undefined,xpath:''};};/**\n * Helper function to get the containing view of contextNode using xpath\n * to fish the DOM.\n *\n * @param {DOMElement} contextNode - context element to search\n * @param {*} xpath - xpath to update the contextNode if needed\n * @returns {Object} view information. xpath to the containing view.\n */const getViewInfo=(contextNode,xpath)=>{const viewXpath='./ancestor::*[contains(@class, \\'sw-showobject-page\\')]';const view=htmlUtils.getElementByXpath(viewXpath,contextNode);if(view){const result=document.evaluate('//*[contains(@class, \\'sw-showobject-page\\')]',document,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE,null);let index=1;//multiple work areas\nlet node=result.iterateNext();while(node){const elem=htmlUtils.getElementByXpath('(//*[contains(@class, \\'sw-showobject-page\\')])['+index+']'+xpath,document);if(elem===contextNode){break;}else{index+=1;}node=result.iterateNext();}return'(//*[contains(@class, \\'sw-showobject-page\\')])['+index+']';}return'';};/**\n * Helper function to get the currently selected type.\n *\n * @returns {String} the selected type.\n */const getSelectedTypeInfo=()=>{return appCtxService.ctx.selected&&appCtxService.ctx.selected!==null&&appCtxService.ctx.selected.type?appCtxService.ctx.selected.type:'';};/**\n * Helper function to get the current selection mode.\n *\n * @returns {String} the selection mode.\n */const getSelectionModeInfo=()=>{const mselected=appCtxService.ctx.mselected;if(mselected&&mselected!==null&&mselected.length>=1){for(let index=1;index<mselected.length;index++){if(mselected[index].type!==mselected[index-1].type){return'MULTIPLE';}}return mselected.length>1?'MULTIPLE':'SINGLE';}return'SINGLE';};/**\n * Helper function to get the current user context information (user/role/group/workspace).\n *\n * @returns {Object} user context information. User uid, role uid, group uid, and workspace id.\n */const getUserContextInfo=()=>{let user='';let role='';let group='';let workspace='';if(appCtxService.ctx&&appCtxService.ctx.userSession&&appCtxService.ctx.userSession.props){user=appCtxService.ctx.userSession.props.user.dbValues[0];role=appCtxService.ctx.userSession.props.role.dbValues[0];group=appCtxService.ctx.userSession.props.group.dbValues[0];if(appCtxService.ctx.workspace){workspace=appCtxService.ctx.workspace.workspaceId;}}return{user:user,role:role,group:group,workspace:workspace};};/**\n * Helper function to get command information from contextNode.\n *\n * @param {HTMLElement} contextNode - button element that contains command id attribute\n * @returns {Object} command information. Command id, command bar anchor, property name,\n * section titlekey, secondary workarea tab, primary workarea tab, view xpath, user,\n * role, group, workspace, selected type, and selection mode.\n */const getCommandInfo=contextNode=>{let localContextNode=contextNode;const cmdId=contextNode.getAttribute('data-command-id');let xpath='//*[@data-command-id=\\''+cmdId+'\\']';const cmdBarInfo=getCommandBarInfo(localContextNode,xpath);xpath=cmdBarInfo.grpCmdId?'//*[@data-command-id=\\''+cmdBarInfo.grpCmdId+'\\']':cmdBarInfo.xpath+xpath;localContextNode=cmdBarInfo.contextNode;const propInfo=getPropertyInfo(localContextNode);xpath=propInfo.xpath+xpath;const sectionInfo=getSectionInfo(localContextNode);xpath=sectionInfo.xpath+xpath;const swaTabInfo=getSwaTabInfo(localContextNode);xpath=swaTabInfo.xpath+xpath;const pwaTabInfo=getPwaTabInfo(localContextNode);xpath=pwaTabInfo.xpath+xpath;xpath=getViewInfo(localContextNode,xpath)+xpath;const userContextInfo=getUserContextInfo();return{xpath:xpath,commandId:cmdId,commandBarAnchor:cmdBarInfo.cmdBarAnchor,grpCmdId:cmdBarInfo.grpCmdId,grpCmdAnchor:cmdBarInfo.grpCmdBarAnchor,propName:propInfo.propName,sectionTitleKey:sectionInfo.sectionTitleKey,swaTab:swaTabInfo.swaTabKey,pwaTab:pwaTabInfo.pwaTabKey,selectedType:getSelectedTypeInfo(),selectionMode:getSelectionModeInfo(),user:userContextInfo.user,role:userContextInfo.role,group:userContextInfo.group,workspace:userContextInfo.workspace};};/**\n *\n * @param {HTMLElement} contextNode - anchor element that contains tab key attribute\n * @returns {Object} tab information\n */const getTabInfo=contextNode=>{let localContextNode=contextNode;const tabKey=localContextNode.getAttribute('tabkey');// determine if we are in overflow\nconst overflowXpath='//*[contains(@class, \\'sw-tab-overflowContainer\\')]//*[contains(@class, \\'sw-tab-overflowButton\\') and contains(@class, \\'aw-jswidget-controlArrowRotateRight\\')]';const overflowButtonElem=htmlUtils.getElementByXpath(overflowXpath,document);if(overflowButtonElem){// in overflow, get the hidden tab\nconst hiddenTabXpath='./ancestor::*[contains(@class, \\'sw-tab-overflowContainer\\')]/ancestor::*//*[@role=\\'tablist\\' and contains(@class, \\'sw-tabContainer\\')]//*[@role=\\'tab\\']//*[@tabkey=\\''+tabKey+'\\']';const hiddenTabElem=htmlUtils.getElementByXpath(hiddenTabXpath,overflowButtonElem);if(hiddenTabElem){localContextNode=hiddenTabElem;}}const tabName=localContextNode.getAttribute('aria-label');let xpath='//*[@tabkey=\\''+tabKey+'\\']';const swaXpath='./ancestor::*[contains(@class, \\'sw-secondary-workarea\\')]';const swaElem=htmlUtils.getElementByXpath(swaXpath,localContextNode);if(swaElem){// clicked on swa tab\nxpath='//*[contains(@class, \\'sw-secondary-workarea\\')]'+xpath;const pwaTabInfo=getPwaTabInfo(localContextNode);xpath=pwaTabInfo.xpath+xpath;xpath=getViewInfo(localContextNode,xpath)+xpath;}else{const pwaXpath='./ancestor::*[contains(@class, \\'sw-tabContainer\\')]/ancestor::*[contains(@class, \\'aw-layout-subLocationTitles\\')]';const pwaElem=htmlUtils.getElementByXpath(pwaXpath,localContextNode);if(pwaElem){xpath='//*[contains(@class, \\'aw-layout-subLocationTitles\\')]//*[contains(@class, \\'sw-tabContainer\\')]'+xpath;xpath=getViewInfo(localContextNode,xpath)+xpath;}}const userContextInfo=getUserContextInfo();return{xpath:xpath,tabName:tabName,selectedType:getSelectedTypeInfo(),selectionMode:getSelectionModeInfo(),user:userContextInfo.user,role:userContextInfo.role,group:userContextInfo.group,workspace:userContextInfo.workspace};};/**\n *\n * @param {HTMLElement} contextNode - aw-tile element\n * @returns {Object} tile information\n */const getTileInfo=contextNode=>{const tileName=contextNode.getAttribute('title');const userContextInfo=getUserContextInfo();return{xpath:'//*[contains(@class, \\'aw-tile-tileContainer\\') and @data-locator=\\'tile-container\\' and @title=\\''+tileName+'\\']',tileName:tileName,selectedType:getSelectedTypeInfo(),selectionMode:getSelectionModeInfo(),user:userContextInfo.user,role:userContextInfo.role,group:userContextInfo.group,workspace:userContextInfo.workspace};};// TODO: (mm) decide if this function is needed. This function is just pushing to localStorage.\nconst tempFn=(key,info)=>{let infos=[];const result=localStorage.get(key);if(result){infos=JSON.parse(result);let found=false;let index=0;for(let element of infos){if(element.xpath===info.xpath&&element.selectedType===info.selectedType&&element.user===info.user&&element.group===info.group&&element.role===info.role&&element.workspace===info.workspace){found=true;break;}index+=1;}if(found){// move to front\nconst elem=infos[index];infos.splice(index,1);infos.unshift(elem);}else{if(infos.length===5){infos.pop();}infos.push(info);}}else{infos.push(info);}localStorage.publish(key,JSON.stringify(infos));};/**\n * Global click listener on the \"bubble down\" so this code is invoked first.\n * Collect information from the DOM for commands/tabs/tiles and notify all services.\n */export function initClickListener(){document.addEventListener('click',function(event){const commandElement=htmlUtils.getElementByXpath('./ancestor-or-self::*[@data-command-id]',event.target);if(commandElement){const cmdInfo=getCommandInfo(commandElement);tempFn('commandInformation',cmdInfo);notify2(cmdInfo);return;}const tabElement=htmlUtils.getElementByXpath('./ancestor-or-self::*[@tabkey]',event.target);if(tabElement){const tabInfo=getTabInfo(tabElement);tempFn('tabInformation',tabInfo);notify2(tabInfo);return;}const tileXpath='./ancestor-or-self::*[not(@data-locator=\\'tile-resizeButton\\')]/ancestor::*[contains(@class, \\'aw-tile-tileContainer\\') and @data-locator=\\'tile-container\\']';const tileElement=htmlUtils.getElementByXpath(tileXpath,event.target);if(tileElement){const tileInfo=getTileInfo(tileElement);tempFn('tileInformation',tileInfo);notify2(tileInfo);}},true);}/**\n * Register a service\n *\n * @param {String} serviceName name of service to register\n * @param {Object} service instance to register\n */export function registerService(serviceName,service){_services.push({name:serviceName,instance:service});}/**\n * Remove service registration\n *\n * @param {String} serviceName service name to un-register\n */export function unregisterService(serviceName){_services=_services.filter(function(value){return value.name!==serviceName;});}/**\n * capture current user gesture and publish-\n * TODO: (mm) delete this function and it's references\n * then re-name notify2 to notify\n * @param  {...currentContext} payload for callee service\n * @returns {Function} callback function for subscribed services\n */export const notify=async function(){};/**\n * Notify the registered services of the click information\n * gathered by the global click listener.\n *\n * @param  {Object} clickInfo - information gathered by the global click listener.\n */export function notify2(clickInfo){for(let service of _services){service.instance.notify(clickInfo);}}/**\n * Highlight widget as per widget context\n * TODO: (mm) move or delete this function, doesn't belong here.\n * @param {String} widgetType - can be tab, tile or command\n * @param {String} widgetId - 123\n * @param {String} selector params like target tab, command selector\n */export const highlightWidget=async(widgetType,widgetId,selector)=>{if(widgetType.toLowerCase()==='tab'){tabRegistryService.highlightTab(widgetId,selector);}else{commandHighlightService.highlightCommand(widgetId,selector);}};const exports={registerService,unregisterService,notify,highlightWidget,initClickListener};export default exports;","map":null,"metadata":{},"sourceType":"module"}