{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.resizeObserverService} which manages element callbacks and resize observe/unobserve.\n *\n * @module js/resizeObserver.service\n */\n\n/**\n * Resize observer service to manage element callbacks.\n */\nlet exports = {}; // members\n\nlet _observerInstance = null;\n\nlet _entryMap = new Map();\n/**\n * A helper service which allows performing custom actions when native DOM elements are resized.\n *\n *    const resizableElement = $element[ 0 ]; //The DOM element to observe\n *\n *    const observer = awResizeObserverService.observe( resizableElement, entry => {\n *      console.log( 'The element has been resized in DOM.' );\n *      console.log( entry.target ); // -> resizableElement\n *      console.log( entry.contentRect.width ); // -> e.g. '230px'\n *    } );\n *\n * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\n * under the hood. It does not support any polyfills for the browsers that don't support resize observer.\n */\n\n/**\n * Returns if this browser supports resize observer API\n */\n\n\nexport let supportsResizeObserver = () => {\n  return typeof window.ResizeObserver === 'function';\n};\n/**\n * Creates the single native observer shared across all `ResizeObserver` instances.\n *\n */\n\nlet initializeResizeObserver = () => {\n  if (!_observerInstance && supportsResizeObserver()) {\n    _observerInstance = new ResizeObserver(entries => {\n      entries.forEach(entry => {\n        if (_entryMap.has(entry.target)) {\n          _entryMap.get(entry.target)(entry);\n        }\n      });\n    });\n  }\n};\n/**\n * Registers a new resize callback for the DOM element.\n *\n * @param {HTMLElement} element\n * @param {Function} callback\n */\n\n\nexport let observe = (element, callback) => {\n  _entryMap.set(element, callback);\n\n  initializeResizeObserver();\n\n  _observerInstance.observe(element);\n  /**\n   * Destroys the observer which disables the `callback` passed to the observe method.\n   */\n\n\n  return () => {\n    _observerInstance.unobserve(element);\n\n    _entryMap.delete(element);\n  };\n};\nexports = {\n  observe,\n  supportsResizeObserver\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/layout/src/js/resizeObserver.service.js"],"names":["exports","_observerInstance","_entryMap","supportsResizeObserver","window","initializeResizeObserver","entries","entry","observe"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAIA,OAAO,GAAX,EAAA,C,CAEA;;AACA,IAAIC,iBAAiB,GAArB,IAAA;;AACA,IAAIC,SAAS,GAAG,IAAhB,GAAgB,EAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,OAAO,IAAIC,sBAAsB,GAAG,MAAM;EACtC,OAAO,OAAOC,MAAM,CAAb,cAAA,KAAP,UAAA;AADG,CAAA;AAIP;AACA;AACA;AACA;;AACA,IAAIC,wBAAwB,GAAG,MAAM;EACjC,IAAI,CAAA,iBAAA,IAAsBF,sBAA1B,EAAA,EAAqD;IACjDF,iBAAiB,GAAG,IAAA,cAAA,CAAoBK,OAAO,IAAI;MAC/CA,OAAO,CAAPA,OAAAA,CAAiBC,KAAK,IAAI;QACtB,IAAIL,SAAS,CAATA,GAAAA,CAAeK,KAAK,CAAxB,MAAIL,CAAJ,EAAoC;UAChCA,SAAS,CAATA,GAAAA,CAAeK,KAAK,CAApBL,MAAAA,EAAAA,KAAAA;QACH;MAHLI,CAAAA;IADJL,CAAoB,CAApBA;EAOH;AATL,CAAA;AAYA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIO,OAAO,GAAG,CAAA,OAAA,EAAA,QAAA,KAAyB;EAC1CN,SAAS,CAATA,GAAAA,CAAAA,OAAAA,EAAAA,QAAAA;;EACAG,wBAAwB;;EACxBJ,iBAAiB,CAAjBA,OAAAA,CAAAA,OAAAA;EAEA;AACJ;AACA;;;EACI,OAAO,MAAM;IACTA,iBAAiB,CAAjBA,SAAAA,CAAAA,OAAAA;;IACAC,SAAS,CAATA,MAAAA,CAAAA,OAAAA;EAFJ,CAAA;AARG,CAAA;AAcPF,OAAO,GAAG;EAAA,OAAA;EAENG;AAFM,CAAVH;AAKA,eAAA,OAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.resizeObserverService} which manages element callbacks and resize observe/unobserve.\n *\n * @module js/resizeObserver.service\n */\n\n/**\n * Resize observer service to manage element callbacks.\n */\nlet exports = {};\n\n// members\nlet _observerInstance = null;\nlet _entryMap = new Map();\n\n/**\n * A helper service which allows performing custom actions when native DOM elements are resized.\n *\n *    const resizableElement = $element[ 0 ]; //The DOM element to observe\n *\n *    const observer = awResizeObserverService.observe( resizableElement, entry => {\n *      console.log( 'The element has been resized in DOM.' );\n *      console.log( entry.target ); // -> resizableElement\n *      console.log( entry.contentRect.width ); // -> e.g. '230px'\n *    } );\n *\n * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\n * under the hood. It does not support any polyfills for the browsers that don't support resize observer.\n */\n\n/**\n * Returns if this browser supports resize observer API\n */\nexport let supportsResizeObserver = () => {\n    return typeof window.ResizeObserver === 'function';\n};\n\n/**\n * Creates the single native observer shared across all `ResizeObserver` instances.\n *\n */\nlet initializeResizeObserver = () => {\n    if( !_observerInstance && supportsResizeObserver() ) {\n        _observerInstance = new ResizeObserver( entries => {\n            entries.forEach( entry => {\n                if( _entryMap.has( entry.target ) ) {\n                    _entryMap.get( entry.target )( entry );\n                }\n            } );\n        } );\n    }\n};\n\n/**\n * Registers a new resize callback for the DOM element.\n *\n * @param {HTMLElement} element\n * @param {Function} callback\n */\nexport let observe = ( element, callback ) => {\n    _entryMap.set( element, callback );\n    initializeResizeObserver();\n    _observerInstance.observe( element );\n\n    /**\n     * Destroys the observer which disables the `callback` passed to the observe method.\n     */\n    return () => {\n        _observerInstance.unobserve( element );\n        _entryMap.delete( element );\n    };\n};\n\nexports = {\n    observe,\n    supportsResizeObserver\n};\n\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}