{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editHandlerFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport appCtxSvc from 'js/appCtxService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport dms from 'soa/dataManagementService';\nimport editEventsService from 'js/editEventsService';\nimport eventBus from 'js/eventBus';\nimport leavePlaceService from 'js/leavePlace.service';\nimport localeSvc from 'js/localeService';\nimport logger from 'js/logger';\nimport messagingSvc from 'js/messagingService';\nimport notySvc from 'js/NotyModule';\nimport parsingUtils from 'js/parsingUtils';\nimport policySvc from 'soa/kernel/propertyPolicyService';\nimport saveHandlerService from 'js/saveHandlerService';\nimport soaSvc from 'soa/kernel/soaService';\nimport uwPropertyService from 'js/uwPropertyService';\nimport vmsvc from 'js/viewModelObjectService'; // Various services\n\nvar exports = {};\nlet preSaveActionsCounter = 0; //  Registration counter for preSave Actions.\n\nlet preSaveActions = {};\n/**\n * Create edit handler\n *\n * @param {Object} dataSource - the dataSource we're associating the edit handler with\n * @param {Array} editSupportParamKeys - the url parameters which are allowed to change during edit mode\n *\n * @return {Object} edit handler object\n */\n\nexport let createEditHandler = function (dataSourceArg, editSupportParamKeys) {\n  var editHandler = {\n    // Mark this handler as native - checked from GWT jsni code\n    isNative: true,\n    _editing: false,\n    canEdit: false\n  };\n  var dataSource = dataSourceArg;\n  var _singleLeaveConfirmation = null;\n  var _multiLeaveConfirmation = null;\n  var _saveTxt = null;\n  var _discardTxt = null;\n  var _validationError = null;\n  var _xrtViewModelSvc = null;\n  let _isDestroyed = false;\n  let _leaveHandler = null;\n\n  if (localeSvc) {\n    localeSvc.getLocalizedTextFromKey('XRTMessages.navigationConfirmationSingle').then(result => _singleLeaveConfirmation = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.navigationConfirmationMultiple').then(result => _multiLeaveConfirmation = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.save').then(result => _saveTxt = result);\n    localeSvc.getLocalizedTextFromKey('XRTMessages.discard').then(result => _discardTxt = result);\n    localeSvc.getLocalizedTextFromKey('editHandlerMessages.validationError').then(result => _validationError = result);\n  }\n\n  let saveEditsListener = null;\n\n  const removeSaveListener = function () {\n    document.removeEventListener('keydown', saveEditsListener);\n  };\n\n  const addSaveListener = function (editOptions) {\n    removeSaveListener();\n\n    if (editOptions && editOptions.autoSave) {\n      saveEditsListener = editEventsService.saveEditsListener(editHandler, removeSaveListener);\n    } else {\n      saveEditsListener = editEventsService.saveEditsListener(null, removeSaveListener);\n    }\n\n    document.addEventListener('keydown', saveEditsListener);\n  };\n  /**\n   * Notify the save state changes\n   *\n   * @param {String} stateName - edit state name ('starting', 'saved', 'cancelling')\n   * @param {Boolean} fireEvents - fire modelObjectsUpdated events\n   * @param {Array} failureUids - the object uids that failed to save\n   * @param {Object} modifiedPropsMap - modified properties map\n   */\n\n\n  function _notifySaveStateChanged(stateName, fireEvents, failureUids, modifiedPropsMap) {\n    switch (stateName) {\n      case 'starting':\n        dataSource.checkEditableOnProperties();\n        addSaveListener();\n        break;\n\n      case 'saved':\n        dataSource.saveEditiableStates();\n        removeSaveListener();\n        break;\n\n      case 'canceling':\n        dataSource.resetEditiableStates();\n        removeSaveListener();\n        break;\n\n      case 'partialSave':\n        dataSource.updatePartialEditState(failureUids, modifiedPropsMap);\n        break;\n\n      default:\n        logger.error('Unexpected stateName value: ' + stateName);\n    }\n\n    if (fireEvents) {\n      var dataProvider = dataSource.getDataProvider();\n\n      if (dataProvider && dataProvider.viewModelCollection) {\n        eventBus.publish(dataProvider.name + '.modelObjectsUpdated', {\n          viewModelObjects: dataProvider.viewModelCollection.getLoadedViewModelObjects(),\n          totalObjectsFound: dataProvider.viewModelCollection.getTotalObjectsLoaded()\n        });\n      }\n    }\n\n    editHandler._editing = stateName === 'starting' || stateName === 'partialSave';\n\n    if (editHandler.editStateChangeDispatcher) {\n      editHandler.editStateChangeDispatcher({\n        type: 'SET_EDIT_STATE_CHANGED',\n        value: editHandler._editing\n      });\n    } // Add to the appCtx about the editing state\n\n\n    appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n    var context = {\n      state: stateName\n    };\n    context.dataSource = dataSource.getSourceObject();\n    context.failureUids = failureUids;\n    eventBus.publish('editHandlerStateChange', context);\n  }\n\n  const onlyEditSupportParamsChanging = function (newLocation, oldLocation, editSupportParamKeys) {\n    const newParams = newLocation.params;\n    const oldParams = oldLocation.params; // Return false if state name is changing\n\n    if (newLocation.state.name !== oldLocation.state.name) {\n      return false;\n    }\n\n    let selectionParamsSame = true;\n\n    for (let i = 0; i < editSupportParamKeys.length; i++) {\n      let param = editSupportParamKeys[i];\n\n      if (newParams[param] !== oldParams[param]) {\n        selectionParamsSame = false;\n      }\n    }\n\n    if (selectionParamsSame) {\n      return false;\n    } // Return false if the keys are not equal ( excluding the editSupportParamKeys )\n\n\n    let newParamsClone = JSON.parse(JSON.stringify(newParams));\n    let oldParamsClone = JSON.parse(JSON.stringify(oldParams));\n\n    for (let i = 0; i < editSupportParamKeys.length; i++) {\n      let param = editSupportParamKeys[i];\n      delete newParamsClone[param];\n      delete oldParamsClone[param];\n    }\n\n    if (!_.isEqual(Object.keys(newParamsClone), Object.keys(oldParamsClone))) {\n      return false;\n    } // Return false if one of the param values has changed ( excluding the v )\n\n\n    for (let key in newParamsClone) {\n      if (newParamsClone[key] !== oldParamsClone[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Reregisters the existing leaveHandler with the leavePlaceService\n   */\n\n\n  editHandler.reregisterLeaveHandler = function () {\n    leavePlaceService.registerLeaveHandler(_leaveHandler);\n  };\n  /**\n   * Start editing\n   *\n   * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n   * @return {Promise} response\n   */\n\n\n  editHandler.startEdit = function (editOptions) {\n    // Register with leave place service\n    _leaveHandler = {\n      okToLeave: function (targetNavDetails, newLocation, oldLocation) {\n        // Skip leaveConfirmation if editSupportParamKeys are the only part of the url that is changing.\n        if (editSupportParamKeys && newLocation && oldLocation && onlyEditSupportParamsChanging(newLocation, oldLocation, editSupportParamKeys)) {\n          return Promise.resolve({\n            clearLeaveHandler: false\n          });\n        }\n\n        return editHandler.leaveConfirmation();\n      }\n    };\n    leavePlaceService.registerLeaveHandler(_leaveHandler);\n    const isPropEditing = Boolean(editOptions);\n\n    if (!editOptions) {\n      editHandler._editing = true;\n    }\n\n    var viewModelObjectList = dataSource.getLoadedViewModelObjects(); // Get list of UIDs\n\n    var uidToVMMap = {};\n\n    if (isPropEditing) {\n      _.forEach(editOptions.vmos, function (viewModelObject) {\n        if (!uidToVMMap[viewModelObject.uid]) {\n          uidToVMMap[viewModelObject.uid] = [viewModelObject];\n        }\n      });\n    } else if (viewModelObjectList !== null) {\n      _.forEach(viewModelObjectList, function (viewModelObject) {\n        if (uidToVMMap[viewModelObject.uid]) {\n          var existingVMOs = uidToVMMap[viewModelObject.uid];\n          existingVMOs.push(viewModelObject);\n        } else {\n          uidToVMMap[viewModelObject.uid] = [viewModelObject];\n        }\n      });\n    }\n\n    let propMap = {};\n\n    if (isPropEditing) {\n      _.forEach(editOptions.vmos, function (vmo) {\n        propMap[vmo.uid] = editOptions.propertyNames;\n      });\n    } else {\n      propMap = dataSource.getPropertyMap();\n    }\n\n    var propPolicy = {\n      types: [{\n        name: 'BusinessObject',\n        properties: [{\n          name: 'is_modifiable'\n        }]\n      }]\n    };\n    var policyId = policySvc.register(propPolicy, 'startEditHandler_Policy', 'selected');\n    var input = {\n      inputs: []\n    };\n\n    if (propMap) {\n      _.forEach(propMap, function (value, key) {\n        dms.getLoadViewModelForEditingInput(input, key, value);\n      });\n    }\n\n    return dms.loadViewModelForEditing2(input.inputs).then(function (response) {\n      if (_isDestroyed) {\n        return;\n      }\n\n      let propNamesToUpdate = editOptions ? editOptions.propertyNames : [];\n      processJsonStringResponse(response.viewModelObjectsJsonStrings, uidToVMMap, propNamesToUpdate);\n\n      if (isPropEditing) {\n        for (let j = 0; j < editOptions.vmos.length; j++) {\n          for (let i = 0; i < editOptions.propertyNames.length; i++) {\n            const prop = editOptions.vmos[j].props[editOptions.propertyNames[i]];\n            uwPropertyService.setEditable(prop, true);\n            uwPropertyService.setEditState(prop, true, true, true);\n          }\n        }\n\n        addSaveListener(editOptions);\n      } else {\n        _notifySaveStateChanged('starting', true);\n      }\n\n      policySvc.unregister(policyId);\n      return response;\n    }, function (error) {\n      editHandler._editing = false;\n      policySvc.unregister(policyId);\n    });\n  };\n  /**\n   * This function processes the response and replace the existing viewModelObject with the newly created VMO\n   * @param {String[]} viewModelObjectsInJsonString - The viewModel objects json strings array\n   * @param {Object[]} uidToVMMap - the Ui to VM object map\n   * @param {String[]} [propsToUpdate] - (Optional) If provided, only these properties on the vmos with be updated\n   */\n\n\n  function processJsonStringResponse(viewModelObjectsInJsonString, uidToVMMap, propsToUpdate) {\n    var loadedObjects = dataSource.getLoadedViewModelObjects();\n\n    _.forEach(viewModelObjectsInJsonString, function (viewModelObjectJsonString) {\n      var responseObject = parsingUtils.parseJsonString(viewModelObjectJsonString);\n\n      if (responseObject && responseObject.objects && responseObject.objects.length > 0) {\n        _.forEach(responseObject.objects, function (serverVMO) {\n          var uid = serverVMO.uid;\n          var exisitingVMOs = uidToVMMap[uid] ? uidToVMMap[uid] : loadedObjects;\n          var updatedVMO = vmsvc.createViewModelObject(uid, 'EDIT', null, serverVMO);\n          vmsvc.updateSourceObjectPropertiesByViewModelObject(updatedVMO, exisitingVMOs, propsToUpdate);\n        });\n      }\n    });\n  }\n  /**\n   * Can we start editing?\n   *\n   * @return {Boolean} true if we can start editing\n   */\n\n\n  editHandler.canStartEdit = function () {\n    return dataSource.canStartEdit();\n  };\n  /**\n   * Is an edit in progress?\n   *\n   * @return {Boolean} true if we're editing\n   */\n\n\n  editHandler.editInProgress = function () {\n    return this._editing;\n  };\n  /**\n   * Cancel the current edit\n   *\n   * @param {Boolean} noPendingModifications - are there pending modifications? (optional)\n   * @param {Boolean} ignoreLeaveHandler - don't remove leave handler\n   */\n\n\n  editHandler.cancelEdits = function (noPendingModifications, ignoreLeaveHandler) {\n    if (!ignoreLeaveHandler) {\n      leavePlaceService.registerLeaveHandler(null);\n    }\n\n    _notifySaveStateChanged('canceling', !noPendingModifications);\n  };\n  /**\n   * Perform the actions post Save Edit\n   *\n   * @param {Boolean} saveSuccess Whether the save edit was successful\n   */\n\n\n  editHandler.saveEditsPostActions = function (saveSuccess) {\n    if (saveSuccess) {\n      leavePlaceService.registerLeaveHandler(null);\n    }\n\n    _notifySaveStateChanged('saved', saveSuccess);\n  };\n  /**\n   * Register preSaveAction.\n   * @param {String} preSaveActionName - The preSave function to be executed.\n   * @return {String} preSaveAction ID\n   */\n\n\n  editHandler.registerPreSaveAction = function (preSaveActionName) {\n    var nextId = ++preSaveActionsCounter;\n    var preSaveActionID = 'preSaveAction_' + nextId;\n    preSaveActions[preSaveActionID] = preSaveActionName;\n    return preSaveActionID;\n  };\n  /**\n   * unregister preSaveAction.\n   * @param {String} preSaveActionID - preSaveActionID\n   */\n\n\n  editHandler.unregisterPreSaveAction = function (preSaveActionID) {\n    if (preSaveActions && preSaveActions[preSaveActionID]) {\n      delete preSaveActions[preSaveActionID];\n    }\n  };\n\n  editHandler.setDataUpdater = editStateChangeDispatcher => {\n    editHandler.editStateChangeDispatcher = editStateChangeDispatcher;\n  };\n  /**\n   * Save the current edits\n   * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n   * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n   * @return {Promise} Promise that is resolved when save edit is complete\n   */\n\n\n  editHandler.saveEdits = function (isPartialSaveDisabled, isAutoSave) {\n    // Do not save edit if there are validation errors\n    // Execute preSaveActions if there are any.\n    _.forEach(preSaveActions, function (value) {\n      value();\n    });\n\n    let hasValidationErrors = false;\n    let editableViewModelProperties = dataSource.getAllEditableProperties();\n\n    for (let prop of editableViewModelProperties) {\n      if (prop.error && prop.error.length > 0) {\n        hasValidationErrors = true;\n        break;\n      }\n    }\n\n    if (hasValidationErrors) {\n      messagingSvc.showError(_validationError);\n\n      if (isPartialSaveDisabled) {\n        _notifySaveStateChanged('canceling', false);\n      }\n\n      return AwPromiseService.instance.reject(_validationError);\n    } // Get all properties that are modified\n\n\n    let modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n    let modifiedPropsMap = dataSource.getModifiedPropertiesMap(modifiedViewModelProperties); // Prepare the SOA input\n\n    let inputs = [];\n\n    _.forEach(modifiedPropsMap, modifiedObj => {\n      let viewModelObject = modifiedObj.viewModelObject;\n\n      if (!viewModelObject || !viewModelObject.uid) {\n        viewModelObject = {\n          uid: cdm.NULL_UID,\n          type: 'unknownType'\n        };\n      }\n\n      let viewModelProps = modifiedObj.viewModelProps; // 'sourceObjectLastSavedDate' and 'srcObjectTypeName' should be defined in viewModelProperty, if not then\n      // we need to extract that info from viewModelObject and assign it.\n\n      _.forEach(viewModelProps, prop => {\n        if (!prop.sourceObjectLastSavedDate && viewModelObject.props && viewModelObject.props.last_mod_date) {\n          prop.sourceObjectLastSavedDate = viewModelObject.props.last_mod_date.dbValues;\n        }\n\n        if (!prop.srcObjectTypeName && dataSource.getDataProvider() && dataSource.getDataProvider().columnConfig) {\n          let columns = dataSource.getDataProvider().columnConfig.columns;\n          let propInfo = columns.find(element => element.propertyName === prop.propertyName);\n\n          if (propInfo) {\n            prop.srcObjectTypeName = propInfo.typeName;\n          }\n        }\n      });\n\n      let input = dms.getSaveViewModelEditAndSubmitToWorkflowInput(viewModelObject);\n\n      _.forEach(viewModelProps, props => dms.pushViewModelProperty(input, props));\n\n      inputs.push(input);\n    }); // Ensure editing flag is set temporarily to ensure correct saveHandler is retrieved\n\n\n    if (isAutoSave) {\n      editHandler._editing = true;\n      appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n    }\n\n    let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ? dataSource.getDeclViewModel().getAtomicData() : null;\n    let evaluationContext = atomicData ? {\n      pageContext: atomicData.pageContext\n    } : {\n      pageContext: null\n    };\n    let saveHandlerPromise = saveHandlerService.getSaveServiceHandlers([dataSource.getContextVMO()], evaluationContext);\n    let saveHandler = null;\n    return saveHandlerPromise.then(saveHandlers => {\n      // Unset editing flag now that saveHandlers are retrieved and to prevent save/cancel edit command appearing\n      if (isAutoSave) {\n        editHandler._editing = false;\n        appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n      }\n\n      let appSaveHandler = saveHandlers ? saveHandlers[0] : [];\n\n      if (appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty) {\n        saveHandler = appSaveHandler;\n      }\n    }).then(() => {\n      if (saveHandler) {\n        return saveHandler.isDirty(dataSource);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(isDirty => {\n      if (saveHandler && isDirty) {\n        return saveHandler.saveEdits(dataSource, inputs);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(() => {\n      if (saveHandler) {\n        editHandler.saveEditsPostActions(true);\n        return false;\n      }\n\n      return true;\n    }).then(saveHandlerActive => {\n      if (saveHandlerActive && inputs.length > 0) {\n        dataSource.registerPropPolicy();\n        return dms.saveViewModelEditAndSubmitWorkflow(inputs);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }).then(response => {\n      if (response) {\n        let error = null;\n\n        if (response.partialErrors || response.PartialErrors) {\n          error = soaSvc.createError(response);\n        } else if (response.ServiceData && response.ServiceData.partialErrors) {\n          error = soaSvc.createError(response.ServiceData);\n        }\n\n        if (error) {\n          let failureUids = [];\n\n          _.forEach(error.cause.partialErrors, partialError => failureUids.push(partialError.clientId));\n\n          updateLsdForPartialSavedVmos(response.viewModelObjectsJsonString, modifiedPropsMap);\n\n          if (isPartialSaveDisabled) {\n            _notifySaveStateChanged('canceling', false);\n          } else {\n            _notifySaveStateChanged('partialSave', false, failureUids, modifiedPropsMap);\n          }\n\n          let errMessage = messagingSvc.getSOAErrorMessage(error);\n          messagingSvc.showError(errMessage);\n          dataSource.unregisterPropPolicy();\n          return AwPromiseService.instance.resolve();\n        }\n      }\n\n      editHandler.saveEditsPostActions(true);\n      dataSource.unregisterPropPolicy();\n      return AwPromiseService.instance.resolve();\n    }, error => {\n      dataSource.unregisterPropPolicy();\n\n      if (error) {\n        if (isPartialSaveDisabled) {\n          _notifySaveStateChanged('canceling', false);\n        }\n\n        return AwPromiseService.instance.reject(error);\n      }\n    });\n  };\n  /**\n   * In case of partial save, update the LSD for partiaqlly saved view model objects\n   *\n   * @param {String} viewModelObjectsJsonString - VMO JSON string\n   * @param {Object} modifiedPropsMap - Map of modified properties\n   */\n\n\n  function updateLsdForPartialSavedVmos(viewModelObjectsJsonString, modifiedPropsMap) {\n    _.forEach(viewModelObjectsJsonString, function (viewModelObjectJsonString) {\n      var responseObject = parsingUtils.parseJsonString(viewModelObjectJsonString);\n\n      if (responseObject && responseObject.objects && responseObject.objects.length > 0) {\n        _.forEach(responseObject.objects, function (serverVMO) {\n          var uid = serverVMO.uid;\n\n          if (modifiedPropsMap[uid]) {\n            var modifiedProps = modifiedPropsMap[uid].viewModelProps;\n\n            _.forEach(modifiedProps, function _iterateModifiedVmoProps(modifiedProp) {\n              var serverVmoProp = serverVMO.props[modifiedProp.propertyName];\n\n              if (serverVmoProp) {\n                modifiedProp.sourceObjectLastSavedDate = serverVmoProp.srcObjLsd;\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n  /**\n   * Create noty button\n   *\n   * @param {String} label\n   * @param {Function} callback\n   *\n   * @return {Object} button object\n   */\n\n\n  function createButton(label, callback) {\n    return {\n      addClass: 'btn btn-notify',\n      text: label,\n      onClick: callback\n    };\n  }\n  /**\n   * Check for dirty edits.\n   *\n   * @return {boolean} value based on viewmodel has some unsaved edits\n   */\n\n\n  editHandler.isDirty = function () {\n    var self = this;\n    var isDirty = false;\n\n    if (self.editInProgress()) {\n      var modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n      var gwtViewModels = dataSource.getGwtVMs();\n\n      if (modifiedViewModelProperties && modifiedViewModelProperties.length > 0) {\n        return AwPromiseService.instance.when(true);\n      }\n\n      if (dataSource.hasxrtBasedViewModel() && !isDirty && gwtViewModels.length > 0 && _xrtViewModelSvc) {\n        _.forEach(gwtViewModels, function (gwtVM) {\n          isDirty = _xrtViewModelSvc.isViewModelDirty(gwtVM);\n\n          if (isDirty) {\n            return false; // to break the loop\n          }\n        });\n\n        return AwPromiseService.instance.when(isDirty);\n      }\n\n      let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ? dataSource.getDeclViewModel().getAtomicData() : null;\n      let evaluationContext = atomicData ? {\n        pageContext: atomicData.pageContext\n      } : {\n        pageContext: null\n      };\n      var saveHandlerPromise = saveHandlerService.getSaveServiceHandlers([dataSource.getContextVMO()], evaluationContext);\n      return saveHandlerPromise.then(function (saveHandlers) {\n        var appSaveHandler = saveHandlers ? saveHandlers[0] : null;\n\n        if (appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty) {\n          return appSaveHandler;\n        }\n      }).then(function (saveHandler) {\n        if (saveHandler) {\n          return saveHandler.isDirty(dataSource);\n        }\n\n        return AwPromiseService.instance.when(false);\n      });\n    }\n\n    return AwPromiseService.instance.when(false);\n  };\n  /**\n   * get the datasource from the xrt\n   *\n   * @return {Object} dataSource - dataSource of the modified page\n   */\n\n\n  editHandler.getDataSource = function () {\n    return dataSource;\n  };\n\n  editHandler.setDataSource = function (newDataSource) {\n    dataSource = newDataSource;\n    editHandler.checkCanEdit();\n  };\n  /**\n   * Display a notification message. Prevents duplicate popups from being active at the same time.\n   *\n   * @return {Promise} A promise resolved when option in popup is selected\n   */\n\n\n  var displayNotyMessage = function () {\n    // If a popup is already active just return existing promise\n    if (!editHandler._deferredPopup) {\n      editHandler._deferredPopup = AwPromiseService.instance.defer();\n      var message = _multiLeaveConfirmation;\n      var modifiedObject = null;\n      var multipleObjects = false;\n      var modifiedViewModelProperties = dataSource.getAllModifiedPropertiesWithVMO();\n\n      if (modifiedViewModelProperties !== null) {\n        _.forEach(modifiedViewModelProperties, function (modifiedProperty) {\n          var currentModifiedObject = modifiedProperty.viewModelObject;\n\n          if (modifiedObject === null) {\n            modifiedObject = currentModifiedObject;\n          } else if (modifiedObject !== null && modifiedObject !== currentModifiedObject) {\n            multipleObjects = true;\n          }\n        });\n      }\n\n      if (!multipleObjects) {\n        if (!modifiedObject) {\n          modifiedObject = dataSource.getSourceObject().vmo;\n\n          if (!modifiedObject && dataSource.getSourceObject().getAtomicData) {\n            modifiedObject = dataSource.getSourceObject().getAtomicData().xrtVMO;\n          }\n        }\n        /*\n           In case of the objects where object_string is empty , make use of the object_name if it is present on the VMO.\n           else it will show the defualt message.\n        */\n\n\n        if (modifiedObject) {\n          var objectDataToReplace = modifiedObject.props.object_string && modifiedObject.props.object_string.uiValue || modifiedObject.props.object_name && modifiedObject.props.object_name.uiValue;\n\n          if (objectDataToReplace) {\n            message = _singleLeaveConfirmation.replace('{0}', objectDataToReplace);\n          }\n        }\n      }\n\n      var buttonArray = [];\n      buttonArray.push(createButton(_discardTxt, function ($noty) {\n        $noty.close();\n        editHandler.cancelEdits();\n\n        editHandler._deferredPopup.resolve();\n\n        editHandler._deferredPopup = null;\n      }));\n      buttonArray.push(createButton(_saveTxt, function ($noty) {\n        $noty.close(); // partial save is disabled, because after save it will be navigating away \n\n        editHandler.saveEdits(true).then(function () {\n          editHandler._deferredPopup.resolve();\n\n          editHandler._deferredPopup = null;\n        }, function () {\n          editHandler._deferredPopup.resolve();\n\n          editHandler._deferredPopup = null;\n        });\n      }));\n      notySvc.showWarning(message, buttonArray);\n      return editHandler._deferredPopup.promise;\n    }\n\n    return editHandler._deferredPopup.promise;\n  };\n  /**\n   * Leave confirmation. If passed a callback will call the callback once it is ok to leave. Returns a promise\n   * that is resolved when it is ok to leave.\n   *\n   * @param {Object} callback - async callback\n   * @return {Promise} - promise that is resolved when leaveConfirmation is complete\n   */\n\n\n  editHandler.leaveConfirmation = function (callback) {\n    var self = this;\n    return self.isDirty().then(function (isDirty) {\n      return isDirty;\n    }).then(function (isDirty) {\n      if (isDirty) {\n        return displayNotyMessage().then(function () {\n          if (_.isFunction(callback)) {\n            callback();\n          }\n        });\n      } else if (dataSource && dataSource.hasxrtBasedViewModel() && self.editInProgress()) {\n        if (_xrtViewModelSvc && dataSource.getSourceObject().xrtData.xrtViewModel) {\n          _xrtViewModelSvc.checkEditHandler(dataSource.getSourceObject().xrtData.xrtViewModel).then(function () {\n            _notifySaveStateChanged('saved', false);\n\n            if (_.isFunction(callback)) {\n              callback();\n            }\n          });\n        }\n      } else {\n        editHandler.cancelEdits(true);\n\n        if (_.isFunction(callback)) {\n          callback();\n        }\n      }\n\n      return AwPromiseService.instance.resolve();\n    });\n  };\n\n  editHandler.canEditSubLocationObjects = function () {\n    return true;\n  };\n\n  editHandler.getSelection = function () {\n    var contextVMO = dataSource.getContextVMO();\n\n    if (contextVMO) {\n      return cdm.getObject(contextVMO.uid);\n    }\n\n    return null;\n  };\n\n  editHandler.destroy = function () {\n    // Only deregister the leave handler if we are sure this edit handler's leave handler is the one registered\n    leavePlaceService.deregisterLeaveHandler(_leaveHandler);\n    removeSaveListener();\n    dataSource = null;\n    _isDestroyed = true;\n    editHandler.canEdit = false;\n    editHandler._editing = false;\n  }; //update status here\n\n\n  editHandler.checkCanEdit = function () {\n    editHandler.canEdit = dataSource.canStartEdit();\n    appCtxSvc.updateCtx('editInProgress', editHandler._editing);\n  };\n\n  return editHandler;\n};\nexports = {\n  createEditHandler\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","_","appCtxSvc","cdm","dms","editEventsService","eventBus","leavePlaceService","localeSvc","logger","messagingSvc","notySvc","parsingUtils","policySvc","saveHandlerService","soaSvc","uwPropertyService","vmsvc","exports","preSaveActionsCounter","preSaveActions","createEditHandler","dataSourceArg","editSupportParamKeys","editHandler","isNative","_editing","canEdit","dataSource","_singleLeaveConfirmation","_multiLeaveConfirmation","_saveTxt","_discardTxt","_validationError","_xrtViewModelSvc","_isDestroyed","_leaveHandler","getLocalizedTextFromKey","then","result","saveEditsListener","removeSaveListener","document","removeEventListener","addSaveListener","editOptions","autoSave","addEventListener","_notifySaveStateChanged","stateName","fireEvents","failureUids","modifiedPropsMap","checkEditableOnProperties","saveEditiableStates","resetEditiableStates","updatePartialEditState","error","dataProvider","getDataProvider","viewModelCollection","publish","name","viewModelObjects","getLoadedViewModelObjects","totalObjectsFound","getTotalObjectsLoaded","editStateChangeDispatcher","type","value","updateCtx","context","state","getSourceObject","onlyEditSupportParamsChanging","newLocation","oldLocation","newParams","params","oldParams","selectionParamsSame","i","length","param","newParamsClone","JSON","parse","stringify","oldParamsClone","isEqual","Object","keys","key","reregisterLeaveHandler","registerLeaveHandler","startEdit","okToLeave","targetNavDetails","Promise","resolve","clearLeaveHandler","leaveConfirmation","isPropEditing","Boolean","viewModelObjectList","uidToVMMap","forEach","vmos","viewModelObject","uid","existingVMOs","push","propMap","vmo","propertyNames","getPropertyMap","propPolicy","types","properties","policyId","register","input","inputs","getLoadViewModelForEditingInput","loadViewModelForEditing2","response","propNamesToUpdate","processJsonStringResponse","viewModelObjectsJsonStrings","j","prop","props","setEditable","setEditState","unregister","viewModelObjectsInJsonString","propsToUpdate","loadedObjects","viewModelObjectJsonString","responseObject","parseJsonString","objects","serverVMO","exisitingVMOs","updatedVMO","createViewModelObject","updateSourceObjectPropertiesByViewModelObject","canStartEdit","editInProgress","cancelEdits","noPendingModifications","ignoreLeaveHandler","saveEditsPostActions","saveSuccess","registerPreSaveAction","preSaveActionName","nextId","preSaveActionID","unregisterPreSaveAction","setDataUpdater","saveEdits","isPartialSaveDisabled","isAutoSave","hasValidationErrors","editableViewModelProperties","getAllEditableProperties","showError","instance","reject","modifiedViewModelProperties","getAllModifiedProperties","getModifiedPropertiesMap","modifiedObj","NULL_UID","viewModelProps","sourceObjectLastSavedDate","last_mod_date","dbValues","srcObjectTypeName","columnConfig","columns","propInfo","find","element","propertyName","typeName","getSaveViewModelEditAndSubmitToWorkflowInput","pushViewModelProperty","atomicData","getDeclViewModel","getAtomicData","evaluationContext","pageContext","saveHandlerPromise","getSaveServiceHandlers","getContextVMO","saveHandler","saveHandlers","appSaveHandler","isDirty","saveHandlerActive","registerPropPolicy","saveViewModelEditAndSubmitWorkflow","partialErrors","PartialErrors","createError","ServiceData","cause","partialError","clientId","updateLsdForPartialSavedVmos","viewModelObjectsJsonString","errMessage","getSOAErrorMessage","unregisterPropPolicy","modifiedProps","_iterateModifiedVmoProps","modifiedProp","serverVmoProp","srcObjLsd","createButton","label","callback","addClass","text","onClick","self","gwtViewModels","getGwtVMs","when","hasxrtBasedViewModel","gwtVM","isViewModelDirty","getDataSource","setDataSource","newDataSource","checkCanEdit","displayNotyMessage","_deferredPopup","defer","message","modifiedObject","multipleObjects","getAllModifiedPropertiesWithVMO","modifiedProperty","currentModifiedObject","xrtVMO","objectDataToReplace","object_string","uiValue","object_name","replace","buttonArray","$noty","close","showWarning","promise","isFunction","xrtData","xrtViewModel","checkEditHandler","canEditSubLocationObjects","getSelection","contextVMO","getObject","destroy","deregisterLeaveHandler"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/editHandlerFactory.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editHandlerFactory\n */\n\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport appCtxSvc from 'js/appCtxService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport dms from 'soa/dataManagementService';\nimport editEventsService from 'js/editEventsService';\nimport eventBus from 'js/eventBus';\nimport leavePlaceService from 'js/leavePlace.service';\nimport localeSvc from 'js/localeService';\nimport logger from 'js/logger';\nimport messagingSvc from 'js/messagingService';\nimport notySvc from 'js/NotyModule';\nimport parsingUtils from 'js/parsingUtils';\nimport policySvc from 'soa/kernel/propertyPolicyService';\nimport saveHandlerService from 'js/saveHandlerService';\nimport soaSvc from 'soa/kernel/soaService';\nimport uwPropertyService from 'js/uwPropertyService';\nimport vmsvc from 'js/viewModelObjectService';\n\n// Various services\n\nvar exports = {};\nlet preSaveActionsCounter = 0; //  Registration counter for preSave Actions.\nlet preSaveActions = {};\n\n/**\n * Create edit handler\n *\n * @param {Object} dataSource - the dataSource we're associating the edit handler with\n * @param {Array} editSupportParamKeys - the url parameters which are allowed to change during edit mode\n *\n * @return {Object} edit handler object\n */\nexport let createEditHandler = function( dataSourceArg, editSupportParamKeys ) {\n    var editHandler = {\n        // Mark this handler as native - checked from GWT jsni code\n        isNative: true,\n        _editing: false,\n        canEdit: false\n    };\n    var dataSource = dataSourceArg;\n    var _singleLeaveConfirmation = null;\n    var _multiLeaveConfirmation = null;\n    var _saveTxt = null;\n    var _discardTxt = null;\n    var _validationError = null;\n    var _xrtViewModelSvc = null;\n    let _isDestroyed = false;\n    let _leaveHandler = null;\n\n    if( localeSvc ) {\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.navigationConfirmationSingle' ).then( result => _singleLeaveConfirmation = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.navigationConfirmationMultiple' ).then( result => _multiLeaveConfirmation = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.save' ).then( result => _saveTxt = result );\n        localeSvc.getLocalizedTextFromKey( 'XRTMessages.discard' ).then( result => _discardTxt = result );\n        localeSvc.getLocalizedTextFromKey( 'editHandlerMessages.validationError' ).then( result => _validationError = result );\n    }\n\n    let saveEditsListener = null;\n\n    const removeSaveListener = function() {\n        document.removeEventListener( 'keydown', saveEditsListener );\n    };\n\n    const addSaveListener = function( editOptions ) {\n        removeSaveListener();\n        if( editOptions && editOptions.autoSave ) {\n            saveEditsListener = editEventsService.saveEditsListener( editHandler, removeSaveListener );\n        } else {\n            saveEditsListener = editEventsService.saveEditsListener( null, removeSaveListener );\n        }\n        document.addEventListener( 'keydown', saveEditsListener );\n    };\n\n    /**\n     * Notify the save state changes\n     *\n     * @param {String} stateName - edit state name ('starting', 'saved', 'cancelling')\n     * @param {Boolean} fireEvents - fire modelObjectsUpdated events\n     * @param {Array} failureUids - the object uids that failed to save\n     * @param {Object} modifiedPropsMap - modified properties map\n     */\n    function _notifySaveStateChanged( stateName, fireEvents, failureUids, modifiedPropsMap ) {\n        switch ( stateName ) {\n            case 'starting':\n                dataSource.checkEditableOnProperties();\n                addSaveListener();\n                break;\n            case 'saved':\n                dataSource.saveEditiableStates();\n                removeSaveListener();\n                break;\n            case 'canceling':\n                dataSource.resetEditiableStates();\n                removeSaveListener();\n                break;\n            case 'partialSave':\n                dataSource.updatePartialEditState( failureUids, modifiedPropsMap );\n                break;\n            default:\n                logger.error( 'Unexpected stateName value: ' + stateName );\n        }\n\n        if( fireEvents ) {\n            var dataProvider = dataSource.getDataProvider();\n            if( dataProvider && dataProvider.viewModelCollection ) {\n                eventBus.publish( dataProvider.name + '.modelObjectsUpdated', {\n                    viewModelObjects: dataProvider.viewModelCollection.getLoadedViewModelObjects(),\n                    totalObjectsFound: dataProvider.viewModelCollection.getTotalObjectsLoaded()\n                } );\n            }\n        }\n\n        editHandler._editing = stateName === 'starting' || stateName === 'partialSave';\n        if( editHandler.editStateChangeDispatcher ) {\n            editHandler.editStateChangeDispatcher( {\n                type: 'SET_EDIT_STATE_CHANGED',\n                value: editHandler._editing\n            } );\n        }\n\n        // Add to the appCtx about the editing state\n        appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n\n        var context = {\n            state: stateName\n        };\n\n        context.dataSource = dataSource.getSourceObject();\n        context.failureUids = failureUids;\n        eventBus.publish( 'editHandlerStateChange', context );\n    }\n\n    const onlyEditSupportParamsChanging = function( newLocation, oldLocation, editSupportParamKeys ) {\n        const newParams = newLocation.params;\n        const oldParams = oldLocation.params;\n\n        // Return false if state name is changing\n        if( newLocation.state.name !== oldLocation.state.name ) {\n            return false;\n        }\n\n        let selectionParamsSame = true;\n        for( let i = 0; i < editSupportParamKeys.length; i++ ) {\n            let param = editSupportParamKeys[ i ];\n            if( newParams[ param ] !== oldParams[ param ] ) {\n                selectionParamsSame = false;\n            }\n        }\n        if( selectionParamsSame ) {\n            return false;\n        }\n\n        // Return false if the keys are not equal ( excluding the editSupportParamKeys )\n        let newParamsClone = JSON.parse( JSON.stringify( newParams ) );\n        let oldParamsClone = JSON.parse( JSON.stringify( oldParams ) );\n        for( let i = 0; i < editSupportParamKeys.length; i++ ) {\n            let param = editSupportParamKeys[ i ];\n            delete newParamsClone[ param ];\n            delete oldParamsClone[ param ];\n        }\n        if( !_.isEqual( Object.keys( newParamsClone ), Object.keys( oldParamsClone ) ) ) {\n            return false;\n        }\n\n        // Return false if one of the param values has changed ( excluding the v )\n        for( let key in newParamsClone ) {\n            if( newParamsClone[ key ] !== oldParamsClone[ key ] ) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Reregisters the existing leaveHandler with the leavePlaceService\n     */\n    editHandler.reregisterLeaveHandler = function() {\n        leavePlaceService.registerLeaveHandler( _leaveHandler );\n    };\n\n    /**\n     * Start editing\n     *\n     * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n     * @return {Promise} response\n     */\n    editHandler.startEdit = function( editOptions ) {\n        // Register with leave place service\n        _leaveHandler = {\n            okToLeave: function( targetNavDetails, newLocation, oldLocation ) {\n                // Skip leaveConfirmation if editSupportParamKeys are the only part of the url that is changing.\n                if( editSupportParamKeys && newLocation && oldLocation && onlyEditSupportParamsChanging( newLocation, oldLocation, editSupportParamKeys ) ) {\n                    return Promise.resolve( { clearLeaveHandler: false } );\n                }\n                return editHandler.leaveConfirmation();\n            }\n        };\n        leavePlaceService.registerLeaveHandler( _leaveHandler );\n\n        const isPropEditing = Boolean( editOptions );\n\n        if( !editOptions ) {\n            editHandler._editing = true;\n        }\n        var viewModelObjectList = dataSource.getLoadedViewModelObjects();\n\n        // Get list of UIDs\n        var uidToVMMap = {};\n        if( isPropEditing ) {\n            _.forEach( editOptions.vmos, function( viewModelObject ) {\n                if( !uidToVMMap[ viewModelObject.uid ] ) {\n                    uidToVMMap[ viewModelObject.uid ] = [ viewModelObject ];\n                }\n            } );\n        } else if( viewModelObjectList !== null ) {\n            _.forEach( viewModelObjectList, function( viewModelObject ) {\n                if( uidToVMMap[ viewModelObject.uid ] ) {\n                    var existingVMOs = uidToVMMap[ viewModelObject.uid ];\n                    existingVMOs.push( viewModelObject );\n                } else {\n                    uidToVMMap[ viewModelObject.uid ] = [ viewModelObject ];\n                }\n            } );\n        }\n\n        let propMap = {};\n        if( isPropEditing ) {\n            _.forEach( editOptions.vmos, function( vmo ) {\n                propMap[ vmo.uid ] = editOptions.propertyNames;\n            } );\n        } else {\n            propMap = dataSource.getPropertyMap();\n        }\n\n        var propPolicy = {\n            types: [ {\n                name: 'BusinessObject',\n                properties: [ {\n                    name: 'is_modifiable'\n                } ]\n            } ]\n        };\n\n        var policyId = policySvc.register( propPolicy, 'startEditHandler_Policy', 'selected' );\n\n        var input = {\n            inputs: []\n        };\n        if( propMap ) {\n            _.forEach( propMap, function( value, key ) {\n                dms.getLoadViewModelForEditingInput( input, key, value );\n            } );\n        }\n\n        return dms.loadViewModelForEditing2( input.inputs ).then( function( response ) {\n            if( _isDestroyed ) {\n                return;\n            }\n            let propNamesToUpdate = editOptions ? editOptions.propertyNames : [];\n            processJsonStringResponse( response.viewModelObjectsJsonStrings, uidToVMMap, propNamesToUpdate );\n            if( isPropEditing ) {\n                for( let j = 0; j < editOptions.vmos.length; j++ ) {\n                    for( let i = 0; i < editOptions.propertyNames.length; i++ ) {\n                        const prop = editOptions.vmos[ j ].props[ editOptions.propertyNames[ i ] ];\n                        uwPropertyService.setEditable( prop, true );\n                        uwPropertyService.setEditState( prop, true, true, true );\n                    }\n                }\n                addSaveListener( editOptions );\n            } else {\n                _notifySaveStateChanged( 'starting', true );\n            }\n            policySvc.unregister( policyId );\n            return response;\n        }, function( error ) {\n            editHandler._editing = false;\n            policySvc.unregister( policyId );\n        } );\n    };\n\n    /**\n     * This function processes the response and replace the existing viewModelObject with the newly created VMO\n     * @param {String[]} viewModelObjectsInJsonString - The viewModel objects json strings array\n     * @param {Object[]} uidToVMMap - the Ui to VM object map\n     * @param {String[]} [propsToUpdate] - (Optional) If provided, only these properties on the vmos with be updated\n     */\n    function processJsonStringResponse( viewModelObjectsInJsonString, uidToVMMap, propsToUpdate ) {\n        var loadedObjects = dataSource.getLoadedViewModelObjects();\n        _.forEach( viewModelObjectsInJsonString, function( viewModelObjectJsonString ) {\n            var responseObject = parsingUtils.parseJsonString( viewModelObjectJsonString );\n            if( responseObject && responseObject.objects && responseObject.objects.length > 0 ) {\n                _.forEach( responseObject.objects, function( serverVMO ) {\n                    var uid = serverVMO.uid;\n                    var exisitingVMOs = uidToVMMap[ uid ] ? uidToVMMap[ uid ] : loadedObjects;\n                    var updatedVMO = vmsvc.createViewModelObject( uid, 'EDIT', null, serverVMO );\n                    vmsvc.updateSourceObjectPropertiesByViewModelObject( updatedVMO, exisitingVMOs, propsToUpdate );\n                } );\n            }\n        } );\n    }\n\n    /**\n     * Can we start editing?\n     *\n     * @return {Boolean} true if we can start editing\n     */\n    editHandler.canStartEdit = function() {\n        return dataSource.canStartEdit();\n    };\n\n    /**\n     * Is an edit in progress?\n     *\n     * @return {Boolean} true if we're editing\n     */\n    editHandler.editInProgress = function() {\n        return this._editing;\n    };\n\n    /**\n     * Cancel the current edit\n     *\n     * @param {Boolean} noPendingModifications - are there pending modifications? (optional)\n     * @param {Boolean} ignoreLeaveHandler - don't remove leave handler\n     */\n    editHandler.cancelEdits = function( noPendingModifications, ignoreLeaveHandler ) {\n        if( !ignoreLeaveHandler ) {\n            leavePlaceService.registerLeaveHandler( null );\n        }\n        _notifySaveStateChanged( 'canceling', !noPendingModifications );\n    };\n\n    /**\n     * Perform the actions post Save Edit\n     *\n     * @param {Boolean} saveSuccess Whether the save edit was successful\n     */\n    editHandler.saveEditsPostActions = function( saveSuccess ) {\n        if( saveSuccess ) {\n            leavePlaceService.registerLeaveHandler( null );\n        }\n        _notifySaveStateChanged( 'saved', saveSuccess );\n    };\n\n    /**\n     * Register preSaveAction.\n     * @param {String} preSaveActionName - The preSave function to be executed.\n     * @return {String} preSaveAction ID\n     */\n    editHandler.registerPreSaveAction = function( preSaveActionName ) {\n        var nextId = ++preSaveActionsCounter;\n        var preSaveActionID = 'preSaveAction_' + nextId;\n        preSaveActions[ preSaveActionID ] = preSaveActionName;\n        return preSaveActionID;\n    };\n\n    /**\n     * unregister preSaveAction.\n     * @param {String} preSaveActionID - preSaveActionID\n     */\n    editHandler.unregisterPreSaveAction = function( preSaveActionID ) {\n        if( preSaveActions && preSaveActions[ preSaveActionID ] ) {\n            delete preSaveActions[ preSaveActionID ];\n        }\n    };\n\n    editHandler.setDataUpdater = ( editStateChangeDispatcher ) => {\n        editHandler.editStateChangeDispatcher = editStateChangeDispatcher;\n    };\n\n    /**\n     * Save the current edits\n     * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n     * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n     * @return {Promise} Promise that is resolved when save edit is complete\n     */\n    editHandler.saveEdits = function( isPartialSaveDisabled, isAutoSave ) {\n        // Do not save edit if there are validation errors\n\n        // Execute preSaveActions if there are any.\n        _.forEach( preSaveActions, function( value ) {\n            value();\n        } );\n        let hasValidationErrors = false;\n        let editableViewModelProperties = dataSource.getAllEditableProperties();\n        for( let prop of editableViewModelProperties ) {\n            if( prop.error && prop.error.length > 0 ) {\n                hasValidationErrors = true;\n                break;\n            }\n        }\n\n        if( hasValidationErrors ) {\n            messagingSvc.showError( _validationError );\n            if( isPartialSaveDisabled ) {\n                _notifySaveStateChanged( 'canceling', false );\n            }\n            return AwPromiseService.instance.reject( _validationError );\n        }\n\n        // Get all properties that are modified\n        let modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n        let modifiedPropsMap = dataSource.getModifiedPropertiesMap( modifiedViewModelProperties );\n\n        // Prepare the SOA input\n        let inputs = [];\n        _.forEach( modifiedPropsMap, modifiedObj => {\n            let viewModelObject = modifiedObj.viewModelObject;\n            if( !viewModelObject || !viewModelObject.uid ) {\n                viewModelObject = {\n                    uid: cdm.NULL_UID,\n                    type: 'unknownType'\n                };\n            }\n\n            let viewModelProps = modifiedObj.viewModelProps;\n\n            // 'sourceObjectLastSavedDate' and 'srcObjectTypeName' should be defined in viewModelProperty, if not then\n            // we need to extract that info from viewModelObject and assign it.\n            _.forEach( viewModelProps, prop => {\n                if( !prop.sourceObjectLastSavedDate && viewModelObject.props && viewModelObject.props.last_mod_date ) {\n                    prop.sourceObjectLastSavedDate = viewModelObject.props.last_mod_date.dbValues;\n                }\n                if( !prop.srcObjectTypeName && dataSource.getDataProvider() && dataSource.getDataProvider().columnConfig ) {\n                    let columns = dataSource.getDataProvider().columnConfig.columns;\n                    let propInfo = columns.find( element => element.propertyName === prop.propertyName );\n                    if( propInfo ) {\n                        prop.srcObjectTypeName = propInfo.typeName;\n                    }\n                }\n            } );\n\n            let input = dms.getSaveViewModelEditAndSubmitToWorkflowInput( viewModelObject );\n            _.forEach( viewModelProps, props => dms.pushViewModelProperty( input, props ) );\n            inputs.push( input );\n        } );\n\n        // Ensure editing flag is set temporarily to ensure correct saveHandler is retrieved\n        if( isAutoSave ) {\n            editHandler._editing = true;\n            appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n        }\n\n        let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ?\n            dataSource.getDeclViewModel().getAtomicData() : null;\n        let evaluationContext = atomicData ? { pageContext: atomicData.pageContext } : { pageContext: null };\n        let saveHandlerPromise = saveHandlerService.getSaveServiceHandlers( [ dataSource.getContextVMO() ], evaluationContext );\n        let saveHandler = null;\n\n        return saveHandlerPromise.then( saveHandlers => {\n            // Unset editing flag now that saveHandlers are retrieved and to prevent save/cancel edit command appearing\n            if( isAutoSave ) {\n                editHandler._editing = false;\n                appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n            }\n            let appSaveHandler = saveHandlers ? saveHandlers[ 0 ] : [];\n            if( appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty ) {\n                saveHandler = appSaveHandler;\n            }\n        } ).then( () => {\n            if( saveHandler ) {\n                return saveHandler.isDirty( dataSource );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( isDirty => {\n            if( saveHandler && isDirty ) {\n                return saveHandler.saveEdits( dataSource, inputs );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( () => {\n            if( saveHandler ) {\n                editHandler.saveEditsPostActions( true );\n                return false;\n            }\n            return true;\n        } ).then( saveHandlerActive => {\n            if( saveHandlerActive && inputs.length > 0 ) {\n                dataSource.registerPropPolicy();\n                return dms.saveViewModelEditAndSubmitWorkflow( inputs );\n            }\n            return AwPromiseService.instance.resolve();\n        } ).then( response => {\n            if( response ) {\n                let error = null;\n                if( response.partialErrors || response.PartialErrors ) {\n                    error = soaSvc.createError( response );\n                } else if( response.ServiceData && response.ServiceData.partialErrors ) {\n                    error = soaSvc.createError( response.ServiceData );\n                }\n\n                if( error ) {\n                    let failureUids = [];\n                    _.forEach( error.cause.partialErrors, partialError => failureUids.push( partialError.clientId ) );\n\n                    updateLsdForPartialSavedVmos( response.viewModelObjectsJsonString, modifiedPropsMap );\n                    if( isPartialSaveDisabled ) {\n                        _notifySaveStateChanged( 'canceling', false );\n                    } else {\n                        _notifySaveStateChanged( 'partialSave', false, failureUids, modifiedPropsMap );\n                    }\n\n                    let errMessage = messagingSvc.getSOAErrorMessage( error );\n                    messagingSvc.showError( errMessage );\n                    dataSource.unregisterPropPolicy();\n                    return AwPromiseService.instance.resolve();\n                }\n            }\n            editHandler.saveEditsPostActions( true );\n            dataSource.unregisterPropPolicy();\n            return AwPromiseService.instance.resolve();\n        }, error => {\n            dataSource.unregisterPropPolicy();\n            if( error ) {\n                if( isPartialSaveDisabled ) {\n                    _notifySaveStateChanged( 'canceling', false );\n                }\n                return AwPromiseService.instance.reject( error );\n            }\n        } );\n    };\n\n    /**\n     * In case of partial save, update the LSD for partiaqlly saved view model objects\n     *\n     * @param {String} viewModelObjectsJsonString - VMO JSON string\n     * @param {Object} modifiedPropsMap - Map of modified properties\n     */\n    function updateLsdForPartialSavedVmos( viewModelObjectsJsonString, modifiedPropsMap ) {\n        _.forEach( viewModelObjectsJsonString, function( viewModelObjectJsonString ) {\n            var responseObject = parsingUtils.parseJsonString( viewModelObjectJsonString );\n            if( responseObject && responseObject.objects && responseObject.objects.length > 0 ) {\n                _.forEach( responseObject.objects, function( serverVMO ) {\n                    var uid = serverVMO.uid;\n                    if( modifiedPropsMap[ uid ] ) {\n                        var modifiedProps = modifiedPropsMap[ uid ].viewModelProps;\n                        _.forEach( modifiedProps, function _iterateModifiedVmoProps( modifiedProp ) {\n                            var serverVmoProp = serverVMO.props[ modifiedProp.propertyName ];\n                            if( serverVmoProp ) {\n                                modifiedProp.sourceObjectLastSavedDate = serverVmoProp.srcObjLsd;\n                            }\n                        } );\n                    }\n                } );\n            }\n        } );\n    }\n\n    /**\n     * Create noty button\n     *\n     * @param {String} label\n     * @param {Function} callback\n     *\n     * @return {Object} button object\n     */\n    function createButton( label, callback ) {\n        return {\n            addClass: 'btn btn-notify',\n            text: label,\n            onClick: callback\n        };\n    }\n\n    /**\n     * Check for dirty edits.\n     *\n     * @return {boolean} value based on viewmodel has some unsaved edits\n     */\n    editHandler.isDirty = function() {\n        var self = this;\n        var isDirty = false;\n\n        if( self.editInProgress() ) {\n            var modifiedViewModelProperties = dataSource.getAllModifiedProperties();\n            var gwtViewModels = dataSource.getGwtVMs();\n            if( modifiedViewModelProperties && modifiedViewModelProperties.length > 0 ) {\n                return AwPromiseService.instance.when( true );\n            }\n\n            if( dataSource.hasxrtBasedViewModel() && !isDirty && gwtViewModels.length > 0 && _xrtViewModelSvc ) {\n                _.forEach( gwtViewModels, function( gwtVM ) {\n                    isDirty = _xrtViewModelSvc.isViewModelDirty( gwtVM );\n                    if( isDirty ) {\n                        return false; // to break the loop\n                    }\n                } );\n                return AwPromiseService.instance.when( isDirty );\n            }\n\n            let atomicData = dataSource.getDeclViewModel() && dataSource.getDeclViewModel().getAtomicData ?\n                dataSource.getDeclViewModel().getAtomicData() : null;\n            let evaluationContext = atomicData ? { pageContext: atomicData.pageContext } : { pageContext: null };\n            var saveHandlerPromise = saveHandlerService\n                .getSaveServiceHandlers( [ dataSource.getContextVMO() ], evaluationContext );\n            return saveHandlerPromise.then( function( saveHandlers ) {\n                var appSaveHandler = saveHandlers ? saveHandlers[ 0 ] : null;\n                if( appSaveHandler && appSaveHandler.saveEdits && appSaveHandler.isDirty ) {\n                    return appSaveHandler;\n                }\n            } ).then( function( saveHandler ) {\n                if( saveHandler ) {\n                    return saveHandler.isDirty( dataSource );\n                }\n                return AwPromiseService.instance.when( false );\n            } );\n        }\n        return AwPromiseService.instance.when( false );\n    };\n\n    /**\n     * get the datasource from the xrt\n     *\n     * @return {Object} dataSource - dataSource of the modified page\n     */\n    editHandler.getDataSource = function() {\n        return dataSource;\n    };\n\n    editHandler.setDataSource = function( newDataSource ) {\n        dataSource = newDataSource;\n        editHandler.checkCanEdit();\n    };\n\n    /**\n     * Display a notification message. Prevents duplicate popups from being active at the same time.\n     *\n     * @return {Promise} A promise resolved when option in popup is selected\n     */\n    var displayNotyMessage = function() {\n        // If a popup is already active just return existing promise\n        if( !editHandler._deferredPopup ) {\n            editHandler._deferredPopup = AwPromiseService.instance.defer();\n\n            var message = _multiLeaveConfirmation;\n            var modifiedObject = null;\n            var multipleObjects = false;\n\n            var modifiedViewModelProperties = dataSource.getAllModifiedPropertiesWithVMO();\n            if( modifiedViewModelProperties !== null ) {\n                _.forEach( modifiedViewModelProperties, function( modifiedProperty ) {\n                    var currentModifiedObject = modifiedProperty.viewModelObject;\n                    if( modifiedObject === null ) {\n                        modifiedObject = currentModifiedObject;\n                    } else if( modifiedObject !== null && modifiedObject !== currentModifiedObject ) {\n                        multipleObjects = true;\n                    }\n                } );\n            }\n\n            if( !multipleObjects ) {\n                if( !modifiedObject ) {\n                    modifiedObject = dataSource.getSourceObject().vmo;\n                    if( !modifiedObject && dataSource.getSourceObject().getAtomicData ) {\n                        modifiedObject = dataSource.getSourceObject().getAtomicData().xrtVMO;\n                    }\n                }\n                /*\n                   In case of the objects where object_string is empty , make use of the object_name if it is present on the VMO.\n                   else it will show the defualt message.\n                */\n                if( modifiedObject ) {\n                    var objectDataToReplace = modifiedObject.props.object_string && modifiedObject.props.object_string.uiValue ||\n                        modifiedObject.props.object_name && modifiedObject.props.object_name.uiValue;\n                    if( objectDataToReplace ) {\n                        message = _singleLeaveConfirmation.replace( '{0}', objectDataToReplace );\n                    }\n                }\n            }\n\n            var buttonArray = [];\n            buttonArray.push( createButton( _discardTxt, function( $noty ) {\n                $noty.close();\n                editHandler.cancelEdits();\n                editHandler._deferredPopup.resolve();\n                editHandler._deferredPopup = null;\n            } ) );\n            buttonArray.push( createButton( _saveTxt, function( $noty ) {\n                $noty.close();\n                // partial save is disabled, because after save it will be navigating away \n                editHandler.saveEdits( true ).then( function() {\n                    editHandler._deferredPopup.resolve();\n                    editHandler._deferredPopup = null;\n                }, function() {\n                    editHandler._deferredPopup.resolve();\n                    editHandler._deferredPopup = null;\n                } );\n            } ) );\n            notySvc.showWarning( message, buttonArray );\n\n            return editHandler._deferredPopup.promise;\n        }\n\n        return editHandler._deferredPopup.promise;\n    };\n\n    /**\n     * Leave confirmation. If passed a callback will call the callback once it is ok to leave. Returns a promise\n     * that is resolved when it is ok to leave.\n     *\n     * @param {Object} callback - async callback\n     * @return {Promise} - promise that is resolved when leaveConfirmation is complete\n     */\n    editHandler.leaveConfirmation = function( callback ) {\n        var self = this;\n        return self.isDirty().then( function( isDirty ) {\n            return isDirty;\n        } ).then(\n            function( isDirty ) {\n                if( isDirty ) {\n                    return displayNotyMessage().then( function() {\n                        if( _.isFunction( callback ) ) {\n                            callback();\n                        }\n                    } );\n                } else if( dataSource && dataSource.hasxrtBasedViewModel() && self.editInProgress() ) {\n                    if( _xrtViewModelSvc && dataSource.getSourceObject().xrtData.xrtViewModel ) {\n                        _xrtViewModelSvc.checkEditHandler( dataSource.getSourceObject().xrtData.xrtViewModel )\n                            .then( function() {\n                                _notifySaveStateChanged( 'saved', false );\n                                if( _.isFunction( callback ) ) {\n                                    callback();\n                                }\n                            } );\n                    }\n                } else {\n                    editHandler.cancelEdits( true );\n                    if( _.isFunction( callback ) ) {\n                        callback();\n                    }\n                }\n                return AwPromiseService.instance.resolve();\n            } );\n    };\n\n    editHandler.canEditSubLocationObjects = function() {\n        return true;\n    };\n\n    editHandler.getSelection = function() {\n        var contextVMO = dataSource.getContextVMO();\n        if( contextVMO ) {\n            return cdm.getObject( contextVMO.uid );\n        }\n        return null;\n    };\n\n    editHandler.destroy = function() {\n        // Only deregister the leave handler if we are sure this edit handler's leave handler is the one registered\n        leavePlaceService.deregisterLeaveHandler( _leaveHandler );\n        removeSaveListener();\n        dataSource = null;\n        _isDestroyed = true;\n        editHandler.canEdit = false;\n        editHandler._editing = false;\n    };\n\n    //update status here\n    editHandler.checkCanEdit = function() {\n        editHandler.canEdit = dataSource.canStartEdit();\n        appCtxSvc.updateCtx( 'editInProgress', editHandler._editing );\n    };\n\n    return editHandler;\n};\n\nexports = {\n    createEditHandler\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}