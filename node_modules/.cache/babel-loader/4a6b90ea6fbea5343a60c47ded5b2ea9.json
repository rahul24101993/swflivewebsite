{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context\n *\n * @publishedApolloService\n *\n * @module js/conditionService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport adapterService from 'js/adapterService';\nimport expressionParserUtils from 'js/expressionParserUtils';\nvar exports = {};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Any} The evaluated expression result.\n */\n\nexport let parseExpression = function (declViewModel, expression, evaluationEnv, depModuleObj) {\n  var evaluationContext = {};\n\n  _.assign(evaluationContext, declViewModel, evaluationEnv, depModuleObj);\n\n  if (_.isObject(expression)) {\n    // loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values\n    var updatedExpression = expressionParserUtils.updateDynamicValues(expression, evaluationContext);\n    return expressionParserUtils.evaluateExpressions(updatedExpression, evaluationContext, adapterService);\n  }\n\n  return AwParseService.instance(expression)(evaluationContext);\n};\n/**\n * Evaluate condition expression and ensure a boolean is returned\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Boolean} The evaluated condition result.\n */\n\nexport let evaluateCondition = function (declViewModel, expression, evaluationEnv, depModuleObj) {\n  return Boolean(exports.parseExpression(declViewModel, expression, evaluationEnv, depModuleObj));\n};\n\nconst _evaluateConditionBasedExpression = function (condition, declViewModel, evaluateDepParams) {\n  var finalConditionExpression;\n\n  if (_.startsWith(condition, 'conditions.')) {\n    if (declViewModel._internal) {\n      finalConditionExpression = _.get(declViewModel._internal, condition);\n    } else {\n      finalConditionExpression = _.get(evaluateDepParams.conditionList, condition);\n    }\n  } // for condition\": 'ctx.xyz || ctx.abc' or condition\": '!ctx.xyz' or condition\": '!conditions.xyz'\n\n\n  if (finalConditionExpression === undefined) {\n    finalConditionExpression = condition;\n  } else if (finalConditionExpression.expression) {\n    finalConditionExpression = finalConditionExpression.expression;\n  }\n\n  if (evaluateDepParams) {\n    return evaluateCondition(declViewModel, finalConditionExpression, evaluateDepParams.evaluationEnv, evaluateDepParams.depModuleObj);\n  }\n\n  return evaluateCondition(declViewModel, finalConditionExpression);\n};\n/**\n * Evaluate all variants of condition\n *\n * @param {String} condition - condition to evaluate\n * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object\n * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb\n *                                {Object} conditionList- Conditions object of viewmodel\n *                                {String} clauseName -\"activewhen\",\"visiblewhen\"\n *                                {Object} evaluationEnv -specific data required for this call like ctx.\n *                                {Object} depModuleObj\n * @return {Boolean} return true, if expression evalutes to true.\n */\n\n\nexport let evaluateConditionExpression = function (condition, declViewModel, evaluateDepParams) {\n  if (evaluateDepParams && typeof condition[evaluateDepParams.clauseName] === 'boolean') {\n    return condition[evaluateDepParams.clauseName];\n    /*\n     *    activewhen: true\n     */\n  } else if (evaluateDepParams && condition[evaluateDepParams.clauseName]) {\n    condition = _.get(condition, evaluateDepParams.clauseName + '.condition');\n\n    if (typeof condition === 'boolean') {\n      return condition;\n    }\n  }\n\n  if (condition && condition.length) {\n    /*\n      evaluate * conditions expression\n      *: {\n          condition: \"conditions.xyz\"\n      }\n      */\n    return _evaluateConditionBasedExpression(condition, declViewModel, evaluateDepParams);\n  }\n\n  return false;\n};\n/**\n * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of\n * the condition differs from the old value\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} queries - The array of objects containing query definitions\n * @param {Array} values - The array of objects of changed value to be used for each of the query object\n * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage\n * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed\n * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.\n * @param {Object} trackValues - Whether or not to track expression value changes.\n */\n\nlet processWatch = function (conditionStates, conditionName, queries, values, adaptExpressions, performAnd, conditionExpressions, trackValues, viewModelName) {\n  var oldValue = conditionStates[conditionName];\n  var newValue = queries.reduce(function (prevVerdict, currQuery, queryIndex) {\n    var verdict;\n    var valuesToUse = values[queryIndex];\n\n    if (currQuery && _.isObject(currQuery) && values && values.length === queries.length) {\n      // determine whether object requires to be adapted\n      if (adaptExpressions[queryIndex]) {\n        var valuesToAdapt = _.isArray(valuesToUse) ? valuesToUse : [valuesToUse];\n        valuesToUse = adapterService.getAdaptedObjectsSync(valuesToAdapt);\n      } // expression is an object, hence process the query object inside it\n\n\n      verdict = expressionParserUtils.evaluateExpressions(currQuery, valuesToUse, adapterService);\n    } else {\n      // expression is simple string with boolean result\n      verdict = Boolean(values && valuesToUse);\n    }\n\n    var newExpressionValue = valuesToUse;\n    var conditionVal;\n\n    if (conditionExpressions) {\n      conditionVal = conditionExpressions[conditionName];\n    }\n\n    if (trackValues && conditionExpressions && conditionVal[0] !== newExpressionValue) {\n      eventBus.publish('condition.expressionValueChanged', {\n        condition: 'conditions.' + conditionName,\n        oldValue: conditionExpressions[conditionName],\n        newValue: newExpressionValue\n      });\n    }\n\n    return performAnd ? prevVerdict && verdict : prevVerdict || verdict;\n  }, performAnd);\n\n  if (logger.isDeclarativeLogEnabled()) {\n    debugService.debugConditions(conditionName, newValue, queries, viewModelName);\n  }\n\n  if (oldValue !== newValue) {\n    eventBus.publish('condition.valueChanged', {\n      condition: 'conditions.' + conditionName,\n      oldValue: oldValue,\n      newValue: newValue\n    });\n  }\n};\n/**\n * Register a watch for given expression on provided scope and update conditionStates[conditionName] when\n * expression's value changes.\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} expressions - Array of expression to be watched for value change.\n * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.\n * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression\n * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback\n * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not\n * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing\n */\n\n\nexport let registerWatch = function (conditionStates, dataCtxNode, conditionName, expressions, conditionExpressions, queries, adaptExpressions, deepWatch, performAnd) {\n  if (!queries) {\n    var watchQueryAdaptInfo = {\n      watchers: [],\n      queries: [],\n      adapt: []\n    };\n    var multiAttributeANDExpression;\n    var multiAttributeORExpression;\n\n    _.forEach(expressions, function (expr) {\n      multiAttributeANDExpression = expr[expressionParserUtils.$AND];\n      multiAttributeORExpression = expr[expressionParserUtils.$OR];\n      var expressionsFinal = multiAttributeANDExpression || multiAttributeORExpression || expressions;\n\n      _.forEach(expressionsFinal, function (finalExpr) {\n        var sourceToWatch = expressionParserUtils.resolve(expressionParserUtils.$SOURCE, finalExpr);\n        var needsToAdapt = sourceToWatch && sourceToWatch[expressionParserUtils.$ADAPT];\n        sourceToWatch = needsToAdapt || sourceToWatch || finalExpr;\n        var executeQuery = expressionParserUtils.resolve(expressionParserUtils.$QUERY, finalExpr);\n        watchQueryAdaptInfo.watchers.push(sourceToWatch);\n        watchQueryAdaptInfo.queries.push(executeQuery || finalExpr);\n        watchQueryAdaptInfo.adapt.push(Boolean(needsToAdapt));\n      });\n    });\n\n    exports.registerWatch(conditionStates, dataCtxNode, conditionName, watchQueryAdaptInfo.watchers, conditionExpressions, watchQueryAdaptInfo.queries, watchQueryAdaptInfo.adapt, true, multiAttributeANDExpression);\n  } else {\n    // process expressions, queries and adaptExpressions array\n    var dynamicValueResolvedQueries = queries.map(function (query) {\n      return expressionParserUtils.updateDynamicValues(query, dataCtxNode);\n    }); // revisitme Charu - add support for trackChanges\n\n    processWatch(conditionStates, conditionName, dynamicValueResolvedQueries, dataCtxNode.expressions[conditionName], adaptExpressions, performAnd, conditionExpressions, dataCtxNode.declViewModelJson.conditions[conditionName].trackValues, dataCtxNode.declViewModelJson._viewModelId);\n  }\n};\n/**\n * Expand a string based expression to include nested conditions\n *\n * @param {String} expression - a string expression to evaluate\n * @param {Object} internalViewModel - the object containing other expressions\n * @returns {String} the new string expression\n */\n\nexport let getRealExpression = function (expression, internalViewModel) {\n  //Since getRealExpression() api operates on string expressions, object types should be filtered.\n  if (_.isString(expression)) {\n    var conditionIndex = expression.indexOf('conditions.');\n\n    if (conditionIndex > -1) {\n      var substring = expression.substring(conditionIndex);\n      var endConditionIndex = substring.search('[^a-zA-Z0-9._]');\n      endConditionIndex = endConditionIndex > -1 ? conditionIndex + endConditionIndex : expression.length;\n      var referenceCondition = expression.substring(conditionIndex, endConditionIndex);\n      var evaluatedCondition = _.get(internalViewModel, referenceCondition) || {};\n      var returnExpression = null;\n\n      if (_.isString(evaluatedCondition.expression)) {\n        returnExpression = expression.replace(referenceCondition, '(' + evaluatedCondition.expression + ')');\n      } else {\n        return evaluatedCondition.expression;\n      }\n\n      return getRealExpression(returnExpression, internalViewModel);\n    }\n\n    return expression;\n  }\n\n  return undefined;\n};\nexports = {\n  parseExpression,\n  registerWatch,\n  evaluateCondition,\n  evaluateConditionExpression,\n  getRealExpression\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/conditionService.js"],"names":["exports","parseExpression","evaluationContext","_","updatedExpression","expressionParserUtils","AwParseService","evaluateCondition","Boolean","_evaluateConditionBasedExpression","declViewModel","finalConditionExpression","evaluateDepParams","evaluateConditionExpression","condition","processWatch","oldValue","conditionStates","newValue","valuesToUse","values","currQuery","queries","adaptExpressions","valuesToAdapt","adapterService","verdict","newExpressionValue","conditionVal","conditionExpressions","trackValues","eventBus","performAnd","prevVerdict","logger","debugService","registerWatch","watchQueryAdaptInfo","watchers","adapt","multiAttributeANDExpression","expr","multiAttributeORExpression","expressionsFinal","sourceToWatch","needsToAdapt","executeQuery","dynamicValueResolvedQueries","dataCtxNode","getRealExpression","conditionIndex","expression","substring","endConditionIndex","referenceCondition","evaluatedCondition","returnExpression"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context\n *\n * @publishedApolloService\n *\n * @module js/conditionService\n */\n\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport adapterService from 'js/adapterService';\nimport expressionParserUtils from 'js/expressionParserUtils';\n\nvar exports = {};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Any} The evaluated expression result.\n */\nexport let parseExpression = function( declViewModel, expression, evaluationEnv, depModuleObj ) {\n    var evaluationContext = {};\n    _.assign( evaluationContext, declViewModel, evaluationEnv, depModuleObj );\n    if( _.isObject( expression ) ) {\n        // loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values\n        var updatedExpression = expressionParserUtils.updateDynamicValues( expression, evaluationContext );\n        return expressionParserUtils.evaluateExpressions( updatedExpression, evaluationContext, adapterService );\n    }\n\n    return AwParseService.instance( expression )( evaluationContext );\n};\n\n/**\n * Evaluate condition expression and ensure a boolean is returned\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Boolean} The evaluated condition result.\n */\nexport let evaluateCondition = function( declViewModel, expression, evaluationEnv, depModuleObj ) {\n    return Boolean( exports.parseExpression( declViewModel, expression, evaluationEnv, depModuleObj ) );\n};\n\nconst _evaluateConditionBasedExpression = function( condition, declViewModel, evaluateDepParams ) {\n    var finalConditionExpression;\n    if( _.startsWith( condition, 'conditions.' ) ) {\n        if( declViewModel._internal ) {\n            finalConditionExpression = _.get( declViewModel._internal, condition );\n        } else {\n            finalConditionExpression = _.get( evaluateDepParams.conditionList, condition );\n        }\n    }\n    // for condition\": 'ctx.xyz || ctx.abc' or condition\": '!ctx.xyz' or condition\": '!conditions.xyz'\n    if( finalConditionExpression === undefined ) {\n        finalConditionExpression = condition;\n    } else if( finalConditionExpression.expression ) {\n        finalConditionExpression = finalConditionExpression.expression;\n    }\n\n    if( evaluateDepParams ) {\n        return evaluateCondition( declViewModel, finalConditionExpression, evaluateDepParams.evaluationEnv, evaluateDepParams.depModuleObj );\n    }\n    return evaluateCondition( declViewModel, finalConditionExpression );\n};\n\n/**\n * Evaluate all variants of condition\n *\n * @param {String} condition - condition to evaluate\n * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object\n * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb\n *                                {Object} conditionList- Conditions object of viewmodel\n *                                {String} clauseName -\"activewhen\",\"visiblewhen\"\n *                                {Object} evaluationEnv -specific data required for this call like ctx.\n *                                {Object} depModuleObj\n * @return {Boolean} return true, if expression evalutes to true.\n */\nexport let evaluateConditionExpression = function( condition, declViewModel, evaluateDepParams ) {\n    if( evaluateDepParams && typeof condition[ evaluateDepParams.clauseName ] === 'boolean' ) {\n        return condition[ evaluateDepParams.clauseName ];\n        /*\n         *    activewhen: true\n         */\n    } else if( evaluateDepParams && condition[ evaluateDepParams.clauseName ] ) {\n        condition = _.get( condition, evaluateDepParams.clauseName + '.condition' );\n\n        if( typeof condition === 'boolean' ) {\n            return condition;\n        }\n    }\n    if( condition && condition.length ) {\n        /*\n          evaluate * conditions expression\n          *: {\n              condition: \"conditions.xyz\"\n          }\n          */\n        return _evaluateConditionBasedExpression( condition, declViewModel, evaluateDepParams );\n    }\n    return false;\n};\n\n/**\n * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of\n * the condition differs from the old value\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} queries - The array of objects containing query definitions\n * @param {Array} values - The array of objects of changed value to be used for each of the query object\n * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage\n * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed\n * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.\n * @param {Object} trackValues - Whether or not to track expression value changes.\n */\nlet processWatch = function( conditionStates, conditionName, queries, values, adaptExpressions, performAnd, conditionExpressions, trackValues, viewModelName ) {\n    var oldValue = conditionStates[ conditionName ];\n    var newValue = queries.reduce( function( prevVerdict, currQuery, queryIndex ) {\n        var verdict;\n        var valuesToUse = values[ queryIndex ];\n        if( currQuery && _.isObject( currQuery ) && values && values.length === queries.length ) {\n            // determine whether object requires to be adapted\n            if( adaptExpressions[ queryIndex ] ) {\n                var valuesToAdapt = _.isArray( valuesToUse ) ? valuesToUse : [ valuesToUse ];\n                valuesToUse = adapterService.getAdaptedObjectsSync( valuesToAdapt );\n            }\n            // expression is an object, hence process the query object inside it\n            verdict = expressionParserUtils.evaluateExpressions( currQuery, valuesToUse, adapterService );\n        } else {\n            // expression is simple string with boolean result\n            verdict = Boolean( values && valuesToUse );\n        }\n\n        var newExpressionValue = valuesToUse;\n        var conditionVal;\n        if( conditionExpressions ) {\n            conditionVal = conditionExpressions[ conditionName ];\n        }\n        if( trackValues && conditionExpressions && conditionVal[ 0 ] !== newExpressionValue ) {\n            eventBus.publish( 'condition.expressionValueChanged', {\n                condition: 'conditions.' + conditionName,\n                oldValue: conditionExpressions[ conditionName ],\n                newValue: newExpressionValue\n            } );\n        }\n        return performAnd ? prevVerdict && verdict : prevVerdict || verdict;\n    }, performAnd );\n\n    if( logger.isDeclarativeLogEnabled() ) {\n        debugService.debugConditions( conditionName, newValue, queries, viewModelName );\n    }\n\n    if( oldValue !== newValue ) {\n        eventBus.publish( 'condition.valueChanged', {\n            condition: 'conditions.' + conditionName,\n            oldValue: oldValue,\n            newValue: newValue\n        } );\n    }\n};\n\n/**\n * Register a watch for given expression on provided scope and update conditionStates[conditionName] when\n * expression's value changes.\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} expressions - Array of expression to be watched for value change.\n * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.\n * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression\n * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback\n * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not\n * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing\n */\nexport let registerWatch = function( conditionStates, dataCtxNode, conditionName, expressions, conditionExpressions, queries, adaptExpressions, deepWatch, performAnd ) {\n    if( !queries ) {\n        var watchQueryAdaptInfo = {\n            watchers: [],\n            queries: [],\n            adapt: []\n        };\n\n        var multiAttributeANDExpression;\n        var multiAttributeORExpression;\n        _.forEach( expressions, function( expr ) {\n            multiAttributeANDExpression = expr[ expressionParserUtils.$AND ];\n            multiAttributeORExpression = expr[ expressionParserUtils.$OR ];\n\n            var expressionsFinal = multiAttributeANDExpression || multiAttributeORExpression || expressions;\n            _.forEach( expressionsFinal, function( finalExpr ) {\n                var sourceToWatch = expressionParserUtils.resolve( expressionParserUtils.$SOURCE, finalExpr );\n                var needsToAdapt = sourceToWatch && sourceToWatch[ expressionParserUtils.$ADAPT ];\n                sourceToWatch = needsToAdapt || sourceToWatch || finalExpr;\n\n                var executeQuery = expressionParserUtils.resolve( expressionParserUtils.$QUERY, finalExpr );\n                watchQueryAdaptInfo.watchers.push( sourceToWatch );\n                watchQueryAdaptInfo.queries.push( executeQuery || finalExpr );\n                watchQueryAdaptInfo.adapt.push( Boolean( needsToAdapt ) );\n            } );\n        } );\n\n        exports.registerWatch( conditionStates, dataCtxNode, conditionName, watchQueryAdaptInfo.watchers, conditionExpressions, watchQueryAdaptInfo.queries,\n            watchQueryAdaptInfo.adapt, true, multiAttributeANDExpression );\n    } else {\n        // process expressions, queries and adaptExpressions array\n        var dynamicValueResolvedQueries = queries.map( function( query ) {\n            return expressionParserUtils.updateDynamicValues( query, dataCtxNode );\n        } );\n\n        // revisitme Charu - add support for trackChanges\n        processWatch( conditionStates, conditionName, dynamicValueResolvedQueries, dataCtxNode.expressions[ conditionName ], adaptExpressions, performAnd, conditionExpressions, dataCtxNode\n            .declViewModelJson.conditions[\n                conditionName ].trackValues, dataCtxNode.declViewModelJson._viewModelId );\n    }\n};\n\n/**\n * Expand a string based expression to include nested conditions\n *\n * @param {String} expression - a string expression to evaluate\n * @param {Object} internalViewModel - the object containing other expressions\n * @returns {String} the new string expression\n */\nexport let getRealExpression = function( expression, internalViewModel ) {\n    //Since getRealExpression() api operates on string expressions, object types should be filtered.\n    if( _.isString( expression ) ) {\n        var conditionIndex = expression.indexOf( 'conditions.' );\n        if( conditionIndex > -1 ) {\n            var substring = expression.substring( conditionIndex );\n            var endConditionIndex = substring.search( '[^a-zA-Z0-9._]' );\n            endConditionIndex = endConditionIndex > -1 ? conditionIndex + endConditionIndex : expression.length;\n            var referenceCondition = expression.substring( conditionIndex, endConditionIndex );\n            var evaluatedCondition = _.get( internalViewModel, referenceCondition ) || {};\n            var returnExpression = null;\n            if( _.isString( evaluatedCondition.expression ) ) {\n                returnExpression = expression.replace( referenceCondition, '(' + evaluatedCondition.expression + ')' );\n            } else {\n                return evaluatedCondition.expression;\n            }\n            return getRealExpression( returnExpression, internalViewModel );\n        }\n        return expression;\n    }\n    return undefined;\n};\n\nexports = {\n    parseExpression,\n    registerWatch,\n    evaluateCondition,\n    evaluateConditionExpression,\n    getRealExpression\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}