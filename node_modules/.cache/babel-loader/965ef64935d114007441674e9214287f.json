{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Command service to manage commands.\n *\n * @module js/command.service\n *\n * @namespace commandService\n */\nimport appCtxService from 'js/appCtxService';\nimport preferenceService from 'soa/preferenceService';\nimport { getCommand as getCommandInternal, getCommands as getCommandsInternal } from './commandConfigurationService';\nimport conditionService from 'js/conditionService';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition, parseStringCondition } from 'js/conditionParser.service';\nimport { concat, flatten, get, uniq } from 'lodash';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\n/**\n  * Get a function to check if a command should be visible in the given workspace\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @returns {Function} Function to determine if command should be visible\n  */\n\nconst getWorkspaceCommandValidator = function () {\n  let workspace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (workspace.workspaceType === 'Exclusive') {\n    const {\n      includedCommands,\n      excludedCommands\n    } = workspace;\n\n    if (includedCommands && excludedCommands) {\n      return command => includedCommands.includes(command.id) && !excludedCommands.includes(command.id);\n    } else if (includedCommands) {\n      return command => includedCommands.includes(command.id);\n    } else if (excludedCommands) {\n      return command => !excludedCommands.includes(command.id);\n    }\n  } //if not exclusive workspace don't filter commands\n\n\n  return () => true;\n};\n/**\n  * Filter any commands that should be hidden based on the given workspace and preference\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @param {[String]} hiddenCommandPreference Hidden command preference value\n  * @returns {Function} Function to determine if the command should be visible\n  */\n\n\nconst filterHiddenCommands = function (workspace, hiddenCommandPreference) {\n  const isValidWorkspaceCommand = getWorkspaceCommandValidator(workspace);\n  return command => !hiddenCommandPreference.includes(command.id) && isValidWorkspaceCommand(command);\n};\n/**\n  * Get the command overlays for the commands matching the given inputs. Calls the getCommands method on each\n  * contributed provider and then return the aggregate result.\n  *\n  * @function getCommands\n  * @memberOf commandService\n  * @param {String} commandAreaNameTokens - Comma separated list of command area name tokens, eg. Navigation, Onestep, etc\n  * @param {Object} context - Additional context to use in command evaluation\n  * @param {Object} commandStateUpdater - A hook to update the command state\n  *\n  * @return {Promise} A promise containing the array of command overlays\n  */\n\n\nexport const getCommands = async function (commandAreaNameTokens) {\n  const overlays = await getCommandsInternal(commandAreaNameTokens);\n  const hiddenCommandPreference = await preferenceService.getStringValues('AWC_HiddenCommands');\n  const workspace = appCtxService.getCtx('workspace');\n  return overlays.filter(filterHiddenCommands(workspace, hiddenCommandPreference || []));\n};\n/**\n  * Get a CommandOverlay for the given command.\n  *\n  * @function getCommand\n  * @memberOf commandService\n  * @param {String} commandId - Command id\n  * @return {CommandOverlay} The unresolved overlay for the command\n  */\n\nexport const getCommand = getCommandInternal;\n/**\n  * Get the command for the command with the given commandId and executes it if it is visible\n  *\n  * @function executeCommandIfVisibleAndEnabled\n  * @memberOf commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {Object} commandContext - Additional context to use in command evaluation\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\n\nexport const executeCommandIfVisibleAndEnabled = async function (commandId, commandContext, runActionWithViewModel) {\n  if (!runActionWithViewModel) {\n    return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');\n  }\n\n  const command = await getCommand(commandId);\n  const scope = {\n    ctx: appCtxService.ctx,\n    commandContext: { ...commandContext\n    }\n  };\n  const commandRender = getCommandRender(scope, command);\n  return commandRender.visible ? commandRender.execute(runActionWithViewModel) : Promise.resolve();\n};\n/**\n  * Execute a command with the given arguments\n  *\n  * @function executeCommand\n  * @memberof commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {String|String[]} commandArgs - (Optional) (Deprecated) Command arguments. Should only be used for GWT commands.\n  * @param {Object} context - (Optional) Context to execute the command in. Required for zero compile commands.\n  * @param {Object} commandContext - (Optional) (Deprecated) Additional data to set into context. Should not be used.\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\n\nexport const executeCommand = async function (commandId, commandArgs, context) {\n  let commandContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let runActionWithViewModel = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!runActionWithViewModel) {\n    return Promise.reject('executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component');\n  }\n\n  const command = await getCommand(commandId);\n  const scope = {\n    ctx: appCtxService.ctx,\n    ...context,\n    commandContext: {\n      commandArgs,\n      ...commandContext\n    }\n  };\n  const commandRender = getCommandRender(scope, command);\n  return commandRender.execute(runActionWithViewModel);\n};\n/**************************** CommandRender creation logic ****************************/\n\n/**\n  * All of the data that AwCommand needs to render a command\n  *\n  * All properties should be the \"end result\" that AwCommand can directly use. For example\n  * \"title\" can be either \"title\" or \"selectedTitle\" based on selection state and\n  * \"hasPopup\" can be true or false for group commands depending on child command states\n  *\n  * @param {Object} info Command display information\n  * @param {CommandHandler} handler The current handler for the command\n  * @param {Object} state The current state of the command\n  * @param {Object} scope The evaluation context this result was computed in\n  */\n\nconst CommandRender = function (_ref, handler, _ref2, scope) {\n  let {\n    id,\n    title = '',\n    description = '',\n    icon = '',\n    extendedTooltip,\n    decorator,\n    cellDisplay = null\n  } = _ref;\n  let {\n    hasPopup,\n    visible,\n    enabled,\n    selected\n  } = _ref2;\n  /**\n    * ID of the command\n    */\n\n  this.id = id;\n  /**\n    * The handler that is currently active for this command\n    */\n\n  this.handler = handler;\n  /**\n    * (Optional) The evaluated title of the command\n    */\n\n  this.title = typeof title === 'string' ? title : null;\n  /**\n    * (Optional) The evaluated description of the command\n    */\n\n  this.description = description;\n  /**\n    * (Optional) ID of the icon currently used\n    */\n\n  this.icon = icon;\n  /**\n    * (Optional) Evaluated JSX to include in the command display\n    */\n\n  this.decorator = decorator;\n  /**\n    * (Optional) Evaluated extended tooltip configuration\n    */\n\n  this.extendedTooltip = extendedTooltip;\n  /**\n    * (Optional) Cell display information configured on placement\n    */\n\n  this.cellDisplay = cellDisplay;\n  /**\n    * Execute this command in its current state\n    *\n    * @param {Function} runActionWithViewModel View model service api\n    * @param {Object} commandContext Context to execute the command in\n    * @returns {Promise} Promise resolved when execution is complete\n    */\n\n  this.execute = function (runActionWithViewModel, commandContext) {\n    debugService.debug('commands', this.id); // command menus are \"executed\" by AwCommand\n    // enhanced per Cory:\n    //     - cover the case where a ribbon command has been configured to execute a non popup action\n\n    if (this.hasPopup && handler.action.actionType === 'popup') {\n      return handler.action;\n    }\n\n    return handler.execute.apply(handler, [runActionWithViewModel, scope, commandContext]);\n  };\n  /**\n    * Whether this command will open a popup when clicked\n    */\n\n\n  this.hasPopup = hasPopup;\n  /**\n    * Whether this command is currently visible\n    */\n\n  this.visible = visible;\n  /**\n    * Whether this command is currently enabled\n    */\n\n  this.enabled = enabled;\n  /**\n    * Whether this command is currently selected\n    */\n\n  this.selected = selected;\n};\n/**\n  * Sidenav areas that will cause commands to be automatically selected\n  */\n\n\n_c2 = CommandRender;\n_c = CommandRender;\nconst supportedPanelAreas = ['activeToolsAndInfoCommand', 'activeNavigationCommand', 'sidenavCommandId'];\n/**\n   * Get the ID of the panel that is currently opened\n   *\n   * @param {Object} scope Evaluation context\n   * @returns {String|null} ID of the opened panel\n   */\n\nconst getActivePanelId = scope => {\n  for (const area of supportedPanelAreas) {\n    if (scope.ctx[area] && scope.ctx[area].commandId) {\n      return scope.ctx[area].commandId;\n    }\n  }\n\n  return null;\n};\n/**\n  * Determine if a command should be currently selected\n  *\n  * @param {Condition} selectWhen Select when condition for the command\n  * @param {String} id Command ID\n  * @param {Object} scope Command evaluation context\n  * @returns {Boolean} Latest state for this command\n  */\n\n\nconst isCommandSelected = function (selectWhen, id, scope) {\n  const activePanelId = getActivePanelId(scope);\n\n  if (selectWhen) {\n    return Boolean(conditionService.evaluateCondition({}, selectWhen.expression, scope));\n  } else if (activePanelId === id) {\n    return true;\n  }\n\n  return false;\n};\n/**\n  * Get a resolver to switch between selected/not selected properties\n  *\n  * @param {String} propName primary property name\n  * @param {String} selectedPropName selected property name\n  * @returns {Function} Resolver method\n  */\n\n\nconst getSelectedPropResolver = (propName, selectedPropName) => {\n  const getResolvedParameters = (command, scope, selected) => {\n    const getParameter = x => {\n      return AwParseService.instance(getStringBetweenDoubleMustaches(x))(scope);\n    };\n\n    if (command[selectedPropName] && selected) {\n      return command[selectedPropName].parameters.map(getParameter);\n    }\n\n    if (command[propName] && command[propName].parameters && propName !== 'decorator') {\n      return command[propName].parameters.map(getParameter);\n    }\n\n    if (command[propName] && command[propName].text && command[propName].text.parameters && propName === 'decorator') {\n      return command[propName].text.parameters.map(getParameter);\n    }\n\n    return [];\n  };\n\n  return (command, scope, selected) => {\n    const parameters = getResolvedParameters(command, scope, selected);\n\n    if (command[selectedPropName] && selected && command[selectedPropName].value) {\n      return command[selectedPropName].value.format(...parameters);\n    }\n\n    if (command[propName] && command[propName].value && propName !== 'decorator') {\n      return command[propName].value.format(...parameters);\n    }\n\n    if (command[propName] && command[propName].text && command[propName].text.value && propName === 'decorator') {\n      return command[propName].text.value.format(...parameters);\n    }\n\n    return '';\n  };\n};\n/**\n  * Get the resolved title for a command\n  */\n\n\nconst getTitle = getSelectedPropResolver('title', 'selectedTitle');\n/**\n  * Get the resolved title for a command\n  */\n\nconst getDescription = getSelectedPropResolver('description', 'selectedDescription');\n/**\n  * Get the resolved decorator for a command\n  */\n\nconst getDecorator = getSelectedPropResolver('decorator', null);\n/**\n  * Get the latest state for a standard command\n  *\n  * Supported command types: BASE, TOGGLE, RIBBON\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\nconst getBaseCommandRender = (scope, command) => {\n  for (const handler of command.handlers) {\n    const isActive = Boolean(conditionService.evaluateCondition({}, handler.activeWhen.expression, scope));\n\n    if (isActive) {\n      command.trace('Active handler is', handler);\n      debugService.debugUpdateHandlerOnCommand(command.id, handler);\n      const enabled = handler.enableWhen ? Boolean(conditionService.evaluateCondition({}, handler.enableWhen.expression, scope)) : true;\n      const selected = isCommandSelected(handler.selectWhen, command.id, scope); //TODO: Check if visibleWhen is required in schema and validate default if not required\n\n      const visible = handler.visibleWhen ? Boolean(conditionService.evaluateCondition({}, handler.visibleWhen.expression, scope)) : true;\n      const id = command.id; //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n\n      const title = getTitle(command, scope, selected);\n      const description = getDescription(command, scope, selected);\n      const icon = command.selectedIcon && selected ? command.selectedIcon : command.icon;\n      const hasPopup = command.type === 'RIBBON';\n      const cellDisplay = command.cellDisplay;\n      const currentTooltip = selected && command.selectedExtendedTooltip ? command.selectedExtendedTooltip : command.extendedTooltip;\n      const decorator = {};\n      decorator.text = getDecorator(command, scope, selected);\n      decorator.className = command.decorator && command.decorator.class ? command.decorator.class : null;\n      decorator.visibleWhen = command.decorator && command.decorator.visibleWhen ? Boolean(conditionService.evaluateCondition({}, command.decorator.visibleWhen.expression, scope)) : true;\n      return new CommandRender({\n        id,\n        description,\n        title,\n        icon,\n        extendedTooltip: currentTooltip,\n        decorator,\n        cellDisplay\n      }, handler, {\n        enabled,\n        selected,\n        visible,\n        hasPopup\n      }, scope);\n    }\n  }\n\n  command.trace('Command has no active handler');\n  return new CommandRender(command, null, {\n    enabled: false,\n    selected: false,\n    visible: false\n  }, scope);\n};\n/**\n  * Get the latest state for a group command\n  *\n  * Supported types: GROUP\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\n\nconst getGroupCommandRender = (scope, command) => {\n  const {\n    showGroupSelected = true\n  } = command;\n  const childCommandStates = command.children.map(child => getCommandRender(scope, child));\n  command.trace('Child command states', childCommandStates);\n  const visibleChildCommands = childCommandStates.filter(x => x.visible);\n  const groupCommandState = visibleChildCommands.reduce((_ref3, childCommandState) => {\n    let {\n      enabled,\n      selected\n    } = _ref3;\n    return {\n      enabled: enabled || childCommandState.enabled,\n      selected: showGroupSelected && (selected || childCommandState.enabled && childCommandState.selected)\n    };\n  }, {\n    enabled: false,\n    selected: false\n  });\n  const id = command.id; //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n\n  const title = getTitle(command, scope, groupCommandState.selected);\n  const description = getDescription(command, scope, groupCommandState.selected);\n  const icon = command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n  const visible = visibleChildCommands.length > 0;\n  const hasPopup = visibleChildCommands.length > 1;\n  return new CommandRender({\n    id,\n    title,\n    description,\n    icon,\n    extendedTooltip: command.extendedTooltip,\n    decorator: null\n  }, visibleChildCommands.length === 1 ? visibleChildCommands[0].handler : command.handlers[0], { ...groupCommandState,\n    hasPopup,\n    visible\n  }, scope);\n};\n/**\n  * Get the latest state for a shuttle command\n  *\n  * Supported types: SHUTTLE\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\n\n\nconst getShuttleCommandRender = (scope, command) => {\n  // pass into command object\n  // pull show group selected property out of command (shuttle should always be false)\n  const showGroupSelected = false; // pull all child command states (ctx)\n  // throw logic onto child commands pull selected properties\n  // .map call function on specific items that creates new array with result of function\n  // passes child state into getCommandRender\n\n  const childCommandStates = command.children.map(child => getCommandRender(scope, child)); //  find all of the commands that are visible\n  // .filter creates new array (visibleChildCommands) which has commands w/ property visible = true\n\n  const visibleChildCommands = childCommandStates.filter(x => x.visible); // adding selected child commands? find commands that are selected\n  // list of current child commands selected & visible\n  // get first selected child out of filtered list (child command 0)\n\n  const selectedChildCommands = visibleChildCommands.filter(x => x.selected); // groupcommandstate = reduced visible commands, pass to child command state\n\n  const groupCommandState = visibleChildCommands.reduce((_ref4, childCommandState) => {\n    let {\n      enabled\n    } = _ref4;\n    return {\n      enabled: enabled || childCommandState.enabled,\n      selected: showGroupSelected\n    };\n  }, {\n    enabled: false,\n    selected: false\n  });\n  const id = command.id;\n  const firstSelectedChild = selectedChildCommands[0];\n\n  const getShuttleTitle = () => {\n    if (firstSelectedChild) {\n      return firstSelectedChild.title;\n    }\n\n    return getTitle(command, scope, groupCommandState.selected);\n  };\n\n  const getShuttleDescription = () => {\n    //TODO: Should shuttle commands also inherit description?\n    //View mode command with description of a specific view model seems wrong\n    if (firstSelectedChild) {\n      return firstSelectedChild.description;\n    }\n\n    return getDescription(command, scope, groupCommandState.selected);\n  };\n\n  const getShuttleIcon = () => {\n    if (firstSelectedChild) {\n      return firstSelectedChild.icon;\n    }\n\n    return command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n  };\n\n  const getShuttleExtendedTooltip = () => {\n    // If tooltip configured on parent command use that\n    if (command.extendedTooltip) {\n      return command.extendedTooltip;\n    } // If no tooltip and active child has tooltip use that\n\n\n    if (firstSelectedChild && firstSelectedChild.extendedTooltip) {\n      return firstSelectedChild.extendedTooltip;\n    } // If no tooltip and active child does not have tooltip use title/description of child\n\n\n    return null;\n  };\n\n  const title = getShuttleTitle();\n  const description = getShuttleDescription();\n  const icon = getShuttleIcon();\n  const visible = visibleChildCommands.length > 0;\n  const hasPopup = visibleChildCommands.length > 1;\n  return new CommandRender({\n    id,\n    title,\n    description,\n    icon,\n    extendedTooltip: getShuttleExtendedTooltip(),\n    decorator: null\n  }, visibleChildCommands.length === 1 ? visibleChildCommands[0].handler : command.handlers[0], { ...groupCommandState,\n    hasPopup,\n    visible\n  }, scope);\n};\n/**\n  * Map of command type to the render function for it\n  */\n\n\nconst commandTypeToRenderer = {\n  BASE: getBaseCommandRender,\n  RIBBON: getBaseCommandRender,\n  GROUP: getGroupCommandRender,\n  SHUTTLE: getShuttleCommandRender\n};\n/**\n  * Get the latest render data based on the new command state\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {Object} command The unprocessed command data\n  * @returns {CommandRender} Latest render data for the command\n  */\n\nexport const getCommandRender = (scope, command) => {\n  const renderFunction = commandTypeToRenderer[command.type] || commandTypeToRenderer.BASE;\n  command.trace('Getting current command state', scope, command, renderFunction);\n  const renderResult = renderFunction(scope, command);\n  command.trace('Command state', renderResult);\n  debugService.debugCommandRender(command, renderResult);\n  return renderResult;\n};\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\n\nconst getBaseCommandParameters = command => {\n  const staticCommandParameters = ['activeToolsAndInfoCommand.commandId', 'activeNavigationCommand.commandId', 'sidenavCommandId.commandId'];\n  const {\n    ctxParameters: titleParameters,\n    additionalParameters: titleContextParameters\n  } = getCommandI18nParameters(command);\n  return (command.handlers || []).reduce((acc, handler) => {\n    const conditionDeps = [parseCondition(handler.activeWhen), parseCondition(handler.visibleWhen), parseCondition(handler.enableWhen), parseCondition(handler.selectWhen)];\n    return {\n      ctxParameters: uniq(concat(flatten(conditionDeps.map(x => x.ctxParameters)), acc.ctxParameters)),\n      additionalParameters: concat(acc.additionalParameters, flatten(conditionDeps.map(x => x.additionalParameters)))\n    };\n  }, {\n    ctxParameters: [...titleParameters, ...staticCommandParameters],\n    additionalParameters: [command, ...titleContextParameters]\n  });\n};\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\n\n\nconst getGroupCommandParameters = command => {\n  const {\n    ctxParameters: titleParameters,\n    additionalParameters: titleContextParameters\n  } = getCommandI18nParameters(command);\n  return command.children.reduce((acc, child) => {\n    const childParameters = getCommandParameters(child);\n    return {\n      ctxParameters: uniq(concat(childParameters.ctxParameters, acc.ctxParameters)),\n      additionalParameters: concat(acc.additionalParameters, childParameters.additionalParameters)\n    };\n  }, {\n    ctxParameters: [...titleParameters],\n    additionalParameters: [command, ...titleContextParameters]\n  });\n};\n\nconst commandTypeToParameterMapper = {\n  BASE: getBaseCommandParameters,\n  RIBBON: getBaseCommandParameters,\n  GROUP: getGroupCommandParameters,\n  SHUTTLE: getGroupCommandParameters\n};\n/**\n  * Get ctx/other parameters for a property of a command\n  *\n  * @param {CommandOverlay} command command being parsed\n  * @param {String} propName property name\n  * @returns {Object} dependencies\n  */\n\nconst getI18nParameters = (command, propName) => {\n  if (command[propName]) {\n    return command[propName].parameters.reduce((acc, x) => {\n      const {\n        ctxParameters,\n        additionalParameters\n      } = parseStringCondition(x);\n      return {\n        ctxParameters: [...acc.ctxParameters, ...ctxParameters],\n        additionalParameters: [...acc.additionalParameters, ...additionalParameters]\n      };\n    }, {\n      ctxParameters: [],\n      additionalParameters: []\n    });\n  }\n\n  return {\n    ctxParameters: [],\n    additionalParameters: []\n  };\n};\n/**\n  * Get parameters for any localized properties that support \"parameter format\"\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx parameters\n  */\n\n\nconst getCommandI18nParameters = command => {\n  return ['title', 'selectedTitle', 'description', 'selectedDescription'].reduce((acc, propName) => {\n    const {\n      ctxParameters,\n      additionalParameters\n    } = getI18nParameters(command, propName);\n    return {\n      ctxParameters: [...acc.ctxParameters, ...ctxParameters],\n      additionalParameters: [...acc.additionalParameters, ...additionalParameters]\n    };\n  }, {\n    ctxParameters: [],\n    additionalParameters: []\n  });\n};\n/**\n  * Get anything in ctx that this command depends on\n  *\n  * TODO: Additional parameters will need to be \"resolved\" before returning\n  *\n  * @param {CommandOverlay} command Command to get the information for\n  * @returns {List<Path>} List of lodash get paths (array or string)\n  */\n\n\nexport const getCommandParameters = command => (commandTypeToParameterMapper[command.type] || commandTypeToParameterMapper.BASE)(command);\n/**\n  * Get all of the Derived States for the given commands\n  *\n  * @param {Object} vmDef View model definition\n  * @param {Object} props Component properties\n  * @returns {List<DerivedStateResult>} Derived state configurations for commands\n  */\n\nexport const getCommandStates = (vmDef, _ref5) => {\n  let {\n    commandList = [],\n    commandContext = {},\n    visibleServerCommands = {}\n  } = _ref5;\n  const scope = {\n    commandContext,\n    visibleServerCommands\n  }; //The list of \"additionalParameters\" is just strings initially, need to pull actual values from props\n\n  const getFromProps = path => get(scope, path);\n\n  return commandList.map(cmd => {\n    const {\n      ctxParameters,\n      additionalParameters: additionalParametersRefs\n    } = cmd.parameters || getCommandParameters({ ...cmd\n    });\n    cmd.parameters = {\n      ctxParameters,\n      additionalParameters: additionalParametersRefs\n    };\n    const additionalParameters = [additionalParametersRefs[0], ...additionalParametersRefs.slice(1).map(getFromProps)];\n    return new DerivedStateResult({\n      ctxParameters,\n      additionalParameters,\n      compute: _ref6 => {\n        let {\n          ctx\n        } = _ref6;\n        return getCommandRender({\n          commandContext,\n          ctx: { ...ctx,\n            //Fakes visibleServerCommands being in CTX even though it actually local to this command bar\n            visibleServerCommands\n          }\n        }, additionalParameters[0]);\n      }\n    });\n  });\n};\nexport default {\n  getCommands,\n  getCommand,\n  executeCommand,\n  executeCommandIfVisibleAndEnabled\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"CommandRender\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"CommandRender\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/command.service.js"],"names":["getCommand","getCommands","getWorkspaceCommandValidator","workspace","excludedCommands","includedCommands","command","filterHiddenCommands","isValidWorkspaceCommand","hiddenCommandPreference","overlays","getCommandsInternal","preferenceService","appCtxService","executeCommandIfVisibleAndEnabled","Promise","scope","ctx","commandContext","commandRender","getCommandRender","executeCommand","runActionWithViewModel","CommandRender","title","description","icon","cellDisplay","selected","debugService","handler","supportedPanelAreas","getActivePanelId","isCommandSelected","activePanelId","Boolean","conditionService","selectWhen","getSelectedPropResolver","getResolvedParameters","getParameter","x","AwParseService","getStringBetweenDoubleMustaches","propName","parameters","getTitle","getDescription","getDecorator","getBaseCommandRender","isActive","enabled","visible","id","hasPopup","currentTooltip","decorator","extendedTooltip","getGroupCommandRender","showGroupSelected","childCommandStates","child","visibleChildCommands","groupCommandState","childCommandState","getShuttleCommandRender","selectedChildCommands","firstSelectedChild","getShuttleTitle","getShuttleDescription","getShuttleIcon","getShuttleExtendedTooltip","commandTypeToRenderer","BASE","RIBBON","GROUP","SHUTTLE","renderFunction","renderResult","getBaseCommandParameters","staticCommandParameters","ctxParameters","additionalParameters","titleContextParameters","getCommandI18nParameters","conditionDeps","parseCondition","uniq","concat","flatten","acc","getGroupCommandParameters","childParameters","getCommandParameters","commandTypeToParameterMapper","getI18nParameters","parseStringCondition","getCommandStates","commandList","visibleServerCommands","getFromProps","path","get","cmd","additionalParametersRefs","compute"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Command service to manage commands.\n *\n * @module js/command.service\n *\n * @namespace commandService\n */\nimport appCtxService from 'js/appCtxService';\nimport preferenceService from 'soa/preferenceService';\nimport { getCommand as getCommandInternal, getCommands as getCommandsInternal } from './commandConfigurationService';\nimport conditionService from 'js/conditionService';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition, parseStringCondition } from 'js/conditionParser.service';\nimport { concat, flatten, get, uniq } from 'lodash';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\n\n/**\n  * Get a function to check if a command should be visible in the given workspace\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @returns {Function} Function to determine if command should be visible\n  */\nconst getWorkspaceCommandValidator = ( workspace = {} ) => {\n    if( workspace.workspaceType === 'Exclusive' ) {\n        const { includedCommands, excludedCommands } = workspace;\n        if( includedCommands && excludedCommands ) {\n            return ( command ) => includedCommands.includes( command.id ) && !excludedCommands.includes( command.id );\n        } else if( includedCommands ) {\n            return ( command ) => includedCommands.includes( command.id );\n        }else if( excludedCommands ) {\n            return ( command ) => !excludedCommands.includes( command.id );\n        }\n    }\n    //if not exclusive workspace don't filter commands\n    return () => true;\n};\n\n/**\n  * Filter any commands that should be hidden based on the given workspace and preference\n  *\n  * @param {Workspace} workspace Workspace definition\n  * @param {[String]} hiddenCommandPreference Hidden command preference value\n  * @returns {Function} Function to determine if the command should be visible\n  */\nconst filterHiddenCommands = function( workspace, hiddenCommandPreference ) {\n    const isValidWorkspaceCommand = getWorkspaceCommandValidator( workspace );\n    return command => !hiddenCommandPreference.includes( command.id ) && isValidWorkspaceCommand( command );\n};\n\n/**\n  * Get the command overlays for the commands matching the given inputs. Calls the getCommands method on each\n  * contributed provider and then return the aggregate result.\n  *\n  * @function getCommands\n  * @memberOf commandService\n  * @param {String} commandAreaNameTokens - Comma separated list of command area name tokens, eg. Navigation, Onestep, etc\n  * @param {Object} context - Additional context to use in command evaluation\n  * @param {Object} commandStateUpdater - A hook to update the command state\n  *\n  * @return {Promise} A promise containing the array of command overlays\n  */\nexport const getCommands = async function( commandAreaNameTokens ) {\n    const overlays = await getCommandsInternal( commandAreaNameTokens );\n    const hiddenCommandPreference = await preferenceService.getStringValues( 'AWC_HiddenCommands' );\n    const workspace = appCtxService.getCtx( 'workspace' );\n    return overlays.filter( filterHiddenCommands( workspace, hiddenCommandPreference || [] ) );\n};\n\n/**\n  * Get a CommandOverlay for the given command.\n  *\n  * @function getCommand\n  * @memberOf commandService\n  * @param {String} commandId - Command id\n  * @return {CommandOverlay} The unresolved overlay for the command\n  */\nexport const getCommand = getCommandInternal;\n\n/**\n  * Get the command for the command with the given commandId and executes it if it is visible\n  *\n  * @function executeCommandIfVisibleAndEnabled\n  * @memberOf commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {Object} commandContext - Additional context to use in command evaluation\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\nexport const executeCommandIfVisibleAndEnabled = async function( commandId, commandContext, runActionWithViewModel ) {\n    if( !runActionWithViewModel ) {\n        return Promise.reject( 'executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component' );\n    }\n    const command = await getCommand( commandId );\n    const scope = {\n        ctx: appCtxService.ctx,\n        commandContext: {\n            ...commandContext\n        }\n    };\n    const commandRender = getCommandRender( scope, command );\n    return commandRender.visible ? commandRender.execute( runActionWithViewModel ) : Promise.resolve();\n};\n\n/**\n  * Execute a command with the given arguments\n  *\n  * @function executeCommand\n  * @memberof commandService\n  *\n  * @param {String} commandId - Command id\n  * @param {String|String[]} commandArgs - (Optional) (Deprecated) Command arguments. Should only be used for GWT commands.\n  * @param {Object} context - (Optional) Context to execute the command in. Required for zero compile commands.\n  * @param {Object} commandContext - (Optional) (Deprecated) Additional data to set into context. Should not be used.\n  * @param {Function} runActionWithViewModel - Callback method required for executing commands\n  *\n  * @returns {Promise} Resolved when the command execution is complete.\n  */\nexport const executeCommand = async function( commandId, commandArgs, context, commandContext = {}, runActionWithViewModel ) {\n    if( !runActionWithViewModel ) {\n        return Promise.reject( 'executeCommand requires the \"runActionWithViewModel\" API. This can be accessed from the render function of your component' );\n    }\n    const command = await getCommand( commandId );\n    const scope = {\n        ctx: appCtxService.ctx,\n        ...context,\n        commandContext: {\n            commandArgs,\n            ...commandContext\n        }\n    };\n    const commandRender = getCommandRender( scope, command );\n    return commandRender.execute( runActionWithViewModel );\n};\n\n/**************************** CommandRender creation logic ****************************/\n\n/**\n  * All of the data that AwCommand needs to render a command\n  *\n  * All properties should be the \"end result\" that AwCommand can directly use. For example\n  * \"title\" can be either \"title\" or \"selectedTitle\" based on selection state and\n  * \"hasPopup\" can be true or false for group commands depending on child command states\n  *\n  * @param {Object} info Command display information\n  * @param {CommandHandler} handler The current handler for the command\n  * @param {Object} state The current state of the command\n  * @param {Object} scope The evaluation context this result was computed in\n  */\nconst CommandRender = function( {\n    id,\n    title = '',\n    description = '',\n    icon = '',\n    extendedTooltip,\n    decorator,\n    cellDisplay = null\n}, handler, {\n    hasPopup,\n    visible,\n    enabled,\n    selected\n}, scope ) {\n    /**\n      * ID of the command\n      */\n    this.id = id;\n\n    /**\n      * The handler that is currently active for this command\n      */\n    this.handler = handler;\n\n    /**\n      * (Optional) The evaluated title of the command\n      */\n    this.title = typeof title === 'string' ? title : null;\n\n    /**\n      * (Optional) The evaluated description of the command\n      */\n    this.description = description;\n\n    /**\n      * (Optional) ID of the icon currently used\n      */\n    this.icon = icon;\n\n    /**\n      * (Optional) Evaluated JSX to include in the command display\n      */\n    this.decorator = decorator;\n\n    /**\n      * (Optional) Evaluated extended tooltip configuration\n      */\n    this.extendedTooltip = extendedTooltip;\n\n    /**\n      * (Optional) Cell display information configured on placement\n      */\n    this.cellDisplay = cellDisplay;\n\n    /**\n      * Execute this command in its current state\n      *\n      * @param {Function} runActionWithViewModel View model service api\n      * @param {Object} commandContext Context to execute the command in\n      * @returns {Promise} Promise resolved when execution is complete\n      */\n    this.execute = function( runActionWithViewModel, commandContext ) {\n        debugService.debug( 'commands', this.id );\n        // command menus are \"executed\" by AwCommand\n        // enhanced per Cory:\n        //     - cover the case where a ribbon command has been configured to execute a non popup action\n        if( this.hasPopup && handler.action.actionType === 'popup' ) {\n            return handler.action;\n        }\n        return handler.execute.apply( handler, [ runActionWithViewModel, scope, commandContext ] );\n    };\n\n    /**\n      * Whether this command will open a popup when clicked\n      */\n    this.hasPopup = hasPopup;\n\n    /**\n      * Whether this command is currently visible\n      */\n    this.visible = visible;\n\n    /**\n      * Whether this command is currently enabled\n      */\n    this.enabled = enabled;\n\n    /**\n      * Whether this command is currently selected\n      */\n    this.selected = selected;\n};\n\n/**\n  * Sidenav areas that will cause commands to be automatically selected\n  */\nconst supportedPanelAreas = [ 'activeToolsAndInfoCommand', 'activeNavigationCommand', 'sidenavCommandId' ];\n\n/**\n   * Get the ID of the panel that is currently opened\n   *\n   * @param {Object} scope Evaluation context\n   * @returns {String|null} ID of the opened panel\n   */\nconst getActivePanelId = ( scope ) => {\n    for( const area of supportedPanelAreas ) {\n        if( scope.ctx[area] && scope.ctx[area].commandId ) {\n            return scope.ctx[area].commandId;\n        }\n    }\n    return null;\n};\n\n/**\n  * Determine if a command should be currently selected\n  *\n  * @param {Condition} selectWhen Select when condition for the command\n  * @param {String} id Command ID\n  * @param {Object} scope Command evaluation context\n  * @returns {Boolean} Latest state for this command\n  */\nconst isCommandSelected = function( selectWhen, id, scope ) {\n    const activePanelId = getActivePanelId( scope );\n    if( selectWhen ) {\n        return Boolean( conditionService.evaluateCondition( {}, selectWhen.expression, scope ) );\n    } else if( activePanelId === id ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n  * Get a resolver to switch between selected/not selected properties\n  *\n  * @param {String} propName primary property name\n  * @param {String} selectedPropName selected property name\n  * @returns {Function} Resolver method\n  */\nconst getSelectedPropResolver = ( propName, selectedPropName ) => {\n    const getResolvedParameters = ( command, scope, selected ) => {\n        const getParameter = x => {\n            return AwParseService.instance( getStringBetweenDoubleMustaches( x ) )( scope );\n        };\n        if ( command[selectedPropName] && selected ) {\n            return command[selectedPropName].parameters.map( getParameter );\n        }\n        if ( command[propName] && command[propName].parameters && propName !== 'decorator' ) {\n            return command[propName].parameters.map( getParameter );\n        }\n        if ( command[propName] && command[propName].text && command[propName].text.parameters && propName === 'decorator' ) {\n            return command[propName].text.parameters.map( getParameter );\n        }\n        return [];\n    };\n    return ( command, scope, selected ) => {\n        const parameters = getResolvedParameters( command, scope, selected );\n        if ( command[selectedPropName] && selected && command[selectedPropName].value ) {\n            return command[selectedPropName].value.format( ...parameters );\n        }\n        if ( command[propName] && command[propName].value && propName !== 'decorator' ) {\n            return command[propName].value.format( ...parameters );\n        }\n        if ( command[propName] && command[propName].text && command[propName].text.value && propName === 'decorator' ) {\n            return command[propName].text.value.format( ...parameters );\n        }\n        return '';\n    };\n};\n\n/**\n  * Get the resolved title for a command\n  */\nconst getTitle = getSelectedPropResolver( 'title', 'selectedTitle' );\n\n/**\n  * Get the resolved title for a command\n  */\nconst getDescription = getSelectedPropResolver( 'description', 'selectedDescription' );\n\n/**\n  * Get the resolved decorator for a command\n  */\nconst getDecorator = getSelectedPropResolver( 'decorator', null );\n\n/**\n  * Get the latest state for a standard command\n  *\n  * Supported command types: BASE, TOGGLE, RIBBON\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getBaseCommandRender = ( scope, command ) => {\n    for( const handler of command.handlers ) {\n        const isActive = Boolean( conditionService.evaluateCondition( {}, handler.activeWhen.expression, scope ) );\n        if( isActive ) {\n            command.trace( 'Active handler is', handler );\n            debugService.debugUpdateHandlerOnCommand( command.id, handler );\n            const enabled = handler.enableWhen ? Boolean( conditionService.evaluateCondition( {}, handler.enableWhen.expression, scope ) ) : true;\n            const selected = isCommandSelected( handler.selectWhen, command.id, scope );\n            //TODO: Check if visibleWhen is required in schema and validate default if not required\n            const visible = handler.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, handler.visibleWhen.expression, scope ) ) : true;\n            const id = command.id;\n            //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n            const title = getTitle( command, scope, selected );\n            const description = getDescription( command, scope, selected );\n            const icon = command.selectedIcon && selected ? command.selectedIcon : command.icon;\n            const hasPopup = command.type === 'RIBBON';\n            const cellDisplay = command.cellDisplay;\n            const currentTooltip = selected && command.selectedExtendedTooltip ? command.selectedExtendedTooltip : command.extendedTooltip;\n            const decorator = {};\n            decorator.text =  getDecorator( command, scope, selected );\n            decorator.className = command.decorator && command.decorator.class ? command.decorator.class : null;\n            decorator.visibleWhen = command.decorator && command.decorator.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, command.decorator.visibleWhen.expression, scope ) ) : true;\n\n            return new CommandRender( {\n                id,\n                description,\n                title,\n                icon,\n                extendedTooltip: currentTooltip,\n                decorator,\n                cellDisplay\n            }, handler, {\n                enabled,\n                selected,\n                visible,\n                hasPopup\n            }, scope );\n        }\n    }\n    command.trace( 'Command has no active handler' );\n    return new CommandRender( command, null, {\n        enabled: false,\n        selected: false,\n        visible: false\n    }, scope );\n};\n\n/**\n  * Get the latest state for a group command\n  *\n  * Supported types: GROUP\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getGroupCommandRender = ( scope, command ) => {\n    const { showGroupSelected = true } = command;\n    const childCommandStates = command.children.map( child => getCommandRender( scope, child ) );\n    command.trace( 'Child command states', childCommandStates );\n    const visibleChildCommands = childCommandStates.filter( x => x.visible );\n    const groupCommandState = visibleChildCommands.reduce( ( { enabled, selected }, childCommandState ) => {\n        return {\n            enabled: enabled || childCommandState.enabled,\n            selected: showGroupSelected && ( selected || childCommandState.enabled && childCommandState.selected )\n        };\n    }, {\n        enabled: false,\n        selected: false\n    } );\n    const id = command.id;\n    //TODO: selectedTitle / selectedIcon may only apply if type=toggle. Never covered before.\n    const title = getTitle( command, scope, groupCommandState.selected );\n    const description = getDescription( command, scope, groupCommandState.selected );\n    const icon = command.selectedIcon && groupCommandState.selected ? command.selectedIcon : command.icon;\n    const visible = visibleChildCommands.length > 0;\n    const hasPopup = visibleChildCommands.length > 1;\n    return new CommandRender( {\n        id,\n        title,\n        description,\n        icon,\n        extendedTooltip: command.extendedTooltip,\n        decorator: null\n    }, visibleChildCommands.length === 1 ? visibleChildCommands[ 0 ].handler : command.handlers[ 0 ], {\n        ...groupCommandState,\n        hasPopup,\n        visible\n    }, scope );\n};\n\n/**\n  * Get the latest state for a shuttle command\n  *\n  * Supported types: SHUTTLE\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {CommandOverlay} command Unprocessed command overlay\n  * @returns {CommandRender} Latest state for this command\n  */\nconst getShuttleCommandRender = ( scope, command ) => {\n    // pass into command object\n    // pull show group selected property out of command (shuttle should always be false)\n    const showGroupSelected = false;\n    // pull all child command states (ctx)\n    // throw logic onto child commands pull selected properties\n    // .map call function on specific items that creates new array with result of function\n    // passes child state into getCommandRender\n    const childCommandStates = command.children.map( child => getCommandRender( scope, child ) );\n    //  find all of the commands that are visible\n    // .filter creates new array (visibleChildCommands) which has commands w/ property visible = true\n    const visibleChildCommands = childCommandStates.filter( x => x.visible );\n    // adding selected child commands? find commands that are selected\n    // list of current child commands selected & visible\n    // get first selected child out of filtered list (child command 0)\n    const selectedChildCommands = visibleChildCommands.filter( x => x.selected );\n    // groupcommandstate = reduced visible commands, pass to child command state\n    const groupCommandState = visibleChildCommands.reduce( ( { enabled }, childCommandState ) => {\n        return {\n            enabled: enabled || childCommandState.enabled,\n            selected: showGroupSelected\n        };\n    }, {\n        enabled: false,\n        selected: false\n    } );\n\n    const id = command.id;\n    const firstSelectedChild = selectedChildCommands[ 0 ];\n\n    const getShuttleTitle = () => {\n        if( firstSelectedChild ) {\n            return firstSelectedChild.title;\n        }\n        return getTitle( command, scope, groupCommandState.selected );\n    };\n    const getShuttleDescription = () => {\n        //TODO: Should shuttle commands also inherit description?\n        //View mode command with description of a specific view model seems wrong\n        if( firstSelectedChild ) {\n            return firstSelectedChild.description;\n        }\n        return getDescription( command, scope, groupCommandState.selected );\n    };\n    const getShuttleIcon = () => {\n        if( firstSelectedChild ) {\n            return firstSelectedChild.icon;\n        }\n        return command.selectedIcon && groupCommandState.selected ?\n            command.selectedIcon :\n            command.icon;\n    };\n    const getShuttleExtendedTooltip = () => {\n        // If tooltip configured on parent command use that\n        if( command.extendedTooltip ) {\n            return command.extendedTooltip;\n        }\n        // If no tooltip and active child has tooltip use that\n        if( firstSelectedChild && firstSelectedChild.extendedTooltip ) {\n            return firstSelectedChild.extendedTooltip;\n        }\n        // If no tooltip and active child does not have tooltip use title/description of child\n        return null;\n    };\n    const title = getShuttleTitle();\n    const description = getShuttleDescription();\n    const icon = getShuttleIcon();\n\n    const visible = visibleChildCommands.length > 0;\n    const hasPopup = visibleChildCommands.length > 1;\n    return new CommandRender( {\n        id,\n        title,\n        description,\n        icon,\n        extendedTooltip: getShuttleExtendedTooltip(),\n        decorator: null\n    }, visibleChildCommands.length === 1 ? visibleChildCommands[ 0 ].handler : command.handlers[ 0 ], {\n        ...groupCommandState,\n        hasPopup,\n        visible\n    }, scope );\n};\n\n/**\n  * Map of command type to the render function for it\n  */\nconst commandTypeToRenderer = {\n    BASE: getBaseCommandRender,\n    RIBBON: getBaseCommandRender,\n    GROUP: getGroupCommandRender,\n    SHUTTLE: getShuttleCommandRender\n};\n\n/**\n  * Get the latest render data based on the new command state\n  *\n  * @param {Object} scope Evaluation scope for the command\n  * @param {Object} command The unprocessed command data\n  * @returns {CommandRender} Latest render data for the command\n  */\nexport const getCommandRender = ( scope, command ) => {\n    const renderFunction = commandTypeToRenderer[ command.type ] || commandTypeToRenderer.BASE;\n    command.trace( 'Getting current command state', scope, command, renderFunction );\n    const renderResult = renderFunction( scope, command );\n    command.trace( 'Command state', renderResult );\n    debugService.debugCommandRender( command, renderResult );\n    return renderResult;\n};\n\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\nconst getBaseCommandParameters = ( command ) => {\n    const staticCommandParameters = [ 'activeToolsAndInfoCommand.commandId', 'activeNavigationCommand.commandId', 'sidenavCommandId.commandId' ];\n\n    const {\n        ctxParameters: titleParameters,\n        additionalParameters: titleContextParameters\n    } = getCommandI18nParameters( command );\n    return ( command.handlers || [] ).reduce( ( acc, handler ) => {\n        const conditionDeps = [\n            parseCondition( handler.activeWhen ),\n            parseCondition( handler.visibleWhen ),\n            parseCondition( handler.enableWhen ),\n            parseCondition( handler.selectWhen )\n        ];\n        return {\n            ctxParameters: uniq( concat( flatten( conditionDeps.map( x => x.ctxParameters ) ), acc.ctxParameters ) ),\n            additionalParameters: concat( acc.additionalParameters, flatten( conditionDeps.map( x => x.additionalParameters ) ) )\n        };\n    }, {\n        ctxParameters: [ ...titleParameters, ...staticCommandParameters ],\n        additionalParameters: [ command, ...titleContextParameters  ]\n    } );\n};\n\n/**\n  * Parse a CommandOverlay to determine what parameters are needed to get the command state\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx and additional parameters (unresolved)\n  */\nconst getGroupCommandParameters = ( command ) => {\n    const {\n        ctxParameters: titleParameters,\n        additionalParameters: titleContextParameters\n    } = getCommandI18nParameters( command );\n    return command.children.reduce( ( acc, child ) => {\n        const childParameters = getCommandParameters( child );\n        return {\n            ctxParameters: uniq( concat( childParameters.ctxParameters, acc.ctxParameters ) ),\n            additionalParameters: concat( acc.additionalParameters, childParameters.additionalParameters )\n        };\n    }, {\n        ctxParameters: [ ...titleParameters ],\n        additionalParameters: [ command, ...titleContextParameters ]\n    } );\n};\n\nconst commandTypeToParameterMapper = {\n    BASE: getBaseCommandParameters,\n    RIBBON: getBaseCommandParameters,\n    GROUP: getGroupCommandParameters,\n    SHUTTLE: getGroupCommandParameters\n};\n\n/**\n  * Get ctx/other parameters for a property of a command\n  *\n  * @param {CommandOverlay} command command being parsed\n  * @param {String} propName property name\n  * @returns {Object} dependencies\n  */\nconst getI18nParameters = ( command, propName ) => {\n    if( command[propName] ) {\n        return command[propName].parameters.reduce( ( acc, x ) => {\n            const {\n                ctxParameters,\n                additionalParameters\n            } = parseStringCondition( x );\n            return {\n                ctxParameters: [ ...acc.ctxParameters, ...ctxParameters ],\n                additionalParameters: [ ...acc.additionalParameters, ...additionalParameters ]\n            };\n        }, {\n            ctxParameters: [],\n            additionalParameters: []\n        } );\n    }\n    return {\n        ctxParameters: [],\n        additionalParameters: []\n    };\n};\n\n/**\n  * Get parameters for any localized properties that support \"parameter format\"\n  *\n  * @param {CommandOverlay} command command\n  * @returns {Object} ctx parameters\n  */\nconst getCommandI18nParameters = ( command ) => {\n    return [ 'title', 'selectedTitle', 'description', 'selectedDescription' ].reduce( ( acc, propName ) => {\n        const {\n            ctxParameters,\n            additionalParameters\n        } = getI18nParameters( command, propName );\n        return {\n            ctxParameters: [ ...acc.ctxParameters, ...ctxParameters ],\n            additionalParameters: [ ...acc.additionalParameters, ...additionalParameters ]\n        };\n    }, {\n        ctxParameters: [],\n        additionalParameters: []\n    } );\n};\n\n/**\n  * Get anything in ctx that this command depends on\n  *\n  * TODO: Additional parameters will need to be \"resolved\" before returning\n  *\n  * @param {CommandOverlay} command Command to get the information for\n  * @returns {List<Path>} List of lodash get paths (array or string)\n  */\nexport const getCommandParameters = ( command ) => ( commandTypeToParameterMapper[ command.type ] || commandTypeToParameterMapper.BASE )( command );\n\n/**\n  * Get all of the Derived States for the given commands\n  *\n  * @param {Object} vmDef View model definition\n  * @param {Object} props Component properties\n  * @returns {List<DerivedStateResult>} Derived state configurations for commands\n  */\nexport const getCommandStates = ( vmDef, { commandList = [], commandContext = {}, visibleServerCommands = {} } ) => {\n    const scope = {\n        commandContext,\n        visibleServerCommands\n    };\n    //The list of \"additionalParameters\" is just strings initially, need to pull actual values from props\n    const getFromProps = ( path ) => get( scope, path );\n    return commandList.map( cmd => {\n        const {\n            ctxParameters,\n            additionalParameters: additionalParametersRefs\n        } = cmd.parameters || getCommandParameters( { ...cmd } );\n        cmd.parameters = {\n            ctxParameters,\n            additionalParameters: additionalParametersRefs\n        };\n        const additionalParameters = [ additionalParametersRefs[ 0 ], ...additionalParametersRefs.slice( 1 ).map( getFromProps ) ];\n        return new DerivedStateResult( {\n            ctxParameters,\n            additionalParameters,\n            compute: ( { ctx } ) => getCommandRender( {\n                commandContext,\n                ctx: {\n                    ...ctx,\n                    //Fakes visibleServerCommands being in CTX even though it actually local to this command bar\n                    visibleServerCommands\n                }\n            }, additionalParameters[ 0 ] )\n        } );\n    } );\n};\n\nexport default {\n    getCommands,\n    getCommand,\n    executeCommand,\n    executeCommandIfVisibleAndEnabled\n};\n"]},"metadata":{},"sourceType":"module"}