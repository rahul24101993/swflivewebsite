{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to manage native contributions using a registry object generated at build time. Uses ES6 import to load pieces\n * defined in the registry on demand. Also defines the {@link NgServices.contributionService} which is accessible\n * through injection.\n *\n * @module js/contribution.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cfgSvc2 from 'js/configurationService';\nimport _ from 'lodash';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport { afxDynamicImport } from 'js/moduleLoader';\nvar trace = new Debug('contributionService');\nlet exports = {};\n/**\n * Load the set of contributions that are mapped to the given key string.\n *\n * Each contribution should return a function. The function will be called with the key of the contribution\n * and a promise to resolve with the object. With this method contributions have the ability to get the\n * contribution dynamically instead of returning a static object.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @return {Promise} A promise containing the objects that have been contributed.\n */\n\nexport let loadContributions = function (key) {\n  return cfgSvc2.getCfg('contributions').then(function (contributionProviders) {\n    if (contributionProviders[key]) {\n      // return AwPromiseService.instance.all( modules ).then( values => values );\n      return AwPromiseService.instance(function (resolve) {\n        // Allow module loader to manage the caching / registry\n        trace('Loading contributions', key);\n        afxDynamicImport(contributionProviders[key], function handleLoadedContribution() {\n          trace('Contribution load complete', key); // Create a promise for each contribution function\n\n          var promises = []; // Number of arguments is not known so have parse manually as array\n\n          _.forEach(Array.prototype.slice.call(arguments), function (arg, index) {\n            if (_.isFunction(arg)) {\n              var deferredLp = AwPromiseService.instance.defer();\n              arg(key, deferredLp);\n              promises.push(deferredLp.promise);\n            } else {\n              logger.error(contributionProviders[key][index] + ' did not return a contribution function');\n            }\n          }); // And resolve the main promise once all are resolved\n\n\n          resolve(AwPromiseService.instance.all(promises));\n        });\n      });\n    }\n\n    logger.trace(key + ' not found in contribution registry');\n    return [];\n  });\n};\n/**\n * Support a callback based pattern when angular is not loaded. This should only be used before the angular start.\n *\n * Async contributions are not supported with this pattern, so any contributions that support this method must\n * return the value directly.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @param {Function} callback - A callback to call with the newly loaded contributions\n */\n\nexport let requireBeforeAppInitialize = function (key, callback) {\n  // The following fallback is to support the bootstrap usage.\n  var contributionProviders = cfgSvc2.getCfgCached('contributions');\n\n  if (contributionProviders[key]) {\n    // Allow module loader to manage the caching / registry\n    afxDynamicImport(contributionProviders[key], function () {\n      var result = []; // Number of arguments is not known so have parse manually as array\n\n      _.forEach(Array.prototype.slice.call(arguments), function (arg, index) {\n        if (_.isFunction(arg)) {\n          result.push(arg(key));\n        } else {\n          logger.error(contributionProviders[key][index] + ' did not return a contribution function');\n        }\n      });\n\n      callback(result);\n    });\n  } else {\n    logger.trace(key + ' not found in contribution registry');\n    callback([]);\n  }\n};\nexports = {\n  loadContributions,\n  requireBeforeAppInitialize\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/contribution.service.js"],"names":["trace","exports","loadContributions","contributionProviders","afxDynamicImport","promises","_","Array","deferredLp","AwPromiseService","arg","logger","resolve","key","requireBeforeAppInitialize","cfgSvc2","result","callback"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to manage native contributions using a registry object generated at build time. Uses ES6 import to load pieces\n * defined in the registry on demand. Also defines the {@link NgServices.contributionService} which is accessible\n * through injection.\n *\n * @module js/contribution.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cfgSvc2 from 'js/configurationService';\nimport _ from 'lodash';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport { afxDynamicImport } from 'js/moduleLoader';\n\nvar trace = new Debug( 'contributionService' );\n\nlet exports = {};\n\n/**\n * Load the set of contributions that are mapped to the given key string.\n *\n * Each contribution should return a function. The function will be called with the key of the contribution\n * and a promise to resolve with the object. With this method contributions have the ability to get the\n * contribution dynamically instead of returning a static object.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @return {Promise} A promise containing the objects that have been contributed.\n */\nexport let loadContributions = function( key ) {\n    return cfgSvc2.getCfg( 'contributions' ).then( function( contributionProviders ) {\n        if( contributionProviders[ key ] ) {\n            // return AwPromiseService.instance.all( modules ).then( values => values );\n            return AwPromiseService.instance( function( resolve ) {\n                // Allow module loader to manage the caching / registry\n                trace( 'Loading contributions', key );\n                afxDynamicImport( contributionProviders[ key ], function handleLoadedContribution() {\n                    trace( 'Contribution load complete', key );\n                    // Create a promise for each contribution function\n                    var promises = [];\n                    // Number of arguments is not known so have parse manually as array\n                    _.forEach( Array.prototype.slice.call( arguments ), function( arg, index ) {\n                        if( _.isFunction( arg ) ) {\n                            var deferredLp = AwPromiseService.instance.defer();\n                            arg( key, deferredLp );\n                            promises.push( deferredLp.promise );\n                        } else {\n                            logger.error( contributionProviders[ key ][ index ] +\n                                ' did not return a contribution function' );\n                        }\n                    } );\n\n                    // And resolve the main promise once all are resolved\n                    resolve( AwPromiseService.instance.all( promises ) );\n                } );\n            } );\n        }\n        logger.trace( key + ' not found in contribution registry' );\n        return [];\n    } );\n};\n\n/**\n * Support a callback based pattern when angular is not loaded. This should only be used before the angular start.\n *\n * Async contributions are not supported with this pattern, so any contributions that support this method must\n * return the value directly.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @param {Function} callback - A callback to call with the newly loaded contributions\n */\nexport let requireBeforeAppInitialize = function( key, callback ) {\n    // The following fallback is to support the bootstrap usage.\n    var contributionProviders = cfgSvc2.getCfgCached( 'contributions' );\n    if( contributionProviders[ key ] ) {\n        // Allow module loader to manage the caching / registry\n        afxDynamicImport( contributionProviders[ key ], function() {\n            var result = [];\n            // Number of arguments is not known so have parse manually as array\n            _.forEach( Array.prototype.slice.call( arguments ), function( arg, index ) {\n                if( _.isFunction( arg ) ) {\n                    result.push( arg( key ) );\n                } else {\n                    logger.error( contributionProviders[ key ][ index ] + ' did not return a contribution function' );\n                }\n            } );\n            callback( result );\n        } );\n    } else {\n        logger.trace( key + ' not found in contribution registry' );\n        callback( [] );\n    }\n};\n\nexports = {\n    loadContributions,\n    requireBeforeAppInitialize\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}