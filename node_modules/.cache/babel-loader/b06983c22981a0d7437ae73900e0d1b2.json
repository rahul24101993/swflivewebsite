{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link wcagService} which provides services for accessibility related functionalities\n *\n * @module js/wcagService\n */\nimport $ from 'jquery';\nimport localeSvc from 'js/localeService';\nimport popupUtils from 'js/popupUtils';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport domUtils from 'js/domUtils';\nlet exports = {};\nlet dom = domUtils.DOMAPIs;\nlet groupCmdParent = null;\nlet focusableCandidates = ['button:not(.disabled), [href]:not(.disabled), input:not(.disabled), select:not(.disabled), textarea:not(.disabled), [tabindex]:not(.disabled)', 'summary:not(.disabled)'];\nconst ENTER_KEY_CODE_VALUE = 'Enter';\nconst SPACE_KEY_CODE_VALUE = 'Space';\nconst MAIN_SELECTOR = 'main.aw-layout-workareaMain';\n/**\n * Helper function to update aria-label on targetelement located by childlocator\n * @param {Object} containerDOMElement - The element which contains landmark element\n * @param {string} childLocator - string identifying landmakr element within containerDOMElement\n * @param {string} messageFile Name of file containing messages\n */\n\nexport let updateArialabel = function (containerDOMElement, childLocator, messageFile) {\n  let targetElement = null;\n\n  if (containerDOMElement === null) {\n    targetElement = $(childLocator).length > 0 ? $(childLocator)[0] : null;\n  } else if ($(containerDOMElement).find(childLocator).length > 0) {\n    targetElement = $(containerDOMElement).find(childLocator)[0];\n  } else if (childLocator.length === 0) {\n    targetElement = containerDOMElement;\n  }\n\n  if (targetElement !== null) {\n    let ariaLabelKey = targetElement.getAttribute('aria-label').substring(5);\n    localeSvc.getLocalizedText(messageFile, ariaLabelKey).then(function (localizedVal) {\n      targetElement.setAttribute('aria-label', localizedVal);\n    });\n  }\n};\n/**\n * This API is a helper function to add aria-label to duplicate 'main' landmarks.\n *\n */\n\nexport let updateArialabelForDuplicateLandmarks = function () {\n  let mainEls = document.querySelectorAll(MAIN_SELECTOR);\n  let cnt = 1; // below check is to ensure we do not have this attribute set in case there is just one\n  // instance of the landmark on a page\n\n  if (mainEls && mainEls.length !== 1) {\n    for (let i = 0; i < mainEls.length; i++) {\n      localeSvc.getLocalizedText('UIElementsMessages', 'mainLabel').then(function (localizedVal) {\n        let ariaLabelledByAttr = document.createAttribute('aria-label');\n        ariaLabelledByAttr.value = localizedVal + cnt;\n        cnt++;\n        mainEls[i].setAttributeNode(ariaLabelledByAttr);\n      });\n    }\n  }\n};\n/**\n * This API is a helper function to add missing button in form to avoid SiteImprove violations.\n *\n */\n\nexport let updateMissingButtonInForm = function (containerDOMElement) {\n  if (containerDOMElement) {\n    let BUTTON_CLASS = 'aw-hide-form-button';\n    let BUTTON_EL = 'button';\n    let formElem = null;\n\n    if (containerDOMElement.tagName && containerDOMElement.tagName === 'FORM') {\n      formElem = containerDOMElement;\n    } else {\n      formElem = containerDOMElement.querySelector('form');\n    } // intent is to check for the presence of dummy hidden disabled button. Not necessary to check the\n    // presence of an already existing functional button within the form since even if one or more\n    // functional buttons exist within the form , it does not cause any functional failures because\n    // the dummy button is disabled and hence not submit-able.\n\n\n    if (!formElem.querySelector(BUTTON_EL + '.' + BUTTON_CLASS)) {\n      let buttonNode = document.createElement(BUTTON_EL);\n      buttonNode.type = 'submit';\n      buttonNode.classList.add(BUTTON_CLASS);\n      buttonNode.disabled = true;\n      buttonNode.setAttribute('aria-hidden', true);\n      formElem.appendChild(buttonNode);\n    }\n  }\n};\n/**\n * This API is a helper function to find all the focusable children of a DOMElement.\n *\n * @param {DOMElement} containerElement the container to look for focusable children\n * @return {NodeList} all the focusable children\n */\n\nexport let findFocusableChildren = function (containerElement) {\n  return containerElement.querySelectorAll(focusableCandidates);\n};\n/**\n * Finds the next focusable child in the containing element if one child is already focused.\n * Otherwise, can send first focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnFirstChildIfNone whether to return first focusable child if no next child found\n * @return {Node} next focusable child, or first focusable child if none found (option)\n */\n\nexport let findNextFocusableChild = function (containerElement, returnFirstChildIfNone) {\n  let nextFocusableChild = null;\n  const focusableElements = findFocusableChildren(containerElement);\n\n  if (focusableElements && focusableElements.length) {\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (focusableElements[i] === document.activeElement) {\n        if (i + 1 < focusableElements.length) {\n          nextFocusableChild = focusableElements[i + 1];\n        }\n\n        break;\n      }\n    }\n\n    if (!nextFocusableChild && returnFirstChildIfNone) {\n      nextFocusableChild = focusableElements[0];\n    }\n  }\n\n  return nextFocusableChild;\n};\n/**\n * Finds the previous focusable child in the containing element if one child is already focused.\n * Otherwise, can send last focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnLastChildIfNone whether to return last focusable child if no previous child found\n * @return {Node} previous focusable child, or last focusable child if none found (option)\n */\n\nexport let findPreviousFocusableChild = function (containerElement, returnLastChildIfNone) {\n  let previousFocusableChild = null;\n  const focusableElements = findFocusableChildren(containerElement);\n\n  if (focusableElements && focusableElements.length) {\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (focusableElements[i] === document.activeElement) {\n        if (i > 0) {\n          previousFocusableChild = focusableElements[i - 1];\n        }\n\n        break;\n      }\n    }\n\n    if (!previousFocusableChild && returnLastChildIfNone) {\n      previousFocusableChild = focusableElements[focusableElements.length - 1];\n    }\n  }\n\n  return previousFocusableChild;\n};\nexport let setParentOfGroupCmds = function (referenceElement) {\n  groupCmdParent = referenceElement;\n};\nexport let getParentOfGroupCmds = function () {\n  return groupCmdParent;\n};\n\nlet isNotyMsgPresentInDOM = function (notyMessageContainer) {\n  return document.body.contains(notyMessageContainer);\n};\n\nlet isNotyMsgNotfocussed = function (focussableElements) {\n  return document.activeElement !== focussableElements[0];\n};\n\nlet renderFocusToNotyMsg = function () {\n  let notyMsgContainerId = 'noty_bottom_layout_container';\n  let notyMessageContainer = document.getElementById(notyMsgContainerId);\n\n  if (isNotyMsgPresentInDOM(notyMessageContainer)) {\n    let focussableElements = findFocusableChildren(notyMessageContainer);\n\n    if (isNotyMsgNotfocussed(focussableElements)) {\n      focussableElements[0].focus();\n    }\n  }\n};\n\nexport let skipToFirstFocusableElement = function (container, checkActiveFocusInContainer, selectedElementCSS) {\n  // If there is already focused element in container, donot skip to focusbale ele\n  let currentFocusedEle = document.activeElement;\n\n  if (container === undefined || container === null || checkActiveFocusInContainer !== false && container.contains(currentFocusedEle)) {\n    return true;\n  }\n\n  let elementLoading = $(container).find('.aw-element-loading, .aw-jswidgets-loading');\n\n  if (elementLoading.length === 0) {\n    // If there is no element in loading state, then only start focus\n    //Try focus on first selected element\n    if (selectedElementCSS && selectedElementCSS.length > 0) {\n      let elementToFocus = $(container).find(selectedElementCSS);\n\n      if (elementToFocus.length > 0) {\n        elementToFocus[0].focus();\n        renderFocusToNotyMsg();\n\n        if (document.activeElement === elementToFocus[0]) {\n          //Focus successful\n          return true;\n        }\n      }\n    }\n\n    let focusable = findFocusableChildren(container);\n\n    if (focusable && focusable.length > 0) {\n      for (let focusableEle of focusable) {\n        if ($(focusableEle).is(':visible')) {\n          focusableEle.focus();\n          renderFocusToNotyMsg();\n          return true;\n        }\n      }\n    } else {\n      //Check if element it self is focusable\n      container.focus();\n      renderFocusToNotyMsg();\n\n      if (document.activeElement === container) {\n        //Focus successful\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nlet trapFocus = panelRef => event => {\n  let {\n    panelEl: element,\n    options\n  } = panelRef; // apply exclude cases- LCS-443560 - Commands in overflow do not process events after SOA completion\n\n  if (popupUtils.checkIgnore(options, event.target)) {\n    return;\n  } // If new focus element is NOT in current popup element, focus on reference and hide\n\n\n  if (!element.contains(event.target)) {\n    // only do this when tab move to the last element\n    if (event.target.id && event.target.id.includes(element.id)) {\n      skipToFirstFocusableElement(panelRef.options.reference, panelRef.options.checkActiveFocusInContainer); // do not hide an element if the api not available, for example noty_msg should not be hidden\n      // once focus reaches the sentinel\n\n      if (panelRef.options.api) {\n        panelRef.options.api.hide(panelRef);\n      }\n    }\n  }\n}; // Bracket the dialog node with two invisible, focusable nodes.\n// While this dialog is open, we use these to make sure that focus never\n// leaves the document even if dialogNode is the first or last node.\n\n\nlet createSentinel = (element, id) => {\n  let preDiv = document.createElement('div');\n  let preNode = element.parentNode.insertBefore(preDiv, element);\n  preNode.tabIndex = 0;\n  preNode.id = `pre-${id}`;\n  let postDiv = document.createElement('div');\n  let postNode = element.parentNode.insertBefore(postDiv, element.nextSibling);\n  postNode.tabIndex = 0;\n  postNode.id = `post-${id}`;\n  return () => {\n    if (element.parentNode) {\n      //check for presence before removing\n      if (_.includes(element.parentNode.childNodes, preNode)) {\n        element.parentNode.removeChild(preNode);\n      }\n\n      if (_.includes(element.parentNode.childNodes, postNode)) {\n        element.parentNode.removeChild(postNode);\n      }\n    }\n  };\n};\n\nlet configureFocusListener = panelRef => {\n  const focusHandler = trapFocus(panelRef);\n  document.addEventListener('focus', focusHandler, true);\n  return () => {\n    document.removeEventListener('focus', focusHandler, true);\n  };\n};\n\nexport let configureAutoFocus = function (dialogNode, popupRef) {\n  const removeHandlers = [];\n  const {\n    reference,\n    selectedElementCSS\n  } = popupRef.options;\n  removeHandlers.push(createSentinel(dialogNode, popupRef.id));\n  removeHandlers.push(configureFocusListener(popupRef)); // honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.\n\n  const onClose = () => {\n    if (reference) {\n      skipToFirstFocusableElement(reference);\n      setParentOfGroupCmds(reference);\n    }\n  };\n\n  focusFirstDescendantWithDelay(dialogNode, selectedElementCSS);\n  return {\n    removeHandlers,\n    onClose\n  };\n};\nexport let focusFirstDescendantWithDelay = function (element, selectedElementCSS) {\n  let timer = setInterval(() => {\n    // if not existed anymore or element is already rendered\n    if (!element) {\n      clearInterval(timer);\n      return;\n    } // still available\n\n\n    if (element.childNodes) {\n      for (var i = 0; i < element.childNodes.length; i++) {\n        var child = element.childNodes[i];\n\n        if (child.tagName && skipToFirstFocusableElement(child, null, selectedElementCSS)) {\n          clearInterval(timer);\n          return true;\n        }\n      }\n    }\n  }, 50); // clean resource when reach max limit\n\n  setTimeout(() => clearInterval(timer), 5000);\n};\n/**\n * Helper function to add 'Skip to Main' functionality in order to support\n * enter/click option on 'Skip to Main' Bypass block\n */\n\nexport let initializeSkipToMain = function () {\n  let mainElement = document.querySelector(MAIN_SELECTOR);\n\n  if (mainElement) {\n    let focusable = findFocusableChildren(mainElement);\n\n    if (focusable && focusable.length > 0) {\n      let firstFocusable = focusable[0];\n      firstFocusable.focus();\n    }\n  } else {\n    logger.error('missing main landmark');\n  }\n};\n/**\n *  Helper function to apply/unapply focus to 'main' landmark when\n *  a page is focussed for the first time using tab click and when\n *  Skip to main link gets focussed\n */\n\nexport let applyFocusOnMain = function () {\n  let skipToMainLinkElem = null;\n  let mainElement = document.querySelector(MAIN_SELECTOR);\n  skipToMainLinkElem = document.querySelector('a.aw-skip-to-main');\n\n  if (skipToMainLinkElem !== null && mainElement !== null) {\n    dom.on(skipToMainLinkElem, 'focus', () => {\n      mainElement.classList.add('aw-apply-focus-to-main');\n    });\n    dom.on(skipToMainLinkElem, 'blur', () => {\n      mainElement.classList.remove('aw-apply-focus-to-main');\n    });\n  }\n};\n/**\n * get key name - supports modern browsers and IE11\n *\n * @param {Object} event keyboard event object ($event)\n * @returns {String} key name\n */\n\nexport let getKeyName = function (event) {\n  // change space key to string literal 'Space'\n  return event.key === ' ' ? SPACE_KEY_CODE_VALUE : event.key;\n};\n/**\n * check if the keyboard event is equivalent to a mouse click\n *\n * @param {Object} event keyboard event object ($event)\n * @param {boolean} ignoreSpacebar - if the element accepts space as a valid key stroke eg: lov\n * @returns {boolean} true if valid synthetic 'click' pressed\n */\n\nlet isValidKeyPress = function (event, ignoreSpacebar) {\n  let keyPressed = getKeyName(event);\n\n  if (ignoreSpacebar) {\n    if (keyPressed === ENTER_KEY_CODE_VALUE) {\n      return true;\n    }\n  } else {\n    // Default space bar press scrolls the page. Preventing that behavior\n    if (keyPressed === SPACE_KEY_CODE_VALUE) {\n      event.preventDefault();\n    } // Check if keyboard event is equivalent to a mouse click\n\n\n    if (keyPressed === ENTER_KEY_CODE_VALUE || keyPressed === SPACE_KEY_CODE_VALUE) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport let handleMoveUpOrDown = (event, container) => {\n  let keyPressed = getKeyName(event);\n\n  if (keyPressed === 'ArrowUp' || keyPressed === 'ArrowDown') {\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      const nextChildUp = findPreviousFocusableChild(container, true);\n      nextChildUp && nextChildUp.focus();\n    } else {\n      event.preventDefault();\n      const nextChildDown = findNextFocusableChild(container, true);\n      nextChildDown && nextChildDown.focus();\n    }\n  }\n}; // When Element is removed from DOM/ mouse clicked, then focus is lost and then\n// on next press of tab, where should be focus starting point- we have to manually manage focus\n// In order to do this, we add 'aw-focus-startpoint' CSS to element that will be focus starting\n// point on next press of tab key press -check solution below\n//https://sarahmhigley.com/writing/focus-navigation-start-point/#assistive-tech-support\n\nexport let updateFocusStartPoint = eletoUpdateFocus => {\n  if (eletoUpdateFocus !== null) {\n    //Remove flying focus from any existing elements\n    $('.aw-focus-startpoint').removeClass('aw-focus-startpoint'); //Update flying focus on\n\n    eletoUpdateFocus.classList.add('aw-focus-startpoint');\n  }\n};\n/**\n * use this function when you want to programatically focus an element\n * and show the focus style normally reserved for keyboard-mode.\n * @param {Object} elementToFocus - dom element about to get focus\n */\n\nexport let afxFocusElement = elementToFocus => {\n  elementToFocus.focus();\n  document.body.classList.add('keyboard');\n};\n/**\n * use this function to check if the user is operating in keyboard-mode.\n * This is determined based on the user's most recent action.\n * returns true if from keyboard. 'false' if from mouse.\n * @returns {boolean} true if it is a keyboard event\n */\n\nexport let areWeInKeyboardMode = () => {\n  if (document.body.classList.contains('keyboard')) {\n    return true;\n  }\n\n  return false;\n};\nexports = {\n  updateArialabel,\n  updateArialabelForDuplicateLandmarks,\n  updateMissingButtonInForm,\n  initializeSkipToMain,\n  findFocusableChildren,\n  findNextFocusableChild,\n  findPreviousFocusableChild,\n  skipToFirstFocusableElement,\n  setParentOfGroupCmds,\n  getParentOfGroupCmds,\n  focusFirstDescendantWithDelay,\n  applyFocusOnMain,\n  isValidKeyPress,\n  configureAutoFocus,\n  getKeyName,\n  handleMoveUpOrDown,\n  updateFocusStartPoint,\n  afxFocusElement,\n  areWeInKeyboardMode\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uielements/src/js/wcagService.js"],"names":["exports","dom","domUtils","groupCmdParent","focusableCandidates","ENTER_KEY_CODE_VALUE","SPACE_KEY_CODE_VALUE","MAIN_SELECTOR","updateArialabel","targetElement","containerDOMElement","$","childLocator","ariaLabelKey","localeSvc","updateArialabelForDuplicateLandmarks","mainEls","document","cnt","i","ariaLabelledByAttr","localizedVal","updateMissingButtonInForm","BUTTON_CLASS","BUTTON_EL","formElem","buttonNode","findFocusableChildren","containerElement","findNextFocusableChild","nextFocusableChild","focusableElements","findPreviousFocusableChild","previousFocusableChild","setParentOfGroupCmds","getParentOfGroupCmds","isNotyMsgPresentInDOM","isNotyMsgNotfocussed","focussableElements","renderFocusToNotyMsg","notyMsgContainerId","notyMessageContainer","skipToFirstFocusableElement","currentFocusedEle","container","checkActiveFocusInContainer","elementLoading","selectedElementCSS","elementToFocus","focusable","focusableEle","trapFocus","panelRef","event","panelEl","options","popupUtils","element","createSentinel","preDiv","preNode","id","postDiv","postNode","_","configureFocusListener","focusHandler","configureAutoFocus","removeHandlers","popupRef","onClose","focusFirstDescendantWithDelay","timer","setInterval","clearInterval","child","setTimeout","initializeSkipToMain","mainElement","firstFocusable","logger","applyFocusOnMain","skipToMainLinkElem","getKeyName","isValidKeyPress","keyPressed","handleMoveUpOrDown","nextChildUp","nextChildDown","updateFocusStartPoint","eletoUpdateFocus","afxFocusElement","areWeInKeyboardMode"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link wcagService} which provides services for accessibility related functionalities\n *\n * @module js/wcagService\n */\nimport $ from 'jquery';\nimport localeSvc from 'js/localeService';\nimport popupUtils from 'js/popupUtils';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport domUtils from 'js/domUtils';\n\nlet exports = {};\nlet dom = domUtils.DOMAPIs;\nlet groupCmdParent = null;\nlet focusableCandidates = [ 'button:not(.disabled), [href]:not(.disabled), input:not(.disabled), select:not(.disabled), textarea:not(.disabled), [tabindex]:not(.disabled)', 'summary:not(.disabled)' ];\nconst ENTER_KEY_CODE_VALUE = 'Enter';\nconst SPACE_KEY_CODE_VALUE = 'Space';\nconst MAIN_SELECTOR = 'main.aw-layout-workareaMain';\n\n/**\n * Helper function to update aria-label on targetelement located by childlocator\n * @param {Object} containerDOMElement - The element which contains landmark element\n * @param {string} childLocator - string identifying landmakr element within containerDOMElement\n * @param {string} messageFile Name of file containing messages\n */\nexport let updateArialabel = function( containerDOMElement, childLocator, messageFile ) {\n    let targetElement = null;\n    if( containerDOMElement === null ) {\n        targetElement = $( childLocator ).length > 0 ? $( childLocator )[ 0 ] : null;\n    } else if( $( containerDOMElement ).find( childLocator ).length > 0 ) {\n        targetElement = $( containerDOMElement ).find( childLocator )[ 0 ];\n    } else if( childLocator.length === 0 ) {\n        targetElement = containerDOMElement;\n    }\n    if( targetElement !== null ) {\n        let ariaLabelKey = targetElement.getAttribute( 'aria-label' ).substring( 5 );\n        localeSvc.getLocalizedText( messageFile, ariaLabelKey ).then( function( localizedVal ) {\n            targetElement.setAttribute( 'aria-label', localizedVal );\n        } );\n    }\n};\n\n/**\n * This API is a helper function to add aria-label to duplicate 'main' landmarks.\n *\n */\nexport let updateArialabelForDuplicateLandmarks = function() {\n    let mainEls = document.querySelectorAll( MAIN_SELECTOR );\n    let cnt = 1;\n    // below check is to ensure we do not have this attribute set in case there is just one\n    // instance of the landmark on a page\n    if( mainEls && mainEls.length !== 1 ) {\n        for( let i = 0; i < mainEls.length; i++ ) {\n            localeSvc.getLocalizedText( 'UIElementsMessages', 'mainLabel' ).then( function( localizedVal ) {\n                let ariaLabelledByAttr = document.createAttribute( 'aria-label' );\n                ariaLabelledByAttr.value = localizedVal + cnt;\n                cnt++;\n                mainEls[ i ].setAttributeNode( ariaLabelledByAttr );\n            } );\n        }\n    }\n};\n\n/**\n * This API is a helper function to add missing button in form to avoid SiteImprove violations.\n *\n */\nexport let updateMissingButtonInForm = function( containerDOMElement ) {\n    if( containerDOMElement ) {\n        let BUTTON_CLASS = 'aw-hide-form-button';\n        let BUTTON_EL = 'button';\n        let formElem = null;\n        if( containerDOMElement.tagName && containerDOMElement.tagName === 'FORM' ) {\n            formElem = containerDOMElement;\n        } else {\n            formElem = containerDOMElement.querySelector( 'form' );\n        }\n        // intent is to check for the presence of dummy hidden disabled button. Not necessary to check the\n        // presence of an already existing functional button within the form since even if one or more\n        // functional buttons exist within the form , it does not cause any functional failures because\n        // the dummy button is disabled and hence not submit-able.\n        if( !formElem.querySelector( BUTTON_EL + '.' + BUTTON_CLASS ) ) {\n            let buttonNode = document.createElement( BUTTON_EL );\n            buttonNode.type = 'submit';\n            buttonNode.classList.add( BUTTON_CLASS );\n            buttonNode.disabled = true;\n            buttonNode.setAttribute( 'aria-hidden', true );\n            formElem.appendChild( buttonNode );\n        }\n    }\n};\n\n/**\n * This API is a helper function to find all the focusable children of a DOMElement.\n *\n * @param {DOMElement} containerElement the container to look for focusable children\n * @return {NodeList} all the focusable children\n */\nexport let findFocusableChildren = function( containerElement ) {\n    return containerElement.querySelectorAll( focusableCandidates );\n};\n\n/**\n * Finds the next focusable child in the containing element if one child is already focused.\n * Otherwise, can send first focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnFirstChildIfNone whether to return first focusable child if no next child found\n * @return {Node} next focusable child, or first focusable child if none found (option)\n */\nexport let findNextFocusableChild = function( containerElement, returnFirstChildIfNone ) {\n    let nextFocusableChild = null;\n    const focusableElements = findFocusableChildren( containerElement );\n    if( focusableElements && focusableElements.length ) {\n        for( let i = 0; i < focusableElements.length; i++ ) {\n            if( focusableElements[ i ] === document.activeElement ) {\n                if( i + 1 < focusableElements.length ) {\n                    nextFocusableChild = focusableElements[ i + 1 ];\n                }\n                break;\n            }\n        }\n        if( !nextFocusableChild && returnFirstChildIfNone ) {\n            nextFocusableChild = focusableElements[ 0 ];\n        }\n    }\n    return nextFocusableChild;\n};\n\n/**\n * Finds the previous focusable child in the containing element if one child is already focused.\n * Otherwise, can send last focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnLastChildIfNone whether to return last focusable child if no previous child found\n * @return {Node} previous focusable child, or last focusable child if none found (option)\n */\nexport let findPreviousFocusableChild = function( containerElement, returnLastChildIfNone ) {\n    let previousFocusableChild = null;\n    const focusableElements = findFocusableChildren( containerElement );\n    if( focusableElements && focusableElements.length ) {\n        for( let i = 0; i < focusableElements.length; i++ ) {\n            if( focusableElements[ i ] === document.activeElement ) {\n                if( i > 0 ) {\n                    previousFocusableChild = focusableElements[ i - 1 ];\n                }\n                break;\n            }\n        }\n        if( !previousFocusableChild && returnLastChildIfNone ) {\n            previousFocusableChild = focusableElements[ focusableElements.length - 1 ];\n        }\n    }\n    return previousFocusableChild;\n};\n\nexport let setParentOfGroupCmds = function( referenceElement ) {\n    groupCmdParent = referenceElement;\n};\n\nexport let getParentOfGroupCmds = function() {\n    return groupCmdParent;\n};\n\nlet isNotyMsgPresentInDOM = function( notyMessageContainer ) {\n    return document.body.contains( notyMessageContainer );\n};\n\nlet isNotyMsgNotfocussed = function( focussableElements ) {\n    return document.activeElement !== focussableElements[ 0 ];\n};\n\nlet renderFocusToNotyMsg = function() {\n    let notyMsgContainerId = 'noty_bottom_layout_container';\n    let notyMessageContainer = document.getElementById( notyMsgContainerId );\n\n    if( isNotyMsgPresentInDOM( notyMessageContainer ) ) {\n        let focussableElements = findFocusableChildren( notyMessageContainer );\n        if( isNotyMsgNotfocussed( focussableElements ) ) {\n            focussableElements[ 0 ].focus();\n        }\n    }\n};\n\nexport let skipToFirstFocusableElement = function( container, checkActiveFocusInContainer, selectedElementCSS ) {\n    // If there is already focused element in container, donot skip to focusbale ele\n    let currentFocusedEle = document.activeElement;\n    if( container === undefined || container === null || checkActiveFocusInContainer !== false && container.contains( currentFocusedEle ) ) {\n        return true;\n    }\n\n    let elementLoading = $( container ).find( '.aw-element-loading, .aw-jswidgets-loading' );\n    if( elementLoading.length === 0 ) {\n        // If there is no element in loading state, then only start focus\n        //Try focus on first selected element\n        if( selectedElementCSS && selectedElementCSS.length > 0 ) {\n            let elementToFocus = $( container ).find( selectedElementCSS );\n            if( elementToFocus.length > 0 ) {\n                elementToFocus[ 0 ].focus();\n                renderFocusToNotyMsg();\n                if( document.activeElement === elementToFocus[ 0 ] ) {\n                    //Focus successful\n                    return true;\n                }\n            }\n        }\n        let focusable = findFocusableChildren( container );\n        if( focusable && focusable.length > 0 ) {\n            for( let focusableEle of focusable ) {\n                if( $( focusableEle ).is( ':visible' ) ) {\n                    focusableEle.focus();\n                    renderFocusToNotyMsg();\n                    return true;\n                }\n            }\n        } else {\n            //Check if element it self is focusable\n            container.focus();\n            renderFocusToNotyMsg();\n            if( document.activeElement === container ) {\n                //Focus successful\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nlet trapFocus = ( panelRef ) => ( event ) => {\n    let { panelEl: element, options } = panelRef;\n\n    // apply exclude cases- LCS-443560 - Commands in overflow do not process events after SOA completion\n    if( popupUtils.checkIgnore( options, event.target ) ) { return; }\n\n    // If new focus element is NOT in current popup element, focus on reference and hide\n    if( !element.contains( event.target ) ) {\n        // only do this when tab move to the last element\n        if( event.target.id && event.target.id.includes( element.id ) ) {\n            skipToFirstFocusableElement( panelRef.options.reference, panelRef.options.checkActiveFocusInContainer );\n\n            // do not hide an element if the api not available, for example noty_msg should not be hidden\n            // once focus reaches the sentinel\n            if( panelRef.options.api ) {\n                panelRef.options.api.hide( panelRef );\n            }\n        }\n    }\n};\n\n// Bracket the dialog node with two invisible, focusable nodes.\n// While this dialog is open, we use these to make sure that focus never\n// leaves the document even if dialogNode is the first or last node.\nlet createSentinel = ( element, id ) => {\n    let preDiv = document.createElement( 'div' );\n    let preNode = element.parentNode.insertBefore( preDiv, element );\n    preNode.tabIndex = 0;\n    preNode.id = `pre-${id}`;\n\n    let postDiv = document.createElement( 'div' );\n    let postNode = element.parentNode.insertBefore( postDiv, element.nextSibling );\n    postNode.tabIndex = 0;\n    postNode.id = `post-${id}`;\n    return () => {\n        if( element.parentNode ) {\n            //check for presence before removing\n            if( _.includes( element.parentNode.childNodes, preNode ) ) {\n                element.parentNode.removeChild( preNode );\n            }\n            if( _.includes( element.parentNode.childNodes, postNode ) ) {\n                element.parentNode.removeChild( postNode );\n            }\n        }\n    };\n};\n\nlet configureFocusListener = ( panelRef ) => {\n    const focusHandler = trapFocus( panelRef );\n    document.addEventListener( 'focus', focusHandler, true );\n\n    return () => {\n        document.removeEventListener( 'focus', focusHandler, true );\n    };\n};\n\nexport let configureAutoFocus = function( dialogNode, popupRef ) {\n    const removeHandlers = [];\n    const { reference, selectedElementCSS } = popupRef.options;\n\n    removeHandlers.push( createSentinel( dialogNode, popupRef.id ) );\n    removeHandlers.push( configureFocusListener( popupRef ) );\n\n    // honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.\n    const onClose = () => {\n        if( reference ) {\n            skipToFirstFocusableElement( reference );\n            setParentOfGroupCmds( reference );\n        }\n    };\n\n    focusFirstDescendantWithDelay( dialogNode, selectedElementCSS );\n\n    return {\n        removeHandlers,\n        onClose\n    };\n};\n\nexport let focusFirstDescendantWithDelay = function( element, selectedElementCSS ) {\n    let timer = setInterval( () => {\n        // if not existed anymore or element is already rendered\n        if( !element ) {\n            clearInterval( timer );\n            return;\n        }\n        // still available\n        if( element.childNodes ) {\n            for( var i = 0; i < element.childNodes.length; i++ ) {\n                var child = element.childNodes[ i ];\n                if( child.tagName && skipToFirstFocusableElement( child, null, selectedElementCSS ) ) {\n                    clearInterval( timer );\n                    return true;\n                }\n            }\n        }\n    }, 50 );\n    // clean resource when reach max limit\n    setTimeout( () => clearInterval( timer ), 5000 );\n};\n\n/**\n * Helper function to add 'Skip to Main' functionality in order to support\n * enter/click option on 'Skip to Main' Bypass block\n */\nexport let initializeSkipToMain = function() {\n    let mainElement = document.querySelector( MAIN_SELECTOR );\n    if( mainElement ) {\n        let focusable = findFocusableChildren( mainElement );\n        if( focusable && focusable.length > 0 ) {\n            let firstFocusable = focusable[ 0 ];\n            firstFocusable.focus();\n        }\n    } else {\n        logger.error( 'missing main landmark' );\n    }\n};\n\n/**\n *  Helper function to apply/unapply focus to 'main' landmark when\n *  a page is focussed for the first time using tab click and when\n *  Skip to main link gets focussed\n */\nexport let applyFocusOnMain = function() {\n    let skipToMainLinkElem = null;\n    let mainElement = document.querySelector( MAIN_SELECTOR );\n    skipToMainLinkElem = document.querySelector( 'a.aw-skip-to-main' );\n    if( skipToMainLinkElem !== null && mainElement !== null ) {\n        dom.on( skipToMainLinkElem, 'focus', () => {\n            mainElement.classList.add( 'aw-apply-focus-to-main' );\n        } );\n        dom.on( skipToMainLinkElem, 'blur', () => {\n            mainElement.classList.remove( 'aw-apply-focus-to-main' );\n        } );\n    }\n};\n\n/**\n * get key name - supports modern browsers and IE11\n *\n * @param {Object} event keyboard event object ($event)\n * @returns {String} key name\n */\nexport let getKeyName = function( event ) {\n    // change space key to string literal 'Space'\n    return event.key === ' ' ? SPACE_KEY_CODE_VALUE : event.key;\n};\n\n/**\n * check if the keyboard event is equivalent to a mouse click\n *\n * @param {Object} event keyboard event object ($event)\n * @param {boolean} ignoreSpacebar - if the element accepts space as a valid key stroke eg: lov\n * @returns {boolean} true if valid synthetic 'click' pressed\n */\nlet isValidKeyPress = function( event, ignoreSpacebar ) {\n    let keyPressed = getKeyName( event );\n    if( ignoreSpacebar ) {\n        if( keyPressed === ENTER_KEY_CODE_VALUE ) {\n            return true;\n        }\n    } else {\n        // Default space bar press scrolls the page. Preventing that behavior\n        if( keyPressed === SPACE_KEY_CODE_VALUE ) {\n            event.preventDefault();\n        }\n        // Check if keyboard event is equivalent to a mouse click\n        if( keyPressed === ENTER_KEY_CODE_VALUE || keyPressed === SPACE_KEY_CODE_VALUE ) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport let handleMoveUpOrDown = ( event, container ) => {\n    let keyPressed = getKeyName( event );\n    if( keyPressed === 'ArrowUp' || keyPressed === 'ArrowDown' ) {\n        if( event.key === 'ArrowUp' ) {\n            event.preventDefault();\n            const nextChildUp = findPreviousFocusableChild( container, true );\n            nextChildUp && nextChildUp.focus();\n        } else {\n            event.preventDefault();\n            const nextChildDown = findNextFocusableChild( container, true );\n            nextChildDown && nextChildDown.focus();\n        }\n    }\n};\n\n// When Element is removed from DOM/ mouse clicked, then focus is lost and then\n// on next press of tab, where should be focus starting point- we have to manually manage focus\n// In order to do this, we add 'aw-focus-startpoint' CSS to element that will be focus starting\n// point on next press of tab key press -check solution below\n//https://sarahmhigley.com/writing/focus-navigation-start-point/#assistive-tech-support\nexport let updateFocusStartPoint = ( eletoUpdateFocus ) => {\n    if( eletoUpdateFocus !== null ) {\n        //Remove flying focus from any existing elements\n        $( '.aw-focus-startpoint' ).removeClass( 'aw-focus-startpoint' );\n        //Update flying focus on\n        eletoUpdateFocus.classList.add( 'aw-focus-startpoint' );\n    }\n};\n\n/**\n * use this function when you want to programatically focus an element\n * and show the focus style normally reserved for keyboard-mode.\n * @param {Object} elementToFocus - dom element about to get focus\n */\nexport let afxFocusElement = ( elementToFocus ) => {\n    elementToFocus.focus();\n    document.body.classList.add( 'keyboard' );\n};\n\n/**\n * use this function to check if the user is operating in keyboard-mode.\n * This is determined based on the user's most recent action.\n * returns true if from keyboard. 'false' if from mouse.\n * @returns {boolean} true if it is a keyboard event\n */\nexport let areWeInKeyboardMode = () => {\n    if( document.body.classList.contains( 'keyboard' ) ) {\n        return true;\n    }\n    return false;\n};\n\nexports = {\n    updateArialabel,\n    updateArialabelForDuplicateLandmarks,\n    updateMissingButtonInForm,\n    initializeSkipToMain,\n    findFocusableChildren,\n    findNextFocusableChild,\n    findPreviousFocusableChild,\n    skipToFirstFocusableElement,\n    setParentOfGroupCmds,\n    getParentOfGroupCmds,\n    focusFirstDescendantWithDelay,\n    applyFocusOnMain,\n    isValidKeyPress,\n    configureAutoFocus,\n    getKeyName,\n    handleMoveUpOrDown,\n    updateFocusStartPoint,\n    afxFocusElement,\n    areWeInKeyboardMode\n};\n\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}