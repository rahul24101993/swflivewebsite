{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This is the integration logic with the route change events.\n *\n * NOTE - since this is loaded PRIOR to app.initModule() it can't use the typical angular resolution patterns. Needs to\n * be treated as a ES6 only module.\n *\n * @module js/routeChangeHandler\n */\nimport sessionState from 'js/sessionState';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\nimport workspaceValService from 'js/workspaceValidationService';\nimport pageService from 'js/page.service';\nimport postLoginPipeLineSvc from 'js/postLoginPipeline.service';\nimport awConfiguration from 'js/awConfiguration';\nimport eventBus from 'js/eventBus';\nvar exports = {};\n/**\n * state change handler function called when the router is about to transition states. Leverages the\n * authentication state information to determine whether or not to prevent the current route change, and trigger\n * the authentication path.\n *\n * If session state shows already authenticated, allow the transition.\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n * @param {Object} options ui-router navigation options\n */\n\nexport let routeStateChangeStart = function (toState, toParams, fromState, fromParams, options) {\n  // this gets run prior to bootstrap finishing, so there is no angular resolution available.\n  const defer = AwPromiseService.instance.defer();\n\n  if (!sessionState.getIsAuthenticated()) {\n    if (!sessionState.isAuthenticationInProgress()) {\n      // save these for future nav trigger -- NOT SURE about SSO case.\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // the session may be ok, but until we ask the server we don't know.\n      // event.preventDefault();\n\n      defer.reject('routeChangeHandler: prevent State'); // From this point, we can trigger async load behavior since the event has been updated.\n      // check if there is a valid current session, if so continue, otherwise trigger\n      // the authentication path.\n\n      sessionState.performValidSessionCheck(targetNavDetails);\n    } else {\n      // during authInProgress true, Only page that without auth\n      // can be accessed.\n      if (!toState.noAuth) {\n        sessionState.setAuthStatus(false);\n        sessionState.setAuthenticationInProgress(false); // event.preventDefault();\n\n        defer.reject('routeChangeHandler: prevent State'); // stop the auth processing of the current flow, stop the nav request for\n        // this new URL, but trigger a state change to the new target route.\n\n        sessionState.forceNavigation(toState, toParams);\n      }\n    }\n\n    defer.resolve();\n  } else {\n    workspaceValService.isValidPageAsync(toState.name).then(function (changeState) {\n      var defRoutePath = awConfiguration.get('defaultRoutePath'); // If the page being navigated to is not a valid page (i.e. not in the list of available pages for the workspace),\n      // go to the default page. If it is a valid page, we might be here because the user has switched his workspace and the\n      // page user was on is no longer a valid page in the new workspace. So go to the default page.\n\n      if (!changeState || toParams.validateDefaultRoutePath === 'true' && toState.name !== defRoutePath) {\n        // event.preventDefault();\n        defer.reject('routeChangeHandler: prevent State');\n        AwStateService.instance.go(defRoutePath);\n      }\n    });\n    defer.resolve();\n  }\n\n  return defer.promise;\n};\n/**\n * Invoked when the state change was successful from UI router\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n */\n\nexport let routeStateChangeSuccess = function (toState, toParams, fromState, fromParams) {\n  var allStagesAuthenticated = postLoginPipeLineSvc.checkPostLoginAuthenticatedStages();\n\n  if (sessionState && sessionState.getIsAuthenticated()) {\n    if (allStagesAuthenticated) {\n      sessionState.routeStateChangeSuccess(toState, toParams, fromState, fromParams);\n      pageService.navigateToDefaultSubPage(toState, toParams);\n    } else {\n      sessionState.runPostLoginStages();\n    }\n  }\n};\n/**\n * delegates from the route resolution down into the session state ES6 module. This simply wraps the load\n * and call to the session manager.\n *\n * @param {Object} $q - promise Q\n * @return {Promise} promise\n */\n\nexport let pickAuthenticator = function () {\n  return sessionState.pickAuthenticator();\n};\neventBus.subscribe('transitionHooks', _ref => {\n  let {\n    transitionService\n  } = _ref;\n\n  /**\n   * Replacement of $stateChangeSuccess\n   */\n  transitionService.onSuccess({}, function (transition) {\n    exports.routeStateChangeSuccess(transition.to(), transition.params(), transition.from(), transition.params('from'));\n  });\n  /**\n   * Replacement of $stateChangeStart\n   */\n\n  transitionService.onEnter({}, function (transition) {\n    return exports.routeStateChangeStart(transition.to(), transition.params(), transition.from(), transition.params('from'), transition.options());\n  });\n});\nexports = {\n  routeStateChangeStart,\n  routeStateChangeSuccess,\n  pickAuthenticator\n};\nexport default exports;","map":{"version":3,"names":["sessionState","AwPromiseService","AwStateService","workspaceValService","pageService","postLoginPipeLineSvc","awConfiguration","eventBus","exports","routeStateChangeStart","toState","toParams","fromState","fromParams","options","defer","instance","getIsAuthenticated","isAuthenticationInProgress","targetNavDetails","reject","performValidSessionCheck","noAuth","setAuthStatus","setAuthenticationInProgress","forceNavigation","resolve","isValidPageAsync","name","then","changeState","defRoutePath","get","validateDefaultRoutePath","go","promise","routeStateChangeSuccess","allStagesAuthenticated","checkPostLoginAuthenticatedStages","navigateToDefaultSubPage","runPostLoginStages","pickAuthenticator","subscribe","transitionService","onSuccess","transition","to","params","from","onEnter"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/routeChangeHandler.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This is the integration logic with the route change events.\n *\n * NOTE - since this is loaded PRIOR to app.initModule() it can't use the typical angular resolution patterns. Needs to\n * be treated as a ES6 only module.\n *\n * @module js/routeChangeHandler\n */\nimport sessionState from 'js/sessionState';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\nimport workspaceValService from 'js/workspaceValidationService';\nimport pageService from 'js/page.service';\nimport postLoginPipeLineSvc from 'js/postLoginPipeline.service';\nimport awConfiguration from 'js/awConfiguration';\nimport eventBus from 'js/eventBus';\nvar exports = {};\n\n/**\n * state change handler function called when the router is about to transition states. Leverages the\n * authentication state information to determine whether or not to prevent the current route change, and trigger\n * the authentication path.\n *\n * If session state shows already authenticated, allow the transition.\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n * @param {Object} options ui-router navigation options\n */\nexport let routeStateChangeStart = function( toState, toParams, fromState, fromParams, options ) {\n    // this gets run prior to bootstrap finishing, so there is no angular resolution available.\n    const defer = AwPromiseService.instance.defer();\n    if( !sessionState.getIsAuthenticated() ) {\n        if( !sessionState.isAuthenticationInProgress() ) {\n            // save these for future nav trigger -- NOT SURE about SSO case.\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // the session may be ok, but until we ask the server we don't know.\n            // event.preventDefault();\n            defer.reject( 'routeChangeHandler: prevent State' );\n            // From this point, we can trigger async load behavior since the event has been updated.\n\n            // check if there is a valid current session, if so continue, otherwise trigger\n            // the authentication path.\n            sessionState.performValidSessionCheck( targetNavDetails );\n        } else {\n            // during authInProgress true, Only page that without auth\n            // can be accessed.\n            if( !toState.noAuth ) {\n                sessionState.setAuthStatus( false );\n                sessionState.setAuthenticationInProgress( false );\n                // event.preventDefault();\n                defer.reject( 'routeChangeHandler: prevent State' );\n\n                // stop the auth processing of the current flow, stop the nav request for\n                // this new URL, but trigger a state change to the new target route.\n                sessionState.forceNavigation( toState, toParams );\n            }\n        }\n        defer.resolve();\n    } else {\n        workspaceValService.isValidPageAsync( toState.name ).then(\n            function( changeState ) {\n                var defRoutePath = awConfiguration.get( 'defaultRoutePath' );\n                // If the page being navigated to is not a valid page (i.e. not in the list of available pages for the workspace),\n                // go to the default page. If it is a valid page, we might be here because the user has switched his workspace and the\n                // page user was on is no longer a valid page in the new workspace. So go to the default page.\n\n                if( !changeState || toParams.validateDefaultRoutePath === 'true' &&\n                    toState.name !== defRoutePath ) {\n                    // event.preventDefault();\n                    defer.reject( 'routeChangeHandler: prevent State' );\n\n                    AwStateService.instance.go( defRoutePath );\n                }\n            } );\n        defer.resolve();\n    }\n    return defer.promise;\n};\n\n/**\n * Invoked when the state change was successful from UI router\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n */\nexport let routeStateChangeSuccess = function( toState, toParams, fromState, fromParams ) {\n    var allStagesAuthenticated = postLoginPipeLineSvc.checkPostLoginAuthenticatedStages();\n    if( sessionState && sessionState.getIsAuthenticated() ) {\n        if( allStagesAuthenticated ) {\n            sessionState.routeStateChangeSuccess( toState, toParams, fromState, fromParams );\n            pageService.navigateToDefaultSubPage( toState, toParams );\n        } else {\n            sessionState.runPostLoginStages();\n        }\n    }\n};\n\n/**\n * delegates from the route resolution down into the session state ES6 module. This simply wraps the load\n * and call to the session manager.\n *\n * @param {Object} $q - promise Q\n * @return {Promise} promise\n */\nexport let pickAuthenticator = function() {\n    return sessionState.pickAuthenticator();\n};\neventBus.subscribe( 'transitionHooks', ( { transitionService } ) => {\n    /**\n     * Replacement of $stateChangeSuccess\n     */\n    transitionService.onSuccess( {}, function( transition ) {\n        exports.routeStateChangeSuccess( transition.to(), transition.params(), transition.from(), transition.params( 'from' ) );\n    } );\n    /**\n     * Replacement of $stateChangeStart\n     */\n    transitionService.onEnter( {}, function( transition ) {\n        return exports.routeStateChangeStart( transition.to(), transition.params(), transition.from(), transition.params( 'from' ), transition.options() );\n    } );\n} );\n\nexports = {\n    routeStateChangeStart,\n    routeStateChangeSuccess,\n    pickAuthenticator\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}