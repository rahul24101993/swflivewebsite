{"ast":null,"code":"/* eslint-disable no-await-in-loop */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabRegistryService} which manages tabs.\n *\n * @module js/tabRegistry.service\n */\nimport Debug from 'debug';\nimport AwPromiseService from 'js/awPromiseService';\nimport eventBus from 'js/eventBus';\nimport htmlUtils from 'js/htmlUtils';\nimport wcagSvc from 'js/wcagService';\nconst registry = {};\nconst trace = new Debug('tabRegistryService');\n/**\n * Register a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {List<Object>} tabs List of tabs in tab set (all tabs, not just visible)\n * @param {Object} registryData Callback to change tabs and the tabs that are currently visible\n * @throws Error if tabSetId is already registered\n */\n\nexport function registerTabSet(tabSetId, _ref) {\n  let {\n    changeTab,\n    highlightTab,\n    tabs\n  } = _ref;\n  trace(`Tab set ${tabSetId} registered: ${tabs.map(t => t.tabKey)}`);\n\n  if (registry[tabSetId]) {\n    throw new Error(`Tab set with ID ${tabSetId} is already registered`);\n  }\n\n  registry[tabSetId] = {\n    changeTab,\n    highlightTab,\n    tabs\n  }; // Announce tabset registration\n\n  eventBus.publish(tabSetId + '.tabSetRegistered');\n}\n/**\n * Remove registration of a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n */\n\nexport function unregisterTabSet(tabSetId) {\n  trace(`Tab set ${tabSetId} unregistered`);\n  delete registry[tabSetId]; // Announce tabset un-registration\n\n  eventBus.publish(tabSetId + '.tabSetUnregistered');\n}\n/**\n * Get the list of tabs currently visible in the tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @returns {List<Object>} List of tabs visible in the tab set. Null if tab set is not registered.\n */\n\nexport function getVisibleTabs(tabSetId) {\n  const registration = registry[tabSetId];\n  return registration ? registration.tabs : null;\n}\n/**\n * Change the selected tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to change to\n * @returns {Promise<Void>} Promise resolved when tab transition is complete. Rejected if transition fails or tab is not visible.\n */\n\nexport function changeTab(tabSetId, targetTabId) {\n  const targetTab = (getVisibleTabs(tabSetId) || []).filter(tab => tab.tabKey === targetTabId)[0];\n  const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n\n  return targetTab ? ps.resolve(registry[tabSetId].changeTab(targetTab)) : ps.reject(`${targetTabId} is not available in tab set`);\n}\n/**\n * Highlight tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to be highlighted\n * @returns {Promise<Void>} Promise resolved when tab highlight is complete. Rejected if tab is not visible.\n */\n\nexport function highlightTab(tabSetId, targetTabId) {\n  const targetTab = (getVisibleTabs(tabSetId) || []).filter(tab => tab.tabKey === targetTabId)[0];\n  const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n\n  return targetTab ? ps.resolve(registry[tabSetId].highlightTab(targetTab)) : ps.reject(`${targetTabId} is not available in tab set`);\n}\nconst retryMaxCount = 10;\nconst idleTimeMs = 50;\n/**\n * Delay the execution for a given ms\n *\n * @function delay\n * @param {Number} ms - amount of milliseconds to wait\n * @return {Promise} promise - resolved after x amount of milliseconds\n */\n\nconst delay = function (ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n/**\n * Get the Tab Element based off ID and xPath\n *\n * @function getTabElement\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n * @returns {Element} - the html element to the tab\n */\n\n\nexport const getTabElement = async function (tabId, xPath) {\n  let tabElement = htmlUtils.getElementByXpath(xPath, document.body);\n\n  if (tabElement) {\n    let tabIndex = tabElement.getAttribute('tabindex');\n\n    if (parseInt(tabIndex) > -1) {\n      return tabElement;\n    } // tab is in overflow\n\n\n    const tabContainer = tabElement.closest('.sw-tabContainer');\n\n    if (tabContainer) {\n      const overflowBtn = tabContainer.nextElementSibling;\n\n      if (overflowBtn) {\n        overflowBtn.querySelector('button').click();\n        let retryCounter = 0;\n        let popupTabElement;\n        let loadingElement;\n        setTimeout(function () {\n          retryCounter = retryMaxCount; // After 10 seconds just quit\n        }, 10000);\n\n        while (retryCounter < retryMaxCount) {\n          loadingElement = htmlUtils.getElementByXpath('//div[contains(@class, \\'aw-popup-command-bar\\')]//div[contains(@class, \\'aw-jswidgets-loading\\')]', document.body);\n\n          if (!loadingElement) {\n            popupTabElement = htmlUtils.getElementByXpath(`//li[@tabkey='${tabId}']`, document.body);\n\n            if (popupTabElement) {\n              return popupTabElement;\n            }\n\n            retryCounter++;\n          }\n\n          await delay(idleTimeMs);\n        }\n      }\n    }\n  }\n};\n/**\n * Click on the tab\n *\n * @function clickOnTab\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\n\nexport const clickOnTab = async function (tabId, xPath) {\n  const tabElement = await getTabElement(tabId, xPath);\n\n  if (tabElement) {\n    tabElement.click();\n  }\n};\n/**\n * @function highlightTabBasedOnXPath\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\n\nexport const highlightTabBasedOnXPath = async function (tabId, xPath) {\n  const tabElement = await getTabElement(tabId, xPath);\n\n  if (tabElement) {\n    wcagSvc.afxFocusElement(tabElement);\n  }\n};\nconst exports = {\n  changeTab,\n  highlightTab,\n  getVisibleTabs,\n  registerTabSet,\n  unregisterTabSet,\n  clickOnTab,\n  highlightTabBasedOnXPath\n};\nexport default exports;","map":{"version":3,"names":["Debug","AwPromiseService","eventBus","htmlUtils","wcagSvc","registry","trace","registerTabSet","tabSetId","changeTab","highlightTab","tabs","map","t","tabKey","Error","publish","unregisterTabSet","getVisibleTabs","registration","targetTabId","targetTab","filter","tab","ps","instance","resolve","reject","retryMaxCount","idleTimeMs","delay","ms","Promise","setTimeout","getTabElement","tabId","xPath","tabElement","getElementByXpath","document","body","tabIndex","getAttribute","parseInt","tabContainer","closest","overflowBtn","nextElementSibling","querySelector","click","retryCounter","popupTabElement","loadingElement","clickOnTab","highlightTabBasedOnXPath","afxFocusElement","exports"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/tabRegistry.service.js"],"sourcesContent":["/* eslint-disable no-await-in-loop */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabRegistryService} which manages tabs.\n *\n * @module js/tabRegistry.service\n */\nimport Debug from 'debug';\nimport AwPromiseService from 'js/awPromiseService';\nimport eventBus from 'js/eventBus';\nimport htmlUtils from 'js/htmlUtils';\nimport wcagSvc from 'js/wcagService';\n\nconst registry = {};\nconst trace = new Debug( 'tabRegistryService' );\n\n\n/**\n * Register a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {List<Object>} tabs List of tabs in tab set (all tabs, not just visible)\n * @param {Object} registryData Callback to change tabs and the tabs that are currently visible\n * @throws Error if tabSetId is already registered\n */\nexport function registerTabSet( tabSetId, {\n    changeTab,\n    highlightTab,\n    tabs\n} ) {\n    trace( `Tab set ${tabSetId} registered: ${tabs.map( t => t.tabKey )}` );\n    if( registry[ tabSetId ] ) {\n        throw new Error( `Tab set with ID ${tabSetId} is already registered` );\n    }\n    registry[ tabSetId ] = {\n        changeTab,\n        highlightTab,\n        tabs\n    };\n    // Announce tabset registration\n    eventBus.publish( tabSetId + '.tabSetRegistered' );\n}\n\n/**\n * Remove registration of a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n */\nexport function unregisterTabSet( tabSetId ) {\n    trace( `Tab set ${tabSetId} unregistered` );\n    delete registry[ tabSetId ];\n    // Announce tabset un-registration\n    eventBus.publish( tabSetId + '.tabSetUnregistered' );\n}\n\n/**\n * Get the list of tabs currently visible in the tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @returns {List<Object>} List of tabs visible in the tab set. Null if tab set is not registered.\n */\nexport function getVisibleTabs( tabSetId ) {\n    const registration = registry[ tabSetId ];\n    return registration ? registration.tabs : null;\n}\n\n/**\n * Change the selected tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to change to\n * @returns {Promise<Void>} Promise resolved when tab transition is complete. Rejected if transition fails or tab is not visible.\n */\nexport function changeTab( tabSetId, targetTabId ) {\n    const targetTab = ( getVisibleTabs( tabSetId ) || [] ).filter( tab => tab.tabKey === targetTabId )[0];\n    const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n    return targetTab ? ps.resolve( registry[ tabSetId ].changeTab( targetTab ) ) : ps.reject( `${targetTabId} is not available in tab set` );\n}\n\n/**\n * Highlight tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to be highlighted\n * @returns {Promise<Void>} Promise resolved when tab highlight is complete. Rejected if tab is not visible.\n */\nexport function highlightTab( tabSetId, targetTabId ) {\n    const targetTab = ( getVisibleTabs( tabSetId ) || [] ).filter( tab => tab.tabKey === targetTabId )[0];\n    const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n    return targetTab ? ps.resolve( registry[ tabSetId ].highlightTab( targetTab ) ) : ps.reject( `${targetTabId} is not available in tab set` );\n}\n\nconst retryMaxCount = 10;\n\nconst idleTimeMs = 50;\n\n/**\n * Delay the execution for a given ms\n *\n * @function delay\n * @param {Number} ms - amount of milliseconds to wait\n * @return {Promise} promise - resolved after x amount of milliseconds\n */\nconst delay = function( ms ) {\n    return new Promise( resolve => setTimeout( resolve, ms ) );\n};\n\n/**\n * Get the Tab Element based off ID and xPath\n *\n * @function getTabElement\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n * @returns {Element} - the html element to the tab\n */\nexport const getTabElement = async function( tabId, xPath ) {\n    let tabElement = htmlUtils.getElementByXpath( xPath, document.body );\n    if( tabElement ) {\n        let tabIndex = tabElement.getAttribute( 'tabindex' );\n        if( parseInt( tabIndex ) > -1 ) {\n            return tabElement;\n        }\n        // tab is in overflow\n        const tabContainer = tabElement.closest( '.sw-tabContainer' );\n        if( tabContainer ) {\n            const overflowBtn = tabContainer.nextElementSibling;\n            if( overflowBtn ) {\n                overflowBtn.querySelector( 'button' ).click();\n                let retryCounter = 0;\n                let popupTabElement;\n                let loadingElement;\n\n                setTimeout( function() {\n                    retryCounter = retryMaxCount; // After 10 seconds just quit\n                }, 10000 );\n\n                while( retryCounter < retryMaxCount ) {\n                    loadingElement = htmlUtils.getElementByXpath( '//div[contains(@class, \\'aw-popup-command-bar\\')]//div[contains(@class, \\'aw-jswidgets-loading\\')]', document.body );\n                    if( !loadingElement ) {\n                        popupTabElement = htmlUtils.getElementByXpath( `//li[@tabkey='${tabId}']`, document.body );\n                        if( popupTabElement ) {\n                            return popupTabElement;\n                        }\n                        retryCounter++;\n                    }\n                    await delay( idleTimeMs );\n                }\n            }\n        }\n    }\n};\n\n\n/**\n * Click on the tab\n *\n * @function clickOnTab\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\nexport const clickOnTab = async function( tabId, xPath ) {\n    const tabElement = await getTabElement( tabId, xPath );\n    if( tabElement ) {\n        tabElement.click();\n    }\n};\n\n/**\n * @function highlightTabBasedOnXPath\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\nexport const highlightTabBasedOnXPath = async function( tabId, xPath ) {\n    const tabElement = await getTabElement( tabId, xPath );\n    if( tabElement ) {\n        wcagSvc.afxFocusElement( tabElement );\n    }\n};\n\nconst exports = {\n    changeTab,\n    highlightTab,\n    getVisibleTabs,\n    registerTabSet,\n    unregisterTabSet,\n    clickOnTab,\n    highlightTabBasedOnXPath\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}