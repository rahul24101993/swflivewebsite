{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to parse the mongo-db like expression.\n *\n * @module js/adapterParserService\n *\n * @namespace adapterParserService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport _ from 'lodash';\nimport assert from 'js/assert';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport moduleLoader from 'js/moduleLoader';\n\nvar _adapterConfigObject;\n\nvar exports = {};\nvar OP_ARRAY = ['$and', '$or'];\nvar _conditionQuickEval = {};\n/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n */\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n *\n * @returns {ObjectArray} objects adapted from source using adapter configuration.\n */\n\nexport let getAdaptedObjectsSync = function (sourceObjects, adapterConfigObject) {\n  var adaptedObjects = [];\n  adaptedObjects = adaptedObjects.concat(sourceObjects);\n  assert(adapterConfigObject, 'The Adapter Config service is not loaded');\n  _adapterConfigObject = adapterConfigObject;\n\n  if (!_.isEmpty(_adapterConfigObject)) {\n    var adoptees = [];\n\n    _.forEach(sourceObjects, function (sourceObject) {\n      var verdictObj = exports.applyConditions(sourceObject);\n\n      if (verdictObj && verdictObj.verdict) {\n        var targetProp = _adapterConfigObject[verdictObj.index].target;\n\n        if (targetProp.prop) {\n          var propObjs = sourceObject.props[targetProp.prop];\n          propObjs = _.isArray(propObjs) ? propObjs : [propObjs];\n\n          _.forEach(propObjs, function (prop) {\n            if (prop && prop.dbValues) {\n              _.forEach(prop.dbValues, function (dbValue) {\n                var modelObject = cdm.getObject(dbValue);\n\n                if (modelObject) {\n                  adoptees.push(modelObject);\n                } else {\n                  adoptees.push(sourceObject);\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n\n    if (adoptees && adoptees.length > 0) {\n      adaptedObjects = adoptees;\n    }\n  }\n\n  return adaptedObjects;\n};\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n * @param {Boolean} isFullyAdapted - if object should be recursively adapted\n *\n * @return {Promise} Resolved with an array of adapted objects containing the results of the operation.\n */\n\nexport let getAdaptedObjects = function (sourceObjects, adapterConfigObject, isFullyAdapted) {\n  assert(adapterConfigObject, 'The Adapter Config service is not loaded');\n  _adapterConfigObject = adapterConfigObject;\n\n  if (!_.isEmpty(_adapterConfigObject)) {\n    var promises = [];\n    var adoptees = [];\n\n    _.forEach(sourceObjects, function (sourceObject) {\n      promises.push(_getAdaptedObjectSource(sourceObject, isFullyAdapted));\n    });\n\n    return AwPromiseService.instance.all(promises).then(function (results) {\n      _.forEach(results, function (result) {\n        adoptees = adoptees.concat(result);\n      });\n\n      return adoptees;\n    });\n  }\n\n  return AwPromiseService.instance.resolve(sourceObjects);\n};\n/**\n * This is to set the adapter config object\n *\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n */\n\nexport let setConfiguration = function (adapterConfigObject) {\n  _adapterConfigObject = adapterConfigObject;\n};\n/**\n * This method apply and evaluate the conditions on the source object and returns boolean value accordingly.\n *\n * @param {Object} sourceObject - source object\n * @param {Object} configObject - solution config object in case this function is called from a different context\n * @returns {Object} verdict object\n */\n\nexport let applyConditions = function (sourceObject, configObject) {\n  var index = 0;\n  var verdict = false;\n\n  if (!_.isUndefined(configObject)) {\n    _adapterConfigObject = configObject;\n  }\n\n  while (index < _adapterConfigObject.length) {\n    var adaptrObjConf = _adapterConfigObject[index];\n    var adaptrObjConfConds = adaptrObjConf.conditions;\n\n    if (adaptrObjConfConds) {\n      var condKeys = _.keys(adaptrObjConfConds)[0];\n\n      if (_.indexOf(OP_ARRAY, condKeys) >= 0) {\n        verdict = _traverseQueryTree(adaptrObjConfConds, sourceObject)[0];\n      } else {\n        verdict = _evaluateLeafNodes(adaptrObjConfConds, sourceObject);\n      }\n    }\n\n    if (verdict) {\n      break;\n    }\n\n    index++;\n  }\n\n  var verdictObj = {};\n  verdictObj.index = index;\n  verdictObj.verdict = verdict;\n  return verdictObj;\n};\n/**\n * @param {Object} sourceObject - source object\n * @param {Object} verdictObj - verdict object\n *\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\n\nvar _getAdoptees = function (sourceObject, verdictObj) {\n  var deferred = AwPromiseService.instance.defer();\n  var allAdoptees = [];\n\n  if (verdictObj.verdict) {\n    var targetProp = _adapterConfigObject[verdictObj.index].target;\n\n    if (targetProp.prop) {\n      var adaptedObjs = sourceObject.props[targetProp.prop];\n\n      if (adaptedObjs instanceof Array && adaptedObjs.length > 0) {\n        allAdoptees = allAdoptees.concat(adaptedObjs);\n      } else if (adaptedObjs) {\n        allAdoptees.push(adaptedObjs);\n      }\n    }\n\n    if ((targetProp.method || targetProp.methodAsync) && targetProp.deps) {\n      moduleLoader.loadDependentModule(targetProp.deps).then(function (depModuleObj) {\n        // _deps will be undefined when try to load adapterService inside itself\n        var _depModuleObj = depModuleObj;\n\n        if (!depModuleObj && targetProp.deps === 'js/adapterService') {\n          _depModuleObj = exports;\n        }\n\n        if (targetProp.method) {\n          var ret = _depModuleObj[targetProp.method].apply(_depModuleObj, [allAdoptees]);\n\n          deferred.resolve(ret);\n        } else {\n          var retPromise = _depModuleObj[targetProp.methodAsync].apply(_depModuleObj, [allAdoptees]);\n\n          retPromise.then(function (response) {\n            deferred.resolve(response);\n          }, function (error) {\n            deferred.reject(error);\n          });\n        }\n      });\n    } else {\n      deferred.resolve(allAdoptees);\n    }\n  } else {\n    allAdoptees.push(sourceObject);\n    deferred.resolve(allAdoptees);\n  }\n\n  return deferred.promise;\n};\n/**\n * private object, not exposed out of service This is placeholder of two functions\n */\n\n\nvar _logicalOperator = {};\n/**\n * This takes array of boolean values and evaluate it in AND mode.\n *\n * @param {Object} values - values\n * @return {boolean} verdict\n */\n\n_logicalOperator.$and = function (values) {\n  assert(values instanceof Array, 'Values is not an array');\n  var verdict = true;\n\n  _.forEach(values, function (val) {\n    if (!val) {\n      verdict = false;\n      return false; // to break the loop, not return value\n    }\n  });\n\n  return verdict;\n};\n/**\n * This takes array of boolean values and evaluate it in OR mode\n *\n * @param {Object} values - values\n * @return {Boolean} verdict\n */\n\n\n_logicalOperator.$or = function (values) {\n  assert(values instanceof Array, 'Values is not an array');\n  var verdict = false;\n\n  _.forEach(values, function (val) {\n    if (val) {\n      verdict = true;\n      return false; // to break the loop, not return value\n    }\n  });\n\n  return verdict;\n};\n/**\n *\n * This method traverses the adapter condition file recursively to evaluate it against the source object\n *\n * @param {Object} rootObj - root object\n * @param {Object} sourceObject - source object\n * @return {Array} values\n */\n\n\nvar _traverseQueryTree = function (rootObj, sourceObject) {\n  var values = [];\n\n  _.forEach(rootObj, function (childObj, logicalOps) {\n    if (_.indexOf(OP_ARRAY, logicalOps) >= 0) {\n      assert(childObj instanceof Array, 'The value of and/or logical operators should be in Array');\n      values.push(_logicalOperator[logicalOps](_traverseQueryTree(childObj, sourceObject)));\n    } else if (_.intersection(OP_ARRAY, _.keys(childObj)).length > 0) {\n      values = values.concat(_traverseQueryTree(childObj, sourceObject));\n    } else {\n      var val = _evaluateLeafNodes(childObj, sourceObject);\n\n      if (!_.isUndefined(val)) {\n        values.push(val);\n      }\n    }\n  });\n\n  return values;\n};\n/**\n * @param {Object} leafNode - leaf node\n * @param {Object} sourceObject - source object\n * @return {Boolean|null} TRUE if conditions are valid\n */\n\n\nvar _evaluateLeafNodes = function (leafNode, sourceObject) {\n  var propKey = _.keys(leafNode)[0];\n\n  assert(_.indexOf(OP_ARRAY, propKey) < 0, 'These are not the leaf level nodes to evaluate');\n\n  if (_.indexOf(OP_ARRAY, propKey) < 0) {\n    var propRealValue = _.get(sourceObject, propKey);\n\n    var condition = _.get(leafNode, propKey);\n\n    var condKey = _.keys(condition)[0];\n\n    var condVal = _.get(condition, condKey);\n\n    var compareToKey = propKey + '@' + condKey; // modelType.typeHierarchy@$in\n\n    var compareTo = {};\n    compareTo[compareToKey] = condVal;\n\n    if (!_conditionQuickEval[compareToKey]) {\n      _conditionQuickEval[compareToKey] = expressionParserUtils.getEvaluationFn(condKey, propKey, compareTo);\n    }\n\n    return _conditionQuickEval[compareToKey](condVal, propRealValue);\n  }\n\n  return null;\n};\n/**\n * Retrieves the adapted object recursively.\n *\n * @param {*} sourceObject - source object\n * @param {*} isFullyAdapted - if object should be recursively adapted\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\n\n\nvar _getAdaptedObjectSource = function (sourceObject, isFullyAdapted) {\n  var deferred = AwPromiseService.instance.defer();\n  var adaptedReturnObjects = [];\n  var verdictObject = exports.applyConditions(sourceObject);\n\n  if (verdictObject.verdict) {\n    var adaptedObjectPromise = _getAdoptees(sourceObject, verdictObject);\n\n    adaptedObjectPromise.then(function (adaptedObjects) {\n      if (isFullyAdapted) {\n        var deferredPromises = [];\n\n        _.forEach(adaptedObjects, function (adaptedObject) {\n          deferredPromises.push(_getAdaptedObjectSource(adaptedObject, isFullyAdapted));\n        });\n\n        AwPromiseService.instance.all(deferredPromises).then(function (results) {\n          _.forEach(results, function (result) {\n            adaptedReturnObjects = adaptedReturnObjects.concat(result);\n          });\n\n          deferred.resolve(adaptedReturnObjects);\n        });\n      } else {\n        deferred.resolve(adaptedObjects);\n      }\n    });\n  } else {\n    adaptedReturnObjects.push(sourceObject);\n    deferred.resolve(adaptedReturnObjects);\n  }\n\n  return deferred.promise;\n};\n\nexports = {\n  getAdaptedObjectsSync,\n  getAdaptedObjects,\n  setConfiguration,\n  applyConditions\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/adapterParserService.js"],"names":["exports","OP_ARRAY","_conditionQuickEval","getAdaptedObjectsSync","adaptedObjects","assert","_adapterConfigObject","_","adoptees","verdictObj","targetProp","propObjs","sourceObject","prop","modelObject","cdm","getAdaptedObjects","promises","_getAdaptedObjectSource","AwPromiseService","setConfiguration","applyConditions","index","verdict","adaptrObjConf","adaptrObjConfConds","condKeys","_traverseQueryTree","_evaluateLeafNodes","_getAdoptees","deferred","allAdoptees","adaptedObjs","moduleLoader","_depModuleObj","ret","retPromise","_logicalOperator","values","childObj","val","propKey","propRealValue","condition","condKey","condVal","compareToKey","compareTo","expressionParserUtils","adaptedReturnObjects","verdictObject","adaptedObjectPromise","deferredPromises"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to parse the mongo-db like expression.\n *\n * @module js/adapterParserService\n *\n * @namespace adapterParserService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport _ from 'lodash';\nimport assert from 'js/assert';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport moduleLoader from 'js/moduleLoader';\n\nvar _adapterConfigObject;\n\nvar exports = {};\n\nvar OP_ARRAY = [ '$and', '$or' ];\n\nvar _conditionQuickEval = {};\n\n/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n */\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n *\n * @returns {ObjectArray} objects adapted from source using adapter configuration.\n */\nexport let getAdaptedObjectsSync = function( sourceObjects, adapterConfigObject ) {\n    var adaptedObjects = [];\n    adaptedObjects = adaptedObjects.concat( sourceObjects );\n\n    assert( adapterConfigObject, 'The Adapter Config service is not loaded' );\n    _adapterConfigObject = adapterConfigObject;\n\n    if( !_.isEmpty( _adapterConfigObject ) ) {\n        var adoptees = [];\n        _.forEach( sourceObjects, function( sourceObject ) {\n            var verdictObj = exports.applyConditions( sourceObject );\n            if( verdictObj && verdictObj.verdict ) {\n                var targetProp = _adapterConfigObject[ verdictObj.index ].target;\n                if( targetProp.prop ) {\n                    var propObjs = sourceObject.props[ targetProp.prop ];\n                    propObjs = _.isArray( propObjs ) ? propObjs : [ propObjs ];\n                    _.forEach( propObjs, function( prop ) {\n                        if( prop && prop.dbValues ) {\n                            _.forEach( prop.dbValues, function( dbValue ) {\n                                var modelObject = cdm.getObject( dbValue );\n                                if( modelObject ) {\n                                    adoptees.push( modelObject );\n                                } else {\n                                    adoptees.push( sourceObject );\n                                }\n                            } );\n                        }\n                    } );\n                }\n            }\n        } );\n\n        if( adoptees && adoptees.length > 0 ) {\n            adaptedObjects = adoptees;\n        }\n    }\n\n    return adaptedObjects;\n};\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n * @param {Boolean} isFullyAdapted - if object should be recursively adapted\n *\n * @return {Promise} Resolved with an array of adapted objects containing the results of the operation.\n */\nexport let getAdaptedObjects = function( sourceObjects, adapterConfigObject, isFullyAdapted ) {\n    assert( adapterConfigObject, 'The Adapter Config service is not loaded' );\n    _adapterConfigObject = adapterConfigObject;\n\n    if( !_.isEmpty( _adapterConfigObject ) ) {\n        var promises = [];\n        var adoptees = [];\n        _.forEach( sourceObjects, function( sourceObject ) {\n            promises.push( _getAdaptedObjectSource( sourceObject, isFullyAdapted ) );\n        } );\n\n        return AwPromiseService.instance.all( promises ).then( function( results ) {\n            _.forEach( results, function( result ) {\n                adoptees = adoptees.concat( result );\n            } );\n            return adoptees;\n        } );\n    }\n    return AwPromiseService.instance.resolve( sourceObjects );\n};\n\n/**\n * This is to set the adapter config object\n *\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n */\nexport let setConfiguration = function( adapterConfigObject ) {\n    _adapterConfigObject = adapterConfigObject;\n};\n\n/**\n * This method apply and evaluate the conditions on the source object and returns boolean value accordingly.\n *\n * @param {Object} sourceObject - source object\n * @param {Object} configObject - solution config object in case this function is called from a different context\n * @returns {Object} verdict object\n */\nexport let applyConditions = function( sourceObject, configObject ) {\n    var index = 0;\n    var verdict = false;\n    if( !_.isUndefined( configObject ) ) {\n        _adapterConfigObject = configObject;\n    }\n    while( index < _adapterConfigObject.length ) {\n        var adaptrObjConf = _adapterConfigObject[ index ];\n        var adaptrObjConfConds = adaptrObjConf.conditions;\n        if( adaptrObjConfConds ) {\n            var condKeys = _.keys( adaptrObjConfConds )[ 0 ];\n            if( _.indexOf( OP_ARRAY, condKeys ) >= 0 ) {\n                verdict = _traverseQueryTree( adaptrObjConfConds, sourceObject )[ 0 ];\n            } else {\n                verdict = _evaluateLeafNodes( adaptrObjConfConds, sourceObject );\n            }\n        }\n        if( verdict ) {\n            break;\n        }\n        index++;\n    }\n\n    var verdictObj = {};\n    verdictObj.index = index;\n    verdictObj.verdict = verdict;\n\n    return verdictObj;\n};\n\n/**\n * @param {Object} sourceObject - source object\n * @param {Object} verdictObj - verdict object\n *\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\nvar _getAdoptees = function( sourceObject, verdictObj ) {\n    var deferred = AwPromiseService.instance.defer();\n    var allAdoptees = [];\n\n    if( verdictObj.verdict ) {\n        var targetProp = _adapterConfigObject[ verdictObj.index ].target;\n        if( targetProp.prop ) {\n            var adaptedObjs = sourceObject.props[ targetProp.prop ];\n            if( adaptedObjs instanceof Array && adaptedObjs.length > 0 ) {\n                allAdoptees = allAdoptees.concat( adaptedObjs );\n            } else if( adaptedObjs ) {\n                allAdoptees.push( adaptedObjs );\n            }\n        }\n\n        if( ( targetProp.method || targetProp.methodAsync ) && targetProp.deps ) {\n            moduleLoader.loadDependentModule( targetProp.deps ).then(\n                function( depModuleObj ) {\n                    // _deps will be undefined when try to load adapterService inside itself\n                    var _depModuleObj = depModuleObj;\n                    if( !depModuleObj && targetProp.deps === 'js/adapterService' ) {\n                        _depModuleObj = exports;\n                    }\n\n                    if( targetProp.method ) {\n                        var ret = _depModuleObj[ targetProp.method ].apply( _depModuleObj, [ allAdoptees ] );\n                        deferred.resolve( ret );\n                    } else {\n                        var retPromise = _depModuleObj[ targetProp.methodAsync ].apply( _depModuleObj, [ allAdoptees ] );\n                        retPromise.then( function( response ) {\n                            deferred.resolve( response );\n                        }, function( error ) {\n                            deferred.reject( error );\n                        } );\n                    }\n                } );\n        } else {\n            deferred.resolve( allAdoptees );\n        }\n    } else {\n        allAdoptees.push( sourceObject );\n        deferred.resolve( allAdoptees );\n    }\n\n    return deferred.promise;\n};\n\n/**\n * private object, not exposed out of service This is placeholder of two functions\n */\nvar _logicalOperator = {};\n\n/**\n * This takes array of boolean values and evaluate it in AND mode.\n *\n * @param {Object} values - values\n * @return {boolean} verdict\n */\n_logicalOperator.$and = function( values ) {\n    assert( values instanceof Array, 'Values is not an array' );\n    var verdict = true;\n    _.forEach( values, function( val ) {\n        if( !val ) {\n            verdict = false;\n            return false; // to break the loop, not return value\n        }\n    } );\n    return verdict;\n};\n\n/**\n * This takes array of boolean values and evaluate it in OR mode\n *\n * @param {Object} values - values\n * @return {Boolean} verdict\n */\n_logicalOperator.$or = function( values ) {\n    assert( values instanceof Array, 'Values is not an array' );\n    var verdict = false;\n    _.forEach( values, function( val ) {\n        if( val ) {\n            verdict = true;\n            return false; // to break the loop, not return value\n        }\n    } );\n    return verdict;\n};\n\n/**\n *\n * This method traverses the adapter condition file recursively to evaluate it against the source object\n *\n * @param {Object} rootObj - root object\n * @param {Object} sourceObject - source object\n * @return {Array} values\n */\nvar _traverseQueryTree = function( rootObj, sourceObject ) {\n    var values = [];\n    _.forEach( rootObj, function( childObj, logicalOps ) {\n        if( _.indexOf( OP_ARRAY, logicalOps ) >= 0 ) {\n            assert( childObj instanceof Array, 'The value of and/or logical operators should be in Array' );\n            values.push( _logicalOperator[ logicalOps ]( _traverseQueryTree( childObj, sourceObject ) ) );\n        } else if( _.intersection( OP_ARRAY, _.keys( childObj ) ).length > 0 ) {\n            values = values.concat( _traverseQueryTree( childObj, sourceObject ) );\n        } else {\n            var val = _evaluateLeafNodes( childObj, sourceObject );\n            if( !_.isUndefined( val ) ) {\n                values.push( val );\n            }\n        }\n    } );\n    return values;\n};\n\n/**\n * @param {Object} leafNode - leaf node\n * @param {Object} sourceObject - source object\n * @return {Boolean|null} TRUE if conditions are valid\n */\nvar _evaluateLeafNodes = function( leafNode, sourceObject ) {\n    var propKey = _.keys( leafNode )[ 0 ];\n    assert( _.indexOf( OP_ARRAY, propKey ) < 0, 'These are not the leaf level nodes to evaluate' );\n    if( _.indexOf( OP_ARRAY, propKey ) < 0 ) {\n        var propRealValue = _.get( sourceObject, propKey );\n        var condition = _.get( leafNode, propKey );\n        var condKey = _.keys( condition )[ 0 ];\n        var condVal = _.get( condition, condKey );\n        var compareToKey = propKey + '@' + condKey; // modelType.typeHierarchy@$in\n        var compareTo = {};\n        compareTo[ compareToKey ] = condVal;\n        if( !_conditionQuickEval[ compareToKey ] ) {\n            _conditionQuickEval[ compareToKey ] = expressionParserUtils.getEvaluationFn( condKey, propKey, compareTo );\n        }\n        return _conditionQuickEval[ compareToKey ]( condVal, propRealValue );\n    }\n    return null;\n};\n\n/**\n * Retrieves the adapted object recursively.\n *\n * @param {*} sourceObject - source object\n * @param {*} isFullyAdapted - if object should be recursively adapted\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\nvar _getAdaptedObjectSource = function( sourceObject, isFullyAdapted ) {\n    var deferred = AwPromiseService.instance.defer();\n    var adaptedReturnObjects = [];\n    var verdictObject = exports.applyConditions( sourceObject );\n\n    if( verdictObject.verdict ) {\n        var adaptedObjectPromise = _getAdoptees( sourceObject, verdictObject );\n\n        adaptedObjectPromise.then( function( adaptedObjects ) {\n            if( isFullyAdapted ) {\n                var deferredPromises = [];\n\n                _.forEach( adaptedObjects, function( adaptedObject ) {\n                    deferredPromises.push( _getAdaptedObjectSource( adaptedObject, isFullyAdapted ) );\n                } );\n\n                AwPromiseService.instance.all( deferredPromises ).then( function( results ) {\n                    _.forEach( results, function( result ) {\n                        adaptedReturnObjects = adaptedReturnObjects.concat( result );\n                    } );\n\n                    deferred.resolve( adaptedReturnObjects );\n                } );\n            } else {\n                deferred.resolve( adaptedObjects );\n            }\n        } );\n    } else {\n        adaptedReturnObjects.push( sourceObject );\n        deferred.resolve( adaptedReturnObjects );\n    }\n\n    return deferred.promise;\n};\n\nexports = {\n    getAdaptedObjectsSync,\n    getAdaptedObjects,\n    setConfiguration,\n    applyConditions\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}