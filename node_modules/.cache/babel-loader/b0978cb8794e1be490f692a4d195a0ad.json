{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSPLMTableNativeService\n */\nimport * as eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport splmTableFactory from 'js/splmTableFactory';\nimport awTableSvc from 'js/awTableService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport columnFilterService from 'js/awColumnFilterService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport viewModelObjectService from 'js/viewModelObjectService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport * as cfgSvc from 'js/awConfiguration';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport util from 'js/splmTableUtils';\nexport const initializeTable = function (element, viewModelCollection, dataCtxNode, declGridParam, runActionWithViewModel) {\n  // revisitme:\n  // tstark - leave for refactor\n  // - viewModelCollection has no use here.\n  // - passing element as ref can save one factor of memory leak.\n  // - But the dataCtxNode and declGridParam is too complex, we have viewModel -> data -> dataProvider,\n  //   almost impossible to know where the closure is getting hold. The fact I know is by dummy the data,\n  //   the symptom will go away\n  let tableCallbacks = {};\n  let declGridObj = { ...declGridParam\n  };\n  const gridid = declGridObj.gridid;\n  const dataProvider = declGridObj.dataProviderInstance;\n  const columnProvider = declGridObj.columnProviderInstance;\n  declarativeDataCtxService.applyScope(dataCtxNode.data, declGridObj.gridOptions, null, dataCtxNode, null);\n  let gridOptions = declGridObj.gridOptions;\n  let declViewModel = dataCtxNode.data;\n  var instanceEventSubcr = [];\n  var tableInstance = null;\n  let tableElem = null;\n  var _previousSelections = [];\n  const tableInstanceCallbacks = {};\n  columnProvider.setColumnFilters([]);\n  /**\n    * Refresh the table content by invoking the action to reload first page of data provider\n    */\n\n  var reloadDataProvider = function () {\n    if (gridid) {\n      if (dataProvider && dataProvider.json && dataProvider.json.firstPage) {\n        delete dataProvider.json.firstPage;\n      }\n\n      dataProvider.resetDataProvider();\n      /**\n        * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n        * tstark - leave for refactor\n        * Delete firstPage results only on dataProvider reset\n       if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n           delete dataProvider.json.firstPage;\n       }\n       viewModelSvc.executeCommand( declViewModel, dataProvider, dataCtxNode );\n        */\n    }\n  };\n\n  if (gridid) {\n    var propertyProvider = declViewModel.dataProviders[declGridObj.propertyProvider];\n\n    if (!columnProvider.sortCallback) {\n      columnProvider.sortCallback = function () {\n        reloadDataProvider();\n      };\n    } // Attach enableArrangeMenu to gridOptions because we are not passing grid into splmTable\n\n\n    gridOptions = gridOptions || {};\n    gridOptions.enableArrangeMenu = declGridObj.enableArrangeMenu;\n    gridOptions.showContextMenu = !_.isNil(declGridObj.showContextMenu) ? declGridObj.showContextMenu : gridOptions.showContextMenu;\n    gridOptions.showDecorators = declGridObj.showDecorators;\n    gridOptions.useTree = declGridObj.useTree; // Turn on grid menu if arrange command is enabled, only if not set by grid\n\n    if (gridOptions.enableGridMenu === undefined && gridOptions.enableArrangeMenu) {\n      gridOptions.enableGridMenu = true;\n    } // Turn on XXLARGE header height if enableHeaderIcon is enabled\n\n\n    if (gridOptions.enableHeaderIcon === true) {\n      gridOptions.headerHeight = 'XXLARGE';\n    }\n\n    var _loadTreeProperties = function (propertyLoadRequest) {\n      var propertyLoadInput = awTableSvc.createPropertyLoadInput([propertyLoadRequest]);\n      return propertyProvider.getProperties(dataCtxNode, propertyLoadInput).then(function (propertyLoadResult) {\n        if (dataProvider.topNodeUid) {\n          _.forEach(propertyLoadResult.updatedNodes, function (vmo) {\n            if (vmo.uid === dataProvider.topNodeUid) {\n              // Assign on props doesn't work if it's undefined, doing this for now to make it work.\n              if (dataProvider.topTreeNode.props === undefined) {\n                dataProvider.topTreeNode.props = {};\n              }\n\n              _.assign(dataProvider.topTreeNode.props, vmo.props);\n            } // Reset edit state since props have loaded\n\n\n            viewModelObjectService.setEditState(vmo, false);\n            delete vmo.isPropLoading;\n          });\n\n          if (propertyLoadResult.updatedNodes) {\n            tableInstance.refresh();\n          }\n        }\n\n        if (!propertyLoadResult.columnConfig) {\n          // Notify table to refresh if no columnConfig change to reflect new prop values in vmos\n          tableInstance.refresh();\n        } else if (propertyLoadResult.columnConfig.columns.length !== dataProvider.cols.length) {\n          /** revisitme Shaishav: Can we make the new condition similar to old condition? Will there\n             * be extra refreshes because of new condition?\n             * tstark - leave for refactor\n          //} else if( !_.isEqual( propertyLoadResult.columnConfig.columns, dataProvider.columnConfig.columns ) ) {\n             */\n          // LCS-178290 - Redundant refresh in page load\n          // Do column Refresh only in the case we have new columnConfig from server\n          columnProvider.buildDynamicColumns(propertyLoadResult.columnConfig.columns, true).then(() => {\n            tableInstance.resetColumns();\n          });\n        }\n\n        if (util.shouldRequestStartEditPropsLoaded(tableElem)) {\n          util.requestStartEdit(tableElem);\n        }\n      });\n    };\n\n    var _loadProps = _.debounce(function (emptyVMOs) {\n      /**\n        * Since debounced functions have a slight chance of being fired off after a maxWait and after the\n        * declViewModelhas been destroyed (and before the debounce 'cancel' function is called), we want to\n        * check for that case here.\n        */\n      if (declViewModel.isDestroyed()) {\n        return;\n      }\n      /**\n        * Include 'top' node if it does not have 'props' set yet.\n        */\n\n\n      if (!dataProvider.topTreeNode.props) {\n        var topNodeUid = dataProvider.topTreeNode.uid;\n        var foundTop = false;\n\n        for (var i = 0; i < emptyVMOs.length; i++) {\n          if (emptyVMOs[i].uid === topNodeUid) {\n            foundTop = true;\n            break;\n          }\n        }\n\n        if (!foundTop) {\n          emptyVMOs.push(dataProvider.topTreeNode);\n        }\n      } // Return if there are no props to load\n\n\n      if (emptyVMOs.length === 0) {\n        return;\n      }\n\n      var columnInfos = [];\n\n      _.forEach(dataProvider.cols, function (columnInfo) {\n        if (!columnInfo.isTreeNavigation) {\n          columnInfos.push(columnInfo);\n        }\n      });\n\n      _.forEach(emptyVMOs, function (vmo) {\n        vmo.isPropLoading = true;\n      });\n\n      var propertyLoadRequest = {\n        parentNode: null,\n        childNodes: emptyVMOs,\n        columnInfos: columnInfos\n      };\n\n      _loadTreeProperties(propertyLoadRequest);\n    }, 500, {\n      maxWait: 10000,\n      trailing: true,\n      leading: false\n    });\n\n    var initializeProvider = function (dataProvider, columnProvider, passedState) {\n      return columnProvider.initialize(passedState).then(function (dynamicColumns) {\n        dataProvider.cols = dataProvider.cols ? dataProvider.cols : dynamicColumns;\n        /**\n          * Dont re-initialize DP if it already exists => Doesn't matter if empty table or table with rows\n          */\n\n        if (dataProvider.json && dataProvider.json.firstPage) {\n          /**\n            * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n            * tstark - leave for refactor\n            * Delete firstPage results only on dataProvider reset\n           // If first page but no data loaded in loadedVMObjects, try viewModelSvc executing the dataprovider\n           if( dataProvider.json.firstPage.length > 0 && dataProvider.viewModelCollection &&\n               dataProvider.viewModelCollection.loadedVMObjects && dataProvider.viewModelCollection.loadedVMObjects.length === 0 ) {\n                   viewModelSvc.executeCommand( declViewModel, declGrid.dataProvider, $scope );\n           }\n           */\n          // Do Nothing\n          return null;\n        }\n\n        return dataProvider.initialize(dataCtxNode).then(function () {\n          if (!dataProvider.cols || dataProvider.cols.length === 0) {\n            if (!dataProvider.columnConfig) {\n              return Promise.reject(new Error('Column config not loaded'));\n            }\n\n            return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns, true);\n          }\n\n          return null;\n        });\n      });\n    };\n\n    tableCallbacks.completeInitialization = () => {\n      if (dataProvider.columnConfig) {\n        dataProvider.initializationComplete = 'InProgress';\n        return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns, true).then(() => {\n          var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n\n          if (declGridObj.reusable) {\n            gridContextDispatcher = declGridObj.gridContextDispatcher;\n          }\n\n          tableInstance = splmTableFactory.createTableObject(element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight, gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox);\n          tableInstance.showCheckBox = declGridObj.showCheckBox;\n          tableInstance.resetColumns();\n          tableInstance.viewModelCollection = viewModelCollection;\n          tableInstance.refresh();\n          initializeObserver();\n          tableElem = tableInstance.getTableElement();\n          dataProvider.initializationComplete = true;\n\n          if (declGridObj.containerHeight) {\n            tableInstance.updateContainerHeight(declGridObj.containerHeight);\n          } // Event Interface to rerender the table with data currently on the client\n\n\n          instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.clientRefresh', function () {\n            _.defer(function () {\n              tableInstance.showCheckBox = declGridObj.showCheckBox;\n\n              if (tableElem && tableElem._tableInstance) {\n                tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n              }\n\n              util.cleanupComponents(element);\n              tableInstance.refresh();\n            });\n          }));\n        });\n      }\n    };\n\n    tableCallbacks.updateTableColumns = updatedColumns => {\n      if (updatedColumns && updatedColumns.length > 0) {\n        columnProvider.buildDynamicColumns(updatedColumns, true).then(() => {\n          if (tableInstance !== null) {\n            tableInstance.resetColumns();\n          }\n        });\n      }\n    };\n\n    tableCallbacks.updateContentRowSelection = () => {\n      tableInstance && tableInstance.updateContentRowSelection();\n    };\n\n    tableCallbacks.selectTableColumn = columnDef => {\n      if (columnDef) {\n        splmTableSelectionHelper.selectColumnCells(tableInstance.getTableElement(), columnDef.field);\n      }\n    };\n\n    tableCallbacks.updateSortDirection = (currentColumnIndex, newColumnIndex, sortDirection) => {\n      if (newColumnIndex > -1) {\n        tableInstance && tableInstance.updateSortDirection(currentColumnIndex, newColumnIndex, sortDirection);\n        reloadDataProvider();\n      }\n    };\n\n    tableCallbacks.updateDynamicRowHeight = dynamicRowHeightStatus => {\n      tableInstance && tableInstance.updateDynamicRowHeight(dynamicRowHeightStatus);\n    };\n\n    tableCallbacks.updatePinColumn = (columnDef, isFreezeAction, defaultColumnPinIndex) => {\n      if (columnDef && defaultColumnPinIndex > -1) {\n        tableInstance && tableInstance.updatePinColumn(columnDef, isFreezeAction, defaultColumnPinIndex);\n      }\n    };\n\n    tableCallbacks.hideColumn = columnDef => {\n      if (columnDef) {\n        tableInstance && tableInstance.hideColumn(columnDef);\n      }\n    };\n\n    tableCallbacks.columnFilterApplied = columnFilterInfo => {\n      // viewModel columnProvider needed because columnFilters with be needed by the viewModel action inputs\n      // revisitme - Send event to all application listeners, remove when converted\n      const eventData = {\n        isInternalTableEvent: true,\n        gridId: gridid,\n        ...columnFilterInfo\n      };\n      eventBus.publish('pltable.columnFilterApplied', eventData);\n      const menuService = util.getTableMenuService(tableElem);\n      menuService.ensureAllTableMenusDismissed();\n\n      if (columnFilterInfo.filters && columnFilterInfo.filters.length) {\n        columnFilterService.setFilters(columnProvider, dataProvider, columnFilterInfo.filters, columnFilterInfo.column);\n      } else if (columnFilterInfo.column) {\n        columnFilterService.removeFilter(columnFilterInfo.column, columnProvider, dataProvider);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n\n      dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied(dataProvider);\n      const columnName = columnFilterInfo.column ? columnFilterInfo.column.field : null;\n      tableInstance.updateFilterIcons(columnName);\n      reloadDataProvider();\n    };\n\n    tableCallbacks.editStateUpdated = () => {\n      const data = {\n        dataSource: dataProvider,\n        state: dataProvider._editingState\n      };\n      tableInstance.updateEditState(data);\n    };\n\n    tableCallbacks.updateEditState = async props => {\n      if (props && props.tableContext) {\n        if (props.tableContext.startEdit && props.tableContext.startEdit.value === true) {\n          await dataProvider.startEdit(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.startEdit.update) {\n            props.tableContext.startEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(true);\n          }\n        } else if (props.tableContext.cancelEdit && props.tableContext.cancelEdit.value === true) {\n          await dataProvider.cancelEdits(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.cancelEdit.update) {\n            props.tableContext.cancelEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(false);\n          }\n        } else if (props.tableContext.saveEdit && props.tableContext.saveEdit.value === true) {\n          await dataProvider.saveEdits(props.dataCtxNode, props.dataCtxNode.data);\n\n          if (props.tableContext.saveEdit.update) {\n            props.tableContext.saveEdit.update(false);\n          }\n\n          if (props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update) {\n            props.tableContext.isBulkEditing.update(false);\n          }\n        }\n      }\n    };\n\n    const initializeObserver = () => {\n      if (resizeObserverSvc.supportsResizeObserver()) {\n        const callback = _.debounce(() => {\n          eventBus.publish(gridid + '.plTable.resizeCheck');\n        }, 200, {\n          maxWait: 10000,\n          trailing: true,\n          leading: false\n        });\n\n        resizeObserverSvc.observe(element, callback);\n      }\n    };\n\n    if (gridOptions.useTree === true) {\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.loadProps', function (eventData) {\n        _loadProps(eventData.VMOs);\n      }));\n      instanceEventSubcr.push(eventBus.subscribe('primaryWorkarea.reloadTop', function (event) {\n        var clearAllStates = !(event && event.retainAllStates);\n\n        if (clearAllStates) {\n          awTableStateSvc.clearAllStates(declViewModel, gridid);\n        }\n        /*\n          * delete firstPage results if any before re-initializing dataProvider\n          */\n\n\n        if (dataProvider.json.firstPage) {\n          delete dataProvider.json.firstPage;\n        }\n\n        dataProvider.initialize(dataCtxNode);\n      }));\n\n      const toggleTreeNode = function (node) {\n        if (!node.loadingStatus) {\n          node.loadingStatus = true;\n          tableInstance.updateTreeCellIcon(node); // get the current copy of data\n\n          Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n\n          if (node.isExpanded === true) {\n            tableInstance.setNodeExpansionInProgress(true);\n            node._expandRequested = true;\n            var preExpandVMObjectsLength = dataProvider.viewModelCollection.loadedVMObjects.length;\n            dataProvider.expandObject(dataCtxNode, node).then(function (updatedViewModelCollection) {\n              // LCS-180794: If Expand did not return any new objects or\n              //if node has previous expansion state and dataProvider.cacheCollapse=true which means it didn't get new objects from server,\n              // continue updating the rest of the table\n              tableInstance.setNodeExpansionInProgress(false);\n\n              if (preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length) {\n                delete node.loadingStatus;\n                tableInstance.refresh();\n              } //view model collection is updated so update table with new set of VMOs.\n\n\n              dataProvider.update(updatedViewModelCollection.loadedVMObjects);\n            }).finally(function () {\n              // Make sure even when errored that the expansion in progress is set to false\n              tableInstance.setNodeExpansionInProgress(false); //ensure properties are loaded after expansion\n              // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n              // render the rows. The row rendering will then occur once they props have been loaded.\n\n              tableInstance.loadMissingProps();\n              delete node.loadingStatus;\n              delete node._expandRequested;\n              tableInstance.updateTreeCellIcon(node);\n              tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n\n              if (util.shouldRequestStartEditTreeExpand(tableElem, node, propertyProvider)) {\n                util.requestStartEdit(tableElem);\n              }\n            });\n            awTableStateSvc.saveRowExpanded(declViewModel, gridid, node);\n          } else {\n            dataProvider.collapseObject(dataCtxNode, node).then(function (updatedViewModelCollection) {\n              dataProvider.update(updatedViewModelCollection.loadedVMObjects);\n\n              if (preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length) {\n                tableInstance.refresh();\n              }\n            }).finally(function () {\n              delete node.loadingStatus;\n              tableInstance.updateTreeCellIcon(node);\n              tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n            });\n            awTableStateSvc.saveRowCollapsed(declViewModel, gridid, node);\n          }\n        }\n      };\n\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.toggleTreeNode', toggleTreeNode));\n\n      if (declGridObj.reusable) {\n        tableInstanceCallbacks.toggleTreeNode = toggleTreeNode;\n      }\n\n      const doFocusPlaceHolder = function (vmNode) {\n        var vmCollection = dataProvider.viewModelCollection;\n        var cursorNdx = vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(vmNode));\n        /**\n         * Find 'parent' node of the 'placeholder' node in the vmCollection\n         */\n\n        var phParentNode = null;\n        var cursorNode = vmCollection.getViewModelObject(cursorNdx);\n        var parentLevelNdx = cursorNode.levelNdx - 1;\n\n        if (parentLevelNdx === -1) {\n          phParentNode = dataProvider.topTreeNode;\n        } else {\n          for (var rowNdx = cursorNdx - 1; rowNdx >= 0; rowNdx--) {\n            var currRow = vmCollection.getViewModelObject(rowNdx);\n\n            if (currRow.levelNdx === parentLevelNdx) {\n              phParentNode = currRow;\n              break;\n            }\n          }\n        }\n\n        if (phParentNode === null) {\n          return null;\n        }\n        /**\n         * Load, using the 'focusAction', the siblings of the 'placeholder' in the context of its immediate\n         * 'parent'.\n         * <P>\n         * Note: We want to use a smaller page size here to minimize the loading.\n         */\n\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput(phParentNode, 0, null, vmNode.id, dataProvider.treePageSize, true, null);\n        var loadIDs = {\n          t_uid: dataProvider.topTreeNode.uid,\n          o_uid: phParentNode.uid,\n          c_uid: vmNode.uid,\n          uid: null\n        };\n        var actionRequestObj = {\n          treeLoadInput: treeLoadInput,\n          loadIDs: loadIDs\n        };\n        /**\n         * Change 'suffix' text to indicate we are attempting to load more rows.\n         */\n\n        vmNode.loadingStatus = true; // get the current copy of data\n\n        Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n        return dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.nextAction, dataProvider.json, dataCtxNode, actionRequestObj).then(function (response) {\n          /**\n           * Locate cursor node in original collection & find/collect all contained 'child' nodes.\n           */\n          var cursorId = uwUtilSvc.getEvaluatedId(cursorNode);\n          var cursorLevel = cursorNode.levelNdx;\n          var vmCollection = dataProvider.viewModelCollection;\n          var cursorNdxInOrig = vmCollection.findViewModelObjectById(cursorId);\n          var loadedVMObjects = vmCollection.loadedVMObjects;\n          var cursorVMObjects = [loadedVMObjects[cursorNdxInOrig]];\n\n          for (var l = cursorNdxInOrig + 1; l < loadedVMObjects.length; l++) {\n            var currNode = loadedVMObjects[l];\n\n            if (currNode.levelNdx <= cursorLevel) {\n              break;\n            }\n\n            cursorVMObjects.push(currNode);\n          }\n          /**\n           * Re-order the childNdx values of the sibling nodes relative to initial placeholder as 0;\n           */\n\n\n          var treeLoadResult = response.actionResultObj.responseObj.treeLoadResult;\n          var newVMObjects = treeLoadResult.childNodes;\n          var cursorNdxInNew = 0;\n\n          for (var i = 0; i < newVMObjects.length; i++) {\n            if (newVMObjects[i].id === cursorId) {\n              cursorNdxInNew = i;\n              break;\n            }\n          }\n\n          for (var j = 0; j < newVMObjects.length; j++) {\n            newVMObjects[j].childNdx = j - cursorNdxInNew;\n          }\n          /**\n           * Check if the 'fresh' cursor node is at either end of the 'sibling' list and is now known to be an\n           * 'incompleteHead' or 'incompleteTail'\n           * <P>\n           * If so: Move that status over to the 'original' cursor node.\n           * <P>\n           * Note: We are about to replace the 'fresh' node in the set of its siblings just returned and we do\n           * not want to lose this important information.\n           */\n\n\n          if (cursorNdxInNew === 0 && newVMObjects[0].incompleteHead) {\n            cursorNode.incompleteHead = true;\n          }\n\n          var lastNodeNdx = newVMObjects.length - 1;\n\n          if (cursorNdxInNew === lastNodeNdx && newVMObjects[lastNodeNdx].incompleteTail) {\n            cursorNode.incompleteTail = true;\n          }\n          /**\n           * Make sure the placeholder 'parent' node gets its 'children' set (a shallow clone is good enough).\n           * <P>\n           * Replace the 'fresh' cursor node with the 'original' cursor node since it holds important state\n           * and hierarchy info.\n           */\n\n\n          phParentNode.children = _.clone(newVMObjects);\n          phParentNode.children[cursorNdxInNew] = cursorNode;\n          /**\n           * Remove the 'fresh' cursor node from the array of its siblings.\n           * <P>\n           * Insert the cursor node (and all of its children from the original array) into the array of new\n           * nodes.\n           * <P>\n           * Remove the cursor node (and all of its children) from the original array\n           * <P>\n           * Insert the new nodes (updated with the cursor node and all of its children from the original\n           * array) into the vmCollection array of nodes.\n           * <P>\n           * Clear the loading status of the cursor node.\n           */\n\n          newVMObjects.splice(cursorNdxInNew, 1); // LCS-230184 - In the case where no changes are made to the loadedVMObjects, we must manually refresh\n          // so that the table can process the remaining rendered nodes for more focus placeholder, expansion\n          // restoration, or prop loading.\n\n          if (newVMObjects.length === 0) {\n            delete vmNode.loadingStatus;\n            delete vmNode._focusRequested;\n            tableInstance.refresh();\n            return;\n          }\n\n          var insertNdx = cursorNdxInNew - 1;\n          arrayUtils.insert(newVMObjects, insertNdx, cursorVMObjects);\n          loadedVMObjects.splice(cursorNdxInOrig, cursorVMObjects.length);\n          arrayUtils.insert(loadedVMObjects, cursorNdxInOrig - 1, newVMObjects);\n          delete vmNode.loadingStatus;\n          delete vmNode._focusRequested;\n          dataProvider.update(loadedVMObjects);\n          /**\n           * Fire a 'treeNodesLoaded' event, sourced to the uwDataProvider, for all tree-table changes. This\n           * event includes only the input/result structures for the current load operation. This event is\n           * used to load additional properties in an async fashion.\n           */\n\n          eventBus.publish(dataProvider.name + '.treeNodesLoaded', {\n            treeLoadInput: treeLoadInput,\n            treeLoadResult: treeLoadResult\n          });\n          /**\n           * Fire a 'modelObjectsUpdated' event, sourced to the uwDataProvider, for all tree-table changes.\n           * This event includes the complete array of nodes in the collection.\n           */\n\n          eventBus.publish(dataProvider.name + '.modelObjectsUpdated', {\n            viewModelObjects: loadedVMObjects,\n            noResults: false\n          });\n        });\n      };\n\n      tableInstanceCallbacks.doFocusPlaceHolder = doFocusPlaceHolder;\n    } else {\n      instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.modelObjectsUpdated', function (event) {\n        if (event && !event.arrangeColumnEvent) {\n          tableCallbacks.columnsArranged(event);\n        }\n      }));\n    }\n\n    tableCallbacks.columnsArranged = columnArrangeData => {\n      if (columnArrangeData.arrangeType && columnArrangeData.arrangeType === 'saveColumnAndLoadAction' && columnArrangeData.viewModelObjects) {\n        // Just update data provider with vmos changed by columnArrangeService\n        tableInstance.resetInfiniteScroll();\n        dataProvider.update(columnArrangeData.viewModelObjects, columnArrangeData.totalFound); // Need to refresh the table since there is no watch anymore on loadedVMObjects\n\n        tableInstance.refresh();\n      }\n    };\n    /**\n      * Subscribe to resetState. Clear all states and set isFocusedLoad to true.\n      */\n\n\n    instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.resetState', function () {\n      awTableStateSvc.clearAllStates(declViewModel, gridid);\n      dataProvider.isFocusedLoad = true;\n    }));\n    cfgSvc.get('propertyRendererTemplates');\n    initializeProvider(dataProvider, columnProvider, dataCtxNode).then(() => {\n      var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n\n      if (declGridObj.reusable) {\n        gridContextDispatcher = declGridObj.gridContextDispatcher;\n      }\n\n      tableInstance = splmTableFactory.createTableObject(element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight, gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox);\n      tableInstance.showCheckBox = declGridObj.showCheckBox;\n      tableElem = tableInstance.getTableElement();\n      initializeObserver(); // Following refresh is for cases like object sets. Where first page is already loaded by stylesheet SOA\n\n      tableInstance.viewModelCollection = viewModelCollection;\n      tableInstance.refresh();\n      dataProvider.initializationComplete = true;\n\n      if (declGridObj.containerHeight) {\n        tableInstance.updateContainerHeight(declGridObj.containerHeight);\n      } // Event Interface to rerender the table with data currently on the client\n\n\n      instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.clientRefresh', function () {\n        _.defer(function () {\n          tableInstance.showCheckBox = declGridObj.showCheckBox;\n\n          if (tableElem && tableElem._tableInstance) {\n            tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n          }\n\n          util.cleanupComponents(element);\n          tableInstance.refresh();\n        });\n      }));\n    }, error => {\n      dataProvider.initializationComplete = false;\n      logger.trace(error);\n    });\n  }\n\n  instanceEventSubcr.push(eventBus.subscribe('columnArrange', function (eventData) {\n    if (eventData.name === gridid || eventData.columnConfigId && dataProvider.columnConfig && eventData.columnConfigId === dataProvider.columnConfig.columnConfigId) {\n      if (eventData.columns.length) {\n        tableInstance.removeStaleFilters(eventData.columns);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n    }\n\n    if (tableInstance.getDynamicRowHeightStatus()) {\n      tableInstance.resetDynamicRowHeights();\n    }\n  }));\n  var relatedModifiedEvent = eventBus.subscribe('cdm.relatedModified', function (eventData) {\n    tableInstance.relatedModified();\n  });\n  instanceEventSubcr.push(relatedModifiedEvent); // Event Interface to rerender table with reloaded data from the dataprovider\n\n  instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.reload', reloadDataProvider)); // revisitme - tstark - Need to keep event until all application teams convert away from events\n\n  instanceEventSubcr.push(eventBus.subscribe('pltable.columnFilterApplied', function (eventData) {\n    if (gridid === eventData.gridId && eventData.isInternalTableEvent !== true) {\n      if (eventData.filters && eventData.filters.length) {\n        columnFilterService.setFilters(columnProvider, dataProvider, eventData.filters, eventData.column);\n      } else if (eventData.column) {\n        columnFilterService.removeFilter(eventData.column, columnProvider, dataProvider);\n      } else {\n        columnFilterService.removeAllFilters(dataProvider, columnProvider);\n      }\n\n      dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied(dataProvider);\n      const columnName = eventData.column ? eventData.column.field : null;\n      tableInstance.updateFilterIcons(columnName);\n      reloadDataProvider();\n    }\n  }));\n\n  tableCallbacks.updateColumnMenuData = function (columnMenuData) {\n    _.forEach(dataProvider.cols, function (currentColumn) {\n      if (columnMenuData.columnName === currentColumn.field) {\n        currentColumn.filter = { ...currentColumn.filter,\n          ...columnMenuData\n        };\n        currentColumn.filter.columnMenuData = columnMenuData;\n\n        if (currentColumn.filter.showFilters) {\n          if (currentColumn.filter.showFilters.dbValue && currentColumn.filter.showFilters.dbValue !== 'false') {\n            currentColumn.filter.showFilterFacets = true;\n          } else {\n            currentColumn.filter.showFilterFacets = false;\n          }\n        }\n\n        return false;\n      }\n    });\n  }; // revisitme - tstark - Need to keep event until all application teams convert away from events\n\n\n  instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.setFilterDisability', function (eventData) {\n    if (gridid === eventData.gridId) {\n      tableInstance.setFilterDisability(eventData.isFilterDisabled);\n    }\n  }));\n  /**\n    *  destroy the table\n    */\n\n  tableCallbacks.destroy = function () {\n    var columns = [];\n\n    if (dataProvider.columnConfig && dataProvider.columnConfig.columns) {\n      columns = dataProvider.columnConfig.columns;\n    }\n\n    _.forEach(instanceEventSubcr, function (eventBusSub) {\n      eventBus.unsubscribe(eventBusSub);\n    });\n\n    splmTableFactory.destroyTable(gridid, element, columns);\n  };\n\n  tableCallbacks.updateVmCollection = viewModelCollection => {\n    if (tableInstance) {\n      tableInstance.viewModelCollection = viewModelCollection;\n\n      if (util.shouldRequestStartEditPagination(tableElem)) {\n        util.requestStartEdit(tableElem);\n      }\n\n      tableInstance.refresh();\n    }\n  };\n\n  tableCallbacks.updateDeclGridObject = declGridParam => {\n    declGridObj = declGridParam;\n  };\n\n  tableCallbacks.updateMenuContext = menuContext => {\n    declGridObj.menuContext = menuContext;\n  };\n\n  tableCallbacks.updateState = newState => {\n    declViewModel = newState;\n\n    if (tableInstance) {\n      tableInstance.updateInstanceState(newState);\n    }\n  };\n\n  tableCallbacks.refreshTable = () => {\n    if (tableInstance) {\n      tableInstance.refresh();\n    }\n  };\n\n  tableCallbacks.updateGridOptionsForTableInstance = props => {\n    if (tableElem && tableElem._tableInstance && props && props.showCheckBox !== undefined) {\n      tableElem._tableInstance.showCheckBox = props.showCheckBox;\n    }\n  };\n  /**\n    * Setup to react to changes in selection within the dataProvider.\n    *\n    * @param {Object} event -\n    * @param {Object} data -\n    */\n\n\n  instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.selectionChangeEvent', function (event) {\n    var selections = event.selectionModel.getSelection(); // Set scroll to row in progress\n\n    if (dataProvider.isFocusedLoad === true && selections.length > 0) {\n      dataProvider.isFocusedLoad = false;\n      dataProvider.scrollToRow = true;\n    }\n\n    if (selections.length > 0 && selections.length >= _previousSelections.length && _.isEqual(_previousSelections, selections) === false || dataProvider.scrollToRow === true) {\n      dataProvider.scrollToRow = true;\n      eventBus.publish('plTable.scrollToRow', {\n        gridId: gridid,\n        rowUids: selections\n      });\n    }\n\n    _previousSelections = selections.slice();\n  }));\n  var pageLoadInProgress = false;\n\n  const getTreeNodePageCallback = function (results) {\n    logger.trace('AW simple table: Loaded next tree page data');\n    pageLoadInProgress = false;\n\n    if (util.shouldRequestStartEditTreePagination(tableElem, propertyProvider)) {\n      util.requestStartEdit(tableElem);\n    }\n\n    dataProvider.update(results.loadedVMObjects, results.totalFound);\n  }; // eslint-disable-next-line complexity\n\n\n  const loadMorePages = function (eventData) {\n    if (tableInstance.viewModelCollection) {\n      var lastItemIndex = eventData.lastRenderedItem.index; // get the current copy of data\n\n      Object.assign(dataCtxNode.data.data, dataCtxNode.data.getData());\n\n      if (lastItemIndex !== 0 && lastItemIndex === tableInstance.viewModelCollection.loadedVMObjects.length - 1) {\n        if (dataProvider.nextAction || dataProvider.action) {\n          var lastNode = dataProvider.viewModelCollection.loadedVMObjects[lastItemIndex];\n\n          if (dataProvider.hasMorePages() && lastNode.incompleteTail) {\n            delete lastNode.incompleteTail;\n\n            if (eventData.lastRenderedItem.levelNdx > 0) {\n              pageLoadInProgress = true;\n              dataProvider.getTreeNodePage(dataCtxNode, null, eventData.lastRenderedItem.uid, true, null).then(getTreeNodePageCallback);\n              return;\n            }\n\n            pageLoadInProgress = true;\n            dataProvider.pageDispatcher({\n              type: 'NEXT_PAGE'\n            });\n            return;\n          }\n\n          logger.trace('AW simple table: Rendering of all rows below completed');\n        }\n      }\n\n      var firstItemIndex = eventData.firstRenderedItem.index;\n\n      if (firstItemIndex === 0) {\n        if (dataProvider.previousAction) {\n          var firstNode = dataProvider.viewModelCollection.loadedVMObjects[firstItemIndex];\n\n          if (dataProvider.hasMorePagesUp() && firstNode.incompleteHead) {\n            delete firstNode.incompleteHead;\n            tableInstance.maintainScrollPosition();\n\n            if (eventData.firstRenderedItem.levelNdx > 0) {\n              pageLoadInProgress = true;\n              dataProvider.getTreeNodePage(dataCtxNode, null, eventData.firstRenderedItem.uid, false, null).then(getTreeNodePageCallback);\n              return;\n            }\n\n            pageLoadInProgress = true;\n            dataProvider.pageDispatcher({\n              type: 'PREVIOUS_PAGE'\n            });\n            return;\n          }\n\n          logger.trace('AW simple table: Rendering of all rows above completed');\n        }\n      } // Check for incomplete head/tail on tree node in rendered range\n\n\n      if (gridOptions.useTree === true) {\n        var incompleteNode = dataProvider.findIncompleteNodeInRange(firstItemIndex, lastItemIndex);\n\n        if (incompleteNode !== null && incompleteNode.levelNdx > 0) {\n          var loadNextPage = incompleteNode.incompleteTail === true;\n\n          if (loadNextPage === true && !(dataProvider.nextAction || dataProvider.action)) {\n            return;\n          } else if (loadNextPage === false && !dataProvider.previousAction) {\n            return;\n          }\n\n          delete incompleteNode.incompleteHead;\n          delete incompleteNode.incompleteTail;\n          pageLoadInProgress = true;\n          dataProvider.getTreeNodePage(dataCtxNode, null, incompleteNode.uid, loadNextPage, null).then(getTreeNodePageCallback);\n          return;\n        }\n      }\n    }\n    /** revisitme Radhika: We havesome logic below around pageLoadInProgress. We might need some\n       * tstark - leave for refactor\n           * in the new system. The code needs to be cleaned up and the necessary lines needs to be reused\n          if( dataProvider.viewModelCollection && pageLoadInProgress === false ) {\n              // Check if next page should be loaded\n              var lastItemIndex = eventData.lastRenderedItem.index;\n              if( lastItemIndex !== 0 && lastItemIndex === dataProvider.viewModelCollection.loadedVMObjects.length - 1 ) {\n                  if( dataProvider.nextAction || dataProvider.action ) {\n                      var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                      if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                          delete lastNode.incompleteTail;\n                          if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                              pageLoadInProgress = true;\n                              dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                              return;\n                          }\n                          /**\n                           * REFACTOR: This is how UI Grid checks to see if we actually have more pages to load or not since\n                           * dataProvider.hasMorePages() will always return true, because it sets dataProvider.update(firstPageObjs, firstPageObjs.length + 1)\n                           * in dataProviderFactory and uses these two values for checking for if more pages to load or not.\n                           * Will remove this code in 4.2 when all UIgrid replaced by PL Table\n                          var maxToLoad;\n                          if( dataProvider.action && dataProvider.action.inputData ) {\n                              var actionInputData = dataProvider.action.inputData;\n                              if( actionInputData.searchInput ) {\n                                  maxToLoad = actionInputData.searchInput.maxToLoad;\n                              }\n                          }\n                           /**\n                           *\n                           * If we have a firstPage and its length is less than maxToLoad, we dont need to load another page.\n                           * All other cases, handle like normally => Try to get next page of data\n                           *\n                          if( maxToLoad && dataProvider.json.firstPage && dataProvider.json.firstPage.length < maxToLoad ) {\n                              logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                          } else {\n                              pageLoadInProgress = true;\n                              dataProvider.getNextPage( dataCtxNode ).then( function() {\n                                  logger.trace( 'AW simple table: Loaded next page data' );\n                                  pageLoadInProgress = false;\n                                  if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                      util.requestStartEdit( tableElem );\n                                  }\n                              } );\n                              return;\n                          }\n                      } else {\n                          logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                      }\n                  }\n              }\n               // Check if previous page should be loaded as long as next page has not already been requested\n              var firstItemIndex = eventData.firstRenderedItem.index;\n              if( firstItemIndex === 0 ) {\n                  if( dataProvider.previousAction ) {\n                      var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                      if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                          delete firstNode.incompleteHead;\n                          eventBus.publish( dataProvider.name + '.plTable.maintainScrollPosition' );\n                          if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                              pageLoadInProgress = true;\n                              dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                              return;\n                          }\n                           pageLoadInProgress = true;\n                          dataProvider.getPreviousPage( dataCtxNode ).then( function() {\n                              logger.trace( 'AW simple table: Loaded previous page data' );\n                              pageLoadInProgress = false;\n                              if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                  util.requestStartEdit( tableElem );\n                              }\n                          } );\n                          return;\n                      }\n                       logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                  }\n              }\n               // Check for incomplete head/tail on tree node in rendered range\n              if( gridOptions.useTree === true ) {\n                  var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                  if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                      var loadNextPage = incompleteNode.incompleteTail === true;\n                      if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                          return;\n                      } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                          return;\n                      }\n                      delete incompleteNode.incompleteHead;\n                      delete incompleteNode.incompleteTail;\n                      pageLoadInProgress = true;\n                      dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                      return;\n                  }\n              }\n          }\n      */\n\n  };\n\n  tableInstanceCallbacks.loadMorePages = loadMorePages;\n\n  let unsetScrollToRowIndex = function () {\n    tableInstance.unsetScrollToRowIndex();\n  };\n\n  tableInstanceCallbacks.unsetScrollToRowIndex = unsetScrollToRowIndex;\n\n  let columnsRearranged = function (eventData) {\n    tableInstance.columnsRearranged(eventData);\n  };\n\n  tableInstanceCallbacks.columnsRearranged = columnsRearranged;\n\n  let columnsResized = function (eventData) {\n    tableInstance.columnsResized(eventData);\n  };\n\n  tableInstanceCallbacks.columnsResized = columnsResized;\n  return tableCallbacks;\n};\nexport default {\n  initializeTable\n};","map":{"version":3,"names":["eventBus","_","logger","arrayUtils","splmTableFactory","awTableSvc","resizeObserverSvc","columnFilterService","awTableStateSvc","uwUtilSvc","viewModelObjectService","splmTableSelectionHelper","cfgSvc","declarativeDataCtxService","util","initializeTable","element","viewModelCollection","dataCtxNode","declGridParam","runActionWithViewModel","tableCallbacks","declGridObj","gridid","dataProvider","dataProviderInstance","columnProvider","columnProviderInstance","applyScope","data","gridOptions","declViewModel","instanceEventSubcr","tableInstance","tableElem","_previousSelections","tableInstanceCallbacks","setColumnFilters","reloadDataProvider","json","firstPage","resetDataProvider","propertyProvider","dataProviders","sortCallback","enableArrangeMenu","showContextMenu","isNil","showDecorators","useTree","enableGridMenu","undefined","enableHeaderIcon","headerHeight","_loadTreeProperties","propertyLoadRequest","propertyLoadInput","createPropertyLoadInput","getProperties","then","propertyLoadResult","topNodeUid","forEach","updatedNodes","vmo","uid","topTreeNode","props","assign","setEditState","isPropLoading","refresh","columnConfig","columns","length","cols","buildDynamicColumns","resetColumns","shouldRequestStartEditPropsLoaded","requestStartEdit","_loadProps","debounce","emptyVMOs","isDestroyed","foundTop","i","push","columnInfos","columnInfo","isTreeNavigation","parentNode","childNodes","maxWait","trailing","leading","initializeProvider","passedState","initialize","dynamicColumns","Promise","reject","Error","completeInitialization","initializationComplete","gridContextDispatcher","reusable","createTableObject","contentFilter","containerheight","tableContext","showCheckBox","initializeObserver","getTableElement","containerHeight","updateContainerHeight","subscribe","defer","_tableInstance","cleanupComponents","updateTableColumns","updatedColumns","updateContentRowSelection","selectTableColumn","columnDef","selectColumnCells","field","updateSortDirection","currentColumnIndex","newColumnIndex","sortDirection","updateDynamicRowHeight","dynamicRowHeightStatus","updatePinColumn","isFreezeAction","defaultColumnPinIndex","hideColumn","columnFilterApplied","columnFilterInfo","eventData","isInternalTableEvent","gridId","publish","menuService","getTableMenuService","ensureAllTableMenusDismissed","filters","setFilters","column","removeFilter","removeAllFilters","isColumnFilterApplied","columnName","updateFilterIcons","editStateUpdated","dataSource","state","_editingState","updateEditState","startEdit","value","update","isBulkEditing","cancelEdit","cancelEdits","saveEdit","saveEdits","supportsResizeObserver","callback","observe","VMOs","event","clearAllStates","retainAllStates","toggleTreeNode","node","loadingStatus","updateTreeCellIcon","Object","getData","isExpanded","setNodeExpansionInProgress","_expandRequested","preExpandVMObjectsLength","loadedVMObjects","expandObject","updatedViewModelCollection","finally","loadMissingProps","focusTreeNodeExpandAfterRender","shouldRequestStartEditTreeExpand","saveRowExpanded","collapseObject","saveRowCollapsed","doFocusPlaceHolder","vmNode","vmCollection","cursorNdx","findViewModelObjectById","getEvaluatedId","phParentNode","cursorNode","getViewModelObject","parentLevelNdx","levelNdx","rowNdx","currRow","treeLoadInput","createTreeLoadInput","id","treePageSize","loadIDs","t_uid","o_uid","c_uid","actionRequestObj","someDataProviderSvc","executeLoadAction","nextAction","response","cursorId","cursorLevel","cursorNdxInOrig","cursorVMObjects","l","currNode","treeLoadResult","actionResultObj","responseObj","newVMObjects","cursorNdxInNew","j","childNdx","incompleteHead","lastNodeNdx","incompleteTail","children","clone","splice","_focusRequested","insertNdx","insert","name","viewModelObjects","noResults","arrangeColumnEvent","columnsArranged","columnArrangeData","arrangeType","resetInfiniteScroll","totalFound","isFocusedLoad","get","error","trace","columnConfigId","removeStaleFilters","getDynamicRowHeightStatus","resetDynamicRowHeights","relatedModifiedEvent","relatedModified","updateColumnMenuData","columnMenuData","currentColumn","filter","showFilters","dbValue","showFilterFacets","setFilterDisability","isFilterDisabled","destroy","eventBusSub","unsubscribe","destroyTable","updateVmCollection","shouldRequestStartEditPagination","updateDeclGridObject","updateMenuContext","menuContext","updateState","newState","updateInstanceState","refreshTable","updateGridOptionsForTableInstance","selections","selectionModel","getSelection","scrollToRow","isEqual","rowUids","slice","pageLoadInProgress","getTreeNodePageCallback","results","shouldRequestStartEditTreePagination","loadMorePages","lastItemIndex","lastRenderedItem","index","action","lastNode","hasMorePages","getTreeNodePage","pageDispatcher","type","firstItemIndex","firstRenderedItem","previousAction","firstNode","hasMorePagesUp","maintainScrollPosition","incompleteNode","findIncompleteNodeInRange","loadNextPage","unsetScrollToRowIndex","columnsRearranged","columnsResized"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/awSPLMTableNativeService.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/awSPLMTableNativeService\n */\nimport * as eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport splmTableFactory from 'js/splmTableFactory';\nimport awTableSvc from 'js/awTableService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport columnFilterService from 'js/awColumnFilterService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport viewModelObjectService from 'js/viewModelObjectService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport * as cfgSvc from 'js/awConfiguration';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport util from 'js/splmTableUtils';\n\n\nexport const initializeTable = function( element, viewModelCollection, dataCtxNode, declGridParam, runActionWithViewModel ) {\n    // revisitme:\n    // tstark - leave for refactor\n    // - viewModelCollection has no use here.\n    // - passing element as ref can save one factor of memory leak.\n    // - But the dataCtxNode and declGridParam is too complex, we have viewModel -> data -> dataProvider,\n    //   almost impossible to know where the closure is getting hold. The fact I know is by dummy the data,\n    //   the symptom will go away\n    let tableCallbacks = {};\n    let declGridObj = { ...declGridParam };\n    const gridid = declGridObj.gridid;\n    const dataProvider = declGridObj.dataProviderInstance;\n    const columnProvider = declGridObj.columnProviderInstance;\n    declarativeDataCtxService.applyScope( dataCtxNode.data, declGridObj.gridOptions, null, dataCtxNode, null );\n    let gridOptions = declGridObj.gridOptions;\n    let declViewModel = dataCtxNode.data;\n\n    var instanceEventSubcr = [];\n    var tableInstance = null;\n    let tableElem = null;\n    var _previousSelections = [];\n    const tableInstanceCallbacks = {};\n\n    columnProvider.setColumnFilters( [] );\n\n    /**\n      * Refresh the table content by invoking the action to reload first page of data provider\n      */\n    var reloadDataProvider = function() {\n        if( gridid ) {\n            if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n                delete dataProvider.json.firstPage;\n            }\n            dataProvider.resetDataProvider();\n            /**\n              * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n              * tstark - leave for refactor\n              * Delete firstPage results only on dataProvider reset\n             if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n                 delete dataProvider.json.firstPage;\n             }\n             viewModelSvc.executeCommand( declViewModel, dataProvider, dataCtxNode );\n              */\n        }\n    };\n\n    if( gridid ) {\n        var propertyProvider = declViewModel.dataProviders[ declGridObj.propertyProvider ];\n\n        if( !columnProvider.sortCallback ) {\n            columnProvider.sortCallback = function() {\n                reloadDataProvider();\n            };\n        }\n\n        // Attach enableArrangeMenu to gridOptions because we are not passing grid into splmTable\n        gridOptions = gridOptions || {};\n        gridOptions.enableArrangeMenu = declGridObj.enableArrangeMenu;\n        gridOptions.showContextMenu = !_.isNil( declGridObj.showContextMenu ) ? declGridObj.showContextMenu : gridOptions.showContextMenu;\n        gridOptions.showDecorators = declGridObj.showDecorators;\n        gridOptions.useTree = declGridObj.useTree;\n\n        // Turn on grid menu if arrange command is enabled, only if not set by grid\n        if( gridOptions.enableGridMenu === undefined && gridOptions.enableArrangeMenu ) {\n            gridOptions.enableGridMenu = true;\n        }\n\n        // Turn on XXLARGE header height if enableHeaderIcon is enabled\n        if( gridOptions.enableHeaderIcon === true ) {\n            gridOptions.headerHeight = 'XXLARGE';\n        }\n\n        var _loadTreeProperties = function( propertyLoadRequest ) {\n            var propertyLoadInput = awTableSvc.createPropertyLoadInput( [ propertyLoadRequest ] );\n            return propertyProvider.getProperties( dataCtxNode, propertyLoadInput ).then( function( propertyLoadResult ) {\n                if( dataProvider.topNodeUid ) {\n                    _.forEach( propertyLoadResult.updatedNodes, function( vmo ) {\n                        if( vmo.uid === dataProvider.topNodeUid ) {\n                            // Assign on props doesn't work if it's undefined, doing this for now to make it work.\n                            if( dataProvider.topTreeNode.props === undefined ) {\n                                dataProvider.topTreeNode.props = {};\n                            }\n\n                            _.assign( dataProvider.topTreeNode.props, vmo.props );\n                        }\n                        // Reset edit state since props have loaded\n                        viewModelObjectService.setEditState( vmo, false );\n                        delete vmo.isPropLoading;\n                    } );\n                    if( propertyLoadResult.updatedNodes ) {\n                        tableInstance.refresh();\n                    }\n                }\n                if( !propertyLoadResult.columnConfig ) {\n                    // Notify table to refresh if no columnConfig change to reflect new prop values in vmos\n                    tableInstance.refresh();\n                } else if( propertyLoadResult.columnConfig.columns.length !== dataProvider.cols.length ) {\n                    /** revisitme Shaishav: Can we make the new condition similar to old condition? Will there\n                       * be extra refreshes because of new condition?\n                       * tstark - leave for refactor\n                  //} else if( !_.isEqual( propertyLoadResult.columnConfig.columns, dataProvider.columnConfig.columns ) ) {\n                       */\n                    // LCS-178290 - Redundant refresh in page load\n                    // Do column Refresh only in the case we have new columnConfig from server\n                    columnProvider.buildDynamicColumns( propertyLoadResult.columnConfig.columns, true ).then( () => {\n                        tableInstance.resetColumns();\n                    } );\n                }\n\n                if( util.shouldRequestStartEditPropsLoaded( tableElem ) ) {\n                    util.requestStartEdit( tableElem );\n                }\n            } );\n        };\n\n        var _loadProps = _.debounce( function( emptyVMOs ) {\n            /**\n              * Since debounced functions have a slight chance of being fired off after a maxWait and after the\n              * declViewModelhas been destroyed (and before the debounce 'cancel' function is called), we want to\n              * check for that case here.\n              */\n\n            if( declViewModel.isDestroyed() ) {\n                return;\n            }\n\n            /**\n              * Include 'top' node if it does not have 'props' set yet.\n              */\n            if( !dataProvider.topTreeNode.props ) {\n                var topNodeUid = dataProvider.topTreeNode.uid;\n\n                var foundTop = false;\n\n                for( var i = 0; i < emptyVMOs.length; i++ ) {\n                    if( emptyVMOs[ i ].uid === topNodeUid ) {\n                        foundTop = true;\n                        break;\n                    }\n                }\n\n                if( !foundTop ) {\n                    emptyVMOs.push( dataProvider.topTreeNode );\n                }\n            }\n\n            // Return if there are no props to load\n            if( emptyVMOs.length === 0 ) {\n                return;\n            }\n\n            var columnInfos = [];\n\n            _.forEach( dataProvider.cols, function( columnInfo ) {\n                if( !columnInfo.isTreeNavigation ) {\n                    columnInfos.push( columnInfo );\n                }\n            } );\n\n            _.forEach( emptyVMOs, function( vmo ) {\n                vmo.isPropLoading = true;\n            } );\n\n            var propertyLoadRequest = {\n                parentNode: null,\n                childNodes: emptyVMOs,\n                columnInfos: columnInfos\n            };\n\n            _loadTreeProperties( propertyLoadRequest );\n        }, 500, {\n            maxWait: 10000,\n            trailing: true,\n            leading: false\n        } );\n\n        var initializeProvider = function( dataProvider, columnProvider, passedState ) {\n            return columnProvider.initialize( passedState ).then( function( dynamicColumns ) {\n                dataProvider.cols = dataProvider.cols ? dataProvider.cols : dynamicColumns;\n                /**\n                  * Dont re-initialize DP if it already exists => Doesn't matter if empty table or table with rows\n                  */\n                if( dataProvider.json && dataProvider.json.firstPage ) {\n                    /**\n                      * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n                      * tstark - leave for refactor\n                      * Delete firstPage results only on dataProvider reset\n                     // If first page but no data loaded in loadedVMObjects, try viewModelSvc executing the dataprovider\n                     if( dataProvider.json.firstPage.length > 0 && dataProvider.viewModelCollection &&\n                         dataProvider.viewModelCollection.loadedVMObjects && dataProvider.viewModelCollection.loadedVMObjects.length === 0 ) {\n                             viewModelSvc.executeCommand( declViewModel, declGrid.dataProvider, $scope );\n                     }\n                     */\n                    // Do Nothing\n                    return null;\n                }\n\n                return dataProvider.initialize( dataCtxNode ).then( function() {\n                    if( !dataProvider.cols || dataProvider.cols.length === 0 ) {\n                        if( !dataProvider.columnConfig ) {\n                            return Promise.reject( new Error( 'Column config not loaded' ) );\n                        }\n                        return columnProvider.buildDynamicColumns( dataProvider.columnConfig.columns, true );\n                    }\n                    return null;\n                } );\n            } );\n        };\n\n        tableCallbacks.completeInitialization = () => {\n            if( dataProvider.columnConfig ) {\n                dataProvider.initializationComplete = 'InProgress';\n                return columnProvider.buildDynamicColumns( dataProvider.columnConfig.columns, true ).then( () => {\n                    var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n                    if( declGridObj.reusable ) {\n                        gridContextDispatcher = declGridObj.gridContextDispatcher;\n                    }\n                    tableInstance = splmTableFactory.createTableObject(\n                        element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight,\n                        gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox\n                    );\n                    tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    tableInstance.resetColumns();\n                    tableInstance.viewModelCollection = viewModelCollection;\n                    tableInstance.refresh();\n                    initializeObserver();\n                    tableElem = tableInstance.getTableElement();\n                    dataProvider.initializationComplete = true;\n                    if( declGridObj.containerHeight ) {\n                        tableInstance.updateContainerHeight( declGridObj.containerHeight );\n                    }\n                    // Event Interface to rerender the table with data currently on the client\n                    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.clientRefresh', function() {\n                        _.defer( function() {\n                            tableInstance.showCheckBox = declGridObj.showCheckBox;\n                            if ( tableElem && tableElem._tableInstance ) {\n                                tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n                            }\n                            util.cleanupComponents( element );\n                            tableInstance.refresh();\n                        } );\n                    } ) );\n                } );\n            }\n        };\n\n        tableCallbacks.updateTableColumns = ( updatedColumns ) => {\n            if( updatedColumns && updatedColumns.length > 0 ) {\n                columnProvider.buildDynamicColumns( updatedColumns, true ).then( () => {\n                    if( tableInstance !== null ) {\n                        tableInstance.resetColumns();\n                    }\n                } );\n            }\n        };\n\n        tableCallbacks.updateContentRowSelection = () => {\n            tableInstance && tableInstance.updateContentRowSelection();\n        };\n\n        tableCallbacks.selectTableColumn = ( columnDef ) => {\n            if( columnDef ) {\n                splmTableSelectionHelper.selectColumnCells( tableInstance.getTableElement(), columnDef.field );\n            }\n        };\n\n        tableCallbacks.updateSortDirection = ( currentColumnIndex, newColumnIndex, sortDirection ) => {\n            if( newColumnIndex > -1 ) {\n                tableInstance && tableInstance.updateSortDirection( currentColumnIndex, newColumnIndex, sortDirection );\n                reloadDataProvider();\n            }\n        };\n\n        tableCallbacks.updateDynamicRowHeight = ( dynamicRowHeightStatus ) => {\n            tableInstance && tableInstance.updateDynamicRowHeight( dynamicRowHeightStatus );\n        };\n\n        tableCallbacks.updatePinColumn = ( columnDef, isFreezeAction, defaultColumnPinIndex ) => {\n            if( columnDef && defaultColumnPinIndex > -1 ) {\n                tableInstance && tableInstance.updatePinColumn( columnDef, isFreezeAction, defaultColumnPinIndex );\n            }\n        };\n\n        tableCallbacks.hideColumn = ( columnDef ) => {\n            if( columnDef ) {\n                tableInstance && tableInstance.hideColumn( columnDef );\n            }\n        };\n\n        tableCallbacks.columnFilterApplied = ( columnFilterInfo ) => {\n            // viewModel columnProvider needed because columnFilters with be needed by the viewModel action inputs\n            // revisitme - Send event to all application listeners, remove when converted\n            const eventData = {\n                isInternalTableEvent: true,\n                gridId: gridid,\n                ...columnFilterInfo\n            };\n            eventBus.publish( 'pltable.columnFilterApplied', eventData );\n            const menuService = util.getTableMenuService( tableElem );\n            menuService.ensureAllTableMenusDismissed();\n            if( columnFilterInfo.filters && columnFilterInfo.filters.length ) {\n                columnFilterService.setFilters( columnProvider, dataProvider, columnFilterInfo.filters, columnFilterInfo.column );\n            } else if( columnFilterInfo.column ) {\n                columnFilterService.removeFilter( columnFilterInfo.column, columnProvider, dataProvider );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n            dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied( dataProvider );\n            const columnName = columnFilterInfo.column ? columnFilterInfo.column.field : null;\n            tableInstance.updateFilterIcons( columnName );\n            reloadDataProvider();\n        };\n\n        tableCallbacks.editStateUpdated = () => {\n            const data = {\n                dataSource: dataProvider,\n                state: dataProvider._editingState\n            };\n            tableInstance.updateEditState( data );\n        };\n\n        tableCallbacks.updateEditState = async( props ) => {\n            if( props && props.tableContext ) {\n                if ( props.tableContext.startEdit && props.tableContext.startEdit.value === true ) {\n                    await dataProvider.startEdit( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.startEdit.update ) {\n                        props.tableContext.startEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( true );\n                    }\n                } else if ( props.tableContext.cancelEdit && props.tableContext.cancelEdit.value === true ) {\n                    await dataProvider.cancelEdits( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.cancelEdit.update ) {\n                        props.tableContext.cancelEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( false );\n                    }\n                } else if ( props.tableContext.saveEdit && props.tableContext.saveEdit.value === true ) {\n                    await dataProvider.saveEdits( props.dataCtxNode, props.dataCtxNode.data );\n                    if ( props.tableContext.saveEdit.update ) {\n                        props.tableContext.saveEdit.update( false );\n                    }\n                    if ( props.tableContext.isBulkEditing && props.tableContext.isBulkEditing.update ) {\n                        props.tableContext.isBulkEditing.update( false );\n                    }\n                }\n            }\n        };\n\n        const initializeObserver = () => {\n            if( resizeObserverSvc.supportsResizeObserver() ) {\n                const callback = _.debounce( () => {\n                    eventBus.publish( gridid + '.plTable.resizeCheck' );\n                }, 200, {\n                    maxWait: 10000,\n                    trailing: true,\n                    leading: false\n                } );\n                resizeObserverSvc.observe( element, callback );\n            }\n        };\n\n        if( gridOptions.useTree === true ) {\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.loadProps', function( eventData ) {\n                _loadProps( eventData.VMOs );\n            } ) );\n\n            instanceEventSubcr.push( eventBus.subscribe( 'primaryWorkarea.reloadTop', function( event ) {\n                var clearAllStates = !( event && event.retainAllStates );\n\n                if( clearAllStates ) {\n                    awTableStateSvc.clearAllStates( declViewModel, gridid );\n                }\n\n                /*\n                  * delete firstPage results if any before re-initializing dataProvider\n                  */\n                if( dataProvider.json.firstPage ) {\n                    delete dataProvider.json.firstPage;\n                }\n\n                dataProvider.initialize( dataCtxNode );\n            } ) );\n\n            const toggleTreeNode = function( node ) {\n                if( !node.loadingStatus ) {\n                    node.loadingStatus = true;\n                    tableInstance.updateTreeCellIcon( node );\n                    // get the current copy of data\n                    Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n                    if( node.isExpanded === true ) {\n                        tableInstance.setNodeExpansionInProgress( true );\n                        node._expandRequested = true;\n                        var preExpandVMObjectsLength = dataProvider.viewModelCollection.loadedVMObjects.length;\n                        dataProvider.expandObject( dataCtxNode, node ).then( function( updatedViewModelCollection ) {\n                            // LCS-180794: If Expand did not return any new objects or\n                            //if node has previous expansion state and dataProvider.cacheCollapse=true which means it didn't get new objects from server,\n                            // continue updating the rest of the table\n                            tableInstance.setNodeExpansionInProgress( false );\n                            if( preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length ) {\n                                delete node.loadingStatus;\n                                tableInstance.refresh();\n                            }\n                            //view model collection is updated so update table with new set of VMOs.\n                            dataProvider.update( updatedViewModelCollection.loadedVMObjects );\n                        } ).finally( function() {\n                            // Make sure even when errored that the expansion in progress is set to false\n                            tableInstance.setNodeExpansionInProgress( false );\n                            //ensure properties are loaded after expansion\n                            // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n                            // render the rows. The row rendering will then occur once they props have been loaded.\n                            tableInstance.loadMissingProps();\n                            delete node.loadingStatus;\n                            delete node._expandRequested;\n                            tableInstance.updateTreeCellIcon( node );\n                            tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n                            if( util.shouldRequestStartEditTreeExpand( tableElem, node, propertyProvider ) ) {\n                                util.requestStartEdit( tableElem );\n                            }\n                        } );\n                        awTableStateSvc.saveRowExpanded( declViewModel, gridid, node );\n                    } else {\n                        dataProvider.collapseObject( dataCtxNode, node ).then( function( updatedViewModelCollection ) {\n                            dataProvider.update( updatedViewModelCollection.loadedVMObjects );\n                            if( preExpandVMObjectsLength === updatedViewModelCollection.loadedVMObjects.length ) {\n                                tableInstance.refresh();\n                            }\n                        } ).finally( function() {\n                            delete node.loadingStatus;\n                            tableInstance.updateTreeCellIcon( node );\n                            tableElem._tableInstance.focusTreeNodeExpandAfterRender = node;\n                        } );\n                        awTableStateSvc.saveRowCollapsed( declViewModel, gridid, node );\n                    }\n                }\n            };\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.toggleTreeNode', toggleTreeNode ) );\n            if( declGridObj.reusable ) {\n                tableInstanceCallbacks.toggleTreeNode = toggleTreeNode;\n            }\n\n            const doFocusPlaceHolder = function( vmNode ) {\n                var vmCollection = dataProvider.viewModelCollection;\n                var cursorNdx = vmCollection.findViewModelObjectById( uwUtilSvc.getEvaluatedId( vmNode ) );\n                /**\n                 * Find 'parent' node of the 'placeholder' node in the vmCollection\n                 */\n                var phParentNode = null;\n                var cursorNode = vmCollection.getViewModelObject( cursorNdx );\n                var parentLevelNdx = cursorNode.levelNdx - 1;\n                if( parentLevelNdx === -1 ) {\n                    phParentNode = dataProvider.topTreeNode;\n                } else {\n                    for( var rowNdx = cursorNdx - 1; rowNdx >= 0; rowNdx-- ) {\n                        var currRow = vmCollection.getViewModelObject( rowNdx );\n                        if( currRow.levelNdx === parentLevelNdx ) {\n                            phParentNode = currRow;\n                            break;\n                        }\n                    }\n                }\n                if( phParentNode === null ) {\n                    return null;\n                }\n                /**\n                 * Load, using the 'focusAction', the siblings of the 'placeholder' in the context of its immediate\n                 * 'parent'.\n                 * <P>\n                 * Note: We want to use a smaller page size here to minimize the loading.\n                 */\n                var treeLoadInput = awTableSvc.createTreeLoadInput( phParentNode, 0, null, vmNode.id, dataProvider.treePageSize, true, null );\n                var loadIDs = {\n                    t_uid: dataProvider.topTreeNode.uid,\n                    o_uid: phParentNode.uid,\n                    c_uid: vmNode.uid,\n                    uid: null\n                };\n                var actionRequestObj = {\n                    treeLoadInput: treeLoadInput,\n                    loadIDs: loadIDs\n                };\n                /**\n                 * Change 'suffix' text to indicate we are attempting to load more rows.\n                 */\n                vmNode.loadingStatus = true;\n                // get the current copy of data\n                Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n                return dataProvider.someDataProviderSvc.executeLoadAction( dataProvider.nextAction,\n                    dataProvider.json, dataCtxNode, actionRequestObj ).then( function( response ) {\n                    /**\n                     * Locate cursor node in original collection & find/collect all contained 'child' nodes.\n                     */\n                    var cursorId = uwUtilSvc.getEvaluatedId( cursorNode );\n                    var cursorLevel = cursorNode.levelNdx;\n                    var vmCollection = dataProvider.viewModelCollection;\n                    var cursorNdxInOrig = vmCollection.findViewModelObjectById( cursorId );\n                    var loadedVMObjects = vmCollection.loadedVMObjects;\n                    var cursorVMObjects = [ loadedVMObjects[ cursorNdxInOrig ] ];\n                    for( var l = cursorNdxInOrig + 1; l < loadedVMObjects.length; l++ ) {\n                        var currNode = loadedVMObjects[ l ];\n                        if( currNode.levelNdx <= cursorLevel ) {\n                            break;\n                        }\n                        cursorVMObjects.push( currNode );\n                    }\n                    /**\n                     * Re-order the childNdx values of the sibling nodes relative to initial placeholder as 0;\n                     */\n                    var treeLoadResult = response.actionResultObj.responseObj.treeLoadResult;\n                    var newVMObjects = treeLoadResult.childNodes;\n                    var cursorNdxInNew = 0;\n                    for( var i = 0; i < newVMObjects.length; i++ ) {\n                        if( newVMObjects[ i ].id === cursorId ) {\n                            cursorNdxInNew = i;\n                            break;\n                        }\n                    }\n                    for( var j = 0; j < newVMObjects.length; j++ ) {\n                        newVMObjects[ j ].childNdx = j - cursorNdxInNew;\n                    }\n                    /**\n                     * Check if the 'fresh' cursor node is at either end of the 'sibling' list and is now known to be an\n                     * 'incompleteHead' or 'incompleteTail'\n                     * <P>\n                     * If so: Move that status over to the 'original' cursor node.\n                     * <P>\n                     * Note: We are about to replace the 'fresh' node in the set of its siblings just returned and we do\n                     * not want to lose this important information.\n                     */\n                    if( cursorNdxInNew === 0 && newVMObjects[ 0 ].incompleteHead ) {\n                        cursorNode.incompleteHead = true;\n                    }\n                    var lastNodeNdx = newVMObjects.length - 1;\n                    if( cursorNdxInNew === lastNodeNdx && newVMObjects[ lastNodeNdx ].incompleteTail ) {\n                        cursorNode.incompleteTail = true;\n                    }\n                    /**\n                     * Make sure the placeholder 'parent' node gets its 'children' set (a shallow clone is good enough).\n                     * <P>\n                     * Replace the 'fresh' cursor node with the 'original' cursor node since it holds important state\n                     * and hierarchy info.\n                     */\n                    phParentNode.children = _.clone( newVMObjects );\n                    phParentNode.children[ cursorNdxInNew ] = cursorNode;\n                    /**\n                     * Remove the 'fresh' cursor node from the array of its siblings.\n                     * <P>\n                     * Insert the cursor node (and all of its children from the original array) into the array of new\n                     * nodes.\n                     * <P>\n                     * Remove the cursor node (and all of its children) from the original array\n                     * <P>\n                     * Insert the new nodes (updated with the cursor node and all of its children from the original\n                     * array) into the vmCollection array of nodes.\n                     * <P>\n                     * Clear the loading status of the cursor node.\n                     */\n                    newVMObjects.splice( cursorNdxInNew, 1 );\n                    // LCS-230184 - In the case where no changes are made to the loadedVMObjects, we must manually refresh\n                    // so that the table can process the remaining rendered nodes for more focus placeholder, expansion\n                    // restoration, or prop loading.\n                    if( newVMObjects.length === 0 ) {\n                        delete vmNode.loadingStatus;\n                        delete vmNode._focusRequested;\n                        tableInstance.refresh();\n                        return;\n                    }\n                    var insertNdx = cursorNdxInNew - 1;\n                    arrayUtils.insert( newVMObjects, insertNdx, cursorVMObjects );\n                    loadedVMObjects.splice( cursorNdxInOrig, cursorVMObjects.length );\n                    arrayUtils.insert( loadedVMObjects, cursorNdxInOrig - 1, newVMObjects );\n                    delete vmNode.loadingStatus;\n                    delete vmNode._focusRequested;\n                    dataProvider.update( loadedVMObjects );\n                    /**\n                     * Fire a 'treeNodesLoaded' event, sourced to the uwDataProvider, for all tree-table changes. This\n                     * event includes only the input/result structures for the current load operation. This event is\n                     * used to load additional properties in an async fashion.\n                     */\n                    eventBus.publish( dataProvider.name + '.treeNodesLoaded', {\n                        treeLoadInput: treeLoadInput,\n                        treeLoadResult: treeLoadResult\n                    } );\n                    /**\n                     * Fire a 'modelObjectsUpdated' event, sourced to the uwDataProvider, for all tree-table changes.\n                     * This event includes the complete array of nodes in the collection.\n                     */\n                    eventBus.publish( dataProvider.name + '.modelObjectsUpdated', {\n                        viewModelObjects: loadedVMObjects,\n                        noResults: false\n                    } );\n                } );\n            };\n            tableInstanceCallbacks.doFocusPlaceHolder = doFocusPlaceHolder;\n        } else {\n            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.modelObjectsUpdated', function( event ) {\n                if ( event && !event.arrangeColumnEvent ) {\n                    tableCallbacks.columnsArranged( event );\n                }\n            } ) );\n        }\n\n        tableCallbacks.columnsArranged = ( columnArrangeData ) => {\n            if( columnArrangeData.arrangeType && columnArrangeData.arrangeType === 'saveColumnAndLoadAction' && columnArrangeData.viewModelObjects ) {\n                // Just update data provider with vmos changed by columnArrangeService\n                tableInstance.resetInfiniteScroll();\n                dataProvider.update( columnArrangeData.viewModelObjects, columnArrangeData.totalFound );\n                // Need to refresh the table since there is no watch anymore on loadedVMObjects\n                tableInstance.refresh();\n            }\n        };\n\n        /**\n          * Subscribe to resetState. Clear all states and set isFocusedLoad to true.\n          */\n        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.resetState', function() {\n            awTableStateSvc.clearAllStates( declViewModel, gridid );\n            dataProvider.isFocusedLoad = true;\n        } ) );\n\n        cfgSvc.get( 'propertyRendererTemplates' );\n        initializeProvider( dataProvider, columnProvider, dataCtxNode ).then( () => {\n            var gridContextDispatcher = dataCtxNode.gridContextDispatcher;\n            if( declGridObj.reusable ) {\n                gridContextDispatcher = declGridObj.gridContextDispatcher;\n            }\n            tableInstance = splmTableFactory.createTableObject(\n                element, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, declGridObj.contentFilter, gridOptions, declGridObj.containerheight,\n                gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, declGridObj.tableContext, declGridObj.reusable, declGridObj.showCheckBox\n            );\n            tableInstance.showCheckBox = declGridObj.showCheckBox;\n            tableElem = tableInstance.getTableElement();\n            initializeObserver();\n            // Following refresh is for cases like object sets. Where first page is already loaded by stylesheet SOA\n            tableInstance.viewModelCollection = viewModelCollection;\n            tableInstance.refresh();\n\n            dataProvider.initializationComplete = true;\n\n            if( declGridObj.containerHeight ) {\n                tableInstance.updateContainerHeight( declGridObj.containerHeight );\n            }\n\n            // Event Interface to rerender the table with data currently on the client\n            instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.clientRefresh', function() {\n                _.defer( function() {\n                    tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    if ( tableElem && tableElem._tableInstance ) {\n                        tableElem._tableInstance.showCheckBox = declGridObj.showCheckBox;\n                    }\n                    util.cleanupComponents( element );\n                    tableInstance.refresh();\n                } );\n            } ) );\n        }, error => {\n            dataProvider.initializationComplete = false;\n            logger.trace( error );\n        } );\n    }\n\n    instanceEventSubcr.push( eventBus.subscribe( 'columnArrange', function( eventData ) {\n        if( eventData.name === gridid || eventData.columnConfigId && dataProvider.columnConfig && eventData.columnConfigId === dataProvider.columnConfig.columnConfigId ) {\n            if( eventData.columns.length ) {\n                tableInstance.removeStaleFilters( eventData.columns );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n        }\n        if ( tableInstance.getDynamicRowHeightStatus() ) {\n            tableInstance.resetDynamicRowHeights();\n        }\n    } ) );\n\n    var relatedModifiedEvent = eventBus.subscribe( 'cdm.relatedModified', function( eventData ) {\n        tableInstance.relatedModified();\n    } );\n\n    instanceEventSubcr.push( relatedModifiedEvent );\n\n    // Event Interface to rerender table with reloaded data from the dataprovider\n    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.reload', reloadDataProvider ) );\n\n    // revisitme - tstark - Need to keep event until all application teams convert away from events\n    instanceEventSubcr.push( eventBus.subscribe( 'pltable.columnFilterApplied', function( eventData ) {\n        if( gridid === eventData.gridId && eventData.isInternalTableEvent !== true ) {\n            if( eventData.filters && eventData.filters.length ) {\n                columnFilterService.setFilters( columnProvider, dataProvider, eventData.filters, eventData.column );\n            } else if( eventData.column ) {\n                columnFilterService.removeFilter( eventData.column, columnProvider, dataProvider );\n            } else {\n                columnFilterService.removeAllFilters( dataProvider, columnProvider );\n            }\n            dataProvider.isColumnFilterApplied = columnFilterService.isColumnFilterApplied( dataProvider );\n            const columnName = eventData.column ? eventData.column.field : null;\n            tableInstance.updateFilterIcons( columnName );\n            reloadDataProvider();\n        }\n    } ) );\n\n    tableCallbacks.updateColumnMenuData = function( columnMenuData ) {\n        _.forEach( dataProvider.cols, function( currentColumn ) {\n            if( columnMenuData.columnName === currentColumn.field ) {\n                currentColumn.filter = { ...currentColumn.filter, ...columnMenuData };\n                currentColumn.filter.columnMenuData = columnMenuData;\n                if ( currentColumn.filter.showFilters ) {\n                    if( currentColumn.filter.showFilters.dbValue && currentColumn.filter.showFilters.dbValue !== 'false' ) {\n                        currentColumn.filter.showFilterFacets = true;\n                    } else {\n                        currentColumn.filter.showFilterFacets = false;\n                    }\n                }\n                return false;\n            }\n        } );\n    };\n\n    // revisitme - tstark - Need to keep event until all application teams convert away from events\n    instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.setFilterDisability', function( eventData ) {\n        if( gridid === eventData.gridId ) {\n            tableInstance.setFilterDisability( eventData.isFilterDisabled );\n        }\n    } ) );\n\n    /**\n      *  destroy the table\n      */\n    tableCallbacks.destroy = function() {\n        var columns = [];\n        if( dataProvider.columnConfig && dataProvider.columnConfig.columns ) {\n            columns = dataProvider.columnConfig.columns;\n        }\n        _.forEach( instanceEventSubcr, function( eventBusSub ) {\n            eventBus.unsubscribe( eventBusSub );\n        } );\n        splmTableFactory.destroyTable( gridid, element, columns );\n    };\n\n    tableCallbacks.updateVmCollection = ( viewModelCollection ) => {\n        if( tableInstance ) {\n            tableInstance.viewModelCollection = viewModelCollection;\n            if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                util.requestStartEdit( tableElem );\n            }\n            tableInstance.refresh();\n        }\n    };\n\n    tableCallbacks.updateDeclGridObject = ( declGridParam ) => {\n        declGridObj = declGridParam;\n    };\n\n    tableCallbacks.updateMenuContext = ( menuContext ) => {\n        declGridObj.menuContext = menuContext;\n    };\n\n    tableCallbacks.updateState = ( newState ) => {\n        declViewModel = newState;\n        if( tableInstance ) {\n            tableInstance.updateInstanceState( newState );\n        }\n    };\n\n    tableCallbacks.refreshTable = () => {\n        if( tableInstance ) {\n            tableInstance.refresh();\n        }\n    };\n\n    tableCallbacks.updateGridOptionsForTableInstance = ( props ) => {\n        if( tableElem && tableElem._tableInstance && props && props.showCheckBox !== undefined ) {\n            tableElem._tableInstance.showCheckBox = props.showCheckBox;\n        }\n    };\n\n    /**\n      * Setup to react to changes in selection within the dataProvider.\n      *\n      * @param {Object} event -\n      * @param {Object} data -\n      */\n    instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectionChangeEvent', function( event ) {\n        var selections = event.selectionModel.getSelection();\n        // Set scroll to row in progress\n        if( dataProvider.isFocusedLoad === true && selections.length > 0 ) {\n            dataProvider.isFocusedLoad = false;\n            dataProvider.scrollToRow = true;\n        }\n\n        if( selections.length > 0 && selections.length >= _previousSelections.length && _.isEqual( _previousSelections, selections ) === false ||\n             dataProvider.scrollToRow === true ) {\n            dataProvider.scrollToRow = true;\n            eventBus.publish( 'plTable.scrollToRow', {\n                gridId: gridid,\n                rowUids: selections\n            } );\n        }\n        _previousSelections = selections.slice();\n    } ) );\n    var pageLoadInProgress = false;\n\n    const getTreeNodePageCallback = function( results ) {\n        logger.trace( 'AW simple table: Loaded next tree page data' );\n        pageLoadInProgress = false;\n        if( util.shouldRequestStartEditTreePagination( tableElem, propertyProvider ) ) {\n            util.requestStartEdit( tableElem );\n        }\n        dataProvider.update( results.loadedVMObjects, results.totalFound );\n    };\n\n    // eslint-disable-next-line complexity\n    const loadMorePages = function( eventData ) {\n        if( tableInstance.viewModelCollection ) {\n            var lastItemIndex = eventData.lastRenderedItem.index;\n            // get the current copy of data\n            Object.assign( dataCtxNode.data.data, dataCtxNode.data.getData() );\n            if( lastItemIndex !== 0 && lastItemIndex === tableInstance.viewModelCollection.loadedVMObjects.length - 1 ) {\n                if( dataProvider.nextAction || dataProvider.action ) {\n                    var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                    if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                        delete lastNode.incompleteTail;\n                        if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                            pageLoadInProgress = true;\n                            dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                            return;\n                        }\n                        pageLoadInProgress = true;\n                        dataProvider.pageDispatcher( { type: 'NEXT_PAGE' } );\n                        return;\n                    }\n                    logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                }\n            }\n            var firstItemIndex = eventData.firstRenderedItem.index;\n            if( firstItemIndex === 0 ) {\n                if( dataProvider.previousAction ) {\n                    var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                    if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                        delete firstNode.incompleteHead;\n                        tableInstance.maintainScrollPosition();\n                        if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                            pageLoadInProgress = true;\n                            dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                            return;\n                        }\n                        pageLoadInProgress = true;\n                        dataProvider.pageDispatcher( { type: 'PREVIOUS_PAGE' } );\n                        return;\n                    }\n                    logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                }\n            }\n            // Check for incomplete head/tail on tree node in rendered range\n            if( gridOptions.useTree === true ) {\n                var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                    var loadNextPage = incompleteNode.incompleteTail === true;\n                    if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                        return;\n                    } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                        return;\n                    }\n                    delete incompleteNode.incompleteHead;\n                    delete incompleteNode.incompleteTail;\n                    pageLoadInProgress = true;\n                    dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                    return;\n                }\n            }\n        }\n        /** revisitme Radhika: We havesome logic below around pageLoadInProgress. We might need some\n           * tstark - leave for refactor\n               * in the new system. The code needs to be cleaned up and the necessary lines needs to be reused\n              if( dataProvider.viewModelCollection && pageLoadInProgress === false ) {\n                  // Check if next page should be loaded\n                  var lastItemIndex = eventData.lastRenderedItem.index;\n                  if( lastItemIndex !== 0 && lastItemIndex === dataProvider.viewModelCollection.loadedVMObjects.length - 1 ) {\n                      if( dataProvider.nextAction || dataProvider.action ) {\n                          var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                          if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                              delete lastNode.incompleteTail;\n                              if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n                              /**\n                               * REFACTOR: This is how UI Grid checks to see if we actually have more pages to load or not since\n                               * dataProvider.hasMorePages() will always return true, because it sets dataProvider.update(firstPageObjs, firstPageObjs.length + 1)\n                               * in dataProviderFactory and uses these two values for checking for if more pages to load or not.\n                               * Will remove this code in 4.2 when all UIgrid replaced by PL Table\n                              var maxToLoad;\n                              if( dataProvider.action && dataProvider.action.inputData ) {\n                                  var actionInputData = dataProvider.action.inputData;\n                                  if( actionInputData.searchInput ) {\n                                      maxToLoad = actionInputData.searchInput.maxToLoad;\n                                  }\n                              }\n\n                              /**\n                               *\n                               * If we have a firstPage and its length is less than maxToLoad, we dont need to load another page.\n                               * All other cases, handle like normally => Try to get next page of data\n                               *\n                              if( maxToLoad && dataProvider.json.firstPage && dataProvider.json.firstPage.length < maxToLoad ) {\n                                  logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                              } else {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getNextPage( dataCtxNode ).then( function() {\n                                      logger.trace( 'AW simple table: Loaded next page data' );\n                                      pageLoadInProgress = false;\n                                      if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                          util.requestStartEdit( tableElem );\n                                      }\n                                  } );\n                                  return;\n                              }\n                          } else {\n                              logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                          }\n                      }\n                  }\n\n                  // Check if previous page should be loaded as long as next page has not already been requested\n                  var firstItemIndex = eventData.firstRenderedItem.index;\n                  if( firstItemIndex === 0 ) {\n                      if( dataProvider.previousAction ) {\n                          var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                          if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                              delete firstNode.incompleteHead;\n                              eventBus.publish( dataProvider.name + '.plTable.maintainScrollPosition' );\n                              if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n\n                              pageLoadInProgress = true;\n                              dataProvider.getPreviousPage( dataCtxNode ).then( function() {\n                                  logger.trace( 'AW simple table: Loaded previous page data' );\n                                  pageLoadInProgress = false;\n                                  if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                      util.requestStartEdit( tableElem );\n                                  }\n                              } );\n                              return;\n                          }\n\n                          logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                      }\n                  }\n\n                  // Check for incomplete head/tail on tree node in rendered range\n                  if( gridOptions.useTree === true ) {\n                      var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                      if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                          var loadNextPage = incompleteNode.incompleteTail === true;\n                          if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                              return;\n                          } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                              return;\n                          }\n                          delete incompleteNode.incompleteHead;\n                          delete incompleteNode.incompleteTail;\n                          pageLoadInProgress = true;\n                          dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                          return;\n                      }\n                  }\n              }\n          */\n    };\n    tableInstanceCallbacks.loadMorePages = loadMorePages;\n\n    let unsetScrollToRowIndex = function() {\n        tableInstance.unsetScrollToRowIndex();\n    };\n\n    tableInstanceCallbacks.unsetScrollToRowIndex = unsetScrollToRowIndex;\n\n\n    let columnsRearranged = function( eventData ) {\n        tableInstance.columnsRearranged( eventData );\n    };\n\n    tableInstanceCallbacks.columnsRearranged = columnsRearranged;\n\n    let columnsResized = function( eventData ) {\n        tableInstance.columnsResized( eventData );\n    };\n\n    tableInstanceCallbacks.columnsResized = columnsResized;\n\n    return tableCallbacks;\n};\n\nexport default {\n    initializeTable\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}