{"ast":null,"code":"// Copyright (c) 2022 Siemens\n\n/**\n * A simple and inexpensive HTML Sanitizer which detects and/or eliminates HTML that can cause potential cross-site\n * scripting (XSS) and other UI issues.\n *\n * @module js/sanitizer\n */\nimport _ from 'lodash';\nimport localeSvc from 'js/localeService';\n/**\n * HTML 'anchor' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_ANCHOR_SCRIPT = /href=\"[^\"]*?java[^\"]*?\"/;\n/**\n * HTML 'src=java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_SRC_SCRIPT = /src=java*/;\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_SCRIPT = /style=\"[^\"]*?java[^\"]*?\"/;\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_WEIRD = /style=\"[^\"]*?&[^\"]*?\"/;\n/**\n * HTML '<style on*=' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_ATTR = /<style.*(on\\S+)(\\s*)=/;\n/**\n * HTML entity regular expression\n *\n * @private\n */\n\nvar REGEX_HTML_ENTITY = /[a-z]+|#[0-9]+|#x[0-9a-fA-F]+/i;\n/**\n * HTML 'on*' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\n\nvar REGEX_IMG_ATTR = /(\\b)(on\\S+)(\\s*)=/i;\n/**\n * HTML 'base64' regular expression (e.g. 'data:image/jpeg;base64').\n *\n * @private\n */\n\nvar REGEX_BASE64_IMG = /(\\b)(src=\"data:image\\S+)(\\s*)base64/i;\n/**\n * HTML escaped entity regular expression\n *\n * @private\n */\n\nvar REGEX_HTML_ESCAPED_ENTITY = /&[a-z]+;|&#[0-9]+;/i;\n/**\n * {RegEx} Matches external links\n */\n\nvar REGEX_URL_PATTERN = /http(|s):\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+#()[\\]\\-])?|http(|s):\\/\\/([\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+\\*#()[\\]\\-])?/gi; // eslint-disable-line no-useless-escape\n\n/**\n * HTML 'image' regular expression\n *\n * @private\n */\n\nvar REGEX_INVALID_HTML = new RegExp(REGEX_FRAGMENT_ANCHOR_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_SRC_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_STYLE_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_STYLE_ATTR.source + '|' //\n+ REGEX_FRAGMENT_STYLE_WEIRD.source, 'i');\n/**\n * Global array of HTML black list tags used for sanitization\n *\n * @private\n */\n\nvar TAG_BLACKLIST = ['applet', 'audio', 'body', 'embed', 'fieldset', 'form', 'frame', 'frameset', 'input', 'iframe', 'meta', 'object', 'output', 'param', 'script', 'style', 'textarea', 'video'];\n/**\n * Global reference to invalid HTML locale string\n *\n * @private\n */\n\nvar _invalidHtmlMessage = null;\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\n\nlet exports;\n/**\n * HTML escapes a character. HTML meta characters will be escaped.\n *\n * @private\n *\n * @param {String} unsafe - unsafe HTML String which needs to be escaped.\n *\n * @return {String} Returns escaped and safe HTML String.\n */\n\nfunction _escapeHtml(unsafe) {\n  if (!/['\"<>&]+/.test(unsafe)) {\n    return unsafe;\n  }\n\n  return unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n/**\n * HTML meta characters will be un-escaped. This method should be used only after sanitizing the input.\n *\n * @private\n *\n * @param {String} escapedSafe - escapedSafe HTML String which needs to be un-escaped.\n *\n * @return {String} Returns un-escaped and safe HTML String.\n */\n\n\nfunction _unEscapeHtml(escapedSafe) {\n  // eslint-disable-line no-unused-vars\n  return escapedSafe.replace(/&amp;/ig, '&').replace(/&lt;/ig, '<').replace(/&gt;/ig, '>').replace(/&quot;/ig, '\"').replace(/&#39;/ig, '\\'');\n}\n/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n *\n * @param {Boolean} replaceAnchors - TRUE if any HTTP type external references should be wrapped in an HTML <a\n *            href=\"XXXXX\"></a> (i.e. 'anchors').\n *\n * @param {Boolean} replaceNewLines - TRUE if any newline characters should be replaced by an HTML '<BR>'\n *\n * @return {String} Returns escaped and safe HTML.\n */\n\n\nexport let htmlEscapeAllowEntities = function (value, replaceAnchors, replaceNewLines) {\n  if (_.isString(value) && value.length > 0) {\n    if (!/(['\"<>&]+|(http)+|\\n)/i.test(value)) {\n      return value;\n    }\n\n    var escaped;\n\n    if (!/&+/.test(value)) {\n      escaped = _escapeHtml(value);\n    } else {\n      var splitArray = value.split('&', -1);\n      var nSegment = splitArray.length;\n\n      for (var ndx = 0; ndx < nSegment; ndx++) {\n        var currSegment = splitArray[ndx];\n        /**\n         * The first segment is never part of a valid tag;\n         * <P>\n         * Note that if the input string starts with a tag, we will get an empty segment at the\n         * beginning.\n         */\n\n        if (ndx === 0) {\n          escaped = _escapeHtml(currSegment);\n          continue;\n        }\n\n        var entityEnd = currSegment.indexOf(';');\n\n        if (entityEnd > 0 && REGEX_HTML_ENTITY.test(currSegment.substring(0, entityEnd))) {\n          // Concatenate the entity without escaping.\n          escaped = escaped.concat('&').concat(currSegment.substring(0, entityEnd + 1)); // Concatenate the rest of the segment, escaped.\n\n          escaped = escaped.concat(_escapeHtml(currSegment.substring(entityEnd + 1)));\n        } else {\n          // The segment did not start with an entity reference, so escape the whole segment.\n          escaped = escaped.concat('&amp;').concat(_escapeHtml(currSegment));\n        }\n      }\n    }\n\n    if (replaceAnchors && escaped) {\n      // replaces url text to hyperlinks\n      escaped = escaped.replace(REGEX_URL_PATTERN, '<a href=\"$&\">$&</a>');\n    }\n\n    if (replaceNewLines && escaped) {\n      // replaces new lines to <br> tags\n      escaped = escaped.replace(/\\n/g, '<br/>');\n    }\n\n    return escaped;\n  }\n\n  return '';\n};\n/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list\n * tags.\n *\n * @param {StringArray} values - Array of HTML Strings which needs to be sanitized.\n *\n * @return {StringArray} Returns sanitized HTML string array.\n */\n\nexport let sanitizeHtmlValues = function (values) {\n  if (values && values.length > 0) {\n    for (var ii = values.length - 1; ii >= 0; ii--) {\n      var originalHtml = values[ii];\n      var sanitizedHtml = exports.sanitizeHtmlValue(originalHtml);\n\n      if (sanitizedHtml && originalHtml !== sanitizedHtml) {\n        values[ii] = sanitizedHtml;\n      }\n    }\n  }\n\n  return values;\n};\n/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n *\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */\n\nexport let sanitizeHtmlValue = function (rawValue) {\n  var sanitized = '';\n  var decodedValue = '';\n\n  if (_.isString(rawValue)) {\n    // load _invalidHtmlMessage if it is not loaded\n    if (!_invalidHtmlMessage) {\n      exports.setInvalidHtmlMessage(localeSvc.getLoadedText().INVALID_HTML);\n    }\n    /**\n     * Decode html escaped entity characters before applying sanitization, so that it will also catch\n     * escaped XSS vulnerability attacks.\n     */\n\n\n    if (REGEX_HTML_ESCAPED_ENTITY.test(rawValue)) {\n      decodedValue = _.unescape(rawValue);\n    } else {\n      decodedValue = rawValue;\n    }\n    /**\n     * Break the string into n+1 segments based on any HTML tags\n     * <P>\n     * Loop for each of these segments.\n     */\n\n\n    var splitArray = decodedValue.split('<', -1);\n    var nSplit = splitArray.length;\n\n    for (var ndx = 0; ndx < nSplit; ndx++) {\n      var currSegment = splitArray[ndx];\n      /**\n       * The first segment is never part of a valid tag;\n       * <P>\n       * Note that if the input string starts with a tag, we will get an empty segment at the beginning.\n       */\n\n      if (ndx === 0) {\n        sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));\n        continue;\n      }\n      /**\n       * Determine if the current segment is the start of an attribute-free tag or end-tag in our\n       * whitelist.\n       */\n\n\n      var tagStart = 0; // will be 1 if this turns out to be an end tag.\n\n      var tagEnd = currSegment.indexOf('>');\n      var tag = null;\n      var isValidTag = true;\n      var selfClosingTag = false;\n\n      if (tagEnd > 0) {\n        if (currSegment.charAt(0) === '/') {\n          tagStart = 1;\n        } // for self closing tags ex: '<br />'\n\n\n        if (currSegment.charAt(tagEnd - 1) === '/') {\n          selfClosingTag = true;\n          tagEnd -= 1;\n        }\n\n        tag = currSegment.substring(tagStart, tagEnd);\n        var exist = tag.replace(/\\s(\\w|\\D).*/ig, ''); // for attributes\n\n        if (TAG_BLACKLIST.indexOf(exist.toLowerCase().trim()) !== -1) {\n          isValidTag = false;\n        }\n\n        if (isValidTag) {\n          // concat the tag, not escaping it\n          if (tagStart === 0) {\n            /**\n             * Check for image attribute script <BR>\n             * <img src=\"\" onerror=\"alert('securityIssue_img');\"/>\n             */\n            if (REGEX_BASE64_IMG.test(tag)) {\n              // split tag into attributes, and process individually\n              // to avoid false positives.\n              var attributes = tag.match(/[\\w-]+=\"[^\"]*\"/g);\n\n              for (var i = 0; i < attributes.length; i++) {\n                if (attributes[i].indexOf('src=') < 0 && REGEX_IMG_ATTR.test(attributes[i])) {\n                  return _invalidHtmlMessage;\n                }\n              }\n            } else if (REGEX_IMG_ATTR.test(tag)) {\n              return _invalidHtmlMessage;\n            }\n\n            sanitized = sanitized.concat('<');\n          } else {\n            // we had seen an end-tag\n            sanitized = sanitized.concat('</');\n          }\n\n          if (selfClosingTag) {\n            sanitized = sanitized.concat(tag).concat('/>'); // concat the rest of the segment, escaping it\n\n            sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd + 2)));\n          } else {\n            sanitized = sanitized.concat(tag).concat('>'); // concat the rest of the segment, escaping it\n\n            sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd + 1)));\n          }\n        } else {\n          return _invalidHtmlMessage;\n        }\n      } else {\n        sanitized = sanitized.concat('<');\n        sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));\n      }\n    }\n    /**\n     * Check for weird style stuff\n     */\n\n\n    if (REGEX_INVALID_HTML.test(sanitized)) {\n      return _invalidHtmlMessage;\n    }\n  }\n\n  return rawValue;\n};\n/**\n * Set the message that is seen when invalid HTML content is found.\n * <P>\n * Note: This message is normally set based on the value returned by the 'localeService'. This method is marked\n * 'private' and is intended to be used during testing to allow a preditable value to be returned.\n *\n * @private (this method should be used for unit test only)\n *\n * @param {String} message - Localized text to return from 'sanitizeHtmlValue' when some issue is found.\n */\n\nexport let setInvalidHtmlMessage = function (message) {\n  _invalidHtmlMessage = message;\n};\n/**\n * Escape markup which Highcharts will unescape internally\n *\n * Full sanitize is not necessary (and causes issues) because Highcharts internally sets as\n * text on DOM element (does not create element from string)\n *\n * @param {String} x Value to escape\n * @returns {String} Escaped value\n */\n\nexport const escapeMarkup = x => x.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n/**\n * This API sanitizes props to be sent to native html elements to avoid console warnings.\n * It however allows to bypass few custom-attributes if mentioned in argument.\n * Use this if any valid custom attributes to be excluded from being filtered out.\n *\n *\n * @param {Object} props - props coming from component.\n * @param {String} htmlElement - name of htmlElement for which a sanitization is requried\n * @returns {Object} sanitizedProps - Returns valid sanitized props good to use on native html element.\n */\n\nexport const sanitizeHTMLTagProps = (props, htmlElement) => {\n  //placeHolder to allow custom attributes on given html tag.\n  //maintain a list of custom attributes or exception props that are required to bypass sanitization check.\n  //Make sure this list shouldn't contribute to react console warnings.\n  let customAttributes;\n  let excludeAttributes = [];\n\n  switch (htmlElement) {\n    case 'input':\n      customAttributes = ['label', 'data-locator', 'onKeyDown', 'dirty', 'checked'];\n      break;\n\n    case 'span':\n      customAttributes = ['data-locator', 'value'];\n      excludeAttributes = ['aria-label', 'aria-required'];\n      break;\n\n    case 'div':\n    case 'nav':\n    case 'main':\n    case 'textarea':\n    default:\n      customAttributes = ['data-locator'];\n  }\n\n  let sanitizedProps = {};\n  let dummyHtmlElem = document.createElement(htmlElement);\n  let filteredAttribs = Object.keys(props).filter(propName => !excludeAttributes.includes(propName) && (propName in dummyHtmlElem || propName.toLowerCase() in dummyHtmlElem || _.camelCase(propName) in dummyHtmlElem || customAttributes.includes(propName)));\n  filteredAttribs.forEach(key => sanitizedProps[key] = props[key]);\n  return sanitizedProps;\n};\nexports = {\n  htmlEscapeAllowEntities,\n  sanitizeHtmlValues,\n  sanitizeHtmlValue,\n  setInvalidHtmlMessage,\n  escapeMarkup,\n  sanitizeHTMLTagProps\n};\nexport default exports;","map":{"version":3,"names":["_","localeSvc","REGEX_FRAGMENT_ANCHOR_SCRIPT","REGEX_FRAGMENT_SRC_SCRIPT","REGEX_FRAGMENT_STYLE_SCRIPT","REGEX_FRAGMENT_STYLE_WEIRD","REGEX_FRAGMENT_STYLE_ATTR","REGEX_HTML_ENTITY","REGEX_IMG_ATTR","REGEX_BASE64_IMG","REGEX_HTML_ESCAPED_ENTITY","REGEX_URL_PATTERN","REGEX_INVALID_HTML","RegExp","source","TAG_BLACKLIST","_invalidHtmlMessage","exports","_escapeHtml","unsafe","test","replace","_unEscapeHtml","escapedSafe","htmlEscapeAllowEntities","value","replaceAnchors","replaceNewLines","isString","length","escaped","splitArray","split","nSegment","ndx","currSegment","entityEnd","indexOf","substring","concat","sanitizeHtmlValues","values","ii","originalHtml","sanitizedHtml","sanitizeHtmlValue","rawValue","sanitized","decodedValue","setInvalidHtmlMessage","getLoadedText","INVALID_HTML","unescape","nSplit","tagStart","tagEnd","tag","isValidTag","selfClosingTag","charAt","exist","toLowerCase","trim","attributes","match","i","message","escapeMarkup","x","sanitizeHTMLTagProps","props","htmlElement","customAttributes","excludeAttributes","sanitizedProps","dummyHtmlElem","document","createElement","filteredAttribs","Object","keys","filter","propName","includes","camelCase","forEach","key"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/sanitizer.js"],"sourcesContent":["// Copyright (c) 2022 Siemens\n\n/**\n * A simple and inexpensive HTML Sanitizer which detects and/or eliminates HTML that can cause potential cross-site\n * scripting (XSS) and other UI issues.\n *\n * @module js/sanitizer\n */\nimport _ from 'lodash';\nimport localeSvc from 'js/localeService';\n\n/**\n * HTML 'anchor' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_ANCHOR_SCRIPT = /href=\"[^\"]*?java[^\"]*?\"/;\n\n/**\n * HTML 'src=java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_SRC_SCRIPT = /src=java*/;\n\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_SCRIPT = /style=\"[^\"]*?java[^\"]*?\"/;\n\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_WEIRD = /style=\"[^\"]*?&[^\"]*?\"/;\n\n/**\n * HTML '<style on*=' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_ATTR = /<style.*(on\\S+)(\\s*)=/;\n\n/**\n * HTML entity regular expression\n *\n * @private\n */\nvar REGEX_HTML_ENTITY = /[a-z]+|#[0-9]+|#x[0-9a-fA-F]+/i;\n\n/**\n * HTML 'on*' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\nvar REGEX_IMG_ATTR = /(\\b)(on\\S+)(\\s*)=/i;\n\n/**\n * HTML 'base64' regular expression (e.g. 'data:image/jpeg;base64').\n *\n * @private\n */\nvar REGEX_BASE64_IMG = /(\\b)(src=\"data:image\\S+)(\\s*)base64/i;\n\n/**\n * HTML escaped entity regular expression\n *\n * @private\n */\nvar REGEX_HTML_ESCAPED_ENTITY = /&[a-z]+;|&#[0-9]+;/i;\n\n/**\n * {RegEx} Matches external links\n */\nvar REGEX_URL_PATTERN =\n    /http(|s):\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+#()[\\]\\-])?|http(|s):\\/\\/([\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+\\*#()[\\]\\-])?/gi; // eslint-disable-line no-useless-escape\n\n/**\n * HTML 'image' regular expression\n *\n * @private\n */\nvar REGEX_INVALID_HTML = new RegExp( REGEX_FRAGMENT_ANCHOR_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_SRC_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_ATTR.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_WEIRD.source, 'i' );\n\n/**\n * Global array of HTML black list tags used for sanitization\n *\n * @private\n */\nvar TAG_BLACKLIST = [ 'applet', 'audio', 'body', 'embed', 'fieldset', 'form', 'frame', 'frameset', 'input',\n    'iframe', 'meta', 'object', 'output', 'param', 'script', 'style', 'textarea', 'video'\n];\n\n/**\n * Global reference to invalid HTML locale string\n *\n * @private\n */\nvar _invalidHtmlMessage = null;\n\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\nlet exports;\n\n/**\n * HTML escapes a character. HTML meta characters will be escaped.\n *\n * @private\n *\n * @param {String} unsafe - unsafe HTML String which needs to be escaped.\n *\n * @return {String} Returns escaped and safe HTML String.\n */\nfunction _escapeHtml( unsafe ) {\n    if( !/['\"<>&]+/.test( unsafe ) ) {\n        return unsafe;\n    }\n\n    return unsafe.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ).replace( /\"/g,\n        '&quot;' ).replace( /'/g, '&#39;' );\n}\n\n/**\n * HTML meta characters will be un-escaped. This method should be used only after sanitizing the input.\n *\n * @private\n *\n * @param {String} escapedSafe - escapedSafe HTML String which needs to be un-escaped.\n *\n * @return {String} Returns un-escaped and safe HTML String.\n */\nfunction _unEscapeHtml( escapedSafe ) { // eslint-disable-line no-unused-vars\n    return escapedSafe.replace( /&amp;/ig, '&' ).replace( /&lt;/ig, '<' ).replace( /&gt;/ig, '>' ).replace(\n        /&quot;/ig, '\"' ).replace( /&#39;/ig, '\\'' );\n}\n\n/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n *\n * @param {Boolean} replaceAnchors - TRUE if any HTTP type external references should be wrapped in an HTML <a\n *            href=\"XXXXX\"></a> (i.e. 'anchors').\n *\n * @param {Boolean} replaceNewLines - TRUE if any newline characters should be replaced by an HTML '<BR>'\n *\n * @return {String} Returns escaped and safe HTML.\n */\nexport let htmlEscapeAllowEntities = function( value, replaceAnchors, replaceNewLines ) {\n    if( _.isString( value ) && value.length > 0 ) {\n        if( !/(['\"<>&]+|(http)+|\\n)/i.test( value ) ) {\n            return value;\n        }\n\n        var escaped;\n\n        if( !/&+/.test( value ) ) {\n            escaped = _escapeHtml( value );\n        } else {\n            var splitArray = value.split( '&', -1 );\n\n            var nSegment = splitArray.length;\n\n            for( var ndx = 0; ndx < nSegment; ndx++ ) {\n                var currSegment = splitArray[ ndx ];\n\n                /**\n                 * The first segment is never part of a valid tag;\n                 * <P>\n                 * Note that if the input string starts with a tag, we will get an empty segment at the\n                 * beginning.\n                 */\n                if( ndx === 0 ) {\n                    escaped = _escapeHtml( currSegment );\n                    continue;\n                }\n\n                var entityEnd = currSegment.indexOf( ';' );\n\n                if( entityEnd > 0 && REGEX_HTML_ENTITY.test( currSegment.substring( 0, entityEnd ) ) ) {\n                    // Concatenate the entity without escaping.\n                    escaped = escaped.concat( '&' ).concat( currSegment.substring( 0, entityEnd + 1 ) );\n\n                    // Concatenate the rest of the segment, escaped.\n                    escaped = escaped.concat( _escapeHtml( currSegment.substring( entityEnd + 1 ) ) );\n                } else {\n                    // The segment did not start with an entity reference, so escape the whole segment.\n                    escaped = escaped.concat( '&amp;' ).concat( _escapeHtml( currSegment ) );\n                }\n            }\n        }\n\n        if( replaceAnchors && escaped ) {\n            // replaces url text to hyperlinks\n            escaped = escaped.replace( REGEX_URL_PATTERN, '<a href=\"$&\">$&</a>' );\n        }\n\n        if( replaceNewLines && escaped ) {\n            // replaces new lines to <br> tags\n            escaped = escaped.replace( /\\n/g, '<br/>' );\n        }\n\n        return escaped;\n    }\n\n    return '';\n};\n\n/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list\n * tags.\n *\n * @param {StringArray} values - Array of HTML Strings which needs to be sanitized.\n *\n * @return {StringArray} Returns sanitized HTML string array.\n */\nexport let sanitizeHtmlValues = function( values ) {\n    if( values && values.length > 0 ) {\n        for( var ii = values.length - 1; ii >= 0; ii-- ) {\n            var originalHtml = values[ ii ];\n            var sanitizedHtml = exports.sanitizeHtmlValue( originalHtml );\n            if( sanitizedHtml && originalHtml !== sanitizedHtml ) {\n                values[ ii ] = sanitizedHtml;\n            }\n        }\n    }\n\n    return values;\n};\n\n/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n *\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */\nexport let sanitizeHtmlValue = function( rawValue ) {\n    var sanitized = '';\n    var decodedValue = '';\n\n    if( _.isString( rawValue ) ) {\n        // load _invalidHtmlMessage if it is not loaded\n        if( !_invalidHtmlMessage ) {\n            exports.setInvalidHtmlMessage( localeSvc.getLoadedText().INVALID_HTML );\n        }\n\n        /**\n         * Decode html escaped entity characters before applying sanitization, so that it will also catch\n         * escaped XSS vulnerability attacks.\n         */\n        if( REGEX_HTML_ESCAPED_ENTITY.test( rawValue ) ) {\n            decodedValue = _.unescape( rawValue );\n        } else {\n            decodedValue = rawValue;\n        }\n\n        /**\n         * Break the string into n+1 segments based on any HTML tags\n         * <P>\n         * Loop for each of these segments.\n         */\n        var splitArray = decodedValue.split( '<', -1 );\n\n        var nSplit = splitArray.length;\n\n        for( var ndx = 0; ndx < nSplit; ndx++ ) {\n            var currSegment = splitArray[ ndx ];\n\n            /**\n             * The first segment is never part of a valid tag;\n             * <P>\n             * Note that if the input string starts with a tag, we will get an empty segment at the beginning.\n             */\n            if( ndx === 0 ) {\n                sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment ) );\n                continue;\n            }\n\n            /**\n             * Determine if the current segment is the start of an attribute-free tag or end-tag in our\n             * whitelist.\n             */\n            var tagStart = 0; // will be 1 if this turns out to be an end tag.\n            var tagEnd = currSegment.indexOf( '>' );\n            var tag = null;\n            var isValidTag = true;\n            var selfClosingTag = false;\n\n            if( tagEnd > 0 ) {\n                if( currSegment.charAt( 0 ) === '/' ) {\n                    tagStart = 1;\n                }\n\n                // for self closing tags ex: '<br />'\n                if( currSegment.charAt( tagEnd - 1 ) === '/' ) {\n                    selfClosingTag = true;\n                    tagEnd -= 1;\n                }\n\n                tag = currSegment.substring( tagStart, tagEnd );\n\n                var exist = tag.replace( /\\s(\\w|\\D).*/ig, '' ); // for attributes\n\n                if( TAG_BLACKLIST.indexOf( exist.toLowerCase().trim() ) !== -1 ) {\n                    isValidTag = false;\n                }\n\n                if( isValidTag ) {\n                    // concat the tag, not escaping it\n                    if( tagStart === 0 ) {\n                        /**\n                         * Check for image attribute script <BR>\n                         * <img src=\"\" onerror=\"alert('securityIssue_img');\"/>\n                         */\n                        if( REGEX_BASE64_IMG.test( tag ) ) {\n                            // split tag into attributes, and process individually\n                            // to avoid false positives.\n                            var attributes = tag.match( /[\\w-]+=\"[^\"]*\"/g );\n\n                            for( var i = 0; i < attributes.length; i++ ) {\n                                if( attributes[ i ].indexOf( 'src=' ) < 0 &&\n                                    REGEX_IMG_ATTR.test( attributes[ i ] ) ) {\n                                    return _invalidHtmlMessage;\n                                }\n                            }\n                        } else if( REGEX_IMG_ATTR.test( tag ) ) {\n                            return _invalidHtmlMessage;\n                        }\n                        sanitized = sanitized.concat( '<' );\n                    } else {\n                        // we had seen an end-tag\n                        sanitized = sanitized.concat( '</' );\n                    }\n\n                    if( selfClosingTag ) {\n                        sanitized = sanitized.concat( tag ).concat( '/>' );\n\n                        // concat the rest of the segment, escaping it\n                        sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment\n                            .substring( tagEnd + 2 ) ) );\n                    } else {\n                        sanitized = sanitized.concat( tag ).concat( '>' );\n\n                        // concat the rest of the segment, escaping it\n                        sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment\n                            .substring( tagEnd + 1 ) ) );\n                    }\n                } else {\n                    return _invalidHtmlMessage;\n                }\n            } else {\n                sanitized = sanitized.concat( '<' );\n                sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment ) );\n            }\n        }\n\n        /**\n         * Check for weird style stuff\n         */\n        if( REGEX_INVALID_HTML.test( sanitized ) ) {\n            return _invalidHtmlMessage;\n        }\n    }\n\n    return rawValue;\n};\n\n/**\n * Set the message that is seen when invalid HTML content is found.\n * <P>\n * Note: This message is normally set based on the value returned by the 'localeService'. This method is marked\n * 'private' and is intended to be used during testing to allow a preditable value to be returned.\n *\n * @private (this method should be used for unit test only)\n *\n * @param {String} message - Localized text to return from 'sanitizeHtmlValue' when some issue is found.\n */\nexport let setInvalidHtmlMessage = function( message ) {\n    _invalidHtmlMessage = message;\n};\n\n/**\n * Escape markup which Highcharts will unescape internally\n *\n * Full sanitize is not necessary (and causes issues) because Highcharts internally sets as\n * text on DOM element (does not create element from string)\n *\n * @param {String} x Value to escape\n * @returns {String} Escaped value\n */\nexport const escapeMarkup = x => x.replace( /</g, '&lt;' ).replace( />/g, '&gt;' );\n\n/**\n * This API sanitizes props to be sent to native html elements to avoid console warnings.\n * It however allows to bypass few custom-attributes if mentioned in argument.\n * Use this if any valid custom attributes to be excluded from being filtered out.\n *\n *\n * @param {Object} props - props coming from component.\n * @param {String} htmlElement - name of htmlElement for which a sanitization is requried\n * @returns {Object} sanitizedProps - Returns valid sanitized props good to use on native html element.\n */\nexport const sanitizeHTMLTagProps = ( props, htmlElement ) => {\n    //placeHolder to allow custom attributes on given html tag.\n    //maintain a list of custom attributes or exception props that are required to bypass sanitization check.\n    //Make sure this list shouldn't contribute to react console warnings.\n    let customAttributes;\n    let excludeAttributes = [];\n    switch ( htmlElement ) {\n        case 'input':\n            customAttributes = [ 'label', 'data-locator', 'onKeyDown', 'dirty', 'checked' ];\n            break;\n        case 'span':\n            customAttributes = [ 'data-locator', 'value' ];\n            excludeAttributes = [ 'aria-label', 'aria-required' ];\n            break;\n        case 'div':\n        case 'nav':\n        case 'main':\n        case 'textarea':\n        default:\n            customAttributes = [ 'data-locator' ];\n    }\n\n    let sanitizedProps = {};\n    let dummyHtmlElem = document.createElement( htmlElement );\n    let filteredAttribs = Object.keys( props ).filter( ( propName ) =>\n        !excludeAttributes.includes( propName ) && ( propName in dummyHtmlElem || propName.toLowerCase() in dummyHtmlElem ||\n            _.camelCase( propName ) in dummyHtmlElem || customAttributes.includes( propName ) )\n    );\n    filteredAttribs.forEach( ( key ) => sanitizedProps[ key ] = props[ key ] );\n    return sanitizedProps;\n};\nexports = {\n    htmlEscapeAllowEntities,\n    sanitizeHtmlValues,\n    sanitizeHtmlValue,\n    setInvalidHtmlMessage,\n    escapeMarkup,\n    sanitizeHTMLTagProps\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}