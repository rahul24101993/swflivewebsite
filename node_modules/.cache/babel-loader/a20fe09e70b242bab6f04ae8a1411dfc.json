{"ast":null,"code":"var _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$();\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n/* eslint-disable complexity */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declViewModelService\n *\n * @namespace viewModelService\n */\n\n\nimport React, { useState, useMemo, useEffect, createRef, useRef } from 'react';\nimport ReactDOM from 'react-dom';\nimport { reducer } from 'js/store';\nimport { useReducer, useInitHook, useAtomicDataReducer, convertToHtml } from './reactHelper';\nimport { useDerivedState } from 'js/reactAppCtx';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport awDuiLocalizationSvc from 'js/awDuiLocalizationService';\nimport { processViewModel, createDeclViewModel } from 'js/declViewModelProcessingFactory';\nimport { subscribe, unsubscribe, publish } from 'js/eventBus';\nimport viewModelService, { handleRegisteredEvent } from 'js/viewModelService';\nimport conditionService from 'js/conditionService';\nimport { NULLDATE } from 'js/dateTimeService';\nimport _ from 'lodash';\nimport { resolveSubPanelContext, updateI18nTexts } from 'js/viewModelProcessingFactory';\nimport { useDataProviders } from 'js/dataProviderUtils';\nimport { useGrid, useGrids, useGridContext } from 'js/gridProviderUtils';\nimport { usePopups } from 'js/reactPopup';\nimport { useLOVs } from 'js/lovProviderUtils';\nimport { updateValidationSchema, getStateCollection, filterFlatViewModelPropForAtomic, filterFlatViewModelProps } from 'js/propValidationUtils';\nimport { performLOVOperation } from 'js/uwLovDataService';\nimport syncStrategyService from 'js/syncStrategyService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { useSelectionModels } from 'js/declSelectionModelFactory';\nimport { useEditHandlers, removeEditHandler } from 'js/declEditHandlerFactory';\nimport { useMessages } from 'js/messagesProviderUtils';\nimport appCtxSvc from 'js/appCtxService';\nimport editHandlerService from 'js/editHandlerService';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport useVmoStore from './useVmoStore';\nimport debugService from 'js/debugService';\nimport logger from 'js/logger';\nimport { createFieldsBasedOnMetaData } from 'js/atomicDataService';\nimport { createAllFields, isFieldsEqual } from 'js/declFieldService';\nimport splmStatsService from 'js/splmStatsService';\nimport { useCommands } from 'js/commandBarUtils';\nimport AwInterpolateService from 'js/awInterpolateService';\n/**\n * execute lifecycle hook\n * @param {string} hookName hook name as 'onInit', 'onMount' and 'onUnmount'\n * @param {object} viewModel view model instance\n */\n\nconst executeHook = (hookName, viewModel, props, renderOptions) => {\n  if (viewModel.lifecycleHooks && viewModel.lifecycleHooks[hookName]) {\n    if (logger.isDeclarativeLogEnabled()) {\n      debugService.debugLifecyleHooks(hookName, viewModel);\n    }\n\n    if (hookName === 'onMount') {\n      debugService.debug('lifeCycles', viewModel._internal.panelId, 'mount');\n    }\n\n    viewModel.lifecycleHooks[hookName](renderOptions);\n  } // support backward compatibility of XXX.contentLoaded that is equivalent to onMount\n\n\n  if (hookName === 'onMount') {\n    const onEvents = viewModel.onEvent;\n\n    if (onEvents && onEvents.length > 0) {\n      let contentLoadedEvent = onEvents.find(event => {\n        const eventName = event.eventId;\n\n        if (eventName && eventName.includes('.contentLoaded')) {\n          // make sure contentLoaded event is subscribed for this viewmodel\n          // handle legacy use cases too compiler will convert viewModels to PascalCase but legacy viewNames could be in camel case\n          const viewName = viewModel.getViewId();\n          return eventName.split('.contentLoaded')[0].toLowerCase() === viewName.toLowerCase();\n        }\n\n        return false;\n      });\n\n      if (contentLoadedEvent) {\n        publish(contentLoadedEvent.eventId);\n      }\n    } // Backward compatability for command-sub-panel\n\n\n    if (props.isCommandSubPanel === 'true') {\n      publish('awPanel.reveal', {\n        panelId: props.viewId\n      });\n    }\n  }\n};\n/**\n * setup view model instance lifcycle in react\n * @param {object} viewModel view model Instance\n * @param {object} ctx App Ctx object\n * @param {object} prop view model property\n * @param {object} viewData view data\n * @param {boolean} limitEventScope Flag to control whether the even needs to be limited to specific view only\n * @param {object} subscriptions subscriptions\n * @returns {function} function to teardown view model intance\n */\n\n\nconst setupLifeCycle = (vmDef, viewModel, ctx, getProps, renderOptions, limitEventScope, runActionWithViewModel, subscriptions, getFields) => {\n  const props = getProps();\n  subscriptions.current = loadSubscriptions(viewModel.onEvent, viewModel, limitEventScope, getProps, runActionWithViewModel, getFields);\n  let dataCtxNode = {\n    data: viewModel,\n    ctx: ctx,\n    ports: viewModel.ports,\n    props: props,\n    getProps,\n    subPanelContext: props.subPanelContext,\n    getFields\n  }; //Execute onMount LifecycleHook\n\n  executeHook('onInit', viewModel);\n  executeHook('onMount', viewModel, props, renderOptions);\n\n  if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n    syncStrategyService.setupSyncStrategy(dataCtxNode);\n    syncStrategyService.updateVmOnMountUnmount(dataCtxNode, true);\n  } // TODO: can we split this out as teardownLifCycle later??\n\n\n  return () => {\n    const clearContext = () => {\n      cleanupEditHandlers(vmDef._internal.editHandlers, dataCtxNode);\n      unloadSubscriptions(subscriptions.current);\n\n      vmDef._internal.destroy(true);\n\n      dataCtxNode = null;\n      viewModel.actions = null;\n      viewModel.dispatch = null;\n      viewModel = null;\n    }; //onUnmount\n    //Make sure the onUnmount action is complete before destroying the declViewModel\n\n\n    if (viewModel.lifecycleHooks && viewModel.lifecycleHooks.onUnmount) {\n      debugService.debug('lifeCycles', viewModel._internal.panelId, 'unmount');\n      viewModel.lifecycleHooks.onUnmount(renderOptions).then(() => {\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugLifecyleHooks('onUnmount', viewModel);\n        }\n\n        if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n          syncStrategyService.updateVmOnMountUnmount(dataCtxNode, false);\n          syncViewModelCacheService.set('syncViewModelCache.' + viewModel._internal.viewId, null);\n        }\n\n        clearContext();\n      });\n    } else {\n      if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n        syncStrategyService.updateVmOnMountUnmount(dataCtxNode, false);\n        syncViewModelCacheService.set('syncViewModelCache.' + viewModel._internal.viewId, null);\n      }\n\n      clearContext();\n    }\n  };\n};\n/**\n * use i18n hook\n * @param {object} viewModel view model instance\n * @returns {object} i18n string map\n */\n\n\nconst useI18n = _ref => {\n  _s8();\n\n  _s();\n\n  let {\n    i18n,\n    data,\n    dispatch,\n    chartProviders,\n    columnProviders,\n    grids\n  } = _ref;\n  const [i18nData, setI18n] = useState({});\n  const [i18nLoaded, setI18nLoaded] = useState(false);\n  useInitHook(() => {\n    if (i18n && Object.keys(i18n).length > 0) {\n      awDuiLocalizationSvc.populateI18nMap(i18n, null).then(results => {\n        if (results && Object.keys(results).length > 0) {\n          updateI18nTexts(data, {\n            i18n: results\n          }, 0);\n          dispatch({\n            path: 'data',\n            value: { ...data\n            }\n          });\n\n          if (chartProviders) {\n            updateI18nTexts(chartProviders, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'chartProviders',\n              value: { ...chartProviders\n              }\n            });\n          }\n\n          if (columnProviders) {\n            updateI18nTexts(columnProviders, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'columnProviders',\n              value: { ...columnProviders\n              }\n            });\n          }\n\n          if (grids) {\n            updateI18nTexts(grids, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'grids',\n              value: { ...grids\n              }\n            });\n          }\n\n          setI18n(results);\n          setI18nLoaded(true);\n        } else {\n          setI18nLoaded(true);\n        }\n      });\n    }\n  }); // Stu: we should not return this i18nLoaded, the downstream setupLifCycle should not depend on i18n. If it is\n  //      we should remove the dependency\n  // Jesse: it will cause cucumber failure for sure, will do it in next MX\n\n  return [i18nData, i18n && Object.keys(i18n).length > 0 ? i18nLoaded : true];\n}; // eslint-disable-next-line require-jsdoc\n\n\n_s8(useI18n, \"z3w0qxZ5R9xbi/2H2+rVf1MgXqs=\", false, function () {\n  return [useInitHook];\n});\n\n_s(useI18n, \"IfPeJjNC0FyQE572oasoTGAoR8Q=\", false, function () {\n  return [useInitHook];\n});\n\nconst updateSubPanelContext = (jsonData, dataHook, subPanelContext) => {\n  if (subPanelContext) {\n    let resolvedData = {};\n    resolveSubPanelContext(jsonData, subPanelContext, resolvedData);\n    const [data, updateData] = dataHook;\n\n    _.forEach(resolvedData, function (propValue, propName) {\n      let dataClone = _.cloneDeep(data[propName]);\n\n      if (uwPropertySvc.isViewModelProperty(dataClone)) {\n        uwPropertySvc.setValue(dataClone, Object.values(propValue));\n        updateData({\n          path: propName,\n          value: dataClone\n        });\n      } else {\n        _.merge(dataClone, propValue);\n\n        updateData({\n          path: propName,\n          value: dataClone\n        });\n      }\n    });\n  }\n};\n/**\n * afx form hook\n * @param {object} vmDef view model definition\n * @param {array} dataHook dataHook in data-dispatch pair\n * @param {object} i18n i18n data used by reset\n * @returns {object} fields and form props\n */\n\n\nexport const useAfxForm = (vmDef, viewModel, ctx, dataHook, i18n, declViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema) => {\n  _s9();\n\n  _s2(); // create field part. If we dont have to toch this by action we are good\n\n\n  const {\n    dataProviders,\n    createData\n  } = vmDef;\n  const [touched, setTouched] = useState({});\n  const [errors, setErrors] = useState({});\n  const [isValid, setValid] = useState(true);\n  const [data, updateData] = dataHook;\n  const validRef = useRef(isValid);\n\n  const updateFormValidity = formValidity => {\n    if (validRef.current !== formValidity) {\n      validRef.current = formValidity;\n      setValid(formValidity);\n    }\n  };\n\n  const getFormValidity = React.useCallback(() => validRef.current, [validRef]);\n  const errorsRef = useRef(errors);\n\n  const updateErrors = errorObj => {\n    if (errorObj !== errorsRef.current) {\n      errorsRef.current = errorObj;\n      setErrors({ ...errorObj\n      });\n    }\n  };\n\n  const getErrorsState = React.useCallback(() => errorsRef.current, [errorsRef]);\n  const touchedRef = useRef(touched);\n\n  const updateTouched = function (path) {\n    if (touched && touched[path] !== true) {\n      let newTouched = { ...touchedRef.current,\n        [path]: true\n      };\n      touchedRef.current = newTouched;\n      setTouched(newTouched);\n    }\n  };\n\n  const getTouchedState = React.useCallback(() => touchedRef.current, [touchedRef]);\n  const {\n    atomicData = {},\n    atomicDataRef = {}\n  } = viewModel;\n  const props = getProps ? getProps() : {};\n\n  const getVmProp = (isCtxProp, name) => {\n    const ctxObj = isCtxProp ? ctx : data;\n    return _.get(ctxObj, name);\n  };\n\n  const getVmPropFromList = (propName, index, isCtxProp) => {\n    const ctxObj = isCtxProp ? ctx : data;\n    return _.get(ctxObj, propName)[index];\n  };\n\n  const validateAndUpdateDCPPath = path => {\n    //Identify DCP property and escape using the bracket notation.\n    //For non DCP properties too, if the keys are more than 3, we should update the path\n    const propsKey = 'props.';\n    let propName = path.substring(path.indexOf(propsKey) + 6, path.length);\n\n    if (uwPropertySvc.isDCPProperty(propName) || path.split('.').length > 3) {\n      return path.replace(`.${propName}`, `['${propName}']`);\n    }\n\n    return path;\n  };\n\n  const updateValue = (isCtxProp, name, updatedProp) => {\n    if (updatedProp.isDCP || name.split('.').length > 3) {\n      name = validateAndUpdateDCPPath(name);\n    }\n\n    isCtxProp ? appCtxSvc.updatePartialCtx(name, updatedProp) : updateData({\n      path: name,\n      value: updatedProp\n    });\n  };\n\n  const isFormValid = stateCollection => {\n    let schema = vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n\n    if (schema) {\n      return !hasInvalidProps(stateCollection, schema);\n    }\n\n    return true;\n  };\n\n  const hasInvalidProps = (vmPropCollection, schema) => {\n    let invalidProps = {};\n    let entries = schema && vmPropCollection && Object.entries(vmPropCollection);\n\n    if (!declUtils.isNil(entries) && entries.length > 0) {\n      for (let [key] of entries) {\n        try {\n          schema.validateSyncAt(key, vmPropCollection);\n        } catch (e) {\n          if (e && e.errors) {\n            invalidProps[key] = e.errors;\n            break;\n          }\n        }\n      }\n    }\n\n    return Object.keys(invalidProps).length !== 0;\n  };\n\n  const setFormValidity = stateCollection => {\n    let validity = isFormValid(stateCollection);\n    updateFormValidity(validity);\n  };\n\n  const validateField = (name, viewModelProperty) => {\n    let newErrors = getErrorsState();\n    let schema = null;\n\n    try {\n      schema = viewModelProperty && vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n\n      if (schema) {\n        schema.validateSyncAt(name, viewModelProperty); // No need to update the errors object, if the \"property name\" is not present earlier.\n\n        if (newErrors && newErrors[name]) {\n          delete newErrors[name];\n          updateErrors({ ...newErrors\n          });\n        }\n      }\n    } catch (e) {\n      if (e && e.errors) {\n        newErrors = { ...newErrors,\n          [name]: e.errors\n        };\n        updateErrors(newErrors);\n      }\n    } finally {\n      setFormValidity(getStateCollection(viewModel));\n    }\n  };\n\n  const setLovDataVal = (name, isCtxProp, index) => (_ref2, operation) => {\n    let {\n      lovEntry,\n      dataProvider,\n      checkLovEntries,\n      dateApi\n    } = _ref2;\n\n    if (name.includes('[')) {\n      name = name.replace(/ *\\[[^\\]]*]/, '');\n    }\n\n    let uiProperty;\n\n    if (isCtxProp) {\n      uiProperty = appCtxSvc.getCtx(name);\n    } else if (!_.isNil(index)) {\n      uiProperty = viewModel.getData()[name][index];\n    } else {\n      uiProperty = viewModel.getData()[name];\n    }\n\n    let vmpPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n    return performLOVOperation({\n      uiProperty,\n      vmo: null,\n      lovEntry,\n      dataProvider,\n      createUpdateValue,\n      checkLovEntries,\n      dateApi\n    }, operation).then(_ref3 => {\n      let {\n        newProp,\n        isPropertyUpdateReqd\n      } = _ref3;\n\n      if (newProp && isPropertyUpdateReqd) {\n        updateValue(isCtxProp, vmpPropName, newProp);\n        updateTouched(validateName);\n        validateField(validateName, {\n          [validateName]: newProp\n        });\n      }\n\n      return Promise.resolve(newProp);\n    });\n  };\n\n  const setLovDataValVMO = (vmoName, propName, isCtxProp) => (_ref4, operation) => {\n    let {\n      lovEntry,\n      dataProvider,\n      checkLovEntries,\n      dateApi\n    } = _ref4;\n    let uiProperty = isCtxProp ? appCtxSvc.getCtx(propName) : getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    return performLOVOperation({\n      uiProperty,\n      vmo: getVMO(vmoName),\n      lovEntry,\n      dataProvider,\n      createUpdateValue,\n      checkLovEntries,\n      dateApi\n    }, operation).then(_ref5 => {\n      let {\n        newProp,\n        isPropertyUpdateReqd\n      } = _ref5;\n\n      if (newProp && isPropertyUpdateReqd) {\n        updateValue(isCtxProp, pathName, newProp);\n        updateTouched(propName);\n        validateField(uiProperty.propertyName, getVMOProps(vmoName));\n        return Promise.resolve(newProp);\n      }\n    });\n  };\n\n  const handleChange = (name, isCtxProp, index) => event => {\n    const vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    let vmPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n\n    if (event.persist) {\n      event.persist();\n    }\n\n    let newVMProp = createUpdateValue(vmProp, event);\n    updateValue(isCtxProp, vmPropName, newVMProp);\n    updateTouched(validateName);\n    validateField(validateName, {\n      [validateName]: newVMProp\n    });\n  };\n\n  const setValueForVmo = (vmoName, propName, isCtxProp) => (newVal, additionalProp) => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    let updateVal = { ...vmProp\n    };\n    uwPropertySvc.updateViewModelProp(updateVal, newVal, additionalProp, true);\n    updateValue(isCtxProp, pathName, updateVal);\n    updateTouched(propName);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const setValue = (name, isCtxProp, index) => (newVal, additionalProp) => {\n    const prevVal = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    let vmPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n    let updateVal = { ...prevVal\n    };\n    uwPropertySvc.updateViewModelProp(updateVal, newVal, additionalProp, true);\n    updateValue(isCtxProp, vmPropName, updateVal); // check validity and update Touched\n\n    updateTouched(validateName);\n    validateField(validateName, {\n      [validateName]: updateVal\n    });\n  };\n\n  const handleChangeVMO = (vmoName, propName, isCtxProp) => event => {\n    if (event.persist) {\n      event.persist();\n    }\n\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    updateValue(isCtxProp, pathName, createUpdateValue(vmProp, event));\n    updateTouched(propName);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const moveUp = (prop, index) => {\n    for (var i = 0; i < prop.displayValsModel.length; i++) {\n      if (i === index) {\n        prop.displayValsModel[i].selected = false;\n        prop.lastSelected = prop.displayValsModel[index];\n      }\n    }\n\n    prop.lastSelected = null;\n    var currDbVal = prop.dbValue[index];\n    var currDisplayVal = prop.displayValues[index];\n    var currDisplayValModel = prop.displayValsModel[index];\n    prop.dbValue.splice(index, 1);\n    prop.dbValue.splice(index - 1, 0, currDbVal);\n    prop.displayValues.splice(index, 1);\n    prop.displayValues.splice(index - 1, 0, currDisplayVal);\n    prop.displayValsModel.splice(index, 1);\n    prop.displayValsModel.splice(index - 1, 0, currDisplayValModel);\n    prop.dirty = true;\n  };\n\n  const moveDown = (prop, index) => {\n    index -= 1;\n\n    for (var i = 0; i < prop.displayValsModel.length; i++) {\n      if (i === index) {\n        prop.displayValsModel[i].selected = false;\n        prop.lastSelected = prop.displayValsModel[index];\n      }\n    }\n\n    prop.lastSelected = null;\n    var currDbVal = prop.dbValue[index];\n    var currDisplayVal = prop.displayValues[index];\n    var currDisplayValModel = prop.displayValsModel[index];\n    prop.dbValue.splice(index, 1);\n    prop.dbValue.splice(index + 1, 0, currDbVal);\n    prop.displayValues.splice(index, 1);\n    prop.displayValues.splice(index + 1, 0, currDisplayVal);\n    prop.displayValsModel.splice(index, 1);\n    prop.displayValsModel.splice(index + 1, 0, currDisplayValModel);\n    prop.dirty = true;\n  };\n\n  const remove = (prop, index) => {\n    index -= 2;\n    prop.dbValue.splice(index, 1);\n\n    if (prop.hasLov) {\n      prop.displayValues.splice(index, 1);\n\n      if (prop.isArray) {\n        prop.displayValsModel = prop.displayValsModel || [];\n        prop.displayValsModel.splice(index, 1);\n      }\n    }\n\n    prop.dirty = true;\n  };\n\n  const handleClick = (name, isCtxProp, $index) => event => {\n    let vmProp = _.isNil($index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, $index, isCtxProp);\n    let vmPropName = _.isNil($index) ? name : name + '[' + $index + ']';\n    let validateName = _.isNil($index) ? name : name + '_' + $index;\n    let prop = { ...vmProp\n    };\n\n    if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n      let indexStr = event.currentTarget.attributes.id.value;\n      let index = parseInt(indexStr);\n      let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n      if (!isButtonClicked) {\n        let isAnyValueSelected = false;\n\n        if (prop.displayValsModel) {\n          for (var j = 0; j < prop.displayValsModel.length; j++) {\n            if (prop.displayValsModel[j].selected && prop.displayValsModel[j].isInEditMode) {\n              isAnyValueSelected = true;\n              break;\n            }\n          }\n        }\n\n        if (!isAnyValueSelected) {\n          if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n            prop.autofocus = true;\n            prop.currArrayDbValue = prop.dbValue.slice(0);\n            prop.displayValsModel[index].isInEditMode = true;\n            updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n            updateTouched(validateName);\n            validateField(validateName, {\n              [validateName]: prop\n            });\n          } else {\n            for (var i = 0; i < prop.displayValsModel.length; i++) {\n              if (i === index && !prop.lastSelected) {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              } else if (i === index && prop.lastSelected) {\n                if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                  prop.displayValsModel[i].selected = false;\n                  prop.lastSelected = undefined;\n                } else {\n                  prop.displayValsModel[i].selected = true;\n                  prop.lastSelected = prop.displayValsModel[index];\n                }\n              } else {\n                prop.displayValsModel[i].selected = false;\n              }\n            }\n\n            updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n            updateTouched(validateName);\n            event.stopPropagation();\n          }\n        }\n      } else {\n        let hasActionHappened = false;\n        let titleVal;\n\n        if (event.currentTarget.attributes.title) {\n          titleVal = event.currentTarget.attributes.title.value;\n        }\n\n        if (titleVal && titleVal === 'Move Up' && index > 0) {\n          moveUp(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n          moveDown(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Remove') {\n          remove(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (hasActionHappened) {\n          updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n          updateTouched(validateName);\n          validateField(validateName, {\n            [name]: prop\n          });\n        }\n      }\n    }\n  };\n\n  const handleClickVMO = (vmoName, propName, isCtxProp) => event => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let prop = { ...vmProp\n    };\n\n    if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n      let indexStr = event.currentTarget.attributes.id.value;\n      let index = parseInt(indexStr);\n      let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n      if (!isButtonClicked) {\n        if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n          prop.autofocus = true;\n          prop.currArrayDbValue = prop.dbValue.slice(0);\n          prop.displayValsModel[index].isInEditMode = true;\n          let pathName = vmoName + '.props.' + propName;\n          updateValue(isCtxProp, pathName, createUpdateValue(prop, event));\n          updateTouched(propName);\n          validateField(vmProp.propertyName, getVMOProps(vmoName));\n        } else {\n          for (var i = 0; i < prop.displayValsModel.length; i++) {\n            if (i === index && !prop.lastSelected) {\n              prop.displayValsModel[i].selected = true;\n              prop.lastSelected = prop.displayValsModel[index];\n            } else if (i === index && prop.lastSelected) {\n              if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                prop.displayValsModel[i].selected = false;\n                prop.lastSelected = undefined;\n              } else {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              }\n            } else {\n              prop.displayValsModel[i].selected = false;\n            }\n          }\n\n          event.stopPropagation();\n        }\n      } else {\n        let hasActionHappened = false;\n        let titleVal = event.currentTarget.attributes.title.value;\n\n        if (titleVal && titleVal === 'Move Up' && index > 0) {\n          moveUp(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n          moveDown(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Remove') {\n          remove(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (hasActionHappened) {\n          let pathName = vmoName + '.props.' + propName;\n          updateValue(isCtxProp, pathName, createUpdateValue(prop, event));\n          updateTouched(propName);\n          validateField(vmProp.propertyName, getVMOProps(vmoName));\n        }\n      }\n    }\n  };\n\n  const handleBlur = (name, isCtxProp, index) => event => {\n    let vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    name = _.isNil(index) ? name : vmProp.propertyName;\n\n    if (vmProp.isArray && event.isBlurFromInput) {\n      //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n      //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n      updateArray(vmProp, event);\n    }\n\n    uwPropertySvc.updateViewModelProperty(vmProp);\n    validateField(name, {\n      [name]: vmProp\n    });\n  };\n\n  const handleBlurVMO = (vmoName, propName) => event => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n\n    if (vmProp.isArray && event.isBlurFromInput) {\n      //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n      //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n      updateArray(vmProp, event);\n    }\n\n    uwPropertySvc.updateViewModelProperty(vmProp);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const isValidArrayValue = (viewModelProperty, valToUpdate) => {\n    var isValid = false;\n\n    if (valToUpdate !== undefined && valToUpdate !== '' && valToUpdate !== null && viewModelProperty.dbValue !== undefined) {\n      if (viewModelProperty.type === 'INTEGERARRAY' || viewModelProperty.type === 'DOUBLEARRAY' || viewModelProperty.type === 'DATEARRAY') {\n        if (isFinite(valToUpdate)) {\n          isValid = true;\n        }\n      } else if (viewModelProperty.type === 'BOOLEANARRAY') {\n        isValid = _.isBoolean(valToUpdate);\n      } else {\n        isValid = true;\n      }\n    }\n\n    return isValid;\n  };\n\n  const updateArray = (prop, event) => {\n    let indexStr;\n    let index;\n    let valToUpdate;\n\n    if (prop.type === 'DATEARRAY') {\n      index = event.index;\n      valToUpdate = new Date(event.target.value);\n    } else {\n      if (prop.type === 'BOOLEANARRAY' && prop.renderingHint === 'radiobutton') {\n        if (event.target.defaultValue === 'true') {\n          valToUpdate = true;\n        } else if (event.target.defaultValue === 'false') {\n          valToUpdate = false;\n        }\n\n        index = event.index;\n      } else if (prop.type === 'BOOLEANARRAY') {\n        valToUpdate = event.target.checked;\n        index = event.index;\n      } else {\n        indexStr = event.currentTarget.attributes.id.value;\n        index = parseInt(indexStr);\n        valToUpdate = event.currentTarget.value;\n      }\n    }\n\n    if (isValidArrayValue(prop, valToUpdate) && (!prop.error || prop.hasServerValidationError)) {\n      if (prop.currArrayDbValue) {\n        prop.currArrayDbValue.splice(index, 1, valToUpdate);\n        prop.dirty = true;\n        prop.dbValue = prop.currArrayDbValue.slice(0);\n      }\n    } else if (prop.dbValue === '' || prop.dbValue === null || prop.dbValue === undefined) {\n      prop.dbValue = prop.currArrayDbValue.slice(0);\n    }\n\n    if (prop.displayValsModel[index] && prop.dbValue.length > 0) {\n      prop.displayValsModel[index].displayValue = prop.dbValue[index];\n      prop.displayValsModel[index].isInEditMode = false;\n      prop.displayValsModel[index].selected = false;\n    }\n\n    prop.lastSelected = undefined;\n  };\n\n  const createNewArrayVal = (newVal, updateVal, event) => {\n    if (updateVal.type === 'DATEARRAY') {\n      if (_.isArray(updateVal.dbValue) && updateVal.dbValue.length > 0) {\n        _.forEach(updateVal.dbValue, function (value) {\n          if (value !== undefined && value !== '') {\n            newVal.push(value);\n          }\n        });\n\n        if (event.target.value) {\n          newVal.push(new Date(event.target.value));\n        }\n      } else if (event.target.value) {\n        newVal.push(new Date(event.target.value));\n      }\n    } else {\n      if (_.isArray(updateVal.dbValue) && updateVal.dbValue.length > 0) {\n        _.forEach(updateVal.dbValue, function (value) {\n          if (value !== undefined && value !== '') {\n            newVal.push(value);\n          }\n        });\n      }\n\n      if (event.target.value && updateVal.type !== 'BOOLEANARRAY') {\n        newVal.push(event.target.value);\n      }\n\n      if (event.target.value && updateVal.type === 'BOOLEANARRAY' && updateVal.renderingHint === 'radiobutton') {\n        newVal.push(event.target.value);\n      }\n\n      if (event.key === 'Enter' && updateVal.type === 'BOOLEANARRAY' && event.target.checked !== undefined && updateVal.renderingHint !== 'radiobutton') {\n        newVal.push(event.target.checked);\n      }\n    }\n  };\n\n  const createUpdateValue = (prevVal, event) => {\n    let updateVal = { ...prevVal\n    };\n\n    if (prevVal.type.toUpperCase() === 'DATEARRAY' && event.target.value === null) {\n      return updateVal;\n    }\n\n    let newVal;\n\n    switch (prevVal.type.toUpperCase()) {\n      case 'DATE':\n        newVal = event.target.value ? Number(new Date(event.target.value)) : NULLDATE;\n        break;\n\n      case 'BOOLEAN':\n        if (event.target.type === 'radio') {\n          newVal = event.target.value === 'true';\n        } else {\n          newVal = event.target.checked;\n        }\n\n        break;\n\n      case 'INTEGER':\n        newVal = event.target.value.replace(/[^\\+|\\-|0-9]/g, '');\n        break;\n\n      case 'DOUBLE':\n        newVal = event.target.value.replace(/[^\\+|\\-|0-9\\.|e]/g, '');\n        break;\n\n      case 'DATETIME':\n        newVal = new Date(event.target.value).toLocaleTimeString();\n        break;\n\n      case 'OBJECT':\n        newVal = Array.isArray(event.target.value) && event.target.value.length > 0 ? event.target.value[0] : '';\n        break;\n\n      case 'OBJECTARRAY':\n        if (!updateVal.hasLov) {\n          newVal = _.clone(prevVal.dbValue);\n\n          _.forEach(event.target.value, function (value) {\n            if (value !== undefined && value !== '') {\n              newVal.push(value);\n            }\n          });\n        } else {\n          newVal = [];\n\n          if (event.updateArray) {\n            updateArray(updateVal, event);\n\n            _.forEach(updateVal.dbValue, function (value) {\n              if (value !== undefined && value !== '') {\n                newVal.push(value);\n              }\n            });\n          } else {\n            createNewArrayVal(newVal, updateVal, event);\n          }\n        }\n\n        break;\n\n      case 'DOUBLEARRAY':\n      case 'DATEARRAY':\n      case 'INTEGERARRAY':\n      case 'STRINGARRAY':\n      case 'CHECKBOXARRAY':\n      case 'BOOLEANARRAY':\n        {\n          newVal = [];\n\n          if (event.updateArray) {\n            updateArray(updateVal, event);\n\n            _.forEach(updateVal.dbValue, function (value) {\n              if (value !== undefined && value !== '') {\n                newVal.push(value);\n              }\n            });\n          } else {\n            createNewArrayVal(newVal, updateVal, event);\n          }\n\n          break;\n        }\n\n      default:\n        newVal = event.target.value;\n    }\n\n    uwPropertySvc.setValue(updateVal, newVal);\n    return updateVal;\n  };\n\n  const getVMO = (vmoName, isCtxProp) => {\n    const lData = isCtxProp ? ctx : viewModel.getData();\n\n    const vmo = _.get(lData, vmoName);\n\n    if (vmo) {\n      return vmo;\n    }\n\n    return undefined;\n  };\n\n  const getAutofocusVMO = vmProp => {\n    if (vmProp) {\n      return vmProp.autofocus;\n    }\n\n    return undefined;\n  };\n\n  const getAutofocus = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.autofocus;\n  };\n\n  const getVMOProps = vmoName => {\n    let vmo = getVMO(vmoName);\n\n    if (vmo && vmo.props) {\n      return vmo.props;\n    }\n\n    return undefined;\n  };\n\n  const getVMPropForVMO = (vmoName, propName) => {\n    let vmo = getVMO(vmoName);\n\n    if (vmo && vmo.props && vmo.props[propName]) {\n      return vmo.props[propName];\n    }\n\n    return undefined;\n  };\n\n  const getValueVMO = vmProp => {\n    if (vmProp && vmProp.type === 'BOOLEAN') {\n      if (vmProp.dbValue === '') {\n        return undefined;\n      }\n\n      if (declUtils.isNil(vmProp.dbValue)) {\n        return null;\n      }\n\n      return String(vmProp.dbValue) === 'true' || String(vmProp.dbValue) === 'TRUE';\n    }\n\n    return vmProp && !_.isUndefined(vmProp && vmProp.dbValue) ? vmProp.dbValue : '';\n  };\n\n  const getValue = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.type === 'BOOLEAN') {\n      if (vmProp.dbValue === '') {\n        return undefined;\n      }\n\n      if (declUtils.isNil(vmProp.dbValue)) {\n        return null;\n      }\n\n      return String(vmProp.dbValue) === 'true' || String(vmProp.dbValue) === 'TRUE';\n    }\n\n    return vmProp && !_.isUndefined(vmProp && vmProp.dbValue) ? vmProp.dbValue : '';\n  };\n\n  const getTouched = name => {\n    let touchedState = getTouchedState();\n    return touchedState[name] ? 'true' : 'false';\n  };\n\n  const getErrorsVMPArray = function (name, index) {\n    let errors = getErrorsState();\n    let isTouched = getTouched(name + '_' + index);\n    return isTouched === 'true' ? errors[name + '_' + index] : undefined;\n  };\n\n  const getErrors = function (name, rootPath, path) {\n    let errors = getErrorsState();\n\n    if (!_.isNil(rootPath)) {\n      let atomicPath = rootPath + '.' + path;\n      atomicPath = atomicPath.replace(/\\./g, '_');\n      atomicPath = atomicPath.replace(/\\[/g, '_');\n      atomicPath = atomicPath.replace(/\\]/g, '');\n      let isTouched = getTouched(atomicPath);\n      return isTouched === 'true' ? errors[atomicPath] : undefined;\n    }\n\n    let isTouched = getTouched(name);\n    return isTouched === 'true' ? errors[name] : undefined;\n  };\n\n  const getAtomicVmProp = function (name, isCtxProp, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let vmProp;\n\n    if (isAtomic && viewProp) {\n      vmProp = viewProp;\n    } else {\n      vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    }\n\n    return vmProp;\n  };\n\n  const getPropertyDisplayName = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : ''; // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n\n    return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n  };\n\n  const getPropertyDisplayNameVMO = vmProp => {\n    const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : ''; // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n\n    return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n  };\n\n  const getPlaceHolder = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    let placeholder = '';\n\n    if (!vmProp) {\n      return placeholder;\n    }\n\n    let propertyType = getPropertyType(name, isCtxProp, index);\n\n    switch (propertyType && propertyType.toUpperCase()) {\n      case 'DATEARRAY':\n      case 'DATE':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n        break;\n\n      default:\n        if (vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else if (vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else {\n          placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n        }\n\n    }\n\n    return placeholder;\n  };\n\n  const getPlaceHolderVMO = vmProp => {\n    let placeholder = '';\n\n    if (!vmProp) {\n      return placeholder;\n    }\n\n    let propertyType = vmProp.type;\n\n    switch (propertyType && propertyType.toUpperCase()) {\n      case 'DATEARRAY':\n      case 'DATETIME':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY HH:mm' : '';\n        break;\n\n      case 'DATE':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n        break;\n\n      case 'TIME':\n        placeholder = vmProp.isEditable ? 'HH:mm:ss' : '';\n        break;\n\n      default:\n        if (vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else if (vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else {\n          placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n        }\n\n    }\n\n    return placeholder;\n  };\n\n  const getUIValue = function (name, isCtxProp, index, isAtomic, viewProp) {\n    let key = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'uiValue';\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp[key];\n  };\n\n  const getUIValueVMO = function (vmProp) {\n    let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'uiValue';\n\n    if (vmProp) {\n      return vmProp[key];\n    }\n\n    return undefined;\n  };\n\n  const getRenderingHint = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.renderingHint;\n  };\n\n  const getRenderingHintVMO = vmProp => {\n    if (vmProp) {\n      return vmProp.renderingHint;\n    }\n\n    return undefined;\n  };\n\n  const getPropertyType = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled) {\n      return 'DATETIME';\n    }\n\n    return vmProp && vmProp.type;\n  };\n\n  const getPropertyTypeVMO = vmProp => {\n    if (vmProp && vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled) {\n      return 'DATETIME';\n    }\n\n    return vmProp && vmProp.type;\n  };\n\n  const getRequired = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.isRequired;\n  };\n\n  const getRequiredVMO = vmProp => {\n    return vmProp && vmProp.isRequired;\n  };\n\n  const getMaxLength = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.maxLength;\n  };\n\n  const getMaxLengthVMO = vmProp => {\n    return vmProp && vmProp.maxLength;\n  };\n\n  const getPropertyRadioTrueText = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioTrueTextVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioFalseText = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioFalseTextVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n    }\n\n    return undefined;\n  };\n\n  const getDisplayValsModel = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' || vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' || vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY')) {\n      return vmProp.displayValsModel;\n    }\n\n    return undefined;\n  };\n\n  const getDisplayValsModelVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' || vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' || vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY')) {\n      return vmProp.displayValsModel;\n    }\n\n    return undefined;\n  };\n\n  const getDateApi = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME')) {\n      if (vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue) {\n        uwPropertySvc.initializeDateApiValues(vmProp);\n      }\n\n      return vmProp.dateApi;\n    }\n\n    return undefined;\n  };\n\n  const getDateApiVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME')) {\n      if (vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue) {\n        uwPropertySvc.initializeDateApiValues(vmProp);\n      }\n\n      return vmProp.dateApi;\n    }\n\n    return undefined;\n  };\n\n  const getIsLov = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.hasLov;\n  };\n\n  const getIsLovVMO = vmProp => {\n    return vmProp && vmProp.hasLov;\n  };\n\n  const getLovApiVMO = vmProp => {\n    return vmProp && vmProp.lovApi;\n  };\n\n  const getDataProvider = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (!vmProp) {\n      return undefined;\n    } // case dynamic dataProvider\n\n\n    if (_.isFunction(vmProp.dataProvider)) {\n      return vmProp.dataProvider();\n    }\n\n    return vmProp.dataProvider && dataProviders && dataProviders[vmProp.dataProvider] ? dataProviders[vmProp.dataProvider] : null;\n  };\n\n  const getDataProviderVMO = vmProp => {\n    return vmProp && vmProp.dataProvider;\n  };\n\n  const getIsArray = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.isArray;\n  };\n\n  const getIsArrayVMO = vmProp => {\n    return vmProp && vmProp.isArray;\n  };\n\n  const getLovApi = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.lovApi) {\n      return vmProp.lovApi;\n    }\n\n    return null;\n  };\n\n  const getEditArrayInlineMode = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.editArrayInlineMode;\n  };\n\n  const getEditArrayInlineModeVMO = vmProp => {\n    return vmProp && vmProp.editArrayInlineMode;\n  };\n\n  const getNumberOfLines = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.numberOfLines;\n  };\n\n  const getNumberOfLinesVMO = vmProp => {\n    return vmProp && vmProp.numberOfLines;\n  }; // compute the label position\n  // the precedence is like this:\n  // 1. class in view (sw-row / sw-column / sw-reverse)\n  // 2. v-m prop.labelPosition\n  // 3. boolean and object use label at end\n  // 4. editable props use label at top\n\n\n  const getLabelPlacement = vmProp => {\n    var labelPlacement = '';\n\n    if (!vmProp) {\n      return labelPlacement;\n    } // get rid of editLayoutSide and consolidate positioning here?\n    // revisitMe ulrey. discuss with Nihar?\n\n\n    switch (vmProp.propertyLabelDisplay) {\n      case 'PROPERTY_LABEL_AT_RIGHT':\n        labelPlacement = 'end';\n        break;\n\n      case 'PROPERTY_LABEL_AT_TOP':\n        labelPlacement = 'top';\n        break;\n\n      case 'PROPERTY_LABEL_AT_SIDE':\n        labelPlacement = 'start';\n        break;\n\n      case 'NO_PROPERTY_LABEL':\n        // revistMe scott: is <aw-widget labeldisplay=\"Headless\"> also supported?\n        labelPlacement = 'none';\n        break;\n\n      default:\n        labelPlacement = 'default';\n    }\n\n    return labelPlacement;\n  };\n\n  const getLabelPlacementFromData = function (propName, vmoName, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 ? arguments[4] : undefined;\n    const vmProp = isAtomic && viewProp ? viewProp : vmoName ? getVMPropForVMO(vmoName, propName) : !declUtils.isNil(index) ? data[propName][index] : data[propName];\n    return getLabelPlacement(vmProp);\n  };\n  /**\n   * Check if prop is dirty\n   * if uncommitted value changes, but is reverted: dirty=false\n   * @param {object} vmProp view model property\n   * @returns {boolean} true if prop is dirty\n   */\n\n\n  const dirtyCheck = vmProp => {\n    // deal with case where null !== emptystring if( vmProp.valueUpdated || vmProp.displayValueUpdated ) {\n    if (_.isNil(vmProp.value) && _.isNil(vmProp.newValue)) {\n      return false;\n    }\n\n    return (vmProp.valueUpdated || vmProp.displayValueUpdated) && !_.isEqual(vmProp.value, vmProp.newValue);\n  };\n  /**\n   * Check if prop is dirty\n   * @param {string} name property namne\n   * @param {boolean} isCtxProp is prop from ctx (optional)\n   * @returns {boolean} true if prop is dirty / undefined if clean\n   */\n\n\n  const isPropDirty = function (name, isCtxProp, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 ? arguments[4] : undefined;\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && dirtyCheck(vmProp)) {\n      return 'true';\n    }\n\n    return undefined;\n  };\n  /**\n   * Check if vmo prop is dirty\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} true if prop is dirty / undefined if clean\n   */\n\n\n  const isPropDirtyVMO = vmProp => {\n    if (vmProp && dirtyCheck(vmProp)) {\n      return 'true';\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets pattern for VMO\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {object} patterns object\n   */\n\n\n  const getPatterns = vmProp => {\n    if (vmProp && vmProp.patterns) {\n      return vmProp.patterns;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets preferred pattern\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {string} preferred patterns value\n   */\n\n\n  const getPreferredPattern = vmProp => {\n    if (vmProp) {\n      return vmProp.preferredPattern;\n    }\n\n    return undefined;\n  };\n\n  const getPreferredPatternVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.preferredPattern;\n    }\n\n    return undefined;\n  };\n\n  const getAutoAssignVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n\n  const getAutoAssignableVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.isAutoAssignable;\n    }\n\n    return undefined;\n  };\n\n  const getPatternAutoAssignFlagsVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.patternAutoAssignFlags;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets isAutoAssign boolean value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} isAutoAssign bool value\n   */\n\n\n  const getIsAutoAssign = vmProp => {\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n\n  const getIsAutoAssignVMPArray = (propName, isCtxProp, index) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index);\n\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets isAutoAssignable boolean value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} isAutoAssignable bool value\n   */\n\n\n  const getIsAutoAssignable = vmProp => {\n    if (vmProp) {\n      return vmProp.isAutoAssignable;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets patternAutoAssignFlags value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {object} PatternAutoAssignFlags object\n   */\n\n\n  const getPatternAutoAssignFlags = vmProp => {\n    if (vmProp) {\n      return vmProp.patternAutoAssignFlags;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets parent uid\n   * @param {string} vmoName view-model object name\n   * @param {string} vmProp property name\n   * @param {boolean} isCtxProp property name\n   * @returns {string} parent uid\n   */\n\n\n  const getParentUid = (vmoName, vmProp, isCtxProp) => {\n    if (vmProp && (vmProp.patterns || vmProp.patternAutoAssignFlags)) {\n      const vmo = getVMO(vmoName, isCtxProp);\n      return vmo && vmo.uid ? vmo.uid : undefined;\n    }\n\n    return undefined;\n  };\n\n  const handleReset = () => {\n    // revisitme - spond\n    // HINT: In reset case, we need to consider all extra data we put in data store rather than\n    // reset the whole data store to data def\n    updateData({\n      value: { ...data,\n        ...createData({\n          i18n\n        })\n      }\n    });\n    setTouched({});\n    updateErrors({});\n    setFormValidity(getStateCollection(viewModel));\n  };\n\n  const getAction = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.action && viewModel.actions && viewModel.actions[vmProp.action] ? viewModel.actions[vmProp.action] : null;\n  };\n\n  const getActionVMO = vmProp => {\n    return vmProp && vmProp.action && viewModel.actions && viewModel.actions[vmProp.action] ? viewModel.actions[vmProp.action] : null;\n  };\n\n  const constructFieldForNamedPropertyVMO = function (vmoName, propName) {\n    let isCtxProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    return {\n      name: propName,\n      onChange: handleChangeVMO(vmoName, propName, isCtxProp),\n      onBlur: handleBlurVMO(vmoName, propName),\n      onClick: handleClickVMO(vmoName, propName, isCtxProp),\n      value: getValueVMO(vmProp),\n      checked: getValueVMO(vmProp),\n      touched: getTouched(propName),\n      label: getPropertyDisplayNameVMO(vmProp),\n      typex: getPropertyTypeVMO(vmProp),\n      error: getErrors(propName),\n      required: getRequiredVMO(vmProp),\n      maxLength: getMaxLengthVMO(vmProp),\n      placeholder: getPlaceHolderVMO(vmProp),\n      disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n      dirty: isPropDirtyVMO(vmProp),\n      'data-locator': getPropertyDisplayNameVMO(vmProp),\n      'aria-label': getPropertyDisplayNameVMO(vmProp),\n      'aria-required': getRequiredVMO(vmProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      setLovVal: setLovDataValVMO(vmoName, propName, isCtxProp),\n      vmo: getVMO(vmoName, isCtxProp),\n      update: setValueForVmo(vmoName, propName, isCtxProp),\n      autoFocus: getAutofocusVMO(vmProp),\n      __vmprop__: () => vmProp,\n      fielddata: {\n        uiValue: getUIValueVMO(vmProp),\n        uiValues: getUIValueVMO(vmProp, 'uiValues'),\n        oldValue: getUIValueVMO(vmProp, 'oldValue'),\n        oldValues: getUIValueVMO(vmProp, 'oldValues'),\n        displayValues: getUIValueVMO(vmProp, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        isEnabled: vmProp && vmProp.isEnabled,\n        isSelectOnly: vmProp && vmProp.isSelectOnly,\n        isEditable: vmProp && vmProp.isEditable,\n        isLocalizable: vmProp && vmProp.isLocalizable,\n        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayNameVMO(vmProp),\n        labelPlacement: getLabelPlacement(vmProp),\n        renderingHint: getRenderingHintVMO(vmProp),\n        propertyRadioTrueText: getPropertyRadioTrueTextVMO(vmProp),\n        propertyRadioFalseText: getPropertyRadioFalseTextVMO(vmProp),\n        radioVertical: vmProp && vmProp.vertical,\n        displayValsModel: getDisplayValsModelVMO(vmProp),\n        numberOfLines: getNumberOfLinesVMO(vmProp),\n        dateApi: getDateApiVMO(vmProp),\n        isArray: getIsArrayVMO(vmProp),\n        hasLov: getIsLovVMO(vmProp),\n        dataProvider: getDataProviderVMO(vmProp),\n        editArrayInlineMode: getEditArrayInlineModeVMO(vmProp),\n        isRichText: vmProp && vmProp.isRichText,\n        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry,\n        patterns: getPatterns(vmProp),\n        preferredPattern: getPreferredPattern(vmProp),\n        lovApi: getLovApiVMO(vmProp),\n        action: getActionVMO(vmProp),\n        destPanelId: vmProp && vmProp.destPanelId,\n        iconName: vmProp && vmProp.iconName,\n        iconSource: vmProp && vmProp.iconSource,\n        tooltip: vmProp && vmProp.tooltip,\n        isAutoAssign: getIsAutoAssign(vmProp),\n        isAutoAssignable: getIsAutoAssignable(vmProp),\n        parentUid: getParentUid(vmoName, vmProp, isCtxProp),\n        propertyName: propName,\n        patternAutoAssignFlags: getPatternAutoAssignFlags(vmProp),\n        hasRevRuleAttached: vmProp && vmProp.hasRevRuleAttached\n      }\n    };\n  };\n\n  const constructFieldForNamedProperty = function (propName) {\n    let isCtxProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const vmProp = getVmProp(isCtxProp, propName);\n    return {\n      name: propName,\n      onChange: handleChange(propName, isCtxProp),\n      onBlur: handleBlur(propName, isCtxProp),\n      onClick: handleClick(propName, isCtxProp),\n      value: getValue(propName, isCtxProp),\n      checked: getValue(propName, isCtxProp),\n      touched: getTouched(propName),\n      label: getPropertyDisplayName(propName, isCtxProp),\n      typex: getPropertyType(propName, isCtxProp),\n      error: getErrors(propName),\n      required: getRequired(propName, isCtxProp),\n      maxLength: getMaxLength(propName, isCtxProp),\n      placeholder: getPlaceHolder(propName, isCtxProp),\n      disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n      dirty: isPropDirty(propName, isCtxProp),\n      'data-locator': getPropertyDisplayName(propName, isCtxProp),\n      'aria-label': getPropertyDisplayName(propName, isCtxProp),\n      'aria-required': getRequired(propName, isCtxProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      setLovVal: setLovDataVal(propName, isCtxProp),\n      update: setValue(propName, isCtxProp),\n      autoFocus: getAutofocus(propName, isCtxProp),\n      __vmprop__: () => vmProp,\n      fielddata: {\n        uiValue: getUIValue(propName, isCtxProp),\n        uiValues: getUIValue(propName, isCtxProp, null, false, null, 'uiValues'),\n        displayValues: getUIValue(propName, isCtxProp, null, false, null, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        isEnabled: vmProp && vmProp.isEnabled,\n        isSelectOnly: vmProp && vmProp.isSelectOnly,\n        isEditable: vmProp && vmProp.isEditable,\n        isLocalizable: vmProp && vmProp.isLocalizable,\n        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayName(propName, isCtxProp),\n        labelPlacement: getLabelPlacementFromData(propName, isCtxProp),\n        renderingHint: getRenderingHint(propName, isCtxProp),\n        propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp),\n        propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp),\n        radioVertical: vmProp && vmProp.vertical,\n        displayValsModel: getDisplayValsModel(propName, isCtxProp),\n        numberOfLines: getNumberOfLines(propName, isCtxProp),\n        dateApi: getDateApi(propName, isCtxProp),\n        isArray: getIsArray(propName, isCtxProp),\n        hasLov: getIsLov(propName, isCtxProp),\n        dataProvider: getDataProvider(propName, isCtxProp),\n        lovApi: getLovApi(propName, isCtxProp),\n        editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp),\n        action: getAction(propName, isCtxProp),\n        iconName: vmProp && vmProp.iconName,\n        iconSource: vmProp && vmProp.iconSource,\n        tooltip: vmProp && vmProp.tooltip,\n        parentUid: undefined,\n        propertyName: propName,\n        patterns: vmProp && vmProp.patterns,\n        preferredPattern: vmProp && vmProp.preferredPattern,\n        isAutoAssign: vmProp && vmProp.isAutoAssign,\n        destPanelId: vmProp && vmProp.destPanelId,\n        isRichText: vmProp && vmProp.isRichText,\n        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n      }\n    };\n  };\n\n  const constructFieldArrayOfNamedProperty = function (vmPropList, propName) {\n    let isCtxProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let vmpFieldArray = [];\n\n    _.forEach(vmPropList, function (value, index) {\n      if (value !== undefined && value !== '') {\n        const vmProp = getVmPropFromList(propName, index, isCtxProp);\n        let obj = {\n          name: vmProp.propertyName,\n          onChange: handleChange(propName, isCtxProp, index),\n          onBlur: handleBlur(propName, isCtxProp, index),\n          onClick: handleClick(propName, isCtxProp, index),\n          value: getValue(propName, isCtxProp, index),\n          checked: getValue(propName, isCtxProp, index),\n          touched: getTouched(vmProp.propertyName),\n          label: getPropertyDisplayName(propName, isCtxProp, index),\n          typex: getPropertyType(propName, isCtxProp, index),\n          error: getErrorsVMPArray(propName, index),\n          required: getRequired(propName, isCtxProp, index),\n          maxLength: getMaxLength(propName, isCtxProp, index),\n          placeholder: getPlaceHolder(propName, isCtxProp, index),\n          disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n          dirty: isPropDirty(propName, isCtxProp, index),\n          'data-locator': getPropertyDisplayName(propName, isCtxProp, index),\n          'aria-label': getPropertyDisplayName(propName, isCtxProp, index),\n          'aria-required': getRequired(propName, isCtxProp, index),\n          //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n          setLovVal: setLovDataVal(propName, isCtxProp, index),\n          update: setValue(propName, isCtxProp, index),\n          autoFocus: getAutofocus(propName, isCtxProp, index),\n          __vmprop__: () => vmProp,\n          fielddata: {\n            uiValue: getUIValue(propName, isCtxProp, index),\n            uiValues: getUIValue(propName, isCtxProp, index, false, null, 'uiValues'),\n            displayValues: getUIValue(propName, isCtxProp, index, false, null, 'displayValues'),\n            convertToHtml: value => convertToHtml(value, isCtxProp),\n            isEnabled: vmProp && vmProp.isEnabled,\n            isSelectOnly: vmProp && vmProp.isSelectOnly,\n            isEditable: vmProp && vmProp.isEditable,\n            isLocalizable: vmProp && vmProp.isLocalizable,\n            uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n            propertyDisplayName: getPropertyDisplayName(propName, isCtxProp, index),\n            labelPlacement: getLabelPlacementFromData(propName, isCtxProp, index),\n            renderingHint: getRenderingHint(propName, isCtxProp, index),\n            propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp, index),\n            propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp, index),\n            radioVertical: vmProp && vmProp.vertical,\n            displayValsModel: getDisplayValsModel(propName, isCtxProp, index),\n            numberOfLines: getNumberOfLines(propName, isCtxProp, index),\n            dateApi: getDateApi(propName, isCtxProp, index),\n            isArray: getIsArray(propName, isCtxProp, index),\n            hasLov: getIsLov(propName, isCtxProp, index),\n            dataProvider: getDataProvider(propName, isCtxProp, index),\n            lovApi: getLovApi(propName, isCtxProp, index),\n            editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp, index),\n            action: getAction(propName, isCtxProp, index),\n            iconName: vmProp && vmProp.iconName,\n            iconSource: vmProp && vmProp.iconSource,\n            tooltip: vmProp && vmProp.tooltip,\n            destPanelId: vmProp && vmProp.destPanelId,\n            isRichText: vmProp && vmProp.isRichText,\n            patterns: vmProp && vmProp.patterns,\n            preferredPattern: vmProp && vmProp.preferredPattern,\n            isAutoAssign: getIsAutoAssignVMPArray(propName, isCtxProp, index),\n            parentUid: undefined,\n            propertyName: propName,\n            emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n          }\n        };\n        vmpFieldArray.push(obj);\n      }\n    });\n\n    return vmpFieldArray;\n  };\n  /**\n   *\n   * @param { string } path pathofAtomicData\n   * @param { string } rootPath RootPath\n   * @returns {object} partialObj\n   */\n\n\n  const createPartialField = (path, rootPath) => {\n    return {\n      get value() {\n        return this.getValue();\n      },\n\n      getValue: () => {\n        let rootObject = atomicDataRef[rootPath].getAtomicData();\n        return path === '' ? rootObject : _.get(rootObject, path);\n      },\n      update: value => {\n        let rootObject = atomicDataRef[rootPath].getAtomicData();\n\n        if (path === '') {\n          rootObject = value;\n        } else {\n          _.set(rootObject, path, { ...value\n          });\n        }\n\n        atomicDataRef[rootPath].setAtomicData(_.clone(rootObject));\n        let atomicDataVmpCollection = filterFlatViewModelPropForAtomic(viewModel);\n\n        if (Object.keys(atomicDataVmpCollection).length > 0) {\n          let dataVmpCollection = filterFlatViewModelProps(viewModel.getData());\n          let stateCollection = { ...dataVmpCollection,\n            ...atomicDataVmpCollection\n          };\n          updateValidationSchema(viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection);\n          setFormValidity(stateCollection);\n        }\n      }\n    };\n  };\n  /**\n   *\n   * @param {*} path String\n   * @param {*} rootPath  String\n   * @param {*} fieldType  String\n   * @returns\n   */\n\n\n  const createFieldForAtomicData = (path, rootPath, fieldType) => {\n    if (fieldType === 'partialField') {\n      return createPartialField(path, rootPath);\n    }\n\n    return constructFieldForAtomicProperty(path, rootPath, fieldType);\n  };\n  /**\n   * @param {*} path The path of partial state object with respect to state object\n   * @param {*} rootPath  The root name of the state object\n   * @param {*} fieldType The type of the field defined in meta\n   * @returns { object }-\n   */\n\n\n  const constructFieldForAtomicProperty = (path, rootPath, fieldType) => {\n    let rootObject = viewModel.atomicData[rootPath];\n\n    let stateObj = _.get(rootObject, path);\n\n    const propName = path.split('.')[path.split('.').length - 1];\n    let viewProp = null;\n    const vmo = { ...stateObj,\n      props: {}\n    };\n    let prevFieldsRef = fieldsRef.current;\n\n    let prevFieldObject = _.get(prevFieldsRef, rootPath + '.' + path, null);\n\n    if (fieldType === 'viewModelObject' && stateObj && stateObj.props) {\n      Object.keys(stateObj.props).forEach(propertyName => {\n        viewProp = stateObj.props[propertyName];\n        let prevField = prevFieldObject && prevFieldObject.props && prevFieldObject.props[propertyName];\n        let path1 = `${path}.props.${propertyName}`;\n        let newField = creatAtomicFields(propertyName, rootPath, viewProp, path1, fieldType, stateObj);\n\n        if (isFieldsEqual(prevField, newField)) {\n          vmo.props[propertyName] = prevField;\n        } else {\n          vmo.props[propertyName] = newField;\n        }\n      });\n      return vmo;\n    } else if (fieldType === 'ViewModelProperty') {\n      viewProp = stateObj;\n    } else {\n      viewProp = modelPropertySvc.createViewModelProperty({ ...stateObj,\n        propName,\n        type: fieldType\n      });\n    }\n\n    let newFieldObject = creatAtomicFields(propName, rootPath, viewProp, path, fieldType);\n\n    if (isFieldsEqual(prevFieldObject, newFieldObject)) {\n      return prevFieldObject;\n    }\n\n    return newFieldObject;\n  };\n\n  const creatAtomicFields = function (propName, rootPath, viewProp, path, fieldType) {\n    let vmo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let isCtxProp = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let index = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let isAtomic = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n\n    const updateAtomicData = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      if (event.persist) {\n        event.persist();\n      }\n\n      if (event.additionalProp) {\n        uwPropertySvc.updateViewModelProp(viewProp, null, event.additionalProp, false);\n      }\n\n      viewProp = createUpdateValue(viewProp, event); // This is required to do later instance check.\n      // Mutating the object directly is not a good idea.\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        _.set(rtObj, `${atomicPath}`, { ...viewProp\n        });\n      } else {\n        let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n        let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n        if (val1 === viewProp.dbValue && val2 === viewProp.dbValue) {\n          return;\n        }\n\n        _.set(rtObj, `${atomicPath}.value`, viewProp.dbValue);\n\n        _.set(rtObj, `${atomicPath}.dbValue`, viewProp.dbValue);\n      }\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        let atPath = rootPath + '.' + atomicPath;\n        atPath = atPath.replace(/\\./g, '_');\n        atPath = atPath.replace(/\\[/g, '_');\n        atPath = atPath.replace(/\\]/g, '');\n        validateField(atPath, {\n          [atPath]: viewProp\n        });\n        updateTouched(atPath);\n      }\n\n      atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n    };\n\n    const getValue = () => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      return _.get(rtObj, `${atomicPath}.dbValue`);\n    };\n\n    const handleBlurAtomic = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let vmProp = _.get(rtObj, `${atomicPath}`);\n\n      if (vmProp.isArray && event.isBlurFromInput) {\n        //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n        //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n        updateArray(vmProp, event);\n      }\n\n      uwPropertySvc.updateViewModelProperty(vmProp);\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        let atPath = rootPath + '.' + atomicPath;\n        atPath = atPath.replace(/\\./g, '_');\n        atPath = atPath.replace(/\\[/g, '_');\n        atPath = atPath.replace(/\\]/g, '');\n        validateField(atPath, {\n          [atPath]: vmProp\n        });\n      }\n    };\n\n    const handleClickAtomic = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let vmProp = _.get(rtObj, `${atomicPath}`);\n\n      let prop = { ...vmProp\n      };\n\n      if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n        let indexStr = event.currentTarget.attributes.id.value;\n        let index = parseInt(indexStr);\n        let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n        if (!isButtonClicked) {\n          if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n            prop.autofocus = true;\n            prop.currArrayDbValue = prop.dbValue.slice(0);\n            prop.displayValsModel[index].isInEditMode = true;\n            let newProp = createUpdateValue(prop, event);\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              _.set(rtObj, `${atomicPath}`, { ...newProp\n              });\n            } else {\n              let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n              let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n              if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n                return;\n              }\n\n              _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n              _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n            }\n\n            atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              let atPath = rootPath + '.' + atomicPath;\n              atPath = atPath.replace(/\\./g, '_');\n              atPath = atPath.replace(/\\[/g, '_');\n              atPath = atPath.replace(/\\]/g, '');\n              validateField(atPath, {\n                [atPath]: newProp\n              });\n              updateTouched(atPath);\n            }\n          } else {\n            for (var i = 0; i < prop.displayValsModel.length; i++) {\n              if (i === index && !prop.lastSelected) {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              } else if (i === index && prop.lastSelected) {\n                if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                  prop.displayValsModel[i].selected = false;\n                  prop.lastSelected = undefined;\n                } else {\n                  prop.displayValsModel[i].selected = true;\n                  prop.lastSelected = prop.displayValsModel[index];\n                }\n              } else {\n                prop.displayValsModel[i].selected = false;\n              }\n            }\n\n            event.stopPropagation();\n          }\n        } else {\n          let hasActionHappened = false;\n          let titleVal = event.currentTarget.attributes.title.value;\n\n          if (titleVal && titleVal === 'Move Up' && index > 0) {\n            moveUp(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n            moveDown(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (titleVal && titleVal === 'Remove') {\n            remove(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (hasActionHappened) {\n            let newProp = createUpdateValue(prop, event);\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              _.set(rtObj, `${atomicPath}`, { ...newProp\n              });\n            } else {\n              let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n              let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n              if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n                return;\n              }\n\n              _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n              _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n            }\n\n            atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              let atPath = rootPath + '.' + atomicPath;\n              atPath = atPath.replace(/\\./g, '_');\n              atPath = atPath.replace(/\\[/g, '_');\n              atPath = atPath.replace(/\\]/g, '');\n              validateField(atPath, {\n                [atPath]: newProp\n              });\n              updateTouched(atPath);\n            }\n          }\n        }\n      }\n    };\n\n    const setLovDataValAtomic = (propName, isCtxProp, index, isAtomic, viewProp) => (_ref6, operation) => {\n      let {\n        lovEntry,\n        dataProvider,\n        checkLovEntries,\n        dateApi\n      } = _ref6;\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let uiProperty = _.get(rtObj, `${atomicPath}`);\n\n      return performLOVOperation({\n        uiProperty,\n        vmo: vmo,\n        lovEntry,\n        dataProvider,\n        createUpdateValue,\n        checkLovEntries,\n        dateApi\n      }, operation).then(_ref7 => {\n        let {\n          newProp,\n          isPropertyUpdateReqd\n        } = _ref7;\n\n        if (newProp && isPropertyUpdateReqd) {\n          if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n            _.set(rtObj, `${atomicPath}`, { ...newProp\n            });\n          } else {\n            let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n            let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n            if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n              return;\n            }\n\n            _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n            _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n          }\n\n          if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n            let atPath = rootPath + '.' + atomicPath;\n            atPath = atPath.replace(/\\./g, '_');\n            atPath = atPath.replace(/\\[/g, '_');\n            atPath = atPath.replace(/\\]/g, '');\n            validateField(atPath, {\n              [atPath]: newProp\n            });\n            updateTouched(atPath);\n          }\n\n          atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n        }\n\n        return newProp;\n      });\n    };\n\n    return {\n      name: propName,\n      onChange: event => {\n        updateAtomicData(event);\n      },\n      value: getValue(),\n      getValue,\n      onBlur: event => handleBlurAtomic(event),\n      // Need to fill in\n      onClick: event => handleClickAtomic(event),\n      // Need to fill in\n      update: (value, additionalProp) => {\n        let event = {\n          target: {\n            type: 'OBJECT',\n            value: value,\n            additionalProp: additionalProp\n          }\n        };\n        updateAtomicData(event);\n      },\n      // Need to fill in\n      checked: getValue(),\n      touched: getTouched(propName),\n      label: getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      typex: getPropertyType(propName, isCtxProp, index, isAtomic, viewProp),\n      error: getErrors(propName, rootPath, path),\n      required: getRequired(propName, isCtxProp, index, isAtomic, viewProp),\n      maxLength: getMaxLength(propName, isCtxProp, index, isAtomic, viewProp),\n      placeholder: getPlaceHolder(propName, isCtxProp, index, isAtomic, viewProp),\n      disabled: viewProp && (!viewProp.isEnabled || !viewProp.isEditable),\n      setLovVal: setLovDataValAtomic(propName, isCtxProp, index, isAtomic, viewProp),\n      dirty: isPropDirty(propName, isCtxProp, index, isAtomic, viewProp),\n      'data-locator': getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      'aria-label': getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      'aria-required': getRequired(propName, isCtxProp, index, isAtomic, viewProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      autoFocus: getAutofocus(propName, isCtxProp),\n      vmo: vmo,\n      __vmprop__: () => viewProp,\n      fielddata: {\n        uiValue: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'uiValue'),\n        uiValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'uiValues'),\n        displayValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        oldValue: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'oldValue'),\n        oldValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'oldValues'),\n        isEnabled: viewProp && viewProp.isEnabled,\n        isSelectOnly: viewProp && viewProp.isSelectOnly,\n        isEditable: viewProp && viewProp.isEditable,\n        isLocalizable: viewProp && viewProp.isLocalizable,\n        uwAnchor: viewProp && viewProp.uwAnchor ? viewProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayName(propName, isCtxProp, null, isAtomic, viewProp),\n        labelPlacement: getLabelPlacementFromData(propName, isCtxProp, index, isAtomic, viewProp),\n        renderingHint: getRenderingHint(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp, index, isAtomic, viewProp),\n        radioVertical: viewProp && viewProp.vertical,\n        displayValsModel: getDisplayValsModel(propName, isCtxProp, index, isAtomic, viewProp),\n        numberOfLines: getNumberOfLines(propName, isCtxProp, index, isAtomic, viewProp),\n        dateApi: getDateApi(propName, isCtxProp, index, isAtomic, viewProp),\n        isArray: getIsArray(propName, isCtxProp, index, isAtomic, viewProp),\n        hasLov: getIsLov(propName, isCtxProp, index, isAtomic, viewProp),\n        dataProvider: getDataProvider(propName, isCtxProp, index, isAtomic, viewProp),\n        lovApi: getLovApi(propName, isCtxProp, index, isAtomic, viewProp),\n        editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp, index, isAtomic, viewProp),\n        action: getAction(propName, isCtxProp, index, isAtomic, viewProp),\n        iconName: viewProp && viewProp.iconName,\n        iconSource: viewProp && viewProp.iconSource,\n        tooltip: viewProp && viewProp.tooltip,\n        patterns: viewProp && viewProp.patterns,\n        preferredPattern: getPreferredPatternVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyName: propName,\n        parentUid: vmo ? vmo.uid : undefined,\n        isAutoAssign: getAutoAssignVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        isAutoAssignable: getAutoAssignableVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        patternAutoAssignFlags: getPatternAutoAssignFlagsVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        emptyLOVEntry: viewProp && viewProp.emptyLOVEntry,\n        destPanelId: viewProp && viewProp.destPanelId,\n        isRichText: viewProp && viewProp.isRichText,\n        hasRevRuleAttached: viewProp && viewProp.hasRevRuleAttached\n      }\n    };\n  };\n\n  let fields = createAllFields(data, atomicData, declViewModelJson, createFieldForAtomicData, createFieldsBasedOnMetaData, constructFieldForNamedPropertyVMO, constructFieldArrayOfNamedProperty, constructFieldForNamedProperty, ctx, fieldsRef);\n  fieldsRef.current = fields;\n\n  const hasErrors = () => {\n    let formErrors = getErrorsState();\n    let hasError = false;\n\n    if (formErrors) {\n      Object.keys(formErrors || {}).forEach(value => {\n        if (formErrors[value]) {\n          hasError = true;\n        }\n      });\n    }\n\n    return hasError;\n  };\n\n  const handleSubmit = async (event, submitAction) => {\n    event.preventDefault();\n    setFormValidity(getStateCollection(viewModel));\n\n    if (!hasErrors()) {\n      document.activeElement.blur(); // focus out from the form\n\n      await submitAction();\n      handleReset();\n    } else {\n      const focusOnFirstError = () => {\n        let inputElements = event.currentTarget;\n\n        for (let idx = 0; idx < inputElements.length; idx++) {\n          if (inputElements[idx].hasAttribute('error')) {\n            inputElements[idx].focus();\n            break;\n          }\n        }\n      };\n\n      focusOnFirstError();\n    }\n  };\n\n  useInitHook(() => {\n    setFormValidity(getStateCollection(viewModel)); // 20201013 - skip no field case\n    // const keys = Object.keys( fields );\n    //if( keys.length > 0 ) {\n    //let initValues = {};\n    // Object.keys( fields ).forEach( field => {\n    //     initValues[ field ] = fields[ field ] && fields[ field ].value;\n    // } );\n    //setInitialValues( initValues );\n    //}\n  });\n  /**\n   * This function checks the pristine state of the Form.\n   * If the form has been touched, this would return false, otherwise true.\n   * @returns boolean true/false\n   */\n\n  const isFormDirty = () => {\n    let touchedObj = getTouchedState();\n    let isFormDirty = false;\n    let keys = Object.keys(touchedObj);\n\n    for (let i = 0; i < keys.length; i++) {\n      let name = keys[i];\n\n      if (touchedObj[name]) {\n        isFormDirty = true;\n        break;\n      }\n    }\n\n    return isFormDirty;\n  };\n\n  const formProp = {\n    onSubmit: handleSubmit,\n    onReset: handleReset,\n    children: {},\n    id: viewModel._internal.panelId,\n    attributes: {\n      noValidate: true,\n      autoComplete: 'off',\n      valid: getFormValidity(),\n      dirty: isFormDirty()\n    }\n  };\n  return {\n    fields,\n    formProp\n  };\n};\n/**\n * Keeping props inside a Ref. This is to avoid the stale prop issue specially with the actions\n * fired on event subscription.getProps would ensure to give latest prop;\n * @param {*} props React Props Object\n * @return {*} callback function to get the latest prop\n */\n\n_s9(useAfxForm, \"ylprpMI9QTAwjxUqXT25EtduUeI=\", false, function () {\n  return [useInitHook];\n});\n\n_s2(useAfxForm, \"c8youxKBlZDxb+HWbIXAvcZz8iQ=\", false, function () {\n  return [useInitHook];\n});\n\nconst useProps = props => {\n  _s10();\n\n  _s3();\n\n  const propRef = useRef(props);\n  propRef.current = props;\n  return React.useCallback(() => propRef.current, [propRef]);\n};\n/**\n * get view model context based on input\n * @param {object} vmDef view model instance factory\n * @param {object} subPanelContext sub panel context\n * @returns {object} view model context as:\n * {\n *     viewModel: {\n *         data,\n *         dispatch: function( { path: 'ctx.a', value: 3 } ) // way to update viewModel directly\n *     },\n *     actions: {\n *         myAction: executeAction.bind(null, 'myAction', vm)\n *     },\n *     ctx,\n *     fields: {\n *         first_name: {\n *             name: value,\n *             onChange: handleChange(value),\n *             onBlur: handleBlur(value),\n *             value: getValue(value),\n *             checked: getValue(value),\n *             touched: getTouched(value),\n *             propertyDisplayName: getPropertyDisplayName(value),\n *             label:  getPropertyDisplayName(value),\n *             typex: getPropertyType(value),\n *             helperText: getErrors(value),\n *             error: getErrors(value),\n *             required: getRequired(value),\n *             labelPlacement: getLabelPlacement(value),\n *             dirty: isModified(value)\n *         }\n *     },\n *     formSubmit: // Please bind this with form submit button\n * }\n */\n\n/* eslint-disable react-hooks/rules-of-hooks */\n\n\n_s10(useProps, \"Z4ZcnD5XDrf7a5m0u8SmAMrbBDU=\");\n\n_s3(useProps, \"Z4ZcnD5XDrf7a5m0u8SmAMrbBDU=\");\n\nexport const useAfxViewModel = (vmDef, prop, renderOptions, ctxImports) => {\n  _s12();\n\n  _s5();\n\n  const declViewModelJson = vmDef._internal.origDeclViewModelJson;\n  const getProps = useProps(prop);\n  let vmpCollRef = useRef(null);\n  let vmpValidationSchema = useRef(null);\n  let fieldsRef = useRef(null);\n  const getFields = React.useCallback(() => fieldsRef.current, [fieldsRef]);\n\n  const setFields = fields => {\n    if (fieldsRef.current !== fields) {\n      fieldsRef.current = fields;\n    }\n  }; // data\n\n\n  const dataHook = useReducer(reducer, null, vmDef.createData); // fieldsdata\n\n  const allAtomicData = useAtomicDataReducer(declViewModelJson); // ctx\n\n  const {\n    ctx,\n    ctxMin,\n    ctxDispatch\n  } = useDerivedState(vmDef, prop, dataHook[0], ctxImports);\n  const ctxHook = [{ ...ctx,\n    ...ctxMin\n  }, ctxDispatch]; // sync strategy ports\n\n  const portsHook = useReducer(reducer, null, vmDef.createPorts); // subPanelContext\n\n  useMemo(() => {\n    updateSubPanelContext(vmDef._internal.origDeclViewModelJson.data, dataHook, prop.subPanelContext);\n  }, [prop.subPanelContext]);\n  let subscriptions = useRef(null);\n  let editHandlerRef = useRef(null); //CommandsViewModel maintains its own lifecycle and has separate subscriptions from parent viewModel\n  //E.g. Container view has some events and container view has commandbar so there are 2 viewmodels\n  // and 2 subscriptions. Lifecycle of command viewModel subscription though is limited to command click\n  // since runActionWithViewModel is not component, we need to declare useRef outside ( under component)\n\n  let subscriptionsForCommands = useRef(null);\n  /**\n   * Run an action with a different view model from the one used by this component\n   *\n   * @param {Object} viewModelJson The unprocessed JSON\n   * @param {String} actionId ID of the action to execute\n   * @param {Object} scope (Optional) Additional properties to include in execution scope\n   */\n\n  const runActionWithViewModel = async function (viewModelJson, actionId) {\n    let scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const trace = new Debug('declViewModelService:actionId'); //get view model ready for executing action\n\n    const commandVmDef = createDeclViewModel(viewModelJson, prop);\n    commandVmDef.data = commandVmDef.data || {};\n    /**\n     * TODO: This takes ~1s for commandsViewModel. Options to fix are:\n     *  1. Cache based on view model ID (so first command click is slow but rest are not)\n     *    - Still results in processing more i18n than necessary\n     *  2. Use lazy getter\n     *    - viewModel.i18n[key] would now be a promise, which would have significant impact\n     */\n\n    commandVmDef.i18n = await awDuiLocalizationSvc.populateI18nMap(viewModelJson.i18n, null);\n    const processedVm = processViewModel(commandVmDef, ctxHook, dataHook);\n    const commandsViewModel = processedVm.viewModel;\n    const subscriptionObject = setupLifeCycle(commandVmDef, commandsViewModel, ctxHook[0], () => prop, null, true, runActionWithViewModel, subscriptionsForCommands, getFields); //Actions being executed can access anything in ctx, even if useSelector hook is not setup\n\n    const executionScope = { ...scope,\n      data: commandsViewModel,\n      ctx: ctxHook[0]\n    };\n    const result = await viewModelService.executeCommand(commandsViewModel, actionId, executionScope); //executeCommand is resolved after first action is complete. We have to wait on all following actions (triggered by events) to complete before resolving\n\n    const resolveWhenCommandsViewModelIsNotActive = new Promise(resolve => {\n      const intervalId = setInterval(() => {\n        if (!commandsViewModel.getToken().isActive()) {\n          clearInterval(intervalId);\n          return resolve();\n        }\n\n        trace('Action is still executing checking again in 50ms', actionId);\n        return null;\n      }, 50);\n    });\n    await resolveWhenCommandsViewModelIsNotActive; //cleanup the view model\n\n    subscriptionObject();\n    return result;\n  }; // view model\n\n\n  const {\n    viewModel,\n    grids\n  } = processViewModel(vmDef, ctxHook, dataHook, portsHook, allAtomicData, getProps, runActionWithViewModel, getFields); // i18n\n\n  const [i18n, i18nLoaded] = useI18n(viewModel);\n  viewModel.i18n = i18n;\n  let stateCollection = getStateCollection(viewModel);\n  updateValidationSchema(viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection); // form\n\n  const {\n    fields,\n    formProp\n  } = useAfxForm(vmDef, viewModel, ctxHook[0], dataHook, i18n, vmDef._internal.origDeclViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema);\n  setFields(fields);\n  let dataCtxNode = {\n    props: prop,\n    data: viewModel,\n    ctx: ctxHook[0],\n    subPanelContext: prop.subPanelContext,\n    ports: viewModel.ports,\n    getProps,\n    getFields,\n    fields\n  }; // selectionModels\n\n  viewModel.selectionModels = useSelectionModels(vmDef._internal.selectionModels, dataCtxNode);\n  useDataProviders(vmDef.dataProviders, getProps, dataCtxNode); // tableContext\n\n  const [gridContextPlaceholder, gridContextDispatcher] = useGridContext(prop);\n  useGrids(vmDef.grids, dataCtxNode, vmDef.dataProviders, gridContextPlaceholder, gridContextDispatcher, viewModel, getProps); // Setup lifecycle\n  // NOTE: it should be setupLifeCycle, but there is a eslint rule to force the function name to be 'useXXX'\n\n  useInitHook(() => setupLifeCycle(vmDef, viewModel, ctxHook[0], getProps, renderOptions, false, runActionWithViewModel, subscriptions, getFields), i18nLoaded);\n  useInitHook(() => declDragAndDropService.updateDeps(viewModel)); // grids\n\n  if (i18nLoaded === true) {\n    for (const gridDefKey in grids) {\n      let gridInstance = grids[gridDefKey];\n      gridInstance.i18nLoaded = i18nLoaded;\n    }\n  }\n\n  useGrid(prop, vmDef.getPanelId(), gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel); //lovs\n\n  useLOVs(fields, prop, viewModel, renderOptions); // initialize popups\n\n  usePopups(viewModel); //messages\n\n  const messages = useMessages(viewModel, fields); // drag and drop\n\n  declDragAndDropService.setupDragAndDrop(viewModel, dataCtxNode, getProps); //update Event subscriptions\n\n  updateSubscriptions(subscriptions.current, viewModel);\n  useCommands(viewModel, prop, renderOptions);\n\n  for (let key in viewModel.declViewModelJson.conditions) {\n    conditionService.registerWatch(viewModel.conditions, viewModel, key, [viewModel.declViewModelJson.conditions[key].expression], vmDef.oldExpressions);\n  }\n\n  vmDef.oldExpressions = viewModel.expressions;\n\n  if (viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate && Array.isArray(viewModel.declViewModelJson.lifecycleHooks.onUpdate)) {\n    var _s11 = $RefreshSig$();\n\n    var _s4 = $RefreshSig$();\n\n    _s11(_s4(_s11(_.forEach(viewModel.declViewModelJson.lifecycleHooks.onUpdate, _s11(_s4(_s11(function (onUpdateDef, i) {\n      _s11();\n\n      _s4();\n\n      let observerObjs = [];\n\n      if (viewModel.declViewModelJson.lifecycleHooks && onUpdateDef) {\n        let obj = onUpdateDef;\n        let evContext = {\n          props: prop,\n          viewModel,\n          fields: getFields()\n        };\n\n        _.forEach(obj.observers, function (observer) {\n          let evaluatedObj = _.get(evContext, observer); //populate observers irrespective of their value\n          //This aids usecases where initial values for observers are null/undefined and are populated eventually\n\n\n          observerObjs.push(evaluatedObj);\n        });\n      }\n\n      useEffect(function () {\n        //don't execute hook if all parameters are undefined\n        if (observerObjs.filter(x => !_.isUndefined(x)).length) {\n          if (logger.isDeclarativeLogEnabled()) {\n            debugService.debugLifecyleHooks('onUpdate', viewModel, observerObjs);\n          }\n\n          debugService.debug('lifeCycles', viewModel._internal.panelId, 'update');\n          viewModel.lifecycleHooks.onUpdate[i](renderOptions);\n        }\n      }, observerObjs);\n    }, \"OD7bBpZva5O2jO+Puf00hKivP7c=\"), \"OD7bBpZva5O2jO+Puf00hKivP7c=\"), \"OD7bBpZva5O2jO+Puf00hKivP7c=\")), \"OD7bBpZva5O2jO+Puf00hKivP7c=\"), \"OD7bBpZva5O2jO+Puf00hKivP7c=\"), \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n  } else {\n    let observerObjs = [];\n\n    if (viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate) {\n      let obj = viewModel.declViewModelJson.lifecycleHooks.onUpdate;\n      let evContext = {\n        props: prop,\n        viewModel,\n        fields: getFields()\n      };\n\n      _.forEach(obj.observers, function (observer) {\n        let evaluatedObj = _.get(evContext, observer); //populate observers irrespective of their value\n        //This aids usecases where initial values for observers are null/undefined and are populated eventually\n\n\n        observerObjs.push(evaluatedObj);\n      });\n    }\n\n    useEffect(function () {\n      //don't execute hook if all parameters are undefined\n      if (observerObjs.filter(x => !_.isUndefined(x)).length) {\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugLifecyleHooks('onUpdate', viewModel, observerObjs);\n        }\n\n        debugService.debug('lifeCycles', viewModel._internal.panelId, 'update');\n        executeHook('onUpdate', viewModel, prop, renderOptions);\n      }\n    }, observerObjs);\n  }\n\n  viewModel.editHandlers = useEditHandlers(vmDef._internal.editHandlers, viewModel, dataCtxNode, editHandlerRef, fields); // Edit handlers\n\n  const editContexts = findEditContexts(viewModel);\n\n  if (editContexts.length > 0) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEditHandlers2(viewModel);\n  } // update Sync path\n\n\n  let path = '';\n\n  if (prop.viewId && prop.viewPath) {\n    let viewPathArray = prop.viewPath.split('/');\n\n    if (prop.viewId === prop.viewPath) {\n      path = prop.viewPath;\n    } else if (prop.viewId === viewPathArray[viewPathArray.length - 1]) {\n      path = prop.viewPath;\n    } else {\n      path = prop.viewPath + '/' + prop.viewId;\n    }\n  } else if (prop.viewId) {\n    path = prop.viewId;\n  }\n\n  return {\n    ctx: ctxMin,\n    ctxDeprecated: ctx,\n    ctxMin,\n    viewModel,\n    actions: viewModel.actions,\n    i18n,\n    fields,\n    grids,\n    formProp,\n    messages,\n    runActionWithViewModel,\n    gridContextPlaceholder,\n    gridContextDispatcher,\n    viewPath: path\n  };\n};\n/**\n * Edit handlers hook\n * @param {Object} viewModel View model\n */\n\n_s12(useAfxViewModel, \"lq8KlZQMWhhtc3Fk3x2ucIywln4=\", false, function () {\n  return [useProps, useAtomicDataReducer, useDerivedState, useI18n, useAfxForm, useSelectionModels, useDataProviders, useGridContext, useGrids, useInitHook, useInitHook, useGrid, useLOVs, usePopups, useMessages, useCommands, useEditHandlers, useEditHandlers2];\n});\n\n_s5(useAfxViewModel, \"orzwELkpJmJWLFUIcdZfVHUlR8g=\", false, function () {\n  return [useProps, useAtomicDataReducer, useDerivedState, useI18n, useAfxForm, useSelectionModels, useDataProviders, useGridContext, useGrids, useInitHook, useInitHook, useGrid, useLOVs, usePopups, useMessages, useCommands, useEditHandlers, useEditHandlers2];\n});\n\nexport function useEditHandlers2(viewModel) {\n  _s13();\n\n  _s6();\n\n  useEffect(function () {\n    editHandlerService.updateStates2(viewModel);\n  });\n}\n/**\n * Find edit contexts of view model\n * @param {Object} viewModel View model\n * @return {String} Edit contexts\n */\n\n_s13(useEditHandlers2, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n_s6(useEditHandlers2, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\nfunction findEditContexts(viewModel) {\n  let editContexts = [];\n\n  if (viewModel.editHandlers) {\n    for (const editHandlerName in viewModel.editHandlers) {\n      if (!viewModel.editHandlers[editHandlerName].dataSource) {\n        editContexts.push(viewModel.editHandlers[editHandlerName].context);\n      }\n    }\n  }\n\n  if (viewModel.dataProviders) {\n    for (const dataProviderName in viewModel.dataProviders) {\n      const dataProvider = viewModel.dataProviders[dataProviderName];\n\n      if (dataProvider.editContext) {\n        editContexts.push(dataProvider.editContext);\n      }\n    }\n  }\n\n  return editContexts;\n}\n/**\n * load subscriptions\n * @param {JSON} onEventDef onEvent definition\n * @param {ViewModelObject} vm view model object\n * @param {limitEventScope} limitEventScope Limit the event registration for certain view models like commands VM\n * @returns {Array} event subscriptions\n */\n\n\nexport function loadSubscriptions(onEventDef, vm, limitEventScope, getProps, runActionWithViewModel, getFields) {\n  // process event subscription\n  const res = [];\n\n  if (onEventDef) {\n    onEventDef.forEach(eventObj => {\n      // - Construct a call back to process action.\n      // - put vm to the scope of the fn and communicate to subscriber\n      // - update that vm in every render cycle ( which is anti-pattern )\n      if (!_.isEmpty(eventObj)) {\n        const subscriber = eventData => {\n          const viewModel = subscriber.vm;\n\n          if (eventData && eventData.scope) {\n            // Never mutate the existing eventData, it would causes issue when there are multiple subscriptions\n            // and the action associated with the event is async.\n            let newEventData = { ...eventData,\n              scope: { ...eventData.scope\n              }\n            };\n            newEventData.scope.data = viewModel;\n            newEventData.scope.ctx = appCtxSvc.ctx;\n            handleRegisteredEvent(newEventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields);\n          } else {\n            handleRegisteredEvent(eventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields);\n          }\n        };\n\n        subscriber.subDef = subscribe(eventObj.eventId, subscriber);\n        subscriber.vm = vm;\n        res.push(subscriber);\n      }\n    });\n  }\n\n  return res;\n}\n/**\n * Update vm to scope in event subscriptions\n * @param {Array} subscriptions event subscriptions\n * @param {ViewModelObject} vm view model object\n */\n\nexport function updateSubscriptions(subscriptions, vm) {\n  if (subscriptions) {\n    subscriptions.forEach(subscriber => subscriber.vm = vm);\n  }\n}\n/**\n * unload subscriptions from event bus\n * @param {Array} subscriptions event subscriptions\n */\n\nexport function unloadSubscriptions(subscriptions) {\n  subscriptions.forEach(subscriber => unsubscribe(subscriber.subDef) && delete subscriber.vm);\n  subscriptions.splice(0, subscriptions.length);\n}\n/**\n * cleanup edit handlers\n * @param {Array} editHandlers  editHandlers\n * @param {Object} dataCtxNode dataCtxNode\n */\n\nexport function cleanupEditHandlers(editHandlers, dataCtxNode) {\n  if (editHandlers) {\n    for (const key in editHandlers) {\n      if (editHandlers[key] && editHandlers[key].context) {\n        let contextKey = editHandlers[key].context;\n\n        if (contextKey && contextKey.match(/\\{\\{.*}}/g)) {\n          contextKey = AwInterpolateService.instance(contextKey)(dataCtxNode);\n        }\n\n        removeEditHandler(contextKey);\n      }\n    }\n  }\n}\n\nconst getDifferenceBetweenObjects = function (object, base) {\n  function changes(object, base) {\n    return _.transform(object, function (result, value, key) {\n      if (!_.isEqual(value, base[key])) {\n        result[key] = _.isObject(value) && _.isObject(base[key]) ? changes(value, base[key]) : value;\n      }\n    });\n  }\n\n  return changes(object, base);\n};\n\nconst isObject = function (item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n\nconst mergeDeep = function (target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n};\n/**\n * create react component based on view model JSON\n * @param {JSON} declViewModelJson view model definition\n * @param {Function} renderFn the renderFn, default null\n * @param {Object} options the render options\n * @returns {JSX.Element} context for view interpolation\n *\n */\n\n\nexport const createComponent = function (declViewModelJson, renderFn) {\n  var _s14 = $RefreshSig$();\n\n  var _s7 = $RefreshSig$();\n\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let ctxImports = arguments.length > 3 ? arguments[3] : undefined;\n\n  const Component = prop => {\n    _s14();\n\n    _s7();\n\n    splmStatsService.startComponentRenderTime();\n    const [vmDef] = useState(() => createDeclViewModel(declViewModelJson, prop));\n    const [declViewModel] = useState(() => declViewModelJson);\n    let viewData = null;\n    let elementsMap = useRef(new Map());\n    let ref = prop.domRef;\n\n    if (!ref && options.elementRefList) {\n      viewData = {\n        elementRefList: null\n      };\n      options.elementRefList.map(domElement => {\n        if (!elementsMap.current.has(domElement)) {\n          elementsMap.current.set(domElement, /*#__PURE__*/createRef(null));\n        }\n      });\n      viewData.elementRefList = elementsMap.current; // How to update props ??\n    }\n\n    let {\n      elementRefList,\n      ...restOptionsParams\n    } = { ...options\n    };\n    useVmoStore(prop, vmDef._internal.origDeclViewModelJson.props);\n    const vm = useAfxViewModel(vmDef, prop, { ...viewData,\n      ...restOptionsParams\n    }, ctxImports);\n    let {\n      i18n,\n      data,\n      dispatch\n    } = vm.viewModel;\n    let createData = vmDef.createData; // deserve to put one more useRef since createData and createDeclViewModel is very expensive\n\n    const hmrLastRef = useRef(null);\n    useEffect(function useHmrEffect() {\n      // console.log( 'hmrEffect triggered!' );\n      // Merge new data into current data\n      // TODO: Patch entire view model, maybe don't use hook approach to sync data.\n      if (hmrLastRef.current !== null) {\n        const initialData = createData(i18n);\n        const newData = createDeclViewModel(declViewModelJson, prop).createData(i18n);\n        const diffData = getDifferenceBetweenObjects(newData, initialData);\n        let mergedData = null;\n\n        if (!_.isEmpty(diffData)) {\n          mergedData = mergeDeep(data, diffData);\n          dispatch({\n            path: 'data',\n            value: { ...mergedData\n            }\n          });\n        }\n\n        hmrLastRef.current = declViewModel;\n      }\n    }, [declViewModel]);\n    let props = { ...prop,\n      ...vm\n    };\n    renderFn = renderFn || vmDef.renderFn; // support mixin (renderParams) based on render options\n\n    if (!ref && options.elementRefList) {\n      props.elementRefList = viewData.elementRefList;\n    } // initialize AwExtendedTooltip\n\n\n    if (options && options.isTootip) {\n      let action = vm.actions.extendedTooltipPopup; // justification: hooks are called in the same order each time AwExtendedTooltip renders.\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n\n      useEffect(() => {\n        action.reference.current = prop.reference.current;\n        action.userOptions.current = prop.extendedTooltipOptions;\n      }, [prop.reference.current]);\n    }\n\n    if (options.registerCtx) {\n      // justification: hooks are called in the same order each time that component renders.\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useEffect(() => {\n        let {\n          key,\n          value,\n          path\n        } = options.registerCtx;\n        appCtxSvc.registerCtx(prop.key || key, value || _.get(vm, path));\n      });\n    }\n\n    let component = renderFn(props);\n    component = setDndHandler(vm, props, component); // generic style inheritance\n\n    if (component && component.props && props && props.className) {\n      // don't repeat classes.... use simple string check\n      if (!(component.props.className && component.props.className.includes(props.className))) {\n        if (component.type && component.type.includes && component.type.includes('-')) {\n          component = /*#__PURE__*/React.cloneElement(component, {\n            class: component.props.class + ' ' + props.className\n          });\n        } else {\n          component = /*#__PURE__*/React.cloneElement(component, {\n            className: component.props.className + ' ' + props.className\n          });\n        }\n      }\n    } // inject ref prop by need\n\n\n    if (ref && component) {\n      if (props.domRef) {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          ref,\n          domRef: props.domRef\n        });\n      } else {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          ref\n        });\n      }\n    } // provide a opportunity to override appendToBody behavior through props\n\n\n    if (options.usePortal && prop.enableAppend !== false) {\n      component = /*#__PURE__*/ReactDOM.createPortal(component, prop.parent || document.body);\n    }\n\n    splmStatsService.trackComponent(declViewModelJson._viewModelId);\n    return component || null;\n  }; // Scenario: Verify zero group compile command with popup associated with ZCC (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:7\n  // Scenario: Verify zero shuttle compile command (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:74\n  // Scenario: Verify triangle and popup are not shown when there is only one visible command in the zero group compile command (attempt 2, retried)\n  //     # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:40\n  // Scenario: Verify zero shuttle compile command with/without label (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:143\n  // https://stackoverflow.com/questions/60453845/is-it-safe-to-usememo-for-jsx\n\n\n  _s14(Component, \"dptXBNoQDHbEtgT+0nWGkWpiPCM=\", false, function () {\n    return [useVmoStore, useAfxViewModel];\n  });\n\n  _s7(Component, \"RSO2PDv5AsJn8/IR/8BjnzP4xNc=\", false, function () {\n    return [useVmoStore, useAfxViewModel];\n  });\n\n  if (options.useMemo === false) {\n    Component.displayName = declViewModelJson._viewModelId;\n    return Component;\n  }\n\n  Component.displayName = `${declViewModelJson._viewModelId}.memo`;\n  return /*#__PURE__*/React.memo(Component);\n};\n\nconst setDndHandler = function (vm, props, component) {\n  const dndHandlers = vm.viewModel.dndHandler || props.attachdndHandlers;\n\n  if (dndHandlers) {\n    if (component && typeof component.type === 'string') {\n      let dndListener = declDragAndDropService.setViewDnd(dndHandlers);\n      component = /*#__PURE__*/React.cloneElement(component, { ...dndListener,\n        className: component.props.className + ' aw-widgets-droppable'\n      });\n    } else {\n      if (component && component.props && !component.props.onDragEnter && component.type !== 'aw-splm-table') {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          attachdndHandlers: dndHandlers\n        });\n      }\n    }\n  }\n\n  return component;\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declViewModelService.js"],"names":["executeHook","viewModel","logger","debugService","hookName","onEvents","contentLoadedEvent","event","eventName","viewName","publish","props","panelId","viewId","setupLifeCycle","getProps","subscriptions","loadSubscriptions","dataCtxNode","data","ctx","ports","subPanelContext","getFields","_","syncStrategyService","clearContext","cleanupEditHandlers","vmDef","unloadSubscriptions","syncViewModelCacheService","useI18n","grids","useState","useInitHook","i18n","Object","awDuiLocalizationSvc","results","updateI18nTexts","dispatch","path","value","chartProviders","columnProviders","setI18n","setI18nLoaded","updateSubPanelContext","resolvedData","resolveSubPanelContext","dataClone","uwPropertySvc","updateData","useAfxForm","createData","validRef","useRef","updateFormValidity","formValidity","setValid","getFormValidity","React","errorsRef","updateErrors","errorObj","setErrors","getErrorsState","touchedRef","updateTouched","touched","newTouched","setTouched","getTouchedState","atomicData","atomicDataRef","getVmProp","ctxObj","isCtxProp","getVmPropFromList","validateAndUpdateDCPPath","propsKey","propName","updateValue","updatedProp","name","appCtxSvc","isFormValid","stateCollection","schema","vmpValidationSchema","hasInvalidProps","invalidProps","entries","declUtils","e","setFormValidity","validity","validateField","newErrors","viewModelProperty","errors","getStateCollection","setLovDataVal","dateApi","uiProperty","vmpPropName","validateName","vmo","isPropertyUpdateReqd","newProp","Promise","setLovDataValVMO","getVMPropForVMO","pathName","vmoName","getVMO","getVMOProps","handleChange","vmProp","vmPropName","newVMProp","createUpdateValue","setValueForVmo","updateVal","setValue","prevVal","handleChangeVMO","moveUp","i","prop","currDbVal","currDisplayVal","currDisplayValModel","index","moveDown","remove","handleClick","indexStr","parseInt","isButtonClicked","isAnyValueSelected","j","hasActionHappened","titleVal","handleClickVMO","handleBlur","updateArray","handleBlurVMO","isValidArrayValue","isValid","valToUpdate","isFinite","createNewArrayVal","newVal","Number","Array","lData","getAutofocusVMO","getAutofocus","getAtomicVmProp","getValueVMO","String","getValue","getTouched","touchedState","getErrorsVMPArray","isTouched","getErrors","atomicPath","rootPath","isAtomic","viewProp","getPropertyDisplayName","propDisplayName","getPropertyDisplayNameVMO","getPlaceHolder","placeholder","propertyType","getPropertyType","getPlaceHolderVMO","getUIValue","key","getUIValueVMO","getRenderingHint","getRenderingHintVMO","getPropertyTypeVMO","getRequired","getRequiredVMO","getMaxLength","getMaxLengthVMO","getPropertyRadioTrueText","getPropertyRadioTrueTextVMO","getPropertyRadioFalseText","getPropertyRadioFalseTextVMO","getDisplayValsModel","getDisplayValsModelVMO","getDateApi","getDateApiVMO","getIsLov","getIsLovVMO","getLovApiVMO","getDataProvider","dataProviders","getDataProviderVMO","getIsArray","getIsArrayVMO","getLovApi","getEditArrayInlineMode","getEditArrayInlineModeVMO","getNumberOfLines","getNumberOfLinesVMO","getLabelPlacement","labelPlacement","getLabelPlacementFromData","dirtyCheck","isPropDirty","isPropDirtyVMO","getPatterns","getPreferredPattern","getPreferredPatternVMO","getAutoAssignVMO","getAutoAssignableVMO","getPatternAutoAssignFlagsVMO","getIsAutoAssign","getIsAutoAssignVMPArray","getIsAutoAssignable","getPatternAutoAssignFlags","getParentUid","handleReset","getAction","getActionVMO","constructFieldForNamedPropertyVMO","onChange","onBlur","onClick","checked","label","typex","error","required","maxLength","disabled","dirty","setLovVal","update","autoFocus","__vmprop__","fielddata","uiValue","uiValues","oldValue","oldValues","displayValues","convertToHtml","isEnabled","isSelectOnly","isEditable","isLocalizable","uwAnchor","propertyDisplayName","renderingHint","propertyRadioTrueText","propertyRadioFalseText","radioVertical","displayValsModel","numberOfLines","isArray","hasLov","dataProvider","editArrayInlineMode","isRichText","emptyLOVEntry","patterns","preferredPattern","lovApi","action","destPanelId","iconName","iconSource","tooltip","isAutoAssign","isAutoAssignable","parentUid","propertyName","patternAutoAssignFlags","hasRevRuleAttached","constructFieldForNamedProperty","constructFieldArrayOfNamedProperty","vmpFieldArray","obj","createPartialField","rootObject","atomicDataVmpCollection","filterFlatViewModelPropForAtomic","dataVmpCollection","filterFlatViewModelProps","updateValidationSchema","createFieldForAtomicData","fieldType","constructFieldForAtomicProperty","stateObj","prevFieldsRef","fieldsRef","prevFieldObject","prevField","path1","newField","creatAtomicFields","isFieldsEqual","type","newFieldObject","updateAtomicData","rtObj","val1","val2","atPath","handleBlurAtomic","handleClickAtomic","setLovDataValAtomic","target","additionalProp","fields","createAllFields","hasErrors","formErrors","hasError","handleSubmit","document","submitAction","focusOnFirstError","inputElements","idx","isFormDirty","touchedObj","keys","formProp","onSubmit","onReset","children","id","attributes","noValidate","autoComplete","valid","useProps","propRef","useAfxViewModel","declViewModelJson","vmpCollRef","setFields","dataHook","useReducer","allAtomicData","useAtomicDataReducer","ctxDispatch","useDerivedState","ctxHook","ctxMin","portsHook","useMemo","editHandlerRef","subscriptionsForCommands","runActionWithViewModel","scope","trace","commandVmDef","createDeclViewModel","viewModelJson","processedVm","processViewModel","commandsViewModel","subscriptionObject","executionScope","result","viewModelService","resolveWhenCommandsViewModelIsNotActive","resolve","intervalId","setInterval","clearInterval","useSelectionModels","useDataProviders","useGridContext","useGrids","declDragAndDropService","i18nLoaded","gridInstance","useGrid","useLOVs","usePopups","messages","useMessages","updateSubscriptions","useCommands","conditionService","observerObjs","evContext","evaluatedObj","useEffect","x","useEditHandlers","editContexts","findEditContexts","useEditHandlers2","viewPathArray","ctxDeprecated","actions","viewPath","editHandlerService","res","onEventDef","eventObj","subscriber","eventData","newEventData","handleRegisteredEvent","subscribe","unsubscribe","editHandlers","contextKey","AwInterpolateService","removeEditHandler","getDifferenceBetweenObjects","base","changes","isObject","item","mergeDeep","sources","source","createComponent","options","ctxImports","Component","splmStatsService","viewData","elementsMap","ref","elementRefList","domElement","createRef","restOptionsParams","useVmoStore","vm","hmrLastRef","initialData","newData","diffData","mergedData","renderFn","component","setDndHandler","class","className","domRef","ReactDOM","_viewModelId","dndHandlers","dndListener","attachdndHandlers"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declViewModelService\n *\n * @namespace viewModelService\n */\nimport React, { useState, useMemo, useEffect, createRef, useRef } from 'react';\nimport ReactDOM from 'react-dom';\nimport { reducer } from 'js/store';\nimport { useReducer, useInitHook, useAtomicDataReducer, convertToHtml } from './reactHelper';\nimport { useDerivedState } from 'js/reactAppCtx';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport awDuiLocalizationSvc from 'js/awDuiLocalizationService';\nimport { processViewModel, createDeclViewModel } from 'js/declViewModelProcessingFactory';\nimport { subscribe, unsubscribe, publish } from 'js/eventBus';\nimport viewModelService, { handleRegisteredEvent } from 'js/viewModelService';\nimport conditionService from 'js/conditionService';\nimport { NULLDATE } from 'js/dateTimeService';\nimport _ from 'lodash';\nimport { resolveSubPanelContext, updateI18nTexts } from 'js/viewModelProcessingFactory';\nimport { useDataProviders } from 'js/dataProviderUtils';\nimport { useGrid, useGrids, useGridContext } from 'js/gridProviderUtils';\nimport { usePopups } from 'js/reactPopup';\nimport { useLOVs } from 'js/lovProviderUtils';\nimport { updateValidationSchema, getStateCollection, filterFlatViewModelPropForAtomic, filterFlatViewModelProps } from 'js/propValidationUtils';\nimport { performLOVOperation } from 'js/uwLovDataService';\nimport syncStrategyService from 'js/syncStrategyService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { useSelectionModels } from 'js/declSelectionModelFactory';\nimport { useEditHandlers, removeEditHandler } from 'js/declEditHandlerFactory';\nimport { useMessages } from 'js/messagesProviderUtils';\nimport appCtxSvc from 'js/appCtxService';\nimport editHandlerService from 'js/editHandlerService';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport useVmoStore from './useVmoStore';\nimport debugService from 'js/debugService';\nimport logger from 'js/logger';\nimport { createFieldsBasedOnMetaData } from 'js/atomicDataService';\nimport { createAllFields, isFieldsEqual } from 'js/declFieldService';\nimport splmStatsService from 'js/splmStatsService';\nimport { useCommands } from 'js/commandBarUtils';\nimport AwInterpolateService from 'js/awInterpolateService';\n/**\n * execute lifecycle hook\n * @param {string} hookName hook name as 'onInit', 'onMount' and 'onUnmount'\n * @param {object} viewModel view model instance\n */\n\nconst executeHook = ( hookName, viewModel, props, renderOptions ) => {\n    if( viewModel.lifecycleHooks && viewModel.lifecycleHooks[ hookName ] ) {\n        if( logger.isDeclarativeLogEnabled() ) {\n            debugService.debugLifecyleHooks( hookName, viewModel );\n        }\n        if( hookName === 'onMount' ) {\n            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'mount' );\n        }\n        viewModel.lifecycleHooks[ hookName ]( renderOptions );\n    }\n    // support backward compatibility of XXX.contentLoaded that is equivalent to onMount\n    if( hookName === 'onMount' ) {\n        const onEvents = viewModel.onEvent;\n        if( onEvents && onEvents.length > 0 ) {\n            let contentLoadedEvent = onEvents.find( ( event ) => {\n                const eventName = event.eventId;\n                if( eventName && eventName.includes( '.contentLoaded' ) ) {\n                    // make sure contentLoaded event is subscribed for this viewmodel\n                    // handle legacy use cases too compiler will convert viewModels to PascalCase but legacy viewNames could be in camel case\n                    const viewName = viewModel.getViewId();\n                    return eventName.split( '.contentLoaded' )[ 0 ].toLowerCase() === viewName.toLowerCase();\n                }\n                return false;\n            } );\n            if( contentLoadedEvent ) {\n                publish( contentLoadedEvent.eventId );\n            }\n        }\n        // Backward compatability for command-sub-panel\n        if( props.isCommandSubPanel === 'true' ) {\n            publish( 'awPanel.reveal', {\n                panelId: props.viewId\n            } );\n        }\n    }\n};\n\n/**\n * setup view model instance lifcycle in react\n * @param {object} viewModel view model Instance\n * @param {object} ctx App Ctx object\n * @param {object} prop view model property\n * @param {object} viewData view data\n * @param {boolean} limitEventScope Flag to control whether the even needs to be limited to specific view only\n * @param {object} subscriptions subscriptions\n * @returns {function} function to teardown view model intance\n */\nconst setupLifeCycle = ( vmDef, viewModel, ctx, getProps, renderOptions, limitEventScope, runActionWithViewModel, subscriptions, getFields ) => {\n    const props = getProps();\n    subscriptions.current = loadSubscriptions( viewModel.onEvent, viewModel, limitEventScope, getProps, runActionWithViewModel, getFields );\n    let dataCtxNode = {\n        data: viewModel,\n        ctx: ctx,\n        ports: viewModel.ports,\n        props: props,\n        getProps,\n        subPanelContext: props.subPanelContext,\n        getFields\n    };\n    //Execute onMount LifecycleHook\n    executeHook( 'onInit', viewModel );\n    executeHook( 'onMount', viewModel, props, renderOptions );\n    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n        syncStrategyService.setupSyncStrategy( dataCtxNode );\n        syncStrategyService.updateVmOnMountUnmount( dataCtxNode, true );\n    }\n    // TODO: can we split this out as teardownLifCycle later??\n    return () => {\n        const clearContext = () => {\n            cleanupEditHandlers( vmDef._internal.editHandlers, dataCtxNode );\n            unloadSubscriptions( subscriptions.current );\n            vmDef._internal.destroy( true );\n            dataCtxNode = null;\n            viewModel.actions = null;\n            viewModel.dispatch = null;\n            viewModel = null;\n        };\n        //onUnmount\n        //Make sure the onUnmount action is complete before destroying the declViewModel\n        if( viewModel.lifecycleHooks && viewModel.lifecycleHooks.onUnmount ) {\n            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'unmount' );\n            viewModel.lifecycleHooks.onUnmount( renderOptions ).then( () => {\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugLifecyleHooks( 'onUnmount', viewModel );\n                }\n                if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n                    syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );\n                    syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );\n                }\n                clearContext();\n            } );\n        } else {\n            if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n                syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );\n                syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );\n            }\n            clearContext();\n        }\n    };\n};\n\n/**\n * use i18n hook\n * @param {object} viewModel view model instance\n * @returns {object} i18n string map\n */\nconst useI18n = ( { i18n, data, dispatch, chartProviders, columnProviders, grids } ) => {\n    const [ i18nData, setI18n ] = useState( {} );\n    const [ i18nLoaded, setI18nLoaded ] = useState( false );\n\n    useInitHook( () => {\n        if( i18n && Object.keys( i18n ).length > 0 ) {\n            awDuiLocalizationSvc.populateI18nMap( i18n, null ).then( results => {\n                if( results && Object.keys( results ).length > 0 ) {\n                    updateI18nTexts( data, { i18n: results }, 0 );\n                    dispatch( { path: 'data', value: { ...data } } );\n                    if( chartProviders ) {\n                        updateI18nTexts( chartProviders, { i18n: results }, 0 );\n                        dispatch( { path: 'chartProviders', value: { ...chartProviders } } );\n                    }\n                    if( columnProviders ) {\n                        updateI18nTexts( columnProviders, { i18n: results }, 0 );\n                        dispatch( { path: 'columnProviders', value: { ...columnProviders } } );\n                    }\n                    if( grids ) {\n                        updateI18nTexts( grids, { i18n: results }, 0 );\n                        dispatch( { path: 'grids', value: { ...grids } } );\n                    }\n                    setI18n( results );\n                    setI18nLoaded( true );\n                } else {\n                    setI18nLoaded( true );\n                }\n            } );\n        }\n    } );\n\n    // Stu: we should not return this i18nLoaded, the downstream setupLifCycle should not depend on i18n. If it is\n    //      we should remove the dependency\n    // Jesse: it will cause cucumber failure for sure, will do it in next MX\n    return [ i18nData, i18n && Object.keys( i18n ).length > 0 ? i18nLoaded : true ];\n};\n\n// eslint-disable-next-line require-jsdoc\nconst updateSubPanelContext = ( jsonData, dataHook, subPanelContext ) => {\n    if( subPanelContext ) {\n        let resolvedData = {};\n        resolveSubPanelContext( jsonData, subPanelContext, resolvedData );\n        const [ data, updateData ] = dataHook;\n        _.forEach( resolvedData, function( propValue, propName ) {\n            let dataClone = _.cloneDeep( data[ propName ] );\n            if( uwPropertySvc.isViewModelProperty( dataClone ) ) {\n                uwPropertySvc.setValue( dataClone, Object.values( propValue ) );\n                updateData( { path: propName, value: dataClone } );\n            } else {\n                _.merge( dataClone, propValue );\n                updateData( { path: propName, value: dataClone } );\n            }\n        } );\n    }\n};\n\n/**\n * afx form hook\n * @param {object} vmDef view model definition\n * @param {array} dataHook dataHook in data-dispatch pair\n * @param {object} i18n i18n data used by reset\n * @returns {object} fields and form props\n */\nexport const useAfxForm = ( vmDef, viewModel, ctx, dataHook, i18n, declViewModelJson, getProps, fieldsRef, vmpCollRef,\n    vmpValidationSchema ) => { // create field part. If we dont have to toch this by action we are good\n    const { dataProviders, createData } = vmDef;\n    const [ touched, setTouched ] = useState( {} );\n    const [ errors, setErrors ] = useState( {} );\n    const [ isValid, setValid ] = useState( true );\n    const [ data, updateData ] = dataHook;\n\n    const validRef = useRef( isValid );\n    const updateFormValidity = ( formValidity ) => {\n        if( validRef.current !== formValidity ) {\n            validRef.current = formValidity;\n            setValid( formValidity );\n        }\n    };\n    const getFormValidity = React.useCallback( () => validRef.current, [ validRef ] );\n\n    const errorsRef = useRef( errors );\n    const updateErrors = ( errorObj ) => {\n        if( errorObj !== errorsRef.current ) {\n            errorsRef.current = errorObj;\n            setErrors( { ...errorObj } );\n        }\n    };\n    const getErrorsState = React.useCallback( () => errorsRef.current, [ errorsRef ] );\n\n    const touchedRef = useRef( touched );\n    const updateTouched = function( path ) {\n        if( touched && touched[ path ] !== true ) {\n            let newTouched = { ...touchedRef.current, [ path ]: true };\n            touchedRef.current = newTouched;\n            setTouched( newTouched );\n        }\n    };\n    const getTouchedState = React.useCallback( () => touchedRef.current, [ touchedRef ] );\n\n    const { atomicData = {}, atomicDataRef = {} } = viewModel;\n    const props = getProps ? getProps() : {};\n\n    const getVmProp = ( isCtxProp, name ) => {\n        const ctxObj = isCtxProp ? ctx : data;\n        return _.get( ctxObj, name );\n    };\n    const getVmPropFromList = ( propName, index, isCtxProp ) => {\n        const ctxObj = isCtxProp ? ctx : data;\n        return _.get( ctxObj, propName )[ index ];\n    };\n\n    const validateAndUpdateDCPPath = ( path ) => {\n        //Identify DCP property and escape using the bracket notation.\n        //For non DCP properties too, if the keys are more than 3, we should update the path\n        const propsKey = 'props.';\n        let propName = path.substring( path.indexOf( propsKey ) + 6, path.length );\n        if( uwPropertySvc.isDCPProperty( propName ) || path.split( '.' ).length > 3 ) {\n            return path.replace( `.${propName}`, `['${propName}']` );\n        }\n        return path;\n    };\n\n    const updateValue = ( isCtxProp, name, updatedProp ) => {\n        if( updatedProp.isDCP || name.split( '.' ).length > 3 ) {\n            name = validateAndUpdateDCPPath( name );\n        }\n        isCtxProp ? appCtxSvc.updatePartialCtx( name, updatedProp ) : updateData( { path: name, value: updatedProp } );\n    };\n\n    const isFormValid = ( stateCollection ) => {\n        let schema = vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n        if( schema ) {\n            return !hasInvalidProps( stateCollection, schema );\n        }\n        return true;\n    };\n\n    const hasInvalidProps = ( vmPropCollection, schema ) => {\n        let invalidProps = {};\n        let entries = schema && vmPropCollection && Object.entries( vmPropCollection );\n        if( !declUtils.isNil( entries ) && entries.length > 0 ) {\n            for( let [ key ] of entries ) {\n                try {\n                    schema.validateSyncAt( key, vmPropCollection );\n                } catch ( e ) {\n                    if( e && e.errors ) {\n                        invalidProps[ key ] = e.errors;\n                        break;\n                    }\n                }\n            }\n        }\n        return Object.keys( invalidProps ).length !== 0;\n    };\n\n    const setFormValidity = ( stateCollection ) => {\n        let validity = isFormValid( stateCollection );\n        updateFormValidity( validity );\n    };\n\n    const validateField = ( name, viewModelProperty ) => {\n        let newErrors = getErrorsState();\n        let schema = null;\n        try {\n            schema = viewModelProperty && vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n            if( schema ) {\n                schema.validateSyncAt( name, viewModelProperty );\n                // No need to update the errors object, if the \"property name\" is not present earlier.\n                if( newErrors && newErrors[ name ] ) {\n                    delete newErrors[ name ];\n                    updateErrors( { ...newErrors } );\n                }\n            }\n        } catch ( e ) {\n            if( e && e.errors ) {\n                newErrors = { ...newErrors, [ name ]: e.errors };\n                updateErrors( newErrors );\n            }\n        } finally {\n            setFormValidity( getStateCollection( viewModel ) );\n        }\n    };\n\n    const setLovDataVal = ( name, isCtxProp, index ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n        if( name.includes( '[' ) ) {\n            name = name.replace( / *\\[[^\\]]*]/, '' );\n        }\n        let uiProperty;\n        if( isCtxProp ) {\n            uiProperty = appCtxSvc.getCtx( name );\n        } else if( !_.isNil( index ) ) {\n            uiProperty = viewModel.getData()[ name ][ index ];\n        } else {\n            uiProperty = viewModel.getData()[ name ];\n        }\n        let vmpPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n\n        return performLOVOperation( {\n            uiProperty,\n            vmo: null,\n            lovEntry,\n            dataProvider,\n            createUpdateValue,\n            checkLovEntries,\n            dateApi\n        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n            if( newProp && isPropertyUpdateReqd ) {\n                updateValue( isCtxProp, vmpPropName, newProp );\n                updateTouched( validateName );\n                validateField( validateName, {\n                    [ validateName ]: newProp\n                } );\n            }\n            return Promise.resolve( newProp );\n        } );\n    };\n    const setLovDataValVMO = ( vmoName, propName, isCtxProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n        let uiProperty = isCtxProp ? appCtxSvc.getCtx( propName ) : getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n\n        return performLOVOperation( {\n            uiProperty,\n            vmo: getVMO( vmoName ),\n            lovEntry,\n            dataProvider,\n            createUpdateValue,\n            checkLovEntries,\n            dateApi\n        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n            if( newProp && isPropertyUpdateReqd ) {\n                updateValue( isCtxProp, pathName, newProp );\n                updateTouched( propName );\n                validateField( uiProperty.propertyName, getVMOProps( vmoName ) );\n                return Promise.resolve( newProp );\n            }\n        } );\n    };\n\n    const handleChange = ( name, isCtxProp, index ) => event => {\n        const vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n        if( event.persist ) {\n            event.persist();\n        }\n        let newVMProp = createUpdateValue( vmProp, event );\n        updateValue( isCtxProp, vmPropName, newVMProp );\n        updateTouched( validateName );\n        validateField( validateName, {\n            [ validateName ]: newVMProp\n        } );\n    };\n\n    const setValueForVmo = ( vmoName, propName, isCtxProp ) => ( newVal, additionalProp ) => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n        let updateVal = { ...vmProp };\n        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );\n        updateValue( isCtxProp, pathName, updateVal );\n        updateTouched( propName );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const setValue = ( name, isCtxProp, index ) => ( newVal, additionalProp ) => {\n        const prevVal = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n        let updateVal = { ...prevVal };\n        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );\n        updateValue( isCtxProp, vmPropName, updateVal );\n        // check validity and update Touched\n        updateTouched( validateName );\n        validateField( validateName, {\n            [ validateName ]: updateVal\n        } );\n    };\n\n    const handleChangeVMO = ( vmoName, propName, isCtxProp ) => event => {\n        if( event.persist ) {\n            event.persist();\n        }\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n        updateValue( isCtxProp, pathName, createUpdateValue( vmProp, event ) );\n        updateTouched( propName );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const moveUp = ( prop, index ) => {\n        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n            if( i === index ) {\n                prop.displayValsModel[ i ].selected = false;\n                prop.lastSelected = prop.displayValsModel[ index ];\n            }\n        }\n        prop.lastSelected = null;\n        var currDbVal = prop.dbValue[ index ];\n        var currDisplayVal = prop.displayValues[ index ];\n        var currDisplayValModel = prop.displayValsModel[ index ];\n\n        prop.dbValue.splice( index, 1 );\n        prop.dbValue.splice( index - 1, 0, currDbVal );\n\n        prop.displayValues.splice( index, 1 );\n        prop.displayValues.splice( index - 1, 0, currDisplayVal );\n\n        prop.displayValsModel.splice( index, 1 );\n        prop.displayValsModel.splice( index - 1, 0, currDisplayValModel );\n\n        prop.dirty = true;\n    };\n\n    const moveDown = ( prop, index ) => {\n        index -= 1;\n        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n            if( i === index ) {\n                prop.displayValsModel[ i ].selected = false;\n                prop.lastSelected = prop.displayValsModel[ index ];\n            }\n        }\n        prop.lastSelected = null;\n        var currDbVal = prop.dbValue[ index ];\n        var currDisplayVal = prop.displayValues[ index ];\n        var currDisplayValModel = prop.displayValsModel[ index ];\n        prop.dbValue.splice( index, 1 );\n        prop.dbValue.splice( index + 1, 0, currDbVal );\n\n        prop.displayValues.splice( index, 1 );\n        prop.displayValues.splice( index + 1, 0, currDisplayVal );\n\n        prop.displayValsModel.splice( index, 1 );\n        prop.displayValsModel.splice( index + 1, 0, currDisplayValModel );\n\n        prop.dirty = true;\n    };\n\n    const remove = ( prop, index ) => {\n        index -= 2;\n        prop.dbValue.splice( index, 1 );\n\n        if( prop.hasLov ) {\n            prop.displayValues.splice( index, 1 );\n\n            if( prop.isArray ) {\n                prop.displayValsModel = prop.displayValsModel || [];\n                prop.displayValsModel.splice( index, 1 );\n            }\n        }\n        prop.dirty = true;\n    };\n\n    const handleClick = ( name, isCtxProp, $index ) => event => {\n        let vmProp = _.isNil( $index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, $index, isCtxProp );\n        let vmPropName = _.isNil( $index ) ? name : name + '[' + $index + ']';\n        let validateName = _.isNil( $index ) ? name : name + '_' + $index;\n        let prop = { ...vmProp };\n        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n            let indexStr = event.currentTarget.attributes.id.value;\n            let index = parseInt( indexStr );\n            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n            if( !isButtonClicked ) {\n                let isAnyValueSelected = false;\n                if( prop.displayValsModel ) {\n                    for( var j = 0; j < prop.displayValsModel.length; j++ ) {\n                        if( prop.displayValsModel[ j ].selected && prop.displayValsModel[ j ].isInEditMode ) {\n                            isAnyValueSelected = true;\n                            break;\n                        }\n                    }\n                }\n                if( !isAnyValueSelected ) {\n                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                        prop.autofocus = true;\n                        prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                        prop.displayValsModel[ index ].isInEditMode = true;\n                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                        updateTouched( validateName );\n                        validateField( validateName, {\n                            [ validateName ]: prop\n                        } );\n                    } else {\n                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                            if( i === index && !prop.lastSelected ) {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            } else if( i === index && prop.lastSelected ) {\n                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                    prop.displayValsModel[ i ].selected = false;\n                                    prop.lastSelected = undefined;\n                                } else {\n                                    prop.displayValsModel[ i ].selected = true;\n                                    prop.lastSelected = prop.displayValsModel[ index ];\n                                }\n                            } else {\n                                prop.displayValsModel[ i ].selected = false;\n                            }\n                        }\n                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                        updateTouched( validateName );\n                        event.stopPropagation();\n                    }\n                }\n            } else {\n                let hasActionHappened = false;\n                let titleVal;\n                if( event.currentTarget.attributes.title ) {\n                    titleVal = event.currentTarget.attributes.title.value;\n                }\n                if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                    moveUp( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                    moveDown( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Remove' ) {\n                    remove( prop, index );\n                    hasActionHappened = true;\n                }\n\n                if( hasActionHappened ) {\n                    updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                    updateTouched( validateName );\n                    validateField( validateName, {\n                        [ name ]: prop\n                    } );\n                }\n            }\n        }\n    };\n    const handleClickVMO = ( vmoName, propName, isCtxProp ) => event => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let prop = { ...vmProp };\n        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n            let indexStr = event.currentTarget.attributes.id.value;\n            let index = parseInt( indexStr );\n            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n            if( !isButtonClicked ) {\n                if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                    prop.autofocus = true;\n                    prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                    prop.displayValsModel[ index ].isInEditMode = true;\n\n                    let pathName = vmoName + '.props.' + propName;\n                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );\n                    updateTouched( propName );\n                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n                } else {\n                    for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                        if( i === index && !prop.lastSelected ) {\n                            prop.displayValsModel[ i ].selected = true;\n                            prop.lastSelected = prop.displayValsModel[ index ];\n                        } else if( i === index && prop.lastSelected ) {\n                            if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                prop.displayValsModel[ i ].selected = false;\n                                prop.lastSelected = undefined;\n                            } else {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            }\n                        } else {\n                            prop.displayValsModel[ i ].selected = false;\n                        }\n                    }\n                    event.stopPropagation();\n                }\n            } else {\n                let hasActionHappened = false;\n                let titleVal = event.currentTarget.attributes.title.value;\n                if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                    moveUp( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                    moveDown( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Remove' ) {\n                    remove( prop, index );\n                    hasActionHappened = true;\n                }\n\n                if( hasActionHappened ) {\n                    let pathName = vmoName + '.props.' + propName;\n                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );\n                    updateTouched( propName );\n                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n                }\n            }\n        }\n    };\n\n    const handleBlur = ( name, isCtxProp, index ) => event => {\n        let vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        name = _.isNil( index ) ? name : vmProp.propertyName;\n        if( vmProp.isArray && event.isBlurFromInput ) {\n            //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n            updateArray( vmProp, event );\n        }\n        uwPropertySvc.updateViewModelProperty( vmProp );\n        validateField( name, {\n            [ name ]: vmProp\n        } );\n    };\n\n    const handleBlurVMO = ( vmoName, propName ) => event => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n\n        if( vmProp.isArray && event.isBlurFromInput ) {\n            //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n            updateArray( vmProp, event );\n        }\n        uwPropertySvc.updateViewModelProperty( vmProp );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const isValidArrayValue = ( viewModelProperty, valToUpdate ) => {\n        var isValid = false;\n\n        if( valToUpdate !== undefined && valToUpdate !== '' && valToUpdate !== null &&\n            viewModelProperty.dbValue !== undefined ) {\n            if( viewModelProperty.type === 'INTEGERARRAY' || viewModelProperty.type === 'DOUBLEARRAY' ||\n                viewModelProperty.type === 'DATEARRAY' ) {\n                if( isFinite( valToUpdate ) ) {\n                    isValid = true;\n                }\n            } else if( viewModelProperty.type === 'BOOLEANARRAY' ) {\n                isValid = _.isBoolean( valToUpdate );\n            } else {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n\n    const updateArray = ( prop, event ) => {\n        let indexStr;\n        let index;\n        let valToUpdate;\n        if( prop.type === 'DATEARRAY' ) {\n            index = event.index;\n            valToUpdate = new Date( event.target.value );\n        } else {\n            if( prop.type === 'BOOLEANARRAY' && prop.renderingHint === 'radiobutton' ) {\n                if( event.target.defaultValue === 'true' ) {\n                    valToUpdate = true;\n                } else if( event.target.defaultValue === 'false' ) {\n                    valToUpdate = false;\n                }\n                index = event.index;\n            } else if( prop.type === 'BOOLEANARRAY' ) {\n                valToUpdate = event.target.checked;\n                index = event.index;\n            } else {\n                indexStr = event.currentTarget.attributes.id.value;\n                index = parseInt( indexStr );\n                valToUpdate = event.currentTarget.value;\n            }\n        }\n        if( isValidArrayValue( prop, valToUpdate ) && ( !prop.error || prop.hasServerValidationError ) ) {\n            if( prop.currArrayDbValue ) {\n                prop.currArrayDbValue.splice( index, 1, valToUpdate );\n                prop.dirty = true;\n                prop.dbValue = prop.currArrayDbValue.slice( 0 );\n            }\n        } else if( prop.dbValue === '' || prop.dbValue === null || prop.dbValue === undefined ) {\n            prop.dbValue = prop.currArrayDbValue.slice( 0 );\n        }\n\n        if( prop.displayValsModel[ index ] && prop.dbValue.length > 0 ) {\n            prop.displayValsModel[ index ].displayValue = prop.dbValue[ index ];\n            prop.displayValsModel[ index ].isInEditMode = false;\n            prop.displayValsModel[ index ].selected = false;\n        }\n        prop.lastSelected = undefined;\n    };\n\n    const createNewArrayVal = ( newVal, updateVal, event ) => {\n        if( updateVal.type === 'DATEARRAY' ) {\n            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {\n                _.forEach( updateVal.dbValue, function( value ) {\n                    if( value !== undefined && value !== '' ) {\n                        newVal.push( value );\n                    }\n                } );\n                if( event.target.value ) {\n                    newVal.push( new Date( event.target.value ) );\n                }\n            } else if( event.target.value ) {\n                newVal.push( new Date( event.target.value ) );\n            }\n        } else {\n            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {\n                _.forEach( updateVal.dbValue, function( value ) {\n                    if( value !== undefined && value !== '' ) {\n                        newVal.push( value );\n                    }\n                } );\n            }\n            if( event.target.value && updateVal.type !== 'BOOLEANARRAY' ) {\n                newVal.push( event.target.value );\n            }\n            if( event.target.value && updateVal.type === 'BOOLEANARRAY' && updateVal.renderingHint === 'radiobutton' ) {\n                newVal.push( event.target.value );\n            }\n            if( event.key === 'Enter' && updateVal.type === 'BOOLEANARRAY' && event.target.checked !== undefined && updateVal.renderingHint !== 'radiobutton' ) {\n                newVal.push( event.target.checked );\n            }\n        }\n    };\n\n    const createUpdateValue = ( prevVal, event ) => {\n        let updateVal = { ...prevVal };\n\n        if( prevVal.type.toUpperCase() === 'DATEARRAY' && event.target.value === null ) {\n            return updateVal;\n        }\n\n        let newVal;\n        switch ( prevVal.type.toUpperCase() ) {\n            case 'DATE':\n                newVal = event.target.value ? Number( new Date( event.target.value ) ) : NULLDATE;\n                break;\n            case 'BOOLEAN':\n                if( event.target.type === 'radio' ) {\n                    newVal = event.target.value === 'true';\n                } else {\n                    newVal = event.target.checked;\n                }\n                break;\n            case 'INTEGER':\n                newVal = event.target.value.replace( /[^\\+|\\-|0-9]/g, '' );\n                break;\n            case 'DOUBLE':\n                newVal = event.target.value.replace( /[^\\+|\\-|0-9\\.|e]/g, '' );\n                break;\n            case 'DATETIME':\n                newVal = new Date( event.target.value ).toLocaleTimeString();\n                break;\n            case 'OBJECT':\n                newVal = Array.isArray( event.target.value ) && event.target.value.length > 0 ? event.target.value[ 0 ] : '';\n                break;\n            case 'OBJECTARRAY':\n                if( !updateVal.hasLov ) {\n                    newVal = _.clone( prevVal.dbValue );\n                    _.forEach( event.target.value, function( value ) {\n                        if( value !== undefined && value !== '' ) {\n                            newVal.push( value );\n                        }\n                    } );\n                } else {\n                    newVal = [];\n                    if( event.updateArray ) {\n                        updateArray( updateVal, event );\n                        _.forEach( updateVal.dbValue, function( value ) {\n                            if( value !== undefined && value !== '' ) {\n                                newVal.push( value );\n                            }\n                        } );\n                    } else {\n                        createNewArrayVal( newVal, updateVal, event );\n                    }\n                }\n                break;\n            case 'DOUBLEARRAY':\n            case 'DATEARRAY':\n            case 'INTEGERARRAY':\n            case 'STRINGARRAY':\n            case 'CHECKBOXARRAY':\n            case 'BOOLEANARRAY': {\n                newVal = [];\n                if( event.updateArray ) {\n                    updateArray( updateVal, event );\n                    _.forEach( updateVal.dbValue, function( value ) {\n                        if( value !== undefined && value !== '' ) {\n                            newVal.push( value );\n                        }\n                    } );\n                } else {\n                    createNewArrayVal( newVal, updateVal, event );\n                }\n                break;\n            }\n            default:\n                newVal = event.target.value;\n        }\n        uwPropertySvc.setValue( updateVal, newVal );\n        return updateVal;\n    };\n\n    const getVMO = ( vmoName, isCtxProp ) => {\n        const lData = isCtxProp ? ctx : viewModel.getData();\n        const vmo = _.get( lData, vmoName );\n        if( vmo ) {\n            return vmo;\n        }\n        return undefined;\n    };\n\n    const getAutofocusVMO = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.autofocus;\n        }\n        return undefined;\n    };\n\n    const getAutofocus = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.autofocus;\n    };\n\n    const getVMOProps = ( vmoName ) => {\n        let vmo = getVMO( vmoName );\n        if( vmo && vmo.props ) {\n            return vmo.props;\n        }\n        return undefined;\n    };\n\n    const getVMPropForVMO = ( vmoName, propName ) => {\n        let vmo = getVMO( vmoName );\n        if( vmo && vmo.props && vmo.props[ propName ] ) {\n            return vmo.props[ propName ];\n        }\n        return undefined;\n    };\n\n    const getValueVMO = ( vmProp ) => {\n        if( vmProp && vmProp.type === 'BOOLEAN' ) {\n            if( vmProp.dbValue === '' ) {\n                return undefined;\n            }\n\n            if( declUtils.isNil( vmProp.dbValue ) ) {\n                return null;\n            }\n\n            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';\n        }\n        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';\n    };\n\n    const getValue = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && vmProp.type === 'BOOLEAN' ) {\n            if( vmProp.dbValue === '' ) {\n                return undefined;\n            }\n            if( declUtils.isNil( vmProp.dbValue ) ) {\n                return null;\n            }\n\n            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';\n        }\n        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';\n    };\n\n    const getTouched = name => {\n        let touchedState = getTouchedState();\n        return touchedState[ name ] ? 'true' : 'false';\n    };\n\n    const getErrorsVMPArray = function( name, index ) {\n        let errors = getErrorsState();\n        let isTouched = getTouched( name + '_' + index );\n        return isTouched === 'true' ? errors[ name + '_' + index ] : undefined;\n    };\n\n    const getErrors = function( name, rootPath, path ) {\n        let errors = getErrorsState();\n        if( !_.isNil( rootPath ) ) {\n            let atomicPath = rootPath + '.' + path;\n            atomicPath = atomicPath.replace( /\\./g, '_' );\n            atomicPath = atomicPath.replace( /\\[/g, '_' );\n            atomicPath = atomicPath.replace( /\\]/g, '' );\n            let isTouched = getTouched( atomicPath );\n            return isTouched === 'true' ? errors[ atomicPath ] : undefined;\n        }\n        let isTouched = getTouched( name );\n        return isTouched === 'true' ? errors[ name ] : undefined;\n    };\n\n    const getAtomicVmProp = ( name, isCtxProp, index, isAtomic = false, viewProp = null ) => {\n        let vmProp;\n        if( isAtomic && viewProp ) {\n            vmProp = viewProp;\n        } else {\n            vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        }\n        return vmProp;\n    };\n\n    const getPropertyDisplayName = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';\n        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n    };\n\n    const getPropertyDisplayNameVMO = ( vmProp ) => {\n        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';\n        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n    };\n\n    const getPlaceHolder = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        let placeholder = '';\n        if( !vmProp ) {\n            return placeholder;\n        }\n        let propertyType = getPropertyType( name, isCtxProp, index );\n        switch ( propertyType && propertyType.toUpperCase() ) {\n            case 'DATEARRAY':\n            case 'DATE':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n                break;\n            default:\n                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else {\n                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n                }\n        }\n        return placeholder;\n    };\n\n    const getPlaceHolderVMO = ( vmProp ) => {\n        let placeholder = '';\n        if( !vmProp ) {\n            return placeholder;\n        }\n        let propertyType = vmProp.type;\n        switch ( propertyType && propertyType.toUpperCase() ) {\n            case 'DATEARRAY':\n            case 'DATETIME':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY HH:mm' : '';\n                break;\n            case 'DATE':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n                break;\n            case 'TIME':\n                placeholder = vmProp.isEditable ? 'HH:mm:ss' : '';\n                break;\n            default:\n                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else {\n                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n                }\n        }\n        return placeholder;\n    };\n\n    const getUIValue = ( name, isCtxProp, index, isAtomic, viewProp, key = 'uiValue' ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp[ key ];\n    };\n\n    const getUIValueVMO = ( vmProp, key = 'uiValue' ) => {\n        if( vmProp ) {\n            return vmProp[ key ];\n        }\n        return undefined;\n    };\n\n    const getRenderingHint = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.renderingHint;\n    };\n\n    const getRenderingHintVMO = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.renderingHint;\n        }\n        return undefined;\n    };\n\n    const getPropertyType = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {\n            return 'DATETIME';\n        }\n        return vmProp && vmProp.type;\n    };\n\n    const getPropertyTypeVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {\n            return 'DATETIME';\n        }\n        return vmProp && vmProp.type;\n    };\n\n    const getRequired = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.isRequired;\n    };\n\n    const getRequiredVMO = ( vmProp ) => {\n        return vmProp && vmProp.isRequired;\n    };\n\n    const getMaxLength = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.maxLength;\n    };\n\n    const getMaxLengthVMO = ( vmProp ) => {\n        return vmProp && vmProp.maxLength;\n    };\n\n    const getPropertyRadioTrueText = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioTrueTextVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioFalseText = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioFalseTextVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n        }\n        return undefined;\n    };\n\n    const getDisplayValsModel = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||\n                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||\n                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {\n            return vmProp.displayValsModel;\n        }\n        return undefined;\n    };\n\n    const getDisplayValsModelVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||\n                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||\n                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {\n            return vmProp.displayValsModel;\n        }\n        return undefined;\n    };\n\n    const getDateApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {\n            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {\n                uwPropertySvc.initializeDateApiValues( vmProp );\n            }\n            return vmProp.dateApi;\n        }\n        return undefined;\n    };\n\n    const getDateApiVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {\n            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {\n                uwPropertySvc.initializeDateApiValues( vmProp );\n            }\n            return vmProp.dateApi;\n        }\n        return undefined;\n    };\n\n    const getIsLov = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.hasLov;\n    };\n    const getIsLovVMO = ( vmProp ) => {\n        return vmProp && vmProp.hasLov;\n    };\n\n    const getLovApiVMO = ( vmProp ) => {\n        return vmProp && vmProp.lovApi;\n    };\n\n    const getDataProvider = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( !vmProp ) {\n            return undefined;\n        }\n\n        // case dynamic dataProvider\n        if( _.isFunction( vmProp.dataProvider ) ) {\n            return vmProp.dataProvider();\n        }\n\n        return vmProp.dataProvider && dataProviders && dataProviders[ vmProp.dataProvider ] ? dataProviders[ vmProp.dataProvider ] : null;\n    };\n\n    const getDataProviderVMO = ( vmProp ) => {\n        return vmProp && vmProp.dataProvider;\n    };\n\n    const getIsArray = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.isArray;\n    };\n\n    const getIsArrayVMO = ( vmProp ) => {\n        return vmProp && vmProp.isArray;\n    };\n\n    const getLovApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && vmProp.lovApi ) {\n            return vmProp.lovApi;\n        }\n        return null;\n    };\n\n    const getEditArrayInlineMode = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.editArrayInlineMode;\n    };\n\n    const getEditArrayInlineModeVMO = ( vmProp ) => {\n        return vmProp && vmProp.editArrayInlineMode;\n    };\n\n    const getNumberOfLines = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.numberOfLines;\n    };\n\n    const getNumberOfLinesVMO = ( vmProp ) => {\n        return vmProp && vmProp.numberOfLines;\n    };\n\n    // compute the label position\n    // the precedence is like this:\n    // 1. class in view (sw-row / sw-column / sw-reverse)\n    // 2. v-m prop.labelPosition\n    // 3. boolean and object use label at end\n    // 4. editable props use label at top\n    const getLabelPlacement = ( vmProp ) => {\n        var labelPlacement = '';\n\n        if( !vmProp ) {\n            return labelPlacement;\n        }\n\n        // get rid of editLayoutSide and consolidate positioning here?\n        // revisitMe ulrey. discuss with Nihar?\n        switch ( vmProp.propertyLabelDisplay ) {\n            case 'PROPERTY_LABEL_AT_RIGHT':\n                labelPlacement = 'end';\n                break;\n            case 'PROPERTY_LABEL_AT_TOP':\n                labelPlacement = 'top';\n                break;\n            case 'PROPERTY_LABEL_AT_SIDE':\n                labelPlacement = 'start';\n                break;\n            case 'NO_PROPERTY_LABEL':\n                // revistMe scott: is <aw-widget labeldisplay=\"Headless\"> also supported?\n                labelPlacement = 'none';\n                break;\n            default:\n                labelPlacement = 'default';\n        }\n        return labelPlacement;\n    };\n\n    const getLabelPlacementFromData = ( propName, vmoName, index, isAtomic = false, viewProp ) => {\n        const vmProp = isAtomic && viewProp ? viewProp : vmoName ? getVMPropForVMO( vmoName, propName ) : !declUtils.isNil( index ) ? data[ propName ][ index ] : data[ propName ];\n        return getLabelPlacement( vmProp );\n    };\n\n    /**\n     * Check if prop is dirty\n     * if uncommitted value changes, but is reverted: dirty=false\n     * @param {object} vmProp view model property\n     * @returns {boolean} true if prop is dirty\n     */\n    const dirtyCheck = ( vmProp ) => {\n        // deal with case where null !== emptystring if( vmProp.valueUpdated || vmProp.displayValueUpdated ) {\n        if( _.isNil( vmProp.value ) && _.isNil( vmProp.newValue ) ) {\n            return false;\n        }\n        return ( vmProp.valueUpdated || vmProp.displayValueUpdated ) && !_.isEqual( vmProp.value, vmProp.newValue );\n    };\n\n    /**\n     * Check if prop is dirty\n     * @param {string} name property namne\n     * @param {boolean} isCtxProp is prop from ctx (optional)\n     * @returns {boolean} true if prop is dirty / undefined if clean\n     */\n    const isPropDirty = ( name, isCtxProp, index, isAtomic = false, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && dirtyCheck( vmProp ) ) {\n            return 'true';\n        }\n        return undefined;\n    };\n\n    /**\n     * Check if vmo prop is dirty\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} true if prop is dirty / undefined if clean\n     */\n    const isPropDirtyVMO = ( vmProp ) => {\n        if( vmProp && dirtyCheck( vmProp ) ) {\n            return 'true';\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets pattern for VMO\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {object} patterns object\n     */\n    const getPatterns = ( vmProp ) => {\n        if( vmProp && vmProp.patterns ) {\n            return vmProp.patterns;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets preferred pattern\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {string} preferred patterns value\n     */\n    const getPreferredPattern = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.preferredPattern;\n        }\n        return undefined;\n    };\n\n    const getPreferredPatternVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.preferredPattern;\n        }\n        return undefined;\n    };\n\n    const getAutoAssignVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    const getAutoAssignableVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.isAutoAssignable;\n        }\n        return undefined;\n    };\n\n    const getPatternAutoAssignFlagsVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.patternAutoAssignFlags;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets isAutoAssign boolean value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} isAutoAssign bool value\n     */\n    const getIsAutoAssign = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    const getIsAutoAssignVMPArray = ( propName, isCtxProp, index ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index );\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets isAutoAssignable boolean value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} isAutoAssignable bool value\n     */\n    const getIsAutoAssignable = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.isAutoAssignable;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets patternAutoAssignFlags value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {object} PatternAutoAssignFlags object\n     */\n    const getPatternAutoAssignFlags = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.patternAutoAssignFlags;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets parent uid\n     * @param {string} vmoName view-model object name\n     * @param {string} vmProp property name\n     * @param {boolean} isCtxProp property name\n     * @returns {string} parent uid\n     */\n    const getParentUid = ( vmoName, vmProp, isCtxProp ) => {\n        if( vmProp && ( vmProp.patterns || vmProp.patternAutoAssignFlags ) ) {\n            const vmo = getVMO( vmoName, isCtxProp );\n            return vmo && vmo.uid ? vmo.uid : undefined;\n        }\n        return undefined;\n    };\n\n    const handleReset = () => {\n        // revisitme - spond\n        // HINT: In reset case, we need to consider all extra data we put in data store rather than\n        // reset the whole data store to data def\n        updateData( { value: { ...data, ...createData( { i18n } ) } } );\n        setTouched( {} );\n        updateErrors( {} );\n        setFormValidity( getStateCollection( viewModel ) );\n    };\n\n    const getAction = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;\n    };\n\n    const getActionVMO = ( vmProp ) => {\n        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;\n    };\n\n    const constructFieldForNamedPropertyVMO = ( vmoName, propName, isCtxProp = null ) => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        return {\n            name: propName,\n            onChange: handleChangeVMO( vmoName, propName, isCtxProp ),\n            onBlur: handleBlurVMO( vmoName, propName ),\n            onClick: handleClickVMO( vmoName, propName, isCtxProp ),\n            value: getValueVMO( vmProp ),\n            checked: getValueVMO( vmProp ),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayNameVMO( vmProp ),\n            typex: getPropertyTypeVMO( vmProp ),\n            error: getErrors( propName ),\n            required: getRequiredVMO( vmProp ),\n            maxLength: getMaxLengthVMO( vmProp ),\n            placeholder: getPlaceHolderVMO( vmProp ),\n            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n            dirty: isPropDirtyVMO( vmProp ),\n            'data-locator': getPropertyDisplayNameVMO( vmProp ),\n            'aria-label': getPropertyDisplayNameVMO( vmProp ),\n            'aria-required': getRequiredVMO( vmProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            setLovVal: setLovDataValVMO( vmoName, propName, isCtxProp ),\n            vmo: getVMO( vmoName, isCtxProp ),\n            update: setValueForVmo( vmoName, propName, isCtxProp ),\n            autoFocus: getAutofocusVMO( vmProp ),\n            __vmprop__: () => vmProp,\n            fielddata: {\n                uiValue: getUIValueVMO( vmProp ),\n                uiValues: getUIValueVMO( vmProp, 'uiValues' ),\n                oldValue: getUIValueVMO( vmProp, 'oldValue' ),\n                oldValues: getUIValueVMO( vmProp, 'oldValues' ),\n                displayValues: getUIValueVMO( vmProp, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                isEnabled: vmProp && vmProp.isEnabled,\n                isSelectOnly: vmProp && vmProp.isSelectOnly,\n                isEditable: vmProp && vmProp.isEditable,\n                isLocalizable: vmProp && vmProp.isLocalizable,\n                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayNameVMO( vmProp ),\n                labelPlacement: getLabelPlacement( vmProp ),\n                renderingHint: getRenderingHintVMO( vmProp ),\n                propertyRadioTrueText: getPropertyRadioTrueTextVMO( vmProp ),\n                propertyRadioFalseText: getPropertyRadioFalseTextVMO( vmProp ),\n                radioVertical: vmProp && vmProp.vertical,\n                displayValsModel: getDisplayValsModelVMO( vmProp ),\n                numberOfLines: getNumberOfLinesVMO( vmProp ),\n                dateApi: getDateApiVMO( vmProp ),\n                isArray: getIsArrayVMO( vmProp ),\n                hasLov: getIsLovVMO( vmProp ),\n                dataProvider: getDataProviderVMO( vmProp ),\n                editArrayInlineMode: getEditArrayInlineModeVMO( vmProp ),\n                isRichText: vmProp && vmProp.isRichText,\n                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry,\n                patterns: getPatterns( vmProp ),\n                preferredPattern: getPreferredPattern( vmProp ),\n                lovApi: getLovApiVMO( vmProp ),\n                action: getActionVMO( vmProp ),\n                destPanelId: vmProp && vmProp.destPanelId,\n                iconName: vmProp && vmProp.iconName,\n                iconSource: vmProp && vmProp.iconSource,\n                tooltip: vmProp && vmProp.tooltip,\n                isAutoAssign: getIsAutoAssign( vmProp ),\n                isAutoAssignable: getIsAutoAssignable( vmProp ),\n                parentUid: getParentUid( vmoName, vmProp, isCtxProp ),\n                propertyName: propName,\n                patternAutoAssignFlags: getPatternAutoAssignFlags( vmProp ),\n                hasRevRuleAttached: vmProp && vmProp.hasRevRuleAttached\n            }\n        };\n    };\n\n    const constructFieldForNamedProperty = ( propName, isCtxProp = null ) => {\n        const vmProp = getVmProp( isCtxProp, propName );\n        return {\n            name: propName,\n            onChange: handleChange( propName, isCtxProp ),\n            onBlur: handleBlur( propName, isCtxProp ),\n            onClick: handleClick( propName, isCtxProp ),\n            value: getValue( propName, isCtxProp ),\n            checked: getValue( propName, isCtxProp ),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayName( propName, isCtxProp ),\n            typex: getPropertyType( propName, isCtxProp ),\n            error: getErrors( propName ),\n            required: getRequired( propName, isCtxProp ),\n            maxLength: getMaxLength( propName, isCtxProp ),\n            placeholder: getPlaceHolder( propName, isCtxProp ),\n            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n            dirty: isPropDirty( propName, isCtxProp ),\n            'data-locator': getPropertyDisplayName( propName, isCtxProp ),\n            'aria-label': getPropertyDisplayName( propName, isCtxProp ),\n            'aria-required': getRequired( propName, isCtxProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            setLovVal: setLovDataVal( propName, isCtxProp ),\n            update: setValue( propName, isCtxProp ),\n            autoFocus: getAutofocus( propName, isCtxProp ),\n            __vmprop__: () => vmProp,\n            fielddata: {\n                uiValue: getUIValue( propName, isCtxProp ),\n                uiValues: getUIValue( propName, isCtxProp, null, false, null, 'uiValues' ),\n                displayValues: getUIValue( propName, isCtxProp, null, false, null, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                isEnabled: vmProp && vmProp.isEnabled,\n                isSelectOnly: vmProp && vmProp.isSelectOnly,\n                isEditable: vmProp && vmProp.isEditable,\n                isLocalizable: vmProp && vmProp.isLocalizable,\n                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp ),\n                labelPlacement: getLabelPlacementFromData( propName, isCtxProp ),\n                renderingHint: getRenderingHint( propName, isCtxProp ),\n                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp ),\n                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp ),\n                radioVertical: vmProp && vmProp.vertical,\n                displayValsModel: getDisplayValsModel( propName, isCtxProp ),\n                numberOfLines: getNumberOfLines( propName, isCtxProp ),\n                dateApi: getDateApi( propName, isCtxProp ),\n                isArray: getIsArray( propName, isCtxProp ),\n                hasLov: getIsLov( propName, isCtxProp ),\n                dataProvider: getDataProvider( propName, isCtxProp ),\n                lovApi: getLovApi( propName, isCtxProp ),\n                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp ),\n                action: getAction( propName, isCtxProp ),\n                iconName: vmProp && vmProp.iconName,\n                iconSource: vmProp && vmProp.iconSource,\n                tooltip: vmProp && vmProp.tooltip,\n                parentUid: undefined,\n                propertyName: propName,\n                patterns: vmProp && vmProp.patterns,\n                preferredPattern: vmProp && vmProp.preferredPattern,\n                isAutoAssign: vmProp && vmProp.isAutoAssign,\n                destPanelId: vmProp && vmProp.destPanelId,\n                isRichText: vmProp && vmProp.isRichText,\n                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n            }\n        };\n    };\n\n    const constructFieldArrayOfNamedProperty = ( vmPropList, propName, isCtxProp = null ) => {\n        let vmpFieldArray = [];\n        _.forEach( vmPropList, function( value, index ) {\n            if( value !== undefined && value !== '' ) {\n                const vmProp = getVmPropFromList( propName, index, isCtxProp );\n                let obj = {\n                    name: vmProp.propertyName,\n                    onChange: handleChange( propName, isCtxProp, index ),\n                    onBlur: handleBlur( propName, isCtxProp, index ),\n                    onClick: handleClick( propName, isCtxProp, index ),\n                    value: getValue( propName, isCtxProp, index ),\n                    checked: getValue( propName, isCtxProp, index ),\n                    touched: getTouched( vmProp.propertyName ),\n                    label: getPropertyDisplayName( propName, isCtxProp, index ),\n                    typex: getPropertyType( propName, isCtxProp, index ),\n                    error: getErrorsVMPArray( propName, index ),\n                    required: getRequired( propName, isCtxProp, index ),\n                    maxLength: getMaxLength( propName, isCtxProp, index ),\n                    placeholder: getPlaceHolder( propName, isCtxProp, index ),\n                    disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n                    dirty: isPropDirty( propName, isCtxProp, index ),\n                    'data-locator': getPropertyDisplayName( propName, isCtxProp, index ),\n                    'aria-label': getPropertyDisplayName( propName, isCtxProp, index ),\n                    'aria-required': getRequired( propName, isCtxProp,\n                        index ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n                    setLovVal: setLovDataVal( propName, isCtxProp, index ),\n                    update: setValue( propName, isCtxProp, index ),\n                    autoFocus: getAutofocus( propName, isCtxProp, index ),\n                    __vmprop__: () => vmProp,\n                    fielddata: {\n                        uiValue: getUIValue( propName, isCtxProp, index ),\n                        uiValues: getUIValue( propName, isCtxProp, index, false, null, 'uiValues' ),\n                        displayValues: getUIValue( propName, isCtxProp, index, false, null, 'displayValues' ),\n                        convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                        isEnabled: vmProp && vmProp.isEnabled,\n                        isSelectOnly: vmProp && vmProp.isSelectOnly,\n                        isEditable: vmProp && vmProp.isEditable,\n                        isLocalizable: vmProp && vmProp.isLocalizable,\n                        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                        propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, index ),\n                        labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index ),\n                        renderingHint: getRenderingHint( propName, isCtxProp, index ),\n                        propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index ),\n                        propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index ),\n                        radioVertical: vmProp && vmProp.vertical,\n                        displayValsModel: getDisplayValsModel( propName, isCtxProp, index ),\n                        numberOfLines: getNumberOfLines( propName, isCtxProp, index ),\n                        dateApi: getDateApi( propName, isCtxProp, index ),\n                        isArray: getIsArray( propName, isCtxProp, index ),\n                        hasLov: getIsLov( propName, isCtxProp, index ),\n                        dataProvider: getDataProvider( propName, isCtxProp, index ),\n                        lovApi: getLovApi( propName, isCtxProp, index ),\n                        editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index ),\n                        action: getAction( propName, isCtxProp, index ),\n                        iconName: vmProp && vmProp.iconName,\n                        iconSource: vmProp && vmProp.iconSource,\n                        tooltip: vmProp && vmProp.tooltip,\n                        destPanelId: vmProp && vmProp.destPanelId,\n                        isRichText: vmProp && vmProp.isRichText,\n                        patterns: vmProp && vmProp.patterns,\n                        preferredPattern: vmProp && vmProp.preferredPattern,\n                        isAutoAssign: getIsAutoAssignVMPArray( propName, isCtxProp, index ),\n                        parentUid: undefined,\n                        propertyName: propName,\n                        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n                    }\n                };\n                vmpFieldArray.push( obj );\n            }\n        } );\n        return vmpFieldArray;\n    };\n\n    /**\n     *\n     * @param { string } path pathofAtomicData\n     * @param { string } rootPath RootPath\n     * @returns {object} partialObj\n     */\n    const createPartialField = ( path, rootPath ) => {\n        return {\n            get value() {\n                return this.getValue();\n            },\n            getValue: () => {\n                let rootObject = atomicDataRef[ rootPath ].getAtomicData();\n                return path === '' ? rootObject : _.get( rootObject, path );\n            },\n            update: ( value ) => {\n                let rootObject = atomicDataRef[ rootPath ].getAtomicData();\n                if( path === '' ) {\n                    rootObject = value;\n                } else {\n                    _.set( rootObject, path, { ...value } );\n                }\n                atomicDataRef[ rootPath ].setAtomicData( _.clone( rootObject ) );\n                let atomicDataVmpCollection = filterFlatViewModelPropForAtomic( viewModel );\n                if( Object.keys( atomicDataVmpCollection ).length > 0 ) {\n                    let dataVmpCollection = filterFlatViewModelProps( viewModel.getData() );\n                    let stateCollection = { ...dataVmpCollection, ...atomicDataVmpCollection };\n                    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );\n                    setFormValidity( stateCollection );\n                }\n            }\n        };\n    };\n\n    /**\n     *\n     * @param {*} path String\n     * @param {*} rootPath  String\n     * @param {*} fieldType  String\n     * @returns\n     */\n    const createFieldForAtomicData = ( path, rootPath, fieldType ) => {\n        if( fieldType === 'partialField' ) {\n            return createPartialField( path, rootPath );\n        }\n        return constructFieldForAtomicProperty( path, rootPath, fieldType );\n    };\n    /**\n     * @param {*} path The path of partial state object with respect to state object\n     * @param {*} rootPath  The root name of the state object\n     * @param {*} fieldType The type of the field defined in meta\n     * @returns { object }-\n     */\n    const constructFieldForAtomicProperty = ( path, rootPath, fieldType ) => {\n        let rootObject = viewModel.atomicData[ rootPath ];\n        let stateObj = _.get( rootObject, path );\n        const propName = path.split( '.' )[ path.split( '.' ).length - 1 ];\n        let viewProp = null;\n        const vmo = { ...stateObj, props: {} };\n\n        let prevFieldsRef = fieldsRef.current;\n        let prevFieldObject = _.get( prevFieldsRef, rootPath + '.' + path, null );\n\n        if( fieldType === 'viewModelObject' && stateObj && stateObj.props ) {\n            Object.keys( stateObj.props ).forEach( ( propertyName ) => {\n                viewProp = stateObj.props[ propertyName ];\n                let prevField = prevFieldObject && prevFieldObject.props && prevFieldObject.props[ propertyName ];\n                let path1 = `${path}.props.${propertyName}`;\n                let newField = creatAtomicFields( propertyName, rootPath, viewProp, path1, fieldType, stateObj );\n                if( isFieldsEqual( prevField, newField ) ) {\n                    vmo.props[ propertyName ] = prevField;\n                } else {\n                    vmo.props[ propertyName ] = newField;\n                }\n            } );\n            return vmo;\n        } else if( fieldType === 'ViewModelProperty' ) {\n            viewProp = stateObj;\n        } else {\n            viewProp = modelPropertySvc.createViewModelProperty( { ...stateObj, propName, type: fieldType } );\n        }\n        let newFieldObject = creatAtomicFields( propName, rootPath, viewProp, path, fieldType );\n        if( isFieldsEqual( prevFieldObject, newFieldObject ) ) {\n            return prevFieldObject;\n        }\n        return newFieldObject;\n    };\n\n    const creatAtomicFields = ( propName, rootPath, viewProp, path, fieldType, vmo = null,\n        isCtxProp = false, index = null, isAtomic = true ) => {\n        const updateAtomicData = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            if( event.persist ) {\n                event.persist();\n            }\n            if( event.additionalProp ) {\n                uwPropertySvc.updateViewModelProp( viewProp, null, event.additionalProp, false );\n            }\n            viewProp = createUpdateValue( viewProp, event );\n            // This is required to do later instance check.\n            // Mutating the object directly is not a good idea.\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                _.set( rtObj, `${atomicPath}`, { ...viewProp } );\n            } else {\n                let val1 = _.get( rtObj, `${atomicPath}.value` );\n                let val2 = _.get( rtObj, `${atomicPath}.value` );\n                if( val1 === viewProp.dbValue && val2 === viewProp.dbValue ) {\n                    return;\n                }\n                _.set( rtObj, `${atomicPath}.value`, viewProp.dbValue );\n                _.set( rtObj, `${atomicPath}.dbValue`, viewProp.dbValue );\n            }\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                let atPath = rootPath + '.' + atomicPath;\n                atPath = atPath.replace( /\\./g, '_' );\n                atPath = atPath.replace( /\\[/g, '_' );\n                atPath = atPath.replace( /\\]/g, '' );\n                validateField( atPath, {\n                    [ atPath ]: viewProp\n                } );\n                updateTouched( atPath );\n            }\n            atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n        };\n        const getValue = () => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            return _.get( rtObj, `${atomicPath}.dbValue` );\n        };\n\n        const handleBlurAtomic = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let vmProp = _.get( rtObj, `${atomicPath}` );\n\n            if( vmProp.isArray && event.isBlurFromInput ) {\n                //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n                //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n                updateArray( vmProp, event );\n            }\n            uwPropertySvc.updateViewModelProperty( vmProp );\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                let atPath = rootPath + '.' + atomicPath;\n                atPath = atPath.replace( /\\./g, '_' );\n                atPath = atPath.replace( /\\[/g, '_' );\n                atPath = atPath.replace( /\\]/g, '' );\n                validateField( atPath, {\n                    [ atPath ]: vmProp\n                } );\n            }\n        };\n\n        const handleClickAtomic = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let vmProp = _.get( rtObj, `${atomicPath}` );\n            let prop = { ...vmProp };\n            if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n                let indexStr = event.currentTarget.attributes.id.value;\n                let index = parseInt( indexStr );\n                let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n                if( !isButtonClicked ) {\n                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                        prop.autofocus = true;\n                        prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                        prop.displayValsModel[ index ].isInEditMode = true;\n\n                        let newProp = createUpdateValue( prop, event );\n\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                        } else {\n                            let val1 = _.get( rtObj, `${atomicPath}.value` );\n                            let val2 = _.get( rtObj, `${atomicPath}.value` );\n                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                                return;\n                            }\n                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                        }\n                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            let atPath = rootPath + '.' + atomicPath;\n                            atPath = atPath.replace( /\\./g, '_' );\n                            atPath = atPath.replace( /\\[/g, '_' );\n                            atPath = atPath.replace( /\\]/g, '' );\n                            validateField( atPath, {\n                                [ atPath ]: newProp\n                            } );\n                            updateTouched( atPath );\n                        }\n                    } else {\n                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                            if( i === index && !prop.lastSelected ) {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            } else if( i === index && prop.lastSelected ) {\n                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                    prop.displayValsModel[ i ].selected = false;\n                                    prop.lastSelected = undefined;\n                                } else {\n                                    prop.displayValsModel[ i ].selected = true;\n                                    prop.lastSelected = prop.displayValsModel[ index ];\n                                }\n                            } else {\n                                prop.displayValsModel[ i ].selected = false;\n                            }\n                        }\n                        event.stopPropagation();\n                    }\n                } else {\n                    let hasActionHappened = false;\n                    let titleVal = event.currentTarget.attributes.title.value;\n                    if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                        moveUp( prop, index );\n                        hasActionHappened = true;\n                    }\n                    if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                        moveDown( prop, index );\n                        hasActionHappened = true;\n                    }\n                    if( titleVal && titleVal === 'Remove' ) {\n                        remove( prop, index );\n                        hasActionHappened = true;\n                    }\n\n                    if( hasActionHappened ) {\n                        let newProp = createUpdateValue( prop, event );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                        } else {\n                            let val1 = _.get( rtObj, `${atomicPath}.value` );\n                            let val2 = _.get( rtObj, `${atomicPath}.value` );\n                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                                return;\n                            }\n                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                        }\n                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            let atPath = rootPath + '.' + atomicPath;\n                            atPath = atPath.replace( /\\./g, '_' );\n                            atPath = atPath.replace( /\\[/g, '_' );\n                            atPath = atPath.replace( /\\]/g, '' );\n                            validateField( atPath, {\n                                [ atPath ]: newProp\n                            } );\n                            updateTouched( atPath );\n                        }\n                    }\n                }\n            }\n        };\n\n        const setLovDataValAtomic = ( propName, isCtxProp, index, isAtomic, viewProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let uiProperty = _.get( rtObj, `${atomicPath}` );\n\n            return performLOVOperation( {\n                uiProperty,\n                vmo: vmo,\n                lovEntry,\n                dataProvider,\n                createUpdateValue,\n                checkLovEntries,\n                dateApi\n            }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n                if( newProp && isPropertyUpdateReqd ) {\n                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                        _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                    } else {\n                        let val1 = _.get( rtObj, `${atomicPath}.value` );\n                        let val2 = _.get( rtObj, `${atomicPath}.value` );\n                        if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                            return;\n                        }\n                        _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                        _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                    }\n                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                        let atPath = rootPath + '.' + atomicPath;\n                        atPath = atPath.replace( /\\./g, '_' );\n                        atPath = atPath.replace( /\\[/g, '_' );\n                        atPath = atPath.replace( /\\]/g, '' );\n                        validateField( atPath, {\n                            [ atPath ]: newProp\n                        } );\n                        updateTouched( atPath );\n                    }\n                    atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                }\n                return newProp;\n            } );\n        };\n        return {\n            name: propName,\n            onChange: ( event ) => {\n                updateAtomicData( event );\n            },\n            value: getValue(),\n            getValue,\n            onBlur: ( event ) => handleBlurAtomic( event ), // Need to fill in\n            onClick: ( event ) => handleClickAtomic( event ), // Need to fill in\n            update: ( value, additionalProp ) => {\n                let event = {\n                    target: {\n                        type: 'OBJECT',\n                        value: value,\n                        additionalProp : additionalProp\n                    }\n                };\n                updateAtomicData( event );\n            }, // Need to fill in\n            checked: getValue(),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            typex: getPropertyType( propName, isCtxProp, index, isAtomic, viewProp ),\n            error: getErrors( propName, rootPath, path ),\n            required: getRequired( propName, isCtxProp, index, isAtomic, viewProp ),\n            maxLength: getMaxLength( propName, isCtxProp, index, isAtomic, viewProp ),\n            placeholder: getPlaceHolder( propName, isCtxProp, index, isAtomic, viewProp ),\n            disabled: viewProp && ( !viewProp.isEnabled || !viewProp.isEditable ),\n            setLovVal: setLovDataValAtomic( propName, isCtxProp, index, isAtomic, viewProp ),\n            dirty: isPropDirty( propName, isCtxProp, index, isAtomic, viewProp ),\n            'data-locator': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            'aria-label': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            'aria-required': getRequired( propName, isCtxProp, index, isAtomic,\n                viewProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            autoFocus: getAutofocus( propName, isCtxProp ),\n            vmo: vmo,\n            __vmprop__: () => viewProp,\n            fielddata: {\n                uiValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValue' ),\n                uiValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValues' ),\n                displayValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                oldValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValue' ),\n                oldValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValues' ),\n                isEnabled: viewProp && viewProp.isEnabled,\n                isSelectOnly: viewProp && viewProp.isSelectOnly,\n                isEditable: viewProp && viewProp.isEditable,\n                isLocalizable: viewProp && viewProp.isLocalizable,\n                uwAnchor: viewProp && viewProp.uwAnchor ? viewProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, null, isAtomic, viewProp ),\n                labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index, isAtomic, viewProp ),\n                renderingHint: getRenderingHint( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index, isAtomic, viewProp ),\n                radioVertical: viewProp && viewProp.vertical,\n                displayValsModel: getDisplayValsModel( propName, isCtxProp, index, isAtomic, viewProp ),\n                numberOfLines: getNumberOfLines( propName, isCtxProp, index, isAtomic, viewProp ),\n                dateApi: getDateApi( propName, isCtxProp, index, isAtomic, viewProp ),\n                isArray: getIsArray( propName, isCtxProp, index, isAtomic, viewProp ),\n                hasLov: getIsLov( propName, isCtxProp, index, isAtomic, viewProp ),\n                dataProvider: getDataProvider( propName, isCtxProp, index, isAtomic, viewProp ),\n                lovApi: getLovApi( propName, isCtxProp, index, isAtomic, viewProp ),\n                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index, isAtomic, viewProp ),\n                action: getAction( propName, isCtxProp, index, isAtomic, viewProp ),\n                iconName: viewProp && viewProp.iconName,\n                iconSource: viewProp && viewProp.iconSource,\n                tooltip: viewProp && viewProp.tooltip,\n                patterns: viewProp && viewProp.patterns,\n                preferredPattern: getPreferredPatternVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyName: propName,\n                parentUid: vmo ? vmo.uid : undefined,\n                isAutoAssign: getAutoAssignVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                isAutoAssignable: getAutoAssignableVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                patternAutoAssignFlags: getPatternAutoAssignFlagsVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                emptyLOVEntry: viewProp && viewProp.emptyLOVEntry,\n                destPanelId: viewProp && viewProp.destPanelId,\n                isRichText: viewProp && viewProp.isRichText,\n                hasRevRuleAttached: viewProp && viewProp.hasRevRuleAttached\n            }\n\n        };\n    };\n\n    let fields = createAllFields( data,\n        atomicData,\n        declViewModelJson,\n        createFieldForAtomicData,\n        createFieldsBasedOnMetaData,\n        constructFieldForNamedPropertyVMO,\n        constructFieldArrayOfNamedProperty,\n        constructFieldForNamedProperty,\n        ctx, fieldsRef );\n\n    fieldsRef.current = fields;\n\n    const hasErrors = () => {\n        let formErrors = getErrorsState();\n        let hasError = false;\n        if( formErrors ) {\n            Object.keys( formErrors || {} ).forEach( value => {\n                if( formErrors[ value ] ) {\n                    hasError = true;\n                }\n            } );\n        }\n        return hasError;\n    };\n\n    const handleSubmit = async ( event, submitAction ) => {\n        event.preventDefault();\n        setFormValidity( getStateCollection( viewModel ) );\n        if( !hasErrors() ) {\n            document.activeElement.blur(); // focus out from the form\n            await submitAction();\n            handleReset();\n        } else {\n            const focusOnFirstError = () => {\n                let inputElements = event.currentTarget;\n                for( let idx = 0; idx < inputElements.length; idx++ ) {\n                    if( inputElements[ idx ].hasAttribute( 'error' ) ) {\n                        inputElements[ idx ].focus();\n                        break;\n                    }\n                }\n            };\n            focusOnFirstError();\n        }\n    };\n\n    useInitHook( () => {\n        setFormValidity( getStateCollection( viewModel ) );\n        // 20201013 - skip no field case\n        // const keys = Object.keys( fields );\n        //if( keys.length > 0 ) {\n        //let initValues = {};\n        // Object.keys( fields ).forEach( field => {\n        //     initValues[ field ] = fields[ field ] && fields[ field ].value;\n        // } );\n        //setInitialValues( initValues );\n        //}\n    } );\n    /**\n     * This function checks the pristine state of the Form.\n     * If the form has been touched, this would return false, otherwise true.\n     * @returns boolean true/false\n     */\n    const isFormDirty = () => {\n        let touchedObj = getTouchedState();\n        let isFormDirty = false;\n        let keys = Object.keys( touchedObj );\n        for( let i = 0; i < keys.length; i++ ) {\n            let name = keys[ i ];\n            if( touchedObj[ name ] ) {\n                isFormDirty = true;\n                break;\n            }\n        }\n        return isFormDirty;\n    };\n\n    const formProp = {\n        onSubmit: handleSubmit,\n        onReset: handleReset,\n        children: {},\n        id: viewModel._internal.panelId,\n        attributes: {\n            noValidate: true,\n            autoComplete: 'off',\n            valid: getFormValidity(),\n            dirty: isFormDirty()\n        }\n    };\n\n    return {\n        fields,\n        formProp\n    };\n};\n\n/**\n * Keeping props inside a Ref. This is to avoid the stale prop issue specially with the actions\n * fired on event subscription.getProps would ensure to give latest prop;\n * @param {*} props React Props Object\n * @return {*} callback function to get the latest prop\n */\nconst useProps = ( props ) => {\n    const propRef = useRef( props );\n    propRef.current = props;\n    return React.useCallback( () => propRef.current, [ propRef ] );\n};\n\n/**\n * get view model context based on input\n * @param {object} vmDef view model instance factory\n * @param {object} subPanelContext sub panel context\n * @returns {object} view model context as:\n * {\n *     viewModel: {\n *         data,\n *         dispatch: function( { path: 'ctx.a', value: 3 } ) // way to update viewModel directly\n *     },\n *     actions: {\n *         myAction: executeAction.bind(null, 'myAction', vm)\n *     },\n *     ctx,\n *     fields: {\n *         first_name: {\n *             name: value,\n *             onChange: handleChange(value),\n *             onBlur: handleBlur(value),\n *             value: getValue(value),\n *             checked: getValue(value),\n *             touched: getTouched(value),\n *             propertyDisplayName: getPropertyDisplayName(value),\n *             label:  getPropertyDisplayName(value),\n *             typex: getPropertyType(value),\n *             helperText: getErrors(value),\n *             error: getErrors(value),\n *             required: getRequired(value),\n *             labelPlacement: getLabelPlacement(value),\n *             dirty: isModified(value)\n *         }\n *     },\n *     formSubmit: // Please bind this with form submit button\n * }\n */\n/* eslint-disable react-hooks/rules-of-hooks */\n\nexport const useAfxViewModel = ( vmDef, prop, renderOptions, ctxImports ) => {\n    const declViewModelJson = vmDef._internal.origDeclViewModelJson;\n    const getProps = useProps( prop );\n    let vmpCollRef = useRef( null );\n    let vmpValidationSchema = useRef( null );\n\n    let fieldsRef = useRef( null );\n    const getFields = React.useCallback( () => fieldsRef.current, [ fieldsRef ] );\n\n    const setFields = ( fields ) => {\n        if( fieldsRef.current !== fields ) {\n            fieldsRef.current = fields;\n        }\n    };\n\n    // data\n    const dataHook = useReducer( reducer, null, vmDef.createData );\n\n    // fieldsdata\n    const allAtomicData = useAtomicDataReducer( declViewModelJson );\n\n    // ctx\n    const { ctx, ctxMin, ctxDispatch } = useDerivedState( vmDef, prop, dataHook[ 0 ], ctxImports );\n    const ctxHook = [ { ...ctx, ...ctxMin }, ctxDispatch ];\n\n    // sync strategy ports\n    const portsHook = useReducer( reducer, null, vmDef.createPorts );\n\n    // subPanelContext\n    useMemo( () => {\n        updateSubPanelContext( vmDef._internal.origDeclViewModelJson.data, dataHook, prop.subPanelContext );\n    }, [ prop.subPanelContext ] );\n\n    let subscriptions = useRef( null );\n    let editHandlerRef = useRef( null );\n\n    //CommandsViewModel maintains its own lifecycle and has separate subscriptions from parent viewModel\n    //E.g. Container view has some events and container view has commandbar so there are 2 viewmodels\n    // and 2 subscriptions. Lifecycle of command viewModel subscription though is limited to command click\n    // since runActionWithViewModel is not component, we need to declare useRef outside ( under component)\n    let subscriptionsForCommands = useRef( null );\n    /**\n     * Run an action with a different view model from the one used by this component\n     *\n     * @param {Object} viewModelJson The unprocessed JSON\n     * @param {String} actionId ID of the action to execute\n     * @param {Object} scope (Optional) Additional properties to include in execution scope\n     */\n    const runActionWithViewModel = async ( viewModelJson, actionId, scope = {} ) => {\n        const trace = new Debug( 'declViewModelService:actionId' );\n        //get view model ready for executing action\n        const commandVmDef = createDeclViewModel( viewModelJson, prop );\n        commandVmDef.data = commandVmDef.data || {};\n\n        /**\n         * TODO: This takes ~1s for commandsViewModel. Options to fix are:\n         *  1. Cache based on view model ID (so first command click is slow but rest are not)\n         *    - Still results in processing more i18n than necessary\n         *  2. Use lazy getter\n         *    - viewModel.i18n[key] would now be a promise, which would have significant impact\n         */\n        commandVmDef.i18n = await awDuiLocalizationSvc.populateI18nMap( viewModelJson.i18n, null );\n        const processedVm = processViewModel( commandVmDef, ctxHook, dataHook );\n        const commandsViewModel = processedVm.viewModel;\n\n        const subscriptionObject = setupLifeCycle( commandVmDef, commandsViewModel, ctxHook[ 0 ], () => prop, null, true, runActionWithViewModel, subscriptionsForCommands, getFields );\n\n        //Actions being executed can access anything in ctx, even if useSelector hook is not setup\n        const executionScope = {\n            ...scope,\n            data: commandsViewModel,\n            ctx: ctxHook[ 0 ]\n        };\n\n        const result = await viewModelService.executeCommand( commandsViewModel, actionId, executionScope );\n        //executeCommand is resolved after first action is complete. We have to wait on all following actions (triggered by events) to complete before resolving\n        const resolveWhenCommandsViewModelIsNotActive = new Promise( ( resolve ) => {\n            const intervalId = setInterval( () => {\n                if( !commandsViewModel.getToken().isActive() ) {\n                    clearInterval( intervalId );\n                    return resolve();\n                }\n                trace( 'Action is still executing checking again in 50ms', actionId );\n                return null;\n            }, 50 );\n        } );\n        await resolveWhenCommandsViewModelIsNotActive;\n        //cleanup the view model\n        subscriptionObject();\n        return result;\n    };\n\n    // view model\n    const { viewModel, grids } = processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData, getProps, runActionWithViewModel, getFields );\n\n    // i18n\n    const [ i18n, i18nLoaded ] = useI18n( viewModel );\n    viewModel.i18n = i18n;\n\n    let stateCollection = getStateCollection( viewModel );\n    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );\n\n    // form\n    const { fields, formProp } = useAfxForm( vmDef, viewModel, ctxHook[ 0 ], dataHook, i18n, vmDef._internal.origDeclViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema );\n    setFields( fields );\n\n    let dataCtxNode = {\n        props: prop,\n        data: viewModel,\n        ctx: ctxHook[ 0 ],\n        subPanelContext: prop.subPanelContext,\n        ports: viewModel.ports,\n        getProps,\n        getFields,\n        fields\n    };\n\n    // selectionModels\n    viewModel.selectionModels = useSelectionModels( vmDef._internal.selectionModels, dataCtxNode );\n\n    useDataProviders( vmDef.dataProviders, getProps, dataCtxNode );\n\n    // tableContext\n    const [ gridContextPlaceholder, gridContextDispatcher ] = useGridContext( prop );\n    useGrids( vmDef.grids, dataCtxNode, vmDef.dataProviders, gridContextPlaceholder, gridContextDispatcher, viewModel, getProps );\n\n    // Setup lifecycle\n    // NOTE: it should be setupLifeCycle, but there is a eslint rule to force the function name to be 'useXXX'\n    useInitHook( () => setupLifeCycle( vmDef, viewModel, ctxHook[ 0 ], getProps, renderOptions, false, runActionWithViewModel, subscriptions, getFields ), i18nLoaded );\n\n    useInitHook( () => declDragAndDropService.updateDeps( viewModel ) );\n\n    // grids\n    if( i18nLoaded === true ) {\n        for( const gridDefKey in grids ) {\n            let gridInstance = grids[ gridDefKey ];\n            gridInstance.i18nLoaded = i18nLoaded;\n        }\n    }\n\n    useGrid( prop, vmDef.getPanelId(), gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel );\n\n    //lovs\n    useLOVs( fields, prop, viewModel, renderOptions );\n\n    // initialize popups\n    usePopups( viewModel );\n\n    //messages\n\n    const messages = useMessages( viewModel, fields );\n\n    // drag and drop\n    declDragAndDropService.setupDragAndDrop( viewModel, dataCtxNode, getProps );\n\n    //update Event subscriptions\n    updateSubscriptions( subscriptions.current, viewModel );\n\n    useCommands( viewModel, prop, renderOptions );\n\n    for( let key in viewModel.declViewModelJson.conditions ) {\n        conditionService.registerWatch( viewModel.conditions, viewModel, key, [ viewModel.declViewModelJson.conditions[ key ].expression ], vmDef.oldExpressions );\n    }\n    vmDef.oldExpressions = viewModel.expressions;\n\n    if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate && Array.isArray( viewModel.declViewModelJson.lifecycleHooks.onUpdate ) ) {\n        _.forEach( viewModel.declViewModelJson.lifecycleHooks.onUpdate, function( onUpdateDef, i ) {\n            let observerObjs = [];\n            if( viewModel.declViewModelJson.lifecycleHooks && onUpdateDef ) {\n                let obj = onUpdateDef;\n                let evContext = { props: prop, viewModel, fields: getFields() };\n                _.forEach( obj.observers, function( observer ) {\n                    let evaluatedObj = _.get( evContext, observer );\n                    //populate observers irrespective of their value\n                    //This aids usecases where initial values for observers are null/undefined and are populated eventually\n                    observerObjs.push( evaluatedObj );\n                } );\n            }\n\n            useEffect( function() {\n                //don't execute hook if all parameters are undefined\n                if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {\n                    if( logger.isDeclarativeLogEnabled() ) {\n                        debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );\n                    }\n                    debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );\n                    viewModel.lifecycleHooks.onUpdate[ i ]( renderOptions );\n                }\n            }, observerObjs );\n        } );\n    } else {\n        let observerObjs = [];\n        if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate ) {\n            let obj = viewModel.declViewModelJson.lifecycleHooks.onUpdate;\n            let evContext = { props: prop, viewModel, fields: getFields() };\n            _.forEach( obj.observers, function( observer ) {\n                let evaluatedObj = _.get( evContext, observer );\n                //populate observers irrespective of their value\n                //This aids usecases where initial values for observers are null/undefined and are populated eventually\n                observerObjs.push( evaluatedObj );\n            } );\n        }\n\n        useEffect( function() {\n            //don't execute hook if all parameters are undefined\n            if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );\n                }\n                debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );\n                executeHook( 'onUpdate', viewModel, prop, renderOptions );\n            }\n        }, observerObjs );\n    }\n\n    viewModel.editHandlers = useEditHandlers( vmDef._internal.editHandlers, viewModel, dataCtxNode, editHandlerRef, fields );\n\n    // Edit handlers\n    const editContexts = findEditContexts( viewModel );\n    if( editContexts.length > 0 ) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEditHandlers2( viewModel );\n    }\n\n    // update Sync path\n    let path = '';\n    if( prop.viewId && prop.viewPath ) {\n        let viewPathArray = prop.viewPath.split( '/' );\n        if( prop.viewId === prop.viewPath ) {\n            path = prop.viewPath;\n        } else if( prop.viewId === viewPathArray[ viewPathArray.length - 1 ] ) {\n            path = prop.viewPath;\n        } else {\n            path = prop.viewPath + '/' + prop.viewId;\n        }\n    } else if( prop.viewId ) {\n        path = prop.viewId;\n    }\n\n    return {\n        ctx: ctxMin,\n        ctxDeprecated: ctx,\n        ctxMin,\n        viewModel,\n        actions: viewModel.actions,\n        i18n,\n        fields,\n        grids,\n        formProp,\n        messages,\n        runActionWithViewModel,\n        gridContextPlaceholder,\n        gridContextDispatcher,\n        viewPath: path\n    };\n};\n\n/**\n * Edit handlers hook\n * @param {Object} viewModel View model\n */\nexport function useEditHandlers2( viewModel ) {\n    useEffect( function() {\n        editHandlerService.updateStates2( viewModel );\n    } );\n}\n\n/**\n * Find edit contexts of view model\n * @param {Object} viewModel View model\n * @return {String} Edit contexts\n */\nfunction findEditContexts( viewModel ) {\n    let editContexts = [];\n    if( viewModel.editHandlers ) {\n        for( const editHandlerName in viewModel.editHandlers ) {\n            if( !viewModel.editHandlers[ editHandlerName ].dataSource ) {\n                editContexts.push( viewModel.editHandlers[ editHandlerName ].context );\n            }\n        }\n    }\n    if( viewModel.dataProviders ) {\n        for( const dataProviderName in viewModel.dataProviders ) {\n            const dataProvider = viewModel.dataProviders[ dataProviderName ];\n            if( dataProvider.editContext ) {\n                editContexts.push( dataProvider.editContext );\n            }\n        }\n    }\n    return editContexts;\n}\n\n/**\n * load subscriptions\n * @param {JSON} onEventDef onEvent definition\n * @param {ViewModelObject} vm view model object\n * @param {limitEventScope} limitEventScope Limit the event registration for certain view models like commands VM\n * @returns {Array} event subscriptions\n */\nexport function loadSubscriptions( onEventDef, vm, limitEventScope, getProps, runActionWithViewModel, getFields ) {\n    // process event subscription\n    const res = [];\n    if( onEventDef ) {\n        onEventDef.forEach( ( eventObj ) => {\n            // - Construct a call back to process action.\n            // - put vm to the scope of the fn and communicate to subscriber\n            // - update that vm in every render cycle ( which is anti-pattern )\n            if( !_.isEmpty( eventObj ) ) {\n                const subscriber = eventData => {\n                    const viewModel = subscriber.vm;\n                    if( eventData && eventData.scope ) {\n                        // Never mutate the existing eventData, it would causes issue when there are multiple subscriptions\n                        // and the action associated with the event is async.\n                        let newEventData = { ...eventData, scope: { ...eventData.scope } };\n                        newEventData.scope.data = viewModel;\n                        newEventData.scope.ctx = appCtxSvc.ctx;\n                        handleRegisteredEvent( newEventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );\n                    } else {\n                        handleRegisteredEvent( eventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );\n                    }\n                };\n                subscriber.subDef = subscribe( eventObj.eventId, subscriber );\n                subscriber.vm = vm;\n                res.push( subscriber );\n            }\n        } );\n    }\n    return res;\n}\n\n/**\n * Update vm to scope in event subscriptions\n * @param {Array} subscriptions event subscriptions\n * @param {ViewModelObject} vm view model object\n */\nexport function updateSubscriptions( subscriptions, vm ) {\n    if( subscriptions ) {\n        subscriptions.forEach( subscriber => subscriber.vm = vm );\n    }\n}\n\n/**\n * unload subscriptions from event bus\n * @param {Array} subscriptions event subscriptions\n */\nexport function unloadSubscriptions( subscriptions ) {\n    subscriptions.forEach( subscriber => unsubscribe( subscriber.subDef ) && delete subscriber.vm );\n    subscriptions.splice( 0, subscriptions.length );\n}\n\n/**\n * cleanup edit handlers\n * @param {Array} editHandlers  editHandlers\n * @param {Object} dataCtxNode dataCtxNode\n */\nexport function cleanupEditHandlers( editHandlers, dataCtxNode ) {\n    if( editHandlers ) {\n        for( const key in editHandlers ) {\n            if( editHandlers[ key ] && editHandlers[ key ].context ) {\n                let contextKey = editHandlers[ key ].context;\n                if( contextKey && contextKey.match( /\\{\\{.*}}/g ) ) {\n                    contextKey = AwInterpolateService.instance( contextKey )( dataCtxNode );\n                }\n                removeEditHandler( contextKey );\n            }\n        }\n    }\n}\n\nconst getDifferenceBetweenObjects = function( object, base ) {\n    function changes( object, base ) {\n        return _.transform( object, function( result, value, key ) {\n            if( !_.isEqual( value, base[ key ] ) ) {\n                result[ key ] = _.isObject( value ) && _.isObject( base[ key ] ) ? changes( value, base[ key ] ) : value;\n            }\n        } );\n    }\n    return changes( object, base );\n};\n\nconst isObject = function( item ) {\n    return item && typeof item === 'object' && !Array.isArray( item );\n};\n\nconst mergeDeep = function( target, ...sources ) {\n    if( !sources.length ) {\n        return target;\n    }\n    const source = sources.shift();\n\n    if( isObject( target ) && isObject( source ) ) {\n        for( const key in source ) {\n            if( isObject( source[ key ] ) ) {\n                if( !target[ key ] ) {\n                    Object.assign( target, {\n                        [ key ]: {}\n                    } );\n                }\n                mergeDeep( target[ key ], source[ key ] );\n            } else {\n                Object.assign( target, {\n                    [ key ]: source[ key ]\n                } );\n            }\n        }\n    }\n\n    return mergeDeep( target, ...sources );\n};\n\n/**\n * create react component based on view model JSON\n * @param {JSON} declViewModelJson view model definition\n * @param {Function} renderFn the renderFn, default null\n * @param {Object} options the render options\n * @returns {JSX.Element} context for view interpolation\n *\n */\nexport const createComponent = ( declViewModelJson, renderFn, options = {}, ctxImports ) => {\n    const Component = prop => {\n        splmStatsService.startComponentRenderTime();\n        const [ vmDef ] = useState( () => createDeclViewModel( declViewModelJson, prop ) );\n        const [ declViewModel ] = useState( () => declViewModelJson );\n        let viewData = null;\n        let elementsMap = useRef( new Map() );\n        let ref = prop.domRef;\n        if( !ref && options.elementRefList ) {\n            viewData = {\n                elementRefList: null\n            };\n            options.elementRefList.map( ( domElement ) => {\n                if( !elementsMap.current.has( domElement ) ) {\n                    elementsMap.current.set( domElement, createRef( null ) );\n                }\n            } );\n            viewData.elementRefList = elementsMap.current;\n            // How to update props ??\n        }\n        let { elementRefList, ...restOptionsParams } = { ...options };\n        useVmoStore( prop, vmDef._internal.origDeclViewModelJson.props );\n        const vm = useAfxViewModel( vmDef, prop, { ...viewData, ...restOptionsParams }, ctxImports );\n\n        let { i18n, data, dispatch } = vm.viewModel;\n        let createData = vmDef.createData;\n\n        // deserve to put one more useRef since createData and createDeclViewModel is very expensive\n        const hmrLastRef = useRef( null );\n        useEffect( function useHmrEffect() {\n            // console.log( 'hmrEffect triggered!' );\n            // Merge new data into current data\n            // TODO: Patch entire view model, maybe don't use hook approach to sync data.\n            if( hmrLastRef.current !== null ) {\n                const initialData = createData( i18n );\n                const newData = createDeclViewModel( declViewModelJson, prop ).createData( i18n );\n                const diffData = getDifferenceBetweenObjects( newData, initialData );\n                let mergedData = null;\n                if( !_.isEmpty( diffData ) ) {\n                    mergedData = mergeDeep( data, diffData );\n                    dispatch( { path: 'data', value: { ...mergedData } } );\n                }\n                hmrLastRef.current = declViewModel;\n            }\n        }, [ declViewModel ] );\n\n        let props = { ...prop, ...vm };\n        renderFn = renderFn || vmDef.renderFn;\n\n        // support mixin (renderParams) based on render options\n        if( !ref && options.elementRefList ) {\n            props.elementRefList = viewData.elementRefList;\n        }\n\n        // initialize AwExtendedTooltip\n        if( options && options.isTootip ) {\n            let action = vm.actions.extendedTooltipPopup;\n            // justification: hooks are called in the same order each time AwExtendedTooltip renders.\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            useEffect( () => {\n                action.reference.current = prop.reference.current;\n                action.userOptions.current = prop.extendedTooltipOptions;\n            }, [ prop.reference.current ] );\n        }\n\n        if( options.registerCtx ) {\n            // justification: hooks are called in the same order each time that component renders.\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            useEffect( () => {\n                let { key, value, path } = options.registerCtx;\n                appCtxSvc.registerCtx( prop.key || key, value || _.get( vm, path ) );\n            } );\n        }\n\n        let component = renderFn( props );\n\n        component = setDndHandler( vm, props, component );\n\n        // generic style inheritance\n        if( component && component.props && props && props.className ) {\n            // don't repeat classes.... use simple string check\n            if( !( component.props.className && component.props.className.includes( props.className ) ) ) {\n                if( component.type && component.type.includes && component.type.includes( '-' ) ) {\n                    component = React.cloneElement( component, { class: component.props.class + ' ' + props.className } );\n                } else {\n                    component = React.cloneElement( component, { className: component.props.className + ' ' + props.className } );\n                }\n            }\n        }\n\n        // inject ref prop by need\n        if( ref && component ) {\n            if( props.domRef ) {\n                component = React.cloneElement( component, { ref, domRef: props.domRef } );\n            } else {\n                component = React.cloneElement( component, { ref } );\n            }\n        }\n\n        // provide a opportunity to override appendToBody behavior through props\n        if( options.usePortal && prop.enableAppend !== false ) {\n            component = ReactDOM.createPortal( component, prop.parent || document.body );\n        }\n\n        splmStatsService.trackComponent( declViewModelJson._viewModelId );\n\n        return component || null;\n    };\n\n    // Scenario: Verify zero group compile command with popup associated with ZCC (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:7\n    // Scenario: Verify zero shuttle compile command (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:74\n    // Scenario: Verify triangle and popup are not shown when there is only one visible command in the zero group compile command (attempt 2, retried)\n    //     # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:40\n    // Scenario: Verify zero shuttle compile command with/without label (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:143\n    // https://stackoverflow.com/questions/60453845/is-it-safe-to-usememo-for-jsx\n    if( options.useMemo === false ) {\n        Component.displayName = declViewModelJson._viewModelId;\n        return Component;\n    }\n\n    Component.displayName = `${declViewModelJson._viewModelId}.memo`;\n    return React.memo( Component );\n};\n\nconst setDndHandler = function( vm, props, component ) {\n    const dndHandlers = vm.viewModel.dndHandler || props.attachdndHandlers;\n    if( dndHandlers ) {\n        if( component && typeof component.type === 'string' ) {\n            let dndListener = declDragAndDropService.setViewDnd( dndHandlers );\n            component = React.cloneElement( component, { ...dndListener, className: component.props.className + ' aw-widgets-droppable' } );\n        } else {\n            if( component && component.props && !component.props.onDragEnter && component.type !== 'aw-splm-table' ) {\n                component = React.cloneElement( component, { attachdndHandlers: dndHandlers } );\n            }\n        }\n    }\n    return component;\n};\n"]},"metadata":{},"sourceType":"module"}