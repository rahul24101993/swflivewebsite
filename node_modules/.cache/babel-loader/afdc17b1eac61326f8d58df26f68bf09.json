{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n * A set of utilities and methods related to processing and modifying the commadns view model\n *\n * @module js/commandConfigUtils.service\n */\nimport configurationService from 'js/configurationService';\nimport { getRealExpression } from 'js/conditionService';\nimport _, { get, isObject, isString, isArray, mapValues, cloneDeepWith } from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nconst trace = new Debug('command:AwCommandBar');\n/** Regular Expression for the condition prefix in the expression. */\n\nconst conditionRE = /\\bconditions\\b\\./;\n/**\n * Get the conditions with any condition reuse within string expressions expanded\n *\n * @param {Object} viewModelJson View model with conditions to expand\n * @returns {Object} Processed condition expressions\n */\n\nconst getExpandedConditionExpressions = function (viewModelJson) {\n  const stringExpandedConditions = mapValues(viewModelJson.conditions, condition => {\n    if (isString(condition.expression)) {\n      //simple expansion of string conditions\n      return { ...condition,\n        expression: getRealExpression(condition.expression, viewModelJson)\n      };\n    }\n\n    if (isObject(condition.expression)) {\n      //recurse through object and expand any referenced string conditions\n      return cloneDeepWith(condition, value => {\n        if (isObject(value) && value.$source && conditionRE.test(value.$source)) {\n          const refExpression = getRealExpression(value.$source, viewModelJson);\n          return isString(refExpression) ? { ...value,\n            $source: refExpression,\n            __useSourceParsing: true\n          } : value;\n        }\n      });\n    }\n\n    return condition;\n  });\n  const tempVm = {\n    conditions: stringExpandedConditions\n  };\n\n  const checkObjectCondition = (condition, shouldRecurse) => {\n    if (isObject(condition) && condition.$source && conditionRE.test(condition.$source)) {\n      const eqCheck = get(condition, '$query.$eq');\n      const neCheck = get(condition, '$query.$ne');\n      const refExpression = getRealExpression(condition.$source, tempVm);\n\n      if (eqCheck === true || neCheck === false) {\n        //for true just swap original condition into same place\n        //need to restart recursion for new object to ensure and \"conditions.x\" included in it are updated\n        const newValue = cloneDeepWith(refExpression, expandObjectConditions);\n        trace('Expanded object condition', condition, newValue);\n        return newValue;\n      }\n\n      if (eqCheck === false || neCheck === true) {\n        //for false wrap with a $not\n        const newValue = {\n          $not: cloneDeepWith(refExpression, expandObjectConditions)\n        };\n        trace('Expanded object condition', condition, newValue);\n        return newValue;\n      }\n\n      logger.warn('Condition reuse only supports boolean checks', condition);\n    }\n\n    return shouldRecurse ? cloneDeepWith(condition, expandObjectConditions) : condition;\n  };\n\n  const expandObjectConditions = value => {\n    if (isArray(value)) {\n      return value.map(x => checkObjectCondition(x, true));\n    }\n\n    const newVal = checkObjectCondition(value);\n\n    if (newVal !== value) {\n      //don't return if not modifying anything, will stop recursion for the current object\n      return newVal;\n    }\n  };\n\n  return cloneDeepWith(stringExpandedConditions, expandObjectConditions);\n};\n/**\n * Convert every placement that has \"parentGroupID\" into a placement with\n * a dynamically generated anchor based on parent\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\n\nconst addChildPlacements = function (viewModelJson) {\n  for (const [placementID, placement] of Object.entries(viewModelJson.commandPlacements)) {\n    if (placement.parentGroupId) {\n      viewModelJson.commandPlacements[`$$${placementID}${placement.parentGroupId}`] = {\n        id: placement.id,\n        priority: placement.priority,\n        relativeTo: placement.relativeTo,\n        uiAnchor: placement.parentGroupId\n      };\n    }\n  }\n};\n/**\n * Ensure the primary commandsViewModel has all of the expected properties\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\n\nconst ensureProps = function (viewModelJson) {\n  ['actions', 'commandHandlers', 'commandPlacements', 'commands', 'conditions', 'messages'].forEach(function (k) {\n    viewModelJson[k] = viewModelJson[k] || {};\n  });\n  ['onEvent'].forEach(function (k) {\n    viewModelJson[k] = viewModelJson[k] || [];\n  });\n};\n/**\n * Convert \"true\" and \"false\" shortcuts into actual conditions\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n * @param {Object} commandHandlers Command handlers to modify\n */\n\n\nexport const updateShortConditions = function (viewModelJson, commandHandlers) {\n  const trueCondition = {\n    condition: 'conditions.true'\n  };\n  const falseCondition = {\n    condition: 'conditions.false'\n  };\n\n  for (const handler of Object.values(commandHandlers)) {\n    ['activeWhen', 'visibleWhen', 'selectWhen', 'enableWhen'].forEach(function (conditionKey) {\n      if (handler[conditionKey] === true || _.get(handler, [conditionKey, 'condition']) === true) {\n        handler[conditionKey] = trueCondition;\n      } else if (handler[conditionKey] === false || _.get(handler, [conditionKey, 'condition']) === false) {\n        handler[conditionKey] = falseCondition;\n      }\n    });\n  }\n\n  viewModelJson.conditions.true = {\n    expression: 'true'\n  };\n  viewModelJson.conditions.false = {\n    expression: 'false'\n  };\n};\n/**\n * Convert \"title\": \"{{ctx.previousLocationDisplayName }}\" to parameter format\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\nconst updateShortCommandTitles = function (viewModelJson) {\n  for (const command of Object.values(viewModelJson.commands)) {\n    if (command.title && typeof command.title === 'string' && (command.title.startsWith('{{ctx') || command.title.startsWith('{{commandContext'))) {\n      command.title = {\n        text: '{0}',\n        params: [command.title]\n      };\n    }\n  }\n};\n\nlet viewModelJsonCache = null;\n\nconst setCommandsViewModelCache = newCache => {\n  viewModelJsonCache = newCache;\n};\n/**\n * Get and pre process the commands view model from config service\n * @param {boolean} clearCache true if to clear any commandsViewModelCache\n * @returns {Promise<Object>} promise resolved with the commands view model (plain object)\n */\n\n\nconst getCommandsViewModel = async function () {\n  let clearCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (viewModelJsonCache && !clearCache) {\n    return viewModelJsonCache;\n  }\n\n  let viewModelJson = await configurationService.getCfg('commandsViewModel');\n  ensureProps(viewModelJson);\n  const expandedConditions = getExpandedConditionExpressions(viewModelJson);\n  viewModelJson.conditions = expandedConditions;\n  addChildPlacements(viewModelJson);\n  updateShortConditions(viewModelJson, viewModelJson.commandHandlers);\n  updateShortCommandTitles(viewModelJson);\n  setCommandsViewModelCache(viewModelJson);\n  return viewModelJson;\n};\n/**\n * Get all matches of a regex in the given string\n *\n * @param {RegExp} re Regex to used\n * @param {String} s String to search\n * @returns {Array<String>} List of all matches\n */\n\n\nconst getAllMatches = function (re, s) {\n  var result = [];\n  var m = re.exec(s);\n\n  while (m) {\n    result.push(m[1]);\n    m = re.exec(s);\n  }\n\n  return result;\n};\n\nconst conditionsRE = /conditions\\.([a-zA-Z]\\w*)(\\W*|$)/g;\n/**\n * Get all nested conditions from a condition expression. See unit tests for examples.\n *\n * @param {String|Object} s condition expression\n * @returns {String[]} nested conditions\n */\n\nconst getConditions = function (s) {\n  if (typeof s === 'string') {\n    return getAllMatches(conditionsRE, s);\n  }\n\n  if (typeof s === 'object') {\n    return Object.keys(s).map(k => s[k]) //Object.values( s ) if not for IE11\n    .reduce((acc, nxt) => acc.concat(getConditions(nxt)), []);\n  }\n\n  return [];\n};\n/**\n * Utility to get the actual condition expression from the commands view model\n *\n * @param {Object} commandsViewModel The commands view model\n * @param {String} condition The conditon name (\"conditions.asdf\")\n * @returns {String|Object} The condition expression (string or object)\n */\n\n\nconst getConditionExpression = function (commandsViewModel, condition) {\n  var conditionName = condition.split('.')[1];\n\n  var expression = _.get(commandsViewModel, `_internal.conditions.${conditionName}.expression`, null) || _.get(commandsViewModel, `conditions.${conditionName}.expression`, null);\n\n  if (expression === null) {\n    //If condition does not exist return \"false\" to avoid console errors (same behavior)\n    logger.error(`Reference to missing condition \"${conditionName}\"`);\n    expression = 'false';\n  }\n\n  return expression;\n};\n/**\n * Recurses into the object and sub objects and finds real length of the expression by replacing the\n * references to other condition.xyz conditions\n *\n * @param {Object|String} expression expression whose actual length is desired\n * @param {Object} internalViewModel Object holding all expression definitions\n * @returns {Number} the length of the expression\n */\n\n\nconst getExpressionLength = function (expression, internalViewModel) {\n  var sum = function (a, b) {\n    return a + b;\n  };\n\n  if (typeof expression === 'string') {\n    return expression.length;\n  }\n\n  return _.map(expression, function (value, key) {\n    if (key === '__useSourceParsing') {\n      return 0;\n    }\n\n    var length = String(key).length;\n\n    if (value && _.isString(value)) {\n      var nestedConditions = getConditions(value);\n\n      if (nestedConditions.length > 0) {\n        var nestedConditionLength = nestedConditions.map(function (condName) {\n          return getExpressionLength(getConditionExpression(internalViewModel, 'conditions.' + condName), internalViewModel);\n        }).reduce(sum);\n        return length + nestedConditionLength;\n      }\n\n      return length + String(value).length;\n    }\n\n    if (_.isObject(value)) {\n      return length + getExpressionLength(value, internalViewModel);\n    }\n\n    return length + String(value).length;\n  }).reduce(sum);\n};\n\nconst exports = {\n  updateShortConditions,\n  getCommandsViewModel,\n  getConditions,\n  getConditionExpression,\n  getExpressionLength\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/commandConfigUtils.service.js"],"names":["trace","conditionRE","getExpandedConditionExpressions","stringExpandedConditions","mapValues","viewModelJson","condition","isString","expression","getRealExpression","isObject","cloneDeepWith","value","refExpression","$source","__useSourceParsing","tempVm","conditions","checkObjectCondition","eqCheck","get","neCheck","newValue","$not","logger","shouldRecurse","expandObjectConditions","isArray","x","newVal","addChildPlacements","Object","placement","placementID","parentGroupId","id","priority","relativeTo","uiAnchor","ensureProps","updateShortConditions","trueCondition","falseCondition","handler","_","updateShortCommandTitles","command","text","params","viewModelJsonCache","setCommandsViewModelCache","newCache","getCommandsViewModel","clearCache","configurationService","expandedConditions","getAllMatches","result","m","re","conditionsRE","getConditions","k","s","acc","getConditionExpression","conditionName","getExpressionLength","sum","a","key","length","String","nestedConditions","nestedConditionLength","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n * A set of utilities and methods related to processing and modifying the commadns view model\n *\n * @module js/commandConfigUtils.service\n */\nimport configurationService from 'js/configurationService';\nimport { getRealExpression } from 'js/conditionService';\nimport _, { get, isObject, isString, isArray, mapValues, cloneDeepWith } from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nconst trace = new Debug( 'command:AwCommandBar' );\n\n/** Regular Expression for the condition prefix in the expression. */\nconst conditionRE = /\\bconditions\\b\\./;\n\n/**\n * Get the conditions with any condition reuse within string expressions expanded\n *\n * @param {Object} viewModelJson View model with conditions to expand\n * @returns {Object} Processed condition expressions\n */\nconst getExpandedConditionExpressions = function( viewModelJson ) {\n    const stringExpandedConditions = mapValues( viewModelJson.conditions, condition => {\n        if( isString( condition.expression ) ) {\n            //simple expansion of string conditions\n            return {\n                ...condition,\n                expression: getRealExpression( condition.expression, viewModelJson )\n            };\n        }\n        if( isObject( condition.expression ) ) {\n            //recurse through object and expand any referenced string conditions\n            return cloneDeepWith( condition, ( value ) => {\n                if( isObject( value ) && value.$source && conditionRE.test( value.$source ) ) {\n                    const refExpression = getRealExpression( value.$source, viewModelJson );\n                    return isString( refExpression ) ? {\n                        ...value,\n                        $source: refExpression,\n                        __useSourceParsing: true\n                    } : value;\n                }\n            } );\n        }\n        return condition;\n    } );\n    const tempVm = {\n        conditions: stringExpandedConditions\n    };\n    const checkObjectCondition = ( condition, shouldRecurse ) => {\n        if( isObject( condition ) && condition.$source && conditionRE.test( condition.$source ) ) {\n            const eqCheck = get( condition, '$query.$eq' );\n            const neCheck = get( condition, '$query.$ne' );\n            const refExpression = getRealExpression( condition.$source, tempVm );\n            if( eqCheck === true || neCheck === false ) {\n                //for true just swap original condition into same place\n                //need to restart recursion for new object to ensure and \"conditions.x\" included in it are updated\n                const newValue = cloneDeepWith( refExpression, expandObjectConditions );\n                trace( 'Expanded object condition', condition, newValue );\n                return newValue;\n            }\n            if( eqCheck === false || neCheck === true ) {\n                //for false wrap with a $not\n                const newValue = {\n                    $not: cloneDeepWith( refExpression, expandObjectConditions )\n                };\n                trace( 'Expanded object condition', condition, newValue );\n                return newValue;\n            }\n            logger.warn( 'Condition reuse only supports boolean checks', condition );\n        }\n        return shouldRecurse ? cloneDeepWith( condition, expandObjectConditions ) : condition;\n    };\n    const expandObjectConditions = ( value ) => {\n        if( isArray( value ) ) {\n            return value.map( x => checkObjectCondition( x, true ) );\n        }\n        const newVal = checkObjectCondition( value );\n        if( newVal !== value ) {\n            //don't return if not modifying anything, will stop recursion for the current object\n            return newVal;\n        }\n    };\n    return cloneDeepWith( stringExpandedConditions, expandObjectConditions );\n};\n\n/**\n * Convert every placement that has \"parentGroupID\" into a placement with\n * a dynamically generated anchor based on parent\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst addChildPlacements = function( viewModelJson ) {\n    for( const [ placementID, placement ] of Object.entries( viewModelJson.commandPlacements ) ) {\n        if( placement.parentGroupId ) {\n            viewModelJson.commandPlacements[ `$$${placementID}${placement.parentGroupId}` ] = {\n                id: placement.id,\n                priority: placement.priority,\n                relativeTo: placement.relativeTo,\n                uiAnchor: placement.parentGroupId\n            };\n        }\n    }\n};\n\n/**\n * Ensure the primary commandsViewModel has all of the expected properties\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst ensureProps = function( viewModelJson ) {\n    [ 'actions', 'commandHandlers', 'commandPlacements', 'commands', 'conditions', 'messages' ].forEach( function( k ) {\n        viewModelJson[ k ] = viewModelJson[ k ] || {};\n    } );\n    [ 'onEvent' ].forEach( function( k ) {\n        viewModelJson[ k ] = viewModelJson[ k ] || [];\n    } );\n};\n\n/**\n * Convert \"true\" and \"false\" shortcuts into actual conditions\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n * @param {Object} commandHandlers Command handlers to modify\n */\nexport const updateShortConditions = function( viewModelJson, commandHandlers ) {\n    const trueCondition = {\n        condition: 'conditions.true'\n    };\n    const falseCondition = {\n        condition: 'conditions.false'\n    };\n    for( const handler of Object.values( commandHandlers ) ) {\n        [ 'activeWhen', 'visibleWhen', 'selectWhen', 'enableWhen' ].forEach( function( conditionKey ) {\n            if( handler[ conditionKey ] === true ||\n                _.get( handler, [ conditionKey, 'condition' ] ) === true ) {\n                handler[ conditionKey ] = trueCondition;\n            } else if( handler[ conditionKey ] === false ||\n                _.get( handler, [ conditionKey, 'condition' ] ) === false ) {\n                handler[ conditionKey ] = falseCondition;\n            }\n        } );\n    }\n    viewModelJson.conditions.true = {\n        expression: 'true'\n    };\n    viewModelJson.conditions.false = {\n        expression: 'false'\n    };\n};\n\n/**\n * Convert \"title\": \"{{ctx.previousLocationDisplayName }}\" to parameter format\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst updateShortCommandTitles = function( viewModelJson ) {\n    for( const command of Object.values( viewModelJson.commands ) ) {\n        if( command.title && typeof command.title === 'string' && ( command.title.startsWith( '{{ctx' ) || command.title.startsWith( '{{commandContext' ) ) ) {\n            command.title = {\n                text: '{0}',\n                params: [ command.title ]\n            };\n        }\n    }\n};\n\nlet viewModelJsonCache = null;\nconst setCommandsViewModelCache = ( newCache ) => {\n    viewModelJsonCache = newCache;\n};\n\n/**\n * Get and pre process the commands view model from config service\n * @param {boolean} clearCache true if to clear any commandsViewModelCache\n * @returns {Promise<Object>} promise resolved with the commands view model (plain object)\n */\nconst getCommandsViewModel = async function( clearCache = false ) {\n    if( viewModelJsonCache && !clearCache ) {\n        return viewModelJsonCache;\n    }\n    let viewModelJson = await configurationService.getCfg( 'commandsViewModel' );\n    ensureProps( viewModelJson );\n    const expandedConditions = getExpandedConditionExpressions( viewModelJson );\n    viewModelJson.conditions = expandedConditions;\n    addChildPlacements( viewModelJson );\n    updateShortConditions( viewModelJson, viewModelJson.commandHandlers );\n    updateShortCommandTitles( viewModelJson );\n    setCommandsViewModelCache( viewModelJson );\n    return viewModelJson;\n};\n\n/**\n * Get all matches of a regex in the given string\n *\n * @param {RegExp} re Regex to used\n * @param {String} s String to search\n * @returns {Array<String>} List of all matches\n */\nconst getAllMatches = function( re, s ) {\n    var result = [];\n    var m = re.exec( s );\n    while( m ) {\n        result.push( m[ 1 ] );\n        m = re.exec( s );\n    }\n    return result;\n};\n\nconst conditionsRE = /conditions\\.([a-zA-Z]\\w*)(\\W*|$)/g;\n\n/**\n * Get all nested conditions from a condition expression. See unit tests for examples.\n *\n * @param {String|Object} s condition expression\n * @returns {String[]} nested conditions\n */\nconst getConditions = function( s ) {\n    if( typeof s === 'string' ) {\n        return getAllMatches( conditionsRE, s );\n    }\n    if( typeof s === 'object' ) {\n        return Object.keys( s ).map( k => s[ k ] ) //Object.values( s ) if not for IE11\n            .reduce( ( acc, nxt ) => acc.concat( getConditions( nxt ) ), [] );\n    }\n    return [];\n};\n\n/**\n * Utility to get the actual condition expression from the commands view model\n *\n * @param {Object} commandsViewModel The commands view model\n * @param {String} condition The conditon name (\"conditions.asdf\")\n * @returns {String|Object} The condition expression (string or object)\n */\nconst getConditionExpression = function( commandsViewModel, condition ) {\n    var conditionName = condition.split( '.' )[ 1 ];\n    var expression = _.get( commandsViewModel, `_internal.conditions.${conditionName}.expression`, null ) ||\n        _.get( commandsViewModel, `conditions.${conditionName}.expression`, null );\n    if( expression === null ) {\n        //If condition does not exist return \"false\" to avoid console errors (same behavior)\n        logger.error( `Reference to missing condition \"${conditionName}\"` );\n        expression = 'false';\n    }\n    return expression;\n};\n\n/**\n * Recurses into the object and sub objects and finds real length of the expression by replacing the\n * references to other condition.xyz conditions\n *\n * @param {Object|String} expression expression whose actual length is desired\n * @param {Object} internalViewModel Object holding all expression definitions\n * @returns {Number} the length of the expression\n */\nconst getExpressionLength = function( expression, internalViewModel ) {\n    var sum = function( a, b ) {\n        return a + b;\n    };\n    if( typeof expression === 'string' ) {\n        return expression.length;\n    }\n    return _.map( expression, function( value, key ) {\n        if( key === '__useSourceParsing' ) {\n            return 0;\n        }\n        var length = String( key ).length;\n        if( value && _.isString( value ) ) {\n            var nestedConditions = getConditions( value );\n            if( nestedConditions.length > 0 ) {\n                var nestedConditionLength = nestedConditions.map( function( condName ) {\n                    return getExpressionLength( getConditionExpression( internalViewModel, 'conditions.' + condName ), internalViewModel );\n                } ).reduce( sum );\n                return length + nestedConditionLength;\n            }\n            return length + String( value ).length;\n        }\n        if( _.isObject( value ) ) {\n            return length + getExpressionLength( value, internalViewModel );\n        }\n        return length + String( value ).length;\n    } ).reduce( sum );\n};\n\nconst exports = {\n    updateShortConditions,\n    getCommandsViewModel,\n    getConditions,\n    getConditionExpression,\n    getExpressionLength\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}