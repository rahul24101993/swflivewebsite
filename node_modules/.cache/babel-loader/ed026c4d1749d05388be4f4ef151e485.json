{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\pltable\\\\src\\\\js\\\\splmTableEditor.js\";\n\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the edit function for PL Table.\n *\n * @module js/splmTableEditor\n */\nimport SPLMTableFillDown from 'js/splmTableFillDown';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport uwPropertyService from 'js/uwPropertyService';\nimport browserUtils from 'js/browserUtils';\nimport { getEditContext, displayAutoSaveOnGuidanceMessage, displayCellEditDisabledGuidanceMessage } from 'js/splmTableDirectEditUtils';\nimport { includeComponent } from 'js/moduleLoader';\nimport { renderComponent } from 'js/declReactUtils';\nimport { AppCtxComponent } from 'js/reactAppCtx';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Cell from 'js/splmTableCellRenderer';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar SPLMTableEditor = function (tableElem, directiveElem, gridContextDispatcher) {\n  let _trv = new Trv(tableElem);\n\n  let _fillDown = new SPLMTableFillDown(tableElem);\n\n  let _lovValueChangedEventSubs = {};\n  let _blurHandler = null;\n  let _focusProp = null;\n\n  let _tableInstance = util.getTableInstance(tableElem);\n\n  let _selectedCellInfo = null;\n  let _saveEditPromise = null;\n  let _isEditablePromise = null;\n  let _escapeKeyHandler = null;\n  let _enterKeyHandler = null;\n  let _fillDownSaveInprogress = false;\n  const ariaReadOnly = 'aria-readonly';\n  const ariaActiveDescendant = 'aria-activedescendant'; // cache local event subscription\n\n  let _eventBusSubs = [];\n  let self = this; // eslint-disable-line no-invalid-this\n\n  const destroyLovEventListeners = function () {\n    _.forEach(_lovValueChangedEventSubs, function (subscription) {\n      eventBus.unsubscribe(subscription);\n    });\n\n    _lovValueChangedEventSubs = {};\n  };\n\n  self.destroy = function () {\n    destroyLovEventListeners();\n\n    _.forEach(_eventBusSubs, function (sub) {\n      eventBus.unsubscribe(sub);\n    });\n\n    _eventBusSubs = [];\n  };\n\n  self.setFocusProp = function (prop) {\n    _focusProp = prop;\n  };\n\n  const triggerBlurHandler = function () {\n    if (_blurHandler) {\n      _blurHandler();\n    }\n  };\n\n  self.updateEditStatus = function () {\n    triggerBlurHandler();\n\n    var cellElems = _trv.getContentCellElementsFromTable();\n\n    _.forEach(cellElems, function (elem) {\n      self.updateEditStatusForCell(elem);\n    });\n\n    if (!util.isBulkEditing(tableElem)) {\n      _focusProp = null;\n      destroyLovEventListeners();\n    }\n  };\n\n  const toggleLinkStyle = function (element, isLinkStyle) {\n    if (isLinkStyle) {\n      // disabled to active link\n      var linkElements = element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n\n      for (var i = linkElements.length; i > 0; i--) {\n        var linkElem = linkElements[i - 1];\n\n        if (linkElem && linkElem.classList) {\n          linkElem.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n          linkElem.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n        }\n      }\n    } else {\n      // active to disabled links\n      linkElements = element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n\n      for (var j = linkElements.length; j > 0; j--) {\n        var linkElem1 = linkElements[j - 1];\n\n        if (linkElem1 && linkElem1.classList) {\n          linkElem1.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n          linkElem1.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n        }\n      }\n    }\n  };\n  /**\n   * Ensure the drag handle is the last element in the parent container.\n   *\n   * @param {DOMElement} cell - cell with drag handle to re-append\n   */\n\n\n  const ensureDragHandleLastChild = function (cell) {\n    var dragHandleElements = cell.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE);\n\n    if (dragHandleElements.length > 0) {\n      dragHandleElements[0].parentElement.appendChild(dragHandleElements[0]);\n    }\n  };\n\n  const reverseEditCell = function (cell, vmo, column, cellElemProperty) {\n    if (cell.parentElement === null) {\n      return;\n    }\n\n    cell.isElementInEdit = false;\n    var editCells = null;\n\n    if (cellElemProperty.isArray) {\n      editCells = cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY);\n    } else {\n      editCells = cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP);\n    }\n\n    var isErrorProperty = false;\n    var cellTopElement = Cell.createElement(column, vmo, tableElem, cell.parentElement);\n\n    if (_tableInstance.dynamicRowHeightStatus === true) {\n      Cell.addDynamicCellHeight(vmo, cellTopElement);\n    }\n\n    if (editCells.length > 0) {\n      var editCell = editCells[0];\n\n      if (cellElemProperty.isArray) {\n        const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n\n        if (editArrayPopup) {\n          editArrayPopup.hide();\n        }\n      } else {\n        editCell.parentElement.removeChild(editCell);\n      }\n\n      setTimeout(function () {\n        util.cleanupComponents(editCell);\n        var propertyErrorElements = editCell.getElementsByClassName('aw-widgets-propertyError');\n\n        if (propertyErrorElements.length > 0) {\n          isErrorProperty = true;\n        }\n\n        if (isErrorProperty) {\n          cellTopElement.classList.add('aw-widgets-propertyError');\n        }\n\n        if (!cellElemProperty.isArray) {\n          util.destroyElement(editCell);\n        }\n      }, 1000);\n    }\n\n    cell.classList.remove(Const.CLASS_AW_IS_EDITING);\n    cell.appendChild(cellTopElement);\n    var cellTopElements = cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP);\n\n    if (cellTopElements.length > 0) {\n      cellTopElements[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);\n    }\n\n    ensureDragHandleLastChild(cell);\n  };\n\n  const removeFocusEvents = function (cellElem) {\n    const useCapture = true;\n    cellElem.removeEventListener('focus', cellElem.onFocusEvent, useCapture);\n    cellElem.onFocusEvent = null;\n    cellElem.removeEventListener('mousedown', cellElem.onFocusClickEvent);\n    cellElem.onFocusClickEvent = null;\n  };\n\n  let _isUserClick = false;\n  let _isCtrlKey = false;\n\n  const addFocusEvent = function (cellElem, vmo) {\n    removeFocusEvents(cellElem);\n\n    const onFocusEvent = function (event) {\n      // Update row selection if clicking on editable cell. This is needed because UW widget stops propagation of the event\n      // to the row element when it is created.\n      if (_isUserClick) {\n        let eventObj;\n\n        if (browserUtils.isIE) {\n          eventObj = document.createEvent('MouseEvent');\n          eventObj.initMouseEvent('click', true, true, window, 0, eventObj.screenX, eventObj.screenY, eventObj.clientX, eventObj.clientY, _isCtrlKey, false, false, false, 0, null);\n        } else {\n          eventObj = new MouseEvent('click', {\n            ctrlKey: _isCtrlKey\n          });\n        }\n\n        cellElem.parentElement.dispatchEvent(eventObj);\n        _isUserClick = false;\n        _isCtrlKey = false;\n      }\n\n      self.editCell(cellElem, vmo);\n    };\n\n    cellElem.onFocusEvent = onFocusEvent;\n    const useCapture = true; // LCS-357443: IE does not focus the cell when using element.onfocus.\n    // Instead focus event must be added with addEventListener and useCapture as true.\n\n    cellElem.addEventListener('focus', onFocusEvent, useCapture);\n\n    const isFocusClickEvent = function (event) {\n      _isUserClick = true;\n      _isCtrlKey = event.ctrlKey;\n    };\n\n    cellElem.isFocusClickEvent = isFocusClickEvent;\n    cellElem.addEventListener('mousedown', isFocusClickEvent);\n  };\n\n  const addEditStatus = function (cellElem, cellElemProperty, vmo) {\n    if (cellElem.children[0]) {\n      cellElem.children[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);\n      var rowHeight = util.getTableRowHeight(_tableInstance.gridOptions, undefined);\n\n      if (rowHeight !== undefined) {\n        cellElem.children[0].style.height = rowHeight + 'px';\n      }\n    } else {\n      logger.debug(cellElem.propName + ' has no child');\n    }\n\n    addFocusEvent(cellElem, vmo);\n\n    _fillDown.enableFillDown(cellElem);\n\n    toggleLinkStyle(cellElem, false); // for saved cells in partial edit status\n\n    var cellTop = cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0] || cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP)[0] || cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY)[0];\n    Cell.updateCellChangedClass(cellElemProperty, cellTop);\n\n    if (_focusProp === cellElem.prop) {\n      self.editCell(cellElem, vmo);\n    }\n  };\n\n  const removeBlurHandler = function () {\n    const useCapture = true;\n    document.body.removeEventListener('click', _blurHandler, useCapture);\n\n    _trv.getScrollCanvasElementFromTable().removeEventListener('scroll', _blurHandler, useCapture);\n\n    _trv.getPinCanvasElementFromTable().removeEventListener('scroll', _blurHandler, useCapture);\n  };\n\n  const removeEscapeAndEnterHandlers = function (cell) {\n    document.body.removeEventListener('keydown', _escapeKeyHandler, true);\n    cell.removeEventListener('keydown', _enterKeyHandler, true);\n    _escapeKeyHandler = null;\n    _enterKeyHandler = null;\n  };\n\n  const setBlurHandler = function (blurHandler) {\n    _blurHandler = blurHandler;\n  };\n\n  const removeEditStatus = function (cellElem, cellElemProperty, vmo, skipCellCreation) {\n    const cellTopElem = cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];\n\n    if (cellTopElem && (cellTopElem.classList.contains(Const.CLASS_AW_EDITABLE_CELL) || cellTopElem.classList.contains(Const.CLASS_CELL_CHANGED)) || cellElem.propIsEditableCache) {\n      if (!cellElemProperty.isArray && !cellElem.isSelected) {\n        _fillDown.disableFillDown(cellElem);\n      }\n\n      if (!skipCellCreation) {\n        cellElem.removeChild(cellTopElem);\n        reverseEditCell(cellElem, vmo, cellElem.columnDef, cellElemProperty);\n      }\n\n      cellElem.children[0].classList.remove(Const.CLASS_AW_EDITABLE_CELL);\n      removeFocusEvents(cellElem);\n    }\n\n    toggleLinkStyle(cellElem, true);\n  };\n\n  self.updateEditStatusForCell = function (cellElem) {\n    var cellElemProperty = cellElem.prop;\n    let vmo = util.getViewModelObjectByCellElement(cellElem);\n    vmo = getVmoById(vmo.alternateID || vmo.uid); // get latest vmo from collection rather than cached\n\n    var vmoProp = vmo && vmo.props && vmo.props[cellElem.propName];\n\n    if (cellElem.propName && cellElemProperty && cellElem.columnDef.isTreeNavigation !== true) {\n      // LCS-142669 - read modifiable besides of isEditable\n      if ((cellElemProperty.isEditable || vmoProp && vmoProp.isEditable) && cellElem.columnDef.modifiable !== false && util.isBulkEditing(tableElem)) {\n        addEditStatus(cellElem, cellElemProperty, vmo);\n      } else if (cellElem.isSelected && cellElem.propIsEditableCache && cellElemProperty.isPropInEdit) {\n        addEditStatus(cellElem, cellElemProperty, vmo);\n      } else {\n        removeEditStatus(cellElem, cellElemProperty, vmo);\n\n        if (util.isBulkEditing(tableElem)) {\n          cellElem.setAttribute(ariaReadOnly, 'true');\n        } else if (cellElem.hasAttribute(ariaReadOnly) && cellElem.propIsEditableCache !== false) {\n          cellElem.removeAttribute(ariaReadOnly);\n        }\n      }\n    } else if (util.isBulkEditing(tableElem)) {\n      cellElem.setAttribute(ariaReadOnly, 'true');\n    } else if (cellElem.hasAttribute(ariaReadOnly) && cellElem.propIsEditableCache !== false) {\n      cellElem.removeAttribute(ariaReadOnly);\n    }\n  };\n  /**\n   * Subscribe to lovValueChangedEvent. Update dependent cells\n   */\n\n\n  const subscribeToLovValueChangedEvent = function (cell, vmo, prop) {\n    return eventBus.subscribe(prop.propertyName + '.lovValueChanged', function () {\n      // Update dependent LOVS only\n      if (!prop.lovApi || !prop.lovApi.behaviorData || prop.lovApi.behaviorData.style !== 'Interdependent') {\n        return;\n      }\n\n      prop.lovApi.behaviorData.dependendProps.forEach(function (propertyName) {\n        // Only update cells for other props\n        if (prop.propertyName !== propertyName) {\n          var row = cell.parentElement; // Find the cell\n\n          _.forEach(row.children, function (cellElem) {\n            if (cellElem.propName === propertyName) {\n              // Update cell content\n              var oldCellTop = cellElem.children[0];\n              var newCellTop = Cell.createElement(cellElem.columnDef, row.vmo, tableElem, row);\n\n              if (_tableInstance.dynamicRowHeightStatus === true) {\n                Cell.addDynamicCellHeight(vmo, newCellTop);\n              }\n\n              newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);\n              cellElem.replaceChild(newCellTop, oldCellTop);\n              cellElem.isDependantEdit = true;\n\n              if (!util.isBulkEditing(tableElem) && util.isAutoSaveEnabled(tableElem)) {\n                self.removeAllCellSelection();\n                self.editCell(cellElem, vmo);\n              }\n\n              return false;\n            }\n\n            return true;\n          });\n        }\n      });\n    });\n  };\n  /**\n   * Cancels edits if isDirty() comes back false\n   */\n\n\n  const cancelEditsIfNotDirty = function () {\n    const context = getEditContext(_tableInstance);\n    let editHandler = null;\n    let isDirtyPromise;\n\n    if (context) {\n      editHandler = editHandlerSvc.getEditHandler(context);\n      isDirtyPromise = editHandler.isDirty();\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      isDirtyPromise = _tableInstance.dataProvider.isDirty();\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      isDirtyPromise = _tableInstance.declViewModel.isDirty();\n    }\n\n    if (isDirtyPromise) {\n      isDirtyPromise.then(function (isDirty) {\n        // If the handler is not dirty cancel edits to get out of edit mode.\n        if (!isDirty) {\n          if (editHandler) {\n            editHandler.cancelEdits();\n          } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n            const dataCtxNode = {\n              data: _tableInstance.declViewModel,\n              ctx: appCtxService.ctx\n            };\n\n            _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n          } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n            _tableInstance.declViewModel.cancelEdits();\n          }\n        }\n      });\n    }\n  };\n  /**\n   * Handles cell editing functionality for the blur event\n   * @param {Event} event - the blur event\n   * @param {DOMElement} cell - The cell element\n   * @param {ViewModelProperty} prop - The property\n   * @param {ViewModelObject} vmo - The view model object\n   */\n\n\n  const handleCellEditBlur = function (event, cell, prop, vmo) {\n    // Autosave the cell on blur when in autosave mode\n    if (!util.isBulkEditing(tableElem) && util.isAutoSaveEnabled(tableElem) && event && !_fillDownSaveInprogress) {\n      // Stop the event bubbling so save can finish first, we will resend the click when save is finished\n      event.stopPropagation();\n      event.preventDefault();\n\n      _fillDown.disableFillDown(cell); // get target vmo/prop if clicking on table so we can resend click to it after\n\n\n      const tableCell = util.closestElement(event.target, '.ui-grid-cell');\n      let vmo;\n      let propName;\n\n      if (tableCell) {\n        propName = tableCell.propName;\n        vmo = util.getViewModelObjectByCellElement(tableCell);\n      }\n\n      _saveEditPromise = self.saveEdit([cell]).then(() => {\n        _saveEditPromise = null;\n\n        if (!tableCell) {\n          let clickElement = event.target; // Elements like svg don't have a click function, so bubble up till we have a clickable element.\n\n          while (!clickElement.click) {\n            clickElement = clickElement.parentElement;\n          }\n\n          clickElement.click();\n        } else {\n          // reselect table cell\n          let uid = vmo && vmo.alternateID || vmo.uid;\n          let cellToSelect = util.getCellElementsByPropertyAndUid(tableElem, propName, uid)[0];\n          cellToSelect && cellToSelect.click && cellToSelect.click();\n        }\n      });\n    } else if (!util.isBulkEditing(tableElem) && !util.isAutoSaveEnabled(tableElem)) {\n      cancelEditsIfNotDirty();\n      removeEditStatus(cell, prop, vmo, true);\n    }\n  };\n  /**\n   * Returns the focusable cell info if it is focusable\n   *\n   * @param {Object} column - the column\n   * @param {ViewModelObject} vmo - the vmo\n   *\n   * @return {Object} the focusable cell's info\n   */\n\n\n  const getFocusableCellInfo = function (column, vmo) {\n    if (column.modifiable !== false && !column.isTreeNavigation) {\n      const propName = column.propertyName || column.field;\n      const prop = vmo.props[propName];\n\n      if (prop && prop.isEditable) {\n        return {\n          vmo: vmo,\n          column: column\n        };\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Returns the info of the next focusable cell\n   *\n   * @param {ViewModelObject} currentVMO - the current vmo\n   * @param {Object} currentColumn - the current column\n   * @param {boolean} reverseDirection - true if going in the reverse direction\n   *\n   * @return {Object} the next focusable cell's info\n   */\n\n\n  const getNextFocusableCellInfo = (currentVMO, currentColumn, reverseDirection) => {\n    let columns = _tableInstance.dataProvider.cols.filter(function (col) {\n      return !col.hiddenFlag;\n    });\n\n    const currentIdx = columns.indexOf(currentColumn); // Reverse the columns order if we are going in reverse\n\n    if (reverseDirection) {\n      columns = columns.slice().reverse();\n    }\n\n    for (let i = currentIdx + 1; i < columns.length; i++) {\n      const col = columns[i];\n      const focusableCellInfo = getFocusableCellInfo(col, currentVMO);\n\n      if (focusableCellInfo) {\n        return focusableCellInfo;\n      }\n    } // If no cell was found, check next vmo until found  -- Limit - Until end of data, will not page while looking\n\n\n    const loadedVMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n\n    const currentVMOIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(currentVMO.uid);\n\n    for (let i = currentVMOIndex + 1; i < loadedVMOs.length; i++) {\n      const nextVMO = loadedVMOs[i];\n\n      for (let y = 0; y < columns.length; y++) {\n        const col = columns[y];\n        const focusableCellInfo = getFocusableCellInfo(col, nextVMO);\n\n        if (focusableCellInfo) {\n          return focusableCellInfo;\n        }\n      }\n    } // If we still haven't found anything, then there are no more editable cells available, return null\n\n\n    return null;\n  };\n  /**\n   * Attaches the keydown handler to a cell\n   * @param {DOMElement} cellElem The cell element\n   */\n\n\n  const attachKeydownHandler = cellElem => {\n    cellElem.onkeydown = event => {\n      if (event.code !== 'Tab') {\n        return;\n      }\n\n      let reverseTab = false;\n\n      if (event.shiftKey) {\n        reverseTab = true;\n      } // Now check vmo for next editable column.\n\n\n      const closestVMO = event.target.closest('.ui-grid-row').vmo;\n      const column = event.target.closest('.ui-grid-cell').columnDef;\n      const nextEditableInfo = getNextFocusableCellInfo(closestVMO, column, reverseTab); // Scroll to that cell if exists\n\n      if (nextEditableInfo) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        const vmoIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(nextEditableInfo.vmo.uid);\n\n        triggerBlurHandler();\n\n        _tableInstance.renderer.scrollToRowIndex([vmoIndex]);\n\n        if (!nextEditableInfo.column.pinnedLeft) {\n          _tableInstance.renderer.scrollToColumn(nextEditableInfo.column);\n        }\n\n        setTimeout(() => {\n          // Get the cell and focus it after it is scrolled into view\n          const firstRowOnDom = tableElem.getElementsByClassName('ui-grid-row')[0];\n\n          if (firstRowOnDom) {\n            const editableRowRelativeIdx = vmoIndex - firstRowOnDom.getAttribute('data-indexNumber');\n            let rowElem;\n\n            if (nextEditableInfo.column.pinnedLeft) {\n              rowElem = _trv.getPinContentRowElementFromTable(editableRowRelativeIdx);\n            } else {\n              rowElem = _trv.getScrollContentRowElementFromTable(editableRowRelativeIdx);\n            }\n\n            const cellElems = rowElem && rowElem.getElementsByClassName('ui-grid-cell') || [];\n\n            const foundCell = _.filter(cellElems, {\n              columnDef: nextEditableInfo.column\n            })[0];\n\n            if (foundCell) {\n              self.editCell(foundCell, nextEditableInfo.vmo);\n            }\n          }\n        }, 200);\n      }\n    };\n  };\n\n  const attachEscapeKeyHandler = (cell, prop, vmo, column) => {\n    // Set listener for Escape key and reverse edit cell\n    _escapeKeyHandler = event => {\n      if (event.key !== 'Escape') {\n        return;\n      }\n\n      const currentCell = util.closestElement(event.target, '.' + Const.CLASS_CELL);\n\n      if (currentCell === cell && cell.isElementInEdit) {\n        event.stopPropagation();\n        uwPropertyService.resetUpdates(prop);\n        reverseEditCell(cell, vmo, column, prop);\n\n        if (!util.isBulkEditing(tableElem)) {\n          prop.isPropInEdit = false;\n          removeEditStatus(cell, prop, vmo, true); // Check if isDirty still, is so, do nothing, else cancel edits\n\n          cancelEditsIfNotDirty();\n          removeEscapeAndEnterHandlers(cell);\n          cell.focus();\n        } else {\n          // Readd click handler to allow cell to go back into edit\n          addFocusEvent(cell, vmo);\n        }\n      } else {\n        const context = getEditContext(_tableInstance);\n        let editHandler = editHandlerSvc.getEditHandler(context);\n\n        if (editHandler) {\n          editHandler.cancelEdits();\n        } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n          const dataCtxNode = {\n            data: _tableInstance.declViewModel,\n            ctx: appCtxService.ctx\n          };\n\n          _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n        } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n          _tableInstance.declViewModel.cancelEdits();\n        }\n      }\n    };\n\n    document.body.addEventListener('keydown', _escapeKeyHandler, true);\n  };\n\n  const attachEnterKeyHandler = (cell, blurHandler) => {\n    const hasPopupExpanded = element => {\n      const popupVisible = element.getElementsByClassName('aw-jswidgets-popUpVisible');\n      const expanded = element.getElementsByClassName('aw-jswidgets-expanded');\n      return popupVisible.length + expanded.length > 0;\n    };\n\n    _enterKeyHandler = event => {\n      if (event.key === 'Enter' && !event.altKey && !util.isBulkEditing(tableElem)) {\n        const currentCell = util.closestElement(event.target, '.' + Const.CLASS_CELL); // Special handling for array properties\n\n        const isArrayProperty = currentCell.prop && currentCell.prop.isArray;\n\n        if (isArrayProperty) {\n          if (event.target.value === '') {\n            event.stopPropagation();\n            blurHandler(event);\n\n            if (!util.isBulkEditing(tableElem)) {\n              currentCell.focus();\n            }\n          }\n        } else {\n          // If there isn't a popup in the children, then call blurhandler\n          if (currentCell && !hasPopupExpanded(currentCell)) {\n            event.stopPropagation();\n            blurHandler(event);\n\n            if (_saveEditPromise) {\n              _saveEditPromise.then(function () {\n                currentCell.focus();\n              });\n            } else {\n              currentCell.focus();\n            }\n          }\n        }\n      }\n    };\n\n    cell.addEventListener('keydown', _enterKeyHandler, true);\n  };\n  /**\n   * Publishes teh cell start edit event\n   * @param {DOMElement} cell The cell element\n   * @param {Object} vmo the view model object\n   */\n\n\n  const publishCellStartEditEvent = function (cell, vmo) {\n    const eventData = {\n      columnInfo: cell.columnDef,\n      gridId: tableElem.id,\n      vmo: vmo\n    };\n    eventBus.publish(tableElem.id + '.cellStartEdit', eventData);\n  };\n\n  const getVmoById = function (vmoId) {\n    let idx = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(vmoId);\n\n    return _tableInstance.dataProvider.viewModelCollection.loadedVMObjects[idx];\n  };\n  /**\n   * Unsubscribes from the hold lov value change event and subscribes to a new one\n   * @param {DOMElement} cell the cell element\n   * @param {Object} vmo the view model object\n   * @param {Object} prop The property\n   */\n\n\n  const handleLovValueChangedEvent = function (cell, vmo, prop) {\n    const lovValueChangedEventSub = subscribeToLovValueChangedEvent(cell, vmo, prop);\n    let oldLovSubscr = _lovValueChangedEventSubs[prop.parentUid + prop.propertyName];\n\n    if (oldLovSubscr) {\n      eventBus.unsubscribe(oldLovSubscr);\n      delete _lovValueChangedEventSubs[prop.parentUid + prop.propertyName];\n    }\n\n    _lovValueChangedEventSubs[prop.parentUid + prop.propertyName] = lovValueChangedEventSub;\n  };\n\n  const isUserInteractingWithDropDown = (prop, event) => {\n    if (prop.hasLov && event) {\n      const listBoxDrop = document.querySelector('.sw-lov-contentContainer');\n\n      if (listBoxDrop && listBoxDrop.contains(event.target)) {\n        return true;\n      }\n    } else if (prop.type && event && (prop.type === 'DATE' || prop.type === 'DATEARRAY')) {\n      const datePicker = document.querySelector('.flatpickr-calendar.open');\n\n      if (datePicker && datePicker.contains(event.target)) {\n        return true;\n      }\n\n      const dateTimeDrop = document.querySelector('.sw-popup-contentContainer .aw-base-scrollPanel');\n\n      if (dateTimeDrop && dateTimeDrop.contains(event.target)) {\n        return true;\n      }\n    } else if (prop.type && event && prop.type === 'STRING' && prop.isRichText) {\n      const ckEditor = document.getElementsByClassName('ck-body-wrapper')[0];\n\n      if (ckEditor && ckEditor.contains(event.target)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Creates the edit cell and attaches it to the DOM\n   * @param {Object} vmo - the view model object\n   * @param {AwColumnDef} column The column definition\n   * @param {DOMElement} cell The cell element\n   */\n\n\n  const createAndAttachEditCell = function (vmo, column, cell) {\n    // for array fields, application should use popup to display it,\n    // or you will face cut off issues: LCS-161794\n    const prop = vmo.props[cell.propName];\n    prop.autofocus = true;\n    let editNonArrayClass = prop.isArray ? Const.CLASS_TABLE_EDIT_CELL_ARRAY : Const.CLASS_TABLE_EDIT_CELL_NON_ARRAY;\n    let editCellElem = util.createElement('div', 'aw-splm-tableEditCellTop', editNonArrayClass);\n    let editContainer = util.createElement('div', 'aw-jswidgets-tableEditContainer', 'aw-jswidgets-cellTop');\n    /* revisitme Brad\n     * Revisit/revise for support of column def providing rendering hint\n     * column.renderingHint\n     */\n\n    let propertyValElem = includeComponent('SplmTableCellEditor', {\n      vmo,\n      name: prop.propertyName\n    });\n    renderComponent( /*#__PURE__*/_jsxDEV(AppCtxComponent, {\n      children: propertyValElem\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 718,\n      columnNumber: 26\n    }, this), editContainer);\n    editCellElem.appendChild(editContainer);\n    attachKeydownHandler(editCellElem);\n    Cell.updateCellChangedClass(prop, editCellElem.getElementsByClassName(Const.CLASS_AW_JS_CELL_TOP)[0]);\n\n    if (prop.isArray && _tableInstance.gridOptions.popupContext && _tableInstance.gridOptions.popupContext.editArrayPopup) {\n      const cellBoundingArea = cell.getBoundingClientRect();\n      const popupOptions = {\n        whenParentScrolls: 'follow',\n        innerClassName: Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY,\n        autoFocus: false,\n        parent: cell,\n        reference: cell,\n        overlapOnReference: true,\n        containerWidth: cellBoundingArea.width,\n        width: cellBoundingArea.width,\n        forceCloseOthers: false\n      };\n      const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n\n      if (editArrayPopup) {\n        editArrayPopup.hide().then(() => {\n          editArrayPopup.show(popupOptions).then(popupRef => {\n            self.popupRef = popupRef;\n          });\n        });\n      }\n    } else {\n      cell.insertBefore(editCellElem, cell.childNodes[0]);\n    }\n  };\n  /**\n   * Starts the edit of the cell\n   * @param {DOMElement} cell The cell element\n   * @param {Object} vmo the view model object\n   */\n\n\n  self.editCell = function (cell, vmo) {\n    const column = cell.columnDef;\n    const prop = cell.prop;\n\n    if (!cell.isDependantEdit && (!cell.isSelected && !util.isBulkEditing(tableElem) || cell.isElementInEdit === true)) {\n      return;\n    }\n\n    gridContextDispatcher({\n      type: 'UPDATE_VALUES',\n      editVmo: vmo,\n      editPropertyName: cell.propName\n    });\n    publishCellStartEditEvent(cell, vmo); // Trigger blur handler\n\n    triggerBlurHandler();\n    cell.isElementInEdit = true;\n    prop.isPropInEdit = true;\n    cell.classList.add(Const.CLASS_AW_IS_EDITING); // Handle possible lov value changes\n\n    handleLovValueChangedEvent(cell, vmo, prop); // Remove cell top\n\n    let editableGridCell = cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];\n\n    if (editableGridCell) {\n      cell.removeChild(editableGridCell);\n    }\n\n    let originAutoFocus = prop.autofocus;\n    createAndAttachEditCell(vmo, column, cell);\n    removeFocusEvents(cell);\n\n    const blurHandler = function (event) {\n      // Only revert edit status if scrolling with array (popup)\n      if (event && event.type === 'scroll' && cell.prop && !cell.prop.isArray) {\n        return;\n      }\n\n      let selectedCell = null;\n\n      if (event && event.type !== 'keydown') {\n        _focusProp = null;\n        selectedCell = util.closestElement(event.target, `.${Const.CLASS_CELL}`);\n      }\n\n      if (!cell.isElementInEdit) {\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers(cell);\n      } else if (selectedCell !== cell && cell.isElementInEdit) {\n        // Close panels\n        let panelContext = appCtxService.getCtx('panelContext');\n\n        if (panelContext && panelContext.addTypeRef === true) {\n          // If clicking on different cell close the panel else leave it open\n          if (cell.propName !== prop.propertyName || cell.parentElement.vmo.uid !== prop.parentUid) {\n            eventBus.publish('completed', {\n              source: 'toolAndInfoPanel'\n            });\n          } else {\n            return;\n          }\n        }\n\n        if (isUserInteractingWithDropDown(prop, event)) {\n          return true;\n        } // Remove the blur handler since cell is going out of edit\n\n\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers(cell); // Reverse the cell edit\n\n        reverseEditCell(cell, vmo, column, prop);\n        prop.autofocus = originAutoFocus;\n        prop.isPropInEdit = false;\n        cell.isSelected = false;\n        delete cell.isDependantEdit; // Handle cell editing functionality on blur\n\n        handleCellEditBlur(event, cell, prop, vmo); // Readd click handler to allow cell to go back into edit\n\n        addFocusEvent(cell, vmo);\n      }\n    }; // Add blur handler to take cell out of edit on click away\n\n\n    removeBlurHandler();\n    removeEscapeAndEnterHandlers(cell); // Setting useCapture to true is needed for autosave since it allows us to detect the click before the target\n    // element does.\n\n    const useCapture = true;\n    document.body.addEventListener('click', blurHandler, useCapture);\n\n    const scrollViewportElem = _trv.getScrollCanvasElementFromTable();\n\n    const pinViewportElem = _trv.getPinCanvasElementFromTable();\n\n    scrollViewportElem.removeEventListener('scroll', blurHandler, useCapture);\n    pinViewportElem.removeEventListener('scroll', blurHandler, useCapture);\n    scrollViewportElem.addEventListener('scroll', blurHandler, useCapture);\n    pinViewportElem.addEventListener('scroll', blurHandler, useCapture);\n    attachEscapeKeyHandler(cell, prop, vmo, column);\n    attachEnterKeyHandler(cell, blurHandler);\n    setBlurHandler(blurHandler);\n  };\n\n  self.isPropertiesEditablePromise = function (editOptions) {\n    let editPromise;\n    const editContext = getEditContext(_tableInstance);\n\n    if (editContext) {\n      // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n      // can be editing at any given time.\n      const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n\n      if (previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler(editContext) && previousActiveHandler.editInProgress()) {\n        editPromise = new Promise(resolve => {\n          previousActiveHandler.leaveConfirmation(() => {\n            editHandlerSvc.setActiveEditHandlerContext(editContext);\n            editHandlerSvc.startEdit(editOptions).then(() => {\n              resolve();\n            });\n          });\n        });\n      } else {\n        editHandlerSvc.setActiveEditHandlerContext(editContext);\n        editPromise = editHandlerSvc.startEdit(editOptions);\n      }\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      const dataCtxNode = {\n        data: _tableInstance.declViewModel,\n        ctx: appCtxService.ctx\n      };\n      editPromise = _tableInstance.dataProvider.startEdit(dataCtxNode, _tableInstance.declViewModel, editOptions);\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      editPromise = _tableInstance.declViewModel.startEdit(editOptions);\n    }\n\n    return editPromise ? editPromise : Promise.resolve(false);\n  };\n  /**\n   * Checks if the provided cell/property is editable by calling startEdit on the editHandler or editConfig\n   * @param {Object} vmo The view model object\n   * @param {DOMElement} cellElem The cell element\n   *\n   * @returns {Promise<Boolean>} Promise that will resolve to the editability of the property\n   */\n\n\n  const isCellEditable = async function (vmo, cellElem) {\n    // Allow save to finish before checking start edit\n    if (_saveEditPromise) {\n      await _saveEditPromise;\n    }\n\n    let prop = vmo.props[cellElem.propName];\n    let propertyNames = [prop.propertyName]; // Need to pass all dependent props to ensure we have latest lsd\n\n    if (prop.lovApi && prop.lovApi.behaviorData && prop.lovApi.behaviorData.style === 'Interdependent') {\n      propertyNames = prop.lovApi.behaviorData.dependendProps;\n    }\n\n    let editOpts = {\n      vmos: [vmo],\n      propertyNames: propertyNames,\n      autoSave: util.isAutoSaveEnabled(tableElem)\n    };\n    const result = await self.isPropertiesEditablePromise(editOpts);\n\n    if (result === false) {\n      return false;\n    } // update prop to latest\n\n\n    prop = vmo.props[cellElem.propName];\n    return prop && prop.isEditable && prop.isEnabled !== false;\n  };\n  /**\n   * Saved the provided cell/property that was edited\n   * @param {DOMElement[]} cells the cells to save\n   * @returns {Promise<Boolean>} Promise that will resolve when save is complete\n   */\n\n\n  self.saveEdit = function (cells) {\n    let isPartialSaveDisabled = true;\n    let editPromise = null;\n    const editContext = getEditContext(_tableInstance);\n\n    if (editContext) {\n      editPromise = editHandlerSvc.saveEdits(editContext, isPartialSaveDisabled, util.isAutoSaveEnabled(tableElem));\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      const dataCtxNode = {\n        data: _tableInstance.declViewModel,\n        ctx: appCtxService.ctx\n      };\n      editPromise = _tableInstance.dataProvider.saveEdits(dataCtxNode, _tableInstance.declViewModel);\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      editPromise = _tableInstance.declViewModel.saveEdits();\n    }\n\n    if (editPromise) {\n      return editPromise.finally(function () {\n        self.setCellEditingContext(false);\n\n        for (let i = 0; i < cells.length; i++) {\n          if (document.body.contains(cells[i])) {\n            self.updateEditStatusForCell(cells[i]);\n          }\n        } // Clear prop is editable cache to ensure newly selected cell makes a startEdit call, since\n        // our save call will likely invalidate the editable cache. This is also ensuring that double click on\n        // another cell takes that cell into edit instead of selected state.\n\n\n        self.clearPropIsEditableCache();\n      });\n    }\n\n    return Promise.resolve(false);\n  };\n  /**\n   * Removes the selected and selectedEditable css classes from any elements that have them\n   */\n\n\n  const removeCellSelection = function () {\n    // Remove all other \"selected\" classes from cells\n    let selected1 = Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE));\n    let selected2 = Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED));\n    let elems = selected1.concat(selected2);\n\n    for (let i = 0; i < elems.length; i++) {\n      elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n      elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED);\n      let containerElement = null; // The below method can result in undefined value.\n\n      containerElement = _trv.getTableContainerElementFromTable();\n\n      if (containerElement && containerElement.hasAttribute(ariaActiveDescendant)) {\n        containerElement.removeAttribute(ariaActiveDescendant);\n      }\n    }\n  };\n  /**\n   * Updates the cell to be selected and sets selection/edit info to false on old selected cell\n   * @param {DOMElement} cell The new selected cell\n   * @param {Boolean} persistEditableFlag flag to denote if isEditable should be persisted\n   */\n\n\n  const updateSelectedCell = function (cell, persistEditableFlag) {\n    if (_selectedCellInfo && _selectedCellInfo.cell) {\n      let _cell = _selectedCellInfo.cell;\n      _cell.isSelected = false;\n      const vmo = getVmoById(_selectedCellInfo.vmoId); // If prop edit is not enabled we should not touch the prop.isEditable flag\n\n      if (!persistEditableFlag && vmo && _cell.prop && util.isPropEditEnabled(tableElem) && !util.isBulkEditing(tableElem)) {\n        _cell.prop.isEditable = false;\n\n        if (vmo.props && vmo.props[_cell.propName]) {\n          vmo.props[_cell.propName].isEditable = false;\n        }\n      }\n    }\n\n    if (cell) {\n      cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED);\n      cell.isSelected = true;\n      let refVmo = util.getViewModelObjectByCellElement(cell);\n      let vmoId = refVmo.alternateID || refVmo.uid;\n      _selectedCellInfo = {\n        cell: cell,\n        vmoId: vmoId\n      };\n      let containerElement = null; // The below method can result in undefined value.\n\n      containerElement = _trv.getTableContainerElementFromTable();\n\n      if (containerElement) {\n        containerElement.setAttribute(ariaActiveDescendant, cell.getAttribute('id'));\n      }\n    } else {\n      _selectedCellInfo = null;\n    }\n  };\n\n  self.clearPropIsEditableCache = function (persistEditableFlag) {\n    const cellElems = _trv.getContentCellElementsFromTable();\n\n    _.forEach(cellElems, function (elem) {\n      delete elem.propIsEditableCache;\n\n      if (elem.hasAttribute(ariaReadOnly)) {\n        elem.removeAttribute(ariaReadOnly);\n      }\n    }); // Reset cell selection since we are clearing editibility cache\n    // making the editability selection classes no longer valid\n\n\n    removeCellSelection();\n    const currentSelectedCell = _selectedCellInfo ? _selectedCellInfo.cell : null;\n    updateSelectedCell(null, persistEditableFlag);\n\n    if (currentSelectedCell && currentSelectedCell.parentElement) {\n      const eventObject = {\n        ctrlKey: false,\n        shiftKey: false,\n        type: 'click'\n      };\n      self.onClickHandler(eventObject, currentSelectedCell, util.getViewModelObjectByCellElement(currentSelectedCell));\n    }\n  };\n  /**\n   * Update the cell editability by using the cached editability or loading the editability if it is not cached\n   * @param {DOMElement} cell - The cell element to get editability for\n   * @param {Object} vmo - the row's view model object\n   */\n\n\n  const updateCellEditability = function (cell, vmo) {\n    // Make some SOA call here for getting the editability\n    removeCellSelection();\n    updateSelectedCell(cell); // Check if cellEdit is enabled and if this cell/prop type supports edit\n\n    const isCellEditSupported = util.isPropEditEnabled(tableElem) && cell.propName && cell.prop && cell.columnDef.isTreeNavigation !== true;\n\n    if (!isCellEditSupported) {\n      cell.setAttribute(ariaReadOnly, 'true');\n      return;\n    } // If prop is modified we can restore editability cache since we know it has not been saved\n    // and was previously editable\n\n\n    if (uwPropertyService.isModified(cell.prop) && cell.propIsEditableCache === undefined && !util.isAutoSaveEnabled(tableElem)) {\n      cell.propIsEditableCache = true;\n    } // Check if editability info exists, if not\n    // Check columnDef if editable, if not add readonly class\n    // If editable, make startEdit call to get editability for cell\n\n\n    if (cell.columnDef.name !== 'icon' && cell.columnDef.modifiable !== false && cell.propIsEditableCache === undefined) {\n      // only allow one check at a time.\n      const cellEditablePromise = function () {\n        return isCellEditable(vmo, cell).then(function (isEditable) {\n          cell.propIsEditableCache = isEditable;\n\n          if (cell.propIsEditableCache === false) {\n            cell.setAttribute(ariaReadOnly, 'true');\n          } else if (cell.hasAttribute(ariaReadOnly)) {\n            cell.removeAttribute(ariaReadOnly);\n          }\n\n          if (cell.isSelected) {\n            if (isEditable) {\n              cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n            }\n\n            _fillDown.enableFillDown(cell);\n          }\n        }).then(function () {\n          delete cell.isCellEditablePromise;\n          _isEditablePromise = null;\n        });\n      };\n\n      if (_isEditablePromise) {\n        _isEditablePromise.then(function () {\n          removeCellSelection();\n          updateSelectedCell(cell);\n          _isEditablePromise = cellEditablePromise();\n          cell.isCellEditablePromise = _isEditablePromise;\n        });\n      } else {\n        _isEditablePromise = cellEditablePromise();\n        cell.isCellEditablePromise = _isEditablePromise;\n      }\n\n      return;\n    }\n\n    if (cell.propIsEditableCache) {\n      // Mark the prop as editable since the cache tells us it is editable\n      cell.prop.isEditable = true;\n      vmo.props[cell.propName].isEditable = true;\n      cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n\n      if (cell.hasAttribute(ariaReadOnly)) {\n        cell.removeAttribute(ariaReadOnly);\n      }\n    } else if (cell.propIsEditableCache === false) {\n      cell.setAttribute(ariaReadOnly, 'true');\n    }\n  };\n\n  let _guidanceMessageInitialized = false;\n\n  const publishCellNotEditable = function (vmo, prop) {\n    eventBus.publish(_tableInstance.gridId + '.plTable.cellNotEditable', {\n      vmo: vmo,\n      prop: prop\n    });\n  };\n  /**\n   * Updates ctx and the editHandler/editConfig to be in editing mode when autosave is off.\n   * Doing this ensures the edit command will get toggled when editing in autosave off mode.\n   * @param {Boolean} isEditing - If in edit\n   */\n\n\n  self.setCellEditingContext = function (isEditing) {\n    // Enable/disable caching\n    if (isEditing) {\n      _tableInstance.dataProvider.cacheCollapse = isEditing;\n    } else {\n      _tableInstance.dataProvider.restoreInitialCacheCollapseState();\n    }\n\n    _tableInstance.controller.setDraggable(!isEditing); // For autosave off we need to see _editing flag and update ctx to get commands to switch over\n\n\n    if (!util.isAutoSaveEnabled(tableElem)) {\n      const editContext = getEditContext(_tableInstance);\n\n      if (editContext) {\n        const editHandler = editHandlerSvc.getEditHandler(editContext);\n        editHandler._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx('editInProgress', editHandler._editing); // Need to ensure this handler is active so that save command will call this handler\n\n        editHandlerSvc.setActiveEditHandlerContext(editContext); // We need to ensure edit handler and edithandlerState to be in sync.\n\n        if (editHandler.editStateChangeDispatcher) {\n          editHandler.editStateChangeDispatcher({\n            type: 'SET_EDIT_STATE_CHANGED',\n            value: editHandler._editing\n          });\n        }\n      } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n        _tableInstance.dataProvider._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx(_tableInstance.dataProvider._appCtxEditInProgress, _tableInstance.dataProvider._editing);\n      } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n        _tableInstance.declViewModel._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx(_tableInstance.declViewModel._internal.eventTopicEditInProgress, _tableInstance.declViewModel._editing);\n      }\n    } // Display guidance message when auto save is off for auto save only table\n\n\n    const isAutoSaveContextTrue = appCtxService.getCtx('autoSave') && appCtxService.getCtx('autoSave.dbValue');\n\n    if (!isAutoSaveContextTrue && tableElem._tableInstance.gridOptions.forceAutoSave && isEditing && !util.isCellEditing(tableElem) && !_guidanceMessageInitialized) {\n      _guidanceMessageInitialized = true;\n      displayAutoSaveOnGuidanceMessage(tableElem);\n    }\n\n    util.setIsCellEditing(tableElem, isEditing);\n  };\n\n  let _cellEditDisabledMessageInitialized = null;\n\n  const isCellSelectedNotEditable = function (cell) {\n    return cell && cell.isSelected && cell.prop && cell.prop.isEditable === false;\n  };\n  /**\n   * Handles the direct edit handling for cell selection\n   * @param {HTMLElement} cell The cell\n   * @param {Object} vmo the view model object\n   */\n\n\n  const handleDirectEdit = function (cell, vmo) {\n    // Start edit\n    removeCellSelection(); // Check if prop isEditable needs to be reset since cache says it is true\n\n    if (!cell.prop.isEditable) {\n      cell.prop.isEditable = true;\n\n      if (vmo.props && vmo.props[cell.propName]) {\n        vmo.props[cell.propName].isEditable = true;\n      }\n    } // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n    // can be editing at any given time.\n\n\n    const editContext = getEditContext(_tableInstance);\n    const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n\n    if (editContext && previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler(editContext) && previousActiveHandler.editInProgress()) {\n      previousActiveHandler.leaveConfirmation(() => {\n        editHandlerSvc.setActiveEditHandlerContext(editContext); // Reregister leaveHandler since we are making the handler active again without calling startEdit\n\n        editHandlerSvc.getEditHandler(editContext).reregisterLeaveHandler();\n        self.editCell(cell, vmo);\n        self.setCellEditingContext(true);\n      });\n    } else {\n      self.editCell(cell, vmo);\n      self.setCellEditingContext(true);\n    }\n  };\n  /**\n   * Handles cell click when pending isEditable Promise\n   * @param {HTMLElement} cell The cell\n   * @param {Object} vmo The view model object\n   */\n\n\n  const handlePendingEditSelection = async function (cell, vmo) {\n    // Prevent multiple calls to resolve editable promise\n    cell.isCellEditablePromiseResolving = true;\n    await cell.isCellEditablePromise;\n    delete cell.isCellEditablePromiseResolving;\n\n    if (cell.isSelected) {\n      if (cell.propIsEditableCache) {\n        _focusProp = cell.prop;\n        removeCellSelection(); // Check if prop isEditable needs to be reset since cache says it is true\n\n        if (!cell.prop.isEditable) {\n          cell.prop.isEditable = true;\n\n          if (vmo.props && vmo.props[cell.propName]) {\n            vmo.props[cell.propName].isEditable = true;\n          }\n        }\n\n        self.editCell(cell, vmo);\n        self.setCellEditingContext(true);\n      } else {\n        publishCellNotEditable(vmo, cell.prop);\n      }\n    }\n  };\n  /**\n   * Click handler for cell/row. Will select the cell and row or start edit as needed\n   *\n   * @param {Event} event the click event\n   * @param {DOMElement} cell the cell in question\n   * @param {ViewModelObject} vmo The vmo for the row\n   */\n\n\n  self.onClickHandler = async (event, cell, vmo) => {\n    if (util.isBulkEditing(tableElem)) {\n      return;\n    }\n\n    if (event.ctrlKey) {\n      triggerBlurHandler();\n      removeCellSelection();\n      updateSelectedCell(null);\n\n      if (util.isCellHeaderSelectionEnabled(tableElem)) {\n        SelectionHelper.setCellHeaderSelection(null, tableElem);\n      }\n\n      return;\n    }\n\n    if (cell.isSelected && cell.propIsEditableCache && !cell.isElementInEdit) {\n      handleDirectEdit(cell, vmo);\n    } else if (cell.isSelected && util.isPropEditEnabled(tableElem) === false && !_cellEditDisabledMessageInitialized) {\n      // Display guidance message when cell editing is disabled\n      _cellEditDisabledMessageInitialized = true;\n      displayCellEditDisabledGuidanceMessage(tableElem);\n    } else if (cell.isSelected && cell.isCellEditablePromise && !cell.isCellEditablePromiseResolving) {\n      handlePendingEditSelection(cell, vmo);\n    } else if (!cell.isSelected && !event.shiftKey) {\n      await updateCellEditability(cell, vmo);\n\n      _fillDown.enableFillDown(cell);\n\n      if (util.isCellHeaderSelectionEnabled(tableElem)) {\n        SelectionHelper.setCellHeaderSelection(cell, tableElem);\n      }\n    } else if (event.shiftKey) {\n      triggerBlurHandler();\n      removeCellSelection();\n      updateSelectedCell(null);\n    } else if (!cell.isCellEditablePromiseResolving && isCellSelectedNotEditable(cell)) {\n      publishCellNotEditable(vmo, cell.prop);\n    }\n  };\n  /**\n   * Adds the onclick event listener for an individual cell and gets its editability\n   * @param {DOMElement} cell - The cell to set the listener for\n   * @param {Object} vmo - The row's VMO\n   */\n\n\n  self.addCellClickListener = function (cell, vmo) {\n    cell.onclick = function (event) {\n      // if command click or url/anchor tag click don't select/handle select\n      if (!event.target.closest('.aw-command, a.aw-splm-tablePropertyValueLinks')) {\n        self.onClickHandler(event, cell, vmo);\n      }\n    };\n\n    cell.oncontextmenu = function (event) {\n      if (!util.isBulkEditing(tableElem) && !cell.isSelected) {\n        updateCellEditability(cell, vmo);\n      }\n    };\n  };\n  /**\n   * Removes the cell selected classes as well as the selected attribute for the cell.\n   */\n\n\n  self.removeAllCellSelection = function () {\n    removeCellSelection();\n    updateSelectedCell();\n  };\n  /**\n   * Checks if the current selected cell is on the newly selected vmo(s), if not remove selection\n   * @param {Object} eventData event data\n   */\n\n\n  const checkCellAndVMOSelection = function (eventData) {\n    let selectedObjects = eventData.selectedObjects;\n\n    if (_selectedCellInfo && _selectedCellInfo.vmoId) {\n      const vmo = getVmoById(_selectedCellInfo.vmoId);\n\n      if (selectedObjects.indexOf(vmo) === -1) {\n        self.removeAllCellSelection();\n      }\n    }\n  };\n\n  const isEligibleForCopyDown = function (columnDef) {\n    if (util.isPropEditEnabled(tableElem) && columnDef.isTreeNavigation !== true && columnDef.name !== 'icon' && columnDef.modifiable !== false) {\n      return true;\n    }\n\n    return false;\n  };\n\n  const copyPropertyToCellContent = function (sourceProperty, vmoUid) {\n    let cellElements = util.getCellElementsByPropertyAndUid(tableElem, sourceProperty.propertyName, vmoUid);\n\n    for (let i = 0; i < cellElements.length; i++) {\n      let cellElem = cellElements[i];\n      let row = cellElem.parentElement;\n      let oldCellTop = cellElem.children[0];\n      let newCellTop = Cell.createElement(cellElem.columnDef, row.vmo, tableElem, row);\n\n      if (util.isBulkEditing(tableElem)) {\n        newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);\n      }\n\n      cellElem.replaceChild(newCellTop, oldCellTop);\n    }\n  };\n\n  const copyFillDownProperty = function (targetProperty, sourceProperty) {\n    targetProperty.uiValue = sourceProperty.uiValue;\n    targetProperty.dbValue = sourceProperty.dbValue;\n    targetProperty.valueUpdated = true;\n    uwPropertyService.updateViewModelProperty(targetProperty);\n  };\n\n  const loadCellEditabilityForTargetCells = function (uid2CellMap, vmos, propertyNames) {\n    let editOpts = {\n      vmos: vmos,\n      propertyNames: propertyNames,\n      autoSave: util.isAutoSaveEnabled(tableElem)\n    };\n    return self.isPropertiesEditablePromise(editOpts).then(function (result) {\n      for (let currentVmo of vmos) {\n        let cell = uid2CellMap[currentVmo.uid];\n\n        if (cell) {\n          cell.propIsEditableCache = result === false ? false : cell.prop && cell.prop.isEditable;\n\n          if (cell.propIsEditableCache === false) {\n            cell.setAttribute(ariaReadOnly, 'true');\n          }\n        }\n      }\n\n      return Promise.resolve(result);\n    });\n  };\n\n  const modifyPropsForCellEdit = function (result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp) {\n    if (result === false) {\n      return;\n    }\n\n    let propsModified = false;\n\n    for (let i = 0; i < vmosToEdit.length; i++) {\n      let currentVMO = vmosToEdit[i];\n      const targetProp = currentVMO.props[eventData.propertyName];\n\n      if (sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable) {\n        propsModified = true;\n        cellsToSave.push(cellMap[currentVMO.uid]); // update the target using the source\n\n        copyFillDownProperty(targetProp, sourceProp);\n        copyPropertyToCellContent(sourceProp, currentVMO.uid);\n      }\n    }\n\n    if (propsModified) {\n      if (util.isAutoSaveEnabled(tableElem)) {\n        self.saveEdit(cellsToSave);\n      } else {\n        self.setCellEditingContext(true);\n      }\n    }\n  };\n\n  const prepareTargetCellPropsInfo = function (vmo, eventData, vmosToEdit, columnDef) {\n    if (isEligibleForCopyDown(columnDef)) {\n      vmosToEdit.push(vmo);\n    }\n  };\n\n  const populateTargetCellPropsLegacyEdit = function (vmo, eventData, sourceProp) {\n    const targetProp = vmo.props[eventData.propertyName];\n\n    if (sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable) {\n      // update the target using the source\n      copyFillDownProperty(targetProp, sourceProp);\n      copyPropertyToCellContent(sourceProp, vmo.uid);\n    }\n  };\n\n  self.fillDownCompleteHandler = eventData => {\n    // get the VMOs from the table\n    let VMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n    let $source = VMOs.filter(function (vmo) {\n      return vmo.uid === eventData.source;\n    });\n    let sourceProp = $source[0] && $source[0].props[eventData.propertyName];\n    let vmosToEdit = [];\n    let cellMap = {};\n    let cellsToSave = []; // Reverse the vmo order if we are going down\n\n    if (eventData.direction !== 'up') {\n      VMOs = VMOs.slice().reverse();\n    } // Attempt to apply the source value to the target properties\n\n\n    let foundLastTarget = false;\n\n    for (let vmo of VMOs) {\n      // Iterate over the vmos until we find the last target prop.\n      if (!foundLastTarget && vmo.uid === eventData.endTarget) {\n        foundLastTarget = true;\n      }\n\n      if (!foundLastTarget) {\n        continue;\n      } // Stop iterating if we reach the source prop\n\n\n      if (vmo.uid === eventData.source) {\n        break;\n      }\n\n      const columnDef = util.getColumnDef(eventData.propertyName, _tableInstance.dataProvider); // Populate target cell props ( bulk edit mode ) or prepare the target prop info ( direct edit )\n\n      if (util.isBulkEditing(tableElem)) {\n        populateTargetCellPropsLegacyEdit(vmo, eventData, sourceProp);\n      } else {\n        const targetCell = util.getCellElementsByPropertyAndUid(tableElem, eventData.propertyName, vmo.uid)[0];\n\n        if (targetCell) {\n          cellMap[vmo.uid] = targetCell;\n        }\n\n        prepareTargetCellPropsInfo(vmo, eventData, vmosToEdit, columnDef);\n      }\n    } // Load editabilty and apply value to editable cells\n\n\n    if (!util.isBulkEditing(tableElem)) {\n      _fillDownSaveInprogress = true;\n      let propertyNames = [eventData.propertyName];\n      loadCellEditabilityForTargetCells(cellMap, vmosToEdit, propertyNames).then(result => {\n        modifyPropsForCellEdit(result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp);\n        _fillDownSaveInprogress = false;\n      });\n    }\n  };\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectNone`, self.removeAllCellSelection));\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectAll`, self.removeAllCellSelection));\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectionChangeEvent`, checkCellAndVMOSelection));\n};\n\n_c = SPLMTableEditor;\nexport default SPLMTableEditor;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableEditor\");","map":{"version":3,"names":["SPLMTableFillDown","_","appCtxService","editHandlerSvc","eventBus","logger","uwPropertyService","browserUtils","getEditContext","displayAutoSaveOnGuidanceMessage","displayCellEditDisabledGuidanceMessage","includeComponent","renderComponent","AppCtxComponent","Trv","Const","util","Cell","SelectionHelper","SPLMTableEditor","tableElem","directiveElem","gridContextDispatcher","_trv","_fillDown","_lovValueChangedEventSubs","_blurHandler","_focusProp","_tableInstance","getTableInstance","_selectedCellInfo","_saveEditPromise","_isEditablePromise","_escapeKeyHandler","_enterKeyHandler","_fillDownSaveInprogress","ariaReadOnly","ariaActiveDescendant","_eventBusSubs","self","destroyLovEventListeners","forEach","subscription","unsubscribe","destroy","sub","setFocusProp","prop","triggerBlurHandler","updateEditStatus","cellElems","getContentCellElementsFromTable","elem","updateEditStatusForCell","isBulkEditing","toggleLinkStyle","element","isLinkStyle","linkElements","getElementsByClassName","CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED","i","length","linkElem","classList","add","CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS","remove","j","linkElem1","ensureDragHandleLastChild","cell","dragHandleElements","CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE","parentElement","appendChild","reverseEditCell","vmo","column","cellElemProperty","isElementInEdit","editCells","isArray","CLASS_TABLE_EDIT_CELL_TOP_ARRAY","CLASS_TABLE_EDIT_CELL_TOP","isErrorProperty","cellTopElement","createElement","dynamicRowHeightStatus","addDynamicCellHeight","editCell","editArrayPopup","gridOptions","popupContext","hide","removeChild","setTimeout","cleanupComponents","propertyErrorElements","destroyElement","CLASS_AW_IS_EDITING","cellTopElements","CLASS_TABLE_CELL_TOP","CLASS_AW_EDITABLE_CELL","removeFocusEvents","cellElem","useCapture","removeEventListener","onFocusEvent","onFocusClickEvent","_isUserClick","_isCtrlKey","addFocusEvent","event","eventObj","isIE","document","createEvent","initMouseEvent","window","screenX","screenY","clientX","clientY","MouseEvent","ctrlKey","dispatchEvent","addEventListener","isFocusClickEvent","addEditStatus","children","rowHeight","getTableRowHeight","undefined","style","height","debug","propName","enableFillDown","cellTop","updateCellChangedClass","removeBlurHandler","body","getScrollCanvasElementFromTable","getPinCanvasElementFromTable","removeEscapeAndEnterHandlers","setBlurHandler","blurHandler","removeEditStatus","skipCellCreation","cellTopElem","contains","CLASS_CELL_CHANGED","propIsEditableCache","isSelected","disableFillDown","columnDef","getViewModelObjectByCellElement","getVmoById","alternateID","uid","vmoProp","props","isTreeNavigation","isEditable","modifiable","isPropInEdit","setAttribute","hasAttribute","removeAttribute","subscribeToLovValueChangedEvent","subscribe","propertyName","lovApi","behaviorData","dependendProps","row","oldCellTop","newCellTop","replaceChild","isDependantEdit","isAutoSaveEnabled","removeAllCellSelection","cancelEditsIfNotDirty","context","editHandler","isDirtyPromise","getEditHandler","isDirty","dataProvider","getEditConfiguration","declViewModel","then","cancelEdits","dataCtxNode","data","ctx","handleCellEditBlur","stopPropagation","preventDefault","tableCell","closestElement","target","saveEdit","clickElement","click","cellToSelect","getCellElementsByPropertyAndUid","getFocusableCellInfo","field","getNextFocusableCellInfo","currentVMO","currentColumn","reverseDirection","columns","cols","filter","col","hiddenFlag","currentIdx","indexOf","slice","reverse","focusableCellInfo","loadedVMOs","viewModelCollection","loadedVMObjects","currentVMOIndex","findViewModelObjectById","nextVMO","y","attachKeydownHandler","onkeydown","code","reverseTab","shiftKey","closestVMO","closest","nextEditableInfo","vmoIndex","renderer","scrollToRowIndex","pinnedLeft","scrollToColumn","firstRowOnDom","editableRowRelativeIdx","getAttribute","rowElem","getPinContentRowElementFromTable","getScrollContentRowElementFromTable","foundCell","attachEscapeKeyHandler","key","currentCell","CLASS_CELL","resetUpdates","focus","attachEnterKeyHandler","hasPopupExpanded","popupVisible","expanded","altKey","isArrayProperty","value","publishCellStartEditEvent","eventData","columnInfo","gridId","id","publish","vmoId","idx","handleLovValueChangedEvent","lovValueChangedEventSub","oldLovSubscr","parentUid","isUserInteractingWithDropDown","hasLov","listBoxDrop","querySelector","type","datePicker","dateTimeDrop","isRichText","ckEditor","createAndAttachEditCell","autofocus","editNonArrayClass","CLASS_TABLE_EDIT_CELL_ARRAY","CLASS_TABLE_EDIT_CELL_NON_ARRAY","editCellElem","editContainer","propertyValElem","name","CLASS_AW_JS_CELL_TOP","cellBoundingArea","getBoundingClientRect","popupOptions","whenParentScrolls","innerClassName","autoFocus","parent","reference","overlapOnReference","containerWidth","width","forceCloseOthers","show","popupRef","insertBefore","childNodes","editVmo","editPropertyName","editableGridCell","originAutoFocus","selectedCell","panelContext","getCtx","addTypeRef","source","scrollViewportElem","pinViewportElem","isPropertiesEditablePromise","editOptions","editPromise","editContext","previousActiveHandler","getActiveEditHandler","editInProgress","Promise","resolve","leaveConfirmation","setActiveEditHandlerContext","startEdit","isCellEditable","propertyNames","editOpts","vmos","autoSave","result","isEnabled","cells","isPartialSaveDisabled","saveEdits","finally","setCellEditingContext","clearPropIsEditableCache","removeCellSelection","selected1","Array","prototype","call","CLASS_TABLE_CELL_SELECTED_EDITABLE","selected2","CLASS_TABLE_CELL_SELECTED","elems","concat","containerElement","getTableContainerElementFromTable","updateSelectedCell","persistEditableFlag","_cell","isPropEditEnabled","refVmo","currentSelectedCell","eventObject","onClickHandler","updateCellEditability","isCellEditSupported","isModified","cellEditablePromise","isCellEditablePromise","_guidanceMessageInitialized","publishCellNotEditable","isEditing","cacheCollapse","restoreInitialCacheCollapseState","controller","setDraggable","_editing","updateCtx","editStateChangeDispatcher","_appCtxEditInProgress","_internal","eventTopicEditInProgress","isAutoSaveContextTrue","forceAutoSave","isCellEditing","setIsCellEditing","_cellEditDisabledMessageInitialized","isCellSelectedNotEditable","handleDirectEdit","reregisterLeaveHandler","handlePendingEditSelection","isCellEditablePromiseResolving","isCellHeaderSelectionEnabled","setCellHeaderSelection","addCellClickListener","onclick","oncontextmenu","checkCellAndVMOSelection","selectedObjects","isEligibleForCopyDown","copyPropertyToCellContent","sourceProperty","vmoUid","cellElements","copyFillDownProperty","targetProperty","uiValue","dbValue","valueUpdated","updateViewModelProperty","loadCellEditabilityForTargetCells","uid2CellMap","currentVmo","modifyPropsForCellEdit","vmosToEdit","cellsToSave","cellMap","sourceProp","propsModified","targetProp","isPropertyModifiable","editable","push","prepareTargetCellPropsInfo","populateTargetCellPropsLegacyEdit","fillDownCompleteHandler","VMOs","$source","direction","foundLastTarget","endTarget","getColumnDef","targetCell"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableEditor.js"],"sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the edit function for PL Table.\n *\n * @module js/splmTableEditor\n */\n\nimport SPLMTableFillDown from 'js/splmTableFillDown';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport uwPropertyService from 'js/uwPropertyService';\nimport browserUtils from 'js/browserUtils';\nimport { getEditContext, displayAutoSaveOnGuidanceMessage, displayCellEditDisabledGuidanceMessage } from 'js/splmTableDirectEditUtils';\nimport { includeComponent } from 'js/moduleLoader';\nimport { renderComponent } from 'js/declReactUtils';\nimport { AppCtxComponent } from 'js/reactAppCtx';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Cell from 'js/splmTableCellRenderer';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\n\nvar SPLMTableEditor = function( tableElem, directiveElem, gridContextDispatcher ) {\n    let _trv = new Trv( tableElem );\n    let _fillDown = new SPLMTableFillDown( tableElem );\n    let _lovValueChangedEventSubs = {};\n    let _blurHandler = null;\n    let _focusProp = null;\n    let _tableInstance = util.getTableInstance( tableElem );\n    let _selectedCellInfo = null;\n    let _saveEditPromise = null;\n    let _isEditablePromise = null;\n    let _escapeKeyHandler = null;\n    let _enterKeyHandler = null;\n    let _fillDownSaveInprogress = false;\n    const ariaReadOnly = 'aria-readonly';\n    const ariaActiveDescendant = 'aria-activedescendant';\n\n    // cache local event subscription\n    let _eventBusSubs = [];\n\n    let self = this; // eslint-disable-line no-invalid-this\n\n    const destroyLovEventListeners = function() {\n        _.forEach( _lovValueChangedEventSubs, function( subscription ) {\n            eventBus.unsubscribe( subscription );\n        } );\n        _lovValueChangedEventSubs = {};\n    };\n\n    self.destroy = function() {\n        destroyLovEventListeners();\n        _.forEach( _eventBusSubs, function( sub ) {\n            eventBus.unsubscribe( sub );\n        } );\n        _eventBusSubs = [];\n    };\n\n    self.setFocusProp = function( prop ) {\n        _focusProp = prop;\n    };\n\n    const triggerBlurHandler = function() {\n        if( _blurHandler ) {\n            _blurHandler();\n        }\n    };\n\n    self.updateEditStatus = function() {\n        triggerBlurHandler();\n        var cellElems = _trv.getContentCellElementsFromTable();\n        _.forEach( cellElems, function( elem ) {\n            self.updateEditStatusForCell( elem );\n        } );\n        if( !util.isBulkEditing( tableElem ) ) {\n            _focusProp = null;\n            destroyLovEventListeners();\n        }\n    };\n\n    const toggleLinkStyle = function( element, isLinkStyle ) {\n        if( isLinkStyle ) {\n            // disabled to active link\n            var linkElements = element.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n            for( var i = linkElements.length; i > 0; i-- ) {\n                var linkElem = linkElements[ i - 1 ];\n                if( linkElem && linkElem.classList ) {\n                    linkElem.classList.add( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                    linkElem.classList.remove( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n                }\n            }\n        } else {\n            // active to disabled links\n            linkElements = element.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n            for( var j = linkElements.length; j > 0; j-- ) {\n                var linkElem1 = linkElements[ j - 1 ];\n                if( linkElem1 && linkElem1.classList ) {\n                    linkElem1.classList.add( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n                    linkElem1.classList.remove( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                }\n            }\n        }\n    };\n\n    /**\n     * Ensure the drag handle is the last element in the parent container.\n     *\n     * @param {DOMElement} cell - cell with drag handle to re-append\n     */\n    const ensureDragHandleLastChild = function( cell ) {\n        var dragHandleElements = cell.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE );\n        if( dragHandleElements.length > 0 ) {\n            dragHandleElements[ 0 ].parentElement.appendChild( dragHandleElements[ 0 ] );\n        }\n    };\n\n    const reverseEditCell = function( cell, vmo, column, cellElemProperty ) {\n        if( cell.parentElement === null ) {\n            return;\n        }\n        cell.isElementInEdit = false;\n        var editCells = null;\n        if( cellElemProperty.isArray ) {\n            editCells = cell.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY );\n        } else {\n            editCells = cell.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP );\n        }\n        var isErrorProperty = false;\n        var cellTopElement = Cell.createElement( column, vmo, tableElem, cell.parentElement );\n        if( _tableInstance.dynamicRowHeightStatus === true ) {\n            Cell.addDynamicCellHeight( vmo, cellTopElement );\n        }\n        if( editCells.length > 0 ) {\n            var editCell = editCells[ 0 ];\n            if( cellElemProperty.isArray ) {\n                const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n                if( editArrayPopup ) {\n                    editArrayPopup.hide();\n                }\n            } else {\n                editCell.parentElement.removeChild( editCell );\n            }\n\n            setTimeout( function() {\n                util.cleanupComponents( editCell );\n                var propertyErrorElements = editCell.getElementsByClassName( 'aw-widgets-propertyError' );\n                if( propertyErrorElements.length > 0 ) {\n                    isErrorProperty = true;\n                }\n                if( isErrorProperty ) {\n                    cellTopElement.classList.add( 'aw-widgets-propertyError' );\n                }\n                if( !cellElemProperty.isArray ) {\n                    util.destroyElement( editCell );\n                }\n            }, 1000 );\n        }\n\n        cell.classList.remove( Const.CLASS_AW_IS_EDITING );\n        cell.appendChild( cellTopElement );\n\n        var cellTopElements = cell.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP );\n\n        if( cellTopElements.length > 0 ) {\n            cellTopElements[ 0 ].classList.add( Const.CLASS_AW_EDITABLE_CELL );\n        }\n\n        ensureDragHandleLastChild( cell );\n    };\n\n    const removeFocusEvents = function( cellElem ) {\n        const useCapture = true;\n        cellElem.removeEventListener( 'focus', cellElem.onFocusEvent, useCapture );\n        cellElem.onFocusEvent = null;\n        cellElem.removeEventListener( 'mousedown', cellElem.onFocusClickEvent );\n        cellElem.onFocusClickEvent = null;\n    };\n\n    let _isUserClick = false;\n    let _isCtrlKey = false;\n    const addFocusEvent = function( cellElem, vmo ) {\n        removeFocusEvents( cellElem );\n        const onFocusEvent = function( event ) {\n            // Update row selection if clicking on editable cell. This is needed because UW widget stops propagation of the event\n            // to the row element when it is created.\n            if( _isUserClick ) {\n                let eventObj;\n                if( browserUtils.isIE ) {\n                    eventObj = document.createEvent( 'MouseEvent' );\n                    eventObj.initMouseEvent( 'click', true, true, window, 0, eventObj.screenX, eventObj.screenY, eventObj.clientX, eventObj.clientY, _isCtrlKey, false, false, false, 0, null );\n                } else {\n                    eventObj = new MouseEvent( 'click', { ctrlKey: _isCtrlKey } );\n                }\n                cellElem.parentElement.dispatchEvent( eventObj );\n                _isUserClick = false;\n                _isCtrlKey = false;\n            }\n            self.editCell( cellElem, vmo );\n        };\n\n        cellElem.onFocusEvent = onFocusEvent;\n        const useCapture = true;\n        // LCS-357443: IE does not focus the cell when using element.onfocus.\n        // Instead focus event must be added with addEventListener and useCapture as true.\n        cellElem.addEventListener( 'focus', onFocusEvent, useCapture );\n\n        const isFocusClickEvent = function( event ) {\n            _isUserClick = true;\n            _isCtrlKey = event.ctrlKey;\n        };\n        cellElem.isFocusClickEvent = isFocusClickEvent;\n        cellElem.addEventListener( 'mousedown', isFocusClickEvent );\n    };\n\n    const addEditStatus = function( cellElem, cellElemProperty, vmo ) {\n        if( cellElem.children[ 0 ] ) {\n            cellElem.children[ 0 ].classList.add( Const.CLASS_AW_EDITABLE_CELL );\n            var rowHeight = util.getTableRowHeight( _tableInstance.gridOptions, undefined );\n            if( rowHeight !== undefined ) {\n                cellElem.children[ 0 ].style.height = rowHeight + 'px';\n            }\n        } else {\n            logger.debug( cellElem.propName + ' has no child' );\n        }\n\n        addFocusEvent( cellElem, vmo );\n\n        _fillDown.enableFillDown( cellElem );\n        toggleLinkStyle( cellElem, false );\n\n        // for saved cells in partial edit status\n        var cellTop = cellElem.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ] || cellElem.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP )[ 0 ] || cellElem\n            .getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY )[ 0 ];\n        Cell.updateCellChangedClass( cellElemProperty, cellTop );\n\n        if( _focusProp === cellElem.prop ) {\n            self.editCell( cellElem, vmo );\n        }\n    };\n\n    const removeBlurHandler = function() {\n        const useCapture = true;\n        document.body.removeEventListener( 'click', _blurHandler, useCapture );\n        _trv.getScrollCanvasElementFromTable().removeEventListener( 'scroll', _blurHandler, useCapture );\n        _trv.getPinCanvasElementFromTable().removeEventListener( 'scroll', _blurHandler, useCapture );\n    };\n\n    const removeEscapeAndEnterHandlers = function( cell ) {\n        document.body.removeEventListener( 'keydown', _escapeKeyHandler, true );\n        cell.removeEventListener( 'keydown', _enterKeyHandler, true );\n        _escapeKeyHandler = null;\n        _enterKeyHandler = null;\n    };\n\n    const setBlurHandler = function( blurHandler ) {\n        _blurHandler = blurHandler;\n    };\n\n    const removeEditStatus = function( cellElem, cellElemProperty, vmo, skipCellCreation ) {\n        const cellTopElem = cellElem.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ];\n        if( cellTopElem && ( cellTopElem.classList.contains( Const.CLASS_AW_EDITABLE_CELL ) || cellTopElem.classList.contains( Const.CLASS_CELL_CHANGED ) ) ||\n            cellElem.propIsEditableCache ) {\n            if( !cellElemProperty.isArray && !cellElem.isSelected ) {\n                _fillDown.disableFillDown( cellElem );\n            }\n            if( !skipCellCreation ) {\n                cellElem.removeChild( cellTopElem );\n                reverseEditCell( cellElem, vmo, cellElem.columnDef, cellElemProperty );\n            }\n            cellElem.children[ 0 ].classList.remove( Const.CLASS_AW_EDITABLE_CELL );\n            removeFocusEvents( cellElem );\n        }\n        toggleLinkStyle( cellElem, true );\n    };\n\n    self.updateEditStatusForCell = function( cellElem ) {\n        var cellElemProperty = cellElem.prop;\n        let vmo = util.getViewModelObjectByCellElement( cellElem );\n        vmo = getVmoById( vmo.alternateID || vmo.uid ); // get latest vmo from collection rather than cached\n        var vmoProp = vmo && vmo.props && vmo.props[ cellElem.propName ];\n\n        if( cellElem.propName && cellElemProperty && cellElem.columnDef.isTreeNavigation !== true ) {\n            // LCS-142669 - read modifiable besides of isEditable\n            if( ( cellElemProperty.isEditable || vmoProp && vmoProp.isEditable ) && cellElem.columnDef.modifiable !== false && util.isBulkEditing( tableElem ) ) {\n                addEditStatus( cellElem, cellElemProperty, vmo );\n            } else if( cellElem.isSelected && cellElem.propIsEditableCache && cellElemProperty.isPropInEdit ) {\n                addEditStatus( cellElem, cellElemProperty, vmo );\n            } else {\n                removeEditStatus( cellElem, cellElemProperty, vmo );\n                if( util.isBulkEditing( tableElem ) ) {\n                    cellElem.setAttribute( ariaReadOnly, 'true' );\n                } else if( cellElem.hasAttribute( ariaReadOnly ) && cellElem.propIsEditableCache !== false ) {\n                    cellElem.removeAttribute( ariaReadOnly );\n                }\n            }\n        } else if( util.isBulkEditing( tableElem ) ) {\n            cellElem.setAttribute( ariaReadOnly, 'true' );\n        } else if( cellElem.hasAttribute( ariaReadOnly ) && cellElem.propIsEditableCache !== false ) {\n            cellElem.removeAttribute( ariaReadOnly );\n        }\n    };\n\n    /**\n     * Subscribe to lovValueChangedEvent. Update dependent cells\n     */\n    const subscribeToLovValueChangedEvent = function( cell, vmo, prop ) {\n        return eventBus.subscribe( prop.propertyName + '.lovValueChanged', function() {\n            // Update dependent LOVS only\n            if( !prop.lovApi || !prop.lovApi.behaviorData || prop.lovApi.behaviorData.style !== 'Interdependent' ) {\n                return;\n            }\n\n            prop.lovApi.behaviorData.dependendProps.forEach( function( propertyName ) {\n                // Only update cells for other props\n                if( prop.propertyName !== propertyName ) {\n                    var row = cell.parentElement;\n                    // Find the cell\n                    _.forEach( row.children, function( cellElem ) {\n                        if( cellElem.propName === propertyName ) {\n                            // Update cell content\n                            var oldCellTop = cellElem.children[ 0 ];\n                            var newCellTop = Cell.createElement( cellElem.columnDef, row.vmo, tableElem, row );\n                            if( _tableInstance.dynamicRowHeightStatus === true ) {\n                                Cell.addDynamicCellHeight( vmo, newCellTop );\n                            }\n                            newCellTop.classList.add( Const.CLASS_AW_EDITABLE_CELL );\n                            cellElem.replaceChild( newCellTop, oldCellTop );\n                            cellElem.isDependantEdit = true;\n                            if( !util.isBulkEditing( tableElem ) && util.isAutoSaveEnabled( tableElem ) ) {\n                                self.removeAllCellSelection();\n                                self.editCell( cellElem, vmo );\n                            }\n                            return false;\n                        }\n                        return true;\n                    } );\n                }\n            } );\n        } );\n    };\n\n    /**\n     * Cancels edits if isDirty() comes back false\n     */\n    const cancelEditsIfNotDirty = function() {\n        const context = getEditContext( _tableInstance );\n        let editHandler = null;\n        let isDirtyPromise;\n        if( context ) {\n            editHandler = editHandlerSvc.getEditHandler( context );\n            isDirtyPromise = editHandler.isDirty();\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            isDirtyPromise = _tableInstance.dataProvider.isDirty();\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            isDirtyPromise = _tableInstance.declViewModel.isDirty();\n        }\n\n        if( isDirtyPromise ) {\n            isDirtyPromise.then( function( isDirty ) {\n                // If the handler is not dirty cancel edits to get out of edit mode.\n                if( !isDirty ) {\n                    if( editHandler ) {\n                        editHandler.cancelEdits();\n                    } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                        const dataCtxNode = {\n                            data: _tableInstance.declViewModel,\n                            ctx: appCtxService.ctx\n                        };\n                        _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n                    } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                        _tableInstance.declViewModel.cancelEdits();\n                    }\n                }\n            } );\n        }\n    };\n\n    /**\n     * Handles cell editing functionality for the blur event\n     * @param {Event} event - the blur event\n     * @param {DOMElement} cell - The cell element\n     * @param {ViewModelProperty} prop - The property\n     * @param {ViewModelObject} vmo - The view model object\n     */\n    const handleCellEditBlur = function( event, cell, prop, vmo ) {\n        // Autosave the cell on blur when in autosave mode\n        if( !util.isBulkEditing( tableElem ) && util.isAutoSaveEnabled( tableElem ) && event && !_fillDownSaveInprogress ) {\n            // Stop the event bubbling so save can finish first, we will resend the click when save is finished\n            event.stopPropagation();\n            event.preventDefault();\n            _fillDown.disableFillDown( cell );\n\n            // get target vmo/prop if clicking on table so we can resend click to it after\n            const tableCell = util.closestElement( event.target, '.ui-grid-cell' );\n            let vmo;\n            let propName;\n            if( tableCell ) {\n                propName = tableCell.propName;\n                vmo = util.getViewModelObjectByCellElement( tableCell );\n            }\n            _saveEditPromise = self.saveEdit( [ cell ] ).then( () => {\n                _saveEditPromise = null;\n                if( !tableCell ) {\n                    let clickElement = event.target;\n                    // Elements like svg don't have a click function, so bubble up till we have a clickable element.\n                    while( !clickElement.click ) {\n                        clickElement = clickElement.parentElement;\n                    }\n                    clickElement.click();\n                } else {\n                    // reselect table cell\n                    let uid = vmo && vmo.alternateID || vmo.uid;\n                    let cellToSelect = util.getCellElementsByPropertyAndUid( tableElem, propName, uid )[ 0 ];\n                    cellToSelect && cellToSelect.click && cellToSelect.click();\n                }\n            } );\n        } else if( !util.isBulkEditing( tableElem ) && !util.isAutoSaveEnabled( tableElem ) ) {\n            cancelEditsIfNotDirty();\n            removeEditStatus( cell, prop, vmo, true );\n        }\n    };\n\n    /**\n     * Returns the focusable cell info if it is focusable\n     *\n     * @param {Object} column - the column\n     * @param {ViewModelObject} vmo - the vmo\n     *\n     * @return {Object} the focusable cell's info\n     */\n    const getFocusableCellInfo = function( column, vmo ) {\n        if( column.modifiable !== false && !column.isTreeNavigation ) {\n            const propName = column.propertyName || column.field;\n            const prop = vmo.props[ propName ];\n            if( prop && prop.isEditable ) {\n                return {\n                    vmo: vmo,\n                    column: column\n                };\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the info of the next focusable cell\n     *\n     * @param {ViewModelObject} currentVMO - the current vmo\n     * @param {Object} currentColumn - the current column\n     * @param {boolean} reverseDirection - true if going in the reverse direction\n     *\n     * @return {Object} the next focusable cell's info\n     */\n    const getNextFocusableCellInfo = ( currentVMO, currentColumn, reverseDirection ) => {\n        let columns = _tableInstance.dataProvider.cols.filter( function( col ) {\n            return !col.hiddenFlag;\n        } );\n        const currentIdx = columns.indexOf( currentColumn );\n\n        // Reverse the columns order if we are going in reverse\n        if( reverseDirection ) {\n            columns = columns.slice().reverse();\n        }\n\n        for( let i = currentIdx + 1; i < columns.length; i++ ) {\n            const col = columns[ i ];\n            const focusableCellInfo = getFocusableCellInfo( col, currentVMO );\n            if( focusableCellInfo ) {\n                return focusableCellInfo;\n            }\n        }\n\n        // If no cell was found, check next vmo until found  -- Limit - Until end of data, will not page while looking\n        const loadedVMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n        const currentVMOIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( currentVMO.uid );\n        for( let i = currentVMOIndex + 1; i < loadedVMOs.length; i++ ) {\n            const nextVMO = loadedVMOs[ i ];\n            for( let y = 0; y < columns.length; y++ ) {\n                const col = columns[ y ];\n                const focusableCellInfo = getFocusableCellInfo( col, nextVMO );\n                if( focusableCellInfo ) {\n                    return focusableCellInfo;\n                }\n            }\n        }\n\n        // If we still haven't found anything, then there are no more editable cells available, return null\n        return null;\n    };\n\n    /**\n     * Attaches the keydown handler to a cell\n     * @param {DOMElement} cellElem The cell element\n     */\n    const attachKeydownHandler = ( cellElem ) => {\n        cellElem.onkeydown = ( event ) => {\n            if( event.code !== 'Tab' ) {\n                return;\n            }\n\n            let reverseTab = false;\n            if( event.shiftKey ) {\n                reverseTab = true;\n            }\n\n            // Now check vmo for next editable column.\n            const closestVMO = event.target.closest( '.ui-grid-row' ).vmo;\n            const column = event.target.closest( '.ui-grid-cell' ).columnDef;\n            const nextEditableInfo = getNextFocusableCellInfo( closestVMO, column, reverseTab );\n\n            // Scroll to that cell if exists\n            if( nextEditableInfo ) {\n                event.preventDefault();\n                event.stopPropagation();\n\n                const vmoIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( nextEditableInfo.vmo.uid );\n\n                triggerBlurHandler();\n\n                _tableInstance.renderer.scrollToRowIndex( [ vmoIndex ] );\n                if( !nextEditableInfo.column.pinnedLeft ) {\n                    _tableInstance.renderer.scrollToColumn( nextEditableInfo.column );\n                }\n\n                setTimeout( () => {\n                    // Get the cell and focus it after it is scrolled into view\n                    const firstRowOnDom = tableElem.getElementsByClassName( 'ui-grid-row' )[ 0 ];\n                    if( firstRowOnDom ) {\n                        const editableRowRelativeIdx = vmoIndex - firstRowOnDom.getAttribute( 'data-indexNumber' );\n                        let rowElem;\n                        if( nextEditableInfo.column.pinnedLeft ) {\n                            rowElem = _trv.getPinContentRowElementFromTable( editableRowRelativeIdx );\n                        } else {\n                            rowElem = _trv.getScrollContentRowElementFromTable( editableRowRelativeIdx );\n                        }\n                        const cellElems = rowElem && rowElem.getElementsByClassName( 'ui-grid-cell' ) || [];\n                        const foundCell = _.filter( cellElems, { columnDef: nextEditableInfo.column } )[ 0 ];\n                        if( foundCell ) {\n                            self.editCell( foundCell, nextEditableInfo.vmo );\n                        }\n                    }\n                }, 200 );\n            }\n        };\n    };\n\n    const attachEscapeKeyHandler = ( cell, prop, vmo, column ) => {\n        // Set listener for Escape key and reverse edit cell\n        _escapeKeyHandler = ( event ) => {\n            if( event.key !== 'Escape' ) {\n                return;\n            }\n\n            const currentCell = util.closestElement( event.target, '.' + Const.CLASS_CELL );\n            if( currentCell === cell && cell.isElementInEdit ) {\n                event.stopPropagation();\n                uwPropertyService.resetUpdates( prop );\n                reverseEditCell( cell, vmo, column, prop );\n                if( !util.isBulkEditing( tableElem ) ) {\n                    prop.isPropInEdit = false;\n                    removeEditStatus( cell, prop, vmo, true );\n\n                    // Check if isDirty still, is so, do nothing, else cancel edits\n                    cancelEditsIfNotDirty();\n                    removeEscapeAndEnterHandlers( cell );\n                    cell.focus();\n                } else {\n                    // Readd click handler to allow cell to go back into edit\n                    addFocusEvent( cell, vmo );\n                }\n            } else {\n                const context = getEditContext( _tableInstance );\n                let editHandler = editHandlerSvc.getEditHandler( context );\n                if( editHandler ) {\n                    editHandler.cancelEdits();\n                } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                    const dataCtxNode = {\n                        data: _tableInstance.declViewModel,\n                        ctx: appCtxService.ctx\n                    };\n                    _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n                } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                    _tableInstance.declViewModel.cancelEdits();\n                }\n            }\n        };\n        document.body.addEventListener( 'keydown', _escapeKeyHandler, true );\n    };\n\n    const attachEnterKeyHandler = ( cell, blurHandler ) => {\n        const hasPopupExpanded = ( element ) => {\n            const popupVisible = element.getElementsByClassName( 'aw-jswidgets-popUpVisible' );\n            const expanded = element.getElementsByClassName( 'aw-jswidgets-expanded' );\n            return popupVisible.length + expanded.length > 0;\n        };\n\n        _enterKeyHandler = ( event ) => {\n            if( event.key === 'Enter' && !event.altKey && !util.isBulkEditing( tableElem ) ) {\n                const currentCell = util.closestElement( event.target, '.' + Const.CLASS_CELL );\n                // Special handling for array properties\n                const isArrayProperty = currentCell.prop && currentCell.prop.isArray;\n                if( isArrayProperty ) {\n                    if( event.target.value === '' ) {\n                        event.stopPropagation();\n                        blurHandler( event );\n                        if( !util.isBulkEditing( tableElem ) ) {\n                            currentCell.focus();\n                        }\n                    }\n                } else {\n                    // If there isn't a popup in the children, then call blurhandler\n                    if( currentCell && !hasPopupExpanded( currentCell ) ) {\n                        event.stopPropagation();\n                        blurHandler( event );\n                        if( _saveEditPromise ) {\n                            _saveEditPromise.then( function() {\n                                currentCell.focus();\n                            } );\n                        } else {\n                            currentCell.focus();\n                        }\n                    }\n                }\n            }\n        };\n        cell.addEventListener( 'keydown', _enterKeyHandler, true );\n    };\n\n    /**\n     * Publishes teh cell start edit event\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */\n    const publishCellStartEditEvent = function( cell, vmo ) {\n        const eventData = {\n            columnInfo: cell.columnDef,\n            gridId: tableElem.id,\n            vmo: vmo\n        };\n\n        eventBus.publish( tableElem.id + '.cellStartEdit', eventData );\n    };\n\n    const getVmoById = function( vmoId ) {\n        let idx = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( vmoId );\n        return _tableInstance.dataProvider.viewModelCollection.loadedVMObjects[ idx ];\n    };\n\n    /**\n     * Unsubscribes from the hold lov value change event and subscribes to a new one\n     * @param {DOMElement} cell the cell element\n     * @param {Object} vmo the view model object\n     * @param {Object} prop The property\n     */\n    const handleLovValueChangedEvent = function( cell, vmo, prop ) {\n        const lovValueChangedEventSub = subscribeToLovValueChangedEvent( cell, vmo, prop );\n        let oldLovSubscr = _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ];\n        if( oldLovSubscr ) {\n            eventBus.unsubscribe( oldLovSubscr );\n            delete _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ];\n        }\n        _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ] = lovValueChangedEventSub;\n    };\n\n    const isUserInteractingWithDropDown = ( prop, event ) => {\n        if( prop.hasLov && event ) {\n            const listBoxDrop = document.querySelector( '.sw-lov-contentContainer' );\n            if( listBoxDrop && listBoxDrop.contains( event.target ) ) {\n                return true;\n            }\n        } else if( prop.type && event && ( prop.type === 'DATE' || prop.type === 'DATEARRAY' ) ) {\n            const datePicker = document.querySelector( '.flatpickr-calendar.open' );\n            if( datePicker && datePicker.contains( event.target ) ) {\n                return true;\n            }\n            const dateTimeDrop = document.querySelector( '.sw-popup-contentContainer .aw-base-scrollPanel' );\n            if( dateTimeDrop && dateTimeDrop.contains( event.target ) ) {\n                return true;\n            }\n        } else if( prop.type && event && prop.type === 'STRING' && prop.isRichText ) {\n            const ckEditor = document.getElementsByClassName( 'ck-body-wrapper' )[ 0 ];\n            if( ckEditor && ckEditor.contains( event.target ) ) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Creates the edit cell and attaches it to the DOM\n     * @param {Object} vmo - the view model object\n     * @param {AwColumnDef} column The column definition\n     * @param {DOMElement} cell The cell element\n     */\n    const createAndAttachEditCell = function( vmo, column, cell ) {\n        // for array fields, application should use popup to display it,\n        // or you will face cut off issues: LCS-161794\n        const prop = vmo.props[ cell.propName ];\n        prop.autofocus = true;\n        let editNonArrayClass = prop.isArray ? Const.CLASS_TABLE_EDIT_CELL_ARRAY : Const.CLASS_TABLE_EDIT_CELL_NON_ARRAY;\n        let editCellElem = util.createElement( 'div', 'aw-splm-tableEditCellTop', editNonArrayClass );\n        let editContainer = util.createElement( 'div', 'aw-jswidgets-tableEditContainer', 'aw-jswidgets-cellTop' );\n\n        /* revisitme Brad\n         * Revisit/revise for support of column def providing rendering hint\n         * column.renderingHint\n         */\n        let propertyValElem = includeComponent( 'SplmTableCellEditor', {\n            vmo,\n            name: prop.propertyName\n        } );\n\n        renderComponent( <AppCtxComponent>{propertyValElem}</AppCtxComponent>, editContainer );\n        editCellElem.appendChild( editContainer );\n\n        attachKeydownHandler( editCellElem );\n\n        Cell.updateCellChangedClass( prop, editCellElem.getElementsByClassName( Const.CLASS_AW_JS_CELL_TOP )[ 0 ] );\n        if( prop.isArray && _tableInstance.gridOptions.popupContext && _tableInstance.gridOptions.popupContext.editArrayPopup ) {\n            const cellBoundingArea = cell.getBoundingClientRect();\n            const popupOptions = {\n                whenParentScrolls: 'follow',\n                innerClassName: Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY,\n                autoFocus: false,\n                parent: cell,\n                reference: cell,\n                overlapOnReference: true,\n                containerWidth: cellBoundingArea.width,\n                width: cellBoundingArea.width,\n                forceCloseOthers: false\n            };\n            const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n            if( editArrayPopup ) {\n                editArrayPopup.hide().then( () => {\n                    editArrayPopup.show( popupOptions ).then( ( popupRef ) => {\n                        self.popupRef = popupRef;\n                    } );\n                } );\n            }\n        } else {\n            cell.insertBefore( editCellElem, cell.childNodes[ 0 ] );\n        }\n    };\n\n    /**\n     * Starts the edit of the cell\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */\n    self.editCell = function( cell, vmo ) {\n        const column = cell.columnDef;\n        const prop = cell.prop;\n        if( !cell.isDependantEdit && ( !cell.isSelected && !util.isBulkEditing( tableElem ) || cell.isElementInEdit === true ) ) {\n            return;\n        }\n\n        gridContextDispatcher( {\n            type: 'UPDATE_VALUES',\n            editVmo: vmo,\n            editPropertyName: cell.propName\n        } );\n\n        publishCellStartEditEvent( cell, vmo );\n\n        // Trigger blur handler\n        triggerBlurHandler();\n\n        cell.isElementInEdit = true;\n        prop.isPropInEdit = true;\n\n        cell.classList.add( Const.CLASS_AW_IS_EDITING );\n\n        // Handle possible lov value changes\n        handleLovValueChangedEvent( cell, vmo, prop );\n\n        // Remove cell top\n        let editableGridCell = cell.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ];\n        if( editableGridCell ) {\n            cell.removeChild( editableGridCell );\n        }\n\n        let originAutoFocus = prop.autofocus;\n        createAndAttachEditCell( vmo, column, cell );\n        removeFocusEvents( cell );\n\n        const blurHandler = function( event ) {\n            // Only revert edit status if scrolling with array (popup)\n            if( event && event.type === 'scroll' && cell.prop && !cell.prop.isArray ) {\n                return;\n            }\n            let selectedCell = null;\n            if( event && event.type !== 'keydown' ) {\n                _focusProp = null;\n                selectedCell = util.closestElement( event.target, `.${Const.CLASS_CELL}` );\n            }\n            if( !cell.isElementInEdit ) {\n                removeBlurHandler();\n                removeEscapeAndEnterHandlers( cell );\n            } else if( selectedCell !== cell && cell.isElementInEdit ) {\n                // Close panels\n                let panelContext = appCtxService.getCtx( 'panelContext' );\n                if( panelContext && panelContext.addTypeRef === true ) {\n                    // If clicking on different cell close the panel else leave it open\n                    if( cell.propName !== prop.propertyName || cell.parentElement.vmo.uid !== prop.parentUid ) {\n                        eventBus.publish( 'completed', {\n                            source: 'toolAndInfoPanel'\n                        } );\n                    } else {\n                        return;\n                    }\n                }\n\n                if( isUserInteractingWithDropDown( prop, event ) ) {\n                    return true;\n                }\n\n                // Remove the blur handler since cell is going out of edit\n                removeBlurHandler();\n                removeEscapeAndEnterHandlers( cell );\n\n                // Reverse the cell edit\n                reverseEditCell( cell, vmo, column, prop );\n\n                prop.autofocus = originAutoFocus;\n                prop.isPropInEdit = false;\n\n                cell.isSelected = false;\n                delete cell.isDependantEdit;\n\n                // Handle cell editing functionality on blur\n                handleCellEditBlur( event, cell, prop, vmo );\n\n                // Readd click handler to allow cell to go back into edit\n                addFocusEvent( cell, vmo );\n            }\n        };\n\n        // Add blur handler to take cell out of edit on click away\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers( cell );\n\n        // Setting useCapture to true is needed for autosave since it allows us to detect the click before the target\n        // element does.\n        const useCapture = true;\n        document.body.addEventListener( 'click', blurHandler, useCapture );\n\n        const scrollViewportElem = _trv.getScrollCanvasElementFromTable();\n        const pinViewportElem = _trv.getPinCanvasElementFromTable();\n\n        scrollViewportElem.removeEventListener( 'scroll', blurHandler, useCapture );\n        pinViewportElem.removeEventListener( 'scroll', blurHandler, useCapture );\n        scrollViewportElem.addEventListener( 'scroll', blurHandler, useCapture );\n        pinViewportElem.addEventListener( 'scroll', blurHandler, useCapture );\n\n        attachEscapeKeyHandler( cell, prop, vmo, column );\n        attachEnterKeyHandler( cell, blurHandler );\n\n        setBlurHandler( blurHandler );\n    };\n\n    self.isPropertiesEditablePromise = function( editOptions ) {\n        let editPromise;\n        const editContext = getEditContext( _tableInstance );\n        if( editContext ) {\n            // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n            // can be editing at any given time.\n            const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n            if( previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler( editContext ) && previousActiveHandler.editInProgress() ) {\n                editPromise = new Promise( ( resolve ) => {\n                    previousActiveHandler.leaveConfirmation( () => {\n                        editHandlerSvc.setActiveEditHandlerContext( editContext );\n                        editHandlerSvc.startEdit( editOptions ).then( () => {\n                            resolve();\n                        } );\n                    } );\n                } );\n            } else {\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                editPromise = editHandlerSvc.startEdit( editOptions );\n            }\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            const dataCtxNode = {\n                data: _tableInstance.declViewModel,\n                ctx: appCtxService.ctx\n            };\n            editPromise = _tableInstance.dataProvider.startEdit( dataCtxNode, _tableInstance.declViewModel, editOptions );\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            editPromise = _tableInstance.declViewModel.startEdit( editOptions );\n        }\n\n        return editPromise ? editPromise : Promise.resolve( false );\n    };\n\n    /**\n     * Checks if the provided cell/property is editable by calling startEdit on the editHandler or editConfig\n     * @param {Object} vmo The view model object\n     * @param {DOMElement} cellElem The cell element\n     *\n     * @returns {Promise<Boolean>} Promise that will resolve to the editability of the property\n     */\n    const isCellEditable = async function( vmo, cellElem ) {\n        // Allow save to finish before checking start edit\n        if( _saveEditPromise ) {\n            await _saveEditPromise;\n        }\n        let prop = vmo.props[ cellElem.propName ];\n        let propertyNames = [ prop.propertyName ];\n        // Need to pass all dependent props to ensure we have latest lsd\n        if( prop.lovApi && prop.lovApi.behaviorData && prop.lovApi.behaviorData.style === 'Interdependent' ) {\n            propertyNames = prop.lovApi.behaviorData.dependendProps;\n        }\n        let editOpts = {\n            vmos: [ vmo ],\n            propertyNames: propertyNames,\n            autoSave: util.isAutoSaveEnabled( tableElem )\n        };\n        const result = await self.isPropertiesEditablePromise( editOpts );\n\n        if( result === false ) {\n            return false;\n        }\n        // update prop to latest\n        prop = vmo.props[ cellElem.propName ];\n        return prop && prop.isEditable && prop.isEnabled !== false;\n    };\n\n    /**\n     * Saved the provided cell/property that was edited\n     * @param {DOMElement[]} cells the cells to save\n     * @returns {Promise<Boolean>} Promise that will resolve when save is complete\n     */\n    self.saveEdit = function( cells ) {\n        let isPartialSaveDisabled = true;\n        let editPromise = null;\n        const editContext = getEditContext( _tableInstance );\n        if( editContext ) {\n            editPromise = editHandlerSvc.saveEdits( editContext, isPartialSaveDisabled, util.isAutoSaveEnabled( tableElem ) );\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            const dataCtxNode = {\n                data: _tableInstance.declViewModel,\n                ctx: appCtxService.ctx\n            };\n            editPromise = _tableInstance.dataProvider.saveEdits( dataCtxNode, _tableInstance.declViewModel );\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            editPromise = _tableInstance.declViewModel.saveEdits();\n        }\n\n        if( editPromise ) {\n            return editPromise.finally( function() {\n                self.setCellEditingContext( false );\n                for( let i = 0; i < cells.length; i++ ) {\n                    if( document.body.contains( cells[ i ] ) ) {\n                        self.updateEditStatusForCell( cells[ i ] );\n                    }\n                }\n                // Clear prop is editable cache to ensure newly selected cell makes a startEdit call, since\n                // our save call will likely invalidate the editable cache. This is also ensuring that double click on\n                // another cell takes that cell into edit instead of selected state.\n                self.clearPropIsEditableCache();\n            } );\n        }\n        return Promise.resolve( false );\n    };\n\n    /**\n     * Removes the selected and selectedEditable css classes from any elements that have them\n     */\n    const removeCellSelection = function() {\n        // Remove all other \"selected\" classes from cells\n        let selected1 = Array.prototype.slice.call( tableElem.getElementsByClassName( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE ) );\n        let selected2 = Array.prototype.slice.call( tableElem.getElementsByClassName( Const.CLASS_TABLE_CELL_SELECTED ) );\n        let elems = selected1.concat( selected2 );\n        for( let i = 0; i < elems.length; i++ ) {\n            elems[ i ].classList.remove( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n            elems[ i ].classList.remove( Const.CLASS_TABLE_CELL_SELECTED );\n            let containerElement = null;\n            // The below method can result in undefined value.\n            containerElement = _trv.getTableContainerElementFromTable();\n            if( containerElement && containerElement.hasAttribute( ariaActiveDescendant ) ) {\n                containerElement.removeAttribute( ariaActiveDescendant );\n            }\n        }\n    };\n\n    /**\n     * Updates the cell to be selected and sets selection/edit info to false on old selected cell\n     * @param {DOMElement} cell The new selected cell\n     * @param {Boolean} persistEditableFlag flag to denote if isEditable should be persisted\n     */\n    const updateSelectedCell = function( cell, persistEditableFlag ) {\n        if( _selectedCellInfo && _selectedCellInfo.cell ) {\n            let _cell = _selectedCellInfo.cell;\n            _cell.isSelected = false;\n            const vmo = getVmoById( _selectedCellInfo.vmoId );\n            // If prop edit is not enabled we should not touch the prop.isEditable flag\n            if( !persistEditableFlag && vmo && _cell.prop && util.isPropEditEnabled( tableElem ) && !util.isBulkEditing( tableElem ) ) {\n                _cell.prop.isEditable = false;\n                if( vmo.props && vmo.props[ _cell.propName ] ) {\n                    vmo.props[ _cell.propName ].isEditable = false;\n                }\n            }\n        }\n\n        if( cell ) {\n            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED );\n            cell.isSelected = true;\n            let refVmo = util.getViewModelObjectByCellElement( cell );\n            let vmoId = refVmo.alternateID || refVmo.uid;\n            _selectedCellInfo = {\n                cell: cell,\n                vmoId: vmoId\n            };\n            let containerElement = null;\n            // The below method can result in undefined value.\n            containerElement = _trv.getTableContainerElementFromTable();\n            if( containerElement ) {\n                containerElement.setAttribute( ariaActiveDescendant, cell.getAttribute( 'id' ) );\n            }\n        } else {\n            _selectedCellInfo = null;\n        }\n    };\n\n    self.clearPropIsEditableCache = function( persistEditableFlag ) {\n        const cellElems = _trv.getContentCellElementsFromTable();\n        _.forEach( cellElems, function( elem ) {\n            delete elem.propIsEditableCache;\n            if( elem.hasAttribute( ariaReadOnly ) ) {\n                elem.removeAttribute( ariaReadOnly );\n            }\n        } );\n        // Reset cell selection since we are clearing editibility cache\n        // making the editability selection classes no longer valid\n        removeCellSelection();\n        const currentSelectedCell = _selectedCellInfo ? _selectedCellInfo.cell : null;\n        updateSelectedCell( null, persistEditableFlag );\n        if( currentSelectedCell && currentSelectedCell.parentElement ) {\n            const eventObject = {\n                ctrlKey: false,\n                shiftKey: false,\n                type: 'click'\n            };\n            self.onClickHandler( eventObject, currentSelectedCell, util.getViewModelObjectByCellElement( currentSelectedCell ) );\n        }\n    };\n\n    /**\n     * Update the cell editability by using the cached editability or loading the editability if it is not cached\n     * @param {DOMElement} cell - The cell element to get editability for\n     * @param {Object} vmo - the row's view model object\n     */\n    const updateCellEditability = function( cell, vmo ) {\n        // Make some SOA call here for getting the editability\n        removeCellSelection();\n        updateSelectedCell( cell );\n\n        // Check if cellEdit is enabled and if this cell/prop type supports edit\n        const isCellEditSupported = util.isPropEditEnabled( tableElem ) && cell.propName && cell.prop && cell.columnDef.isTreeNavigation !== true;\n        if( !isCellEditSupported ) {\n            cell.setAttribute( ariaReadOnly, 'true' );\n            return;\n        }\n\n        // If prop is modified we can restore editability cache since we know it has not been saved\n        // and was previously editable\n        if( uwPropertyService.isModified( cell.prop ) && cell.propIsEditableCache === undefined && !util.isAutoSaveEnabled( tableElem ) ) {\n            cell.propIsEditableCache = true;\n        }\n\n        // Check if editability info exists, if not\n        // Check columnDef if editable, if not add readonly class\n        // If editable, make startEdit call to get editability for cell\n        if( cell.columnDef.name !== 'icon' && cell.columnDef.modifiable !== false && cell.propIsEditableCache === undefined ) {\n            // only allow one check at a time.\n            const cellEditablePromise = function() {\n                return isCellEditable( vmo, cell ).then( function( isEditable ) {\n                    cell.propIsEditableCache = isEditable;\n                    if( cell.propIsEditableCache === false ) {\n                        cell.setAttribute( ariaReadOnly, 'true' );\n                    } else if( cell.hasAttribute( ariaReadOnly ) ) {\n                        cell.removeAttribute( ariaReadOnly );\n                    }\n                    if( cell.isSelected ) {\n                        if( isEditable ) {\n                            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n                        }\n                        _fillDown.enableFillDown( cell );\n                    }\n                } ).then( function() {\n                    delete cell.isCellEditablePromise;\n                    _isEditablePromise = null;\n                } );\n            };\n            if( _isEditablePromise ) {\n                _isEditablePromise.then( function() {\n                    removeCellSelection();\n                    updateSelectedCell( cell );\n                    _isEditablePromise = cellEditablePromise();\n                    cell.isCellEditablePromise = _isEditablePromise;\n                } );\n            } else {\n                _isEditablePromise = cellEditablePromise();\n                cell.isCellEditablePromise = _isEditablePromise;\n            }\n            return;\n        }\n\n        if( cell.propIsEditableCache ) {\n            // Mark the prop as editable since the cache tells us it is editable\n            cell.prop.isEditable = true;\n            vmo.props[ cell.propName ].isEditable = true;\n            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n            if( cell.hasAttribute( ariaReadOnly ) ) {\n                cell.removeAttribute( ariaReadOnly );\n            }\n        } else if( cell.propIsEditableCache === false ) {\n            cell.setAttribute( ariaReadOnly, 'true' );\n        }\n    };\n\n    let _guidanceMessageInitialized = false;\n\n    const publishCellNotEditable = function( vmo, prop ) {\n        eventBus.publish( _tableInstance.gridId + '.plTable.cellNotEditable', {\n            vmo: vmo,\n            prop: prop\n        } );\n    };\n\n    /**\n     * Updates ctx and the editHandler/editConfig to be in editing mode when autosave is off.\n     * Doing this ensures the edit command will get toggled when editing in autosave off mode.\n     * @param {Boolean} isEditing - If in edit\n     */\n    self.setCellEditingContext = function( isEditing ) {\n        // Enable/disable caching\n        if( isEditing ) {\n            _tableInstance.dataProvider.cacheCollapse = isEditing;\n        } else {\n            _tableInstance.dataProvider.restoreInitialCacheCollapseState();\n        }\n        _tableInstance.controller.setDraggable( !isEditing );\n\n        // For autosave off we need to see _editing flag and update ctx to get commands to switch over\n        if( !util.isAutoSaveEnabled( tableElem ) ) {\n            const editContext = getEditContext( _tableInstance );\n            if( editContext ) {\n                const editHandler = editHandlerSvc.getEditHandler( editContext );\n                editHandler._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( 'editInProgress', editHandler._editing );\n                // Need to ensure this handler is active so that save command will call this handler\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                // We need to ensure edit handler and edithandlerState to be in sync.\n                if( editHandler.editStateChangeDispatcher ) {\n                    editHandler.editStateChangeDispatcher( {\n                        type: 'SET_EDIT_STATE_CHANGED',\n                        value: editHandler._editing\n                    } );\n                }\n            } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                _tableInstance.dataProvider._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( _tableInstance.dataProvider._appCtxEditInProgress, _tableInstance.dataProvider._editing );\n            } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                _tableInstance.declViewModel._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( _tableInstance.declViewModel._internal.eventTopicEditInProgress, _tableInstance.declViewModel._editing );\n            }\n        }\n\n        // Display guidance message when auto save is off for auto save only table\n        const isAutoSaveContextTrue = appCtxService.getCtx( 'autoSave' ) && appCtxService.getCtx( 'autoSave.dbValue' );\n        if( !isAutoSaveContextTrue && tableElem._tableInstance.gridOptions.forceAutoSave && isEditing && !util.isCellEditing( tableElem ) && !_guidanceMessageInitialized ) {\n            _guidanceMessageInitialized = true;\n            displayAutoSaveOnGuidanceMessage( tableElem );\n        }\n\n        util.setIsCellEditing( tableElem, isEditing );\n    };\n\n    let _cellEditDisabledMessageInitialized = null;\n\n    const isCellSelectedNotEditable = function( cell ) {\n        return cell && cell.isSelected && cell.prop && cell.prop.isEditable === false;\n    };\n\n    /**\n     * Handles the direct edit handling for cell selection\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo the view model object\n     */\n    const handleDirectEdit = function( cell, vmo ) {\n        // Start edit\n        removeCellSelection();\n        // Check if prop isEditable needs to be reset since cache says it is true\n        if( !cell.prop.isEditable ) {\n            cell.prop.isEditable = true;\n            if( vmo.props && vmo.props[ cell.propName ] ) {\n                vmo.props[ cell.propName ].isEditable = true;\n            }\n        }\n        // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n        // can be editing at any given time.\n        const editContext = getEditContext( _tableInstance );\n        const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n        if( editContext && previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler( editContext ) && previousActiveHandler.editInProgress() ) {\n            previousActiveHandler.leaveConfirmation( () => {\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                // Reregister leaveHandler since we are making the handler active again without calling startEdit\n                editHandlerSvc.getEditHandler( editContext ).reregisterLeaveHandler();\n                self.editCell( cell, vmo );\n                self.setCellEditingContext( true );\n            } );\n        } else {\n            self.editCell( cell, vmo );\n            self.setCellEditingContext( true );\n        }\n    };\n\n    /**\n     * Handles cell click when pending isEditable Promise\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo The view model object\n     */\n    const handlePendingEditSelection = async function( cell, vmo ) {\n        // Prevent multiple calls to resolve editable promise\n        cell.isCellEditablePromiseResolving = true;\n        await cell.isCellEditablePromise;\n        delete cell.isCellEditablePromiseResolving;\n        if( cell.isSelected ) {\n            if( cell.propIsEditableCache ) {\n                _focusProp = cell.prop;\n                removeCellSelection();\n                // Check if prop isEditable needs to be reset since cache says it is true\n                if( !cell.prop.isEditable ) {\n                    cell.prop.isEditable = true;\n                    if( vmo.props && vmo.props[ cell.propName ] ) {\n                        vmo.props[ cell.propName ].isEditable = true;\n                    }\n                }\n                self.editCell( cell, vmo );\n                self.setCellEditingContext( true );\n            } else {\n                publishCellNotEditable( vmo, cell.prop );\n            }\n        }\n    };\n\n    /**\n     * Click handler for cell/row. Will select the cell and row or start edit as needed\n     *\n     * @param {Event} event the click event\n     * @param {DOMElement} cell the cell in question\n     * @param {ViewModelObject} vmo The vmo for the row\n     */\n    self.onClickHandler = async( event, cell, vmo ) => {\n        if( util.isBulkEditing( tableElem ) ) {\n            return;\n        }\n\n        if( event.ctrlKey ) {\n            triggerBlurHandler();\n            removeCellSelection();\n            updateSelectedCell( null );\n            if( util.isCellHeaderSelectionEnabled( tableElem ) ) {\n                SelectionHelper.setCellHeaderSelection( null, tableElem );\n            }\n            return;\n        }\n\n        if( cell.isSelected && cell.propIsEditableCache && !cell.isElementInEdit ) {\n            handleDirectEdit( cell, vmo );\n        } else if( cell.isSelected && util.isPropEditEnabled( tableElem ) === false && !_cellEditDisabledMessageInitialized ) {\n            // Display guidance message when cell editing is disabled\n            _cellEditDisabledMessageInitialized = true;\n            displayCellEditDisabledGuidanceMessage( tableElem );\n        } else if( cell.isSelected && cell.isCellEditablePromise && !cell.isCellEditablePromiseResolving ) {\n            handlePendingEditSelection( cell, vmo );\n        } else if( !cell.isSelected && !event.shiftKey ) {\n            await updateCellEditability( cell, vmo );\n            _fillDown.enableFillDown( cell );\n            if( util.isCellHeaderSelectionEnabled( tableElem ) ) {\n                SelectionHelper.setCellHeaderSelection( cell, tableElem );\n            }\n        } else if( event.shiftKey ) {\n            triggerBlurHandler();\n            removeCellSelection();\n            updateSelectedCell( null );\n        } else if( !cell.isCellEditablePromiseResolving && isCellSelectedNotEditable( cell ) ) {\n            publishCellNotEditable( vmo, cell.prop );\n        }\n    };\n\n    /**\n     * Adds the onclick event listener for an individual cell and gets its editability\n     * @param {DOMElement} cell - The cell to set the listener for\n     * @param {Object} vmo - The row's VMO\n     */\n    self.addCellClickListener = function( cell, vmo ) {\n        cell.onclick = function( event ) {\n            // if command click or url/anchor tag click don't select/handle select\n            if( !event.target.closest( '.aw-command, a.aw-splm-tablePropertyValueLinks' ) ) {\n                self.onClickHandler( event, cell, vmo );\n            }\n        };\n\n        cell.oncontextmenu = function( event ) {\n            if( !util.isBulkEditing( tableElem ) && !cell.isSelected ) {\n                updateCellEditability( cell, vmo );\n            }\n        };\n    };\n\n    /**\n     * Removes the cell selected classes as well as the selected attribute for the cell.\n     */\n    self.removeAllCellSelection = function() {\n        removeCellSelection();\n        updateSelectedCell();\n    };\n\n    /**\n     * Checks if the current selected cell is on the newly selected vmo(s), if not remove selection\n     * @param {Object} eventData event data\n     */\n    const checkCellAndVMOSelection = function( eventData ) {\n        let selectedObjects = eventData.selectedObjects;\n        if( _selectedCellInfo && _selectedCellInfo.vmoId ) {\n            const vmo = getVmoById( _selectedCellInfo.vmoId );\n            if( selectedObjects.indexOf( vmo ) === -1 ) {\n                self.removeAllCellSelection();\n            }\n        }\n    };\n\n    const isEligibleForCopyDown = function( columnDef ) {\n        if( util.isPropEditEnabled( tableElem ) && columnDef.isTreeNavigation !== true && columnDef.name !== 'icon' && columnDef.modifiable !== false ) {\n            return true;\n        }\n        return false;\n    };\n\n    const copyPropertyToCellContent = function( sourceProperty, vmoUid ) {\n        let cellElements = util.getCellElementsByPropertyAndUid( tableElem, sourceProperty.propertyName, vmoUid );\n        for( let i = 0; i < cellElements.length; i++ ) {\n            let cellElem = cellElements[ i ];\n            let row = cellElem.parentElement;\n            let oldCellTop = cellElem.children[ 0 ];\n            let newCellTop = Cell.createElement( cellElem.columnDef, row.vmo, tableElem, row );\n            if( util.isBulkEditing( tableElem ) ) {\n                newCellTop.classList.add( Const.CLASS_AW_EDITABLE_CELL );\n            }\n            cellElem.replaceChild( newCellTop, oldCellTop );\n        }\n    };\n\n    const copyFillDownProperty = function( targetProperty, sourceProperty ) {\n        targetProperty.uiValue = sourceProperty.uiValue;\n        targetProperty.dbValue = sourceProperty.dbValue;\n        targetProperty.valueUpdated = true;\n        uwPropertyService.updateViewModelProperty( targetProperty );\n    };\n\n    const loadCellEditabilityForTargetCells = function( uid2CellMap, vmos, propertyNames ) {\n        let editOpts = {\n            vmos: vmos,\n            propertyNames: propertyNames,\n            autoSave: util.isAutoSaveEnabled( tableElem )\n        };\n\n        return self.isPropertiesEditablePromise( editOpts ).then( function( result ) {\n            for( let currentVmo of vmos ) {\n                let cell = uid2CellMap[ currentVmo.uid ];\n                if( cell ) {\n                    cell.propIsEditableCache = result === false ? false : cell.prop && cell.prop.isEditable;\n                    if( cell.propIsEditableCache === false ) {\n                        cell.setAttribute( ariaReadOnly, 'true' );\n                    }\n                }\n            }\n            return Promise.resolve( result );\n        } );\n    };\n\n    const modifyPropsForCellEdit = function( result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp ) {\n        if( result === false ) {\n            return;\n        }\n        let propsModified = false;\n        for( let i = 0; i < vmosToEdit.length; i++ ) {\n            let currentVMO = vmosToEdit[ i ];\n            const targetProp = currentVMO.props[ eventData.propertyName ];\n\n            if( sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable ) {\n                propsModified = true;\n                cellsToSave.push( cellMap[ currentVMO.uid ] );\n                // update the target using the source\n                copyFillDownProperty( targetProp, sourceProp );\n                copyPropertyToCellContent( sourceProp, currentVMO.uid );\n            }\n        }\n        if( propsModified ) {\n            if( util.isAutoSaveEnabled( tableElem ) ) {\n                self.saveEdit( cellsToSave );\n            } else {\n                self.setCellEditingContext( true );\n            }\n        }\n    };\n\n    const prepareTargetCellPropsInfo = function( vmo, eventData, vmosToEdit, columnDef ) {\n        if( isEligibleForCopyDown( columnDef ) ) {\n            vmosToEdit.push( vmo );\n        }\n    };\n\n    const populateTargetCellPropsLegacyEdit = function( vmo, eventData, sourceProp ) {\n        const targetProp = vmo.props[ eventData.propertyName ];\n        if( sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable ) {\n            // update the target using the source\n            copyFillDownProperty( targetProp, sourceProp );\n            copyPropertyToCellContent( sourceProp, vmo.uid );\n        }\n    };\n\n    self.fillDownCompleteHandler = ( eventData ) => {\n        // get the VMOs from the table\n        let VMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n\n        let $source = VMOs.filter( function( vmo ) {\n            return vmo.uid === eventData.source;\n        } );\n\n        let sourceProp = $source[ 0 ] && $source[ 0 ].props[ eventData.propertyName ];\n        let vmosToEdit = [];\n        let cellMap = {};\n        let cellsToSave = [];\n\n        // Reverse the vmo order if we are going down\n        if( eventData.direction !== 'up' ) {\n            VMOs = VMOs.slice().reverse();\n        }\n\n        // Attempt to apply the source value to the target properties\n        let foundLastTarget = false;\n        for( let vmo of VMOs ) {\n            // Iterate over the vmos until we find the last target prop.\n            if( !foundLastTarget && vmo.uid === eventData.endTarget ) {\n                foundLastTarget = true;\n            }\n            if( !foundLastTarget ) {\n                continue;\n            }\n\n            // Stop iterating if we reach the source prop\n            if( vmo.uid === eventData.source ) {\n                break;\n            }\n\n            const columnDef = util.getColumnDef( eventData.propertyName, _tableInstance.dataProvider );\n\n            // Populate target cell props ( bulk edit mode ) or prepare the target prop info ( direct edit )\n            if( util.isBulkEditing( tableElem ) ) {\n                populateTargetCellPropsLegacyEdit( vmo, eventData, sourceProp );\n            } else {\n                const targetCell = util.getCellElementsByPropertyAndUid( tableElem, eventData.propertyName, vmo.uid )[ 0 ];\n                if( targetCell ) {\n                    cellMap[ vmo.uid ] = targetCell;\n                }\n                prepareTargetCellPropsInfo( vmo, eventData, vmosToEdit, columnDef );\n            }\n        }\n\n        // Load editabilty and apply value to editable cells\n        if( !util.isBulkEditing( tableElem ) ) {\n            _fillDownSaveInprogress = true;\n            let propertyNames = [ eventData.propertyName ];\n            loadCellEditabilityForTargetCells( cellMap, vmosToEdit, propertyNames ).then( ( result ) => {\n                modifyPropsForCellEdit( result, vmosToEdit, eventData, cellsToSave, cellMap,\n                    sourceProp );\n                _fillDownSaveInprogress = false;\n            } );\n        }\n    };\n\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectNone`, self.removeAllCellSelection ) );\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectAll`, self.removeAllCellSelection ) );\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectionChangeEvent`, checkCellAndVMOSelection ) );\n};\n\nexport default SPLMTableEditor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}