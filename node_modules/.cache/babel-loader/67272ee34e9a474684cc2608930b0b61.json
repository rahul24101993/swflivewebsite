{"ast":null,"code":"/* eslint-disable max-lines */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable complexity */\n\n/* eslint-disable require-jsdoc */\n\n/* eslint-disable no-multi-assign */\n\n/* eslint-disable no-eq-null */\n\n/* eslint-disable eqeqeq */\n\n/* eslint-disable max-statements-per-line */\n\n/* eslint-disable no-constant-condition */\n\n/* eslint-disable no-cond-assign */\n\n/* eslint-env es6 */\n\n/**\n * Sourced from https://github.com/angular/angular.js/blob/master/src/ng/parse.js#L1676 with minor changes\n *\n * (NOT) Copyright (c) 2021 Siemens\n */\nimport { forEach, isUndefined, cloneDeep as copy, isString, isNumber, isFunction, identity } from 'lodash';\n\nconst minErr = key => identity;\n\nconst isDefined = a => !isUndefined(a);\n\nconst createMap = () => new Map();\n\nconst noop = () => {//\n};\n/**\n * @private\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\n\n\nconst lowercase = function (string) {\n  return isString(string) ? string.toLowerCase() : string;\n};\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nvar $parseMinErr = minErr('$parse');\nvar objectValueOf = {}.constructor.prototype.valueOf; // Sandboxing AngularJS Expressions\n// ------------------------------\n// AngularJS expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following AngularJS expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\nfunction getStringValue(name) {\n  // Property names must be strings. This means that non-string objects cannot be used\n  // as keys in an object. Any non-string object, including a number, is typecasted\n  // into a string via the toString method.\n  // -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n  //\n  // So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n  // to a string. It's not always possible. If `name` is an object and its `toString` method is\n  // 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n  //\n  // TypeError: Cannot convert object to primitive value\n  //\n  // For performance reasons, we don't catch this error here and allow it to propagate up the call\n  // stack. Note that you'll get the same error in JavaScript if you try to access a property using\n  // such a 'broken' object as a key.\n  return String(name);\n}\n\nvar OPERATORS = createMap();\nforEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {\n  OPERATORS[operator] = true;\n});\nvar ESCAPE = {\n  n: '\\n',\n  f: '\\f',\n  r: '\\r',\n  t: '\\t',\n  v: '\\v',\n  '\\'': '\\'',\n  '\"': '\"'\n}; /////////////////////////////////////////\n\n/**\n * @constructor\n */\n\nexport var Lexer = function Lexer(options) {\n  this.options = options;\n};\n_c = Lexer;\nLexer.prototype = {\n  constructor: Lexer,\n  lex: function (text) {\n    this.text = text;\n    this.index = 0;\n    this.tokens = [];\n\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n\n      if (ch === '\"' || ch === '\\'') {\n        this.readString(ch);\n      } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n        this.readNumber();\n      } else if (this.isIdentifierStart(this.peekMultichar())) {\n        this.readIdent();\n      } else if (this.is(ch, '(){}[].,;:?')) {\n        this.tokens.push({\n          index: this.index,\n          text: ch\n        });\n        this.index++;\n      } else if (this.isWhitespace(ch)) {\n        this.index++;\n      } else {\n        var ch2 = ch + this.peek();\n        var ch3 = ch2 + this.peek(2);\n        var op1 = OPERATORS[ch];\n        var op2 = OPERATORS[ch2];\n        var op3 = OPERATORS[ch3];\n\n        if (op1 || op2 || op3) {\n          var token = op3 ? ch3 : op2 ? ch2 : ch;\n          this.tokens.push({\n            index: this.index,\n            text: token,\n            operator: true\n          });\n          this.index += token.length;\n        } else {\n          this.throwError('Unexpected next character ', this.index, this.index + 1);\n        }\n      }\n    }\n\n    return this.tokens;\n  },\n  is: function (ch, chars) {\n    return chars.indexOf(ch) !== -1;\n  },\n  peek: function (i) {\n    var num = i || 1;\n    return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;\n  },\n  isNumber: function (ch) {\n    return '0' <= ch && ch <= '9' && typeof ch === 'string';\n  },\n  isWhitespace: function (ch) {\n    // IE treats non-breaking space as \\u00A0\n    return ch === ' ' || ch === '\\r' || ch === '\\t' || ch === '\\n' || ch === '\\v' || ch === '\\u00A0';\n  },\n  isIdentifierStart: function (ch) {\n    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);\n  },\n  isValidIdentifierStart: function (ch) {\n    return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';\n  },\n  isIdentifierContinue: function (ch) {\n    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);\n  },\n  isValidIdentifierContinue: function (ch, cp) {\n    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n  },\n  codePointAt: function (ch) {\n    if (ch.length === 1) {\n      return ch.charCodeAt(0);\n    } // eslint-disable-next-line no-bitwise\n\n\n    return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;\n  },\n  peekMultichar: function () {\n    var ch = this.text.charAt(this.index);\n    var peek = this.peek();\n\n    if (!peek) {\n      return ch;\n    }\n\n    var cp1 = ch.charCodeAt(0);\n    var cp2 = peek.charCodeAt(0);\n\n    if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {\n      return ch + peek;\n    }\n\n    return ch;\n  },\n  isExpOperator: function (ch) {\n    return ch === '-' || ch === '+' || this.isNumber(ch);\n  },\n  throwError: function (error, start, end) {\n    end = end || this.index;\n    var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;\n    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);\n  },\n  readNumber: function () {\n    var number = '';\n    var start = this.index;\n\n    while (this.index < this.text.length) {\n      var ch = lowercase(this.text.charAt(this.index));\n\n      if (ch === '.' || this.isNumber(ch)) {\n        number += ch;\n      } else {\n        var peekCh = this.peek();\n\n        if (ch === 'e' && this.isExpOperator(peekCh)) {\n          number += ch;\n        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === 'e') {\n          number += ch;\n        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === 'e') {\n          this.throwError('Invalid exponent');\n        } else {\n          break;\n        }\n      }\n\n      this.index++;\n    }\n\n    this.tokens.push({\n      index: start,\n      text: number,\n      constant: true,\n      value: Number(number)\n    });\n  },\n  readIdent: function () {\n    var start = this.index;\n    this.index += this.peekMultichar().length;\n\n    while (this.index < this.text.length) {\n      var ch = this.peekMultichar();\n\n      if (!this.isIdentifierContinue(ch)) {\n        break;\n      }\n\n      this.index += ch.length;\n    }\n\n    this.tokens.push({\n      index: start,\n      text: this.text.slice(start, this.index),\n      identifier: true\n    });\n  },\n  readString: function (quote) {\n    var start = this.index;\n    this.index++;\n    var string = '';\n    var rawString = quote;\n    var escapeVar = false;\n\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n      rawString += ch;\n\n      if (escapeVar) {\n        if (ch === 'u') {\n          var hex = this.text.substring(this.index + 1, this.index + 5);\n\n          if (!hex.match(/[\\da-f]{4}/i)) {\n            this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n          }\n\n          this.index += 4;\n          string += String.fromCharCode(parseInt(hex, 16));\n        } else {\n          var rep = ESCAPE[ch];\n          string += rep || ch;\n        }\n\n        escapeVar = false;\n      } else if (ch === '\\\\') {\n        escapeVar = true;\n      } else if (ch === quote) {\n        this.index++;\n        this.tokens.push({\n          index: start,\n          text: rawString,\n          constant: true,\n          value: string\n        });\n        return;\n      } else {\n        string += ch;\n      }\n\n      this.index++;\n    }\n\n    this.throwError('Unterminated quote', start);\n  }\n};\nexport var AST = function AST(lexer, options) {\n  this.lexer = lexer;\n  this.options = options;\n};\n_c2 = AST;\nAST.Program = 'Program';\nAST.ExpressionStatement = 'ExpressionStatement';\nAST.AssignmentExpression = 'AssignmentExpression';\nAST.ConditionalExpression = 'ConditionalExpression';\nAST.LogicalExpression = 'LogicalExpression';\nAST.BinaryExpression = 'BinaryExpression';\nAST.UnaryExpression = 'UnaryExpression';\nAST.CallExpression = 'CallExpression';\nAST.MemberExpression = 'MemberExpression';\nAST.Identifier = 'Identifier';\nAST.Literal = 'Literal';\nAST.ArrayExpression = 'ArrayExpression';\nAST.Property = 'Property';\nAST.ObjectExpression = 'ObjectExpression';\nAST.ThisExpression = 'ThisExpression';\nAST.LocalsExpression = 'LocalsExpression'; // Internal use only\n\nAST.NGValueParameter = 'NGValueParameter';\nAST.prototype = {\n  ast: function (text) {\n    this.text = text;\n    this.tokens = this.lexer.lex(text);\n    var value = this.program();\n\n    if (this.tokens.length !== 0) {\n      this.throwError('is an unexpected token', this.tokens[0]);\n    }\n\n    return value;\n  },\n  program: function () {\n    var body = [];\n\n    while (true) {\n      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']')) {\n        body.push(this.expressionStatement());\n      }\n\n      if (!this.expect(';')) {\n        return {\n          type: AST.Program,\n          body: body\n        };\n      }\n    }\n  },\n  expressionStatement: function () {\n    return {\n      type: AST.ExpressionStatement,\n      expression: this.filterChain()\n    };\n  },\n  filterChain: function () {\n    var left = this.expression();\n\n    while (this.expect('|')) {\n      left = this.filter(left);\n    }\n\n    return left;\n  },\n  expression: function () {\n    return this.assignment();\n  },\n  assignment: function () {\n    var result = this.ternary();\n\n    if (this.expect('=')) {\n      if (!isAssignable(result)) {\n        throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');\n      }\n\n      result = {\n        type: AST.AssignmentExpression,\n        left: result,\n        right: this.assignment(),\n        operator: '='\n      };\n    }\n\n    return result;\n  },\n  ternary: function () {\n    var test = this.logicalOR();\n    var alternate;\n    var consequent;\n\n    if (this.expect('?')) {\n      alternate = this.expression();\n\n      if (this.consume(':')) {\n        consequent = this.expression();\n        return {\n          type: AST.ConditionalExpression,\n          test: test,\n          alternate: alternate,\n          consequent: consequent\n        };\n      }\n    }\n\n    return test;\n  },\n  logicalOR: function () {\n    var left = this.logicalAND();\n\n    while (this.expect('||')) {\n      left = {\n        type: AST.LogicalExpression,\n        operator: '||',\n        left: left,\n        right: this.logicalAND()\n      };\n    }\n\n    return left;\n  },\n  logicalAND: function () {\n    var left = this.equality();\n\n    while (this.expect('&&')) {\n      left = {\n        type: AST.LogicalExpression,\n        operator: '&&',\n        left: left,\n        right: this.equality()\n      };\n    }\n\n    return left;\n  },\n  equality: function () {\n    var left = this.relational();\n    var token;\n\n    while (token = this.expect('==', '!=', '===', '!==')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.relational()\n      };\n    }\n\n    return left;\n  },\n  relational: function () {\n    var left = this.additive();\n    var token;\n\n    while (token = this.expect('<', '>', '<=', '>=')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.additive()\n      };\n    }\n\n    return left;\n  },\n  additive: function () {\n    var left = this.multiplicative();\n    var token;\n\n    while (token = this.expect('+', '-')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.multiplicative()\n      };\n    }\n\n    return left;\n  },\n  multiplicative: function () {\n    var left = this.unary();\n    var token;\n\n    while (token = this.expect('*', '/', '%')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.unary()\n      };\n    }\n\n    return left;\n  },\n  unary: function () {\n    var token;\n\n    if (token = this.expect('+', '-', '!')) {\n      return {\n        type: AST.UnaryExpression,\n        operator: token.text,\n        prefix: true,\n        argument: this.unary()\n      };\n    }\n\n    return this.primary();\n  },\n  primary: function () {\n    var primary;\n\n    if (this.expect('(')) {\n      primary = this.filterChain();\n      this.consume(')');\n    } else if (this.expect('[')) {\n      primary = this.arrayDeclaration();\n    } else if (this.expect('{')) {\n      primary = this.object();\n    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n      primary = copy(this.selfReferential[this.consume().text]);\n    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n      primary = {\n        type: AST.Literal,\n        value: this.options.literals[this.consume().text]\n      };\n    } else if (this.peek().identifier) {\n      primary = this.identifier();\n    } else if (this.peek().constant) {\n      primary = this.constant();\n    } else {\n      this.throwError('not a primary expression', this.peek());\n    }\n\n    var next;\n\n    while (next = this.expect('(', '[', '.')) {\n      if (next.text === '(') {\n        primary = {\n          type: AST.CallExpression,\n          callee: primary,\n          arguments: this.parseArguments()\n        };\n        this.consume(')');\n      } else if (next.text === '[') {\n        primary = {\n          type: AST.MemberExpression,\n          object: primary,\n          property: this.expression(),\n          computed: true\n        };\n        this.consume(']');\n      } else if (next.text === '.') {\n        primary = {\n          type: AST.MemberExpression,\n          object: primary,\n          property: this.identifier(),\n          computed: false\n        };\n      } else {\n        this.throwError('IMPOSSIBLE');\n      }\n    }\n\n    return primary;\n  },\n  filter: function (baseExpression) {\n    var args = [baseExpression];\n    var result = {\n      type: AST.CallExpression,\n      callee: this.identifier(),\n      arguments: args,\n      filter: true\n    };\n\n    while (this.expect(':')) {\n      args.push(this.expression());\n    }\n\n    return result;\n  },\n  parseArguments: function () {\n    var args = [];\n\n    if (this.peekToken().text !== ')') {\n      do {\n        args.push(this.filterChain());\n      } while (this.expect(','));\n    }\n\n    return args;\n  },\n  identifier: function () {\n    var token = this.consume();\n\n    if (!token.identifier) {\n      this.throwError('is not a valid identifier', token);\n    }\n\n    return {\n      type: AST.Identifier,\n      name: token.text\n    };\n  },\n  constant: function () {\n    // TODO check that it is a constant\n    return {\n      type: AST.Literal,\n      value: this.consume().value\n    };\n  },\n  arrayDeclaration: function () {\n    var elements = [];\n\n    if (this.peekToken().text !== ']') {\n      do {\n        if (this.peek(']')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n\n        elements.push(this.expression());\n      } while (this.expect(','));\n    }\n\n    this.consume(']');\n    return {\n      type: AST.ArrayExpression,\n      elements: elements\n    };\n  },\n  object: function () {\n    var properties = [];\n    var property;\n\n    if (this.peekToken().text !== '}') {\n      do {\n        if (this.peek('}')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n\n        property = {\n          type: AST.Property,\n          kind: 'init'\n        };\n\n        if (this.peek().constant) {\n          property.key = this.constant();\n          property.computed = false;\n          this.consume(':');\n          property.value = this.expression();\n        } else if (this.peek().identifier) {\n          property.key = this.identifier();\n          property.computed = false;\n\n          if (this.peek(':')) {\n            this.consume(':');\n            property.value = this.expression();\n          } else {\n            property.value = property.key;\n          }\n        } else if (this.peek('[')) {\n          this.consume('[');\n          property.key = this.expression();\n          this.consume(']');\n          property.computed = true;\n          this.consume(':');\n          property.value = this.expression();\n        } else {\n          this.throwError('invalid key', this.peek());\n        }\n\n        properties.push(property);\n      } while (this.expect(','));\n    }\n\n    this.consume('}');\n    return {\n      type: AST.ObjectExpression,\n      properties: properties\n    };\n  },\n  throwError: function (msg, token) {\n    throw $parseMinErr('syntax', 'Syntax Error: Token \\'{0}\\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));\n  },\n  consume: function (e1) {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n\n    var token = this.expect(e1);\n\n    if (!token) {\n      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n    }\n\n    return token;\n  },\n  peekToken: function () {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n\n    return this.tokens[0];\n  },\n  peek: function (e1, e2, e3, e4) {\n    return this.peekAhead(0, e1, e2, e3, e4);\n  },\n  peekAhead: function (i, e1, e2, e3, e4) {\n    if (this.tokens.length > i) {\n      var token = this.tokens[i];\n      var t = token.text;\n\n      if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {\n        return token;\n      }\n    }\n\n    return false;\n  },\n  expect: function (e1, e2, e3, e4) {\n    var token = this.peek(e1, e2, e3, e4);\n\n    if (token) {\n      this.tokens.shift();\n      return token;\n    }\n\n    return false;\n  },\n  selfReferential: {\n    this: {\n      type: AST.ThisExpression\n    },\n    $locals: {\n      type: AST.LocalsExpression\n    }\n  }\n};\n\nfunction ifDefined(v, d) {\n  return typeof v !== 'undefined' ? v : d;\n}\n\nfunction plusFn(l, r) {\n  if (typeof l === 'undefined') {\n    return r;\n  }\n\n  if (typeof r === 'undefined') {\n    return l;\n  }\n\n  return l + r;\n}\n\nfunction isStateless($filter, filterName) {\n  var fn = $filter(filterName);\n  return !fn.$stateful;\n}\n\nvar PURITY_ABSOLUTE = 1;\nvar PURITY_RELATIVE = 2; // Detect nodes which could depend on non-shallow state of objects\n\nfunction isPure(node, parentIsPure) {\n  switch (node.type) {\n    // Computed members might invoke a stateful toString()\n    case AST.MemberExpression:\n      if (node.computed) {\n        return false;\n      }\n\n      break;\n    // Unary always convert to primative\n\n    case AST.UnaryExpression:\n      return PURITY_ABSOLUTE;\n    // The binary + operator can invoke a stateful toString().\n\n    case AST.BinaryExpression:\n      return node.operator !== '+' ? PURITY_ABSOLUTE : false;\n    // Functions / filters probably read state from within objects\n\n    case AST.CallExpression:\n      return false;\n  }\n\n  return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter, parentIsPure) {\n  var allConstants;\n  var argsToWatch;\n  var isStatelessFilter;\n  var astIsPure = ast.isPure = isPure(ast, parentIsPure);\n\n  switch (ast.type) {\n    case AST.Program:\n      allConstants = true;\n      forEach(ast.body, function (expr) {\n        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure);\n        allConstants = allConstants && expr.expression.constant;\n      });\n      ast.constant = allConstants;\n      break;\n\n    case AST.Literal:\n      ast.constant = true;\n      ast.toWatch = [];\n      break;\n\n    case AST.UnaryExpression:\n      findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);\n      ast.constant = ast.argument.constant;\n      ast.toWatch = ast.argument.toWatch;\n      break;\n\n    case AST.BinaryExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n      break;\n\n    case AST.LogicalExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.ConditionalExpression:\n      findConstantAndWatchExpressions(ast.test, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);\n      ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.Identifier:\n      ast.constant = false;\n      ast.toWatch = [ast];\n      break;\n\n    case AST.MemberExpression:\n      findConstantAndWatchExpressions(ast.object, $filter, astIsPure);\n\n      if (ast.computed) {\n        findConstantAndWatchExpressions(ast.property, $filter, astIsPure);\n      }\n\n      ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.CallExpression:\n      isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;\n      allConstants = isStatelessFilter;\n      argsToWatch = [];\n      forEach(ast.arguments, function (expr) {\n        findConstantAndWatchExpressions(expr, $filter, astIsPure);\n        allConstants = allConstants && expr.constant;\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      });\n      ast.constant = allConstants;\n      ast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n      break;\n\n    case AST.AssignmentExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = [ast];\n      break;\n\n    case AST.ArrayExpression:\n      allConstants = true;\n      argsToWatch = [];\n      forEach(ast.elements, function (expr) {\n        findConstantAndWatchExpressions(expr, $filter, astIsPure);\n        allConstants = allConstants && expr.constant;\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      });\n      ast.constant = allConstants;\n      ast.toWatch = argsToWatch;\n      break;\n\n    case AST.ObjectExpression:\n      allConstants = true;\n      argsToWatch = [];\n      forEach(ast.properties, function (property) {\n        findConstantAndWatchExpressions(property.value, $filter, astIsPure);\n        allConstants = allConstants && property.value.constant;\n        argsToWatch.push.apply(argsToWatch, property.value.toWatch);\n\n        if (property.computed) {\n          //`{[key]: value}` implicitly does `key.toString()` which may be non-pure\n          findConstantAndWatchExpressions(property.key, $filter,\n          /*parentIsPure=*/\n          false);\n          allConstants = allConstants && property.key.constant;\n          argsToWatch.push.apply(argsToWatch, property.key.toWatch);\n        }\n      });\n      ast.constant = allConstants;\n      ast.toWatch = argsToWatch;\n      break;\n\n    case AST.ThisExpression:\n      ast.constant = false;\n      ast.toWatch = [];\n      break;\n\n    case AST.LocalsExpression:\n      ast.constant = false;\n      ast.toWatch = [];\n      break;\n  }\n}\n\nfunction getInputs(body) {\n  if (body.length !== 1) {\n    return;\n  }\n\n  var lastExpression = body[0].expression;\n  var candidate = lastExpression.toWatch;\n\n  if (candidate.length !== 1) {\n    return candidate;\n  }\n\n  return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n  return ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n    return {\n      type: AST.AssignmentExpression,\n      left: ast.body[0].expression,\n      right: {\n        type: AST.NGValueParameter\n      },\n      operator: '='\n    };\n  }\n}\n\nfunction isLiteral(ast) {\n  return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);\n}\n\nfunction isConstant(ast) {\n  return ast.constant;\n}\n\nexport function ASTCompiler($filter) {\n  this.$filter = $filter;\n}\n_c3 = ASTCompiler;\nASTCompiler.prototype = {\n  compile: function (ast) {\n    var self = this;\n    this.state = {\n      nextId: 0,\n      filters: {},\n      fn: {\n        vars: [],\n        body: [],\n        own: {}\n      },\n      assign: {\n        vars: [],\n        body: [],\n        own: {}\n      },\n      inputs: []\n    };\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var extra = '';\n    var assignable;\n    this.stage = 'assign';\n\n    if (assignable = assignableAST(ast)) {\n      this.state.computing = 'assign';\n      var result = this.nextId();\n      this.recurse(assignable, result);\n      this.return_(result);\n      extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');\n    }\n\n    var toWatch = getInputs(ast.body);\n    self.stage = 'inputs';\n    forEach(toWatch, function (watch, key) {\n      var fnKey = 'fn' + key;\n      self.state[fnKey] = {\n        vars: [],\n        body: [],\n        own: {}\n      };\n      self.state.computing = fnKey;\n      var intoId = self.nextId();\n      self.recurse(watch, intoId);\n      self.return_(intoId);\n      self.state.inputs.push({\n        name: fnKey,\n        isPure: watch.isPure\n      });\n      watch.watchId = key;\n    });\n    this.state.computing = 'fn';\n    this.stage = 'main';\n    this.recurse(ast);\n    var fnString = // The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n    // This is a workaround for this until we do a better job at only removing the prefix only when we should.\n    '\"' + this.USE + ' ' + this.STRICT + '\";\\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;'; // eslint-disable-next-line no-new-func\n\n    var fn = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString)(this.$filter, getStringValue, ifDefined, plusFn);\n    this.state = this.stage = undefined;\n    return fn;\n  },\n  USE: 'use',\n  STRICT: 'strict',\n  watchFns: function () {\n    var result = [];\n    var inputs = this.state.inputs;\n    var self = this;\n    forEach(inputs, function (input) {\n      result.push('var ' + input.name + '=' + self.generateFunction(input.name, 's'));\n\n      if (input.isPure) {\n        result.push(input.name, '.isPure=' + JSON.stringify(input.isPure) + ';');\n      }\n    });\n\n    if (inputs.length) {\n      result.push('fn.inputs=[' + inputs.map(function (i) {\n        return i.name;\n      }).join(',') + '];');\n    }\n\n    return result.join('');\n  },\n  generateFunction: function (name, params) {\n    return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';\n  },\n  filterPrefix: function () {\n    var parts = [];\n    var self = this;\n    forEach(this.state.filters, function (id, filter) {\n      parts.push(id + '=$filter(' + self.escape(filter) + ')');\n    });\n\n    if (parts.length) {\n      return 'var ' + parts.join(',') + ';';\n    }\n\n    return '';\n  },\n  varsPrefix: function (section) {\n    return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';\n  },\n  body: function (section) {\n    return this.state[section].body.join('');\n  },\n  recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var left;\n    var right;\n    var self = this;\n    var args;\n    var expression;\n    var computed;\n    recursionFn = recursionFn || noop;\n\n    if (!skipWatchIdCheck && isDefined(ast.watchId)) {\n      intoId = intoId || this.nextId();\n      this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));\n      return;\n    }\n\n    switch (ast.type) {\n      case AST.Program:\n        forEach(ast.body, function (expression, pos) {\n          self.recurse(expression.expression, undefined, undefined, function (expr) {\n            right = expr;\n          });\n\n          if (pos !== ast.body.length - 1) {\n            self.current().body.push(right, ';');\n          } else {\n            self.return_(right);\n          }\n        });\n        break;\n\n      case AST.Literal:\n        expression = this.escape(ast.value);\n        this.assign(intoId, expression);\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.UnaryExpression:\n        this.recurse(ast.argument, undefined, undefined, function (expr) {\n          right = expr;\n        });\n        expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';\n        this.assign(intoId, expression);\n        recursionFn(expression);\n        break;\n\n      case AST.BinaryExpression:\n        this.recurse(ast.left, undefined, undefined, function (expr) {\n          left = expr;\n        });\n        this.recurse(ast.right, undefined, undefined, function (expr) {\n          right = expr;\n        });\n\n        if (ast.operator === '+') {\n          expression = this.plus(left, right);\n        } else if (ast.operator === '-') {\n          expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n        } else {\n          expression = '(' + left + ')' + ast.operator + '(' + right + ')';\n        }\n\n        this.assign(intoId, expression);\n        recursionFn(expression);\n        break;\n\n      case AST.LogicalExpression:\n        intoId = intoId || this.nextId();\n        self.recurse(ast.left, intoId);\n        self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));\n        recursionFn(intoId);\n        break;\n\n      case AST.ConditionalExpression:\n        intoId = intoId || this.nextId();\n        self.recurse(ast.test, intoId);\n        self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));\n        recursionFn(intoId);\n        break;\n\n      case AST.Identifier:\n        intoId = intoId || this.nextId();\n\n        if (nameId) {\n          nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');\n          nameId.computed = false;\n          nameId.name = ast.name;\n        }\n\n        self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {\n          self.if_(self.stage === 'inputs' || 's', function () {\n            if (create && create !== 1) {\n              self.if_(self.isNull(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));\n            }\n\n            self.assign(intoId, self.nonComputedMember('s', ast.name));\n          });\n        }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));\n        recursionFn(intoId);\n        break;\n\n      case AST.MemberExpression:\n        left = nameId && (nameId.context = this.nextId()) || this.nextId();\n        intoId = intoId || this.nextId();\n        self.recurse(ast.object, left, undefined, function () {\n          self.if_(self.notNull(left), function () {\n            if (ast.computed) {\n              right = self.nextId();\n              self.recurse(ast.property, right);\n              self.getStringValue(right);\n\n              if (create && create !== 1) {\n                self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));\n              }\n\n              expression = self.computedMember(left, right);\n              self.assign(intoId, expression);\n\n              if (nameId) {\n                nameId.computed = true;\n                nameId.name = right;\n              }\n            } else {\n              if (create && create !== 1) {\n                self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));\n              }\n\n              expression = self.nonComputedMember(left, ast.property.name);\n              self.assign(intoId, expression);\n\n              if (nameId) {\n                nameId.computed = false;\n                nameId.name = ast.property.name;\n              }\n            }\n          }, function () {\n            self.assign(intoId, 'undefined');\n          });\n          recursionFn(intoId);\n        }, Boolean(create));\n        break;\n\n      case AST.CallExpression:\n        intoId = intoId || this.nextId();\n\n        if (ast.filter) {\n          right = self.filter(ast.callee.name);\n          args = [];\n          forEach(ast.arguments, function (expr) {\n            var argument = self.nextId();\n            self.recurse(expr, argument);\n            args.push(argument);\n          });\n          expression = right + '(' + args.join(',') + ')';\n          self.assign(intoId, expression);\n          recursionFn(intoId);\n        } else {\n          right = self.nextId();\n          left = {};\n          args = [];\n          self.recurse(ast.callee, right, left, function () {\n            self.if_(self.notNull(right), function () {\n              forEach(ast.arguments, function (expr) {\n                self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {\n                  args.push(argument);\n                });\n              });\n\n              if (left.name) {\n                expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';\n              } else {\n                expression = right + '(' + args.join(',') + ')';\n              }\n\n              self.assign(intoId, expression);\n            }, function () {\n              self.assign(intoId, 'undefined');\n            });\n            recursionFn(intoId);\n          });\n        }\n\n        break;\n\n      case AST.AssignmentExpression:\n        right = this.nextId();\n        left = {};\n        this.recurse(ast.left, undefined, left, function () {\n          self.if_(self.notNull(left.context), function () {\n            self.recurse(ast.right, right);\n            expression = self.member(left.context, left.name, left.computed) + ast.operator + right;\n            self.assign(intoId, expression);\n            recursionFn(intoId || expression);\n          });\n        }, 1);\n        break;\n\n      case AST.ArrayExpression:\n        args = [];\n        forEach(ast.elements, function (expr) {\n          self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {\n            args.push(argument);\n          });\n        });\n        expression = '[' + args.join(',') + ']';\n        this.assign(intoId, expression);\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.ObjectExpression:\n        args = [];\n        computed = false;\n        forEach(ast.properties, function (property) {\n          if (property.computed) {\n            computed = true;\n          }\n        });\n\n        if (computed) {\n          intoId = intoId || this.nextId();\n          this.assign(intoId, '{}');\n          forEach(ast.properties, function (property) {\n            if (property.computed) {\n              left = self.nextId();\n              self.recurse(property.key, left);\n            } else {\n              left = property.key.type === AST.Identifier ? property.key.name : String(property.key.value);\n            }\n\n            right = self.nextId();\n            self.recurse(property.value, right);\n            self.assign(self.member(intoId, left, property.computed), right);\n          });\n        } else {\n          forEach(ast.properties, function (property) {\n            self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {\n              args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : String(property.key.value)) + ':' + expr);\n            });\n          });\n          expression = '{' + args.join(',') + '}';\n          this.assign(intoId, expression);\n        }\n\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.ThisExpression:\n        this.assign(intoId, 's');\n        recursionFn(intoId || 's');\n        break;\n\n      case AST.LocalsExpression:\n        this.assign(intoId, 'l');\n        recursionFn(intoId || 'l');\n        break;\n\n      case AST.NGValueParameter:\n        this.assign(intoId, 'v');\n        recursionFn(intoId || 'v');\n        break;\n    }\n  },\n  getHasOwnProperty: function (element, property) {\n    var key = element + '.' + property;\n    var own = this.current().own;\n\n    if (!own.hasOwnProperty(key)) {\n      own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');\n    }\n\n    return own[key];\n  },\n  assign: function (id, value) {\n    if (!id) {\n      return;\n    }\n\n    this.current().body.push(id, '=', value, ';');\n    return id;\n  },\n  filter: function (filterName) {\n    if (!this.state.filters.hasOwnProperty(filterName)) {\n      this.state.filters[filterName] = this.nextId(true);\n    }\n\n    return this.state.filters[filterName];\n  },\n  ifDefined: function (id, defaultValue) {\n    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';\n  },\n  plus: function (left, right) {\n    return 'plus(' + left + ',' + right + ')';\n  },\n  return_: function (id) {\n    this.current().body.push('return ', id, ';');\n  },\n  if_: function (test, alternate, consequent) {\n    if (test === true) {\n      alternate();\n    } else {\n      var body = this.current().body;\n      body.push('if(', test, '){');\n      alternate();\n      body.push('}');\n\n      if (consequent) {\n        body.push('else{');\n        consequent();\n        body.push('}');\n      }\n    }\n  },\n  not: function (expression) {\n    return '!(' + expression + ')';\n  },\n  isNull: function (expression) {\n    return expression + '==null';\n  },\n  notNull: function (expression) {\n    return expression + '!=null';\n  },\n  nonComputedMember: function (left, right) {\n    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n    var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n\n    if (SAFE_IDENTIFIER.test(right)) {\n      return left + '.' + right;\n    }\n\n    return left + '[\"' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '\"]';\n  },\n  computedMember: function (left, right) {\n    return left + '[' + right + ']';\n  },\n  member: function (left, right, computed) {\n    if (computed) {\n      return this.computedMember(left, right);\n    }\n\n    return this.nonComputedMember(left, right);\n  },\n  getStringValue: function (item) {\n    this.assign(item, 'getStringValue(' + item + ')');\n  },\n  lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var self = this;\n    return function () {\n      self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n    };\n  },\n  lazyAssign: function (id, value) {\n    var self = this;\n    return function () {\n      self.assign(id, value);\n    };\n  },\n  stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n  stringEscapeFn: function (c) {\n    return '\\\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n  },\n  escape: function (value) {\n    if (isString(value)) {\n      return '\\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\\'';\n    }\n\n    if (isNumber(value)) {\n      return value.toString();\n    }\n\n    if (value === true) {\n      return 'true';\n    }\n\n    if (value === false) {\n      return 'false';\n    }\n\n    if (value === null) {\n      return 'null';\n    }\n\n    if (typeof value === 'undefined') {\n      return 'undefined';\n    }\n\n    throw $parseMinErr('esc', 'IMPOSSIBLE');\n  },\n  nextId: function (skip, init) {\n    var id = 'v' + this.state.nextId++;\n\n    if (!skip) {\n      this.current().vars.push(id + (init ? '=' + init : ''));\n    }\n\n    return id;\n  },\n  current: function () {\n    return this.state[this.state.computing];\n  }\n};\nexport function ASTInterpreter($filter) {\n  this.$filter = $filter;\n}\n_c4 = ASTInterpreter;\nASTInterpreter.prototype = {\n  compile: function (ast) {\n    var self = this;\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var assignable;\n    var assign;\n\n    if (assignable = assignableAST(ast)) {\n      assign = this.recurse(assignable);\n    }\n\n    var toWatch = getInputs(ast.body);\n    var inputs;\n\n    if (toWatch) {\n      inputs = [];\n      forEach(toWatch, function (watch, key) {\n        var input = self.recurse(watch);\n        input.isPure = watch.isPure;\n        watch.input = input;\n        inputs.push(input);\n        watch.watchId = key;\n      });\n    }\n\n    var expressions = [];\n    forEach(ast.body, function (expression) {\n      expressions.push(self.recurse(expression.expression));\n    });\n    var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {\n      var lastValue;\n      forEach(expressions, function (exp) {\n        lastValue = exp(scope, locals);\n      });\n      return lastValue;\n    };\n\n    if (assign) {\n      fn.assign = function (scope, value, locals) {\n        return assign(scope, locals, value);\n      };\n    }\n\n    if (inputs) {\n      fn.inputs = inputs;\n    }\n\n    return fn;\n  },\n  recurse: function (ast, context, create) {\n    var left;\n    var right;\n    var self = this;\n    var args;\n\n    if (ast.input) {\n      return this.inputs(ast.input, ast.watchId);\n    }\n\n    switch (ast.type) {\n      case AST.Literal:\n        return this.value(ast.value, context);\n\n      case AST.UnaryExpression:\n        right = this.recurse(ast.argument);\n        return this['unary' + ast.operator](right, context);\n\n      case AST.BinaryExpression:\n        left = this.recurse(ast.left);\n        right = this.recurse(ast.right);\n        return this['binary' + ast.operator](left, right, context);\n\n      case AST.LogicalExpression:\n        left = this.recurse(ast.left);\n        right = this.recurse(ast.right);\n        return this['binary' + ast.operator](left, right, context);\n\n      case AST.ConditionalExpression:\n        return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);\n\n      case AST.Identifier:\n        return self.identifier(ast.name, context, create);\n\n      case AST.MemberExpression:\n        left = this.recurse(ast.object, false, Boolean(create));\n\n        if (!ast.computed) {\n          right = ast.property.name;\n        }\n\n        if (ast.computed) {\n          right = this.recurse(ast.property);\n        }\n\n        return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);\n\n      case AST.CallExpression:\n        args = [];\n        forEach(ast.arguments, function (expr) {\n          args.push(self.recurse(expr));\n        });\n\n        if (ast.filter) {\n          right = this.$filter(ast.callee.name);\n        }\n\n        if (!ast.filter) {\n          right = this.recurse(ast.callee, true);\n        }\n\n        return ast.filter ? function (scope, locals, assign, inputs) {\n          var values = [];\n\n          for (var i = 0; i < args.length; ++i) {\n            values.push(args[i](scope, locals, assign, inputs));\n          }\n\n          var value = right.apply(undefined, values, inputs);\n          return context ? {\n            context: undefined,\n            name: undefined,\n            value: value\n          } : value;\n        } : function (scope, locals, assign, inputs) {\n          var rhs = right(scope, locals, assign, inputs);\n          var value;\n\n          if (rhs.value != null) {\n            var values = [];\n\n            for (var i = 0; i < args.length; ++i) {\n              values.push(args[i](scope, locals, assign, inputs));\n            }\n\n            value = rhs.value.apply(rhs.context, values);\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.AssignmentExpression:\n        left = this.recurse(ast.left, true, 1);\n        right = this.recurse(ast.right);\n        return function (scope, locals, assign, inputs) {\n          var lhs = left(scope, locals, assign, inputs);\n          var rhs = right(scope, locals, assign, inputs);\n          lhs.context[lhs.name] = rhs;\n          return context ? {\n            value: rhs\n          } : rhs;\n        };\n\n      case AST.ArrayExpression:\n        args = [];\n        forEach(ast.elements, function (expr) {\n          args.push(self.recurse(expr));\n        });\n        return function (scope, locals, assign, inputs) {\n          var value = [];\n\n          for (var i = 0; i < args.length; ++i) {\n            value.push(args[i](scope, locals, assign, inputs));\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.ObjectExpression:\n        args = [];\n        forEach(ast.properties, function (property) {\n          if (property.computed) {\n            args.push({\n              key: self.recurse(property.key),\n              computed: true,\n              value: self.recurse(property.value)\n            });\n          } else {\n            args.push({\n              key: property.key.type === AST.Identifier ? property.key.name : String(property.key.value),\n              computed: false,\n              value: self.recurse(property.value)\n            });\n          }\n        });\n        return function (scope, locals, assign, inputs) {\n          var value = {};\n\n          for (var i = 0; i < args.length; ++i) {\n            if (args[i].computed) {\n              value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);\n            } else {\n              value[args[i].key] = args[i].value(scope, locals, assign, inputs);\n            }\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.ThisExpression:\n        return function (scope) {\n          return context ? {\n            value: scope\n          } : scope;\n        };\n\n      case AST.LocalsExpression:\n        return function (scope, locals) {\n          return context ? {\n            value: locals\n          } : locals;\n        };\n\n      case AST.NGValueParameter:\n        return function (scope, locals, assign) {\n          return context ? {\n            value: assign\n          } : assign;\n        };\n    }\n  },\n  'unary+': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n\n      if (isDefined(arg)) {\n        arg = Number(arg);\n      } else {\n        arg = 0;\n      }\n\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'unary-': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n\n      if (isDefined(arg)) {\n        arg = -arg;\n      } else {\n        arg = -0;\n      }\n\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'unary!': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = !argument(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary+': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = plusFn(lhs, rhs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary-': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary*': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary/': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary%': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary===': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary!==': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary==': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary!=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary<': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary>': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary<=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary>=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary&&': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary||': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'ternary?:': function (test, alternate, consequent, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  value: function (value, context) {\n    return function () {\n      return context ? {\n        context: undefined,\n        name: undefined,\n        value: value\n      } : value;\n    };\n  },\n  identifier: function (name, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var base = locals && name in locals ? locals : scope;\n\n      if (create && create !== 1 && base && base[name] == null) {\n        base[name] = {};\n      }\n\n      var value = base ? base[name] : undefined;\n\n      if (context) {\n        return {\n          context: base,\n          name: name,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  computedMember: function (left, right, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs;\n      var value;\n\n      if (lhs != null) {\n        rhs = right(scope, locals, assign, inputs);\n        rhs = getStringValue(rhs);\n\n        if (create && create !== 1) {\n          if (lhs && !lhs[rhs]) {\n            lhs[rhs] = {};\n          }\n        }\n\n        value = lhs[rhs];\n      }\n\n      if (context) {\n        return {\n          context: lhs,\n          name: rhs,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  nonComputedMember: function (left, right, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n\n      if (create && create !== 1) {\n        if (lhs && lhs[right] == null) {\n          lhs[right] = {};\n        }\n      }\n\n      var value = lhs != null ? lhs[right] : undefined;\n\n      if (context) {\n        return {\n          context: lhs,\n          name: right,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  inputs: function (input, watchId) {\n    return function (scope, value, locals, inputs) {\n      if (inputs) {\n        return inputs[watchId];\n      }\n\n      return input(scope, value, locals);\n    };\n  }\n};\n/**\n * @constructor\n */\n\nexport function Parser(lexer, $filter, options) {\n  this.ast = new AST(lexer, options);\n  this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);\n}\n_c5 = Parser;\nParser.prototype = {\n  constructor: Parser,\n  parse: function (text) {\n    var ast = this.getAst(text);\n    var fn = this.astCompiler.compile(ast.ast);\n    fn.literal = isLiteral(ast.ast);\n    fn.constant = isConstant(ast.ast);\n    fn.oneTime = ast.oneTime;\n    return fn;\n  },\n  getAst: function (exp) {\n    var oneTime = false;\n    exp = exp.trim();\n\n    if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {\n      oneTime = true;\n      exp = exp.substring(2);\n    }\n\n    return {\n      ast: this.ast.ast(exp),\n      oneTime: oneTime\n    };\n  }\n};\n\nfunction getValueOf(value) {\n  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);\n} ///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts AngularJS {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'AngularJS'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('AngularJS');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context`  `{object}`  an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals`  `{object=}`  local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\n\n\nexport function $ParseProvider() {\n  var cache = createMap();\n  var literals = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined\n  };\n  var identStart;\n  var identContinue;\n  /**\n  * @ngdoc method\n  * @name $parseProvider#addLiteral\n  * @description\n  *\n  * Configure $parse service to add literal values that will be present as literal at expressions.\n  *\n  * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n  * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n  *\n  **/\n\n  this.addLiteral = function (literalName, literalValue) {\n    literals[literalName] = literalValue;\n  };\n  /**\n  * @ngdoc method\n  * @name $parseProvider#setIdentifierFns\n  *\n  * @description\n  *\n  * Allows defining the set of characters that are allowed in AngularJS expressions. The function\n  * `identifierStart` will get called to know if a given character is a valid character to be the\n  * first character for an identifier. The function `identifierContinue` will get called to know if\n  * a given character is a valid character to be a follow-up identifier character. The functions\n  * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n  * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n  * mind that the `string` parameter can be two characters long depending on the character\n  * representation. It is expected for the function to return `true` or `false`, whether that\n  * character is allowed or not.\n  *\n  * Since this function will be called extensively, keep the implementation of these functions fast,\n  * as the performance of these functions have a direct impact on the expressions parsing speed.\n  *\n  * @param {function=} identifierStart The function that will decide whether the given character is\n  *   a valid identifier start character.\n  * @param {function=} identifierContinue The function that will decide whether the given character is\n  *   a valid identifier continue character.\n  */\n\n\n  this.setIdentifierFns = function (identifierStart, identifierContinue) {\n    identStart = identifierStart;\n    identContinue = identifierContinue;\n    return this;\n  };\n\n  this.$get = ['$filter', function ($filter) {\n    var noUnsafeEval = false; //csp().noUnsafeEval;\n\n    var $parseOptions = {\n      csp: noUnsafeEval,\n      literals: copy(literals),\n      isIdentifierStart: isFunction(identStart) && identStart,\n      isIdentifierContinue: isFunction(identContinue) && identContinue\n    };\n    $parse.$$getAst = $$getAst;\n    return $parse;\n\n    function $parse(exp, interceptorFn) {\n      var parsedExpression;\n      var cacheKey;\n\n      switch (typeof exp) {\n        case 'string':\n          exp = exp.trim();\n          cacheKey = exp;\n          parsedExpression = cache[cacheKey];\n\n          if (!parsedExpression) {\n            var lexer = new Lexer($parseOptions);\n            var parser = new Parser(lexer, $filter, $parseOptions);\n            parsedExpression = parser.parse(exp);\n            cache[cacheKey] = addWatchDelegate(parsedExpression);\n          }\n\n          return addInterceptor(parsedExpression, interceptorFn);\n\n        case 'function':\n          return addInterceptor(exp, interceptorFn);\n\n        default:\n          return addInterceptor(noop, interceptorFn);\n      }\n    }\n\n    function $$getAst(exp) {\n      var lexer = new Lexer($parseOptions);\n      var parser = new Parser(lexer, $filter, $parseOptions);\n      return parser.getAst(exp).ast;\n    }\n\n    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {\n      if (newValue == null || oldValueOfValue == null) {\n        // null/undefined\n        return newValue === oldValueOfValue;\n      }\n\n      if (typeof newValue === 'object') {\n        // attempt to convert the value to a primitive type\n        // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n        //             be cheaply dirty-checked\n        newValue = getValueOf(newValue);\n\n        if (typeof newValue === 'object' && !compareObjectIdentity) {\n          // objects/arrays are not supported - deep-watching them would be too expensive\n          return false;\n        } // fall-through to the primitive equality check\n\n      } //Primitive or NaN\n      // eslint-disable-next-line no-self-compare\n\n\n      return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;\n    }\n\n    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var inputExpressions = parsedExpression.inputs;\n      var lastResult;\n\n      if (inputExpressions.length === 1) {\n        var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\n        inputExpressions = inputExpressions[0];\n        return scope.$watch(function expressionInputWatch(scope) {\n          var newInputValue = inputExpressions(scope);\n\n          if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {\n            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);\n            oldInputValueOf = newInputValue && getValueOf(newInputValue);\n          }\n\n          return lastResult;\n        }, listener, objectEquality, prettyPrintExpression);\n      }\n\n      var oldInputValueOfValues = [];\n      var oldInputValues = [];\n\n      for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n        oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\n        oldInputValues[i] = null;\n      }\n\n      return scope.$watch(function expressionInputsWatch(scope) {\n        var changed = false;\n\n        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n          var newInputValue = inputExpressions[i](scope);\n\n          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) {\n            oldInputValues[i] = newInputValue;\n            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);\n          }\n        }\n\n        if (changed) {\n          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);\n        }\n\n        return lastResult;\n      }, listener, objectEquality, prettyPrintExpression);\n    }\n\n    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var isDone = parsedExpression.literal ? isAllDefined : isDefined;\n      var unwatch;\n      var lastValue;\n      var exp = parsedExpression.$$intercepted || parsedExpression;\n      var post = parsedExpression.$$interceptor || identity;\n      var useInputs = parsedExpression.inputs && !exp.inputs; // Propagate the literal/inputs/constant attributes\n      // ... but not oneTime since we are handling it\n\n      oneTimeWatch.literal = parsedExpression.literal;\n      oneTimeWatch.constant = parsedExpression.constant;\n      oneTimeWatch.inputs = parsedExpression.inputs; // Allow other delegates to run on this wrapped expression\n\n      addWatchDelegate(oneTimeWatch);\n      unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);\n      return unwatch;\n\n      function unwatchIfDone() {\n        if (isDone(lastValue)) {\n          unwatch();\n        }\n      }\n\n      function oneTimeWatch(scope, locals, assign, inputs) {\n        lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs);\n\n        if (isDone(lastValue)) {\n          scope.$$postDigest(unwatchIfDone);\n        }\n\n        return post(lastValue);\n      }\n    }\n\n    function isAllDefined(value) {\n      var allDefined = true;\n      forEach(value, function (val) {\n        if (!isDefined(val)) {\n          allDefined = false;\n        }\n      });\n      return allDefined;\n    }\n\n    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {\n      var unwatch = scope.$watch(function constantWatch(scope) {\n        unwatch();\n        return parsedExpression(scope);\n      }, listener, objectEquality);\n      return unwatch;\n    }\n\n    function addWatchDelegate(parsedExpression) {\n      if (parsedExpression.constant) {\n        parsedExpression.$$watchDelegate = constantWatchDelegate;\n      } else if (parsedExpression.oneTime) {\n        parsedExpression.$$watchDelegate = oneTimeWatchDelegate;\n      } else if (parsedExpression.inputs) {\n        parsedExpression.$$watchDelegate = inputsWatchDelegate;\n      }\n\n      return parsedExpression;\n    }\n\n    function chainInterceptors(first, second) {\n      function chainedInterceptor(value) {\n        return second(first(value));\n      }\n\n      chainedInterceptor.$stateful = first.$stateful || second.$stateful;\n      chainedInterceptor.$$pure = first.$$pure && second.$$pure;\n      return chainedInterceptor;\n    }\n\n    function addInterceptor(parsedExpression, interceptorFn) {\n      if (!interceptorFn) {\n        return parsedExpression;\n      } // Extract any existing interceptors out of the parsedExpression\n      // to ensure the original parsedExpression is always the $$intercepted\n\n\n      if (parsedExpression.$$interceptor) {\n        interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn);\n        parsedExpression = parsedExpression.$$intercepted;\n      }\n\n      var useInputs = false;\n\n      var fn = function interceptedExpression(scope, locals, assign, inputs) {\n        var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);\n        return interceptorFn(value);\n      }; // Maintain references to the interceptor/intercepted\n\n\n      fn.$$intercepted = parsedExpression;\n      fn.$$interceptor = interceptorFn; // Propagate the literal/oneTime/constant attributes\n\n      fn.literal = parsedExpression.literal;\n      fn.oneTime = parsedExpression.oneTime;\n      fn.constant = parsedExpression.constant; // Treat the interceptor like filters.\n      // If it is not $stateful then only watch its inputs.\n      // If the expression itself has no inputs then use the full expression as an input.\n\n      if (!interceptorFn.$stateful) {\n        useInputs = !parsedExpression.inputs;\n        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];\n\n        if (!interceptorFn.$$pure) {\n          fn.inputs = fn.inputs.map(function (e) {\n            // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a\n            // non-pure interceptor function.\n            if (e.isPure === PURITY_RELATIVE) {\n              return function depurifier(s) {\n                return e(s);\n              };\n            }\n\n            return e;\n          });\n        }\n      }\n\n      return addWatchDelegate(fn);\n    }\n  }];\n}\n\nvar _c, _c2, _c3, _c4, _c5;\n\n$RefreshReg$(_c, \"Lexer\");\n$RefreshReg$(_c2, \"AST\");\n$RefreshReg$(_c3, \"ASTCompiler\");\n$RefreshReg$(_c4, \"ASTInterpreter\");\n$RefreshReg$(_c5, \"Parser\");","map":{"version":3,"names":["forEach","isUndefined","cloneDeep","copy","isString","isNumber","isFunction","identity","minErr","key","isDefined","a","createMap","Map","noop","lowercase","string","toLowerCase","$parseMinErr","objectValueOf","constructor","prototype","valueOf","getStringValue","name","String","OPERATORS","split","operator","ESCAPE","n","f","r","t","v","Lexer","options","lex","text","index","tokens","length","ch","charAt","readString","peek","readNumber","isIdentifierStart","peekMultichar","readIdent","is","push","isWhitespace","ch2","ch3","op1","op2","op3","token","throwError","chars","indexOf","i","num","codePointAt","isValidIdentifierStart","isIdentifierContinue","isValidIdentifierContinue","cp","charCodeAt","cp1","cp2","isExpOperator","error","start","end","colStr","substring","number","peekCh","constant","value","Number","slice","identifier","quote","rawString","escapeVar","hex","match","fromCharCode","parseInt","rep","AST","lexer","Program","ExpressionStatement","AssignmentExpression","ConditionalExpression","LogicalExpression","BinaryExpression","UnaryExpression","CallExpression","MemberExpression","Identifier","Literal","ArrayExpression","Property","ObjectExpression","ThisExpression","LocalsExpression","NGValueParameter","ast","program","body","expressionStatement","expect","type","expression","filterChain","left","filter","assignment","result","ternary","isAssignable","right","test","logicalOR","alternate","consequent","consume","logicalAND","equality","relational","additive","multiplicative","unary","prefix","argument","primary","arrayDeclaration","object","selfReferential","hasOwnProperty","literals","next","callee","arguments","parseArguments","property","computed","baseExpression","args","peekToken","elements","properties","kind","msg","e1","e2","e3","e4","peekAhead","shift","this","$locals","ifDefined","d","plusFn","l","isStateless","$filter","filterName","fn","$stateful","PURITY_ABSOLUTE","PURITY_RELATIVE","isPure","node","parentIsPure","undefined","findConstantAndWatchExpressions","allConstants","argsToWatch","isStatelessFilter","astIsPure","expr","toWatch","concat","apply","getInputs","lastExpression","candidate","assignableAST","isLiteral","isConstant","ASTCompiler","compile","self","state","nextId","filters","vars","own","assign","inputs","extra","assignable","stage","computing","recurse","return_","generateFunction","watch","fnKey","intoId","watchId","fnString","USE","STRICT","filterPrefix","watchFns","Function","input","JSON","stringify","map","join","params","varsPrefix","parts","id","escape","section","nameId","recursionFn","create","skipWatchIdCheck","if_","lazyAssign","computedMember","lazyRecurse","pos","current","plus","not","context","getHasOwnProperty","isNull","nonComputedMember","notNull","Boolean","member","element","defaultValue","SAFE_IDENTIFIER","UNSAFE_CHARACTERS","replace","stringEscapeFn","item","stringEscapeRegex","c","toString","skip","init","ASTInterpreter","expressions","scope","locals","lastValue","exp","values","rhs","lhs","arg","base","Parser","astCompiler","csp","parse","getAst","literal","oneTime","trim","getValueOf","call","$ParseProvider","cache","true","false","null","identStart","identContinue","addLiteral","literalName","literalValue","setIdentifierFns","identifierStart","identifierContinue","$get","noUnsafeEval","$parseOptions","$parse","$$getAst","interceptorFn","parsedExpression","cacheKey","parser","addWatchDelegate","addInterceptor","expressionInputDirtyCheck","newValue","oldValueOfValue","compareObjectIdentity","inputsWatchDelegate","listener","objectEquality","prettyPrintExpression","inputExpressions","lastResult","oldInputValueOf","$watch","expressionInputWatch","newInputValue","oldInputValueOfValues","oldInputValues","ii","expressionInputsWatch","changed","oneTimeWatchDelegate","isDone","isAllDefined","unwatch","$$intercepted","post","$$interceptor","useInputs","oneTimeWatch","unwatchIfDone","$$postDigest","allDefined","val","constantWatchDelegate","constantWatch","$$watchDelegate","chainInterceptors","first","second","chainedInterceptor","$$pure","interceptedExpression","e","depurifier","s"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/angularjsParseService.js"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable complexity */\n/* eslint-disable require-jsdoc */\n/* eslint-disable no-multi-assign */\n/* eslint-disable no-eq-null */\n/* eslint-disable eqeqeq */\n/* eslint-disable max-statements-per-line */\n/* eslint-disable no-constant-condition */\n/* eslint-disable no-cond-assign */\n/* eslint-env es6 */\n\n/**\n * Sourced from https://github.com/angular/angular.js/blob/master/src/ng/parse.js#L1676 with minor changes\n *\n * (NOT) Copyright (c) 2021 Siemens\n */\n\nimport {\n    forEach,\n    isUndefined,\n    cloneDeep as copy,\n    isString,\n    isNumber,\n    isFunction,\n    identity\n} from 'lodash';\n\nconst minErr = ( key ) => identity;\nconst isDefined = ( a ) => !isUndefined( a );\nconst createMap = () => new Map();\nconst noop = () => {\n    //\n};\n\n/**\n * @private\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\nconst lowercase = function( string ) {\n    return isString( string ) ? string.toLowerCase() : string;\n};\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr( '$parse' );\n\nvar objectValueOf = {}.constructor.prototype.valueOf;\n\n// Sandboxing AngularJS Expressions\n// ------------------------------\n// AngularJS expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following AngularJS expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\n\nfunction getStringValue( name ) {\n    // Property names must be strings. This means that non-string objects cannot be used\n    // as keys in an object. Any non-string object, including a number, is typecasted\n    // into a string via the toString method.\n    // -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n    //\n    // So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n    // to a string. It's not always possible. If `name` is an object and its `toString` method is\n    // 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n    //\n    // TypeError: Cannot convert object to primitive value\n    //\n    // For performance reasons, we don't catch this error here and allow it to propagate up the call\n    // stack. Note that you'll get the same error in JavaScript if you try to access a property using\n    // such a 'broken' object as a key.\n    return String( name );\n}\n\n\nvar OPERATORS = createMap();\nforEach( '+ - * / % === !== == != < > <= >= && || ! = |'.split( ' ' ), function( operator ) { OPERATORS[operator] = true; } );\nvar ESCAPE = { n:'\\n', f:'\\f', r:'\\r', t:'\\t', v:'\\v', '\\'':'\\'', '\"':'\"' };\n\n\n/////////////////////////////////////////\n\n\n/**\n * @constructor\n */\nexport var Lexer = function Lexer( options ) {\n    this.options = options;\n};\n\nLexer.prototype = {\n    constructor: Lexer,\n\n    lex: function( text ) {\n        this.text = text;\n        this.index = 0;\n        this.tokens = [];\n\n        while ( this.index < this.text.length ) {\n            var ch = this.text.charAt( this.index );\n            if ( ch === '\"' || ch === '\\'' ) {\n                this.readString( ch );\n            } else if ( this.isNumber( ch ) || ch === '.' && this.isNumber( this.peek() ) ) {\n                this.readNumber();\n            } else if ( this.isIdentifierStart( this.peekMultichar() ) ) {\n                this.readIdent();\n            } else if ( this.is( ch, '(){}[].,;:?' ) ) {\n                this.tokens.push( { index: this.index, text: ch } );\n                this.index++;\n            } else if ( this.isWhitespace( ch ) ) {\n                this.index++;\n            } else {\n                var ch2 = ch + this.peek();\n                var ch3 = ch2 + this.peek( 2 );\n                var op1 = OPERATORS[ch];\n                var op2 = OPERATORS[ch2];\n                var op3 = OPERATORS[ch3];\n                if ( op1 || op2 || op3 ) {\n                    var token = op3 ? ch3 : op2 ? ch2 : ch;\n                    this.tokens.push( { index: this.index, text: token, operator: true } );\n                    this.index += token.length;\n                } else {\n                    this.throwError( 'Unexpected next character ', this.index, this.index + 1 );\n                }\n            }\n        }\n        return this.tokens;\n    },\n\n    is: function( ch, chars ) {\n        return chars.indexOf( ch ) !== -1;\n    },\n\n    peek: function( i ) {\n        var num = i || 1;\n        return this.index + num < this.text.length ? this.text.charAt( this.index + num ) : false;\n    },\n\n    isNumber: function( ch ) {\n        return '0' <= ch && ch <= '9' && typeof ch === 'string';\n    },\n\n    isWhitespace: function( ch ) {\n    // IE treats non-breaking space as \\u00A0\n        return ch === ' ' || ch === '\\r' || ch === '\\t' ||\n            ch === '\\n' || ch === '\\v' || ch === '\\u00A0';\n    },\n\n    isIdentifierStart: function( ch ) {\n        return this.options.isIdentifierStart ?\n            this.options.isIdentifierStart( ch, this.codePointAt( ch ) ) :\n            this.isValidIdentifierStart( ch );\n    },\n\n    isValidIdentifierStart: function( ch ) {\n        return 'a' <= ch && ch <= 'z' ||\n            'A' <= ch && ch <= 'Z' ||\n            '_' === ch || ch === '$';\n    },\n\n    isIdentifierContinue: function( ch ) {\n        return this.options.isIdentifierContinue ?\n            this.options.isIdentifierContinue( ch, this.codePointAt( ch ) ) :\n            this.isValidIdentifierContinue( ch );\n    },\n\n    isValidIdentifierContinue: function( ch, cp ) {\n        return this.isValidIdentifierStart( ch, cp ) || this.isNumber( ch );\n    },\n\n    codePointAt: function( ch ) {\n        if ( ch.length === 1 ) { return ch.charCodeAt( 0 ); }\n        // eslint-disable-next-line no-bitwise\n        return ( ch.charCodeAt( 0 ) << 10 ) + ch.charCodeAt( 1 ) - 0x35FDC00;\n    },\n\n    peekMultichar: function() {\n        var ch = this.text.charAt( this.index );\n        var peek = this.peek();\n        if ( !peek ) {\n            return ch;\n        }\n        var cp1 = ch.charCodeAt( 0 );\n        var cp2 = peek.charCodeAt( 0 );\n        if ( cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF ) {\n            return ch + peek;\n        }\n        return ch;\n    },\n\n    isExpOperator: function( ch ) {\n        return ch === '-' || ch === '+' || this.isNumber( ch );\n    },\n\n    throwError: function( error, start, end ) {\n        end = end || this.index;\n        var colStr = isDefined( start )\n            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring( start, end ) + ']'\n            : ' ' + end;\n        throw $parseMinErr( 'lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',\n            error, colStr, this.text );\n    },\n\n    readNumber: function() {\n        var number = '';\n        var start = this.index;\n        while ( this.index < this.text.length ) {\n            var ch = lowercase( this.text.charAt( this.index ) );\n            if ( ch === '.' || this.isNumber( ch ) ) {\n                number += ch;\n            } else {\n                var peekCh = this.peek();\n                if ( ch === 'e' && this.isExpOperator( peekCh ) ) {\n                    number += ch;\n                } else if ( this.isExpOperator( ch ) &&\n            peekCh && this.isNumber( peekCh ) &&\n            number.charAt( number.length - 1 ) === 'e' ) {\n                    number += ch;\n                } else if ( this.isExpOperator( ch ) &&\n            ( !peekCh || !this.isNumber( peekCh ) ) &&\n            number.charAt( number.length - 1 ) === 'e' ) {\n                    this.throwError( 'Invalid exponent' );\n                } else {\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.tokens.push( {\n            index: start,\n            text: number,\n            constant: true,\n            value: Number( number )\n        } );\n    },\n\n    readIdent: function() {\n        var start = this.index;\n        this.index += this.peekMultichar().length;\n        while ( this.index < this.text.length ) {\n            var ch = this.peekMultichar();\n            if ( !this.isIdentifierContinue( ch ) ) {\n                break;\n            }\n            this.index += ch.length;\n        }\n        this.tokens.push( {\n            index: start,\n            text: this.text.slice( start, this.index ),\n            identifier: true\n        } );\n    },\n\n    readString: function( quote ) {\n        var start = this.index;\n        this.index++;\n        var string = '';\n        var rawString = quote;\n        var escapeVar = false;\n        while ( this.index < this.text.length ) {\n            var ch = this.text.charAt( this.index );\n            rawString += ch;\n            if ( escapeVar ) {\n                if ( ch === 'u' ) {\n                    var hex = this.text.substring( this.index + 1, this.index + 5 );\n                    if ( !hex.match( /[\\da-f]{4}/i ) ) {\n                        this.throwError( 'Invalid unicode escape [\\\\u' + hex + ']' );\n                    }\n                    this.index += 4;\n                    string += String.fromCharCode( parseInt( hex, 16 ) );\n                } else {\n                    var rep = ESCAPE[ch];\n                    string += rep || ch;\n                }\n                escapeVar = false;\n            } else if ( ch === '\\\\' ) {\n                escapeVar = true;\n            } else if ( ch === quote ) {\n                this.index++;\n                this.tokens.push( {\n                    index: start,\n                    text: rawString,\n                    constant: true,\n                    value: string\n                } );\n                return;\n            } else {\n                string += ch;\n            }\n            this.index++;\n        }\n        this.throwError( 'Unterminated quote', start );\n    }\n};\n\nexport var AST = function AST( lexer, options ) {\n    this.lexer = lexer;\n    this.options = options;\n};\n\nAST.Program = 'Program';\nAST.ExpressionStatement = 'ExpressionStatement';\nAST.AssignmentExpression = 'AssignmentExpression';\nAST.ConditionalExpression = 'ConditionalExpression';\nAST.LogicalExpression = 'LogicalExpression';\nAST.BinaryExpression = 'BinaryExpression';\nAST.UnaryExpression = 'UnaryExpression';\nAST.CallExpression = 'CallExpression';\nAST.MemberExpression = 'MemberExpression';\nAST.Identifier = 'Identifier';\nAST.Literal = 'Literal';\nAST.ArrayExpression = 'ArrayExpression';\nAST.Property = 'Property';\nAST.ObjectExpression = 'ObjectExpression';\nAST.ThisExpression = 'ThisExpression';\nAST.LocalsExpression = 'LocalsExpression';\n\n// Internal use only\nAST.NGValueParameter = 'NGValueParameter';\n\nAST.prototype = {\n    ast: function( text ) {\n        this.text = text;\n        this.tokens = this.lexer.lex( text );\n\n        var value = this.program();\n\n        if ( this.tokens.length !== 0 ) {\n            this.throwError( 'is an unexpected token', this.tokens[0] );\n        }\n\n        return value;\n    },\n\n    program: function() {\n        var body = [];\n        while ( true ) {\n            if ( this.tokens.length > 0 && !this.peek( '}', ')', ';', ']' ) ) { body.push( this.expressionStatement() ); }\n            if ( !this.expect( ';' ) ) {\n                return { type: AST.Program, body: body };\n            }\n        }\n    },\n\n    expressionStatement: function() {\n        return { type: AST.ExpressionStatement, expression: this.filterChain() };\n    },\n\n    filterChain: function() {\n        var left = this.expression();\n        while ( this.expect( '|' ) ) {\n            left = this.filter( left );\n        }\n        return left;\n    },\n\n    expression: function() {\n        return this.assignment();\n    },\n\n    assignment: function() {\n        var result = this.ternary();\n        if ( this.expect( '=' ) ) {\n            if ( !isAssignable( result ) ) {\n                throw $parseMinErr( 'lval', 'Trying to assign a value to a non l-value' );\n            }\n\n            result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '=' };\n        }\n        return result;\n    },\n\n    ternary: function() {\n        var test = this.logicalOR();\n        var alternate;\n        var consequent;\n        if ( this.expect( '?' ) ) {\n            alternate = this.expression();\n            if ( this.consume( ':' ) ) {\n                consequent = this.expression();\n                return { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent };\n            }\n        }\n        return test;\n    },\n\n    logicalOR: function() {\n        var left = this.logicalAND();\n        while ( this.expect( '||' ) ) {\n            left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n        }\n        return left;\n    },\n\n    logicalAND: function() {\n        var left = this.equality();\n        while ( this.expect( '&&' ) ) {\n            left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n        }\n        return left;\n    },\n\n    equality: function() {\n        var left = this.relational();\n        var token;\n        while ( token = this.expect( '==', '!=', '===', '!==' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n        }\n        return left;\n    },\n\n    relational: function() {\n        var left = this.additive();\n        var token;\n        while ( token = this.expect( '<', '>', '<=', '>=' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n        }\n        return left;\n    },\n\n    additive: function() {\n        var left = this.multiplicative();\n        var token;\n        while ( token = this.expect( '+', '-' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n        }\n        return left;\n    },\n\n    multiplicative: function() {\n        var left = this.unary();\n        var token;\n        while ( token = this.expect( '*', '/', '%' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n        }\n        return left;\n    },\n\n    unary: function() {\n        var token;\n        if (  token = this.expect( '+', '-', '!' )  ) {\n            return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n        }\n        return this.primary();\n    },\n\n    primary: function() {\n        var primary;\n        if ( this.expect( '(' ) ) {\n            primary = this.filterChain();\n            this.consume( ')' );\n        } else if ( this.expect( '[' ) ) {\n            primary = this.arrayDeclaration();\n        } else if ( this.expect( '{' ) ) {\n            primary = this.object();\n        } else if ( this.selfReferential.hasOwnProperty( this.peek().text ) ) {\n            primary = copy( this.selfReferential[this.consume().text] );\n        } else if ( this.options.literals.hasOwnProperty( this.peek().text ) ) {\n            primary = { type: AST.Literal, value: this.options.literals[this.consume().text] };\n        } else if ( this.peek().identifier ) {\n            primary = this.identifier();\n        } else if ( this.peek().constant ) {\n            primary = this.constant();\n        } else {\n            this.throwError( 'not a primary expression', this.peek() );\n        }\n\n        var next;\n        while ( next = this.expect( '(', '[', '.' ) ) {\n            if ( next.text === '(' ) {\n                primary = { type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };\n                this.consume( ')' );\n            } else if ( next.text === '[' ) {\n                primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n                this.consume( ']' );\n            } else if ( next.text === '.' ) {\n                primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n            } else {\n                this.throwError( 'IMPOSSIBLE' );\n            }\n        }\n        return primary;\n    },\n\n    filter: function( baseExpression ) {\n        var args = [ baseExpression ];\n        var result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n        while ( this.expect( ':' ) ) {\n            args.push( this.expression() );\n        }\n\n        return result;\n    },\n\n    parseArguments: function() {\n        var args = [];\n        if ( this.peekToken().text !== ')' ) {\n            do {\n                args.push( this.filterChain() );\n            } while ( this.expect( ',' ) );\n        }\n        return args;\n    },\n\n    identifier: function() {\n        var token = this.consume();\n        if ( !token.identifier ) {\n            this.throwError( 'is not a valid identifier', token );\n        }\n        return { type: AST.Identifier, name: token.text };\n    },\n\n    constant: function() {\n    // TODO check that it is a constant\n        return { type: AST.Literal, value: this.consume().value };\n    },\n\n    arrayDeclaration: function() {\n        var elements = [];\n        if ( this.peekToken().text !== ']' ) {\n            do {\n                if ( this.peek( ']' ) ) {\n                    // Support trailing commas per ES5.1.\n                    break;\n                }\n                elements.push( this.expression() );\n            } while ( this.expect( ',' ) );\n        }\n        this.consume( ']' );\n\n        return { type: AST.ArrayExpression, elements: elements };\n    },\n\n    object: function() {\n        var properties = []; var\n            property;\n        if ( this.peekToken().text !== '}' ) {\n            do {\n                if ( this.peek( '}' ) ) {\n                    // Support trailing commas per ES5.1.\n                    break;\n                }\n                property = { type: AST.Property, kind: 'init' };\n                if ( this.peek().constant ) {\n                    property.key = this.constant();\n                    property.computed = false;\n                    this.consume( ':' );\n                    property.value = this.expression();\n                } else if ( this.peek().identifier ) {\n                    property.key = this.identifier();\n                    property.computed = false;\n                    if ( this.peek( ':' ) ) {\n                        this.consume( ':' );\n                        property.value = this.expression();\n                    } else {\n                        property.value = property.key;\n                    }\n                } else if ( this.peek( '[' ) ) {\n                    this.consume( '[' );\n                    property.key = this.expression();\n                    this.consume( ']' );\n                    property.computed = true;\n                    this.consume( ':' );\n                    property.value = this.expression();\n                } else {\n                    this.throwError( 'invalid key', this.peek() );\n                }\n                properties.push( property );\n            } while ( this.expect( ',' ) );\n        }\n        this.consume( '}' );\n\n        return { type: AST.ObjectExpression, properties: properties };\n    },\n\n    throwError: function( msg, token ) {\n        throw $parseMinErr( 'syntax',\n            'Syntax Error: Token \\'{0}\\' {1} at column {2} of the expression [{3}] starting at [{4}].',\n            token.text, msg, token.index + 1, this.text, this.text.substring( token.index ) );\n    },\n\n    consume: function( e1 ) {\n        if ( this.tokens.length === 0 ) {\n            throw $parseMinErr( 'ueoe', 'Unexpected end of expression: {0}', this.text );\n        }\n\n        var token = this.expect( e1 );\n        if ( !token ) {\n            this.throwError( 'is unexpected, expecting [' + e1 + ']', this.peek() );\n        }\n        return token;\n    },\n\n    peekToken: function() {\n        if ( this.tokens.length === 0 ) {\n            throw $parseMinErr( 'ueoe', 'Unexpected end of expression: {0}', this.text );\n        }\n        return this.tokens[0];\n    },\n\n    peek: function( e1, e2, e3, e4 ) {\n        return this.peekAhead( 0, e1, e2, e3, e4 );\n    },\n\n    peekAhead: function( i, e1, e2, e3, e4 ) {\n        if ( this.tokens.length > i ) {\n            var token = this.tokens[i];\n            var t = token.text;\n            if ( t === e1 || t === e2 || t === e3 || t === e4 ||\n          !e1 && !e2 && !e3 && !e4 ) {\n                return token;\n            }\n        }\n        return false;\n    },\n\n    expect: function( e1, e2, e3, e4 ) {\n        var token = this.peek( e1, e2, e3, e4 );\n        if ( token ) {\n            this.tokens.shift();\n            return token;\n        }\n        return false;\n    },\n\n    selfReferential: {\n        this: { type: AST.ThisExpression },\n        $locals: { type: AST.LocalsExpression }\n    }\n};\n\nfunction ifDefined( v, d ) {\n    return typeof v !== 'undefined' ? v : d;\n}\n\nfunction plusFn( l, r ) {\n    if ( typeof l === 'undefined' ) { return r; }\n    if ( typeof r === 'undefined' ) { return l; }\n    return l + r;\n}\n\nfunction isStateless( $filter, filterName ) {\n    var fn = $filter( filterName );\n    return !fn.$stateful;\n}\n\nvar PURITY_ABSOLUTE = 1;\nvar PURITY_RELATIVE = 2;\n\n// Detect nodes which could depend on non-shallow state of objects\nfunction isPure( node, parentIsPure ) {\n    switch ( node.type ) {\n    // Computed members might invoke a stateful toString()\n        case AST.MemberExpression:\n            if ( node.computed ) {\n                return false;\n            }\n            break;\n\n            // Unary always convert to primative\n        case AST.UnaryExpression:\n            return PURITY_ABSOLUTE;\n\n            // The binary + operator can invoke a stateful toString().\n        case AST.BinaryExpression:\n            return node.operator !== '+' ? PURITY_ABSOLUTE : false;\n\n            // Functions / filters probably read state from within objects\n        case AST.CallExpression:\n            return false;\n    }\n\n    return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;\n}\n\nfunction findConstantAndWatchExpressions( ast, $filter, parentIsPure ) {\n    var allConstants;\n    var argsToWatch;\n    var isStatelessFilter;\n\n    var astIsPure = ast.isPure = isPure( ast, parentIsPure );\n\n    switch ( ast.type ) {\n        case AST.Program:\n            allConstants = true;\n            forEach( ast.body, function( expr ) {\n                findConstantAndWatchExpressions( expr.expression, $filter, astIsPure );\n                allConstants = allConstants && expr.expression.constant;\n            } );\n            ast.constant = allConstants;\n            break;\n        case AST.Literal:\n            ast.constant = true;\n            ast.toWatch = [];\n            break;\n        case AST.UnaryExpression:\n            findConstantAndWatchExpressions( ast.argument, $filter, astIsPure );\n            ast.constant = ast.argument.constant;\n            ast.toWatch = ast.argument.toWatch;\n            break;\n        case AST.BinaryExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = ast.left.toWatch.concat( ast.right.toWatch );\n            break;\n        case AST.LogicalExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.ConditionalExpression:\n            findConstantAndWatchExpressions( ast.test, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.alternate, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.consequent, $filter, astIsPure );\n            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.Identifier:\n            ast.constant = false;\n            ast.toWatch = [ ast ];\n            break;\n        case AST.MemberExpression:\n            findConstantAndWatchExpressions( ast.object, $filter, astIsPure );\n            if ( ast.computed ) {\n                findConstantAndWatchExpressions( ast.property, $filter, astIsPure );\n            }\n            ast.constant = ast.object.constant && ( !ast.computed || ast.property.constant );\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.CallExpression:\n            isStatelessFilter = ast.filter ? isStateless( $filter, ast.callee.name ) : false;\n            allConstants = isStatelessFilter;\n            argsToWatch = [];\n            forEach( ast.arguments, function( expr ) {\n                findConstantAndWatchExpressions( expr, $filter, astIsPure );\n                allConstants = allConstants && expr.constant;\n                argsToWatch.push.apply( argsToWatch, expr.toWatch );\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];\n            break;\n        case AST.AssignmentExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = [ ast ];\n            break;\n        case AST.ArrayExpression:\n            allConstants = true;\n            argsToWatch = [];\n            forEach( ast.elements, function( expr ) {\n                findConstantAndWatchExpressions( expr, $filter, astIsPure );\n                allConstants = allConstants && expr.constant;\n                argsToWatch.push.apply( argsToWatch, expr.toWatch );\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = argsToWatch;\n            break;\n        case AST.ObjectExpression:\n            allConstants = true;\n            argsToWatch = [];\n            forEach( ast.properties, function( property ) {\n                findConstantAndWatchExpressions( property.value, $filter, astIsPure );\n                allConstants = allConstants && property.value.constant;\n                argsToWatch.push.apply( argsToWatch, property.value.toWatch );\n                if ( property.computed ) {\n                    //`{[key]: value}` implicitly does `key.toString()` which may be non-pure\n                    findConstantAndWatchExpressions( property.key, $filter, /*parentIsPure=*/false );\n                    allConstants = allConstants && property.key.constant;\n                    argsToWatch.push.apply( argsToWatch, property.key.toWatch );\n                }\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = argsToWatch;\n            break;\n        case AST.ThisExpression:\n            ast.constant = false;\n            ast.toWatch = [];\n            break;\n        case AST.LocalsExpression:\n            ast.constant = false;\n            ast.toWatch = [];\n            break;\n    }\n}\n\nfunction getInputs( body ) {\n    if ( body.length !== 1 ) { return; }\n    var lastExpression = body[0].expression;\n    var candidate = lastExpression.toWatch;\n    if ( candidate.length !== 1 ) { return candidate; }\n    return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable( ast ) {\n    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST( ast ) {\n    if ( ast.body.length === 1 && isAssignable( ast.body[0].expression ) ) {\n        return { type: AST.AssignmentExpression, left: ast.body[0].expression, right: { type: AST.NGValueParameter }, operator: '=' };\n    }\n}\n\nfunction isLiteral( ast ) {\n    return ast.body.length === 0 ||\n      ast.body.length === 1 && (\n          ast.body[0].expression.type === AST.Literal ||\n      ast.body[0].expression.type === AST.ArrayExpression ||\n      ast.body[0].expression.type === AST.ObjectExpression );\n}\n\nfunction isConstant( ast ) {\n    return ast.constant;\n}\n\nexport function ASTCompiler( $filter ) {\n    this.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n    compile: function( ast ) {\n        var self = this;\n        this.state = {\n            nextId: 0,\n            filters: {},\n            fn: { vars: [], body: [], own: {} },\n            assign: { vars: [], body: [], own: {} },\n            inputs: []\n        };\n        findConstantAndWatchExpressions( ast, self.$filter );\n        var extra = '';\n        var assignable;\n        this.stage = 'assign';\n        if ( assignable = assignableAST( ast ) ) {\n            this.state.computing = 'assign';\n            var result = this.nextId();\n            this.recurse( assignable, result );\n            this.return_( result );\n            extra = 'fn.assign=' + this.generateFunction( 'assign', 's,v,l' );\n        }\n        var toWatch = getInputs( ast.body );\n        self.stage = 'inputs';\n        forEach( toWatch, function( watch, key ) {\n            var fnKey = 'fn' + key;\n            self.state[fnKey] = { vars: [], body: [], own: {} };\n            self.state.computing = fnKey;\n            var intoId = self.nextId();\n            self.recurse( watch, intoId );\n            self.return_( intoId );\n            self.state.inputs.push( { name: fnKey, isPure: watch.isPure } );\n            watch.watchId = key;\n        } );\n        this.state.computing = 'fn';\n        this.stage = 'main';\n        this.recurse( ast );\n        var fnString =\n      // The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n      // This is a workaround for this until we do a better job at only removing the prefix only when we should.\n      '\"' + this.USE + ' ' + this.STRICT + '\";\\n' +\n      this.filterPrefix() +\n      'var fn=' + this.generateFunction( 'fn', 's,l,a,i' ) +\n      extra +\n      this.watchFns() +\n      'return fn;';\n\n        // eslint-disable-next-line no-new-func\n        var fn = new Function( '$filter',\n            'getStringValue',\n            'ifDefined',\n            'plus',\n            fnString )(\n            this.$filter,\n            getStringValue,\n            ifDefined,\n            plusFn );\n        this.state = this.stage = undefined;\n        return fn;\n    },\n\n    USE: 'use',\n\n    STRICT: 'strict',\n\n    watchFns: function() {\n        var result = [];\n        var inputs = this.state.inputs;\n        var self = this;\n        forEach( inputs, function( input ) {\n            result.push( 'var ' + input.name + '=' + self.generateFunction( input.name, 's' ) );\n            if ( input.isPure ) {\n                result.push( input.name, '.isPure=' + JSON.stringify( input.isPure ) + ';' );\n            }\n        } );\n        if ( inputs.length ) {\n            result.push( 'fn.inputs=[' + inputs.map( function( i ) { return i.name; } ).join( ',' ) + '];' );\n        }\n        return result.join( '' );\n    },\n\n    generateFunction: function( name, params ) {\n        return 'function(' + params + '){' +\n        this.varsPrefix( name ) +\n        this.body( name ) +\n        '};';\n    },\n\n    filterPrefix: function() {\n        var parts = [];\n        var self = this;\n        forEach( this.state.filters, function( id, filter ) {\n            parts.push( id + '=$filter(' + self.escape( filter ) + ')' );\n        } );\n        if ( parts.length ) { return 'var ' + parts.join( ',' ) + ';'; }\n        return '';\n    },\n\n    varsPrefix: function( section ) {\n        return this.state[section].vars.length ? 'var ' + this.state[section].vars.join( ',' ) + ';' : '';\n    },\n\n    body: function( section ) {\n        return this.state[section].body.join( '' );\n    },\n\n    recurse: function( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck ) {\n        var left; var right; var self = this; var args; var expression; var computed;\n        recursionFn = recursionFn || noop;\n        if ( !skipWatchIdCheck && isDefined( ast.watchId ) ) {\n            intoId = intoId || this.nextId();\n            this.if_( 'i',\n                this.lazyAssign( intoId, this.computedMember( 'i', ast.watchId ) ),\n                this.lazyRecurse( ast, intoId, nameId, recursionFn, create, true )\n            );\n            return;\n        }\n        switch ( ast.type ) {\n            case AST.Program:\n                forEach( ast.body, function( expression, pos ) {\n                    self.recurse( expression.expression, undefined, undefined, function( expr ) { right = expr; } );\n                    if ( pos !== ast.body.length - 1 ) {\n                        self.current().body.push( right, ';' );\n                    } else {\n                        self.return_( right );\n                    }\n                } );\n                break;\n            case AST.Literal:\n                expression = this.escape( ast.value );\n                this.assign( intoId, expression );\n                recursionFn( intoId || expression );\n                break;\n            case AST.UnaryExpression:\n                this.recurse( ast.argument, undefined, undefined, function( expr ) { right = expr; } );\n                expression = ast.operator + '(' + this.ifDefined( right, 0 ) + ')';\n                this.assign( intoId, expression );\n                recursionFn( expression );\n                break;\n            case AST.BinaryExpression:\n                this.recurse( ast.left, undefined, undefined, function( expr ) { left = expr; } );\n                this.recurse( ast.right, undefined, undefined, function( expr ) { right = expr; } );\n                if ( ast.operator === '+' ) {\n                    expression = this.plus( left, right );\n                } else if ( ast.operator === '-' ) {\n                    expression = this.ifDefined( left, 0 ) + ast.operator + this.ifDefined( right, 0 );\n                } else {\n                    expression = '(' + left + ')' + ast.operator + '(' + right + ')';\n                }\n                this.assign( intoId, expression );\n                recursionFn( expression );\n                break;\n            case AST.LogicalExpression:\n                intoId = intoId || this.nextId();\n                self.recurse( ast.left, intoId );\n                self.if_( ast.operator === '&&' ? intoId : self.not( intoId ), self.lazyRecurse( ast.right, intoId ) );\n                recursionFn( intoId );\n                break;\n            case AST.ConditionalExpression:\n                intoId = intoId || this.nextId();\n                self.recurse( ast.test, intoId );\n                self.if_( intoId, self.lazyRecurse( ast.alternate, intoId ), self.lazyRecurse( ast.consequent, intoId ) );\n                recursionFn( intoId );\n                break;\n            case AST.Identifier:\n                intoId = intoId || this.nextId();\n                if ( nameId ) {\n                    nameId.context = self.stage === 'inputs' ? 's' : this.assign( this.nextId(), this.getHasOwnProperty( 'l', ast.name ) + '?l:s' );\n                    nameId.computed = false;\n                    nameId.name = ast.name;\n                }\n                self.if_( self.stage === 'inputs' || self.not( self.getHasOwnProperty( 'l', ast.name ) ),\n                    function() {\n                        self.if_( self.stage === 'inputs' || 's', function() {\n                            if ( create && create !== 1 ) {\n                                self.if_(\n                                    self.isNull( self.nonComputedMember( 's', ast.name ) ),\n                                    self.lazyAssign( self.nonComputedMember( 's', ast.name ), '{}' ) );\n                            }\n                            self.assign( intoId, self.nonComputedMember( 's', ast.name ) );\n                        } );\n                    }, intoId && self.lazyAssign( intoId, self.nonComputedMember( 'l', ast.name ) )\n                );\n                recursionFn( intoId );\n                break;\n            case AST.MemberExpression:\n                left = nameId && ( nameId.context = this.nextId() ) || this.nextId();\n                intoId = intoId || this.nextId();\n                self.recurse( ast.object, left, undefined, function() {\n                    self.if_( self.notNull( left ), function() {\n                        if ( ast.computed ) {\n                            right = self.nextId();\n                            self.recurse( ast.property, right );\n                            self.getStringValue( right );\n                            if ( create && create !== 1 ) {\n                                self.if_( self.not( self.computedMember( left, right ) ), self.lazyAssign( self.computedMember( left, right ), '{}' ) );\n                            }\n                            expression = self.computedMember( left, right );\n                            self.assign( intoId, expression );\n                            if ( nameId ) {\n                                nameId.computed = true;\n                                nameId.name = right;\n                            }\n                        } else {\n                            if ( create && create !== 1 ) {\n                                self.if_( self.isNull( self.nonComputedMember( left, ast.property.name ) ), self.lazyAssign( self.nonComputedMember( left, ast.property.name ), '{}' ) );\n                            }\n                            expression = self.nonComputedMember( left, ast.property.name );\n                            self.assign( intoId, expression );\n                            if ( nameId ) {\n                                nameId.computed = false;\n                                nameId.name = ast.property.name;\n                            }\n                        }\n                    }, function() {\n                        self.assign( intoId, 'undefined' );\n                    } );\n                    recursionFn( intoId );\n                }, Boolean( create ) );\n                break;\n            case AST.CallExpression:\n                intoId = intoId || this.nextId();\n                if ( ast.filter ) {\n                    right = self.filter( ast.callee.name );\n                    args = [];\n                    forEach( ast.arguments, function( expr ) {\n                        var argument = self.nextId();\n                        self.recurse( expr, argument );\n                        args.push( argument );\n                    } );\n                    expression = right + '(' + args.join( ',' ) + ')';\n                    self.assign( intoId, expression );\n                    recursionFn( intoId );\n                } else {\n                    right = self.nextId();\n                    left = {};\n                    args = [];\n                    self.recurse( ast.callee, right, left, function() {\n                        self.if_( self.notNull( right ), function() {\n                            forEach( ast.arguments, function( expr ) {\n                                self.recurse( expr, ast.constant ? undefined : self.nextId(), undefined, function( argument ) {\n                                    args.push( argument );\n                                } );\n                            } );\n                            if ( left.name ) {\n                                expression = self.member( left.context, left.name, left.computed ) + '(' + args.join( ',' ) + ')';\n                            } else {\n                                expression = right + '(' + args.join( ',' ) + ')';\n                            }\n                            self.assign( intoId, expression );\n                        }, function() {\n                            self.assign( intoId, 'undefined' );\n                        } );\n                        recursionFn( intoId );\n                    } );\n                }\n                break;\n            case AST.AssignmentExpression:\n                right = this.nextId();\n                left = {};\n                this.recurse( ast.left, undefined, left, function() {\n                    self.if_( self.notNull( left.context ), function() {\n                        self.recurse( ast.right, right );\n                        expression = self.member( left.context, left.name, left.computed ) + ast.operator + right;\n                        self.assign( intoId, expression );\n                        recursionFn( intoId || expression );\n                    } );\n                }, 1 );\n                break;\n            case AST.ArrayExpression:\n                args = [];\n                forEach( ast.elements, function( expr ) {\n                    self.recurse( expr, ast.constant ? undefined : self.nextId(), undefined, function( argument ) {\n                        args.push( argument );\n                    } );\n                } );\n                expression = '[' + args.join( ',' ) + ']';\n                this.assign( intoId, expression );\n                recursionFn( intoId || expression );\n                break;\n            case AST.ObjectExpression:\n                args = [];\n                computed = false;\n                forEach( ast.properties, function( property ) {\n                    if ( property.computed ) {\n                        computed = true;\n                    }\n                } );\n                if ( computed ) {\n                    intoId = intoId || this.nextId();\n                    this.assign( intoId, '{}' );\n                    forEach( ast.properties, function( property ) {\n                        if ( property.computed ) {\n                            left = self.nextId();\n                            self.recurse( property.key, left );\n                        } else {\n                            left = property.key.type === AST.Identifier ?\n                                property.key.name :\n                                String( property.key.value );\n                        }\n                        right = self.nextId();\n                        self.recurse( property.value, right );\n                        self.assign( self.member( intoId, left, property.computed ), right );\n                    } );\n                } else {\n                    forEach( ast.properties, function( property ) {\n                        self.recurse( property.value, ast.constant ? undefined : self.nextId(), undefined, function( expr ) {\n                            args.push( self.escape(\n                                property.key.type === AST.Identifier ? property.key.name :\n                                    String( property.key.value ) ) +\n                ':' + expr );\n                        } );\n                    } );\n                    expression = '{' + args.join( ',' ) + '}';\n                    this.assign( intoId, expression );\n                }\n                recursionFn( intoId || expression );\n                break;\n            case AST.ThisExpression:\n                this.assign( intoId, 's' );\n                recursionFn( intoId || 's' );\n                break;\n            case AST.LocalsExpression:\n                this.assign( intoId, 'l' );\n                recursionFn( intoId || 'l' );\n                break;\n            case AST.NGValueParameter:\n                this.assign( intoId, 'v' );\n                recursionFn( intoId || 'v' );\n                break;\n        }\n    },\n\n    getHasOwnProperty: function( element, property ) {\n        var key = element + '.' + property;\n        var own = this.current().own;\n        if ( !own.hasOwnProperty( key ) ) {\n            own[key] = this.nextId( false, element + '&&(' + this.escape( property ) + ' in ' + element + ')' );\n        }\n        return own[key];\n    },\n\n    assign: function( id, value ) {\n        if ( !id ) { return; }\n        this.current().body.push( id, '=', value, ';' );\n        return id;\n    },\n\n    filter: function( filterName ) {\n        if ( !this.state.filters.hasOwnProperty( filterName ) ) {\n            this.state.filters[filterName] = this.nextId( true );\n        }\n        return this.state.filters[filterName];\n    },\n\n    ifDefined: function( id, defaultValue ) {\n        return 'ifDefined(' + id + ',' + this.escape( defaultValue ) + ')';\n    },\n\n    plus: function( left, right ) {\n        return 'plus(' + left + ',' + right + ')';\n    },\n\n    return_: function( id ) {\n        this.current().body.push( 'return ', id, ';' );\n    },\n\n    if_: function( test, alternate, consequent ) {\n        if ( test === true ) {\n            alternate();\n        } else {\n            var body = this.current().body;\n            body.push( 'if(', test, '){' );\n            alternate();\n            body.push( '}' );\n            if ( consequent ) {\n                body.push( 'else{' );\n                consequent();\n                body.push( '}' );\n            }\n        }\n    },\n\n    not: function( expression ) {\n        return '!(' + expression + ')';\n    },\n\n    isNull: function( expression ) {\n        return expression + '==null';\n    },\n\n    notNull: function( expression ) {\n        return expression + '!=null';\n    },\n\n    nonComputedMember: function( left, right ) {\n        var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n        var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n        if ( SAFE_IDENTIFIER.test( right ) ) {\n            return left + '.' + right;\n        }\n        return left  + '[\"' + right.replace( UNSAFE_CHARACTERS, this.stringEscapeFn ) + '\"]';\n    },\n\n    computedMember: function( left, right ) {\n        return left + '[' + right + ']';\n    },\n\n    member: function( left, right, computed ) {\n        if ( computed ) { return this.computedMember( left, right ); }\n        return this.nonComputedMember( left, right );\n    },\n\n    getStringValue: function( item ) {\n        this.assign( item, 'getStringValue(' + item + ')' );\n    },\n\n    lazyRecurse: function( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck ) {\n        var self = this;\n        return function() {\n            self.recurse( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck );\n        };\n    },\n\n    lazyAssign: function( id, value ) {\n        var self = this;\n        return function() {\n            self.assign( id, value );\n        };\n    },\n\n    stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n    stringEscapeFn: function( c ) {\n        return '\\\\u' + ( '0000' + c.charCodeAt( 0 ).toString( 16 ) ).slice( -4 );\n    },\n\n    escape: function( value ) {\n        if ( isString( value ) ) { return '\\'' + value.replace( this.stringEscapeRegex, this.stringEscapeFn ) + '\\''; }\n        if ( isNumber( value ) ) { return value.toString(); }\n        if ( value === true ) { return 'true'; }\n        if ( value === false ) { return 'false'; }\n        if ( value === null ) { return 'null'; }\n        if ( typeof value === 'undefined' ) { return 'undefined'; }\n\n        throw $parseMinErr( 'esc', 'IMPOSSIBLE' );\n    },\n\n    nextId: function( skip, init ) {\n        var id = 'v' + this.state.nextId++;\n        if ( !skip ) {\n            this.current().vars.push( id + ( init ? '=' + init : '' ) );\n        }\n        return id;\n    },\n\n    current: function() {\n        return this.state[this.state.computing];\n    }\n};\n\n\nexport function ASTInterpreter( $filter ) {\n    this.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n    compile: function( ast ) {\n        var self = this;\n        findConstantAndWatchExpressions( ast, self.$filter );\n        var assignable;\n        var assign;\n        if ( assignable = assignableAST( ast ) ) {\n            assign = this.recurse( assignable );\n        }\n        var toWatch = getInputs( ast.body );\n        var inputs;\n        if ( toWatch ) {\n            inputs = [];\n            forEach( toWatch, function( watch, key ) {\n                var input = self.recurse( watch );\n                input.isPure = watch.isPure;\n                watch.input = input;\n                inputs.push( input );\n                watch.watchId = key;\n            } );\n        }\n        var expressions = [];\n        forEach( ast.body, function( expression ) {\n            expressions.push( self.recurse( expression.expression ) );\n        } );\n        var fn = ast.body.length === 0 ? noop :\n            ast.body.length === 1 ? expressions[0] :\n                function( scope, locals ) {\n                    var lastValue;\n                    forEach( expressions, function( exp ) {\n                        lastValue = exp( scope, locals );\n                    } );\n                    return lastValue;\n                };\n        if ( assign ) {\n            fn.assign = function( scope, value, locals ) {\n                return assign( scope, locals, value );\n            };\n        }\n        if ( inputs ) {\n            fn.inputs = inputs;\n        }\n        return fn;\n    },\n\n    recurse: function( ast, context, create ) {\n        var left; var right; var self = this; var\n            args;\n        if ( ast.input ) {\n            return this.inputs( ast.input, ast.watchId );\n        }\n        switch ( ast.type ) {\n            case AST.Literal:\n                return this.value( ast.value, context );\n            case AST.UnaryExpression:\n                right = this.recurse( ast.argument );\n                return this['unary' + ast.operator]( right, context );\n            case AST.BinaryExpression:\n                left = this.recurse( ast.left );\n                right = this.recurse( ast.right );\n                return this['binary' + ast.operator]( left, right, context );\n            case AST.LogicalExpression:\n                left = this.recurse( ast.left );\n                right = this.recurse( ast.right );\n                return this['binary' + ast.operator]( left, right, context );\n            case AST.ConditionalExpression:\n                return this['ternary?:'](\n                    this.recurse( ast.test ),\n                    this.recurse( ast.alternate ),\n                    this.recurse( ast.consequent ),\n                    context\n                );\n            case AST.Identifier:\n                return self.identifier( ast.name, context, create );\n            case AST.MemberExpression:\n                left = this.recurse( ast.object, false, Boolean( create ) );\n                if ( !ast.computed ) {\n                    right = ast.property.name;\n                }\n                if ( ast.computed ) { right = this.recurse( ast.property ); }\n                return ast.computed ?\n                    this.computedMember( left, right, context, create ) :\n                    this.nonComputedMember( left, right, context, create );\n            case AST.CallExpression:\n                args = [];\n                forEach( ast.arguments, function( expr ) {\n                    args.push( self.recurse( expr ) );\n                } );\n                if ( ast.filter ) { right = this.$filter( ast.callee.name ); }\n                if ( !ast.filter ) { right = this.recurse( ast.callee, true ); }\n                return ast.filter ?\n                    function( scope, locals, assign, inputs ) {\n                        var values = [];\n                        for ( var i = 0; i < args.length; ++i ) {\n                            values.push( args[i]( scope, locals, assign, inputs ) );\n                        }\n                        var value = right.apply( undefined, values, inputs );\n                        return context ? { context: undefined, name: undefined, value: value } : value;\n                    } :\n                    function( scope, locals, assign, inputs ) {\n                        var rhs = right( scope, locals, assign, inputs );\n                        var value;\n                        if ( rhs.value != null ) {\n                            var values = [];\n                            for ( var i = 0; i < args.length; ++i ) {\n                                values.push( args[i]( scope, locals, assign, inputs ) );\n                            }\n                            value = rhs.value.apply( rhs.context, values );\n                        }\n                        return context ? { value: value } : value;\n                    };\n            case AST.AssignmentExpression:\n                left = this.recurse( ast.left, true, 1 );\n                right = this.recurse( ast.right );\n                return function( scope, locals, assign, inputs ) {\n                    var lhs = left( scope, locals, assign, inputs );\n                    var rhs = right( scope, locals, assign, inputs );\n                    lhs.context[lhs.name] = rhs;\n                    return context ? { value: rhs } : rhs;\n                };\n            case AST.ArrayExpression:\n                args = [];\n                forEach( ast.elements, function( expr ) {\n                    args.push( self.recurse( expr ) );\n                } );\n                return function( scope, locals, assign, inputs ) {\n                    var value = [];\n                    for ( var i = 0; i < args.length; ++i ) {\n                        value.push( args[i]( scope, locals, assign, inputs ) );\n                    }\n                    return context ? { value: value } : value;\n                };\n            case AST.ObjectExpression:\n                args = [];\n                forEach( ast.properties, function( property ) {\n                    if ( property.computed ) {\n                        args.push( { key: self.recurse( property.key ),\n                            computed: true,\n                            value: self.recurse( property.value )\n                        } );\n                    } else {\n                        args.push( { key: property.key.type === AST.Identifier ?\n                            property.key.name :\n                            String( property.key.value ),\n                        computed: false,\n                        value: self.recurse( property.value )\n                        } );\n                    }\n                } );\n                return function( scope, locals, assign, inputs ) {\n                    var value = {};\n                    for ( var i = 0; i < args.length; ++i ) {\n                        if ( args[i].computed ) {\n                            value[args[i].key( scope, locals, assign, inputs )] = args[i].value( scope, locals, assign, inputs );\n                        } else {\n                            value[args[i].key] = args[i].value( scope, locals, assign, inputs );\n                        }\n                    }\n                    return context ? { value: value } : value;\n                };\n            case AST.ThisExpression:\n                return function( scope ) {\n                    return context ? { value: scope } : scope;\n                };\n            case AST.LocalsExpression:\n                return function( scope, locals ) {\n                    return context ? { value: locals } : locals;\n                };\n            case AST.NGValueParameter:\n                return function( scope, locals, assign ) {\n                    return context ? { value: assign } : assign;\n                };\n        }\n    },\n\n    'unary+': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = argument( scope, locals, assign, inputs );\n            if ( isDefined( arg ) ) {\n                arg = Number( arg );\n            } else {\n                arg = 0;\n            }\n            return context ? { value: arg } : arg;\n        };\n    },\n    'unary-': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = argument( scope, locals, assign, inputs );\n            if ( isDefined( arg ) ) {\n                arg = -arg;\n            } else {\n                arg = -0;\n            }\n            return context ? { value: arg } : arg;\n        };\n    },\n    'unary!': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = !argument( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary+': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs = right( scope, locals, assign, inputs );\n            var arg = plusFn( lhs, rhs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary-': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs = right( scope, locals, assign, inputs );\n            var arg = ( isDefined( lhs ) ? lhs : 0 ) - ( isDefined( rhs ) ? rhs : 0 );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary*': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) * right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary/': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) / right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary%': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) % right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary===': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) === right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary!==': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) !== right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary==': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            // eslint-disable-next-line eqeqeq\n            var arg = left( scope, locals, assign, inputs ) == right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary!=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            // eslint-disable-next-line eqeqeq\n            var arg = left( scope, locals, assign, inputs ) != right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary<': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) < right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary>': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) > right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary<=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) <= right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary>=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) >= right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary&&': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) && right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary||': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) || right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'ternary?:': function( test, alternate, consequent, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = test( scope, locals, assign, inputs ) ? alternate( scope, locals, assign, inputs ) : consequent( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    value: function( value, context ) {\n        return function() { return context ? { context: undefined, name: undefined, value: value } : value; };\n    },\n    identifier: function( name, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var base = locals && name in locals ? locals : scope;\n            if ( create && create !== 1 && base && base[name] == null ) {\n                base[name] = {};\n            }\n            var value = base ? base[name] : undefined;\n            if ( context ) {\n                return { context: base, name: name, value: value };\n            }\n            return value;\n        };\n    },\n    computedMember: function( left, right, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs;\n            var value;\n            if ( lhs != null ) {\n                rhs = right( scope, locals, assign, inputs );\n                rhs = getStringValue( rhs );\n                if ( create && create !== 1 ) {\n                    if ( lhs && !lhs[rhs] ) {\n                        lhs[rhs] = {};\n                    }\n                }\n                value = lhs[rhs];\n            }\n            if ( context ) {\n                return { context: lhs, name: rhs, value: value };\n            }\n            return value;\n        };\n    },\n    nonComputedMember: function( left, right, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            if ( create && create !== 1 ) {\n                if ( lhs && lhs[right] == null ) {\n                    lhs[right] = {};\n                }\n            }\n            var value = lhs != null ? lhs[right] : undefined;\n            if ( context ) {\n                return { context: lhs, name: right, value: value };\n            }\n            return value;\n        };\n    },\n    inputs: function( input, watchId ) {\n        return function( scope, value, locals, inputs ) {\n            if ( inputs ) { return inputs[watchId]; }\n            return input( scope, value, locals );\n        };\n    }\n};\n\n/**\n * @constructor\n */\nexport function Parser( lexer, $filter, options ) {\n    this.ast = new AST( lexer, options );\n    this.astCompiler = options.csp ? new ASTInterpreter( $filter ) :\n        new ASTCompiler( $filter );\n}\n\nParser.prototype = {\n    constructor: Parser,\n\n    parse: function( text ) {\n        var ast = this.getAst( text );\n        var fn = this.astCompiler.compile( ast.ast );\n        fn.literal = isLiteral( ast.ast );\n        fn.constant = isConstant( ast.ast );\n        fn.oneTime = ast.oneTime;\n        return fn;\n    },\n\n    getAst: function( exp ) {\n        var oneTime = false;\n        exp = exp.trim();\n\n        if ( exp.charAt( 0 ) === ':' && exp.charAt( 1 ) === ':' ) {\n            oneTime = true;\n            exp = exp.substring( 2 );\n        }\n        return {\n            ast: this.ast.ast( exp ),\n            oneTime: oneTime\n        };\n    }\n};\n\nfunction getValueOf( value ) {\n    return isFunction( value.valueOf ) ? value.valueOf() : objectValueOf.call( value );\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts AngularJS {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'AngularJS'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('AngularJS');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context`  `{object}`  an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals`  `{object=}`  local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\nexport function $ParseProvider() {\n    var cache = createMap();\n    var literals = {\n        true: true,\n        false: false,\n        null: null,\n        undefined: undefined\n    };\n    var identStart; var identContinue;\n\n    /**\n   * @ngdoc method\n   * @name $parseProvider#addLiteral\n   * @description\n   *\n   * Configure $parse service to add literal values that will be present as literal at expressions.\n   *\n   * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n   * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n   *\n   **/\n    this.addLiteral = function( literalName, literalValue ) {\n        literals[literalName] = literalValue;\n    };\n\n    /**\n  * @ngdoc method\n  * @name $parseProvider#setIdentifierFns\n  *\n  * @description\n  *\n  * Allows defining the set of characters that are allowed in AngularJS expressions. The function\n  * `identifierStart` will get called to know if a given character is a valid character to be the\n  * first character for an identifier. The function `identifierContinue` will get called to know if\n  * a given character is a valid character to be a follow-up identifier character. The functions\n  * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n  * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n  * mind that the `string` parameter can be two characters long depending on the character\n  * representation. It is expected for the function to return `true` or `false`, whether that\n  * character is allowed or not.\n  *\n  * Since this function will be called extensively, keep the implementation of these functions fast,\n  * as the performance of these functions have a direct impact on the expressions parsing speed.\n  *\n  * @param {function=} identifierStart The function that will decide whether the given character is\n  *   a valid identifier start character.\n  * @param {function=} identifierContinue The function that will decide whether the given character is\n  *   a valid identifier continue character.\n  */\n    this.setIdentifierFns = function( identifierStart, identifierContinue ) {\n        identStart = identifierStart;\n        identContinue = identifierContinue;\n        return this;\n    };\n\n    this.$get = [ '$filter', function( $filter ) {\n        var noUnsafeEval = false; //csp().noUnsafeEval;\n        var $parseOptions = {\n            csp: noUnsafeEval,\n            literals: copy( literals ),\n            isIdentifierStart: isFunction( identStart ) && identStart,\n            isIdentifierContinue: isFunction( identContinue ) && identContinue\n        };\n        $parse.$$getAst = $$getAst;\n        return $parse;\n\n        function $parse( exp, interceptorFn ) {\n            var parsedExpression; var cacheKey;\n\n            switch ( typeof exp ) {\n                case 'string':\n                    exp = exp.trim();\n                    cacheKey = exp;\n\n                    parsedExpression = cache[cacheKey];\n\n                    if ( !parsedExpression ) {\n                        var lexer = new Lexer( $parseOptions );\n                        var parser = new Parser( lexer, $filter, $parseOptions );\n                        parsedExpression = parser.parse( exp );\n\n                        cache[cacheKey] = addWatchDelegate( parsedExpression );\n                    }\n                    return addInterceptor( parsedExpression, interceptorFn );\n\n                case 'function':\n                    return addInterceptor( exp, interceptorFn );\n\n                default:\n                    return addInterceptor( noop, interceptorFn );\n            }\n        }\n\n        function $$getAst( exp ) {\n            var lexer = new Lexer( $parseOptions );\n            var parser = new Parser( lexer, $filter, $parseOptions );\n            return parser.getAst( exp ).ast;\n        }\n\n        function expressionInputDirtyCheck( newValue, oldValueOfValue, compareObjectIdentity ) {\n            if ( newValue == null || oldValueOfValue == null ) { // null/undefined\n                return newValue === oldValueOfValue;\n            }\n\n            if ( typeof newValue === 'object' ) {\n                // attempt to convert the value to a primitive type\n                // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n                //             be cheaply dirty-checked\n                newValue = getValueOf( newValue );\n\n                if ( typeof newValue === 'object' && !compareObjectIdentity ) {\n                    // objects/arrays are not supported - deep-watching them would be too expensive\n                    return false;\n                }\n\n                // fall-through to the primitive equality check\n            }\n\n            //Primitive or NaN\n            // eslint-disable-next-line no-self-compare\n            return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;\n        }\n\n        function inputsWatchDelegate( scope, listener, objectEquality, parsedExpression, prettyPrintExpression ) {\n            var inputExpressions = parsedExpression.inputs;\n            var lastResult;\n\n            if ( inputExpressions.length === 1 ) {\n                var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n                inputExpressions = inputExpressions[0];\n                return scope.$watch( function expressionInputWatch( scope ) {\n                    var newInputValue = inputExpressions( scope );\n                    if ( !expressionInputDirtyCheck( newInputValue, oldInputValueOf, inputExpressions.isPure ) ) {\n                        lastResult = parsedExpression( scope, undefined, undefined, [ newInputValue ] );\n                        oldInputValueOf = newInputValue && getValueOf( newInputValue );\n                    }\n                    return lastResult;\n                }, listener, objectEquality, prettyPrintExpression );\n            }\n\n            var oldInputValueOfValues = [];\n            var oldInputValues = [];\n            for ( var i = 0, ii = inputExpressions.length; i < ii; i++ ) {\n                oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n                oldInputValues[i] = null;\n            }\n\n            return scope.$watch( function expressionInputsWatch( scope ) {\n                var changed = false;\n\n                for ( var i = 0, ii = inputExpressions.length; i < ii; i++ ) {\n                    var newInputValue = inputExpressions[i]( scope );\n                    if ( changed || ( changed = !expressionInputDirtyCheck( newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure ) ) ) {\n                        oldInputValues[i] = newInputValue;\n                        oldInputValueOfValues[i] = newInputValue && getValueOf( newInputValue );\n                    }\n                }\n\n                if ( changed ) {\n                    lastResult = parsedExpression( scope, undefined, undefined, oldInputValues );\n                }\n\n                return lastResult;\n            }, listener, objectEquality, prettyPrintExpression );\n        }\n\n        function oneTimeWatchDelegate( scope, listener, objectEquality, parsedExpression, prettyPrintExpression ) {\n            var isDone = parsedExpression.literal ? isAllDefined : isDefined;\n            var unwatch; var lastValue;\n\n            var exp = parsedExpression.$$intercepted || parsedExpression;\n            var post = parsedExpression.$$interceptor || identity;\n\n            var useInputs = parsedExpression.inputs && !exp.inputs;\n\n            // Propagate the literal/inputs/constant attributes\n            // ... but not oneTime since we are handling it\n            oneTimeWatch.literal = parsedExpression.literal;\n            oneTimeWatch.constant = parsedExpression.constant;\n            oneTimeWatch.inputs = parsedExpression.inputs;\n\n            // Allow other delegates to run on this wrapped expression\n            addWatchDelegate( oneTimeWatch );\n\n            unwatch = scope.$watch( oneTimeWatch, listener, objectEquality, prettyPrintExpression );\n\n            return unwatch;\n\n            function unwatchIfDone() {\n                if ( isDone( lastValue ) ) {\n                    unwatch();\n                }\n            }\n\n            function oneTimeWatch( scope, locals, assign, inputs ) {\n                lastValue = useInputs && inputs ? inputs[0] : exp( scope, locals, assign, inputs );\n                if ( isDone( lastValue ) ) {\n                    scope.$$postDigest( unwatchIfDone );\n                }\n                return post( lastValue );\n            }\n        }\n\n        function isAllDefined( value ) {\n            var allDefined = true;\n            forEach( value, function( val ) {\n                if ( !isDefined( val ) ) { allDefined = false; }\n            } );\n            return allDefined;\n        }\n\n        function constantWatchDelegate( scope, listener, objectEquality, parsedExpression ) {\n            var unwatch = scope.$watch( function constantWatch( scope ) {\n                unwatch();\n                return parsedExpression( scope );\n            }, listener, objectEquality );\n            return unwatch;\n        }\n\n        function addWatchDelegate( parsedExpression ) {\n            if ( parsedExpression.constant ) {\n                parsedExpression.$$watchDelegate = constantWatchDelegate;\n            } else if ( parsedExpression.oneTime ) {\n                parsedExpression.$$watchDelegate = oneTimeWatchDelegate;\n            } else if ( parsedExpression.inputs ) {\n                parsedExpression.$$watchDelegate = inputsWatchDelegate;\n            }\n\n            return parsedExpression;\n        }\n\n        function chainInterceptors( first, second ) {\n            function chainedInterceptor( value ) {\n                return second( first( value ) );\n            }\n            chainedInterceptor.$stateful = first.$stateful || second.$stateful;\n            chainedInterceptor.$$pure = first.$$pure && second.$$pure;\n\n            return chainedInterceptor;\n        }\n\n        function addInterceptor( parsedExpression, interceptorFn ) {\n            if ( !interceptorFn ) { return parsedExpression; }\n\n            // Extract any existing interceptors out of the parsedExpression\n            // to ensure the original parsedExpression is always the $$intercepted\n            if ( parsedExpression.$$interceptor ) {\n                interceptorFn = chainInterceptors( parsedExpression.$$interceptor, interceptorFn );\n                parsedExpression = parsedExpression.$$intercepted;\n            }\n\n            var useInputs = false;\n\n            var fn = function interceptedExpression( scope, locals, assign, inputs ) {\n                var value = useInputs && inputs ? inputs[0] : parsedExpression( scope, locals, assign, inputs );\n                return interceptorFn( value );\n            };\n\n            // Maintain references to the interceptor/intercepted\n            fn.$$intercepted = parsedExpression;\n            fn.$$interceptor = interceptorFn;\n\n            // Propagate the literal/oneTime/constant attributes\n            fn.literal = parsedExpression.literal;\n            fn.oneTime = parsedExpression.oneTime;\n            fn.constant = parsedExpression.constant;\n\n            // Treat the interceptor like filters.\n            // If it is not $stateful then only watch its inputs.\n            // If the expression itself has no inputs then use the full expression as an input.\n            if ( !interceptorFn.$stateful ) {\n                useInputs = !parsedExpression.inputs;\n                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];\n\n                if ( !interceptorFn.$$pure ) {\n                    fn.inputs = fn.inputs.map( function( e ) {\n                        // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a\n                        // non-pure interceptor function.\n                        if ( e.isPure === PURITY_RELATIVE ) {\n                            return function depurifier( s ) { return e( s ); };\n                        }\n                        return e;\n                    } );\n                }\n            }\n\n            return addWatchDelegate( fn );\n        }\n    } ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}