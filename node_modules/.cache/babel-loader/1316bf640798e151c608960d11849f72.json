{"ast":null,"code":"/* eslint-disable jsx-a11y/no-noninteractive-element-to-interactive-role */ // Copyright (c) 2020 Siemens\nimport AwExtendedTooltip from'viewmodel/AwExtendedTooltipViewModel';import AwIcon from'viewmodel/AwIconViewModel';import AwPic from'viewmodel/AwPicViewModel';import AwPopup from'viewmodel/AwPopupViewModel';import eventBus from'js/eventBus';import wcagService from'js/wcagService';import{DerivedStateResult}from'js/derivedContextService';import{assignWith,get}from'lodash';import{getStringBetweenDoubleMustaches}from'js/parsingUtils';import{DOMAPIs as dom}from'js/domUtils';import analyticsSvc from'js/analyticsService';import*as cas from'js/centralAggregationService';/**\n * TODO: Predictive UI\n *   - Why is command calling two apis on analytics service? Need to merge and split internally\n *   - Can move to creation of input to this component\n */import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";let popupRef=null;/**\n * Method to publish analytics to server\n * @param {Object} command - command clicked by user\n * @param {String} parentId - command id of parent of the child command\n */const publishAnalytics=(command,parentId)=>{var sanPopupCmdLogData={sanAnalyticsType:'Popup Commands',sanCommandId:command.id,sanCommandTitle:command.title};analyticsSvc.logCommands(sanPopupCmdLogData);};/**\n * Component to render a command that has already been processed\n *\n * @param {*} param0 context for render function interpolation\n * @returns {JSX.Element} react component\n */export const awCommandRenderFunction=_ref=>{let{viewModel:{dispatch,data:{isCommandExecuting}},command,ctxMin:{commandClass},runActionWithViewModel,actions:{openCommandPopup},childCommandClickCallback,commandContext,visibilityLoader}=_ref;/**\n     * Click handler for the command button\n     *\n     * @param {Event} e Click event\n     */const executeCommand=async e=>{e.stopPropagation();if(command.enabled){eventBus.publish('removeMessages',{});dispatch({path:'data.isCommandExecuting',value:true});const result=await command.execute(runActionWithViewModel,commandContext);dispatch({path:'data.isCommandExecuting',value:false});logUserGesture();if(command.hasPopup){const overrideOptions=result.inputData.options;openCommandPopup.show({...overrideOptions,context:getPopupContext(overrideOptions)}).then(popup=>{popupRef=popup;});}if(childCommandClickCallback){childCommandClickCallback(command.hasPopup);}}if(childCommandClickCallback){childCommandClickCallback(command.hasPopup);}publishAnalytics(command,getParentGroupId());};const getParentGroupId=function(){let parentGroupId='';if(commandContext&&commandContext.command){parentGroupId=commandContext.command.id;}return parentGroupId;};const getSubject=function(){let subject={};if(commandContext&&commandContext.selectionData){let pselected=commandContext.selectionData.pselected?commandContext.selectionData.pselected:'';let selected=commandContext.selectionData.selected?commandContext.selectionData.selected:'';subject={pselected:pselected,selected:selected};}return subject;};const logUserGesture=function(){let widgetInfo={commandId:command.id,parentGroupId:getParentGroupId(),commandContext:commandContext};cas.notify({widgetInfo:widgetInfo,userGesture:'commandClick',subject:getSubject()});};const getPopupContext=options=>{const scope={commandContext};let subPanelContext=assignWith({},options.subPanelContext,(objValue,srcValue)=>{const path=getStringBetweenDoubleMustaches(objValue||srcValue);return get(scope,path);});return{anchor:command.id,//TODO: Command context will need to be included in this also\ncontext:{command,...commandContext},visibilityLoader,subPanelContext,childCommandClickCallback:hasPopup=>{if(hasPopup){return;}openCommandPopup.hide();closeAncestorMenus();}};};const closeAncestorMenus=()=>{if(!popupRef){return;}let menu=popupRef.parentPopup;// if it's a nested menu\nwhile(menu&&dom.get('.aw-popup-command-bar',menu.panelEl)){menu.hide();menu=menu.parentPopup;}popupRef=null;};const onKeyDownHandler=event=>{if(wcagService.isValidKeyPress(event)){event.preventDefault();executeCommand(event);}else{wcagService.handleMoveUpOrDown(event,event.currentTarget.parentElement.parentElement);}};// move to memo function?\nif(!command.icon){if(command.selected){command.icon='cmdCheckmark';}else{command.icon='cmdBlankIcon';}}return/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsxs(\"li\",{ref:openCommandPopup.reference,onKeyDown:onKeyDownHandler,onClick:executeCommand,\"button-id\":command.id,\"command-id\":command.id,\"data-command-id\":command.id,className:commandClass,tabIndex:-1//Programatically focusable but not naturally\n,\"aria-label\":command.title,title:command.extendedTooltip||command.description?null:command.title,\"aria-disabled\":isCommandExecuting||!command.enabled,role:\"button\",\"aria-haspopup\":command.hasPopup,children:[/*#__PURE__*/_jsxs(\"div\",{className:\"aw-popup-cellContentContainer\",children:[/*#__PURE__*/_jsx(AwPic,{className:\"aw-widget-thumbnail\",iconId:command.icon}),command.decorator&&command.decorator.text&&command.decorator.visibleWhen?/*#__PURE__*/_jsx(\"div\",{className:\"aw-commands-cellDecorator\",children:command.decorator.className?/*#__PURE__*/_jsx(\"div\",{className:command.decorator.className,children:command.decorator.text}):/*#__PURE__*/_jsx(\"div\",{children:command.decorator.text})}):null,command.title]}),command.hasPopup?/*#__PURE__*/_jsx(\"div\",{className:\"aw-widgets-groupCommandStack\",children:/*#__PURE__*/_jsx(AwIcon,{iconId:\"miscDownArrow_uxRefresh\"})}):null]}),/*#__PURE__*/_jsx(AwPopup,{...openCommandPopup.options}),/*#__PURE__*/_jsx(AwExtendedTooltip,{reference:openCommandPopup.reference,extendedTooltipOptions:{isCommand:true,alignment:'VERTICAL'},extendedTooltipContext:command,extendedTooltip:command.extendedTooltip})]});};/**\n * Get the classes to use for the button in AwCommand\n *\n * @param {Object} renderContext Component render context\n * @param {Boolean} selected Command selected state\n * @param {Boolean} enabled Command enabled state\n * @param {Boolean} hasPopup Command popup state\n * @param {Boolean} isCommandExecuting Whether the command is currently executing\n * @returns {String} The class to use\n */const getCommandClass=(renderContext,selected,enabled,hasPopup,isCommandExecuting,icon)=>{const classNames=['sw-aria-border','aw-widgets-cellListItem','aw-widgets-cellTop',selected?'aw-state-selected':null,enabled&&!isCommandExecuting?null:'disabled',hasPopup?'aw-hierarchical-popup':null].filter(x=>x);return classNames.join(' ');};/**\n * Parser to get the class to set on command\n *\n * @param {Object} vmDef View model definition\n * @param {Object} prop Current properties\n * @param {Object} data Current view model data\n * @returns {[DerivedStateResult]} Derived state configurations\n */export const getCommandClassMemo=(vmDef,prop,data)=>{return[new DerivedStateResult({ctxParameters:[],additionalParameters:[prop.command.selected,prop.command.enabled,prop.command.hasPopup,data.isCommandExecuting,prop.command.icon],compute:getCommandClass})];};","map":null,"metadata":{},"sourceType":"module"}