{"ast":null,"code":"/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service is the entry point for SPLM table. It initializes the table and renders it\n *\n * @module js/splmTableFactory\n */\nimport SPLMTableColumnRearrangement from 'js/splmTableColumnRearrangement';\nimport SPLMTableInfiniteScrollService from 'js/splmTableInfiniteScrollService';\nimport SPLMTableKeyboardService from 'js/splmTableKeyboardService';\nimport SPLMTableTranspose from 'js/splmTableTranspose';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport awColumnFilterService from 'js/awColumnFilterService';\nimport awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport domUtils from 'js/domUtils';\nimport dragAndDropService from 'js/dragAndDropService';\nimport eventBus from 'js/eventBus';\nimport localeService from 'js/localeService';\nimport selectionHelper from 'js/selectionHelper';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport uwUtilSvc from 'js/uwUtilService';\nimport messagingService from 'js/messagingService';\nimport { svgString as miscInProcessIndicator } from \"image/miscInProcessIndicator16.svg\";\nimport { svgString as miscExpandedTree } from \"image/miscExpandedTree12.svg\";\nimport { svgString as miscCollapsedTree } from \"image/miscCollapsedTree12.svg\";\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport Editor from 'js/splmTableEditor';\nimport MenuService from 'js/splmTableMenuService';\nimport Ctrl from 'js/splmTableDomController';\nimport Cell from 'js/splmTableCellRenderer';\nimport SPLMTableSelectionHelper from 'js/splmTableSelectionHelper';\n/**\n * Cached reference to the various AngularJS and AW services.\n */\n\nvar exports = {};\nvar _splmTableMessages = {};\nvar _defaultContentFilter = {\n  isIdOfObject: function (vmo, uid) {\n    let matchedId = false;\n\n    if (vmo) {\n      if (vmo.alternateID) {\n        matchedId = vmo.alternateID === uid;\n      }\n\n      if (!matchedId && vmo.uid) {\n        matchedId = vmo.uid === uid || vmo.uid.indexOf(uid) !== -1;\n      }\n    }\n\n    return matchedId;\n  }\n};\nconst dom = domUtils.DOMAPIs;\n/**\n * Check if we are using a 'gridid' in the closest 'declViewModel' in the scope tree.<BR>\n * If so: Use it to display the aw-table data<BR>\n *\n */\n\nexport let createTableObject = function (directiveElement, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, contentFilter, gridOptions, containerHeight, gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, tableContext, reusable, showCheckBox) {\n  // 20180920: put it to null so that it will error out when there is an code error\n  var _tableColumns = null;\n\n  var _contentFilter = contentFilter || _defaultContentFilter; // setup cell renderer\n\n\n  var cellRenderer = awSPLMTableCellRendererFactory.createCellRenderer();\n  var table = util.createElement('div');\n\n  var _trv = new Trv(table);\n\n  var tableCtrl = null;\n  var tableEditor = null;\n  var menuService = null;\n  var _nodeExpansionInProgress = false;\n  let tableScroll = null;\n  let columnRearrangementService = null;\n  let keyboardService = null;\n  let updateEditState = null;\n  let _showCheckBox = showCheckBox; // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n  // Define header and row height here to save computed CSS reading\n\n  var _rowBorderWidth = 1;\n\n  var _rowHeight = appCtxService.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n\n  _rowHeight = util.getTableRowHeight(gridOptions, _rowHeight);\n  var _headerHeight = Const.HEIGHT_HEADER;\n  _headerHeight = util.getTableHeaderHeight(gridOptions, _headerHeight); // This updateColumnDefs function is called as part of the buildDynamicColumns.\n\n  let _updateColumnDefs = function () {\n    let columns = dataProvider.cols;\n\n    if (gridOptions.transpose === true) {\n      // Get and assign transposed columns\n      columns = SPLMTableTranspose.getTransposedColumns(_tableColumns, dataProvider.viewModelCollection.loadedVMObjects);\n    }\n\n    for (let i = 0; i < columns.length; i++) {\n      columns[i].visible = !columns[i].hasOwnProperty('visible') || columns[i].visible;\n    }\n\n    _tableColumns = _.filter(columns, function (column) {\n      if (column.visible) {\n        return column;\n      }\n\n      return false;\n    });\n\n    _.forEach(_tableColumns, function (column, index) {\n      column.index = index;\n\n      if (!column.cellRenderers) {\n        column.cellRenderers = [];\n      }\n\n      if (column.name === 'icon' && column.iconCellRenderer) {\n        column.cellRenderers = column.cellRenderers.concat(column.iconCellRenderer);\n      }\n\n      column.cellRenderers = column.cellRenderers.concat(cellRenderer.getAwCellRenderers());\n    });\n\n    _.forEach(_tableColumns, function (column, index) {\n      column.index = index;\n\n      if (!column.headerRenderers) {\n        column.headerRenderers = [];\n      }\n\n      column.headerRenderers = column.headerRenderers.concat(cellRenderer.getAwHeaderRenderers());\n    });\n\n    menuService.loadDefaultColumnMenus();\n  };\n\n  let getObjects = function () {\n    if (!dataProvider.viewModelCollection) {\n      return [];\n    }\n\n    if (gridOptions.transpose === true) {\n      return SPLMTableTranspose.getTransposedVmos(dataProvider.cols, dataProvider.viewModelCollection.loadedVMObjects);\n    }\n\n    return dataProvider.viewModelCollection.loadedVMObjects;\n  };\n\n  let resetColumns = function () {\n    _updateColumnDefs();\n\n    awColumnFilterService.removeStaleFilters(columnProvider, _tableColumns); // property loading has completed\n\n    tableCtrl.resetColumnDefs(_tableColumns); // Table headers recreated, need to initialize column rearrangement\n\n    columnRearrangementService.initialize(); // Trick for update scroll container position\n\n    if (tableScroll.isInitialized()) {\n      cellRenderer.resetHoverCommandElement();\n      tableScroll.setLoadedVMObjects(getObjects());\n      tableScroll.handleScroll();\n    }\n  };\n  /**\n   * Finds VMOs with undefined props within the specified range.\n   *\n   * @param {int} startIndex - starting VMO index\n   * @param {int} endIndex - edning VMO index\n   */\n\n\n  var findVMOsWithMissingProps = function (startIndex, endIndex) {\n    var emptyVMOs = [];\n\n    for (var i = startIndex; i <= endIndex; i++) {\n      var vmo = dataProvider.viewModelCollection.loadedVMObjects[i];\n\n      if (vmo.isPropLoading) {\n        continue;\n      } else if (!vmo.props) {\n        emptyVMOs.push(vmo);\n      } else {\n        var keys = Object.keys(vmo.props);\n\n        if (keys.length === 0) {\n          emptyVMOs.push(vmo);\n        }\n      }\n    }\n\n    return emptyVMOs;\n  };\n\n  let loadMissingProps = function () {\n    var firstRenderedItemIndex = tableScroll.getFirstRenderedItemIndex();\n    var lastRenderedItemIndex = tableScroll.getLastRenderedItemIndex();\n    var emptyVMOs = findVMOsWithMissingProps(firstRenderedItemIndex, lastRenderedItemIndex);\n\n    if (emptyVMOs.length > 0) {\n      eventBus.publish(gridid + '.plTable.loadProps', {\n        VMOs: emptyVMOs\n      });\n    }\n  };\n\n  if (gridid) {\n    var instanceEventSubcr = []; // Do essential table DOM Element initialization for further processing\n\n    table.id = gridid;\n    table.classList.add(Const.CLASS_TABLE);\n    table.classList.add(Const.CLASS_WIDGET_GRID);\n    table.classList.add(Const.CLASS_LAYOUT_COLUMN);\n    table.classList.add(Const.CLASS_WIDGET_TABLE_DROP);\n    table.classList.add(Const.CLASS_SELECTION_ENABLED);\n    util.setSortCriteriaOnColumns(columnProvider, dataProvider);\n\n    var getContainerHeight = function () {\n      if (containerHeight !== undefined) {\n        return containerHeight;\n      }\n\n      if (gridOptions.maxRowsToShow !== undefined) {\n        return (_rowHeight + _rowBorderWidth) * gridOptions.maxRowsToShow + Const.HEIGHT_HEADER;\n      }\n\n      return undefined;\n    };\n\n    tableScroll = new SPLMTableInfiniteScrollService(getContainerHeight());\n    table._tableInstance = {\n      ctx: appCtxService.ctx,\n      messages: _splmTableMessages,\n      declViewModel: declViewModel,\n      dataProvider: dataProvider,\n      viewModelCollection: viewModelCollection,\n      columnProvider: columnProvider,\n      gridId: gridid,\n      gridOptions: gridOptions,\n      isBulkEditing: false,\n      isCellEditing: false,\n      renderer: tableScroll,\n      dynamicRowHeightStatus: false,\n      cellRenderer: cellRenderer,\n      runActionWithViewModel: runActionWithViewModel,\n      tableInstanceCallbacks,\n      tableContext: tableContext ? tableContext : {},\n      showCheckBox: showCheckBox\n    };\n    tableEditor = new Editor(table, directiveElement, gridContextDispatcher);\n    table._tableInstance.editor = tableEditor;\n    keyboardService = new SPLMTableKeyboardService(table, tableEditor);\n    keyboardService.setupKeyListener();\n    table._tableInstance.keyboardService = keyboardService;\n    menuService = new MenuService(table, directiveElement, table._tableInstance, gridContextDispatcher);\n\n    if (gridOptions.enableGridMenu) {\n      menuService.addGridMenu();\n    }\n\n    if (gridOptions.showContextMenu === true) {\n      menuService.setContextSelectionHelper(selectionHelper);\n    }\n\n    if (gridOptions.enableDynamicRowHeight) {\n      table._tableInstance.dynamicRowHeightStatus = true;\n    }\n\n    _updateColumnDefs();\n\n    tableCtrl = new Ctrl(table, _tableColumns, tableEditor, gridContextDispatcher);\n    table._tableInstance.controller = tableCtrl;\n    table._tableInstance.editor = tableEditor; // LCS-13247 Pagination SOA performance issue for Objectset Table\n    // - Put a debounce here to avoid possible sending traffic jam, the number\n    //   is from _pingRedrawDebounce from aw.table.controller\n    // - With debounce IE performance improves a lot and no impact to chrome performance,\n    //   so leave the debounce for all\n\n    var _loadMorePageDebounce = _.debounce(function (firstRenderedItem, lastRenderedItem) {\n      eventBus.publish(gridid + '.plTable.loadMorePages', {\n        firstRenderedItem: firstRenderedItem,\n        lastRenderedItem: lastRenderedItem\n      });\n    }, 500);\n\n    var pendingUpdatedProps = {};\n\n    var updateRowContents = function (updatedPropsMaps) {\n      var rowElements = _trv.queryAllRowCellElementsFromTable();\n\n      _.forEach(updatedPropsMaps, function (updatedProps, vmoUid) {\n        _.forEach(rowElements, function (rowElem) {\n          _.forEach(rowElem.children, function (cellElem) {\n            // Check if the vmo has been updated, if not continue to next cell\n            let updatedVmo = null;\n\n            if (rowElem.vmo && rowElem.vmo.uid === vmoUid) {\n              updatedVmo = rowElem.vmo;\n            } else if (gridOptions.transpose === true && cellElem.columnDef.vmo && cellElem.columnDef.vmo.uid === vmoUid) {\n              updatedVmo = cellElem.columnDef.vmo;\n            } else {\n              return;\n            }\n\n            var needsUpdate = false;\n\n            if (cellElem.columnDef && cellElem.columnDef.name === 'icon' || gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === 'icon') {\n              var imgElem = cellElem.getElementsByTagName('img')[0];\n\n              if (imgElem && imgElem.getAttribute('src') !== util.getImgURL(updatedVmo)) {\n                needsUpdate = true;\n              }\n            } else {\n              for (var i = 0; i < updatedProps.length; i++) {\n                if (cellElem.propName === updatedProps[i] || gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === updatedProps[i]) {\n                  needsUpdate = true;\n                  break;\n                }\n              }\n            }\n\n            if (needsUpdate) {\n              Cell.updateCell(cellElem, rowElem, table, tableEditor);\n\n              if (rowElem.vmo.selected && (cellElem.columnDef.isTableCommand || cellElem.columnDef.isTreeNavigation)) {\n                let cellTop = cellElem.children[0];\n\n                if (cellElem.columnDef.isTreeNavigation) {\n                  cellTop = cellElem.getElementsByClassName('aw-jswidgets-tableNonEditContainer')[0];\n                }\n\n                if (cellTop.getElementsByClassName(Const.CLASS_AW_CELL_COMMANDS_CONTAINER).length === 0) {\n                  if (dataProvider.selectionModel && !dataProvider.selectionModel.multiSelectEnabled && dataProvider.selectionModel.getCurrentSelectedCount() === 1) {\n                    let cellCommand = awSPLMTableCellRendererFactory.createCellCommandElement(cellElem.columnDef, rowElem.vmo, true);\n                    cellTop.appendChild(cellCommand);\n                  }\n                }\n              }\n            }\n          });\n        });\n      });\n    };\n\n    var updatePendingProps = _.debounce(function () {\n      // prevent from calling if table has been destroyed in meantime\n      if (!table._tableInstance.isDestroyed) {\n        updateRowContents(pendingUpdatedProps);\n        pendingUpdatedProps = {};\n      }\n    }, 250);\n\n    instanceEventSubcr.push(eventBus.subscribe('viewModelObject.propsUpdated', function (updatedProps) {\n      // Merge the updatedVmos into pendingUpdatedVmos\n      for (var vmoUid in updatedProps) {\n        if (pendingUpdatedProps[vmoUid] === undefined) {\n          pendingUpdatedProps[vmoUid] = updatedProps[vmoUid];\n        } else {\n          for (var i = 0; i < updatedProps[vmoUid].length; i++) {\n            var updatedPropName = updatedProps[vmoUid][i];\n\n            if (pendingUpdatedProps[vmoUid].indexOf(updatedPropName) === -1) {\n              pendingUpdatedProps[vmoUid].push(updatedPropName);\n            }\n          }\n        }\n      }\n\n      updatePendingProps();\n    }));\n\n    var loadProps = function (emptyVMOs) {\n      eventBus.publish(gridid + '.plTable.loadProps', {\n        VMOs: emptyVMOs\n      });\n    };\n\n    var editCellElement;\n    columnRearrangementService = new SPLMTableColumnRearrangement(table); // 20180927: This is not related to global isEdit anymore, feel free\n    // to refactor:)\n\n    var updateEditStatusForTableCanvas = function (isEditing) {\n      tableCtrl.setDraggable(!isEditing);\n      tableEditor.updateEditStatus(isEditing);\n    };\n\n    var _setupTreeForRestrictiveEditing = function (isEditing) {\n      tableScroll.setupTreeEditScroll(isEditing);\n    };\n\n    updateEditState = function (eventData) {\n      // We should not start edit for any non table cases.\n      // This should be started only for table cases and also based on the grid id you are on.\n      // PWA case the dataSource is the dataProvider, thus has no .dataProviders property (we check if it is the dataProvider in scope with .name)\n      // SWA case we have dataSource.dataProvider and can check with dataProviders[ dataProvider.name ]\n      if (tableCtrl && eventData.dataSource && (eventData.dataSource.getAtomicData && eventData.dataSource.getAtomicData().dpRef && eventData.dataSource.getAtomicData().dpRef.current || eventData.dataSource.name === dataProvider.name)) {\n        var isEditing = eventData.state === 'partialSave' || eventData.state === 'starting'; // If saving, set all column filters to be stale as data could have changed\n\n        if (eventData.state === 'saved') {\n          _.forEach(dataProvider.cols, function (column) {\n            awColumnFilterService.setColumnFilterStale(column);\n          });\n\n          if (!util.isAutoSaveEnabled(table)) {\n            tableEditor.clearPropIsEditableCache();\n          }\n\n          util.setIsCellEditing(table, false);\n        } else if (eventData.state === 'canceling') {\n          tableEditor.clearPropIsEditableCache();\n          util.setIsCellEditing(table, false);\n        } // Enable vmo caching on collapse in edit mode\n\n\n        dataProvider.cacheCollapse = true;\n        util.setIsBulkEditing(table, isEditing);\n        gridContextDispatcher({\n          type: 'UPDATE_VALUES',\n          isBulkEditing: table._tableInstance.isBulkEditing,\n          dynamicRowHeightStatus: table._tableInstance.dynamicRowHeightStatus\n        });\n        tableCtrl.setSelectable(!isEditing);\n\n        if (util.isCellEditing(table) === false || util.isCellEditing(table) && !util.isAutoSaveEnabled(table)) {\n          updateEditStatusForTableCanvas(isEditing);\n        }\n\n        if (gridOptions.useTree && !util.isExpandOrPaginationAllowedInEdit(table)) {\n          _setupTreeForRestrictiveEditing(isEditing);\n        }\n\n        if (!isEditing) {\n          // Restore original cache collapse state when leaving edit mode\n          dataProvider.restoreInitialCacheCollapseState();\n        }\n\n        if (table._tableInstance.dynamicRowHeightStatus === true) {\n          resetDynamicRowHeights();\n          clientRefresh();\n        }\n      }\n    };\n\n    instanceEventSubcr.push(eventBus.subscribe(dataProvider._eventTopicEditInProgress, function () {\n      if (reusable !== true) {\n        const eventData = {\n          dataSource: dataProvider,\n          state: dataProvider._editingState\n        };\n        updateEditState(eventData);\n      }\n    }));\n    instanceEventSubcr.push(eventBus.subscribe(declViewModel._internal.eventTopicEditInProgress, function () {\n      const eventData = {\n        dataSource: declViewModel,\n        state: declViewModel._editingState\n      };\n      updateEditState(eventData);\n    }));\n    instanceEventSubcr.push(eventBus.subscribe('plTable.editStateChange', function (eventData) {\n      updateEditState(eventData);\n    }));\n    instanceEventSubcr.push(eventBus.subscribe('editHandlerStateChange', function (eventData) {\n      updateEditState(eventData);\n    }));\n\n    var _updateAllRowsVisibilityDebounce = _.debounce(function () {\n      var rowElements = _trv.queryAllRowCellElementsFromTable();\n\n      _.forEach(rowElements, function (row) {\n        if (row.vmo) {\n          var cellTopElem = row.getElementsByClassName(Const.CLASS_SPLM_TABLE_ICON_CELL)[0];\n\n          if (!cellTopElem) {\n            cellTopElem = row.getElementsByClassName(Const.CLASS_AW_TREE_COMMAND_CELL)[0];\n          }\n\n          if (cellTopElem) {\n            var iconCellElem = cellTopElem.parentElement;\n            var columnDef = iconCellElem.columnDef;\n            var newCellTop = Cell.createElement(columnDef, row.vmo, table, row);\n            iconCellElem.replaceChild(newCellTop, cellTopElem);\n          }\n        }\n      });\n    }, 100);\n    /**\n     * Subscribe to resetScroll. Clear the tables rendered items cache and scroll to top of table.\n     */\n\n\n    instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.resetScroll', function () {\n      resetInfiniteScroll();\n    }));\n    var verdict = util.validateRowHeightGridOption(table._tableInstance.gridOptions);\n    /**\n     * Subscribe to LayoutChangeEvent. Update row height to correct value\n     */\n\n    if (verdict === false) {\n      instanceEventSubcr.push(eventBus.subscribe('LayoutChangeEvent', function (data) {\n        var oldHeight = _rowHeight;\n        _rowHeight = data.rowHeight;\n\n        if (oldHeight === _rowHeight) {\n          return;\n        }\n\n        if (tableScroll.isInitialized()) {\n          tableScroll.setRowHeight(_rowHeight + _rowBorderWidth);\n          var newContainerHeight = getContainerHeight();\n\n          if (newContainerHeight !== undefined) {\n            tableScroll.setContainerHeight(newContainerHeight);\n          } // Reinitialize properties so that the rendering calculations are valid\n\n\n          tableScroll.initializeProperties(); // Reset dynamic row height if enabled\n\n          if (table._tableInstance.dynamicRowHeightStatus) {\n            resetDynamicRowHeights();\n          }\n\n          tableScroll.updateRowAlignment(); // Scroll to rows in that were in view before layout change\n\n          var scrollContainer = _trv.getScrollCanvasElementFromTable();\n\n          var oldScrollTop = scrollContainer.scrollTop;\n          scrollContainer.scrollTop = oldScrollTop / oldHeight * _rowHeight;\n          tableScroll.handleScroll();\n        }\n      }));\n    } // Reusable table does not need below named events for selection changes, it will now work with selectionData.\n\n\n    let isReusable = _.isString(reusable) ? reusable === 'true' : reusable;\n\n    if (isReusable !== true) {\n      instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.selectionChangeEvent', function () {\n        SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table);\n      }));\n      instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.selectAll', function () {\n        SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table);\n      }));\n      instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.selectNone', function () {\n        SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table);\n      }));\n    }\n\n    instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.visibilityStateChanged', _updateAllRowsVisibilityDebounce));\n    instanceEventSubcr.push(eventBus.subscribe(gridid + '.plTable.resizeCheck', function () {\n      if (tableScroll.isInitialized()) {\n        tableScroll.checkForResize();\n      }\n    }));\n\n    var scrollToRow = function (gridId, rowUids) {\n      if (gridid === gridId) {\n        if (util.isBulkEditing(table)) {\n          return;\n        }\n\n        var rowIndexes = [];\n\n        for (var i = 0; i < rowUids.length; i++) {\n          var uid = rowUids[i].uid ? rowUids[i].uid : rowUids[i];\n          var rowIndex = dataProvider.viewModelCollection.findViewModelObjectById(uid);\n\n          if (rowIndex !== -1) {\n            rowIndexes.push(rowIndex);\n          }\n        }\n\n        if (rowIndexes.length > 0) {\n          tableScroll.scrollToRowIndex(rowIndexes);\n        }\n      }\n    };\n\n    instanceEventSubcr.push(eventBus.subscribe('plTable.scrollToRow', function (eventData) {\n      scrollToRow(eventData.gridId, eventData.rowUids);\n    }));\n\n    var updateDecoratorVisibility = function (isEnabled) {\n      if (isEnabled === true && gridOptions.showDecorators !== false) {\n        table.classList.add(Const.CLASS_AW_SHOW_DECORATORS);\n      } else {\n        table.classList.remove(Const.CLASS_AW_SHOW_DECORATORS);\n      }\n    };\n\n    var decoratorToggle = 'decoratorToggle';\n    var showDecorators = appCtxService.getCtx(decoratorToggle);\n    updateDecoratorVisibility(showDecorators);\n    instanceEventSubcr.push(eventBus.subscribe('appCtx.register', function (event) {\n      if (event.name === decoratorToggle) {\n        updateDecoratorVisibility(event.value);\n      }\n    }));\n    instanceEventSubcr.push(eventBus.subscribe('appCtx.update', function (event) {\n      if (event.name === decoratorToggle) {\n        updateDecoratorVisibility(event.value.decoratorToggle);\n      }\n    }));\n    instanceEventSubcr.push(eventBus.subscribe('decoratorsUpdated', function (updateVMOs) {\n      updateVMOs = updateVMOs.length === undefined ? [updateVMOs] : updateVMOs;\n      tableCtrl.updateColorIndicatorElements(updateVMOs);\n    }));\n    /**\n     * React to request for node expansions.\n     */\n\n    instanceEventSubcr.push(eventBus.subscribe(dataProvider.name + '.expandTreeNode', function (eventData) {\n      if (eventData.parentNode) {\n        var vmCollection = dataProvider.getViewModelCollection();\n        var rowNdx = vmCollection.findViewModelObjectById(eventData.parentNode.id);\n\n        if (rowNdx !== -1) {\n          var vmo = vmCollection.getViewModelObject(rowNdx);\n\n          if (vmo.isExpanded !== true) {\n            vmo.isExpanded = true;\n\n            if (tableInstanceCallbacks.toggleTreeNode) {\n              tableInstanceCallbacks.toggleTreeNode(vmo);\n            } else {\n              eventBus.publish(table.id + '.plTable.toggleTreeNode', vmo);\n            }\n          }\n        }\n      }\n    }));\n\n    const getTargetVmo = function (element, isTarget) {\n      /**\n       * Merge event 'target' with any other objects currently selected.\n       */\n      var targetObjects = [];\n      var elementRow = element.classList.contains(Const.CLASS_ROW) ? element : util.closestElement(element, '.' + Const.CLASS_ROW);\n\n      if (elementRow && elementRow.vmo) {\n        targetObjects.push(elementRow.vmo);\n        var targetUid = elementRow.vmo.uid;\n\n        if (!isTarget) {\n          var sourceObjects = dragAndDropService.getSourceObjects(dataProvider, targetUid).filter(function (obj) {\n            return targetObjects.indexOf(obj) === -1;\n          });\n          targetObjects = targetObjects.concat(sourceObjects);\n        }\n\n        return targetObjects;\n      }\n\n      return null;\n    };\n\n    const clearRowSelection = targetVMO => {\n      // eslint-disable-line\n      dataProvider.selectNone();\n    };\n\n    var listenToRelatedModifiedEvent = false;\n    var targetVMOScoped = null;\n\n    const selectTarget = (targetElement, targetVMO) => {\n      // eslint-disable-line\n\n      /**\n       * Setup to listen when the 'drop' is complete\n       */\n      if (!listenToRelatedModifiedEvent) {\n        listenToRelatedModifiedEvent = true;\n        targetVMOScoped = targetVMO;\n      }\n    };\n\n    const isTextNodeDragged = dataTranferObj => {\n      if (dataTranferObj && dataTranferObj.types) {\n        return event.type === 'dragstart' && [...dataTranferObj.types].some(type => type === 'text/plain' || type === 'Text');\n      }\n\n      return false;\n    };\n\n    let newCallbackApis = {\n      clearSelection: clearRowSelection,\n      setSelection: targetVMO => {\n        selectTarget(null, targetVMO);\n      },\n      getTargetElementAndVmo: (event, isSourceEle) => {\n        let targetVMO = null;\n        let target = null;\n\n        if (!isTextNodeDragged(event.dataTransfer)) {\n          target = dom.closest(event.target, '.ui-grid-row') || dom.closest(event.target, '.aw-widgets-droppable');\n        }\n\n        if (target) {\n          targetVMO = getTargetVmo(target, !isSourceEle);\n        }\n\n        return {\n          targetElement: target,\n          targetVMO: targetVMO\n        };\n      },\n      highlightTarget: eventData => {\n        splmTableDragHandler.handleDragDropHighlightPLTable(eventData);\n      }\n    };\n\n    const registerSplmTableDndListner = (element, callbackApis, declViewModel, tableProvider) => {\n      const getEventCallbackFn = event => {\n        let target = {};\n        let isSourceEle = event.type === 'dragstart';\n\n        if (callbackApis.getTargetElementAndVmo) {\n          target = callbackApis.getTargetElementAndVmo(event, isSourceEle);\n        }\n\n        let fun = declViewModel.dndHandler[event.type];\n        fun(event, target, callbackApis, tableProvider);\n      };\n\n      const setListener = eventType => {\n        let callBackFn = getEventCallbackFn.bind(null);\n        element.addEventListener(eventType, callBackFn);\n      };\n\n      const setEventListener = providers => {\n        Object.keys(providers).forEach(providerName => {\n          setListener(providerName.toLowerCase());\n        });\n      };\n\n      let dragProviders = declDragAndDropService.getDragHandler(declViewModel);\n\n      if (dragProviders) {\n        setEventListener(dragProviders);\n      }\n\n      let dropProviders = declDragAndDropService.getDropHandler(declViewModel);\n\n      if (dropProviders) {\n        setEventListener(dropProviders);\n      }\n    };\n\n    table._tableInstance.subDefs = instanceEventSubcr;\n    directiveElement.appendChild(table); // Drag and drop service needs to be setup after table has been attached to the directive element so\n    // that it can properly get the scope.\n\n    if (gridOptions.enableDragAndDrop !== false) {\n      /**\n       * LCS-315044: Setup the drag and drop with the new design pattern if drag and drop\n       * handlers are defined for table's container view.\n       *\n       * The branching is done to support AW, as AW is still consuming the old drag and drop pattern.\n       */\n      if (declDragAndDropService.areDnDHandelersDefined(declViewModel)) {\n        registerSplmTableDndListner(table, newCallbackApis, declViewModel, dataProvider);\n      }\n    } else {\n      dragAndDropService.disableDragAndDrop(table);\n    }\n  }\n\n  var getIconCellSVG = function (vmo) {\n    if (vmo.loadingStatus) {\n      return {\n        id: 'miscInProcessIndicator',\n        image: miscInProcessIndicator\n      };\n    } else if (vmo.isLeaf) {\n      // we made the decision to stop rendering 'typeBlankIcon' because (1) there is no visual difference, (2) we want\n      // to decrease the number of DOM elements and (3) we don't know the history of why it was there.\n      return {};\n    } else if (vmo.isExpanded) {\n      return {\n        id: 'miscExpandedTree',\n        image: miscExpandedTree\n      };\n    }\n\n    return {\n      id: 'miscCollapsedTree',\n      image: miscCollapsedTree\n    };\n  };\n\n  let updateContentRowSelection = () => {\n    SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table);\n  };\n\n  let updateSortDirection = (currentColumnIndex, newColumnIndex, sortDirection) => {\n    tableCtrl.setHeaderCellSortDirection(currentColumnIndex, newColumnIndex, sortDirection);\n  };\n\n  let refresh = function () {\n    var columnAttrs = []; // attributesToInflate at server side cannot accept full name i.e typename.propertyname.\n    // we don't need to inflate the attributes or properties that are hidden.\n\n    _.forEach(dataProvider.cols, function (uwColumnInfo) {\n      if (uwColumnInfo.field && uwColumnInfo.hiddenFlag !== true) {\n        columnAttrs.push(uwColumnInfo.field);\n      }\n    });\n\n    if (dataProvider && dataProvider.action && dataProvider.action.inputData) {\n      dataProvider.action.inputData.searchInput = dataProvider.action.inputData.searchInput || {};\n      var searchInput = dataProvider.action.inputData.searchInput;\n\n      if (searchInput.attributesToInflate) {\n        searchInput.attributesToInflate = _.union(searchInput.attributesToInflate, columnAttrs);\n      } else {\n        searchInput.attributesToInflate = columnAttrs;\n      }\n    } // Since VMOs represent columns, we need to reset the columns also for transpose mode\n\n\n    if (gridOptions.transpose === true) {\n      resetColumns();\n    } // REFACTOR: infinite scroll code should be refactor to follow:\n    // 1. DOMElement should be the only interface for interaction between service and function\n    // 2. Lot of code below should be pull out from anonymous function, a initialize grid which\n    //    is taking 70 line of code is a bad smell.\n\n\n    if (!tableScroll.isInitialized()) {\n      // Set initial scroll index before table initializes\n      if (dataProvider.isFocusedLoad) {\n        var selection = dataProvider.getSelectedObjects();\n\n        if (selection.length === 1) {\n          scrollToRow(gridid, [selection[0].uid]);\n        }\n      }\n\n      tableScroll.initializeGrid({\n        tableElem: table,\n        directiveElem: directiveElement,\n        scrollViewportElem: _trv.getScrollCanvasElementFromTable(),\n        pinViewportElem: _trv.getPinCanvasElementFromTable(),\n        rowSelector: '.' + Const.CLASS_ROW,\n        rowHeight: _rowHeight + _rowBorderWidth,\n        headerHeight: _headerHeight,\n        dynamicRowHeightStatus: gridOptions.enableDynamicRowHeight,\n        loadedVMObjects: getObjects(),\n        updateVisibleCells: function (rowParentElem) {\n          tableCtrl.updateVisibleCells(rowParentElem);\n        },\n        updateScrollColumnsInView: function (scrollLeft, scrollContainerWidth) {\n          tableCtrl.updateScrollColumnsInView(scrollLeft, scrollContainerWidth);\n        },\n        onStartScroll: function () {\n          if (!util.isBulkEditing(table) || !editCellElement) {\n            return;\n          } // Close drop down if it is open on the edit cell\n\n\n          var cellListElement = editCellElement.getElementsByClassName('aw-jswidgets-popUpVisible')[0];\n\n          if (cellListElement) {\n            editCellElement.click();\n          }\n        },\n        syncHeader: function (isPin, scrollLeft) {\n          let traversalTable = new Trv(table);\n          util.syncHeader(traversalTable, isPin, scrollLeft);\n        },\n        renderRows: function (startIndex, endIndex) {\n          var subVMObjects = getObjects().slice(startIndex, endIndex + 1); // Return if there is nothing to render\n\n          if (subVMObjects.length === 0) {\n            return;\n          }\n\n          if (gridOptions.useTree === true) {\n            let messages = gridOptions.textBundle ? gridOptions.textBundle : _splmTableMessages;\n\n            _.forEach(subVMObjects, function (vmo) {\n              if (vmo.isLeaf) {\n                vmo._twistieTitle = '';\n              } else {\n                vmo._twistieTitle = vmo.isExpanded ? messages.TwistieTooltipExpanded : messages.TwistieTooltipCollapsed;\n              }\n\n              if (!util.isExpandAllowed(table)) {\n                vmo._twistieTitle = '';\n              }\n            });\n          }\n\n          var insertBefore = false;\n\n          var scrollContents = _trv.getScrollContentElementFromTable();\n\n          var pinContents = _trv.getPinContentElementFromTable();\n\n          var firstPinElement = pinContents.childElementCount > 0 ? pinContents.childNodes[0] : 0;\n          var firstScrollElement = scrollContents.childElementCount > 0 ? scrollContents.childNodes[0] : 0;\n\n          if (firstScrollElement && firstScrollElement.getAttribute('data-indexNumber')) {\n            var firstRowIdx = parseInt(firstScrollElement.getAttribute('data-indexNumber'));\n            insertBefore = firstRowIdx > startIndex;\n          }\n\n          var pinContentElement = tableCtrl.constructContentElement(subVMObjects, startIndex, _rowHeight, true);\n          var scrollContentElement = tableCtrl.constructContentElement(subVMObjects, startIndex, _rowHeight, false);\n          tableCtrl.setAriaLabelledAndDescribedBy(directiveElement, _trv.getTableContainerElementFromTable());\n          tableCtrl.setAriaRowCount(_trv.getTableContainerElementFromTable());\n\n          if (table._tableInstance.dynamicRowHeightStatus) {\n            tableCtrl.syncContentRowHeights(pinContentElement, scrollContentElement);\n          }\n\n          SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, pinContentElement.childNodes, scrollContentElement.childNodes, table);\n\n          if (insertBefore) {\n            _trv.getPinContentElementFromTable().insertBefore(pinContentElement, firstPinElement);\n\n            _trv.getScrollContentElementFromTable().insertBefore(scrollContentElement, firstScrollElement);\n          } else {\n            _trv.getPinContentElementFromTable().appendChild(pinContentElement);\n\n            _trv.getScrollContentElementFromTable().appendChild(scrollContentElement);\n          }\n\n          if (table._tableInstance.focusTreeNodeExpandAfterRender) {\n            let node = table._tableInstance.focusTreeNodeExpandAfterRender;\n\n            let rowContents = _trv.queryAllRowCellElementsFromTable();\n\n            let rowElem = _.filter(rowContents, {\n              vmo: node\n            })[0];\n\n            if (rowElem) {\n              let elementToFocus = rowElem.getElementsByClassName(Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD)[0];\n              elementToFocus && elementToFocus.focus();\n            }\n          }\n        },\n        removeRows: function (upperCount, lowerCounter) {\n          cellRenderer.resetHoverCommandElement();\n          tableCtrl.removeContentElement(upperCount, lowerCounter);\n          tableCtrl.setAriaRowCount(_trv.getTableContainerElementFromTable());\n        },\n        afterGridRenderCallback: function (firstRenderedItem, lastRenderedItem) {\n          let containerElement = _trv.getTableContainerElementFromTable();\n\n          if (containerElement && containerElement.hasAttribute('aria-activedescendant')) {\n            var activedescendantId = containerElement.getAttribute('aria-activedescendant');\n\n            if (!document.getElementById(activedescendantId)) {\n              containerElement.removeAttribute('aria-activedescendant');\n            }\n          }\n\n          var isEditing = util.isBulkEditing(table);\n          let loadingProps = false;\n\n          if (isEditing) {\n            updateEditStatusForTableCanvas(isEditing);\n          }\n\n          if (gridOptions.useTree === true) {\n            if (_nodeExpansionInProgress === true) {\n              return;\n            }\n\n            var nonPlaceholderFound = false;\n\n            for (var i = lastRenderedItem.index; i >= firstRenderedItem.index; i--) {\n              var vmo = dataProvider.viewModelCollection.loadedVMObjects[i];\n\n              if (dataProvider.focusAction) {\n                if (vmo._focusRequested) {\n                  return;\n                }\n\n                if (vmo.isPlaceholder) {\n                  // ...use .isPlaceholder or .isFocusParent instead\n                  if (nonPlaceholderFound) {\n                    delete vmo.isPlaceholder;\n                    vmo._focusRequested = true;\n                    tableInstanceCallbacks.doFocusPlaceHolder(vmo);\n                    return;\n                  }\n                } else {\n                  nonPlaceholderFound = true;\n                }\n              }\n            } // Find and expand the first of any nodes that need to be expanded\n\n\n            for (var j = firstRenderedItem.index; j <= lastRenderedItem.index; j++) {\n              var vmObject = dataProvider.viewModelCollection.loadedVMObjects[j];\n              var expandNode = false;\n\n              if (vmObject.isLeaf !== true && vmObject._expandRequested !== true && vmObject.isExpanded !== true) {\n                // Mark for expansion if the node was already expanded\n                if (util.performStateServiceAction('isNodeExpanded', declViewModel, gridid, vmObject)) {\n                  expandNode = true;\n                }\n              } // Expand the node\n\n\n              if (expandNode === true) {\n                vmObject.isExpanded = true;\n\n                if (tableInstanceCallbacks.toggleTreeNode) {\n                  tableInstanceCallbacks.toggleTreeNode(vmObject);\n                } else {\n                  eventBus.publish(table.id + '.plTable.toggleTreeNode', vmObject);\n                }\n\n                return;\n              }\n            } // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n            // render the rows. The row rendering will then occur once they props have been loaded.\n\n\n            var emptyVMOs = findVMOsWithMissingProps(firstRenderedItem.index, lastRenderedItem.index);\n\n            if (emptyVMOs.length > 0) {\n              loadProps(emptyVMOs);\n              loadingProps = true;\n            }\n          }\n\n          if (util.isPaginationAllowed(table)) {\n            // _loadMorePageDebounce( firstRenderedItem, lastRenderedItem );\n            if (tableInstanceCallbacks) {\n              _loadMorePageDebounce(firstRenderedItem, lastRenderedItem, tableInstanceCallbacks);\n\n              tableInstanceCallbacks.loadMorePages({\n                firstRenderedItem: firstRenderedItem,\n                lastRenderedItem: lastRenderedItem\n              });\n            }\n          } // Set scrollToRow to false after row is scrolled to and all\n          // visible nodes around the scrolled to row are expanded\n\n\n          if (dataProvider.scrollToRow === true && tableScroll.isInitialRowIndexInView() === true) {\n            dataProvider.scrollToRow = false;\n          }\n        }\n      });\n      tableScroll.renderInitialRows();\n      var setContainerHeightEvent = eventBus.subscribe(gridid + '.plTable.containerHeightUpdated', function (heightVal) {\n        updateContainerHeight(heightVal);\n      });\n      instanceEventSubcr.push(setContainerHeightEvent);\n    } else {\n      // reset the row height cache\n      tableScroll.resetRowHeightCache(); // Set the loaded view model objects\n\n      tableScroll.setLoadedVMObjects(getObjects()); // Render initial rows if at top of table\n\n      if (_trv.getScrollCanvasElementFromTable().scrollTop === 0) {\n        tableScroll.renderInitialRows();\n      } else {\n        tableScroll.handleScroll();\n      }\n    }\n  };\n\n  let clientRefresh = function () {\n    if (table && table._tableInstance) {\n      table._tableInstance.showCheckBox = _showCheckBox;\n    }\n\n    util.cleanupComponents(table);\n    refresh();\n  };\n\n  let updateContainerHeight = function (heightVal) {\n    tableScroll.setContainerHeight(heightVal);\n    tableScroll.initializeProperties();\n    tableScroll.handleScrollDown();\n  };\n\n  let updateDynamicRowHeight = function (dynamicRowHeightStatus) {\n    table._tableInstance.dynamicRowHeightStatus = dynamicRowHeightStatus;\n    tableScroll.setDynamicRowHeight(table._tableInstance.dynamicRowHeightStatus);\n    clientRefresh();\n\n    if (!table._tableInstance.dynamicRowHeightStatus) {\n      resetDynamicRowHeights();\n    }\n  };\n\n  let updatePinColumn = (columnDef, isFreezeAction, defaultColumnPinIndex) => {\n    const pinColumnIndex = isFreezeAction ? columnDef.index : defaultColumnPinIndex;\n    tableCtrl.pinToColumn(pinColumnIndex);\n\n    if (!isFreezeAction) {\n      tableCtrl.resetFreezeScroll(columnDef.field);\n    }\n\n    tableScroll.handlePinViewportScrollbarPadding();\n  };\n\n  let hideColumn = columnFieldName => {\n    let columnDef;\n    var columns = dataProvider.cols;\n\n    _.forEach(columns, function (currentColumn) {\n      if (currentColumn.field === columnFieldName) {\n        columnDef = currentColumn;\n        return false;\n      }\n    });\n\n    if (columnDef) {\n      var columnIndex = columnDef.index;\n      let isOnlyVisibleColumn = true;\n\n      _.forEach(columns, function (currentColumn) {\n        if (currentColumn.name !== columnDef.name && currentColumn.visible === true && currentColumn.name !== 'icon') {\n          isOnlyVisibleColumn = false;\n          return false;\n        }\n      });\n\n      if (!isOnlyVisibleColumn) {\n        if (columnProvider.isArrangeSupported() && columnProvider.hideColumn) {\n          // account for hidden columns\n          if (dataProvider.cols[columnIndex].propertyName !== columnDef.propertyName) {\n            for (var i = 0; i < columns.length; i++) {\n              if (columns[i].propertyName === columnDef.propertyName) {\n                columnIndex = i;\n                break;\n              }\n            }\n          }\n\n          columnProvider.hideColumn(columnIndex);\n        }\n\n        tableCtrl.updateColumnVisibility(columnDef.field);\n\n        if (columnDef.filter && columnDef.filter.isFilterApplied) {\n          const eventData = {\n            gridId: gridid,\n            column: columnDef\n          };\n          eventBus.publish('pltable.columnFilterApplied', eventData);\n        }\n      } else {\n        localeService.getLocalizedText('UIMessages', 'hideColumnOnlyVisibleError').then(function (message) {\n          messagingService.showError(message);\n        });\n      }\n    }\n  };\n\n  let resetDynamicRowHeights = function () {\n    if (dataProvider.viewModelCollection) {\n      _.forEach(dataProvider.viewModelCollection.loadedVMObjects, function (vmo) {\n        delete vmo.rowHeight;\n      });\n    }\n  };\n\n  let resetInfiniteScroll = function () {\n    if (tableScroll && tableScroll.isInitialized()) {\n      tableScroll.resetInfiniteScroll();\n    }\n  };\n\n  let maintainScrollPosition = function () {\n    tableScroll.setScrollPositionToBeMaintained();\n  };\n\n  let unsetScrollToRowIndex = function () {\n    if (tableScroll && tableScroll.isInitialized()) {\n      tableScroll.resetInitialRowIndex();\n    }\n  };\n\n  let relatedModified = function () {\n    if (listenToRelatedModifiedEvent) {\n      listenToRelatedModifiedEvent = false;\n      var selectionModel = dataProvider.selectionModel;\n\n      if (selectionModel) {\n        selectionHelper.handleSelectionEvent([targetVMOScoped], selectionModel, null, dataProvider);\n        SPLMTableSelectionHelper.updateContentRowSelection(dataProvider.selectionModel, dataProvider.cols, _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table);\n      }\n    }\n  };\n\n  let columnsResized = function (eventData) {\n    // Prevent columnSizeChanged for transpose mode since the columns in transpose represent VMOs\n    // and not the columns in the columnProvider\n    if (gridOptions.transpose !== true) {\n      columnProvider.columnSizeChanged(eventData.name, eventData.delta);\n    }\n\n    if (table._tableInstance.dynamicRowHeightStatus) {\n      resetDynamicRowHeights();\n      clientRefresh();\n    }\n  };\n\n  let columnsRearranged = function (eventData) {\n    if (gridOptions.transpose === true) {\n      // Update the dom columns so they reflect correct data\n      // and return since the columns represent VMOs and not the columns in\n      // the columnProvider\n      resetColumns();\n      return;\n    } // Get column position in relation to all columns, not just visible columns\n\n\n    var originalPosition = eventData.originalPosition;\n    var newPosition = null; // Get new position index\n\n    _.forEach(dataProvider.cols, function (column) {\n      if (eventData.name === column.name) {\n        newPosition = column.index;\n      }\n    }); // Adjust for hidden columns\n\n\n    _.forEach(dataProvider.cols, function (column, index) {\n      if (column.hiddenFlag === true && index <= newPosition) {\n        newPosition += 1;\n      }\n\n      if (column.hiddenFlag === true && index <= originalPosition) {\n        originalPosition += 1;\n      }\n    }); // awColumnService adjusts the column positions when the icon column is not present.\n    // By incrementing the positions by 1, we are able to ensure awColumnService still uses\n    // the correct column positions. Once  UI-Grid is removed, we can remove this hack and update awColumnService\n    // to not adjust positions when icon column is not present.\n\n\n    if (dataProvider.cols && dataProvider.cols[0].name !== 'icon') {\n      originalPosition += 1;\n      newPosition += 1;\n    }\n\n    if (originalPosition !== null && newPosition !== null) {\n      columnProvider.columnOrderChanged(eventData.name, originalPosition, newPosition);\n    }\n  };\n\n  return {\n    getDynamicRowHeightStatus: function () {\n      return table._tableInstance.dynamicRowHeightStatus;\n    },\n    resetDynamicRowHeights: resetDynamicRowHeights,\n    updateDynamicRowHeight: updateDynamicRowHeight,\n    maintainScrollPosition: maintainScrollPosition,\n    unsetScrollToRowIndex: unsetScrollToRowIndex,\n    relatedModified: relatedModified,\n    columnsResized: columnsResized,\n    columnsRearranged: columnsRearranged,\n    resetInfiniteScroll: resetInfiniteScroll,\n    getTableElement: function () {\n      return table;\n    },\n    updateContentRowSelection: updateContentRowSelection,\n    updateContainerHeight: updateContainerHeight,\n    updateSortDirection: updateSortDirection,\n    updatePinColumn: updatePinColumn,\n    hideColumn: hideColumn,\n\n    /**\n     * Reset columns for PL Table\n     * this method out of exports.initializeTable, cannot do it now since it depends on dataProvider\n     * any other members whose scope is inside initializeTable.\n     */\n    resetColumns: function () {\n      resetColumns();\n    },\n    updateEditState: updateEditState,\n    removeStaleFilters: function (columns) {\n      awColumnFilterService.removeStaleFilters(columnProvider, columns || _tableColumns);\n    },\n    setNodeExpansionInProgress: function (isInProgress) {\n      _nodeExpansionInProgress = isInProgress;\n    },\n    updateFilterIcons: function (columnName) {\n      if (columnName) {\n        tableCtrl.updateFilterIcon(columnName);\n      } else {\n        tableCtrl.updateAllFilterIcons();\n      }\n    },\n    setFilterDisability: function (isDisabled) {\n      menuService.setFilterDisability(isDisabled);\n    },\n    loadMissingProps: function () {\n      loadMissingProps();\n    },\n    updateTreeCellIcon: function (vmo) {\n      const rowContents = _trv.queryAllRowCellElementsFromTable();\n\n      _.forEach(rowContents, function (rowElem) {\n        if (rowElem.vmo) {\n          const matchingId = _contentFilter.isIdOfObject(rowElem.vmo, uwUtilSvc.getEvaluatedId(vmo));\n\n          if (matchingId === true) {\n            // Only update if there is expand/collapse button available\n            let treeNodeCommandElement = rowElem.querySelector(`.${Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD}`);\n\n            if (treeNodeCommandElement) {\n              const iconCell = getIconCellSVG(vmo); // this if check is for the vmo.isLeaf use case where there is no need to render an icon\n\n              let iconContainerElement = treeNodeCommandElement.querySelector(`.${Const.CLASS_ICON_BASE}`);\n\n              if (iconContainerElement && iconCell && iconCell.image && iconCell.image.length > 0) {\n                // add both for consistency, same as AwIcon\n                iconContainerElement = util.addAttributeToDOMElement(iconContainerElement, 'iconId', iconCell.id);\n                iconContainerElement = util.addAttributeToDOMElement(iconContainerElement, 'icon-id', iconCell.id);\n                treeNodeCommandElement.title = vmo._twistieTitle;\n                iconContainerElement.innerHTML = iconCell.image;\n              }\n            }\n          }\n        }\n      });\n    },\n\n    /**\n     * Refreshes the content in the table with the data currently in the dataProvider\n     */\n    refresh: refresh,\n    updateInstanceState: function (newState) {\n      declViewModel = newState;\n      table._tableInstance.declViewModel = newState;\n    }\n  };\n};\n/**\n *  Release the resources occupied by SPLM table\n *\n * @param {String} gridId - Grid ID to be destroyed\n * @param {Element} tableElement - The table element\n * @param {Object} columnDefs - The column defs\n */\n\nexport let destroyTable = function (gridId, tableElement, columnDefs) {\n  var table = tableElement.querySelector(`.${Const.CLASS_TABLE}`);\n  var instance = table && table._tableInstance || {};\n  var instanceEventSubcr = instance.subDefs;\n\n  _.forEach(instanceEventSubcr, function (eventBusSub) {\n    if (eventBusSub !== null) {\n      eventBus.unsubscribe(eventBusSub);\n    }\n  });\n\n  for (var i = 0; i < columnDefs.length; i++) {\n    var cellRenderers = columnDefs[i].cellRenderers;\n\n    if (cellRenderers) {\n      for (var j = 0; j < cellRenderers.length; j++) {\n        if (_.isFunction(cellRenderers[j].destroy)) {\n          cellRenderers[j].destroy();\n        }\n      }\n    }\n  } // Cleanup any leftover components\n\n\n  util.cleanupComponents(tableElement); // Destroy the column/table menu\n\n  var menu = document.getElementById(gridId + '_menuContainer');\n\n  if (menu !== null) {\n    menu.parentElement.removeChild(menu);\n  } // Destroy table renderer\n\n\n  if (instance.renderer) {\n    instance.renderer.destroyGrid();\n  } // table editor eventBusSubs unsubscribe\n\n\n  if (instance.editor) {\n    instance.editor.destroy();\n  } // NOTE: This is not need for now since we force every\n  // angularJS Compile must based on table scope. But leave\n  // it here for now by commenting it out.\n  // var cellRenderer = _cellRendererDefs[gridId];\n  // cellRenderer.destroyHoverCommandElement();\n  // delete _cellRendererDefs[gridId];\n\n\n  instance.isDestroyed = true;\n  eventBus.publish('tableDestroyed');\n};\n_splmTableMessages.arrangeMenu = localeService.getLoadedTextFromKey('treeTableMessages.arrangeMenu');\n_splmTableMessages.removeAllFilters = localeService.getLoadedTextFromKey('treeTableMessages.removeAllFilters');\n_splmTableMessages.TwistieTooltipExpanded = localeService.getLoadedTextFromKey('treeTableMessages.TwistieTooltipExpanded');\n_splmTableMessages.TwistieTooltipCollapsed = localeService.getLoadedTextFromKey('treeTableMessages.TwistieTooltipCollapsed');\n_splmTableMessages.hideColumn = localeService.getLoadedTextFromKey('treeTableMessages.hideColumn');\n_splmTableMessages.sortAscending = localeService.getLoadedTextFromKey('treeTableMessages.sortAscending');\n_splmTableMessages.sortDescending = localeService.getLoadedTextFromKey('treeTableMessages.sortDescending');\n_splmTableMessages.removeSort = localeService.getLoadedTextFromKey('treeTableMessages.removeSort');\n_splmTableMessages.freezeMenu = localeService.getLoadedTextFromKey('treeTableMessages.freezeMenu');\n_splmTableMessages.unfreezeMenu = localeService.getLoadedTextFromKey('treeTableMessages.unfreezeMenu');\n_splmTableMessages.visibilityControlsTitle = localeService.getLoadedTextFromKey('treeTableMessages.visibilityControlsTitle');\n_splmTableMessages.gridMenu = localeService.getLoadedTextFromKey('treeTableMessages.gridMenu');\nexports = {\n  createTableObject,\n  destroyTable\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableFactory.js"],"names":["exports","_splmTableMessages","_defaultContentFilter","isIdOfObject","matchedId","vmo","dom","domUtils","createTableObject","_tableColumns","_contentFilter","contentFilter","cellRenderer","awSPLMTableCellRendererFactory","table","util","_trv","tableCtrl","tableEditor","menuService","_nodeExpansionInProgress","tableScroll","columnRearrangementService","keyboardService","updateEditState","_showCheckBox","_rowBorderWidth","_rowHeight","appCtxService","Const","_headerHeight","_updateColumnDefs","columns","dataProvider","gridOptions","SPLMTableTranspose","i","column","_","getObjects","resetColumns","awColumnFilterService","findVMOsWithMissingProps","emptyVMOs","keys","Object","loadMissingProps","firstRenderedItemIndex","lastRenderedItemIndex","eventBus","gridid","VMOs","instanceEventSubcr","getContainerHeight","containerHeight","ctx","messages","declViewModel","viewModelCollection","columnProvider","gridId","isBulkEditing","isCellEditing","renderer","dynamicRowHeightStatus","runActionWithViewModel","tableContext","showCheckBox","_loadMorePageDebounce","firstRenderedItem","lastRenderedItem","pendingUpdatedProps","updateRowContents","rowElements","rowElem","updatedVmo","cellElem","needsUpdate","imgElem","updatedProps","Cell","cellTop","cellCommand","updatePendingProps","updatedPropName","loadProps","updateEditStatusForTableCanvas","_setupTreeForRestrictiveEditing","eventData","isEditing","gridContextDispatcher","type","resetDynamicRowHeights","clientRefresh","reusable","dataSource","state","_editingState","_updateAllRowsVisibilityDebounce","row","cellTopElem","iconCellElem","columnDef","newCellTop","resetInfiniteScroll","verdict","oldHeight","data","newContainerHeight","scrollContainer","oldScrollTop","isReusable","SPLMTableSelectionHelper","scrollToRow","rowIndexes","rowUids","uid","rowIndex","updateDecoratorVisibility","isEnabled","decoratorToggle","showDecorators","event","updateVMOs","vmCollection","rowNdx","tableInstanceCallbacks","getTargetVmo","targetObjects","elementRow","element","targetUid","sourceObjects","clearRowSelection","targetVMO","listenToRelatedModifiedEvent","targetVMOScoped","selectTarget","isTextNodeDragged","dataTranferObj","newCallbackApis","clearSelection","setSelection","getTargetElementAndVmo","target","targetElement","highlightTarget","splmTableDragHandler","registerSplmTableDndListner","getEventCallbackFn","isSourceEle","callbackApis","fun","setListener","eventType","callBackFn","setEventListener","providers","providerName","dragProviders","declDragAndDropService","dropProviders","directiveElement","dragAndDropService","getIconCellSVG","id","image","miscInProcessIndicator","miscExpandedTree","miscCollapsedTree","updateContentRowSelection","updateSortDirection","refresh","columnAttrs","uwColumnInfo","searchInput","selection","tableElem","directiveElem","scrollViewportElem","pinViewportElem","rowSelector","rowHeight","headerHeight","loadedVMObjects","updateVisibleCells","updateScrollColumnsInView","onStartScroll","cellListElement","editCellElement","syncHeader","traversalTable","renderRows","subVMObjects","endIndex","insertBefore","scrollContents","pinContents","firstPinElement","firstScrollElement","firstRowIdx","parseInt","pinContentElement","scrollContentElement","node","rowContents","elementToFocus","removeRows","afterGridRenderCallback","containerElement","activedescendantId","document","loadingProps","nonPlaceholderFound","j","vmObject","expandNode","setContainerHeightEvent","updateContainerHeight","updateDynamicRowHeight","updatePinColumn","pinColumnIndex","isFreezeAction","hideColumn","columnFieldName","currentColumn","columnIndex","isOnlyVisibleColumn","localeService","messagingService","maintainScrollPosition","unsetScrollToRowIndex","relatedModified","selectionModel","selectionHelper","columnsResized","columnsRearranged","originalPosition","newPosition","index","getDynamicRowHeightStatus","getTableElement","removeStaleFilters","setNodeExpansionInProgress","updateFilterIcons","setFilterDisability","updateTreeCellIcon","matchingId","uwUtilSvc","treeNodeCommandElement","CLASS_WIDGET_TREE_NODE_TOGGLE_CMD","iconCell","iconContainerElement","CLASS_ICON_BASE","updateInstanceState","destroyTable","tableElement","CLASS_TABLE","instance","eventBusSub","columnDefs","cellRenderers","menu"],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service is the entry point for SPLM table. It initializes the table and renders it\n *\n * @module js/splmTableFactory\n */\nimport SPLMTableColumnRearrangement from 'js/splmTableColumnRearrangement';\nimport SPLMTableInfiniteScrollService from 'js/splmTableInfiniteScrollService';\nimport SPLMTableKeyboardService from 'js/splmTableKeyboardService';\nimport SPLMTableTranspose from 'js/splmTableTranspose';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport awColumnFilterService from 'js/awColumnFilterService';\nimport awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport domUtils from 'js/domUtils';\nimport dragAndDropService from 'js/dragAndDropService';\nimport eventBus from 'js/eventBus';\nimport localeService from 'js/localeService';\nimport selectionHelper from 'js/selectionHelper';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport uwUtilSvc from 'js/uwUtilService';\nimport messagingService from 'js/messagingService';\nimport { svgString as miscInProcessIndicator } from 'image/miscInProcessIndicator16.svg';\nimport { svgString as miscExpandedTree } from 'image/miscExpandedTree12.svg';\nimport { svgString as miscCollapsedTree } from 'image/miscCollapsedTree12.svg';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport Editor from 'js/splmTableEditor';\nimport MenuService from 'js/splmTableMenuService';\nimport Ctrl from 'js/splmTableDomController';\nimport Cell from 'js/splmTableCellRenderer';\nimport SPLMTableSelectionHelper from 'js/splmTableSelectionHelper';\n\n/**\n * Cached reference to the various AngularJS and AW services.\n */\nvar exports = {};\n\nvar _splmTableMessages = {};\n\nvar _defaultContentFilter = {\n    isIdOfObject: function( vmo, uid ) {\n        let matchedId = false;\n        if( vmo ) {\n            if( vmo.alternateID ) {\n                matchedId = vmo.alternateID === uid;\n            }\n\n            if( !matchedId && vmo.uid ) {\n                matchedId = vmo.uid === uid || vmo.uid.indexOf( uid ) !== -1;\n            }\n        }\n        return matchedId;\n    }\n};\n\nconst dom = domUtils.DOMAPIs;\n/**\n * Check if we are using a 'gridid' in the closest 'declViewModel' in the scope tree.<BR>\n * If so: Use it to display the aw-table data<BR>\n *\n */\nexport let createTableObject = function( directiveElement, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, contentFilter, gridOptions, containerHeight,\n    gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, tableContext, reusable, showCheckBox ) {\n    // 20180920: put it to null so that it will error out when there is an code error\n    var _tableColumns = null;\n    var _contentFilter = contentFilter || _defaultContentFilter;\n\n    // setup cell renderer\n    var cellRenderer = awSPLMTableCellRendererFactory.createCellRenderer();\n    var table = util.createElement( 'div' );\n    var _trv = new Trv( table );\n    var tableCtrl = null;\n    var tableEditor = null;\n    var menuService = null;\n    var _nodeExpansionInProgress = false;\n    let tableScroll = null;\n    let columnRearrangementService = null;\n    let keyboardService = null;\n    let updateEditState = null;\n    let _showCheckBox = showCheckBox;\n\n    // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n    // Define header and row height here to save computed CSS reading\n    var _rowBorderWidth = 1;\n    var _rowHeight = appCtxService.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n    _rowHeight = util.getTableRowHeight( gridOptions, _rowHeight );\n\n    var _headerHeight = Const.HEIGHT_HEADER;\n    _headerHeight = util.getTableHeaderHeight( gridOptions, _headerHeight );\n\n    // This updateColumnDefs function is called as part of the buildDynamicColumns.\n    let _updateColumnDefs = function() {\n        let columns = dataProvider.cols;\n        if( gridOptions.transpose === true ) {\n            // Get and assign transposed columns\n            columns = SPLMTableTranspose.getTransposedColumns( _tableColumns, dataProvider.viewModelCollection.loadedVMObjects );\n        }\n        for( let i = 0; i < columns.length; i++ ) {\n            columns[ i ].visible = !columns[ i ].hasOwnProperty( 'visible' ) || columns[ i ].visible;\n        }\n\n        _tableColumns = _.filter( columns, function( column ) {\n            if( column.visible ) {\n                return column;\n            }\n            return false;\n        } );\n\n        _.forEach( _tableColumns, function( column, index ) {\n            column.index = index;\n\n            if( !column.cellRenderers ) {\n                column.cellRenderers = [];\n            }\n            if( column.name === 'icon' && column.iconCellRenderer ) {\n                column.cellRenderers = column.cellRenderers.concat( column.iconCellRenderer );\n            }\n            column.cellRenderers = column.cellRenderers.concat( cellRenderer.getAwCellRenderers() );\n        } );\n\n        _.forEach( _tableColumns, function( column, index ) {\n            column.index = index;\n\n            if( !column.headerRenderers ) {\n                column.headerRenderers = [];\n            }\n\n            column.headerRenderers = column.headerRenderers.concat( cellRenderer.getAwHeaderRenderers() );\n        } );\n\n        menuService.loadDefaultColumnMenus();\n    };\n\n    let getObjects = function() {\n        if( !dataProvider.viewModelCollection ) {\n            return [];\n        }\n        if( gridOptions.transpose === true ) {\n            return SPLMTableTranspose.getTransposedVmos( dataProvider.cols, dataProvider.viewModelCollection.loadedVMObjects );\n        }\n        return dataProvider.viewModelCollection.loadedVMObjects;\n    };\n\n    let resetColumns = function() {\n        _updateColumnDefs();\n\n        awColumnFilterService.removeStaleFilters( columnProvider, _tableColumns );\n\n        // property loading has completed\n        tableCtrl.resetColumnDefs( _tableColumns );\n        // Table headers recreated, need to initialize column rearrangement\n        columnRearrangementService.initialize();\n\n        // Trick for update scroll container position\n        if( tableScroll.isInitialized() ) {\n            cellRenderer.resetHoverCommandElement();\n            tableScroll.setLoadedVMObjects( getObjects() );\n            tableScroll.handleScroll();\n        }\n    };\n\n    /**\n     * Finds VMOs with undefined props within the specified range.\n     *\n     * @param {int} startIndex - starting VMO index\n     * @param {int} endIndex - edning VMO index\n     */\n    var findVMOsWithMissingProps = function( startIndex, endIndex ) {\n        var emptyVMOs = [];\n\n        for( var i = startIndex; i <= endIndex; i++ ) {\n            var vmo = dataProvider.viewModelCollection.loadedVMObjects[ i ];\n            if( vmo.isPropLoading ) {\n                continue;\n            } else if( !vmo.props ) {\n                emptyVMOs.push( vmo );\n            } else {\n                var keys = Object.keys( vmo.props );\n\n                if( keys.length === 0 ) {\n                    emptyVMOs.push( vmo );\n                }\n            }\n        }\n\n        return emptyVMOs;\n    };\n\n    let loadMissingProps = function() {\n        var firstRenderedItemIndex = tableScroll.getFirstRenderedItemIndex();\n        var lastRenderedItemIndex = tableScroll.getLastRenderedItemIndex();\n        var emptyVMOs = findVMOsWithMissingProps( firstRenderedItemIndex, lastRenderedItemIndex );\n        if( emptyVMOs.length > 0 ) {\n            eventBus.publish( gridid + '.plTable.loadProps', {\n                VMOs: emptyVMOs\n            } );\n        }\n    };\n\n    if( gridid ) {\n        var instanceEventSubcr = [];\n\n        // Do essential table DOM Element initialization for further processing\n        table.id = gridid;\n\n        table.classList.add( Const.CLASS_TABLE );\n        table.classList.add( Const.CLASS_WIDGET_GRID );\n        table.classList.add( Const.CLASS_LAYOUT_COLUMN );\n        table.classList.add( Const.CLASS_WIDGET_TABLE_DROP );\n        table.classList.add( Const.CLASS_SELECTION_ENABLED );\n\n        util.setSortCriteriaOnColumns( columnProvider, dataProvider );\n\n        var getContainerHeight = function() {\n            if( containerHeight !== undefined ) {\n                return containerHeight;\n            }\n\n            if( gridOptions.maxRowsToShow !== undefined ) {\n                return ( _rowHeight + _rowBorderWidth ) * gridOptions.maxRowsToShow + Const.HEIGHT_HEADER;\n            }\n\n            return undefined;\n        };\n\n        tableScroll = new SPLMTableInfiniteScrollService( getContainerHeight() );\n\n        table._tableInstance = {\n            ctx: appCtxService.ctx,\n            messages: _splmTableMessages,\n            declViewModel: declViewModel,\n            dataProvider: dataProvider,\n            viewModelCollection: viewModelCollection,\n            columnProvider: columnProvider,\n            gridId: gridid,\n            gridOptions: gridOptions,\n            isBulkEditing: false,\n            isCellEditing: false,\n            renderer: tableScroll,\n            dynamicRowHeightStatus: false,\n            cellRenderer: cellRenderer,\n            runActionWithViewModel: runActionWithViewModel,\n            tableInstanceCallbacks,\n            tableContext: tableContext ? tableContext : {},\n            showCheckBox: showCheckBox\n        };\n\n        tableEditor = new Editor( table, directiveElement, gridContextDispatcher );\n        table._tableInstance.editor = tableEditor;\n        keyboardService = new SPLMTableKeyboardService( table, tableEditor );\n        keyboardService.setupKeyListener();\n        table._tableInstance.keyboardService = keyboardService;\n\n        menuService = new MenuService( table, directiveElement, table._tableInstance, gridContextDispatcher );\n\n        if( gridOptions.enableGridMenu ) {\n            menuService.addGridMenu();\n        }\n\n        if( gridOptions.showContextMenu === true ) {\n            menuService.setContextSelectionHelper( selectionHelper );\n        }\n\n        if( gridOptions.enableDynamicRowHeight ) {\n            table._tableInstance.dynamicRowHeightStatus = true;\n        }\n\n        _updateColumnDefs();\n\n        tableCtrl = new Ctrl( table, _tableColumns, tableEditor, gridContextDispatcher );\n        table._tableInstance.controller = tableCtrl;\n        table._tableInstance.editor = tableEditor;\n\n        // LCS-13247 Pagination SOA performance issue for Objectset Table\n        // - Put a debounce here to avoid possible sending traffic jam, the number\n        //   is from _pingRedrawDebounce from aw.table.controller\n        // - With debounce IE performance improves a lot and no impact to chrome performance,\n        //   so leave the debounce for all\n        var _loadMorePageDebounce = _.debounce( function( firstRenderedItem, lastRenderedItem ) {\n            eventBus.publish( gridid + '.plTable.loadMorePages', {\n                firstRenderedItem: firstRenderedItem,\n                lastRenderedItem: lastRenderedItem\n            } );\n        }, 500 );\n\n        var pendingUpdatedProps = {};\n\n        var updateRowContents = function( updatedPropsMaps ) {\n            var rowElements = _trv.queryAllRowCellElementsFromTable();\n            _.forEach( updatedPropsMaps, function( updatedProps, vmoUid ) {\n                _.forEach( rowElements, function( rowElem ) {\n                    _.forEach( rowElem.children, function( cellElem ) {\n                        // Check if the vmo has been updated, if not continue to next cell\n                        let updatedVmo = null;\n                        if( rowElem.vmo && rowElem.vmo.uid === vmoUid ) {\n                            updatedVmo = rowElem.vmo;\n                        } else if( gridOptions.transpose === true && cellElem.columnDef.vmo && cellElem.columnDef.vmo.uid === vmoUid ) {\n                            updatedVmo = cellElem.columnDef.vmo;\n                        } else {\n                            return;\n                        }\n\n                        var needsUpdate = false;\n                        if( cellElem.columnDef && cellElem.columnDef.name === 'icon' ||\n                            gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === 'icon' ) {\n                            var imgElem = cellElem.getElementsByTagName( 'img' )[ 0 ];\n                            if( imgElem && imgElem.getAttribute( 'src' ) !== util.getImgURL( updatedVmo ) ) {\n                                needsUpdate = true;\n                            }\n                        } else {\n                            for( var i = 0; i < updatedProps.length; i++ ) {\n                                if( cellElem.propName === updatedProps[ i ] ||\n                                    gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === updatedProps[ i ] ) {\n                                    needsUpdate = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if( needsUpdate ) {\n                            Cell.updateCell( cellElem, rowElem, table, tableEditor );\n                            if( rowElem.vmo.selected && ( cellElem.columnDef.isTableCommand || cellElem.columnDef.isTreeNavigation ) ) {\n                                let cellTop = cellElem.children[ 0 ];\n                                if( cellElem.columnDef.isTreeNavigation ) {\n                                    cellTop = cellElem.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' )[ 0 ];\n                                }\n                                if( cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length === 0 ) {\n                                    if( dataProvider.selectionModel && !dataProvider.selectionModel.multiSelectEnabled && dataProvider.selectionModel\n                                        .getCurrentSelectedCount() === 1 ) {\n                                        let cellCommand = awSPLMTableCellRendererFactory.createCellCommandElement( cellElem.columnDef, rowElem.vmo, true );\n                                        cellTop.appendChild( cellCommand );\n                                    }\n                                }\n                            }\n                        }\n                    } );\n                } );\n            } );\n        };\n\n        var updatePendingProps = _.debounce( function() {\n            // prevent from calling if table has been destroyed in meantime\n            if( !table._tableInstance.isDestroyed ) {\n                updateRowContents( pendingUpdatedProps );\n                pendingUpdatedProps = {};\n            }\n        }, 250 );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'viewModelObject.propsUpdated', function( updatedProps ) {\n            // Merge the updatedVmos into pendingUpdatedVmos\n            for( var vmoUid in updatedProps ) {\n                if( pendingUpdatedProps[ vmoUid ] === undefined ) {\n                    pendingUpdatedProps[ vmoUid ] = updatedProps[ vmoUid ];\n                } else {\n                    for( var i = 0; i < updatedProps[ vmoUid ].length; i++ ) {\n                        var updatedPropName = updatedProps[ vmoUid ][ i ];\n                        if( pendingUpdatedProps[ vmoUid ].indexOf( updatedPropName ) === -1 ) {\n                            pendingUpdatedProps[ vmoUid ].push( updatedPropName );\n                        }\n                    }\n                }\n            }\n            updatePendingProps();\n        } ) );\n\n        var loadProps = function( emptyVMOs ) {\n            eventBus.publish( gridid + '.plTable.loadProps', {\n                VMOs: emptyVMOs\n            } );\n        };\n\n        var editCellElement;\n\n        columnRearrangementService = new SPLMTableColumnRearrangement( table );\n\n        // 20180927: This is not related to global isEdit anymore, feel free\n        // to refactor:)\n        var updateEditStatusForTableCanvas = function( isEditing ) {\n            tableCtrl.setDraggable( !isEditing );\n            tableEditor.updateEditStatus( isEditing );\n        };\n\n        var _setupTreeForRestrictiveEditing = function( isEditing ) {\n            tableScroll.setupTreeEditScroll( isEditing );\n        };\n\n        updateEditState = function( eventData ) {\n            // We should not start edit for any non table cases.\n            // This should be started only for table cases and also based on the grid id you are on.\n            // PWA case the dataSource is the dataProvider, thus has no .dataProviders property (we check if it is the dataProvider in scope with .name)\n            // SWA case we have dataSource.dataProvider and can check with dataProviders[ dataProvider.name ]\n            if( tableCtrl && eventData.dataSource && ( eventData.dataSource.getAtomicData\n              && eventData.dataSource.getAtomicData().dpRef && eventData.dataSource.getAtomicData().dpRef.current\n              || eventData.dataSource.name === dataProvider.name ) ) {\n                var isEditing = eventData.state === 'partialSave' || eventData.state === 'starting';\n\n                // If saving, set all column filters to be stale as data could have changed\n                if( eventData.state === 'saved' ) {\n                    _.forEach( dataProvider.cols, function( column ) {\n                        awColumnFilterService.setColumnFilterStale( column );\n                    } );\n                    if( !util.isAutoSaveEnabled( table ) ) {\n                        tableEditor.clearPropIsEditableCache();\n                    }\n                    util.setIsCellEditing( table, false );\n                } else if( eventData.state === 'canceling' ) {\n                    tableEditor.clearPropIsEditableCache();\n                    util.setIsCellEditing( table, false );\n                }\n\n                // Enable vmo caching on collapse in edit mode\n                dataProvider.cacheCollapse = true;\n\n                util.setIsBulkEditing( table, isEditing );\n                gridContextDispatcher( {\n                    type: 'UPDATE_VALUES',\n                    isBulkEditing: table._tableInstance.isBulkEditing,\n                    dynamicRowHeightStatus: table._tableInstance.dynamicRowHeightStatus\n                } );\n\n                tableCtrl.setSelectable( !isEditing );\n\n                if( util.isCellEditing( table ) === false || util.isCellEditing( table ) && !util.isAutoSaveEnabled( table ) ) {\n                    updateEditStatusForTableCanvas( isEditing );\n                }\n\n                if( gridOptions.useTree && !util.isExpandOrPaginationAllowedInEdit( table ) ) {\n                    _setupTreeForRestrictiveEditing( isEditing );\n                }\n\n                if( !isEditing ) {\n                    // Restore original cache collapse state when leaving edit mode\n                    dataProvider.restoreInitialCacheCollapseState();\n                }\n                if( table._tableInstance.dynamicRowHeightStatus === true ) {\n                    resetDynamicRowHeights();\n                    clientRefresh();\n                }\n            }\n        };\n\n        instanceEventSubcr.push( eventBus.subscribe( dataProvider._eventTopicEditInProgress, function() {\n            if ( reusable !== true ) {\n                const eventData = {\n                    dataSource: dataProvider,\n                    state: dataProvider._editingState\n                };\n                updateEditState( eventData );\n            }\n        } ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( declViewModel._internal.eventTopicEditInProgress, function() {\n            const eventData = {\n                dataSource: declViewModel,\n                state: declViewModel._editingState\n            };\n            updateEditState( eventData );\n        } ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'plTable.editStateChange', function( eventData ) {\n            updateEditState( eventData );\n        } ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'editHandlerStateChange', function( eventData ) {\n            updateEditState( eventData );\n        } ) );\n\n        var _updateAllRowsVisibilityDebounce = _.debounce( function() {\n            var rowElements = _trv.queryAllRowCellElementsFromTable();\n            _.forEach( rowElements, function( row ) {\n                if( row.vmo ) {\n                    var cellTopElem = row.getElementsByClassName( Const.CLASS_SPLM_TABLE_ICON_CELL )[ 0 ];\n                    if( !cellTopElem ) {\n                        cellTopElem = row.getElementsByClassName( Const.CLASS_AW_TREE_COMMAND_CELL )[ 0 ];\n                    }\n                    if( cellTopElem ) {\n                        var iconCellElem = cellTopElem.parentElement;\n                        var columnDef = iconCellElem.columnDef;\n                        var newCellTop = Cell.createElement( columnDef, row.vmo, table, row );\n                        iconCellElem.replaceChild( newCellTop, cellTopElem );\n                    }\n                }\n            } );\n        }, 100 );\n\n        /**\n         * Subscribe to resetScroll. Clear the tables rendered items cache and scroll to top of table.\n         */\n        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.resetScroll', function() {\n            resetInfiniteScroll();\n        } ) );\n\n        var verdict = util.validateRowHeightGridOption( table._tableInstance.gridOptions );\n        /**\n         * Subscribe to LayoutChangeEvent. Update row height to correct value\n         */\n        if( verdict === false ) {\n            instanceEventSubcr.push( eventBus.subscribe( 'LayoutChangeEvent', function( data ) {\n                var oldHeight = _rowHeight;\n                _rowHeight = data.rowHeight;\n                if( oldHeight === _rowHeight ) {\n                    return;\n                }\n                if( tableScroll.isInitialized() ) {\n                    tableScroll.setRowHeight( _rowHeight + _rowBorderWidth );\n\n                    var newContainerHeight = getContainerHeight();\n                    if( newContainerHeight !== undefined ) {\n                        tableScroll.setContainerHeight( newContainerHeight );\n                    }\n                    // Reinitialize properties so that the rendering calculations are valid\n                    tableScroll.initializeProperties();\n\n                    // Reset dynamic row height if enabled\n                    if( table._tableInstance.dynamicRowHeightStatus ) {\n                        resetDynamicRowHeights();\n                    }\n\n                    tableScroll.updateRowAlignment();\n\n                    // Scroll to rows in that were in view before layout change\n                    var scrollContainer = _trv.getScrollCanvasElementFromTable();\n                    var oldScrollTop = scrollContainer.scrollTop;\n                    scrollContainer.scrollTop = oldScrollTop / oldHeight * _rowHeight;\n                    tableScroll.handleScroll();\n                }\n            } ) );\n        }\n\n        // Reusable table does not need below named events for selection changes, it will now work with selectionData.\n        let isReusable = _.isString( reusable ) ?  reusable === 'true' : reusable;\n        if (  isReusable !== true ) {\n            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectionChangeEvent', function() {\n                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );\n            } ) );\n\n            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectAll', function() {\n                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );\n            } ) );\n\n            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectNone', function() {\n                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );\n            } ) );\n        }\n\n        instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.visibilityStateChanged', _updateAllRowsVisibilityDebounce ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.resizeCheck', function() {\n            if( tableScroll.isInitialized() ) {\n                tableScroll.checkForResize();\n            }\n        } ) );\n\n        var scrollToRow = function( gridId, rowUids ) {\n            if( gridid === gridId ) {\n                if( util.isBulkEditing( table ) ) {\n                    return;\n                }\n                var rowIndexes = [];\n                for( var i = 0; i < rowUids.length; i++ ) {\n                    var uid = rowUids[ i ].uid ? rowUids[ i ].uid : rowUids[ i ];\n                    var rowIndex = dataProvider.viewModelCollection.findViewModelObjectById( uid );\n                    if( rowIndex !== -1 ) {\n                        rowIndexes.push( rowIndex );\n                    }\n                }\n                if( rowIndexes.length > 0 ) {\n                    tableScroll.scrollToRowIndex( rowIndexes );\n                }\n            }\n        };\n\n        instanceEventSubcr.push( eventBus.subscribe( 'plTable.scrollToRow', function( eventData ) {\n            scrollToRow( eventData.gridId, eventData.rowUids );\n        } ) );\n\n        var updateDecoratorVisibility = function( isEnabled ) {\n            if( isEnabled === true && gridOptions.showDecorators !== false ) {\n                table.classList.add( Const.CLASS_AW_SHOW_DECORATORS );\n            } else {\n                table.classList.remove( Const.CLASS_AW_SHOW_DECORATORS );\n            }\n        };\n\n        var decoratorToggle = 'decoratorToggle';\n\n        var showDecorators = appCtxService.getCtx( decoratorToggle );\n        updateDecoratorVisibility( showDecorators );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'appCtx.register', function( event ) {\n            if( event.name === decoratorToggle ) {\n                updateDecoratorVisibility( event.value );\n            }\n        } ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'appCtx.update', function( event ) {\n            if( event.name === decoratorToggle ) {\n                updateDecoratorVisibility( event.value.decoratorToggle );\n            }\n        } ) );\n\n        instanceEventSubcr.push( eventBus.subscribe( 'decoratorsUpdated', function( updateVMOs ) {\n            updateVMOs = updateVMOs.length === undefined ? [ updateVMOs ] : updateVMOs;\n            tableCtrl.updateColorIndicatorElements( updateVMOs );\n        } ) );\n\n        /**\n         * React to request for node expansions.\n         */\n        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.expandTreeNode', function( eventData ) {\n            if( eventData.parentNode ) {\n                var vmCollection = dataProvider.getViewModelCollection();\n\n                var rowNdx = vmCollection.findViewModelObjectById( eventData.parentNode.id );\n\n                if( rowNdx !== -1 ) {\n                    var vmo = vmCollection.getViewModelObject( rowNdx );\n                    if( vmo.isExpanded !== true ) {\n                        vmo.isExpanded = true;\n                        if( tableInstanceCallbacks.toggleTreeNode ) {\n                            tableInstanceCallbacks.toggleTreeNode( vmo );\n                        } else {\n                            eventBus.publish( table.id + '.plTable.toggleTreeNode', vmo );\n                        }\n                    }\n                }\n            }\n        } ) );\n\n        const getTargetVmo = function( element, isTarget ) {\n            /**\n             * Merge event 'target' with any other objects currently selected.\n             */\n            var targetObjects = [];\n\n            var elementRow = element.classList.contains( Const.CLASS_ROW ) ? element : util.closestElement( element, '.' + Const.CLASS_ROW );\n\n            if( elementRow && elementRow.vmo ) {\n                targetObjects.push( elementRow.vmo );\n                var targetUid = elementRow.vmo.uid;\n\n                if( !isTarget ) {\n                    var sourceObjects = dragAndDropService.getSourceObjects(\n                        dataProvider, targetUid ).filter( function( obj ) {\n                        return targetObjects.indexOf( obj ) === -1;\n                    } );\n                    targetObjects = targetObjects.concat( sourceObjects );\n                }\n\n                return targetObjects;\n            }\n\n            return null;\n        };\n\n        const clearRowSelection = ( targetVMO ) => { // eslint-disable-line\n            dataProvider.selectNone();\n        };\n\n        var listenToRelatedModifiedEvent = false;\n        var targetVMOScoped = null;\n        const selectTarget = ( targetElement, targetVMO ) => { // eslint-disable-line\n            /**\n             * Setup to listen when the 'drop' is complete\n             */\n            if ( !listenToRelatedModifiedEvent ) {\n                listenToRelatedModifiedEvent = true;\n                targetVMOScoped = targetVMO;\n            }\n        };\n\n        const isTextNodeDragged = ( dataTranferObj ) => {\n            if( dataTranferObj && dataTranferObj.types ) {\n                return event.type === 'dragstart' && [ ...dataTranferObj.types ].some( type => type === 'text/plain' || type === 'Text' );\n            }\n            return false;\n        };\n\n        let newCallbackApis = {\n            clearSelection: clearRowSelection,\n            setSelection: ( targetVMO ) => {\n                selectTarget( null, targetVMO );\n            },\n            getTargetElementAndVmo: ( event, isSourceEle ) => {\n                let targetVMO = null;\n                let target = null;\n                if( !isTextNodeDragged( event.dataTransfer ) ) {\n                    target = dom.closest( event.target, '.ui-grid-row' ) || dom.closest( event.target, '.aw-widgets-droppable' );\n                }\n                if( target ) {\n                    targetVMO = getTargetVmo( target, !isSourceEle );\n                }\n                return {\n                    targetElement: target,\n                    targetVMO: targetVMO\n                };\n            },\n            highlightTarget: ( eventData ) => {\n                splmTableDragHandler.handleDragDropHighlightPLTable( eventData );\n            }\n        };\n\n        const registerSplmTableDndListner = ( element, callbackApis, declViewModel, tableProvider ) => {\n            const getEventCallbackFn = ( event ) => {\n                let target = {};\n                let isSourceEle = event.type === 'dragstart';\n                if( callbackApis.getTargetElementAndVmo ) {\n                    target = callbackApis.getTargetElementAndVmo( event, isSourceEle );\n                }\n                let fun = declViewModel.dndHandler[ event.type ];\n                fun( event, target, callbackApis, tableProvider );\n            };\n            const setListener = ( eventType ) => {\n                let callBackFn = getEventCallbackFn.bind( null );\n                element.addEventListener( eventType, callBackFn );\n            };\n            const setEventListener = ( providers ) => {\n                Object.keys( providers ).forEach( ( providerName ) => {\n                    setListener( providerName.toLowerCase() );\n                } );\n            };\n            let dragProviders = declDragAndDropService.getDragHandler( declViewModel );\n            if( dragProviders ) {\n                setEventListener( dragProviders );\n            }\n            let dropProviders = declDragAndDropService.getDropHandler( declViewModel );\n            if( dropProviders ) {\n                setEventListener( dropProviders );\n            }\n        };\n        table._tableInstance.subDefs = instanceEventSubcr;\n\n        directiveElement.appendChild( table );\n\n        // Drag and drop service needs to be setup after table has been attached to the directive element so\n        // that it can properly get the scope.\n        if( gridOptions.enableDragAndDrop !== false ) {\n            /**\n             * LCS-315044: Setup the drag and drop with the new design pattern if drag and drop\n             * handlers are defined for table's container view.\n             *\n             * The branching is done to support AW, as AW is still consuming the old drag and drop pattern.\n             */\n            if( declDragAndDropService.areDnDHandelersDefined( declViewModel ) ) {\n                registerSplmTableDndListner( table, newCallbackApis, declViewModel, dataProvider );\n            }\n        } else {\n            dragAndDropService.disableDragAndDrop( table );\n        }\n    }\n\n    var getIconCellSVG = function( vmo ) {\n        if( vmo.loadingStatus ) {\n            return { id: 'miscInProcessIndicator', image: miscInProcessIndicator };\n        } else if( vmo.isLeaf ) {\n            // we made the decision to stop rendering 'typeBlankIcon' because (1) there is no visual difference, (2) we want\n            // to decrease the number of DOM elements and (3) we don't know the history of why it was there.\n            return {};\n        } else if( vmo.isExpanded ) {\n            return { id: 'miscExpandedTree', image: miscExpandedTree };\n        }\n        return { id: 'miscCollapsedTree', image: miscCollapsedTree };\n    };\n\n    let updateContentRowSelection = () => {\n        SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n            _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );\n    };\n\n    let updateSortDirection = ( currentColumnIndex, newColumnIndex, sortDirection ) => {\n        tableCtrl.setHeaderCellSortDirection( currentColumnIndex, newColumnIndex, sortDirection );\n    };\n\n    let refresh = function() {\n        var columnAttrs = [];\n\n        // attributesToInflate at server side cannot accept full name i.e typename.propertyname.\n        // we don't need to inflate the attributes or properties that are hidden.\n        _.forEach( dataProvider.cols, function( uwColumnInfo ) {\n            if( uwColumnInfo.field && uwColumnInfo.hiddenFlag !== true ) {\n                columnAttrs.push( uwColumnInfo.field );\n            }\n        } );\n\n        if( dataProvider && dataProvider.action && dataProvider.action.inputData ) {\n            dataProvider.action.inputData.searchInput = dataProvider.action.inputData.searchInput || {};\n            var searchInput = dataProvider.action.inputData.searchInput;\n\n            if( searchInput.attributesToInflate ) {\n                searchInput.attributesToInflate = _.union( searchInput.attributesToInflate, columnAttrs );\n            } else {\n                searchInput.attributesToInflate = columnAttrs;\n            }\n        }\n\n        // Since VMOs represent columns, we need to reset the columns also for transpose mode\n        if( gridOptions.transpose === true ) {\n            resetColumns();\n        }\n\n        // REFACTOR: infinite scroll code should be refactor to follow:\n        // 1. DOMElement should be the only interface for interaction between service and function\n        // 2. Lot of code below should be pull out from anonymous function, a initialize grid which\n        //    is taking 70 line of code is a bad smell.\n        if( !tableScroll.isInitialized() ) {\n            // Set initial scroll index before table initializes\n            if( dataProvider.isFocusedLoad ) {\n                var selection = dataProvider.getSelectedObjects();\n                if( selection.length === 1 ) {\n                    scrollToRow( gridid, [ selection[ 0 ].uid ] );\n                }\n            }\n\n            tableScroll.initializeGrid( {\n                tableElem: table,\n                directiveElem: directiveElement,\n                scrollViewportElem: _trv.getScrollCanvasElementFromTable(),\n                pinViewportElem: _trv.getPinCanvasElementFromTable(),\n                rowSelector: '.' + Const.CLASS_ROW,\n                rowHeight: _rowHeight + _rowBorderWidth,\n                headerHeight: _headerHeight,\n                dynamicRowHeightStatus: gridOptions.enableDynamicRowHeight,\n                loadedVMObjects: getObjects(),\n                updateVisibleCells: function( rowParentElem ) {\n                    tableCtrl.updateVisibleCells( rowParentElem );\n                },\n                updateScrollColumnsInView: function( scrollLeft, scrollContainerWidth ) {\n                    tableCtrl.updateScrollColumnsInView( scrollLeft, scrollContainerWidth );\n                },\n                onStartScroll: function() {\n                    if( !util.isBulkEditing( table ) || !editCellElement ) {\n                        return;\n                    }\n\n                    // Close drop down if it is open on the edit cell\n                    var cellListElement = editCellElement.getElementsByClassName( 'aw-jswidgets-popUpVisible' )[ 0 ];\n                    if( cellListElement ) {\n                        editCellElement.click();\n                    }\n                },\n                syncHeader: function( isPin, scrollLeft ) {\n                    let traversalTable = new Trv( table );\n                    util.syncHeader( traversalTable, isPin, scrollLeft );\n                },\n                renderRows: function( startIndex, endIndex ) {\n                    var subVMObjects = getObjects().slice( startIndex, endIndex + 1 );\n                    // Return if there is nothing to render\n                    if( subVMObjects.length === 0 ) {\n                        return;\n                    }\n                    if( gridOptions.useTree === true ) {\n                        let messages = gridOptions.textBundle ? gridOptions.textBundle : _splmTableMessages;\n                        _.forEach( subVMObjects, function( vmo ) {\n                            if( vmo.isLeaf ) {\n                                vmo._twistieTitle = '';\n                            } else {\n                                vmo._twistieTitle = vmo.isExpanded ? messages.TwistieTooltipExpanded : messages.TwistieTooltipCollapsed;\n                            }\n\n                            if( !util.isExpandAllowed( table ) ) {\n                                vmo._twistieTitle = '';\n                            }\n                        } );\n                    }\n                    var insertBefore = false;\n                    var scrollContents = _trv.getScrollContentElementFromTable();\n                    var pinContents = _trv.getPinContentElementFromTable();\n                    var firstPinElement = pinContents.childElementCount > 0 ? pinContents.childNodes[ 0 ] : 0;\n                    var firstScrollElement = scrollContents.childElementCount > 0 ? scrollContents.childNodes[ 0 ] : 0;\n                    if( firstScrollElement && firstScrollElement.getAttribute( 'data-indexNumber' ) ) {\n                        var firstRowIdx = parseInt( firstScrollElement.getAttribute( 'data-indexNumber' ) );\n                        insertBefore = firstRowIdx > startIndex;\n                    }\n                    var pinContentElement = tableCtrl.constructContentElement( subVMObjects, startIndex, _rowHeight, true );\n                    var scrollContentElement = tableCtrl.constructContentElement( subVMObjects, startIndex, _rowHeight, false );\n                    tableCtrl.setAriaLabelledAndDescribedBy( directiveElement, _trv.getTableContainerElementFromTable() );\n                    tableCtrl.setAriaRowCount( _trv.getTableContainerElementFromTable() );\n                    if( table._tableInstance.dynamicRowHeightStatus ) {\n                        tableCtrl.syncContentRowHeights( pinContentElement, scrollContentElement );\n                    }\n\n                    SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n                        pinContentElement.childNodes, scrollContentElement.childNodes, table );\n\n                    if( insertBefore ) {\n                        _trv.getPinContentElementFromTable().insertBefore( pinContentElement, firstPinElement );\n                        _trv.getScrollContentElementFromTable().insertBefore( scrollContentElement, firstScrollElement );\n                    } else {\n                        _trv.getPinContentElementFromTable().appendChild( pinContentElement );\n                        _trv.getScrollContentElementFromTable().appendChild( scrollContentElement );\n                    }\n\n                    if( table._tableInstance.focusTreeNodeExpandAfterRender ) {\n                        let node = table._tableInstance.focusTreeNodeExpandAfterRender;\n                        let rowContents = _trv.queryAllRowCellElementsFromTable();\n                        let rowElem = _.filter( rowContents, { vmo: node } )[ 0 ];\n                        if( rowElem ) {\n                            let elementToFocus = rowElem.getElementsByClassName( Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD )[ 0 ];\n                            elementToFocus && elementToFocus.focus();\n                        }\n                    }\n                },\n                removeRows: function( upperCount, lowerCounter ) {\n                    cellRenderer.resetHoverCommandElement();\n                    tableCtrl.removeContentElement( upperCount, lowerCounter );\n                    tableCtrl.setAriaRowCount( _trv.getTableContainerElementFromTable() );\n                },\n                afterGridRenderCallback: function( firstRenderedItem, lastRenderedItem ) {\n                    let containerElement = _trv.getTableContainerElementFromTable();\n                    if( containerElement && containerElement.hasAttribute( 'aria-activedescendant' ) ) {\n                        var activedescendantId = containerElement.getAttribute( 'aria-activedescendant' );\n                        if( !document.getElementById( activedescendantId ) ) {\n                            containerElement.removeAttribute( 'aria-activedescendant' );\n                        }\n                    }\n                    var isEditing = util.isBulkEditing( table );\n                    let loadingProps = false;\n\n                    if( isEditing ) {\n                        updateEditStatusForTableCanvas( isEditing );\n                    }\n\n                    if( gridOptions.useTree === true ) {\n                        if( _nodeExpansionInProgress === true ) {\n                            return;\n                        }\n\n                        var nonPlaceholderFound = false;\n                        for( var i = lastRenderedItem.index; i >= firstRenderedItem.index; i-- ) {\n                            var vmo = dataProvider.viewModelCollection.loadedVMObjects[ i ];\n\n                            if( dataProvider.focusAction ) {\n                                if( vmo._focusRequested ) {\n                                    return;\n                                }\n\n                                if( vmo.isPlaceholder ) { // ...use .isPlaceholder or .isFocusParent instead\n                                    if( nonPlaceholderFound ) {\n                                        delete vmo.isPlaceholder;\n\n                                        vmo._focusRequested = true;\n\n                                        tableInstanceCallbacks.doFocusPlaceHolder( vmo );\n                                        return;\n                                    }\n                                } else {\n                                    nonPlaceholderFound = true;\n                                }\n                            }\n                        }\n\n                        // Find and expand the first of any nodes that need to be expanded\n                        for( var j = firstRenderedItem.index; j <= lastRenderedItem.index; j++ ) {\n                            var vmObject = dataProvider.viewModelCollection.loadedVMObjects[ j ];\n                            var expandNode = false;\n\n                            if( vmObject.isLeaf !== true && vmObject._expandRequested !== true && vmObject.isExpanded !== true ) {\n                                // Mark for expansion if the node was already expanded\n                                if( util.performStateServiceAction( 'isNodeExpanded', declViewModel, gridid, vmObject ) ) {\n                                    expandNode = true;\n                                }\n                            }\n\n                            // Expand the node\n                            if( expandNode === true ) {\n                                vmObject.isExpanded = true;\n                                if( tableInstanceCallbacks.toggleTreeNode ) {\n                                    tableInstanceCallbacks.toggleTreeNode( vmObject );\n                                } else {\n                                    eventBus.publish( table.id + '.plTable.toggleTreeNode', vmObject );\n                                }\n\n                                return;\n                            }\n                        }\n\n                        // If any VMOs need props to be loaded, we will call for the props to be loaded and not\n                        // render the rows. The row rendering will then occur once they props have been loaded.\n                        var emptyVMOs = findVMOsWithMissingProps( firstRenderedItem.index, lastRenderedItem.index );\n                        if( emptyVMOs.length > 0 ) {\n                            loadProps( emptyVMOs );\n                            loadingProps = true;\n                        }\n                    }\n\n                    if( util.isPaginationAllowed( table ) ) {\n                        // _loadMorePageDebounce( firstRenderedItem, lastRenderedItem );\n                        if( tableInstanceCallbacks ) {\n                            _loadMorePageDebounce( firstRenderedItem, lastRenderedItem, tableInstanceCallbacks );\n                            tableInstanceCallbacks.loadMorePages( {\n                                firstRenderedItem: firstRenderedItem,\n                                lastRenderedItem: lastRenderedItem\n                            } );\n                        }\n                    }\n\n                    // Set scrollToRow to false after row is scrolled to and all\n                    // visible nodes around the scrolled to row are expanded\n                    if( dataProvider.scrollToRow === true && tableScroll.isInitialRowIndexInView() === true ) {\n                        dataProvider.scrollToRow = false;\n                    }\n                }\n            } );\n            tableScroll.renderInitialRows();\n            var setContainerHeightEvent = eventBus.subscribe(\n                gridid + '.plTable.containerHeightUpdated',\n                function( heightVal ) {\n                    updateContainerHeight( heightVal );\n                } );\n            instanceEventSubcr.push( setContainerHeightEvent );\n        } else {\n            // reset the row height cache\n            tableScroll.resetRowHeightCache();\n            // Set the loaded view model objects\n            tableScroll.setLoadedVMObjects( getObjects() );\n\n            // Render initial rows if at top of table\n            if( _trv.getScrollCanvasElementFromTable().scrollTop === 0 ) {\n                tableScroll.renderInitialRows();\n            } else {\n                tableScroll.handleScroll();\n            }\n        }\n    };\n\n    let clientRefresh = function() {\n        if( table && table._tableInstance ) {\n            table._tableInstance.showCheckBox = _showCheckBox;\n        }\n        util.cleanupComponents( table );\n        refresh();\n    };\n\n    let updateContainerHeight = function( heightVal ) {\n        tableScroll.setContainerHeight( heightVal );\n        tableScroll.initializeProperties();\n        tableScroll.handleScrollDown();\n    };\n\n    let updateDynamicRowHeight = function( dynamicRowHeightStatus ) {\n        table._tableInstance.dynamicRowHeightStatus = dynamicRowHeightStatus;\n        tableScroll.setDynamicRowHeight( table._tableInstance.dynamicRowHeightStatus );\n\n        clientRefresh();\n        if( !table._tableInstance.dynamicRowHeightStatus ) {\n            resetDynamicRowHeights();\n        }\n    };\n\n    let updatePinColumn = ( columnDef, isFreezeAction, defaultColumnPinIndex ) => {\n        const pinColumnIndex = isFreezeAction ? columnDef.index : defaultColumnPinIndex;\n        tableCtrl.pinToColumn( pinColumnIndex );\n        if( !isFreezeAction ) {\n            tableCtrl.resetFreezeScroll( columnDef.field );\n        }\n        tableScroll.handlePinViewportScrollbarPadding();\n    };\n\n    let hideColumn = ( columnFieldName ) => {\n        let columnDef;\n        var columns = dataProvider.cols;\n\n        _.forEach( columns, function( currentColumn ) {\n            if ( currentColumn.field === columnFieldName ) {\n                columnDef = currentColumn;\n                return false;\n            }\n        } );\n\n        if ( columnDef ) {\n            var columnIndex = columnDef.index;\n\n            let isOnlyVisibleColumn = true;\n            _.forEach( columns, function( currentColumn ) {\n                if( currentColumn.name !== columnDef.name && currentColumn.visible === true && currentColumn.name !== 'icon' ) {\n                    isOnlyVisibleColumn = false;\n                    return false;\n                }\n            } );\n\n            if( !isOnlyVisibleColumn ) {\n                if( columnProvider.isArrangeSupported() && columnProvider.hideColumn ) {\n                    // account for hidden columns\n                    if( dataProvider.cols[ columnIndex ].propertyName !== columnDef.propertyName ) {\n                        for( var i = 0; i < columns.length; i++ ) {\n                            if( columns[ i ].propertyName === columnDef.propertyName ) {\n                                columnIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    columnProvider.hideColumn( columnIndex );\n                }\n                tableCtrl.updateColumnVisibility( columnDef.field );\n\n                if( columnDef.filter && columnDef.filter.isFilterApplied ) {\n                    const eventData = {\n                        gridId: gridid,\n                        column: columnDef\n                    };\n                    eventBus.publish( 'pltable.columnFilterApplied', eventData );\n                }\n            } else {\n                localeService.getLocalizedText( 'UIMessages', 'hideColumnOnlyVisibleError' ).then( function( message ) {\n                    messagingService.showError( message );\n                } );\n            }\n        }\n    };\n\n    let resetDynamicRowHeights = function() {\n        if( dataProvider.viewModelCollection ) {\n            _.forEach( dataProvider.viewModelCollection.loadedVMObjects, function( vmo ) {\n                delete vmo.rowHeight;\n            } );\n        }\n    };\n\n    let resetInfiniteScroll = function() {\n        if( tableScroll && tableScroll.isInitialized() ) {\n            tableScroll.resetInfiniteScroll();\n        }\n    };\n\n    let maintainScrollPosition = function() {\n        tableScroll.setScrollPositionToBeMaintained();\n    };\n\n    let unsetScrollToRowIndex = function() {\n        if( tableScroll && tableScroll.isInitialized() ) {\n            tableScroll.resetInitialRowIndex();\n        }\n    };\n\n    let relatedModified = function() {\n        if ( listenToRelatedModifiedEvent ) {\n            listenToRelatedModifiedEvent = false;\n            var selectionModel = dataProvider.selectionModel;\n\n            if( selectionModel ) {\n                selectionHelper.handleSelectionEvent( [ targetVMOScoped ], selectionModel, null, dataProvider );\n                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,\n                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );\n            }\n        }\n    };\n\n    let columnsResized = function( eventData ) {\n        // Prevent columnSizeChanged for transpose mode since the columns in transpose represent VMOs\n        // and not the columns in the columnProvider\n        if( gridOptions.transpose !== true ) {\n            columnProvider.columnSizeChanged( eventData.name, eventData.delta );\n        }\n        if( table._tableInstance.dynamicRowHeightStatus ) {\n            resetDynamicRowHeights();\n            clientRefresh();\n        }\n    };\n    let columnsRearranged = function( eventData )  {\n        if( gridOptions.transpose === true ) {\n            // Update the dom columns so they reflect correct data\n            // and return since the columns represent VMOs and not the columns in\n            // the columnProvider\n            resetColumns();\n            return;\n        }\n        // Get column position in relation to all columns, not just visible columns\n        var originalPosition = eventData.originalPosition;\n        var newPosition = null;\n\n        // Get new position index\n        _.forEach( dataProvider.cols, function( column ) {\n            if( eventData.name === column.name ) {\n                newPosition = column.index;\n            }\n        } );\n\n        // Adjust for hidden columns\n        _.forEach( dataProvider.cols, function( column, index ) {\n            if( column.hiddenFlag === true && index <= newPosition ) {\n                newPosition += 1;\n            }\n\n            if( column.hiddenFlag === true && index <= originalPosition ) {\n                originalPosition += 1;\n            }\n        } );\n\n        // awColumnService adjusts the column positions when the icon column is not present.\n        // By incrementing the positions by 1, we are able to ensure awColumnService still uses\n        // the correct column positions. Once  UI-Grid is removed, we can remove this hack and update awColumnService\n        // to not adjust positions when icon column is not present.\n        if( dataProvider.cols && dataProvider.cols[ 0 ].name !== 'icon' ) {\n            originalPosition += 1;\n            newPosition += 1;\n        }\n\n        if( originalPosition !== null && newPosition !== null ) {\n            columnProvider.columnOrderChanged( eventData.name, originalPosition, newPosition );\n        }\n    };\n\n    return {\n        getDynamicRowHeightStatus: function() {\n            return table._tableInstance.dynamicRowHeightStatus;\n        },\n        resetDynamicRowHeights: resetDynamicRowHeights,\n        updateDynamicRowHeight: updateDynamicRowHeight,\n        maintainScrollPosition:maintainScrollPosition,\n        unsetScrollToRowIndex:unsetScrollToRowIndex,\n        relatedModified: relatedModified,\n        columnsResized: columnsResized,\n        columnsRearranged:columnsRearranged,\n        resetInfiniteScroll: resetInfiniteScroll,\n\n        getTableElement: function() {\n            return table;\n        },\n        updateContentRowSelection: updateContentRowSelection,\n        updateContainerHeight: updateContainerHeight,\n        updateSortDirection: updateSortDirection,\n        updatePinColumn: updatePinColumn,\n        hideColumn: hideColumn,\n        /**\n         * Reset columns for PL Table\n         * this method out of exports.initializeTable, cannot do it now since it depends on dataProvider\n         * any other members whose scope is inside initializeTable.\n         */\n        resetColumns: function() {\n            resetColumns();\n        },\n        updateEditState: updateEditState,\n        removeStaleFilters: function( columns ) {\n            awColumnFilterService.removeStaleFilters( columnProvider, columns || _tableColumns );\n        },\n        setNodeExpansionInProgress: function( isInProgress ) {\n            _nodeExpansionInProgress = isInProgress;\n        },\n        updateFilterIcons: function( columnName ) {\n            if( columnName ) {\n                tableCtrl.updateFilterIcon( columnName );\n            } else {\n                tableCtrl.updateAllFilterIcons();\n            }\n        },\n        setFilterDisability: function( isDisabled ) {\n            menuService.setFilterDisability( isDisabled );\n        },\n        loadMissingProps: function() {\n            loadMissingProps();\n        },\n        updateTreeCellIcon: function( vmo ) {\n            const rowContents = _trv.queryAllRowCellElementsFromTable();\n            _.forEach( rowContents, function( rowElem ) {\n                if( rowElem.vmo ) {\n                    const matchingId = _contentFilter.isIdOfObject( rowElem.vmo, uwUtilSvc.getEvaluatedId( vmo ) );\n                    if( matchingId === true ) {\n                        // Only update if there is expand/collapse button available\n                        let treeNodeCommandElement = rowElem.querySelector( `.${Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD}` );\n                        if( treeNodeCommandElement ) {\n                            const iconCell = getIconCellSVG( vmo );\n                            // this if check is for the vmo.isLeaf use case where there is no need to render an icon\n                            let iconContainerElement = treeNodeCommandElement.querySelector( `.${Const.CLASS_ICON_BASE}` );\n                            if( iconContainerElement && iconCell && iconCell.image && iconCell.image.length > 0 ) {\n                                // add both for consistency, same as AwIcon\n                                iconContainerElement = util.addAttributeToDOMElement( iconContainerElement, 'iconId', iconCell.id );\n                                iconContainerElement = util.addAttributeToDOMElement( iconContainerElement, 'icon-id', iconCell.id );\n\n                                treeNodeCommandElement.title = vmo._twistieTitle;\n                                iconContainerElement.innerHTML = iconCell.image;\n                            }\n                        }\n                    }\n                }\n            } );\n        },\n        /**\n         * Refreshes the content in the table with the data currently in the dataProvider\n         */\n        refresh: refresh,\n        updateInstanceState: function( newState ) {\n            declViewModel = newState;\n            table._tableInstance.declViewModel = newState;\n        }\n    };\n};\n\n/**\n *  Release the resources occupied by SPLM table\n *\n * @param {String} gridId - Grid ID to be destroyed\n * @param {Element} tableElement - The table element\n * @param {Object} columnDefs - The column defs\n */\nexport let destroyTable = function( gridId, tableElement, columnDefs ) {\n    var table = tableElement.querySelector( `.${Const.CLASS_TABLE}` );\n    var instance = table && table._tableInstance || {};\n    var instanceEventSubcr = instance.subDefs;\n    _.forEach( instanceEventSubcr, function( eventBusSub ) {\n        if( eventBusSub !== null ) {\n            eventBus.unsubscribe( eventBusSub );\n        }\n    } );\n\n    for( var i = 0; i < columnDefs.length; i++ ) {\n        var cellRenderers = columnDefs[ i ].cellRenderers;\n        if( cellRenderers ) {\n            for( var j = 0; j < cellRenderers.length; j++ ) {\n                if( _.isFunction( cellRenderers[ j ].destroy ) ) {\n                    cellRenderers[ j ].destroy();\n                }\n            }\n        }\n    }\n\n    // Cleanup any leftover components\n    util.cleanupComponents( tableElement );\n\n    // Destroy the column/table menu\n    var menu = document.getElementById( gridId + '_menuContainer' );\n    if( menu !== null ) {\n        menu.parentElement.removeChild( menu );\n    }\n\n    // Destroy table renderer\n    if( instance.renderer ) {\n        instance.renderer.destroyGrid();\n    }\n\n    // table editor eventBusSubs unsubscribe\n    if( instance.editor ) {\n        instance.editor.destroy();\n    }\n\n    // NOTE: This is not need for now since we force every\n    // angularJS Compile must based on table scope. But leave\n    // it here for now by commenting it out.\n    // var cellRenderer = _cellRendererDefs[gridId];\n    // cellRenderer.destroyHoverCommandElement();\n    // delete _cellRendererDefs[gridId];\n\n    instance.isDestroyed = true;\n\n    eventBus.publish( 'tableDestroyed' );\n};\n\n_splmTableMessages.arrangeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.arrangeMenu' );\n_splmTableMessages.removeAllFilters = localeService.getLoadedTextFromKey( 'treeTableMessages.removeAllFilters' );\n_splmTableMessages.TwistieTooltipExpanded = localeService.getLoadedTextFromKey( 'treeTableMessages.TwistieTooltipExpanded' );\n_splmTableMessages.TwistieTooltipCollapsed = localeService.getLoadedTextFromKey( 'treeTableMessages.TwistieTooltipCollapsed' );\n_splmTableMessages.hideColumn = localeService.getLoadedTextFromKey( 'treeTableMessages.hideColumn' );\n_splmTableMessages.sortAscending = localeService.getLoadedTextFromKey( 'treeTableMessages.sortAscending' );\n_splmTableMessages.sortDescending = localeService.getLoadedTextFromKey( 'treeTableMessages.sortDescending' );\n_splmTableMessages.removeSort = localeService.getLoadedTextFromKey( 'treeTableMessages.removeSort' );\n_splmTableMessages.freezeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.freezeMenu' );\n_splmTableMessages.unfreezeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.unfreezeMenu' );\n_splmTableMessages.visibilityControlsTitle = localeService.getLoadedTextFromKey( 'treeTableMessages.visibilityControlsTitle' );\n_splmTableMessages.gridMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.gridMenu' );\n\nexports = {\n    createTableObject,\n    destroyTable\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}