{"ast":null,"code":"/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This module provides the utility functions for supporting aw service.\n *\n * @module js/serviceUtils\n */\nimport _ from 'lodash';\n/**\n * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\n\nexport function httpGet(theUrl) {\n  return new Promise((resolve, reject) => {\n    var xmlHttp = new XMLHttpRequest();\n\n    xmlHttp.onreadystatechange = function () {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        resolve(xmlHttp.responseText);\n      }\n    };\n\n    xmlHttp.onerror = function (e) {\n      reject(e);\n    };\n\n    xmlHttp.open('GET', theUrl, true); // true for asynchronous\n\n    xmlHttp.send(null);\n  });\n}\n/**\n * simple http get for JSON specific and fake response data structure.\n * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\n\nexport function httpGetJsonObject(theUrl) {\n  return httpGet(theUrl).then(txt => {\n    return {\n      data: JSON.parse(txt)\n    };\n  });\n}\n/**\n * Quick check for if the expression can be splitted or not.\n *\n * NOTE: it is strictly based on logic in parseExpression, only handle the case that\n * parseExpression can handle\n * @param {String} expression The expression to parse.\n * @returns {Boolean} true if expression can be splitted.\n */\n\nexport const expressionCanSplit = expression => {\n  return expression.match(/[)(+\\-*/^!&|=><%?:]|\\['|'\\]/);\n};\n/**\n * Splits expression into sub expression\n * @param {String} expression - The expression which needs to broken\n * @returns {Array} - Array of sub expressions\n */\n\nexport const processExpression = expression => {\n  // remove trailing newline character which is added automatically\n  const characters = Array.from(expression.replace(/(\\r\\n|\\n|\\r)/gm, '').trim());\n  let stack = [];\n  let expr = '';\n  let ignoreQuotes = false;\n  characters.forEach((character, index) => {\n    if (character === '(') {\n      if (expr === '') {\n        stack.push('(');\n      } else {\n        expr = `${expr}${character}`;\n      }\n    } else if (character === ')') {\n      const temp = `${expr}${character}`;\n      const openBrackets = temp.split('(').length - 1;\n      const closedBrackets = temp.split(')').length - 1;\n\n      if (openBrackets === 0) {\n        if (expr !== '') {\n          stack.push({\n            expr\n          });\n          expr = '';\n        }\n\n        stack.push(')');\n      } else if (openBrackets > 0) {\n        if (openBrackets < closedBrackets) {\n          stack.push({\n            expr\n          });\n          expr = '';\n          stack.push(')');\n        } else {\n          expr = `${expr}${character}`;\n        }\n      } // stack.push( ')' );\n\n    } else if (/(\\+|-|\\*|\\/|\\^|!|&|\\||=|>|<|%|\\?|:)/.test(character)) {\n      if (character !== ':') {\n        // handle such expression that contains equal to ex- \"ctx.message\" === \"\"Hello=World\"\n        if (character === '=' && !(characters[index - 1] === '=' || characters[index - 1] === '!' || characters[index - 1] === '>' || characters[index - 1] === '<' || characters[index + 1] === '=')) {\n          expr = `${expr}${character}`;\n        } else {\n          if (expr !== '') {\n            stack.push({\n              expr\n            });\n            expr = '';\n          }\n\n          stack.push(character);\n        }\n      } else {\n        const qMark = _.filter(stack, element => element === '?').length;\n\n        const colans = _.filter(stack, element => element === ':').length;\n\n        if (qMark - colans > 0) {\n          if (expr !== '') {\n            stack.push({\n              expr\n            });\n            expr = '';\n          }\n\n          stack.push(character);\n        } else {\n          expr = `${expr}${character}`;\n        }\n      }\n    } else if (character === '[' && characters[index + 1] === '\\'') {\n      expr = `${expr}.`;\n      ignoreQuotes = true;\n    } else if (character === ']' && characters[index - 1] === '\\'') {\n      //DO not\n      ignoreQuotes = false;\n    } else if (character === '\\'' && !ignoreQuotes) {\n      expr = `${expr}${character}`;\n    } else if (character.trim() !== '' && character.trim() !== '\\'') {\n      expr = `${expr}${character}`;\n    }\n\n    if (index === characters.length - 1) {\n      //process expr\n      if (expr !== '') {\n        // expr = `${expr}${character}`;\n        stack.push({\n          expr\n        });\n        expr = '';\n      }\n    } // if()\n\n  });\n  return stack;\n};\n/**\n * This API evaluates expression against the evaluation context using dynamic function.\n * @param {Array} params - The parameter name array\n * @param {Array} paramValues - The parameter value array\n * @param {Object} applyObject - The apply Object\n * @param {String} expression - The expression which needs to be evaluated\n * @returns {Object} result\n */\n\nexport const parseNative = (params, paramValues, applyObject, expression) => {\n  if (params) {\n    params = params.map(param => param.includes('-') ? param.replace(/\\-/g, '_') : param);\n  }\n\n  return evalExpression(expression, params, paramValues, false, applyObject);\n};\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Array} params - The parameter name array\n * @param {Array} values - The parameter value array\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n *\n * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically\n */\n\nexport const evalExpression = (expr, params, values, ignoreError, applyObject) => {\n  try {\n    let sandBoxParams = ['window', 'document', 'eval', 'setTimeout', 'setInterval', 'XMLHttpRequest', 'Function'];\n    let sandBoxValues = [{}, {}, {}, {}, {}, {}, {}]; //Replace all dot(.) as . are not valid arguments of function\n\n    let newParams = params.map(ele => ele.indexOf('.') < 0 ? ele : ele.replace(/\\./g, ''));\n    let func = new Function(...newParams, ...sandBoxParams, `return ${expr};`);\n    return func.apply(applyObject, values, ...sandBoxValues);\n  } catch (e) {\n    if (!ignoreError) {\n      throw new Error(`evalExpression('${expr}') => ${e.message}`);\n    } else {\n      return undefined;\n    }\n  }\n};\n/**\n * This metthod splits an expression into Array of subExpressions.\n * @param {String} expression - The expression to be interpolated\n * @returns {Array} Array of sub expressions\n */\n\nexport const splitExpressionForInterpolate = expression => {\n  const startSyntax = '{{';\n\n  if (expression.includes(startSyntax) === false) {\n    return expression;\n  }\n\n  const endSyntax = '}}';\n  const splits = expression.split(startSyntax);\n  let finalSplits = [];\n\n  _.forEach(splits, split => {\n    if (split.includes(endSyntax)) {\n      const subSplits = split.split(endSyntax);\n\n      _.forEach(subSplits, (sSplit, index) => {\n        if (index === 0) {\n          finalSplits.push({\n            expr: sSplit\n          });\n        } else {\n          finalSplits.push(sSplit);\n        }\n      });\n    } else {\n      finalSplits.push(split);\n    }\n  });\n\n  return finalSplits;\n};\n/**\n * Decode value from string.\n * @param {String} val - decode string value\n * @returns {String} value String\n */\n\nexport function valFromString(val) {\n  return val !== null ? val.toString().replace(/(~~|~2F)/g, function (m) {\n    const constantMap = {\n      '~~': '~',\n      '~2F': '/'\n    };\n    return constantMap[m];\n  }) : val;\n}\nexport default {\n  httpGet,\n  httpGetJsonObject,\n  processExpression,\n  expressionCanSplit,\n  valFromString,\n  evalExpression\n};","map":{"version":3,"names":["_","httpGet","theUrl","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","onerror","e","open","send","httpGetJsonObject","then","txt","data","JSON","parse","expressionCanSplit","expression","match","processExpression","characters","Array","from","replace","trim","stack","expr","ignoreQuotes","forEach","character","index","push","temp","openBrackets","split","length","closedBrackets","test","qMark","filter","element","colans","parseNative","params","paramValues","applyObject","map","param","includes","evalExpression","values","ignoreError","sandBoxParams","sandBoxValues","newParams","ele","indexOf","func","Function","apply","Error","message","undefined","splitExpressionForInterpolate","startSyntax","endSyntax","splits","finalSplits","subSplits","sSplit","valFromString","val","toString","m","constantMap"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/serviceUtils.js"],"sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This module provides the utility functions for supporting aw service.\n *\n * @module js/serviceUtils\n */\nimport _ from 'lodash';\n\n/**\n * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\nexport function httpGet( theUrl ) {\n    return new Promise( ( resolve, reject ) => {\n        var xmlHttp = new XMLHttpRequest();\n        xmlHttp.onreadystatechange = function() {\n            if( xmlHttp.readyState === 4 && xmlHttp.status === 200 ) {\n                resolve( xmlHttp.responseText );\n            }\n        };\n\n        xmlHttp.onerror = function( e ) {\n            reject( e );\n        };\n\n        xmlHttp.open( 'GET', theUrl, true ); // true for asynchronous\n        xmlHttp.send( null );\n    } );\n}\n\n/**\n * simple http get for JSON specific and fake response data structure.\n * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\nexport function httpGetJsonObject( theUrl ) {\n    return httpGet( theUrl ).then( ( txt ) => {\n        return {\n            data: JSON.parse( txt )\n        };\n    } );\n}\n\n/**\n * Quick check for if the expression can be splitted or not.\n *\n * NOTE: it is strictly based on logic in parseExpression, only handle the case that\n * parseExpression can handle\n * @param {String} expression The expression to parse.\n * @returns {Boolean} true if expression can be splitted.\n */\nexport const expressionCanSplit = expression => {\n    return expression.match( /[)(+\\-*/^!&|=><%?:]|\\['|'\\]/ );\n};\n\n/**\n * Splits expression into sub expression\n * @param {String} expression - The expression which needs to broken\n * @returns {Array} - Array of sub expressions\n */\nexport const processExpression = expression => {\n    // remove trailing newline character which is added automatically\n    const characters = Array.from( expression.replace( /(\\r\\n|\\n|\\r)/gm, '' ).trim() );\n    let stack = [];\n    let expr = '';\n    let ignoreQuotes = false;\n    characters.forEach( ( character, index ) => {\n        if( character === '(' ) {\n            if( expr === '' ) {\n                stack.push( '(' );\n            } else {\n                expr = `${expr}${character}`;\n            }\n        } else if( character === ')' ) {\n            const temp = `${expr}${character}`;\n            const openBrackets = temp.split( '(' ).length - 1;\n            const closedBrackets = temp.split( ')' ).length - 1;\n            if( openBrackets === 0 ) {\n                if( expr !== '' ) {\n                    stack.push( { expr } );\n                    expr = '';\n                }\n                stack.push( ')' );\n            } else if( openBrackets > 0 ) {\n                if( openBrackets < closedBrackets ) {\n                    stack.push( { expr } );\n                    expr = '';\n                    stack.push( ')' );\n                } else {\n                    expr = `${expr}${character}`;\n                }\n            }\n            // stack.push( ')' );\n        } else if( /(\\+|-|\\*|\\/|\\^|!|&|\\||=|>|<|%|\\?|:)/.test( character ) ) {\n            if( character !== ':' ) {\n                // handle such expression that contains equal to ex- \"ctx.message\" === \"\"Hello=World\"\n                if( character === '=' && !( characters[ index - 1 ] === '=' || characters[ index - 1 ] === '!' || characters[ index - 1 ] === '>' || characters[ index - 1 ] === '<' ||\n                        characters[ index + 1 ] === '=' ) ) {\n                    expr = `${expr}${character}`;\n                } else {\n                    if( expr !== '' ) {\n                        stack.push( { expr } );\n                        expr = '';\n                    }\n                    stack.push( character );\n                }\n            } else {\n                const qMark = _.filter( stack, element => element === '?' ).length;\n                const colans = _.filter( stack, element => element === ':' ).length;\n                if( qMark - colans > 0 ) {\n                    if( expr !== '' ) {\n                        stack.push( { expr } );\n                        expr = '';\n                    }\n                    stack.push( character );\n                } else {\n                    expr = `${expr}${character}`;\n                }\n            }\n        } else if( character === '[' && characters[ index + 1 ] === '\\'' ) {\n            expr = `${expr}.`;\n            ignoreQuotes = true;\n        } else if( character === ']' && characters[ index - 1 ] === '\\'' ) {\n            //DO not\n            ignoreQuotes = false;\n        } else if( character === '\\'' && !ignoreQuotes ) {\n            expr = `${expr}${character}`;\n        } else if( character.trim() !== '' && character.trim() !== '\\'' ) {\n            expr = `${expr}${character}`;\n        }\n\n        if( index === characters.length - 1 ) {\n            //process expr\n            if( expr !== '' ) {\n                // expr = `${expr}${character}`;\n                stack.push( { expr } );\n                expr = '';\n            }\n        }\n        // if()\n    } );\n    return stack;\n};\n\n/**\n * This API evaluates expression against the evaluation context using dynamic function.\n * @param {Array} params - The parameter name array\n * @param {Array} paramValues - The parameter value array\n * @param {Object} applyObject - The apply Object\n * @param {String} expression - The expression which needs to be evaluated\n * @returns {Object} result\n */\nexport const parseNative = ( params, paramValues, applyObject, expression ) => {\n    if( params ) {\n        params = params.map( param => param.includes( '-' ) ? param.replace( /\\-/g, '_' ) : param );\n    }\n    return evalExpression( expression, params, paramValues, false, applyObject );\n};\n\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Array} params - The parameter name array\n * @param {Array} values - The parameter value array\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n *\n * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically\n */\nexport const evalExpression = ( expr, params, values, ignoreError, applyObject ) => {\n    try {\n        let sandBoxParams = [ 'window', 'document', 'eval', 'setTimeout', 'setInterval', 'XMLHttpRequest', 'Function' ];\n        let sandBoxValues = [ {}, {}, {}, {}, {}, {}, {} ];\n\n        //Replace all dot(.) as . are not valid arguments of function\n        let newParams = params.map( ele => ele.indexOf( '.' ) < 0 ? ele : ele.replace( /\\./g, '' ) );\n\n        let func = new Function( ...newParams, ...sandBoxParams, `return ${expr};` );\n        return func.apply( applyObject, values, ...sandBoxValues );\n    } catch ( e ) {\n        if( !ignoreError ) {\n            throw new Error( `evalExpression('${expr}') => ${e.message}` );\n        } else {\n            return undefined;\n        }\n    }\n};\n\n/**\n * This metthod splits an expression into Array of subExpressions.\n * @param {String} expression - The expression to be interpolated\n * @returns {Array} Array of sub expressions\n */\nexport const splitExpressionForInterpolate = expression => {\n    const startSyntax = '{{';\n    if( expression.includes( startSyntax ) === false ) {\n        return expression;\n    }\n    const endSyntax = '}}';\n    const splits = expression.split( startSyntax );\n    let finalSplits = [];\n    _.forEach( splits, split => {\n        if( split.includes( endSyntax ) ) {\n            const subSplits = split.split( endSyntax );\n            _.forEach( subSplits, ( sSplit, index ) => {\n                if( index === 0 ) {\n                    finalSplits.push( { expr: sSplit } );\n                } else {\n                    finalSplits.push( sSplit );\n                }\n            } );\n        } else {\n            finalSplits.push( split );\n        }\n    } );\n    return finalSplits;\n};\n\n/**\n * Decode value from string.\n * @param {String} val - decode string value\n * @returns {String} value String\n */\nexport function valFromString( val ) {\n    return val !== null ? val.toString().replace( /(~~|~2F)/g, function( m ) {\n        const constantMap = { '~~': '~', '~2F': '/' };\n        return constantMap[ m ];\n    } ) : val;\n}\n\nexport default {\n    httpGet,\n    httpGetJsonObject,\n    processExpression,\n    expressionCanSplit,\n    valFromString,\n    evalExpression\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}