{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * This is autogenerated file. If you hand modify this file, please remove this line.\n *\n * @module js/awInterpolateService\n */\nimport _ from 'lodash';\nimport { splitExpressionForInterpolate } from 'js/serviceUtils';\nimport AwParseService from 'js/awParseService';\nexport default class AwInterpolateService {\n  /**\n   * Algo\n   * 1. Spilt statment into statement + Filters by |\n   * 2. Evaluate expression then apply filters on it if any.\n   * @param {String} expression - The String expression which needs to be evaluated\n   * @returns {Object} the interpolate function\n   */\n  static instance(expression) {\n    return evalCtx => {\n      if (!expression) {\n        return undefined;\n      }\n\n      let expressions = splitExpressionForInterpolate(expression);\n      expressions = _.map(expressions, subExpr => {\n        if (subExpr.expr) {\n          let containsOR = false;\n          let localExpression = subExpr.expr;\n\n          if (localExpression.includes('||')) {\n            //Replace || for now till we split with |\n            localExpression = localExpression.replace(/\\|\\|/g, '@#@#');\n            containsOR = true;\n          }\n\n          if (/\\|/g.test(localExpression)) {\n            throw new Error('Filter expressions are not supported by interpolate');\n          }\n\n          if (containsOR) {\n            localExpression = localExpression.replace(/\\@\\#\\@\\#/g, '||');\n          } //If the length of the array is > 1 means filter exists, in that case 0th entry is going to be expression\n          //split removes seperators\n\n\n          const toParse = localExpression.trim();\n\n          try {\n            return AwParseService.instance(toParse)(evalCtx);\n          } catch (error) {\n            return undefined;\n          }\n        }\n\n        return subExpr;\n      });\n      return expressions.join('');\n    };\n  }\n\n}","map":{"version":3,"names":["_","splitExpressionForInterpolate","AwParseService","AwInterpolateService","instance","expression","evalCtx","undefined","expressions","map","subExpr","expr","containsOR","localExpression","includes","replace","test","Error","toParse","trim","error","join"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/awInterpolateService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * This is autogenerated file. If you hand modify this file, please remove this line.\n *\n * @module js/awInterpolateService\n */\nimport _ from 'lodash';\nimport { splitExpressionForInterpolate } from 'js/serviceUtils';\nimport AwParseService from 'js/awParseService';\nexport default class AwInterpolateService {\n    /**\n     * Algo\n     * 1. Spilt statment into statement + Filters by |\n     * 2. Evaluate expression then apply filters on it if any.\n     * @param {String} expression - The String expression which needs to be evaluated\n     * @returns {Object} the interpolate function\n     */\n    static instance( expression ) {\n        return evalCtx => {\n            if( !expression ) {\n                return undefined;\n            }\n            let expressions = splitExpressionForInterpolate( expression );\n            expressions = _.map( expressions, subExpr => {\n                if( subExpr.expr ) {\n                    let containsOR = false;\n                    let localExpression = subExpr.expr;\n                    if( localExpression.includes( '||' ) ) {\n                        //Replace || for now till we split with |\n                        localExpression = localExpression.replace( /\\|\\|/g, '@#@#' );\n                        containsOR = true;\n                    }\n                    if( /\\|/g.test( localExpression ) ) {\n                        throw new Error( 'Filter expressions are not supported by interpolate' );\n                    }\n                    if( containsOR ) {\n                        localExpression = localExpression.replace( /\\@\\#\\@\\#/g, '||' );\n                    }\n\n                    //If the length of the array is > 1 means filter exists, in that case 0th entry is going to be expression\n                    //split removes seperators\n                    const toParse = localExpression.trim();\n                    try {\n                        return AwParseService.instance( toParse )( evalCtx );\n                    } catch ( error ) {\n                        return undefined;\n                    }\n                }\n                return subExpr;\n            } );\n            return expressions.join( '' );\n        };\n    }\n}\n"],"mappings":"AAAA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,CAAP,MAAc,QAAd;AACA,SAASC,6BAAT,QAA8C,iBAA9C;AACA,OAAOC,cAAP,MAA2B,mBAA3B;AACA,eAAe,MAAMC,oBAAN,CAA2B;EACtC;AACJ;AACA;AACA;AACA;AACA;AACA;EACmB,OAARC,QAAQ,CAAEC,UAAF,EAAe;IAC1B,OAAOC,OAAO,IAAI;MACd,IAAI,CAACD,UAAL,EAAkB;QACd,OAAOE,SAAP;MACH;;MACD,IAAIC,WAAW,GAAGP,6BAA6B,CAAEI,UAAF,CAA/C;MACAG,WAAW,GAAGR,CAAC,CAACS,GAAF,CAAOD,WAAP,EAAoBE,OAAO,IAAI;QACzC,IAAIA,OAAO,CAACC,IAAZ,EAAmB;UACf,IAAIC,UAAU,GAAG,KAAjB;UACA,IAAIC,eAAe,GAAGH,OAAO,CAACC,IAA9B;;UACA,IAAIE,eAAe,CAACC,QAAhB,CAA0B,IAA1B,CAAJ,EAAuC;YACnC;YACAD,eAAe,GAAGA,eAAe,CAACE,OAAhB,CAAyB,OAAzB,EAAkC,MAAlC,CAAlB;YACAH,UAAU,GAAG,IAAb;UACH;;UACD,IAAI,MAAMI,IAAN,CAAYH,eAAZ,CAAJ,EAAoC;YAChC,MAAM,IAAII,KAAJ,CAAW,qDAAX,CAAN;UACH;;UACD,IAAIL,UAAJ,EAAiB;YACbC,eAAe,GAAGA,eAAe,CAACE,OAAhB,CAAyB,WAAzB,EAAsC,IAAtC,CAAlB;UACH,CAbc,CAef;UACA;;;UACA,MAAMG,OAAO,GAAGL,eAAe,CAACM,IAAhB,EAAhB;;UACA,IAAI;YACA,OAAOjB,cAAc,CAACE,QAAf,CAAyBc,OAAzB,EAAoCZ,OAApC,CAAP;UACH,CAFD,CAEE,OAAQc,KAAR,EAAgB;YACd,OAAOb,SAAP;UACH;QACJ;;QACD,OAAOG,OAAP;MACH,CA1Ba,CAAd;MA2BA,OAAOF,WAAW,CAACa,IAAZ,CAAkB,EAAlB,CAAP;IACH,CAjCD;EAkCH;;AA3CqC"},"metadata":{},"sourceType":"module"}