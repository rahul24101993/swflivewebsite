{"ast":null,"code":"/* eslint-disable max-lines */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable complexity */\n\n/* eslint-disable require-jsdoc */\n\n/* eslint-disable no-multi-assign */\n\n/* eslint-disable no-eq-null */\n\n/* eslint-disable eqeqeq */\n\n/* eslint-disable max-statements-per-line */\n\n/* eslint-disable no-constant-condition */\n\n/* eslint-disable no-cond-assign */\n\n/* eslint-env es6 */\n\n/**\n * Sourced from https://github.com/angular/angular.js/blob/master/src/ng/parse.js#L1676 with minor changes\n *\n * (NOT) Copyright (c) 2021 Siemens\n */\nimport { forEach, isUndefined, cloneDeep as copy, isString, isNumber, isFunction, identity } from 'lodash';\n\nconst minErr = key => identity;\n\nconst isDefined = a => !isUndefined(a);\n\nconst createMap = () => new Map();\n\nconst noop = () => {//\n};\n/**\n * @private\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\n\n\nconst lowercase = function (string) {\n  return isString(string) ? string.toLowerCase() : string;\n};\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nvar $parseMinErr = minErr('$parse');\nvar objectValueOf = {}.constructor.prototype.valueOf; // Sandboxing AngularJS Expressions\n// ------------------------------\n// AngularJS expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following AngularJS expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\nfunction getStringValue(name) {\n  // Property names must be strings. This means that non-string objects cannot be used\n  // as keys in an object. Any non-string object, including a number, is typecasted\n  // into a string via the toString method.\n  // -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n  //\n  // So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n  // to a string. It's not always possible. If `name` is an object and its `toString` method is\n  // 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n  //\n  // TypeError: Cannot convert object to primitive value\n  //\n  // For performance reasons, we don't catch this error here and allow it to propagate up the call\n  // stack. Note that you'll get the same error in JavaScript if you try to access a property using\n  // such a 'broken' object as a key.\n  return String(name);\n}\n\nvar OPERATORS = createMap();\nforEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {\n  OPERATORS[operator] = true;\n});\nvar ESCAPE = {\n  n: '\\n',\n  f: '\\f',\n  r: '\\r',\n  t: '\\t',\n  v: '\\v',\n  '\\'': '\\'',\n  '\"': '\"'\n}; /////////////////////////////////////////\n\n/**\n * @constructor\n */\n\nexport var Lexer = function Lexer(options) {\n  this.options = options;\n};\n_c6 = Lexer;\n_c = Lexer;\nLexer.prototype = {\n  constructor: Lexer,\n  lex: function (text) {\n    this.text = text;\n    this.index = 0;\n    this.tokens = [];\n\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n\n      if (ch === '\"' || ch === '\\'') {\n        this.readString(ch);\n      } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n        this.readNumber();\n      } else if (this.isIdentifierStart(this.peekMultichar())) {\n        this.readIdent();\n      } else if (this.is(ch, '(){}[].,;:?')) {\n        this.tokens.push({\n          index: this.index,\n          text: ch\n        });\n        this.index++;\n      } else if (this.isWhitespace(ch)) {\n        this.index++;\n      } else {\n        var ch2 = ch + this.peek();\n        var ch3 = ch2 + this.peek(2);\n        var op1 = OPERATORS[ch];\n        var op2 = OPERATORS[ch2];\n        var op3 = OPERATORS[ch3];\n\n        if (op1 || op2 || op3) {\n          var token = op3 ? ch3 : op2 ? ch2 : ch;\n          this.tokens.push({\n            index: this.index,\n            text: token,\n            operator: true\n          });\n          this.index += token.length;\n        } else {\n          this.throwError('Unexpected next character ', this.index, this.index + 1);\n        }\n      }\n    }\n\n    return this.tokens;\n  },\n  is: function (ch, chars) {\n    return chars.indexOf(ch) !== -1;\n  },\n  peek: function (i) {\n    var num = i || 1;\n    return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;\n  },\n  isNumber: function (ch) {\n    return '0' <= ch && ch <= '9' && typeof ch === 'string';\n  },\n  isWhitespace: function (ch) {\n    // IE treats non-breaking space as \\u00A0\n    return ch === ' ' || ch === '\\r' || ch === '\\t' || ch === '\\n' || ch === '\\v' || ch === '\\u00A0';\n  },\n  isIdentifierStart: function (ch) {\n    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);\n  },\n  isValidIdentifierStart: function (ch) {\n    return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';\n  },\n  isIdentifierContinue: function (ch) {\n    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);\n  },\n  isValidIdentifierContinue: function (ch, cp) {\n    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n  },\n  codePointAt: function (ch) {\n    if (ch.length === 1) {\n      return ch.charCodeAt(0);\n    } // eslint-disable-next-line no-bitwise\n\n\n    return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;\n  },\n  peekMultichar: function () {\n    var ch = this.text.charAt(this.index);\n    var peek = this.peek();\n\n    if (!peek) {\n      return ch;\n    }\n\n    var cp1 = ch.charCodeAt(0);\n    var cp2 = peek.charCodeAt(0);\n\n    if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {\n      return ch + peek;\n    }\n\n    return ch;\n  },\n  isExpOperator: function (ch) {\n    return ch === '-' || ch === '+' || this.isNumber(ch);\n  },\n  throwError: function (error, start, end) {\n    end = end || this.index;\n    var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;\n    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);\n  },\n  readNumber: function () {\n    var number = '';\n    var start = this.index;\n\n    while (this.index < this.text.length) {\n      var ch = lowercase(this.text.charAt(this.index));\n\n      if (ch === '.' || this.isNumber(ch)) {\n        number += ch;\n      } else {\n        var peekCh = this.peek();\n\n        if (ch === 'e' && this.isExpOperator(peekCh)) {\n          number += ch;\n        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === 'e') {\n          number += ch;\n        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === 'e') {\n          this.throwError('Invalid exponent');\n        } else {\n          break;\n        }\n      }\n\n      this.index++;\n    }\n\n    this.tokens.push({\n      index: start,\n      text: number,\n      constant: true,\n      value: Number(number)\n    });\n  },\n  readIdent: function () {\n    var start = this.index;\n    this.index += this.peekMultichar().length;\n\n    while (this.index < this.text.length) {\n      var ch = this.peekMultichar();\n\n      if (!this.isIdentifierContinue(ch)) {\n        break;\n      }\n\n      this.index += ch.length;\n    }\n\n    this.tokens.push({\n      index: start,\n      text: this.text.slice(start, this.index),\n      identifier: true\n    });\n  },\n  readString: function (quote) {\n    var start = this.index;\n    this.index++;\n    var string = '';\n    var rawString = quote;\n    var escapeVar = false;\n\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n      rawString += ch;\n\n      if (escapeVar) {\n        if (ch === 'u') {\n          var hex = this.text.substring(this.index + 1, this.index + 5);\n\n          if (!hex.match(/[\\da-f]{4}/i)) {\n            this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n          }\n\n          this.index += 4;\n          string += String.fromCharCode(parseInt(hex, 16));\n        } else {\n          var rep = ESCAPE[ch];\n          string += rep || ch;\n        }\n\n        escapeVar = false;\n      } else if (ch === '\\\\') {\n        escapeVar = true;\n      } else if (ch === quote) {\n        this.index++;\n        this.tokens.push({\n          index: start,\n          text: rawString,\n          constant: true,\n          value: string\n        });\n        return;\n      } else {\n        string += ch;\n      }\n\n      this.index++;\n    }\n\n    this.throwError('Unterminated quote', start);\n  }\n};\nexport var AST = function AST(lexer, options) {\n  this.lexer = lexer;\n  this.options = options;\n};\n_c7 = AST;\n_c2 = AST;\nAST.Program = 'Program';\nAST.ExpressionStatement = 'ExpressionStatement';\nAST.AssignmentExpression = 'AssignmentExpression';\nAST.ConditionalExpression = 'ConditionalExpression';\nAST.LogicalExpression = 'LogicalExpression';\nAST.BinaryExpression = 'BinaryExpression';\nAST.UnaryExpression = 'UnaryExpression';\nAST.CallExpression = 'CallExpression';\nAST.MemberExpression = 'MemberExpression';\nAST.Identifier = 'Identifier';\nAST.Literal = 'Literal';\nAST.ArrayExpression = 'ArrayExpression';\nAST.Property = 'Property';\nAST.ObjectExpression = 'ObjectExpression';\nAST.ThisExpression = 'ThisExpression';\nAST.LocalsExpression = 'LocalsExpression'; // Internal use only\n\nAST.NGValueParameter = 'NGValueParameter';\nAST.prototype = {\n  ast: function (text) {\n    this.text = text;\n    this.tokens = this.lexer.lex(text);\n    var value = this.program();\n\n    if (this.tokens.length !== 0) {\n      this.throwError('is an unexpected token', this.tokens[0]);\n    }\n\n    return value;\n  },\n  program: function () {\n    var body = [];\n\n    while (true) {\n      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']')) {\n        body.push(this.expressionStatement());\n      }\n\n      if (!this.expect(';')) {\n        return {\n          type: AST.Program,\n          body: body\n        };\n      }\n    }\n  },\n  expressionStatement: function () {\n    return {\n      type: AST.ExpressionStatement,\n      expression: this.filterChain()\n    };\n  },\n  filterChain: function () {\n    var left = this.expression();\n\n    while (this.expect('|')) {\n      left = this.filter(left);\n    }\n\n    return left;\n  },\n  expression: function () {\n    return this.assignment();\n  },\n  assignment: function () {\n    var result = this.ternary();\n\n    if (this.expect('=')) {\n      if (!isAssignable(result)) {\n        throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');\n      }\n\n      result = {\n        type: AST.AssignmentExpression,\n        left: result,\n        right: this.assignment(),\n        operator: '='\n      };\n    }\n\n    return result;\n  },\n  ternary: function () {\n    var test = this.logicalOR();\n    var alternate;\n    var consequent;\n\n    if (this.expect('?')) {\n      alternate = this.expression();\n\n      if (this.consume(':')) {\n        consequent = this.expression();\n        return {\n          type: AST.ConditionalExpression,\n          test: test,\n          alternate: alternate,\n          consequent: consequent\n        };\n      }\n    }\n\n    return test;\n  },\n  logicalOR: function () {\n    var left = this.logicalAND();\n\n    while (this.expect('||')) {\n      left = {\n        type: AST.LogicalExpression,\n        operator: '||',\n        left: left,\n        right: this.logicalAND()\n      };\n    }\n\n    return left;\n  },\n  logicalAND: function () {\n    var left = this.equality();\n\n    while (this.expect('&&')) {\n      left = {\n        type: AST.LogicalExpression,\n        operator: '&&',\n        left: left,\n        right: this.equality()\n      };\n    }\n\n    return left;\n  },\n  equality: function () {\n    var left = this.relational();\n    var token;\n\n    while (token = this.expect('==', '!=', '===', '!==')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.relational()\n      };\n    }\n\n    return left;\n  },\n  relational: function () {\n    var left = this.additive();\n    var token;\n\n    while (token = this.expect('<', '>', '<=', '>=')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.additive()\n      };\n    }\n\n    return left;\n  },\n  additive: function () {\n    var left = this.multiplicative();\n    var token;\n\n    while (token = this.expect('+', '-')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.multiplicative()\n      };\n    }\n\n    return left;\n  },\n  multiplicative: function () {\n    var left = this.unary();\n    var token;\n\n    while (token = this.expect('*', '/', '%')) {\n      left = {\n        type: AST.BinaryExpression,\n        operator: token.text,\n        left: left,\n        right: this.unary()\n      };\n    }\n\n    return left;\n  },\n  unary: function () {\n    var token;\n\n    if (token = this.expect('+', '-', '!')) {\n      return {\n        type: AST.UnaryExpression,\n        operator: token.text,\n        prefix: true,\n        argument: this.unary()\n      };\n    }\n\n    return this.primary();\n  },\n  primary: function () {\n    var primary;\n\n    if (this.expect('(')) {\n      primary = this.filterChain();\n      this.consume(')');\n    } else if (this.expect('[')) {\n      primary = this.arrayDeclaration();\n    } else if (this.expect('{')) {\n      primary = this.object();\n    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n      primary = copy(this.selfReferential[this.consume().text]);\n    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n      primary = {\n        type: AST.Literal,\n        value: this.options.literals[this.consume().text]\n      };\n    } else if (this.peek().identifier) {\n      primary = this.identifier();\n    } else if (this.peek().constant) {\n      primary = this.constant();\n    } else {\n      this.throwError('not a primary expression', this.peek());\n    }\n\n    var next;\n\n    while (next = this.expect('(', '[', '.')) {\n      if (next.text === '(') {\n        primary = {\n          type: AST.CallExpression,\n          callee: primary,\n          arguments: this.parseArguments()\n        };\n        this.consume(')');\n      } else if (next.text === '[') {\n        primary = {\n          type: AST.MemberExpression,\n          object: primary,\n          property: this.expression(),\n          computed: true\n        };\n        this.consume(']');\n      } else if (next.text === '.') {\n        primary = {\n          type: AST.MemberExpression,\n          object: primary,\n          property: this.identifier(),\n          computed: false\n        };\n      } else {\n        this.throwError('IMPOSSIBLE');\n      }\n    }\n\n    return primary;\n  },\n  filter: function (baseExpression) {\n    var args = [baseExpression];\n    var result = {\n      type: AST.CallExpression,\n      callee: this.identifier(),\n      arguments: args,\n      filter: true\n    };\n\n    while (this.expect(':')) {\n      args.push(this.expression());\n    }\n\n    return result;\n  },\n  parseArguments: function () {\n    var args = [];\n\n    if (this.peekToken().text !== ')') {\n      do {\n        args.push(this.filterChain());\n      } while (this.expect(','));\n    }\n\n    return args;\n  },\n  identifier: function () {\n    var token = this.consume();\n\n    if (!token.identifier) {\n      this.throwError('is not a valid identifier', token);\n    }\n\n    return {\n      type: AST.Identifier,\n      name: token.text\n    };\n  },\n  constant: function () {\n    // TODO check that it is a constant\n    return {\n      type: AST.Literal,\n      value: this.consume().value\n    };\n  },\n  arrayDeclaration: function () {\n    var elements = [];\n\n    if (this.peekToken().text !== ']') {\n      do {\n        if (this.peek(']')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n\n        elements.push(this.expression());\n      } while (this.expect(','));\n    }\n\n    this.consume(']');\n    return {\n      type: AST.ArrayExpression,\n      elements: elements\n    };\n  },\n  object: function () {\n    var properties = [];\n    var property;\n\n    if (this.peekToken().text !== '}') {\n      do {\n        if (this.peek('}')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n\n        property = {\n          type: AST.Property,\n          kind: 'init'\n        };\n\n        if (this.peek().constant) {\n          property.key = this.constant();\n          property.computed = false;\n          this.consume(':');\n          property.value = this.expression();\n        } else if (this.peek().identifier) {\n          property.key = this.identifier();\n          property.computed = false;\n\n          if (this.peek(':')) {\n            this.consume(':');\n            property.value = this.expression();\n          } else {\n            property.value = property.key;\n          }\n        } else if (this.peek('[')) {\n          this.consume('[');\n          property.key = this.expression();\n          this.consume(']');\n          property.computed = true;\n          this.consume(':');\n          property.value = this.expression();\n        } else {\n          this.throwError('invalid key', this.peek());\n        }\n\n        properties.push(property);\n      } while (this.expect(','));\n    }\n\n    this.consume('}');\n    return {\n      type: AST.ObjectExpression,\n      properties: properties\n    };\n  },\n  throwError: function (msg, token) {\n    throw $parseMinErr('syntax', 'Syntax Error: Token \\'{0}\\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));\n  },\n  consume: function (e1) {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n\n    var token = this.expect(e1);\n\n    if (!token) {\n      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n    }\n\n    return token;\n  },\n  peekToken: function () {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n\n    return this.tokens[0];\n  },\n  peek: function (e1, e2, e3, e4) {\n    return this.peekAhead(0, e1, e2, e3, e4);\n  },\n  peekAhead: function (i, e1, e2, e3, e4) {\n    if (this.tokens.length > i) {\n      var token = this.tokens[i];\n      var t = token.text;\n\n      if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {\n        return token;\n      }\n    }\n\n    return false;\n  },\n  expect: function (e1, e2, e3, e4) {\n    var token = this.peek(e1, e2, e3, e4);\n\n    if (token) {\n      this.tokens.shift();\n      return token;\n    }\n\n    return false;\n  },\n  selfReferential: {\n    this: {\n      type: AST.ThisExpression\n    },\n    $locals: {\n      type: AST.LocalsExpression\n    }\n  }\n};\n\nfunction ifDefined(v, d) {\n  return typeof v !== 'undefined' ? v : d;\n}\n\nfunction plusFn(l, r) {\n  if (typeof l === 'undefined') {\n    return r;\n  }\n\n  if (typeof r === 'undefined') {\n    return l;\n  }\n\n  return l + r;\n}\n\nfunction isStateless($filter, filterName) {\n  var fn = $filter(filterName);\n  return !fn.$stateful;\n}\n\nvar PURITY_ABSOLUTE = 1;\nvar PURITY_RELATIVE = 2; // Detect nodes which could depend on non-shallow state of objects\n\nfunction isPure(node, parentIsPure) {\n  switch (node.type) {\n    // Computed members might invoke a stateful toString()\n    case AST.MemberExpression:\n      if (node.computed) {\n        return false;\n      }\n\n      break;\n    // Unary always convert to primative\n\n    case AST.UnaryExpression:\n      return PURITY_ABSOLUTE;\n    // The binary + operator can invoke a stateful toString().\n\n    case AST.BinaryExpression:\n      return node.operator !== '+' ? PURITY_ABSOLUTE : false;\n    // Functions / filters probably read state from within objects\n\n    case AST.CallExpression:\n      return false;\n  }\n\n  return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter, parentIsPure) {\n  var allConstants;\n  var argsToWatch;\n  var isStatelessFilter;\n  var astIsPure = ast.isPure = isPure(ast, parentIsPure);\n\n  switch (ast.type) {\n    case AST.Program:\n      allConstants = true;\n      forEach(ast.body, function (expr) {\n        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure);\n        allConstants = allConstants && expr.expression.constant;\n      });\n      ast.constant = allConstants;\n      break;\n\n    case AST.Literal:\n      ast.constant = true;\n      ast.toWatch = [];\n      break;\n\n    case AST.UnaryExpression:\n      findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);\n      ast.constant = ast.argument.constant;\n      ast.toWatch = ast.argument.toWatch;\n      break;\n\n    case AST.BinaryExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n      break;\n\n    case AST.LogicalExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.ConditionalExpression:\n      findConstantAndWatchExpressions(ast.test, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);\n      ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.Identifier:\n      ast.constant = false;\n      ast.toWatch = [ast];\n      break;\n\n    case AST.MemberExpression:\n      findConstantAndWatchExpressions(ast.object, $filter, astIsPure);\n\n      if (ast.computed) {\n        findConstantAndWatchExpressions(ast.property, $filter, astIsPure);\n      }\n\n      ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);\n      ast.toWatch = ast.constant ? [] : [ast];\n      break;\n\n    case AST.CallExpression:\n      isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;\n      allConstants = isStatelessFilter;\n      argsToWatch = [];\n      forEach(ast.arguments, function (expr) {\n        findConstantAndWatchExpressions(expr, $filter, astIsPure);\n        allConstants = allConstants && expr.constant;\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      });\n      ast.constant = allConstants;\n      ast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n      break;\n\n    case AST.AssignmentExpression:\n      findConstantAndWatchExpressions(ast.left, $filter, astIsPure);\n      findConstantAndWatchExpressions(ast.right, $filter, astIsPure);\n      ast.constant = ast.left.constant && ast.right.constant;\n      ast.toWatch = [ast];\n      break;\n\n    case AST.ArrayExpression:\n      allConstants = true;\n      argsToWatch = [];\n      forEach(ast.elements, function (expr) {\n        findConstantAndWatchExpressions(expr, $filter, astIsPure);\n        allConstants = allConstants && expr.constant;\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      });\n      ast.constant = allConstants;\n      ast.toWatch = argsToWatch;\n      break;\n\n    case AST.ObjectExpression:\n      allConstants = true;\n      argsToWatch = [];\n      forEach(ast.properties, function (property) {\n        findConstantAndWatchExpressions(property.value, $filter, astIsPure);\n        allConstants = allConstants && property.value.constant;\n        argsToWatch.push.apply(argsToWatch, property.value.toWatch);\n\n        if (property.computed) {\n          //`{[key]: value}` implicitly does `key.toString()` which may be non-pure\n          findConstantAndWatchExpressions(property.key, $filter,\n          /*parentIsPure=*/\n          false);\n          allConstants = allConstants && property.key.constant;\n          argsToWatch.push.apply(argsToWatch, property.key.toWatch);\n        }\n      });\n      ast.constant = allConstants;\n      ast.toWatch = argsToWatch;\n      break;\n\n    case AST.ThisExpression:\n      ast.constant = false;\n      ast.toWatch = [];\n      break;\n\n    case AST.LocalsExpression:\n      ast.constant = false;\n      ast.toWatch = [];\n      break;\n  }\n}\n\nfunction getInputs(body) {\n  if (body.length !== 1) {\n    return;\n  }\n\n  var lastExpression = body[0].expression;\n  var candidate = lastExpression.toWatch;\n\n  if (candidate.length !== 1) {\n    return candidate;\n  }\n\n  return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n  return ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n    return {\n      type: AST.AssignmentExpression,\n      left: ast.body[0].expression,\n      right: {\n        type: AST.NGValueParameter\n      },\n      operator: '='\n    };\n  }\n}\n\nfunction isLiteral(ast) {\n  return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);\n}\n\nfunction isConstant(ast) {\n  return ast.constant;\n}\n\nexport function ASTCompiler($filter) {\n  this.$filter = $filter;\n}\n_c8 = ASTCompiler;\n_c3 = ASTCompiler;\nASTCompiler.prototype = {\n  compile: function (ast) {\n    var self = this;\n    this.state = {\n      nextId: 0,\n      filters: {},\n      fn: {\n        vars: [],\n        body: [],\n        own: {}\n      },\n      assign: {\n        vars: [],\n        body: [],\n        own: {}\n      },\n      inputs: []\n    };\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var extra = '';\n    var assignable;\n    this.stage = 'assign';\n\n    if (assignable = assignableAST(ast)) {\n      this.state.computing = 'assign';\n      var result = this.nextId();\n      this.recurse(assignable, result);\n      this.return_(result);\n      extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');\n    }\n\n    var toWatch = getInputs(ast.body);\n    self.stage = 'inputs';\n    forEach(toWatch, function (watch, key) {\n      var fnKey = 'fn' + key;\n      self.state[fnKey] = {\n        vars: [],\n        body: [],\n        own: {}\n      };\n      self.state.computing = fnKey;\n      var intoId = self.nextId();\n      self.recurse(watch, intoId);\n      self.return_(intoId);\n      self.state.inputs.push({\n        name: fnKey,\n        isPure: watch.isPure\n      });\n      watch.watchId = key;\n    });\n    this.state.computing = 'fn';\n    this.stage = 'main';\n    this.recurse(ast);\n    var fnString = // The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n    // This is a workaround for this until we do a better job at only removing the prefix only when we should.\n    '\"' + this.USE + ' ' + this.STRICT + '\";\\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;'; // eslint-disable-next-line no-new-func\n\n    var fn = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString)(this.$filter, getStringValue, ifDefined, plusFn);\n    this.state = this.stage = undefined;\n    return fn;\n  },\n  USE: 'use',\n  STRICT: 'strict',\n  watchFns: function () {\n    var result = [];\n    var inputs = this.state.inputs;\n    var self = this;\n    forEach(inputs, function (input) {\n      result.push('var ' + input.name + '=' + self.generateFunction(input.name, 's'));\n\n      if (input.isPure) {\n        result.push(input.name, '.isPure=' + JSON.stringify(input.isPure) + ';');\n      }\n    });\n\n    if (inputs.length) {\n      result.push('fn.inputs=[' + inputs.map(function (i) {\n        return i.name;\n      }).join(',') + '];');\n    }\n\n    return result.join('');\n  },\n  generateFunction: function (name, params) {\n    return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';\n  },\n  filterPrefix: function () {\n    var parts = [];\n    var self = this;\n    forEach(this.state.filters, function (id, filter) {\n      parts.push(id + '=$filter(' + self.escape(filter) + ')');\n    });\n\n    if (parts.length) {\n      return 'var ' + parts.join(',') + ';';\n    }\n\n    return '';\n  },\n  varsPrefix: function (section) {\n    return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';\n  },\n  body: function (section) {\n    return this.state[section].body.join('');\n  },\n  recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var left;\n    var right;\n    var self = this;\n    var args;\n    var expression;\n    var computed;\n    recursionFn = recursionFn || noop;\n\n    if (!skipWatchIdCheck && isDefined(ast.watchId)) {\n      intoId = intoId || this.nextId();\n      this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));\n      return;\n    }\n\n    switch (ast.type) {\n      case AST.Program:\n        forEach(ast.body, function (expression, pos) {\n          self.recurse(expression.expression, undefined, undefined, function (expr) {\n            right = expr;\n          });\n\n          if (pos !== ast.body.length - 1) {\n            self.current().body.push(right, ';');\n          } else {\n            self.return_(right);\n          }\n        });\n        break;\n\n      case AST.Literal:\n        expression = this.escape(ast.value);\n        this.assign(intoId, expression);\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.UnaryExpression:\n        this.recurse(ast.argument, undefined, undefined, function (expr) {\n          right = expr;\n        });\n        expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';\n        this.assign(intoId, expression);\n        recursionFn(expression);\n        break;\n\n      case AST.BinaryExpression:\n        this.recurse(ast.left, undefined, undefined, function (expr) {\n          left = expr;\n        });\n        this.recurse(ast.right, undefined, undefined, function (expr) {\n          right = expr;\n        });\n\n        if (ast.operator === '+') {\n          expression = this.plus(left, right);\n        } else if (ast.operator === '-') {\n          expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n        } else {\n          expression = '(' + left + ')' + ast.operator + '(' + right + ')';\n        }\n\n        this.assign(intoId, expression);\n        recursionFn(expression);\n        break;\n\n      case AST.LogicalExpression:\n        intoId = intoId || this.nextId();\n        self.recurse(ast.left, intoId);\n        self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));\n        recursionFn(intoId);\n        break;\n\n      case AST.ConditionalExpression:\n        intoId = intoId || this.nextId();\n        self.recurse(ast.test, intoId);\n        self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));\n        recursionFn(intoId);\n        break;\n\n      case AST.Identifier:\n        intoId = intoId || this.nextId();\n\n        if (nameId) {\n          nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');\n          nameId.computed = false;\n          nameId.name = ast.name;\n        }\n\n        self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {\n          self.if_(self.stage === 'inputs' || 's', function () {\n            if (create && create !== 1) {\n              self.if_(self.isNull(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));\n            }\n\n            self.assign(intoId, self.nonComputedMember('s', ast.name));\n          });\n        }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));\n        recursionFn(intoId);\n        break;\n\n      case AST.MemberExpression:\n        left = nameId && (nameId.context = this.nextId()) || this.nextId();\n        intoId = intoId || this.nextId();\n        self.recurse(ast.object, left, undefined, function () {\n          self.if_(self.notNull(left), function () {\n            if (ast.computed) {\n              right = self.nextId();\n              self.recurse(ast.property, right);\n              self.getStringValue(right);\n\n              if (create && create !== 1) {\n                self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));\n              }\n\n              expression = self.computedMember(left, right);\n              self.assign(intoId, expression);\n\n              if (nameId) {\n                nameId.computed = true;\n                nameId.name = right;\n              }\n            } else {\n              if (create && create !== 1) {\n                self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));\n              }\n\n              expression = self.nonComputedMember(left, ast.property.name);\n              self.assign(intoId, expression);\n\n              if (nameId) {\n                nameId.computed = false;\n                nameId.name = ast.property.name;\n              }\n            }\n          }, function () {\n            self.assign(intoId, 'undefined');\n          });\n          recursionFn(intoId);\n        }, Boolean(create));\n        break;\n\n      case AST.CallExpression:\n        intoId = intoId || this.nextId();\n\n        if (ast.filter) {\n          right = self.filter(ast.callee.name);\n          args = [];\n          forEach(ast.arguments, function (expr) {\n            var argument = self.nextId();\n            self.recurse(expr, argument);\n            args.push(argument);\n          });\n          expression = right + '(' + args.join(',') + ')';\n          self.assign(intoId, expression);\n          recursionFn(intoId);\n        } else {\n          right = self.nextId();\n          left = {};\n          args = [];\n          self.recurse(ast.callee, right, left, function () {\n            self.if_(self.notNull(right), function () {\n              forEach(ast.arguments, function (expr) {\n                self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {\n                  args.push(argument);\n                });\n              });\n\n              if (left.name) {\n                expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';\n              } else {\n                expression = right + '(' + args.join(',') + ')';\n              }\n\n              self.assign(intoId, expression);\n            }, function () {\n              self.assign(intoId, 'undefined');\n            });\n            recursionFn(intoId);\n          });\n        }\n\n        break;\n\n      case AST.AssignmentExpression:\n        right = this.nextId();\n        left = {};\n        this.recurse(ast.left, undefined, left, function () {\n          self.if_(self.notNull(left.context), function () {\n            self.recurse(ast.right, right);\n            expression = self.member(left.context, left.name, left.computed) + ast.operator + right;\n            self.assign(intoId, expression);\n            recursionFn(intoId || expression);\n          });\n        }, 1);\n        break;\n\n      case AST.ArrayExpression:\n        args = [];\n        forEach(ast.elements, function (expr) {\n          self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {\n            args.push(argument);\n          });\n        });\n        expression = '[' + args.join(',') + ']';\n        this.assign(intoId, expression);\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.ObjectExpression:\n        args = [];\n        computed = false;\n        forEach(ast.properties, function (property) {\n          if (property.computed) {\n            computed = true;\n          }\n        });\n\n        if (computed) {\n          intoId = intoId || this.nextId();\n          this.assign(intoId, '{}');\n          forEach(ast.properties, function (property) {\n            if (property.computed) {\n              left = self.nextId();\n              self.recurse(property.key, left);\n            } else {\n              left = property.key.type === AST.Identifier ? property.key.name : String(property.key.value);\n            }\n\n            right = self.nextId();\n            self.recurse(property.value, right);\n            self.assign(self.member(intoId, left, property.computed), right);\n          });\n        } else {\n          forEach(ast.properties, function (property) {\n            self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {\n              args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : String(property.key.value)) + ':' + expr);\n            });\n          });\n          expression = '{' + args.join(',') + '}';\n          this.assign(intoId, expression);\n        }\n\n        recursionFn(intoId || expression);\n        break;\n\n      case AST.ThisExpression:\n        this.assign(intoId, 's');\n        recursionFn(intoId || 's');\n        break;\n\n      case AST.LocalsExpression:\n        this.assign(intoId, 'l');\n        recursionFn(intoId || 'l');\n        break;\n\n      case AST.NGValueParameter:\n        this.assign(intoId, 'v');\n        recursionFn(intoId || 'v');\n        break;\n    }\n  },\n  getHasOwnProperty: function (element, property) {\n    var key = element + '.' + property;\n    var own = this.current().own;\n\n    if (!own.hasOwnProperty(key)) {\n      own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');\n    }\n\n    return own[key];\n  },\n  assign: function (id, value) {\n    if (!id) {\n      return;\n    }\n\n    this.current().body.push(id, '=', value, ';');\n    return id;\n  },\n  filter: function (filterName) {\n    if (!this.state.filters.hasOwnProperty(filterName)) {\n      this.state.filters[filterName] = this.nextId(true);\n    }\n\n    return this.state.filters[filterName];\n  },\n  ifDefined: function (id, defaultValue) {\n    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';\n  },\n  plus: function (left, right) {\n    return 'plus(' + left + ',' + right + ')';\n  },\n  return_: function (id) {\n    this.current().body.push('return ', id, ';');\n  },\n  if_: function (test, alternate, consequent) {\n    if (test === true) {\n      alternate();\n    } else {\n      var body = this.current().body;\n      body.push('if(', test, '){');\n      alternate();\n      body.push('}');\n\n      if (consequent) {\n        body.push('else{');\n        consequent();\n        body.push('}');\n      }\n    }\n  },\n  not: function (expression) {\n    return '!(' + expression + ')';\n  },\n  isNull: function (expression) {\n    return expression + '==null';\n  },\n  notNull: function (expression) {\n    return expression + '!=null';\n  },\n  nonComputedMember: function (left, right) {\n    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n    var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n\n    if (SAFE_IDENTIFIER.test(right)) {\n      return left + '.' + right;\n    }\n\n    return left + '[\"' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '\"]';\n  },\n  computedMember: function (left, right) {\n    return left + '[' + right + ']';\n  },\n  member: function (left, right, computed) {\n    if (computed) {\n      return this.computedMember(left, right);\n    }\n\n    return this.nonComputedMember(left, right);\n  },\n  getStringValue: function (item) {\n    this.assign(item, 'getStringValue(' + item + ')');\n  },\n  lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var self = this;\n    return function () {\n      self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n    };\n  },\n  lazyAssign: function (id, value) {\n    var self = this;\n    return function () {\n      self.assign(id, value);\n    };\n  },\n  stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n  stringEscapeFn: function (c) {\n    return '\\\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n  },\n  escape: function (value) {\n    if (isString(value)) {\n      return '\\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\\'';\n    }\n\n    if (isNumber(value)) {\n      return value.toString();\n    }\n\n    if (value === true) {\n      return 'true';\n    }\n\n    if (value === false) {\n      return 'false';\n    }\n\n    if (value === null) {\n      return 'null';\n    }\n\n    if (typeof value === 'undefined') {\n      return 'undefined';\n    }\n\n    throw $parseMinErr('esc', 'IMPOSSIBLE');\n  },\n  nextId: function (skip, init) {\n    var id = 'v' + this.state.nextId++;\n\n    if (!skip) {\n      this.current().vars.push(id + (init ? '=' + init : ''));\n    }\n\n    return id;\n  },\n  current: function () {\n    return this.state[this.state.computing];\n  }\n};\nexport function ASTInterpreter($filter) {\n  this.$filter = $filter;\n}\n_c9 = ASTInterpreter;\n_c4 = ASTInterpreter;\nASTInterpreter.prototype = {\n  compile: function (ast) {\n    var self = this;\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var assignable;\n    var assign;\n\n    if (assignable = assignableAST(ast)) {\n      assign = this.recurse(assignable);\n    }\n\n    var toWatch = getInputs(ast.body);\n    var inputs;\n\n    if (toWatch) {\n      inputs = [];\n      forEach(toWatch, function (watch, key) {\n        var input = self.recurse(watch);\n        input.isPure = watch.isPure;\n        watch.input = input;\n        inputs.push(input);\n        watch.watchId = key;\n      });\n    }\n\n    var expressions = [];\n    forEach(ast.body, function (expression) {\n      expressions.push(self.recurse(expression.expression));\n    });\n    var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {\n      var lastValue;\n      forEach(expressions, function (exp) {\n        lastValue = exp(scope, locals);\n      });\n      return lastValue;\n    };\n\n    if (assign) {\n      fn.assign = function (scope, value, locals) {\n        return assign(scope, locals, value);\n      };\n    }\n\n    if (inputs) {\n      fn.inputs = inputs;\n    }\n\n    return fn;\n  },\n  recurse: function (ast, context, create) {\n    var left;\n    var right;\n    var self = this;\n    var args;\n\n    if (ast.input) {\n      return this.inputs(ast.input, ast.watchId);\n    }\n\n    switch (ast.type) {\n      case AST.Literal:\n        return this.value(ast.value, context);\n\n      case AST.UnaryExpression:\n        right = this.recurse(ast.argument);\n        return this['unary' + ast.operator](right, context);\n\n      case AST.BinaryExpression:\n        left = this.recurse(ast.left);\n        right = this.recurse(ast.right);\n        return this['binary' + ast.operator](left, right, context);\n\n      case AST.LogicalExpression:\n        left = this.recurse(ast.left);\n        right = this.recurse(ast.right);\n        return this['binary' + ast.operator](left, right, context);\n\n      case AST.ConditionalExpression:\n        return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);\n\n      case AST.Identifier:\n        return self.identifier(ast.name, context, create);\n\n      case AST.MemberExpression:\n        left = this.recurse(ast.object, false, Boolean(create));\n\n        if (!ast.computed) {\n          right = ast.property.name;\n        }\n\n        if (ast.computed) {\n          right = this.recurse(ast.property);\n        }\n\n        return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);\n\n      case AST.CallExpression:\n        args = [];\n        forEach(ast.arguments, function (expr) {\n          args.push(self.recurse(expr));\n        });\n\n        if (ast.filter) {\n          right = this.$filter(ast.callee.name);\n        }\n\n        if (!ast.filter) {\n          right = this.recurse(ast.callee, true);\n        }\n\n        return ast.filter ? function (scope, locals, assign, inputs) {\n          var values = [];\n\n          for (var i = 0; i < args.length; ++i) {\n            values.push(args[i](scope, locals, assign, inputs));\n          }\n\n          var value = right.apply(undefined, values, inputs);\n          return context ? {\n            context: undefined,\n            name: undefined,\n            value: value\n          } : value;\n        } : function (scope, locals, assign, inputs) {\n          var rhs = right(scope, locals, assign, inputs);\n          var value;\n\n          if (rhs.value != null) {\n            var values = [];\n\n            for (var i = 0; i < args.length; ++i) {\n              values.push(args[i](scope, locals, assign, inputs));\n            }\n\n            value = rhs.value.apply(rhs.context, values);\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.AssignmentExpression:\n        left = this.recurse(ast.left, true, 1);\n        right = this.recurse(ast.right);\n        return function (scope, locals, assign, inputs) {\n          var lhs = left(scope, locals, assign, inputs);\n          var rhs = right(scope, locals, assign, inputs);\n          lhs.context[lhs.name] = rhs;\n          return context ? {\n            value: rhs\n          } : rhs;\n        };\n\n      case AST.ArrayExpression:\n        args = [];\n        forEach(ast.elements, function (expr) {\n          args.push(self.recurse(expr));\n        });\n        return function (scope, locals, assign, inputs) {\n          var value = [];\n\n          for (var i = 0; i < args.length; ++i) {\n            value.push(args[i](scope, locals, assign, inputs));\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.ObjectExpression:\n        args = [];\n        forEach(ast.properties, function (property) {\n          if (property.computed) {\n            args.push({\n              key: self.recurse(property.key),\n              computed: true,\n              value: self.recurse(property.value)\n            });\n          } else {\n            args.push({\n              key: property.key.type === AST.Identifier ? property.key.name : String(property.key.value),\n              computed: false,\n              value: self.recurse(property.value)\n            });\n          }\n        });\n        return function (scope, locals, assign, inputs) {\n          var value = {};\n\n          for (var i = 0; i < args.length; ++i) {\n            if (args[i].computed) {\n              value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);\n            } else {\n              value[args[i].key] = args[i].value(scope, locals, assign, inputs);\n            }\n          }\n\n          return context ? {\n            value: value\n          } : value;\n        };\n\n      case AST.ThisExpression:\n        return function (scope) {\n          return context ? {\n            value: scope\n          } : scope;\n        };\n\n      case AST.LocalsExpression:\n        return function (scope, locals) {\n          return context ? {\n            value: locals\n          } : locals;\n        };\n\n      case AST.NGValueParameter:\n        return function (scope, locals, assign) {\n          return context ? {\n            value: assign\n          } : assign;\n        };\n    }\n  },\n  'unary+': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n\n      if (isDefined(arg)) {\n        arg = Number(arg);\n      } else {\n        arg = 0;\n      }\n\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'unary-': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n\n      if (isDefined(arg)) {\n        arg = -arg;\n      } else {\n        arg = -0;\n      }\n\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'unary!': function (argument, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = !argument(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary+': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = plusFn(lhs, rhs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary-': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary*': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary/': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary%': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary===': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary!==': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary==': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary!=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary<': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary>': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary<=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary>=': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary&&': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'binary||': function (left, right, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  'ternary?:': function (test, alternate, consequent, context) {\n    return function (scope, locals, assign, inputs) {\n      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);\n      return context ? {\n        value: arg\n      } : arg;\n    };\n  },\n  value: function (value, context) {\n    return function () {\n      return context ? {\n        context: undefined,\n        name: undefined,\n        value: value\n      } : value;\n    };\n  },\n  identifier: function (name, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var base = locals && name in locals ? locals : scope;\n\n      if (create && create !== 1 && base && base[name] == null) {\n        base[name] = {};\n      }\n\n      var value = base ? base[name] : undefined;\n\n      if (context) {\n        return {\n          context: base,\n          name: name,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  computedMember: function (left, right, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs;\n      var value;\n\n      if (lhs != null) {\n        rhs = right(scope, locals, assign, inputs);\n        rhs = getStringValue(rhs);\n\n        if (create && create !== 1) {\n          if (lhs && !lhs[rhs]) {\n            lhs[rhs] = {};\n          }\n        }\n\n        value = lhs[rhs];\n      }\n\n      if (context) {\n        return {\n          context: lhs,\n          name: rhs,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  nonComputedMember: function (left, right, context, create) {\n    return function (scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n\n      if (create && create !== 1) {\n        if (lhs && lhs[right] == null) {\n          lhs[right] = {};\n        }\n      }\n\n      var value = lhs != null ? lhs[right] : undefined;\n\n      if (context) {\n        return {\n          context: lhs,\n          name: right,\n          value: value\n        };\n      }\n\n      return value;\n    };\n  },\n  inputs: function (input, watchId) {\n    return function (scope, value, locals, inputs) {\n      if (inputs) {\n        return inputs[watchId];\n      }\n\n      return input(scope, value, locals);\n    };\n  }\n};\n/**\n * @constructor\n */\n\nexport function Parser(lexer, $filter, options) {\n  this.ast = new AST(lexer, options);\n  this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);\n}\n_c10 = Parser;\n_c5 = Parser;\nParser.prototype = {\n  constructor: Parser,\n  parse: function (text) {\n    var ast = this.getAst(text);\n    var fn = this.astCompiler.compile(ast.ast);\n    fn.literal = isLiteral(ast.ast);\n    fn.constant = isConstant(ast.ast);\n    fn.oneTime = ast.oneTime;\n    return fn;\n  },\n  getAst: function (exp) {\n    var oneTime = false;\n    exp = exp.trim();\n\n    if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {\n      oneTime = true;\n      exp = exp.substring(2);\n    }\n\n    return {\n      ast: this.ast.ast(exp),\n      oneTime: oneTime\n    };\n  }\n};\n\nfunction getValueOf(value) {\n  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);\n} ///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts AngularJS {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'AngularJS'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('AngularJS');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\n\n\nexport function $ParseProvider() {\n  var cache = createMap();\n  var literals = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined\n  };\n  var identStart;\n  var identContinue;\n  /**\n  * @ngdoc method\n  * @name $parseProvider#addLiteral\n  * @description\n  *\n  * Configure $parse service to add literal values that will be present as literal at expressions.\n  *\n  * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n  * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n  *\n  **/\n\n  this.addLiteral = function (literalName, literalValue) {\n    literals[literalName] = literalValue;\n  };\n  /**\n  * @ngdoc method\n  * @name $parseProvider#setIdentifierFns\n  *\n  * @description\n  *\n  * Allows defining the set of characters that are allowed in AngularJS expressions. The function\n  * `identifierStart` will get called to know if a given character is a valid character to be the\n  * first character for an identifier. The function `identifierContinue` will get called to know if\n  * a given character is a valid character to be a follow-up identifier character. The functions\n  * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n  * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n  * mind that the `string` parameter can be two characters long depending on the character\n  * representation. It is expected for the function to return `true` or `false`, whether that\n  * character is allowed or not.\n  *\n  * Since this function will be called extensively, keep the implementation of these functions fast,\n  * as the performance of these functions have a direct impact on the expressions parsing speed.\n  *\n  * @param {function=} identifierStart The function that will decide whether the given character is\n  *   a valid identifier start character.\n  * @param {function=} identifierContinue The function that will decide whether the given character is\n  *   a valid identifier continue character.\n  */\n\n\n  this.setIdentifierFns = function (identifierStart, identifierContinue) {\n    identStart = identifierStart;\n    identContinue = identifierContinue;\n    return this;\n  };\n\n  this.$get = ['$filter', function ($filter) {\n    var noUnsafeEval = false; //csp().noUnsafeEval;\n\n    var $parseOptions = {\n      csp: noUnsafeEval,\n      literals: copy(literals),\n      isIdentifierStart: isFunction(identStart) && identStart,\n      isIdentifierContinue: isFunction(identContinue) && identContinue\n    };\n    $parse.$$getAst = $$getAst;\n    return $parse;\n\n    function $parse(exp, interceptorFn) {\n      var parsedExpression;\n      var cacheKey;\n\n      switch (typeof exp) {\n        case 'string':\n          exp = exp.trim();\n          cacheKey = exp;\n          parsedExpression = cache[cacheKey];\n\n          if (!parsedExpression) {\n            var lexer = new Lexer($parseOptions);\n            var parser = new Parser(lexer, $filter, $parseOptions);\n            parsedExpression = parser.parse(exp);\n            cache[cacheKey] = addWatchDelegate(parsedExpression);\n          }\n\n          return addInterceptor(parsedExpression, interceptorFn);\n\n        case 'function':\n          return addInterceptor(exp, interceptorFn);\n\n        default:\n          return addInterceptor(noop, interceptorFn);\n      }\n    }\n\n    function $$getAst(exp) {\n      var lexer = new Lexer($parseOptions);\n      var parser = new Parser(lexer, $filter, $parseOptions);\n      return parser.getAst(exp).ast;\n    }\n\n    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {\n      if (newValue == null || oldValueOfValue == null) {\n        // null/undefined\n        return newValue === oldValueOfValue;\n      }\n\n      if (typeof newValue === 'object') {\n        // attempt to convert the value to a primitive type\n        // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n        //             be cheaply dirty-checked\n        newValue = getValueOf(newValue);\n\n        if (typeof newValue === 'object' && !compareObjectIdentity) {\n          // objects/arrays are not supported - deep-watching them would be too expensive\n          return false;\n        } // fall-through to the primitive equality check\n\n      } //Primitive or NaN\n      // eslint-disable-next-line no-self-compare\n\n\n      return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;\n    }\n\n    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var inputExpressions = parsedExpression.inputs;\n      var lastResult;\n\n      if (inputExpressions.length === 1) {\n        var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\n        inputExpressions = inputExpressions[0];\n        return scope.$watch(function expressionInputWatch(scope) {\n          var newInputValue = inputExpressions(scope);\n\n          if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {\n            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);\n            oldInputValueOf = newInputValue && getValueOf(newInputValue);\n          }\n\n          return lastResult;\n        }, listener, objectEquality, prettyPrintExpression);\n      }\n\n      var oldInputValueOfValues = [];\n      var oldInputValues = [];\n\n      for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n        oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\n        oldInputValues[i] = null;\n      }\n\n      return scope.$watch(function expressionInputsWatch(scope) {\n        var changed = false;\n\n        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n          var newInputValue = inputExpressions[i](scope);\n\n          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) {\n            oldInputValues[i] = newInputValue;\n            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);\n          }\n        }\n\n        if (changed) {\n          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);\n        }\n\n        return lastResult;\n      }, listener, objectEquality, prettyPrintExpression);\n    }\n\n    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var isDone = parsedExpression.literal ? isAllDefined : isDefined;\n      var unwatch;\n      var lastValue;\n      var exp = parsedExpression.$$intercepted || parsedExpression;\n      var post = parsedExpression.$$interceptor || identity;\n      var useInputs = parsedExpression.inputs && !exp.inputs; // Propagate the literal/inputs/constant attributes\n      // ... but not oneTime since we are handling it\n\n      oneTimeWatch.literal = parsedExpression.literal;\n      oneTimeWatch.constant = parsedExpression.constant;\n      oneTimeWatch.inputs = parsedExpression.inputs; // Allow other delegates to run on this wrapped expression\n\n      addWatchDelegate(oneTimeWatch);\n      unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);\n      return unwatch;\n\n      function unwatchIfDone() {\n        if (isDone(lastValue)) {\n          unwatch();\n        }\n      }\n\n      function oneTimeWatch(scope, locals, assign, inputs) {\n        lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs);\n\n        if (isDone(lastValue)) {\n          scope.$$postDigest(unwatchIfDone);\n        }\n\n        return post(lastValue);\n      }\n    }\n\n    function isAllDefined(value) {\n      var allDefined = true;\n      forEach(value, function (val) {\n        if (!isDefined(val)) {\n          allDefined = false;\n        }\n      });\n      return allDefined;\n    }\n\n    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {\n      var unwatch = scope.$watch(function constantWatch(scope) {\n        unwatch();\n        return parsedExpression(scope);\n      }, listener, objectEquality);\n      return unwatch;\n    }\n\n    function addWatchDelegate(parsedExpression) {\n      if (parsedExpression.constant) {\n        parsedExpression.$$watchDelegate = constantWatchDelegate;\n      } else if (parsedExpression.oneTime) {\n        parsedExpression.$$watchDelegate = oneTimeWatchDelegate;\n      } else if (parsedExpression.inputs) {\n        parsedExpression.$$watchDelegate = inputsWatchDelegate;\n      }\n\n      return parsedExpression;\n    }\n\n    function chainInterceptors(first, second) {\n      function chainedInterceptor(value) {\n        return second(first(value));\n      }\n\n      chainedInterceptor.$stateful = first.$stateful || second.$stateful;\n      chainedInterceptor.$$pure = first.$$pure && second.$$pure;\n      return chainedInterceptor;\n    }\n\n    function addInterceptor(parsedExpression, interceptorFn) {\n      if (!interceptorFn) {\n        return parsedExpression;\n      } // Extract any existing interceptors out of the parsedExpression\n      // to ensure the original parsedExpression is always the $$intercepted\n\n\n      if (parsedExpression.$$interceptor) {\n        interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn);\n        parsedExpression = parsedExpression.$$intercepted;\n      }\n\n      var useInputs = false;\n\n      var fn = function interceptedExpression(scope, locals, assign, inputs) {\n        var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);\n        return interceptorFn(value);\n      }; // Maintain references to the interceptor/intercepted\n\n\n      fn.$$intercepted = parsedExpression;\n      fn.$$interceptor = interceptorFn; // Propagate the literal/oneTime/constant attributes\n\n      fn.literal = parsedExpression.literal;\n      fn.oneTime = parsedExpression.oneTime;\n      fn.constant = parsedExpression.constant; // Treat the interceptor like filters.\n      // If it is not $stateful then only watch its inputs.\n      // If the expression itself has no inputs then use the full expression as an input.\n\n      if (!interceptorFn.$stateful) {\n        useInputs = !parsedExpression.inputs;\n        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];\n\n        if (!interceptorFn.$$pure) {\n          fn.inputs = fn.inputs.map(function (e) {\n            // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a\n            // non-pure interceptor function.\n            if (e.isPure === PURITY_RELATIVE) {\n              return function depurifier(s) {\n                return e(s);\n              };\n            }\n\n            return e;\n          });\n        }\n      }\n\n      return addWatchDelegate(fn);\n    }\n  }];\n}\n\nvar _c, _c2, _c3, _c4, _c5;\n\n$RefreshReg$(_c, \"Lexer\");\n$RefreshReg$(_c2, \"AST\");\n$RefreshReg$(_c3, \"ASTCompiler\");\n$RefreshReg$(_c4, \"ASTInterpreter\");\n$RefreshReg$(_c5, \"Parser\");\n\nvar _c6, _c7, _c8, _c9, _c10;\n\n$RefreshReg$(_c6, \"Lexer\");\n$RefreshReg$(_c7, \"AST\");\n$RefreshReg$(_c8, \"ASTCompiler\");\n$RefreshReg$(_c9, \"ASTInterpreter\");\n$RefreshReg$(_c10, \"Parser\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/angularjsParseService.js"],"names":["cloneDeep","minErr","key","isDefined","a","isUndefined","createMap","noop","lowercase","isString","string","$parseMinErr","objectValueOf","String","OPERATORS","forEach","ESCAPE","n","f","r","t","v","Lexer","constructor","lex","ch","index","text","ch2","ch3","op1","op2","op3","token","operator","is","chars","peek","num","i","isNumber","isWhitespace","isIdentifierStart","isValidIdentifierStart","isIdentifierContinue","isValidIdentifierContinue","codePointAt","peekMultichar","cp1","cp2","isExpOperator","throwError","end","colStr","readNumber","number","start","peekCh","constant","value","Number","readIdent","identifier","readString","rawString","escapeVar","hex","parseInt","rep","AST","ast","program","body","type","expressionStatement","expression","filterChain","left","assignment","result","isAssignable","right","ternary","test","alternate","consequent","logicalOR","logicalAND","equality","relational","additive","multiplicative","unary","prefix","argument","primary","copy","next","callee","arguments","object","property","computed","filter","args","parseArguments","name","arrayDeclaration","elements","properties","kind","consume","peekToken","peekAhead","expect","selfReferential","this","ThisExpression","$locals","LocalsExpression","l","fn","$filter","PURITY_ABSOLUTE","PURITY_RELATIVE","node","undefined","astIsPure","isPure","allConstants","findConstantAndWatchExpressions","expr","isStatelessFilter","isStateless","argsToWatch","lastExpression","candidate","NGValueParameter","ASTCompiler","compile","self","nextId","filters","vars","own","assign","inputs","extra","assignable","assignableAST","toWatch","getInputs","fnKey","intoId","watch","fnString","USE","STRICT","watchFns","input","JSON","generateFunction","filterPrefix","parts","id","varsPrefix","recurse","recursionFn","pos","nameId","create","Boolean","getHasOwnProperty","element","ifDefined","plus","return_","if_","not","isNull","notNull","nonComputedMember","SAFE_IDENTIFIER","UNSAFE_CHARACTERS","computedMember","member","getStringValue","lazyRecurse","lazyAssign","stringEscapeRegex","stringEscapeFn","c","escape","init","current","ASTInterpreter","expressions","lastValue","exp","values","context","rhs","lhs","scope","locals","arg","plusFn","base","Parser","options","parse","isLiteral","isConstant","getAst","oneTime","isFunction","cache","literals","true","false","null","identStart","identContinue","noUnsafeEval","$parseOptions","csp","$parse","cacheKey","parsedExpression","lexer","parser","addWatchDelegate","addInterceptor","newValue","oldValueOfValue","getValueOf","inputExpressions","oldInputValueOf","newInputValue","expressionInputDirtyCheck","lastResult","oldInputValueOfValues","oldInputValues","ii","changed","isDone","post","useInputs","oneTimeWatch","unwatch","allDefined","second","first","chainedInterceptor","interceptorFn","chainInterceptors","e"],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable complexity */\n/* eslint-disable require-jsdoc */\n/* eslint-disable no-multi-assign */\n/* eslint-disable no-eq-null */\n/* eslint-disable eqeqeq */\n/* eslint-disable max-statements-per-line */\n/* eslint-disable no-constant-condition */\n/* eslint-disable no-cond-assign */\n/* eslint-env es6 */\n\n/**\n * Sourced from https://github.com/angular/angular.js/blob/master/src/ng/parse.js#L1676 with minor changes\n *\n * (NOT) Copyright (c) 2021 Siemens\n */\n\nimport {\n    forEach,\n    isUndefined,\n    cloneDeep as copy,\n    isString,\n    isNumber,\n    isFunction,\n    identity\n} from 'lodash';\n\nconst minErr = ( key ) => identity;\nconst isDefined = ( a ) => !isUndefined( a );\nconst createMap = () => new Map();\nconst noop = () => {\n    //\n};\n\n/**\n * @private\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\nconst lowercase = function( string ) {\n    return isString( string ) ? string.toLowerCase() : string;\n};\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr( '$parse' );\n\nvar objectValueOf = {}.constructor.prototype.valueOf;\n\n// Sandboxing AngularJS Expressions\n// ------------------------------\n// AngularJS expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following AngularJS expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\n\nfunction getStringValue( name ) {\n    // Property names must be strings. This means that non-string objects cannot be used\n    // as keys in an object. Any non-string object, including a number, is typecasted\n    // into a string via the toString method.\n    // -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n    //\n    // So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n    // to a string. It's not always possible. If `name` is an object and its `toString` method is\n    // 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n    //\n    // TypeError: Cannot convert object to primitive value\n    //\n    // For performance reasons, we don't catch this error here and allow it to propagate up the call\n    // stack. Note that you'll get the same error in JavaScript if you try to access a property using\n    // such a 'broken' object as a key.\n    return String( name );\n}\n\n\nvar OPERATORS = createMap();\nforEach( '+ - * / % === !== == != < > <= >= && || ! = |'.split( ' ' ), function( operator ) { OPERATORS[operator] = true; } );\nvar ESCAPE = { n:'\\n', f:'\\f', r:'\\r', t:'\\t', v:'\\v', '\\'':'\\'', '\"':'\"' };\n\n\n/////////////////////////////////////////\n\n\n/**\n * @constructor\n */\nexport var Lexer = function Lexer( options ) {\n    this.options = options;\n};\n\nLexer.prototype = {\n    constructor: Lexer,\n\n    lex: function( text ) {\n        this.text = text;\n        this.index = 0;\n        this.tokens = [];\n\n        while ( this.index < this.text.length ) {\n            var ch = this.text.charAt( this.index );\n            if ( ch === '\"' || ch === '\\'' ) {\n                this.readString( ch );\n            } else if ( this.isNumber( ch ) || ch === '.' && this.isNumber( this.peek() ) ) {\n                this.readNumber();\n            } else if ( this.isIdentifierStart( this.peekMultichar() ) ) {\n                this.readIdent();\n            } else if ( this.is( ch, '(){}[].,;:?' ) ) {\n                this.tokens.push( { index: this.index, text: ch } );\n                this.index++;\n            } else if ( this.isWhitespace( ch ) ) {\n                this.index++;\n            } else {\n                var ch2 = ch + this.peek();\n                var ch3 = ch2 + this.peek( 2 );\n                var op1 = OPERATORS[ch];\n                var op2 = OPERATORS[ch2];\n                var op3 = OPERATORS[ch3];\n                if ( op1 || op2 || op3 ) {\n                    var token = op3 ? ch3 : op2 ? ch2 : ch;\n                    this.tokens.push( { index: this.index, text: token, operator: true } );\n                    this.index += token.length;\n                } else {\n                    this.throwError( 'Unexpected next character ', this.index, this.index + 1 );\n                }\n            }\n        }\n        return this.tokens;\n    },\n\n    is: function( ch, chars ) {\n        return chars.indexOf( ch ) !== -1;\n    },\n\n    peek: function( i ) {\n        var num = i || 1;\n        return this.index + num < this.text.length ? this.text.charAt( this.index + num ) : false;\n    },\n\n    isNumber: function( ch ) {\n        return '0' <= ch && ch <= '9' && typeof ch === 'string';\n    },\n\n    isWhitespace: function( ch ) {\n    // IE treats non-breaking space as \\u00A0\n        return ch === ' ' || ch === '\\r' || ch === '\\t' ||\n            ch === '\\n' || ch === '\\v' || ch === '\\u00A0';\n    },\n\n    isIdentifierStart: function( ch ) {\n        return this.options.isIdentifierStart ?\n            this.options.isIdentifierStart( ch, this.codePointAt( ch ) ) :\n            this.isValidIdentifierStart( ch );\n    },\n\n    isValidIdentifierStart: function( ch ) {\n        return 'a' <= ch && ch <= 'z' ||\n            'A' <= ch && ch <= 'Z' ||\n            '_' === ch || ch === '$';\n    },\n\n    isIdentifierContinue: function( ch ) {\n        return this.options.isIdentifierContinue ?\n            this.options.isIdentifierContinue( ch, this.codePointAt( ch ) ) :\n            this.isValidIdentifierContinue( ch );\n    },\n\n    isValidIdentifierContinue: function( ch, cp ) {\n        return this.isValidIdentifierStart( ch, cp ) || this.isNumber( ch );\n    },\n\n    codePointAt: function( ch ) {\n        if ( ch.length === 1 ) { return ch.charCodeAt( 0 ); }\n        // eslint-disable-next-line no-bitwise\n        return ( ch.charCodeAt( 0 ) << 10 ) + ch.charCodeAt( 1 ) - 0x35FDC00;\n    },\n\n    peekMultichar: function() {\n        var ch = this.text.charAt( this.index );\n        var peek = this.peek();\n        if ( !peek ) {\n            return ch;\n        }\n        var cp1 = ch.charCodeAt( 0 );\n        var cp2 = peek.charCodeAt( 0 );\n        if ( cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF ) {\n            return ch + peek;\n        }\n        return ch;\n    },\n\n    isExpOperator: function( ch ) {\n        return ch === '-' || ch === '+' || this.isNumber( ch );\n    },\n\n    throwError: function( error, start, end ) {\n        end = end || this.index;\n        var colStr = isDefined( start )\n            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring( start, end ) + ']'\n            : ' ' + end;\n        throw $parseMinErr( 'lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',\n            error, colStr, this.text );\n    },\n\n    readNumber: function() {\n        var number = '';\n        var start = this.index;\n        while ( this.index < this.text.length ) {\n            var ch = lowercase( this.text.charAt( this.index ) );\n            if ( ch === '.' || this.isNumber( ch ) ) {\n                number += ch;\n            } else {\n                var peekCh = this.peek();\n                if ( ch === 'e' && this.isExpOperator( peekCh ) ) {\n                    number += ch;\n                } else if ( this.isExpOperator( ch ) &&\n            peekCh && this.isNumber( peekCh ) &&\n            number.charAt( number.length - 1 ) === 'e' ) {\n                    number += ch;\n                } else if ( this.isExpOperator( ch ) &&\n            ( !peekCh || !this.isNumber( peekCh ) ) &&\n            number.charAt( number.length - 1 ) === 'e' ) {\n                    this.throwError( 'Invalid exponent' );\n                } else {\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.tokens.push( {\n            index: start,\n            text: number,\n            constant: true,\n            value: Number( number )\n        } );\n    },\n\n    readIdent: function() {\n        var start = this.index;\n        this.index += this.peekMultichar().length;\n        while ( this.index < this.text.length ) {\n            var ch = this.peekMultichar();\n            if ( !this.isIdentifierContinue( ch ) ) {\n                break;\n            }\n            this.index += ch.length;\n        }\n        this.tokens.push( {\n            index: start,\n            text: this.text.slice( start, this.index ),\n            identifier: true\n        } );\n    },\n\n    readString: function( quote ) {\n        var start = this.index;\n        this.index++;\n        var string = '';\n        var rawString = quote;\n        var escapeVar = false;\n        while ( this.index < this.text.length ) {\n            var ch = this.text.charAt( this.index );\n            rawString += ch;\n            if ( escapeVar ) {\n                if ( ch === 'u' ) {\n                    var hex = this.text.substring( this.index + 1, this.index + 5 );\n                    if ( !hex.match( /[\\da-f]{4}/i ) ) {\n                        this.throwError( 'Invalid unicode escape [\\\\u' + hex + ']' );\n                    }\n                    this.index += 4;\n                    string += String.fromCharCode( parseInt( hex, 16 ) );\n                } else {\n                    var rep = ESCAPE[ch];\n                    string += rep || ch;\n                }\n                escapeVar = false;\n            } else if ( ch === '\\\\' ) {\n                escapeVar = true;\n            } else if ( ch === quote ) {\n                this.index++;\n                this.tokens.push( {\n                    index: start,\n                    text: rawString,\n                    constant: true,\n                    value: string\n                } );\n                return;\n            } else {\n                string += ch;\n            }\n            this.index++;\n        }\n        this.throwError( 'Unterminated quote', start );\n    }\n};\n\nexport var AST = function AST( lexer, options ) {\n    this.lexer = lexer;\n    this.options = options;\n};\n\nAST.Program = 'Program';\nAST.ExpressionStatement = 'ExpressionStatement';\nAST.AssignmentExpression = 'AssignmentExpression';\nAST.ConditionalExpression = 'ConditionalExpression';\nAST.LogicalExpression = 'LogicalExpression';\nAST.BinaryExpression = 'BinaryExpression';\nAST.UnaryExpression = 'UnaryExpression';\nAST.CallExpression = 'CallExpression';\nAST.MemberExpression = 'MemberExpression';\nAST.Identifier = 'Identifier';\nAST.Literal = 'Literal';\nAST.ArrayExpression = 'ArrayExpression';\nAST.Property = 'Property';\nAST.ObjectExpression = 'ObjectExpression';\nAST.ThisExpression = 'ThisExpression';\nAST.LocalsExpression = 'LocalsExpression';\n\n// Internal use only\nAST.NGValueParameter = 'NGValueParameter';\n\nAST.prototype = {\n    ast: function( text ) {\n        this.text = text;\n        this.tokens = this.lexer.lex( text );\n\n        var value = this.program();\n\n        if ( this.tokens.length !== 0 ) {\n            this.throwError( 'is an unexpected token', this.tokens[0] );\n        }\n\n        return value;\n    },\n\n    program: function() {\n        var body = [];\n        while ( true ) {\n            if ( this.tokens.length > 0 && !this.peek( '}', ')', ';', ']' ) ) { body.push( this.expressionStatement() ); }\n            if ( !this.expect( ';' ) ) {\n                return { type: AST.Program, body: body };\n            }\n        }\n    },\n\n    expressionStatement: function() {\n        return { type: AST.ExpressionStatement, expression: this.filterChain() };\n    },\n\n    filterChain: function() {\n        var left = this.expression();\n        while ( this.expect( '|' ) ) {\n            left = this.filter( left );\n        }\n        return left;\n    },\n\n    expression: function() {\n        return this.assignment();\n    },\n\n    assignment: function() {\n        var result = this.ternary();\n        if ( this.expect( '=' ) ) {\n            if ( !isAssignable( result ) ) {\n                throw $parseMinErr( 'lval', 'Trying to assign a value to a non l-value' );\n            }\n\n            result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '=' };\n        }\n        return result;\n    },\n\n    ternary: function() {\n        var test = this.logicalOR();\n        var alternate;\n        var consequent;\n        if ( this.expect( '?' ) ) {\n            alternate = this.expression();\n            if ( this.consume( ':' ) ) {\n                consequent = this.expression();\n                return { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent };\n            }\n        }\n        return test;\n    },\n\n    logicalOR: function() {\n        var left = this.logicalAND();\n        while ( this.expect( '||' ) ) {\n            left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n        }\n        return left;\n    },\n\n    logicalAND: function() {\n        var left = this.equality();\n        while ( this.expect( '&&' ) ) {\n            left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality() };\n        }\n        return left;\n    },\n\n    equality: function() {\n        var left = this.relational();\n        var token;\n        while ( token = this.expect( '==', '!=', '===', '!==' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n        }\n        return left;\n    },\n\n    relational: function() {\n        var left = this.additive();\n        var token;\n        while ( token = this.expect( '<', '>', '<=', '>=' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n        }\n        return left;\n    },\n\n    additive: function() {\n        var left = this.multiplicative();\n        var token;\n        while ( token = this.expect( '+', '-' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n        }\n        return left;\n    },\n\n    multiplicative: function() {\n        var left = this.unary();\n        var token;\n        while ( token = this.expect( '*', '/', '%' ) ) {\n            left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n        }\n        return left;\n    },\n\n    unary: function() {\n        var token;\n        if (  token = this.expect( '+', '-', '!' )  ) {\n            return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n        }\n        return this.primary();\n    },\n\n    primary: function() {\n        var primary;\n        if ( this.expect( '(' ) ) {\n            primary = this.filterChain();\n            this.consume( ')' );\n        } else if ( this.expect( '[' ) ) {\n            primary = this.arrayDeclaration();\n        } else if ( this.expect( '{' ) ) {\n            primary = this.object();\n        } else if ( this.selfReferential.hasOwnProperty( this.peek().text ) ) {\n            primary = copy( this.selfReferential[this.consume().text] );\n        } else if ( this.options.literals.hasOwnProperty( this.peek().text ) ) {\n            primary = { type: AST.Literal, value: this.options.literals[this.consume().text] };\n        } else if ( this.peek().identifier ) {\n            primary = this.identifier();\n        } else if ( this.peek().constant ) {\n            primary = this.constant();\n        } else {\n            this.throwError( 'not a primary expression', this.peek() );\n        }\n\n        var next;\n        while ( next = this.expect( '(', '[', '.' ) ) {\n            if ( next.text === '(' ) {\n                primary = { type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };\n                this.consume( ')' );\n            } else if ( next.text === '[' ) {\n                primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n                this.consume( ']' );\n            } else if ( next.text === '.' ) {\n                primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n            } else {\n                this.throwError( 'IMPOSSIBLE' );\n            }\n        }\n        return primary;\n    },\n\n    filter: function( baseExpression ) {\n        var args = [ baseExpression ];\n        var result = { type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true };\n\n        while ( this.expect( ':' ) ) {\n            args.push( this.expression() );\n        }\n\n        return result;\n    },\n\n    parseArguments: function() {\n        var args = [];\n        if ( this.peekToken().text !== ')' ) {\n            do {\n                args.push( this.filterChain() );\n            } while ( this.expect( ',' ) );\n        }\n        return args;\n    },\n\n    identifier: function() {\n        var token = this.consume();\n        if ( !token.identifier ) {\n            this.throwError( 'is not a valid identifier', token );\n        }\n        return { type: AST.Identifier, name: token.text };\n    },\n\n    constant: function() {\n    // TODO check that it is a constant\n        return { type: AST.Literal, value: this.consume().value };\n    },\n\n    arrayDeclaration: function() {\n        var elements = [];\n        if ( this.peekToken().text !== ']' ) {\n            do {\n                if ( this.peek( ']' ) ) {\n                    // Support trailing commas per ES5.1.\n                    break;\n                }\n                elements.push( this.expression() );\n            } while ( this.expect( ',' ) );\n        }\n        this.consume( ']' );\n\n        return { type: AST.ArrayExpression, elements: elements };\n    },\n\n    object: function() {\n        var properties = []; var\n            property;\n        if ( this.peekToken().text !== '}' ) {\n            do {\n                if ( this.peek( '}' ) ) {\n                    // Support trailing commas per ES5.1.\n                    break;\n                }\n                property = { type: AST.Property, kind: 'init' };\n                if ( this.peek().constant ) {\n                    property.key = this.constant();\n                    property.computed = false;\n                    this.consume( ':' );\n                    property.value = this.expression();\n                } else if ( this.peek().identifier ) {\n                    property.key = this.identifier();\n                    property.computed = false;\n                    if ( this.peek( ':' ) ) {\n                        this.consume( ':' );\n                        property.value = this.expression();\n                    } else {\n                        property.value = property.key;\n                    }\n                } else if ( this.peek( '[' ) ) {\n                    this.consume( '[' );\n                    property.key = this.expression();\n                    this.consume( ']' );\n                    property.computed = true;\n                    this.consume( ':' );\n                    property.value = this.expression();\n                } else {\n                    this.throwError( 'invalid key', this.peek() );\n                }\n                properties.push( property );\n            } while ( this.expect( ',' ) );\n        }\n        this.consume( '}' );\n\n        return { type: AST.ObjectExpression, properties: properties };\n    },\n\n    throwError: function( msg, token ) {\n        throw $parseMinErr( 'syntax',\n            'Syntax Error: Token \\'{0}\\' {1} at column {2} of the expression [{3}] starting at [{4}].',\n            token.text, msg, token.index + 1, this.text, this.text.substring( token.index ) );\n    },\n\n    consume: function( e1 ) {\n        if ( this.tokens.length === 0 ) {\n            throw $parseMinErr( 'ueoe', 'Unexpected end of expression: {0}', this.text );\n        }\n\n        var token = this.expect( e1 );\n        if ( !token ) {\n            this.throwError( 'is unexpected, expecting [' + e1 + ']', this.peek() );\n        }\n        return token;\n    },\n\n    peekToken: function() {\n        if ( this.tokens.length === 0 ) {\n            throw $parseMinErr( 'ueoe', 'Unexpected end of expression: {0}', this.text );\n        }\n        return this.tokens[0];\n    },\n\n    peek: function( e1, e2, e3, e4 ) {\n        return this.peekAhead( 0, e1, e2, e3, e4 );\n    },\n\n    peekAhead: function( i, e1, e2, e3, e4 ) {\n        if ( this.tokens.length > i ) {\n            var token = this.tokens[i];\n            var t = token.text;\n            if ( t === e1 || t === e2 || t === e3 || t === e4 ||\n          !e1 && !e2 && !e3 && !e4 ) {\n                return token;\n            }\n        }\n        return false;\n    },\n\n    expect: function( e1, e2, e3, e4 ) {\n        var token = this.peek( e1, e2, e3, e4 );\n        if ( token ) {\n            this.tokens.shift();\n            return token;\n        }\n        return false;\n    },\n\n    selfReferential: {\n        this: { type: AST.ThisExpression },\n        $locals: { type: AST.LocalsExpression }\n    }\n};\n\nfunction ifDefined( v, d ) {\n    return typeof v !== 'undefined' ? v : d;\n}\n\nfunction plusFn( l, r ) {\n    if ( typeof l === 'undefined' ) { return r; }\n    if ( typeof r === 'undefined' ) { return l; }\n    return l + r;\n}\n\nfunction isStateless( $filter, filterName ) {\n    var fn = $filter( filterName );\n    return !fn.$stateful;\n}\n\nvar PURITY_ABSOLUTE = 1;\nvar PURITY_RELATIVE = 2;\n\n// Detect nodes which could depend on non-shallow state of objects\nfunction isPure( node, parentIsPure ) {\n    switch ( node.type ) {\n    // Computed members might invoke a stateful toString()\n        case AST.MemberExpression:\n            if ( node.computed ) {\n                return false;\n            }\n            break;\n\n            // Unary always convert to primative\n        case AST.UnaryExpression:\n            return PURITY_ABSOLUTE;\n\n            // The binary + operator can invoke a stateful toString().\n        case AST.BinaryExpression:\n            return node.operator !== '+' ? PURITY_ABSOLUTE : false;\n\n            // Functions / filters probably read state from within objects\n        case AST.CallExpression:\n            return false;\n    }\n\n    return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;\n}\n\nfunction findConstantAndWatchExpressions( ast, $filter, parentIsPure ) {\n    var allConstants;\n    var argsToWatch;\n    var isStatelessFilter;\n\n    var astIsPure = ast.isPure = isPure( ast, parentIsPure );\n\n    switch ( ast.type ) {\n        case AST.Program:\n            allConstants = true;\n            forEach( ast.body, function( expr ) {\n                findConstantAndWatchExpressions( expr.expression, $filter, astIsPure );\n                allConstants = allConstants && expr.expression.constant;\n            } );\n            ast.constant = allConstants;\n            break;\n        case AST.Literal:\n            ast.constant = true;\n            ast.toWatch = [];\n            break;\n        case AST.UnaryExpression:\n            findConstantAndWatchExpressions( ast.argument, $filter, astIsPure );\n            ast.constant = ast.argument.constant;\n            ast.toWatch = ast.argument.toWatch;\n            break;\n        case AST.BinaryExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = ast.left.toWatch.concat( ast.right.toWatch );\n            break;\n        case AST.LogicalExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.ConditionalExpression:\n            findConstantAndWatchExpressions( ast.test, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.alternate, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.consequent, $filter, astIsPure );\n            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.Identifier:\n            ast.constant = false;\n            ast.toWatch = [ ast ];\n            break;\n        case AST.MemberExpression:\n            findConstantAndWatchExpressions( ast.object, $filter, astIsPure );\n            if ( ast.computed ) {\n                findConstantAndWatchExpressions( ast.property, $filter, astIsPure );\n            }\n            ast.constant = ast.object.constant && ( !ast.computed || ast.property.constant );\n            ast.toWatch = ast.constant ? [] : [ ast ];\n            break;\n        case AST.CallExpression:\n            isStatelessFilter = ast.filter ? isStateless( $filter, ast.callee.name ) : false;\n            allConstants = isStatelessFilter;\n            argsToWatch = [];\n            forEach( ast.arguments, function( expr ) {\n                findConstantAndWatchExpressions( expr, $filter, astIsPure );\n                allConstants = allConstants && expr.constant;\n                argsToWatch.push.apply( argsToWatch, expr.toWatch );\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];\n            break;\n        case AST.AssignmentExpression:\n            findConstantAndWatchExpressions( ast.left, $filter, astIsPure );\n            findConstantAndWatchExpressions( ast.right, $filter, astIsPure );\n            ast.constant = ast.left.constant && ast.right.constant;\n            ast.toWatch = [ ast ];\n            break;\n        case AST.ArrayExpression:\n            allConstants = true;\n            argsToWatch = [];\n            forEach( ast.elements, function( expr ) {\n                findConstantAndWatchExpressions( expr, $filter, astIsPure );\n                allConstants = allConstants && expr.constant;\n                argsToWatch.push.apply( argsToWatch, expr.toWatch );\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = argsToWatch;\n            break;\n        case AST.ObjectExpression:\n            allConstants = true;\n            argsToWatch = [];\n            forEach( ast.properties, function( property ) {\n                findConstantAndWatchExpressions( property.value, $filter, astIsPure );\n                allConstants = allConstants && property.value.constant;\n                argsToWatch.push.apply( argsToWatch, property.value.toWatch );\n                if ( property.computed ) {\n                    //`{[key]: value}` implicitly does `key.toString()` which may be non-pure\n                    findConstantAndWatchExpressions( property.key, $filter, /*parentIsPure=*/false );\n                    allConstants = allConstants && property.key.constant;\n                    argsToWatch.push.apply( argsToWatch, property.key.toWatch );\n                }\n            } );\n            ast.constant = allConstants;\n            ast.toWatch = argsToWatch;\n            break;\n        case AST.ThisExpression:\n            ast.constant = false;\n            ast.toWatch = [];\n            break;\n        case AST.LocalsExpression:\n            ast.constant = false;\n            ast.toWatch = [];\n            break;\n    }\n}\n\nfunction getInputs( body ) {\n    if ( body.length !== 1 ) { return; }\n    var lastExpression = body[0].expression;\n    var candidate = lastExpression.toWatch;\n    if ( candidate.length !== 1 ) { return candidate; }\n    return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable( ast ) {\n    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST( ast ) {\n    if ( ast.body.length === 1 && isAssignable( ast.body[0].expression ) ) {\n        return { type: AST.AssignmentExpression, left: ast.body[0].expression, right: { type: AST.NGValueParameter }, operator: '=' };\n    }\n}\n\nfunction isLiteral( ast ) {\n    return ast.body.length === 0 ||\n      ast.body.length === 1 && (\n          ast.body[0].expression.type === AST.Literal ||\n      ast.body[0].expression.type === AST.ArrayExpression ||\n      ast.body[0].expression.type === AST.ObjectExpression );\n}\n\nfunction isConstant( ast ) {\n    return ast.constant;\n}\n\nexport function ASTCompiler( $filter ) {\n    this.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n    compile: function( ast ) {\n        var self = this;\n        this.state = {\n            nextId: 0,\n            filters: {},\n            fn: { vars: [], body: [], own: {} },\n            assign: { vars: [], body: [], own: {} },\n            inputs: []\n        };\n        findConstantAndWatchExpressions( ast, self.$filter );\n        var extra = '';\n        var assignable;\n        this.stage = 'assign';\n        if ( assignable = assignableAST( ast ) ) {\n            this.state.computing = 'assign';\n            var result = this.nextId();\n            this.recurse( assignable, result );\n            this.return_( result );\n            extra = 'fn.assign=' + this.generateFunction( 'assign', 's,v,l' );\n        }\n        var toWatch = getInputs( ast.body );\n        self.stage = 'inputs';\n        forEach( toWatch, function( watch, key ) {\n            var fnKey = 'fn' + key;\n            self.state[fnKey] = { vars: [], body: [], own: {} };\n            self.state.computing = fnKey;\n            var intoId = self.nextId();\n            self.recurse( watch, intoId );\n            self.return_( intoId );\n            self.state.inputs.push( { name: fnKey, isPure: watch.isPure } );\n            watch.watchId = key;\n        } );\n        this.state.computing = 'fn';\n        this.stage = 'main';\n        this.recurse( ast );\n        var fnString =\n      // The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n      // This is a workaround for this until we do a better job at only removing the prefix only when we should.\n      '\"' + this.USE + ' ' + this.STRICT + '\";\\n' +\n      this.filterPrefix() +\n      'var fn=' + this.generateFunction( 'fn', 's,l,a,i' ) +\n      extra +\n      this.watchFns() +\n      'return fn;';\n\n        // eslint-disable-next-line no-new-func\n        var fn = new Function( '$filter',\n            'getStringValue',\n            'ifDefined',\n            'plus',\n            fnString )(\n            this.$filter,\n            getStringValue,\n            ifDefined,\n            plusFn );\n        this.state = this.stage = undefined;\n        return fn;\n    },\n\n    USE: 'use',\n\n    STRICT: 'strict',\n\n    watchFns: function() {\n        var result = [];\n        var inputs = this.state.inputs;\n        var self = this;\n        forEach( inputs, function( input ) {\n            result.push( 'var ' + input.name + '=' + self.generateFunction( input.name, 's' ) );\n            if ( input.isPure ) {\n                result.push( input.name, '.isPure=' + JSON.stringify( input.isPure ) + ';' );\n            }\n        } );\n        if ( inputs.length ) {\n            result.push( 'fn.inputs=[' + inputs.map( function( i ) { return i.name; } ).join( ',' ) + '];' );\n        }\n        return result.join( '' );\n    },\n\n    generateFunction: function( name, params ) {\n        return 'function(' + params + '){' +\n        this.varsPrefix( name ) +\n        this.body( name ) +\n        '};';\n    },\n\n    filterPrefix: function() {\n        var parts = [];\n        var self = this;\n        forEach( this.state.filters, function( id, filter ) {\n            parts.push( id + '=$filter(' + self.escape( filter ) + ')' );\n        } );\n        if ( parts.length ) { return 'var ' + parts.join( ',' ) + ';'; }\n        return '';\n    },\n\n    varsPrefix: function( section ) {\n        return this.state[section].vars.length ? 'var ' + this.state[section].vars.join( ',' ) + ';' : '';\n    },\n\n    body: function( section ) {\n        return this.state[section].body.join( '' );\n    },\n\n    recurse: function( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck ) {\n        var left; var right; var self = this; var args; var expression; var computed;\n        recursionFn = recursionFn || noop;\n        if ( !skipWatchIdCheck && isDefined( ast.watchId ) ) {\n            intoId = intoId || this.nextId();\n            this.if_( 'i',\n                this.lazyAssign( intoId, this.computedMember( 'i', ast.watchId ) ),\n                this.lazyRecurse( ast, intoId, nameId, recursionFn, create, true )\n            );\n            return;\n        }\n        switch ( ast.type ) {\n            case AST.Program:\n                forEach( ast.body, function( expression, pos ) {\n                    self.recurse( expression.expression, undefined, undefined, function( expr ) { right = expr; } );\n                    if ( pos !== ast.body.length - 1 ) {\n                        self.current().body.push( right, ';' );\n                    } else {\n                        self.return_( right );\n                    }\n                } );\n                break;\n            case AST.Literal:\n                expression = this.escape( ast.value );\n                this.assign( intoId, expression );\n                recursionFn( intoId || expression );\n                break;\n            case AST.UnaryExpression:\n                this.recurse( ast.argument, undefined, undefined, function( expr ) { right = expr; } );\n                expression = ast.operator + '(' + this.ifDefined( right, 0 ) + ')';\n                this.assign( intoId, expression );\n                recursionFn( expression );\n                break;\n            case AST.BinaryExpression:\n                this.recurse( ast.left, undefined, undefined, function( expr ) { left = expr; } );\n                this.recurse( ast.right, undefined, undefined, function( expr ) { right = expr; } );\n                if ( ast.operator === '+' ) {\n                    expression = this.plus( left, right );\n                } else if ( ast.operator === '-' ) {\n                    expression = this.ifDefined( left, 0 ) + ast.operator + this.ifDefined( right, 0 );\n                } else {\n                    expression = '(' + left + ')' + ast.operator + '(' + right + ')';\n                }\n                this.assign( intoId, expression );\n                recursionFn( expression );\n                break;\n            case AST.LogicalExpression:\n                intoId = intoId || this.nextId();\n                self.recurse( ast.left, intoId );\n                self.if_( ast.operator === '&&' ? intoId : self.not( intoId ), self.lazyRecurse( ast.right, intoId ) );\n                recursionFn( intoId );\n                break;\n            case AST.ConditionalExpression:\n                intoId = intoId || this.nextId();\n                self.recurse( ast.test, intoId );\n                self.if_( intoId, self.lazyRecurse( ast.alternate, intoId ), self.lazyRecurse( ast.consequent, intoId ) );\n                recursionFn( intoId );\n                break;\n            case AST.Identifier:\n                intoId = intoId || this.nextId();\n                if ( nameId ) {\n                    nameId.context = self.stage === 'inputs' ? 's' : this.assign( this.nextId(), this.getHasOwnProperty( 'l', ast.name ) + '?l:s' );\n                    nameId.computed = false;\n                    nameId.name = ast.name;\n                }\n                self.if_( self.stage === 'inputs' || self.not( self.getHasOwnProperty( 'l', ast.name ) ),\n                    function() {\n                        self.if_( self.stage === 'inputs' || 's', function() {\n                            if ( create && create !== 1 ) {\n                                self.if_(\n                                    self.isNull( self.nonComputedMember( 's', ast.name ) ),\n                                    self.lazyAssign( self.nonComputedMember( 's', ast.name ), '{}' ) );\n                            }\n                            self.assign( intoId, self.nonComputedMember( 's', ast.name ) );\n                        } );\n                    }, intoId && self.lazyAssign( intoId, self.nonComputedMember( 'l', ast.name ) )\n                );\n                recursionFn( intoId );\n                break;\n            case AST.MemberExpression:\n                left = nameId && ( nameId.context = this.nextId() ) || this.nextId();\n                intoId = intoId || this.nextId();\n                self.recurse( ast.object, left, undefined, function() {\n                    self.if_( self.notNull( left ), function() {\n                        if ( ast.computed ) {\n                            right = self.nextId();\n                            self.recurse( ast.property, right );\n                            self.getStringValue( right );\n                            if ( create && create !== 1 ) {\n                                self.if_( self.not( self.computedMember( left, right ) ), self.lazyAssign( self.computedMember( left, right ), '{}' ) );\n                            }\n                            expression = self.computedMember( left, right );\n                            self.assign( intoId, expression );\n                            if ( nameId ) {\n                                nameId.computed = true;\n                                nameId.name = right;\n                            }\n                        } else {\n                            if ( create && create !== 1 ) {\n                                self.if_( self.isNull( self.nonComputedMember( left, ast.property.name ) ), self.lazyAssign( self.nonComputedMember( left, ast.property.name ), '{}' ) );\n                            }\n                            expression = self.nonComputedMember( left, ast.property.name );\n                            self.assign( intoId, expression );\n                            if ( nameId ) {\n                                nameId.computed = false;\n                                nameId.name = ast.property.name;\n                            }\n                        }\n                    }, function() {\n                        self.assign( intoId, 'undefined' );\n                    } );\n                    recursionFn( intoId );\n                }, Boolean( create ) );\n                break;\n            case AST.CallExpression:\n                intoId = intoId || this.nextId();\n                if ( ast.filter ) {\n                    right = self.filter( ast.callee.name );\n                    args = [];\n                    forEach( ast.arguments, function( expr ) {\n                        var argument = self.nextId();\n                        self.recurse( expr, argument );\n                        args.push( argument );\n                    } );\n                    expression = right + '(' + args.join( ',' ) + ')';\n                    self.assign( intoId, expression );\n                    recursionFn( intoId );\n                } else {\n                    right = self.nextId();\n                    left = {};\n                    args = [];\n                    self.recurse( ast.callee, right, left, function() {\n                        self.if_( self.notNull( right ), function() {\n                            forEach( ast.arguments, function( expr ) {\n                                self.recurse( expr, ast.constant ? undefined : self.nextId(), undefined, function( argument ) {\n                                    args.push( argument );\n                                } );\n                            } );\n                            if ( left.name ) {\n                                expression = self.member( left.context, left.name, left.computed ) + '(' + args.join( ',' ) + ')';\n                            } else {\n                                expression = right + '(' + args.join( ',' ) + ')';\n                            }\n                            self.assign( intoId, expression );\n                        }, function() {\n                            self.assign( intoId, 'undefined' );\n                        } );\n                        recursionFn( intoId );\n                    } );\n                }\n                break;\n            case AST.AssignmentExpression:\n                right = this.nextId();\n                left = {};\n                this.recurse( ast.left, undefined, left, function() {\n                    self.if_( self.notNull( left.context ), function() {\n                        self.recurse( ast.right, right );\n                        expression = self.member( left.context, left.name, left.computed ) + ast.operator + right;\n                        self.assign( intoId, expression );\n                        recursionFn( intoId || expression );\n                    } );\n                }, 1 );\n                break;\n            case AST.ArrayExpression:\n                args = [];\n                forEach( ast.elements, function( expr ) {\n                    self.recurse( expr, ast.constant ? undefined : self.nextId(), undefined, function( argument ) {\n                        args.push( argument );\n                    } );\n                } );\n                expression = '[' + args.join( ',' ) + ']';\n                this.assign( intoId, expression );\n                recursionFn( intoId || expression );\n                break;\n            case AST.ObjectExpression:\n                args = [];\n                computed = false;\n                forEach( ast.properties, function( property ) {\n                    if ( property.computed ) {\n                        computed = true;\n                    }\n                } );\n                if ( computed ) {\n                    intoId = intoId || this.nextId();\n                    this.assign( intoId, '{}' );\n                    forEach( ast.properties, function( property ) {\n                        if ( property.computed ) {\n                            left = self.nextId();\n                            self.recurse( property.key, left );\n                        } else {\n                            left = property.key.type === AST.Identifier ?\n                                property.key.name :\n                                String( property.key.value );\n                        }\n                        right = self.nextId();\n                        self.recurse( property.value, right );\n                        self.assign( self.member( intoId, left, property.computed ), right );\n                    } );\n                } else {\n                    forEach( ast.properties, function( property ) {\n                        self.recurse( property.value, ast.constant ? undefined : self.nextId(), undefined, function( expr ) {\n                            args.push( self.escape(\n                                property.key.type === AST.Identifier ? property.key.name :\n                                    String( property.key.value ) ) +\n                ':' + expr );\n                        } );\n                    } );\n                    expression = '{' + args.join( ',' ) + '}';\n                    this.assign( intoId, expression );\n                }\n                recursionFn( intoId || expression );\n                break;\n            case AST.ThisExpression:\n                this.assign( intoId, 's' );\n                recursionFn( intoId || 's' );\n                break;\n            case AST.LocalsExpression:\n                this.assign( intoId, 'l' );\n                recursionFn( intoId || 'l' );\n                break;\n            case AST.NGValueParameter:\n                this.assign( intoId, 'v' );\n                recursionFn( intoId || 'v' );\n                break;\n        }\n    },\n\n    getHasOwnProperty: function( element, property ) {\n        var key = element + '.' + property;\n        var own = this.current().own;\n        if ( !own.hasOwnProperty( key ) ) {\n            own[key] = this.nextId( false, element + '&&(' + this.escape( property ) + ' in ' + element + ')' );\n        }\n        return own[key];\n    },\n\n    assign: function( id, value ) {\n        if ( !id ) { return; }\n        this.current().body.push( id, '=', value, ';' );\n        return id;\n    },\n\n    filter: function( filterName ) {\n        if ( !this.state.filters.hasOwnProperty( filterName ) ) {\n            this.state.filters[filterName] = this.nextId( true );\n        }\n        return this.state.filters[filterName];\n    },\n\n    ifDefined: function( id, defaultValue ) {\n        return 'ifDefined(' + id + ',' + this.escape( defaultValue ) + ')';\n    },\n\n    plus: function( left, right ) {\n        return 'plus(' + left + ',' + right + ')';\n    },\n\n    return_: function( id ) {\n        this.current().body.push( 'return ', id, ';' );\n    },\n\n    if_: function( test, alternate, consequent ) {\n        if ( test === true ) {\n            alternate();\n        } else {\n            var body = this.current().body;\n            body.push( 'if(', test, '){' );\n            alternate();\n            body.push( '}' );\n            if ( consequent ) {\n                body.push( 'else{' );\n                consequent();\n                body.push( '}' );\n            }\n        }\n    },\n\n    not: function( expression ) {\n        return '!(' + expression + ')';\n    },\n\n    isNull: function( expression ) {\n        return expression + '==null';\n    },\n\n    notNull: function( expression ) {\n        return expression + '!=null';\n    },\n\n    nonComputedMember: function( left, right ) {\n        var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n        var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n        if ( SAFE_IDENTIFIER.test( right ) ) {\n            return left + '.' + right;\n        }\n        return left  + '[\"' + right.replace( UNSAFE_CHARACTERS, this.stringEscapeFn ) + '\"]';\n    },\n\n    computedMember: function( left, right ) {\n        return left + '[' + right + ']';\n    },\n\n    member: function( left, right, computed ) {\n        if ( computed ) { return this.computedMember( left, right ); }\n        return this.nonComputedMember( left, right );\n    },\n\n    getStringValue: function( item ) {\n        this.assign( item, 'getStringValue(' + item + ')' );\n    },\n\n    lazyRecurse: function( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck ) {\n        var self = this;\n        return function() {\n            self.recurse( ast, intoId, nameId, recursionFn, create, skipWatchIdCheck );\n        };\n    },\n\n    lazyAssign: function( id, value ) {\n        var self = this;\n        return function() {\n            self.assign( id, value );\n        };\n    },\n\n    stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n    stringEscapeFn: function( c ) {\n        return '\\\\u' + ( '0000' + c.charCodeAt( 0 ).toString( 16 ) ).slice( -4 );\n    },\n\n    escape: function( value ) {\n        if ( isString( value ) ) { return '\\'' + value.replace( this.stringEscapeRegex, this.stringEscapeFn ) + '\\''; }\n        if ( isNumber( value ) ) { return value.toString(); }\n        if ( value === true ) { return 'true'; }\n        if ( value === false ) { return 'false'; }\n        if ( value === null ) { return 'null'; }\n        if ( typeof value === 'undefined' ) { return 'undefined'; }\n\n        throw $parseMinErr( 'esc', 'IMPOSSIBLE' );\n    },\n\n    nextId: function( skip, init ) {\n        var id = 'v' + this.state.nextId++;\n        if ( !skip ) {\n            this.current().vars.push( id + ( init ? '=' + init : '' ) );\n        }\n        return id;\n    },\n\n    current: function() {\n        return this.state[this.state.computing];\n    }\n};\n\n\nexport function ASTInterpreter( $filter ) {\n    this.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n    compile: function( ast ) {\n        var self = this;\n        findConstantAndWatchExpressions( ast, self.$filter );\n        var assignable;\n        var assign;\n        if ( assignable = assignableAST( ast ) ) {\n            assign = this.recurse( assignable );\n        }\n        var toWatch = getInputs( ast.body );\n        var inputs;\n        if ( toWatch ) {\n            inputs = [];\n            forEach( toWatch, function( watch, key ) {\n                var input = self.recurse( watch );\n                input.isPure = watch.isPure;\n                watch.input = input;\n                inputs.push( input );\n                watch.watchId = key;\n            } );\n        }\n        var expressions = [];\n        forEach( ast.body, function( expression ) {\n            expressions.push( self.recurse( expression.expression ) );\n        } );\n        var fn = ast.body.length === 0 ? noop :\n            ast.body.length === 1 ? expressions[0] :\n                function( scope, locals ) {\n                    var lastValue;\n                    forEach( expressions, function( exp ) {\n                        lastValue = exp( scope, locals );\n                    } );\n                    return lastValue;\n                };\n        if ( assign ) {\n            fn.assign = function( scope, value, locals ) {\n                return assign( scope, locals, value );\n            };\n        }\n        if ( inputs ) {\n            fn.inputs = inputs;\n        }\n        return fn;\n    },\n\n    recurse: function( ast, context, create ) {\n        var left; var right; var self = this; var\n            args;\n        if ( ast.input ) {\n            return this.inputs( ast.input, ast.watchId );\n        }\n        switch ( ast.type ) {\n            case AST.Literal:\n                return this.value( ast.value, context );\n            case AST.UnaryExpression:\n                right = this.recurse( ast.argument );\n                return this['unary' + ast.operator]( right, context );\n            case AST.BinaryExpression:\n                left = this.recurse( ast.left );\n                right = this.recurse( ast.right );\n                return this['binary' + ast.operator]( left, right, context );\n            case AST.LogicalExpression:\n                left = this.recurse( ast.left );\n                right = this.recurse( ast.right );\n                return this['binary' + ast.operator]( left, right, context );\n            case AST.ConditionalExpression:\n                return this['ternary?:'](\n                    this.recurse( ast.test ),\n                    this.recurse( ast.alternate ),\n                    this.recurse( ast.consequent ),\n                    context\n                );\n            case AST.Identifier:\n                return self.identifier( ast.name, context, create );\n            case AST.MemberExpression:\n                left = this.recurse( ast.object, false, Boolean( create ) );\n                if ( !ast.computed ) {\n                    right = ast.property.name;\n                }\n                if ( ast.computed ) { right = this.recurse( ast.property ); }\n                return ast.computed ?\n                    this.computedMember( left, right, context, create ) :\n                    this.nonComputedMember( left, right, context, create );\n            case AST.CallExpression:\n                args = [];\n                forEach( ast.arguments, function( expr ) {\n                    args.push( self.recurse( expr ) );\n                } );\n                if ( ast.filter ) { right = this.$filter( ast.callee.name ); }\n                if ( !ast.filter ) { right = this.recurse( ast.callee, true ); }\n                return ast.filter ?\n                    function( scope, locals, assign, inputs ) {\n                        var values = [];\n                        for ( var i = 0; i < args.length; ++i ) {\n                            values.push( args[i]( scope, locals, assign, inputs ) );\n                        }\n                        var value = right.apply( undefined, values, inputs );\n                        return context ? { context: undefined, name: undefined, value: value } : value;\n                    } :\n                    function( scope, locals, assign, inputs ) {\n                        var rhs = right( scope, locals, assign, inputs );\n                        var value;\n                        if ( rhs.value != null ) {\n                            var values = [];\n                            for ( var i = 0; i < args.length; ++i ) {\n                                values.push( args[i]( scope, locals, assign, inputs ) );\n                            }\n                            value = rhs.value.apply( rhs.context, values );\n                        }\n                        return context ? { value: value } : value;\n                    };\n            case AST.AssignmentExpression:\n                left = this.recurse( ast.left, true, 1 );\n                right = this.recurse( ast.right );\n                return function( scope, locals, assign, inputs ) {\n                    var lhs = left( scope, locals, assign, inputs );\n                    var rhs = right( scope, locals, assign, inputs );\n                    lhs.context[lhs.name] = rhs;\n                    return context ? { value: rhs } : rhs;\n                };\n            case AST.ArrayExpression:\n                args = [];\n                forEach( ast.elements, function( expr ) {\n                    args.push( self.recurse( expr ) );\n                } );\n                return function( scope, locals, assign, inputs ) {\n                    var value = [];\n                    for ( var i = 0; i < args.length; ++i ) {\n                        value.push( args[i]( scope, locals, assign, inputs ) );\n                    }\n                    return context ? { value: value } : value;\n                };\n            case AST.ObjectExpression:\n                args = [];\n                forEach( ast.properties, function( property ) {\n                    if ( property.computed ) {\n                        args.push( { key: self.recurse( property.key ),\n                            computed: true,\n                            value: self.recurse( property.value )\n                        } );\n                    } else {\n                        args.push( { key: property.key.type === AST.Identifier ?\n                            property.key.name :\n                            String( property.key.value ),\n                        computed: false,\n                        value: self.recurse( property.value )\n                        } );\n                    }\n                } );\n                return function( scope, locals, assign, inputs ) {\n                    var value = {};\n                    for ( var i = 0; i < args.length; ++i ) {\n                        if ( args[i].computed ) {\n                            value[args[i].key( scope, locals, assign, inputs )] = args[i].value( scope, locals, assign, inputs );\n                        } else {\n                            value[args[i].key] = args[i].value( scope, locals, assign, inputs );\n                        }\n                    }\n                    return context ? { value: value } : value;\n                };\n            case AST.ThisExpression:\n                return function( scope ) {\n                    return context ? { value: scope } : scope;\n                };\n            case AST.LocalsExpression:\n                return function( scope, locals ) {\n                    return context ? { value: locals } : locals;\n                };\n            case AST.NGValueParameter:\n                return function( scope, locals, assign ) {\n                    return context ? { value: assign } : assign;\n                };\n        }\n    },\n\n    'unary+': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = argument( scope, locals, assign, inputs );\n            if ( isDefined( arg ) ) {\n                arg = Number( arg );\n            } else {\n                arg = 0;\n            }\n            return context ? { value: arg } : arg;\n        };\n    },\n    'unary-': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = argument( scope, locals, assign, inputs );\n            if ( isDefined( arg ) ) {\n                arg = -arg;\n            } else {\n                arg = -0;\n            }\n            return context ? { value: arg } : arg;\n        };\n    },\n    'unary!': function( argument, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = !argument( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary+': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs = right( scope, locals, assign, inputs );\n            var arg = plusFn( lhs, rhs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary-': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs = right( scope, locals, assign, inputs );\n            var arg = ( isDefined( lhs ) ? lhs : 0 ) - ( isDefined( rhs ) ? rhs : 0 );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary*': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) * right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary/': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) / right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary%': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) % right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary===': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) === right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary!==': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) !== right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary==': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            // eslint-disable-next-line eqeqeq\n            var arg = left( scope, locals, assign, inputs ) == right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary!=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            // eslint-disable-next-line eqeqeq\n            var arg = left( scope, locals, assign, inputs ) != right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary<': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) < right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary>': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) > right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary<=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) <= right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary>=': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) >= right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary&&': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) && right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'binary||': function( left, right, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = left( scope, locals, assign, inputs ) || right( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    'ternary?:': function( test, alternate, consequent, context ) {\n        return function( scope, locals, assign, inputs ) {\n            var arg = test( scope, locals, assign, inputs ) ? alternate( scope, locals, assign, inputs ) : consequent( scope, locals, assign, inputs );\n            return context ? { value: arg } : arg;\n        };\n    },\n    value: function( value, context ) {\n        return function() { return context ? { context: undefined, name: undefined, value: value } : value; };\n    },\n    identifier: function( name, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var base = locals && name in locals ? locals : scope;\n            if ( create && create !== 1 && base && base[name] == null ) {\n                base[name] = {};\n            }\n            var value = base ? base[name] : undefined;\n            if ( context ) {\n                return { context: base, name: name, value: value };\n            }\n            return value;\n        };\n    },\n    computedMember: function( left, right, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            var rhs;\n            var value;\n            if ( lhs != null ) {\n                rhs = right( scope, locals, assign, inputs );\n                rhs = getStringValue( rhs );\n                if ( create && create !== 1 ) {\n                    if ( lhs && !lhs[rhs] ) {\n                        lhs[rhs] = {};\n                    }\n                }\n                value = lhs[rhs];\n            }\n            if ( context ) {\n                return { context: lhs, name: rhs, value: value };\n            }\n            return value;\n        };\n    },\n    nonComputedMember: function( left, right, context, create ) {\n        return function( scope, locals, assign, inputs ) {\n            var lhs = left( scope, locals, assign, inputs );\n            if ( create && create !== 1 ) {\n                if ( lhs && lhs[right] == null ) {\n                    lhs[right] = {};\n                }\n            }\n            var value = lhs != null ? lhs[right] : undefined;\n            if ( context ) {\n                return { context: lhs, name: right, value: value };\n            }\n            return value;\n        };\n    },\n    inputs: function( input, watchId ) {\n        return function( scope, value, locals, inputs ) {\n            if ( inputs ) { return inputs[watchId]; }\n            return input( scope, value, locals );\n        };\n    }\n};\n\n/**\n * @constructor\n */\nexport function Parser( lexer, $filter, options ) {\n    this.ast = new AST( lexer, options );\n    this.astCompiler = options.csp ? new ASTInterpreter( $filter ) :\n        new ASTCompiler( $filter );\n}\n\nParser.prototype = {\n    constructor: Parser,\n\n    parse: function( text ) {\n        var ast = this.getAst( text );\n        var fn = this.astCompiler.compile( ast.ast );\n        fn.literal = isLiteral( ast.ast );\n        fn.constant = isConstant( ast.ast );\n        fn.oneTime = ast.oneTime;\n        return fn;\n    },\n\n    getAst: function( exp ) {\n        var oneTime = false;\n        exp = exp.trim();\n\n        if ( exp.charAt( 0 ) === ':' && exp.charAt( 1 ) === ':' ) {\n            oneTime = true;\n            exp = exp.substring( 2 );\n        }\n        return {\n            ast: this.ast.ast( exp ),\n            oneTime: oneTime\n        };\n    }\n};\n\nfunction getValueOf( value ) {\n    return isFunction( value.valueOf ) ? value.valueOf() : objectValueOf.call( value );\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts AngularJS {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'AngularJS'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('AngularJS');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\nexport function $ParseProvider() {\n    var cache = createMap();\n    var literals = {\n        true: true,\n        false: false,\n        null: null,\n        undefined: undefined\n    };\n    var identStart; var identContinue;\n\n    /**\n   * @ngdoc method\n   * @name $parseProvider#addLiteral\n   * @description\n   *\n   * Configure $parse service to add literal values that will be present as literal at expressions.\n   *\n   * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n   * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n   *\n   **/\n    this.addLiteral = function( literalName, literalValue ) {\n        literals[literalName] = literalValue;\n    };\n\n    /**\n  * @ngdoc method\n  * @name $parseProvider#setIdentifierFns\n  *\n  * @description\n  *\n  * Allows defining the set of characters that are allowed in AngularJS expressions. The function\n  * `identifierStart` will get called to know if a given character is a valid character to be the\n  * first character for an identifier. The function `identifierContinue` will get called to know if\n  * a given character is a valid character to be a follow-up identifier character. The functions\n  * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n  * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n  * mind that the `string` parameter can be two characters long depending on the character\n  * representation. It is expected for the function to return `true` or `false`, whether that\n  * character is allowed or not.\n  *\n  * Since this function will be called extensively, keep the implementation of these functions fast,\n  * as the performance of these functions have a direct impact on the expressions parsing speed.\n  *\n  * @param {function=} identifierStart The function that will decide whether the given character is\n  *   a valid identifier start character.\n  * @param {function=} identifierContinue The function that will decide whether the given character is\n  *   a valid identifier continue character.\n  */\n    this.setIdentifierFns = function( identifierStart, identifierContinue ) {\n        identStart = identifierStart;\n        identContinue = identifierContinue;\n        return this;\n    };\n\n    this.$get = [ '$filter', function( $filter ) {\n        var noUnsafeEval = false; //csp().noUnsafeEval;\n        var $parseOptions = {\n            csp: noUnsafeEval,\n            literals: copy( literals ),\n            isIdentifierStart: isFunction( identStart ) && identStart,\n            isIdentifierContinue: isFunction( identContinue ) && identContinue\n        };\n        $parse.$$getAst = $$getAst;\n        return $parse;\n\n        function $parse( exp, interceptorFn ) {\n            var parsedExpression; var cacheKey;\n\n            switch ( typeof exp ) {\n                case 'string':\n                    exp = exp.trim();\n                    cacheKey = exp;\n\n                    parsedExpression = cache[cacheKey];\n\n                    if ( !parsedExpression ) {\n                        var lexer = new Lexer( $parseOptions );\n                        var parser = new Parser( lexer, $filter, $parseOptions );\n                        parsedExpression = parser.parse( exp );\n\n                        cache[cacheKey] = addWatchDelegate( parsedExpression );\n                    }\n                    return addInterceptor( parsedExpression, interceptorFn );\n\n                case 'function':\n                    return addInterceptor( exp, interceptorFn );\n\n                default:\n                    return addInterceptor( noop, interceptorFn );\n            }\n        }\n\n        function $$getAst( exp ) {\n            var lexer = new Lexer( $parseOptions );\n            var parser = new Parser( lexer, $filter, $parseOptions );\n            return parser.getAst( exp ).ast;\n        }\n\n        function expressionInputDirtyCheck( newValue, oldValueOfValue, compareObjectIdentity ) {\n            if ( newValue == null || oldValueOfValue == null ) { // null/undefined\n                return newValue === oldValueOfValue;\n            }\n\n            if ( typeof newValue === 'object' ) {\n                // attempt to convert the value to a primitive type\n                // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n                //             be cheaply dirty-checked\n                newValue = getValueOf( newValue );\n\n                if ( typeof newValue === 'object' && !compareObjectIdentity ) {\n                    // objects/arrays are not supported - deep-watching them would be too expensive\n                    return false;\n                }\n\n                // fall-through to the primitive equality check\n            }\n\n            //Primitive or NaN\n            // eslint-disable-next-line no-self-compare\n            return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;\n        }\n\n        function inputsWatchDelegate( scope, listener, objectEquality, parsedExpression, prettyPrintExpression ) {\n            var inputExpressions = parsedExpression.inputs;\n            var lastResult;\n\n            if ( inputExpressions.length === 1 ) {\n                var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n                inputExpressions = inputExpressions[0];\n                return scope.$watch( function expressionInputWatch( scope ) {\n                    var newInputValue = inputExpressions( scope );\n                    if ( !expressionInputDirtyCheck( newInputValue, oldInputValueOf, inputExpressions.isPure ) ) {\n                        lastResult = parsedExpression( scope, undefined, undefined, [ newInputValue ] );\n                        oldInputValueOf = newInputValue && getValueOf( newInputValue );\n                    }\n                    return lastResult;\n                }, listener, objectEquality, prettyPrintExpression );\n            }\n\n            var oldInputValueOfValues = [];\n            var oldInputValues = [];\n            for ( var i = 0, ii = inputExpressions.length; i < ii; i++ ) {\n                oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n                oldInputValues[i] = null;\n            }\n\n            return scope.$watch( function expressionInputsWatch( scope ) {\n                var changed = false;\n\n                for ( var i = 0, ii = inputExpressions.length; i < ii; i++ ) {\n                    var newInputValue = inputExpressions[i]( scope );\n                    if ( changed || ( changed = !expressionInputDirtyCheck( newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure ) ) ) {\n                        oldInputValues[i] = newInputValue;\n                        oldInputValueOfValues[i] = newInputValue && getValueOf( newInputValue );\n                    }\n                }\n\n                if ( changed ) {\n                    lastResult = parsedExpression( scope, undefined, undefined, oldInputValues );\n                }\n\n                return lastResult;\n            }, listener, objectEquality, prettyPrintExpression );\n        }\n\n        function oneTimeWatchDelegate( scope, listener, objectEquality, parsedExpression, prettyPrintExpression ) {\n            var isDone = parsedExpression.literal ? isAllDefined : isDefined;\n            var unwatch; var lastValue;\n\n            var exp = parsedExpression.$$intercepted || parsedExpression;\n            var post = parsedExpression.$$interceptor || identity;\n\n            var useInputs = parsedExpression.inputs && !exp.inputs;\n\n            // Propagate the literal/inputs/constant attributes\n            // ... but not oneTime since we are handling it\n            oneTimeWatch.literal = parsedExpression.literal;\n            oneTimeWatch.constant = parsedExpression.constant;\n            oneTimeWatch.inputs = parsedExpression.inputs;\n\n            // Allow other delegates to run on this wrapped expression\n            addWatchDelegate( oneTimeWatch );\n\n            unwatch = scope.$watch( oneTimeWatch, listener, objectEquality, prettyPrintExpression );\n\n            return unwatch;\n\n            function unwatchIfDone() {\n                if ( isDone( lastValue ) ) {\n                    unwatch();\n                }\n            }\n\n            function oneTimeWatch( scope, locals, assign, inputs ) {\n                lastValue = useInputs && inputs ? inputs[0] : exp( scope, locals, assign, inputs );\n                if ( isDone( lastValue ) ) {\n                    scope.$$postDigest( unwatchIfDone );\n                }\n                return post( lastValue );\n            }\n        }\n\n        function isAllDefined( value ) {\n            var allDefined = true;\n            forEach( value, function( val ) {\n                if ( !isDefined( val ) ) { allDefined = false; }\n            } );\n            return allDefined;\n        }\n\n        function constantWatchDelegate( scope, listener, objectEquality, parsedExpression ) {\n            var unwatch = scope.$watch( function constantWatch( scope ) {\n                unwatch();\n                return parsedExpression( scope );\n            }, listener, objectEquality );\n            return unwatch;\n        }\n\n        function addWatchDelegate( parsedExpression ) {\n            if ( parsedExpression.constant ) {\n                parsedExpression.$$watchDelegate = constantWatchDelegate;\n            } else if ( parsedExpression.oneTime ) {\n                parsedExpression.$$watchDelegate = oneTimeWatchDelegate;\n            } else if ( parsedExpression.inputs ) {\n                parsedExpression.$$watchDelegate = inputsWatchDelegate;\n            }\n\n            return parsedExpression;\n        }\n\n        function chainInterceptors( first, second ) {\n            function chainedInterceptor( value ) {\n                return second( first( value ) );\n            }\n            chainedInterceptor.$stateful = first.$stateful || second.$stateful;\n            chainedInterceptor.$$pure = first.$$pure && second.$$pure;\n\n            return chainedInterceptor;\n        }\n\n        function addInterceptor( parsedExpression, interceptorFn ) {\n            if ( !interceptorFn ) { return parsedExpression; }\n\n            // Extract any existing interceptors out of the parsedExpression\n            // to ensure the original parsedExpression is always the $$intercepted\n            if ( parsedExpression.$$interceptor ) {\n                interceptorFn = chainInterceptors( parsedExpression.$$interceptor, interceptorFn );\n                parsedExpression = parsedExpression.$$intercepted;\n            }\n\n            var useInputs = false;\n\n            var fn = function interceptedExpression( scope, locals, assign, inputs ) {\n                var value = useInputs && inputs ? inputs[0] : parsedExpression( scope, locals, assign, inputs );\n                return interceptorFn( value );\n            };\n\n            // Maintain references to the interceptor/intercepted\n            fn.$$intercepted = parsedExpression;\n            fn.$$interceptor = interceptorFn;\n\n            // Propagate the literal/oneTime/constant attributes\n            fn.literal = parsedExpression.literal;\n            fn.oneTime = parsedExpression.oneTime;\n            fn.constant = parsedExpression.constant;\n\n            // Treat the interceptor like filters.\n            // If it is not $stateful then only watch its inputs.\n            // If the expression itself has no inputs then use the full expression as an input.\n            if ( !interceptorFn.$stateful ) {\n                useInputs = !parsedExpression.inputs;\n                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];\n\n                if ( !interceptorFn.$$pure ) {\n                    fn.inputs = fn.inputs.map( function( e ) {\n                        // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a\n                        // non-pure interceptor function.\n                        if ( e.isPure === PURITY_RELATIVE ) {\n                            return function depurifier( s ) { return e( s ); };\n                        }\n                        return e;\n                    } );\n                }\n            }\n\n            return addWatchDelegate( fn );\n        }\n    } ];\n}\n"]},"metadata":{},"sourceType":"module"}