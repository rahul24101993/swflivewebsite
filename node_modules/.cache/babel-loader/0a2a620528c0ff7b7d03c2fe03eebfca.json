{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do debugging.\n *\n * @module js/breakpointService\n * @namespace breakpointService\n */\n\n/**\n *  Below is the sample input for breakpoints.\n */\nlet sampleInput = {\n  b1: {\n    lifeCycles: {\n      vmName0: ['init', 'mount'],\n      vmName1: ['destroy']\n    },\n    actions: {\n      vmName0: {\n        actionId0: ['pre'],\n        actionId1: ['post']\n      }\n    },\n    globalEvents: {\n      'aw.include': {\n        data1: 'data1',\n        data2: 'data2'\n      },\n      'aw.*': {\n        data1: 'data1',\n        data2: 'data2'\n      }\n    },\n    ctx: {\n      'aw.test': ['register', 'unregister', 'modify']\n    },\n    commands: ['cm1', 'cmd2']\n  },\n  b2: {\n    lifeCycles: {\n      vmName0: ['init', 'mount'],\n      vmName1: ['destroy']\n    },\n    actions: {\n      vmName0: {\n        actionId0: ['pre'],\n        actionId1: ['post']\n      }\n    },\n    globalEvents: {\n      'aw.include': {\n        data1: 'data1',\n        data2: 'data2'\n      },\n      'aw.*': {\n        data1: 'data1',\n        data2: 'data2'\n      }\n    },\n    ctx: {\n      'aw.test': ['register', 'unregister', 'modify']\n    }\n  }\n};\nlet breakpointsModel = {};\nlet optBrkModel = new Map();\nlet enableBrkPoints = true;\nlet isUnminified = /comment/.test(function () {\n  /*\n      comment\n  */\n});\n/**\n *\n * @param {*} isEnable boolean true or false to enable or disable the breakpoint.\n */\n\nexport let enableBreakPoints = isEnable => {\n  enableBrkPoints = isEnable;\n};\n/**\n *  This function is used to give back all the exiting breakpoints\n *  to the chrome extension to re-generate the breakpoint UI.\n *  @returns {*} returns the breakPoinModel Object.\n */\n\nexport let getAllBreakPoints = () => {\n  return breakpointsModel;\n};\n/**\n * This is a immutable function, which takes two array merge them, remove the\n * duplicates and return a new array.\n * @param {*} array1 The first input array. The array should only contain strings.\n * @param {*} array2 The second input array. The array should only contain strings.\n * @returns {*} a new concatinated array.\n */\n\nlet mergeAndRemoveDuplicates = (array1, array2) => {\n  let concatArray = [...array1, ...array2];\n  return concatArray.reduce((finalArray, item) => {\n    if (finalArray.includes(item)) {\n      return finalArray;\n    }\n\n    return [...finalArray, item];\n  }, []);\n};\n/**\n *\n * @param {*} model  The input model\n * @param {*} holder the holder object\n */\n\n\nlet processInputModel = (model, holder) => {\n  let keys = Object.keys(model);\n  keys.forEach(key => {\n    let objValue = model[key] instanceof Array ? model[key] : [model[key]];\n\n    if (!holder.has(key)) {\n      holder.set(key, objValue);\n    } else {\n      let srcValue = holder.get(key);\n      let finalArray = mergeAndRemoveDuplicates(srcValue, objValue);\n      holder.set(key, finalArray);\n    }\n  });\n};\n/**\n *\n * @param {*} structure The input structure for breakpoints.\n */\n\n\nexport let addBreakPoint = structure => {\n  Object.keys(structure).forEach(breakPointName => {\n    breakpointsModel[breakPointName] = structure[breakPointName];\n  });\n  generateOptimizedModel();\n};\n/**\n * This API is to remove the breakpoint.\n * @param {*} breakPointName name of the breakpoint\n */\n\nexport let removeBreakPoint = breakPointName => {\n  if (breakpointsModel[breakPointName]) {\n    delete breakpointsModel[breakPointName];\n    generateOptimizedModel();\n  }\n};\nexport let removeAllBreakPoints = () => {\n  breakpointsModel = {};\n  generateOptimizedModel();\n};\n/**\n * This API should be used to check if any condtion\n * matches with any exisitng breakpoint condtions.\n *\n * @param {*} breakpointType Name of the breakpoint type\n * @param  {...any} args This differs for breakpoint types\n * @returns {true/false} boolean\n */\n\nexport let hasConditionSatisfied = function (breakpointType) {\n  let isCondMatched = false;\n  let eventName;\n  let actionId;\n  let stage;\n  let panelId;\n  let ctxKey;\n  let commandName;\n  let fromState;\n  let toState;\n  let dataParserId;\n\n  if (!isUnminified || !enableBrkPoints) {\n    return false;\n  }\n\n  switch (breakpointType) {\n    case 'lifeCycles':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      stage = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('lifeCycles') ? optBrkModel.get('lifeCycles').breakPointCondSatisfied(panelId, stage) : false;\n      break;\n\n    case 'actions':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      actionId = arguments.length <= 2 ? undefined : arguments[2];\n      stage = arguments.length <= 3 ? undefined : arguments[3];\n      isCondMatched = optBrkModel.has('actions') ? optBrkModel.get('actions').breakPointCondSatisfied(panelId, actionId, stage) : false;\n      break;\n\n    case 'events':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      eventName = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('events') ? optBrkModel.get('events').breakPointCondSatisfied(panelId, eventName) : false;\n      break;\n\n    case 'dataParsers':\n      panelId = arguments.length <= 1 ? undefined : arguments[1];\n      dataParserId = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('dataParsers') ? optBrkModel.get('dataParsers').breakPointCondSatisfied(panelId, dataParserId) : false;\n      break;\n\n    case 'globalEvents':\n      eventName = arguments.length <= 1 ? undefined : arguments[1];\n      isCondMatched = optBrkModel.has('globalEvents') ? optBrkModel.get('globalEvents').breakPointCondSatisfied(eventName) : false;\n      break;\n\n    case 'ctx':\n      ctxKey = arguments.length <= 1 ? undefined : arguments[1];\n      stage = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('ctx') ? optBrkModel.get('ctx').breakPointCondSatisfied(ctxKey, stage) : false;\n      break;\n\n    case 'commands':\n      commandName = arguments.length <= 1 ? undefined : arguments[1];\n      isCondMatched = optBrkModel.has('commands') ? optBrkModel.get('commands').breakPointCondSatisfied(commandName) : false;\n      break;\n\n    case 'routes':\n      fromState = arguments.length <= 1 ? undefined : arguments[1];\n      toState = arguments.length <= 2 ? undefined : arguments[2];\n      isCondMatched = optBrkModel.has('routes') ? optBrkModel.get('routes').breakPointCondSatisfied(fromState, toState) : false;\n      break;\n  }\n\n  return isCondMatched;\n};\n/**\n * This optimized model holds a class object (singleton class) against every breakpoint type.\n * example\n *      {\n *          \"lifeCycles\" : new LifeCycleModel(),\n *          \"actions\" : new ActionModel(),\n *          \"globalEvents\" : new GlobalEventsModel(),\n *          \"ctx\" : new CtxModel() *\n *       }\n */\n\nlet generateOptimizedModel = () => {\n  let breakPointTypes = ['lifeCycles', 'actions', 'globalEvents', 'ctx', 'commands', 'events', 'routes', 'dataParsers'];\n  /**\n   *  Whenever we re-generate the optimized view-model\n   *  we should take care to clear all the exiting breakpoints.\n   */\n\n  for (let breakPointType of breakPointTypes) {\n    if (optBrkModel.has(breakPointType)) {\n      // Every class from optBrkModel.get( breakPointType ) has clear() method implemented.\n      optBrkModel.get(breakPointType).clearConditions();\n    }\n  }\n\n  for (let breakPointName in breakpointsModel) {\n    let breakPointObj = breakpointsModel[breakPointName];\n\n    for (let breakPointType of breakPointTypes) {\n      switch (breakPointType) {\n        case 'lifeCycles':\n          generateLifeCycleModel(breakPointObj.lifeCycles);\n          break;\n\n        case 'actions':\n          generateActionModel(breakPointObj.actions);\n          break;\n\n        case 'globalEvents':\n          generateGlobalEventsModel(breakPointObj.globalEvents);\n          break;\n\n        case 'events':\n          generateEventModel(breakPointObj.events);\n          break;\n\n        case 'dataParsers':\n          generateDataParserModel(breakPointObj.dataParsers);\n          break;\n\n        case 'ctx':\n          generateCtxModel(breakPointObj.ctx);\n          break;\n\n        case 'commands':\n          generateCommandsModel(breakPointObj.commands);\n          break;\n\n        case 'routes':\n          generateRoutesModel(breakPointObj.routes);\n          break;\n      }\n    }\n  }\n};\n/**\n * This is a singleton 'lifeCycles' class, which holds all the breakpoint\n * information related to lifecycles for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n *  @param {*} model the input model to create breakpoints for viewmodel lifeCycle.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n *\n */\n\n\nlet generateLifeCycleModel = model => {\n  class LifeCycleModel {\n    constructor() {\n      if (LifeCycleModel.instance) {\n        return LifeCycleModel.instance;\n      }\n\n      LifeCycleModel.instance = this;\n      this.holder = new Map();\n      return this;\n    }\n\n    addInput(lifeCycleInput) {\n      processInputModel(lifeCycleInput, this.holder);\n    }\n\n    hasPanelId(panelId) {\n      return this.holder.has(panelId);\n    }\n\n    getStage(panelId) {\n      return this.holder.get(panelId);\n    }\n\n    breakPointCondSatisfied(panelId, stage) {\n      if (this.hasPanelId(panelId)) {\n        return this.holder.get(panelId).includes(stage);\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('lifeCycles')) {\n    optBrkModel.set('lifeCycles', new LifeCycleModel());\n  }\n\n  if (model) {\n    optBrkModel.get('lifeCycles').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for viewmodel actions.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateActionModel = model => {\n  class ActionModel {\n    constructor() {\n      if (ActionModel.instance) {\n        return ActionModel.instance;\n      }\n\n      ActionModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(actionInputModel) {\n      let panelNames = Object.keys(actionInputModel);\n\n      for (let panelName of panelNames) {\n        if (!this.modelHolder.has(panelName)) {\n          let actionModel = new Map();\n          let actionObj = actionInputModel[panelName];\n          Object.keys(actionObj).forEach(actionName => {\n            let actionStage = actionObj[actionName] instanceof Array ? actionObj[actionName] : [actionObj[actionName]];\n            actionModel.set(actionName, actionStage);\n          });\n          this.modelHolder.set(panelName, actionModel);\n        } else {\n          let srcActionModel = this.modelHolder.get(panelName);\n          let newActionModel = actionInputModel[panelName];\n          processInputModel(newActionModel, srcActionModel);\n        }\n      }\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasActionId(panelId, actionId) {\n      if (this.modelHolder.has(panelId)) {\n        return this.modelHolder.get(panelId).has(actionId);\n      }\n\n      return false;\n    }\n\n    breakPointCondSatisfied(panelId, actionId, stage) {\n      if (this.hasActionId(panelId, actionId)) {\n        return this.modelHolder.get(panelId).get(actionId).includes(stage);\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('actions')) {\n    optBrkModel.set('actions', new ActionModel());\n  }\n\n  if (model) {\n    optBrkModel.get('actions').addInput(model);\n  }\n};\n\nlet generateEventModel = model => {\n  class EventModel {\n    constructor() {\n      if (EventModel.instance) {\n        return EventModel.instance;\n      }\n\n      EventModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(eventInputModel) {\n      processInputModel(eventInputModel, this.modelHolder);\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasEventName(panelId, eventName) {\n      try {\n        if (this.hasPanelId(panelId)) {\n          let eventNames = this.modelHolder.get(panelId); // If user provides an incorrect regular expression\n          // the RegExp constructor throws an exception.\n          // We do not want to throw any exception due to user error\n          // hence, eating up the exception and throwing false.\n          //let regexp = RegExp( eventName, 'g' );\n          //return eventNames.some( e => regexp.test( e ) );\n\n          return eventNames.some(e => {\n            try {\n              let regexp = RegExp(e, 'g');\n              return regexp.test(eventName);\n            } catch (e) {\n              return false;\n            }\n          });\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(panelId, eventName) {\n      return this.hasEventName(panelId, eventName);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('events')) {\n    optBrkModel.set('events', new EventModel());\n  }\n\n  if (model) {\n    optBrkModel.get('events').addInput(model);\n  }\n};\n\nlet generateDataParserModel = model => {\n  class DataParserModel {\n    constructor() {\n      if (DataParserModel.instance) {\n        return DataParserModel.instance;\n      }\n\n      DataParserModel.instance = this;\n      this.modelHolder = new Map();\n      return this;\n    }\n\n    addInput(eventInputModel) {\n      processInputModel(eventInputModel, this.modelHolder);\n    }\n\n    hasPanelId(panelId) {\n      return this.modelHolder.has(panelId);\n    }\n\n    hasDataParser(panelId, dataParserId) {\n      try {\n        if (this.hasPanelId(panelId)) {\n          let dataParsers = this.modelHolder.get(panelId); // If user provides an incorrect regular expression\n          // the RegExp constructor throws an exception.\n          // We do not want to throw any exception due to user error\n          // hence, eating up the exception and throwing false.\n          //let regexp = RegExp( eventName, 'g' );\n          //return eventNames.some( e => regexp.test( e ) );\n\n          return dataParsers.some(e => {\n            try {\n              let regexp = RegExp(e, 'g');\n              return regexp.test(dataParserId);\n            } catch (e) {\n              return false;\n            }\n          });\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(panelId, dataParserId) {\n      return this.hasDataParser(panelId, dataParserId);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('dataParsers')) {\n    optBrkModel.set('dataParsers', new DataParserModel());\n  }\n\n  if (model) {\n    optBrkModel.get('dataParsers').addInput(model);\n  }\n};\n/**\n * This is a singleton 'globalEvents' class, which holds all the breakpoint\n * information related to global events for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n * @param {*} model\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateGlobalEventsModel = model => {\n  class GlobalEventsModel {\n    constructor() {\n      if (GlobalEventsModel.instance) {\n        return GlobalEventsModel.instance;\n      }\n\n      GlobalEventsModel.instance = this; // ModelHolder is not being used currently. It would be used\n      // once we provide the support for matching the eventData\n\n      this.modelHolder = new Map();\n      this.eventNames = [];\n      return this;\n    }\n\n    addInput(GlobalEventsModel) {\n      Object.keys(GlobalEventsModel).forEach(eventName => {\n        let eventData = GlobalEventsModel[eventName];\n        this.modelHolder.set(eventName, eventData);\n        this.eventNames.push(eventName);\n      });\n    }\n\n    hasEventName(eventName) {\n      try {\n        // If user provides an incorrect regular expression\n        // the RegExp constructor throws an exception.\n        // We do not want to throw any exception due to user error\n        // hence, eating up the exception and throwing false.\n        return this.eventNames.some(e => {\n          try {\n            let regexp = RegExp(e, 'g');\n            return regexp.test(eventName);\n          } catch (e) {\n            return false;\n          }\n        });\n      } catch (e) {\n        return false;\n      }\n    }\n\n    breakPointCondSatisfied(eventName) {\n      return this.hasEventName(eventName);\n    }\n\n    clearConditions() {\n      this.modelHolder.clear();\n      this.eventNames.length = 0;\n    }\n\n  }\n\n  if (!optBrkModel.has('globalEvents')) {\n    optBrkModel.set('globalEvents', new GlobalEventsModel());\n  }\n\n  if (model) {\n    optBrkModel.get('globalEvents').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for app context changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateCtxModel = model => {\n  class CtxModel {\n    constructor() {\n      if (CtxModel.instance) {\n        return CtxModel.instance;\n      }\n\n      CtxModel.instance = this;\n      this.holder = new Map();\n      this.ctxKeys = [];\n      return this;\n    }\n\n    addInput(ctxInput) {\n      processInputModel(ctxInput, this.holder);\n      Object.keys(ctxInput).forEach(ctxkey => {\n        this.ctxKeys.push(ctxkey);\n      });\n    }\n\n    hasCtxKey(userKey, stage) {\n      try {\n        let userKeyExist = ctxKey => {\n          try {\n            let regexp = RegExp(ctxKey, 'g');\n            return regexp.test(userKey);\n          } catch {\n            return false;\n          }\n        };\n\n        if (this.ctxKeys.some(userKeyExist)) {\n          return this.holder.get(userKey).includes(stage);\n        }\n\n        return false;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    getStage(panelId) {\n      return this.holder.get(panelId);\n    }\n\n    breakPointCondSatisfied(ctxKey, stage) {\n      return this.hasCtxKey(ctxKey, stage);\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('ctx')) {\n    optBrkModel.set('ctx', new CtxModel());\n  }\n\n  if (model) {\n    optBrkModel.get('ctx').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for commands.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateCommandsModel = model => {\n  class CommandsModel {\n    constructor() {\n      if (CommandsModel.instance) {\n        return CommandsModel.instance;\n      }\n\n      CommandsModel.instance = this;\n      this.holder = [];\n      return this;\n    }\n\n    addInput(commands) {\n      if (commands instanceof Array) {\n        this.holder = [...this.holder, ...commands];\n      }\n\n      this.holder.push(commands);\n    }\n\n    hasCommandName(commandName) {\n      return this.holder.includes(commandName);\n    }\n\n    breakPointCondSatisfied(commandName) {\n      return this.hasCommandName(commandName);\n    }\n\n    clearConditions() {\n      this.holder.length = 0;\n    }\n\n  }\n\n  if (!optBrkModel.has('commands')) {\n    optBrkModel.set('commands', new CommandsModel());\n  }\n\n  if (model) {\n    optBrkModel.get('commands').addInput(model);\n  }\n};\n/**\n *\n * @param {*} model the input model to create breakpoints for route changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\n\n\nlet generateRoutesModel = model => {\n  class RoutesModel {\n    constructor() {\n      if (RoutesModel.instance) {\n        return RoutesModel.instance;\n      }\n\n      RoutesModel.instance = this;\n      this.holder = new Map();\n      return this;\n    }\n\n    addInput(model) {\n      Object.keys(model).forEach(fromState => {\n        let toState = model[fromState] ? model[fromState] : null;\n        this.holder.set(fromState, toState);\n      });\n    }\n\n    breakPointCondSatisfied(fromState, toState) {\n      if (this.holder.has(fromState)) {\n        if (!this.holder.get(fromState)) {\n          return true;\n        }\n\n        return this.holder.get(fromState) === toState;\n      }\n\n      return false;\n    }\n\n    clearConditions() {\n      this.holder.clear();\n    }\n\n  }\n\n  if (!optBrkModel.has('routes')) {\n    optBrkModel.set('routes', new RoutesModel());\n  }\n\n  if (model) {\n    optBrkModel.get('routes').addInput(model);\n  }\n};\n\nlet breakpointSvc = {\n  addBreakPoint,\n  removeBreakPoint,\n  removeAllBreakPoints,\n  hasConditionSatisfied,\n  enableBreakPoints,\n  getAllBreakPoints\n};\nexport default breakpointSvc;\nwindow.breakpointSvc = breakpointSvc;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/breakpointService.js"],"names":["sampleInput","b1","lifeCycles","vmName0","vmName1","actions","actionId0","actionId1","globalEvents","data1","data2","ctx","commands","b2","breakpointsModel","optBrkModel","enableBrkPoints","isUnminified","enableBreakPoints","isEnable","getAllBreakPoints","mergeAndRemoveDuplicates","concatArray","finalArray","processInputModel","keys","Object","key","objValue","model","holder","srcValue","addBreakPoint","structure","breakPointName","generateOptimizedModel","removeBreakPoint","removeAllBreakPoints","hasConditionSatisfied","isCondMatched","panelId","stage","actionId","eventName","dataParserId","ctxKey","commandName","fromState","toState","breakPointTypes","breakPointObj","generateLifeCycleModel","generateActionModel","generateGlobalEventsModel","generateEventModel","generateDataParserModel","generateCtxModel","generateCommandsModel","generateRoutesModel","constructor","LifeCycleModel","addInput","hasPanelId","getStage","breakPointCondSatisfied","clearConditions","ActionModel","panelNames","actionModel","actionObj","actionInputModel","actionName","actionStage","srcActionModel","newActionModel","hasActionId","EventModel","hasEventName","eventNames","e","regexp","RegExp","DataParserModel","hasDataParser","dataParsers","GlobalEventsModel","eventData","CtxModel","ctxkey","hasCtxKey","userKeyExist","CommandsModel","hasCommandName","RoutesModel","breakpointSvc","window"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAIA,WAAW,GAAG;EACdC,EAAE,EAAE;IACAC,UAAU,EAAE;MACRC,OAAO,EAAE,CAAA,MAAA,EADD,OACC,CADD;MAERC,OAAO,EAAE,CAAA,SAAA;IAFD,CADZ;IAKAC,OAAO,EAAE;MACLF,OAAO,EAAE;QACLG,SAAS,EAAE,CADN,KACM,CADN;QAELC,SAAS,EAAE,CAAA,MAAA;MAFN;IADJ,CALT;IAWAC,YAAY,EAAE;MACV,cAAc;QACVC,KAAK,EADK,OAAA;QAEVC,KAAK,EAAE;MAFG,CADJ;MAKV,QAAQ;QACJD,KAAK,EADD,OAAA;QAEJC,KAAK,EAAE;MAFH;IALE,CAXd;IAqBAC,GAAG,EAAE;MACD,WAAW,CAAA,UAAA,EAAA,YAAA,EAAA,QAAA;IADV,CArBL;IAwBAC,QAAQ,EAAE,CAAA,KAAA,EAAA,MAAA;EAxBV,CADU;EA4BdC,EAAE,EAAE;IACAX,UAAU,EAAE;MACRC,OAAO,EAAE,CAAA,MAAA,EADD,OACC,CADD;MAERC,OAAO,EAAE,CAAA,SAAA;IAFD,CADZ;IAKAC,OAAO,EAAE;MACLF,OAAO,EAAE;QACLG,SAAS,EAAE,CADN,KACM,CADN;QAELC,SAAS,EAAE,CAAA,MAAA;MAFN;IADJ,CALT;IAWAC,YAAY,EAAE;MACV,cAAc;QACVC,KAAK,EADK,OAAA;QAEVC,KAAK,EAAE;MAFG,CADJ;MAKV,QAAQ;QACJD,KAAK,EADD,OAAA;QAEJC,KAAK,EAAE;MAFH;IALE,CAXd;IAqBAC,GAAG,EAAE;MACD,WAAW,CAAA,UAAA,EAAA,YAAA,EAAA,QAAA;IADV;EArBL;AA5BU,CAAlB;AAuDA,IAAIG,gBAAgB,GAApB,EAAA;AACA,IAAIC,WAAW,GAAG,IAAlB,GAAkB,EAAlB;AACA,IAAIC,eAAe,GAAnB,IAAA;AAEA,IAAIC,YAAY,GAAG,UAAA,IAAA,CAAgB,YAAW;EAC1C;AACJ;AACA;AAHA,CAAmB,CAAnB;AAMA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,iBAAiB,GAAKC,QAAF,IAAgB;EAC3CH,eAAe,GAAfA,QAAAA;AADG,CAAA;AAIP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,iBAAiB,GAAG,MAAM;EACjC,OAAA,gBAAA;AADG,CAAA;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,wBAAwB,GAAG,CAAA,MAAA,EAAA,MAAA,KAAsB;EACjD,IAAIC,WAAW,GAAG,CAAE,GAAF,MAAA,EAAa,GAA/B,MAAkB,CAAlB;EACA,OAAO,WAAW,CAAX,MAAA,CAAoB,CAAA,UAAA,EAAA,IAAA,KAAwB;IAC/C,IAAIC,UAAU,CAAVA,QAAAA,CAAJ,IAAIA,CAAJ,EAAkC;MAC9B,OAAA,UAAA;IACH;;IACD,OAAO,CAAE,GAAF,UAAA,EAAP,IAAO,CAAP;EAJG,CAAA,EAAP,EAAO,CAAP;AAFJ,CAAA;AAUA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,iBAAiB,GAAG,CAAA,KAAA,EAAA,MAAA,KAAqB;EACzC,IAAIC,IAAI,GAAGC,MAAM,CAANA,IAAAA,CAAX,KAAWA,CAAX;EACAD,IAAI,CAAJA,OAAAA,CAAgBE,GAAF,IAAW;IACrB,IAAIC,QAAQ,GAAGC,KAAK,CAALA,GAAK,CAALA,YAAAA,KAAAA,GAAgCA,KAAK,CAArCA,GAAqC,CAArCA,GAA+C,CAAEA,KAAK,CAArE,GAAqE,CAAP,CAA9D;;IACA,IAAI,CAACC,MAAM,CAANA,GAAAA,CAAL,GAAKA,CAAL,EAAyB;MACrBA,MAAM,CAANA,GAAAA,CAAAA,GAAAA,EAAAA,QAAAA;IADJ,CAAA,MAEO;MACH,IAAIC,QAAQ,GAAGD,MAAM,CAANA,GAAAA,CAAf,GAAeA,CAAf;MACA,IAAIP,UAAU,GAAGF,wBAAwB,CAAA,QAAA,EAAzC,QAAyC,CAAzC;MACAS,MAAM,CAANA,GAAAA,CAAAA,GAAAA,EAAAA,UAAAA;IACH;EARLL,CAAAA;AAFJ,CAAA;AAcA;AACA;AACA;AACA;;;AACA,OAAO,IAAIO,aAAa,GAAKC,SAAF,IAAiB;EACxCP,MAAM,CAANA,IAAAA,CAAAA,SAAAA,EAAAA,OAAAA,CAAoCQ,cAAF,IAAsB;IACpDpB,gBAAgB,CAAhBA,cAAgB,CAAhBA,GAAqCmB,SAAS,CAA9CnB,cAA8C,CAA9CA;EADJY,CAAAA;EAGAS,sBAAsB;AAJnB,CAAA;AAOP;AACA;AACA;AACA;;AACA,OAAO,IAAIC,gBAAgB,GAAKF,cAAF,IAAsB;EAChD,IAAIpB,gBAAgB,CAApB,cAAoB,CAApB,EAAyC;IACrC,OAAOA,gBAAgB,CAAvB,cAAuB,CAAvB;IACAqB,sBAAsB;EACzB;AAJE,CAAA;AAOP,OAAO,IAAIE,oBAAoB,GAAG,MAAM;EACpCvB,gBAAgB,GAAhBA,EAAAA;EACAqB,sBAAsB;AAFnB,CAAA;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIG,qBAAqB,GAAG,UAAA,cAAA,EAA+B;EAC9D,IAAIC,aAAa,GAAjB,KAAA;EACA,IAAA,SAAA;EACA,IAAA,QAAA;EACA,IAAA,KAAA;EACA,IAAA,OAAA;EACA,IAAA,MAAA;EACA,IAAA,WAAA;EACA,IAAA,SAAA;EACA,IAAA,OAAA;EACA,IAAA,YAAA;;EACA,IAAI,CAAA,YAAA,IAAiB,CAArB,eAAA,EAAwC;IACpC,OAAA,KAAA;EACH;;EACD,QAAA,cAAA;IACI,KAAA,YAAA;MACIC,OAAO,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAPA,CAAO,CAAPA;MACAC,KAAK,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAALA,CAAK,CAALA;MACAF,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,YAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,YAAAA,EAAAA,uBAAAA,CAAAA,OAAAA,EADYA,KACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,SAAA;MACIC,OAAO,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAPA,CAAO,CAAPA;MACAE,QAAQ,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAARA,CAAQ,CAARA;MACAD,KAAK,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAALA,CAAK,CAALA;MACAF,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,SAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,SAAAA,EAAAA,uBAAAA,CAAAA,OAAAA,EAAAA,QAAAA,EADYA,KACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,QAAA;MACIC,OAAO,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAPA,CAAO,CAAPA;MACAG,SAAS,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAATA,CAAS,CAATA;MACAJ,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAAAA,uBAAAA,CAAAA,OAAAA,EADYA,SACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,aAAA;MACIC,OAAO,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAPA,CAAO,CAAPA;MACAI,YAAY,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAZA,CAAY,CAAZA;MACAL,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,aAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,aAAAA,EAAAA,uBAAAA,CAAAA,OAAAA,EADYA,YACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,cAAA;MACII,SAAS,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAATA,CAAS,CAATA;MACAJ,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,cAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,cAAAA,EAAAA,uBAAAA,CADYA,SACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,KAAA;MACIM,MAAM,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAANA,CAAM,CAANA;MACAJ,KAAK,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAALA,CAAK,CAALA;MACAF,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,KAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,KAAAA,EAAAA,uBAAAA,CAAAA,MAAAA,EADYA,KACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,UAAA;MACIO,WAAW,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAXA,CAAW,CAAXA;MACAP,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,UAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,UAAAA,EAAAA,uBAAAA,CADYA,WACZA,CADYA,GAAhBwB,KAAAA;MAEA;;IAEJ,KAAA,QAAA;MACIQ,SAAS,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAATA,CAAS,CAATA;MACAC,OAAO,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,GAAA,SAAA,GAAA,SAAA,CAAPA,CAAO,CAAPA;MACAT,aAAa,GAAGxB,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,IACZA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAAAA,uBAAAA,CAAAA,SAAAA,EADYA,OACZA,CADYA,GAAhBwB,KAAAA;MAEA;EAtDR;;EAwDA,OAAA,aAAA;AAtEG,CAAA;AAyEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIJ,sBAAsB,GAAG,MAAM;EAC/B,IAAIc,eAAe,GAAG,CAAA,YAAA,EAAA,SAAA,EAAA,cAAA,EAAA,KAAA,EAAA,UAAA,EAAA,QAAA,EAAA,QAAA,EAAtB,aAAsB,CAAtB;EACA;AACJ;AACA;AACA;;EACI,KAAK,IAAL,cAAA,IAAA,eAAA,EAA6C;IACzC,IAAIlC,WAAW,CAAXA,GAAAA,CAAJ,cAAIA,CAAJ,EAAwC;MACpC;MACAA,WAAW,CAAXA,GAAAA,CAAAA,cAAAA,EAAAA,eAAAA;IACH;EACJ;;EAED,KAAK,IAAL,cAAA,IAAA,gBAAA,EAA8C;IAC1C,IAAImC,aAAa,GAAGpC,gBAAgB,CAApC,cAAoC,CAApC;;IACA,KAAK,IAAL,cAAA,IAAA,eAAA,EAA6C;MACzC,QAAA,cAAA;QACI,KAAA,YAAA;UACIqC,sBAAsB,CAAED,aAAa,CAArCC,UAAsB,CAAtBA;UACA;;QACJ,KAAA,SAAA;UACIC,mBAAmB,CAAEF,aAAa,CAAlCE,OAAmB,CAAnBA;UACA;;QACJ,KAAA,cAAA;UACIC,yBAAyB,CAAEH,aAAa,CAAxCG,YAAyB,CAAzBA;UACA;;QACJ,KAAA,QAAA;UACIC,kBAAkB,CAAEJ,aAAa,CAAjCI,MAAkB,CAAlBA;UACA;;QACJ,KAAA,aAAA;UACIC,uBAAuB,CAAEL,aAAa,CAAtCK,WAAuB,CAAvBA;UACA;;QACJ,KAAA,KAAA;UACIC,gBAAgB,CAAEN,aAAa,CAA/BM,GAAgB,CAAhBA;UACA;;QACJ,KAAA,UAAA;UACIC,qBAAqB,CAAEP,aAAa,CAApCO,QAAqB,CAArBA;UACA;;QACJ,KAAA,QAAA;UACIC,mBAAmB,CAAER,aAAa,CAAlCQ,MAAmB,CAAnBA;UACA;MAxBR;IA0BH;EACJ;AA3CL,CAAA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIP,sBAAsB,GAAKtB,KAAF,IAAa;EACtC,MAAA,cAAA,CAAqB;IACjB8B,WAAW,GAAG;MACV,IAAIC,cAAc,CAAlB,QAAA,EAA8B;QAC1B,OAAOA,cAAc,CAArB,QAAA;MACH;;MACDA,cAAc,CAAdA,QAAAA,GAAAA,IAAAA;MACA,KAAA,MAAA,GAAc,IAAd,GAAc,EAAd;MACA,OAAA,IAAA;IACH;;IACDC,QAAQ,CAAA,cAAA,EAAmB;MACvBrC,iBAAiB,CAAA,cAAA,EAAkB,KAAnCA,MAAiB,CAAjBA;IACH;;IACDsC,UAAU,CAAA,OAAA,EAAY;MAClB,OAAO,KAAA,MAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IACDC,QAAQ,CAAA,OAAA,EAAY;MAChB,OAAO,KAAA,MAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IACDC,uBAAuB,CAAA,OAAA,EAAA,KAAA,EAAmB;MACtC,IAAI,KAAA,UAAA,CAAJ,OAAI,CAAJ,EAAiC;QAC7B,OAAO,KAAA,MAAA,CAAA,GAAA,CAAA,OAAA,EAAA,QAAA,CAAP,KAAO,CAAP;MACH;;MACD,OAAA,KAAA;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,MAAA,CAAA,KAAA;IACH;;EA1BgB;;EA4BrB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,YAAKA,CAAL,EAAuC;IACnCA,WAAW,CAAXA,GAAAA,CAAAA,YAAAA,EAA+B,IAA/BA,cAA+B,EAA/BA;EACH;;EACD,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,YAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AAlCL,CAAA;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIqC,mBAAmB,GAAKvB,KAAF,IAAa;EACnC,MAAA,WAAA,CAAkB;IACd8B,WAAW,GAAG;MACV,IAAIO,WAAW,CAAf,QAAA,EAA2B;QACvB,OAAOA,WAAW,CAAlB,QAAA;MACH;;MACDA,WAAW,CAAXA,QAAAA,GAAAA,IAAAA;MACA,KAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;MACA,OAAA,IAAA;IACH;;IACDL,QAAQ,CAAA,gBAAA,EAAqB;MACzB,IAAIM,UAAU,GAAGzC,MAAM,CAANA,IAAAA,CAAjB,gBAAiBA,CAAjB;;MACA,KAAK,IAAL,SAAA,IAAA,UAAA,EAAmC;QAC/B,IAAI,CAAC,KAAA,WAAA,CAAA,GAAA,CAAL,SAAK,CAAL,EAAyC;UACrC,IAAI0C,WAAW,GAAG,IAAlB,GAAkB,EAAlB;UACA,IAAIC,SAAS,GAAGC,gBAAgB,CAAhC,SAAgC,CAAhC;UACA5C,MAAM,CAANA,IAAAA,CAAAA,SAAAA,EAAAA,OAAAA,CAAoC6C,UAAF,IAAkB;YAChD,IAAIC,WAAW,GAAGH,SAAS,CAATA,UAAS,CAATA,YAAAA,KAAAA,GAA2CA,SAAS,CAApDA,UAAoD,CAApDA,GAAqE,CAAEA,SAAS,CAAlG,UAAkG,CAAX,CAAvF;YACAD,WAAW,CAAXA,GAAAA,CAAAA,UAAAA,EAAAA,WAAAA;UAFJ1C,CAAAA;UAIA,KAAA,WAAA,CAAA,GAAA,CAAA,SAAA,EAAA,WAAA;QAPJ,CAAA,MAQO;UACH,IAAI+C,cAAc,GAAG,KAAA,WAAA,CAAA,GAAA,CAArB,SAAqB,CAArB;UACA,IAAIC,cAAc,GAAGJ,gBAAgB,CAArC,SAAqC,CAArC;UACA9C,iBAAiB,CAAA,cAAA,EAAjBA,cAAiB,CAAjBA;QACH;MACJ;IACJ;;IACDsC,UAAU,CAAA,OAAA,EAAY;MAClB,OAAO,KAAA,WAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IAEDa,WAAW,CAAA,OAAA,EAAA,QAAA,EAAsB;MAC7B,IAAI,KAAA,WAAA,CAAA,GAAA,CAAJ,OAAI,CAAJ,EAAsC;QAClC,OAAO,KAAA,WAAA,CAAA,GAAA,CAAA,OAAA,EAAA,GAAA,CAAP,QAAO,CAAP;MACH;;MACD,OAAA,KAAA;IACH;;IAEDX,uBAAuB,CAAA,OAAA,EAAA,QAAA,EAAA,KAAA,EAA6B;MAChD,IAAI,KAAA,WAAA,CAAA,OAAA,EAAJ,QAAI,CAAJ,EAA4C;QACxC,OAAO,KAAA,WAAA,CAAA,GAAA,CAAA,OAAA,EAAA,GAAA,CAAA,QAAA,EAAA,QAAA,CAAP,KAAO,CAAP;MACH;;MACD,OAAA,KAAA;IACH;;IAEDC,eAAe,GAAG;MACd,KAAA,WAAA,CAAA,KAAA;IACH;;EA/Ca;;EAiDlB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,SAAKA,CAAL,EAAoC;IAChCA,WAAW,CAAXA,GAAAA,CAAAA,SAAAA,EAA4B,IAA5BA,WAA4B,EAA5BA;EACH;;EAED,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,SAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AAxDL,CAAA;;AA2DA,IAAIuC,kBAAkB,GAAKzB,KAAF,IAAa;EAClC,MAAA,UAAA,CAAiB;IACb8B,WAAW,GAAG;MACV,IAAIiB,UAAU,CAAd,QAAA,EAA0B;QACtB,OAAOA,UAAU,CAAjB,QAAA;MACH;;MACDA,UAAU,CAAVA,QAAAA,GAAAA,IAAAA;MACA,KAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;MACA,OAAA,IAAA;IACH;;IACDf,QAAQ,CAAA,eAAA,EAAoB;MACxBrC,iBAAiB,CAAA,eAAA,EAAmB,KAApCA,WAAiB,CAAjBA;IACH;;IACDsC,UAAU,CAAA,OAAA,EAAY;MAClB,OAAO,KAAA,WAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IACDe,YAAY,CAAA,OAAA,EAAA,SAAA,EAAuB;MAC/B,IAAI;QACA,IAAI,KAAA,UAAA,CAAJ,OAAI,CAAJ,EAAiC;UAC7B,IAAIC,UAAU,GAAG,KAAA,WAAA,CAAA,GAAA,CADY,OACZ,CAAjB,CAD6B,CAE7B;UACA;UACA;UACA;UACA;UACA;;UACA,OAAO,UAAU,CAAV,IAAA,CAAiBC,CAAC,IAAI;YACzB,IAAI;cACA,IAAIC,MAAM,GAAGC,MAAM,CAAA,CAAA,EAAnB,GAAmB,CAAnB;cACA,OAAOD,MAAM,CAANA,IAAAA,CAAP,SAAOA,CAAP;YAFJ,CAAA,CAGE,OAAA,CAAA,EAAY;cACV,OAAA,KAAA;YACH;UANL,CAAO,CAAP;QAQH;;QACD,OAAA,KAAA;MAlBJ,CAAA,CAmBE,OAAA,CAAA,EAAY;QACV,OAAA,KAAA;MACH;IACJ;;IACDhB,uBAAuB,CAAA,OAAA,EAAA,SAAA,EAAuB;MAC1C,OAAO,KAAA,YAAA,CAAA,OAAA,EAAP,SAAO,CAAP;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,WAAA,CAAA,KAAA;IACH;;EA5CY;;EA8CjB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,QAAKA,CAAL,EAAmC;IAC/BA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAA2B,IAA3BA,UAA2B,EAA3BA;EACH;;EAED,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AArDL,CAAA;;AAwDA,IAAIwC,uBAAuB,GAAK1B,KAAF,IAAa;EACvC,MAAA,eAAA,CAAsB;IAClB8B,WAAW,GAAG;MACV,IAAIuB,eAAe,CAAnB,QAAA,EAA+B;QAC3B,OAAOA,eAAe,CAAtB,QAAA;MACH;;MACDA,eAAe,CAAfA,QAAAA,GAAAA,IAAAA;MACA,KAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;MACA,OAAA,IAAA;IACH;;IACDrB,QAAQ,CAAA,eAAA,EAAoB;MACxBrC,iBAAiB,CAAA,eAAA,EAAmB,KAApCA,WAAiB,CAAjBA;IACH;;IACDsC,UAAU,CAAA,OAAA,EAAY;MAClB,OAAO,KAAA,WAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IACDqB,aAAa,CAAA,OAAA,EAAA,YAAA,EAA0B;MACnC,IAAI;QACA,IAAI,KAAA,UAAA,CAAJ,OAAI,CAAJ,EAAiC;UAC7B,IAAIC,WAAW,GAAG,KAAA,WAAA,CAAA,GAAA,CADW,OACX,CAAlB,CAD6B,CAE7B;UACA;UACA;UACA;UACA;UACA;;UACA,OAAO,WAAW,CAAX,IAAA,CAAkBL,CAAC,IAAI;YAC1B,IAAI;cACA,IAAIC,MAAM,GAAGC,MAAM,CAAA,CAAA,EAAnB,GAAmB,CAAnB;cACA,OAAOD,MAAM,CAANA,IAAAA,CAAP,YAAOA,CAAP;YAFJ,CAAA,CAGE,OAAA,CAAA,EAAY;cACV,OAAA,KAAA;YACH;UANL,CAAO,CAAP;QAQH;;QACD,OAAA,KAAA;MAlBJ,CAAA,CAmBE,OAAA,CAAA,EAAY;QACV,OAAA,KAAA;MACH;IACJ;;IACDhB,uBAAuB,CAAA,OAAA,EAAA,YAAA,EAA0B;MAC7C,OAAO,KAAA,aAAA,CAAA,OAAA,EAAP,YAAO,CAAP;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,WAAA,CAAA,KAAA;IACH;;EA5CiB;;EA8CtB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,aAAKA,CAAL,EAAwC;IACpCA,WAAW,CAAXA,GAAAA,CAAAA,aAAAA,EAAgC,IAAhCA,eAAgC,EAAhCA;EACH;;EAED,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,aAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AArDL,CAAA;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIsC,yBAAyB,GAAKxB,KAAF,IAAa;EACzC,MAAA,iBAAA,CAAwB;IACpB8B,WAAW,GAAG;MACV,IAAI0B,iBAAiB,CAArB,QAAA,EAAiC;QAC7B,OAAOA,iBAAiB,CAAxB,QAAA;MACH;;MACDA,iBAAiB,CAAjBA,QAAAA,GAJU,IAIVA,CAJU,CAKV;MACA;;MACA,KAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;MACA,KAAA,UAAA,GAAA,EAAA;MACA,OAAA,IAAA;IACH;;IACDxB,QAAQ,CAAA,iBAAA,EAAsB;MAC1BnC,MAAM,CAANA,IAAAA,CAAAA,iBAAAA,EAAAA,OAAAA,CAA4CiB,SAAF,IAAiB;QACvD,IAAI2C,SAAS,GAAGD,iBAAiB,CAAjC,SAAiC,CAAjC;QACA,KAAA,WAAA,CAAA,GAAA,CAAA,SAAA,EAAA,SAAA;QACA,KAAA,UAAA,CAAA,IAAA,CAAA,SAAA;MAHJ3D,CAAAA;IAKH;;IACDmD,YAAY,CAAA,SAAA,EAAc;MACtB,IAAI;QACA;QACA;QACA;QACA;QACA,OAAO,KAAA,UAAA,CAAA,IAAA,CAAsBE,CAAC,IAAI;UAC9B,IAAI;YACA,IAAIC,MAAM,GAAGC,MAAM,CAAA,CAAA,EAAnB,GAAmB,CAAnB;YACA,OAAOD,MAAM,CAANA,IAAAA,CAAP,SAAOA,CAAP;UAFJ,CAAA,CAGE,OAAA,CAAA,EAAY;YACV,OAAA,KAAA;UACH;QANL,CAAO,CAAP;MALJ,CAAA,CAaE,OAAA,CAAA,EAAY;QACV,OAAA,KAAA;MACH;IACJ;;IAEDhB,uBAAuB,CAAA,SAAA,EAAc;MACjC,OAAO,KAAA,YAAA,CAAP,SAAO,CAAP;IACH;;IAEDC,eAAe,GAAG;MACd,KAAA,WAAA,CAAA,KAAA;MACA,KAAA,UAAA,CAAA,MAAA,GAAA,CAAA;IACH;;EA7CmB;;EAgDxB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,cAAKA,CAAL,EAAyC;IACrCA,WAAW,CAAXA,GAAAA,CAAAA,cAAAA,EAAiC,IAAjCA,iBAAiC,EAAjCA;EACH;;EACD,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,cAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AAtDL,CAAA;AAyDA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIyC,gBAAgB,GAAK3B,KAAF,IAAa;EAChC,MAAA,QAAA,CAAe;IACX8B,WAAW,GAAG;MACV,IAAI4B,QAAQ,CAAZ,QAAA,EAAwB;QACpB,OAAOA,QAAQ,CAAf,QAAA;MACH;;MACDA,QAAQ,CAARA,QAAAA,GAAAA,IAAAA;MACA,KAAA,MAAA,GAAc,IAAd,GAAc,EAAd;MACA,KAAA,OAAA,GAAA,EAAA;MACA,OAAA,IAAA;IACH;;IACD1B,QAAQ,CAAA,QAAA,EAAa;MACjBrC,iBAAiB,CAAA,QAAA,EAAY,KAA7BA,MAAiB,CAAjBA;MACAE,MAAM,CAANA,IAAAA,CAAAA,QAAAA,EAAAA,OAAAA,CAAmC8D,MAAF,IAAc;QAC3C,KAAA,OAAA,CAAA,IAAA,CAAA,MAAA;MADJ9D,CAAAA;IAGH;;IACD+D,SAAS,CAAA,OAAA,EAAA,KAAA,EAAmB;MACxB,IAAI;QACA,IAAIC,YAAY,GAAK7C,MAAF,IAAc;UAC7B,IAAI;YACA,IAAImC,MAAM,GAAGC,MAAM,CAAA,MAAA,EAAnB,GAAmB,CAAnB;YACA,OAAOD,MAAM,CAANA,IAAAA,CAAP,OAAOA,CAAP;UAFJ,CAAA,CAGE,MAAM;YACJ,OAAA,KAAA;UACH;QANL,CAAA;;QAQA,IAAI,KAAA,OAAA,CAAA,IAAA,CAAJ,YAAI,CAAJ,EAAwC;UACpC,OAAO,KAAA,MAAA,CAAA,GAAA,CAAA,OAAA,EAAA,QAAA,CAAP,KAAO,CAAP;QACH;;QACD,OAAA,KAAA;MAZJ,CAAA,CAaE,OAAA,CAAA,EAAY;QACV,OAAA,KAAA;MACH;IACJ;;IACDjB,QAAQ,CAAA,OAAA,EAAY;MAChB,OAAO,KAAA,MAAA,CAAA,GAAA,CAAP,OAAO,CAAP;IACH;;IACDC,uBAAuB,CAAA,MAAA,EAAA,KAAA,EAAkB;MACrC,OAAO,KAAA,SAAA,CAAA,MAAA,EAAP,KAAO,CAAP;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,MAAA,CAAA,KAAA;IACH;;EA1CU;;EA4Cf,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,KAAKA,CAAL,EAAgC;IAC5BA,WAAW,CAAXA,GAAAA,CAAAA,KAAAA,EAAwB,IAAxBA,QAAwB,EAAxBA;EACH;;EACD,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,KAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AAlDL,CAAA;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI0C,qBAAqB,GAAK5B,KAAF,IAAa;EACrC,MAAA,aAAA,CAAoB;IAChB8B,WAAW,GAAG;MACV,IAAIgC,aAAa,CAAjB,QAAA,EAA6B;QACzB,OAAOA,aAAa,CAApB,QAAA;MACH;;MACDA,aAAa,CAAbA,QAAAA,GAAAA,IAAAA;MACA,KAAA,MAAA,GAAA,EAAA;MACA,OAAA,IAAA;IACH;;IACD9B,QAAQ,CAAA,QAAA,EAAa;MACjB,IAAIjD,QAAQ,YAAZ,KAAA,EAAgC;QAC5B,KAAA,MAAA,GAAc,CAAE,GAAG,KAAL,MAAA,EAAkB,GAAhC,QAAc,CAAd;MACH;;MACD,KAAA,MAAA,CAAA,IAAA,CAAA,QAAA;IACH;;IACDgF,cAAc,CAAA,WAAA,EAAgB;MAC1B,OAAO,KAAA,MAAA,CAAA,QAAA,CAAP,WAAO,CAAP;IACH;;IACD5B,uBAAuB,CAAA,WAAA,EAAgB;MACnC,OAAO,KAAA,cAAA,CAAP,WAAO,CAAP;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,MAAA,CAAA,MAAA,GAAA,CAAA;IACH;;EAvBe;;EAyBpB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,UAAKA,CAAL,EAAqC;IACjCA,WAAW,CAAXA,GAAAA,CAAAA,UAAAA,EAA6B,IAA7BA,aAA6B,EAA7BA;EACH;;EACD,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,UAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AA/BL,CAAA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI2C,mBAAmB,GAAK7B,KAAF,IAAa;EACnC,MAAA,WAAA,CAAkB;IACd8B,WAAW,GAAG;MACV,IAAIkC,WAAW,CAAf,QAAA,EAA2B;QACvB,OAAOA,WAAW,CAAlB,QAAA;MACH;;MACDA,WAAW,CAAXA,QAAAA,GAAAA,IAAAA;MACA,KAAA,MAAA,GAAc,IAAd,GAAc,EAAd;MACA,OAAA,IAAA;IACH;;IACDhC,QAAQ,CAAA,KAAA,EAAU;MACdnC,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAAAA,OAAAA,CAAgCqB,SAAF,IAAiB;QAC3C,IAAIC,OAAO,GAAGnB,KAAK,CAALA,SAAK,CAALA,GAAqBA,KAAK,CAA1BA,SAA0B,CAA1BA,GAAd,IAAA;QACA,KAAA,MAAA,CAAA,GAAA,CAAA,SAAA,EAAA,OAAA;MAFJH,CAAAA;IAIH;;IACDsC,uBAAuB,CAAA,SAAA,EAAA,OAAA,EAAuB;MAC1C,IAAI,KAAA,MAAA,CAAA,GAAA,CAAJ,SAAI,CAAJ,EAAmC;QAC/B,IAAI,CAAC,KAAA,MAAA,CAAA,GAAA,CAAL,SAAK,CAAL,EAAoC;UAChC,OAAA,IAAA;QACH;;QACD,OAAO,KAAA,MAAA,CAAA,GAAA,CAAA,SAAA,MAAP,OAAA;MACH;;MACD,OAAA,KAAA;IACH;;IACDC,eAAe,GAAG;MACd,KAAA,MAAA,CAAA,KAAA;IACH;;EA1Ba;;EA4BlB,IAAI,CAAClD,WAAW,CAAXA,GAAAA,CAAL,QAAKA,CAAL,EAAmC;IAC/BA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAA2B,IAA3BA,WAA2B,EAA3BA;EACH;;EACD,IAAA,KAAA,EAAY;IACRA,WAAW,CAAXA,GAAAA,CAAAA,QAAAA,EAAAA,QAAAA,CAAAA,KAAAA;EACH;AAlCL,CAAA;;AAqCA,IAAI+E,aAAa,GAAG;EAAA,aAAA;EAAA,gBAAA;EAAA,oBAAA;EAAA,qBAAA;EAAA,iBAAA;EAMhB1E;AANgB,CAApB;AAQA,eAAA,aAAA;AACA2E,MAAM,CAANA,aAAAA,GAAAA,aAAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do debugging.\n *\n * @module js/breakpointService\n * @namespace breakpointService\n */\n\n/**\n *  Below is the sample input for breakpoints.\n */\nlet sampleInput = {\n    b1: {\n        lifeCycles: {\n            vmName0: [ 'init', 'mount' ],\n            vmName1: [ 'destroy' ]\n        },\n        actions: {\n            vmName0: {\n                actionId0: [ 'pre' ],\n                actionId1: [ 'post' ]\n            }\n        },\n        globalEvents: {\n            'aw.include': {\n                data1: 'data1',\n                data2: 'data2'\n            },\n            'aw.*': {\n                data1: 'data1',\n                data2: 'data2'\n            }\n        },\n        ctx: {\n            'aw.test': [ 'register', 'unregister', 'modify' ]\n        },\n        commands: [ 'cm1', 'cmd2' ]\n    },\n\n    b2: {\n        lifeCycles: {\n            vmName0: [ 'init', 'mount' ],\n            vmName1: [ 'destroy' ]\n        },\n        actions: {\n            vmName0: {\n                actionId0: [ 'pre' ],\n                actionId1: [ 'post' ]\n            }\n        },\n        globalEvents: {\n            'aw.include': {\n                data1: 'data1',\n                data2: 'data2'\n            },\n            'aw.*': {\n                data1: 'data1',\n                data2: 'data2'\n            }\n        },\n        ctx: {\n            'aw.test': [ 'register', 'unregister', 'modify' ]\n        }\n    }\n};\n\nlet breakpointsModel = {};\nlet optBrkModel = new Map();\nlet enableBrkPoints = true;\n\nlet isUnminified = /comment/.test( function() {\n    /*\n        comment\n    */\n} );\n\n/**\n *\n * @param {*} isEnable boolean true or false to enable or disable the breakpoint.\n */\nexport let enableBreakPoints = ( isEnable ) => {\n    enableBrkPoints = isEnable;\n};\n\n/**\n *  This function is used to give back all the exiting breakpoints\n *  to the chrome extension to re-generate the breakpoint UI.\n *  @returns {*} returns the breakPoinModel Object.\n */\nexport let getAllBreakPoints = () => {\n    return breakpointsModel;\n};\n/**\n * This is a immutable function, which takes two array merge them, remove the\n * duplicates and return a new array.\n * @param {*} array1 The first input array. The array should only contain strings.\n * @param {*} array2 The second input array. The array should only contain strings.\n * @returns {*} a new concatinated array.\n */\nlet mergeAndRemoveDuplicates = ( array1, array2 ) => {\n    let concatArray = [ ...array1, ...array2 ];\n    return concatArray.reduce( ( finalArray, item ) => {\n        if( finalArray.includes( item ) ) {\n            return finalArray;\n        }\n        return [ ...finalArray, item ];\n    }, [] );\n};\n\n/**\n *\n * @param {*} model  The input model\n * @param {*} holder the holder object\n */\nlet processInputModel = ( model, holder ) => {\n    let keys = Object.keys( model );\n    keys.forEach( ( key ) => {\n        let objValue = model[ key ] instanceof Array ? model[ key ] : [ model[ key ] ];\n        if( !holder.has( key ) ) {\n            holder.set( key, objValue );\n        } else {\n            let srcValue = holder.get( key );\n            let finalArray = mergeAndRemoveDuplicates( srcValue, objValue );\n            holder.set( key, finalArray );\n        }\n    } );\n};\n\n/**\n *\n * @param {*} structure The input structure for breakpoints.\n */\nexport let addBreakPoint = ( structure ) => {\n    Object.keys( structure ).forEach( ( breakPointName ) => {\n        breakpointsModel[ breakPointName ] = structure[ breakPointName ];\n    } );\n    generateOptimizedModel();\n};\n\n/**\n * This API is to remove the breakpoint.\n * @param {*} breakPointName name of the breakpoint\n */\nexport let removeBreakPoint = ( breakPointName ) => {\n    if( breakpointsModel[ breakPointName ] ) {\n        delete breakpointsModel[ breakPointName ];\n        generateOptimizedModel();\n    }\n};\n\nexport let removeAllBreakPoints = () => {\n    breakpointsModel = {};\n    generateOptimizedModel();\n};\n\n/**\n * This API should be used to check if any condtion\n * matches with any exisitng breakpoint condtions.\n *\n * @param {*} breakpointType Name of the breakpoint type\n * @param  {...any} args This differs for breakpoint types\n * @returns {true/false} boolean\n */\nexport let hasConditionSatisfied = ( breakpointType, ...args ) => {\n    let isCondMatched = false;\n    let eventName;\n    let actionId;\n    let stage;\n    let panelId;\n    let ctxKey;\n    let commandName;\n    let fromState;\n    let toState;\n    let dataParserId;\n    if( !isUnminified || !enableBrkPoints ) {\n        return false;\n    }\n    switch ( breakpointType ) {\n        case 'lifeCycles':\n            panelId = args[ 0 ];\n            stage = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'lifeCycles' ) ?\n                optBrkModel.get( 'lifeCycles' ).breakPointCondSatisfied( panelId, stage ) : false;\n            break;\n\n        case 'actions':\n            panelId = args[ 0 ];\n            actionId = args[ 1 ];\n            stage = args[ 2 ];\n            isCondMatched = optBrkModel.has( 'actions' ) ?\n                optBrkModel.get( 'actions' ).breakPointCondSatisfied( panelId, actionId, stage ) : false;\n            break;\n\n        case 'events':\n            panelId = args[ 0 ];\n            eventName = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'events' ) ?\n                optBrkModel.get( 'events' ).breakPointCondSatisfied( panelId, eventName ) : false;\n            break;\n\n        case 'dataParsers':\n            panelId = args[ 0 ];\n            dataParserId = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'dataParsers' ) ?\n                optBrkModel.get( 'dataParsers' ).breakPointCondSatisfied( panelId, dataParserId ) : false;\n            break;\n\n        case 'globalEvents':\n            eventName = args[ 0 ];\n            isCondMatched = optBrkModel.has( 'globalEvents' ) ?\n                optBrkModel.get( 'globalEvents' ).breakPointCondSatisfied( eventName ) : false;\n            break;\n\n        case 'ctx':\n            ctxKey = args[ 0 ];\n            stage = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'ctx' ) ?\n                optBrkModel.get( 'ctx' ).breakPointCondSatisfied( ctxKey, stage ) : false;\n            break;\n\n        case 'commands':\n            commandName = args[ 0 ];\n            isCondMatched = optBrkModel.has( 'commands' ) ?\n                optBrkModel.get( 'commands' ).breakPointCondSatisfied( commandName ) : false;\n            break;\n\n        case 'routes':\n            fromState = args[ 0 ];\n            toState = args[ 1 ];\n            isCondMatched = optBrkModel.has( 'routes' ) ?\n                optBrkModel.get( 'routes' ).breakPointCondSatisfied( fromState, toState ) : false;\n            break;\n    }\n    return isCondMatched;\n};\n\n/**\n * This optimized model holds a class object (singleton class) against every breakpoint type.\n * example\n *      {\n *          \"lifeCycles\" : new LifeCycleModel(),\n *          \"actions\" : new ActionModel(),\n *          \"globalEvents\" : new GlobalEventsModel(),\n *          \"ctx\" : new CtxModel() *\n *       }\n */\nlet generateOptimizedModel = () => {\n    let breakPointTypes = [ 'lifeCycles', 'actions', 'globalEvents', 'ctx', 'commands', 'events', 'routes', 'dataParsers' ];\n    /**\n     *  Whenever we re-generate the optimized view-model\n     *  we should take care to clear all the exiting breakpoints.\n     */\n    for( let breakPointType of breakPointTypes ) {\n        if( optBrkModel.has( breakPointType ) ) {\n            // Every class from optBrkModel.get( breakPointType ) has clear() method implemented.\n            optBrkModel.get( breakPointType ).clearConditions();\n        }\n    }\n\n    for( let breakPointName in breakpointsModel ) {\n        let breakPointObj = breakpointsModel[ breakPointName ];\n        for( let breakPointType of breakPointTypes ) {\n            switch ( breakPointType ) {\n                case 'lifeCycles':\n                    generateLifeCycleModel( breakPointObj.lifeCycles );\n                    break;\n                case 'actions':\n                    generateActionModel( breakPointObj.actions );\n                    break;\n                case 'globalEvents':\n                    generateGlobalEventsModel( breakPointObj.globalEvents );\n                    break;\n                case 'events':\n                    generateEventModel( breakPointObj.events );\n                    break;\n                case 'dataParsers':\n                    generateDataParserModel( breakPointObj.dataParsers );\n                    break;\n                case 'ctx':\n                    generateCtxModel( breakPointObj.ctx );\n                    break;\n                case 'commands':\n                    generateCommandsModel( breakPointObj.commands );\n                    break;\n                case 'routes':\n                    generateRoutesModel( breakPointObj.routes );\n                    break;\n            }\n        }\n    }\n};\n\n/**\n * This is a singleton 'lifeCycles' class, which holds all the breakpoint\n * information related to lifecycles for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n *  @param {*} model the input model to create breakpoints for viewmodel lifeCycle.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n *\n */\nlet generateLifeCycleModel = ( model ) => {\n    class LifeCycleModel {\n        constructor() {\n            if( LifeCycleModel.instance ) {\n                return LifeCycleModel.instance;\n            }\n            LifeCycleModel.instance = this;\n            this.holder = new Map();\n            return this;\n        }\n        addInput( lifeCycleInput ) {\n            processInputModel( lifeCycleInput, this.holder );\n        }\n        hasPanelId( panelId ) {\n            return this.holder.has( panelId );\n        }\n        getStage( panelId ) {\n            return this.holder.get( panelId );\n        }\n        breakPointCondSatisfied( panelId, stage ) {\n            if( this.hasPanelId( panelId ) ) {\n                return this.holder.get( panelId ).includes( stage );\n            }\n            return false;\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'lifeCycles' ) ) {\n        optBrkModel.set( 'lifeCycles', new LifeCycleModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'lifeCycles' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for viewmodel actions.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateActionModel = ( model ) => {\n    class ActionModel {\n        constructor() {\n            if( ActionModel.instance ) {\n                return ActionModel.instance;\n            }\n            ActionModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( actionInputModel ) {\n            let panelNames = Object.keys( actionInputModel );\n            for( let panelName of panelNames ) {\n                if( !this.modelHolder.has( panelName ) ) {\n                    let actionModel = new Map();\n                    let actionObj = actionInputModel[ panelName ];\n                    Object.keys( actionObj ).forEach( ( actionName ) => {\n                        let actionStage = actionObj[ actionName ] instanceof Array ? actionObj[ actionName ] : [ actionObj[ actionName ] ];\n                        actionModel.set( actionName, actionStage );\n                    } );\n                    this.modelHolder.set( panelName, actionModel );\n                } else {\n                    let srcActionModel = this.modelHolder.get( panelName );\n                    let newActionModel = actionInputModel[ panelName ];\n                    processInputModel( newActionModel, srcActionModel );\n                }\n            }\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n\n        hasActionId( panelId, actionId ) {\n            if( this.modelHolder.has( panelId ) ) {\n                return this.modelHolder.get( panelId ).has( actionId );\n            }\n            return false;\n        }\n\n        breakPointCondSatisfied( panelId, actionId, stage ) {\n            if( this.hasActionId( panelId, actionId ) ) {\n                return this.modelHolder.get( panelId ).get( actionId ).includes( stage );\n            }\n            return false;\n        }\n\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'actions' ) ) {\n        optBrkModel.set( 'actions', new ActionModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'actions' ).addInput( model );\n    }\n};\n\nlet generateEventModel = ( model ) => {\n    class EventModel {\n        constructor() {\n            if( EventModel.instance ) {\n                return EventModel.instance;\n            }\n            EventModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( eventInputModel ) {\n            processInputModel( eventInputModel, this.modelHolder );\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n        hasEventName( panelId, eventName ) {\n            try {\n                if( this.hasPanelId( panelId ) ) {\n                    let eventNames = this.modelHolder.get( panelId );\n                    // If user provides an incorrect regular expression\n                    // the RegExp constructor throws an exception.\n                    // We do not want to throw any exception due to user error\n                    // hence, eating up the exception and throwing false.\n                    //let regexp = RegExp( eventName, 'g' );\n                    //return eventNames.some( e => regexp.test( e ) );\n                    return eventNames.some( e => {\n                        try {\n                            let regexp = RegExp( e, 'g' );\n                            return regexp.test( eventName );\n                        } catch ( e ) {\n                            return false;\n                        }\n                    } );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        breakPointCondSatisfied( panelId, eventName ) {\n            return this.hasEventName( panelId, eventName );\n        }\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'events' ) ) {\n        optBrkModel.set( 'events', new EventModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'events' ).addInput( model );\n    }\n};\n\nlet generateDataParserModel = ( model ) => {\n    class DataParserModel {\n        constructor() {\n            if( DataParserModel.instance ) {\n                return DataParserModel.instance;\n            }\n            DataParserModel.instance = this;\n            this.modelHolder = new Map();\n            return this;\n        }\n        addInput( eventInputModel ) {\n            processInputModel( eventInputModel, this.modelHolder );\n        }\n        hasPanelId( panelId ) {\n            return this.modelHolder.has( panelId );\n        }\n        hasDataParser( panelId, dataParserId ) {\n            try {\n                if( this.hasPanelId( panelId ) ) {\n                    let dataParsers = this.modelHolder.get( panelId );\n                    // If user provides an incorrect regular expression\n                    // the RegExp constructor throws an exception.\n                    // We do not want to throw any exception due to user error\n                    // hence, eating up the exception and throwing false.\n                    //let regexp = RegExp( eventName, 'g' );\n                    //return eventNames.some( e => regexp.test( e ) );\n                    return dataParsers.some( e => {\n                        try {\n                            let regexp = RegExp( e, 'g' );\n                            return regexp.test( dataParserId );\n                        } catch ( e ) {\n                            return false;\n                        }\n                    } );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        breakPointCondSatisfied( panelId, dataParserId ) {\n            return this.hasDataParser( panelId, dataParserId );\n        }\n        clearConditions() {\n            this.modelHolder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'dataParsers' ) ) {\n        optBrkModel.set( 'dataParsers', new DataParserModel() );\n    }\n\n    if( model ) {\n        optBrkModel.get( 'dataParsers' ).addInput( model );\n    }\n};\n\n/**\n * This is a singleton 'globalEvents' class, which holds all the breakpoint\n * information related to global events for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n * @param {*} model\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateGlobalEventsModel = ( model ) => {\n    class GlobalEventsModel {\n        constructor() {\n            if( GlobalEventsModel.instance ) {\n                return GlobalEventsModel.instance;\n            }\n            GlobalEventsModel.instance = this;\n            // ModelHolder is not being used currently. It would be used\n            // once we provide the support for matching the eventData\n            this.modelHolder = new Map();\n            this.eventNames = [];\n            return this;\n        }\n        addInput( GlobalEventsModel ) {\n            Object.keys( GlobalEventsModel ).forEach( ( eventName ) => {\n                let eventData = GlobalEventsModel[ eventName ];\n                this.modelHolder.set( eventName, eventData );\n                this.eventNames.push( eventName );\n            } );\n        }\n        hasEventName( eventName ) {\n            try {\n                // If user provides an incorrect regular expression\n                // the RegExp constructor throws an exception.\n                // We do not want to throw any exception due to user error\n                // hence, eating up the exception and throwing false.\n                return this.eventNames.some( e => {\n                    try {\n                        let regexp = RegExp( e, 'g' );\n                        return regexp.test( eventName );\n                    } catch ( e ) {\n                        return false;\n                    }\n                } );\n            } catch ( e ) {\n                return false;\n            }\n        }\n\n        breakPointCondSatisfied( eventName ) {\n            return this.hasEventName( eventName );\n        }\n\n        clearConditions() {\n            this.modelHolder.clear();\n            this.eventNames.length = 0;\n        }\n    }\n\n    if( !optBrkModel.has( 'globalEvents' ) ) {\n        optBrkModel.set( 'globalEvents', new GlobalEventsModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'globalEvents' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for app context changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateCtxModel = ( model ) => {\n    class CtxModel {\n        constructor() {\n            if( CtxModel.instance ) {\n                return CtxModel.instance;\n            }\n            CtxModel.instance = this;\n            this.holder = new Map();\n            this.ctxKeys = [];\n            return this;\n        }\n        addInput( ctxInput ) {\n            processInputModel( ctxInput, this.holder );\n            Object.keys( ctxInput ).forEach( ( ctxkey ) => {\n                this.ctxKeys.push( ctxkey );\n            } );\n        }\n        hasCtxKey( userKey, stage ) {\n            try {\n                let userKeyExist = ( ctxKey ) => {\n                    try {\n                        let regexp = RegExp( ctxKey, 'g' );\n                        return regexp.test( userKey );\n                    } catch {\n                        return false;\n                    }\n                };\n                if( this.ctxKeys.some( userKeyExist ) ) {\n                    return this.holder.get( userKey ).includes( stage );\n                }\n                return false;\n            } catch ( e ) {\n                return false;\n            }\n        }\n        getStage( panelId ) {\n            return this.holder.get( panelId );\n        }\n        breakPointCondSatisfied( ctxKey, stage ) {\n            return this.hasCtxKey( ctxKey, stage );\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'ctx' ) ) {\n        optBrkModel.set( 'ctx', new CtxModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'ctx' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for commands.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateCommandsModel = ( model ) => {\n    class CommandsModel {\n        constructor() {\n            if( CommandsModel.instance ) {\n                return CommandsModel.instance;\n            }\n            CommandsModel.instance = this;\n            this.holder = [];\n            return this;\n        }\n        addInput( commands ) {\n            if( commands instanceof Array ) {\n                this.holder = [ ...this.holder, ...commands ];\n            }\n            this.holder.push( commands );\n        }\n        hasCommandName( commandName ) {\n            return this.holder.includes( commandName );\n        }\n        breakPointCondSatisfied( commandName ) {\n            return this.hasCommandName( commandName );\n        }\n        clearConditions() {\n            this.holder.length = 0;\n        }\n    }\n    if( !optBrkModel.has( 'commands' ) ) {\n        optBrkModel.set( 'commands', new CommandsModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'commands' ).addInput( model );\n    }\n};\n\n/**\n *\n * @param {*} model the input model to create breakpoints for route changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */\nlet generateRoutesModel = ( model ) => {\n    class RoutesModel {\n        constructor() {\n            if( RoutesModel.instance ) {\n                return RoutesModel.instance;\n            }\n            RoutesModel.instance = this;\n            this.holder = new Map();\n            return this;\n        }\n        addInput( model ) {\n            Object.keys( model ).forEach( ( fromState ) => {\n                let toState = model[ fromState ] ? model[ fromState ] : null;\n                this.holder.set( fromState, toState );\n            } );\n        }\n        breakPointCondSatisfied( fromState, toState ) {\n            if( this.holder.has( fromState ) ) {\n                if( !this.holder.get( fromState ) ) {\n                    return true;\n                }\n                return this.holder.get( fromState ) === toState;\n            }\n            return false;\n        }\n        clearConditions() {\n            this.holder.clear();\n        }\n    }\n    if( !optBrkModel.has( 'routes' ) ) {\n        optBrkModel.set( 'routes', new RoutesModel() );\n    }\n    if( model ) {\n        optBrkModel.get( 'routes' ).addInput( model );\n    }\n};\n\nlet breakpointSvc = {\n    addBreakPoint,\n    removeBreakPoint,\n    removeAllBreakPoints,\n    hasConditionSatisfied,\n    enableBreakPoints,\n    getAllBreakPoints\n};\nexport default breakpointSvc;\nwindow.breakpointSvc = breakpointSvc;\n"]},"metadata":{},"sourceType":"module"}