{"ast":null,"code":"/* eslint-disable complexity */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declFieldService\n *\n * @namespace declFieldService\n */\n//@collapse\nimport _ from 'lodash';\n\nconst checkIsListOfVMP = list => {\n  let isVMPArray = false;\n\n  if (_.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      isVMPArray = isVMPObj(list[i]);\n\n      if (!isVMPArray) {\n        break;\n      }\n    }\n  }\n\n  return isVMPArray;\n};\n\nconst isVMOObj = dataObject => {\n  return dataObject && dataObject.props;\n};\n\nconst isVMPObj = dataObject => {\n  return dataObject && dataObject.hasOwnProperty('dbValue') && dataObject.hasOwnProperty('uiValue');\n};\n\nconst populateFieldsForAtomicData = function (atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData) {\n  Object.keys(atomicData).forEach(atomicDataName => {\n    let prevFields = fieldsRef.current;\n    let prevField = prevFields && prevFields[atomicDataName];\n    let prevStateObj = prevField && prevField.value;\n    let currentStateObject = atomicData[atomicDataName];\n\n    let metaDef = _.get(declViewModelJson, `data.${atomicDataName}.meta`);\n\n    if (prevStateObj === currentStateObject) {\n      fields[atomicDataName] = prevField;\n    } else {\n      fields[atomicDataName] = createFieldsBasedOnMetaData(currentStateObject, metaDef, atomicDataName, createFieldForAtomicData, fieldsRef);\n    }\n  });\n};\n\nconst populateFieldForCtx = function (ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty) {\n  if (ctxFields) {\n    ctxFields.forEach(fieldName => {\n      const prop = _.get(ctx, fieldName); //Revisit me: Ria\n      //a.b.c => a_b_c : to use a prop key\n      //a[b].c not handled. Discuss with Jesse.\n\n\n      const name = fieldName.replace(/\\./g, '_');\n\n      if (prop && prop.props) {\n        fields[name] = {};\n        Object.keys(prop.props).forEach(prop => {\n          let prevField = fieldsRef[name] && fieldsRef[name][prop];\n          let newField = constructFieldForNamedPropertyVMO(fieldName, prop);\n\n          if (isFieldsEqual(prevField, newField)) {\n            fields[name][prop] = prevField;\n          } else {\n            fields[name][prop] = newField;\n          }\n        });\n      } else {\n        let prevField = fieldsRef[name];\n        const ctxField = constructFieldForNamedProperty(fieldName, true);\n\n        if (isFieldsEqual(prevField, ctxField)) {\n          fields[name] = prevField;\n        } else {\n          fields[name] = ctxField;\n        }\n      }\n    });\n  }\n};\n\nconst populateFieldsForXRT = function (dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO) {\n  Object.keys(dataObject).forEach(object => {\n    let obj = dataObject[object];\n\n    if (isVMOObj(obj) && obj.type !== 'Awp0XRTObjectSetRow') {\n      fields[object] = {};\n      Object.keys(obj.props).forEach(propName => {\n        let oldFields = fieldsRef.current;\n        let oldField = oldFields && oldFields[object] && oldFields[object][propName];\n        let newField = constructFieldForNamedPropertyVMO('objects[\\'' + object + '\\']', propName);\n\n        if (oldField && isFieldsEqual(oldField, newField)) {\n          fields[object][propName] = oldField;\n        } else {\n          fields[object][propName] = newField;\n        }\n      });\n    }\n  });\n};\n\nconst validateVMPList = function (newFieldArr, oldFieldArr) {\n  let allEqual = true;\n\n  for (let itr = 0; itr < newFieldArr.length; itr++) {\n    let oldField = oldFieldArr && oldFieldArr[itr];\n    let newField = newFieldArr && newFieldArr[itr];\n    allEqual = oldField && isFieldsEqual(oldField, newField);\n\n    if (!allEqual) {\n      break;\n    }\n  }\n\n  return allEqual;\n};\n\nconst populateFieldsForVMO = function (fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO) {\n  fields[stateName] = {};\n  Object.keys(dataObject.props).forEach(propName => {\n    let oldFields = fieldsRef.current;\n    let oldField = oldFields && oldFields[stateName] && oldFields[stateName][propName];\n    let newField = constructFieldForNamedPropertyVMO(stateName, propName);\n\n    if (oldField && isFieldsEqual(oldField, newField)) {\n      fields[stateName][propName] = oldField;\n    } else {\n      fields[stateName][propName] = newField;\n    }\n  });\n};\n\nconst populateFieldsForVMP = function (fieldsRef, stateName, constructFieldForNamedProperty, fields) {\n  let oldFields = fieldsRef.current;\n  let oldField = oldFields && oldFields[stateName];\n  let newField = constructFieldForNamedProperty(stateName);\n\n  if (oldField && isFieldsEqual(oldField, newField)) {\n    fields[stateName] = oldField;\n  } else {\n    fields[stateName] = newField;\n  }\n};\n\nexport const createAllFields = function (data, atomicData, declViewModelJson, createFieldForAtomicData, createFieldsBasedOnMetaData, constructFieldForNamedPropertyVMO, constructFieldArrayOfNamedProperty, constructFieldForNamedProperty, ctx, fieldsRef) {\n  let fields = {};\n  let stateNames = Object.keys(data);\n\n  for (let index = 0; index < stateNames.length; index++) {\n    let stateName = stateNames[index];\n    let dataObject = data[stateName];\n\n    if (_.isObject(dataObject) && !_.isFunction(dataObject) && !stateName.startsWith('_') && stateName !== 'dataProviders') {\n      if (stateName === 'objects') {\n        populateFieldsForXRT(dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO);\n      } else if (isVMPObj(dataObject)) {\n        populateFieldsForVMP(fieldsRef, stateName, constructFieldForNamedProperty, fields);\n      } else if (isVMOObj(dataObject)) {\n        populateFieldsForVMO(fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO);\n      } else if (Array.isArray(dataObject) && checkIsListOfVMP(dataObject)) {\n        let oldFields = fieldsRef.current;\n        let oldFieldArr = oldFields && oldFields[stateName];\n        let newFieldArr = constructFieldArrayOfNamedProperty(dataObject, stateName);\n\n        if (validateVMPList(newFieldArr, oldFieldArr)) {\n          fields[stateName] = oldFieldArr;\n        } else {\n          fields[stateName] = newFieldArr;\n        }\n      }\n    }\n  }\n\n  populateFieldsForAtomicData(atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData);\n  let ctxFields = declViewModelJson.ctxFields;\n  populateFieldForCtx(ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty);\n  return fields;\n};\n\nconst validateFieldData = function (oldField, newField) {\n  if (oldField && oldField.fielddata && newField.fielddata) {\n    if (oldField.fielddata.propertyName !== newField.fielddata.propertyName) {\n      return false;\n    }\n\n    if (oldField.fielddata.propertyDisplayName !== newField.fielddata.propertyDisplayName) {\n      return false;\n    }\n\n    if (oldField.fielddata.renderingHint !== newField.fielddata.renderingHint) {\n      return false;\n    }\n\n    if (oldField.fielddata.isEnabled !== newField.fielddata.isEnabled) {\n      return false;\n    }\n\n    if (oldField.fielddata.isEditable !== newField.fielddata.isEditable) {\n      return false;\n    }\n\n    if (oldField.fielddata.tooltip !== newField.fielddata.tooltip) {\n      return false;\n    }\n\n    if (oldField.fielddata.uwAnchor !== newField.fielddata.uwAnchor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nexport const isFieldsEqual = (oldField, newField) => {\n  //TODO: Back command needs refresh -\n  //Scenarios :Export should work when we add properties and go back and export\n  //Export should work when we add properties and go back and export\n  if (newField.name === 'backCommand') {\n    return false;\n  }\n\n  let newProp = newField && newField.__vmprop__ && newField.__vmprop__();\n\n  let oldProp = oldField && oldField.__vmprop__ && oldField.__vmprop__();\n\n  if (newProp !== oldProp) {\n    return false;\n  }\n\n  let newDataProvider = newField.fielddata && newField.fielddata.dataProvider;\n\n  if (newDataProvider) {\n    return false;\n  }\n\n  if (oldField) {\n    if (oldField.checked !== newField.checked) {\n      return false;\n    }\n\n    if (oldField.value !== newField.value) {\n      return false;\n    }\n\n    if (oldField.dirty !== newField.dirty) {\n      return false;\n    }\n\n    if (oldField.fielddata.uiValue !== newField.fielddata.uiValue) {\n      return false;\n    }\n\n    if (oldField.error !== newField.error) {\n      return false;\n    }\n\n    if (oldField.required !== newField.required) {\n      return false;\n    }\n\n    if (oldField.touched !== newField.touched) {\n      return false;\n    }\n\n    if (oldField.disabled !== newField.disabled) {\n      return false;\n    }\n\n    if (oldField.label !== newField.label) {\n      return false;\n    }\n\n    if (oldField.name !== newField.name) {\n      return false;\n    }\n\n    if (oldField.placeholder !== newField.placeholder) {\n      return false;\n    }\n  }\n\n  return validateFieldData(oldField, newField);\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declFieldService.js"],"names":["checkIsListOfVMP","list","isVMPArray","_","i","isVMPObj","isVMOObj","dataObject","populateFieldsForAtomicData","Object","atomicDataName","prevFields","fieldsRef","prevField","prevStateObj","currentStateObject","atomicData","metaDef","fields","createFieldsBasedOnMetaData","populateFieldForCtx","ctxFields","fieldName","prop","name","newField","constructFieldForNamedPropertyVMO","isFieldsEqual","ctxField","constructFieldForNamedProperty","populateFieldsForXRT","object","obj","propName","oldFields","oldField","validateVMPList","allEqual","itr","newFieldArr","oldFieldArr","populateFieldsForVMO","populateFieldsForVMP","createAllFields","stateNames","index","stateName","data","Array","constructFieldArrayOfNamedProperty","declViewModelJson","validateFieldData","newProp","oldProp","newDataProvider"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable no-unused-vars */\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declFieldService\n *\n * @namespace declFieldService\n */\n//@collapse\n\nimport _ from 'lodash';\n\nconst checkIsListOfVMP = ( list ) => {\n    let isVMPArray = false;\n    if( _.isArray( list ) ) {\n        for( let i = 0; i < list.length; i++ ) {\n            isVMPArray = isVMPObj( list[ i ] );\n            if( !isVMPArray ) {\n                break;\n            }\n        }\n    }\n    return isVMPArray;\n};\n\nconst isVMOObj = ( dataObject ) => {\n    return dataObject && dataObject.props;\n};\n\nconst isVMPObj = ( dataObject ) => {\n    return dataObject && dataObject.hasOwnProperty( 'dbValue' ) && dataObject.hasOwnProperty( 'uiValue' );\n};\n\nconst populateFieldsForAtomicData = function( atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData ) {\n    Object.keys( atomicData ).forEach( atomicDataName => {\n        let prevFields = fieldsRef.current;\n        let prevField = prevFields && prevFields[ atomicDataName ];\n        let prevStateObj = prevField && prevField.value;\n        let currentStateObject = atomicData[ atomicDataName ];\n        let metaDef = _.get( declViewModelJson, `data.${atomicDataName}.meta` );\n        if( prevStateObj === currentStateObject ) {\n            fields[ atomicDataName ] = prevField;\n        } else {\n            fields[ atomicDataName ] = createFieldsBasedOnMetaData( currentStateObject, metaDef, atomicDataName, createFieldForAtomicData, fieldsRef );\n        }\n    } );\n};\n\nconst populateFieldForCtx = function( ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty ) {\n    if( ctxFields ) {\n        ctxFields.forEach( ( fieldName ) => {\n            const prop = _.get( ctx, fieldName );\n            //Revisit me: Ria\n            //a.b.c => a_b_c : to use a prop key\n            //a[b].c not handled. Discuss with Jesse.\n            const name = fieldName.replace( /\\./g, '_' );\n\n            if( prop && prop.props ) {\n                fields[ name ] = {};\n                Object.keys( prop.props ).forEach( prop => {\n                    let prevField = fieldsRef[ name ] && fieldsRef[ name ][ prop ];\n                    let newField = constructFieldForNamedPropertyVMO( fieldName, prop );\n                    if( isFieldsEqual( prevField, newField ) ) {\n                        fields[ name ][ prop ] = prevField;\n                    } else {\n                        fields[ name ][ prop ] = newField;\n                    }\n                } );\n            } else {\n                let prevField = fieldsRef[ name ];\n                const ctxField = constructFieldForNamedProperty( fieldName, true );\n                if( isFieldsEqual( prevField, ctxField ) ) {\n                    fields[ name ] = prevField;\n                } else {\n                    fields[ name ] = ctxField;\n                }\n            }\n        } );\n    }\n};\n\nconst populateFieldsForXRT = function( dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO ) {\n    Object.keys( dataObject ).forEach( object => {\n        let obj = dataObject[ object ];\n        if( isVMOObj( obj ) && obj.type !== 'Awp0XRTObjectSetRow' ) {\n            fields[ object ] = {};\n            Object.keys( obj.props ).forEach( propName => {\n                let oldFields = fieldsRef.current;\n                let oldField = oldFields && oldFields[ object ] && oldFields[ object ][ propName ];\n                let newField = constructFieldForNamedPropertyVMO( 'objects[\\'' + object + '\\']', propName );\n                if( oldField && isFieldsEqual( oldField, newField ) ) {\n                    fields[ object ][ propName ] = oldField;\n                } else {\n                    fields[ object ][ propName ] = newField;\n                }\n            } );\n        }\n    } );\n};\n\nconst validateVMPList = function( newFieldArr, oldFieldArr ) {\n    let allEqual = true;\n    for( let itr = 0; itr < newFieldArr.length; itr++ ) {\n        let oldField = oldFieldArr && oldFieldArr[ itr ];\n        let newField = newFieldArr && newFieldArr[ itr ];\n        allEqual = oldField && isFieldsEqual( oldField, newField );\n        if( !allEqual ) {\n            break;\n        }\n    }\n    return allEqual;\n};\n\nconst populateFieldsForVMO = function( fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO ) {\n    fields[ stateName ] = {};\n    Object.keys( dataObject.props ).forEach( propName => {\n        let oldFields = fieldsRef.current;\n        let oldField = oldFields && oldFields[ stateName ] && oldFields[ stateName ][ propName ];\n        let newField = constructFieldForNamedPropertyVMO( stateName, propName );\n        if( oldField && isFieldsEqual( oldField, newField ) ) {\n            fields[ stateName ][ propName ] = oldField;\n        } else {\n            fields[ stateName ][ propName ] = newField;\n        }\n    } );\n};\n\nconst populateFieldsForVMP = function( fieldsRef, stateName, constructFieldForNamedProperty, fields ) {\n    let oldFields = fieldsRef.current;\n    let oldField = oldFields && oldFields[ stateName ];\n    let newField = constructFieldForNamedProperty( stateName );\n    if( oldField && isFieldsEqual( oldField, newField ) ) {\n        fields[ stateName ] = oldField;\n    } else {\n        fields[ stateName ] = newField;\n    }\n};\n\nexport const createAllFields = function( data,\n    atomicData,\n    declViewModelJson,\n    createFieldForAtomicData,\n    createFieldsBasedOnMetaData,\n    constructFieldForNamedPropertyVMO,\n    constructFieldArrayOfNamedProperty,\n    constructFieldForNamedProperty,\n    ctx, fieldsRef ) {\n    let fields = {};\n\n    let stateNames = Object.keys( data );\n\n    for( let index = 0; index < stateNames.length; index++ ) {\n        let stateName = stateNames[ index ];\n        let dataObject = data[ stateName ];\n        if( _.isObject( dataObject ) && !_.isFunction( dataObject ) && !stateName.startsWith( '_' ) && stateName !== 'dataProviders' ) {\n            if( stateName === 'objects' ) {\n                populateFieldsForXRT( dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO );\n            } else if( isVMPObj( dataObject ) ) {\n                populateFieldsForVMP( fieldsRef, stateName, constructFieldForNamedProperty, fields );\n            } else if( isVMOObj( dataObject ) ) {\n                populateFieldsForVMO( fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO );\n            } else if( Array.isArray( dataObject ) && checkIsListOfVMP( dataObject ) ) {\n                let oldFields = fieldsRef.current;\n                let oldFieldArr = oldFields && oldFields[ stateName ];\n                let newFieldArr = constructFieldArrayOfNamedProperty( dataObject, stateName );\n                if( validateVMPList( newFieldArr, oldFieldArr ) ) {\n                    fields[ stateName ] = oldFieldArr;\n                } else {\n                    fields[ stateName ] = newFieldArr;\n                }\n            }\n        }\n    }\n\n    populateFieldsForAtomicData( atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData );\n\n    let ctxFields = declViewModelJson.ctxFields;\n    populateFieldForCtx( ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty );\n    return fields;\n};\n\nconst validateFieldData = function( oldField, newField ) {\n    if( oldField && oldField.fielddata && newField.fielddata ) {\n        if( oldField.fielddata.propertyName !== newField.fielddata.propertyName ) {\n            return false;\n        }\n        if( oldField.fielddata.propertyDisplayName !== newField.fielddata.propertyDisplayName ) {\n            return false;\n        }\n        if( oldField.fielddata.renderingHint !== newField.fielddata.renderingHint ) {\n            return false;\n        }\n\n        if( oldField.fielddata.isEnabled !== newField.fielddata.isEnabled ) {\n            return false;\n        }\n\n        if( oldField.fielddata.isEditable !== newField.fielddata.isEditable ) {\n            return false;\n        }\n\n        if( oldField.fielddata.tooltip !== newField.fielddata.tooltip ) {\n            return false;\n        }\n\n        if( oldField.fielddata.uwAnchor !== newField.fielddata.uwAnchor ) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n};\n\nexport const isFieldsEqual = ( oldField, newField ) => {\n    //TODO: Back command needs refresh -\n    //Scenarios :Export should work when we add properties and go back and export\n    //Export should work when we add properties and go back and export\n\n    if( newField.name === 'backCommand' ) {\n        return false;\n    }\n\n    let newProp = newField && newField.__vmprop__ && newField.__vmprop__();\n    let oldProp = oldField && oldField.__vmprop__ && oldField.__vmprop__();\n    if( newProp !== oldProp ) {\n        return false;\n    }\n\n    let newDataProvider = newField.fielddata && newField.fielddata.dataProvider;\n    if( newDataProvider ) {\n        return false;\n    }\n    if( oldField ) {\n        if( oldField.checked !== newField.checked ) {\n            return false;\n        }\n\n        if( oldField.value !== newField.value ) {\n            return false;\n        }\n\n        if( oldField.dirty !== newField.dirty ) {\n            return false;\n        }\n\n        if( oldField.fielddata.uiValue !== newField.fielddata.uiValue ) {\n            return false;\n        }\n\n        if( oldField.error !== newField.error ) {\n            return false;\n        }\n\n        if( oldField.required !== newField.required ) {\n            return false;\n        }\n\n        if( oldField.touched !== newField.touched ) {\n            return false;\n        }\n\n        if( oldField.disabled !== newField.disabled ) {\n            return false;\n        }\n\n        if( oldField.label !== newField.label ) {\n            return false;\n        }\n\n        if( oldField.name !== newField.name ) {\n            return false;\n        }\n\n        if( oldField.placeholder !== newField.placeholder ) {\n            return false;\n        }\n    }\n\n    return validateFieldData( oldField, newField );\n};\n"]},"metadata":{},"sourceType":"module"}