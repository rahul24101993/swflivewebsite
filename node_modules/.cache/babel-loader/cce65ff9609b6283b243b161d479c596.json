{"ast":null,"code":"/* eslint-disable complexity */ /* eslint-disable no-unused-vars */ /* eslint-disable max-lines */ // Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declFieldService\n *\n * @namespace declFieldService\n */ //@collapse\nimport _ from'lodash';const checkIsListOfVMP=list=>{let isVMPArray=false;if(_.isArray(list)){for(let i=0;i<list.length;i++){isVMPArray=isVMPObj(list[i]);if(!isVMPArray){break;}}}return isVMPArray;};const isVMOObj=dataObject=>{return dataObject&&dataObject.props;};const isVMPObj=dataObject=>{return dataObject&&dataObject.hasOwnProperty('dbValue')&&dataObject.hasOwnProperty('uiValue');};const populateFieldsForAtomicData=function(atomicData,fieldsRef,declViewModelJson,fields,createFieldsBasedOnMetaData,createFieldForAtomicData){Object.keys(atomicData).forEach(atomicDataName=>{let prevFields=fieldsRef.current;let prevField=prevFields&&prevFields[atomicDataName];let prevStateObj=prevField&&prevField.value;let currentStateObject=atomicData[atomicDataName];let metaDef=_.get(declViewModelJson,\"data.\".concat(atomicDataName,\".meta\"));if(prevStateObj===currentStateObject){fields[atomicDataName]=prevField;}else{fields[atomicDataName]=createFieldsBasedOnMetaData(currentStateObject,metaDef,atomicDataName,createFieldForAtomicData,fieldsRef);}});};const populateFieldForCtx=function(ctxFields,ctx,fields,fieldsRef,constructFieldForNamedPropertyVMO,constructFieldForNamedProperty){if(ctxFields){ctxFields.forEach(fieldName=>{const prop=_.get(ctx,fieldName);//Revisit me: Ria\n//a.b.c => a_b_c : to use a prop key\n//a[b].c not handled. Discuss with Jesse.\nconst name=fieldName.replace(/\\./g,'_');if(prop&&prop.props){fields[name]={};Object.keys(prop.props).forEach(prop=>{let prevField=fieldsRef[name]&&fieldsRef[name][prop];let newField=constructFieldForNamedPropertyVMO(fieldName,prop);if(isFieldsEqual(prevField,newField)){fields[name][prop]=prevField;}else{fields[name][prop]=newField;}});}else{let prevField=fieldsRef[name];const ctxField=constructFieldForNamedProperty(fieldName,true);if(isFieldsEqual(prevField,ctxField)){fields[name]=prevField;}else{fields[name]=ctxField;}}});}};const populateFieldsForXRT=function(dataObject,fields,fieldsRef,constructFieldForNamedPropertyVMO){Object.keys(dataObject).forEach(object=>{let obj=dataObject[object];if(isVMOObj(obj)&&obj.type!=='Awp0XRTObjectSetRow'){fields[object]={};Object.keys(obj.props).forEach(propName=>{let oldFields=fieldsRef.current;let oldField=oldFields&&oldFields[object]&&oldFields[object][propName];let newField=constructFieldForNamedPropertyVMO('objects[\\''+object+'\\']',propName);if(oldField&&isFieldsEqual(oldField,newField)){fields[object][propName]=oldField;}else{fields[object][propName]=newField;}});}});};const validateVMPList=function(newFieldArr,oldFieldArr){let allEqual=true;for(let itr=0;itr<newFieldArr.length;itr++){let oldField=oldFieldArr&&oldFieldArr[itr];let newField=newFieldArr&&newFieldArr[itr];allEqual=oldField&&isFieldsEqual(oldField,newField);if(!allEqual){break;}}return allEqual;};const populateFieldsForVMO=function(fields,stateName,dataObject,fieldsRef,constructFieldForNamedPropertyVMO){fields[stateName]={};Object.keys(dataObject.props).forEach(propName=>{let oldFields=fieldsRef.current;let oldField=oldFields&&oldFields[stateName]&&oldFields[stateName][propName];let newField=constructFieldForNamedPropertyVMO(stateName,propName);if(oldField&&isFieldsEqual(oldField,newField)){fields[stateName][propName]=oldField;}else{fields[stateName][propName]=newField;}});};const populateFieldsForVMP=function(fieldsRef,stateName,constructFieldForNamedProperty,fields){let oldFields=fieldsRef.current;let oldField=oldFields&&oldFields[stateName];let newField=constructFieldForNamedProperty(stateName);if(oldField&&isFieldsEqual(oldField,newField)){fields[stateName]=oldField;}else{fields[stateName]=newField;}};export const createAllFields=function(data,atomicData,declViewModelJson,createFieldForAtomicData,createFieldsBasedOnMetaData,constructFieldForNamedPropertyVMO,constructFieldArrayOfNamedProperty,constructFieldForNamedProperty,ctx,fieldsRef){let fields={};let stateNames=Object.keys(data);for(let index=0;index<stateNames.length;index++){let stateName=stateNames[index];let dataObject=data[stateName];if(_.isObject(dataObject)&&!_.isFunction(dataObject)&&!stateName.startsWith('_')&&stateName!=='dataProviders'){if(stateName==='objects'){populateFieldsForXRT(dataObject,fields,fieldsRef,constructFieldForNamedPropertyVMO);}else if(isVMPObj(dataObject)){populateFieldsForVMP(fieldsRef,stateName,constructFieldForNamedProperty,fields);}else if(isVMOObj(dataObject)){populateFieldsForVMO(fields,stateName,dataObject,fieldsRef,constructFieldForNamedPropertyVMO);}else if(Array.isArray(dataObject)&&checkIsListOfVMP(dataObject)){let oldFields=fieldsRef.current;let oldFieldArr=oldFields&&oldFields[stateName];let newFieldArr=constructFieldArrayOfNamedProperty(dataObject,stateName);if(validateVMPList(newFieldArr,oldFieldArr)){fields[stateName]=oldFieldArr;}else{fields[stateName]=newFieldArr;}}}}populateFieldsForAtomicData(atomicData,fieldsRef,declViewModelJson,fields,createFieldsBasedOnMetaData,createFieldForAtomicData);let ctxFields=declViewModelJson.ctxFields;populateFieldForCtx(ctxFields,ctx,fields,fieldsRef,constructFieldForNamedPropertyVMO,constructFieldForNamedProperty);return fields;};const validateFieldData=function(oldField,newField){if(oldField&&oldField.fielddata&&newField.fielddata){if(oldField.fielddata.propertyName!==newField.fielddata.propertyName){return false;}if(oldField.fielddata.propertyDisplayName!==newField.fielddata.propertyDisplayName){return false;}if(oldField.fielddata.renderingHint!==newField.fielddata.renderingHint){return false;}if(oldField.fielddata.isEnabled!==newField.fielddata.isEnabled){return false;}if(oldField.fielddata.isEditable!==newField.fielddata.isEditable){return false;}if(oldField.fielddata.tooltip!==newField.fielddata.tooltip){return false;}if(oldField.fielddata.uwAnchor!==newField.fielddata.uwAnchor){return false;}return true;}return false;};export const isFieldsEqual=(oldField,newField)=>{//TODO: Back command needs refresh -\n//Scenarios :Export should work when we add properties and go back and export\n//Export should work when we add properties and go back and export\nif(newField.name==='backCommand'){return false;}let newProp=newField&&newField.__vmprop__&&newField.__vmprop__();let oldProp=oldField&&oldField.__vmprop__&&oldField.__vmprop__();if(newProp!==oldProp){return false;}let newDataProvider=newField.fielddata&&newField.fielddata.dataProvider;if(newDataProvider){return false;}if(oldField){if(oldField.checked!==newField.checked){return false;}if(oldField.value!==newField.value){return false;}if(oldField.dirty!==newField.dirty){return false;}if(oldField.fielddata.uiValue!==newField.fielddata.uiValue){return false;}if(oldField.error!==newField.error){return false;}if(oldField.required!==newField.required){return false;}if(oldField.touched!==newField.touched){return false;}if(oldField.disabled!==newField.disabled){return false;}if(oldField.label!==newField.label){return false;}if(oldField.name!==newField.name){return false;}if(oldField.placeholder!==newField.placeholder){return false;}}return validateFieldData(oldField,newField);};","map":null,"metadata":{},"sourceType":"module"}