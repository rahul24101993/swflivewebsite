{"ast":null,"code":"/* eslint-disable complexity */ // Copyright (c) 2020 Siemens\n/* global\nafxWeakImport\nAFX_EXTRA_DEPS\n*/ /**\n * mock for dynamic import\n *\n * @module js/moduleLoader\n *\n * @namespace moduleLoader\n */import _ from'lodash';import loadable from'@loadable/component';import AwPromiseService from'js/awPromiseService';import AwBaseService from'js/awBaseService';import{parseImports}from'js/utils';import{getImageAliasFromId}from'js/imageRegistry';import{jsx as _jsx}from\"react/jsx-runtime\";let _includedComponentCache={};// revisitme - like John said we can do deps: () => callback directly. But approach\n// below is lowest impact solution\nconst dynImportRegistration={'js/browserUtils':async()=>await import('js/browserUtils')};/**\n * register dynamic import entry to dynImportRegistration.\n * mainly used by all JSON loader.\n * has best compatibility to existing declUtils design\n * @param {String} name module name when we use it in JSON\n * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`\n */export const registerDynImportEntry=(name,callback)=>{dynImportRegistration[name]=callback;};AFX_EXTRA_DEPS;export const loadDynModule=name=>{if(dynImportRegistration[name]!==undefined){return new Promise(resolve=>{dynImportRegistration[name]().then(obj=>{const resolved=obj&&obj.__esModule&&obj.default?obj.default:obj;if(resolved.prototype instanceof AwBaseService){return resolve(resolved.instance);}return resolve(resolved);});});}throw Error(\"Library \".concat(name,\" does not exist!\"));};export const afxDynamicImport=(deps,func)=>{let modules=[];for(const contri of deps){modules.push(loadDynModule(contri));}return new Promise(resolve=>{// LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick\n// behavior in requirejs.\nsetTimeout(()=>{return Promise.all(modules).then(response=>{return resolve(func.apply(null,response.map(obj=>obj&&obj.__esModule&&obj.default?obj.default:obj)));});},0);});};/**\n * Get angular injected module if necessary\n *\n * @param {*} moduleObj - The loaded module\n * @return {Object} Updated dep module\n */const getModuleInstance=moduleObj=>{if(moduleObj&&moduleObj.prototype instanceof AwBaseService){return moduleObj.instance;}return moduleObj;};/**\n * Get a module synchronously. Returns null if module is not loaded.\n *\n * @param {*} depModuleName -\n *\n * @returns {Object|null} Reference to module API object.\n */export const getDependentModule=depModuleName=>{/** revisitme\n     *  remove me later (loadModule)\n     */return loadDynModule(depModuleName);// LCS-299148 Beyond Angular: Clean up app.getInjector usage\n// afxWeakImport will be setup either in aw_polyfill or afxImport\n//return afxWeakImport( depModuleName );\n};/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */export const loadDependentModule=depModule=>{return getDependentModule(depModule);/**\n     * revsitme\n     * afxDynamicImport is not supported yet\n     */ // return AwPromiseService.instance( function( resolve, reject ) {\n//     if( depModule ) {\n//         afxDynamicImport( [ depModule ], function( depModule2 ) {\n//             resolve( getModuleInstance( depModule2 ) );\n//         }, reject );\n//     } else {\n//         resolve();\n//     }\n// } );\n};export const loadStaticDependentModule=depModule=>{if(depModule){return getModuleInstance(depModule);}return undefined;};/**\n * @param {String[]} depModules - The dependent modules to load.\n * @return {Promise} This promise will be resolved when the given module has been loaded.\n */export const loadDependentModules=depModules=>{return AwPromiseService.instance(function(resolve,reject){if(depModules&&depModules.length>0){afxDynamicImport(depModules,function(){let retModulesMap={};// LCS-299148 Beyond Angular: Clean up app.getInjector usage\n// This interface has bug for the else block, in no case it\n// will return arg as string which can run injector.get(arg)\n// who is using this interface will only supports angularJS service\n// with other limitaton\n//\n// They are:\n// - AFX\n//   - find function.deps in actionService\n//     - Example: src\\thinclient\\requirementscommandpanelsjs\\src\\viewmodel\\Arm0ExportToRoundTripWordDocumentViewModel.json\n//     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc\n//       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method\n//       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')\n//   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)\n//   - highlighterService -> this is fine which is a blind load\n// - AW\n//   - Ase0DualSaveHandler -> this is fine which is a blind load\n//   - aw-gantt.controller -> this is fine which is a blind load\n//\n// - Long term solution\n//   - Rewrite the interface to retrun array only. Refactor all caller\n// - Short term solution\n//   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)\n//\n// - How function definition works today\n//   - Not all function definition supports deps, only function in viewModel ( details see schema )\n//   - all the function imple should be sync otherwise you will get a unexpected promise object\n//   - It has different behavior in different place:\n//     - inputData.data: \"{{function:testFunc}}\"\n//       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.\n//       - While loading the deps by this function, it will blindly add key-module pare to depModules,\n//         For example you will get someActionService['functionSvcName'] = functionService, with all\n//         method provided by someActionService together...\n//       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules\n//         recursively to get the corrct function\n//         - But if a same function exist in someActionService, it will still take priority...\n//\n//     - outputData: \"{{function: testFunc}}\"\n//       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD\n//         BE the actual key in deps. For example:\n//         - You define { functions: { aaa: { functionName: showInfo }}}\n//         - When use it, we use {{function:showInfo}}, not {{function:aaa}}\n//       - No matter what you put in deps, it will always go to main dep (action dep)\n//         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)\n_.forEach(arguments,function(arg,idx){let moduleName=depModules[idx].replace(/^.*\\//,'');if(arg.prototype instanceof AwBaseService){retModulesMap[moduleName]=arg.instance;}else{retModulesMap[moduleName]=arg;}});resolve(retModulesMap);});}else{resolve();}});};/**\n * Loading the imported JS\n *\n * @param {StringArray} moduleNames - Array of module's to 'import'.\n *\n * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent\n *         modules.\n */export const loadImports=moduleNames=>{return AwPromiseService.instance(function(resolve,reject){if(moduleNames&&moduleNames.length>0){afxDynamicImport(moduleNames,function(){var moduleObjs=[];_.forEach(arguments,function(arg){if(arg){if(arg.prototype instanceof AwBaseService){moduleObjs.push(arg.instance);}else{moduleObjs.push(arg);}}});resolve(moduleObjs);});}else{resolve();}});};/**\n * Loading the imported svgs dynamically.\n *\n * @param {String} imageId - String ImageId which can either be complete alias or just imageId.\n * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.\n * @returns Dynamic Image Component\n */export const includeImage=(imageId,exactMatch)=>{if(imageId){let DynamicComponent=_includedComponentCache[imageId];if(!DynamicComponent){const imageAlias=exactMatch?imageId:getImageAliasFromId(imageId);DynamicComponent=loadable(()=>{try{return loadDynModule(imageAlias).then(resolved=>resolved.SvgComponent);}catch(error){console.log(error.message);return Promise.resolve(()=>null);}},{fallback:/*#__PURE__*/_jsx(\"svg\",{style:{width:'16px',height:'16px'}})});_includedComponentCache[imageId]=DynamicComponent;}// add viewId to facilitate debug\nreturn/*#__PURE__*/_jsx(DynamicComponent,{});}};export const includeComponent=(componentName,prop)=>{if(componentName){let DynamicComponent=_includedComponentCache[componentName];let viewId=prop.viewId?prop.viewId:componentName;if(!DynamicComponent){DynamicComponent=loadable(()=>{try{return loadDynModule(\"viewmodel/\".concat(componentName,\"ViewModel\"));}catch(error){console.log(error.message);return Promise.resolve(()=>null);}});_includedComponentCache[componentName]=DynamicComponent;}// add viewId to facilitate debug\nreturn/*#__PURE__*/_jsx(DynamicComponent,{viewId:viewId,...prop});}};window.afxDynamicImport=afxDynamicImport;// dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build\n// AFX_CONFIG_ENTRY\nregisterDynImportEntry('lodash',()=>import('lodash'));registerDynImportEntry('js/configurationService',()=>import('js/configurationService'));registerDynImportEntry('js/viewModelService',()=>import('js/viewModelService'));// export default for test purpose\nexport default{getDependentModule,loadDependentModule,includeComponent,loadStaticDependentModule,loadDependentModules,loadImports,includeImage};","map":null,"metadata":{},"sourceType":"module"}