{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * The native session manager service. This is the coordination/orchestration component which manages the\n * authentication state and authentication processing for signIn and signOut session behavior. The chosen\n * Authenticator performs the actual mechanics of any authentication.\n *\n * This represents the session tracking and authentication detection.\n * @module js/sessionManager.service\n */\nimport cfgSvc from 'js/configurationService';\nimport contributionSvc from 'js/contribution.service';\nimport postLgnPipeLneSvc from 'js/postLoginPipeline.service';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport sessionState from 'js/sessionState';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport analyticsSvc from 'js/analyticsService';\nimport moduleLoader from 'js/moduleLoader';\nimport cas from 'js/centralAggregationService'; // Service\n\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService'; // revisitme: uncomment following imports once available\n\nimport splmStatsService from 'js/splmStatsService'; // import analyticsSvc from 'js/analyticsService';\n\nvar _debug_logAuthActivity = browserUtils.getUrlAttributes().logAuthActivity !== undefined; // service and module references\n// members\n\n\nvar _savedNavTarget;\n\nvar _targetAuthenticator; // flag to suppress location reload during logoff; required for SSO support (ie11 + IIS)\n\n\nvar _suppressReload = false; // prop set/get functions\n\nvar exports = {};\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} isAuth - Whether or not session is currently authenticated.\n */\n\nexport let setAuthStatus = function (isAuth) {\n  sessionState.setAuthStatus(isAuth);\n};\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is session currently authenticated\n */\n\nexport let getAuthStatus = function () {\n  return sessionState.getIsAuthenticated();\n};\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is authentication in progress\n */\n\nexport let isAuthenticationInProgress = function () {\n  return sessionState.isAuthenticationInProgress();\n};\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} inProg - is authentication currently in progress.\n */\n\nexport let setAuthenticationInProgress = function (inProg) {\n  sessionState.setAuthenticationInProgress(inProg);\n};\n/**\n * responsible for choosing the appropriate authenticator logic to be used. resolve the promise with the\n * appropriate authenticator. This needs more work to account for the various authenticators....\n *\n * how do we get the list of authenticators? logic to pick which one?\n *\n * @return {Promise} returns a promise to be resolved once the correct authenticator is chosen.\n */\n\nexport let pickAuthenticator = function () {\n  // determine how to \"contribute\" the different authenticators,\n  if (_targetAuthenticator) {\n    // if an authenticator is already set, just use it.\n    return AwPromiseService.instance.resolve(_targetAuthenticator);\n  }\n\n  var name;\n  return cfgSvc.getCfg('solutionDef').then(function (solution) {\n    name = solution.authenticator;\n    return cfgSvc.getCfg('authenticator');\n  }).then(function (authenticators) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: pickAuthenticator: ' + name);\n    }\n\n    return moduleLoader.loadDependentModule(authenticators[name].dep);\n  }).then(function (module) {\n    if (!module) {\n      throw new Error('No authenticator provided!');\n    }\n\n    return module.getAuthenticator();\n  }).then(function (authenticator) {\n    _targetAuthenticator = authenticator;\n    return _targetAuthenticator;\n  });\n}; // Sign out related functions/behavior\n\n/**\n * logic to invoke the authenticator signOut functionality.\n *\n * @return {Promise} promise\n */\n\nvar callAuthSignOut = function () {\n  if (_targetAuthenticator) {\n    return _targetAuthenticator.signOut().then(function () {\n      exports.postSignOut();\n    }).catch(function () {\n      // signOut error, but just continue the path\n      logger.error('SM: authenticator signOut() err');\n      exports.postSignOut();\n    });\n  }\n\n  logger.error('SM:ERROR - processing signOut, but no Authenticator is available');\n};\n/**\n * method to begin the session termination flow. Starts the signOut process.\n *\n * @return {Promise} promise\n */\n\n\nexport let terminateSession = function () {\n  sessionStorage.clear(); // clearing the sessionStorage once session is terminated\n\n  return exports.pickAuthenticator().then(function () {\n    return callAuthSignOut();\n  });\n};\n/**\n * Wrapper function around the window location reset method to allow for unit test execution.\n *\n * Having a distinct method allows test logic to mock out the actual call.\n */\n\nexport let setLocationToDefault = function () {\n  // need to reload the whole location, not just the $state() to refresh content.\n  // Force a refresh of the page to clear memory.\n  // This adds in security & memory leaks.\n  // should go back to the default or startup page.  Use the base URL\n  var base = location.origin + location.pathname + location.search;\n\n  if (_targetAuthenticator && _targetAuthenticator.getPostSignOutURL) {\n    base = _targetAuthenticator.getPostSignOutURL();\n    _suppressReload = true;\n  }\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: setLocationToDefault - target URL: ' + base);\n  }\n\n  exports.locationReplace(base);\n};\n/**\n * To support unit test, we need a wrapper function which can be mocked to support Jasmine unit tests.\n *\n * @param {String} url - URL to set.\n */\n\nexport let locationReplace = function (url) {\n  // eslint-disable-next-line no-debugger\n  debugger;\n  _suppressReload = true;\n  location.replace(url);\n};\n/**\n * This is the post authenticator signOut stage. At this point there is no longer a valid session. Update state\n * and trigger refresh navigation.\n */\n\nexport let postSignOut = function () {\n  exports.setAuthStatus(false);\n  exports.setAuthenticationInProgress(false);\n  localStrg.publish('signingOut', 'true');\n  exports.setLocationToDefault();\n};\nlocalStrg.subscribe('signingOut', () => {\n  setLocationToDefault();\n});\n/**\n * this resolves the in-doubt state of the session, calls detection soa to see if there is a valid session or\n * not. If there is, continue navigation to target and mark session as authenticated. If no active session,\n * start the authentication processing.\n *\n * NOTE - this runs DURING initialization as part of the first state change, and the angular is not yet\n * initialized.\n *\n * @param {Object} navigationTarget - structure with data for the ui-router request.\n * @return {Promise} promise\n */\n\nexport let checkSessionValid = function (navigationTarget) {\n  _savedNavTarget = navigationTarget; // save for post auth.\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: checkSessionValid: ' + 'navigationTarget=' + navigationTarget);\n  }\n\n  localStrg.removeItem('signingOut'); // 1) get the correct authenticator, then defer to the authenticator.\n  //    SSO & userPW will share some of the getSessionInfo3 path for updating session details.\n  // the pick authenticator will determine which of the authenticators to use.\n  // the way pickAuthenticator is called from route resolve, we have to pass it the promise\n\n  var deferred = AwPromiseService.instance.defer();\n  exports.pickAuthenticator().then(function (authenticator) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: authenticator chosen');\n    }\n\n    authenticator.checkIfSessionAuthenticated().then(function () {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: auth check Good! already authenticated');\n      }\n\n      exports.setAuthStatus(true);\n      var allStagesAuthenticated = postLgnPipeLneSvc.checkPostLoginAuthenticatedStages();\n\n      if (allStagesAuthenticated) {\n        exports.runNavToState();\n        eventBus.publish('authentication.complete', {\n          status: 'OK'\n        });\n      } else {\n        exports.runPostLoginBlocking().then(function () {\n          exports.runNavToState();\n          eventBus.publish('authentication.complete', {\n            status: 'OK'\n          });\n        }, function () {\n          if (_debug_logAuthActivity) {\n            logger.info('SM: end runPostLoginBlocking Stage - but ERROR');\n          }\n\n          exports.runNavToState();\n          eventBus.publish('authentication.complete', {\n            status: 'OK'\n          });\n        });\n      }\n\n      deferred.resolve();\n    }).catch(function (err) {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: auth check exception: ' + '\\n' + JSON.stringify(err, null, 2) + '\\n' + ' SM: Go to \"checkAuthentication\" state');\n      }\n\n      if (err && err.cause && err.cause.status === 500) {\n        // \"Internal Server Error\" which typically means that this API isn't available on the server\n        logger.error(err);\n        window.location.replace(browserUtils.getBaseURL() + 'serverError.html');\n      }\n\n      exports.setAuthenticationInProgress(true); // indicator that in-process of authenticating\n\n      AwStateService.instance.go('checkAuthentication');\n      eventBus.publish('authentication.complete', {\n        status: 'Failed'\n      });\n      deferred.resolve();\n    });\n  }, function (err) {\n    logger.error('SM: Unable to pick an authenticator - serious configuration error!');\n    eventBus.publish('authentication.complete', {\n      status: 'Failed'\n    });\n    deferred.reject(err);\n  });\n  return deferred.promise;\n};\n/**\n * Stage 2 of the authentication flow. Owned by the session manager.\n *\n * fires the session.signIn event\n *\n * used as the post authentication common flow. Mark the authentication state complete, continue with the login\n * flow/pipeline.\n *\n * @return {Promise} promise\n */\n\nexport let authenticationSuccessful = function () {\n  exports.setAuthStatus(true);\n  exports.setAuthenticationInProgress(false);\n\n  if (_debug_logAuthActivity) {\n    logger.info('SM: authSuccessful, fire \"session.signIn\" event');\n  } // Used to fire this event ONLY for User/PW SOA call, fire it here for ALL authenticators\n  // this is the point in the session state flow that the authentication is known to be OK.\n\n\n  eventBus.publish('session.signIn', {}); // initial authentication is complete.  Let the authenticator do any initialization,\n  // then see if there is postLogin pipeline content to be executed...\n\n  return exports.runPostAuthInit().then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runPostAuthInit Stage complete - continue to next Auth step');\n    }\n\n    return exports.runPostLoginBlocking();\n  }).then(function () {\n    return exports.runNavToState();\n  });\n};\n/**\n * Reset PipeLine while signing in\n */\n\nexport let resetPipeLine = function () {\n  if (_debug_logAuthActivity) {\n    logger.info('SM: resetPipeLine');\n  }\n\n  postLgnPipeLneSvc.resetPostLoginStages();\n};\n/**\n * next stage of the authentication path. This is a spot for the authenticator to run any specific logic. At\n * this point we've successfully authenticated and any specific initialization can be done.\n *\n * @return {Promise} a promise which is resolved when the authenticator initialization is complete.\n */\n\nexport let runPostAuthInit = function () {\n  return exports.pickAuthenticator().then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runPostAuthInit');\n    }\n\n    analyticsSvc.authenticationSuccessful();\n    return _targetAuthenticator ? _targetAuthenticator.postAuthInitialization() : AwPromiseService.instance.resolve();\n  });\n};\n/**\n * This function is responsible for invoking a single pipeline step definition.\n *\n * A step definition can either identify a route to run OR provide a work function. If the \"routeName\" is\n * provided, that takes precedence and that route will be called.\n *\n * The continuation promise is passed along to the route as part of the custom data structure with a member name\n * of \"nextContinuation\". for the work function, the promise is passed as a function argument.\n *\n * In either case, the route OR the work function MUST either resolve or reject the promise. Resolve path\n * continues pipeline execution, reject will immediately exit the pipeline and not invoke any of the remaining\n * tasks.\n *\n * @param {Object} stepDefn - a step definition for running a single contributed \"step\"\n * @param {Object} curIdx - index of the current step definition in the list\n * @param {Function} fOK - success function to invoke\n * @param {Function} fErr - error function to invoke\n */\n\nvar runOneStep = function (stepDefn, curIdx, fOK, fErr) {\n  // TODO - assert the inputs, non-null stepDefn, fOk & fErr are functions.\n  if (_debug_logAuthActivity) {\n    logger.info('SM: running on steps for idx: ' + curIdx + ' name: ' + stepDefn.name);\n  } // if not active, skip it altogether\n\n\n  if (!stepDefn.active) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: not active, skipping step: ' + stepDefn.name);\n    }\n\n    fOK(curIdx);\n  } // the stepPromise represents the continuation for the pipeline step.\n\n\n  var stepPromise = AwPromiseService.instance.defer();\n  stepPromise.promise.then(function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: done with pipeline Step continue. ' + stepDefn.name);\n    }\n\n    fOK(curIdx);\n  }, function () {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: done with pipeline Step - REJECT ' + stepDefn.name);\n    }\n\n    fErr(curIdx);\n  }); // branch to either routeName for a route, or call the workFunction\n\n  if (stepDefn.routeName && stepDefn.routeName.length > 0) {\n    // invoke the route\n    var stName = stepDefn.routeName;\n    var options = {\n      notify: true,\n      // notify must be true..\n      location: false\n    };\n    var myState = AwStateService.instance.get(stName); // pass the continuation promise as custom data.\n\n    if (myState) {\n      if (myState.data) {\n        myState.data.nextContinuation = stepPromise;\n      } else {\n        myState.data = {\n          nextContinuation: stepPromise\n        };\n      }\n    }\n\n    AwStateService.instance.go(stName, {}, options);\n  } else {\n    // call the work function\n    if (stepDefn.workFunction) {\n      stepDefn.workFunction(stepDefn, stepPromise);\n    } else {\n      if (_debug_logAuthActivity) {\n        logger.info('SM: No work function, assume fOK path');\n      }\n\n      fOK(curIdx);\n    }\n  }\n};\n/**\n * This is the pipeline execution stage - the session manager blocks on any post logic processes. This is a\n * configuration point to execute any contributed post authentication logic.\n *\n * The \"postLoginPipeline\" named contributions are used to obtain pipeline \"step\" definitions which identify the\n * logic or route to be run.\n *\n * @return {Promise} promise\n */\n\n\nexport let runPostLoginBlocking = function () {\n  var postLogInPiplinePromise = AwPromiseService.instance.defer(); // 1) get the list of contributors (0..n)\n  // 2) get the stepDefinitions from each\n  // 3) sort the stepDefinitions by priority value\n  // 4) invoke each in order.  If one rejects then break the chain. ??? or NOT\n  // 5) when all have run, then continue with the next stage step.\n\n  contributionSvc.loadContributions('postLoginPipeline').then(function (contributors) {\n    if (contributors && contributors.length > 0) {\n      var pipeLineSteps = postLgnPipeLneSvc.sortPostLoginPipeline(contributors); // iterate and call each step,\n      // upon last one, continue the postLogInPiplinePromise\n\n      if (pipeLineSteps && pipeLineSteps.length > 0) {\n        var fNext = null;\n        var fErr = null;\n\n        fNext = function (compStepIdx) {\n          pipeLineSteps[compStepIdx].status = true;\n          localStrg.publish('postLoginStagesKey', JSON.stringify(pipeLineSteps));\n          var nextIdx = compStepIdx + 1;\n\n          if (nextIdx >= pipeLineSteps.length) {\n            // done with the last one,\n            if (_debug_logAuthActivity) {\n              logger.info('SM: done with last step, continue post promise');\n            }\n\n            postLogInPiplinePromise.resolve();\n          } else {\n            // run next one\n            runOneStep(pipeLineSteps[nextIdx], nextIdx, fNext, fErr);\n          }\n        };\n\n        fErr = function (compStepIdx) {\n          // step failure, do we fail the pipeline, or continue with the other steps?\n          // could log the issue and fall into the fNext() ...\n          pipeLineSteps[compStepIdx].status = false;\n          localStrg.publish('postLoginStagesKey', JSON.stringify(pipeLineSteps));\n\n          if (_debug_logAuthActivity) {\n            logger.info('SM: one of the steps had an error: ' + compStepIdx);\n          }\n\n          postLogInPiplinePromise.reject();\n        };\n\n        var pipeLineStepToExecute = null;\n        var stepIndex = 0;\n\n        for (; stepIndex < pipeLineSteps.length; stepIndex++) {\n          // find the step that has status false\n          if (!pipeLineSteps[stepIndex].status) {\n            pipeLineStepToExecute = pipeLineSteps[stepIndex];\n            break;\n          }\n        } // start running the steps if step to execute is not null\n\n\n        if (pipeLineStepToExecute) {\n          runOneStep(pipeLineStepToExecute, stepIndex, fNext, fErr);\n        } else {\n          // this means all steps have been successfully executed. resolve the promise\n          postLogInPiplinePromise.resolve();\n        }\n      } else {\n        // no pipeLine steps, continue on.\n        postLogInPiplinePromise.resolve();\n      }\n    } else {\n      // no contributors\n      postLogInPiplinePromise.resolve();\n    }\n  }, function () {\n    // some reject on the contribution service - continue on.\n    logger.error('SM: contribution service error for postLoginPipeline');\n    postLogInPiplinePromise.resolve();\n  }); // the full pipeline promise - when all step definition handlers have completed.\n\n  return postLogInPiplinePromise.promise;\n};\n/**\n * This is the final authentication stage. At this point all handlers have run, the authenticator has done it's\n * initialization, we can now navigate to the desired target state.\n */\n\nexport let runNavToState = function () {\n  if (_savedNavTarget) {\n    if (_debug_logAuthActivity) {\n      logger.info('SM: runNavToState Stage - redirect to original target: ' + _savedNavTarget.toState);\n    }\n\n    AwStateService.instance.go(_savedNavTarget.toState, _savedNavTarget.toParams, _savedNavTarget.options);\n  } else {\n    logger.error('SM: post auth, runNavToState - NO saved Nav Target!!'); // what to do in this situation?  what is the \"default\" state?\n  }\n};\n/**\n * location reload\n */\n\nfunction reload() {\n  if (!_suppressReload) {\n    location.reload(false);\n  }\n}\n/**\n * init set up for localStorage\n */\n\n\nexport let initLocalStorage = function () {\n  /**\n   * Setup to listed to changes in any associated browser's session state.\n   */\n  localStrg.subscribe('awSession', reload);\n};\nexport let reset = function () {\n  _targetAuthenticator = null;\n}; // No dependency on appCtxService, but need the service initialized for event registration\n\n/**\n * Since this module can be loaded GWT-side by the ModuleLoader class we need to return an object indicating\n * which service should be injected to provide the API for this module.\n */\n\nexports = {\n  setAuthStatus,\n  getAuthStatus,\n  isAuthenticationInProgress,\n  setAuthenticationInProgress,\n  pickAuthenticator,\n  terminateSession,\n  setLocationToDefault,\n  locationReplace,\n  postSignOut,\n  checkSessionValid,\n  authenticationSuccessful,\n  resetPipeLine,\n  runPostAuthInit,\n  runPostLoginBlocking,\n  runNavToState,\n  initLocalStorage,\n  reset\n};\nexport default exports;\ninitLocalStorage(); // setup analytics profiler.\n\nsplmStatsService.initProfiler(); // setup global click listener.\n\ncas.initClickListener();","map":{"version":3,"names":["cfgSvc","contributionSvc","postLgnPipeLneSvc","eventBus","browserUtils","sessionState","localStrg","logger","analyticsSvc","moduleLoader","cas","AwPromiseService","AwStateService","splmStatsService","_debug_logAuthActivity","getUrlAttributes","logAuthActivity","undefined","_savedNavTarget","_targetAuthenticator","_suppressReload","exports","setAuthStatus","isAuth","getAuthStatus","getIsAuthenticated","isAuthenticationInProgress","setAuthenticationInProgress","inProg","pickAuthenticator","instance","resolve","name","getCfg","then","solution","authenticator","authenticators","info","loadDependentModule","dep","module","Error","getAuthenticator","callAuthSignOut","signOut","postSignOut","catch","error","terminateSession","sessionStorage","clear","setLocationToDefault","base","location","origin","pathname","search","getPostSignOutURL","locationReplace","url","replace","publish","subscribe","checkSessionValid","navigationTarget","removeItem","deferred","defer","checkIfSessionAuthenticated","allStagesAuthenticated","checkPostLoginAuthenticatedStages","runNavToState","status","runPostLoginBlocking","err","JSON","stringify","cause","window","getBaseURL","go","reject","promise","authenticationSuccessful","runPostAuthInit","resetPipeLine","resetPostLoginStages","postAuthInitialization","runOneStep","stepDefn","curIdx","fOK","fErr","active","stepPromise","routeName","length","stName","options","notify","myState","get","data","nextContinuation","workFunction","postLogInPiplinePromise","loadContributions","contributors","pipeLineSteps","sortPostLoginPipeline","fNext","compStepIdx","nextIdx","pipeLineStepToExecute","stepIndex","toState","toParams","reload","initLocalStorage","reset","initProfiler","initClickListener"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/sessionManager.service.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * The native session manager service. This is the coordination/orchestration component which manages the\n * authentication state and authentication processing for signIn and signOut session behavior. The chosen\n * Authenticator performs the actual mechanics of any authentication.\n *\n * This represents the session tracking and authentication detection.\n * @module js/sessionManager.service\n */\nimport cfgSvc from 'js/configurationService';\nimport contributionSvc from 'js/contribution.service';\nimport postLgnPipeLneSvc from 'js/postLoginPipeline.service';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport sessionState from 'js/sessionState';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport analyticsSvc from 'js/analyticsService';\nimport moduleLoader from 'js/moduleLoader';\nimport cas from 'js/centralAggregationService';\n\n// Service\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\n\n// revisitme: uncomment following imports once available\nimport splmStatsService from 'js/splmStatsService';\n// import analyticsSvc from 'js/analyticsService';\n\nvar _debug_logAuthActivity = browserUtils.getUrlAttributes().logAuthActivity !== undefined;\n\n// service and module references\n\n// members\nvar _savedNavTarget;\nvar _targetAuthenticator;\n\n// flag to suppress location reload during logoff; required for SSO support (ie11 + IIS)\nvar _suppressReload = false;\n\n// prop set/get functions\n\nvar exports = {};\n\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} isAuth - Whether or not session is currently authenticated.\n */\nexport let setAuthStatus = function( isAuth ) {\n    sessionState.setAuthStatus( isAuth );\n};\n\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is session currently authenticated\n */\nexport let getAuthStatus = function() {\n    return sessionState.getIsAuthenticated();\n};\n\n/**\n * property getter - defer to the state module.\n *\n * @return {Boolean} is authentication in progress\n */\nexport let isAuthenticationInProgress = function() {\n    return sessionState.isAuthenticationInProgress();\n};\n\n/**\n * property setter - defer to the state module.\n *\n * @param {Boolean} inProg - is authentication currently in progress.\n */\nexport let setAuthenticationInProgress = function( inProg ) {\n    sessionState.setAuthenticationInProgress( inProg );\n};\n\n/**\n * responsible for choosing the appropriate authenticator logic to be used. resolve the promise with the\n * appropriate authenticator. This needs more work to account for the various authenticators....\n *\n * how do we get the list of authenticators? logic to pick which one?\n *\n * @return {Promise} returns a promise to be resolved once the correct authenticator is chosen.\n */\nexport let pickAuthenticator = function() {\n    // determine how to \"contribute\" the different authenticators,\n    if( _targetAuthenticator ) {\n        // if an authenticator is already set, just use it.\n        return AwPromiseService.instance.resolve( _targetAuthenticator );\n    }\n\n    var name;\n\n    return cfgSvc.getCfg( 'solutionDef' ).then( function( solution ) {\n        name = solution.authenticator;\n        return cfgSvc.getCfg( 'authenticator' );\n    } ).then( function( authenticators ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: pickAuthenticator: ' + name );\n        }\n\n        return moduleLoader.loadDependentModule( authenticators[ name ].dep );\n    } ).then( function( module ) {\n        if( !module ) {\n            throw new Error( 'No authenticator provided!' );\n        }\n\n        return module.getAuthenticator();\n    } ).then( function( authenticator ) {\n        _targetAuthenticator = authenticator;\n\n        return _targetAuthenticator;\n    } );\n};\n\n// Sign out related functions/behavior\n\n/**\n * logic to invoke the authenticator signOut functionality.\n *\n * @return {Promise} promise\n */\nvar callAuthSignOut = function() {\n    if( _targetAuthenticator ) {\n        return _targetAuthenticator.signOut().then( function() {\n            exports.postSignOut();\n        } ).catch( function() {\n            // signOut error, but just continue the path\n            logger.error( 'SM: authenticator signOut() err' );\n            exports.postSignOut();\n        } );\n    }\n\n    logger.error( 'SM:ERROR - processing signOut, but no Authenticator is available' );\n};\n\n/**\n * method to begin the session termination flow. Starts the signOut process.\n *\n * @return {Promise} promise\n */\nexport let terminateSession = function() {\n    sessionStorage.clear(); // clearing the sessionStorage once session is terminated\n    return exports.pickAuthenticator().then( function() {\n        return callAuthSignOut();\n    } );\n};\n\n/**\n * Wrapper function around the window location reset method to allow for unit test execution.\n *\n * Having a distinct method allows test logic to mock out the actual call.\n */\nexport let setLocationToDefault = function() {\n    // need to reload the whole location, not just the $state() to refresh content.\n    // Force a refresh of the page to clear memory.\n    // This adds in security & memory leaks.\n    // should go back to the default or startup page.  Use the base URL\n    var base = location.origin + location.pathname + location.search;\n    if( _targetAuthenticator && _targetAuthenticator.getPostSignOutURL ) {\n        base = _targetAuthenticator.getPostSignOutURL();\n        _suppressReload = true;\n    }\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: setLocationToDefault - target URL: ' + base );\n    }\n\n    exports.locationReplace( base );\n};\n\n/**\n * To support unit test, we need a wrapper function which can be mocked to support Jasmine unit tests.\n *\n * @param {String} url - URL to set.\n */\nexport let locationReplace = function( url ) {\n    // eslint-disable-next-line no-debugger\n    debugger;\n\n    _suppressReload = true;\n    location.replace( url );\n};\n\n/**\n * This is the post authenticator signOut stage. At this point there is no longer a valid session. Update state\n * and trigger refresh navigation.\n */\nexport let postSignOut = function() {\n    exports.setAuthStatus( false );\n    exports.setAuthenticationInProgress( false );\n    localStrg.publish( 'signingOut', 'true' );\n    exports.setLocationToDefault();\n};\n\nlocalStrg.subscribe( 'signingOut', () => {\n    setLocationToDefault();\n} );\n\n/**\n * this resolves the in-doubt state of the session, calls detection soa to see if there is a valid session or\n * not. If there is, continue navigation to target and mark session as authenticated. If no active session,\n * start the authentication processing.\n *\n * NOTE - this runs DURING initialization as part of the first state change, and the angular is not yet\n * initialized.\n *\n * @param {Object} navigationTarget - structure with data for the ui-router request.\n * @return {Promise} promise\n */\nexport let checkSessionValid = function( navigationTarget ) {\n    _savedNavTarget = navigationTarget; // save for post auth.\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: checkSessionValid: ' + 'navigationTarget=' + navigationTarget );\n    }\n\n    localStrg.removeItem( 'signingOut' );\n\n    // 1) get the correct authenticator, then defer to the authenticator.\n    //    SSO & userPW will share some of the getSessionInfo3 path for updating session details.\n    // the pick authenticator will determine which of the authenticators to use.\n\n    // the way pickAuthenticator is called from route resolve, we have to pass it the promise\n    var deferred = AwPromiseService.instance.defer();\n\n    exports.pickAuthenticator().then( function( authenticator ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: authenticator chosen' );\n        }\n\n        authenticator.checkIfSessionAuthenticated().then( function() {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: auth check Good! already authenticated' );\n            }\n\n            exports.setAuthStatus( true );\n\n            var allStagesAuthenticated = postLgnPipeLneSvc.checkPostLoginAuthenticatedStages();\n\n            if( allStagesAuthenticated ) {\n                exports.runNavToState();\n                eventBus.publish( 'authentication.complete', { status: 'OK' } );\n            } else {\n                exports.runPostLoginBlocking().then( function() {\n                    exports.runNavToState();\n                    eventBus.publish( 'authentication.complete', { status: 'OK' } );\n                }, function() {\n                    if( _debug_logAuthActivity ) {\n                        logger.info( 'SM: end runPostLoginBlocking Stage - but ERROR' );\n                    }\n\n                    exports.runNavToState();\n                    eventBus.publish( 'authentication.complete', { status: 'OK' } );\n                } );\n            }\n\n            deferred.resolve();\n        } ).catch( function( err ) {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: auth check exception: ' + '\\n' + JSON.stringify( err, null, 2 ) + '\\n' + ' SM: Go to \"checkAuthentication\" state' );\n            }\n\n            if( err && err.cause && err.cause.status === 500 ) {\n                // \"Internal Server Error\" which typically means that this API isn't available on the server\n                logger.error( err );\n                window.location.replace( browserUtils.getBaseURL() + 'serverError.html' );\n            }\n\n            exports.setAuthenticationInProgress( true ); // indicator that in-process of authenticating\n\n            AwStateService.instance.go( 'checkAuthentication' );\n            eventBus.publish( 'authentication.complete', { status: 'Failed' } );\n\n            deferred.resolve();\n        } );\n    }, function( err ) {\n        logger.error( 'SM: Unable to pick an authenticator - serious configuration error!' );\n\n        eventBus.publish( 'authentication.complete', { status: 'Failed' } );\n        deferred.reject( err );\n    } );\n\n    return deferred.promise;\n};\n\n/**\n * Stage 2 of the authentication flow. Owned by the session manager.\n *\n * fires the session.signIn event\n *\n * used as the post authentication common flow. Mark the authentication state complete, continue with the login\n * flow/pipeline.\n *\n * @return {Promise} promise\n */\nexport let authenticationSuccessful = function() {\n    exports.setAuthStatus( true );\n    exports.setAuthenticationInProgress( false );\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: authSuccessful, fire \"session.signIn\" event' );\n    }\n\n    // Used to fire this event ONLY for User/PW SOA call, fire it here for ALL authenticators\n    // this is the point in the session state flow that the authentication is known to be OK.\n    eventBus.publish( 'session.signIn', {} );\n\n    // initial authentication is complete.  Let the authenticator do any initialization,\n    // then see if there is postLogin pipeline content to be executed...\n    return exports.runPostAuthInit().then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runPostAuthInit Stage complete - continue to next Auth step' );\n        }\n\n        return exports.runPostLoginBlocking();\n    } ).then( function() {\n        return exports.runNavToState();\n    } );\n};\n\n/**\n * Reset PipeLine while signing in\n */\nexport let resetPipeLine = function() {\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: resetPipeLine' );\n    }\n\n    postLgnPipeLneSvc.resetPostLoginStages();\n};\n\n/**\n * next stage of the authentication path. This is a spot for the authenticator to run any specific logic. At\n * this point we've successfully authenticated and any specific initialization can be done.\n *\n * @return {Promise} a promise which is resolved when the authenticator initialization is complete.\n */\nexport let runPostAuthInit = function() {\n    return exports.pickAuthenticator().then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runPostAuthInit' );\n        }\n\n        analyticsSvc.authenticationSuccessful();\n\n        return _targetAuthenticator ? _targetAuthenticator.postAuthInitialization() : AwPromiseService.instance.resolve();\n    } );\n};\n\n/**\n * This function is responsible for invoking a single pipeline step definition.\n *\n * A step definition can either identify a route to run OR provide a work function. If the \"routeName\" is\n * provided, that takes precedence and that route will be called.\n *\n * The continuation promise is passed along to the route as part of the custom data structure with a member name\n * of \"nextContinuation\". for the work function, the promise is passed as a function argument.\n *\n * In either case, the route OR the work function MUST either resolve or reject the promise. Resolve path\n * continues pipeline execution, reject will immediately exit the pipeline and not invoke any of the remaining\n * tasks.\n *\n * @param {Object} stepDefn - a step definition for running a single contributed \"step\"\n * @param {Object} curIdx - index of the current step definition in the list\n * @param {Function} fOK - success function to invoke\n * @param {Function} fErr - error function to invoke\n */\nvar runOneStep = function( stepDefn, curIdx, fOK, fErr ) {\n    // TODO - assert the inputs, non-null stepDefn, fOk & fErr are functions.\n\n    if( _debug_logAuthActivity ) {\n        logger.info( 'SM: running on steps for idx: ' + curIdx + ' name: ' + stepDefn.name );\n    }\n\n    // if not active, skip it altogether\n    if( !stepDefn.active ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: not active, skipping step: ' + stepDefn.name );\n        }\n\n        fOK( curIdx );\n    }\n\n    // the stepPromise represents the continuation for the pipeline step.\n    var stepPromise = AwPromiseService.instance.defer();\n\n    stepPromise.promise.then( function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: done with pipeline Step continue. ' + stepDefn.name );\n        }\n\n        fOK( curIdx );\n    }, function() {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: done with pipeline Step - REJECT ' + stepDefn.name );\n        }\n\n        fErr( curIdx );\n    } );\n\n    // branch to either routeName for a route, or call the workFunction\n    if( stepDefn.routeName && stepDefn.routeName.length > 0 ) {\n        // invoke the route\n        var stName = stepDefn.routeName;\n\n        var options = {\n            notify: true, // notify must be true..\n            location: false\n        };\n\n        var myState = AwStateService.instance.get( stName );\n\n        // pass the continuation promise as custom data.\n        if( myState ) {\n            if( myState.data ) {\n                myState.data.nextContinuation = stepPromise;\n            } else {\n                myState.data = {\n                    nextContinuation: stepPromise\n                };\n            }\n        }\n\n        AwStateService.instance.go( stName, {}, options );\n    } else {\n        // call the work function\n        if( stepDefn.workFunction ) {\n            stepDefn.workFunction( stepDefn, stepPromise );\n        } else {\n            if( _debug_logAuthActivity ) {\n                logger.info( 'SM: No work function, assume fOK path' );\n            }\n\n            fOK( curIdx );\n        }\n    }\n};\n\n/**\n * This is the pipeline execution stage - the session manager blocks on any post logic processes. This is a\n * configuration point to execute any contributed post authentication logic.\n *\n * The \"postLoginPipeline\" named contributions are used to obtain pipeline \"step\" definitions which identify the\n * logic or route to be run.\n *\n * @return {Promise} promise\n */\nexport let runPostLoginBlocking = function() {\n    var postLogInPiplinePromise = AwPromiseService.instance.defer();\n\n    // 1) get the list of contributors (0..n)\n    // 2) get the stepDefinitions from each\n    // 3) sort the stepDefinitions by priority value\n    // 4) invoke each in order.  If one rejects then break the chain. ??? or NOT\n    // 5) when all have run, then continue with the next stage step.\n\n    contributionSvc.loadContributions( 'postLoginPipeline' ).then( function( contributors ) {\n        if( contributors && contributors.length > 0 ) {\n            var pipeLineSteps = postLgnPipeLneSvc.sortPostLoginPipeline( contributors );\n\n            // iterate and call each step,\n            // upon last one, continue the postLogInPiplinePromise\n            if( pipeLineSteps && pipeLineSteps.length > 0 ) {\n                var fNext = null;\n                var fErr = null;\n\n                fNext = function( compStepIdx ) {\n                    pipeLineSteps[ compStepIdx ].status = true;\n\n                    localStrg.publish( 'postLoginStagesKey', JSON.stringify( pipeLineSteps ) );\n\n                    var nextIdx = compStepIdx + 1;\n\n                    if( nextIdx >= pipeLineSteps.length ) {\n                        // done with the last one,\n                        if( _debug_logAuthActivity ) {\n                            logger.info( 'SM: done with last step, continue post promise' );\n                        }\n\n                        postLogInPiplinePromise.resolve();\n                    } else {\n                        // run next one\n                        runOneStep( pipeLineSteps[ nextIdx ], nextIdx, fNext, fErr );\n                    }\n                };\n\n                fErr = function( compStepIdx ) {\n                    // step failure, do we fail the pipeline, or continue with the other steps?\n                    // could log the issue and fall into the fNext() ...\n                    pipeLineSteps[ compStepIdx ].status = false;\n\n                    localStrg.publish( 'postLoginStagesKey', JSON.stringify( pipeLineSteps ) );\n\n                    if( _debug_logAuthActivity ) {\n                        logger.info( 'SM: one of the steps had an error: ' + compStepIdx );\n                    }\n\n                    postLogInPiplinePromise.reject();\n                };\n\n                var pipeLineStepToExecute = null;\n                var stepIndex = 0;\n\n                for( ; stepIndex < pipeLineSteps.length; stepIndex++ ) {\n                    // find the step that has status false\n                    if( !pipeLineSteps[ stepIndex ].status ) {\n                        pipeLineStepToExecute = pipeLineSteps[ stepIndex ];\n                        break;\n                    }\n                }\n\n                // start running the steps if step to execute is not null\n                if( pipeLineStepToExecute ) {\n                    runOneStep( pipeLineStepToExecute, stepIndex, fNext, fErr );\n                } else {\n                    // this means all steps have been successfully executed. resolve the promise\n                    postLogInPiplinePromise.resolve();\n                }\n            } else {\n                // no pipeLine steps, continue on.\n                postLogInPiplinePromise.resolve();\n            }\n        } else {\n            // no contributors\n            postLogInPiplinePromise.resolve();\n        }\n    }, function() {\n        // some reject on the contribution service - continue on.\n        logger.error( 'SM: contribution service error for postLoginPipeline' );\n\n        postLogInPiplinePromise.resolve();\n    } );\n\n    // the full pipeline promise - when all step definition handlers have completed.\n    return postLogInPiplinePromise.promise;\n};\n\n/**\n * This is the final authentication stage. At this point all handlers have run, the authenticator has done it's\n * initialization, we can now navigate to the desired target state.\n */\nexport let runNavToState = function() {\n    if( _savedNavTarget ) {\n        if( _debug_logAuthActivity ) {\n            logger.info( 'SM: runNavToState Stage - redirect to original target: ' + _savedNavTarget.toState );\n        }\n\n        AwStateService.instance.go( _savedNavTarget.toState, _savedNavTarget.toParams, _savedNavTarget.options );\n    } else {\n        logger.error( 'SM: post auth, runNavToState - NO saved Nav Target!!' );\n        // what to do in this situation?  what is the \"default\" state?\n    }\n};\n\n/**\n * location reload\n */\nfunction reload() {\n    if( !_suppressReload ) {\n        location.reload( false );\n    }\n}\n\n/**\n * init set up for localStorage\n */\nexport let initLocalStorage = function() {\n    /**\n     * Setup to listed to changes in any associated browser's session state.\n     */\n    localStrg.subscribe( 'awSession', reload );\n};\n\nexport let reset = function() {\n    _targetAuthenticator = null;\n};\n\n// No dependency on appCtxService, but need the service initialized for event registration\n\n/**\n * Since this module can be loaded GWT-side by the ModuleLoader class we need to return an object indicating\n * which service should be injected to provide the API for this module.\n */\nexports = {\n    setAuthStatus,\n    getAuthStatus,\n    isAuthenticationInProgress,\n    setAuthenticationInProgress,\n    pickAuthenticator,\n    terminateSession,\n    setLocationToDefault,\n    locationReplace,\n    postSignOut,\n    checkSessionValid,\n    authenticationSuccessful,\n    resetPipeLine,\n    runPostAuthInit,\n    runPostLoginBlocking,\n    runNavToState,\n    initLocalStorage,\n    reset\n};\nexport default exports;\n\ninitLocalStorage();\n\n// setup analytics profiler.\nsplmStatsService.initProfiler();\n// setup global click listener.\ncas.initClickListener();\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAP,MAAmB,yBAAnB;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,GAAP,MAAgB,8BAAhB,C,CAEA;;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AACA,OAAOC,cAAP,MAA2B,mBAA3B,C,CAEA;;AACA,OAAOC,gBAAP,MAA6B,qBAA7B,C,CACA;;AAEA,IAAIC,sBAAsB,GAAGV,YAAY,CAACW,gBAAb,GAAgCC,eAAhC,KAAoDC,SAAjF,C,CAEA;AAEA;;;AACA,IAAIC,eAAJ;;AACA,IAAIC,oBAAJ,C,CAEA;;;AACA,IAAIC,eAAe,GAAG,KAAtB,C,CAEA;;AAEA,IAAIC,OAAO,GAAG,EAAd;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,aAAa,GAAG,UAAUC,MAAV,EAAmB;EAC1ClB,YAAY,CAACiB,aAAb,CAA4BC,MAA5B;AACH,CAFM;AAIP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,aAAa,GAAG,YAAW;EAClC,OAAOnB,YAAY,CAACoB,kBAAb,EAAP;AACH,CAFM;AAIP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,0BAA0B,GAAG,YAAW;EAC/C,OAAOrB,YAAY,CAACqB,0BAAb,EAAP;AACH,CAFM;AAIP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,2BAA2B,GAAG,UAAUC,MAAV,EAAmB;EACxDvB,YAAY,CAACsB,2BAAb,CAA0CC,MAA1C;AACH,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,iBAAiB,GAAG,YAAW;EACtC;EACA,IAAIV,oBAAJ,EAA2B;IACvB;IACA,OAAOR,gBAAgB,CAACmB,QAAjB,CAA0BC,OAA1B,CAAmCZ,oBAAnC,CAAP;EACH;;EAED,IAAIa,IAAJ;EAEA,OAAOhC,MAAM,CAACiC,MAAP,CAAe,aAAf,EAA+BC,IAA/B,CAAqC,UAAUC,QAAV,EAAqB;IAC7DH,IAAI,GAAGG,QAAQ,CAACC,aAAhB;IACA,OAAOpC,MAAM,CAACiC,MAAP,CAAe,eAAf,CAAP;EACH,CAHM,EAGHC,IAHG,CAGG,UAAUG,cAAV,EAA2B;IACjC,IAAIvB,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,4BAA4BN,IAAzC;IACH;;IAED,OAAOvB,YAAY,CAAC8B,mBAAb,CAAkCF,cAAc,CAAEL,IAAF,CAAd,CAAuBQ,GAAzD,CAAP;EACH,CATM,EASHN,IATG,CASG,UAAUO,MAAV,EAAmB;IACzB,IAAI,CAACA,MAAL,EAAc;MACV,MAAM,IAAIC,KAAJ,CAAW,4BAAX,CAAN;IACH;;IAED,OAAOD,MAAM,CAACE,gBAAP,EAAP;EACH,CAfM,EAeHT,IAfG,CAeG,UAAUE,aAAV,EAA0B;IAChCjB,oBAAoB,GAAGiB,aAAvB;IAEA,OAAOjB,oBAAP;EACH,CAnBM,CAAP;AAoBH,CA7BM,C,CA+BP;;AAEA;AACA;AACA;AACA;AACA;;AACA,IAAIyB,eAAe,GAAG,YAAW;EAC7B,IAAIzB,oBAAJ,EAA2B;IACvB,OAAOA,oBAAoB,CAAC0B,OAArB,GAA+BX,IAA/B,CAAqC,YAAW;MACnDb,OAAO,CAACyB,WAAR;IACH,CAFM,EAEHC,KAFG,CAEI,YAAW;MAClB;MACAxC,MAAM,CAACyC,KAAP,CAAc,iCAAd;MACA3B,OAAO,CAACyB,WAAR;IACH,CANM,CAAP;EAOH;;EAEDvC,MAAM,CAACyC,KAAP,CAAc,kEAAd;AACH,CAZD;AAcA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIC,gBAAgB,GAAG,YAAW;EACrCC,cAAc,CAACC,KAAf,GADqC,CACb;;EACxB,OAAO9B,OAAO,CAACQ,iBAAR,GAA4BK,IAA5B,CAAkC,YAAW;IAChD,OAAOU,eAAe,EAAtB;EACH,CAFM,CAAP;AAGH,CALM;AAOP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIQ,oBAAoB,GAAG,YAAW;EACzC;EACA;EACA;EACA;EACA,IAAIC,IAAI,GAAGC,QAAQ,CAACC,MAAT,GAAkBD,QAAQ,CAACE,QAA3B,GAAsCF,QAAQ,CAACG,MAA1D;;EACA,IAAItC,oBAAoB,IAAIA,oBAAoB,CAACuC,iBAAjD,EAAqE;IACjEL,IAAI,GAAGlC,oBAAoB,CAACuC,iBAArB,EAAP;IACAtC,eAAe,GAAG,IAAlB;EACH;;EAED,IAAIN,sBAAJ,EAA6B;IACzBP,MAAM,CAAC+B,IAAP,CAAa,4CAA4Ce,IAAzD;EACH;;EAEDhC,OAAO,CAACsC,eAAR,CAAyBN,IAAzB;AACH,CAhBM;AAkBP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIM,eAAe,GAAG,UAAUC,GAAV,EAAgB;EACzC;EACA;EAEAxC,eAAe,GAAG,IAAlB;EACAkC,QAAQ,CAACO,OAAT,CAAkBD,GAAlB;AACH,CANM;AAQP;AACA;AACA;AACA;;AACA,OAAO,IAAId,WAAW,GAAG,YAAW;EAChCzB,OAAO,CAACC,aAAR,CAAuB,KAAvB;EACAD,OAAO,CAACM,2BAAR,CAAqC,KAArC;EACArB,SAAS,CAACwD,OAAV,CAAmB,YAAnB,EAAiC,MAAjC;EACAzC,OAAO,CAAC+B,oBAAR;AACH,CALM;AAOP9C,SAAS,CAACyD,SAAV,CAAqB,YAArB,EAAmC,MAAM;EACrCX,oBAAoB;AACvB,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIY,iBAAiB,GAAG,UAAUC,gBAAV,EAA6B;EACxD/C,eAAe,GAAG+C,gBAAlB,CADwD,CACpB;;EAEpC,IAAInD,sBAAJ,EAA6B;IACzBP,MAAM,CAAC+B,IAAP,CAAa,4BAA4B,mBAA5B,GAAkD2B,gBAA/D;EACH;;EAED3D,SAAS,CAAC4D,UAAV,CAAsB,YAAtB,EAPwD,CASxD;EACA;EACA;EAEA;;EACA,IAAIC,QAAQ,GAAGxD,gBAAgB,CAACmB,QAAjB,CAA0BsC,KAA1B,EAAf;EAEA/C,OAAO,CAACQ,iBAAR,GAA4BK,IAA5B,CAAkC,UAAUE,aAAV,EAA0B;IACxD,IAAItB,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,0BAAb;IACH;;IAEDF,aAAa,CAACiC,2BAAd,GAA4CnC,IAA5C,CAAkD,YAAW;MACzD,IAAIpB,sBAAJ,EAA6B;QACzBP,MAAM,CAAC+B,IAAP,CAAa,4CAAb;MACH;;MAEDjB,OAAO,CAACC,aAAR,CAAuB,IAAvB;MAEA,IAAIgD,sBAAsB,GAAGpE,iBAAiB,CAACqE,iCAAlB,EAA7B;;MAEA,IAAID,sBAAJ,EAA6B;QACzBjD,OAAO,CAACmD,aAAR;QACArE,QAAQ,CAAC2D,OAAT,CAAkB,yBAAlB,EAA6C;UAAEW,MAAM,EAAE;QAAV,CAA7C;MACH,CAHD,MAGO;QACHpD,OAAO,CAACqD,oBAAR,GAA+BxC,IAA/B,CAAqC,YAAW;UAC5Cb,OAAO,CAACmD,aAAR;UACArE,QAAQ,CAAC2D,OAAT,CAAkB,yBAAlB,EAA6C;YAAEW,MAAM,EAAE;UAAV,CAA7C;QACH,CAHD,EAGG,YAAW;UACV,IAAI3D,sBAAJ,EAA6B;YACzBP,MAAM,CAAC+B,IAAP,CAAa,gDAAb;UACH;;UAEDjB,OAAO,CAACmD,aAAR;UACArE,QAAQ,CAAC2D,OAAT,CAAkB,yBAAlB,EAA6C;YAAEW,MAAM,EAAE;UAAV,CAA7C;QACH,CAVD;MAWH;;MAEDN,QAAQ,CAACpC,OAAT;IACH,CA3BD,EA2BIgB,KA3BJ,CA2BW,UAAU4B,GAAV,EAAgB;MACvB,IAAI7D,sBAAJ,EAA6B;QACzBP,MAAM,CAAC+B,IAAP,CAAa,+BAA+B,IAA/B,GAAsCsC,IAAI,CAACC,SAAL,CAAgBF,GAAhB,EAAqB,IAArB,EAA2B,CAA3B,CAAtC,GAAuE,IAAvE,GAA8E,wCAA3F;MACH;;MAED,IAAIA,GAAG,IAAIA,GAAG,CAACG,KAAX,IAAoBH,GAAG,CAACG,KAAJ,CAAUL,MAAV,KAAqB,GAA7C,EAAmD;QAC/C;QACAlE,MAAM,CAACyC,KAAP,CAAc2B,GAAd;QACAI,MAAM,CAACzB,QAAP,CAAgBO,OAAhB,CAAyBzD,YAAY,CAAC4E,UAAb,KAA4B,kBAArD;MACH;;MAED3D,OAAO,CAACM,2BAAR,CAAqC,IAArC,EAXuB,CAWsB;;MAE7Cf,cAAc,CAACkB,QAAf,CAAwBmD,EAAxB,CAA4B,qBAA5B;MACA9E,QAAQ,CAAC2D,OAAT,CAAkB,yBAAlB,EAA6C;QAAEW,MAAM,EAAE;MAAV,CAA7C;MAEAN,QAAQ,CAACpC,OAAT;IACH,CA5CD;EA6CH,CAlDD,EAkDG,UAAU4C,GAAV,EAAgB;IACfpE,MAAM,CAACyC,KAAP,CAAc,oEAAd;IAEA7C,QAAQ,CAAC2D,OAAT,CAAkB,yBAAlB,EAA6C;MAAEW,MAAM,EAAE;IAAV,CAA7C;IACAN,QAAQ,CAACe,MAAT,CAAiBP,GAAjB;EACH,CAvDD;EAyDA,OAAOR,QAAQ,CAACgB,OAAhB;AACH,CA1EM;AA4EP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,wBAAwB,GAAG,YAAW;EAC7C/D,OAAO,CAACC,aAAR,CAAuB,IAAvB;EACAD,OAAO,CAACM,2BAAR,CAAqC,KAArC;;EAEA,IAAIb,sBAAJ,EAA6B;IACzBP,MAAM,CAAC+B,IAAP,CAAa,iDAAb;EACH,CAN4C,CAQ7C;EACA;;;EACAnC,QAAQ,CAAC2D,OAAT,CAAkB,gBAAlB,EAAoC,EAApC,EAV6C,CAY7C;EACA;;EACA,OAAOzC,OAAO,CAACgE,eAAR,GAA0BnD,IAA1B,CAAgC,YAAW;IAC9C,IAAIpB,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,iEAAb;IACH;;IAED,OAAOjB,OAAO,CAACqD,oBAAR,EAAP;EACH,CANM,EAMHxC,IANG,CAMG,YAAW;IACjB,OAAOb,OAAO,CAACmD,aAAR,EAAP;EACH,CARM,CAAP;AASH,CAvBM;AAyBP;AACA;AACA;;AACA,OAAO,IAAIc,aAAa,GAAG,YAAW;EAClC,IAAIxE,sBAAJ,EAA6B;IACzBP,MAAM,CAAC+B,IAAP,CAAa,mBAAb;EACH;;EAEDpC,iBAAiB,CAACqF,oBAAlB;AACH,CANM;AAQP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIF,eAAe,GAAG,YAAW;EACpC,OAAOhE,OAAO,CAACQ,iBAAR,GAA4BK,IAA5B,CAAkC,YAAW;IAChD,IAAIpB,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,qBAAb;IACH;;IAED9B,YAAY,CAAC4E,wBAAb;IAEA,OAAOjE,oBAAoB,GAAGA,oBAAoB,CAACqE,sBAArB,EAAH,GAAmD7E,gBAAgB,CAACmB,QAAjB,CAA0BC,OAA1B,EAA9E;EACH,CARM,CAAP;AASH,CAVM;AAYP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAI0D,UAAU,GAAG,UAAUC,QAAV,EAAoBC,MAApB,EAA4BC,GAA5B,EAAiCC,IAAjC,EAAwC;EACrD;EAEA,IAAI/E,sBAAJ,EAA6B;IACzBP,MAAM,CAAC+B,IAAP,CAAa,mCAAmCqD,MAAnC,GAA4C,SAA5C,GAAwDD,QAAQ,CAAC1D,IAA9E;EACH,CALoD,CAOrD;;;EACA,IAAI,CAAC0D,QAAQ,CAACI,MAAd,EAAuB;IACnB,IAAIhF,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,oCAAoCoD,QAAQ,CAAC1D,IAA1D;IACH;;IAED4D,GAAG,CAAED,MAAF,CAAH;EACH,CAdoD,CAgBrD;;;EACA,IAAII,WAAW,GAAGpF,gBAAgB,CAACmB,QAAjB,CAA0BsC,KAA1B,EAAlB;EAEA2B,WAAW,CAACZ,OAAZ,CAAoBjD,IAApB,CAA0B,YAAW;IACjC,IAAIpB,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,2CAA2CoD,QAAQ,CAAC1D,IAAjE;IACH;;IAED4D,GAAG,CAAED,MAAF,CAAH;EACH,CAND,EAMG,YAAW;IACV,IAAI7E,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,0CAA0CoD,QAAQ,CAAC1D,IAAhE;IACH;;IAED6D,IAAI,CAAEF,MAAF,CAAJ;EACH,CAZD,EAnBqD,CAiCrD;;EACA,IAAID,QAAQ,CAACM,SAAT,IAAsBN,QAAQ,CAACM,SAAT,CAAmBC,MAAnB,GAA4B,CAAtD,EAA0D;IACtD;IACA,IAAIC,MAAM,GAAGR,QAAQ,CAACM,SAAtB;IAEA,IAAIG,OAAO,GAAG;MACVC,MAAM,EAAE,IADE;MACI;MACd9C,QAAQ,EAAE;IAFA,CAAd;IAKA,IAAI+C,OAAO,GAAGzF,cAAc,CAACkB,QAAf,CAAwBwE,GAAxB,CAA6BJ,MAA7B,CAAd,CATsD,CAWtD;;IACA,IAAIG,OAAJ,EAAc;MACV,IAAIA,OAAO,CAACE,IAAZ,EAAmB;QACfF,OAAO,CAACE,IAAR,CAAaC,gBAAb,GAAgCT,WAAhC;MACH,CAFD,MAEO;QACHM,OAAO,CAACE,IAAR,GAAe;UACXC,gBAAgB,EAAET;QADP,CAAf;MAGH;IACJ;;IAEDnF,cAAc,CAACkB,QAAf,CAAwBmD,EAAxB,CAA4BiB,MAA5B,EAAoC,EAApC,EAAwCC,OAAxC;EACH,CAvBD,MAuBO;IACH;IACA,IAAIT,QAAQ,CAACe,YAAb,EAA4B;MACxBf,QAAQ,CAACe,YAAT,CAAuBf,QAAvB,EAAiCK,WAAjC;IACH,CAFD,MAEO;MACH,IAAIjF,sBAAJ,EAA6B;QACzBP,MAAM,CAAC+B,IAAP,CAAa,uCAAb;MACH;;MAEDsD,GAAG,CAAED,MAAF,CAAH;IACH;EACJ;AACJ,CArED;AAuEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIjB,oBAAoB,GAAG,YAAW;EACzC,IAAIgC,uBAAuB,GAAG/F,gBAAgB,CAACmB,QAAjB,CAA0BsC,KAA1B,EAA9B,CADyC,CAGzC;EACA;EACA;EACA;EACA;;EAEAnE,eAAe,CAAC0G,iBAAhB,CAAmC,mBAAnC,EAAyDzE,IAAzD,CAA+D,UAAU0E,YAAV,EAAyB;IACpF,IAAIA,YAAY,IAAIA,YAAY,CAACX,MAAb,GAAsB,CAA1C,EAA8C;MAC1C,IAAIY,aAAa,GAAG3G,iBAAiB,CAAC4G,qBAAlB,CAAyCF,YAAzC,CAApB,CAD0C,CAG1C;MACA;;MACA,IAAIC,aAAa,IAAIA,aAAa,CAACZ,MAAd,GAAuB,CAA5C,EAAgD;QAC5C,IAAIc,KAAK,GAAG,IAAZ;QACA,IAAIlB,IAAI,GAAG,IAAX;;QAEAkB,KAAK,GAAG,UAAUC,WAAV,EAAwB;UAC5BH,aAAa,CAAEG,WAAF,CAAb,CAA6BvC,MAA7B,GAAsC,IAAtC;UAEAnE,SAAS,CAACwD,OAAV,CAAmB,oBAAnB,EAAyCc,IAAI,CAACC,SAAL,CAAgBgC,aAAhB,CAAzC;UAEA,IAAII,OAAO,GAAGD,WAAW,GAAG,CAA5B;;UAEA,IAAIC,OAAO,IAAIJ,aAAa,CAACZ,MAA7B,EAAsC;YAClC;YACA,IAAInF,sBAAJ,EAA6B;cACzBP,MAAM,CAAC+B,IAAP,CAAa,gDAAb;YACH;;YAEDoE,uBAAuB,CAAC3E,OAAxB;UACH,CAPD,MAOO;YACH;YACA0D,UAAU,CAAEoB,aAAa,CAAEI,OAAF,CAAf,EAA4BA,OAA5B,EAAqCF,KAArC,EAA4ClB,IAA5C,CAAV;UACH;QACJ,CAlBD;;QAoBAA,IAAI,GAAG,UAAUmB,WAAV,EAAwB;UAC3B;UACA;UACAH,aAAa,CAAEG,WAAF,CAAb,CAA6BvC,MAA7B,GAAsC,KAAtC;UAEAnE,SAAS,CAACwD,OAAV,CAAmB,oBAAnB,EAAyCc,IAAI,CAACC,SAAL,CAAgBgC,aAAhB,CAAzC;;UAEA,IAAI/F,sBAAJ,EAA6B;YACzBP,MAAM,CAAC+B,IAAP,CAAa,wCAAwC0E,WAArD;UACH;;UAEDN,uBAAuB,CAACxB,MAAxB;QACH,CAZD;;QAcA,IAAIgC,qBAAqB,GAAG,IAA5B;QACA,IAAIC,SAAS,GAAG,CAAhB;;QAEA,OAAOA,SAAS,GAAGN,aAAa,CAACZ,MAAjC,EAAyCkB,SAAS,EAAlD,EAAuD;UACnD;UACA,IAAI,CAACN,aAAa,CAAEM,SAAF,CAAb,CAA2B1C,MAAhC,EAAyC;YACrCyC,qBAAqB,GAAGL,aAAa,CAAEM,SAAF,CAArC;YACA;UACH;QACJ,CA/C2C,CAiD5C;;;QACA,IAAID,qBAAJ,EAA4B;UACxBzB,UAAU,CAAEyB,qBAAF,EAAyBC,SAAzB,EAAoCJ,KAApC,EAA2ClB,IAA3C,CAAV;QACH,CAFD,MAEO;UACH;UACAa,uBAAuB,CAAC3E,OAAxB;QACH;MACJ,CAxDD,MAwDO;QACH;QACA2E,uBAAuB,CAAC3E,OAAxB;MACH;IACJ,CAjED,MAiEO;MACH;MACA2E,uBAAuB,CAAC3E,OAAxB;IACH;EACJ,CAtED,EAsEG,YAAW;IACV;IACAxB,MAAM,CAACyC,KAAP,CAAc,sDAAd;IAEA0D,uBAAuB,CAAC3E,OAAxB;EACH,CA3ED,EATyC,CAsFzC;;EACA,OAAO2E,uBAAuB,CAACvB,OAA/B;AACH,CAxFM;AA0FP;AACA;AACA;AACA;;AACA,OAAO,IAAIX,aAAa,GAAG,YAAW;EAClC,IAAItD,eAAJ,EAAsB;IAClB,IAAIJ,sBAAJ,EAA6B;MACzBP,MAAM,CAAC+B,IAAP,CAAa,4DAA4DpB,eAAe,CAACkG,OAAzF;IACH;;IAEDxG,cAAc,CAACkB,QAAf,CAAwBmD,EAAxB,CAA4B/D,eAAe,CAACkG,OAA5C,EAAqDlG,eAAe,CAACmG,QAArE,EAA+EnG,eAAe,CAACiF,OAA/F;EACH,CAND,MAMO;IACH5F,MAAM,CAACyC,KAAP,CAAc,sDAAd,EADG,CAEH;EACH;AACJ,CAXM;AAaP;AACA;AACA;;AACA,SAASsE,MAAT,GAAkB;EACd,IAAI,CAAClG,eAAL,EAAuB;IACnBkC,QAAQ,CAACgE,MAAT,CAAiB,KAAjB;EACH;AACJ;AAED;AACA;AACA;;;AACA,OAAO,IAAIC,gBAAgB,GAAG,YAAW;EACrC;AACJ;AACA;EACIjH,SAAS,CAACyD,SAAV,CAAqB,WAArB,EAAkCuD,MAAlC;AACH,CALM;AAOP,OAAO,IAAIE,KAAK,GAAG,YAAW;EAC1BrG,oBAAoB,GAAG,IAAvB;AACH,CAFM,C,CAIP;;AAEA;AACA;AACA;AACA;;AACAE,OAAO,GAAG;EACNC,aADM;EAENE,aAFM;EAGNE,0BAHM;EAINC,2BAJM;EAKNE,iBALM;EAMNoB,gBANM;EAONG,oBAPM;EAQNO,eARM;EASNb,WATM;EAUNkB,iBAVM;EAWNoB,wBAXM;EAYNE,aAZM;EAaND,eAbM;EAcNX,oBAdM;EAeNF,aAfM;EAgBN+C,gBAhBM;EAiBNC;AAjBM,CAAV;AAmBA,eAAenG,OAAf;AAEAkG,gBAAgB,G,CAEhB;;AACA1G,gBAAgB,CAAC4G,YAAjB,G,CACA;;AACA/G,GAAG,CAACgH,iBAAJ"},"metadata":{},"sourceType":"module"}