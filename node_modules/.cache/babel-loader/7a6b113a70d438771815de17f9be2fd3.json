{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is for exposing the native js data provider behavior. The module supports loading the module from GWT\n * and getting the native JS code invoked.\n *\n * @module js/splmTableInfiniteScrollService\n */\nimport logger from 'js/logger';\nimport browserUtils from 'js/browserUtils';\nimport SPLMTableMomentumScrolling from 'js/splmTableMomentumScrolling';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\n/**\n * Native infinite scroll.\n *\n * @constructor\n * @param {Number} containerHeight the container height\n */\n\nlet SPLMTableInfiniteScroll = function (containerHeight) {\n  let self = this;\n  let settings = {};\n  let currentScrollTop = 0; // Holds the last scroll position to detect scroll down or up\n\n  let previousScrollTop = 0;\n  let rowElements = []; // contains cache of rendered list\n\n  let rowHeightCache = [];\n  let initialized = false;\n  let containerHeightInitialized = false;\n  let _containerHeight = containerHeight;\n\n  let _visibleAreaHeight = _containerHeight - settings.headerHeight;\n\n  let initialRowIndex = 0;\n  let extraVisibleRowCount = 14; // keep it even for easier scrolling/calculations\n\n  let visibleRowsCount = 0;\n  let currentScrollLeft = 0;\n  let scrollToRowInProgress = false;\n  let scrollToRowScrollTop = null;\n  let maintainScrollPosition = false;\n  let disablePinScrollEvent = false;\n  let userPinScrollsDetected = 0;\n  let scrollContainerWidth = 0;\n  let verticalScrollDebounceTime = browserUtils.isIE || browserUtils.isFirefox ? 200 : 0;\n  let horizontalScrollDebounceTime = browserUtils.isIE ? 500 : 0;\n  let verticalScrollDebounceMaxWait = browserUtils.isIE || browserUtils.isFirefox ? Infinity : 0;\n  let momentumScrolling = new SPLMTableMomentumScrolling();\n  let lastScrollTimeStamp = new Date();\n  let elapsedMSSinceLastScroll = 0; // LCS-133249 Scrolling performance issue\n  // Do scroll syncing at very beginning\n\n  let extraTop = 0;\n\n  let horizontalScrollDebounceEvent = _.debounce(function () {\n    if (settings.scrollViewportElem && settings.scrollViewportElem.offsetWidth) {\n      scrollContainerWidth = settings.scrollViewportElem.offsetWidth;\n    }\n\n    settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n    settings.updateVisibleCells(settings.scrollParentElem);\n  }, horizontalScrollDebounceTime);\n\n  let verticalScrollDebounceEvent = _.debounce(function () {\n    handleScrollEventInternal();\n  }, verticalScrollDebounceTime, {\n    maxWait: verticalScrollDebounceMaxWait\n  });\n\n  self.initializeGrid = function (obj) {\n    settings = obj;\n    settings.pinParentElem = settings.pinViewportElem.children[0];\n    settings.scrollParentElem = settings.scrollViewportElem.children[0];\n    settings.totalFound = settings.loadedVMObjects.length;\n    settings.dynamicRowHeightStatus = settings.dynamicRowHeightStatus || false;\n    initializeEvents();\n    momentumScrolling.enable(settings.pinViewportElem, settings.scrollViewportElem);\n    initialized = true;\n  };\n  /**\n   * Calculates the visible area of the table\n   * @returns {Number} the visible height\n   */\n\n\n  let calculateVisibleAreaHeight = function () {\n    return _containerHeight - settings.headerHeight;\n  };\n\n  self.checkForResize = _.debounce(async function () {\n    elapsedMSSinceLastScroll = new Date() - lastScrollTimeStamp;\n\n    if (elapsedMSSinceLastScroll < 200) {\n      return;\n    }\n\n    let newClientWidth = settings.scrollViewportElem.offsetWidth;\n\n    if (newClientWidth !== scrollContainerWidth) {\n      if (newClientWidth > scrollContainerWidth) {\n        scrollContainerWidth = newClientWidth;\n        settings.updateScrollColumnsInView(currentScrollLeft);\n      } else {\n        scrollContainerWidth = newClientWidth;\n        settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n      }\n\n      settings.updateVisibleCells(settings.scrollParentElem);\n      self.handlePinViewportScrollbarPadding();\n    }\n\n    if (settings.directiveElem.clientHeight !== _containerHeight) {\n      _containerHeight = settings.directiveElem.clientHeight;\n      let rowContainerHeight = settings.scrollViewportElem.clientHeight || settings.pinViewportElem.clientHeight || _containerHeight;\n      let rowCount = Math.floor(rowContainerHeight / settings.rowHeight);\n      _visibleAreaHeight = calculateVisibleAreaHeight();\n      setVisibleRowsCount(rowCount);\n      await self.handleScroll();\n    }\n  }, 200);\n\n  self.isInitialized = function () {\n    return initialized;\n  };\n  /**\n   * Renders the initial rows on initialization once table div has been rendered so that\n   * the height can be computed properly\n   */\n\n\n  self.renderInitialRows = function () {\n    self.initializeProperties();\n    settings.initialRowIndex = initialRowIndex;\n    self.handleScroll();\n  };\n\n  self.getFirstRenderedItemIndex = function () {\n    var firstRenderedItemIndex = 0;\n    var firstElem = rowElements[0];\n    firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n    return firstRenderedItemIndex;\n  };\n\n  self.getLastRenderedItemIndex = function () {\n    var lastRenderedItemIndex = 0;\n    var lastElem = rowElements[rowElements.length - 1];\n    lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n    return lastRenderedItemIndex;\n  };\n  /**\n   * set the object set height\n   * @param {Number} heightVal The container height\n   */\n\n\n  self.setContainerHeight = function (heightVal) {\n    _containerHeight = heightVal;\n    _visibleAreaHeight = calculateVisibleAreaHeight(); // LCS-140092 - AW UxRefresh does not allow scrolling in Qt WebEngine Browser\n    // 100% is not working in Qt WebEngine, use heightVal here\n\n    settings.scrollViewportElem.style.maxHeight = String(_visibleAreaHeight) + 'px';\n    settings.pinViewportElem.style.maxHeight = String(_visibleAreaHeight) + 'px';\n  };\n  /**\n   * Set if dynamic row height is enabled or not\n   *\n   * @param {Boolean} isEnabled if DRH is enabled or not\n   */\n\n\n  self.setDynamicRowHeight = function (isEnabled) {\n    settings.dynamicRowHeightStatus = isEnabled;\n\n    if (settings.tableElem._tableInstance) {\n      settings.tableElem._tableInstance.dynamicRowHeightStatus = isEnabled;\n    }\n  };\n  /**\n   * Sets the extra visible row count 10 < x < 30\n   *\n   * @param {Number} rowCount The number of rows to set\n   */\n\n\n  function setExtraVisibleRowCount(rowCount) {\n    extraVisibleRowCount = Math.max(10, Math.min(30, rowCount));\n  }\n  /**\n   * Sets the visible row count\n   *\n   * @param {Number} rowCount the number of visible rows\n   */\n\n\n  function setVisibleRowsCount(rowCount) {\n    visibleRowsCount = rowCount;\n    setExtraVisibleRowCount(rowCount);\n  }\n  /**\n   * Convenience method to get certain row height from cache\n   *\n   * @param {Number} index The row's index\n   * @returns {Number} the row's height\n   */\n\n\n  function getHeightFromCache(index) {\n    if (rowHeightCache[index]) {\n      if (index === rowHeightCache.length - 1) {\n        return rowHeightCache[index];\n      }\n\n      return rowHeightCache[index] - 1; // The -1 is because of the -1 margin added to the rows. May change in future\n    }\n\n    return settings.rowHeight;\n  }\n  /**\n   * Calculates the element's top position (scrollTop or just top)\n   * using the row height cache and its index\n   *\n   * @param {Number} elementIdx The element's index\n   * @returns {Number} the top position for the element\n   */\n\n\n  function calculateElementTopPosition(elementIdx) {\n    let runningTop = 0;\n\n    for (let idx = 0; idx < elementIdx; idx++) {\n      runningTop += getHeightFromCache(idx);\n    }\n\n    return runningTop;\n  }\n  /**\n   * Calculates the row index based off of the scrollTop. Uses the row height cache\n   * and will return the index that the scrollTop reaches to.\n   *\n   * @param {Number} scrollTop The scroll top to calculate the element idx start from\n   * @returns {Number} the element's idx\n   */\n\n\n  function calculateElementIndexFromScrollTop(scrollTop) {\n    let runningTotal = 0;\n    let index = 0;\n\n    while (runningTotal < scrollTop) {\n      runningTotal += getHeightFromCache(index);\n      index++;\n    }\n\n    return index;\n  }\n  /**\n   * Calculates the last visible row's index\n   *\n   * @returns {Number} the last visible row's index\n   */\n\n\n  function calculateLastVisibleRowIndex() {\n    return calculateElementIndexFromScrollTop(currentScrollTop + _visibleAreaHeight) - 1;\n  }\n  /**\n   * Initialize scroll properties\n   */\n\n\n  self.initializeProperties = function () {\n    // Clear the row height cache\n    rowHeightCache = []; // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n    // Use given clientHeight to save one computed CSS reading\n\n    if (_containerHeight === undefined) {\n      _containerHeight = containerHeight > 0 ? containerHeight : settings.directiveElem.clientHeight;\n      _visibleAreaHeight = calculateVisibleAreaHeight();\n    } else if (containerHeightInitialized === false) {\n      self.setContainerHeight(_containerHeight);\n    }\n\n    containerHeightInitialized = true; // Table should have height of at least one row.\n\n    settings.scrollViewportElem.style.minHeight = String(settings.rowHeight) + 'px';\n    settings.pinViewportElem.style.minHeight = String(settings.rowHeight) + 'px';\n    let scrollCanvasHeight = _visibleAreaHeight;\n\n    if (scrollCanvasHeight < 0) {\n      scrollCanvasHeight = 0;\n    }\n\n    let rowCount = Math.floor(scrollCanvasHeight / settings.rowHeight);\n    setVisibleRowsCount(rowCount);\n    logger.trace('Table scroll service: Visible row count - ' + visibleRowsCount);\n  };\n  /**\n   * Updates the container and top space heights so the rows are positioned correctly\n   */\n\n\n  self.updateRowAlignment = function () {\n    let topHeight = 0;\n\n    if (rowElements) {\n      let firstElement = rowElements[0];\n\n      if (firstElement && firstElement.getAttribute('data-indexNumber')) {\n        let firstElementIdx = parseInt(firstElement.getAttribute('data-indexNumber'));\n\n        if (settings.treeTableEditSettings) {\n          topHeight = (firstElementIdx - settings.treeTableEditSettings.firstIndex) * settings.rowHeight;\n        } else {\n          topHeight = calculateElementTopPosition(firstElementIdx);\n        }\n      }\n    }\n\n    settings.pinParentElem.style.top = topHeight + 'px';\n    settings.scrollParentElem.style.top = topHeight + 'px';\n    let scrollContentHeight; // If tree table and editing, use treeEditSettings.lastIndex - the first index to get number of rows in total\n\n    if (settings.treeTableEditSettings) {\n      scrollContentHeight = (settings.treeTableEditSettings.lastIndex - settings.treeTableEditSettings.firstIndex + 1) * settings.rowHeight - topHeight;\n    } else {\n      scrollContentHeight = calculateElementTopPosition(settings.totalFound) - topHeight;\n    }\n\n    settings.pinParentElem.style.height = scrollContentHeight + 'px';\n    settings.scrollParentElem.style.height = scrollContentHeight + 'px';\n  };\n  /**\n   * Returns the row height as an int\n   * @returns {Number} The row Height\n   */\n\n\n  self.getRowHeight = function () {\n    return settings.rowHeight;\n  };\n  /**\n   * Scrolls the table up/down one row.\n   *\n   * @param {Boolean} isScrollDown - scroll down indicator, false for scroll up\n   * @returns {Number} returns the new scrollTop of the scrollViewportElement\n   */\n\n\n  self.manualScroll = function (isScrollDown) {\n    let scrollDistance = isScrollDown ? self.getRowHeight() : -self.getRowHeight();\n    settings.scrollViewportElem.scrollTop += scrollDistance;\n    return settings.scrollViewportElem.scrollTop;\n  };\n  /**\n   * Get scrollTop of the scroll viewport.\n   *\n   * @returns {Number} returns the scrollTop of the scrollViewportElement\n   */\n\n\n  self.getScrollTop = function () {\n    return settings.scrollViewportElem.scrollTop;\n  };\n  /**\n   * Sets the row height\n   *\n   *  @param {int} rowHeight - the height of the row in pixels\n   */\n\n\n  self.setRowHeight = function (rowHeight) {\n    settings.rowHeight = rowHeight;\n  };\n  /**\n   * Gets the total objects found\n   * @returns {Number} The total number of objects found\n   */\n\n\n  self.getTotalFound = function () {\n    return settings.totalFound;\n  };\n  /**\n   * Sets the loaded view model objects\n   *\n   *  @param {[ViewModelObject]} loadedViewModelObjects - the collection of view model objects\n   */\n\n\n  self.setLoadedVMObjects = function (loadedViewModelObjects) {\n    // Maintain the scroll position\n    if (maintainScrollPosition === true) {\n      // This will set the variables for maintaining scroll position.\n      // The values are used when handleScroll is called again.\n      setValuesForMaintainingScroll(loadedViewModelObjects.length - settings.totalFound);\n    }\n\n    settings.loadedVMObjects = loadedViewModelObjects;\n    settings.totalFound = loadedViewModelObjects.length;\n  };\n\n  self.setScrollPositionToBeMaintained = function () {\n    maintainScrollPosition = true;\n  };\n  /**\n   * Sets the proper variables to maintain the scroll position\n   * @param {integer} rowDifferenceCount - the difference in rows used to calculate maintained scroll position\n   */\n\n\n  function setValuesForMaintainingScroll(rowDifferenceCount) {\n    maintainScrollPosition = false;\n    scrollToRowInProgress = true;\n    let currentRow = calculateElementIndexFromScrollTop(settings.scrollViewportElem.scrollTop);\n    let scrollToRow = currentRow + rowDifferenceCount;\n    scrollToRowScrollTop = calculateElementTopPosition(scrollToRow);\n  }\n\n  self.isScrollToRowInProgress = function () {\n    return scrollToRowInProgress;\n  };\n\n  let scrollEndTimer;\n  /**\n   * Handles Scroll End logic\n   * Deletes excess rows when user has stopped scrolling for 500ms\n   * This prevents excessive deleting while trying to also create new rows and scroll table\n   */\n\n  function handleScrollEndEvent() {\n    if (scrollEndTimer) {\n      clearTimeout(scrollEndTimer);\n    }\n\n    scrollEndTimer = setTimeout(function () {\n      removeExtraRows();\n    }, 300);\n  }\n  /**\n   * Initialize Scroll Event to table\n   */\n\n\n  function initializeEvents() {\n    settings.scrollViewportElem.removeEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem.removeEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem.removeEventListener('scroll', handlePinScrollEvent);\n    settings.scrollViewportElem.addEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem.addEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem.addEventListener('scroll', handlePinScrollEvent);\n  }\n  /**\n   * Add a padding to the pin viewport to align pin rows with content rows\n   * when scrolled to the bottom.\n   *\n   * @param {Number} tempExtraTop - amount of padding in pixels\n   */\n\n\n  function addPinViewportScrollbarPadding(tempExtraTop) {\n    settings.pinViewportElem.style.top = String(tempExtraTop * -1) + 'px';\n    extraTop = tempExtraTop;\n  }\n  /**\n   * Remove the padding to the pin viewport used for row alignment.\n   */\n\n\n  function removePinViewportScrollbarPadding() {\n    settings.pinViewportElem.style.top = '0px';\n    extraTop = 0;\n  }\n  /**\n   * Apply/remove extra top for pinViewport if the scrollViewport is now visible/invisible\n   */\n\n\n  self.handlePinViewportScrollbarPadding = function () {\n    const pinViewportElem = settings.pinViewportElem;\n    const scrollViewportElem = settings.scrollViewportElem;\n\n    if (currentScrollTop >= 0) {\n      if (pinViewportElem.style.top === '0px' && scrollViewportElem.clientWidth > 0) {\n        let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n\n        if (tempExtraTop > 0) {\n          addPinViewportScrollbarPadding(tempExtraTop);\n        }\n      } else if (pinViewportElem.style.top !== '0px' && scrollViewportElem.clientWidth <= 0) {\n        removePinViewportScrollbarPadding();\n      }\n    }\n  };\n  /**\n   * Scroll Event Handler\n   */\n\n\n  function handleScrollEvent(e) {\n    lastScrollTimeStamp = new Date();\n    let oldScrollTop = currentScrollTop;\n    currentScrollTop = settings.scrollViewportElem.scrollTop;\n    let oldScrollLeft = currentScrollLeft;\n    currentScrollLeft = settings.scrollViewportElem.scrollLeft;\n\n    if (oldScrollTop === currentScrollTop && currentScrollTop < 0 && oldScrollLeft === currentScrollLeft && currentScrollLeft < 0) {\n      e.preventDefault();\n      e.stopPropagation();\n    } // LCS-133249 Scrolling performance issue\n    // Do scroll syncing at very beginning\n\n\n    let pinViewportElem = settings.pinViewportElem;\n\n    if (userPinScrollsDetected === 0 && (oldScrollTop !== currentScrollTop || currentScrollTop === 0)) {\n      disablePinScrollEvent = true;\n      pinViewportElem.scrollTop = currentScrollTop;\n    }\n\n    settings.onStartScroll();\n\n    if (oldScrollLeft !== currentScrollLeft && currentScrollLeft >= 0) {\n      settings.syncHeader(false, currentScrollLeft);\n      horizontalScrollDebounceEvent();\n    }\n\n    if (oldScrollTop !== currentScrollTop && currentScrollTop >= 0) {\n      let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n\n      if (tempExtraTop > 0) {\n        if (settings.scrollViewportElem.clientWidth > 0) {\n          addPinViewportScrollbarPadding(tempExtraTop);\n        }\n      } else if (extraTop > 0) {\n        // For non IE/Edge, need to set top back when scroll up\n        removePinViewportScrollbarPadding();\n      }\n\n      verticalScrollDebounceEvent();\n    }\n\n    userPinScrollsDetected -= 1;\n\n    if (userPinScrollsDetected < 0) {\n      userPinScrollsDetected = 0;\n    }\n  }\n  /**\n   * Real processing method for scroll event after debounce/requestAnimationFrame\n   */\n\n\n  function handleScrollEventInternal() {\n    let func;\n    let isScrollDown = currentScrollTop > previousScrollTop;\n\n    if (isScrollDown) {\n      func = self.handleScrollDown;\n    } else {\n      func = handleScrollUp;\n    }\n\n    previousScrollTop = currentScrollTop; // Do scroll shadow\n\n    if (currentScrollTop > 0) {\n      if (!settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)) {\n        settings.tableElem.classList.add(Const.CLASS_TABLE_SCROLLED);\n      }\n    } else {\n      if (settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)) {\n        settings.tableElem.classList.remove(Const.CLASS_TABLE_SCROLLED);\n      }\n    }\n\n    func.call();\n  }\n  /**\n   * Method to handle scroll down\n   */\n\n\n  self.handleScrollDown = function () {\n    if (rowElements && rowElements.length) {\n      let lastChildElem = rowElements[rowElements.length - 1];\n      let lastIndexNumber = parseInt(lastChildElem.getAttribute('data-indexNumber'));\n      let lastItemBottomPosition;\n\n      if (settings.treeTableEditSettings) {\n        lastItemBottomPosition = (lastIndexNumber - settings.treeTableEditSettings.firstIndex) * settings.rowHeight + settings.rowHeight;\n      } else {\n        lastItemBottomPosition = calculateElementTopPosition(lastIndexNumber + 1);\n      }\n\n      let lastVisibleRowIndex = calculateLastVisibleRowIndex();\n      let lastItemAboveTop = lastItemBottomPosition < currentScrollTop;\n\n      if (lastItemAboveTop === true) {\n        // Check if all the elements are rendered.\n        if (lastIndexNumber + 1 < settings.totalFound) {\n          // Last element went up and page is empty. Need to calculate the page number now\n          self.handleScroll();\n        }\n      } else if (lastItemBottomPosition < calculateElementTopPosition(lastVisibleRowIndex + extraVisibleRowCount)) {\n        let extraBlankRowsInView = lastVisibleRowIndex - lastIndexNumber;\n        extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView; // Last element went up and element is still in the page. Can do continuous rendering\n\n        let startCount = lastIndexNumber + 1;\n        let endCount = startCount + extraVisibleRowCount + extraBlankRowsInView;\n        renderPageData(startCount, endCount);\n      }\n    } else {\n      self.handleScroll();\n    }\n  };\n  /**\n   * Method to handle wheel scroll event\n   *\n   * @param {Object} e - the event\n   */\n\n\n  function handlePinScrollEvent(e) {\n    if (disablePinScrollEvent === true) {\n      disablePinScrollEvent = false;\n      return;\n    }\n\n    var currentPinScrollLeft = settings.pinViewportElem.scrollLeft;\n    settings.syncHeader(true, currentPinScrollLeft); // If scrollTop is same as currentScrollTop then nothing else needs to be done.\n\n    if (settings.pinViewportElem.scrollTop === currentScrollTop) {\n      return;\n    }\n\n    userPinScrollsDetected += 1;\n\n    if (settings.pinViewportElem.scrollTop !== settings.pinViewportElem.scrollHeight - settings.pinViewportElem.offsetHeight) {\n      settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop;\n    } else {\n      settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop + 40;\n    } // Prevent scrolling the parent div\n\n\n    e.preventDefault();\n  }\n  /**\n   * Method call by handleScrollUp and handleScrollDown which processing page rendering\n   *\n   */\n\n\n  self.handleScroll = function () {\n    var currentStartIndex;\n\n    if (settings.initialRowIndex) {\n      self.updateRowAlignment();\n      var newScrollIdx = calculateElementIndexFromScrollTop(calculateElementTopPosition(settings.initialRowIndex) - _visibleAreaHeight * 0.75);\n      var newScrollTop = calculateElementTopPosition(newScrollIdx);\n      delete settings.initialRowIndex;\n      currentScrollTop = newScrollTop < 0 ? 0 : newScrollTop;\n      currentStartIndex = newScrollIdx;\n      settings.scrollViewportElem.scrollTop = currentScrollTop;\n    }\n\n    if (scrollToRowInProgress === true) {\n      self.updateRowAlignment();\n      settings.scrollViewportElem.scrollTop = scrollToRowScrollTop;\n      scrollToRowInProgress = false;\n      scrollToRowScrollTop = null;\n    }\n\n    if (!currentStartIndex) {\n      currentStartIndex = calculateElementIndexFromScrollTop(currentScrollTop);\n    }\n\n    var start = currentStartIndex - extraVisibleRowCount;\n    var end = currentStartIndex + visibleRowsCount + extraVisibleRowCount;\n\n    if (end > settings.totalFound - 1) {\n      var offset = end - settings.totalFound - 1;\n      end -= offset;\n      start -= offset;\n    }\n\n    renderPageData(start, end, true);\n    previousScrollTop = currentScrollTop;\n  };\n  /**\n   * Method to handle scroll up\n   */\n\n\n  function handleScrollUp() {\n    if (rowElements && rowElements.length) {\n      var firstChildElem = rowElements[0];\n      var firstItemIndex = parseInt(firstChildElem.getAttribute('data-indexNumber'));\n      var firstItemTopPosition;\n\n      if (settings.treeTableEditSettings) {\n        firstItemTopPosition = (firstItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight;\n      } else {\n        firstItemTopPosition = calculateElementTopPosition(firstItemIndex);\n      }\n\n      var firstVisibleElem = calculateElementIndexFromScrollTop(currentScrollTop);\n      var firstItemBelowBottom = firstItemTopPosition > currentScrollTop + _visibleAreaHeight;\n\n      if (firstItemBelowBottom === true) {\n        self.handleScroll();\n      } else if (firstItemTopPosition > calculateElementTopPosition(firstVisibleElem - extraVisibleRowCount)) {\n        var extraBlankRowsInView = firstItemIndex - firstVisibleElem;\n        extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n        var endCount = firstItemIndex - 1;\n        var startCount = endCount - extraVisibleRowCount - extraBlankRowsInView;\n        renderPageData(startCount, endCount);\n      }\n    } else {\n      self.handleScroll();\n    }\n  }\n  /**\n   * Sets up scrolling for trees while in edit mode\n   * @param {Boolean} isEditing if the table is in edit mode or not\n   */\n\n\n  self.setupTreeEditScroll = function (isEditing) {\n    if (!isEditing) {\n      if (settings.treeTableEditSettings) {\n        // Find our current scroll position\n        var relativeIdx = settings.scrollViewportElem.scrollTop / self.getRowHeight();\n        var scrollTop = (relativeIdx + settings.treeTableEditSettings.firstIndex - 1) * self.getRowHeight(); // Remove tree Edit settings\n\n        delete settings.treeTableEditSettings; // Reset alignment/rows\n\n        self.updateRowAlignment();\n        self.handleScroll(); // Reset our scroll position to what we were at\n\n        settings.pinViewportElem.scrollTop = scrollTop;\n        settings.scrollViewportElem.scrollTop = scrollTop;\n      }\n\n      return;\n    } // If no element in table, return\n\n\n    if (!rowElements || !rowElements[0]) {\n      return;\n    } // Find first row that contains data\n\n\n    var firstChildElem = rowElements[0];\n    var firstIndex = parseInt(firstChildElem.getAttribute('data-indexNumber'));\n    var hasProps = settings.loadedVMObjects[firstIndex].props;\n\n    while (hasProps && firstIndex > 0) {\n      hasProps = settings.loadedVMObjects[firstIndex - 1].props;\n\n      if (hasProps) {\n        firstIndex--;\n      }\n    } // Find last row that contains data\n\n\n    var lastChildElem = rowElements[rowElements.length - 1];\n    var lastIndex = parseInt(lastChildElem.getAttribute('data-indexNumber'));\n    hasProps = settings.loadedVMObjects[lastIndex].props;\n\n    while (hasProps && lastIndex < settings.totalFound - 1) {\n      hasProps = settings.loadedVMObjects[lastIndex + 1].props;\n\n      if (hasProps) {\n        lastIndex++;\n      }\n    }\n\n    settings.treeTableEditSettings = {\n      firstIndex: firstIndex,\n      lastIndex: lastIndex,\n      totalDataLength: lastIndex + 1\n    }; // update the container height\n\n    self.updateRowAlignment();\n  };\n  /**\n   *  Remove rows from lower-bound to upper-bound\n   *\n   * @param {Object} upperCountIdx - event\n   * @param {Object} lowerCounterIdx - event\n   */\n\n\n  function removeRows(upperCountIdx, lowerCounterIdx) {\n    settings.removeRows(upperCountIdx, lowerCounterIdx);\n    rowElements = settings.scrollParentElem.querySelectorAll(settings.rowSelector);\n  }\n  /**\n   *  Resets infinite scroll back to a starting state\n   */\n\n\n  self.resetInfiniteScroll = function () {\n    self.setLoadedVMObjects([]);\n    self.resetInitialRowIndex();\n    rowHeightCache = [];\n    settings.scrollViewportElem.scrollTop = 0;\n    settings.pinViewportElem.style.top = '0px';\n    settings.scrollViewportElem.style.top = '0px';\n    currentScrollTop = 0;\n    self.handleScroll();\n  };\n  /**\n   * Resets the row height cache\n   */\n\n\n  self.resetRowHeightCache = function () {\n    rowHeightCache = [];\n  };\n  /**\n   * Method to render rows\n   *\n   * @param {Number} startIndex Start render index\n   * @param {Number} endIndex End render Index\n   */\n\n\n  function renderRows(startIndex, endIndex) {\n    settings.renderRows(startIndex, endIndex);\n    rowElements = settings.scrollParentElem.querySelectorAll(settings.rowSelector);\n\n    if (settings.dynamicRowHeightStatus) {\n      // check if last value of rowHeightCache is in new set of rendered data, otherwise can cause off by 1.\n      let lastCacheIdx = rowHeightCache.length - 1;\n      let firstElemIdx = rowElements[0].getAttribute('data-indexnumber');\n      let lastElemIdx = rowElements[rowElements.length - 1].getAttribute('data-indexnumber');\n\n      if (lastCacheIdx < firstElemIdx || lastCacheIdx > lastElemIdx) {\n        // Delete last cache value to prevent off by 1 caused by margin\n        rowHeightCache[rowHeightCache.length - 1] = null;\n      } // Loop through rowElements to update row cache\n\n\n      for (let rowElement of rowElements) {\n        let index = parseInt(rowElement.getAttribute('data-indexnumber'));\n        rowHeightCache[index] = rowElement.offsetHeight;\n      }\n    }\n  }\n  /**\n   * Method to render rows\n   *\n   * @param {int} startCount - event\n   * @param {int} endCount - event\n   * @param {int} removeAllChild - event\n   */\n\n\n  function renderPageData(startCount, endCount, removeAllChild) {\n    var totalDataLength; // Check if table is tree table and is editing\n\n    if (settings.treeTableEditSettings) {\n      if (startCount < settings.treeTableEditSettings.firstIndex) {\n        startCount = settings.treeTableEditSettings.firstIndex;\n      }\n\n      if (endCount > settings.treeTableEditSettings.lastIndex) {\n        endCount = settings.treeTableEditSettings.lastIndex;\n      }\n\n      totalDataLength = settings.treeTableEditSettings.totalDataLength;\n    } else {\n      // Check to avoid negative indexing\n      if (startCount < 0) {\n        startCount = 0;\n      }\n\n      totalDataLength = settings.totalFound;\n    }\n\n    if (startCount >= totalDataLength) {\n      if (totalDataLength === 0) {\n        // if collection becomes empty, then remove all the existing list rows\n        removeRows(rowElements.length - 1, 0);\n        self.updateRowAlignment();\n      } else {\n        settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n        renderRows(startCount, endCount);\n      }\n\n      if (startCount === totalDataLength) {\n        logger.trace('Table scroll service: Rendering of page data complete. No more data to render.');\n        return;\n      }\n    } // check to avoid wrong indexing for startCount\n\n\n    if (startCount > totalDataLength) {\n      endCount -= startCount;\n      startCount = 0;\n    } // check to avoid wrong indexing for endCount\n\n\n    if (endCount >= totalDataLength) {\n      endCount = totalDataLength - 1;\n    }\n\n    if (removeAllChild) {\n      // remove the elements from the dom tree.\n      removeRows(rowElements.length - 1, 0);\n    }\n\n    renderRows(startCount, endCount);\n    self.updateRowAlignment();\n    afterGridRender();\n  }\n  /**\n   * Remove extra rows\n   */\n\n\n  function removeExtraRows() {\n    const rowParentElem = settings.scrollParentElem;\n    rowElements = rowParentElem.querySelectorAll(settings.rowSelector);\n\n    if (rowElements.length === 0) {\n      logger.error('Rendering error');\n    } else {\n      let extraChildCount;\n      let invisibleRowsCount;\n      let invisibleRowsHeight;\n      const firstElem = rowElements[0];\n      const firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n\n      if (settings.treeTableEditSettings) {\n        invisibleRowsHeight = (firstRenderedItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight - currentScrollTop;\n      } else {\n        // Simply checking if there are invisible rows, actual height doesn't matter as is not used\n        invisibleRowsHeight = calculateElementTopPosition(firstRenderedItemIndex) - currentScrollTop;\n      }\n\n      if (invisibleRowsHeight < 0) {\n        invisibleRowsCount = Math.abs(calculateElementIndexFromScrollTop(currentScrollTop) - firstRenderedItemIndex);\n        extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n\n        if (extraChildCount > 0) {\n          // remove the elements from the dom tree.\n          removeRows(extraChildCount, 0);\n        }\n      }\n\n      const lastElem = rowElements[rowElements.length - 1];\n      const lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n      const visRowsHeight = visibleRowsCount * settings.rowHeight + currentScrollTop;\n      const lastVisibleRowIndex = calculateLastVisibleRowIndex();\n\n      if (settings.treeTableEditSettings) {\n        invisibleRowsHeight = (lastRenderedItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight + settings.rowHeight - visRowsHeight;\n      } else {\n        // Simply checking if there are invisible rows, so actual height doesn't matter here as it will not be used.\n        invisibleRowsHeight = lastRenderedItemIndex - lastVisibleRowIndex;\n      }\n\n      if (invisibleRowsHeight > 0) {\n        invisibleRowsCount = lastRenderedItemIndex - lastVisibleRowIndex;\n        extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n\n        if (extraChildCount > 0) {\n          removeRows(rowElements.length - 1, rowElements.length - extraChildCount - 1);\n        }\n      }\n    }\n\n    self.updateRowAlignment();\n  }\n  /**\n   * After grid rendered\n   */\n\n\n  function afterGridRender() {\n    var firstRenderedItemIndex = 0;\n    var lastRenderedItemIndex = 0;\n    var firstElem = rowElements[0];\n    firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n    var lastElem = rowElements[rowElements.length - 1];\n    lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n    var firstRenderedItem = {\n      index: firstRenderedItemIndex,\n      uid: firstElem.vmo.uid,\n      levelNdx: firstElem.vmo.levelNdx\n    };\n    var lastRenderedItem = {\n      index: lastRenderedItemIndex,\n      uid: lastElem.vmo.uid,\n      levelNdx: lastElem.vmo.levelNdx\n    };\n    settings.afterGridRenderCallback(firstRenderedItem, lastRenderedItem);\n  }\n\n  self.destroyGrid = function () {\n    settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem && settings.pinViewportElem.removeEventListener('scroll', handlePinScrollEvent);\n    momentumScrolling.disable();\n    self.checkForResize.cancel();\n    horizontalScrollDebounceEvent.cancel();\n    verticalScrollDebounceEvent.cancel();\n  };\n  /**\n   * Scrolls to the given row\n   *\n   * @param {integer[]} rowIndexes Index to scroll to\n   * @returns {boolean} returns false if a row is in view\n   */\n\n\n  self.scrollToRowIndex = function (rowIndexes) {\n    // Only scroll to row if it is out of view\n    if (self.isInitialized() === true) {\n      var scrollToRowElementPosition = null;\n      var firstRowElementIndex = 0;\n      var lastIndexNumber = 0;\n\n      if (rowElements.length > 0) {\n        firstRowElementIndex = Number(rowElements[0].getAttribute('data-indexnumber'));\n        lastIndexNumber = Number(rowElements[rowElements.length - 1].getAttribute('data-indexnumber'));\n      }\n\n      var scrollCanvasRect = settings.scrollViewportElem.getBoundingClientRect();\n\n      for (var i = 0; i < rowIndexes.length; i++) {\n        var rowIndex = rowIndexes[i];\n\n        if (rowElements.length > 0) {\n          if (rowIndex > lastIndexNumber || rowIndex < firstRowElementIndex) {\n            initialRowIndex = rowIndex;\n            continue;\n          }\n\n          scrollToRowElementPosition = rowElements[rowIndex - firstRowElementIndex].getBoundingClientRect();\n\n          if (scrollToRowElementPosition.top < scrollCanvasRect.top || scrollToRowElementPosition.bottom > scrollCanvasRect.bottom) {\n            initialRowIndex = rowIndex;\n            continue;\n          }\n\n          initialRowIndex = rowIndex;\n        }\n\n        return false;\n      } // Check if attempting to scroll past maximum scrollTop, if so set flag\n\n\n      var maxScrollTop = settings.scrollViewportElem.scrollHeight - settings.scrollViewportElem.clientHeight;\n      var newScrollTop = Math.floor(calculateElementTopPosition(initialRowIndex) - _visibleAreaHeight * 0.75);\n      var initialRowIndexOnDom = initialRowIndex - firstRowElementIndex;\n\n      if (rowElements[initialRowIndexOnDom]) {\n        scrollToRowElementPosition = rowElements[initialRowIndexOnDom].getBoundingClientRect();\n\n        if (scrollToRowElementPosition.top < scrollCanvasRect.top && scrollToRowElementPosition.bottom > scrollCanvasRect.top) {\n          newScrollTop = calculateElementTopPosition(initialRowIndex);\n        } else if (scrollToRowElementPosition.top < scrollCanvasRect.bottom && scrollToRowElementPosition.bottom > scrollCanvasRect.bottom) {\n          newScrollTop = settings.scrollViewportElem.scrollTop + (scrollToRowElementPosition.bottom - scrollCanvasRect.bottom);\n        }\n      }\n\n      if (newScrollTop > maxScrollTop) {\n        scrollToRowInProgress = true;\n        scrollToRowScrollTop = newScrollTop;\n      }\n\n      settings.scrollViewportElem.scrollTop = newScrollTop;\n    } else {\n      initialRowIndex = rowIndexes[0];\n    }\n\n    return true;\n  };\n  /**\n   * Scrolls to scroll container column\n   * @param {Object} column - The column to scroll to\n   */\n\n\n  self.scrollToColumn = function (column) {\n    if (column.startPosition <= currentScrollLeft || column.startPosition > currentScrollLeft + scrollContainerWidth) {\n      settings.scrollViewportElem.scrollLeft = column.startPosition - 10;\n    }\n  };\n\n  self.isInitialRowIndexInView = function () {\n    let firstRowElementIndex = Number(rowElements[0].getAttribute('data-indexnumber'));\n    let initialRowElement = rowElements[initialRowIndex - firstRowElementIndex];\n\n    if (initialRowElement === undefined) {\n      return false;\n    }\n\n    let initialRowElementIndex = initialRowElement.getAttribute('data-indexnumber');\n    let firstVisibleIndex = calculateElementIndexFromScrollTop(currentScrollTop);\n    let lastVisibleIndex = calculateLastVisibleRowIndex();\n\n    if (initialRowElementIndex < firstVisibleIndex || initialRowIndex > lastVisibleIndex) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Resets the initial row index to 0 so that infinite scroll service will\n   * start the rendering of rows at the top.\n   */\n\n\n  self.resetInitialRowIndex = function () {\n    initialRowIndex = 0;\n  };\n};\n\n_c = SPLMTableInfiniteScroll;\nexport default SPLMTableInfiniteScroll;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableInfiniteScroll\");","map":{"version":3,"names":["logger","browserUtils","SPLMTableMomentumScrolling","_","Const","SPLMTableInfiniteScroll","containerHeight","self","settings","currentScrollTop","previousScrollTop","rowElements","rowHeightCache","initialized","containerHeightInitialized","_containerHeight","_visibleAreaHeight","headerHeight","initialRowIndex","extraVisibleRowCount","visibleRowsCount","currentScrollLeft","scrollToRowInProgress","scrollToRowScrollTop","maintainScrollPosition","disablePinScrollEvent","userPinScrollsDetected","scrollContainerWidth","verticalScrollDebounceTime","isIE","isFirefox","horizontalScrollDebounceTime","verticalScrollDebounceMaxWait","Infinity","momentumScrolling","lastScrollTimeStamp","Date","elapsedMSSinceLastScroll","extraTop","horizontalScrollDebounceEvent","debounce","scrollViewportElem","offsetWidth","updateScrollColumnsInView","updateVisibleCells","scrollParentElem","verticalScrollDebounceEvent","handleScrollEventInternal","maxWait","initializeGrid","obj","pinParentElem","pinViewportElem","children","totalFound","loadedVMObjects","length","dynamicRowHeightStatus","initializeEvents","enable","calculateVisibleAreaHeight","checkForResize","newClientWidth","handlePinViewportScrollbarPadding","directiveElem","clientHeight","rowContainerHeight","rowCount","Math","floor","rowHeight","setVisibleRowsCount","handleScroll","isInitialized","renderInitialRows","initializeProperties","getFirstRenderedItemIndex","firstRenderedItemIndex","firstElem","parseInt","getAttribute","getLastRenderedItemIndex","lastRenderedItemIndex","lastElem","setContainerHeight","heightVal","style","maxHeight","String","setDynamicRowHeight","isEnabled","tableElem","_tableInstance","setExtraVisibleRowCount","max","min","getHeightFromCache","index","calculateElementTopPosition","elementIdx","runningTop","idx","calculateElementIndexFromScrollTop","scrollTop","runningTotal","calculateLastVisibleRowIndex","undefined","minHeight","scrollCanvasHeight","trace","updateRowAlignment","topHeight","firstElement","firstElementIdx","treeTableEditSettings","firstIndex","top","scrollContentHeight","lastIndex","height","getRowHeight","manualScroll","isScrollDown","scrollDistance","getScrollTop","setRowHeight","getTotalFound","setLoadedVMObjects","loadedViewModelObjects","setValuesForMaintainingScroll","setScrollPositionToBeMaintained","rowDifferenceCount","currentRow","scrollToRow","isScrollToRowInProgress","scrollEndTimer","handleScrollEndEvent","clearTimeout","setTimeout","removeExtraRows","removeEventListener","handleScrollEvent","handlePinScrollEvent","addEventListener","addPinViewportScrollbarPadding","tempExtraTop","removePinViewportScrollbarPadding","clientWidth","offsetHeight","scrollHeight","e","oldScrollTop","oldScrollLeft","scrollLeft","preventDefault","stopPropagation","onStartScroll","syncHeader","func","handleScrollDown","handleScrollUp","classList","contains","CLASS_TABLE_SCROLLED","add","remove","call","lastChildElem","lastIndexNumber","lastItemBottomPosition","lastVisibleRowIndex","lastItemAboveTop","extraBlankRowsInView","startCount","endCount","renderPageData","currentPinScrollLeft","currentStartIndex","newScrollIdx","newScrollTop","start","end","offset","firstChildElem","firstItemIndex","firstItemTopPosition","firstVisibleElem","firstItemBelowBottom","setupTreeEditScroll","isEditing","relativeIdx","hasProps","props","totalDataLength","removeRows","upperCountIdx","lowerCounterIdx","querySelectorAll","rowSelector","resetInfiniteScroll","resetInitialRowIndex","resetRowHeightCache","renderRows","startIndex","endIndex","lastCacheIdx","firstElemIdx","lastElemIdx","rowElement","removeAllChild","afterGridRender","rowParentElem","error","extraChildCount","invisibleRowsCount","invisibleRowsHeight","abs","visRowsHeight","firstRenderedItem","uid","vmo","levelNdx","lastRenderedItem","afterGridRenderCallback","destroyGrid","disable","cancel","scrollToRowIndex","rowIndexes","scrollToRowElementPosition","firstRowElementIndex","Number","scrollCanvasRect","getBoundingClientRect","i","rowIndex","bottom","maxScrollTop","initialRowIndexOnDom","scrollToColumn","column","startPosition","isInitialRowIndexInView","initialRowElement","initialRowElementIndex","firstVisibleIndex","lastVisibleIndex"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableInfiniteScrollService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is for exposing the native js data provider behavior. The module supports loading the module from GWT\n * and getting the native JS code invoked.\n *\n * @module js/splmTableInfiniteScrollService\n */\nimport logger from 'js/logger';\nimport browserUtils from 'js/browserUtils';\nimport SPLMTableMomentumScrolling from 'js/splmTableMomentumScrolling';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\n\n/**\n * Native infinite scroll.\n *\n * @constructor\n * @param {Number} containerHeight the container height\n */\nlet SPLMTableInfiniteScroll = function( containerHeight ) {\n    let self = this;\n    let settings = {};\n\n    let currentScrollTop = 0; // Holds the last scroll position to detect scroll down or up\n    let previousScrollTop = 0;\n    let rowElements = []; // contains cache of rendered list\n    let rowHeightCache = [];\n    let initialized = false;\n    let containerHeightInitialized = false;\n    let _containerHeight = containerHeight;\n    let _visibleAreaHeight = _containerHeight - settings.headerHeight;\n    let initialRowIndex = 0;\n    let extraVisibleRowCount = 14; // keep it even for easier scrolling/calculations\n    let visibleRowsCount = 0;\n    let currentScrollLeft = 0;\n    let scrollToRowInProgress = false;\n    let scrollToRowScrollTop = null;\n    let maintainScrollPosition = false;\n    let disablePinScrollEvent = false;\n    let userPinScrollsDetected = 0;\n    let scrollContainerWidth = 0;\n    let verticalScrollDebounceTime = browserUtils.isIE || browserUtils.isFirefox ? 200 : 0;\n    let horizontalScrollDebounceTime = browserUtils.isIE ? 500 : 0;\n    let verticalScrollDebounceMaxWait = browserUtils.isIE || browserUtils.isFirefox ? Infinity : 0;\n    let momentumScrolling = new SPLMTableMomentumScrolling();\n    let lastScrollTimeStamp = new Date();\n    let elapsedMSSinceLastScroll = 0;\n\n    // LCS-133249 Scrolling performance issue\n    // Do scroll syncing at very beginning\n    let extraTop = 0;\n\n    let horizontalScrollDebounceEvent = _.debounce( function() {\n        if( settings.scrollViewportElem && settings.scrollViewportElem.offsetWidth ) {\n            scrollContainerWidth = settings.scrollViewportElem.offsetWidth;\n        }\n        settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n        settings.updateVisibleCells( settings.scrollParentElem );\n    }, horizontalScrollDebounceTime );\n\n    let verticalScrollDebounceEvent = _.debounce( function() {\n        handleScrollEventInternal();\n    }, verticalScrollDebounceTime, {\n        maxWait: verticalScrollDebounceMaxWait\n    } );\n\n    self.initializeGrid = function( obj ) {\n        settings = obj;\n        settings.pinParentElem = settings.pinViewportElem.children[ 0 ];\n        settings.scrollParentElem = settings.scrollViewportElem.children[ 0 ];\n        settings.totalFound = settings.loadedVMObjects.length;\n        settings.dynamicRowHeightStatus = settings.dynamicRowHeightStatus || false;\n        initializeEvents();\n        momentumScrolling.enable( settings.pinViewportElem, settings.scrollViewportElem );\n        initialized = true;\n    };\n\n    /**\n     * Calculates the visible area of the table\n     * @returns {Number} the visible height\n     */\n    let calculateVisibleAreaHeight = function() {\n        return _containerHeight - settings.headerHeight;\n    };\n\n    self.checkForResize = _.debounce( async function() {\n        elapsedMSSinceLastScroll = new Date() - lastScrollTimeStamp;\n        if( elapsedMSSinceLastScroll < 200 ) {\n            return;\n        }\n        let newClientWidth = settings.scrollViewportElem.offsetWidth;\n        if( newClientWidth !== scrollContainerWidth ) {\n            if( newClientWidth > scrollContainerWidth ) {\n                scrollContainerWidth = newClientWidth;\n                settings.updateScrollColumnsInView( currentScrollLeft );\n            } else {\n                scrollContainerWidth = newClientWidth;\n                settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n            }\n            settings.updateVisibleCells( settings.scrollParentElem );\n            self.handlePinViewportScrollbarPadding();\n        }\n\n        if( settings.directiveElem.clientHeight !== _containerHeight ) {\n            _containerHeight = settings.directiveElem.clientHeight;\n            let rowContainerHeight = settings.scrollViewportElem.clientHeight || settings.pinViewportElem.clientHeight || _containerHeight;\n            let rowCount = Math.floor( rowContainerHeight / settings.rowHeight );\n            _visibleAreaHeight = calculateVisibleAreaHeight();\n            setVisibleRowsCount( rowCount );\n            await self.handleScroll();\n        }\n    }, 200 );\n\n    self.isInitialized = function() {\n        return initialized;\n    };\n\n    /**\n     * Renders the initial rows on initialization once table div has been rendered so that\n     * the height can be computed properly\n     */\n    self.renderInitialRows = function() {\n        self.initializeProperties();\n        settings.initialRowIndex = initialRowIndex;\n        self.handleScroll();\n    };\n\n    self.getFirstRenderedItemIndex = function() {\n        var firstRenderedItemIndex = 0;\n        var firstElem = rowElements[ 0 ];\n        firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n        return firstRenderedItemIndex;\n    };\n\n    self.getLastRenderedItemIndex = function() {\n        var lastRenderedItemIndex = 0;\n        var lastElem = rowElements[ rowElements.length - 1 ];\n        lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n        return lastRenderedItemIndex;\n    };\n\n    /**\n     * set the object set height\n     * @param {Number} heightVal The container height\n     */\n    self.setContainerHeight = function( heightVal ) {\n        _containerHeight = heightVal;\n        _visibleAreaHeight = calculateVisibleAreaHeight();\n        // LCS-140092 - AW UxRefresh does not allow scrolling in Qt WebEngine Browser\n        // 100% is not working in Qt WebEngine, use heightVal here\n        settings.scrollViewportElem.style.maxHeight = String( _visibleAreaHeight ) + 'px';\n        settings.pinViewportElem.style.maxHeight = String( _visibleAreaHeight ) + 'px';\n    };\n\n    /**\n     * Set if dynamic row height is enabled or not\n     *\n     * @param {Boolean} isEnabled if DRH is enabled or not\n     */\n    self.setDynamicRowHeight = function( isEnabled ) {\n        settings.dynamicRowHeightStatus = isEnabled;\n        if( settings.tableElem._tableInstance ) {\n            settings.tableElem._tableInstance.dynamicRowHeightStatus = isEnabled;\n        }\n    };\n\n    /**\n     * Sets the extra visible row count 10 < x < 30\n     *\n     * @param {Number} rowCount The number of rows to set\n     */\n    function setExtraVisibleRowCount( rowCount ) {\n        extraVisibleRowCount = Math.max( 10, Math.min( 30, rowCount ) );\n    }\n\n    /**\n     * Sets the visible row count\n     *\n     * @param {Number} rowCount the number of visible rows\n     */\n    function setVisibleRowsCount( rowCount ) {\n        visibleRowsCount = rowCount;\n        setExtraVisibleRowCount( rowCount );\n    }\n\n    /**\n     * Convenience method to get certain row height from cache\n     *\n     * @param {Number} index The row's index\n     * @returns {Number} the row's height\n     */\n    function getHeightFromCache( index ) {\n        if( rowHeightCache[ index ] ) {\n            if( index === rowHeightCache.length - 1 ) {\n                return rowHeightCache[ index ];\n            }\n            return rowHeightCache[ index ] - 1; // The -1 is because of the -1 margin added to the rows. May change in future\n        }\n        return settings.rowHeight;\n    }\n\n    /**\n     * Calculates the element's top position (scrollTop or just top)\n     * using the row height cache and its index\n     *\n     * @param {Number} elementIdx The element's index\n     * @returns {Number} the top position for the element\n     */\n    function calculateElementTopPosition( elementIdx ) {\n        let runningTop = 0;\n        for( let idx = 0; idx < elementIdx; idx++ ) {\n            runningTop += getHeightFromCache( idx );\n        }\n        return runningTop;\n    }\n\n    /**\n     * Calculates the row index based off of the scrollTop. Uses the row height cache\n     * and will return the index that the scrollTop reaches to.\n     *\n     * @param {Number} scrollTop The scroll top to calculate the element idx start from\n     * @returns {Number} the element's idx\n     */\n    function calculateElementIndexFromScrollTop( scrollTop ) {\n        let runningTotal = 0;\n        let index = 0;\n        while( runningTotal < scrollTop ) {\n            runningTotal += getHeightFromCache( index );\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Calculates the last visible row's index\n     *\n     * @returns {Number} the last visible row's index\n     */\n    function calculateLastVisibleRowIndex() {\n        return calculateElementIndexFromScrollTop( currentScrollTop + _visibleAreaHeight ) - 1;\n    }\n\n    /**\n     * Initialize scroll properties\n     */\n    self.initializeProperties = function() {\n        // Clear the row height cache\n        rowHeightCache = [];\n        // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n        // Use given clientHeight to save one computed CSS reading\n        if( _containerHeight === undefined ) {\n            _containerHeight = containerHeight > 0 ? containerHeight : settings.directiveElem.clientHeight;\n            _visibleAreaHeight = calculateVisibleAreaHeight();\n        } else if( containerHeightInitialized === false ) {\n            self.setContainerHeight( _containerHeight );\n        }\n        containerHeightInitialized = true;\n\n        // Table should have height of at least one row.\n        settings.scrollViewportElem.style.minHeight = String( settings.rowHeight ) + 'px';\n        settings.pinViewportElem.style.minHeight = String( settings.rowHeight ) + 'px';\n\n        let scrollCanvasHeight = _visibleAreaHeight;\n        if( scrollCanvasHeight < 0 ) {\n            scrollCanvasHeight = 0;\n        }\n\n        let rowCount = Math.floor( scrollCanvasHeight / settings.rowHeight );\n        setVisibleRowsCount( rowCount );\n\n        logger.trace( 'Table scroll service: Visible row count - ' + visibleRowsCount );\n    };\n\n    /**\n     * Updates the container and top space heights so the rows are positioned correctly\n     */\n    self.updateRowAlignment = function() {\n        let topHeight = 0;\n\n        if( rowElements ) {\n            let firstElement = rowElements[ 0 ];\n            if( firstElement && firstElement.getAttribute( 'data-indexNumber' ) ) {\n                let firstElementIdx = parseInt( firstElement.getAttribute( 'data-indexNumber' ) );\n                if( settings.treeTableEditSettings ) {\n                    topHeight = ( firstElementIdx - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight;\n                } else {\n                    topHeight = calculateElementTopPosition( firstElementIdx );\n                }\n            }\n        }\n\n        settings.pinParentElem.style.top = topHeight + 'px';\n        settings.scrollParentElem.style.top = topHeight + 'px';\n\n        let scrollContentHeight;\n        // If tree table and editing, use treeEditSettings.lastIndex - the first index to get number of rows in total\n        if( settings.treeTableEditSettings ) {\n            scrollContentHeight = ( settings.treeTableEditSettings.lastIndex - settings.treeTableEditSettings.firstIndex + 1 ) * settings.rowHeight - topHeight;\n        } else {\n            scrollContentHeight = calculateElementTopPosition( settings.totalFound ) - topHeight;\n        }\n\n        settings.pinParentElem.style.height = scrollContentHeight + 'px';\n        settings.scrollParentElem.style.height = scrollContentHeight + 'px';\n    };\n\n    /**\n     * Returns the row height as an int\n     * @returns {Number} The row Height\n     */\n    self.getRowHeight = function() {\n        return settings.rowHeight;\n    };\n\n    /**\n     * Scrolls the table up/down one row.\n     *\n     * @param {Boolean} isScrollDown - scroll down indicator, false for scroll up\n     * @returns {Number} returns the new scrollTop of the scrollViewportElement\n     */\n    self.manualScroll = function( isScrollDown ) {\n        let scrollDistance = isScrollDown ? self.getRowHeight() : -self.getRowHeight();\n        settings.scrollViewportElem.scrollTop += scrollDistance;\n        return settings.scrollViewportElem.scrollTop;\n    };\n\n    /**\n     * Get scrollTop of the scroll viewport.\n     *\n     * @returns {Number} returns the scrollTop of the scrollViewportElement\n     */\n    self.getScrollTop = function() {\n        return settings.scrollViewportElem.scrollTop;\n    };\n\n    /**\n     * Sets the row height\n     *\n     *  @param {int} rowHeight - the height of the row in pixels\n     */\n    self.setRowHeight = function( rowHeight ) {\n        settings.rowHeight = rowHeight;\n    };\n\n    /**\n     * Gets the total objects found\n     * @returns {Number} The total number of objects found\n     */\n    self.getTotalFound = function() {\n        return settings.totalFound;\n    };\n\n    /**\n     * Sets the loaded view model objects\n     *\n     *  @param {[ViewModelObject]} loadedViewModelObjects - the collection of view model objects\n     */\n    self.setLoadedVMObjects = function( loadedViewModelObjects ) {\n        // Maintain the scroll position\n        if( maintainScrollPosition === true ) {\n            // This will set the variables for maintaining scroll position.\n            // The values are used when handleScroll is called again.\n            setValuesForMaintainingScroll( loadedViewModelObjects.length - settings.totalFound );\n        }\n        settings.loadedVMObjects = loadedViewModelObjects;\n        settings.totalFound = loadedViewModelObjects.length;\n    };\n\n    self.setScrollPositionToBeMaintained = function() {\n        maintainScrollPosition = true;\n    };\n\n    /**\n     * Sets the proper variables to maintain the scroll position\n     * @param {integer} rowDifferenceCount - the difference in rows used to calculate maintained scroll position\n     */\n    function setValuesForMaintainingScroll( rowDifferenceCount ) {\n        maintainScrollPosition = false;\n        scrollToRowInProgress = true;\n        let currentRow = calculateElementIndexFromScrollTop( settings.scrollViewportElem.scrollTop );\n        let scrollToRow = currentRow + rowDifferenceCount;\n        scrollToRowScrollTop = calculateElementTopPosition( scrollToRow );\n    }\n\n    self.isScrollToRowInProgress = function() {\n        return scrollToRowInProgress;\n    };\n\n    let scrollEndTimer;\n\n    /**\n     * Handles Scroll End logic\n     * Deletes excess rows when user has stopped scrolling for 500ms\n     * This prevents excessive deleting while trying to also create new rows and scroll table\n     */\n    function handleScrollEndEvent() {\n        if( scrollEndTimer ) {\n            clearTimeout( scrollEndTimer );\n        }\n        scrollEndTimer = setTimeout( function() {\n            removeExtraRows();\n        }, 300 );\n    }\n\n    /**\n     * Initialize Scroll Event to table\n     */\n    function initializeEvents() {\n        settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem.removeEventListener( 'scroll', handlePinScrollEvent );\n        settings.scrollViewportElem.addEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem.addEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem.addEventListener( 'scroll', handlePinScrollEvent );\n    }\n\n    /**\n     * Add a padding to the pin viewport to align pin rows with content rows\n     * when scrolled to the bottom.\n     *\n     * @param {Number} tempExtraTop - amount of padding in pixels\n     */\n    function addPinViewportScrollbarPadding( tempExtraTop ) {\n        settings.pinViewportElem.style.top = String( tempExtraTop * -1 ) + 'px';\n        extraTop = tempExtraTop;\n    }\n\n    /**\n     * Remove the padding to the pin viewport used for row alignment.\n     */\n    function removePinViewportScrollbarPadding() {\n        settings.pinViewportElem.style.top = '0px';\n        extraTop = 0;\n    }\n\n    /**\n     * Apply/remove extra top for pinViewport if the scrollViewport is now visible/invisible\n     */\n    self.handlePinViewportScrollbarPadding = function() {\n        const pinViewportElem = settings.pinViewportElem;\n        const scrollViewportElem = settings.scrollViewportElem;\n        if( currentScrollTop >= 0 ) {\n            if( pinViewportElem.style.top === '0px' && scrollViewportElem.clientWidth > 0 ) {\n                let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n                if( tempExtraTop > 0 ) {\n                    addPinViewportScrollbarPadding( tempExtraTop );\n                }\n            } else if( pinViewportElem.style.top !== '0px' && scrollViewportElem.clientWidth <= 0 ) {\n                removePinViewportScrollbarPadding();\n            }\n        }\n    };\n\n    /**\n     * Scroll Event Handler\n     */\n    function handleScrollEvent( e ) {\n        lastScrollTimeStamp = new Date();\n        let oldScrollTop = currentScrollTop;\n        currentScrollTop = settings.scrollViewportElem.scrollTop;\n        let oldScrollLeft = currentScrollLeft;\n        currentScrollLeft = settings.scrollViewportElem.scrollLeft;\n\n        if( oldScrollTop === currentScrollTop && currentScrollTop < 0 && oldScrollLeft === currentScrollLeft && currentScrollLeft < 0 ) {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n\n        // LCS-133249 Scrolling performance issue\n        // Do scroll syncing at very beginning\n        let pinViewportElem = settings.pinViewportElem;\n        if( userPinScrollsDetected === 0 && ( oldScrollTop !== currentScrollTop || currentScrollTop === 0 ) ) {\n            disablePinScrollEvent = true;\n            pinViewportElem.scrollTop = currentScrollTop;\n        }\n\n        settings.onStartScroll();\n\n        if( oldScrollLeft !== currentScrollLeft && currentScrollLeft >= 0 ) {\n            settings.syncHeader( false, currentScrollLeft );\n            horizontalScrollDebounceEvent();\n        }\n\n        if( oldScrollTop !== currentScrollTop && currentScrollTop >= 0 ) {\n            let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n            if( tempExtraTop > 0 ) {\n                if( settings.scrollViewportElem.clientWidth > 0 ) {\n                    addPinViewportScrollbarPadding( tempExtraTop );\n                }\n            } else if( extraTop > 0 ) {\n                // For non IE/Edge, need to set top back when scroll up\n                removePinViewportScrollbarPadding();\n            }\n\n            verticalScrollDebounceEvent();\n        }\n\n        userPinScrollsDetected -= 1;\n        if( userPinScrollsDetected < 0 ) {\n            userPinScrollsDetected = 0;\n        }\n    }\n\n    /**\n     * Real processing method for scroll event after debounce/requestAnimationFrame\n     */\n    function handleScrollEventInternal() {\n        let func;\n        let isScrollDown = currentScrollTop > previousScrollTop;\n        if( isScrollDown ) {\n            func = self.handleScrollDown;\n        } else {\n            func = handleScrollUp;\n        }\n        previousScrollTop = currentScrollTop;\n\n        // Do scroll shadow\n        if( currentScrollTop > 0 ) {\n            if( !settings.tableElem.classList.contains( Const.CLASS_TABLE_SCROLLED ) ) {\n                settings.tableElem.classList.add( Const.CLASS_TABLE_SCROLLED );\n            }\n        } else {\n            if( settings.tableElem.classList.contains( Const.CLASS_TABLE_SCROLLED ) ) {\n                settings.tableElem.classList.remove( Const.CLASS_TABLE_SCROLLED );\n            }\n        }\n\n        func.call();\n    }\n\n    /**\n     * Method to handle scroll down\n     */\n    self.handleScrollDown = function() {\n        if( rowElements && rowElements.length ) {\n            let lastChildElem = rowElements[ rowElements.length - 1 ];\n            let lastIndexNumber = parseInt( lastChildElem.getAttribute( 'data-indexNumber' ) );\n            let lastItemBottomPosition;\n            if( settings.treeTableEditSettings ) {\n                lastItemBottomPosition = ( lastIndexNumber - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight + settings.rowHeight;\n            } else {\n                lastItemBottomPosition = calculateElementTopPosition( lastIndexNumber + 1 );\n            }\n            let lastVisibleRowIndex = calculateLastVisibleRowIndex();\n            let lastItemAboveTop = lastItemBottomPosition < currentScrollTop;\n            if( lastItemAboveTop === true ) {\n                // Check if all the elements are rendered.\n                if( lastIndexNumber + 1 < settings.totalFound ) {\n                    // Last element went up and page is empty. Need to calculate the page number now\n                    self.handleScroll();\n                }\n            } else if( lastItemBottomPosition < calculateElementTopPosition( lastVisibleRowIndex + extraVisibleRowCount ) ) {\n                let extraBlankRowsInView = lastVisibleRowIndex - lastIndexNumber;\n                extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n                // Last element went up and element is still in the page. Can do continuous rendering\n                let startCount = lastIndexNumber + 1;\n                let endCount = startCount + extraVisibleRowCount + extraBlankRowsInView;\n                renderPageData( startCount, endCount );\n            }\n        } else {\n            self.handleScroll();\n        }\n    };\n\n    /**\n     * Method to handle wheel scroll event\n     *\n     * @param {Object} e - the event\n     */\n    function handlePinScrollEvent( e ) {\n        if( disablePinScrollEvent === true ) {\n            disablePinScrollEvent = false;\n            return;\n        }\n\n        var currentPinScrollLeft = settings.pinViewportElem.scrollLeft;\n        settings.syncHeader( true, currentPinScrollLeft );\n\n        // If scrollTop is same as currentScrollTop then nothing else needs to be done.\n        if( settings.pinViewportElem.scrollTop === currentScrollTop ) {\n            return;\n        }\n\n        userPinScrollsDetected += 1;\n\n        if( settings.pinViewportElem.scrollTop !== settings.pinViewportElem.scrollHeight - settings.pinViewportElem.offsetHeight ) {\n            settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop;\n        } else {\n            settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop + 40;\n        }\n\n        // Prevent scrolling the parent div\n        e.preventDefault();\n    }\n\n    /**\n     * Method call by handleScrollUp and handleScrollDown which processing page rendering\n     *\n     */\n    self.handleScroll = function() {\n        var currentStartIndex;\n\n        if( settings.initialRowIndex ) {\n            self.updateRowAlignment();\n            var newScrollIdx = calculateElementIndexFromScrollTop( calculateElementTopPosition( settings.initialRowIndex ) - _visibleAreaHeight * 0.75 );\n            var newScrollTop = calculateElementTopPosition( newScrollIdx );\n            delete settings.initialRowIndex;\n            currentScrollTop = newScrollTop < 0 ? 0 : newScrollTop;\n            currentStartIndex = newScrollIdx;\n            settings.scrollViewportElem.scrollTop = currentScrollTop;\n        }\n        if( scrollToRowInProgress === true ) {\n            self.updateRowAlignment();\n            settings.scrollViewportElem.scrollTop = scrollToRowScrollTop;\n            scrollToRowInProgress = false;\n            scrollToRowScrollTop = null;\n        }\n\n        if( !currentStartIndex ) {\n            currentStartIndex = calculateElementIndexFromScrollTop( currentScrollTop );\n        }\n\n        var start = currentStartIndex - extraVisibleRowCount;\n        var end = currentStartIndex + visibleRowsCount + extraVisibleRowCount;\n        if( end > settings.totalFound - 1 ) {\n            var offset = end - settings.totalFound - 1;\n            end -= offset;\n            start -= offset;\n        }\n        renderPageData( start, end, true );\n        previousScrollTop = currentScrollTop;\n    };\n\n    /**\n     * Method to handle scroll up\n     */\n    function handleScrollUp() {\n        if( rowElements && rowElements.length ) {\n            var firstChildElem = rowElements[ 0 ];\n            var firstItemIndex = parseInt( firstChildElem.getAttribute( 'data-indexNumber' ) );\n            var firstItemTopPosition;\n            if( settings.treeTableEditSettings ) {\n                firstItemTopPosition = ( firstItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight;\n            } else {\n                firstItemTopPosition = calculateElementTopPosition( firstItemIndex );\n            }\n            var firstVisibleElem = calculateElementIndexFromScrollTop( currentScrollTop );\n            var firstItemBelowBottom = firstItemTopPosition > currentScrollTop + _visibleAreaHeight;\n            if( firstItemBelowBottom === true ) {\n                self.handleScroll();\n            } else if( firstItemTopPosition > calculateElementTopPosition( firstVisibleElem - extraVisibleRowCount ) ) {\n                var extraBlankRowsInView = firstItemIndex - firstVisibleElem;\n                extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n                var endCount = firstItemIndex - 1;\n\n                var startCount = endCount - extraVisibleRowCount - extraBlankRowsInView;\n                renderPageData( startCount, endCount );\n            }\n        } else {\n            self.handleScroll();\n        }\n    }\n\n    /**\n     * Sets up scrolling for trees while in edit mode\n     * @param {Boolean} isEditing if the table is in edit mode or not\n     */\n    self.setupTreeEditScroll = function( isEditing ) {\n        if( !isEditing ) {\n            if( settings.treeTableEditSettings ) {\n                // Find our current scroll position\n                var relativeIdx = settings.scrollViewportElem.scrollTop / self.getRowHeight();\n                var scrollTop = ( relativeIdx + settings.treeTableEditSettings.firstIndex - 1 ) * self.getRowHeight();\n                // Remove tree Edit settings\n                delete settings.treeTableEditSettings;\n                // Reset alignment/rows\n                self.updateRowAlignment();\n                self.handleScroll();\n                // Reset our scroll position to what we were at\n                settings.pinViewportElem.scrollTop = scrollTop;\n                settings.scrollViewportElem.scrollTop = scrollTop;\n            }\n            return;\n        }\n\n        // If no element in table, return\n        if( !rowElements || !rowElements[ 0 ] ) {\n            return;\n        }\n\n        // Find first row that contains data\n        var firstChildElem = rowElements[ 0 ];\n        var firstIndex = parseInt( firstChildElem.getAttribute( 'data-indexNumber' ) );\n        var hasProps = settings.loadedVMObjects[ firstIndex ].props;\n\n        while( hasProps && firstIndex > 0 ) {\n            hasProps = settings.loadedVMObjects[ firstIndex - 1 ].props;\n            if( hasProps ) {\n                firstIndex--;\n            }\n        }\n\n        // Find last row that contains data\n        var lastChildElem = rowElements[ rowElements.length - 1 ];\n        var lastIndex = parseInt( lastChildElem.getAttribute( 'data-indexNumber' ) );\n        hasProps = settings.loadedVMObjects[ lastIndex ].props;\n\n        while( hasProps && lastIndex < settings.totalFound - 1 ) {\n            hasProps = settings.loadedVMObjects[ lastIndex + 1 ].props;\n            if( hasProps ) {\n                lastIndex++;\n            }\n        }\n\n        settings.treeTableEditSettings = {\n            firstIndex: firstIndex,\n            lastIndex: lastIndex,\n            totalDataLength: lastIndex + 1\n        };\n\n        // update the container height\n        self.updateRowAlignment();\n    };\n\n    /**\n     *  Remove rows from lower-bound to upper-bound\n     *\n     * @param {Object} upperCountIdx - event\n     * @param {Object} lowerCounterIdx - event\n     */\n    function removeRows( upperCountIdx, lowerCounterIdx ) {\n        settings.removeRows( upperCountIdx, lowerCounterIdx );\n        rowElements = settings.scrollParentElem.querySelectorAll( settings.rowSelector );\n    }\n\n    /**\n     *  Resets infinite scroll back to a starting state\n     */\n    self.resetInfiniteScroll = function() {\n        self.setLoadedVMObjects( [] );\n        self.resetInitialRowIndex();\n        rowHeightCache = [];\n        settings.scrollViewportElem.scrollTop = 0;\n        settings.pinViewportElem.style.top = '0px';\n        settings.scrollViewportElem.style.top = '0px';\n        currentScrollTop = 0;\n        self.handleScroll();\n    };\n\n    /**\n     * Resets the row height cache\n     */\n    self.resetRowHeightCache = function() {\n        rowHeightCache = [];\n    };\n\n    /**\n     * Method to render rows\n     *\n     * @param {Number} startIndex Start render index\n     * @param {Number} endIndex End render Index\n     */\n    function renderRows( startIndex, endIndex ) {\n        settings.renderRows( startIndex, endIndex );\n        rowElements = settings.scrollParentElem.querySelectorAll( settings.rowSelector );\n        if( settings.dynamicRowHeightStatus ) {\n            // check if last value of rowHeightCache is in new set of rendered data, otherwise can cause off by 1.\n            let lastCacheIdx = rowHeightCache.length - 1;\n            let firstElemIdx = rowElements[ 0 ].getAttribute( 'data-indexnumber' );\n            let lastElemIdx = rowElements[ rowElements.length - 1 ].getAttribute( 'data-indexnumber' );\n\n            if( lastCacheIdx < firstElemIdx || lastCacheIdx > lastElemIdx ) {\n                // Delete last cache value to prevent off by 1 caused by margin\n                rowHeightCache[ rowHeightCache.length - 1 ] = null;\n            }\n            // Loop through rowElements to update row cache\n            for( let rowElement of rowElements ) {\n                let index = parseInt( rowElement.getAttribute( 'data-indexnumber' ) );\n                rowHeightCache[ index ] = rowElement.offsetHeight;\n            }\n        }\n    }\n\n    /**\n     * Method to render rows\n     *\n     * @param {int} startCount - event\n     * @param {int} endCount - event\n     * @param {int} removeAllChild - event\n     */\n    function renderPageData( startCount, endCount, removeAllChild ) {\n        var totalDataLength;\n        // Check if table is tree table and is editing\n        if( settings.treeTableEditSettings ) {\n            if( startCount < settings.treeTableEditSettings.firstIndex ) {\n                startCount = settings.treeTableEditSettings.firstIndex;\n            }\n\n            if( endCount > settings.treeTableEditSettings.lastIndex ) {\n                endCount = settings.treeTableEditSettings.lastIndex;\n            }\n            totalDataLength = settings.treeTableEditSettings.totalDataLength;\n        } else {\n            // Check to avoid negative indexing\n            if( startCount < 0 ) {\n                startCount = 0;\n            }\n            totalDataLength = settings.totalFound;\n        }\n\n        if( startCount >= totalDataLength ) {\n            if( totalDataLength === 0 ) {\n                // if collection becomes empty, then remove all the existing list rows\n                removeRows( rowElements.length - 1, 0 );\n                self.updateRowAlignment();\n            } else {\n                settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n                renderRows( startCount, endCount );\n            }\n\n            if( startCount === totalDataLength ) {\n                logger.trace( 'Table scroll service: Rendering of page data complete. No more data to render.' );\n                return;\n            }\n        }\n\n        // check to avoid wrong indexing for startCount\n        if( startCount > totalDataLength ) {\n            endCount -= startCount;\n            startCount = 0;\n        }\n\n        // check to avoid wrong indexing for endCount\n        if( endCount >= totalDataLength ) {\n            endCount = totalDataLength - 1;\n        }\n\n        if( removeAllChild ) {\n            // remove the elements from the dom tree.\n            removeRows( rowElements.length - 1, 0 );\n        }\n\n        renderRows( startCount, endCount );\n\n        self.updateRowAlignment();\n\n        afterGridRender();\n    }\n\n    /**\n     * Remove extra rows\n     */\n    function removeExtraRows() {\n        const rowParentElem = settings.scrollParentElem;\n        rowElements = rowParentElem.querySelectorAll( settings.rowSelector );\n\n        if( rowElements.length === 0 ) {\n            logger.error( 'Rendering error' );\n        } else {\n            let extraChildCount;\n            let invisibleRowsCount;\n            let invisibleRowsHeight;\n\n            const firstElem = rowElements[ 0 ];\n            const firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n            if( settings.treeTableEditSettings ) {\n                invisibleRowsHeight = ( firstRenderedItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight - currentScrollTop;\n            } else {\n                // Simply checking if there are invisible rows, actual height doesn't matter as is not used\n                invisibleRowsHeight = calculateElementTopPosition( firstRenderedItemIndex ) - currentScrollTop;\n            }\n            if( invisibleRowsHeight < 0 ) {\n                invisibleRowsCount = Math.abs( calculateElementIndexFromScrollTop( currentScrollTop ) - firstRenderedItemIndex );\n                extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n                if( extraChildCount > 0 ) {\n                    // remove the elements from the dom tree.\n                    removeRows( extraChildCount, 0 );\n                }\n            }\n\n            const lastElem = rowElements[ rowElements.length - 1 ];\n            const lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n            const visRowsHeight = visibleRowsCount * settings.rowHeight + currentScrollTop;\n            const lastVisibleRowIndex = calculateLastVisibleRowIndex();\n            if( settings.treeTableEditSettings ) {\n                invisibleRowsHeight = ( lastRenderedItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight + settings.rowHeight - visRowsHeight;\n            } else {\n                // Simply checking if there are invisible rows, so actual height doesn't matter here as it will not be used.\n                invisibleRowsHeight = lastRenderedItemIndex - lastVisibleRowIndex;\n            }\n            if( invisibleRowsHeight > 0 ) {\n                invisibleRowsCount = lastRenderedItemIndex - lastVisibleRowIndex;\n                extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n                if( extraChildCount > 0 ) {\n                    removeRows( rowElements.length - 1, rowElements.length - extraChildCount - 1 );\n                }\n            }\n        }\n        self.updateRowAlignment();\n    }\n\n    /**\n     * After grid rendered\n     */\n    function afterGridRender() {\n        var firstRenderedItemIndex = 0;\n        var lastRenderedItemIndex = 0;\n\n        var firstElem = rowElements[ 0 ];\n        firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n\n        var lastElem = rowElements[ rowElements.length - 1 ];\n        lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n\n        var firstRenderedItem = {\n            index: firstRenderedItemIndex,\n            uid: firstElem.vmo.uid,\n            levelNdx: firstElem.vmo.levelNdx\n        };\n\n        var lastRenderedItem = {\n            index: lastRenderedItemIndex,\n            uid: lastElem.vmo.uid,\n            levelNdx: lastElem.vmo.levelNdx\n        };\n\n        settings.afterGridRenderCallback( firstRenderedItem, lastRenderedItem );\n    }\n\n    self.destroyGrid = function() {\n        settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem && settings.pinViewportElem.removeEventListener( 'scroll', handlePinScrollEvent );\n        momentumScrolling.disable();\n        self.checkForResize.cancel();\n        horizontalScrollDebounceEvent.cancel();\n        verticalScrollDebounceEvent.cancel();\n    };\n\n    /**\n     * Scrolls to the given row\n     *\n     * @param {integer[]} rowIndexes Index to scroll to\n     * @returns {boolean} returns false if a row is in view\n     */\n    self.scrollToRowIndex = function( rowIndexes ) {\n        // Only scroll to row if it is out of view\n        if( self.isInitialized() === true ) {\n            var scrollToRowElementPosition = null;\n            var firstRowElementIndex = 0;\n            var lastIndexNumber = 0;\n            if( rowElements.length > 0 ) {\n                firstRowElementIndex = Number( rowElements[ 0 ].getAttribute( 'data-indexnumber' ) );\n                lastIndexNumber = Number( rowElements[ rowElements.length - 1 ].getAttribute( 'data-indexnumber' ) );\n            }\n\n            var scrollCanvasRect = settings.scrollViewportElem.getBoundingClientRect();\n            for( var i = 0; i < rowIndexes.length; i++ ) {\n                var rowIndex = rowIndexes[ i ];\n\n                if( rowElements.length > 0 ) {\n                    if( rowIndex > lastIndexNumber || rowIndex < firstRowElementIndex ) {\n                        initialRowIndex = rowIndex;\n                        continue;\n                    }\n\n                    scrollToRowElementPosition = rowElements[ rowIndex - firstRowElementIndex ].getBoundingClientRect();\n                    if( scrollToRowElementPosition.top < scrollCanvasRect.top || scrollToRowElementPosition.bottom > scrollCanvasRect.bottom ) {\n                        initialRowIndex = rowIndex;\n                        continue;\n                    }\n\n                    initialRowIndex = rowIndex;\n                }\n                return false;\n            }\n\n            // Check if attempting to scroll past maximum scrollTop, if so set flag\n            var maxScrollTop = settings.scrollViewportElem.scrollHeight - settings.scrollViewportElem.clientHeight;\n            var newScrollTop = Math.floor( calculateElementTopPosition( initialRowIndex ) - _visibleAreaHeight * 0.75 );\n            var initialRowIndexOnDom = initialRowIndex - firstRowElementIndex;\n\n            if( rowElements[ initialRowIndexOnDom ] ) {\n                scrollToRowElementPosition = rowElements[ initialRowIndexOnDom ].getBoundingClientRect();\n                if( scrollToRowElementPosition.top < scrollCanvasRect.top && scrollToRowElementPosition.bottom > scrollCanvasRect.top ) {\n                    newScrollTop = calculateElementTopPosition( initialRowIndex );\n                } else if( scrollToRowElementPosition.top < scrollCanvasRect.bottom && scrollToRowElementPosition.bottom > scrollCanvasRect.bottom ) {\n                    newScrollTop = settings.scrollViewportElem.scrollTop + ( scrollToRowElementPosition.bottom - scrollCanvasRect.bottom );\n                }\n            }\n\n            if( newScrollTop > maxScrollTop ) {\n                scrollToRowInProgress = true;\n                scrollToRowScrollTop = newScrollTop;\n            }\n            settings.scrollViewportElem.scrollTop = newScrollTop;\n        } else {\n            initialRowIndex = rowIndexes[ 0 ];\n        }\n\n        return true;\n    };\n\n    /**\n     * Scrolls to scroll container column\n     * @param {Object} column - The column to scroll to\n     */\n    self.scrollToColumn = function( column ) {\n        if( column.startPosition <= currentScrollLeft || column.startPosition > currentScrollLeft + scrollContainerWidth ) {\n            settings.scrollViewportElem.scrollLeft = column.startPosition - 10;\n        }\n    };\n\n    self.isInitialRowIndexInView = function() {\n        let firstRowElementIndex = Number( rowElements[ 0 ].getAttribute( 'data-indexnumber' ) );\n        let initialRowElement = rowElements[ initialRowIndex - firstRowElementIndex ];\n        if( initialRowElement === undefined ) {\n            return false;\n        }\n\n        let initialRowElementIndex = initialRowElement.getAttribute( 'data-indexnumber' );\n        let firstVisibleIndex = calculateElementIndexFromScrollTop( currentScrollTop );\n        let lastVisibleIndex = calculateLastVisibleRowIndex();\n\n        if( initialRowElementIndex < firstVisibleIndex || initialRowIndex > lastVisibleIndex ) {\n            return false;\n        }\n\n        return true;\n    };\n\n    /**\n     * Resets the initial row index to 0 so that infinite scroll service will\n     * start the rendering of rows at the top.\n     */\n    self.resetInitialRowIndex = function() {\n        initialRowIndex = 0;\n    };\n};\n\nexport default SPLMTableInfiniteScroll;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}