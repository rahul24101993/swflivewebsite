{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Module for condition/expression parser utilities\n *\n * @module js/expressionParserUtils\n */\nimport _ from 'lodash';\nimport parsingUtils from 'js/parsingUtils';\nimport dateParserUtils from 'js/dateParserUtils';\nimport Debug from 'debug';\nimport AwParseService from 'js/awParseService';\nvar trace = new Debug('expressionParserUtils');\nvar exports = {};\n/**\n * Reference to operators in expression objects\n */\n\nexport let $SOURCE = '$source';\nexport let $QUERY = '$query';\nexport let $ADAPT = '$adapt';\nexport let $ALL = '$all';\nexport let $AND = '$and';\nexport let $OR = '$or';\nexport let $EVENTSOURCE = '$eventSource';\nexport let $NOT = '$not';\n/**\n * Map used to point to the utility function name based on the expression\n */\n\nvar _map_expr2Function = {\n  $eq: 'equalTo',\n  $lt: 'lessThan',\n  $lte: 'lessThanOrEqualTo',\n  $gt: 'greaterThan',\n  $gte: 'greaterThanOrEqualTo',\n  $ne: 'notEqualTo',\n  $neq: 'notEqualsTo',\n  $in: 'within',\n  $notin: 'notIn',\n  $isNull: 'isNull',\n  $notNull: 'notNull',\n  $vlookup: 'vlookup',\n  $regexp: 'regexp',\n  $notinrange: 'notInRange',\n  $notinregexp: 'notInRegexp',\n  $typeOf: 'typeOf'\n};\n/**\n * Gets dbValue for a non array property.\n *\n * @param {Object} prop - property object\n *\n * @return {Object} dbValue of the property\n */\n\nvar _getDbValueForProp = function (prop) {\n  var propValue = null;\n\n  if (prop && prop.dbValue) {\n    propValue = prop.dbValue;\n  } else if (prop && prop.dbValues && prop.dbValues.length > 0) {\n    propValue = prop.dbValues[0];\n  }\n\n  return propValue;\n};\n/**\n * Traverses given path in the received object and returns the value\n * @param {String} path dot separated path\n * @param {Object} obj object to be traversed for finding the value against received path\n *\n * @return {Object} returns object as resolved by traversing the path inside the object\n */\n\n\nexport let resolve = function (path, obj) {\n  var resolvedObj;\n\n  if (path && _.isString(path) && obj && _.isObject(obj)) {\n    resolvedObj = path.split('.').reduce(function (prev, curr) {\n      return prev ? prev = _.get(prev, curr) : undefined;\n    }, obj);\n  }\n\n  return resolvedObj;\n};\n/**\n * Update dynamic values against the query operator. Ex: \"$eq\": \"{{ctx.selected.props.object_string.dbValues[0]}}\"\n * @param {Object} query Object containing operator as key and value that needs to be resolved from data node\n * @param {Object} dataNode Object used to resolve the values\n * @return {Object} updated query\n */\n\nexport let updateDynamicValues = function (query, dataNode) {\n  // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n  // Do copy only at level 0\n  // LCS-168813 - AW404-Comparison use cases fails as color swab is not made available\n  // _.clone( var, true ) is not in lodash any more...we should use _.cloneDeep\n  // there are still several usage for _.clone(var, true), it gets copied here and that\n  // is why we cause the regression.\n  var updatedQuery = _.cloneDeep(query);\n\n  return updateDynamicValuesInternal(updatedQuery, dataNode);\n};\n/**\n *get expression data type\n *\n * @param {object} value - date object\n *\n * @return {String} dataType like - date,string,number\n */\n\nexport let getExpressionDataType = function (value) {\n  try {\n    var dataType;\n\n    if (value) {\n      if (dateParserUtils.isDate(value)) {\n        dataType = 'Date';\n      } else if (_.isNumber(value[0]) && _.isNumber(value[1])) {\n        dataType = 'Number';\n      } else if (_.isString(value[0]) && _.isString(value[1])) {\n        dataType = 'String';\n      }\n    }\n\n    return dataType;\n  } catch (e) {\n    trace('Error in expression', e, value);\n    return undefined;\n  }\n};\n\nvar updateDynamicValuesInternal = function (updatedQuery, dataNode) {\n  var expression = {};\n  var expressionDataType;\n\n  _.forEach(updatedQuery, function (value, key) {\n    if (key === '$notinrange' || dateParserUtils.isDate(value)) {\n      expressionDataType = exports.getExpressionDataType(value);\n\n      if (expressionDataType) {\n        expression = dateParserUtils.getExpressionDateValue(value, expressionDataType);\n        updatedQuery.expressionType = expressionDataType;\n        value = expression.value;\n        updatedQuery[key] = expression.value;\n      }\n    }\n\n    if (_.isString(value) && _.startsWith(value, '{{')) {\n      var dynamicValToResolve = parsingUtils.getStringBetweenDoubleMustaches(value);\n      updatedQuery[key] = exports.resolve(dynamicValToResolve, dataNode);\n    } else if (_.isObject(value)) {\n      updatedQuery[key] = exports.updateDynamicValues(value, dataNode);\n    }\n  });\n\n  return updatedQuery;\n};\n/**\n * Evaluates eventSource expression\n * @param {Object} exp eventSource expression\n * @param {Object} contextObj context object\n * @return {Boolean} verdict of expression evaluation\n */\n\n\nexport let evaluateEventSourceExpression = function (exp, contextObj) {\n  let eventSourceVal = exp[exports.$EVENTSOURCE];\n  let evalResult = false;\n\n  if (contextObj && contextObj.data && contextObj._source) {\n    let {\n      data,\n      _source\n    } = contextObj; // need to check self/view-id/view-name\n\n    if (_source === data._internal.modelId && (eventSourceVal === 'self' || eventSourceVal === data._internal.viewId || eventSourceVal === data._internal.panelId)) {\n      evalResult = true;\n    }\n  }\n\n  return evalResult;\n};\n\nlet checkOperatorResult = function (performAND, performOR, performNOT, evalCheckResult, result) {\n  if (performAND) {\n    return evalCheckResult && result;\n  } else if (performOR) {\n    return evalCheckResult || result;\n  } else if (performNOT) {\n    return !result;\n  }\n\n  return result;\n};\n/**\n * Evaluates checks using expression parser utils\n * @param {Object} query Object definition containing query details to be evaluated on received object\n * @param {Array} objects Array of objects against which the query needs to be evaluated\n * @param {Object} adapterSvc Adapter service\n * @return {Boolean} verdict of expression evaluation\n */\n\n\nexport let evaluateExpressions = function (query, objects, adapterSvc) {\n  var newValue = false;\n  var queryToUse = query;\n  var values = objects;\n\n  if (!_.isArray(objects)) {\n    values = [objects];\n  } // determine whether all or atleast one result(s) should match\n\n\n  var matchAll = queryToUse[exports.$ALL]; // fetch the inner query that is value of $all\n\n  queryToUse = matchAll || queryToUse; // evaluate the check on each of the value\n\n  newValue = values.reduce(function (valReduceResult, value) {\n    // determine existence of multiple checks against same source inside the query\n    var performAND = queryToUse[exports.$AND] || queryToUse[exports.$ALL];\n    var performOR = queryToUse[exports.$OR];\n    var performNOT = queryToUse[exports.$NOT]; // create array of checks to be evaluated on the source\n\n    var evalChecks = performAND || performOR || [queryToUse];\n    evalChecks = performNOT ? [performNOT] : evalChecks;\n    var verdict = evalChecks.reduce(function (evalCheckResult, evalCheck) {\n      var path = exports.resolve(exports.$SOURCE, evalCheck); // path i.e. $source can optionally have $adapt indicating the propValue needs to be adapted before use\n\n      var shouldAdapt = path && path[exports.$ADAPT];\n      path = shouldAdapt || path;\n\n      if (!path && evalCheck && evalCheck[exports.$EVENTSOURCE]) {\n        const evalResult = evaluateEventSourceExpression(evalCheck, value);\n        return checkOperatorResult(performAND, performOR, performNOT, evalCheckResult, evalResult);\n      }\n\n      var condition = exports.resolve(exports.$QUERY, evalCheck) || evalCheck;\n      var propValue = path ? exports.resolve(path, value) : value;\n\n      if (evalCheck.__useSourceParsing) {\n        propValue = AwParseService.instance(path)(value);\n      }\n\n      if (shouldAdapt) {\n        var valuesToAdapt = _.isArray(propValue) ? propValue : [propValue];\n        propValue = adapterSvc.getAdaptedObjectsSync(valuesToAdapt);\n      } // determine whether the query has nested queries with $all / $and / $or / $source\n\n\n      var recurseExpressionEvaluation = condition && (condition[exports.$NOT] || condition[exports.$ALL] || condition[exports.$AND] || condition[exports.$OR] || condition[exports.$SOURCE]);\n      var result;\n\n      if (recurseExpressionEvaluation) {\n        result = exports.evaluateExpressions(condition, propValue, adapterSvc);\n      } else {\n        result = exports.evaluateConditionExpression(condition, null, propValue);\n      }\n\n      return checkOperatorResult(performAND, performOR, performNOT, evalCheckResult, result);\n    }, performAND);\n    return matchAll ? valReduceResult && verdict : valReduceResult || verdict;\n  }, matchAll);\n  /**  When query contains nested $all and the values object is empty it returns the matAll query back to parseExpression API\n   *   which converts it to boolean ie. true and gives wrong output\n   *   for example\n   *   {\n   *      \"$source\": \"ctx.mselected\",\n   *      \"$query\":{\n   *         \"$all\":{\n   *            \"$source\":\"moduleType.typeHierarchyArray\",\n   *            \"$query\":{\n   *               \"$in\":[\n   *                   \"ItemRevision\"\n   *               ]\n   *            }\n   *         }\n   *       }\n   *   }\n   *   In this case is ctx.mselected is empty array i.e no selection in UI then above query returns true.\n   *   Below is the fix for the same.\n   */\n\n  return values.length === 0 && matchAll ? false : newValue;\n};\n/**\n * Evaluate conditions eg. 1. \"conditions\": { \"subscriptionId\": { \"$eq\": \"{{uid}}\" } } eg. 2. \"conditions\": {\n * \"object_desc\": { \"$eq\": \"Plane\" }, \"object_name\": { \"$eq\": \"Plane001\" } }\n *\n * @param {Object} conditions - map of conditions\n * @param { Object } vmoObj - view model object properties map\n * @return {Boolean} TRUE if all conditions are valid\n */\n\nexport let evaluateConditions = function (conditions, vmoObj) {\n  var isValid = true;\n  var vmoProps = vmoObj.props;\n\n  for (var propName in conditions) {\n    if (conditions[propName]) {\n      if (_.isObject(conditions[propName])) {\n        var condition = conditions[propName];\n        var vmoProp = vmoProps[propName];\n\n        var propValue = _getDbValueForProp(vmoProp);\n\n        var compareTo = {};\n\n        for (var key in condition) {\n          var value = condition[key];\n          var propKey = propName + '@' + key;\n\n          if (_.startsWith(value, '{{')) {\n            var propToCompare = parsingUtils.getStringBetweenDoubleMustaches(value);\n            var prop = vmoProps[propToCompare];\n\n            if (!prop) {\n              compareTo[propKey] = vmoObj[propToCompare];\n            } else {\n              compareTo[propKey] = _getDbValueForProp(prop);\n            }\n          } else {\n            compareTo[propKey] = value;\n          }\n        }\n\n        isValid = exports.evaluateConditionExpression(condition, propName, propValue, compareTo);\n      } else {\n        isValid = false;\n      }\n    } // break if even one condition is invalid\n\n\n    if (!isValid) {\n      break;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluate condition expression\n *\n * @param {Object} condition - condition object\n * @param {Object} propName - property name\n * @param {Object} propValue - real value of the property\n * @param {Object} compareTo - real value of the property\n * @return {Boolean} TRUE if conditions are valid\n */\n\nexport let evaluateConditionExpression = function (condition, propName, propValue, compareTo) {\n  var isValid = false;\n  var resolvedPropValue = null;\n\n  if (condition) {\n    for (var key in condition) {\n      if (key !== 'expressionType') {\n        if (_.startsWith(key, '$') && _.has(_map_expr2Function, key)) {\n          var functionName = _map_expr2Function[key];\n\n          if (_.startsWith(condition[key], '{{')) {\n            resolvedPropValue = compareTo[propName + '@' + key];\n          } else {\n            resolvedPropValue = condition[key];\n          }\n\n          if (condition.expressionType === 'Date' && propValue && resolvedPropValue) {\n            var parsedDates = dateParserUtils.getParsedDates(propValue, resolvedPropValue);\n            resolvedPropValue = parsedDates.queryDate;\n            propValue = parsedDates.sourceDate;\n          }\n\n          isValid = exports[functionName](resolvedPropValue, propValue, condition.expressionType);\n        } else {\n          isValid = false;\n        }\n      }\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let equalTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() === propValue.toString();\n  } else {\n    isValid = condValue === propValue;\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether viewmodel property is of a particular type .\n *\n * @param {Object} vmo - viewmodel object\n * @param {String} type - type of property.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let typeOf = function (type, vmo) {\n  var typeHieararchyArray = [];\n\n  if (vmo) {\n    if (vmo.modelType && _.isArray(vmo.modelType.typeHierarchyArray)) {\n      typeHieararchyArray = vmo.modelType.typeHierarchyArray;\n    } else if (_.isArray(vmo.typeHierarchy)) {\n      typeHieararchyArray = vmo.typeHierarchy;\n    } else if (vmo.type) {\n      typeHieararchyArray = vmo.type;\n    }\n  }\n\n  return typeHieararchyArray.includes(type);\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let within = function (condValue, propValue) {\n  var isValid = false;\n  var testValue = _.isArray(propValue) ? propValue : [propValue];\n  var values = _.isArray(condValue) ? condValue : [condValue];\n  isValid = values.some(function (value) {\n    return _.indexOf(testValue, value) >= 0;\n  });\n  return isValid;\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let notInRange = function (condValue, propValue, type) {\n  var isNotInRange = false;\n  var isConditionValid = false;\n\n  if (condValue && condValue.length === 2 && propValue && type) {\n    var conditionLeft = condValue[0];\n    var conditionRight = condValue[1];\n\n    switch (type) {\n      case 'Date':\n        if (_.isFinite(conditionLeft) && _.isFinite(conditionRight) && _.isFinite(propValue)) {\n          isConditionValid = true;\n        }\n\n        break;\n\n      case 'Number':\n        conditionLeft = Number(conditionLeft);\n        conditionRight = Number(conditionRight);\n        propValue = Number(propValue);\n        isConditionValid = true;\n        break;\n\n      case 'String':\n        conditionLeft = conditionLeft.toString();\n        conditionRight = conditionRight.toString();\n        isConditionValid = true;\n        break;\n    }\n\n    if (isConditionValid && conditionLeft > propValue || conditionRight < propValue) {\n      isNotInRange = true;\n    }\n  }\n\n  return isNotInRange;\n};\n/**\n * Evaluating whether property value is not in the condition value array.\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition values do not contain property value\n */\n\nexport let notIn = function (condValue, propValue) {\n  var verdict = exports.within(condValue, propValue);\n  return !verdict;\n};\n/**\n * Evaluating whether condition value is less than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than condition value\n */\n\nexport let lessThan = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn < condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is less than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than or equal to condition value\n */\n\nexport let lessThanOrEqualTo = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn <= condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is greater than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than condition value\n */\n\nexport let greaterThan = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn > condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is greater than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than or equal to condition value\n */\n\nexport let greaterThanOrEqualTo = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn >= condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let notEqualTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() !== propValue.toString();\n  } else {\n    isValid = condValue !== propValue;\n  }\n\n  return isValid;\n};\n/**\n * Applicable for validation criteria -  Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let notEqualsTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() !== propValue.toString();\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\n\nexport let regexp = function (condValue, propValue) {\n  var isValid = false;\n  var regexp;\n  var value = propValue ? String(propValue) : '';\n\n  if (_.isString(condValue)) {\n    regexp = new RegExp(condValue);\n  } else if (_.isObject(condValue) && condValue.$pattern) {\n    try {\n      regexp = new RegExp(condValue.$pattern, condValue.$options);\n    } catch (err) {\n      // Invalid options\n      isValid = false;\n    }\n  }\n\n  if (regexp) {\n    isValid = regexp.test(value);\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\n\nexport let notInRegexp = function (condValue, propValue) {\n  if (condValue && propValue) {\n    return !exports.regexp(condValue, propValue);\n  }\n\n  return false;\n};\n/**\n * Enables looking up a value in given range and matching another value with the value at the same index but\n * different column in the range\n *\n * Example: Range is an array of arrays where first array holds objects and second array holds array of values.\n * range : [\n *   [ {\"uid\":\"v1\"}, {\"uid\":\"v11\"}, {\"uid\":\"v111\"} ],\n *   [ [\"color1\"], [\"color2\"], [\"color3\"] ]\n * }\n *\n * Calling vlookup with following inputs will return true:\n * vlookupInput = {\n *  \"lookupValue\" : \"v11\",\n *  \"lookupValueKey\" : \"uid\",\n *  \"matchKey\" : 1,\n *  \"matchValue\": \"color2\"\n * }\n * vlookup( vlookupInput, range ) :: returns true\n *\n * @param {Object} vlookupInput - Javascript object holding the lookupValue, lookupValueKey, matchKey and matchValue\n * @param {Object} range -        Javascript object with each value as array of string/int/boolean or objects OR\n *                                    array of string/int/boolean or object arrays\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let vlookup = function (vlookupInput, range) {\n  var lookupValueKey = vlookupInput.lookupValueKey;\n  var lookupValue = vlookupInput.lookupValue;\n  var matchKey = vlookupInput.matchKey;\n  var matchValue = vlookupInput.matchValue;\n  var valToMatchFromRange; // determine the lookup strategy based on type of range object\n\n  if (_.isArray(range)) {\n    // range is an array of arrays\n    var matchIndex = -1;\n\n    _.forEach(range, function (value) {\n      var values = _.isArray(value) ? value : [value];\n\n      _.forEach(values, function (currVal, arrPos) {\n        if (currVal) {\n          var lookupValToMatch = lookupValueKey ? currVal[lookupValueKey] : currVal;\n\n          if (lookupValue === lookupValToMatch) {\n            matchIndex = arrPos;\n            return false;\n          }\n        }\n\n        return undefined;\n      });\n\n      if (matchIndex > -1) {\n        valToMatchFromRange = matchKey ? range[matchKey][matchIndex] : Object.keys(range)[matchIndex];\n        valToMatchFromRange = valToMatchFromRange && _.isArray(valToMatchFromRange) && valToMatchFromRange.length > 0 ? valToMatchFromRange[0] : valToMatchFromRange;\n        return false;\n      }\n\n      return undefined;\n    });\n  } else {\n    // range is an object with key value pair\n    _.forEach(range, function (value, key) {\n      if (key === lookupValue) {\n        valToMatchFromRange = value;\n        return false;\n      }\n\n      return undefined;\n    });\n  }\n\n  return valToMatchFromRange === matchValue;\n};\n/* Gets eval function to cache for quicker evals in future */\n\n/**\n *\n * @param {String} condKey - $in\n * @param {String} propKey - modelType.typeHierarchy\n */\n\nexport let getEvaluationFn = function (condKey, propKey) {\n  if (condKey[0] === '$') {\n    return exports[_map_expr2Function[condKey]];\n  }\n\n  return function () {\n    return false;\n  };\n};\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\n\nexport let isNull = function (condValue, propValue) {\n  return !propValue;\n};\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\n\nexport let notNull = function (condValue, propValue) {\n  return !exports.isNull(condValue, propValue);\n};\nexports = {\n  $SOURCE,\n  $QUERY,\n  $ADAPT,\n  $ALL,\n  $AND,\n  $OR,\n  $EVENTSOURCE,\n  $NOT,\n  resolve,\n  updateDynamicValues,\n  evaluateExpressions,\n  evaluateConditions,\n  evaluateConditionExpression,\n  evaluateEventSourceExpression,\n  equalTo,\n  within,\n  notInRange,\n  notIn,\n  lessThan,\n  lessThanOrEqualTo,\n  greaterThan,\n  greaterThanOrEqualTo,\n  notEqualTo,\n  notEqualsTo,\n  regexp,\n  notInRegexp,\n  vlookup,\n  isNull,\n  notNull,\n  getExpressionDataType,\n  typeOf,\n  getEvaluationFn\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/expressionParserUtils.js"],"names":["trace","exports","$SOURCE","$QUERY","$ADAPT","$ALL","$AND","$OR","$EVENTSOURCE","$NOT","_map_expr2Function","$eq","$lt","$lte","$gt","$gte","$ne","$neq","$in","$notin","$isNull","$notNull","$vlookup","$regexp","$notinrange","$notinregexp","$typeOf","_getDbValueForProp","propValue","prop","resolve","path","_","resolvedObj","prev","updateDynamicValues","updatedQuery","updateDynamicValuesInternal","getExpressionDataType","dateParserUtils","dataType","value","expression","key","expressionDataType","dynamicValToResolve","parsingUtils","evaluateEventSourceExpression","eventSourceVal","exp","evalResult","contextObj","_source","data","checkOperatorResult","evalCheckResult","evaluateExpressions","newValue","queryToUse","values","matchAll","performAND","performOR","performNOT","evalChecks","verdict","shouldAdapt","evalCheck","condition","AwParseService","valuesToAdapt","adapterSvc","recurseExpressionEvaluation","result","valReduceResult","evaluateConditions","isValid","vmoProps","vmoObj","conditions","vmoProp","compareTo","propKey","propName","propToCompare","evaluateConditionExpression","resolvedPropValue","functionName","parsedDates","equalTo","condValue","typeOf","typeHieararchyArray","vmo","within","testValue","notInRange","isNotInRange","isConditionValid","conditionLeft","conditionRight","Number","notIn","lessThan","condValueIn","propValueIn","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","notEqualTo","notEqualsTo","regexp","String","notInRegexp","vlookup","lookupValueKey","vlookupInput","lookupValue","matchKey","matchValue","matchIndex","lookupValToMatch","currVal","valToMatchFromRange","range","Object","getEvaluationFn","condKey","isNull","notNull"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Module for condition/expression parser utilities\n *\n * @module js/expressionParserUtils\n */\nimport _ from 'lodash';\nimport parsingUtils from 'js/parsingUtils';\nimport dateParserUtils from 'js/dateParserUtils';\nimport Debug from 'debug';\nimport AwParseService from 'js/awParseService';\n\nvar trace = new Debug( 'expressionParserUtils' );\nvar exports = {};\n\n/**\n * Reference to operators in expression objects\n */\n\nexport let $SOURCE = '$source';\nexport let $QUERY = '$query';\nexport let $ADAPT = '$adapt';\nexport let $ALL = '$all';\nexport let $AND = '$and';\nexport let $OR = '$or';\nexport let $EVENTSOURCE = '$eventSource';\nexport let $NOT = '$not';\n\n/**\n * Map used to point to the utility function name based on the expression\n */\nvar _map_expr2Function = {\n    $eq: 'equalTo',\n    $lt: 'lessThan',\n    $lte: 'lessThanOrEqualTo',\n    $gt: 'greaterThan',\n    $gte: 'greaterThanOrEqualTo',\n    $ne: 'notEqualTo',\n    $neq: 'notEqualsTo',\n    $in: 'within',\n    $notin: 'notIn',\n    $isNull: 'isNull',\n    $notNull: 'notNull',\n    $vlookup: 'vlookup',\n    $regexp: 'regexp',\n    $notinrange: 'notInRange',\n    $notinregexp: 'notInRegexp',\n    $typeOf: 'typeOf'\n};\n\n/**\n * Gets dbValue for a non array property.\n *\n * @param {Object} prop - property object\n *\n * @return {Object} dbValue of the property\n */\nvar _getDbValueForProp = function( prop ) {\n    var propValue = null;\n    if( prop && prop.dbValue ) {\n        propValue = prop.dbValue;\n    } else if( prop && prop.dbValues && prop.dbValues.length > 0 ) {\n        propValue = prop.dbValues[ 0 ];\n    }\n\n    return propValue;\n};\n\n/**\n * Traverses given path in the received object and returns the value\n * @param {String} path dot separated path\n * @param {Object} obj object to be traversed for finding the value against received path\n *\n * @return {Object} returns object as resolved by traversing the path inside the object\n */\nexport let resolve = function( path, obj ) {\n    var resolvedObj;\n    if( path && _.isString( path ) && obj && _.isObject( obj ) ) {\n        resolvedObj = path.split( '.' ).reduce( function( prev, curr ) {\n            return prev ? prev = _.get( prev, curr ) : undefined;\n        }, obj );\n    }\n\n    return resolvedObj;\n};\n\n/**\n * Update dynamic values against the query operator. Ex: \"$eq\": \"{{ctx.selected.props.object_string.dbValues[0]}}\"\n * @param {Object} query Object containing operator as key and value that needs to be resolved from data node\n * @param {Object} dataNode Object used to resolve the values\n * @return {Object} updated query\n */\nexport let updateDynamicValues = function( query, dataNode ) {\n    // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n    // Do copy only at level 0\n    // LCS-168813 - AW404-Comparison use cases fails as color swab is not made available\n    // _.clone( var, true ) is not in lodash any more...we should use _.cloneDeep\n    // there are still several usage for _.clone(var, true), it gets copied here and that\n    // is why we cause the regression.\n    var updatedQuery = _.cloneDeep( query );\n    return updateDynamicValuesInternal( updatedQuery, dataNode );\n};\n\n/**\n *get expression data type\n *\n * @param {object} value - date object\n *\n * @return {String} dataType like - date,string,number\n */\nexport let getExpressionDataType = function( value ) {\n    try {\n        var dataType;\n        if( value ) {\n            if( dateParserUtils.isDate( value ) ) {\n                dataType = 'Date';\n            } else if( _.isNumber( value[ 0 ] ) && _.isNumber( value[ 1 ] ) ) {\n                dataType = 'Number';\n            } else if( _.isString( value[ 0 ] ) && _.isString( value[ 1 ] ) ) {\n                dataType = 'String';\n            }\n        }\n        return dataType;\n    } catch ( e ) {\n        trace( 'Error in expression', e, value );\n        return undefined;\n    }\n};\n\nvar updateDynamicValuesInternal = function( updatedQuery, dataNode ) {\n    var expression = {};\n    var expressionDataType;\n    _.forEach( updatedQuery, function( value, key ) {\n        if( key === '$notinrange' || dateParserUtils.isDate( value ) ) {\n            expressionDataType = exports.getExpressionDataType( value );\n            if( expressionDataType ) {\n                expression = dateParserUtils.getExpressionDateValue( value, expressionDataType );\n                updatedQuery.expressionType = expressionDataType;\n                value = expression.value;\n                updatedQuery[ key ] = expression.value;\n            }\n        }\n\n        if( _.isString( value ) && _.startsWith( value, '{{' ) ) {\n            var dynamicValToResolve = parsingUtils.getStringBetweenDoubleMustaches( value );\n            updatedQuery[ key ] = exports.resolve( dynamicValToResolve, dataNode );\n        } else if( _.isObject( value ) ) {\n            updatedQuery[ key ] = exports.updateDynamicValues( value, dataNode );\n        }\n    } );\n    return updatedQuery;\n};\n\n/**\n * Evaluates eventSource expression\n * @param {Object} exp eventSource expression\n * @param {Object} contextObj context object\n * @return {Boolean} verdict of expression evaluation\n */\nexport let evaluateEventSourceExpression = function( exp, contextObj ) {\n    let eventSourceVal = exp[ exports.$EVENTSOURCE ];\n    let evalResult = false;\n    if( contextObj && contextObj.data && contextObj._source ) {\n        let { data, _source } = contextObj;\n        // need to check self/view-id/view-name\n        if( _source === data._internal.modelId && ( eventSourceVal === 'self' || eventSourceVal === data._internal.viewId || eventSourceVal === data._internal.panelId ) ) {\n            evalResult = true;\n        }\n    }\n    return evalResult;\n};\n\nlet checkOperatorResult = function( performAND, performOR, performNOT, evalCheckResult, result ) {\n    if( performAND ) {\n        return evalCheckResult && result;\n    } else if( performOR ) {\n        return evalCheckResult || result;\n    } else if( performNOT ) {\n        return !result;\n    }\n    return result;\n};\n\n/**\n * Evaluates checks using expression parser utils\n * @param {Object} query Object definition containing query details to be evaluated on received object\n * @param {Array} objects Array of objects against which the query needs to be evaluated\n * @param {Object} adapterSvc Adapter service\n * @return {Boolean} verdict of expression evaluation\n */\nexport let evaluateExpressions = function( query, objects, adapterSvc ) {\n    var newValue = false;\n    var queryToUse = query;\n    var values = objects;\n    if( !_.isArray( objects ) ) {\n        values = [ objects ];\n    }\n    // determine whether all or atleast one result(s) should match\n    var matchAll = queryToUse[ exports.$ALL ];\n\n    // fetch the inner query that is value of $all\n    queryToUse = matchAll || queryToUse;\n\n    // evaluate the check on each of the value\n    newValue = values.reduce( function( valReduceResult, value ) {\n        // determine existence of multiple checks against same source inside the query\n        var performAND = queryToUse[ exports.$AND ] || queryToUse[ exports.$ALL ];\n        var performOR = queryToUse[ exports.$OR ];\n        var performNOT = queryToUse[ exports.$NOT ];\n\n        // create array of checks to be evaluated on the source\n        var evalChecks = performAND || performOR || [ queryToUse ];\n        evalChecks = performNOT ? [ performNOT ] : evalChecks;\n        var verdict = evalChecks.reduce( function( evalCheckResult, evalCheck ) {\n            var path = exports.resolve( exports.$SOURCE, evalCheck );\n            // path i.e. $source can optionally have $adapt indicating the propValue needs to be adapted before use\n            var shouldAdapt = path && path[ exports.$ADAPT ];\n            path = shouldAdapt || path;\n\n            if( !path && evalCheck && evalCheck[ exports.$EVENTSOURCE ] ) {\n                const evalResult = evaluateEventSourceExpression( evalCheck, value );\n                return checkOperatorResult( performAND, performOR, performNOT, evalCheckResult, evalResult );\n            }\n\n            var condition = exports.resolve( exports.$QUERY, evalCheck ) || evalCheck;\n            var propValue = path ? exports.resolve( path, value ) : value;\n            if( evalCheck.__useSourceParsing ) {\n                propValue = AwParseService.instance( path )( value );\n            }\n\n            if( shouldAdapt ) {\n                var valuesToAdapt = _.isArray( propValue ) ? propValue : [ propValue ];\n                propValue = adapterSvc.getAdaptedObjectsSync( valuesToAdapt );\n            }\n\n            // determine whether the query has nested queries with $all / $and / $or / $source\n            var recurseExpressionEvaluation = condition && ( condition[ exports.$NOT ] ||\n                condition[ exports.$ALL ] || condition[ exports.$AND ] || condition[ exports.$OR ] || condition[ exports.$SOURCE ] );\n            var result;\n            if( recurseExpressionEvaluation ) {\n                result = exports.evaluateExpressions( condition, propValue, adapterSvc );\n            } else {\n                result = exports.evaluateConditionExpression( condition, null, propValue );\n            }\n\n            return checkOperatorResult( performAND, performOR, performNOT, evalCheckResult, result );\n        }, performAND );\n\n        return matchAll ? valReduceResult && verdict : valReduceResult || verdict;\n    }, matchAll );\n    /**  When query contains nested $all and the values object is empty it returns the matAll query back to parseExpression API\n     *   which converts it to boolean ie. true and gives wrong output\n     *   for example\n     *   {\n     *      \"$source\": \"ctx.mselected\",\n     *      \"$query\":{\n     *         \"$all\":{\n     *            \"$source\":\"moduleType.typeHierarchyArray\",\n     *            \"$query\":{\n     *               \"$in\":[\n     *                   \"ItemRevision\"\n     *               ]\n     *            }\n     *         }\n     *       }\n     *   }\n     *   In this case is ctx.mselected is empty array i.e no selection in UI then above query returns true.\n     *   Below is the fix for the same.\n     */\n    return values.length === 0 && matchAll ? false : newValue;\n};\n\n/**\n * Evaluate conditions eg. 1. \"conditions\": { \"subscriptionId\": { \"$eq\": \"{{uid}}\" } } eg. 2. \"conditions\": {\n * \"object_desc\": { \"$eq\": \"Plane\" }, \"object_name\": { \"$eq\": \"Plane001\" } }\n *\n * @param {Object} conditions - map of conditions\n * @param { Object } vmoObj - view model object properties map\n * @return {Boolean} TRUE if all conditions are valid\n */\nexport let evaluateConditions = function( conditions, vmoObj ) {\n    var isValid = true;\n    var vmoProps = vmoObj.props;\n    for( var propName in conditions ) {\n        if( conditions[ propName ] ) {\n            if( _.isObject( conditions[ propName ] ) ) {\n                var condition = conditions[ propName ];\n                var vmoProp = vmoProps[ propName ];\n                var propValue = _getDbValueForProp( vmoProp );\n\n                var compareTo = {};\n                for( var key in condition ) {\n                    var value = condition[ key ];\n\n                    var propKey = propName + '@' + key;\n                    if( _.startsWith( value, '{{' ) ) {\n                        var propToCompare = parsingUtils.getStringBetweenDoubleMustaches( value );\n                        var prop = vmoProps[ propToCompare ];\n                        if( !prop ) {\n                            compareTo[ propKey ] = vmoObj[ propToCompare ];\n                        } else {\n                            compareTo[ propKey ] = _getDbValueForProp( prop );\n                        }\n                    } else {\n                        compareTo[ propKey ] = value;\n                    }\n                }\n\n                isValid = exports.evaluateConditionExpression( condition, propName, propValue, compareTo );\n            } else {\n                isValid = false;\n            }\n        }\n        // break if even one condition is invalid\n        if( !isValid ) {\n            break;\n        }\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {Object} condition - condition object\n * @param {Object} propName - property name\n * @param {Object} propValue - real value of the property\n * @param {Object} compareTo - real value of the property\n * @return {Boolean} TRUE if conditions are valid\n */\nexport let evaluateConditionExpression = function( condition, propName, propValue, compareTo ) {\n    var isValid = false;\n    var resolvedPropValue = null;\n\n    if( condition ) {\n        for( var key in condition ) {\n            if( key !== 'expressionType' ) {\n                if( _.startsWith( key, '$' ) && _.has( _map_expr2Function, key ) ) {\n                    var functionName = _map_expr2Function[ key ];\n                    if( _.startsWith( condition[ key ], '{{' ) ) {\n                        resolvedPropValue = compareTo[ propName + '@' + key ];\n                    } else {\n                        resolvedPropValue = condition[ key ];\n                    }\n                    if( condition.expressionType === 'Date' && propValue && resolvedPropValue ) {\n                        var parsedDates = dateParserUtils.getParsedDates( propValue, resolvedPropValue );\n                        resolvedPropValue = parsedDates.queryDate;\n                        propValue = parsedDates.sourceDate;\n                    }\n                    isValid = exports[ functionName ]( resolvedPropValue, propValue, condition.expressionType );\n                } else {\n                    isValid = false;\n                }\n            }\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\nexport let equalTo = function( condValue, propValue ) {\n    var isValid = false;\n    if( condValue && propValue ) {\n        isValid = condValue.toString() === propValue.toString();\n    } else {\n        isValid = condValue === propValue;\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether viewmodel property is of a particular type .\n *\n * @param {Object} vmo - viewmodel object\n * @param {String} type - type of property.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let typeOf = function( type, vmo ) {\n    var typeHieararchyArray = [];\n    if( vmo ) {\n        if( vmo.modelType && _.isArray( vmo.modelType.typeHierarchyArray ) ) {\n            typeHieararchyArray = vmo.modelType.typeHierarchyArray;\n        } else if( _.isArray( vmo.typeHierarchy ) ) {\n            typeHieararchyArray = vmo.typeHierarchy;\n        } else if( vmo.type ) {\n            typeHieararchyArray = vmo.type;\n        }\n    }\n\n    return typeHieararchyArray.includes( type );\n};\n\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let within = function( condValue, propValue ) {\n    var isValid = false;\n    var testValue = _.isArray( propValue ) ? propValue : [ propValue ];\n    var values = _.isArray( condValue ) ? condValue : [ condValue ];\n    isValid = values.some( function( value ) {\n        return _.indexOf( testValue, value ) >= 0;\n    } );\n    return isValid;\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let notInRange = function( condValue, propValue, type ) {\n    var isNotInRange = false;\n    var isConditionValid = false;\n\n    if( condValue && condValue.length === 2 && propValue && type ) {\n        var conditionLeft = condValue[ 0 ];\n        var conditionRight = condValue[ 1 ];\n        switch ( type ) {\n            case 'Date':\n                if( _.isFinite( conditionLeft ) && _.isFinite( conditionRight ) && _.isFinite( propValue ) ) {\n                    isConditionValid = true;\n                }\n                break;\n\n            case 'Number':\n                conditionLeft = Number( conditionLeft );\n                conditionRight = Number( conditionRight );\n                propValue = Number( propValue );\n                isConditionValid = true;\n                break;\n\n            case 'String':\n                conditionLeft = conditionLeft.toString();\n                conditionRight = conditionRight.toString();\n                isConditionValid = true;\n                break;\n        }\n        if( isConditionValid && conditionLeft > propValue || conditionRight < propValue ) {\n            isNotInRange = true;\n        }\n    }\n\n    return isNotInRange;\n};\n\n/**\n * Evaluating whether property value is not in the condition value array.\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition values do not contain property value\n */\n\nexport let notIn = function( condValue, propValue ) {\n    var verdict = exports.within( condValue, propValue );\n    return !verdict;\n};\n\n/**\n * Evaluating whether condition value is less than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than condition value\n */\nexport let lessThan = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn < condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is less than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than or equal to condition value\n */\nexport let lessThanOrEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn <= condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is greater than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than condition value\n */\nexport let greaterThan = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn > condValueIn ) {\n            isValid = true;\n        }\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is greater than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than or equal to condition value\n */\nexport let greaterThanOrEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn >= condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let notEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    if( condValue && propValue ) {\n        isValid = condValue.toString() !== propValue.toString();\n    } else {\n        isValid = condValue !== propValue;\n    }\n    return isValid;\n};\n\n/**\n * Applicable for validation criteria -  Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let notEqualsTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    if( condValue && propValue ) {\n        isValid = condValue.toString() !== propValue.toString();\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\nexport let regexp = function( condValue, propValue ) {\n    var isValid = false;\n    var regexp;\n    var value = propValue ? String( propValue ) : '';\n    if( _.isString( condValue ) ) {\n        regexp = new RegExp( condValue );\n    } else if( _.isObject( condValue ) && condValue.$pattern ) {\n        try {\n            regexp = new RegExp( condValue.$pattern, condValue.$options );\n        } catch ( err ) {\n            // Invalid options\n            isValid = false;\n        }\n    }\n    if( regexp ) {\n        isValid = regexp.test( value );\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\nexport let notInRegexp = function( condValue, propValue ) {\n    if( condValue && propValue ) {\n        return !exports.regexp( condValue, propValue );\n    }\n    return false;\n};\n\n/**\n * Enables looking up a value in given range and matching another value with the value at the same index but\n * different column in the range\n *\n * Example: Range is an array of arrays where first array holds objects and second array holds array of values.\n * range : [\n *   [ {\"uid\":\"v1\"}, {\"uid\":\"v11\"}, {\"uid\":\"v111\"} ],\n *   [ [\"color1\"], [\"color2\"], [\"color3\"] ]\n * }\n *\n * Calling vlookup with following inputs will return true:\n * vlookupInput = {\n *  \"lookupValue\" : \"v11\",\n *  \"lookupValueKey\" : \"uid\",\n *  \"matchKey\" : 1,\n *  \"matchValue\": \"color2\"\n * }\n * vlookup( vlookupInput, range ) :: returns true\n *\n * @param {Object} vlookupInput - Javascript object holding the lookupValue, lookupValueKey, matchKey and matchValue\n * @param {Object} range -        Javascript object with each value as array of string/int/boolean or objects OR\n *                                    array of string/int/boolean or object arrays\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let vlookup = function( vlookupInput, range ) {\n    var lookupValueKey = vlookupInput.lookupValueKey;\n    var lookupValue = vlookupInput.lookupValue;\n    var matchKey = vlookupInput.matchKey;\n    var matchValue = vlookupInput.matchValue;\n\n    var valToMatchFromRange;\n\n    // determine the lookup strategy based on type of range object\n    if( _.isArray( range ) ) {\n        // range is an array of arrays\n        var matchIndex = -1;\n        _.forEach( range, function( value ) {\n            var values = _.isArray( value ) ? value : [ value ];\n            _.forEach( values, function( currVal, arrPos ) {\n                if( currVal ) {\n                    var lookupValToMatch = lookupValueKey ? currVal[ lookupValueKey ] : currVal;\n                    if( lookupValue === lookupValToMatch ) {\n                        matchIndex = arrPos;\n                        return false;\n                    }\n                }\n                return undefined;\n            } );\n\n            if( matchIndex > -1 ) {\n                valToMatchFromRange = matchKey ? range[ matchKey ][ matchIndex ] : Object.keys( range )[ matchIndex ];\n                valToMatchFromRange = valToMatchFromRange && _.isArray( valToMatchFromRange ) && valToMatchFromRange.length > 0 ? valToMatchFromRange[ 0 ] : valToMatchFromRange;\n                return false;\n            }\n            return undefined;\n        } );\n    } else {\n        // range is an object with key value pair\n        _.forEach( range, function( value, key ) {\n            if( key === lookupValue ) {\n                valToMatchFromRange = value;\n                return false;\n            }\n            return undefined;\n        } );\n    }\n\n    return valToMatchFromRange === matchValue;\n};\n\n/* Gets eval function to cache for quicker evals in future */\n/**\n *\n * @param {String} condKey - $in\n * @param {String} propKey - modelType.typeHierarchy\n */\nexport let getEvaluationFn = function( condKey, propKey ) {\n    if( condKey[ 0 ] === '$' ) {\n        return exports[ _map_expr2Function[ condKey ] ];\n    }\n    return function() {\n        return false;\n    };\n};\n\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\nexport let isNull = function( condValue, propValue ) {\n    return !propValue;\n};\n\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\nexport let notNull = function( condValue, propValue ) {\n    return !exports.isNull( condValue, propValue );\n};\n\nexports = {\n    $SOURCE,\n    $QUERY,\n    $ADAPT,\n    $ALL,\n    $AND,\n    $OR,\n    $EVENTSOURCE,\n    $NOT,\n    resolve,\n    updateDynamicValues,\n    evaluateExpressions,\n    evaluateConditions,\n    evaluateConditionExpression,\n    evaluateEventSourceExpression,\n    equalTo,\n    within,\n    notInRange,\n    notIn,\n    lessThan,\n    lessThanOrEqualTo,\n    greaterThan,\n    greaterThanOrEqualTo,\n    notEqualTo,\n    notEqualsTo,\n    regexp,\n    notInRegexp,\n    vlookup,\n    isNull,\n    notNull,\n    getExpressionDataType,\n    typeOf,\n    getEvaluationFn\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}