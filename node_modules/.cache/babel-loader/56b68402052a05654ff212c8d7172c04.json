{"ast":null,"code":"/* eslint-disable max-lines */\n// Copyright (c) 2022 Siemens\n\n/**\n * This service is used for splm table as Dom Controller, play table row/cell instead of DOM Structure\n *\n * @module js/splmTableDomController\n *\n * DOM Structure\n * <aw-splm-table>\n *   CLASS_TABLE|aw-splm-table\n *     CLASS_TABLE_CONTAINER|aw-splm-tableContainer\n *       CLASS_COLUMN_RESIZE_GRIP|aw-splm-tableColumnResizeGrip -> grip for resize\n *       CLASS_PIN_CONTAINER|aw-splm-tablePinnedContainer\n *           CLASS_HEADER_ROW|aw-splm-tableHeaderRow\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *               CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *               CLASS_CELL|ui-grid-cell\n *       CLASS_SCROLL_CONTAINER|aw-splm-tableScrollContainer\n *           CLASS_HEADER_ROW|ui-grid-header-cell-row\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *                 CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *             CLASS_CELL|ui-grid-cell\n *     CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *       CLASS_TABLE_MENU|aw-splm-tableMenu\n *\n *\n * CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *   CLASS_TABLE_MENU|aw-splm-tableMenu\n *     CLASS_TABLE_MENU_ITEM|aw-splm-tableMenuItem\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableColumnResizer from 'js/splmTableColumnResizer';\nimport awEventHelperService from 'js/awEventHelperService';\nimport wcagService from 'js/wcagService';\nimport appCtxSvc from 'js/appCtxService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport Cell from 'js/splmTableCellRenderer'; // Bootstrap for _t to make coding pattern consistent\n\n/**\n * Instances of this class represent a column resizer for PL Table\n *\n * @class SimpleTableDomController\n * @param {DOMElement} tableElem - HTML DOM Element for table\n * @param {Array} columnDefs - Array of Column Definitions\n */\n\nvar SPLMTableDomController = function (tableElem, columnDefs, tableEditor, gridContextDispatcher) {\n  // Class definition   //Dummy comment\n  var self = this;\n  var _table = tableElem;\n\n  var _trv = new Trv(tableElem);\n\n  var _menuService = util.getTableMenuService(tableElem);\n\n  var _columnDefs = columnDefs;\n  var _tableInstance = tableElem._tableInstance;\n  var _keyboardService = _tableInstance.keyboardService;\n  var _grip = null; // Pin/freeze context\n\n  var _pinColumnCount = 0;\n  var _pinContainerWidth = 0;\n  var _scrollContainerWidth = 0;\n  var _alignContainersForCheckbox = false;\n  var _scrollColumnsInView = {\n    start: null,\n    end: null\n  };\n  const ariaColIndex = 'aria-colindex';\n  const ariaRowIndex = 'aria-rowindex';\n  const ariaRowCount = 'aria-rowcount';\n  const dataIndexNumber = 'data-indexnumber'; // ////////////////////////////////////////////////\n  // Internal\n  // ////////////////////////////////////////////////\n\n  var _getSortClassName = function (sortType) {\n    if (typeof sortType === 'string') {\n      sortType = sortType.toUpperCase();\n\n      if (sortType === 'ASC') {\n        return Const.CLASS_ICON_SORT_ASC;\n      } else if (sortType === 'DESC') {\n        return Const.CLASS_ICON_SORT_DESC;\n      } else if (sortType === '') {\n        return Const.CLASS_ICON_SORTABLE;\n      }\n    }\n\n    return Const.CLASS_ICON_NON_SORTABLE;\n  };\n\n  self.setPinContext = function (lastPinIndex) {\n    // Get the right most pinnedLeft option then set pinCount\n    if (lastPinIndex !== undefined && lastPinIndex !== null) {\n      _pinColumnCount = lastPinIndex + 1;\n    } else {\n      var rightMostPinIdx = -1;\n\n      _.forEach(_columnDefs, function (column, idx) {\n        if (column.pinnedLeft === true) {\n          rightMostPinIdx = idx;\n        }\n      }); // _pinColumnCount will be greater than zero if any column is pinned or frozen by the user.\n      // We should not reset this value if it is greater than zero.\n\n\n      if (_pinColumnCount === 0) {\n        _pinColumnCount = rightMostPinIdx + 1;\n      }\n    }\n\n    _pinContainerWidth = 0;\n    _scrollContainerWidth = 0;\n\n    for (var i = 0; i < _columnDefs.length; i++) {\n      if (i < _pinColumnCount) {\n        _columnDefs[i].pinnedLeft = true;\n        _columnDefs[i].startPosition = _pinContainerWidth;\n        _pinContainerWidth += _columnDefs[i].drawnWidth;\n      } else {\n        _columnDefs[i].pinnedLeft = false;\n        _columnDefs[i].startPosition = _scrollContainerWidth;\n        _scrollContainerWidth += _columnDefs[i].drawnWidth;\n      }\n    }\n  };\n  /**\n   * @memberOf js/splmTableDomController\n   *\n   * Get pin column count in the table\n   *\n   * @return {Number} pin column count in the table\n   */\n\n\n  self.getPinColumnCount = function () {\n    return _pinColumnCount;\n  };\n  /**\n   * New design decided in 20180724:\n   *   1. If width=<number>, we use it.\n   *   2. If width = *, we make it as minWidth + 25%* minWidth.\n   *   3. If minWidth + 25% > maxWidth, use maxWidth.\n   *   4. Don't use ui-grid column splitter design, put the splitter at the right side of the\n   *      column. Adapt CSS properly\n   *\n   * For the issue we faced in real autoWidth design:\n   *   1. Horizontal Scroll bar will appear/disappear randomly when sum(cellWidth) == canvasWidth.\n   *      - This should be resolved by new design but will rehearsal if it is not.\n   *\n   *   2. The listener for resize when autoWidth exist.\n   *      - This is not needed for new design.\n   */\n\n\n  self.initializeColumnWidths = function () {\n    _.forEach(_columnDefs, function (column) {\n      var width = 0;\n\n      if (column.name === 'icon') {\n        width = util.getTableRowHeight(_tableInstance.gridOptions, Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH);\n\n        if (width !== Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH) {\n          /** We have some pedding in icon rendering column and to render the complete icon, we need to\n           increase width of icon renderer by 8 units **/\n          width += 8;\n        }\n      } else if (column.width > 0) {\n        width = column.width;\n      } else {\n        width = column.minWidth > 0 ? column.minWidth : Const.WIDTH_DEFAULT_MINIMUM_WIDTH;\n        width = Math.floor(1.25 * width);\n        width = column.maxWidth > 0 && column.maxWidth < width ? column.maxWidth : width;\n      }\n\n      column.width = width;\n      column.drawnWidth = width;\n    });\n  }; // set aria-colcount to a number of columns which are visible in the DOM\n\n\n  self.setAriaColCount = function (tableContainer, columns) {\n    if (columns !== undefined) {\n      var tableCols = columns;\n      var visibleCols = tableCols.filter(column => column.visible !== undefined && column.visible);\n      var visibleColsLength = visibleCols.length;\n      tableContainer.setAttribute('aria-colcount', visibleColsLength);\n    } else {\n      tableContainer.setAttribute('aria-colcount', -1);\n    }\n  }; // set aria-colcount to a number of columns which are visible in the DOM\n\n\n  self.setAriaRowCount = function (tableContainer) {\n    if (_tableInstance.gridOptions.transpose === true) {\n      var tableCols = _tableInstance.dataProvider.cols;\n      var visibleCols = tableCols.filter(column => column.visible !== undefined && column.visible);\n      tableContainer.setAttribute(ariaRowCount, visibleCols.length + 1);\n    } else {\n      if (_tableInstance.dataProvider.json && _tableInstance.dataProvider.json.firstPage && _tableInstance.dataProvider.action && _tableInstance.dataProvider.action.inputData.searchInput) {\n        tableContainer.setAttribute(ariaRowCount, _tableInstance.dataProvider.json.firstPage.length + 1);\n      } else {\n        if (_tableInstance.dataProvider.viewModelCollection && _tableInstance.dataProvider.viewModelCollection.loadedVMObjects) {\n          tableContainer.setAttribute(ariaRowCount, _tableInstance.dataProvider.viewModelCollection.loadedVMObjects.length + 1);\n        } else {\n          tableContainer.setAttribute(ariaRowCount, -1);\n        }\n      }\n    }\n  }; // set describedby and aria-labelledby to a caption or label element id which labels or describes the table\n\n\n  self.setAriaLabelledAndDescribedBy = function (directiveElement, tableContainer) {\n    if (directiveElement) {\n      if (directiveElement.getAttribute('labelled-by')) {\n        tableContainer.setAttribute('aria-labelledby', directiveElement.getAttribute('labelled-by'));\n      }\n\n      if (directiveElement.getAttribute('described-by')) {\n        tableContainer.setAttribute('aria-describedby', directiveElement.getAttribute('described-by'));\n      }\n    }\n  }; // Scroll content width must be at least 1px to ensure pin/scroll syncing keeps working\n  // when there are no columns in either of the containers\n\n\n  var _setScrollContentMinWidth = function (scrollContentElement, width) {\n    var adjustedWidth = width > 0 ? width : 1;\n    scrollContentElement.style.minWidth = adjustedWidth + 'px';\n  };\n\n  var _setPinHeaderWidth = function (width) {\n    var headerElem = _trv.getPinHeaderElementFromTable();\n\n    var pinContentElem = _trv.getPinContentElementFromTable();\n\n    headerElem.style.minWidth = String(width) + 'px';\n\n    _setScrollContentMinWidth(pinContentElem, width);\n  };\n\n  var _setScrollHeaderWidth = function (width) {\n    var headerElem = _trv.getScrollHeaderElementFromTable();\n\n    var scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    headerElem.style.minWidth = String(width) + 'px';\n    var scrollContentMinWidth = parseInt(width, 10) - parseInt(scrollContentElem.style.paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth);\n  };\n\n  var _setHeaderColumnWidth = function (columnIdx, width) {\n    var headerCellElem = _trv.getHeaderCellElementFromTable(columnIdx); // update current cell width\n\n\n    headerCellElem.style.width = String(width) + 'px';\n  };\n\n  var _setContentRowWidth = function (rowElem, width) {\n    rowElem.style.minWidth = String(width) + 'px';\n  };\n\n  var _getContentRowCount = function () {\n    var _length = 0;\n\n    var rows = _trv.getScrollContentRowElementsFromTable();\n\n    if (rows) {\n      _length = rows.length;\n    }\n\n    return _length;\n  };\n\n  var _setContentColumnWidth = function (columnIdx, width) {\n    var rowCnt = _getContentRowCount();\n\n    for (var i = 0; i < rowCnt; i++) {\n      var rowCellElem = _trv.getContentCellFromTable(i, columnIdx);\n\n      var prevWidth = self.getColumnWidth(columnIdx);\n\n      if (columnIdx < _pinColumnCount) {\n        var pinRowElem = _trv.getPinContentRowElementFromTable(i);\n\n        _setContentRowWidth(pinRowElem, _pinContainerWidth + width - prevWidth);\n      } else {\n        var scrollRowElem = _trv.getScrollContentRowElementFromTable(i);\n\n        _setContentRowWidth(scrollRowElem, _scrollContainerWidth + width - prevWidth);\n      }\n\n      rowCellElem.style.width = String(width) + 'px';\n    }\n  };\n  /**\n   * Set the class and title for the filter icon element.\n   *\n   * @param {HTMLElement} iconElement - Filter icon element\n   * @param {Object} filter - filter object from column\n   */\n\n\n  var _applyFilterIcon = function (iconElement, filter) {\n    iconElement.classList.add(Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON);\n    iconElement.title = filter.summaryText;\n  };\n  /**\n   * Set the class and title for the filter icon element.\n   *\n   * @param {Object} column - the column\n   * @param {number} columnIndex - the column index\n   * @param {string} sortDirection - the sort direction\n   * @param {number} startPosition - the start position of the column\n   *\n   * @return {HTMLElement} - the header container\n   */\n\n\n  const _buildHeaderCellContainer = function (column, columnIndex, sortDirection, startPosition) {\n    //Header cell container\n    let headerContainer = document.createElement('div');\n    headerContainer.classList.add(Const.CLASS_HEADER_CELL);\n    headerContainer.tabIndex = -1;\n\n    _keyboardService.setOnFocusAndBlur(headerContainer);\n\n    headerContainer.setAttribute('role', 'columnheader');\n    headerContainer.setAttribute(ariaColIndex, columnIndex + 1); // Check whatever for column selection, and select if needed\n    //Column Def Anchor\n\n    let columnDefElem = document.createElement('div');\n    columnDefElem.classList.add(Const.CLASS_COLUMN_DEF);\n    columnDefElem.classList.add(Const.CLASS_CELL_CONTENTS);\n    columnDefElem.classList.add(Const.CLASS_HEADER_CLEARFIX);\n    columnDefElem.classList.add(Const.CLASS_HEADER_CELL_CONTENT);\n    columnDefElem.style.width = String(column.drawnWidth) + 'px';\n    columnDefElem.columnDef = column; // Enable column selection when click on the header element in transpose mode\n\n    if (_tableInstance.gridOptions.transpose === true) {\n      columnDefElem.onclick = SelectionHelper.selectionChanged(_table);\n    }\n\n    if (column.headerTooltip !== false && column.headerTooltip === true) {\n      columnDefElem.title = column.displayName;\n    }\n\n    headerContainer.appendChild(columnDefElem); // Splitter for resize\n    // Firefox limitation: element must be appended on left if it has 'float:right'\n\n    let resizeElem = document.createElement('div');\n    resizeElem.classList.add(Const.CLASS_HEADER_CELL_SPLITTER);\n\n    if (column.enableColumnResizing) {\n      headerContainer.insertBefore(resizeElem, columnDefElem);\n      splmTableColumnResizer.applyColumnResizeHandler(self, resizeElem, _menuService); //last prop = _menu\n    } //Create Inner element\n\n\n    let innerElem = Cell.createHeaderElement(column, tableElem);\n    innerElem.classList.add(Const.CLASS_HEADER_CELL_INNER);\n    columnDefElem.appendChild(innerElem); //Create Sort element\n\n    let sortElem = document.createElement('i');\n    sortElem.classList.add(Const.CLASS_HEADER_CELL_SORT_ICON);\n    sortElem.classList.add(_getSortClassName(sortDirection));\n    sortElem.title = '';\n    columnDefElem.appendChild(sortElem);\n    let sortDir;\n\n    if (sortDirection !== null && sortDirection !== '') {\n      // aria-sort supported sort values are ascending, descending, none and other.\n      sortDir = sortDirection.toLowerCase().includes('desc') ? 'descending' : 'ascending';\n      headerContainer.setAttribute('aria-sort', sortDir);\n    } //Create Filter element\n\n\n    let filterElem = document.createElement('i');\n    filterElem.classList.add(Const.CLASS_HEADER_CELL_FILTER_ICON);\n\n    if (column.filter && column.filter.isFilterApplied) {\n      _applyFilterIcon(filterElem, column.filter);\n    } else {\n      filterElem.title = '';\n    }\n\n    columnDefElem.appendChild(filterElem);\n\n    if (column.enableColumnMenu === true) {\n      const openMenuEvent = event => {\n        if (gridContextDispatcher) {\n          let currentColumnIndex = -1;\n\n          if (_tableInstance.columnProvider.sortCriteria && _tableInstance.columnProvider.sortCriteria.length > 0) {\n            var sortCriteria = _tableInstance.columnProvider.sortCriteria[0];\n            currentColumnIndex = self.getIdxFromColumnName(sortCriteria.fieldName);\n          }\n\n          gridContextDispatcher({\n            type: 'UPDATE_VALUES',\n            columnDef: columnDefElem.columnDef,\n            currentColumnIndex: currentColumnIndex,\n            pinColumnCount: _pinColumnCount,\n            isBulkEditing: util.isBulkEditing(_table)\n          });\n        }\n\n        _menuService.columnMenuHandler(columnDefElem, gridContextDispatcher)(event);\n      };\n\n      columnDefElem.classList.add(Const.CLASS_COLUMN_MENU_ENABLED);\n      columnDefElem.setAttribute('role', 'button');\n      columnDefElem.setAttribute('aria-haspopup', 'true');\n      columnDefElem.addEventListener('click', event => {\n        openMenuEvent(event);\n      });\n      headerContainer.addEventListener('keydown', function (event) {\n        if (wcagService.isValidKeyPress(event)) {\n          openMenuEvent(event);\n        }\n      });\n    }\n\n    column.startPosition = startPosition;\n    return headerContainer;\n  };\n\n  var _insertColumnHeaders = function (headerElement, startIdx, endIdx) {\n    let columnDefs = _columnDefs;\n    let totalColumnHeaderWidth = 0; //only add role=row if we are sure role=columnheader will be added as its descendents else it will cause aria-required-children violation.\n\n    if (startIdx < endIdx) {\n      headerElement.setAttribute('role', 'row'); //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n\n      headerElement.setAttribute(ariaRowIndex, 1);\n    }\n\n    for (let idx = startIdx; idx < endIdx; idx++) {\n      let column = columnDefs[idx];\n      let sortDirection = null;\n\n      if (_tableInstance.gridOptions.enableSorting !== false && column.enableSorting) {\n        if (column.sort && column.sort.direction) {\n          sortDirection = column.sort.direction;\n        } else {\n          sortDirection = '';\n        }\n      }\n\n      const headerContainer = _buildHeaderCellContainer(column, idx, sortDirection, totalColumnHeaderWidth);\n\n      totalColumnHeaderWidth += column.drawnWidth; //Add header container to header element\n\n      headerElement.appendChild(headerContainer);\n    }\n\n    let headerHeight = util.getTableHeaderHeight(_tableInstance.gridOptions, Const.HEIGHT_HEADER) + 'px';\n    headerElement.style.height = headerHeight;\n    headerElement.style.minHeight = headerHeight;\n    headerElement.style.maxHeight = headerHeight;\n    headerElement.style.minWidth = String(totalColumnHeaderWidth) + 'px';\n  };\n\n  var _createGrip = function () {\n    _grip = document.createElement('div');\n\n    _grip.classList.add(Const.CLASS_COLUMN_RESIZE_GRIP);\n\n    _grip.style.position = 'absolute';\n    _grip.style.height = '100%'; // Try to make border in the middle\n\n    var subGrip = document.createElement('div');\n    subGrip.style.borderLeft = '1px solid';\n    subGrip.style.marginLeft = '30px';\n    subGrip.style.height = '100%';\n\n    _grip.appendChild(subGrip);\n\n    _grip.style.zIndex = '1000';\n    _grip.style.cursor = 'col-resize';\n    _grip.style.outline = '20px transparent';\n    _grip.style.width = '60px';\n    _grip.style.display = 'none';\n    return _grip;\n  };\n\n  var removeHoverClassFromRows = function () {\n    var rows = _trv.getTableContainerElementFromTable().getElementsByClassName('ui-grid-row');\n\n    for (var i = 0; i < rows.length; i++) {\n      rows[i].classList.remove(Const.CLASS_ROW_HOVER);\n    }\n  };\n\n  var removeHoverClassesRaf = function () {\n    requestAnimationFrame(function () {\n      removeHoverClassFromRows();\n    });\n  };\n\n  var _constructTableElement = function () {\n    var columnDefs = _columnDefs; // Table Container\n\n    var tableContainer = document.createElement('div');\n    tableContainer.classList.add(Const.CLASS_TABLE_CONTAINER);\n    tableContainer.tabIndex = 0;\n\n    if (_tableInstance.gridOptions.useTree === true) {\n      tableContainer.setAttribute('role', 'treegrid');\n    } else {\n      tableContainer.setAttribute('role', 'grid');\n    }\n\n    if (_tableInstance.dataProvider.selectionModel.mode === 'multiple') {\n      tableContainer.setAttribute('aria-multiselectable', 'true');\n    } else {\n      tableContainer.setAttribute('aria-multiselectable', 'false');\n    }\n\n    if (_tableInstance.gridOptions.enableCellHeaderSelection === true) {\n      tableContainer.classList.add(Const.CLASS_HEADER_SELECTION_ENABLED);\n    }\n\n    self.setAriaRowCount(tableContainer);\n    self.setAriaColCount(tableContainer, _tableInstance.dataProvider.cols);\n\n    _table.appendChild(tableContainer);\n\n    self.initializeColumnWidths(); // Do pin initialization after eval column width so we could\n    // Dummy Comment\n    // collect container size together\n\n    self.setPinContext(); // Create dragging grip.\n\n    tableContainer.appendChild(_createGrip());\n    var pinContainer = document.createElement('div');\n    pinContainer.classList.add(Const.CLASS_PIN_CONTAINER);\n    pinContainer.classList.add(Const.CLASS_PIN_CONTAINER_LEFT);\n\n    if (_tableInstance.gridOptions.transpose === true) {\n      pinContainer.classList.add(Const.CLASS_COMPARE_CONTAINER);\n    }\n\n    var pinHeaderElem = document.createElement('div');\n    pinHeaderElem.classList.add(Const.CLASS_HEADER_ROW);\n\n    _insertColumnHeaders(pinHeaderElem, 0, _pinColumnCount);\n\n    pinContainer.appendChild(pinHeaderElem);\n    var pinScrollContainer = document.createElement('div');\n    pinScrollContainer.classList.add(Const.CLASS_CANVAS);\n    pinScrollContainer.classList.add(Const.CLASS_VIEWPORT);\n    var pinScrollContents = document.createElement('div');\n    pinScrollContents.addEventListener('mouseleave', function () {\n      removeHoverClassesRaf();\n    });\n    pinScrollContents.classList.add(Const.CLASS_SCROLL_CONTENTS);\n\n    _setScrollContentMinWidth(pinScrollContents, parseInt(pinHeaderElem.style.minWidth, 10));\n\n    pinScrollContainer.appendChild(pinScrollContents);\n    pinContainer.appendChild(pinScrollContainer);\n    tableContainer.appendChild(pinContainer);\n    var scrollContainer = document.createElement('div');\n    scrollContainer.classList.add(Const.CLASS_SCROLL_CONTAINER);\n    scrollContainer.style.marginLeft = String(_pinContainerWidth) + 'px'; // Create Columns in memory\n\n    var scrollHeaderElem = document.createElement('div');\n    scrollHeaderElem.classList.add(Const.CLASS_HEADER_ROW);\n\n    _insertColumnHeaders(scrollHeaderElem, _pinColumnCount, columnDefs.length);\n\n    scrollContainer.appendChild(scrollHeaderElem); // Create row Contents in memory\n\n    var rowsContainer = document.createElement('div');\n    rowsContainer.classList.add(Const.CLASS_VIEWPORT);\n    rowsContainer.classList.add(Const.CLASS_CANVAS);\n    var scrollContents = document.createElement('div');\n    scrollContents.addEventListener('mouseleave', function () {\n      removeHoverClassesRaf();\n    });\n    scrollContents.classList.add(Const.CLASS_SCROLL_CONTENTS);\n\n    _setScrollContentMinWidth(scrollContents, parseInt(scrollHeaderElem.style.minWidth, 10));\n\n    rowsContainer.appendChild(scrollContents);\n    scrollContainer.appendChild(rowsContainer);\n    tableContainer.appendChild(scrollContainer);\n  };\n  /**\n   * @memberOf js/aw-splm-table.directive\n   *\n   * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n   * and the given column (columnInfo )\n   * @param {Object} column - Declarative columnInfo object\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   * @param {Number} columnWidth - Width of the iconCellColumn\n   * @param {HTMLElement} rowElem - row DOMElement\n   * @return {HTMLElement} The newly created DOMElement for the property cell\n   */\n\n\n  const _createPropertyCell = function (column, vmo, columnWidth, rowElem) {\n    const cell = util.createElement('div', Const.CLASS_CELL);\n    cell.tabIndex = -1;\n\n    if (_tableInstance.dynamicRowHeightStatus) {\n      cell.classList.add(Const.CLASS_CELL_DYNAMIC);\n    }\n\n    if (column.colSelected) {\n      cell.classList.add(Const.CLASS_COLUMN_SELECTED);\n      cell.classList.add(Const.CLASS_CELL_SELECTED);\n    }\n\n    const defaultRowHeight = appCtxSvc.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n    const rowHeight = util.getTableRowHeight(_tableInstance.gridOptions, defaultRowHeight);\n    cell.style.width = `${columnWidth}px`;\n    cell.style.height = _tableInstance.dynamicRowHeightStatus ? 'auto' : rowHeight + 'px';\n    cell.appendChild(Cell.createElement(column, vmo, tableElem, rowElem));\n\n    if (column.field === 'transposedColumnProperty') {\n      cell.setAttribute('role', 'rowheader');\n    } else {\n      cell.setAttribute('role', 'gridcell');\n    }\n\n    cell.propName = column.field;\n    cell.columnDef = column;\n\n    if (vmo.props) {\n      cell.prop = vmo.props[column.field];\n    }\n\n    const cellTops = cell.getElementsByClassName('aw-splm-tableCellTop');\n\n    if (cellTops.length > 0) {\n      util.addCSSClassForRowHeight(cellTops[0], _tableInstance.gridOptions);\n    }\n\n    const idxNum = document.createAttribute(dataIndexNumber);\n    idxNum.value = column.index;\n\n    if (column.index >= _pinColumnCount) {\n      idxNum.value = column.index - _pinColumnCount;\n    }\n\n    cell.setAttributeNode(idxNum); // aria-colindex always starts with index 1.\n\n    cell.setAttribute(ariaColIndex, column.index + 1); // Set click listener for cell to get editable states\n\n    tableEditor.addCellClickListener(cell, vmo);\n\n    _keyboardService.setOnFocusAndBlur(cell);\n\n    _keyboardService.setupInternalCellNavigation(cell);\n\n    return cell;\n  };\n  /**\n   * Adds the aria attributes for tree if the row is part of a tree table\n   * @param {HTMLElement} row - the row element\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   */\n\n\n  const _setAriaAttributesForTreeRow = function (row, vmo) {\n    if (_tableInstance.gridOptions.useTree === true) {\n      if (vmo.isLeaf === false) {\n        if (vmo.isExpanded === true) {\n          row.setAttribute('aria-expanded', 'true');\n        } else {\n          row.setAttribute('aria-expanded', 'false');\n        }\n      } // aria-level starts from index 1.\n\n\n      row.setAttribute('aria-level', vmo.levelNdx + 1);\n    }\n  };\n  /**\n   * Adds the mouseenter event listener to apply hover styling to the row.\n   * @param {HTMLElement} row - the row element\n   */\n\n\n  const _addRowHoverListener = function (row) {\n    row.addEventListener('mouseenter', function (event) {\n      const hoveredRow = event.currentTarget;\n      requestAnimationFrame(function () {\n        removeHoverClassFromRows();\n        const index = util.getIndexInParent(hoveredRow);\n\n        const scrollRow = _trv.getScrollContentRowElementFromTable(index);\n\n        const pinRow = _trv.getPinContentRowElementFromTable(index);\n\n        scrollRow.classList.add(Const.CLASS_ROW_HOVER);\n        pinRow.classList.add(Const.CLASS_ROW_HOVER);\n      });\n    });\n  };\n  /**\n   * Adds the selection checkbox to the row\n   * @param {HTMLElement} row - the row element\n   * @param {HTMLElement} tableElem - the table element\n   * @param {Object[]} columnDefs - array of column defs\n   */\n\n\n  const _addRowCheckBox = function (row, tableElem, columnDefs) {\n    // var commandBarHtml =\n    // <div class=\"aw-splm-tableCheckBoxPresent\">\n    //   <a class=\"aw-commands-cellCommandCommon\">\n    //     <span class=\"sw-checkbox-val\">\n    //       <input class=\"sw-property-val\" type=\"checkbox\">\n    //       <span class=\"sw-checkbox-pseudo\"></span>\n    //     </span>\n    //   </a>\n    // </div>\n    let checkBox = util.createElement('div', Const.CLASS_CELL_CHECKBOX);\n    let wrapperAElement = util.createElement('a', 'aw-commands-cellCommandCommon');\n    let wrapperCheckboxDiv = util.createElement('span', 'sw-checkbox-val');\n    let inputElement = util.createElement('input', Const.CLASS_CELL_CHECKBOX_BUTTON);\n    let checkboxTypeAttr = document.createAttribute('type');\n    checkboxTypeAttr.value = 'checkbox';\n    inputElement.setAttributeNode(checkboxTypeAttr);\n    let commandDef = columnDefs.filter(function (def) {\n      if (def.isTableCommand || def.isTreeNavigation) {\n        return true;\n      }\n\n      return false;\n    })[0];\n    let propName = commandDef && (commandDef.propertyName || commandDef.name);\n\n    if (propName && row.vmo && row.vmo.props && row.vmo.props[propName]) {\n      let value = row.vmo.props[propName].uiValue;\n      let checkboxLabelAttr = document.createAttribute('aria-label');\n      checkboxLabelAttr.value = value;\n      inputElement.setAttributeNode(checkboxLabelAttr);\n    }\n\n    let spanCheckboxStyle = document.createElement('span');\n    spanCheckboxStyle.classList.add('sw-checkbox-pseudo'); // Do we really need this intermediate span? Commenting for now. Will remove once all table related auto tests pass\n    // var spanCheckElem = document.createElement( 'span' );\n    // spanCheckElem.classList.add( 'check' );\n    // spanCheckboxStyle.appendChild( spanCheckElem );\n\n    wrapperCheckboxDiv.appendChild(inputElement);\n    wrapperCheckboxDiv.appendChild(spanCheckboxStyle);\n    wrapperAElement.appendChild(wrapperCheckboxDiv);\n    checkBox.appendChild(wrapperAElement); // We should not need following lines. Commenting for now. Will remove once all table related auto tests pass\n    // var cellScope = {};\n    // var checkBox = util.createNgElement( commandBarHtml, tableElem, cellScope );\n\n    row.appendChild(checkBox);\n  };\n  /**\n   * Creates and returns a DOMElement for the TableRow of the passed in view model object (vmo) which defines the row\n   * Will Create cells for each column using the vmo properties associated by propertyName.  Also will prepend an\n   * iconCell at the beginning of the row.  Appropriate rowSelection callback will be added too.\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   * @param {number} rowHeight - the pixel row height\n   * @param {number} startIdx - the column start index\n   * @param {number} endIdx - the column end index\n   *\n   * @return {HTMLElement} row - the created row element\n   */\n\n\n  const _createContentRowElement = function (vmo, rowHeight, startIdx, endIdx) {\n    const columnDefs = _columnDefs;\n    const row = util.createElement('div', Const.CLASS_ROW, Const.CLASS_UI_GRID_ROW, Const.CLASS_ROW_ICON);\n    let rowWidth = 0;\n    row.vmo = vmo; //only add role=row if we are sure role=gridcell or role=rowheader will be added as its descendents else it will cause aria-required-children violation.\n\n    if (startIdx <= endIdx) {\n      row.setAttribute('role', 'row');\n    }\n\n    _setAriaAttributesForTreeRow(row, vmo); // LCS-286849 - jQuery has issues with handling touch to click events on mobile\n\n\n    let target = {\n      default: row,\n      mobile: row\n    };\n    let eventObject = {\n      click: 'touchend'\n    };\n    awEventHelperService.subscribeMouseEvent(target, eventObject, SelectionHelper.selectionChanged(_table));\n    row.oncontextmenu = _menuService.contextSelectionHandler;\n    row.draggable = true;\n\n    _addRowHoverListener(row);\n\n    if (vmo.rowStatus && vmo.rowStatus === 'ADDED') {\n      row.classList.add('aw-jswidgets-change');\n    } else if (vmo.rowStatus && vmo.rowStatus === 'REMOVED') {\n      row.classList.add('aw-jswidgets-oldText');\n    }\n\n    let adjustedColumnDefs = _.sortBy(columnDefs, function (columnDef) {\n      return columnDef.index;\n    });\n\n    _.forEach(adjustedColumnDefs, function (currentColumn) {\n      if (row.vmo.props && row.vmo.props[currentColumn.field]) {\n        row.vmo.props[currentColumn.field].renderingHint = currentColumn.renderingHint;\n      }\n    });\n\n    for (let i = startIdx; i <= endIdx; i++) {\n      const column = adjustedColumnDefs[i];\n      let cell = null;\n      let _width = column.drawnWidth;\n      const showCheckBox = _tableInstance.showCheckBox;\n\n      if (i === 0 && showCheckBox) {\n        _addRowCheckBox(row, tableElem, adjustedColumnDefs);\n      }\n\n      cell = _createPropertyCell(column, vmo, _width, row);\n      rowWidth += _width;\n      row.appendChild(cell);\n    }\n\n    row.style.minWidth = String(rowWidth) + 'px';\n    row.style.minHeight = String(rowHeight) + 'px';\n    return row;\n  };\n  /**\n   * Remove the class and title from the filter icon element.\n   *\n   * @param {HTMLElement} iconElement - Filter icon element\n   */\n\n\n  const _removeFilterIcon = function (iconElement) {\n    iconElement.classList.remove(Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON);\n    iconElement.title = '';\n  };\n\n  self.updateScrollColumnsInView = function (scrollLeft, scrollContainerWidth) {\n    var headerCells = _trv.getScrollHeaderElementFromTable().children; // Find start and end visible columns\n\n\n    var extraColumns = 3;\n    var start = null;\n    var end = null;\n    var totalHeaderCells = headerCells.length; // Return all columns as in view if container width given is null or undefined\n\n    if (scrollContainerWidth === null || scrollContainerWidth === undefined || scrollContainerWidth === 0) {\n      _scrollColumnsInView = {\n        start: 0,\n        end: totalHeaderCells - 1\n      };\n      return;\n    }\n\n    for (var i = 0; i < totalHeaderCells; i++) {\n      var column = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var columnStartPosition = column.startPosition;\n\n      if (columnStartPosition <= scrollLeft) {\n        start = i;\n      }\n\n      if (columnStartPosition <= scrollLeft + scrollContainerWidth) {\n        end = i;\n      }\n    }\n\n    start = start - extraColumns < 0 ? 0 : start - extraColumns;\n    end = end + extraColumns > totalHeaderCells - 1 ? totalHeaderCells - 1 : end + extraColumns;\n    _scrollColumnsInView = {\n      start: start,\n      end: end\n    };\n  };\n\n  self.updateVisibleCells = function (rowParentElem) {\n    const startColumnIdx = _scrollColumnsInView.start;\n    const endColumnIdx = _scrollColumnsInView.end;\n    rowParentElem = rowParentElem.childNodes;\n\n    const scrollHeader = _trv.getScrollHeaderElementFromTable();\n\n    const scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    const headerCells = scrollHeader.children;\n    let minWidth = 0;\n\n    for (let i = startColumnIdx; i < headerCells.length; i++) {\n      const column = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n\n      if (startColumnIdx !== null) {\n        minWidth += column.drawnWidth;\n      }\n    }\n\n    let paddingLeft = null;\n    const scrollHeaderElemMinWidth = scrollHeader.style.minWidth;\n\n    if (startColumnIdx > 0) {\n      const paddingLeftColumnDef = headerCells[startColumnIdx - 1].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      paddingLeft = paddingLeftColumnDef.startPosition + paddingLeftColumnDef.drawnWidth + 'px';\n    } else {\n      paddingLeft = '0px';\n    }\n\n    scrollContentElem.style.paddingLeft = paddingLeft;\n    const scrollContentMinWidth = parseInt(scrollHeaderElemMinWidth, 10) - parseInt(paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth); // Update cell visibility\n\n\n    const scrollRows = rowParentElem;\n\n    for (let j = 0; j < scrollRows.length; j++) {\n      const rowCells = scrollRows[j].children;\n\n      if (rowCells.length === 0) {\n        continue;\n      }\n\n      const row = scrollRows[j];\n      row.style.minWidth = minWidth + 'px';\n      const currentStartIndex = rowCells[0].columnDef.index;\n      const currentEndIndex = rowCells[rowCells.length - 1].columnDef.index;\n      const trueStartColumnIndex = startColumnIdx + _pinColumnCount;\n      const trueEndColumnIndex = endColumnIdx + _pinColumnCount;\n\n      for (let k = rowCells.length - 1; k >= 0; k--) {\n        const cell = rowCells[k];\n        const colIndex = cell.columnDef.index; // Remove out of view cells\n\n        if (colIndex < trueStartColumnIndex || colIndex > trueEndColumnIndex) {\n          util.destroyChildElements(cell);\n          cell.parentElement.removeChild(cell);\n        }\n      }\n\n      for (let l = currentStartIndex - 1; l >= trueStartColumnIndex; l--) {\n        const newCellInsertBefore = _createPropertyCell(_columnDefs[l], row.vmo, _columnDefs[l].drawnWidth, row);\n\n        row.insertBefore(newCellInsertBefore, row.children[0]);\n        tableEditor.updateEditStatusForCell(newCellInsertBefore);\n      }\n\n      for (let m = currentEndIndex + 1; m <= trueEndColumnIndex; m++) {\n        const newCellInsertAfter = _createPropertyCell(_columnDefs[m], row.vmo, _columnDefs[m].drawnWidth, row);\n\n        row.appendChild(newCellInsertAfter);\n        tableEditor.updateEditStatusForCell(newCellInsertAfter);\n      }\n    }\n  }; // LCS-323044 - IE11 - aw-splm-table ascending and descending icon not showing\n  // IE lacks support for multiple arguments in classlist.remove - https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n\n\n  const _removeAllSortDirectionClasses = function (sortElement) {\n    sortElement.classList.remove(Const.CLASS_ICON_SORT_ASC);\n    sortElement.classList.remove(Const.CLASS_ICON_SORT_DESC);\n    sortElement.classList.remove(Const.CLASS_ICON_NON_SORTABLE);\n    sortElement.classList.remove(Const.CLASS_ICON_SORTABLE);\n  }; // ////////////////////////////////////////////////\n  // Public method\n  // ////////////////////////////////////////////////\n\n\n  self.getColumnMinWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].minWidth;\n  };\n\n  self.getColumnMaxWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].maxWidth;\n  };\n\n  self.getColumnWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].drawnWidth;\n  };\n\n  const updateColumnStartPositions = function () {\n    let pinContainerWidth = 0;\n    let scrollContainerWidth = 0;\n\n    for (let i = 0; i < _columnDefs.length; i++) {\n      if (i < _pinColumnCount) {\n        _columnDefs[i].startPosition = pinContainerWidth;\n        pinContainerWidth += _columnDefs[i].drawnWidth;\n      } else {\n        _columnDefs[i].startPosition = scrollContainerWidth;\n        scrollContainerWidth += _columnDefs[i].drawnWidth;\n      }\n    }\n  };\n  /**\n   * @memberOf js/splmTableDomController\n   *\n   * This method is used for updating the column width\n   * This method is also called from resetColumnDefs with 0,0 arguments which needs to be corrected.\n   * @param {Number} columnIdx - column index\n   * @param {Number} deltaWidth - delta width\n   */\n\n\n  self.updateColumnWidth = function (columnIdx, deltaWidth) {\n    let width = self.getColumnWidth(columnIdx) + deltaWidth;\n\n    _setHeaderColumnWidth(columnIdx, width);\n\n    _setContentColumnWidth(columnIdx, width);\n\n    if (columnIdx < _pinColumnCount) {\n      // Set container\n      _pinContainerWidth += deltaWidth;\n\n      _setPinHeaderWidth(_pinContainerWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n    } else {\n      // Set container\n      _scrollContainerWidth += deltaWidth;\n\n      _setScrollHeaderWidth(_scrollContainerWidth);\n    } // Update columnDef start positions\n\n\n    if (deltaWidth !== 0) {\n      _columnDefs[columnIdx].drawnWidth = width;\n\n      _tableInstance.tableInstanceCallbacks.columnsResized({\n        name: _columnDefs[columnIdx].name,\n        delta: deltaWidth\n      });\n    }\n\n    updateColumnStartPositions();\n\n    let scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth);\n\n    if (deltaWidth !== 0) {\n      self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n    }\n  };\n  /**\n   * Update the filter icon for the header of the column name given.\n   *\n   * @param {String} columnName - column name for the header to update\n   */\n\n\n  self.updateFilterIcon = function (columnName) {\n    var headerCells = _trv.getHeaderCellElementsFromTable();\n\n    for (var i = 0; i < headerCells.length; i++) {\n      var columnDef = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var filterIconElement = headerCells[i].getElementsByClassName(Const.CLASS_HEADER_CELL_FILTER_ICON)[0];\n\n      if (columnDef && columnDef.filter && filterIconElement && columnDef.field === columnName) {\n        if (columnDef.filter.isFilterApplied) {\n          _applyFilterIcon(filterIconElement, columnDef.filter);\n        } else {\n          _removeFilterIcon(filterIconElement);\n        }\n\n        break;\n      }\n    }\n  };\n  /**\n   * Update the filter icon for all column headers.\n   */\n\n\n  self.updateAllFilterIcons = function () {\n    var headerCells = _trv.getHeaderCellElementsFromTable();\n\n    for (var i = 0; i < headerCells.length; i++) {\n      var columnDef = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var filterIconElement = headerCells[i].getElementsByClassName(Const.CLASS_HEADER_CELL_FILTER_ICON)[0];\n\n      if (columnDef && columnDef.filter && filterIconElement) {\n        if (columnDef.filter.isFilterApplied) {\n          _applyFilterIcon(filterIconElement, columnDef.filter);\n        } else {\n          _removeFilterIcon(filterIconElement);\n        }\n      }\n    }\n  };\n  /**\n   * Fit column width with content in canvas\n   * NOTE: This mentod will read computed CSS which may cause reflow\n   *\n   * @param {Number} columnIdx - Last column index.\n   *\n   */\n\n\n  self.fitColumnWidth = function (columnIdx) {\n    var treeNavigation = _columnDefs[columnIdx].isTreeNavigation;\n\n    var cellElems = _trv.queryRowColumnCellElementsFromTable(columnIdx);\n\n    var maxWidth = 0;\n\n    var headerTextElement = _trv.getHeaderCellElementFromTable(columnIdx).getElementsByClassName(Const.CLASS_HEADER_CELL_INNER)[0];\n\n    maxWidth = util.getElementTextWidth(headerTextElement);\n    var filterOption = _tableInstance.gridOptions.isFilteringEnabled;\n    var sortOption = _tableInstance.gridOptions.enableSorting; // This is the space occupied after the column name which includes column menu, splitter, resizeGrip etc.\n\n    if (filterOption || sortOption) {\n      maxWidth += Const.WIDTH_MINIMUM_EXTRA_SPACE;\n    }\n\n    cellElems.forEach(function (cellElem) {\n      var actualWidth; // Tree navigation cell\n\n      if (treeNavigation) {\n        // pass entire cellElem into getCellTextWidth because it calculates\n        // What the width of an unobstructed element with height and width set to auto will be\n        // This will give width of entire cell up until the end of the text for tree nav cells\n        actualWidth = util.getElementTextWidth(cellElem);\n        maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n      } else {\n        // cover text and link for now.\n        var valueElems = cellElem.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT);\n\n        if (valueElems.length === 0) {\n          valueElems = cellElem.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n        }\n\n        for (var i = 0; i < valueElems.length; i++) {\n          actualWidth = util.getElementTextWidth(valueElems[i]);\n          maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n        }\n      }\n    });\n\n    if (maxWidth > 0) {\n      var currentWidth = self.getColumnWidth(columnIdx);\n      var validWidth = self.getValidColumnWidth(columnIdx, maxWidth);\n\n      if (currentWidth !== validWidth) {\n        self.updateColumnWidth(columnIdx, validWidth - currentWidth);\n      }\n    }\n  };\n  /**\n   * Update column visibility for hidden columns\n   *\n   * @param {String} columnName - column name\n   */\n\n\n  self.updateColumnVisibility = function (columnName) {\n    var adjustedColumnIdx = self.getIdxFromColumnName(columnName); // Remove hidden column header from DOM\n\n    var headerCellElem = _trv.getHeaderCellElementFromTable(adjustedColumnIdx);\n\n    if (headerCellElem && headerCellElem.parentElement) {\n      headerCellElem.parentElement.removeChild(headerCellElem);\n    } // Remove hidden column rows from DOM\n\n\n    var rowCount = _getContentRowCount();\n\n    for (var i = 0; i < rowCount; i++) {\n      var rowCellElem = _trv.getContentCellFromTable(i, adjustedColumnIdx);\n\n      if (rowCellElem && rowCellElem.parentElement) {\n        rowCellElem.parentElement.removeChild(rowCellElem);\n      }\n    }\n\n    _columnDefs[adjustedColumnIdx].visible = false;\n\n    _columnDefs.splice(adjustedColumnIdx, 1); // Adjust column indices to account for removed column\n\n\n    _.forEach(_columnDefs, function (columnDef, index) {\n      columnDef.index = index;\n    });\n\n    self.resetColumnDefs(_columnDefs);\n\n    var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n  };\n\n  var _updateCellColumnIndexes = function () {\n    var cellElements = _trv.getContentCellElementsFromTable();\n\n    for (var i = 0; i < cellElements.length; i++) {\n      var cellElement = cellElements[i];\n      var column = cellElement.columnDef;\n      var idxNum = document.createAttribute(dataIndexNumber);\n      idxNum.value = column.index;\n\n      if (column.index >= _pinColumnCount) {\n        idxNum.value = column.index - _pinColumnCount;\n      }\n\n      cellElement.setAttributeNode(idxNum);\n      updateColumnStartPositions();\n    }\n  };\n\n  var _pinHeader = function (columnIdx) {\n    // Check existing column index\n    var newPinCount = columnIdx + 1;\n    var oldPinCount = _pinColumnCount; // Update Existing DOM\n\n    var headerCellElements = _trv.getHeaderCellElementsFromTable();\n\n    var moveFragment = document.createDocumentFragment();\n    var deltaWidth = 0;\n\n    if (oldPinCount < newPinCount) {\n      // Update Header\n      for (var i = oldPinCount; i < newPinCount; i++) {\n        moveFragment.appendChild(headerCellElements[oldPinCount]);\n        deltaWidth += self.getColumnWidth(i);\n      }\n\n      var pinHeaderElem = _trv.queryPinContainerFromTable().toHeader().getElement();\n\n      pinHeaderElem.appendChild(moveFragment);\n\n      _setPinHeaderWidth(_pinContainerWidth + deltaWidth);\n\n      _setScrollHeaderWidth(_scrollContainerWidth - deltaWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth + deltaWidth) + 'px';\n    } else if (oldPinCount > newPinCount) {\n      // Update Header\n      for (var j = newPinCount; j < oldPinCount; j++) {\n        moveFragment.appendChild(headerCellElements[newPinCount]);\n        deltaWidth += self.getColumnWidth(j);\n      }\n\n      var scrollHeaderElem = _trv.queryScrollContainerFromTable().toHeader().getElement();\n\n      scrollHeaderElem.insertBefore(moveFragment, scrollHeaderElem.childNodes[0]);\n\n      _setPinHeaderWidth(_pinContainerWidth - deltaWidth);\n\n      _setScrollHeaderWidth(_scrollContainerWidth + deltaWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth - deltaWidth) + 'px';\n    }\n  };\n\n  var _pinContent = function (columnIdx) {\n    // Check existing column index\n    var newPinCount = columnIdx + 1;\n    var oldPinCount = _pinColumnCount; // Update Existing DOM\n\n    var moveFragment = document.createDocumentFragment();\n\n    var pinContentRowElements = _trv.queryPinContainerFromTable().getContentRowElements();\n\n    var scrollContentRowElements = _trv.queryScrollContainerFromTable().getContentRowElements();\n\n    var count = pinContentRowElements.length;\n    var deltaWidth = 0;\n\n    if (oldPinCount < newPinCount) {\n      for (var i = 0; i < count; i++) {\n        deltaWidth = 0;\n\n        for (var j = oldPinCount; j < newPinCount; j++) {\n          moveFragment.appendChild(scrollContentRowElements[i].children[0]);\n          deltaWidth += self.getColumnWidth(j);\n        }\n\n        pinContentRowElements[i].appendChild(moveFragment);\n\n        _setContentRowWidth(pinContentRowElements[i], _pinContainerWidth + deltaWidth);\n\n        _setContentRowWidth(scrollContentRowElements[i], _scrollContainerWidth - deltaWidth);\n      }\n    } else if (oldPinCount > newPinCount) {\n      for (var k = 0; k < count; k++) {\n        deltaWidth = 0;\n\n        for (var l = newPinCount; l < oldPinCount; l++) {\n          moveFragment.appendChild(pinContentRowElements[k].children[newPinCount]);\n          deltaWidth += self.getColumnWidth(l);\n        }\n\n        scrollContentRowElements[k].insertBefore(moveFragment, scrollContentRowElements[k].childNodes[0]);\n\n        _setContentRowWidth(pinContentRowElements[k], _pinContainerWidth - deltaWidth);\n\n        _setContentRowWidth(scrollContentRowElements[k], _scrollContainerWidth + deltaWidth);\n      }\n    }\n  };\n  /**\n   * Pin the table from column 0 to specific column\n   *\n   * @param {Number} columnIdx - Last column index.\n   *\n   */\n\n\n  self.pinToColumn = function (columnIdx) {\n    // Bring back all cells that were virtualized before moving cells to proper container\n    var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n\n    _pinHeader(columnIdx);\n\n    _pinContent(columnIdx);\n\n    self.setPinContext(columnIdx);\n    let colDef = _columnDefs[columnIdx];\n\n    let pinCanvasElement = _trv.getPinCanvasElementFromTable();\n\n    pinCanvasElement.scrollLeft = colDef.startPosition;\n    let traversalTable = new Trv(_table);\n    util.syncHeader(traversalTable, true, pinCanvasElement.scrollLeft);\n\n    _updateCellColumnIndexes(); // Virtualize cells\n\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n  };\n\n  self.resetFreezeScroll = function (columnField) {\n    let startPosition = 0;\n\n    if (_columnDefs && _columnDefs.length) {\n      for (var i = 0; i < _columnDefs.length; i++) {\n        if (_columnDefs[i].field === columnField) {\n          startPosition = _columnDefs[i].startPosition;\n        }\n      }\n    }\n\n    let scrollLeft = startPosition; // set scroll container to this position to keep header focused\n\n    let scrollCanvas = _trv.getScrollCanvasElementFromTable();\n\n    scrollCanvas.scrollLeft = scrollLeft;\n  };\n  /**\n   * Finds the current columns that are pinned in the table\n   *\n   * @returns {Array} all the columns that are pinned\n   */\n\n\n  var _findPinnedColumns = function () {\n    var results = [];\n\n    if (_columnDefs && _columnDefs.length) {\n      for (var i = 0; i < _columnDefs.length; i++) {\n        if (_columnDefs[i].pinnedLeft === true) {\n          results.push(_columnDefs[i]);\n        }\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Checks new columns for any previous pinned columns, then returns index of first found.\n   *\n   * @param {*} newColumns The new columns coming into the table\n   * @param {*} pinnedColumns The old pinned columns that were pinned\n   * @returns {Number} the first index of an incoming column\n   */\n\n\n  var findPinIndex = function (newColumns, pinnedColumns) {\n    var pinIndex;\n\n    if (_.isArray(pinnedColumns) && _.isArray(newColumns)) {\n      for (var i = pinnedColumns.length - 1; i >= 0; i--) {\n        for (var j = 0; j < newColumns.length; j++) {\n          if (pinnedColumns[i].name && (pinnedColumns[i].name === newColumns[j].name || pinnedColumns[i].name === newColumns[j].field)) {\n            pinIndex = newColumns[j].index;\n            break;\n          }\n        }\n\n        if (pinIndex) {\n          break;\n        }\n      }\n    }\n\n    return pinIndex;\n  };\n\n  self.getColumnDefs = function () {\n    return _columnDefs;\n  };\n\n  self.resetColumnDefs = function (columnDefs) {\n    var previouslyPinnedColumns = _findPinnedColumns();\n\n    var currentPinIndex = findPinIndex(columnDefs, previouslyPinnedColumns);\n    _columnDefs = columnDefs;\n    self.initializeColumnWidths();\n    self.setPinContext(currentPinIndex);\n\n    var pinContainerElem = _trv.getPinContainerElementFromTable();\n\n    var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n\n    var pinContentElem = _trv.getPinContentElementFromTable();\n\n    pinHeaderElem.innerHTML = '';\n\n    _insertColumnHeaders(pinHeaderElem, 0, _pinColumnCount);\n\n    pinContainerElem.replaceChild(pinHeaderElem, pinContainerElem.children[0]);\n\n    _setScrollContentMinWidth(pinContentElem, parseInt(pinHeaderElem.style.minWidth, 10));\n\n    var scrollContainerElem = _trv.getScrollContainerElementFromTable();\n\n    var scrollHeaderElem = _trv.getScrollHeaderElementFromTable();\n\n    var scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    scrollHeaderElem.innerHTML = '';\n\n    _insertColumnHeaders(scrollHeaderElem, _pinColumnCount, _columnDefs.length);\n\n    var scrollContentMinWidth = parseInt(scrollHeaderElem.style.minWidth, 10) - parseInt(scrollContentElem.style.paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth);\n\n    if (scrollContainerElem.children.length === 0) {\n      scrollContainerElem.appendChild(scrollHeaderElem);\n    }\n\n    self.updateColumnWidth(0, 0);\n    self.setAriaColCount(_trv.getTableContainerElementFromTable(), columnDefs);\n  };\n\n  self.isColumnWidthChangeValid = function (columnIdx, deltaWidth) {\n    var targetWidth = self.getColumnWidth(columnIdx) + deltaWidth;\n    return self.getValidColumnWidth(columnIdx, targetWidth) === targetWidth;\n  };\n\n  self.getValidColumnWidth = function (columnIdx, targetWidth) {\n    var maxWidth = self.getColumnMaxWidth(columnIdx);\n    var minWidth = self.getColumnMinWidth(columnIdx);\n    minWidth = minWidth > Const.WIDTH_ALLOWED_MINIMUM_WIDTH ? minWidth : Const.WIDTH_ALLOWED_MINIMUM_WIDTH;\n\n    if (minWidth && targetWidth < minWidth) {\n      targetWidth = minWidth;\n    } else if (maxWidth && targetWidth > maxWidth) {\n      targetWidth = maxWidth;\n    } else {// Do nothing\n    }\n\n    return targetWidth;\n  };\n\n  self.isColumnSplitterDraggable = function (columnIdx) {\n    return _columnDefs[columnIdx].enableColumnResizing !== false;\n  };\n\n  self.getTotalColumnWidth = function (columnIdx) {\n    var width = 0;\n    var sum = columnIdx + 1;\n\n    for (var i = 0; i < sum; i++) {\n      width += self.getColumnWidth(i);\n    }\n\n    return width;\n  };\n\n  self.getIdxFromColumnName = function (columnField) {\n    for (var i = 0; i < _columnDefs.length; i++) {\n      if (_columnDefs[i].field === columnField || _columnDefs[i].name === columnField) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  self.setHeaderCellSortDirection = function (oldColumnIdx, newColumnIdx, sortDirection) {\n    var sortElem;\n    var headerCellElem = null;\n    var sortDir = null;\n\n    if (sortDirection !== null && sortDirection !== '') {\n      // aria-sort supported sort values are ascending, descending, none and other.\n      sortDir = sortDirection.toLowerCase().includes('desc') ? 'descending' : 'ascending';\n    }\n\n    if (oldColumnIdx > -1) {\n      sortElem = _trv.getHeaderCellSortIconElementFromTable(oldColumnIdx);\n\n      _removeAllSortDirectionClasses(sortElem);\n\n      sortElem.classList.add(_getSortClassName(''));\n      headerCellElem = _trv.getHeaderCellElementFromTable(oldColumnIdx);\n\n      if (headerCellElem !== null && headerCellElem.parentElement.hasAttribute('aria-sort')) {\n        headerCellElem.parentElement.removeAttribute('aria-sort');\n      }\n    }\n\n    sortElem = _trv.getHeaderCellSortIconElementFromTable(newColumnIdx);\n\n    _removeAllSortDirectionClasses(sortElem);\n\n    sortElem.classList.add(_getSortClassName(sortDirection));\n    headerCellElem = _trv.getHeaderCellElementFromTable(newColumnIdx);\n\n    if (headerCellElem !== null && sortDir !== null) {\n      headerCellElem.parentElement.setAttribute('aria-sort', sortDir);\n    }\n  };\n\n  self.getScrollCanvasScrollLeftPosition = function () {\n    return _trv.getScrollCanvasElementFromTable().scrollLeft * -1;\n  };\n\n  self.getPinCanvasScrollLeftPosition = function () {\n    return _trv.getPinCanvasElementFromTable().scrollLeft * -1;\n  };\n  /**\n   * Applies the dynamic row heights to each row\n   *\n   * @param {DocumentFragment} contentRowFragment - the fragment of content rows to be applied to the DOM\n   * @param {DocumentFragment} tempContentRowFragment - the temporary fragment of content rows\n   * @param {number} rowHeight - the pixel row height\n   */\n\n\n  const _applyDynamicRowHeights = function (contentRowFragment, tempContentRowFragment, rowHeight) {\n    let tempDivElem = document.createElement('div');\n    tempDivElem.style.position = 'absolute';\n    tempDivElem.style.visibility = 'hidden';\n    tempDivElem.style.height = 'auto';\n    tempDivElem.style.width = 'auto';\n    const clonedNode = tempContentRowFragment.childNodes.length ? tempContentRowFragment : contentRowFragment.cloneNode(true);\n    tempDivElem.appendChild(clonedNode);\n    document.body.appendChild(tempDivElem); // Now loop through rows\n\n    const newRows = tempDivElem.childNodes;\n    const rowsWithVMOs = contentRowFragment.childNodes;\n    const maxRowHeight = rowHeight * Const.MAX_ROW_HEIGHT_ROWS;\n\n    for (let i = 0; i < newRows.length; i++) {\n      const row = newRows[i];\n      const vmo = rowsWithVMOs[i].vmo;\n      let height = 0;\n      const cells = row.childNodes;\n\n      for (let j = 0; j < cells.length; j++) {\n        const cell = cells[j];\n\n        if (cell.childNodes[0] && cell.childNodes[0].classList.contains(Const.CLASS_SPLM_TABLE_ICON_CELL)) {\n          continue;\n        } else if (cell.childNodes[0] && cell.childNodes[0].classList.contains(Const.CLASS_AW_TREE_COMMAND_CELL)) {\n          // check if cell has data\n          const _cell = cell.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT)[0];\n\n          if (_cell) {\n            const cellHeight = _cell.offsetHeight + 15;\n            height = cellHeight > height ? cellHeight : height;\n          } else {\n            height = rowHeight > height ? rowHeight : height;\n          }\n        } else {\n          const cellHeight = cell.offsetHeight + 11;\n          height = cellHeight > height ? cellHeight : height;\n        }\n      } // no larger than max height and no smaller than default row height\n\n\n      height = Math.min(Math.max(height, rowHeight), maxRowHeight);\n      vmo.rowHeight = !vmo.rowHeight || height > vmo.rowHeight ? height : vmo.rowHeight; // Mark each actual cell text with height if exists.\n\n      const cellsWithText = rowsWithVMOs[i].getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC);\n\n      for (let k = 0; k < cellsWithText.length; k++) {\n        cellsWithText[k].style.maxHeight = String(vmo.rowHeight) + 'px';\n      }\n    }\n\n    document.body.removeChild(tempDivElem);\n  };\n  /**\n   * Creates a group of row elements with cells spanning from the start and end column index.\n   *\n   * @param {Array} vmos - the array of vmos to create rows for\n   * @param {number} startIndex - the row start index\n   * @param {number} rowHeight - the pixel row height\n   * @param {number} startColumnIdx - the column start index\n   * @param {number} endColumnIdx - the column end index\n   * @param {boolean} isPin - true if the row contents are for the pin container\n   *\n   * @return {DocumentFragment} Document fragment containing the rows for the passed in vmos\n   */\n\n\n  const _constructContentElement = function (vmos, startIndex, rowHeight, startColumnIdx, endColumnIdx, isPin) {\n    let contentRowFragment = document.createDocumentFragment();\n    let tempContentRowFragment = document.createDocumentFragment();\n\n    for (let keyIdx = 0; keyIdx < vmos.length; keyIdx++) {\n      let vmo = vmos[keyIdx];\n      const rowIndex = keyIdx + startIndex;\n      const idxNum = document.createAttribute(dataIndexNumber);\n      idxNum.value = rowIndex;\n      let row = null;\n      let mockrow = null;\n\n      if (isPin) {\n        row = _createContentRowElement(vmo, rowHeight, startColumnIdx, endColumnIdx);\n        row.classList.add(Const.CLASS_PINNED_ROW);\n      } else {\n        if (_scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null) {\n          startColumnIdx = _scrollColumnsInView.start + _pinColumnCount;\n          endColumnIdx = _scrollColumnsInView.end + _pinColumnCount;\n        }\n\n        row = _createContentRowElement(vmo, rowHeight, startColumnIdx, endColumnIdx);\n\n        if (_tableInstance.dynamicRowHeightStatus) {\n          // If dynamic row height, we need to get the row height with all cells rendered, so endColumnIdx is the last item in columnDefs.\n          mockrow = _createContentRowElement(vmo, rowHeight, startColumnIdx, _columnDefs.length - 1);\n          mockrow.setAttributeNode(idxNum.cloneNode());\n        }\n      }\n\n      row.setAttributeNode(idxNum); //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n\n      if (row.children.length > 0) {\n        row.setAttribute(ariaRowIndex, rowIndex + 2);\n      } // Add id attribute to each cell which will be refered by aria-activedescendant at grid level.\n      // The id attribute should be unique, so this will be a combination of gridid, aria-rowindex, aria-colindex.\n\n\n      let cellElements = row.childNodes;\n      let uniqueIdForCell;\n\n      for (let i = 0; i < cellElements.length; i++) {\n        if (cellElements[i].hasAttribute(ariaColIndex)) {\n          uniqueIdForCell = _tableInstance.gridId + '_row' + row.getAttribute(ariaRowIndex) + '_col' + cellElements[i].getAttribute(ariaColIndex);\n          cellElements[i].setAttribute('id', uniqueIdForCell);\n        }\n      }\n\n      contentRowFragment.appendChild(row);\n\n      if (_tableInstance.dynamicRowHeightStatus && mockrow) {\n        tempContentRowFragment.appendChild(mockrow);\n      }\n\n      if (isPin !== true && _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null) {\n        self.updateVisibleCells(contentRowFragment);\n      }\n    } // Dynamic Row Height - When flag is enabled\n    // find heights for rows by creating div and adding doc fragment\n\n\n    if (_tableInstance.dynamicRowHeightStatus) {\n      _applyDynamicRowHeights(contentRowFragment, tempContentRowFragment, rowHeight);\n    }\n\n    return contentRowFragment;\n  };\n\n  self.constructContentElement = function (vmos, startIndex, rowHeight, isPin) {\n    if (isPin === true) {\n      // Set container\n      var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n\n      if (_tableInstance.showCheckBox === true) {\n        if (!_alignContainersForCheckbox) {\n          _alignContainersForCheckbox = true;\n          _pinContainerWidth += 32;\n          pinHeaderElem.lastChild.style.width = pinHeaderElem.lastChild.clientWidth + 32 + 'px';\n          _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n        }\n      } else if (!_tableInstance.showCheckBox && _alignContainersForCheckbox) {\n        _alignContainersForCheckbox = false;\n        _pinContainerWidth -= 32;\n        pinHeaderElem.lastChild.style.width = '';\n        _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n      }\n\n      return _constructContentElement(vmos, startIndex, rowHeight, 0, _pinColumnCount - 1, isPin);\n    }\n\n    return _constructContentElement(vmos, startIndex, rowHeight, _pinColumnCount, _columnDefs.length - 1, isPin);\n  };\n\n  var _removeContentElement = function (parent, upperCountIdx, lowerCounterIdx) {\n    var parentElement = parent.getElement();\n    var children = parent.getContentRowElements();\n    var uCountIdx = upperCountIdx || children.length - 1;\n    var lCountIdx = lowerCounterIdx || 0;\n\n    if (children && children.length > 0) {\n      for (; uCountIdx >= lCountIdx; uCountIdx--) {\n        // Clean up edit cell scope if needed\n        var editCell = children[uCountIdx].getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP)[0] || children[uCountIdx].getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY)[0];\n\n        if (editCell !== undefined && editCell.parentElement.prop !== undefined) {\n          editCell.parentElement.prop.isEditing = false;\n        } // Cleanup any components being used dynamically\n\n\n        util.cleanupComponents(children[uCountIdx]);\n        parentElement.removeChild(children[uCountIdx]);\n      }\n    }\n  };\n\n  self.removeContentElement = function (upperCountIdx, lowerCounterIdx) {\n    _removeContentElement(_trv.queryPinContentFromTable(), upperCountIdx, lowerCounterIdx);\n\n    _removeContentElement(_trv.queryScrollContentFromTable(), upperCountIdx, lowerCounterIdx);\n  };\n\n  self.clearScrollContents = function () {\n    _trv.getScrollContentElementFromTable().innerHTML = '';\n  };\n\n  self.setSelectable = function (selectable) {\n    if (selectable) {\n      _table.classList.add(Const.CLASS_SELECTION_ENABLED);\n    } else {\n      _table.classList.remove(Const.CLASS_SELECTION_ENABLED);\n    }\n  };\n\n  self.setDraggable = function (draggable) {\n    var rowElements = _table.getElementsByClassName(Const.CLASS_ROW);\n\n    for (var i = 0; i < rowElements.length; i++) {\n      rowElements[i].draggable = draggable;\n    }\n  }; // /////////////////////////////////////////////\n  // Column Resize Grip\n  // /////////////////////////////////////////////\n\n\n  self.showColumnGrip = function (posX) {\n    self.setColumnGripPosition(posX);\n\n    _grip.style.removeProperty('display');\n  };\n\n  self.setColumnGripPosition = function (posX) {\n    _grip.style.marginLeft = String(posX - 30\n    /* match with width*/\n    ) + 'px';\n  };\n\n  self.hideColumnGrip = function () {\n    _grip.style.display = 'none';\n  };\n\n  _constructTableElement();\n\n  self.updateColorIndicatorElements = function (updateVMOs) {\n    var pinRows = _trv.getPinContentRowElementsFromTable();\n\n    _.forEach(pinRows, function (pinRow) {\n      var rowVmo = pinRow.vmo;\n\n      if (updateVMOs.includes(rowVmo)) {\n        var colorIndicatorElement = pinRow.getElementsByClassName(Const.CLASS_AW_CELL_COLOR_INDICATOR)[0];\n\n        if (colorIndicatorElement) {\n          var newColorIndicatorElement = util.createColorIndicatorElement(rowVmo);\n          colorIndicatorElement.parentElement.replaceChild(newColorIndicatorElement, colorIndicatorElement);\n        }\n      }\n    });\n  };\n\n  self.syncContentRowHeights = function (pinnedElems, scrollElems) {\n    if (pinnedElems && pinnedElems.childNodes) {\n      for (let i = 0; i < pinnedElems.childNodes.length; i++) {\n        let row = pinnedElems.childNodes[i];\n        let rowVMO = row.vmo;\n        row.style.height = String(rowVMO.rowHeight) + 'px';\n      }\n    }\n\n    if (scrollElems && scrollElems.childNodes) {\n      for (let i = 0; i < scrollElems.childNodes.length; i++) {\n        let row = scrollElems.childNodes[i];\n        let rowVMO = row.vmo;\n        row.style.height = String(rowVMO.rowHeight) + 'px';\n      }\n    }\n  };\n\n  return self;\n};\n\n_c2 = SPLMTableDomController;\n_c = SPLMTableDomController;\nexport default SPLMTableDomController;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableDomController\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableDomController\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableDomController.js"],"names":["SPLMTableDomController","self","_table","_trv","_menuService","util","_columnDefs","_tableInstance","tableElem","_keyboardService","_grip","_pinColumnCount","_pinContainerWidth","_scrollContainerWidth","_alignContainersForCheckbox","_scrollColumnsInView","start","end","ariaColIndex","ariaRowIndex","ariaRowCount","dataIndexNumber","_getSortClassName","sortType","Const","lastPinIndex","rightMostPinIdx","_","column","i","width","Math","columns","tableCols","visibleCols","visibleColsLength","tableContainer","directiveElement","_setScrollContentMinWidth","adjustedWidth","scrollContentElement","_setPinHeaderWidth","headerElem","pinContentElem","String","_setScrollHeaderWidth","scrollContentElem","scrollContentMinWidth","parseInt","_setHeaderColumnWidth","headerCellElem","_setContentRowWidth","rowElem","_getContentRowCount","_length","rows","_setContentColumnWidth","rowCnt","rowCellElem","prevWidth","columnIdx","pinRowElem","scrollRowElem","_applyFilterIcon","iconElement","filter","_buildHeaderCellContainer","headerContainer","document","columnIndex","columnDefElem","SelectionHelper","resizeElem","splmTableColumnResizer","innerElem","Cell","sortElem","sortDirection","sortDir","filterElem","openMenuEvent","event","currentColumnIndex","sortCriteria","gridContextDispatcher","type","columnDef","pinColumnCount","isBulkEditing","wcagService","_insertColumnHeaders","columnDefs","totalColumnHeaderWidth","startIdx","headerElement","idx","headerHeight","_createGrip","subGrip","removeHoverClassFromRows","removeHoverClassesRaf","requestAnimationFrame","_constructTableElement","pinContainer","pinHeaderElem","pinScrollContainer","pinScrollContents","scrollContainer","scrollHeaderElem","rowsContainer","scrollContents","_createPropertyCell","cell","defaultRowHeight","appCtxSvc","rowHeight","columnWidth","vmo","cellTops","idxNum","tableEditor","_setAriaAttributesForTreeRow","row","_addRowHoverListener","hoveredRow","index","scrollRow","pinRow","_addRowCheckBox","checkBox","wrapperAElement","wrapperCheckboxDiv","inputElement","checkboxTypeAttr","commandDef","def","propName","value","checkboxLabelAttr","spanCheckboxStyle","_createContentRowElement","rowWidth","target","default","mobile","eventObject","click","awEventHelperService","adjustedColumnDefs","currentColumn","_width","showCheckBox","_removeFilterIcon","headerCells","extraColumns","totalHeaderCells","scrollContainerWidth","columnStartPosition","scrollLeft","startColumnIdx","endColumnIdx","rowParentElem","scrollHeader","minWidth","paddingLeft","scrollHeaderElemMinWidth","paddingLeftColumnDef","scrollRows","j","rowCells","currentStartIndex","currentEndIndex","trueStartColumnIndex","trueEndColumnIndex","k","colIndex","l","newCellInsertBefore","m","newCellInsertAfter","_removeAllSortDirectionClasses","sortElement","updateColumnStartPositions","pinContainerWidth","deltaWidth","name","delta","scrollCanvasElement","filterIconElement","treeNavigation","cellElems","maxWidth","headerTextElement","filterOption","sortOption","actualWidth","valueElems","cellElem","currentWidth","validWidth","adjustedColumnIdx","rowCount","_updateCellColumnIndexes","cellElements","cellElement","_pinHeader","newPinCount","oldPinCount","headerCellElements","moveFragment","_pinContent","pinContentRowElements","scrollContentRowElements","count","colDef","pinCanvasElement","traversalTable","startPosition","scrollCanvas","_findPinnedColumns","results","findPinIndex","pinnedColumns","newColumns","pinIndex","previouslyPinnedColumns","currentPinIndex","pinContainerElem","scrollContainerElem","targetWidth","sum","oldColumnIdx","_applyDynamicRowHeights","tempDivElem","clonedNode","tempContentRowFragment","contentRowFragment","newRows","rowsWithVMOs","maxRowHeight","height","cells","_cell","cellHeight","cellsWithText","_constructContentElement","keyIdx","vmos","rowIndex","mockrow","uniqueIdForCell","isPin","_removeContentElement","parentElement","parent","children","uCountIdx","upperCountIdx","lCountIdx","lowerCounterIdx","editCell","rowElements","posX","pinRows","rowVmo","updateVMOs","colorIndicatorElement","newColorIndicatorElement","pinnedElems","rowVMO","scrollElems"],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2022 Siemens\n/**\n * This service is used for splm table as Dom Controller, play table row/cell instead of DOM Structure\n *\n * @module js/splmTableDomController\n *\n * DOM Structure\n * <aw-splm-table>\n *   CLASS_TABLE|aw-splm-table\n *     CLASS_TABLE_CONTAINER|aw-splm-tableContainer\n *       CLASS_COLUMN_RESIZE_GRIP|aw-splm-tableColumnResizeGrip -> grip for resize\n *       CLASS_PIN_CONTAINER|aw-splm-tablePinnedContainer\n *           CLASS_HEADER_ROW|aw-splm-tableHeaderRow\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *               CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *               CLASS_CELL|ui-grid-cell\n *       CLASS_SCROLL_CONTAINER|aw-splm-tableScrollContainer\n *           CLASS_HEADER_ROW|ui-grid-header-cell-row\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *                 CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *             CLASS_CELL|ui-grid-cell\n *     CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *       CLASS_TABLE_MENU|aw-splm-tableMenu\n *\n *\n * CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *   CLASS_TABLE_MENU|aw-splm-tableMenu\n *     CLASS_TABLE_MENU_ITEM|aw-splm-tableMenuItem\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableColumnResizer from 'js/splmTableColumnResizer';\nimport awEventHelperService from 'js/awEventHelperService';\nimport wcagService from 'js/wcagService';\nimport appCtxSvc from 'js/appCtxService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport Cell from 'js/splmTableCellRenderer';\n\n// Bootstrap for _t to make coding pattern consistent\n\n/**\n * Instances of this class represent a column resizer for PL Table\n *\n * @class SimpleTableDomController\n * @param {DOMElement} tableElem - HTML DOM Element for table\n * @param {Array} columnDefs - Array of Column Definitions\n */\nvar SPLMTableDomController = function( tableElem, columnDefs, tableEditor, gridContextDispatcher ) {\n    // Class definition   //Dummy comment\n    var self = this;\n    var _table = tableElem;\n    var _trv = new Trv( tableElem );\n    var _menuService = util.getTableMenuService( tableElem );\n    var _columnDefs = columnDefs;\n    var _tableInstance = tableElem._tableInstance;\n    var _keyboardService = _tableInstance.keyboardService;\n\n    var _grip = null;\n    // Pin/freeze context\n    var _pinColumnCount = 0;\n    var _pinContainerWidth = 0;\n    var _scrollContainerWidth = 0;\n    var _alignContainersForCheckbox = false;\n    var _scrollColumnsInView = {\n        start: null,\n        end: null\n    };\n    const ariaColIndex = 'aria-colindex';\n    const ariaRowIndex = 'aria-rowindex';\n    const ariaRowCount = 'aria-rowcount';\n    const dataIndexNumber = 'data-indexnumber';\n\n    // ////////////////////////////////////////////////\n    // Internal\n    // ////////////////////////////////////////////////\n    var _getSortClassName = function( sortType ) {\n        if( typeof sortType === 'string' ) {\n            sortType = sortType.toUpperCase();\n            if( sortType === 'ASC' ) {\n                return Const.CLASS_ICON_SORT_ASC;\n            } else if( sortType === 'DESC' ) {\n                return Const.CLASS_ICON_SORT_DESC;\n            } else if( sortType === '' ) {\n                return Const.CLASS_ICON_SORTABLE;\n            }\n        }\n        return Const.CLASS_ICON_NON_SORTABLE;\n    };\n\n    self.setPinContext = function( lastPinIndex ) {\n        // Get the right most pinnedLeft option then set pinCount\n        if( lastPinIndex !== undefined && lastPinIndex !== null ) {\n            _pinColumnCount = lastPinIndex + 1;\n        } else {\n            var rightMostPinIdx = -1;\n            _.forEach( _columnDefs, function( column, idx ) {\n                if( column.pinnedLeft === true ) {\n                    rightMostPinIdx = idx;\n                }\n            } );\n            // _pinColumnCount will be greater than zero if any column is pinned or frozen by the user.\n            // We should not reset this value if it is greater than zero.\n            if( _pinColumnCount === 0 ) {\n                _pinColumnCount = rightMostPinIdx + 1;\n            }\n        }\n\n        _pinContainerWidth = 0;\n        _scrollContainerWidth = 0;\n        for( var i = 0; i < _columnDefs.length; i++ ) {\n            if( i < _pinColumnCount ) {\n                _columnDefs[ i ].pinnedLeft = true;\n                _columnDefs[ i ].startPosition = _pinContainerWidth;\n                _pinContainerWidth += _columnDefs[ i ].drawnWidth;\n            } else {\n                _columnDefs[ i ].pinnedLeft = false;\n                _columnDefs[ i ].startPosition = _scrollContainerWidth;\n                _scrollContainerWidth += _columnDefs[ i ].drawnWidth;\n            }\n        }\n    };\n\n    /**\n     * @memberOf js/splmTableDomController\n     *\n     * Get pin column count in the table\n     *\n     * @return {Number} pin column count in the table\n     */\n    self.getPinColumnCount = function() {\n        return _pinColumnCount;\n    };\n\n    /**\n     * New design decided in 20180724:\n     *   1. If width=<number>, we use it.\n     *   2. If width = *, we make it as minWidth + 25%* minWidth.\n     *   3. If minWidth + 25% > maxWidth, use maxWidth.\n     *   4. Don't use ui-grid column splitter design, put the splitter at the right side of the\n     *      column. Adapt CSS properly\n     *\n     * For the issue we faced in real autoWidth design:\n     *   1. Horizontal Scroll bar will appear/disappear randomly when sum(cellWidth) == canvasWidth.\n     *      - This should be resolved by new design but will rehearsal if it is not.\n     *\n     *   2. The listener for resize when autoWidth exist.\n     *      - This is not needed for new design.\n     */\n    self.initializeColumnWidths = function() {\n        _.forEach( _columnDefs, function( column ) {\n            var width = 0;\n            if( column.name === 'icon' ) {\n                width = util.getTableRowHeight( _tableInstance.gridOptions, Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH );\n                if( width !== Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH ) {\n                    /** We have some pedding in icon rendering column and to render the complete icon, we need to\n                     increase width of icon renderer by 8 units **/\n                    width += 8;\n                }\n            } else if( column.width > 0 ) {\n                width = column.width;\n            } else {\n                width = column.minWidth > 0 ? column.minWidth : Const.WIDTH_DEFAULT_MINIMUM_WIDTH;\n                width = Math.floor( 1.25 * width );\n                width = column.maxWidth > 0 && column.maxWidth < width ? column.maxWidth : width;\n            }\n            column.width = width;\n            column.drawnWidth = width;\n        } );\n    };\n\n    // set aria-colcount to a number of columns which are visible in the DOM\n    self.setAriaColCount = function( tableContainer, columns ) {\n        if( columns !== undefined ) {\n            var tableCols = columns;\n            var visibleCols = tableCols.filter( column => column.visible !== undefined && column.visible );\n            var visibleColsLength = visibleCols.length;\n            tableContainer.setAttribute( 'aria-colcount', visibleColsLength );\n        } else {\n            tableContainer.setAttribute( 'aria-colcount', -1 );\n        }\n    };\n\n    // set aria-colcount to a number of columns which are visible in the DOM\n    self.setAriaRowCount = function( tableContainer ) {\n        if( _tableInstance.gridOptions.transpose === true ) {\n            var tableCols = _tableInstance.dataProvider.cols;\n            var visibleCols = tableCols.filter( column => column.visible !== undefined && column.visible );\n            tableContainer.setAttribute( ariaRowCount, visibleCols.length + 1 );\n        } else {\n            if( _tableInstance.dataProvider.json && _tableInstance.dataProvider.json.firstPage && _tableInstance.dataProvider.action && _tableInstance.dataProvider.action.inputData.searchInput ) {\n                tableContainer.setAttribute( ariaRowCount, _tableInstance.dataProvider.json.firstPage.length + 1 );\n            } else {\n                if( _tableInstance.dataProvider.viewModelCollection && _tableInstance.dataProvider.viewModelCollection.loadedVMObjects ) {\n                    tableContainer.setAttribute( ariaRowCount, _tableInstance.dataProvider.viewModelCollection.loadedVMObjects.length + 1 );\n                } else {\n                    tableContainer.setAttribute( ariaRowCount, -1 );\n                }\n            }\n        }\n    };\n\n    // set describedby and aria-labelledby to a caption or label element id which labels or describes the table\n    self.setAriaLabelledAndDescribedBy = function( directiveElement, tableContainer ) {\n        if( directiveElement ) {\n            if( directiveElement.getAttribute( 'labelled-by' ) ) {\n                tableContainer.setAttribute( 'aria-labelledby', directiveElement.getAttribute( 'labelled-by' ) );\n            }\n            if( directiveElement.getAttribute( 'described-by' ) ) {\n                tableContainer.setAttribute( 'aria-describedby', directiveElement.getAttribute( 'described-by' ) );\n            }\n        }\n    };\n    // Scroll content width must be at least 1px to ensure pin/scroll syncing keeps working\n    // when there are no columns in either of the containers\n    var _setScrollContentMinWidth = function( scrollContentElement, width ) {\n        var adjustedWidth = width > 0 ? width : 1;\n        scrollContentElement.style.minWidth = adjustedWidth + 'px';\n    };\n\n    var _setPinHeaderWidth = function( width ) {\n        var headerElem = _trv.getPinHeaderElementFromTable();\n        var pinContentElem = _trv.getPinContentElementFromTable();\n        headerElem.style.minWidth = String( width ) + 'px';\n        _setScrollContentMinWidth( pinContentElem, width );\n    };\n\n    var _setScrollHeaderWidth = function( width ) {\n        var headerElem = _trv.getScrollHeaderElementFromTable();\n        var scrollContentElem = _trv.getScrollContentElementFromTable();\n        headerElem.style.minWidth = String( width ) + 'px';\n        var scrollContentMinWidth = parseInt( width, 10 ) - parseInt( scrollContentElem.style.paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n    };\n\n    var _setHeaderColumnWidth = function( columnIdx, width ) {\n        var headerCellElem = _trv.getHeaderCellElementFromTable( columnIdx );\n\n        // update current cell width\n        headerCellElem.style.width = String( width ) + 'px';\n    };\n\n    var _setContentRowWidth = function( rowElem, width ) {\n        rowElem.style.minWidth = String( width ) + 'px';\n    };\n\n    var _getContentRowCount = function() {\n        var _length = 0;\n        var rows = _trv.getScrollContentRowElementsFromTable();\n        if( rows ) {\n            _length = rows.length;\n        }\n        return _length;\n    };\n\n    var _setContentColumnWidth = function( columnIdx, width ) {\n        var rowCnt = _getContentRowCount();\n        for( var i = 0; i < rowCnt; i++ ) {\n            var rowCellElem = _trv.getContentCellFromTable( i, columnIdx );\n            var prevWidth = self.getColumnWidth( columnIdx );\n            if( columnIdx < _pinColumnCount ) {\n                var pinRowElem = _trv.getPinContentRowElementFromTable( i );\n                _setContentRowWidth( pinRowElem, _pinContainerWidth + width - prevWidth );\n            } else {\n                var scrollRowElem = _trv.getScrollContentRowElementFromTable( i );\n                _setContentRowWidth( scrollRowElem, _scrollContainerWidth + width - prevWidth );\n            }\n            rowCellElem.style.width = String( width ) + 'px';\n        }\n    };\n\n    /**\n     * Set the class and title for the filter icon element.\n     *\n     * @param {HTMLElement} iconElement - Filter icon element\n     * @param {Object} filter - filter object from column\n     */\n    var _applyFilterIcon = function( iconElement, filter ) {\n        iconElement.classList.add( Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON );\n        iconElement.title = filter.summaryText;\n    };\n\n    /**\n     * Set the class and title for the filter icon element.\n     *\n     * @param {Object} column - the column\n     * @param {number} columnIndex - the column index\n     * @param {string} sortDirection - the sort direction\n     * @param {number} startPosition - the start position of the column\n     *\n     * @return {HTMLElement} - the header container\n     */\n    const _buildHeaderCellContainer = function( column, columnIndex, sortDirection, startPosition ) {\n        //Header cell container\n        let headerContainer = document.createElement( 'div' );\n        headerContainer.classList.add( Const.CLASS_HEADER_CELL );\n        headerContainer.tabIndex = -1;\n        _keyboardService.setOnFocusAndBlur( headerContainer );\n        headerContainer.setAttribute( 'role', 'columnheader' );\n        headerContainer.setAttribute( ariaColIndex, columnIndex + 1 );\n\n        // Check whatever for column selection, and select if needed\n\n        //Column Def Anchor\n        let columnDefElem = document.createElement( 'div' );\n        columnDefElem.classList.add( Const.CLASS_COLUMN_DEF );\n        columnDefElem.classList.add( Const.CLASS_CELL_CONTENTS );\n        columnDefElem.classList.add( Const.CLASS_HEADER_CLEARFIX );\n        columnDefElem.classList.add( Const.CLASS_HEADER_CELL_CONTENT );\n        columnDefElem.style.width = String( column.drawnWidth ) + 'px';\n        columnDefElem.columnDef = column;\n\n        // Enable column selection when click on the header element in transpose mode\n        if( _tableInstance.gridOptions.transpose === true ) {\n            columnDefElem.onclick = SelectionHelper.selectionChanged( _table );\n        }\n\n        if( column.headerTooltip !== false && column.headerTooltip === true ) {\n            columnDefElem.title = column.displayName;\n        }\n\n        headerContainer.appendChild( columnDefElem );\n\n        // Splitter for resize\n        // Firefox limitation: element must be appended on left if it has 'float:right'\n        let resizeElem = document.createElement( 'div' );\n        resizeElem.classList.add( Const.CLASS_HEADER_CELL_SPLITTER );\n        if( column.enableColumnResizing ) {\n            headerContainer.insertBefore( resizeElem, columnDefElem );\n            splmTableColumnResizer.applyColumnResizeHandler( self, resizeElem, _menuService ); //last prop = _menu\n        }\n\n        //Create Inner element\n        let innerElem = Cell.createHeaderElement( column, tableElem );\n        innerElem.classList.add( Const.CLASS_HEADER_CELL_INNER );\n        columnDefElem.appendChild( innerElem );\n\n        //Create Sort element\n        let sortElem = document.createElement( 'i' );\n        sortElem.classList.add( Const.CLASS_HEADER_CELL_SORT_ICON );\n        sortElem.classList.add( _getSortClassName( sortDirection ) );\n        sortElem.title = '';\n        columnDefElem.appendChild( sortElem );\n        let sortDir;\n        if( sortDirection !== null && sortDirection !== '' ) {\n            // aria-sort supported sort values are ascending, descending, none and other.\n            sortDir = sortDirection.toLowerCase().includes( 'desc' ) ? 'descending' : 'ascending';\n            headerContainer.setAttribute( 'aria-sort', sortDir );\n        }\n\n        //Create Filter element\n        let filterElem = document.createElement( 'i' );\n        filterElem.classList.add( Const.CLASS_HEADER_CELL_FILTER_ICON );\n        if( column.filter && column.filter.isFilterApplied ) {\n            _applyFilterIcon( filterElem, column.filter );\n        } else {\n            filterElem.title = '';\n        }\n        columnDefElem.appendChild( filterElem );\n\n        if( column.enableColumnMenu === true ) {\n            const openMenuEvent = ( event ) => {\n                if( gridContextDispatcher ) {\n                    let currentColumnIndex = -1;\n                    if( _tableInstance.columnProvider.sortCriteria && _tableInstance.columnProvider.sortCriteria.length > 0 ) {\n                        var sortCriteria = _tableInstance.columnProvider.sortCriteria[ 0 ];\n                        currentColumnIndex = self.getIdxFromColumnName( sortCriteria.fieldName );\n                    }\n                    gridContextDispatcher( {\n                        type: 'UPDATE_VALUES',\n                        columnDef: columnDefElem.columnDef,\n                        currentColumnIndex: currentColumnIndex,\n                        pinColumnCount: _pinColumnCount,\n                        isBulkEditing: util.isBulkEditing( _table )\n                    } );\n                }\n                _menuService.columnMenuHandler( columnDefElem, gridContextDispatcher )( event );\n            };\n\n            columnDefElem.classList.add( Const.CLASS_COLUMN_MENU_ENABLED );\n            columnDefElem.setAttribute( 'role', 'button' );\n            columnDefElem.setAttribute( 'aria-haspopup', 'true' );\n            columnDefElem.addEventListener( 'click', ( event ) => {\n                openMenuEvent( event );\n            } );\n            headerContainer.addEventListener( 'keydown', function( event ) {\n                if( wcagService.isValidKeyPress( event ) ) {\n                    openMenuEvent( event );\n                }\n            } );\n        }\n\n        column.startPosition = startPosition;\n\n        return headerContainer;\n    };\n\n    var _insertColumnHeaders = function( headerElement, startIdx, endIdx ) {\n        let columnDefs = _columnDefs;\n        let totalColumnHeaderWidth = 0;\n        //only add role=row if we are sure role=columnheader will be added as its descendents else it will cause aria-required-children violation.\n        if( startIdx < endIdx ) {\n            headerElement.setAttribute( 'role', 'row' );\n            //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n            headerElement.setAttribute( ariaRowIndex, 1 );\n        }\n        for( let idx = startIdx; idx < endIdx; idx++ ) {\n            let column = columnDefs[ idx ];\n            let sortDirection = null;\n\n            if( _tableInstance.gridOptions.enableSorting !== false && column.enableSorting ) {\n                if( column.sort && column.sort.direction ) {\n                    sortDirection = column.sort.direction;\n                } else {\n                    sortDirection = '';\n                }\n            }\n\n            const headerContainer = _buildHeaderCellContainer( column, idx, sortDirection, totalColumnHeaderWidth );\n            totalColumnHeaderWidth += column.drawnWidth;\n\n            //Add header container to header element\n            headerElement.appendChild( headerContainer );\n        }\n        let headerHeight = util.getTableHeaderHeight( _tableInstance.gridOptions, Const.HEIGHT_HEADER ) + 'px';\n        headerElement.style.height = headerHeight;\n        headerElement.style.minHeight = headerHeight;\n        headerElement.style.maxHeight = headerHeight;\n        headerElement.style.minWidth = String( totalColumnHeaderWidth ) + 'px';\n    };\n\n    var _createGrip = function() {\n        _grip = document.createElement( 'div' );\n        _grip.classList.add( Const.CLASS_COLUMN_RESIZE_GRIP );\n        _grip.style.position = 'absolute';\n        _grip.style.height = '100%';\n\n        // Try to make border in the middle\n        var subGrip = document.createElement( 'div' );\n        subGrip.style.borderLeft = '1px solid';\n        subGrip.style.marginLeft = '30px';\n        subGrip.style.height = '100%';\n        _grip.appendChild( subGrip );\n\n        _grip.style.zIndex = '1000';\n        _grip.style.cursor = 'col-resize';\n        _grip.style.outline = '20px transparent';\n        _grip.style.width = '60px';\n        _grip.style.display = 'none';\n        return _grip;\n    };\n\n    var removeHoverClassFromRows = function() {\n        var rows = _trv.getTableContainerElementFromTable().getElementsByClassName( 'ui-grid-row' );\n        for( var i = 0; i < rows.length; i++ ) {\n            rows[ i ].classList.remove( Const.CLASS_ROW_HOVER );\n        }\n    };\n\n    var removeHoverClassesRaf = function() {\n        requestAnimationFrame( function() {\n            removeHoverClassFromRows();\n        } );\n    };\n\n    var _constructTableElement = function() {\n        var columnDefs = _columnDefs;\n\n        // Table Container\n        var tableContainer = document.createElement( 'div' );\n        tableContainer.classList.add( Const.CLASS_TABLE_CONTAINER );\n        tableContainer.tabIndex = 0;\n        if( _tableInstance.gridOptions.useTree === true ) {\n            tableContainer.setAttribute( 'role', 'treegrid' );\n        } else {\n            tableContainer.setAttribute( 'role', 'grid' );\n        }\n        if( _tableInstance.dataProvider.selectionModel.mode === 'multiple' ) {\n            tableContainer.setAttribute( 'aria-multiselectable', 'true' );\n        } else {\n            tableContainer.setAttribute( 'aria-multiselectable', 'false' );\n        }\n\n        if( _tableInstance.gridOptions.enableCellHeaderSelection === true ) {\n            tableContainer.classList.add( Const.CLASS_HEADER_SELECTION_ENABLED );\n        }\n\n        self.setAriaRowCount( tableContainer );\n        self.setAriaColCount( tableContainer, _tableInstance.dataProvider.cols );\n\n        _table.appendChild( tableContainer );\n\n        self.initializeColumnWidths();\n\n        // Do pin initialization after eval column width so we could\n        // Dummy Comment\n        // collect container size together\n        self.setPinContext();\n\n        // Create dragging grip.\n        tableContainer.appendChild( _createGrip() );\n        var pinContainer = document.createElement( 'div' );\n        pinContainer.classList.add( Const.CLASS_PIN_CONTAINER );\n        pinContainer.classList.add( Const.CLASS_PIN_CONTAINER_LEFT );\n        if( _tableInstance.gridOptions.transpose === true ) {\n            pinContainer.classList.add( Const.CLASS_COMPARE_CONTAINER );\n        }\n\n        var pinHeaderElem = document.createElement( 'div' );\n        pinHeaderElem.classList.add( Const.CLASS_HEADER_ROW );\n        _insertColumnHeaders( pinHeaderElem, 0, _pinColumnCount );\n        pinContainer.appendChild( pinHeaderElem );\n\n        var pinScrollContainer = document.createElement( 'div' );\n        pinScrollContainer.classList.add( Const.CLASS_CANVAS );\n        pinScrollContainer.classList.add( Const.CLASS_VIEWPORT );\n\n        var pinScrollContents = document.createElement( 'div' );\n        pinScrollContents.addEventListener( 'mouseleave', function() {\n            removeHoverClassesRaf();\n        } );\n        pinScrollContents.classList.add( Const.CLASS_SCROLL_CONTENTS );\n        _setScrollContentMinWidth( pinScrollContents, parseInt( pinHeaderElem.style.minWidth, 10 ) );\n\n        pinScrollContainer.appendChild( pinScrollContents );\n        pinContainer.appendChild( pinScrollContainer );\n\n        tableContainer.appendChild( pinContainer );\n\n        var scrollContainer = document.createElement( 'div' );\n        scrollContainer.classList.add( Const.CLASS_SCROLL_CONTAINER );\n        scrollContainer.style.marginLeft = String( _pinContainerWidth ) + 'px';\n\n        // Create Columns in memory\n        var scrollHeaderElem = document.createElement( 'div' );\n        scrollHeaderElem.classList.add( Const.CLASS_HEADER_ROW );\n        _insertColumnHeaders( scrollHeaderElem, _pinColumnCount, columnDefs.length );\n        scrollContainer.appendChild( scrollHeaderElem );\n\n        // Create row Contents in memory\n        var rowsContainer = document.createElement( 'div' );\n        rowsContainer.classList.add( Const.CLASS_VIEWPORT );\n        rowsContainer.classList.add( Const.CLASS_CANVAS );\n\n        var scrollContents = document.createElement( 'div' );\n        scrollContents.addEventListener( 'mouseleave', function() {\n            removeHoverClassesRaf();\n        } );\n        scrollContents.classList.add( Const.CLASS_SCROLL_CONTENTS );\n        _setScrollContentMinWidth( scrollContents, parseInt( scrollHeaderElem.style.minWidth, 10 ) );\n\n        rowsContainer.appendChild( scrollContents );\n\n        scrollContainer.appendChild( rowsContainer );\n        tableContainer.appendChild( scrollContainer );\n    };\n\n    /**\n     * @memberOf js/aw-splm-table.directive\n     *\n     * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n     * and the given column (columnInfo )\n     * @param {Object} column - Declarative columnInfo object\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     * @param {Number} columnWidth - Width of the iconCellColumn\n     * @param {HTMLElement} rowElem - row DOMElement\n     * @return {HTMLElement} The newly created DOMElement for the property cell\n     */\n    const _createPropertyCell = function( column, vmo, columnWidth, rowElem ) {\n        const cell = util.createElement( 'div', Const.CLASS_CELL );\n        cell.tabIndex = -1;\n        if( _tableInstance.dynamicRowHeightStatus ) {\n            cell.classList.add( Const.CLASS_CELL_DYNAMIC );\n        }\n        if( column.colSelected ) {\n            cell.classList.add( Const.CLASS_COLUMN_SELECTED );\n            cell.classList.add( Const.CLASS_CELL_SELECTED );\n        }\n        const defaultRowHeight = appCtxSvc.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n        const rowHeight = util.getTableRowHeight( _tableInstance.gridOptions, defaultRowHeight );\n        cell.style.width = `${columnWidth}px`;\n        cell.style.height = _tableInstance.dynamicRowHeightStatus ? 'auto' : rowHeight + 'px';\n\n        cell.appendChild( Cell.createElement( column, vmo, tableElem, rowElem ) );\n\n        if( column.field === 'transposedColumnProperty' ) {\n            cell.setAttribute( 'role', 'rowheader' );\n        } else {\n            cell.setAttribute( 'role', 'gridcell' );\n        }\n\n        cell.propName = column.field;\n        cell.columnDef = column;\n        if( vmo.props ) {\n            cell.prop = vmo.props[ column.field ];\n        }\n\n        const cellTops = cell.getElementsByClassName( 'aw-splm-tableCellTop' );\n        if( cellTops.length > 0 ) {\n            util.addCSSClassForRowHeight( cellTops[ 0 ], _tableInstance.gridOptions );\n        }\n\n        const idxNum = document.createAttribute( dataIndexNumber );\n        idxNum.value = column.index;\n        if( column.index >= _pinColumnCount ) {\n            idxNum.value = column.index - _pinColumnCount;\n        }\n        cell.setAttributeNode( idxNum );\n\n        // aria-colindex always starts with index 1.\n        cell.setAttribute( ariaColIndex, column.index + 1 );\n        // Set click listener for cell to get editable states\n        tableEditor.addCellClickListener( cell, vmo );\n        _keyboardService.setOnFocusAndBlur( cell );\n        _keyboardService.setupInternalCellNavigation( cell );\n\n        return cell;\n    };\n\n    /**\n     * Adds the aria attributes for tree if the row is part of a tree table\n     * @param {HTMLElement} row - the row element\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     */\n    const _setAriaAttributesForTreeRow = function( row, vmo ) {\n        if( _tableInstance.gridOptions.useTree === true ) {\n            if( vmo.isLeaf === false ) {\n                if( vmo.isExpanded === true ) {\n                    row.setAttribute( 'aria-expanded', 'true' );\n                } else {\n                    row.setAttribute( 'aria-expanded', 'false' );\n                }\n            }\n            // aria-level starts from index 1.\n            row.setAttribute( 'aria-level', vmo.levelNdx + 1 );\n        }\n    };\n\n    /**\n     * Adds the mouseenter event listener to apply hover styling to the row.\n     * @param {HTMLElement} row - the row element\n     */\n    const _addRowHoverListener = function( row ) {\n        row.addEventListener( 'mouseenter', function( event ) {\n            const hoveredRow = event.currentTarget;\n            requestAnimationFrame( function() {\n                removeHoverClassFromRows();\n                const index = util.getIndexInParent( hoveredRow );\n                const scrollRow = _trv.getScrollContentRowElementFromTable( index );\n                const pinRow = _trv.getPinContentRowElementFromTable( index );\n                scrollRow.classList.add( Const.CLASS_ROW_HOVER );\n                pinRow.classList.add( Const.CLASS_ROW_HOVER );\n            } );\n        } );\n    };\n\n    /**\n     * Adds the selection checkbox to the row\n     * @param {HTMLElement} row - the row element\n     * @param {HTMLElement} tableElem - the table element\n     * @param {Object[]} columnDefs - array of column defs\n     */\n    const _addRowCheckBox = function( row, tableElem, columnDefs ) {\n        // var commandBarHtml =\n        // <div class=\"aw-splm-tableCheckBoxPresent\">\n        //   <a class=\"aw-commands-cellCommandCommon\">\n        //     <span class=\"sw-checkbox-val\">\n        //       <input class=\"sw-property-val\" type=\"checkbox\">\n        //       <span class=\"sw-checkbox-pseudo\"></span>\n        //     </span>\n        //   </a>\n        // </div>\n        let checkBox = util.createElement( 'div', Const.CLASS_CELL_CHECKBOX );\n        let wrapperAElement = util.createElement( 'a', 'aw-commands-cellCommandCommon' );\n        let wrapperCheckboxDiv = util.createElement( 'span', 'sw-checkbox-val' );\n\n        let inputElement = util.createElement( 'input', Const.CLASS_CELL_CHECKBOX_BUTTON );\n        let checkboxTypeAttr = document.createAttribute( 'type' );\n        checkboxTypeAttr.value = 'checkbox';\n        inputElement.setAttributeNode( checkboxTypeAttr );\n\n        let commandDef = columnDefs.filter( function( def ) {\n            if( def.isTableCommand || def.isTreeNavigation ) {\n                return true;\n            }\n            return false;\n        } )[ 0 ];\n        let propName = commandDef && ( commandDef.propertyName || commandDef.name );\n        if( propName && row.vmo && row.vmo.props && row.vmo.props[ propName ] ) {\n            let value = row.vmo.props[ propName ].uiValue;\n            let checkboxLabelAttr = document.createAttribute( 'aria-label' );\n            checkboxLabelAttr.value = value;\n            inputElement.setAttributeNode( checkboxLabelAttr );\n        }\n\n        let spanCheckboxStyle = document.createElement( 'span' );\n        spanCheckboxStyle.classList.add( 'sw-checkbox-pseudo' );\n\n        // Do we really need this intermediate span? Commenting for now. Will remove once all table related auto tests pass\n        // var spanCheckElem = document.createElement( 'span' );\n        // spanCheckElem.classList.add( 'check' );\n        // spanCheckboxStyle.appendChild( spanCheckElem );\n\n        wrapperCheckboxDiv.appendChild( inputElement );\n        wrapperCheckboxDiv.appendChild( spanCheckboxStyle );\n\n        wrapperAElement.appendChild( wrapperCheckboxDiv );\n\n        checkBox.appendChild( wrapperAElement );\n\n        // We should not need following lines. Commenting for now. Will remove once all table related auto tests pass\n        // var cellScope = {};\n        // var checkBox = util.createNgElement( commandBarHtml, tableElem, cellScope );\n\n        row.appendChild( checkBox );\n    };\n\n    /**\n     * Creates and returns a DOMElement for the TableRow of the passed in view model object (vmo) which defines the row\n     * Will Create cells for each column using the vmo properties associated by propertyName.  Also will prepend an\n     * iconCell at the beginning of the row.  Appropriate rowSelection callback will be added too.\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     * @param {number} rowHeight - the pixel row height\n     * @param {number} startIdx - the column start index\n     * @param {number} endIdx - the column end index\n     *\n     * @return {HTMLElement} row - the created row element\n     */\n    const _createContentRowElement = function( vmo, rowHeight, startIdx, endIdx ) {\n        const columnDefs = _columnDefs;\n        const row = util.createElement( 'div', Const.CLASS_ROW, Const.CLASS_UI_GRID_ROW, Const.CLASS_ROW_ICON );\n        let rowWidth = 0;\n        row.vmo = vmo;\n        //only add role=row if we are sure role=gridcell or role=rowheader will be added as its descendents else it will cause aria-required-children violation.\n        if( startIdx <= endIdx ) {\n            row.setAttribute( 'role', 'row' );\n        }\n\n        _setAriaAttributesForTreeRow( row, vmo );\n\n        // LCS-286849 - jQuery has issues with handling touch to click events on mobile\n        let target = {\n            default: row,\n            mobile: row\n        };\n        let eventObject = {\n            click: 'touchend'\n        };\n        awEventHelperService.subscribeMouseEvent( target, eventObject, SelectionHelper.selectionChanged( _table ) );\n\n        row.oncontextmenu = _menuService.contextSelectionHandler;\n        row.draggable = true;\n\n        _addRowHoverListener( row );\n\n        if( vmo.rowStatus && vmo.rowStatus === 'ADDED' ) {\n            row.classList.add( 'aw-jswidgets-change' );\n        } else if( vmo.rowStatus && vmo.rowStatus === 'REMOVED' ) {\n            row.classList.add( 'aw-jswidgets-oldText' );\n        }\n\n        let adjustedColumnDefs = _.sortBy( columnDefs, function( columnDef ) {\n            return columnDef.index;\n        } );\n        _.forEach( adjustedColumnDefs, function( currentColumn ) {\n            if( row.vmo.props && row.vmo.props[ currentColumn.field ] ) {\n                row.vmo.props[ currentColumn.field ].renderingHint = currentColumn.renderingHint;\n            }\n        } );\n\n        for( let i = startIdx; i <= endIdx; i++ ) {\n            const column = adjustedColumnDefs[ i ];\n            let cell = null;\n            let _width = column.drawnWidth;\n            const showCheckBox = _tableInstance.showCheckBox;\n            if( i === 0 && showCheckBox ) {\n                _addRowCheckBox( row, tableElem, adjustedColumnDefs );\n            }\n            cell = _createPropertyCell( column, vmo, _width, row );\n\n            rowWidth += _width;\n            row.appendChild( cell );\n        }\n\n        row.style.minWidth = String( rowWidth ) + 'px';\n        row.style.minHeight = String( rowHeight ) + 'px';\n\n        return row;\n    };\n\n    /**\n     * Remove the class and title from the filter icon element.\n     *\n     * @param {HTMLElement} iconElement - Filter icon element\n     */\n    const _removeFilterIcon = function( iconElement ) {\n        iconElement.classList.remove( Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON );\n        iconElement.title = '';\n    };\n\n    self.updateScrollColumnsInView = function( scrollLeft, scrollContainerWidth ) {\n        var headerCells = _trv.getScrollHeaderElementFromTable().children;\n        // Find start and end visible columns\n        var extraColumns = 3;\n        var start = null;\n        var end = null;\n        var totalHeaderCells = headerCells.length;\n\n        // Return all columns as in view if container width given is null or undefined\n        if( scrollContainerWidth === null || scrollContainerWidth === undefined || scrollContainerWidth === 0 ) {\n            _scrollColumnsInView = { start: 0, end: totalHeaderCells - 1 };\n            return;\n        }\n\n        for( var i = 0; i < totalHeaderCells; i++ ) {\n            var column = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var columnStartPosition = column.startPosition;\n\n            if( columnStartPosition <= scrollLeft ) {\n                start = i;\n            }\n            if( columnStartPosition <= scrollLeft + scrollContainerWidth ) {\n                end = i;\n            }\n        }\n\n        start = start - extraColumns < 0 ? 0 : start - extraColumns;\n        end = end + extraColumns > totalHeaderCells - 1 ? totalHeaderCells - 1 : end + extraColumns;\n\n        _scrollColumnsInView = { start: start, end: end };\n    };\n\n    self.updateVisibleCells = function( rowParentElem ) {\n        const startColumnIdx = _scrollColumnsInView.start;\n        const endColumnIdx = _scrollColumnsInView.end;\n        rowParentElem = rowParentElem.childNodes;\n        const scrollHeader = _trv.getScrollHeaderElementFromTable();\n        const scrollContentElem = _trv.getScrollContentElementFromTable();\n        const headerCells = scrollHeader.children;\n        let minWidth = 0;\n\n        for( let i = startColumnIdx; i < headerCells.length; i++ ) {\n            const column = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            if( startColumnIdx !== null ) {\n                minWidth += column.drawnWidth;\n            }\n        }\n\n        let paddingLeft = null;\n        const scrollHeaderElemMinWidth = scrollHeader.style.minWidth;\n        if( startColumnIdx > 0 ) {\n            const paddingLeftColumnDef = headerCells[ startColumnIdx - 1 ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            paddingLeft = paddingLeftColumnDef.startPosition + paddingLeftColumnDef.drawnWidth + 'px';\n        } else {\n            paddingLeft = '0px';\n        }\n        scrollContentElem.style.paddingLeft = paddingLeft;\n        const scrollContentMinWidth = parseInt( scrollHeaderElemMinWidth, 10 ) - parseInt( paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n\n        // Update cell visibility\n        const scrollRows = rowParentElem;\n        for( let j = 0; j < scrollRows.length; j++ ) {\n            const rowCells = scrollRows[ j ].children;\n            if( rowCells.length === 0 ) {\n                continue;\n            }\n            const row = scrollRows[ j ];\n            row.style.minWidth = minWidth + 'px';\n            const currentStartIndex = rowCells[ 0 ].columnDef.index;\n            const currentEndIndex = rowCells[ rowCells.length - 1 ].columnDef.index;\n            const trueStartColumnIndex = startColumnIdx + _pinColumnCount;\n            const trueEndColumnIndex = endColumnIdx + _pinColumnCount;\n            for( let k = rowCells.length - 1; k >= 0; k-- ) {\n                const cell = rowCells[ k ];\n                const colIndex = cell.columnDef.index;\n\n                // Remove out of view cells\n                if( colIndex < trueStartColumnIndex || colIndex > trueEndColumnIndex ) {\n                    util.destroyChildElements( cell );\n                    cell.parentElement.removeChild( cell );\n                }\n            }\n\n            for( let l = currentStartIndex - 1; l >= trueStartColumnIndex; l-- ) {\n                const newCellInsertBefore = _createPropertyCell( _columnDefs[ l ], row.vmo, _columnDefs[ l ].drawnWidth, row );\n                row.insertBefore( newCellInsertBefore, row.children[ 0 ] );\n                tableEditor.updateEditStatusForCell( newCellInsertBefore );\n            }\n\n            for( let m = currentEndIndex + 1; m <= trueEndColumnIndex; m++ ) {\n                const newCellInsertAfter = _createPropertyCell( _columnDefs[ m ], row.vmo, _columnDefs[ m ].drawnWidth, row );\n                row.appendChild( newCellInsertAfter );\n                tableEditor.updateEditStatusForCell( newCellInsertAfter );\n            }\n        }\n    };\n\n    // LCS-323044 - IE11 - aw-splm-table ascending and descending icon not showing\n    // IE lacks support for multiple arguments in classlist.remove - https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n    const _removeAllSortDirectionClasses = function( sortElement ) {\n        sortElement.classList.remove( Const.CLASS_ICON_SORT_ASC );\n        sortElement.classList.remove( Const.CLASS_ICON_SORT_DESC );\n        sortElement.classList.remove( Const.CLASS_ICON_NON_SORTABLE );\n        sortElement.classList.remove( Const.CLASS_ICON_SORTABLE );\n    };\n\n    // ////////////////////////////////////////////////\n    // Public method\n    // ////////////////////////////////////////////////\n    self.getColumnMinWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].minWidth;\n    };\n\n    self.getColumnMaxWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].maxWidth;\n    };\n\n    self.getColumnWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].drawnWidth;\n    };\n\n    const updateColumnStartPositions = function() {\n        let pinContainerWidth = 0;\n        let scrollContainerWidth = 0;\n        for( let i = 0; i < _columnDefs.length; i++ ) {\n            if( i < _pinColumnCount ) {\n                _columnDefs[ i ].startPosition = pinContainerWidth;\n                pinContainerWidth += _columnDefs[ i ].drawnWidth;\n            } else {\n                _columnDefs[ i ].startPosition = scrollContainerWidth;\n                scrollContainerWidth += _columnDefs[ i ].drawnWidth;\n            }\n        }\n    };\n\n    /**\n     * @memberOf js/splmTableDomController\n     *\n     * This method is used for updating the column width\n     * This method is also called from resetColumnDefs with 0,0 arguments which needs to be corrected.\n     * @param {Number} columnIdx - column index\n     * @param {Number} deltaWidth - delta width\n     */\n    self.updateColumnWidth = function( columnIdx, deltaWidth ) {\n        let width = self.getColumnWidth( columnIdx ) + deltaWidth;\n\n        _setHeaderColumnWidth( columnIdx, width );\n        _setContentColumnWidth( columnIdx, width );\n\n        if( columnIdx < _pinColumnCount ) {\n            // Set container\n            _pinContainerWidth += deltaWidth;\n            _setPinHeaderWidth( _pinContainerWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n        } else {\n            // Set container\n            _scrollContainerWidth += deltaWidth;\n            _setScrollHeaderWidth( _scrollContainerWidth );\n        }\n\n        // Update columnDef start positions\n        if( deltaWidth !== 0 ) {\n            _columnDefs[ columnIdx ].drawnWidth = width;\n\n            _tableInstance.tableInstanceCallbacks.columnsResized( {\n                name: _columnDefs[ columnIdx ].name,\n                delta: deltaWidth\n            } );\n        }\n\n        updateColumnStartPositions();\n        let scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth );\n\n        if( deltaWidth !== 0 ) {\n            self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n        }\n    };\n\n    /**\n     * Update the filter icon for the header of the column name given.\n     *\n     * @param {String} columnName - column name for the header to update\n     */\n    self.updateFilterIcon = function( columnName ) {\n        var headerCells = _trv.getHeaderCellElementsFromTable();\n        for( var i = 0; i < headerCells.length; i++ ) {\n            var columnDef = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var filterIconElement = headerCells[ i ].getElementsByClassName( Const.CLASS_HEADER_CELL_FILTER_ICON )[ 0 ];\n\n            if( columnDef && columnDef.filter && filterIconElement && columnDef.field === columnName ) {\n                if( columnDef.filter.isFilterApplied ) {\n                    _applyFilterIcon( filterIconElement, columnDef.filter );\n                } else {\n                    _removeFilterIcon( filterIconElement );\n                }\n                break;\n            }\n        }\n    };\n\n    /**\n     * Update the filter icon for all column headers.\n     */\n    self.updateAllFilterIcons = function() {\n        var headerCells = _trv.getHeaderCellElementsFromTable();\n        for( var i = 0; i < headerCells.length; i++ ) {\n            var columnDef = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var filterIconElement = headerCells[ i ].getElementsByClassName( Const.CLASS_HEADER_CELL_FILTER_ICON )[ 0 ];\n\n            if( columnDef && columnDef.filter && filterIconElement ) {\n                if( columnDef.filter.isFilterApplied ) {\n                    _applyFilterIcon( filterIconElement, columnDef.filter );\n                } else {\n                    _removeFilterIcon( filterIconElement );\n                }\n            }\n        }\n    };\n\n    /**\n     * Fit column width with content in canvas\n     * NOTE: This mentod will read computed CSS which may cause reflow\n     *\n     * @param {Number} columnIdx - Last column index.\n     *\n     */\n    self.fitColumnWidth = function( columnIdx ) {\n        var treeNavigation = _columnDefs[ columnIdx ].isTreeNavigation;\n        var cellElems = _trv.queryRowColumnCellElementsFromTable( columnIdx );\n        var maxWidth = 0;\n        var headerTextElement = _trv.getHeaderCellElementFromTable( columnIdx ).getElementsByClassName( Const.CLASS_HEADER_CELL_INNER )[ 0 ];\n        maxWidth = util.getElementTextWidth( headerTextElement );\n\n        var filterOption = _tableInstance.gridOptions.isFilteringEnabled;\n        var sortOption = _tableInstance.gridOptions.enableSorting;\n        // This is the space occupied after the column name which includes column menu, splitter, resizeGrip etc.\n        if( filterOption || sortOption ) {\n            maxWidth += Const.WIDTH_MINIMUM_EXTRA_SPACE;\n        }\n\n        cellElems.forEach( function( cellElem ) {\n            var actualWidth;\n            // Tree navigation cell\n            if( treeNavigation ) {\n                // pass entire cellElem into getCellTextWidth because it calculates\n                // What the width of an unobstructed element with height and width set to auto will be\n                // This will give width of entire cell up until the end of the text for tree nav cells\n                actualWidth = util.getElementTextWidth( cellElem );\n                maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n            } else {\n                // cover text and link for now.\n                var valueElems = cellElem.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT );\n                if( valueElems.length === 0 ) {\n                    valueElems = cellElem.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                }\n                for( var i = 0; i < valueElems.length; i++ ) {\n                    actualWidth = util.getElementTextWidth( valueElems[ i ] );\n                    maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n                }\n            }\n        } );\n\n        if( maxWidth > 0 ) {\n            var currentWidth = self.getColumnWidth( columnIdx );\n            var validWidth = self.getValidColumnWidth( columnIdx, maxWidth );\n            if( currentWidth !== validWidth ) {\n                self.updateColumnWidth( columnIdx, validWidth - currentWidth );\n            }\n        }\n    };\n\n    /**\n     * Update column visibility for hidden columns\n     *\n     * @param {String} columnName - column name\n     */\n    self.updateColumnVisibility = function( columnName ) {\n        var adjustedColumnIdx = self.getIdxFromColumnName( columnName );\n\n        // Remove hidden column header from DOM\n        var headerCellElem = _trv.getHeaderCellElementFromTable( adjustedColumnIdx );\n        if( headerCellElem && headerCellElem.parentElement ) {\n            headerCellElem.parentElement.removeChild( headerCellElem );\n        }\n        // Remove hidden column rows from DOM\n        var rowCount = _getContentRowCount();\n        for( var i = 0; i < rowCount; i++ ) {\n            var rowCellElem = _trv.getContentCellFromTable( i, adjustedColumnIdx );\n            if( rowCellElem && rowCellElem.parentElement ) {\n                rowCellElem.parentElement.removeChild( rowCellElem );\n            }\n        }\n\n        _columnDefs[ adjustedColumnIdx ].visible = false;\n        _columnDefs.splice( adjustedColumnIdx, 1 );\n\n        // Adjust column indices to account for removed column\n        _.forEach( _columnDefs, function( columnDef, index ) {\n            columnDef.index = index;\n        } );\n\n        self.resetColumnDefs( _columnDefs );\n\n        var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n    };\n\n    var _updateCellColumnIndexes = function() {\n        var cellElements = _trv.getContentCellElementsFromTable();\n\n        for( var i = 0; i < cellElements.length; i++ ) {\n            var cellElement = cellElements[ i ];\n            var column = cellElement.columnDef;\n\n            var idxNum = document.createAttribute( dataIndexNumber );\n            idxNum.value = column.index;\n            if( column.index >= _pinColumnCount ) {\n                idxNum.value = column.index - _pinColumnCount;\n            }\n            cellElement.setAttributeNode( idxNum );\n            updateColumnStartPositions();\n        }\n    };\n\n    var _pinHeader = function( columnIdx ) {\n        // Check existing column index\n        var newPinCount = columnIdx + 1;\n        var oldPinCount = _pinColumnCount;\n\n        // Update Existing DOM\n        var headerCellElements = _trv.getHeaderCellElementsFromTable();\n        var moveFragment = document.createDocumentFragment();\n        var deltaWidth = 0;\n        if( oldPinCount < newPinCount ) {\n            // Update Header\n            for( var i = oldPinCount; i < newPinCount; i++ ) {\n                moveFragment.appendChild( headerCellElements[ oldPinCount ] );\n                deltaWidth += self.getColumnWidth( i );\n            }\n            var pinHeaderElem = _trv.queryPinContainerFromTable().toHeader().getElement();\n            pinHeaderElem.appendChild( moveFragment );\n\n            _setPinHeaderWidth( _pinContainerWidth + deltaWidth );\n            _setScrollHeaderWidth( _scrollContainerWidth - deltaWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth + deltaWidth ) + 'px';\n        } else if( oldPinCount > newPinCount ) {\n            // Update Header\n            for( var j = newPinCount; j < oldPinCount; j++ ) {\n                moveFragment.appendChild( headerCellElements[ newPinCount ] );\n                deltaWidth += self.getColumnWidth( j );\n            }\n            var scrollHeaderElem = _trv.queryScrollContainerFromTable().toHeader().getElement();\n            scrollHeaderElem.insertBefore( moveFragment, scrollHeaderElem.childNodes[ 0 ] );\n            _setPinHeaderWidth( _pinContainerWidth - deltaWidth );\n            _setScrollHeaderWidth( _scrollContainerWidth + deltaWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth - deltaWidth ) + 'px';\n        }\n    };\n\n    var _pinContent = function( columnIdx ) {\n        // Check existing column index\n        var newPinCount = columnIdx + 1;\n        var oldPinCount = _pinColumnCount;\n\n        // Update Existing DOM\n        var moveFragment = document.createDocumentFragment();\n        var pinContentRowElements = _trv.queryPinContainerFromTable().getContentRowElements();\n        var scrollContentRowElements = _trv.queryScrollContainerFromTable().getContentRowElements();\n        var count = pinContentRowElements.length;\n        var deltaWidth = 0;\n        if( oldPinCount < newPinCount ) {\n            for( var i = 0; i < count; i++ ) {\n                deltaWidth = 0;\n                for( var j = oldPinCount; j < newPinCount; j++ ) {\n                    moveFragment.appendChild( scrollContentRowElements[ i ].children[ 0 ] );\n                    deltaWidth += self.getColumnWidth( j );\n                }\n                pinContentRowElements[ i ].appendChild( moveFragment );\n                _setContentRowWidth( pinContentRowElements[ i ], _pinContainerWidth + deltaWidth );\n                _setContentRowWidth( scrollContentRowElements[ i ], _scrollContainerWidth - deltaWidth );\n            }\n        } else if( oldPinCount > newPinCount ) {\n            for( var k = 0; k < count; k++ ) {\n                deltaWidth = 0;\n                for( var l = newPinCount; l < oldPinCount; l++ ) {\n                    moveFragment.appendChild( pinContentRowElements[ k ].children[ newPinCount ] );\n                    deltaWidth += self.getColumnWidth( l );\n                }\n                scrollContentRowElements[ k ].insertBefore( moveFragment, scrollContentRowElements[ k ].childNodes[ 0 ] );\n                _setContentRowWidth( pinContentRowElements[ k ], _pinContainerWidth - deltaWidth );\n                _setContentRowWidth( scrollContentRowElements[ k ], _scrollContainerWidth + deltaWidth );\n            }\n        }\n    };\n\n    /**\n     * Pin the table from column 0 to specific column\n     *\n     * @param {Number} columnIdx - Last column index.\n     *\n     */\n    self.pinToColumn = function( columnIdx ) {\n        // Bring back all cells that were virtualized before moving cells to proper container\n        var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n\n        _pinHeader( columnIdx );\n        _pinContent( columnIdx );\n\n        self.setPinContext( columnIdx );\n\n        let colDef = _columnDefs[ columnIdx ];\n        let pinCanvasElement = _trv.getPinCanvasElementFromTable();\n        pinCanvasElement.scrollLeft = colDef.startPosition;\n        let traversalTable = new Trv( _table );\n        util.syncHeader( traversalTable, true, pinCanvasElement.scrollLeft );\n\n        _updateCellColumnIndexes();\n\n        // Virtualize cells\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n    };\n\n    self.resetFreezeScroll = function( columnField ) {\n        let startPosition = 0;\n        if( _columnDefs && _columnDefs.length ) {\n            for( var i = 0; i < _columnDefs.length; i++ ) {\n                if( _columnDefs[ i ].field === columnField ) {\n                    startPosition = _columnDefs[ i ].startPosition;\n                }\n            }\n        }\n        let scrollLeft = startPosition;\n        // set scroll container to this position to keep header focused\n        let scrollCanvas = _trv.getScrollCanvasElementFromTable();\n        scrollCanvas.scrollLeft = scrollLeft;\n    };\n\n    /**\n     * Finds the current columns that are pinned in the table\n     *\n     * @returns {Array} all the columns that are pinned\n     */\n    var _findPinnedColumns = function() {\n        var results = [];\n        if( _columnDefs && _columnDefs.length ) {\n            for( var i = 0; i < _columnDefs.length; i++ ) {\n                if( _columnDefs[ i ].pinnedLeft === true ) {\n                    results.push( _columnDefs[ i ] );\n                }\n            }\n        }\n        return results;\n    };\n\n    /**\n     * Checks new columns for any previous pinned columns, then returns index of first found.\n     *\n     * @param {*} newColumns The new columns coming into the table\n     * @param {*} pinnedColumns The old pinned columns that were pinned\n     * @returns {Number} the first index of an incoming column\n     */\n    var findPinIndex = function( newColumns, pinnedColumns ) {\n        var pinIndex;\n        if( _.isArray( pinnedColumns ) && _.isArray( newColumns ) ) {\n            for( var i = pinnedColumns.length - 1; i >= 0; i-- ) {\n                for( var j = 0; j < newColumns.length; j++ ) {\n                    if( pinnedColumns[ i ].name && ( pinnedColumns[ i ].name === newColumns[ j ].name ||\n                            pinnedColumns[ i ].name === newColumns[ j ].field ) ) {\n                        pinIndex = newColumns[ j ].index;\n                        break;\n                    }\n                }\n                if( pinIndex ) {\n                    break;\n                }\n            }\n        }\n        return pinIndex;\n    };\n\n    self.getColumnDefs = function() {\n        return _columnDefs;\n    };\n\n    self.resetColumnDefs = function( columnDefs ) {\n        var previouslyPinnedColumns = _findPinnedColumns();\n        var currentPinIndex = findPinIndex( columnDefs, previouslyPinnedColumns );\n\n        _columnDefs = columnDefs;\n\n        self.initializeColumnWidths();\n        self.setPinContext( currentPinIndex );\n\n        var pinContainerElem = _trv.getPinContainerElementFromTable();\n        var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n        var pinContentElem = _trv.getPinContentElementFromTable();\n        pinHeaderElem.innerHTML = '';\n        _insertColumnHeaders( pinHeaderElem, 0, _pinColumnCount );\n        pinContainerElem.replaceChild( pinHeaderElem, pinContainerElem.children[ 0 ] );\n        _setScrollContentMinWidth( pinContentElem, parseInt( pinHeaderElem.style.minWidth, 10 ) );\n\n        var scrollContainerElem = _trv.getScrollContainerElementFromTable();\n        var scrollHeaderElem = _trv.getScrollHeaderElementFromTable();\n        var scrollContentElem = _trv.getScrollContentElementFromTable();\n        scrollHeaderElem.innerHTML = '';\n        _insertColumnHeaders( scrollHeaderElem, _pinColumnCount, _columnDefs.length );\n        var scrollContentMinWidth = parseInt( scrollHeaderElem.style.minWidth, 10 ) - parseInt( scrollContentElem.style.paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n\n        if( scrollContainerElem.children.length === 0 ) {\n            scrollContainerElem.appendChild( scrollHeaderElem );\n        }\n\n        self.updateColumnWidth( 0, 0 );\n        self.setAriaColCount( _trv.getTableContainerElementFromTable(), columnDefs );\n    };\n\n    self.isColumnWidthChangeValid = function( columnIdx, deltaWidth ) {\n        var targetWidth = self.getColumnWidth( columnIdx ) + deltaWidth;\n        return self.getValidColumnWidth( columnIdx, targetWidth ) === targetWidth;\n    };\n\n    self.getValidColumnWidth = function( columnIdx, targetWidth ) {\n        var maxWidth = self.getColumnMaxWidth( columnIdx );\n        var minWidth = self.getColumnMinWidth( columnIdx );\n        minWidth = minWidth > Const.WIDTH_ALLOWED_MINIMUM_WIDTH ? minWidth : Const.WIDTH_ALLOWED_MINIMUM_WIDTH;\n\n        if( minWidth && targetWidth < minWidth ) {\n            targetWidth = minWidth;\n        } else if( maxWidth && targetWidth > maxWidth ) {\n            targetWidth = maxWidth;\n        } else {\n            // Do nothing\n        }\n        return targetWidth;\n    };\n\n    self.isColumnSplitterDraggable = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].enableColumnResizing !== false;\n    };\n\n    self.getTotalColumnWidth = function( columnIdx ) {\n        var width = 0;\n        var sum = columnIdx + 1;\n        for( var i = 0; i < sum; i++ ) {\n            width += self.getColumnWidth( i );\n        }\n        return width;\n    };\n\n    self.getIdxFromColumnName = function( columnField ) {\n        for( var i = 0; i < _columnDefs.length; i++ ) {\n            if( _columnDefs[ i ].field === columnField || _columnDefs[ i ].name === columnField ) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.setHeaderCellSortDirection = function( oldColumnIdx, newColumnIdx, sortDirection ) {\n        var sortElem;\n        var headerCellElem = null;\n        var sortDir = null;\n        if( sortDirection !== null && sortDirection !== '' ) {\n            // aria-sort supported sort values are ascending, descending, none and other.\n            sortDir = sortDirection.toLowerCase().includes( 'desc' ) ? 'descending' : 'ascending';\n        }\n        if( oldColumnIdx > -1 ) {\n            sortElem = _trv.getHeaderCellSortIconElementFromTable( oldColumnIdx );\n            _removeAllSortDirectionClasses( sortElem );\n            sortElem.classList.add( _getSortClassName( '' ) );\n            headerCellElem = _trv.getHeaderCellElementFromTable( oldColumnIdx );\n            if( headerCellElem !== null && headerCellElem.parentElement.hasAttribute( 'aria-sort' ) ) {\n                headerCellElem.parentElement.removeAttribute( 'aria-sort' );\n            }\n        }\n\n        sortElem = _trv.getHeaderCellSortIconElementFromTable( newColumnIdx );\n        _removeAllSortDirectionClasses( sortElem );\n        sortElem.classList.add( _getSortClassName( sortDirection ) );\n        headerCellElem = _trv.getHeaderCellElementFromTable( newColumnIdx );\n        if( headerCellElem !== null && sortDir !== null ) {\n            headerCellElem.parentElement.setAttribute( 'aria-sort', sortDir );\n        }\n    };\n\n    self.getScrollCanvasScrollLeftPosition = function() {\n        return _trv.getScrollCanvasElementFromTable().scrollLeft * -1;\n    };\n\n    self.getPinCanvasScrollLeftPosition = function() {\n        return _trv.getPinCanvasElementFromTable().scrollLeft * -1;\n    };\n\n    /**\n     * Applies the dynamic row heights to each row\n     *\n     * @param {DocumentFragment} contentRowFragment - the fragment of content rows to be applied to the DOM\n     * @param {DocumentFragment} tempContentRowFragment - the temporary fragment of content rows\n     * @param {number} rowHeight - the pixel row height\n     */\n    const _applyDynamicRowHeights = function( contentRowFragment, tempContentRowFragment, rowHeight ) {\n        let tempDivElem = document.createElement( 'div' );\n        tempDivElem.style.position = 'absolute';\n        tempDivElem.style.visibility = 'hidden';\n        tempDivElem.style.height = 'auto';\n        tempDivElem.style.width = 'auto';\n        const clonedNode = tempContentRowFragment.childNodes.length ? tempContentRowFragment : contentRowFragment.cloneNode( true );\n        tempDivElem.appendChild( clonedNode );\n        document.body.appendChild( tempDivElem );\n\n        // Now loop through rows\n        const newRows = tempDivElem.childNodes;\n        const rowsWithVMOs = contentRowFragment.childNodes;\n\n        const maxRowHeight = rowHeight * Const.MAX_ROW_HEIGHT_ROWS;\n\n        for( let i = 0; i < newRows.length; i++ ) {\n            const row = newRows[ i ];\n            const vmo = rowsWithVMOs[ i ].vmo;\n            let height = 0;\n            const cells = row.childNodes;\n\n            for( let j = 0; j < cells.length; j++ ) {\n                const cell = cells[ j ];\n                if( cell.childNodes[ 0 ] && cell.childNodes[ 0 ].classList.contains( Const.CLASS_SPLM_TABLE_ICON_CELL ) ) {\n                    continue;\n                } else if( cell.childNodes[ 0 ] && cell.childNodes[ 0 ].classList.contains( Const.CLASS_AW_TREE_COMMAND_CELL ) ) {\n                    // check if cell has data\n                    const _cell = cell.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT )[ 0 ];\n                    if( _cell ) {\n                        const cellHeight = _cell.offsetHeight + 15;\n                        height = cellHeight > height ? cellHeight : height;\n                    } else {\n                        height = rowHeight > height ? rowHeight : height;\n                    }\n                } else {\n                    const cellHeight = cell.offsetHeight + 11;\n                    height = cellHeight > height ? cellHeight : height;\n                }\n            }\n\n            // no larger than max height and no smaller than default row height\n            height = Math.min( Math.max( height, rowHeight ), maxRowHeight );\n\n            vmo.rowHeight = !vmo.rowHeight || height > vmo.rowHeight ? height : vmo.rowHeight;\n            // Mark each actual cell text with height if exists.\n            const cellsWithText = rowsWithVMOs[ i ].getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );\n            for( let k = 0; k < cellsWithText.length; k++ ) {\n                cellsWithText[ k ].style.maxHeight = String( vmo.rowHeight ) + 'px';\n            }\n        }\n\n        document.body.removeChild( tempDivElem );\n    };\n\n    /**\n     * Creates a group of row elements with cells spanning from the start and end column index.\n     *\n     * @param {Array} vmos - the array of vmos to create rows for\n     * @param {number} startIndex - the row start index\n     * @param {number} rowHeight - the pixel row height\n     * @param {number} startColumnIdx - the column start index\n     * @param {number} endColumnIdx - the column end index\n     * @param {boolean} isPin - true if the row contents are for the pin container\n     *\n     * @return {DocumentFragment} Document fragment containing the rows for the passed in vmos\n     */\n    const _constructContentElement = function( vmos, startIndex, rowHeight, startColumnIdx, endColumnIdx, isPin ) {\n        let contentRowFragment = document.createDocumentFragment();\n        let tempContentRowFragment = document.createDocumentFragment();\n\n        for( let keyIdx = 0; keyIdx < vmos.length; keyIdx++ ) {\n            let vmo = vmos[ keyIdx ];\n            const rowIndex = keyIdx + startIndex;\n            const idxNum = document.createAttribute( dataIndexNumber );\n            idxNum.value = rowIndex;\n            let row = null;\n            let mockrow = null;\n            if( isPin ) {\n                row = _createContentRowElement( vmo, rowHeight, startColumnIdx, endColumnIdx );\n                row.classList.add( Const.CLASS_PINNED_ROW );\n            } else {\n                if( _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null ) {\n                    startColumnIdx = _scrollColumnsInView.start + _pinColumnCount;\n                    endColumnIdx = _scrollColumnsInView.end + _pinColumnCount;\n                }\n                row = _createContentRowElement( vmo, rowHeight, startColumnIdx, endColumnIdx );\n                if( _tableInstance.dynamicRowHeightStatus ) {\n                    // If dynamic row height, we need to get the row height with all cells rendered, so endColumnIdx is the last item in columnDefs.\n                    mockrow = _createContentRowElement( vmo, rowHeight, startColumnIdx, _columnDefs.length - 1 );\n                    mockrow.setAttributeNode( idxNum.cloneNode() );\n                }\n            }\n\n            row.setAttributeNode( idxNum );\n            //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n            if( row.children.length > 0 ) {\n                row.setAttribute( ariaRowIndex, rowIndex + 2 );\n            }\n\n            // Add id attribute to each cell which will be refered by aria-activedescendant at grid level.\n            // The id attribute should be unique, so this will be a combination of gridid, aria-rowindex, aria-colindex.\n            let cellElements = row.childNodes;\n            let uniqueIdForCell;\n            for( let i = 0; i < cellElements.length; i++ ) {\n                if( cellElements[ i ].hasAttribute( ariaColIndex ) ) {\n                    uniqueIdForCell = _tableInstance.gridId + '_row' + row.getAttribute( ariaRowIndex ) + '_col' + cellElements[ i ].getAttribute( ariaColIndex );\n                    cellElements[ i ].setAttribute( 'id', uniqueIdForCell );\n                }\n            }\n            contentRowFragment.appendChild( row );\n            if( _tableInstance.dynamicRowHeightStatus && mockrow ) {\n                tempContentRowFragment.appendChild( mockrow );\n            }\n\n            if( isPin !== true && _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null ) {\n                self.updateVisibleCells( contentRowFragment );\n            }\n        }\n\n        // Dynamic Row Height - When flag is enabled\n        // find heights for rows by creating div and adding doc fragment\n        if( _tableInstance.dynamicRowHeightStatus ) {\n            _applyDynamicRowHeights( contentRowFragment, tempContentRowFragment, rowHeight );\n        }\n\n        return contentRowFragment;\n    };\n\n    self.constructContentElement = function( vmos, startIndex, rowHeight, isPin ) {\n        if( isPin === true ) {\n            // Set container\n            var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n            if( _tableInstance.showCheckBox === true ) {\n                if( !_alignContainersForCheckbox ) {\n                    _alignContainersForCheckbox = true;\n                    _pinContainerWidth += 32;\n                    pinHeaderElem.lastChild.style.width = pinHeaderElem.lastChild.clientWidth + 32 + 'px';\n                    _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n                }\n            } else if( !_tableInstance.showCheckBox && _alignContainersForCheckbox ) {\n                _alignContainersForCheckbox = false;\n                _pinContainerWidth -= 32;\n\n                pinHeaderElem.lastChild.style.width = '';\n                _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n            }\n            return _constructContentElement( vmos, startIndex, rowHeight, 0, _pinColumnCount - 1, isPin );\n        }\n\n        return _constructContentElement( vmos, startIndex, rowHeight, _pinColumnCount, _columnDefs.length - 1, isPin );\n    };\n\n    var _removeContentElement = function( parent, upperCountIdx, lowerCounterIdx ) {\n        var parentElement = parent.getElement();\n        var children = parent.getContentRowElements();\n        var uCountIdx = upperCountIdx || children.length - 1;\n        var lCountIdx = lowerCounterIdx || 0;\n\n        if( children && children.length > 0 ) {\n            for( ; uCountIdx >= lCountIdx; uCountIdx-- ) {\n                // Clean up edit cell scope if needed\n                var editCell = children[ uCountIdx ].getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP )[ 0 ] || children[ uCountIdx ].getElementsByClassName( Const\n                    .CLASS_TABLE_EDIT_CELL_TOP_ARRAY )[ 0 ];\n                if( editCell !== undefined && editCell.parentElement.prop !== undefined ) {\n                    editCell.parentElement.prop.isEditing = false;\n                }\n\n                // Cleanup any components being used dynamically\n                util.cleanupComponents( children[ uCountIdx ] );\n                parentElement.removeChild( children[ uCountIdx ] );\n            }\n        }\n    };\n\n    self.removeContentElement = function( upperCountIdx, lowerCounterIdx ) {\n        _removeContentElement( _trv.queryPinContentFromTable(), upperCountIdx, lowerCounterIdx );\n        _removeContentElement( _trv.queryScrollContentFromTable(), upperCountIdx, lowerCounterIdx );\n    };\n\n    self.clearScrollContents = function() {\n        _trv.getScrollContentElementFromTable().innerHTML = '';\n    };\n\n    self.setSelectable = function( selectable ) {\n        if( selectable ) {\n            _table.classList.add( Const.CLASS_SELECTION_ENABLED );\n        } else {\n            _table.classList.remove( Const.CLASS_SELECTION_ENABLED );\n        }\n    };\n\n    self.setDraggable = function( draggable ) {\n        var rowElements = _table.getElementsByClassName( Const.CLASS_ROW );\n        for( var i = 0; i < rowElements.length; i++ ) {\n            rowElements[ i ].draggable = draggable;\n        }\n    };\n\n    // /////////////////////////////////////////////\n    // Column Resize Grip\n    // /////////////////////////////////////////////\n\n    self.showColumnGrip = function( posX ) {\n        self.setColumnGripPosition( posX );\n        _grip.style.removeProperty( 'display' );\n    };\n\n    self.setColumnGripPosition = function( posX ) {\n        _grip.style.marginLeft = String( posX - 30 /* match with width*/ ) + 'px';\n    };\n\n    self.hideColumnGrip = function() {\n        _grip.style.display = 'none';\n    };\n\n    _constructTableElement();\n\n    self.updateColorIndicatorElements = function( updateVMOs ) {\n        var pinRows = _trv.getPinContentRowElementsFromTable();\n        _.forEach( pinRows, function( pinRow ) {\n            var rowVmo = pinRow.vmo;\n            if( updateVMOs.includes( rowVmo ) ) {\n                var colorIndicatorElement = pinRow.getElementsByClassName( Const.CLASS_AW_CELL_COLOR_INDICATOR )[ 0 ];\n                if( colorIndicatorElement ) {\n                    var newColorIndicatorElement = util.createColorIndicatorElement( rowVmo );\n                    colorIndicatorElement.parentElement.replaceChild( newColorIndicatorElement, colorIndicatorElement );\n                }\n            }\n        } );\n    };\n\n    self.syncContentRowHeights = function( pinnedElems, scrollElems ) {\n        if( pinnedElems && pinnedElems.childNodes ) {\n            for( let i = 0; i < pinnedElems.childNodes.length; i++ ) {\n                let row = pinnedElems.childNodes[ i ];\n                let rowVMO = row.vmo;\n                row.style.height = String( rowVMO.rowHeight ) + 'px';\n            }\n        }\n\n        if( scrollElems && scrollElems.childNodes ) {\n            for( let i = 0; i < scrollElems.childNodes.length; i++ ) {\n                let row = scrollElems.childNodes[ i ];\n                let rowVMO = row.vmo;\n                row.style.height = String( rowVMO.rowHeight ) + 'px';\n            }\n        }\n    };\n\n    return self;\n};\n\nexport default SPLMTableDomController;\n"]},"metadata":{},"sourceType":"module"}