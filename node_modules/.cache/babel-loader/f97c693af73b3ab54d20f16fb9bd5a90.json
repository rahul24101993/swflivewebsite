{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/* eslint-disable complexity */ /* eslint-disable @swf/swf/no-react-usage */import React from'react';import _ from'lodash';/**\n * render function for AwList\n * @param {*} props context for render function interpolation\n * @returns {JSX.Element} react component\n */import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";export const awLovListRenderFunction=props=>{const{i18n,viewModel,actions,blankLovEntry,checkLovEntries,context,...prop}=props;const{children,field,setlovEntry,lovPopup,staticFilterStr,isCheckBoxArryLOV,dataProvider}=prop;const{data,dispatch}=viewModel;let vmCollectionObj=[];let scrollElement;let lovEntries=[];let preferredChoices=[];let{selectedEntries=[],dirty}=data;let restEntries=[];let hasPreferredChoices=false;const renderChildWithItem=lovEntry=>{return React.Children.map(children,child=>{let key=lovEntry.propInternalValue!==''?lovEntry.propInternalValue:'_blank_';return/*#__PURE__*/React.cloneElement(child,{field,lovEntry,dataProvider,setLovEntry:setlovEntry,key,prop});});};if(dataProvider){scrollElement=dataProvider.getRootReference();let paginationOption=dataProvider.getPagination();if(!paginationOption){dataProvider.setPagination({root:scrollElement,rootMargin:'5px',threshold:1,bottomAnchorSelector:'.page-bottom'});}vmCollectionObj=dataProvider.vmCollectionObj;}// there are applications using object as propInternalValue,\n// in this case, comparator expected to use propDisplayValue as key\nlet propInternalValueInObject=false;if(vmCollectionObj&&vmCollectionObj.dataLoaded&&vmCollectionObj.vmCollection&&vmCollectionObj.vmCollection.loadedVMObjects.length>0){lovEntries=[...vmCollectionObj.vmCollection.loadedVMObjects];// check for any preferred values\nif(vmCollectionObj.preferredChoices&&vmCollectionObj.preferredChoices.length>0){preferredChoices=[...vmCollectionObj.preferredChoices];hasPreferredChoices=true;}propInternalValueInObject=Boolean(_.find(lovEntries,item=>_.isObject(item.propInternalValue)));}const comparator=(item1,item2)=>{let key=propInternalValueInObject?'propDisplayValue':'propInternalValue';return item1[key]===item2[key];};// As per the previous code...we are assuming if dataprovider does not have action\n// It means it is static and client-side filtering can be done.\n// apply filter if not null\nif(staticFilterStr&&_.isString(staticFilterStr)&&(context.isListbox||!(dataProvider.action||dataProvider.initializeAction))){// alway keep the empty entry if has\nlovEntries=applyFilter(lovEntries,staticFilterStr,true);}// syncLovEntries\nprop.updateValidEntries(lovEntries);if(hasPreferredChoices){// MRU can always be filtered client-side\npreferredChoices=applyFilter(preferredChoices,staticFilterStr);// denote last preferred choice for styling purposes\nif(preferredChoices.length){preferredChoices[preferredChoices.length-1].lastMru=true;}}if(lovEntries.length>0){if(!isCheckBoxArryLOV){// prepend preferredChoices to top of list\nlovEntries=preferredChoices.concat(lovEntries);// syncLovEntries\nprop.updateValidEntries(lovEntries);// honor emptyLOVEntry\nif(field.fielddata.emptyLOVEntry!==false){lovEntries.splice(0,0,blankLovEntry);}// initialize attention\nif(prop.selectIndex.current===null){prop.selectIndex.current=prop.getDefaultAttention();}// set attention\nlet inx=prop.selectIndex.current;_.forEach(lovEntries,(item,jnx)=>{item.attn=inx===jnx;});}else{// isCheckBoxArryLOV\n// need to filter the checked lov at the top\n// apply filter if has selectedEntries and has filter\n// selectedEntries may have placeHolders, we should replace then with valid (if matched) lovEntries\nlet selectedEntries_fixed=[];if(staticFilterStr||dirty){// replace the selectedEntries with latest if dirty\nselectedEntries=getLatestCheckLovEntries(checkLovEntries.current);// remember the list had been filtered, and we should pull latest CheckLovEntries each time\nif(!dirty){dispatch({path:'data.dirty',value:true});}}if(selectedEntries){// replace with valid (if matched) lovEntries\nfor(let index=0;index<selectedEntries.length;index++){const item=selectedEntries[index];let entry=_.find(lovEntries,i=>comparator(i,item));// only pick the valid ones:\n// 1, case all data loaded, we only pick the ones already in lovEntries, entry maybe valid or null\n// 2, case data partial loaded, we need to keep the placeholders, ensure entry always valid\nif(vmCollectionObj.hasMoreValuesExist&&!entry){entry=item;}if(entry){selectedEntries_fixed.push({...entry,isChecked:true});}}selectedEntries=selectedEntries_fixed;// apply filter\nstaticFilterStr&&(selectedEntries=applyFilter(selectedEntries_fixed,staticFilterStr));// cbLov is a bit complex...\n// selected values float to top and DON'T duplicate values in list below\n// preferredChoices can be duplicates though\n// rm any selected entries from preferred choices array\npreferredChoices=_.differenceWith(preferredChoices,selectedEntries,(item1,item2)=>comparator(item1,item2));// reset lastMru\npreferredChoices.forEach(function(choice){choice.lastMru=false;});// set lastMru state on last in list\nif(preferredChoices.length){preferredChoices[preferredChoices.length-1].lastMru=true;}}// filter out selected entries and preferred choices to avoid duplicates\nrestEntries=_.differenceWith(lovEntries,selectedEntries.concat(preferredChoices),(item1,item2)=>comparator(item1,item2));// prepend preferred choices to top\nrestEntries=preferredChoices.concat(restEntries);// syncLovEntries\nprop.updateValidEntries(selectedEntries.concat(restEntries));}}const hasValidEntries=()=>{return lovEntries&&lovEntries.length>0;};const transform=item=>renderChildWithItem(item);const renderContents=()=>{let result=[];if(isCheckBoxArryLOV){// selectedEntries\nif(selectedEntries&&selectedEntries.length>0){let part1=/*#__PURE__*/_jsx(\"div\",{className:\"afx-selected-vals\",children:selectedEntries.map(transform)});result.push(part1);}// others\nif(restEntries&&restEntries.length>0){let part2=restEntries.map(transform);result.push(part2);}}else{if(hasValidEntries()){result.push(lovEntries.map(transform));}}return result;};const NO_LOV_VALUES=i18n.NO_LOV_VALUES;return/*#__PURE__*/_jsxs(\"div\",{className:\"aw-base-scrollPanel\",ref:scrollElement,children:[/*#__PURE__*/_jsxs(\"ul\",{role:\"listbox\",\"aria-label\":field.name,className:\"sw-column flex-shrink\",children:[renderContents(),!hasValidEntries()&&!vmCollectionObj.fetching&&/*#__PURE__*/_jsx(\"li\",{className:\"aw-jswidgets-lov-novals\",title:NO_LOV_VALUES,children:NO_LOV_VALUES}),vmCollectionObj.fetching&&/*#__PURE__*/_jsx(\"li\",{className:\"aw-jswidgets-loadingItem\",children:/*#__PURE__*/_jsx(\"div\",{className:\"aw-jswidgets-loading\",children:\"\\xA0\"})})]}),/*#__PURE__*/_jsx(\"div\",{className:\"page-bottom\"})]});};export const onMount=prop=>{prop.selectIndex.current=null;const{isCheckBoxArryLOV,checkLovEntries}=prop;if(isCheckBoxArryLOV&&checkLovEntries.current){return getLatestCheckLovEntries(checkLovEntries.current);}};const getLatestCheckLovEntries=checkLovEntries=>{return _.reduce(checkLovEntries,(result,value,key)=>{result.push(value);return result;},[]);};const applyFilter=function(collection,filterString){let keepNull=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!filterString){return collection;}return collection.filter(item=>{return keepNull&&!item.propDisplayValue||// only filter it when it's a string\n_.isString(item.propInternalValue)&&item.propInternalValue.toLowerCase().indexOf(filterString.toLowerCase())!==-1||item.propDisplayValue.toLowerCase().indexOf(filterString.toLowerCase())!==-1;});};","map":null,"metadata":{},"sourceType":"module"}