{"ast":null,"code":"/* eslint-disable max-statements-per-line */ /* eslint-disable require-jsdoc */ // Copyright (c) 2020 Siemens\n/**\n * @module js/positionService\n */import _ from'lodash';import popupUtils from'js/popupUtils';import{DOMAPIs as dom}from'js/domUtils';import logger from'js/logger';/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @type {Array}\n * @enum {String}\n */const placements=['top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'];/**\n * the predefined arrow size in px\n */const arrowSize=10;/**\n *\n * @param {Element} reference - the reference element\n * @param {Element} popup - the popup element\n * @param {String} options - the placement related option\n *\n * @returns {Object} the expected offsets\n */const calculateOffsets=function(reference,popup,options){if(!reference||!popup){logger.error(\"Invalid element for reference or popup: reference - \".concat(reference,\", popup - \").concat(popup));return;}if(!dom.inDOM(reference)){logger.warn(\"Invalid reference element: \".concat(reference));}let{placement,alternativePlacements,flipBehavior,hasArrow,arrowOptions,minSize,marginBufferSize}=options;if(placements.indexOf(placement)===-1){logger.warn('Error parameter `placement` ',placement,'. Please use a valid option: '+placements);return undefined;}let data={options,placement,alternativePlacements,flipBehavior,hasArrow,arrowSize,arrowOptions,minSize,marginBufferSize,offsets:{}};data.offsets.boundaries=getBoundaries(options);data.offsets.reference=getReferenceOffsets(reference,options);// apply placementAttribute if has arrow.\nupdatePlacementAttribute(popup,data,Boolean(data.hasArrow));// compute auto placement to support smart position, store placement inside the data object\nlet oldPlacement=placement;data.placement=computeAutoPlacement(popup,data);// if placement changed, need to apply placementAttribute again.\nif(oldPlacement!==data.placement){updatePlacementAttribute(popup,data,Boolean(data.hasArrow));}data.offsets.popup=getPopupOffsets(popup,data);const shiftvariation=data.placement.split('-')[1];if(shiftvariation){let shiftOffsets=calculateShiftOffsets(data);data.offsets.popup={...data.offsets.popup,...shiftOffsets[shiftvariation]};}// if defined overlapOnReference\noptions.overlapOnReference&&applyOverlap(data);// final to getArrowOffsets\ndata.hasArrow&&(data.offsets.arrow=getArrowOffsets(data));return data.offsets;};function applyOverlap(data){let{popup,reference}=data.offsets;const basePlacement=data.placement.split('-')[0];const isVertical=['bottom','top'].indexOf(basePlacement)!==-1;if(isVertical){let sign=basePlacement==='top'?1:-1;popup.top+=reference.height*sign;}}function updatePlacementAttribute(popup,data){let add=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let name='x-placement';if(add){let basePlacement=data.placement.split('-')[0];popup.setAttribute(name,basePlacement);}else{popup.removeAttribute(name);}}function getPopupSide(popup,side,boundaries){let value=0;if(_.has(popup,side)){value=popup[side];}else{const isLeft=side==='left';const start=isLeft?'right':'bottom';const measurement=isLeft?'width':'height';value=boundaries[measurement]-popup[measurement]-popup[start];}return value;}function calculateShiftOffsets(data){const{placement,options}=data;const{reference,popup,boundaries}=data.offsets;const basePlacement=placement.split('-')[0];const shiftvariation=placement.split('-')[1];let shiftOffsets=null;// if shift shiftvariation is specified, run the modifier\nif(shiftvariation){const isVertical=['bottom','top'].indexOf(basePlacement)!==-1;const side=isVertical?'left':'top';const measurement=isVertical?'width':'height';const padding=isVertical?'x':'y';let offset=options&&options.padding?options.padding[padding]||0:0;let targetSide=side;let start=reference[side]+offset;let end=reference[side]+reference[measurement]-popup[measurement]-offset;const mainSideFlipped=!_.has(popup,side);if(options.advancePositioning&&mainSideFlipped){const popupSideValue=getPopupSide(popup,side,boundaries);targetSide=getOppositePlacement(side);start=popup[targetSide]+(popupSideValue-reference[side])-offset;end=popup[targetSide]+(popupSideValue+popup[measurement]-reference[side]-reference[measurement])+offset;}// override top / left or bottom / right based on mainSide flip flag\n// if mainSide flipped: means popup was positioned by bottom / right due to content growth, hence override these target side\nshiftOffsets={start:{[targetSide]:start},end:{[targetSide]:end}};}return shiftOffsets;}function getReferenceOffsets(reference,options){// TODO: viewport case need to take case parent container element\nlet offset=dom.getOffset(reference);let referenceRect=getOuterSizes(reference);// support padding\nif(options&&options.padding){let{x=0,y=0}=options.padding;offset.left-=x;offset.top-=y;referenceRect.width+=2*x;referenceRect.height+=2*y;}const offsets={...offset,...referenceRect};return getClientRect(offsets);}/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @param {String} placement - A valid placement\n * @param {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements\n */function clockwise(placement){let counter=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const index=placements.indexOf(placement);let arr=placements.slice(0,index);let result=placements.slice(index+1).concat(arr);return!counter?result:result.reverse();}function getBoundaries(options){const boundary=options.boundary;// align with `dom.getOffset()`, use viewPort as available space\nlet offsets={// top: window.pageYOffset,\n// left: window.pageXOffset,\ntop:0,left:0,width:window.innerWidth,height:window.innerHeight};if(boundary){offsets={...dom.getOffset(boundary),...getOuterSizes(boundary)};}return getClientRect(offsets);}function getSearchOrder(placement,flipBehavior,alternativePlacements){let searchOrder=[placement];let alternatives=[];let leadAlternatives=[];alternativePlacements&&(alternatives=alternativePlacements.slice(0));if(flipBehavior==='opposite'){let op=getOppositePlacement(placement);leadAlternatives=placement.split('-')[1]?[getOppositeAlignment(placement),op,getOppositeAlignment(op)]:[op];}else if(flipBehavior!=='fixed'){leadAlternatives=clockwise(placement,flipBehavior==='counterclockwise');}return searchOrder.concat(leadAlternatives,alternatives);}function getArea(_ref){let{width,height}=_ref;return width*height;}function checkSpace(rect,popper){let minSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let res=false;if(rect&&rect.width>=Math.max(popper.width,minSize)&&rect.height>=Math.max(popper.height,minSize)){res=true;}return res;}function getPlacement(popup,placement,avaliableRects,flipBehavior,data){let computedPlacement=null;const searchOrder=getSearchOrder(placement,flipBehavior,data.alternativePlacements);const searchRects=searchOrder.reduce((result,item)=>{if(avaliableRects[item]){result[item]=avaliableRects[item];return result;}},{});// Get popper node sizes\n// support dynamic update when parent resize or window resize,\n// need to get original popup content size, not the current size.\nclearResize(popup,data);const popper=getOuterSizes(popup,data);// find an available space with no resize required\ncomputedPlacement=searchOrder.find(key=>{let rect=searchRects[key];if(checkSpace(rect,popper,data.minSize)){return key;}return null;});// then try to find an available space with resize required\nif(!computedPlacement){const sortedAreas=Object.keys(searchRects).map(key=>({key,...searchRects[key],area:getArea(searchRects[key])})).sort((a,b)=>b.area-a.area);applyResize(popup,sortedAreas[0],data);computedPlacement=sortedAreas[0].key;}return computedPlacement?computedPlacement:placement;}function getDefaultConstraints(container,css){let result={};css.forEach(key=>{let key2=\"data-\".concat(key);result[key]=container.getAttribute(key2)||null;});return result;}function clearResize(popup,data){const container=popupUtils.getResizeContainer(popup,data.options.resizeContainer);if(!container){return;}// horner data-max constraints if defined\nconst css=['max-width','max-height','min-width','min-height'];dom.setStyles(container,getDefaultConstraints(container,css));}function getArrowMargin(placement,data){let result={width:0,height:0};if(data.hasArrow&&data.arrowSize){const basePlacement=placement.split('-')[0];const isVertical=['bottom','top'].indexOf(basePlacement)!==-1;const measurement=!isVertical?'width':'height';result[measurement]=data.arrowSize;}return result;}function applyResize(popup,area,data){const marginBufferSize=data.marginBufferSize||0;const container=popupUtils.getResizeContainer(popup,data.options.resizeContainer);if(!container){return;}const styles=dom.getComputedStyle(container);let css={};const props=['width','height'];const arrowMargin=getArrowMargin(area.key,data);props.forEach(item=>{let available=area[item]-arrowMargin[item];// unless space is highly limited, leave a gap for the drop shadow, etc\nif(item==='height'&&marginBufferSize>0){available=Math.max(available-marginBufferSize,0);}let expected=parseInt(styles[item]);let maxItem='max-'+item;let minItem='min-'+item;let overflowItem='overflow-'+(item==='width'?'x':'y');if(available<expected){css[maxItem]=available;css[overflowItem]='auto';if(styles[minItem]&&parseInt(styles[minItem])>available){css[minItem]=available;}}});if(Object.keys(css).length>0){dom.setStyles(container,css);}}function getArrowOffsets(data){const{placement,arrowSize,arrowOptions}=data;const{reference,popup,boundaries}=data.offsets;const[basePlacement,shiftvariation]=placement.split('-');let overrideOffsets=null;const isVertical=['bottom','top'].indexOf(basePlacement)!==-1;const side=isVertical?'left':'top';const measurement=isVertical?'width':'height';// should shift based on reference in this narrow case\nif(reference[measurement]<popup[measurement]){let base=reference[side]-getPopupSide(popup,side,boundaries);overrideOffsets={[side]:Math.min(Math.max(base+reference[measurement]/2-arrowSize,0),popup[measurement]-arrowSize*2)};}let shiftOffsets={};// arrowOptions should be null by default,\nif(arrowOptions&&arrowOptions.alignment){let alignment=arrowOptions.alignment;// based on the popup alignment, arrow should be smart position itself.\nif(alignment==='auto'){alignment=shiftvariation?shiftvariation:'center';}shiftOffsets=getArrowShiftOffsets(data);// return directly got audit error: TypeError: Cannot read property 'name' of undefined\nreturn{...overrideOffsets,...shiftOffsets[alignment]};}return overrideOffsets;}function getArrowShiftOffsets(data){const{placement,arrowSize,arrowOptions}=data;const{reference,popup,boundaries}=data.offsets;const basePlacement=placement.split('-')[0];const shiftvariation=arrowOptions.alignment;let shiftOffsets=null;// if shift shiftvariation is specified, run the modifier\nif(shiftvariation){// could be positive / negative\nlet offset=parseInt(arrowOptions.offset)||0;//  only accept positive values.\nlet shift=Math.max(parseInt(arrowOptions.shift)||0,0);const isVertical=['bottom','top'].indexOf(basePlacement)!==-1;const side=isVertical?'left':'top';const measurement=isVertical?'width':'height';const base=reference[side]-getPopupSide(popup,side,boundaries);const rectifyOffset=Math.min(offset,popup[measurement],reference[measurement]);const padding=rectifyOffset+2*arrowSize;const min=Math.min(shift,popup[measurement]-arrowSize,reference[measurement]-arrowSize);const[lowBound,highBound]=[min,positive(shift,Math.max(popup[measurement]-arrowSize*2-shift,shift),reference[measurement]+base-arrowSize)];shiftOffsets={start:{[side]:positive(lowBound,highBound,base+rectifyOffset)},center:{[side]:positive(0,Math.max(popup[measurement],reference[measurement]),// lowBound, highBound,\nbase+reference[measurement]/2-arrowSize)},// + offset\nend:{[side]:positive(lowBound,highBound,base+reference[measurement]-padding)}};}return shiftOffsets;}function positive(lowBound,highBound){for(var _len=arguments.length,items=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){items[_key-2]=arguments[_key];}return Math.min(Math.max(lowBound,...items),highBound);}function getPopupOffsets(popup,data){const{reference,boundaries}=data.offsets;let placement=data.placement;placement=placement.split('-')[0];// Get popper node sizes\nconst popperRect=getOuterSizes(popup,data);// Add position, width and height to our offsets object\nconst popperOffsets={width:popperRect.width,height:popperRect.height};// depending by the popper placement we have to compute its offsets slightly differently\nconst isHoriz=['right','left'].indexOf(placement)!==-1;const mainSide=isHoriz?'top':'left';const secondarySide=isHoriz?'left':'top';const measurement=isHoriz?'height':'width';const secondaryMeasurement=!isHoriz?'height':'width';// center aligned offsets\nlet center=Math.max(0,reference[mainSide]+(reference[measurement]-popperRect[measurement])/2);popperOffsets[mainSide]=center;// support adaptive shift\nif(data.options.adaptiveShift){let exceed=center+popperRect[measurement]-boundaries[measurement];let adaptive=exceed<0?center:Math.max(0,center-exceed);popperOffsets[mainSide]=adaptive;if(data.options.advancePositioning){// when popup content growing in corner case, we should flip the mainSide in positioning to enable it grows and gets natural size. Ref: LCS-352837\nif(exceed>=-50){delete popperOffsets[mainSide];popperOffsets[getOppositePlacement(mainSide)]=exceed<0?-exceed:0;}}}// support flip\nlet secondaryOppositeSide=getOppositePlacement(secondarySide);if(placement===secondarySide){if(data.options.advancePositioning){// for traditional top/left positioning, when popup content growing, it could be overlap on reference element,\n// to prevent that, we do this improvement to ensure no overlap:\n// for left placement, calculate top/right for popup\n// for top placement, calculate left/bottom for popup\npopperOffsets[secondaryOppositeSide]=Math.max(0,boundaries[secondaryOppositeSide]-reference[secondarySide]);}else{popperOffsets[secondarySide]=Math.max(0,reference[secondarySide]-popperRect[secondaryMeasurement]);}}else{popperOffsets[secondarySide]=Math.max(0,reference[secondaryOppositeSide]);}// center aligned offsets\nreturn popperOffsets;}/**\n * Get the opposite placement of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */function getOppositePlacement(placement){const hash={left:'right',right:'left',bottom:'top',top:'bottom'};return placement.replace(/left|right|bottom|top/g,matched=>hash[matched]);}/**\n * Get the opposite alignment of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */function getOppositeAlignment(placement){const hash={start:'end',end:'start'};return placement.replace(/start|end/g,matched=>hash[matched]);}/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @param {Object} offsets - the offsets\n * @returns {Object} ClientRect like output\n */function getClientRect(offsets){return{...offsets,right:offsets.left+offsets.width,bottom:offsets.top+offsets.height};}/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {Element} element - the element\n * @param {Object} data - the data object\n * @returns {Object} object containing width and height properties\n */function getOuterSizes(element,data){let[x,y]=[0,0];if(data&&data.hasArrow){const window=element.ownerDocument.defaultView;const styles=window.getComputedStyle(element);x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0);y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0);}// offsetHeight only works for block element, using getBoundingClientRect().height to get height for inline element\nconst boundingRect=element.getBoundingClientRect();return{width:boundingRect.width+y,height:boundingRect.height+x};}function computeAutoPlacement(popup,data){const{reference,boundaries}=data.offsets;let{placement,flipBehavior}=data;const h1=reference.top-boundaries.top;const h2=boundaries.bottom-reference.bottom;const h3=boundaries.height;const w1=reference.left-boundaries.left;const w2=boundaries.right-reference.right;const w3=boundaries.width;const rects={top:{width:w3,height:h1},'top-start':{width:boundaries.right-reference.left,height:h1},'top-end':{width:reference.right,height:h1},right:{width:w2,height:h3},'right-start':{width:w2,height:boundaries.bottom-reference.top},'right-end':{width:w2,height:reference.bottom},bottom:{width:w3,height:h2},'bottom-start':{width:boundaries.right-reference.left,height:h2},'bottom-end':{width:reference.right,height:h2},left:{width:w1,height:h3},'left-start':{width:w1,height:boundaries.bottom-reference.top},'left-end':{width:w1,height:reference.bottom}};return getPlacement(popup,placement,rects,flipBehavior,data);}function getMax(type,boundaries,refRect){const isHeight=type==='height';const side=isHeight?'bottom':'right';const secondarySide=!isHeight?'top':'left';const measurement=isHeight?'height':'width';const space=Math.min(boundaries[side]-refRect[side],refRect[secondarySide]-boundaries[secondarySide]);return 2*space+refRect[measurement];}export const positionService={placements,calculateOffsets};export default positionService;","map":null,"metadata":{},"sourceType":"module"}