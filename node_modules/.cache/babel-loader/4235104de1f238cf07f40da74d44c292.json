{"ast":null,"code":"import AwCommandBar from'viewmodel/AwCommandBarViewModel';import eventBus from'js/eventBus';import AwNavigatePanel from'viewmodel/AwNavigatePanelViewModel';import{ShowWhen}from'js/hocCollection';import _ from'lodash';import appCtxSvc from'js/appCtxService';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";const AwShowWhenProvider=ShowWhen(AwNavigatePanel);export const awCommandPanelRenderFunction=props=>{const{attributes,onSubmit,submitAction,subPanelContext={},updateActiveView={},viewModel}=props;const{data}=viewModel;const{activeView=null}=updateActiveView;let previousView=null;let rootNode=data.panelNavTree||null;if(rootNode&&activeView){let currentPanelNode=findNode(activeView,rootNode);if(currentPanelNode){previousView=currentPanelNode.getParentNode().getNodeName();}}const loadSubPanels=()=>{let dynamicSubPanels=data.dynamicSubPanels||[];let hierarchy=findHierarchy(activeView,rootNode);return dynamicSubPanels.map(subPanel=>{let panelId=subPanel.destPanelId;let reCreatePanel=subPanel.hasOwnProperty('recreatePanel')?subPanel.recreatePanel===true:false;let condition=reCreatePanel?activeView===panelId:true;if(!condition){//When move from panel in higher order, we dont destroy it immediately but destroy and recreate on revisit to panel based on recreatePanel flag\nif(hierarchy.indexOf(activeView)>hierarchy.indexOf(panelId)){condition=true;// DO NOT DESTROY\n}}return condition&&/*#__PURE__*/_jsx(AwShowWhenProvider,{showWhen:activeView===panelId,destPanelId:panelId,prePanelId:previousView,updateActiveView:updateActiveView,subPanelContext:subPanel.subPanelContext,title:subPanel.title},panelId);});};return/*#__PURE__*/_jsxs(\"form\",{...attributes,onSubmit:event=>{onSubmit&&onSubmit(event,submitAction);},className:\"sw-column flex-auto aw-panel sw-command-panel align-self-stretch afx-content-background\",children:[!props.hideTitle?/*#__PURE__*/_jsxs(\"div\",{className:\"aw-layout-panelTitle sw-row justify-justified\",children:[/*#__PURE__*/_jsx(\"div\",{className:(props.caption?'':'hidden ')+'aw-panel-caption align-self-stretch',children:props.caption}),/*#__PURE__*/_jsxs(\"div\",{className:\"sw-row align-center justify-right flex-shrink sw-panel-bar\",children:[/*#__PURE__*/_jsx(AwCommandBar,{className:\"aw-layout-workareaCommandbar\",anchor:props.anchor,alignment:\"HORIZONTAL\",context:props.context}),/*#__PURE__*/_jsx(AwCommandBar,{context:props.context,class:\"aw-layout-workareaCommandbar\",anchor:\"aw_commandPanel\",alignment:\"HORIZONTAL\"})]})]}):'',/*#__PURE__*/_jsxs(\"div\",{className:\"sw-command-panelContent sw-column flex-auto\",children:[props.children,loadSubPanels()]}),/*#__PURE__*/_jsx(\"button\",{type:\"submit\",className:\"aw-hide-form-button\",disabled:true,\"aria-hidden\":\"true\"})]});};export const executeReveal=function(revealAction,subPanels){if(_.isFunction(revealAction)){revealAction();}// preloadedPanels are the panels which are statically declared inside command -panel child as command-sub-panel.\nlet preLoadedCommandSubPanels=[];if(subPanels){let children=_.isArray(subPanels)?subPanels:[subPanels];preLoadedCommandSubPanels=children.map(child=>{return child.props&&child.props.panelId?child.props.panelId:'';}).filter(child=>child!=='');}eventBus.publish('awPanel.reveal',{});return preLoadedCommandSubPanels;};/**\n * @param {*} subPanelContext\n */export const navigatePanel=(eventData,updateActiveView,panelNavTree,dynamicSubPanels,staticCommandSubPanels)=>{let activeView=updateActiveView.activeView;const pDispatch=updateActiveView.dispatch;if(pDispatch&&activeView){appCtxSvc.updateCtx('panelContext',eventData);// If the incoming sub-panel is not yet registered with dynamicSubPanels state, It must be a getting loaded newly.\nconst isAlreadyLoadedDynPanel=dynamicSubPanels.findIndex(loadedPanel=>loadedPanel.destPanelId===eventData.destPanelId)!==-1;const isStaticCommandPanel=staticCommandSubPanels.findIndex(staticCommandSubPanel=>staticCommandSubPanel===eventData.destPanelId)!==-1;/**\n         *  isNewNavigationSystemEnabled\n         *  BA Specific case\n         * ----------------------------------------------------------------------------------------------------\n         *  In BA , user might use a component directly inside a command-panel and later do navigation from the\n         *  <aw-command-panel><aw-info show-when=\"data.activeView==='awInfo'\"/><aw-command-panel>\n         *  In these cases, when navigating back, user need to specify \"backNavigation\" as true as part of \"aw.navigate\" eventdata.\n         *  isNewNavigationSystemEnabled will be enabled when \"backNavigation\" is set as true in the event data.\n         *\n         *  In other cases ( same as ng-afx)\n         * -----------------------------------------------------------------------------------------------------------\n         *  <aw-command-panel><aw-command-sub-panel panel-id='awInfo' show-when=\"data.activeView==='awInfo'\"/><aw-command-panel>\n         *  User need not required to define backNavigation as true as part of eventdata amd should work as ng-afx worked.       *\n         *\n         *  If the incoming new panel is not part of dynamicSubPanels and staticCommandSubPanel, then only add it to dynamicSubPanels.\n         *  Otherwise it means the incoming panel( specified destPanelId in eventData) is already loaded and not a new one.\n         */let isNewNavigationSystemEnabled=false;let backNavigation=false;if(eventData.hasOwnProperty('backNavigation')){isNewNavigationSystemEnabled=true;if(eventData.backNavigation){backNavigation=true;}}if(isNewNavigationSystemEnabled&&!isAlreadyLoadedDynPanel&&!backNavigation){dynamicSubPanels.push(eventData);}if(!isNewNavigationSystemEnabled&&!isAlreadyLoadedDynPanel&&!isStaticCommandPanel){dynamicSubPanels.push(eventData);}dynamicSubPanels=dynamicSubPanels.map(subPanel=>subPanel.destPanelId===eventData.destPanelId?eventData:subPanel);// The current view will be evetually becomes the previousView\nlet previousView=null;// The Panel name came from event will become the activeView eventually\n//let activeView = null;\nlet rootNode=panelNavTree||new Node('root');if(activeView!==eventData.destPanelId){previousView=activeView;activeView=eventData.destPanelId;let prevPanelNode=findNode(previousView,rootNode);// If the current panel is not found in tree, then this is the first\nif(!prevPanelNode){let prevNode=new Node(previousView);rootNode.addChildNodes(prevNode);prevNode.addChildNodes(new Node(activeView));}else{// If the new Panel( suppose to load) is found in the Tree, then no need to add it.\n// probably the navigation already happened.\nif(!findNode(activeView,rootNode)){prevPanelNode.addChildNodes(new Node(activeView));}}}return{panelNavTree:{...rootNode},dynamicSubPanels:[...dynamicSubPanels],currentView:activeView};}};export const dispatchActiveView=(updateActiveView,currentView)=>{const pDispatch=updateActiveView.dispatch;if(pDispatch&&currentView){pDispatch({value:{'data.activeView':currentView}});}};/**\n * Simple Data Structure to hold the Panel Navigation sequence.\n * @param {*} name\n * @param {*} pNode\n * @param {*} cNode\n */const Node=function(name){let nodeName=name;let parentNode=null;const childNodes=[];this.getNodeName=()=>nodeName;this.setNodeName=name=>nodeName=name;this.getParentNode=()=>parentNode;this.setParentNode=pNode=>parentNode=pNode;this.getChildNodes=()=>childNodes;this.addChildNodes=childNode=>{let _self=this;let hasChildNode=childNodes.filter(cNode=>cNode.getNodeName()===childNode.getNodeName());if(hasChildNode.length===0){childNodes.push(childNode);childNode.setParentNode(_self);}};};const findHierarchy=(name,rootNode)=>{let order=[];if(rootNode===null||rootNode.getNodeName()===name){return['root'];}let traverseHierarchy=function(rootNode){_.forEach(rootNode.getChildNodes(),Node=>{order.push(Node.getNodeName());return traverseHierarchy(Node);});};traverseHierarchy(rootNode);return order;};const findNode=(name,rootNode)=>{if(rootNode.getNodeName()===name){return rootNode;}let visitedNode=null;let inOrderTraversal=function(rootNode){_.forEach(rootNode.getChildNodes(),Node=>{if(Node&&Node.getNodeName()===name){visitedNode=Node;return;}return inOrderTraversal(Node);});};inOrderTraversal(rootNode);return visitedNode;};","map":null,"metadata":{},"sourceType":"module"}