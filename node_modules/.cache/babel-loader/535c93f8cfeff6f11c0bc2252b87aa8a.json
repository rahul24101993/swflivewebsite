{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * Link below can we used for test complete accurate functionality:\n * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview\n *\n * For now all the use case in awParseService.test.js are guaranteed to work :)\n *\n * @module js/awParseService\n */\nimport { processExpression, expressionCanSplit, parseNative } from 'js/serviceUtils';\nimport { $ParseProvider } from 'js/angularjsParseService';\nconst $parse = new $ParseProvider().$get[1]();\n\nconst getRandomInt = max => Math.floor(Math.random() * Math.floor(max));\n/**\n * The API splits the expression and parse it.\n * @param {String} expression - The String expression to parse\n * @param {Array} names - The String Array of Parameters\n * @param {Array} vals - The Array of parameter values.\n * @returns {Object} parsed value\n */\n\n\nconst splitAndParse = (expression, names, vals) => {\n  if (!expressionCanSplit(expression)) {\n    return undefined;\n  }\n\n  const stack = processExpression(expression);\n  let finalExpresions = stack.map((element, index) => {\n    if (element.expr) {\n      try {\n        const response = parseNative(names, vals, null, element.expr);\n\n        if (response === undefined) {\n          //Check unary operator case\n          if (index < stack.length - 1 && stack[index + 1] === '+' || stack[index + 1] === '-') {\n            element.response = 0;\n          }\n\n          if (index > 0 && stack[index - 1] === '+' || stack[index - 1] === '-') {\n            element.response = 0;\n          }\n        } else {\n          element.response = response;\n        }\n      } catch (e) {\n        //Check unary operator case\n        if (index < stack.length - 1 && stack[index + 1] === '+' || stack[index + 1] === '-') {\n          element.response = 0;\n        } else if (index > 0 && stack[index - 1] === '+' || stack[index - 1] === '-') {\n          element.response = 0;\n        } else {\n          element.response = undefined;\n        }\n      }\n    }\n\n    return element;\n  });\n  let params = [];\n  let values = [];\n  const finalExprs = finalExpresions.map(element => {\n    if (element.expr) {\n      //TODO: generate random number\n      const varName = `param${getRandomInt(100000)}`;\n      params.push(varName);\n      values.push(element.response);\n      return varName;\n    }\n\n    return element;\n  });\n  const evalExpr = finalExprs.join('').trim();\n  return parseNative(params, values, null, evalExpr);\n};\n\nconst numberPropRe = /[a-zA-Z]\\.[0-9]/;\nexport default class AwParseService {\n  static instance(expression) {\n    if (!expression) {\n      return () => undefined;\n    }\n\n    const originalParseFunction = function (evaluationCtx) {\n      let names = Object.keys(evaluationCtx);\n      let vals = Object.values(evaluationCtx);\n\n      try {\n        const response = parseNative(names, vals, null, expression); // revisitme - what is this isNaN mean? for now limits it to number only\n\n        if (typeof response === 'number' && isNaN(response)) {\n          return splitAndParse(expression, names, vals);\n        }\n\n        return response;\n      } catch (e) {\n        //Split the expression and try to resolve\n        return splitAndParse(expression, names, vals);\n      }\n    }; //if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser\n    //Some cases of this have been added in 6.1\n\n\n    if (expression.match(numberPropRe)) {\n      return originalParseFunction;\n    }\n\n    try {\n      const fn = $parse(expression);\n      return function (evaluationCtx) {\n        return fn(evaluationCtx);\n      };\n    } catch (e) {\n      return originalParseFunction;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/awParseService.js"],"names":["$parse","getRandomInt","max","Math","splitAndParse","expressionCanSplit","stack","processExpression","finalExpresions","element","response","parseNative","index","params","values","finalExprs","varName","evalExpr","numberPropRe","instance","originalParseFunction","names","Object","vals","isNaN","expression","fn"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * Link below can we used for test complete accurate functionality:\n * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview\n *\n * For now all the use case in awParseService.test.js are guaranteed to work :)\n *\n * @module js/awParseService\n */\n\nimport {\n    processExpression,\n    expressionCanSplit,\n    parseNative\n} from 'js/serviceUtils';\nimport { $ParseProvider } from 'js/angularjsParseService';\n\nconst $parse = new $ParseProvider().$get[1]();\nconst getRandomInt = max => Math.floor( Math.random() * Math.floor( max ) );\n\n/**\n * The API splits the expression and parse it.\n * @param {String} expression - The String expression to parse\n * @param {Array} names - The String Array of Parameters\n * @param {Array} vals - The Array of parameter values.\n * @returns {Object} parsed value\n */\nconst splitAndParse = ( expression, names, vals ) => {\n    if( !expressionCanSplit( expression ) ) {\n        return undefined;\n    }\n    const stack = processExpression( expression );\n    let finalExpresions = stack.map( ( element, index ) => {\n        if( element.expr ) {\n            try {\n                const response = parseNative( names, vals, null, element.expr );\n                if( response === undefined ) {\n                    //Check unary operator case\n                    if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {\n                        element.response = 0;\n                    }\n                    if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {\n                        element.response = 0;\n                    }\n                } else {\n                    element.response = response;\n                }\n            } catch ( e ) {\n                //Check unary operator case\n                if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {\n                    element.response = 0;\n                } else if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {\n                    element.response = 0;\n                } else {\n                    element.response = undefined;\n                }\n            }\n        }\n        return element;\n    } );\n    let params = [];\n    let values = [];\n    const finalExprs = finalExpresions.map( ( element ) => {\n        if( element.expr ) {\n            //TODO: generate random number\n            const varName = `param${getRandomInt( 100000 )}`;\n            params.push( varName );\n            values.push( element.response );\n            return varName;\n        }\n        return element;\n    } );\n    const evalExpr = finalExprs.join( '' ).trim();\n    return parseNative( params, values, null, evalExpr );\n};\n\nconst numberPropRe = /[a-zA-Z]\\.[0-9]/;\nexport default class AwParseService {\n    static instance( expression ) {\n        if( !expression ) {\n            return () => undefined;\n        }\n        const originalParseFunction = function( evaluationCtx ) {\n            let names = Object.keys( evaluationCtx );\n            let vals = Object.values( evaluationCtx );\n            try {\n                const response = parseNative( names, vals, null, expression );\n                // revisitme - what is this isNaN mean? for now limits it to number only\n                if( typeof response === 'number' && isNaN( response ) ) {\n                    return splitAndParse( expression, names, vals );\n                }\n                return response;\n            } catch ( e ) {\n                //Split the expression and try to resolve\n                return splitAndParse( expression, names, vals );\n            }\n        };\n        //if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser\n        //Some cases of this have been added in 6.1\n        if( expression.match( numberPropRe ) ) {\n            return originalParseFunction;\n        }\n        try {\n            const fn = $parse( expression );\n            return function( evaluationCtx ) {\n                return fn( evaluationCtx );\n            };\n        } catch ( e ) {\n            return originalParseFunction;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}