{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * @module js/dataProviderUtils\n */import{useReducer,useEffect,useRef,useState}from'react';import _ from'lodash';import{useSelectionModel}from'js/declSelectionModelFactory';import declUtils from'js/declUtils';const pageReducer=(state,action)=>{const pageActionType=action.type;let page=state.page||0;switch(pageActionType){case'NEXT_PAGE':page++;break;case'PAGE_RESET':page=action.page||0;break;case'PREVIOUS_PAGE':page--;break;case'FOCUS_PAGE':if(_.has(action,page)){page=action.page;}break;default:return state;}return{...state,pageActionType,page};};const loadVMCollection=(state,action)=>{let newState={...state};newState.totalFound=action.totalFound&&action.totalFound!==''?action.totalFound:action.viewModelObjects.length;newState.vmCollection.setViewModelObjects(action.viewModelObjects);newState.cursor.startIndex=newState.vmCollection.loadedVMObjects.length;if(action.hasMoreValuesExist!==null){newState.cursor.endReached=!newState.hasMoreValuesExist;}else{newState.cursor.endReached=newState.totalFound<=newState.cursor.startIndex;}newState.focusing=false;newState.dataLoaded=true;return newState;};const updateVMCollection=(state,action)=>{let newState={...state};newState.totalFound=action.totalFound&&action.totalFound!==''?action.totalFound:action.viewModelObjects.length;newState.hasMoreValuesExist=action.hasMoreValuesExist?action.hasMoreValuesExist:null;if(newState.totalFound>0){newState.vmCollection.setTotalObjectsFound(action.totalFound);if(action.pageObject.pageActionType==='FOCUS_PAGE'||action.pageObject.pageActionType==='PREVIOUS_PAGE'||action.pageObject.pageActionType==='NEXT_PAGE'){newState.vmCollection.setViewModelObjects(action.viewModelObjects);}else{newState.vmCollection.setViewModelObjects(newState.vmCollection.getLoadedViewModelObjects().concat(action.viewModelObjects));}}else if(action.hasMoreValuesExist!==null){newState.vmCollection.setViewModelObjects(action.viewModelObjects);//This is a NEXT_PAGE case\n}if(action.cursorObject){newState.cursor=action.cursorObject;}else{newState.cursor.startIndex=newState.vmCollection.loadedVMObjects.length;if(action.hasMoreValuesExist!==null){newState.cursor.endReached=!newState.hasMoreValuesExist;}else{newState.cursor.endReached=newState.totalFound<=newState.cursor.startIndex;}}/**\n      * Determine if the last node in the collection is an 'incompleteTail' because we know\n      * there are more found than currently loaded.\n      */if(!_.isEmpty(newState.vmCollection.loadedVMObjects)&&newState.vmCollection.totalFound>newState.vmCollection.getTotalUniqueObjectsLoaded()){_.last(newState.vmCollection.loadedVMObjects).incompleteTail=true;}newState.focusing=false;newState.dataLoaded=true;// set preferredChoices on state obj\nnewState.preferredChoices=action.preferredChoices;return newState;};const resetVMCollection=state=>{let newState={...state};newState.cursor.startIndex=0;delete newState.totalFound;newState.cursor.endReached=false;newState.fetching=false;newState.focusing=false;newState.dataLoaded=false;return newState;};const vmCollectionReducer=(state,action)=>{switch(action.type){case'COLLECTION_UPDATE':// revisitme - needs to do concat here to make sure the whole state of vmCollection\n// is managed here, not dataProvider object\nreturn updateVMCollection(state,action);case'COLLECTION_RESET':return resetVMCollection(state);case'IN_PROGRESS':return{...state,fetching:action.fetching};case'FOCUSING':return{...state,focusing:action.focusing};case'COLLECTION_REPLACE':return loadVMCollection(state,action);default:return state;}};const usePagingObserver=dataProvider=>{let rootLevelRef=dataProvider.getRootReference();// cursor hook\nconst[pageObject,pageDispatcher]=useReducer(pageReducer,{// revisitme: move startIndex logic to here\npage:0});let containerElement;let bottomAnchorElement;let paginationOption=dataProvider.getPagination();if(paginationOption){let bottomAnchorSelector=paginationOption.bottomAnchorSelector;containerElement=rootLevelRef.current?rootLevelRef.current:null;bottomAnchorElement=rootLevelRef.current?rootLevelRef.current.querySelector(bottomAnchorSelector):null;}// only trigger next page when previous REST call is done\nconst loadNextPage=()=>{if(!dataProvider.vmCollectionObj.fetching){pageDispatcher({type:'NEXT_PAGE'});}};let observer=useRef(null);useEffect(()=>{// intersection observer needs both the container and the anchor element to work properly.\nif(bottomAnchorElement&&containerElement){const interSectionWatcher=entries=>{entries.forEach(en=>{if(en.intersectionRatio>0){loadNextPage();}});};let options={root:containerElement,rootMargin:'5px',threshold:1};observer.current=new IntersectionObserver(interSectionWatcher,options);observer.current.observe(bottomAnchorElement);}return()=>{//zarq9k: need to destroy the observer to prevent leakage.\nif(observer.current){observer.current.disconnect();}};},[containerElement,bottomAnchorElement,rootLevelRef]);// if containerElement has no scroll yet, then we should auto load next page until scroll happened or endReached\nuseEffect(()=>{if(dataProvider.vmCollectionObj.cursor.endReached){return undefined;}if(containerElement&&containerElement.clientHeight>0&&containerElement.scrollHeight<=containerElement.clientHeight){loadNextPage();}return undefined;},[pageObject.page]);// , dataProvider.vmCollectionObj\nreturn{pageObject,pageDispatcher};};export const useDataProvider=(dataProvider,getProps,dataCtxNode)=>{const topLevelRef=useRef(null);// attaching a ref to each dataProvider, so that we can pass it to list.\ndataProvider.setRootReference(topLevelRef);const{pageObject,pageDispatcher}=usePagingObserver(dataProvider);const[vmCollectionObj,vmCollectionDispatcher]=useReducer(vmCollectionReducer,{vmCollection:dataProvider.viewModelCollection,totalFound:0,hasMoreValuesExist:null,fetching:false,dataLoaded:false,preferredChoices:[],cursor:{startIndex:0,startReached:false,endIndex:0,endReached:true}});if(dataProvider.inputDataExpressions&&dataProvider.inputDataExpressions.length>0){updateInputDataOnDP(dataProvider,dataCtxNode);}dataProvider.setPropsCallback(getProps);let inputSelectionModel=null;if(dataProvider.json.inputData&&dataProvider.json.inputData.selectionModel){inputSelectionModel=dataProvider.json.inputData.selectionModel;}const dataProviderJson=_.get(dataProvider,'json');const mode=dataProviderJson?dataProviderJson.selectionModelMode:null;const uwSelectionModel=useSelectionModel(mode,null,inputSelectionModel);if(dataProvider.json.inputData&&dataProvider.json.inputData.selectionData){uwSelectionModel.selectionData=dataProvider.json.inputData.selectionData;}const validSourceTypes=dataProvider.json.inputData?dataProvider.json.inputData.validSourceTypes:null;if(_.get(dataProvider,'setValidSourceTypes')){dataProvider.setValidSourceTypes(validSourceTypes);}if(_.get(dataProvider,'setSelectionModel')){dataProvider.setSelectionModel({selectionModel:uwSelectionModel});}if(_.get(dataProvider,'setDataUpdater')){dataProvider.setDataUpdater(pageDispatcher,vmCollectionDispatcher);}useEffect(()=>{//Adding 'inputSelectionModel' check to limit registration of dp listener only for pwa usecase\n//This can be removed if more such usecases are encountered\nif(inputSelectionModel&&inputSelectionModel.selectionData){uwSelectionModel.addRemoveDpListener&&uwSelectionModel.addRemoveDpListener('add',dataProvider);}return()=>{uwSelectionModel.addRemoveDpListener('remove');};},[]);useEffect(()=>{const totalFound=dataProvider.viewModelCollection.getTotalObjectsFound();const totalUniqueLoaded=dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded();// revisitme - use this cursor in loadAction instead of using internal dataProvider.startIndex\n//if( startIndex.current === 0 || startIndex.current < totalFound.current ) {\nif(!vmCollectionObj.fetching&&(!vmCollectionObj.cursor.endReached||vmCollectionObj.focusing===true||totalFound>totalUniqueLoaded)){vmCollectionDispatcher({type:'IN_PROGRESS',fetching:true});dataProvider.loadAction(vmCollectionObj.vmCollection,vmCollectionObj.cursor.startIndex,pageObject);}},[dataProvider,pageObject,pageDispatcher]);//DO not consider current selection until the data is available\nlet currentSelection=vmCollectionObj.dataLoaded?uwSelectionModel.getSelection():null;useEffect(()=>{//sync the selectionModel only if there is data\n//if there is no data this is a redundant operation\nif(_.get(dataProvider,'syncSelectionModel')&&vmCollectionObj.dataLoaded){dataProvider.syncSelectionModel({data:{}},currentSelection,uwSelectionModel.getLastSelection());}},[currentSelection,dataProvider]);return{vmCollectionObj};};const updateInputDataOnDP=(dataProvider,dataCtxNode)=>{let context=declUtils.getLatestContext(dataCtxNode,dataCtxNode.data);dataProvider.inputDataExpressions.map(observer=>{dataProvider.json.inputData[Object.keys(observer)[0]]=_.get(context,Object.values(observer)[0]);});};export const useDataProviders=(dataProviders,getProps,dataCtxNode)=>{// Just to make sure the dp name order is same in every render.\nconst[dataProviderNames]=useState(()=>{return!_.isNil(dataProviders)?Object.keys(dataProviders):[];});//dataProviderNames order will never change between render cycles, hence disabling the eslint\n//https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function\n// zarq9k: any better solution ?\ndataProviderNames.forEach(dpName=>{// zarq9k: once we sink up new and old vmCollectionObj, dataProviders[ dpName ].vmCollectionObj would not be required\n// eslint-disable-next-line react-hooks/rules-of-hooks\ndataProviders[dpName].vmCollectionObj=useDataProvider(dataProviders[dpName],getProps,dataCtxNode).vmCollectionObj;});return{};};","map":null,"metadata":{},"sourceType":"module"}