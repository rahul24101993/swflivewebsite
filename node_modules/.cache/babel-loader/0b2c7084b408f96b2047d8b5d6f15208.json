{"ast":null,"code":"/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This module provides the utility functions for supporting aw service.\n *\n * @module js/serviceUtils\n */\nimport _ from 'lodash';\n/**\n * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\n\nexport function httpGet(theUrl) {\n  return new Promise((resolve, reject) => {\n    var xmlHttp = new XMLHttpRequest();\n\n    xmlHttp.onreadystatechange = function () {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        resolve(xmlHttp.responseText);\n      }\n    };\n\n    xmlHttp.onerror = function (e) {\n      reject(e);\n    };\n\n    xmlHttp.open('GET', theUrl, true); // true for asynchronous\n\n    xmlHttp.send(null);\n  });\n}\n/**\n * simple http get for JSON specific and fake response data structure.\n * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\n\nexport function httpGetJsonObject(theUrl) {\n  return httpGet(theUrl).then(txt => {\n    return {\n      data: JSON.parse(txt)\n    };\n  });\n}\n/**\n * Quick check for if the expression can be splitted or not.\n *\n * NOTE: it is strictly based on logic in parseExpression, only handle the case that\n * parseExpression can handle\n * @param {String} expression The expression to parse.\n * @returns {Boolean} true if expression can be splitted.\n */\n\nexport const expressionCanSplit = expression => {\n  return expression.match(/[)(+\\-*/^!&|=><%?:]|\\['|'\\]/);\n};\n/**\n * Splits expression into sub expression\n * @param {String} expression - The expression which needs to broken\n * @returns {Array} - Array of sub expressions\n */\n\nexport const processExpression = expression => {\n  // remove trailing newline character which is added automatically\n  const characters = Array.from(expression.replace(/(\\r\\n|\\n|\\r)/gm, '').trim());\n  let stack = [];\n  let expr = '';\n  let ignoreQuotes = false;\n  characters.forEach((character, index) => {\n    if (character === '(') {\n      if (expr === '') {\n        stack.push('(');\n      } else {\n        expr = `${expr}${character}`;\n      }\n    } else if (character === ')') {\n      const temp = `${expr}${character}`;\n      const openBrackets = temp.split('(').length - 1;\n      const closedBrackets = temp.split(')').length - 1;\n\n      if (openBrackets === 0) {\n        if (expr !== '') {\n          stack.push({\n            expr\n          });\n          expr = '';\n        }\n\n        stack.push(')');\n      } else if (openBrackets > 0) {\n        if (openBrackets < closedBrackets) {\n          stack.push({\n            expr\n          });\n          expr = '';\n          stack.push(')');\n        } else {\n          expr = `${expr}${character}`;\n        }\n      } // stack.push( ')' );\n\n    } else if (/(\\+|-|\\*|\\/|\\^|!|&|\\||=|>|<|%|\\?|:)/.test(character)) {\n      if (character !== ':') {\n        // handle such expression that contains equal to ex- \"ctx.message\" === \"\"Hello=World\"\n        if (character === '=' && !(characters[index - 1] === '=' || characters[index - 1] === '!' || characters[index - 1] === '>' || characters[index - 1] === '<' || characters[index + 1] === '=')) {\n          expr = `${expr}${character}`;\n        } else {\n          if (expr !== '') {\n            stack.push({\n              expr\n            });\n            expr = '';\n          }\n\n          stack.push(character);\n        }\n      } else {\n        const qMark = _.filter(stack, element => element === '?').length;\n\n        const colans = _.filter(stack, element => element === ':').length;\n\n        if (qMark - colans > 0) {\n          if (expr !== '') {\n            stack.push({\n              expr\n            });\n            expr = '';\n          }\n\n          stack.push(character);\n        } else {\n          expr = `${expr}${character}`;\n        }\n      }\n    } else if (character === '[' && characters[index + 1] === '\\'') {\n      expr = `${expr}.`;\n      ignoreQuotes = true;\n    } else if (character === ']' && characters[index - 1] === '\\'') {\n      //DO not\n      ignoreQuotes = false;\n    } else if (character === '\\'' && !ignoreQuotes) {\n      expr = `${expr}${character}`;\n    } else if (character.trim() !== '' && character.trim() !== '\\'') {\n      expr = `${expr}${character}`;\n    }\n\n    if (index === characters.length - 1) {\n      //process expr\n      if (expr !== '') {\n        // expr = `${expr}${character}`;\n        stack.push({\n          expr\n        });\n        expr = '';\n      }\n    } // if()\n\n  });\n  return stack;\n};\n/**\n * This API evaluates expression against the evaluation context using dynamic function.\n * @param {Array} params - The parameter name array\n * @param {Array} paramValues - The parameter value array\n * @param {Object} applyObject - The apply Object\n * @param {String} expression - The expression which needs to be evaluated\n * @returns {Object} result\n */\n\nexport const parseNative = (params, paramValues, applyObject, expression) => {\n  if (params) {\n    params = params.map(param => param.includes('-') ? param.replace(/\\-/g, '_') : param);\n  }\n\n  return evalExpression(expression, params, paramValues, false, applyObject);\n};\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Array} params - The parameter name array\n * @param {Array} values - The parameter value array\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n *\n * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically\n */\n\nexport const evalExpression = (expr, params, values, ignoreError, applyObject) => {\n  try {\n    let sandBoxParams = ['window', 'document', 'eval', 'setTimeout', 'setInterval', 'XMLHttpRequest', 'Function'];\n    let sandBoxValues = [{}, {}, {}, {}, {}, {}, {}]; //Replace all dot(.) as . are not valid arguments of function\n\n    let newParams = params.map(ele => ele.indexOf('.') < 0 ? ele : ele.replace(/\\./g, ''));\n    let func = new Function(...newParams, ...sandBoxParams, `return ${expr};`);\n    return func.apply(applyObject, values, ...sandBoxValues);\n  } catch (e) {\n    if (!ignoreError) {\n      throw new Error(`evalExpression('${expr}') => ${e.message}`);\n    } else {\n      return undefined;\n    }\n  }\n};\n/**\n * This metthod splits an expression into Array of subExpressions.\n * @param {String} expression - The expression to be interpolated\n * @returns {Array} Array of sub expressions\n */\n\nexport const splitExpressionForInterpolate = expression => {\n  const startSyntax = '{{';\n\n  if (expression.includes(startSyntax) === false) {\n    return expression;\n  }\n\n  const endSyntax = '}}';\n  const splits = expression.split(startSyntax);\n  let finalSplits = [];\n\n  _.forEach(splits, split => {\n    if (split.includes(endSyntax)) {\n      const subSplits = split.split(endSyntax);\n\n      _.forEach(subSplits, (sSplit, index) => {\n        if (index === 0) {\n          finalSplits.push({\n            expr: sSplit\n          });\n        } else {\n          finalSplits.push(sSplit);\n        }\n      });\n    } else {\n      finalSplits.push(split);\n    }\n  });\n\n  return finalSplits;\n};\n/**\n * Decode value from string.\n * @param {String} val - decode string value\n * @returns {String} value String\n */\n\nexport function valFromString(val) {\n  return val !== null ? val.toString().replace(/(~~|~2F)/g, function (m) {\n    const constantMap = {\n      '~~': '~',\n      '~2F': '/'\n    };\n    return constantMap[m];\n  }) : val;\n}\nexport default {\n  httpGet,\n  httpGetJsonObject,\n  processExpression,\n  expressionCanSplit,\n  valFromString,\n  evalExpression\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/serviceUtils.js"],"names":["xmlHttp","resolve","reject","txt","data","JSON","expressionCanSplit","expression","processExpression","characters","Array","stack","expr","ignoreQuotes","character","temp","openBrackets","closedBrackets","index","qMark","_","element","colans","parseNative","params","param","evalExpression","sandBoxParams","sandBoxValues","newParams","ele","func","e","message","splitExpressionForInterpolate","startSyntax","endSyntax","splits","finalSplits","split","subSplits","sSplit","constantMap"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This module provides the utility functions for supporting aw service.\n *\n * @module js/serviceUtils\n */\nimport _ from 'lodash';\n\n/**\n * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\nexport function httpGet( theUrl ) {\n    return new Promise( ( resolve, reject ) => {\n        var xmlHttp = new XMLHttpRequest();\n        xmlHttp.onreadystatechange = function() {\n            if( xmlHttp.readyState === 4 && xmlHttp.status === 200 ) {\n                resolve( xmlHttp.responseText );\n            }\n        };\n\n        xmlHttp.onerror = function( e ) {\n            reject( e );\n        };\n\n        xmlHttp.open( 'GET', theUrl, true ); // true for asynchronous\n        xmlHttp.send( null );\n    } );\n}\n\n/**\n * simple http get for JSON specific and fake response data structure.\n * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode\n * @param {string} theUrl url as string\n * @returns {Promise} promise\n */\nexport function httpGetJsonObject( theUrl ) {\n    return httpGet( theUrl ).then( ( txt ) => {\n        return {\n            data: JSON.parse( txt )\n        };\n    } );\n}\n\n/**\n * Quick check for if the expression can be splitted or not.\n *\n * NOTE: it is strictly based on logic in parseExpression, only handle the case that\n * parseExpression can handle\n * @param {String} expression The expression to parse.\n * @returns {Boolean} true if expression can be splitted.\n */\nexport const expressionCanSplit = expression => {\n    return expression.match( /[)(+\\-*/^!&|=><%?:]|\\['|'\\]/ );\n};\n\n/**\n * Splits expression into sub expression\n * @param {String} expression - The expression which needs to broken\n * @returns {Array} - Array of sub expressions\n */\nexport const processExpression = expression => {\n    // remove trailing newline character which is added automatically\n    const characters = Array.from( expression.replace( /(\\r\\n|\\n|\\r)/gm, '' ).trim() );\n    let stack = [];\n    let expr = '';\n    let ignoreQuotes = false;\n    characters.forEach( ( character, index ) => {\n        if( character === '(' ) {\n            if( expr === '' ) {\n                stack.push( '(' );\n            } else {\n                expr = `${expr}${character}`;\n            }\n        } else if( character === ')' ) {\n            const temp = `${expr}${character}`;\n            const openBrackets = temp.split( '(' ).length - 1;\n            const closedBrackets = temp.split( ')' ).length - 1;\n            if( openBrackets === 0 ) {\n                if( expr !== '' ) {\n                    stack.push( { expr } );\n                    expr = '';\n                }\n                stack.push( ')' );\n            } else if( openBrackets > 0 ) {\n                if( openBrackets < closedBrackets ) {\n                    stack.push( { expr } );\n                    expr = '';\n                    stack.push( ')' );\n                } else {\n                    expr = `${expr}${character}`;\n                }\n            }\n            // stack.push( ')' );\n        } else if( /(\\+|-|\\*|\\/|\\^|!|&|\\||=|>|<|%|\\?|:)/.test( character ) ) {\n            if( character !== ':' ) {\n                // handle such expression that contains equal to ex- \"ctx.message\" === \"\"Hello=World\"\n                if( character === '=' && !( characters[ index - 1 ] === '=' || characters[ index - 1 ] === '!' || characters[ index - 1 ] === '>' || characters[ index - 1 ] === '<' ||\n                        characters[ index + 1 ] === '=' ) ) {\n                    expr = `${expr}${character}`;\n                } else {\n                    if( expr !== '' ) {\n                        stack.push( { expr } );\n                        expr = '';\n                    }\n                    stack.push( character );\n                }\n            } else {\n                const qMark = _.filter( stack, element => element === '?' ).length;\n                const colans = _.filter( stack, element => element === ':' ).length;\n                if( qMark - colans > 0 ) {\n                    if( expr !== '' ) {\n                        stack.push( { expr } );\n                        expr = '';\n                    }\n                    stack.push( character );\n                } else {\n                    expr = `${expr}${character}`;\n                }\n            }\n        } else if( character === '[' && characters[ index + 1 ] === '\\'' ) {\n            expr = `${expr}.`;\n            ignoreQuotes = true;\n        } else if( character === ']' && characters[ index - 1 ] === '\\'' ) {\n            //DO not\n            ignoreQuotes = false;\n        } else if( character === '\\'' && !ignoreQuotes ) {\n            expr = `${expr}${character}`;\n        } else if( character.trim() !== '' && character.trim() !== '\\'' ) {\n            expr = `${expr}${character}`;\n        }\n\n        if( index === characters.length - 1 ) {\n            //process expr\n            if( expr !== '' ) {\n                // expr = `${expr}${character}`;\n                stack.push( { expr } );\n                expr = '';\n            }\n        }\n        // if()\n    } );\n    return stack;\n};\n\n/**\n * This API evaluates expression against the evaluation context using dynamic function.\n * @param {Array} params - The parameter name array\n * @param {Array} paramValues - The parameter value array\n * @param {Object} applyObject - The apply Object\n * @param {String} expression - The expression which needs to be evaluated\n * @returns {Object} result\n */\nexport const parseNative = ( params, paramValues, applyObject, expression ) => {\n    if( params ) {\n        params = params.map( param => param.includes( '-' ) ? param.replace( /\\-/g, '_' ) : param );\n    }\n    return evalExpression( expression, params, paramValues, false, applyObject );\n};\n\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Array} params - The parameter name array\n * @param {Array} values - The parameter value array\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n *\n * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically\n */\nexport const evalExpression = ( expr, params, values, ignoreError, applyObject ) => {\n    try {\n        let sandBoxParams = [ 'window', 'document', 'eval', 'setTimeout', 'setInterval', 'XMLHttpRequest', 'Function' ];\n        let sandBoxValues = [ {}, {}, {}, {}, {}, {}, {} ];\n\n        //Replace all dot(.) as . are not valid arguments of function\n        let newParams = params.map( ele => ele.indexOf( '.' ) < 0 ? ele : ele.replace( /\\./g, '' ) );\n\n        let func = new Function( ...newParams, ...sandBoxParams, `return ${expr};` );\n        return func.apply( applyObject, values, ...sandBoxValues );\n    } catch ( e ) {\n        if( !ignoreError ) {\n            throw new Error( `evalExpression('${expr}') => ${e.message}` );\n        } else {\n            return undefined;\n        }\n    }\n};\n\n/**\n * This metthod splits an expression into Array of subExpressions.\n * @param {String} expression - The expression to be interpolated\n * @returns {Array} Array of sub expressions\n */\nexport const splitExpressionForInterpolate = expression => {\n    const startSyntax = '{{';\n    if( expression.includes( startSyntax ) === false ) {\n        return expression;\n    }\n    const endSyntax = '}}';\n    const splits = expression.split( startSyntax );\n    let finalSplits = [];\n    _.forEach( splits, split => {\n        if( split.includes( endSyntax ) ) {\n            const subSplits = split.split( endSyntax );\n            _.forEach( subSplits, ( sSplit, index ) => {\n                if( index === 0 ) {\n                    finalSplits.push( { expr: sSplit } );\n                } else {\n                    finalSplits.push( sSplit );\n                }\n            } );\n        } else {\n            finalSplits.push( split );\n        }\n    } );\n    return finalSplits;\n};\n\n/**\n * Decode value from string.\n * @param {String} val - decode string value\n * @returns {String} value String\n */\nexport function valFromString( val ) {\n    return val !== null ? val.toString().replace( /(~~|~2F)/g, function( m ) {\n        const constantMap = { '~~': '~', '~2F': '/' };\n        return constantMap[ m ];\n    } ) : val;\n}\n\nexport default {\n    httpGet,\n    httpGetJsonObject,\n    processExpression,\n    expressionCanSplit,\n    valFromString,\n    evalExpression\n};\n"]},"metadata":{},"sourceType":"module"}