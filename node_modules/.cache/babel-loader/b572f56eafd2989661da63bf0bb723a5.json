{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/atomicDataService\n */\nimport _ from 'lodash';\n/**\n * @param {*} stateObject The stateobject inside atomic data section of viewmodel.\n * @param {*} metaObj The meta object for the same\n * @param {*} rootPath The name of the state object inside atomicdata.\n * @param {*} createField the function to create field objects\n * @returns\n */\n\nexport const createFieldsBasedOnMetaData = function (stateObject, metaObj, rootPath, createField) {\n  let atomicFields = {};\n  const fieldsPath = [];\n  fieldsPath.push(rootPath);\n  parseMetaForFieldsPath(metaObj);\n  validateObjWithMetaObjAndCreateFields(stateObject);\n  let rootField = createField('', rootPath, 'partialField');\n  atomicFields = { ...rootField,\n    ...atomicFields\n  };\n  /**\n   *\n   * @param {*} propName\n   * @param {*} basePath\n   * @returns\n   */\n\n  function parsePath(propName, basePath) {\n    let path;\n\n    if (basePath) {\n      path = Number.isInteger(propName) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n    } else {\n      path = propName;\n    }\n\n    return path;\n  }\n  /**\n   *\n   * @param {*} metaObj\n   * @param {*} rootPath\n   */\n\n\n  function parseMetaForFieldsPath(currentMetaObj) {\n    let basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _.forEach(currentMetaObj, function processMeta(propValue, propName) {\n      if (propName === 'field' || propName === 'type') {\n        return undefined;\n      }\n\n      let path = parsePath(propName, basePath);\n      fieldsPath.push(`${rootPath}.${path}`);\n\n      if (_.isObject(propValue)) {\n        parseMetaForFieldsPath(propValue, path);\n      }\n\n      return undefined;\n    });\n\n    return undefined;\n  }\n  /**\n   *\n   * @param {*} obj\n   * @param {*} metaObj\n   * @param {*} basePath\n   */\n\n\n  function validateObjWithMetaObjAndCreateFields(currStateObj, basePath) {\n    _.forEach(currStateObj, function (propValue, propName) {\n      let path = parsePath(propName, basePath);\n      const metaPathMatcher = path.replace(/\\d+/g, '0'); // This is just to match with schema\n\n      const isFieldObject = _.indexOf(fieldsPath, `${rootPath}.${metaPathMatcher}`) !== -1;\n\n      const fieldType = _.get(metaObj, `${metaPathMatcher}.type`, 'partialField');\n\n      const isLeafLevelFieldObj = isFieldObject && fieldType !== 'partialField';\n\n      if (isFieldObject) {\n        let atomicField = createField(path, rootPath, fieldType);\n\n        if (_.isArray(propValue)) {\n          let fieldsObj = atomicField;\n          atomicField = [...propValue];\n\n          _.assign(atomicField, fieldsObj);\n        } else if (_.isObject(propValue) && !isLeafLevelFieldObj) {\n          _.assign(atomicField, propValue);\n        }\n\n        if (fieldType === 'partialField') {\n          Object.defineProperty(atomicField, 'getValue', {\n            enumerable: false\n          });\n          Object.defineProperty(atomicField, 'value', {\n            enumerable: false\n          });\n          Object.defineProperty(atomicField, 'update', {\n            enumerable: false\n          });\n        }\n\n        _.set(atomicFields, path, atomicField);\n      } else {\n        //workaround to handle 'Categorization.category' as a prop name\n        if (!Number.isInteger(propName) && propName.includes('.')) {\n          path = path.replace('.' + propName, `['${propName}']`);\n        } // If only raw data (read only), then set it without generating any field.\n\n\n        _.set(atomicFields, path, _.get(currStateObj, propName));\n      } // If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.\n      // It would save lot of un-necessary recursions.\n      // If current propValue is of type \"Meta\" and fieldType === 'FieldObject', then only traverse inside.\n      // If the fieldType is of type \"field\" or \"VMP\", no need to traverse the object inside.\n\n      /**\n       *  Two Important cases\n       * 1. Current Object (propValue) is not of type \"Field\" i.e not in meta, this means all down ward objects are also not fields\n       *  Hence, no need to traverse inside it.\n       *\n       * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,\n       * but if the propValue is of type \"field\" but not 'partialField' ( ie. full fledged Field Object), this means it the end of\n       * hierarchy (leaf leavel Field Node), no need to traverse inside it.\n       * no need to go inside.\n       */\n\n\n      if (_.isObject(propValue) && isFieldObject && !isLeafLevelFieldObj) {\n        validateObjWithMetaObjAndCreateFields(propValue, path);\n      }\n    });\n  }\n\n  return atomicFields;\n};","map":{"version":3,"names":["_","createFieldsBasedOnMetaData","stateObject","metaObj","rootPath","createField","atomicFields","fieldsPath","push","parseMetaForFieldsPath","validateObjWithMetaObjAndCreateFields","rootField","parsePath","propName","basePath","path","Number","isInteger","currentMetaObj","forEach","processMeta","propValue","undefined","isObject","currStateObj","metaPathMatcher","replace","isFieldObject","indexOf","fieldType","get","isLeafLevelFieldObj","atomicField","isArray","fieldsObj","assign","Object","defineProperty","enumerable","set","includes"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/atomicDataService.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/atomicDataService\n */\nimport _ from 'lodash';\n\n/**\n * @param {*} stateObject The stateobject inside atomic data section of viewmodel.\n * @param {*} metaObj The meta object for the same\n * @param {*} rootPath The name of the state object inside atomicdata.\n * @param {*} createField the function to create field objects\n * @returns\n */\nexport const createFieldsBasedOnMetaData = function( stateObject, metaObj, rootPath, createField ) {\n    let atomicFields = {};\n    const fieldsPath = [];\n    fieldsPath.push( rootPath );\n    parseMetaForFieldsPath( metaObj );\n    validateObjWithMetaObjAndCreateFields( stateObject );\n    let rootField = createField( '', rootPath, 'partialField' );\n    atomicFields = { ...rootField, ...atomicFields };\n\n    /**\n     *\n     * @param {*} propName\n     * @param {*} basePath\n     * @returns\n     */\n    function parsePath( propName, basePath ) {\n        let path;\n        if( basePath ) {\n            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n        } else {\n            path = propName;\n        }\n        return path;\n    }\n\n    /**\n     *\n     * @param {*} metaObj\n     * @param {*} rootPath\n     */\n    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {\n        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {\n            if( propName === 'field' || propName === 'type' ) {\n                return undefined;\n            }\n            let path = parsePath( propName, basePath );\n            fieldsPath.push( `${rootPath}.${path}` );\n            if( _.isObject( propValue ) ) {\n                parseMetaForFieldsPath( propValue, path );\n            }\n            return undefined;\n        } );\n        return undefined;\n    }\n    /**\n     *\n     * @param {*} obj\n     * @param {*} metaObj\n     * @param {*} basePath\n     */\n    function validateObjWithMetaObjAndCreateFields( currStateObj, basePath ) {\n        _.forEach( currStateObj, function( propValue, propName ) {\n            let path = parsePath( propName, basePath );\n            const metaPathMatcher = path.replace( /\\d+/g, '0' ); // This is just to match with schema\n            const isFieldObject = _.indexOf( fieldsPath, `${rootPath}.${metaPathMatcher}` ) !== -1;\n            const fieldType = _.get( metaObj, `${metaPathMatcher}.type`, 'partialField' );\n            const isLeafLevelFieldObj = isFieldObject && fieldType !== 'partialField';\n            if( isFieldObject ) {\n                let atomicField = createField( path, rootPath, fieldType );\n                if( _.isArray( propValue ) ) {\n                    let fieldsObj = atomicField;\n                    atomicField = [ ...propValue ];\n                    _.assign( atomicField, fieldsObj );\n                } else if( _.isObject( propValue ) && !isLeafLevelFieldObj ) {\n                    _.assign( atomicField, propValue );\n                }\n                if( fieldType === 'partialField' ) {\n                    Object.defineProperty( atomicField, 'getValue', { enumerable: false } );\n                    Object.defineProperty( atomicField, 'value', { enumerable: false } );\n                    Object.defineProperty( atomicField, 'update', { enumerable: false } );\n                }\n                _.set( atomicFields, path, atomicField );\n            } else {\n                //workaround to handle 'Categorization.category' as a prop name\n                if( !Number.isInteger( propName ) && propName.includes( '.' ) ) {\n                    path = path.replace( '.' + propName, `['${propName}']` );\n                }\n                // If only raw data (read only), then set it without generating any field.\n                _.set( atomicFields, path, _.get( currStateObj, propName ) );\n            }\n            // If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.\n            // It would save lot of un-necessary recursions.\n            // If current propValue is of type \"Meta\" and fieldType === 'FieldObject', then only traverse inside.\n            // If the fieldType is of type \"field\" or \"VMP\", no need to traverse the object inside.\n            /**\n             *  Two Important cases\n             * 1. Current Object (propValue) is not of type \"Field\" i.e not in meta, this means all down ward objects are also not fields\n             *  Hence, no need to traverse inside it.\n             *\n             * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,\n             * but if the propValue is of type \"field\" but not 'partialField' ( ie. full fledged Field Object), this means it the end of\n             * hierarchy (leaf leavel Field Node), no need to traverse inside it.\n             * no need to go inside.\n             */\n            if( _.isObject( propValue ) && isFieldObject && !isLeafLevelFieldObj ) {\n                validateObjWithMetaObjAndCreateFields( propValue, path );\n            }\n        } );\n    }\n    return atomicFields;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}