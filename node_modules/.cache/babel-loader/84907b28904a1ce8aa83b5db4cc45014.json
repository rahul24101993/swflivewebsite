{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).\n *\n * @module js/awTableService\n */import awColumnSvc from'js/awColumnService';import viewModelObjectSvc from'js/viewModelObjectService';import declModelRegistrySvc from'js/declModelRegistryService';import vmPropSvc from'js/uwPropertyService';import assert from'js/assert';import _ from'lodash';import declUtils from'js/declUtils';import logger from'js/logger';/**\n * revisitme yogesh\n * in whole file lot of jquery and scope usages\n */import $ from'jquery';/**\n * {Number} The maximum # of nodes/rows to request to be returned in a single call to the dataProviderService\n * for the table.\n * <P>\n * Note: This number could be changed dynamically in the future to be based on the number of rows actually being\n * displayed.\n */var _defaultPageSizeTable=40;/**\n * {Number} The maximum # of nodes/rows to request to be returned in a single call to the dataProviderService\n * for the tree.\n * <P>\n * Note: This number could be changed dynamically in the future to be based on the number of rows actually being\n * displayed.\n */var _defaultPageSizeTree=40;/**\n * -------------------------------------------------------------------------<BR>\n * Define Service Objects<BR>\n * -------------------------------------------------------------------------<BR>\n */ /**\n * This class is the overall model used to control the contents and behavior of the 'aw-table' directive. This\n * model allows for functional pieces to be overridden and implemented in application specific ways. Defaults\n * are specified here.\n *\n * @class AwTableViewModel\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' containing properties to base the new\n *            'awTableViewModel' upon.\n *\n * @param {String} gridId - ID of the {declGrid} this model is wrapping.\n *\n * @param {Object} $scope - the scope object\n *\n */var AwTableViewModel=function(declViewModel,gridId,$scope){var vmSelf=this;// eslint-disable-line consistent-this\n/**\n     * @property {String} selectionMode - 'single' or 'multi'\n     *\n     * @memberOf module:js/awTableService~AwTableViewModel\n     */vmSelf.selectionMode='single';/**\n     * @property {String} selectionScope - 'row' or 'cell'\n     *\n     * @memberOf module:js/awTableService~AwTableViewModel\n     */vmSelf.selectionScope='row';/**\n     * @property {Boolean} enableArrangeMenu - default is false\n     *\n     * @memberOf module:js/awTableService~AwTableViewModel\n     */vmSelf.enableArrangeMenu=false;/**\n     * @property {Boolean} enableFilterMenu - default is false\n     *\n     * @memberOf module:js/awTableService~AwTableViewModel\n     */vmSelf.enableFilterMenu=false;/**\n     * @property {Boolean} isEditable - default is false\n     */vmSelf.isEditable=false;/**\n     * ---------------------------------------------------------------------------<BR>\n     * Property & Function definition complete....Finish initialization. <BR>\n     * ---------------------------------------------------------------------------<BR>\n     */ /**\n     * Check if we do NOT have a valid 'declViewModel' and 'gridId' to work with.\n     */assert(declViewModel,'No DeclViewModel specified');assert(gridId,'No DeclGrid ID specified');if(declViewModel._internal.isDestroyed){assert(false,'Invalid to create objects on a destroyed DeclViewModel: '+declViewModel);}/**\n     * The ID of the 'declViewModel' to use for this 'aw-table'.\n     */vmSelf._declViewModelId=declViewModel.getPanelId();/**\n     * Remember this 'declGrid' ID\n     * The ID of the 'declGrid' in the 'declViewModel' to use for this 'aw-table'.\n     */vmSelf._declGridId=gridId;declModelRegistrySvc.registerModel('AwTableViewModel',vmSelf,'_declGridId','_modelId');/**\n     * Initialize all properties based on the 'declViewModel' defined information.\n     * <P>\n     * Check if the 'declGrid' exists\n     */var declGrid=declViewModel._internal.grids[gridId];assert(declGrid,'Invalid DeclGrid ID specified');/**\n     * Set options from v-m json data\n     */vmSelf.gridOptions=declGrid.gridOptions;/**\n     * Check if declGrid has a valid 'dataProvider'.\n     */assert(declGrid.dataProvider,'No DeclDataProvider ID specified');assert(declViewModel.dataProviders[declGrid.dataProvider],'Invalid DeclDataProvider ID specified');/**\n     * Set reference to the 'declGrid's UwDataProvider.\n     */var uwDataProvider=declViewModel.dataProviders[declGrid.dataProvider];/**\n     * The 'UwDataProvider' used to access information about the rows and column value of this 'aw-table'.\n     */vmSelf._uwDataProvider=uwDataProvider;if(uwDataProvider.selectionModel&&uwDataProvider.selectionModel.mode){vmSelf.selectionMode=uwDataProvider.selectionModel.mode;}if(uwDataProvider.selectionModel&&uwDataProvider.selectionModel.scope){vmSelf.selectionScope=uwDataProvider.selectionModel.scope;}/**\n     * Setup columns information\n     * The 'AwTableColumnProvider' used to access information about the columns of this 'aw-table'.\n     */vmSelf._tableColumnProvider=awColumnSvc.createColumnProvider(declViewModel,$scope,uwDataProvider.commands,gridId,uwDataProvider.json.commandsAnchor);vmSelf._tableColumnProvider.initialize().then(function(){// DO nothing\n},function(err){logger.error('Failure during table tableColumnProvider initialization: '+err);});/**\n     * Set 'enableArrangeMenu' if the declGrid indicated an override of the default.\n     */if(!declUtils.isNil(declGrid.enableArrangeMenu)){vmSelf.enableArrangeMenu=declGrid.enableArrangeMenu;}/**\n     * Set 'enableFilterMenu' if the declGrid indicated an override of the default.\n     */if(!declUtils.isNil(declGrid.enableFilterMenu)){vmSelf.enableFilterMenu=declGrid.enableFilterMenu;}/**\n     * Check if declGrid has a valid 'propertyProvider'.\n     * The 'UwDataProvider' used to access properties for the rows and column value of this 'aw-table'.\n     */if(declGrid.propertyProvider&&declViewModel.dataProviders[declGrid.propertyProvider]){vmSelf._uwPropProvider=declViewModel.dataProviders[declGrid.propertyProvider];}};// AwTableViewModel\n/**\n * Override the default implementation to return more helpful information.\n *\n * @return {String} Text used to identify the ID of the AwTableViewModel (e.g. 'modelId' + optional model IDs).\n */AwTableViewModel.prototype.toString=function(){if(this){if(this._declViewModelId){return this._modelId+//\n'  viewModel: '+this._declViewModelId+//\n'  grid: '+this._declGridId+//\n'  dataProvider: '+this._uwDataProvider;}return this._modelId+'  viewModelId: '+'???';}return'AwTableViewModel'+'(Destroyed)';};/**\n * Get the 'provider' used to access information about the rows and column values of this 'aw-table'.\n *\n * @memberOf module:js/awTableService~AwTableViewModel\n *\n * @return {UwDataProvider} Reference to the currently registered 'UwDataProvider'.\n */AwTableViewModel.prototype.getDataProvider=function(){return this._uwDataProvider;};/**\n * Get the 'provider' used to access properties for the rows and column values of this 'aw-table'.\n *\n * @memberOf module:js/awTableService~AwTableViewModel\n *\n * @return {UwDataProvider} Reference to the currently registered 'UwDataProvider' that provides property\n *         information.\n */AwTableViewModel.prototype.getPropertyProvider=function(){return this._uwPropProvider;};/**\n * Get the 'provider' used to access information about the columns of this 'aw-table'.\n *\n * @memberOf module:js/awTableService~AwTableViewModel\n *\n * @return {AwTableColumnProvider} Reference to the currently registered 'AwTableColumnProvider'.\n */AwTableViewModel.prototype.getColumnProvider=function(){assert(this._tableColumnProvider,'No AwTableColumnProvider set');return this._tableColumnProvider;};/**\n * Get the ID of the 'declGridId' in the 'declViewModel' to be used with this 'aw-table'.\n *\n * @memberOf module:js/awTableService~AwTableViewModel\n *\n * @return {String} The ID of the 'declGridId' in the 'declViewModel' to be used with this 'aw-table'.\n */AwTableViewModel.prototype.getGridId=function(){return this._declGridId;};/**\n * Free up all resources held/managed by this object.\n * <P>\n * Note: After this function, no API call should be considered valid. This function is intended to be called\n * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event), any\n * objects managed by this class may be considered a 'memory leak'.\n */AwTableViewModel.prototype.destroy=function(){declModelRegistrySvc.unregisterModel('AwTableViewModel',this,'_declGridId','_modelId');if(this._tableColumnProvider){this._tableColumnProvider.destroy();this._tableColumnProvider=null;}this._uwDataProvider=null;this._uwPropProvider=null;};/**\n * Instances of this class represent the input structure to a request to load a page of rows (nodes) into a flat\n * table/list.\n *\n * @class ListLoadInput\n *\n * @param {String} parentUid - (See property description below)\n * @param {Number} startChildNdx - (See property description below)\n * @param {Number} pageSize - (Optional) (See property description below)\n * @param {Boolean} addAfter - (Optional) (See property description below)\n * @param {Object} filter - (Optional) The string used to filter the list.\n *            <P>\n *            <P>\n *\n * @property {String} parentUid - The 'parent' ViewModelTreeNode used to access any 'child' nodes in the next\n *           level down in the hierarchy.\n * @property {Number} startChildNdx - The 'childNdx' of the node to start the 'next' page loading at (Default:\n *           0).\n * @property {Number} pageSize - The maximum # of 'child' node to return in any single paged access (Default:\n *           See _defaultPageSizeTable ).\n * @property {String} startChildId - The 'id' of the node to start the 'next' page loading at.\n * @property {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n *           (Default: TRUE)\n * @property {String} filter - The string used to filter the list.\n */var ListLoadInput=function(parentUid,startChildNdx,pageSize,addAfter,filter){this.parentUid=parentUid;this.startChildNdx=declUtils.isNil(startChildNdx)?0:startChildNdx;this.pageSize=declUtils.isNil(pageSize)?_defaultPageSizeTable:pageSize;this.addAfter=declUtils.isNil(addAfter)?true:addAfter;this.filter=filter;};/**\n * The class is used to communicate the results of a single paged loading of 'child' nodes in a 'parent' node.\n *\n * @class ListLoadResult\n *\n * @param {ViewModelObject} parentNode - (See property description below)\n * @param {ViewModelObjectArray} childNodes - (See property description below)\n * @param {Number} totalChildCount - (See property description below)\n * @param {Number} startChildNdx - (See property description below)\n * @param {ViewModelObject} newTopNode - (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelObject} parentNode - The 'parent' ViewModelTreeNode used to access any 'child' nodes in\n *           the next level down in the hierarchy.\n *\n * @property {ViewModelObjectArray} childNodes - Array of 'child' nodes resulting from a single load execution\n *           in the context of a 'parent' node (i.e. 'children' in the next level down in the hierarchy).\n *\n * @property {Number} totalChildCount - The total # of known 'child' nodes regardless of how many are currently\n *           loaded into the 'parent' 'children' array.\n *\n * @property {Number} startChildNdx - The 'childNdx' provided in the ListLoadInput that was used to load this\n *           data. This is returned as part of the result to handle cases when multiple loads are being\n *           performed on the same 'parent' and the original closure data could have changed during the async\n *           processing.\n *\n * @property {ViewModelObject} newTopNode - (Optional) If this property is defined, it will be used to replace\n *           the (unseen) 'top' node associated with the overall list.\n *           <P>\n *           Note: If 'children' array of this node is not empty it will be ignored and the 'childNodes' of this\n *           result will be set as the 1st level children of this 'parent' node.\n */var ListLoadResult=function(parentNode,childNodes,totalChildCount,startChildNdx,newTopNode){this.parentNode=parentNode;this.childNodes=childNodes;this.totalChildCount=totalChildCount;this.startChildNdx=startChildNdx;/**\n     * We want to keep the following undefined until when know we need them to be defined.\n     */if(newTopNode){this.newTopNode=newTopNode;}};/**\n * Instances of this class represent the input structure to a request to load properties of a collection of\n * tree-table nodes.\n *\n * @class PropertyLoadRequest\n * @param {ViewModelTreeNode} parentNode - (See property description below)\n * @param {ViewModelTreeNodeArray} childNodes - (See property description below)\n * @param {AwTableColumnInfoArray} columnInfos - (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelTreeNode} parentNode - The 'parent' node the 'child' nodes belong to.\n * @property {ViewModelTreeNodeArray} childNodes - Array of nodes to load ViewModelProperty objects for.\n * @property {AwTableColumnInfoArray} columnInfos - Array of AwTableColumnInfo object containing property names\n *           to load.\n */var PropertyLoadRequest=function(parentNode,childNodes,columnInfos){this.parentNode=parentNode;this.childNodes=childNodes;this.columnInfos=columnInfos;};/**\n * Instances of this class represent the input structure to a request to load properties of a collection of\n * tree-table nodes.\n *\n * @class PropertyLoadInput\n * @param {PropertyLoadRequestArray} propertyLoadRequests - (See property description below)\n *            <P>\n *            <P>\n * @property {PropertyLoadRequestArray} propertyLoadRequests - Array requests to fulfill.\n */var PropertyLoadInput=function(propertyLoadRequests){this.propertyLoadRequests=propertyLoadRequests;};/**\n * The class is used to communicate the results of incremental loading of properties for ViewModelTreeNodes.\n *\n * @class PropertyLoadResult\n * @param {ViewModelTreeNodeArray} updatedNodes - (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelTreeNodeArray} updatedNodes - Array of ViewModelTreeNodes who's ViewModelProperties have\n *           been loaded/updated.\n */var PropertyLoadResult=function(updatedNodes){this.updatedNodes=updatedNodes;};/**\n * The class is used to communicate the results of a single paged loading of 'child' nodes in a 'parent' node.\n *\n * @class TableLoadResult\n * @param {Number} totalFound - (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelObjectArray} rowsLoaded - Array of ViewModelObjects resulting from a single load\n *           execution in the context of a flat table.\n * @property {Number} totalFound - The total # of known rows regardless of how many are currently loaded into\n *           the flat table.\n * @property {Number} nextSearchIndex - The 'page' to start the 'next' page loading at (or -1 if no more rows\n *           exist).\n */var TableLoadResult=function(totalFound){this.rowsLoaded=[];this.totalFound=totalFound;this.nextSearchIndex=-1;};/**\n * Instances of this class represent the input structure to a request to load a page of rows (nodes) into a\n * tree-table.\n *\n * @class TreeLoadInput\n *\n * @param {ViewModelTreeNode} parentNode - (See property description below)\n * @param {Number} startChildNdx - (See property description below)\n * @param {String} startChildId - (See property description below)\n * @param {String} cursorNodeId - (Optional) (See property description below)\n * @param {Number} pageSize - (Optional) (See property description below)\n * @param {Boolean} addAfter - (Optional) (See property description below)\n * @param {ViewModelTreeNode} rootNode - (Optional) (See property description below)\n * @param {Boolean} focusLoadAction - (Optional) (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelTreeNode} parentNode - The 'parent' ViewModelTreeNode used to access any 'child' nodes in\n *           the next level down in the hierarchy.\n * @property {Number} startChildNdx - The 'childNdx' of the node to start the 'next' page loading at.\n * @property {String} startChildId - The 'id' of the node to start the 'next' page loading at.\n * @property {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n *           ViewModelCollection) to insert any new nodes after (or before...depending on value of 'addAfter').\n *           <P>\n *           Note: If not defined, the 'child' nodes will be added at the end (or beginning) of the 'parent'\n *           node's 'children'.\n * @property {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n *           (Default: TRUE)\n * @property {Number} pageSize - The maximum # of 'child' nodes to return in any single paged access (Default:\n *           See _defaultPageSizeTree).\n * @property {ViewModelTreeNode} rootNode - The 'tree' ViewModelTreeNode used to access any 'child' nodes in the\n *           next level down in the hierarchy.\n * @property {Boolean} focusLoadAction - (Optional) TRUE if action is called to load selected object that is\n *           currently not present in tree\n */var TreeLoadInput=function(parentNode,startChildNdx,startChildId,cursorNodeId,pageSize,addAfter,rootNode,focusLoadAction){this.parentNode=parentNode;this.rootNode=rootNode;this.startChildNdx=startChildNdx;this.startChildId=startChildId;this.cursorNodeId=cursorNodeId;this.pageSize=declUtils.isNil(pageSize)?_defaultPageSizeTree:pageSize;this.addAfter=declUtils.isNil(addAfter)?true:addAfter;/**\n     * We want to keep following parameter undefined until when know we need them to be defined.\n     */if(focusLoadAction){this.focusLoadAction=focusLoadAction;}};/**\n * The class is used to communicate the results of a single paged loading of 'child' nodes in a 'parent' node.\n *\n * @class TreeLoadResult\n *\n * @param {ViewModelTreeNode} parentNode - (See property description below)\n * @param {ViewModelTreeNodeArray} childNodes - (See property description below)\n * @param {Number} totalChildCount - (See property description below)\n * @param {Number} startChildNdx - (See property description below)\n * @param {String} cursorNodeId - (See property description below)\n * @param {ViewModelTreeNode} newTopNode - (See property description below)\n * @param {ViewModelTreeNodeArray} vmNodesInTreeHierarchyLevels - (See property description below)\n * @param {Boolean} mergeNewNodesInCurrentlyLoadedTree - (See property description below)\n *            <P>\n *            <P>\n * @property {ViewModelTreeNode} parentNode - The 'parent' ViewModelTreeNode used to access any 'child' nodes in\n *           the next level down in the hierarchy.\n *\n * @property {ViewModelTreeNodeArray} childNodes - Array of 'child' ViewModelTreeNode objects resulting from a\n *           single load execution in the context of a 'parent' node (i.e. 'children' in the next level down in\n *           the hierarchy).\n *\n * @property {Number} totalChildCount - The total # of known 'child' nodes regardless of how many are currently\n *           loaded into the 'parent' 'children' array.\n *\n * @property {Number} startChildNdx - The 'childNdx' provided in the TreeLoadInput that was used to load this\n *           data. This is returned as part of the result to handle cases when multiple loads are being\n *           performed on the same 'parent' and the original closure data could have changed during the async\n *           processing.\n *\n * @property {String} cursorNodeId - (Optional) ID of an existing node in the 'parent' (and, presumably a\n *           ViewModelCollection) to insert any new nodes after (or before) depending on value of 'addAfter'.\n *\n * @property {ViewModelTreeNode} newTopNode - (Optional) If this property is defined, it will be used to replace\n *           the (unseen) 'top' tree node associated with the overall tree-table.\n *           <P>\n *           Note: If 'children' array of this node is not empty it will be ignored and the 'childNodes' of this\n *           result will be set as the 1st level children of this 'parent' node.\n *\n * @property {ViewModelTreeNodeArray} vmNodesInTreeHierarchyLevels - (Optional) Array of arrays. Each array\n *           index represents ViewModelTreeNode objects at given level.Array at index 0 in represents level -1, ,\n *           index 1 level 0 and so on. Each level will have ViewModelTreeNode where next level nodes need to be\n *           inserted.\n *\n * @property {Boolean} mergeNewNodesInCurrentlyLoadedTree - (Optional) If this property is true,\n *           vmNodesInTreeHierarchyLevels array will be merged in currently loaded tree at proper merge point if\n *           present in tree. All existing nodes in Tree and their properties will be retained.\n *\n */var TreeLoadResult=function(parentNode,childNodes,totalChildCount,startChildNdx,cursorNodeId,newTopNode,vmNodesInTreeHierarchyLevels,mergeNewNodesInCurrentlyLoadedTree){this.parentNode=parentNode;this.childNodes=childNodes;this.totalChildCount=totalChildCount;this.startChildNdx=startChildNdx;this.cursorNodeId=cursorNodeId;/**\n     * We want to keep the following parameters undefined until when know we need them to be defined.\n     */if(newTopNode){this.newTopNode=newTopNode;}if(vmNodesInTreeHierarchyLevels){this.vmNodesInTreeHierarchyLevels=vmNodesInTreeHierarchyLevels;}if(mergeNewNodesInCurrentlyLoadedTree){this.mergeNewNodesInCurrentlyLoadedTree=mergeNewNodesInCurrentlyLoadedTree;}};/**\n * Instances of this class represent the properties, hierarchy and status of a single row in a tree-table.\n *\n * @class ViewModelTreeNode\n * @param {String} nodeId - Unique ID for this node within the tree-table.\n * @param {String} type - (See property description below)\n * @param {String} displayName - (See property description below)\n * @param {Number} levelNdx - (See property description below)\n * @param {Number} childNdx - (See property description below)\n * @param {String} iconURL - (See property description below)\n * @param {String} svgString - (See property description below)\n *            <P>\n *            <P>\n * @property {String} id - Unique ID for this node within the tree-table.\n * @property {String} type - The type of model object represented by this tree node (i.e. 'Item'\n *           'DocumentRevision', etc.).\n * @property {String} displayName - The name to display in the 'navigation' column of the tree node.\n * @property {Number} levelNdx - The # of levels down from the 'root' of the tree-table.\n * @property {Number} childNdx - The index to this 'child' within the immediate 'parent'. This information is\n *           meant to help in when only a partial (or sparse) range of children have been loaded. This index is\n *           stable within the 'parent' and not representative of the order based on the 'id'.\n * @property {String} iconURL - The URL to the icon associated with the display of this node in the 'navigation'\n *           column of the tree-table.\n *           <P>\n * @property {String} svgString - The String svg icon associated with the display of this node in the 'navigation'\n *           column of the tree-table.\n *           <P>\n * @property {ViewModelPropertyMap} props - Map of propertyName to ViewModelProperty object holding the\n *           value/state of that property (or 'undefined' if no properties have been loaded yet).\n *           <P>\n * @property {Number} totalChildCount - The total # of known 'child' nodes regardless of how many are currently\n *           loaded into the 'children' array (or 'undefined' if no expansion has been occured or there are no\n *           children).\n *           <P>\n * @property {ViewModelTreeNodeArray} children - Array of currently loaded ViewModelTreeNode children in the\n *           next level down in the hierarchy (or 'undefined' if no expansion has been occurred or there are no\n *           children).\n *           <P>\n * @property {Boolean} isLeaf - TRUE if we have checked and there are NO 'child' nodes beneath this 'parent'\n *           node (or 'undefined' if no expansion has been occurred or there are children).\n */var ViewModelTreeNode=function(nodeId,type,displayName,levelNdx,childNdx,iconURL,svgString){this.uid=nodeId;this.id=nodeId;this.type=type;this.displayName=displayName;this.levelNdx=levelNdx;this.childNdx=childNdx;this.iconURL=iconURL;this.svgString=svgString;this.visible=true;/**\n     * We want to keep the following undefined until when know we need them to be defined.\n     */ // this.props;              // Defined for all ViewModelObjects\n// this.selected;           // Defined for all ViewModelObjects\n//\n// this.totalChildCount;\n// this.children;\n// this.isLeaf;\n// this.isExpanded;\n/**\n     * @private\n     * @property {Number} level number property used by ui-grid\n     */this.$$treeLevel=levelNdx;/**\n     * Note: This property is only defined when needed and then deleted after use.\n     *\n     * @private\n     * @property {Boolean} TRUE if this node is known to have >0 siblings before it in the ordered collection of\n     *           'child' nodes of its 'parent' node.\n     */ // this.incompleteHead = false;\n/**\n     * Note: This property is only defined when needed and then deleted after use.\n     *\n     * @private\n     * @property {Boolean} TRUE if this node is known to have >0 siblings after it in the ordered collection of\n     *           'child' nodes of its 'parent' node.\n     */ // this.incompleteTail = false;\n};/**\n * Note: This property is only defined when needed and then deleted after use.\n *\n * @private\n * @property {String} A localized suffix string shown when async loading operations are being performed on this\n *           node.\n */ // this.loadingStatus;\nViewModelTreeNode.prototype.clearEditiableStates=function(){_.forEach(this.props,function(prop2){vmPropSvc.resetUpdates(prop2);vmPropSvc.setIsEditable(prop2,false);});};/**\n * Sets the 'isEditable' of viewModelProperties if property in the associated IModelObject can be modified.\n *\n * @param {Boolean} editable - TRUE if the properties are to be marked as 'editable'.\n * @param {Boolean} override - TRUE if the editing state should be updated an announced even if not currently\n *            different than the desired state.\n * @param {Boolean} skipDigest - (Optional) TRUE if the 'triggerDigestCycle' function should NOT be called.\n */ViewModelTreeNode.prototype.setEditableStates=function(editable,override,skipDigest){viewModelObjectSvc.setEditableStates(this,editable,override,skipDigest);};/**\n * Override the default implementation to return more helpful information.\n *\n * @return {String} Text used to identify this ViewModelTreeNode (e.g. 'displayName', 'levelNdx', etc.).\n */ViewModelTreeNode.prototype.toString=function(){if(this.displayName){return'node: displayName: '+this.displayName+' levelNdx: '+this.levelNdx+' childNdx: '+this.childNdx;}return'node: displayName: '+'???';};/**\n * -------------------------------------------------------------------------<BR>\n * Define Service API<BR>\n * -------------------------------------------------------------------------<BR>\n */var exports={};/**\n * @param {String} parentUid - UID of the 'parent' IModelObject used to access any 'child' nodes in the next\n *            level down in the hierarchy.\n *\n * @param {Number} startChildNdx - The index to start the 'next' page loading at.\n *\n * @param {Number} pageSize - (Optional) The maximum # of 'child' nodes to return in any single paged access\n *            (Default: See _defaultPageSize).\n *\n * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n *            'cursorNodeId' (Default: TRUE)\n *\n * @param {Boolean} skipFocusOccCheck - (Optional) TRUE if you do not want focus passed. (Default: FALSE)\n *\n * @param {String} filter - (Optional) Filter string.\n *\n * @return {ListLoadInput} Newly created wrapper initialized with properties from the given inputs.\n */export let createListLoadInput=function(parentUid,startChildNdx,pageSize,addAfter,skipFocusOccCheck,filter){return new ListLoadInput(parentUid,startChildNdx,pageSize,addAfter,filter);};/**\n * @param {ViewModelObject} parentNode - The 'parent' ViewModelObject used to access any 'child' nodes in the\n *            next level down in the hierarchy.\n *\n * @param {ViewModelObjectArray} childNodes - Array of 'child' nodes resulting from a single load execution in\n *            the context of a 'parent' node (i.e. 'children' in the next level down in the hierarchy).\n *\n * @param {Number} totalChildCount - The total # of known 'child' nodes regardless of how many are currently\n *            loaded into the 'parent' 'children' array.\n *\n * @param {Number} startChildNdx - The 'childNdx' provided in the ListLoadInput that was used to load this data.\n *            This is returned as part of the result to handle cases when multiple loads are being performed on\n *            the same 'parent' and the original closure data could have changed during the async processing.\n *\n * @param {ViewModelObject} newTopNode - (Optional) If this property is defined, it will be used to replace the\n *            (unseen) 'top' node associated with the overall list.\n *            <P>\n *            Note: If 'children' array of this node is not empty it will be ignored and the 'childNodes' of\n *            this result will be set as the 1st level children of this 'parent' node.\n *\n * @return {ListLoadResult} Newly created wrapper initialized with properties from the given inputs.\n */export let createListLoadResult=function(parentNode,childNodes,totalChildCount,startChildNdx,newTopNode){return new ListLoadResult(parentNode,childNodes,totalChildCount,startChildNdx,newTopNode);};/**\n * @param {TreeNodeInput} treeLoadInput - The input to a 'getTreeNodePage' operation that specified which\n *            'child' nodes to load dynamically.\n * @param {TreeNodeResult} treeLoadResult - The result of a 'getTreeNodePage' operation that resulted in\n *            ViewModelTreeNodes who's ViewModelProperties need to be loaded dynamically.\n * @param {AwTableColumnInfoArray} columnInfos - Array of AwTableColumnInfo containing property names to\n *            request.\n *\n * @return {PropertyLoadInput} Newly created wrapper initialized with properties from the given inputs.\n */export let createPropertyLoadRequest=function(treeLoadInput,treeLoadResult,columnInfos){return new PropertyLoadRequest(treeLoadInput.parentNode,treeLoadResult.childNodes,columnInfos);};/**\n * @param {ViewModelTreeNodeArray} owningNodes - Array of nodes to load ViewModelProperty objects for.\n * @param {StringArray} propertyNames - Array property names to request.\n *\n * @return {PropertyLoadInput} Newly created wrapper initialized with properties from the given inputs.\n */export let createPropertyLoadInput=function(owningNodes,propertyNames){return new PropertyLoadInput(owningNodes,propertyNames);};/**\n * @param {ViewModelTreeNodeArray} childNodes - Array of nodes who's ViewModelProperties have been\n *           loaded/updated.\n *\n * @return {PropertyLoadResult} Newly created wrapper initialized with properties from the given inputs.\n */export let createPropertyLoadResult=function(childNodes){return new PropertyLoadResult(childNodes);};/**\n * @param {Number} totalFound - Total # of rows in the overall table.\n *\n * @return {TableLoadResult} Newly created wrapper initialized with properties from the given inputs.\n */export let createTableLoadResult=function(totalFound){return new TableLoadResult(totalFound);};/**\n * @param {ViewModelTreeNode} parentNode - The 'parent' ViewModelTreeNode used to access any 'child' nodes in\n *            the next level down in the hierarchy.\n *\n * @param {Number} startChildNdx - The 'childNdx' to start the 'next' page loading at.\n *\n * @param {String} startChildId - (Optional) The 'id' of the node to start the 'next' page loading at.\n *\n * @param {String} cursorNodeId - (Optional) ID of an existing node in the 'parent' (and, presumably a\n *            ViewModelCollection) to insert any new nodes after (or before) depending on value of 'addAfter'.\n *\n * @param {Number} pageSize - (Optional) The maximum # of 'child' nodes to return in any single paged access\n *            (Default: See _defaultPageSize).\n *\n * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n *            'cursorNodeId' (Default: TRUE)\n * @param {ViewModelTreeNode} rootNode - The 'root' ViewModelTreeNode used to access any 'child' nodes in the\n *            next level down in the hierarchy.\n *\n * @return {TreeLoadInput} Newly created wrapper initialized with properties from the given inputs.\n */export let createTreeLoadInput=function(parentNode,startChildNdx,startChildId,cursorNodeId,pageSize,addAfter,rootNode){return new TreeLoadInput(parentNode,startChildNdx,startChildId,cursorNodeId,pageSize,addAfter,rootNode);};/**\n * @param {ViewModelTreeNode} parentNode - The 'parent' ViewModelTreeNode used to access any 'child' nodes in\n *            the next level down in the hierarchy.\n *\n * @param {ViewModelTreeNodeArray} childNodes - Array of 'child' ViewModelTreeNode objects resulting from a\n *            single load execution in the context of a 'parent' node (i.e. 'children' in the next level down in\n *            the hierarchy).\n *\n * @param {Number} totalChildCount - The total # of known 'child' nodes regardless of how many are currently\n *            loaded into the 'parent' 'children' array.\n *\n * @param {Number} startChildNdx - The 'childNdx' provided in the TreeLoadInput that was used to load this data.\n *            This is returned as part of the result to handle cases when multiple loads are being performed on\n *            the same 'parent' and the original closure data could have changed during the async processing.\n *\n * @param {String} cursorNodeId - (Optional) ID of an existing node in the 'parent' (and, presumably a\n *            ViewModelCollection) to insert any new nodes after (or before) depending on value of 'addAfter'.\n *\n * @param {Number} newTopNode - (Optional) The node to be considered the new top-most 'parent' node as a result\n *            of this loading operation.\n *            <P>\n *            Note: Often this will be an 'occurrence' object of the underlying 'productModelObject'.\n *\n * @return {TreeLoadResult} Newly created wrapper initialized with properties from the given inputs.\n */export let createTreeLoadResult=function(parentNode,childNodes,totalChildCount,startChildNdx,cursorNodeId,newTopNode){return new TreeLoadResult(parentNode,childNodes,totalChildCount,startChildNdx,cursorNodeId,newTopNode);};/**\n * @param {String} nodeId - Unique ID for this node within the tree-table. 'DocumentRevision', etc.).\n * @param {String} type - The type of model object represented by this tree node (i.e. 'Item'\n * @param {String} displayName - The name to display in the 'navigation' column of the tree-table.\n * @param {Number} levelNdx - The # of levels down from the 'root' of the tree-table.\n * @param {Number} childNdx - The index to this 'child' within the immediate 'parent'. This information is meant\n *            to help in when only a partial (or sparse) range of children have been loaded. This index is\n *            stable within the 'parent' and not representative of the order based on the 'id'.\n * @param {String} iconURL - The URL to the icon associated with the display of this node in the 'navigation'\n *            column of the tree-table.\n * @param {String} svgString - The String svg icon associated with the display of this node in the 'navigation'\n *            column of the tree-table.\n *\n * @return {ViewModelTreeNode} Newly created wrapper initialized with properties from the given inputs.\n */export let createViewModelTreeNode=function(nodeId,type,displayName,levelNdx,childNdx,iconURL,svgString){return new ViewModelTreeNode(nodeId,type,displayName,levelNdx,childNdx,iconURL,svgString);};/**\n * Returns a class that is the overall model used to control the contents and behavior of the 'aw-table'\n * directive. This model allows for functional pieces to be overridden and implemented in application specific\n * ways. Defaults are specified here.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' containing properties to base the new\n *            'awTableViewModel' upon.\n * @param {String} gridId - ID of the {declGrid} the new model will wrap.\n * @param {Object} $scope - the scope object\n *\n * @returns {AwTableViewModel} New instance of this class.\n */export let createViewModel=function(declViewModel,gridId,$scope){return new AwTableViewModel(declViewModel,gridId,$scope);};/**\n * Centralized handling of the 'start' phase of editing a cell in the table. This function is invoked by the\n * 'aw-table-cell' directive's controller.\n *\n * @param {Object} $scope - The AngularJS scope of the controller.\n * @param {Element} $element - The DOM Element the controller is attached to.\n * @param {ClickEvent} event - The ClickEvent on the cell where the editing is to take place.\n */export let handleCellStartEdit=function($scope,$element,event){if($scope.prop&&$scope.prop.isEditable&&!$scope.prop.isEditing){// stop propagation to avoid firing the stopEdit event we are about to attach\nevent.stopPropagation();// trigger any existing stopEdit event in case another cell is in edit mode\n$('body').triggerHandler('click');$scope.prop.autofocus=true;$scope.prop.isEditing=true;$scope._bodyClickListener=function(event2){exports.handleCellStopEdit($scope,$element,event2);};// click outside stops the edit\n$('body').on('click touchstart',$scope._bodyClickListener);/**\n         * Apply editing class on the parent row so CSS can increase the height\n         * <P>\n         * Would be better to set this on the row scope and let the row template style the DOM but 'ui-grid'\n         * doesn't seem to make that part of the template easily customizable.\n         */var gridElem=$element.closest('.aw-jswidgets-grid');if(gridElem){var gridScope=gridElem.scope();if(gridScope&&gridScope.findCellRowElement){var rowElem=gridScope.findCellRowElement($element);if(rowElem){rowElem.addClass('aw-jswidgets-isEditing-row');}}}/**\n         * Add tabIndex so that it can be used by the control being opened for edit. Otherwise, that control is\n         * opened with the default tab index and tabbing does not move to the next control.\n         */$scope.prop.tabIndex=event.currentTarget.tabIndex;/**\n         * Set the cellTop element tab index to -1 so that backtab moves to the correct cell\n         */if($scope.prop.type!=='DATE'&&$scope.prop.type!=='DATEARRAY'){event.currentTarget.tabIndex=-1;}}};/**\n * Centralized handling of the 'end' phase of editing a cell in the table. This function is invoked by the\n * 'aw-table-cell' directive's controller.\n *\n * @param {Object} $scope - The AngularJS scope of the controller.\n * @param {Element} $element - The DOM Element the controller is attached to.\n * @param {ClickEvent} event - The ClickEvent on some other element indicating editing is to stop.\n */export let handleCellStopEdit=function($scope,$element,event){/**\n     * Ignore clicks in the date picker header and ckeditor toolbar.\n     * <P>\n     * Note: Can't reference with the standard datepicker id (#ui-datepicker-div) as the element has been\n     * detached at this point (month change destroys original div)\n     * <P>\n     * Could be better to flip and ensure target has \"#main-view\" parent, but that would tie to tc.html\n     */var target=$(event.target);if(target.parents('.ui-datepicker-header').length===0&&target.closest('.cke').length===0){var cell=target.closest('.aw-jswidgets-cellTop');if(cell.length===0||!cell.scope()||!cell.scope().prop||!cell.scope().prop.isEditing){/**\n             * For non-LOV object reference property stay on edit widget until object Reference panel is active\n             */if($scope.prop.type==='OBJECT'&&!$scope.prop.hasLov){if($scope.referencePanelLoaded){return;}}$scope.$evalAsync(function(){$scope.prop.isEditing=false;/**\n                 * Set or unset dirty state based on current value\n                 */var prevDisplayValues=$scope.prop.prevDisplayValues;$scope.prop.dirty=prevDisplayValues&&prevDisplayValues.length>0&&!_.isEqual(prevDisplayValues[0],$scope.prop.uiValue);});var gridElem=$element.closest('.aw-jswidgets-grid');if(gridElem){var gridScope=gridElem.scope();if(gridScope&&gridScope.findCellRowElement){var rowElem=gridScope.findCellRowElement($element);if(rowElem){rowElem.removeClass('aw-jswidgets-isEditing-row');}}}$('body').off('click touchstart',$scope._bodyClickListener);delete $scope._bodyClickListener;/**\n             * Reset the cellTop element tab index\n             */var $cellTop=$element.find('.aw-jswidgets-cellTop');if($cellTop&&$scope.prop){$cellTop.prop('tabindex',$scope.prop.tabIndex);}}}};/**\n * Test if the given object 'is-a' ListLoadInput created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a ListLoadInput.\n */export let isListLoadInput=function(objectToTest){return objectToTest instanceof ListLoadInput;};/**\n * Test if the given object 'is-a' TreeLoadInput created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a TreeLoadInput.\n */export let isTreeLoadInput=function(objectToTest){return objectToTest instanceof TreeLoadInput;};/**\n * Test if the given object 'is-a' ViewModelTreeNode created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a ViewModelTreeNode.\n */export let isViewModelTreeNode=function(objectToTest){return objectToTest instanceof ViewModelTreeNode;};/**\n * Test if the given object 'is-a' PropertyLoadInput created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a PropertyLoadInput.\n */export let isPropertyLoadInput=function(objectToTest){return objectToTest instanceof PropertyLoadInput;};/**\n * Resolve the row data for the 'next' page of 'children' nodes of the given 'parent'.\n * <P>\n * Note: The paging status is maintained in the 'parent' node.\n *\n * @param {TreeLoadInput} treeLoadInput - The original input to the load operation.\n *\n * @param {ViewModelTreeNodeArray} childNodesIn - The 'child' nodes just loaded.\n *\n * @param {Boolean} simplePage - TRUE if the 'childNodesIn' represents a 'page' (and NOT an array of all 'child'\n *            nodes). If TRUE, the nodes will be simply passed along as the result. If FALSE, the page of\n *            children will be extracted from this array.\n *\n * @param {Boolean} startReached - TRUE if the first page of the results has been reached.\n *\n * @param {Boolean} endReached - TRUE if the last page of the results has been reached.\n *\n * @param {ViewModelTreeNode} newTopNode - (Optional) The node to be considered the new top-most 'parent' node\n *            as a result of this loading operation.\n *\n * @return {TreeLoadResult} A new TreeLoadResult object containing result/status information.\n */export let buildTreeLoadResult=function(treeLoadInput,childNodesIn,simplePage,startReached,endReached,newTopNode){var parentNode=newTopNode?newTopNode:treeLoadInput.parentNode;var currentChildCount=parentNode.children?parentNode.children.length:0;if(simplePage){/**\n         * Determine if we already know how many 'child' nodes this 'parent' has OR we need to compute it now.\n         * <P>\n         * Assume we do not know a 'total' for the 'parent' and simply add these 'child' nodes to the total.\n         */var totalChildCount;if(_.isEmpty(childNodesIn)){totalChildCount=currentChildCount;}else{totalChildCount=currentChildCount+childNodesIn.length;/**\n             * Get the 'head' and 'tail' from the collection of new 'child' nodes.\n             */var headChild=_.head(childNodesIn);var lastChild=_.last(childNodesIn);/**\n             * Check if the 'tail' is known to NOT be the last 'child' of this 'parent'.<br>\n             * If so: Mark that 'child' as an 'incompleteTail' so we know to ask for more below it later.\n             */if(!declUtils.isNil(endReached)){if(!endReached){lastChild.incompleteTail=true;totalChildCount++;}}else if(lastChild.childNdx+1<totalChildCount){lastChild.incompleteTail=true;}/**\n             * Check if we are adding the 1st set of 'child' nodes to this 'parent' and the 'head' one is NOT\n             * the actual 1st child of that 'parent'<BR>\n             * If so: Mark that 'child' as an 'incompleteHead' so we know to ask for more above it later.\n             */if(!declUtils.isNil(startReached)){if(!startReached){headChild.incompleteHead=true;}}else if(currentChildCount===0&&headChild&&headChild.childNdx>0){headChild.incompleteHead=true;}}/**\n         * Create the final data object returned to the dataProvider.\n         */return exports.createTreeLoadResult(treeLoadInput.parentNode,childNodesIn,totalChildCount,treeLoadInput.startChildNdx,treeLoadInput.cursorNodeId,newTopNode);}/**\n     * Check for trival 'no child' case.\n     */if(_.isEmpty(childNodesIn)){return exports.createTreeLoadResult(parentNode,[],currentChildCount,treeLoadInput.startChildNdx,treeLoadInput.cursorNodeId,newTopNode);}/**\n     * Determine starting/stop row range to resolve\n     */var pageSize=treeLoadInput.pageSize;var begNdx=treeLoadInput.startChildNdx;if(begNdx>=childNodesIn.length){return exports.createTreeLoadResult(parentNode,[],childNodesIn.length,treeLoadInput.startChildNdx,treeLoadInput.cursorNodeId,newTopNode);}var endNdx=begNdx+pageSize;if(endNdx>childNodesIn.length){endNdx=childNodesIn.length;}var childNodes=childNodesIn.slice(begNdx,endNdx);if(endNdx<childNodesIn.length){_.last(childNodes).incompleteTail=true;}/**\n     * Resolve the async request.\n     */return exports.createTreeLoadResult(parentNode,childNodes,childNodesIn.length,treeLoadInput.startChildNdx,treeLoadInput.cursorNodeId,newTopNode);};/**\n * Check if the given TreeLoadInput is valid.\n *\n * @param {TreeLoadInput} treeLoadInput - Object to validate.\n *\n * @return {String} The text of a failure message (or NULL if input is valid).\n */export let validateTreeLoadInput=function(treeLoadInput){if(!treeLoadInput){return'No TreeLoadInput specified';}else if(!treeLoadInput.parentNode||treeLoadInput.startChildNdx<0||treeLoadInput.pageSize<=0){return'Invalid TreeLoadInput specified';}return undefined;};/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {Object} ListLoadInput from the given arguments (or undefined if not found)\n */export let findListLoadInput=function(argsIn){for(var ndx=0;ndx<argsIn.length;ndx++){var arg=argsIn[ndx];if(exports.isListLoadInput(arg)){return arg;}}return undefined;};/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {Object} PropertyLoadInput from the given arguments (or undefined if not found)\n */export let findPropertyLoadInput=function(argsIn){var input;for(var ndx=0;ndx<argsIn.length;ndx++){var arg=argsIn[ndx];if(exports.isPropertyLoadInput(arg)){input=arg;}else if(arg&&arg.hasOwnProperty('clientName')&&arg.hasOwnProperty('clientScopeURI')&&input){// add input context from v-m\ninput.propertyLoadContext=arg;}}return input;};/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {Object} TreeLoadInput from the given arguments (or undefined if not found)\n */export let findTreeLoadInput=function(argsIn){for(var ndx=0;ndx<argsIn.length;ndx++){var arg=argsIn[ndx];if(exports.isTreeLoadInput(arg)){return arg;}}return undefined;};exports={createListLoadInput,createListLoadResult,createPropertyLoadRequest,createPropertyLoadInput,createPropertyLoadResult,createTableLoadResult,createTreeLoadInput,createTreeLoadResult,createViewModelTreeNode,createViewModel,handleCellStartEdit,handleCellStopEdit,isListLoadInput,isTreeLoadInput,isViewModelTreeNode,isPropertyLoadInput,buildTreeLoadResult,validateTreeLoadInput,findListLoadInput,findPropertyLoadInput,findTreeLoadInput};export default exports;","map":null,"metadata":{},"sourceType":"module"}