{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/* eslint-disable complexity */\n\n/**\n * @module js/propValidationUtils\n */\nimport * as Yup from 'yup';\nimport _ from 'lodash';\nimport declUtils, { isNil } from 'js/declUtils';\nimport { isViewModelObject } from 'js/viewModelObjectService';\nimport { isViewModelProperty, isArrayOfViewModelProperty } from 'js/uwPropertyService';\nimport { getRealExpression, evaluateCondition } from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport localeSvc from 'js/localeService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport { isMatch } from 'date-fns';\n\nconst mapArrayOfVMPForValidation = (parKey, objectArray) => {\n  let collection = [];\n  objectArray.forEach((value, key) => {\n    collection[parKey + '_' + key] = value;\n  });\n  return collection;\n};\n/**\n *  This method would filter out \"ViewModelProperties\" from data section.\n *  It would only look at first level and try to figure out all the VMP's inside it.\n *  If in a data-structure VMP's are underneath few level, use Atomic data.\n * @param {*} data -\n * @returns {object } -\n */\n\n\nexport const filterFlatViewModelProps = data => {\n  // Below code would filter out the data and extract all the viewModel properties.\n  // It considers all the static and dynamic properties (inside vmo)\n  if (!isNil(data) && !_.isEmpty(data)) {\n    return Object.keys(data).map(key => {\n      let object = data[key];\n\n      if (!_.isEmpty(object)) {\n        // if the VMO is part of an object, then the validation is getting skipped.\n        if (key === 'objects') {\n          let objKey = Object.keys(object)[0];\n          object = object[objKey];\n        }\n\n        if (isViewModelObject(object)) {\n          return object.props;\n        } else if (isViewModelProperty(object)) {\n          return {\n            [key]: object\n          };\n        } else if (_.isArray(object) && isArrayOfViewModelProperty(object)) {\n          return { ...mapArrayOfVMPForValidation(key, object)\n          };\n        }\n      }\n\n      return undefined;\n    }).filter(props => {\n      return props !== null && props !== undefined;\n    }).reduce((acc, current) => {\n      return Object.assign(acc, current);\n    }, {});\n  }\n\n  return {};\n};\n\nconst getAtomicDataPath = function (metaObj, rootPath) {\n  let fieldsPath = [];\n\n  function parsePath(propName, basePath) {\n    let path;\n\n    if (basePath) {\n      path = Number.isInteger(propName) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n    } else {\n      path = propName;\n    }\n\n    return path;\n  }\n\n  function parseMetaForFieldsPath(currentMetaObj) {\n    let basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _.forEach(currentMetaObj, function processMeta(propValue, propName) {\n      if (propName === 'field' || propName === 'type') {\n        return undefined;\n      }\n\n      let path = parsePath(propName, basePath);\n      fieldsPath.push(`${rootPath}.${path}`);\n\n      if (_.isObject(propValue)) {\n        parseMetaForFieldsPath(propValue, path);\n      }\n\n      return undefined;\n    });\n  }\n\n  parseMetaForFieldsPath(metaObj);\n  return fieldsPath;\n};\n\nexport const filterFlatViewModelPropForAtomic = viewModel => {\n  let vmColl = {};\n\n  if (!isNil(viewModel.atomicDataRef) && !_.isEmpty(viewModel.atomicDataRef)) {\n    Object.keys(viewModel.atomicDataRef).forEach(stateName => {\n      let stateObject = viewModel.atomicDataRef[stateName].getAtomicData();\n      let metaObject = viewModel && viewModel.declViewModelJson.data[stateName] && viewModel.declViewModelJson.data[stateName].meta;\n\n      if (metaObject) {\n        let filePath = getAtomicDataPath(metaObject, stateName);\n        let tempStateObject = {\n          [stateName]: stateObject\n        };\n        filePath.forEach((pathkey, index) => {\n          let val = _.get(tempStateObject, pathkey);\n\n          if (!isNil(val) && !_.isEmpty(val)) {\n            if (isViewModelObject(val)) {\n              extractAtomicVMO();\n            } else if (isViewModelProperty(val)) {\n              vmColl[pathkey.replace(/\\./g, '_')] = val;\n            } else if (_.isArray(val) && isArrayOfViewModelProperty(val)) {\n              extractAtomicListVMP();\n            } else if (_.isArray(val)) {\n              extractAtomicListVMo();\n            }\n          }\n\n          function extractAtomicListVMo() {\n            val.forEach((arrpathkey, kindex) => {\n              if (isViewModelObject(val[kindex])) {\n                _.forOwn(val[kindex].props, function (propValue, propName) {\n                  let path = pathkey + '.' + kindex + '.props.' + propName;\n                  vmColl[path.replace(/\\./g, '_')] = propValue;\n                });\n              }\n            });\n          }\n\n          function extractAtomicListVMP() {\n            val.forEach((arrpathkey, kindex) => {\n              let path = pathkey + '.' + kindex;\n              vmColl[path.replace(/\\./g, '_')] = val[kindex];\n            });\n          }\n\n          function extractAtomicVMO() {\n            _.forOwn(val.props, function (propValue, propName) {\n              let path = pathkey + '.props.' + propName;\n              vmColl[path.replace(/\\./g, '_')] = propValue;\n            });\n          }\n        });\n      }\n    });\n  }\n\n  return vmColl;\n};\nexport const getStateCollection = viewModel => {\n  return { ...filterFlatViewModelProps(viewModel.getData()),\n    ...filterFlatViewModelPropForAtomic(viewModel)\n  };\n};\nexport const updateValidationSchema = (viewModel, vmpCollRef, vmpValidationSchema, getProps, vmPropCollection) => {\n  let schemaForValidate = {};\n  let oldVmPropCollection = vmpCollRef.current ? vmpCollRef.current.vmprop : null;\n\n  if (!_.isNil(oldVmPropCollection) && !_.isNil(vmPropCollection)) {\n    let registeredPropNames = Object.keys(oldVmPropCollection);\n    Object.keys(vmPropCollection).forEach(key => {\n      if (!registeredPropNames.includes(key) || oldVmPropCollection[key] && vmPropCollection[key] && oldVmPropCollection[key].isRequired !== vmPropCollection[key].isRequired) {\n        schemaForValidate[key] = vmPropCollection[key];\n      }\n    });\n  } else {\n    schemaForValidate = vmPropCollection;\n  }\n\n  vmpCollRef.current = {\n    vmprop: vmPropCollection,\n    vmModel: viewModel\n  };\n\n  if (!isNil(schemaForValidate) && !_.isEmpty(schemaForValidate)) {\n    const {\n      validationSchemaDef\n    } = getValidationSchema(schemaForValidate, vmpCollRef, getProps);\n    let clubSchema = {};\n    let exitingSchema = vmpValidationSchema.current ? vmpValidationSchema.current.exitingSchema : {};\n    Object.assign(clubSchema, exitingSchema, validationSchemaDef);\n\n    let _validationSchema = Yup.object().shape(clubSchema);\n\n    vmpValidationSchema.current = {\n      exitingSchema: clubSchema,\n      validationSchema: _validationSchema\n    };\n  }\n};\n\nconst isDatetimeValueInvalid = (dateApiObj, dateOrTimeType) => {\n  let timeVal = dateApiObj.timeValue ? dateTimeSvc.getNormalizedTimeValue(dateApiObj.timeValue) : null;\n  let dateVal = dateApiObj.dateValue ? dateApiObj.dateValue.split(' ')[0] : null;\n\n  switch (dateOrTimeType) {\n    case 'DATE':\n      if (dateVal && !isMatch(dateVal, dateTimeSvc.getDateFilterFormat())) {\n        return true;\n      }\n\n      break;\n\n    case 'TIME':\n      if (timeVal && !isMatch(timeVal, dateTimeSvc.getTimeFilterFormat())) {\n        return true;\n      }\n\n      break;\n\n    default:\n      return false;\n  }\n\n  return false;\n};\n\nconst validateDateTime = function () {\n  let dateApiObj = this.options.parent.dateApi;\n\n  if (isDatetimeValueInvalid(dateApiObj, 'DATE')) {\n    return this.createError({\n      message: localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()])\n    });\n  }\n\n  if (isDatetimeValueInvalid(dateApiObj, 'TIME')) {\n    return this.createError({\n      message: localeSvc.getMessage('INVALID_TIME', [dateTimeSvc.getTimeFormatPlaceholder()])\n    });\n  }\n\n  return true;\n};\n\nconst getValidationSchema = function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let vmpCollRef = arguments.length > 1 ? arguments[1] : undefined;\n  let getProps = arguments.length > 2 ? arguments[2] : undefined;\n  let schemaInput = {};\n\n  for (let [key, value] of Object.entries(props)) {\n    if (value) {\n      // build the yup propSchema for checking dbValue\n      let dbValue;\n      let type = value.type || 'none';\n\n      switch (type.toUpperCase()) {\n        case 'DATE':\n          dbValue = Yup.string().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).test('date-validation', 'invalid date', validateDateTime).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()]);\n          });\n          break;\n\n        case 'DATEARRAY':\n          dbValue = Yup.string().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).test('date-array-validation', 'invalid date', validateDateTime).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()]);\n          });\n          break;\n\n        case 'INTEGER':\n          dbValue = Yup.number().nullable().min(-2147483648, 'Out of range').max(2147483647, 'Out of range').transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).typeError(obj => {\n            return localeSvc.getMessage('INVALID_INTEGER', [obj.originalValue]);\n          });\n          break;\n\n        case 'INTEGERARRAY':\n          dbValue = Yup.array().of(Yup.number().nullable().min(-2147483648, 'Out of range').max(2147483647, 'Out of range').transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value)).typeError(obj => {\n            return localeSvc.getMessage('INVALID_INTEGER', [obj.originalValue]);\n          });\n          break;\n\n        case 'DOUBLE':\n          dbValue = Yup.number().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DOUBLE', [obj.originalValue]);\n          });\n          break;\n\n        case 'DOUBLEARRAY':\n          dbValue = Yup.array().of(Yup.number().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value)).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DOUBLE', [obj.originalValue]);\n          });\n          break;\n\n        case 'BOOLEAN':\n          dbValue = Yup.boolean().nullable();\n          break;\n\n        default:\n          dbValue = Yup.string().nullable();\n      }\n\n      if (value.isRequired || value.isRequired === 'true') {\n        dbValue = dbValue.required(() => {\n          return localeSvc.getMessage('PROP_REQUIRED_ERROR');\n        });\n      }\n\n      if (value.validationCriteria) {\n        for (let criteria in value.validationCriteria) {\n          dbValue = dbValue.test(value.validationCriteria[criteria].condition, value.validationCriteria[criteria].value, function () {\n            let conditionObj = value.validationCriteria[criteria].condition;\n            let viewModel = vmpCollRef.current.vmModel;\n            viewModel.data = viewModel.getData();\n            let evalContext = {\n              viewModel,\n              props: getProps,\n              ctx: appCtxSvc.ctx\n            };\n            let expression = getRealExpression(conditionObj, viewModel.declViewModelJson); // eslint-disable-next-line no-invalid-this\n\n            return evaluateCondition(viewModel, expression, evalContext) ? this.createError({\n              message: viewModel.data[key].validationCriteria[criteria].value,\n              path: key\n            }) : true;\n          });\n        }\n      }\n\n      let valueToTestSchema = dbValue.test('propertyError', 'Error', function () {\n        // eslint-disable-next-line no-invalid-this\n        let context = this;\n        let hasError = declUtils.isNil(context.parent.error) || context.parent.error.trim() === '';\n        return !hasError ? context.createError({\n          message: context.parent.error,\n          path: key\n        }) : true;\n      });\n\n      if (['DATETIME', 'DATEARRAY', 'DATE'].includes(type.toUpperCase())) {\n        schemaInput[key] = Yup.object().shape({\n          uiValue: valueToTestSchema\n        });\n      } else {\n        schemaInput[key] = Yup.object().shape({\n          dbValue: valueToTestSchema\n        });\n      }\n    }\n  }\n\n  return {\n    validationSchemaDef: schemaInput\n  };\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/propValidationUtils.js"],"names":["mapArrayOfVMPForValidation","collection","objectArray","parKey","filterFlatViewModelProps","data","isNil","_","key","object","objKey","Object","isViewModelObject","isViewModelProperty","isArrayOfViewModelProperty","props","getAtomicDataPath","fieldsPath","path","Number","basePath","propName","parsePath","rootPath","parseMetaForFieldsPath","filterFlatViewModelPropForAtomic","viewModel","vmColl","stateName","stateObject","metaObject","filePath","tempStateObject","val","extractAtomicVMO","pathkey","extractAtomicListVMP","extractAtomicListVMo","getStateCollection","updateValidationSchema","schemaForValidate","oldVmPropCollection","vmpCollRef","registeredPropNames","vmPropCollection","vmprop","vmModel","validationSchemaDef","getValidationSchema","clubSchema","exitingSchema","vmpValidationSchema","_validationSchema","Yup","validationSchema","isDatetimeValueInvalid","timeVal","dateApiObj","dateTimeSvc","dateVal","isMatch","validateDateTime","message","localeSvc","getProps","schemaInput","type","value","dbValue","originalValue","obj","conditionObj","evalContext","ctx","appCtxSvc","expression","getRealExpression","valueToTestSchema","context","hasError","declUtils","uiValue"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n/* eslint-disable complexity */\n\n/**\n * @module js/propValidationUtils\n */\nimport * as Yup from 'yup';\nimport _ from 'lodash';\nimport declUtils, { isNil } from 'js/declUtils';\nimport { isViewModelObject } from 'js/viewModelObjectService';\nimport { isViewModelProperty, isArrayOfViewModelProperty } from 'js/uwPropertyService';\nimport { getRealExpression, evaluateCondition } from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport localeSvc from 'js/localeService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport { isMatch } from 'date-fns';\n\nconst mapArrayOfVMPForValidation = ( parKey, objectArray ) => {\n    let collection = [];\n    objectArray.forEach( ( value, key ) => {\n        collection[ parKey + '_' + key ] = value;\n    } );\n    return collection;\n};\n/**\n *  This method would filter out \"ViewModelProperties\" from data section.\n *  It would only look at first level and try to figure out all the VMP's inside it.\n *  If in a data-structure VMP's are underneath few level, use Atomic data.\n * @param {*} data -\n * @returns {object } -\n */\nexport const filterFlatViewModelProps = ( data ) => {\n    // Below code would filter out the data and extract all the viewModel properties.\n    // It considers all the static and dynamic properties (inside vmo)\n    if( !isNil( data ) && !_.isEmpty( data ) ) {\n        return Object.keys( data ).map( ( key ) => {\n            let object = data[ key ];\n\n            if( !_.isEmpty( object ) ) {\n                // if the VMO is part of an object, then the validation is getting skipped.\n                if( key === 'objects' ) {\n                    let objKey = Object.keys( object )[ 0 ];\n                    object = object[ objKey ];\n                }\n                if( isViewModelObject( object ) ) {\n                    return object.props;\n                } else if( isViewModelProperty( object ) ) {\n                    return {\n                        [ key ]: object\n                    };\n                } else if( _.isArray( object ) && isArrayOfViewModelProperty( object ) ) {\n                    return {\n                        ...mapArrayOfVMPForValidation( key, object )\n                    };\n                }\n            }\n            return undefined;\n        } ).filter( ( props ) => {\n            return props !== null && props !== undefined;\n        } ).reduce( ( acc, current ) => {\n            return Object.assign( acc, current );\n        }, {} );\n    }\n    return {};\n};\n\nconst getAtomicDataPath = function( metaObj, rootPath ) {\n    let fieldsPath = [];\n\n    function parsePath( propName, basePath ) {\n        let path;\n        if( basePath ) {\n            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n        } else {\n            path = propName;\n        }\n        return path;\n    }\n\n    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {\n        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {\n            if( propName === 'field' || propName === 'type' ) {\n                return undefined;\n            }\n            let path = parsePath( propName, basePath );\n            fieldsPath.push( `${rootPath}.${path}` );\n            if( _.isObject( propValue ) ) {\n                parseMetaForFieldsPath( propValue, path );\n            }\n            return undefined;\n        } );\n    }\n\n    parseMetaForFieldsPath( metaObj );\n\n    return fieldsPath;\n};\n\nexport const filterFlatViewModelPropForAtomic = ( viewModel ) => {\n    let vmColl = {};\n    if( !isNil( viewModel.atomicDataRef ) && !_.isEmpty( viewModel.atomicDataRef ) ) {\n        Object.keys( viewModel.atomicDataRef ).forEach( ( stateName ) => {\n            let stateObject = viewModel.atomicDataRef[ stateName ].getAtomicData();\n            let metaObject = viewModel && viewModel.declViewModelJson.data[ stateName ] &&\n                viewModel.declViewModelJson.data[ stateName ].meta;\n            if( metaObject ) {\n                let filePath = getAtomicDataPath( metaObject, stateName );\n                let tempStateObject = {\n                    [ stateName ]: stateObject\n                };\n                filePath.forEach( ( pathkey, index ) => {\n                    let val = _.get( tempStateObject, pathkey );\n                    if( !isNil( val ) && !_.isEmpty( val ) ) {\n                        if( isViewModelObject( val ) ) {\n                            extractAtomicVMO();\n                        } else if( isViewModelProperty( val ) ) {\n                            vmColl[ pathkey.replace( /\\./g, '_' ) ] = val;\n                        } else if( _.isArray( val ) && isArrayOfViewModelProperty( val ) ) {\n                            extractAtomicListVMP();\n                        } else if( _.isArray( val ) ) {\n                            extractAtomicListVMo();\n                        }\n                    }\n\n                    function extractAtomicListVMo() {\n                        val.forEach( ( arrpathkey, kindex ) => {\n                            if( isViewModelObject( val[ kindex ] ) ) {\n                                _.forOwn( val[ kindex ].props, function( propValue, propName ) {\n                                    let path = pathkey + '.' + kindex + '.props.' + propName;\n                                    vmColl[ path.replace( /\\./g, '_' ) ] = propValue;\n                                } );\n                            }\n                        } );\n                    }\n\n                    function extractAtomicListVMP() {\n                        val.forEach( ( arrpathkey, kindex ) => {\n                            let path = pathkey + '.' + kindex;\n                            vmColl[ path.replace( /\\./g, '_' ) ] = val[ kindex ];\n                        } );\n                    }\n\n                    function extractAtomicVMO() {\n                        _.forOwn( val.props, function( propValue, propName ) {\n                            let path = pathkey + '.props.' + propName;\n                            vmColl[ path.replace( /\\./g, '_' ) ] = propValue;\n                        } );\n                    }\n                } );\n            }\n        } );\n    }\n    return vmColl;\n};\n\nexport const getStateCollection = ( viewModel ) => {\n    return {\n        ...filterFlatViewModelProps( viewModel.getData() ),\n        ...filterFlatViewModelPropForAtomic( viewModel )\n    };\n};\n\nexport const updateValidationSchema = ( viewModel, vmpCollRef, vmpValidationSchema, getProps, vmPropCollection ) => {\n    let schemaForValidate = {};\n    let oldVmPropCollection = vmpCollRef.current ? vmpCollRef.current.vmprop : null;\n    if( !_.isNil( oldVmPropCollection ) && !_.isNil( vmPropCollection ) ) {\n        let registeredPropNames = Object.keys( oldVmPropCollection );\n        Object.keys( vmPropCollection ).forEach( ( key ) => {\n            if( !registeredPropNames.includes( key ) || oldVmPropCollection[ key ] && vmPropCollection[ key ] && oldVmPropCollection[ key ].isRequired !== vmPropCollection[ key ].isRequired ) {\n                schemaForValidate[ key ] = vmPropCollection[ key ];\n            }\n        } );\n    } else {\n        schemaForValidate = vmPropCollection;\n    }\n    vmpCollRef.current = { vmprop: vmPropCollection, vmModel: viewModel };\n    if( !isNil( schemaForValidate ) && !_.isEmpty( schemaForValidate ) ) {\n        const { validationSchemaDef } = getValidationSchema( schemaForValidate, vmpCollRef, getProps );\n        let clubSchema = {};\n        let exitingSchema = vmpValidationSchema.current ? vmpValidationSchema.current.exitingSchema : {};\n        Object.assign( clubSchema, exitingSchema, validationSchemaDef );\n        let _validationSchema = Yup.object().shape( clubSchema );\n        vmpValidationSchema.current = { exitingSchema: clubSchema, validationSchema: _validationSchema };\n    }\n};\n\nconst isDatetimeValueInvalid = ( dateApiObj, dateOrTimeType ) => {\n    let timeVal = dateApiObj.timeValue ? dateTimeSvc.getNormalizedTimeValue( dateApiObj.timeValue ) : null;\n    let dateVal = dateApiObj.dateValue ? dateApiObj.dateValue.split( ' ' )[0] : null;\n    switch( dateOrTimeType ) {\n        case 'DATE':\n            if( dateVal && !isMatch( dateVal, dateTimeSvc.getDateFilterFormat() ) ) {\n                return true;\n            }\n            break;\n        case 'TIME':\n            if( timeVal && !isMatch( timeVal, dateTimeSvc.getTimeFilterFormat() ) ) {\n                return true;\n            }\n            break;\n        default:\n            return false;\n    }\n    return false;\n};\n\nconst validateDateTime = function() {\n    let dateApiObj = this.options.parent.dateApi;\n    if( isDatetimeValueInvalid( dateApiObj, 'DATE' ) ) {\n        return this.createError( { message: localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] ) } );\n    }\n    if( isDatetimeValueInvalid( dateApiObj, 'TIME' ) ) {\n        return this.createError( { message: localeSvc.getMessage( 'INVALID_TIME', [ dateTimeSvc.getTimeFormatPlaceholder() ] ) } );\n    }\n    return true;\n};\n\nconst getValidationSchema = function( props = {}, vmpCollRef, getProps ) {\n    let schemaInput = {};\n    for( let [ key, value ] of Object.entries( props ) ) {\n        if( value ) {\n            // build the yup propSchema for checking dbValue\n            let dbValue;\n            let type = value.type || 'none';\n            switch ( type.toUpperCase() ) {\n                case 'DATE':\n                    dbValue = Yup.string()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .test( 'date-validation', 'invalid date', validateDateTime )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );\n                        } );\n                    break;\n                case 'DATEARRAY':\n                    dbValue = Yup.string()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .test( 'date-array-validation', 'invalid date', validateDateTime )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );\n                        } );\n                    break;\n                case 'INTEGER':\n                    dbValue = Yup.number()\n                        .nullable()\n                        .min( -2147483648, 'Out of range' )\n                        .max( 2147483647, 'Out of range' )\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'INTEGERARRAY':\n                    dbValue = Yup.array().of( Yup.number()\n                        .nullable()\n                        .min( -2147483648, 'Out of range' )\n                        .max( 2147483647, 'Out of range' )\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'DOUBLE':\n                    dbValue = Yup.number()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'DOUBLEARRAY':\n                    dbValue = Yup.array().of( Yup.number()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'BOOLEAN':\n                    dbValue = Yup.boolean()\n                        .nullable();\n                    break;\n                default:\n                    dbValue = Yup.string()\n                        .nullable();\n            }\n\n            if( value.isRequired || value.isRequired === 'true' ) {\n                dbValue = dbValue.required( () => {\n                    return localeSvc.getMessage( 'PROP_REQUIRED_ERROR' );\n                } );\n            }\n\n            if( value.validationCriteria ) {\n                for( let criteria in value.validationCriteria ) {\n                    dbValue = dbValue.test( value.validationCriteria[ criteria ].condition, value.validationCriteria[ criteria ].value, function() {\n                        let conditionObj = value.validationCriteria[ criteria ].condition;\n                        let viewModel = vmpCollRef.current.vmModel;\n                        viewModel.data = viewModel.getData();\n                        let evalContext = { viewModel, props: getProps, ctx: appCtxSvc.ctx };\n                        let expression = getRealExpression( conditionObj, viewModel.declViewModelJson );\n                        // eslint-disable-next-line no-invalid-this\n                        return evaluateCondition( viewModel, expression, evalContext ) ? this.createError( {\n                            message: viewModel.data[ key ].validationCriteria[ criteria ].value,\n                            path: key\n                        } ) : true;\n                    } );\n                }\n            }\n\n            let valueToTestSchema = dbValue.test( 'propertyError', 'Error', function() {\n                // eslint-disable-next-line no-invalid-this\n                let context = this;\n                let hasError = declUtils.isNil( context.parent.error ) || context.parent.error.trim() === '';\n                return !hasError ? context.createError( {\n                    message: context.parent.error,\n                    path: key\n                } ) : true;\n            } );\n            if( [ 'DATETIME', 'DATEARRAY', 'DATE' ].includes( type.toUpperCase() ) ) {\n                schemaInput[ key ] = Yup.object().shape( { uiValue: valueToTestSchema } );\n            } else {\n                schemaInput[ key ] = Yup.object().shape( { dbValue: valueToTestSchema } );\n            }\n        }\n    }\n\n    return {\n        validationSchemaDef: schemaInput\n    };\n};\n"]},"metadata":{},"sourceType":"module"}