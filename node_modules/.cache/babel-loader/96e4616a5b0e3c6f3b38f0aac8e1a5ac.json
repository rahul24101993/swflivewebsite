{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\nimport { evalExpression } from 'js/serviceUtils';\nimport { render, unmountComponentAtNode } from 'react-dom';\n/**\n * fastest way to copy a pure JSON object, use on your own risk\n * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript\n *\n * @param {Object} obj Current DOM Element\n * @returns {Object} new cloned object\n */\n\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function cloneDeepJsonObject(obj) {\n  return obj ? JSON.parse(JSON.stringify(obj)) : obj;\n}\n/**\n * parse data path to scope + subPatoh\n * @param {string} pathStr path string like 'ctx.a.b'\n * @returns {object} path structure like:\n * {\n *     scope: 'ctx'\n *     path: 'a.b'\n * }\n */\n\nexport function parseDataPath(pathStr) {\n  const match = pathStr.match(/[.[]/);\n\n  if (match) {\n    return {\n      scope: pathStr.substr(0, match.index),\n      path: pathStr.substr(match[0] === '[' ? match.index : match.index + 1)\n    };\n  }\n\n  return {\n    scope: pathStr\n  };\n}\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Object} scope parameters as name value pair\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n */\n\nexport function evalInScope(expr, scope, ignoreError, applyObject) {\n  const params = scope ? Object.keys(scope) : [];\n  const values = scope ? Object.values(scope) : [];\n  return evalExpression(expr, params, values, ignoreError, applyObject);\n}\n/**\n * get value from scope\n * @param {object} data scope for evaluation\n * @param {string} path string as path/expression\n * @returns {*} result\n */\n\nexport function getValue(data, path) {\n  return evalInScope(path, data, true);\n}\n/**\n * parse expr {{aa.bb}} to get aa.bb\n * @param {string} str input string\n * @returns {string} the expression inside {{}}\n */\n\nexport function parseExpr(str) {\n  let match = str.match(/^{{(.*)}}$/);\n  return match ? match[1] : undefined;\n}\n/**\n * Evaluate from data definition like:\n * {\n *    attr1: {{data.curVal}}\n * }\n * @param {JSON} input data definition\n * @param {JSON} scope scope for evaluation\n * @param {number} level used for recursive call internally\n * @returns {JSON} evaluated input object\n */\n\nexport function evalDataDefinition(input, scope) {\n  let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // Make the method to be immutable at top level\n\n  let obj = level > 0 ? input : cloneDeepJsonObject(input);\n\n  for (let key in obj) {\n    let value = obj[key];\n\n    if (typeof value === 'string') {\n      let template = parseExpr(value);\n\n      if (template) {\n        obj[key] = getValue(scope, template);\n      }\n    } else {\n      evalDataDefinition(obj[key], scope, level + 1);\n    }\n  }\n\n  return obj;\n}\n/**\n * parse i18n definition. Given:\n * {\n *     myData: {\n *         value1: \"a\",\n *         value2: \"{{i18n.myVal}}\"\n *     }\n * }\n * returns:\n * {\n *     \"myData.value2\": \"{{i18n.myVal}}\"\n * }\n * NODE: No usage for now, keep it here for reference\n * @param {JSON} dataDef data definition\n * @param {Array} stack JSON path stack\n * @returns {JSON} i18n defintions in path-expr pair\n */\n\nfunction getExprsFromDataDef(dataDef) {\n  let stack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const res = {};\n\n  for (let key in dataDef) {\n    stack.push(key);\n    let value = dataDef[key];\n\n    if (typeof value === 'string') {\n      let template = parseExpr(value);\n\n      if (/^i18n\\./.test(template)) {\n        res[stack.join('.')] = value;\n      }\n    } else {\n      Object.assign(res, getExprsFromDataDef(value, stack));\n    }\n\n    stack.pop();\n  }\n\n  return res;\n}\n/**\n * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.\n * @param {object} component React component.\n * @param {DOMElement} renderedElement The container element on which the component will be rendered.\n * @param {Function} callback callback function that will be executed by render method. This is optional.\n */\n\n\nexport function renderComponent(component, renderedElement, callback) {\n  if (component && renderedElement) {\n    render( /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: component\n    }, void 0, false), renderedElement, callback);\n  }\n}\n/**\n * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.\n * These elements will then be unmounted if they have a react element mounted.\n * @param {HTMLElement} baseElement The base element to use\n * @param {String} [selector] CSS selector used to search for nodes from the base element\n */\n\nexport function unmountComponents(baseElement, selector) {\n  // get the container elements that could potentially have a component\n  let components;\n\n  if (!selector) {\n    components = [baseElement];\n  } else {\n    components = baseElement.querySelectorAll(selector);\n  }\n\n  for (let i = 0; i < components.length; i++) {\n    unmountComponentAtNode(components[i]);\n  }\n}","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declReactUtils.js"],"names":["obj","JSON","match","pathStr","scope","path","params","Object","values","evalExpression","evalInScope","str","level","cloneDeepJsonObject","value","template","parseExpr","getValue","evalDataDefinition","stack","res","dataDef","getExprsFromDataDef","component","render","components","baseElement","i","unmountComponentAtNode"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\nimport { evalExpression } from 'js/serviceUtils';\nimport { render, unmountComponentAtNode } from 'react-dom';\n\n/**\n * fastest way to copy a pure JSON object, use on your own risk\n * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript\n *\n * @param {Object} obj Current DOM Element\n * @returns {Object} new cloned object\n */\nexport function cloneDeepJsonObject( obj ) {\n    return obj ? JSON.parse( JSON.stringify( obj ) ) : obj;\n}\n\n/**\n * parse data path to scope + subPatoh\n * @param {string} pathStr path string like 'ctx.a.b'\n * @returns {object} path structure like:\n * {\n *     scope: 'ctx'\n *     path: 'a.b'\n * }\n */\nexport function parseDataPath( pathStr ) {\n    const match = pathStr.match( /[.[]/ );\n    if( match ) {\n        return {\n            scope: pathStr.substr( 0, match.index ),\n            path: pathStr.substr( match[ 0 ] === '[' ? match.index : match.index + 1 )\n        };\n    }\n    return { scope: pathStr };\n}\n\n/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Object} scope parameters as name value pair\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n */\nexport function evalInScope( expr, scope, ignoreError, applyObject ) {\n    const params = scope ? Object.keys( scope ) : [];\n    const values = scope ? Object.values( scope ) : [];\n    return evalExpression( expr, params, values, ignoreError, applyObject );\n}\n\n/**\n * get value from scope\n * @param {object} data scope for evaluation\n * @param {string} path string as path/expression\n * @returns {*} result\n */\nexport function getValue( data, path ) {\n    return evalInScope( path, data, true );\n}\n\n/**\n * parse expr {{aa.bb}} to get aa.bb\n * @param {string} str input string\n * @returns {string} the expression inside {{}}\n */\nexport function parseExpr( str ) {\n    let match = str.match( /^{{(.*)}}$/ );\n    return match ? match[ 1 ] : undefined;\n}\n\n/**\n * Evaluate from data definition like:\n * {\n *    attr1: {{data.curVal}}\n * }\n * @param {JSON} input data definition\n * @param {JSON} scope scope for evaluation\n * @param {number} level used for recursive call internally\n * @returns {JSON} evaluated input object\n */\nexport function evalDataDefinition( input, scope, level = 0 ) {\n    // Make the method to be immutable at top level\n    let obj = level > 0 ? input : cloneDeepJsonObject( input );\n\n    for( let key in obj ) {\n        let value = obj[ key ];\n        if( typeof value === 'string' ) {\n            let template = parseExpr( value );\n            if( template ) {\n                obj[ key ] = getValue( scope, template );\n            }\n        } else {\n            evalDataDefinition( obj[ key ], scope, level + 1 );\n        }\n    }\n    return obj;\n}\n\n/**\n * parse i18n definition. Given:\n * {\n *     myData: {\n *         value1: \"a\",\n *         value2: \"{{i18n.myVal}}\"\n *     }\n * }\n * returns:\n * {\n *     \"myData.value2\": \"{{i18n.myVal}}\"\n * }\n * NODE: No usage for now, keep it here for reference\n * @param {JSON} dataDef data definition\n * @param {Array} stack JSON path stack\n * @returns {JSON} i18n defintions in path-expr pair\n */\nfunction getExprsFromDataDef( dataDef, stack = [] ) {\n    const res = {};\n    for( let key in dataDef ) {\n        stack.push( key );\n        let value = dataDef[ key ];\n        if( typeof value === 'string' ) {\n            let template = parseExpr( value );\n            if( /^i18n\\./.test( template ) ) {\n                res[ stack.join( '.' ) ] = value;\n            }\n        } else {\n            Object.assign( res, getExprsFromDataDef( value, stack ) );\n        }\n        stack.pop();\n    }\n    return res;\n}\n\n/**\n * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.\n * @param {object} component React component.\n * @param {DOMElement} renderedElement The container element on which the component will be rendered.\n * @param {Function} callback callback function that will be executed by render method. This is optional.\n */\nexport function renderComponent( component, renderedElement, callback ) {\n    if( component && renderedElement ) {\n        render( <>{ component }</>, renderedElement, callback );\n    }\n}\n\n/**\n * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.\n * These elements will then be unmounted if they have a react element mounted.\n * @param {HTMLElement} baseElement The base element to use\n * @param {String} [selector] CSS selector used to search for nodes from the base element\n */\nexport function unmountComponents( baseElement, selector ) {\n    // get the container elements that could potentially have a component\n    let components;\n    if( !selector ) {\n        components = [ baseElement ];\n    } else {\n        components = baseElement.querySelectorAll( selector );\n    }\n\n    for( let i = 0; i < components.length; i++ ) {\n        unmountComponentAtNode( components[ i ] );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}