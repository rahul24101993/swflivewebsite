{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/filterPanelUtils\n */import appCtxService from'js/appCtxService';import dateTimeService from'js/dateTimeService';import messagingService from'js/messagingService';import localeSvc from'js/localeService';import $ from'jquery';import logger from'js/logger';import _ from'lodash';var _invalidDateText='';var _invalidRangeText='';var _invalidPrefilter='';var AWC_LIMITED_FILTER_CATEGORIES_ENABLED='AWC_Limited_Filter_Categories_Enabled';export let HIERARCHICAL_FACET_SEPARATOR='/';export let PRESET_CATEGORY='WorkspaceObject.object_type';export let DATE_FILTER='DateFilter';export let INTERNAL_DATE_FILTER='_DateFilter_';export let DATE_RANGE_FILTER='DateRangeFilter';export let DATE_DRILLDOWN_FILTER='DrilldownDateFilter';export let NUMERIC_RANGE_FILTER='NumericRangeFilter';export let INTERNAL_NUMERIC_FILTER='_NumericFilter_';export let INTERNAL_OBJECT_FILTER='_ObjectFilter_';export let INTERNAL_NUMERIC_RANGE='_NumericRange_';export let NUMERIC_FILTER='NumericFilter';export let NUMERIC_RANGE='NumericRange';export let NumericRangeBlankStart='NumericRangeBlankStart';export let NumericRangeBlankEnd='NumericRangeBlankEnd';var INTERNAL_TO='_TO_';export let NO_STARTDATE='*';export let NO_ENDDATE='2100-12-31';export let NO_STARTRANGE='';export let NO_ENDRANGE='';export let BEGINNING_OF_TIME='0001-01-01T00:00:00';export let ENDING_OF_TIME='2100-12-31T23:59:59';var START_OF_DAY='00:00:00';var _presetFilters=true;var _hasTypeFilter=false;var _incontextFlag=false;var customPropValueColorMap={};/**\n * Returns a date object.\n *\n * @function getDate\n * @memberOf filterPanelUtils\n *\n * @param {String}dateString - date string to be converted to date object\n *\n * @return {JsDate} a date object.\n */export let getDate=function(dateString){var dateStr=dateString.substring(0,10);var date;// change open start/end date to null dates\nif(_.startsWith(dateStr,'0001-01-0')||_.startsWith(dateStr,'2100-12-3')){date=dateTimeService.getNullDate();}else{var timeStr=dateString.substring(11,dateString.length-6);if(timeStr.indexOf('59')!==-1){dateStr=dateString.replace(timeStr,START_OF_DAY);}else{dateStr=dateString;}date=new Date(dateStr);}return date;};/**\n * Returns a UTC date object.\n *\n * @function convertToUTC\n * @memberOf filterPanelUtils\n *\n * @param {Object}date - date object\n *\n * @return {JsDate} a UTC date object.\n */function convertToUTC(date){var gmtTime=date.getTime();var offset=date.getTimezoneOffset();var jsDate=new Date(gmtTime+offset*60*1000);return new Date(jsDate.getTime());}/**\n * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can\n * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the\n * dateTimeService.isNullDate.\n *\n * @function isNullDate\n * @memberOf filterPanelUtils\n *\n * @param {Object} dateToTest - a Date object.\n * @returns {Boolean} - true if it's a null date.\n */export let isNullDate=function(dateToTest){if(!dateToTest){return true;}return dateToTest.getFullYear()<=1;};/**\n * Validate dates for category date range.\n *\n * @function validateDates\n * @memberOf filterPanelUtils\n *\n * @param {Object}category - category. This object is modified in this function.\n * @param {Object}startDate - startDate\n * @param {Object}origStartDate - origStartDate\n * @param {Object}endDate - endDate\n * @param {Object}origEndDate - origEndDate\n */export let validateDates=function(category,startDate,origStartDate,endDate,origEndDate){category.showSearch=true;var cStartDate=category.daterange.startDate;var eEndDate=category.daterange.endDate;if(category.daterange.dateRangeSelected&&!cStartDate.valueUpdated&&!eEndDate.valueUpdated){category.showSearch=false;return;}// The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,\n// which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.\nvar tmpStartDate=moveDateToStartOfDay(startDate);var tmpEndDate=moveDateToStartOfDay(endDate);var noStartDate=dateTimeService.isNullDate(tmpStartDate);var noEndDate=dateTimeService.isNullDate(tmpEndDate);// if both dates are not set, disable search button\nif(noStartDate&&noEndDate){category.showSearch=false;return;}var temp1=dateTimeService.compare(startDate,endDate);// if start date is later than end date, disable search button\nif(!noStartDate&&!noEndDate&&startDate!==null&&temp1===1){messagingService.showError(_invalidDateText);category.showSearch=false;return;}var disable;// check if dates vary from previous search to avoid enabling search\nvar tmpOrigEndDate=moveDateToStartOfDay(origEndDate);if(noStartDate){// check if there is no startdate and if end date is same, disable search button\ndisable=category.daterange.startDate===null&&dateTimeService.compare(tmpEndDate,tmpOrigEndDate)===0;}else if(noEndDate){// check if there is no enddate and  start date is same, disable search button\ndisable=category.daterange.endDate===null&&dateTimeService.compare(startDate,category.daterange.startDate.dateApi.dateObject)===0;}else{// if the dates are same as previous search, disable search button\nvar compare1=dateTimeService.compare(startDate,origStartDate)===0;var compare2=dateTimeService.compare(endDate,tmpOrigEndDate)===0;disable=compare1&&compare2;}category.showSearch=!disable;};/**\n * get date range filter.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {Object}startDate - startDate\n * @param {Object}endDate - endDate\n *\n * @return {String} a string that represents the date range.\n */export let getDateRangeString=function(startDate,endDate){var noStartDate=isNullDate(startDate);var noEndDate=isNullDate(endDate);var fromDateString=noStartDate?NO_STARTDATE:dateTimeService.formatUTC(startDate);if(noEndDate){endDate=new Date(NO_ENDDATE);}var toDateString=dateTimeService.formatUTC(moveDateToEndOfDay(endDate));return INTERNAL_DATE_FILTER+fromDateString+INTERNAL_TO+toDateString;};/**\n * get filter of date range.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a filter object of date range for the filter string.\n */export let getDateRangeFilter=function(filter){var searchFilter={};var sArr=filter.split(INTERNAL_TO);searchFilter.searchFilterType='DateFilter';sArr[0]=sArr[0]===NO_STARTDATE?dateTimeService.NULLDATE:dateTimeService.formatUTC(sArr[0]);searchFilter.startDateValue=sArr[0];searchFilter.endDateValue=sArr[1];return searchFilter;};/**\n * get a date range filter with display name and category type.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}startDate - startDate\n * @param {String}endDate - endDate\n *\n * @return {Object} a date range filter with display name and category type.\n */export let getDateRangeDisplayString=function(startDate,endDate){var dateRangeFilter={};var noStartDate=dateTimeService.isNullDate(startDate);var noEndDate=dateTimeService.isNullDate(endDate);var dateRangeString;if(noStartDate){dateRangeString='To '+dateTimeService.formatDate(new Date(endDate)).substring(0,11);}else if(noEndDate){dateRangeString='From '+dateTimeService.formatDate(new Date(startDate)).substring(0,11);}else{dateRangeString=dateTimeService.formatDate(new Date(startDate)).substring(0,11)+' - '+dateTimeService.formatDate(new Date(endDate)).substring(0,11);}dateRangeFilter.displayName=dateRangeString;dateRangeFilter.categoryType=DATE_RANGE_FILTER;return dateRangeFilter;};/**\n * Simple check to validate the given category numeric range.\n *\n * @function checkIfValidRange\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n *\n * @return {Boolean} true if valid range.\n */export let checkIfValidRange=function(category,startRange,endRange){category.showSearch=true;if(startRange!==null&&endRange!==null&&startRange>endRange){var errorValue=startRange+'-'+endRange;var msg=_invalidRangeText.replace('{0}',errorValue);messagingService.showError(msg);category.showSearch=false;return false;}return true;};/**\n * Validate the given category numeric range if the range is selected.\n *\n * @function validateNumericRangeSelected\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {Number}cStartRange - current startRange\n * @param {Number}cEndRange - current endRange\n * @return {Boolean} true if valid range.\n */export let validateNumericRangeSelected=function(category,startRange,endRange,cStartRange,cEndRange){var hasValidated=false;var oStartRange=category.numericrange.filter.startNumericValue;var oEndRange=category.numericrange.filter.endNumericValue;var pStartRange=parseFloat(cStartRange);var pEndRange=parseFloat(cEndRange);var invalidStart=cStartRange===oStartRange||pStartRange===oStartRange||isNaN(pStartRange)&&oStartRange===NO_STARTRANGE;// when the start range goes from blank to 0, it's a real change, so the search button should be enabled.\nif(category.numericrange.filter.startEndRange===NumericRangeBlankStart){invalidStart=isNaN(pStartRange);}var invalidEnd=cEndRange===oEndRange||pEndRange===oEndRange||isNaN(pEndRange)&&oEndRange===NO_ENDRANGE;if(category.numericrange.filter.startEndRange===NumericRangeBlankEnd){invalidEnd=isNaN(pEndRange);}// when the end range goes from blank to 0, it's a real change, so the search button should be enabled.\nif(invalidStart&&invalidEnd){category.showSearch=false;hasValidated=true;}return hasValidated;};/**\n * Validate ranges for category numeric range.\n *\n * @function validateNumericRange\n * @memberOf filterPanelUtils\n *\n * @param {String} category - category\n * @param {String} startRange - startRange\n * @param {String} endRange - endRange\n *\n */export let validateNumericRange=function(category,startRange,endRange){category.showSearch=true;// Validate values to be numbers\nvar cStartRange=category.numericrange.startValue.dbValue;var cEndRange=category.numericrange.endValue.dbValue;var oStartRange=null;var oEndRange=null;if(category.numericrange.numericRangeSelected&&validateNumericRangeSelected(category,startRange,endRange,cStartRange,cEndRange)){return;}var noStartRange=cStartRange===undefined||cStartRange===null||cStartRange==='';var noEndRange=cEndRange===undefined||cEndRange===null||cEndRange==='';// if both numbers are not set, disable search button\nif(noStartRange&&noEndRange){category.showSearch=false;return;}var disable=false;if(noStartRange){disable=endRange===oEndRange||isNaN(endRange);}else if(noEndRange){// check if there is no endRange and  start number is same, disable search button\ndisable=startRange===oStartRange||isNaN(startRange);}else{disable=!isFinite(startRange)||isNaN(startRange)||!isFinite(endRange)||isNaN(endRange);}category.showSearch=!disable;};/**\n * get numeric range filter string.\n *\n * @function getNumericRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}startRange - startRange\n * @param {String}endRange - endRange\n *\n * @return {String} a numeric range string.\n */export let getNumericRangeString=function(startRange,endRange){var fromValue=startRange&&startRange.toString();if(fromValue===undefined||fromValue===null||fromValue.length===0||isNaN(fromValue)){fromValue=NO_STARTRANGE;}var toValue=endRange&&endRange.toString();if(toValue===undefined||toValue===null||toValue.length===0||isNaN(toValue)){toValue=NO_ENDRANGE;}return INTERNAL_NUMERIC_RANGE+fromValue+INTERNAL_TO+toValue;};/**\n * get numeric range filter from a filter string.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a numeric range filter.\n */export let getNumericRangeFilter=function(filter){var searchFilter={};var sArr=filter.split(INTERNAL_TO);searchFilter.searchFilterType=NUMERIC_FILTER;searchFilter.startNumericValue=parseFloat(sArr[0]);searchFilter.endNumericValue=parseFloat(sArr[1]);if(isNaN(searchFilter.startNumericValue)){searchFilter.startEndRange=NumericRangeBlankStart;}else if(isNaN(searchFilter.endNumericValue)){searchFilter.startEndRange=NumericRangeBlankEnd;}else{searchFilter.startEndRange=NUMERIC_RANGE;}return searchFilter;};/**\n * get a numeric range filter.\n *\n * @function getNumericRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {String}startEndRange - startEndRange\n *\n * @return {Object} a numeric range filter with display name and category type.\n */export let getNumericRangeDisplayString=function(startRange,endRange,startEndRange){var numericRangeFilter={};var noStartRange=startEndRange===NumericRangeBlankStart||startRange!==0&&!startRange;var noEndRange=startEndRange===NumericRangeBlankEnd||endRange!==0&&!endRange;var numericRangeString;if(noStartRange){numericRangeString='To '+endRange.toString();}else if(noEndRange){numericRangeString='From '+startRange.toString();}else{numericRangeString=startRange.toString()+' - '+endRange.toString();}numericRangeFilter.displayName=numericRangeString;numericRangeFilter.categoryType=NUMERIC_RANGE_FILTER;return numericRangeFilter;};/**\n * get a real filter.\n *\n * @function getRealFilterWithNoFilterType\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} the real filter stripped off the identifiers.\n */export let getRealFilterWithNoFilterType=function(filter){var realFilter=filter;if(!filter.hasOwnProperty('property')){realFilter=filter.replace(INTERNAL_NUMERIC_FILTER,'').replace(INTERNAL_OBJECT_FILTER,'');}return realFilter;};/**\n * get filter type from filter value.\n *\n * @function getFilterTypeFromFilterValue\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {String} filter type, if it can be derived.\n */export let getFilterTypeFromFilterValue=function(filter){var filterType;if(_.startsWith(filter,INTERNAL_OBJECT_FILTER)){filterType='ObjectFilter';}else if(_.startsWith(filter,INTERNAL_NUMERIC_FILTER)){filterType='NumericFilter';}else{filterType='DateFilter';}return filterType;};/**\n * /** Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */function moveDateToStartOfDay(date){if(!dateTimeService.isNullDate(date)){date.setHours(0,0,0);return date;}return date;}/**\n * Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */function moveDateToEndOfDay(date){if(!dateTimeService.isNullDate(date)){date.setHours(23,59,59);return date;}return date;}/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */export let isPresetFilters=function(){return _presetFilters;};/**\n * Sets preset filters flag\n *\n * @param {Object} flag flag\n */export let setPresetFilters=function(flag){_presetFilters=flag;};/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */export let getHasTypeFilter=function(){return _hasTypeFilter;};/**\n * Sets preset filters flag\n *\n * @param {Object} flag preset filter flag\n */export let setHasTypeFilter=function(flag){_hasTypeFilter=flag;};/**\n * Sets incontext flag\n *\n * @param {Object} flag incontext flag\n */export let setIncontext=function(flag){_incontextFlag=flag;};/**\n * Gets incontext flag\n *\n * @returns {Object} incontext flag\n */export let getIncontext=function(){return _incontextFlag;};/**\n * Save source filter map in appcontext for incontext\n *\n * @param {Object} data data\n */export let saveIncontextFilterMap=function(data){let inContextMap={};if(getHasTypeFilter()){// Create a filter value for each category value\nlet tmpValues=data.searchFilterMap[PRESET_CATEGORY];inContextMap[PRESET_CATEGORY]=tmpValues;}return inContextMap;};/**\n * Returns category internal name\n * @param {Object} category category\n * @returns {Object} The category internal name\n */export let getCategoryInternalName=function(category){return category.internalName;};/**\n * Returns current category\n *\n * @param {Object} response the response from the search SOA\n * @returns {Object} The current category\n */export let getCurrentCategory=function(response){return response.groupedObjectsList[0].internalPropertyName;};/**\n * Returns filter values for a category to be shown in panel\n *\n * @param {Object} category the category to get values for\n *\n * @returns {ObjectArray} The array of filters to show in panel\n */export let getPropGroupValues=function(category){getPreferenceValue();var values=[];for(var i=0;i<category.filterValues.length;i++){var categoryValue=category.filterValues[i];if(categoryValue&&(i<9||categoryValue.color)){values.push(getPropGroupValue(category.type,category.drilldown,categoryValue));}}return values;};/**\n * Returns filter values for a category to be shown in panel\n * @param {String} categoryType categoryType\n * @param {Integer} categoryDrillDown category Drill Down\n * @param {String} categoryValue categoryValue\n * @returns {Object} filter value\n */export let getPropGroupValue=function(categoryType,categoryDrillDown,categoryValue){var pos=categoryValue.categoryName.indexOf('.');var propertyName;if(pos!==-1){propertyName=categoryValue.categoryName.slice(pos+1);}else{propertyName=categoryValue.categoryName;}var mapKey=propertyName+'.'+categoryValue.name;var filterValue={};if(categoryValue.color&&customPropValueColorMap[mapKey]){filterValue.propertyGroupID=categoryValue.color;var rgbColorValue=getFilterColorRGBValue(categoryValue.color);filterValue.colorValue=rgbColorValue;}else{filterValue.propertyGroupID=getFilterColorValue(categoryValue.colorIndex);filterValue.colorIndex=categoryValue.colorIndex;filterValue.colorValue=getFilterColorRGBValue('aw-charts-chartColor'+(categoryValue.colorIndex%9+1));}if(categoryType==='DateFilter'){if(categoryValue.colorIndex>=categoryDrillDown){if(categoryValue.internalName!=='$NONE'){filterValue.startValue=categoryValue.startDateValue;filterValue.endValue=categoryValue.endDateValue;}else{filterValue.startValue='$NONE';}}}else{filterValue.startValue=categoryValue.internalName;filterValue.endValue='';}return filterValue;};/**\n * Returns filter RGB values for a category to be shown in viewer\n * @param {STRING} color color\n * @returns {Object} filter Color RGB value\n */export let getFilterColorRGBValue=function(color){var colorBlock='.aw-ui-filterNameColorBlock';var colorBlockElement=$(colorBlock);var elementExists=colorBlockElement&&colorBlockElement.length>0;if(!elementExists){//in the case of ACE filter panel, the rendering of the panel is delayed\ncolorBlock='.aw-layout-globalToolbarPanel';colorBlockElement=$(colorBlock);elementExists=colorBlockElement&&colorBlockElement.length>0;}if(elementExists){var p=colorBlockElement[0];var replacedClassName=p.className;p.className='aw-ui-filterNameColorBlock '+color;var style2=window.getComputedStyle(p,null).getPropertyValue('background-color');p.className=replacedClassName;return style2;}return'';};/**\n * Returns filter values for a category to be shown in panel\n * @param {Integer} index index\n * @returns {Object} filter value\n */export let getFilterColorValue=function(index){return index>-1?'aw-charts-chartColor'+(index%9+1):'';};/**\n * Get property name from filter name.\n *\n * @param {String} filterName - The filter name\n * @return {propName} property name\n */export let getPropertyFromFilter=function(filterName){var propName=filterName;var YEAR_SUFFIX='_0Z0_year';var YEAR_MONTH_SUFFIX='_0Z0_year_month';var WEEK_SUFFIX='_0Z0_week';var YEAR_MONTH_DAY_SUFFIX='_0Z0_year_month_day';if(_.endsWith(filterName,YEAR_MONTH_DAY_SUFFIX)===true){propName=filterName.replace(YEAR_MONTH_DAY_SUFFIX,'');}if(_.endsWith(filterName,WEEK_SUFFIX)===true){propName=filterName.replace(WEEK_SUFFIX,'');}if(_.endsWith(filterName,YEAR_MONTH_SUFFIX)===true){propName=filterName.replace(YEAR_MONTH_SUFFIX,'');}if(_.endsWith(filterName,YEAR_SUFFIX)===true){propName=filterName.replace(YEAR_SUFFIX,'');}return propName;};/**\n * Get formatted date.\n *\n * @param {String} dateString - input date\n *\n * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range\n *\n * @return {formattedDate} formatted date\n */export let getFormattedFilterDate=function(dateString,isDateRangeToDate){var formattedDate;if(dateString==='*'){if(isDateRangeToDate){formattedDate=ENDING_OF_TIME;}else{formattedDate=BEGINNING_OF_TIME;}}else{try{var date=convertToUTC(new Date(dateString));formattedDate=dateTimeService.formatUTC(date);}catch(e){logger.error('The specified date is invalid and will be ignored for the search:',dateString);return null;}}return formattedDate;};/**\n * Get formatted numeric range filter.\n *\n * @param {String} filterValue - filterValue\n *\n * @return {formattedNumber} formatted filter\n */export let getFormattedFilterNumber=function(filterValue){var formattedFilter={};var startToEnd=filterValue.split(' TO ');var startNumber=parseFloat(startToEnd[0]);var endNumber=parseFloat(startToEnd[1]);if(isNaN(startNumber)&&isNaN(endNumber)){logger.error('The specified range is invalid and will be ignored for the search:',filterValue);return null;}else if(startToEnd[0]==='*'){formattedFilter={searchFilterType:'NumericFilter',startNumericValue:0,endNumericValue:endNumber,startEndRange:NumericRangeBlankStart};}else if(startToEnd[1]==='*'){formattedFilter={searchFilterType:'NumericFilter',startNumericValue:startNumber,endNumericValue:0,startEndRange:NumericRangeBlankEnd};}else{if(isNaN(startNumber)||isNaN(endNumber)){logger.error('The specified range is invalid and will be ignored for the search:',filterValue);return null;}formattedFilter={searchFilterType:'NumericFilter',startNumericValue:startNumber,endNumericValue:endNumber,startEndRange:NUMERIC_RANGE};}return formattedFilter;};/**\n * Get Range Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */export let getRangeSearchFilter=function(filterType,filterValue){// range search.\nvar searchFilter;var startToEnd=filterValue.split(' TO ');if(filterType==='NumericFilter'){searchFilter=getFormattedFilterNumber(filterValue);}else if(filterType==='DateFilter'){var startDate=getFormattedFilterDate(startToEnd[0].trim(),false);var endDate=getFormattedFilterDate(startToEnd[1].trim(),true);if(startDate&&endDate){searchFilter={searchFilterType:filterType,startDateValue:startDate,endDateValue:endDate};}}else{// String type, but string type should not support range search,\n// so treat the \" TO \" as just part of the filter value\nsearchFilter={searchFilterType:filterType,stringValue:filterValue};}return searchFilter;};/**\n * Get Single Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */export let getSingleSearchFilter=function(filterType,filterValue){// range search.\nvar searchFilter;if(filterType==='NumericFilter'){try{var formattedNumber=parseFloat(filterValue);if(isNaN(formattedNumber)){logger.error('The specified number is invalid and will be ignored for the search:',filterValue);}else{searchFilter={searchFilterType:filterType,startNumericValue:formattedNumber,endNumericValue:formattedNumber,stringValue:filterValue};}}catch(e){logger.error('The specified number is invalid and will be ignored for the search:',filterValue);}}else{// Date type is also treated as String, if it's not date range.\nsearchFilter={searchFilterType:'StringFilter',stringValue:filterValue};}return searchFilter;};/**\n * Get filter type based on the value type.\n *\n * @param {Integer} valueType - The valueType for this property\n *\n * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)\n */export let getFilterType=function(valueType){var filterType;switch(valueType){case 2:filterType='DateFilter';break;case 3:case 4:case 5:case 7:filterType='NumericFilter';break;case 9:case 10:case 11:case 12:case 13:case 14:// filterType = 'ObjectFilter';\n// ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.\nfilterType='StringFilter';break;default:filterType='StringFilter';break;}return filterType;};/**\n * Display search prefilter error\n *\n * @param {String} prefilter - The search prefilter\n *\n */export let displayPrefilterError=function(prefilter){var msg=_invalidPrefilter.replace('{0}',prefilter);messagingService.showError(msg);};/**\n * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.\n * This is used to overide filter color in filter panel.\n * Preference value is in formate <propertyname>.<value>:<colorValue>\n */export let getPreferenceValue=()=>{let values=appCtxService.getCtx('preferences.AWC_CustomPropValueColor');if(values&&values[0]){for(var i=0;i<values.length;i++){var prefVal=values[i];var pos=prefVal.indexOf(':');var color=prefVal.slice(pos+1);var property=prefVal.slice(0,pos);customPropValueColorMap[property]=color;}}};/**\n * get filter color\n *\n * @param propertyName filter name\n *\n * @returns color color code need to be applied for filter\n */export let getCustomPropValueColorMap=function(propertyName){return customPropValueColorMap[propertyName];};/**\n * set filter color\n *\n * @param propertyName filter name\n *\n * @param color color code need to be applied for filter\n */export let setCustomPropValueColorMap=function(propertyName,color){customPropValueColorMap[propertyName]=color;};/**\n * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.\n */export let applyCustomColor=function(categoryName,categoryValue,filterValue){var pos=categoryName.indexOf('.');var propertyName;if(pos!==-1){propertyName=categoryName.slice(pos+1);}else{propertyName=categoryName;}var mapKey=propertyName+'.'+categoryValue.stringValue;//Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference\nif(customPropValueColorMap[mapKey]){if(categoryValue.colorValue){//This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later\nfilterValue.color=categoryValue.colorValue;}else{//This scenario will be hit in the cases where color value is not being populated by server response\nfilterValue.color=customPropValueColorMap[mapKey];}}};/**\n * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not\n * @param { Object } category - the current category\n * @returns { Boolean } true/false\n */export let checkIfFilterValuesExist=function(category){if(category.filterValues&&category.filterValues.length>0){return true;}return false;};/**\n * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true\n * @returns { Boolean } true/false\n */export let isLimitedCategoriesFeatureEnabled=function(){var preferenceValue=appCtxService.getCtx('preferences.'+AWC_LIMITED_FILTER_CATEGORIES_ENABLED);if(preferenceValue&&preferenceValue[0].toLowerCase()==='true'){return true;}return false;};/**\n * ifFilterSelectedForCategory - check if the current category has some filter as selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */export let ifFilterSelectedForCategory=function(category){var filterValuesExist=checkIfFilterValuesExist(category);if(filterValuesExist){for(var index=0;index<category.filterValues.length;index++){if(category.filterValues[index].selected){return true;}}}return false;};/**\n * isClsCategory - check if the current category is a classification type\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */export let isClsCategory=category=>{if(category.filterValues&&(category.filterValues.parentnodes&&category.filterValues.parentnodes.length>0||category.filterValues.childnodes&&category.filterValues.childnodes.length>0)){return true;}return false;};/**\n * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */export let ifFilterSelectedForCls=category=>{var filterValuesExist=isClsCategory(category);if(filterValuesExist){for(var index=0;index<category.filterValues.parentnodes.length;index++){if(category.filterValues.parentnodes[index].selected){return true;}}}return false;};/**\n * getFilterFocus - return whether to set autoFocus for a filter as true or false\n * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info\n * @param { Object } filter current filter\n * @param { Object } categoryInternalName current category internal name\n * @param { Integer } index - current filter index\n * @returns { Boolean } autoFocus value for the filter - true/false\n */export const getFilterFocus=(lastSelectedFilterAndCategoryInfo,filter,categoryInternalName,index)=>{let lastAction=lastSelectedFilterAndCategoryInfo?lastSelectedFilterAndCategoryInfo.lastAction:'';switch(lastAction){case'selectFilter':if(lastSelectedFilterAndCategoryInfo&&lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName===filter.categoryName&&lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName===filter.internalName){return true;}return false;case'dateRangeSearch':if(index===0&&lastSelectedFilterAndCategoryInfo&&lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory===categoryInternalName){return true;}return false;case'numericRangeSearch':if(index===1&&lastSelectedFilterAndCategoryInfo&&lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory===categoryInternalName){return true;}return false;default:return false;}};export let loadConfiguration=function(){localeSvc.getLocalizedTextFromKey('UIMessages.invalidDate',true).then(result=>_invalidDateText=result);localeSvc.getLocalizedTextFromKey('UIMessages.invalidRange',true).then(result=>_invalidRangeText=result);localeSvc.getLocalizedTextFromKey('UIMessages.invalidPrefilter',true).then(result=>_invalidPrefilter=result);};loadConfiguration();export default{HIERARCHICAL_FACET_SEPARATOR,PRESET_CATEGORY,DATE_FILTER,INTERNAL_DATE_FILTER,DATE_RANGE_FILTER,DATE_DRILLDOWN_FILTER,NUMERIC_RANGE_FILTER,INTERNAL_NUMERIC_FILTER,INTERNAL_OBJECT_FILTER,INTERNAL_NUMERIC_RANGE,NUMERIC_FILTER,NUMERIC_RANGE,NumericRangeBlankStart,NumericRangeBlankEnd,NO_STARTDATE,NO_ENDDATE,NO_STARTRANGE,NO_ENDRANGE,BEGINNING_OF_TIME,ENDING_OF_TIME,getDate,isNullDate,validateDates,getDateRangeString,getDateRangeFilter,getDateRangeDisplayString,checkIfValidRange,validateNumericRangeSelected,validateNumericRange,getNumericRangeString,getNumericRangeFilter,getNumericRangeDisplayString,getRealFilterWithNoFilterType,getFilterTypeFromFilterValue,isPresetFilters,setPresetFilters,getHasTypeFilter,setHasTypeFilter,setIncontext,getIncontext,saveIncontextFilterMap,getCategoryInternalName,getCurrentCategory,getPropGroupValues,getPropGroupValue,getFilterColorRGBValue,getFilterColorValue,getPropertyFromFilter,getFormattedFilterDate,getFormattedFilterNumber,getRangeSearchFilter,getSingleSearchFilter,getFilterType,displayPrefilterError,getPreferenceValue,getCustomPropValueColorMap,setCustomPropValueColorMap,applyCustomColor,checkIfFilterValuesExist,isLimitedCategoriesFeatureEnabled,ifFilterSelectedForCategory,isClsCategory,ifFilterSelectedForCls,getFilterFocus};","map":null,"metadata":{},"sourceType":"module"}