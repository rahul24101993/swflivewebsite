{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.async} which provides a set of utilities for handling async methods\n *\n * @module js/async.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwTimeoutService from 'js/awTimeoutService';\nimport Debug from 'debug';\nvar trace = new Debug('async');\n/* eslint-disable-next-line valid-jsdoc*/\n\nlet exports = {};\n/**\n * Get an api capable of executing the given api async\n *\n * @param {Function<List<a>>} methodToExecute Method to call. Input will be a list of a where a is the input to the debounced method\n * @param {Number} debounceTime How long to debounce method calls\n * @param {Lock} lock A \"lock\" with a \"isUnlocked\" function. Allows external control of call on top of debounce\n * @returns {Function<a>} A debounced version of the method that supports individual calls\n */\n\nvar debouncePromise = function (methodToExecute, debounceTime, lock) {\n  /**\n   * Promise tracking any currently active batch.\n   *\n   * Resolved once the method is actually executed.\n   */\n  var deferred = null;\n  /**\n   * The current active timer. If allowed to complete the method will be executed.\n   */\n\n  var debounceTimer = null;\n  /**\n   * Items to pass to the network\n   */\n\n  var items = [];\n  /**\n   * Flag tracking if the service was previously locked\n   */\n\n  var wasLocked = false;\n  /**\n   * Actually execute the action\n   *\n   * @returns {Promise} Promise resolved after execution\n   */\n\n  var doAction = function () {\n    // Clear the reference to current batch - set to null to prevent additions to current batch post timeout\n    var currentDefer = deferred;\n    var currentItems = items;\n    deferred = null;\n    items = []; // Actually do the method\n\n    return methodToExecute(currentItems);\n  };\n  /**\n   * Add a new item to batch\n   *\n   * Returns a promise resolved when the method is actually executed.\n   *\n   * @param {a} item The item to add\n   * @returns {Promise} Promise resolved when action is actually executed\n   */\n\n\n  return function (item) {\n    // If a batch is not already active create a new one\n    if (!deferred) {\n      deferred = AwPromiseService.instance.defer();\n    } // If the timer is running cancel it\n\n\n    if (debounceTimer) {\n      AwTimeoutService.instance.cancel(debounceTimer);\n    } // Add item to batch and start a new timer\n\n\n    items.push(item);\n\n    var timerComplete = function () {\n      if (lock) {\n        if (lock.isUnlocked()) {\n          if (!wasLocked) {\n            trace('Debounce is unlocked doing action', debounceTime); // Debounce after unlock has finished, safe to do action\n\n            doAction();\n          } else {\n            trace('Debounce is unlocked restarting timer', debounceTime);\n            wasLocked = false; // Unlock just happened, restart regular debounce\n\n            debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime);\n          }\n        } else {\n          trace('Debounce is locked', debounceTime);\n          wasLocked = true; // Locked, reset timer and check again after debounce\n\n          debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime);\n        }\n      } else {\n        // No extra lock, just do the action\n        doAction();\n      }\n    };\n\n    trace('New item added resetting timer', debounceTime, item);\n    debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime); // Return the \"shared\" promise\n\n    return deferred.promise;\n  };\n};\n\nexport { debouncePromise };\nexports = {\n  debouncePromise\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","AwTimeoutService","Debug","trace","exports","debouncePromise","methodToExecute","debounceTime","lock","deferred","debounceTimer","items","wasLocked","doAction","currentDefer","currentItems","item","instance","defer","cancel","push","timerComplete","isUnlocked","promise"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/async.service.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.async} which provides a set of utilities for handling async methods\n *\n * @module js/async.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwTimeoutService from 'js/awTimeoutService';\nimport Debug from 'debug';\n\nvar trace = new Debug( 'async' );\n\n/* eslint-disable-next-line valid-jsdoc*/\n\nlet exports = {};\n\n/**\n * Get an api capable of executing the given api async\n *\n * @param {Function<List<a>>} methodToExecute Method to call. Input will be a list of a where a is the input to the debounced method\n * @param {Number} debounceTime How long to debounce method calls\n * @param {Lock} lock A \"lock\" with a \"isUnlocked\" function. Allows external control of call on top of debounce\n * @returns {Function<a>} A debounced version of the method that supports individual calls\n */\nvar debouncePromise = function( methodToExecute, debounceTime, lock ) {\n    /**\n     * Promise tracking any currently active batch.\n     *\n     * Resolved once the method is actually executed.\n     */\n    var deferred = null;\n\n    /**\n     * The current active timer. If allowed to complete the method will be executed.\n     */\n    var debounceTimer = null;\n\n    /**\n     * Items to pass to the network\n     */\n    var items = [];\n\n    /**\n     * Flag tracking if the service was previously locked\n     */\n    var wasLocked = false;\n\n    /**\n     * Actually execute the action\n     *\n     * @returns {Promise} Promise resolved after execution\n     */\n    var doAction = function() {\n        // Clear the reference to current batch - set to null to prevent additions to current batch post timeout\n        var currentDefer = deferred;\n        var currentItems = items;\n        deferred = null;\n        items = [];\n        // Actually do the method\n        return methodToExecute( currentItems );\n    };\n\n    /**\n     * Add a new item to batch\n     *\n     * Returns a promise resolved when the method is actually executed.\n     *\n     * @param {a} item The item to add\n     * @returns {Promise} Promise resolved when action is actually executed\n     */\n    return function( item ) {\n        // If a batch is not already active create a new one\n        if( !deferred ) {\n            deferred = AwPromiseService.instance.defer();\n        }\n        // If the timer is running cancel it\n        if( debounceTimer ) {\n            AwTimeoutService.instance.cancel( debounceTimer );\n        }\n        // Add item to batch and start a new timer\n        items.push( item );\n        var timerComplete = function() {\n            if( lock ) {\n                if( lock.isUnlocked() ) {\n                    if( !wasLocked ) {\n                        trace( 'Debounce is unlocked doing action', debounceTime );\n                        // Debounce after unlock has finished, safe to do action\n                        doAction();\n                    } else {\n                        trace( 'Debounce is unlocked restarting timer', debounceTime );\n                        wasLocked = false;\n                        // Unlock just happened, restart regular debounce\n                        debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n                    }\n                } else {\n                    trace( 'Debounce is locked', debounceTime );\n                    wasLocked = true;\n                    // Locked, reset timer and check again after debounce\n                    debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n                }\n            } else {\n                // No extra lock, just do the action\n                doAction();\n            }\n        };\n        trace( 'New item added resetting timer', debounceTime, item );\n        debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n        // Return the \"shared\" promise\n        return deferred.promise;\n    };\n};\nexport { debouncePromise as debouncePromise };\n\nexports = {\n    debouncePromise\n};\nexport default exports;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAOA,gBAAP,MAA6B,qBAA7B;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AACA,OAAOC,KAAP,MAAkB,OAAlB;AAEA,IAAIC,KAAK,GAAG,IAAID,KAAJ,CAAW,OAAX,CAAZ;AAEA;;AAEA,IAAIE,OAAO,GAAG,EAAd;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,eAAe,GAAG,UAAUC,eAAV,EAA2BC,YAA3B,EAAyCC,IAAzC,EAAgD;EAClE;AACJ;AACA;AACA;AACA;EACI,IAAIC,QAAQ,GAAG,IAAf;EAEA;AACJ;AACA;;EACI,IAAIC,aAAa,GAAG,IAApB;EAEA;AACJ;AACA;;EACI,IAAIC,KAAK,GAAG,EAAZ;EAEA;AACJ;AACA;;EACI,IAAIC,SAAS,GAAG,KAAhB;EAEA;AACJ;AACA;AACA;AACA;;EACI,IAAIC,QAAQ,GAAG,YAAW;IACtB;IACA,IAAIC,YAAY,GAAGL,QAAnB;IACA,IAAIM,YAAY,GAAGJ,KAAnB;IACAF,QAAQ,GAAG,IAAX;IACAE,KAAK,GAAG,EAAR,CALsB,CAMtB;;IACA,OAAOL,eAAe,CAAES,YAAF,CAAtB;EACH,CARD;EAUA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,OAAO,UAAUC,IAAV,EAAiB;IACpB;IACA,IAAI,CAACP,QAAL,EAAgB;MACZA,QAAQ,GAAGT,gBAAgB,CAACiB,QAAjB,CAA0BC,KAA1B,EAAX;IACH,CAJmB,CAKpB;;;IACA,IAAIR,aAAJ,EAAoB;MAChBT,gBAAgB,CAACgB,QAAjB,CAA0BE,MAA1B,CAAkCT,aAAlC;IACH,CARmB,CASpB;;;IACAC,KAAK,CAACS,IAAN,CAAYJ,IAAZ;;IACA,IAAIK,aAAa,GAAG,YAAW;MAC3B,IAAIb,IAAJ,EAAW;QACP,IAAIA,IAAI,CAACc,UAAL,EAAJ,EAAwB;UACpB,IAAI,CAACV,SAAL,EAAiB;YACbT,KAAK,CAAE,mCAAF,EAAuCI,YAAvC,CAAL,CADa,CAEb;;YACAM,QAAQ;UACX,CAJD,MAIO;YACHV,KAAK,CAAE,uCAAF,EAA2CI,YAA3C,CAAL;YACAK,SAAS,GAAG,KAAZ,CAFG,CAGH;;YACAF,aAAa,GAAGT,gBAAgB,CAACgB,QAAjB,CAA2BI,aAA3B,EAA0Cd,YAA1C,CAAhB;UACH;QACJ,CAXD,MAWO;UACHJ,KAAK,CAAE,oBAAF,EAAwBI,YAAxB,CAAL;UACAK,SAAS,GAAG,IAAZ,CAFG,CAGH;;UACAF,aAAa,GAAGT,gBAAgB,CAACgB,QAAjB,CAA2BI,aAA3B,EAA0Cd,YAA1C,CAAhB;QACH;MACJ,CAlBD,MAkBO;QACH;QACAM,QAAQ;MACX;IACJ,CAvBD;;IAwBAV,KAAK,CAAE,gCAAF,EAAoCI,YAApC,EAAkDS,IAAlD,CAAL;IACAN,aAAa,GAAGT,gBAAgB,CAACgB,QAAjB,CAA2BI,aAA3B,EAA0Cd,YAA1C,CAAhB,CApCoB,CAqCpB;;IACA,OAAOE,QAAQ,CAACc,OAAhB;EACH,CAvCD;AAwCH,CAtFD;;AAuFA,SAASlB,eAAT;AAEAD,OAAO,GAAG;EACNC;AADM,CAAV;AAGA,eAAeD,OAAf"},"metadata":{},"sourceType":"module"}