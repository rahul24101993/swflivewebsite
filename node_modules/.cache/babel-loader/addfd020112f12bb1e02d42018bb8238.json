{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Fill Down Helper for listen hammer event and manipulate the table element\n *\n * @module js/splmTableFillDownHelper\n *\n * @publishedApolloService\n *\n */\nimport hammer from 'hammerjs';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n/**\n * Instances of this class represent a fill down helper for PL Table\n *\n * @class SPLMTableFillDownHelper\n * @param {Object} tableElem PL Table DOMElement\n */\n\nfunction SPLMTableFillDownHelper(tableElem) {\n  var self = this;\n\n  if (!browserUtils.isMobileOS) {\n    document.body.classList.add('nonTouch');\n  } // reference to the entire table visual tree element\n\n\n  delete self.tableContentElt; // element ref to the source cellTop\n\n  delete self.currentSrcCell; // get the bounding rectangle of the source cell\n\n  delete self.currentSrcCellRectangle; // currently registered event handler\n\n  delete self.currentPanHandler;\n  delete self.currentPanHandlerElement;\n  self.scrollDelta = 0; // currently doing a drag?\n\n  self.isActivelyDragging = false; // the cells within the current drag area; modified as the drag action is done\n\n  self.dragSelectedCells = []; // unhook the drag event hanlder, reset the drag state\n\n  self.removePanEvtHandler = function () {\n    if (self.currentPanHandler) {\n      self.currentPanHandler.off('panup pandown panend panstart pancancel', self.handleHammerCellDrag);\n    }\n\n    delete self.currentPanHandler;\n    self.isActivelyDragging = false;\n    delete self.currentPanHandlerElement;\n\n    if (self.currentSrcCell) {\n      self.currentSrcCell.classList.remove('dragSrc');\n    }\n  }; // pan in some direction. compute the drag coords, find the cells within it\n  // (includes the source and target cells), and style the cells appropriately\n  // to mark the drag area\n\n\n  self.handlePan = function (hEvt) {\n    // get all cells in this column - the attribute name must match the rendering code\n    var getAllColCells = function () {\n      return util.getColumnContentCellElementsByIndex(self.tableContentElt, self.targetColNumber);\n    };\n\n    var scrollAsNeeded = function (panEvent) {\n      // look at table height and offset to determine if we are near the top or bottom?\n      var tableScrollContentRenderer = util.getTableInstance(tableElem).renderer;\n      let currentViewPortBoundingClientRect = self.currentViewportElement.getBoundingClientRect();\n      var boundingTop = currentViewPortBoundingClientRect.top;\n      var boundingBottom = boundingTop + currentViewPortBoundingClientRect.height;\n\n      if (panEvent.srcEvent.pageY < boundingTop + 10) {\n        // scroll up logic\n        self.scrollDelta = tableScrollContentRenderer.manualScroll(false);\n        logger.debug(scroll, ' scroll up');\n      } else if (panEvent.srcEvent.pageY > boundingBottom - 10) {\n        // scroll down logic\n        self.scrollDelta = tableScrollContentRenderer.manualScroll(true);\n        logger.debug(scroll, ' scroll down');\n      }\n    };\n\n    var yDragTop;\n    var yDragBottom; // reset the array of cells in the drag area\n\n    self.dragSelectedCells = []; // which direction is the drag in?\n\n    let srcCellIndex = self.currentSrcCell.parentElement && parseInt(self.currentSrcCell.parentElement.getAttribute('aria-rowindex')) - 2 || 0;\n\n    if (hEvt.srcEvent.clientY + self.scrollDelta > self.currentSrcCellRectangle.top + self.initialScrollDelta + 1) {\n      // down\n      self.dragUp = false;\n      yDragTop = self.currentSrcCellRectangle.top - 1 + self.initialScrollDelta;\n      yDragBottom = hEvt.srcEvent.clientY + self.scrollDelta;\n    } else {\n      // up - swap for contains calculations\n      self.dragUp = true;\n      yDragTop = hEvt.srcEvent.clientY + self.scrollDelta;\n      yDragBottom = self.currentSrcCellRectangle.bottom + self.initialScrollDelta + 1;\n    } // check if the data is being virtualized, if so, adjust target area\n\n\n    var currentSrcCellProperty = util.getPropertyByCellElement(self.currentSrcCell);\n\n    if (self.srcUiVal !== currentSrcCellProperty.uiValue) {\n      if (self.dragUp) {\n        yDragBottom = 9999999;\n      } else {\n        yDragTop = 0;\n      }\n    }\n\n    let columnCells = getAllColCells();\n\n    for (let currentCell of columnCells) {\n      let currIndex = parseInt(currentCell.parentElement.getAttribute('aria-rowindex')) - 2; // -2 because rowindex for header is 1, first row is 2\n\n      let indexDelta = currIndex - srcCellIndex;\n      var currentCellTop = self.currentSrcCellRectangle.top + self.initialScrollDelta + (self.currentSrcCellRectangle.height + 1) * indexDelta;\n      let currentCellBottom = currentCellTop + self.currentSrcCellRectangle.height; // clear any previous styling\n\n      currentCell.classList.remove('dragCellTop');\n      currentCell.classList.remove('dragCell');\n      currentCell.classList.remove('dragCellBottom');\n      var yCell = currentCellTop; // y coord for this cell\n\n      if (self.dragUp === true) {\n        yCell = currentCellBottom;\n      } // compute whether or not this cell is in the drag area\n\n\n      if (yCell < yDragBottom && yCell >= yDragTop) {\n        // if ( hEvt.srcEvent.clientY > currentCellTop && hEvt.srcEvent.clientY < currentCellBottom ) {\n        // this element fits inside the selection rectangle\n        currentCell.classList.add('dragCell');\n        self.dragSelectedCells.push(currentCell);\n      }\n    } // decorate top and bottom cells specially\n\n\n    if (self.dragSelectedCells.length) {\n      self.dragSelectedCells[0].classList.add('dragCellTop');\n      self.dragSelectedCells[self.dragSelectedCells.length - 1].classList.add('dragCellBottom');\n    } // attempt to scroll the grid if we are dragging off\n\n\n    scrollAsNeeded(hEvt);\n  }; // the end pan/drag has been encountered - trigger the data processing\n  // based on the drag area boundary\n\n\n  self.handlePanEnd = function () {\n    // eslint-disable-line no-unused-vars\n    // check that we have more than just the source cell\n    if (self.dragSelectedCells.length > 1) {\n      var endTargetCell;\n      var direction;\n\n      if (self.dragUp) {\n        endTargetCell = self.dragSelectedCells[0];\n        direction = 'up';\n      } else {\n        endTargetCell = self.dragSelectedCells[self.dragSelectedCells.length - 1];\n        direction = 'down';\n      }\n\n      var endTargetProp = util.getPropertyByCellElement(endTargetCell); // iterate the target cells\n\n      for (var inx = 0; inx < self.dragSelectedCells.length; inx++) {\n        self.dragSelectedCells[inx].classList.remove('dragCellTop');\n        self.dragSelectedCells[inx].classList.remove('dragCell');\n        self.dragSelectedCells[inx].classList.remove('dragCellBottom');\n      } // for\n      // emit this fill-complete event to be handled by the tabled\n\n\n      var gridId = util.getTableInstance(tableElem).gridId;\n      let endTarget = endTargetProp.substituteParentUid || endTargetProp.parentUid;\n\n      if (!endTarget) {\n        var rowElement = util.closestElement(endTargetCell, '.' + Const.CLASS_ROW);\n        endTarget = rowElement.vmo.uid;\n      }\n\n      util.getTableInstance(tableElem).editor.fillDownCompleteHandler({\n        propertyName: self.propertyName,\n        source: self.srcUid,\n        endTarget: endTarget,\n        direction: direction\n      });\n    } // children > 1\n\n\n    self.scrollDelta = 0;\n    self.isActivelyDragging = false;\n    self.tableContentElt.classList.remove('aw-jswidgets-dragfilling');\n  };\n\n  self.handlePanCancel = function () {\n    self.removePanEvtHandler();\n  };\n\n  self.handlePanStart = function (hEvt) {\n    // starting pan...\n    self.dragUp = false;\n    self.isActivelyDragging = true;\n    const tableScrollContentRenderer = util.getTableInstance(tableElem).renderer;\n    self.initialScrollDelta = tableScrollContentRenderer.getScrollTop();\n    self.scrollDelta = self.initialScrollDelta; // the source cell for the fill\n\n    var srcCell = util.closestElement(hEvt.target, '.' + Const.CLASS_CELL);\n    self.currentSrcCell = srcCell;\n    self.currentSrcCellRectangle = self.currentSrcCell.getBoundingClientRect();\n    self.currentViewportElement = util.closestElement(self.currentSrcCell, '.' + Const.CLASS_VIEWPORT);\n    var property = util.getPropertyByCellElement(self.currentSrcCell);\n    self.srcUid = property.substituteParentUid || property.parentUid;\n\n    if (!self.srcUid) {\n      var rowElement = util.closestElement(self.currentSrcCell, '.' + Const.CLASS_ROW);\n      self.srcUid = rowElement.vmo.uid;\n    }\n\n    self.srcUiVal = property.uiValue;\n    self.propertyName = property.propertyName;\n    self.tableContentElt = util.closestElement(hEvt.target, '.' + Const.ELEMENT_TABLE); // table content area\n\n    self.currentSrcCell.classList.add('dragSrc');\n    self.tableContentElt.classList.add('aw-jswidgets-dragfilling');\n    self.targetColNumber = self.currentSrcCell.columnDef.index;\n  }; // function for handling the Pan/drag related events from hammer.\n  // account for all the Hammer event states\n\n\n  self.handleHammerCellDrag = function (hEvt) {\n    if (hEvt.type === 'panstart') {\n      self.handlePanStart(hEvt);\n    } else if (hEvt.type === 'panend') {\n      // ending pan\n      self.handlePanEnd();\n    } else if (hEvt.type === 'pancancel') {\n      // cancelling pan\n      self.handlePanCancel();\n    } else if (self.isActivelyDragging) {\n      // other event - actively dragging, so handle pan\n      self.handlePan(hEvt);\n    }\n  }; // this is triggered from the drag handle drag action on the directive.\n  // Determine if we need to setup the hammer pan/drag listener.\n  // Establish the drag start\n\n\n  self.initialize = function (event) {\n    // checking range...\n    if (!self.isActivelyDragging) {\n      event.preventDefault();\n\n      if (self.currentPanHandlerElement) {\n        if (self.currentPanHandlerElement !== event.target) {\n          // remove the old one\n          self.removePanEvtHandler();\n        }\n      }\n\n      if (!self.currentPanHandler) {\n        var hmrMgr = hammer(event.target, {\n          touchAction: 'pan-y'\n        }); // track the element that the hammer is using\n\n        self.currentPanHandlerElement = event.target;\n        var panRecognizer = hmrMgr.get('pan');\n        panRecognizer.set({\n          direction: hammer.DIRECTION_VERTICAL\n        }); // set options\n\n        hmrMgr.on('panup pandown panend panstart pancancel', self.handleHammerCellDrag); // panleft panright\n\n        self.currentPanHandler = hmrMgr;\n      } else if (self.currentPanHandlerElement) {\n        // existing handler, same element?\n        if (self.currentPanHandlerElement !== event.target) {\n          logger.warn('different event handler element - shouldnt be here ------------------');\n        }\n      }\n    }\n  };\n\n  return self;\n}\n\n_c = SPLMTableFillDownHelper;\nexport default SPLMTableFillDownHelper;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableFillDownHelper\");","map":{"version":3,"names":["hammer","browserUtils","logger","eventBus","Const","util","SPLMTableFillDownHelper","tableElem","self","isMobileOS","document","body","classList","add","tableContentElt","currentSrcCell","currentSrcCellRectangle","currentPanHandler","currentPanHandlerElement","scrollDelta","isActivelyDragging","dragSelectedCells","removePanEvtHandler","off","handleHammerCellDrag","remove","handlePan","hEvt","getAllColCells","getColumnContentCellElementsByIndex","targetColNumber","scrollAsNeeded","panEvent","tableScrollContentRenderer","getTableInstance","renderer","currentViewPortBoundingClientRect","currentViewportElement","getBoundingClientRect","boundingTop","top","boundingBottom","height","srcEvent","pageY","manualScroll","debug","scroll","yDragTop","yDragBottom","srcCellIndex","parentElement","parseInt","getAttribute","clientY","initialScrollDelta","dragUp","bottom","currentSrcCellProperty","getPropertyByCellElement","srcUiVal","uiValue","columnCells","currentCell","currIndex","indexDelta","currentCellTop","currentCellBottom","yCell","push","length","handlePanEnd","endTargetCell","direction","endTargetProp","inx","gridId","endTarget","substituteParentUid","parentUid","rowElement","closestElement","CLASS_ROW","vmo","uid","editor","fillDownCompleteHandler","propertyName","source","srcUid","handlePanCancel","handlePanStart","getScrollTop","srcCell","target","CLASS_CELL","CLASS_VIEWPORT","property","ELEMENT_TABLE","columnDef","index","type","initialize","event","preventDefault","hmrMgr","touchAction","panRecognizer","get","set","DIRECTION_VERTICAL","on","warn"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableFillDownHelper.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Fill Down Helper for listen hammer event and manipulate the table element\n *\n * @module js/splmTableFillDownHelper\n *\n * @publishedApolloService\n *\n */\nimport hammer from 'hammerjs';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n\n/**\n * Instances of this class represent a fill down helper for PL Table\n *\n * @class SPLMTableFillDownHelper\n * @param {Object} tableElem PL Table DOMElement\n */\nfunction SPLMTableFillDownHelper( tableElem ) {\n    var self = this;\n\n    if( !browserUtils.isMobileOS ) {\n        document.body.classList.add( 'nonTouch' );\n    }\n\n    // reference to the entire table visual tree element\n    delete self.tableContentElt;\n\n    // element ref to the source cellTop\n    delete self.currentSrcCell;\n    // get the bounding rectangle of the source cell\n    delete self.currentSrcCellRectangle;\n\n    // currently registered event handler\n    delete self.currentPanHandler;\n    delete self.currentPanHandlerElement;\n    self.scrollDelta = 0;\n\n    // currently doing a drag?\n    self.isActivelyDragging = false;\n\n    // the cells within the current drag area; modified as the drag action is done\n    self.dragSelectedCells = [];\n\n    // unhook the drag event hanlder, reset the drag state\n    self.removePanEvtHandler = function() {\n        if( self.currentPanHandler ) {\n            self.currentPanHandler.off( 'panup pandown panend panstart pancancel', self.handleHammerCellDrag );\n        }\n        delete self.currentPanHandler;\n        self.isActivelyDragging = false;\n        delete self.currentPanHandlerElement;\n        if( self.currentSrcCell ) {\n            self.currentSrcCell.classList.remove( 'dragSrc' );\n        }\n    };\n\n    // pan in some direction. compute the drag coords, find the cells within it\n    // (includes the source and target cells), and style the cells appropriately\n    // to mark the drag area\n    self.handlePan = function( hEvt ) {\n        // get all cells in this column - the attribute name must match the rendering code\n        var getAllColCells = function() {\n            return util.getColumnContentCellElementsByIndex( self.tableContentElt, self.targetColNumber );\n        };\n\n        var scrollAsNeeded = function( panEvent ) {\n            // look at table height and offset to determine if we are near the top or bottom?\n            var tableScrollContentRenderer = util.getTableInstance( tableElem ).renderer;\n            let currentViewPortBoundingClientRect = self.currentViewportElement.getBoundingClientRect();\n\n            var boundingTop = currentViewPortBoundingClientRect.top;\n            var boundingBottom = boundingTop + currentViewPortBoundingClientRect.height;\n\n            if( panEvent.srcEvent.pageY < boundingTop + 10 ) {\n                // scroll up logic\n                self.scrollDelta = tableScrollContentRenderer.manualScroll( false );\n                logger.debug( scroll, ' scroll up' );\n            } else if( panEvent.srcEvent.pageY > boundingBottom - 10 ) {\n                // scroll down logic\n                self.scrollDelta = tableScrollContentRenderer.manualScroll( true );\n                logger.debug( scroll, ' scroll down' );\n            }\n        };\n\n        var yDragTop;\n        var yDragBottom;\n\n        // reset the array of cells in the drag area\n        self.dragSelectedCells = [];\n\n        // which direction is the drag in?\n        let srcCellIndex = self.currentSrcCell.parentElement && parseInt( self.currentSrcCell.parentElement.getAttribute( 'aria-rowindex' ) ) - 2 || 0;\n\n        if( hEvt.srcEvent.clientY + self.scrollDelta > self.currentSrcCellRectangle.top + self.initialScrollDelta + 1 ) {\n            // down\n            self.dragUp = false;\n            yDragTop = self.currentSrcCellRectangle.top - 1 + self.initialScrollDelta;\n            yDragBottom = hEvt.srcEvent.clientY + self.scrollDelta;\n        } else {\n            // up - swap for contains calculations\n            self.dragUp = true;\n            yDragTop = hEvt.srcEvent.clientY + self.scrollDelta;\n            yDragBottom = self.currentSrcCellRectangle.bottom + self.initialScrollDelta + 1;\n        }\n\n        // check if the data is being virtualized, if so, adjust target area\n        var currentSrcCellProperty = util.getPropertyByCellElement( self.currentSrcCell );\n        if( self.srcUiVal !== currentSrcCellProperty.uiValue ) {\n            if( self.dragUp ) {\n                yDragBottom = 9999999;\n            } else {\n                yDragTop = 0;\n            }\n        }\n\n        let columnCells = getAllColCells();\n\n        for( let currentCell of columnCells ) {\n            let currIndex = parseInt( currentCell.parentElement.getAttribute( 'aria-rowindex' ) ) - 2; // -2 because rowindex for header is 1, first row is 2\n            let indexDelta = currIndex - srcCellIndex;\n            var currentCellTop = self.currentSrcCellRectangle.top + self.initialScrollDelta + ( self.currentSrcCellRectangle.height + 1 ) * indexDelta;\n            let currentCellBottom = currentCellTop + self.currentSrcCellRectangle.height;\n\n            // clear any previous styling\n            currentCell.classList.remove( 'dragCellTop' );\n            currentCell.classList.remove( 'dragCell' );\n            currentCell.classList.remove( 'dragCellBottom' );\n\n            var yCell = currentCellTop; // y coord for this cell\n            if( self.dragUp === true ) {\n                yCell = currentCellBottom;\n            }\n\n            // compute whether or not this cell is in the drag area\n            if( yCell < yDragBottom && yCell >= yDragTop ) {\n                // if ( hEvt.srcEvent.clientY > currentCellTop && hEvt.srcEvent.clientY < currentCellBottom ) {\n                // this element fits inside the selection rectangle\n                currentCell.classList.add( 'dragCell' );\n                self.dragSelectedCells.push( currentCell );\n            }\n        }\n\n        // decorate top and bottom cells specially\n        if( self.dragSelectedCells.length ) {\n            self.dragSelectedCells[ 0 ].classList.add( 'dragCellTop' );\n            self.dragSelectedCells[ self.dragSelectedCells.length - 1 ].classList.add( 'dragCellBottom' );\n        }\n\n        // attempt to scroll the grid if we are dragging off\n        scrollAsNeeded( hEvt );\n    };\n\n    // the end pan/drag has been encountered - trigger the data processing\n    // based on the drag area boundary\n    self.handlePanEnd = function() { // eslint-disable-line no-unused-vars\n        // check that we have more than just the source cell\n        if( self.dragSelectedCells.length > 1 ) {\n            var endTargetCell;\n            var direction;\n            if( self.dragUp ) {\n                endTargetCell = self.dragSelectedCells[ 0 ];\n                direction = 'up';\n            } else {\n                endTargetCell = self.dragSelectedCells[ self.dragSelectedCells.length - 1 ];\n                direction = 'down';\n            }\n            var endTargetProp = util.getPropertyByCellElement( endTargetCell );\n\n            // iterate the target cells\n            for( var inx = 0; inx < self.dragSelectedCells.length; inx++ ) {\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCellTop' );\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCell' );\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCellBottom' );\n            } // for\n\n            // emit this fill-complete event to be handled by the tabled\n            var gridId = util.getTableInstance( tableElem ).gridId;\n            let endTarget = endTargetProp.substituteParentUid || endTargetProp.parentUid;\n            if( !endTarget ) {\n                var rowElement = util.closestElement( endTargetCell, '.' + Const.CLASS_ROW );\n                endTarget = rowElement.vmo.uid;\n            }\n            util.getTableInstance( tableElem ).editor.fillDownCompleteHandler( {\n                propertyName: self.propertyName,\n                source: self.srcUid,\n                endTarget: endTarget,\n                direction: direction\n            } );\n        } // children > 1\n\n        self.scrollDelta = 0;\n        self.isActivelyDragging = false;\n        self.tableContentElt.classList.remove( 'aw-jswidgets-dragfilling' );\n    };\n\n    self.handlePanCancel = function() {\n        self.removePanEvtHandler();\n    };\n\n    self.handlePanStart = function( hEvt ) {\n        // starting pan...\n        self.dragUp = false;\n        self.isActivelyDragging = true;\n        const tableScrollContentRenderer = util.getTableInstance( tableElem ).renderer;\n        self.initialScrollDelta = tableScrollContentRenderer.getScrollTop();\n        self.scrollDelta = self.initialScrollDelta;\n\n        // the source cell for the fill\n        var srcCell = util.closestElement( hEvt.target, '.' + Const.CLASS_CELL );\n        self.currentSrcCell = srcCell;\n        self.currentSrcCellRectangle = self.currentSrcCell.getBoundingClientRect();\n        self.currentViewportElement = util.closestElement( self.currentSrcCell, '.' + Const.CLASS_VIEWPORT );\n\n        var property = util.getPropertyByCellElement( self.currentSrcCell );\n\n        self.srcUid = property.substituteParentUid || property.parentUid;\n        if( !self.srcUid ) {\n            var rowElement = util.closestElement( self.currentSrcCell, '.' + Const.CLASS_ROW );\n            self.srcUid = rowElement.vmo.uid;\n        }\n        self.srcUiVal = property.uiValue;\n        self.propertyName = property.propertyName;\n\n        self.tableContentElt = util.closestElement( hEvt.target, '.' + Const.ELEMENT_TABLE ); // table content area\n\n        self.currentSrcCell.classList.add( 'dragSrc' );\n\n        self.tableContentElt.classList.add( 'aw-jswidgets-dragfilling' );\n\n        self.targetColNumber = self.currentSrcCell.columnDef.index;\n    };\n\n    // function for handling the Pan/drag related events from hammer.\n    // account for all the Hammer event states\n    self.handleHammerCellDrag = function( hEvt ) {\n        if( hEvt.type === 'panstart' ) {\n            self.handlePanStart( hEvt );\n        } else if( hEvt.type === 'panend' ) {\n            // ending pan\n            self.handlePanEnd();\n        } else if( hEvt.type === 'pancancel' ) {\n            // cancelling pan\n            self.handlePanCancel();\n        } else if( self.isActivelyDragging ) {\n            // other event - actively dragging, so handle pan\n            self.handlePan( hEvt );\n        }\n    };\n\n    // this is triggered from the drag handle drag action on the directive.\n    // Determine if we need to setup the hammer pan/drag listener.\n    // Establish the drag start\n    self.initialize = function( event ) {\n        // checking range...\n        if( !self.isActivelyDragging ) {\n            event.preventDefault();\n\n            if( self.currentPanHandlerElement ) {\n                if( self.currentPanHandlerElement !== event.target ) {\n                    // remove the old one\n                    self.removePanEvtHandler();\n                }\n            }\n\n            if( !self.currentPanHandler ) {\n                var hmrMgr = hammer( event.target, {\n                    touchAction: 'pan-y'\n                } );\n\n                // track the element that the hammer is using\n                self.currentPanHandlerElement = event.target;\n\n                var panRecognizer = hmrMgr.get( 'pan' );\n\n                panRecognizer.set( {\n                    direction: hammer.DIRECTION_VERTICAL\n                } ); // set options\n\n                hmrMgr.on( 'panup pandown panend panstart pancancel', self.handleHammerCellDrag ); // panleft panright\n\n                self.currentPanHandler = hmrMgr;\n            } else if( self.currentPanHandlerElement ) {\n                // existing handler, same element?\n                if( self.currentPanHandlerElement !== event.target ) {\n                    logger.warn( 'different event handler element - shouldnt be here ------------------' );\n                }\n            }\n        }\n    };\n\n    return self;\n}\n\nexport default SPLMTableFillDownHelper;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAP,MAAmB,UAAnB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,KAAP,MAAkB,uBAAlB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,uBAAT,CAAkCC,SAAlC,EAA8C;EAC1C,IAAIC,IAAI,GAAG,IAAX;;EAEA,IAAI,CAACP,YAAY,CAACQ,UAAlB,EAA+B;IAC3BC,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBC,GAAxB,CAA6B,UAA7B;EACH,CALyC,CAO1C;;;EACA,OAAOL,IAAI,CAACM,eAAZ,CAR0C,CAU1C;;EACA,OAAON,IAAI,CAACO,cAAZ,CAX0C,CAY1C;;EACA,OAAOP,IAAI,CAACQ,uBAAZ,CAb0C,CAe1C;;EACA,OAAOR,IAAI,CAACS,iBAAZ;EACA,OAAOT,IAAI,CAACU,wBAAZ;EACAV,IAAI,CAACW,WAAL,GAAmB,CAAnB,CAlB0C,CAoB1C;;EACAX,IAAI,CAACY,kBAAL,GAA0B,KAA1B,CArB0C,CAuB1C;;EACAZ,IAAI,CAACa,iBAAL,GAAyB,EAAzB,CAxB0C,CA0B1C;;EACAb,IAAI,CAACc,mBAAL,GAA2B,YAAW;IAClC,IAAId,IAAI,CAACS,iBAAT,EAA6B;MACzBT,IAAI,CAACS,iBAAL,CAAuBM,GAAvB,CAA4B,yCAA5B,EAAuEf,IAAI,CAACgB,oBAA5E;IACH;;IACD,OAAOhB,IAAI,CAACS,iBAAZ;IACAT,IAAI,CAACY,kBAAL,GAA0B,KAA1B;IACA,OAAOZ,IAAI,CAACU,wBAAZ;;IACA,IAAIV,IAAI,CAACO,cAAT,EAA0B;MACtBP,IAAI,CAACO,cAAL,CAAoBH,SAApB,CAA8Ba,MAA9B,CAAsC,SAAtC;IACH;EACJ,CAVD,CA3B0C,CAuC1C;EACA;EACA;;;EACAjB,IAAI,CAACkB,SAAL,GAAiB,UAAUC,IAAV,EAAiB;IAC9B;IACA,IAAIC,cAAc,GAAG,YAAW;MAC5B,OAAOvB,IAAI,CAACwB,mCAAL,CAA0CrB,IAAI,CAACM,eAA/C,EAAgEN,IAAI,CAACsB,eAArE,CAAP;IACH,CAFD;;IAIA,IAAIC,cAAc,GAAG,UAAUC,QAAV,EAAqB;MACtC;MACA,IAAIC,0BAA0B,GAAG5B,IAAI,CAAC6B,gBAAL,CAAuB3B,SAAvB,EAAmC4B,QAApE;MACA,IAAIC,iCAAiC,GAAG5B,IAAI,CAAC6B,sBAAL,CAA4BC,qBAA5B,EAAxC;MAEA,IAAIC,WAAW,GAAGH,iCAAiC,CAACI,GAApD;MACA,IAAIC,cAAc,GAAGF,WAAW,GAAGH,iCAAiC,CAACM,MAArE;;MAEA,IAAIV,QAAQ,CAACW,QAAT,CAAkBC,KAAlB,GAA0BL,WAAW,GAAG,EAA5C,EAAiD;QAC7C;QACA/B,IAAI,CAACW,WAAL,GAAmBc,0BAA0B,CAACY,YAA3B,CAAyC,KAAzC,CAAnB;QACA3C,MAAM,CAAC4C,KAAP,CAAcC,MAAd,EAAsB,YAAtB;MACH,CAJD,MAIO,IAAIf,QAAQ,CAACW,QAAT,CAAkBC,KAAlB,GAA0BH,cAAc,GAAG,EAA/C,EAAoD;QACvD;QACAjC,IAAI,CAACW,WAAL,GAAmBc,0BAA0B,CAACY,YAA3B,CAAyC,IAAzC,CAAnB;QACA3C,MAAM,CAAC4C,KAAP,CAAcC,MAAd,EAAsB,cAAtB;MACH;IACJ,CAjBD;;IAmBA,IAAIC,QAAJ;IACA,IAAIC,WAAJ,CA1B8B,CA4B9B;;IACAzC,IAAI,CAACa,iBAAL,GAAyB,EAAzB,CA7B8B,CA+B9B;;IACA,IAAI6B,YAAY,GAAG1C,IAAI,CAACO,cAAL,CAAoBoC,aAApB,IAAqCC,QAAQ,CAAE5C,IAAI,CAACO,cAAL,CAAoBoC,aAApB,CAAkCE,YAAlC,CAAgD,eAAhD,CAAF,CAAR,GAAgF,CAArH,IAA0H,CAA7I;;IAEA,IAAI1B,IAAI,CAACgB,QAAL,CAAcW,OAAd,GAAwB9C,IAAI,CAACW,WAA7B,GAA2CX,IAAI,CAACQ,uBAAL,CAA6BwB,GAA7B,GAAmChC,IAAI,CAAC+C,kBAAxC,GAA6D,CAA5G,EAAgH;MAC5G;MACA/C,IAAI,CAACgD,MAAL,GAAc,KAAd;MACAR,QAAQ,GAAGxC,IAAI,CAACQ,uBAAL,CAA6BwB,GAA7B,GAAmC,CAAnC,GAAuChC,IAAI,CAAC+C,kBAAvD;MACAN,WAAW,GAAGtB,IAAI,CAACgB,QAAL,CAAcW,OAAd,GAAwB9C,IAAI,CAACW,WAA3C;IACH,CALD,MAKO;MACH;MACAX,IAAI,CAACgD,MAAL,GAAc,IAAd;MACAR,QAAQ,GAAGrB,IAAI,CAACgB,QAAL,CAAcW,OAAd,GAAwB9C,IAAI,CAACW,WAAxC;MACA8B,WAAW,GAAGzC,IAAI,CAACQ,uBAAL,CAA6ByC,MAA7B,GAAsCjD,IAAI,CAAC+C,kBAA3C,GAAgE,CAA9E;IACH,CA5C6B,CA8C9B;;;IACA,IAAIG,sBAAsB,GAAGrD,IAAI,CAACsD,wBAAL,CAA+BnD,IAAI,CAACO,cAApC,CAA7B;;IACA,IAAIP,IAAI,CAACoD,QAAL,KAAkBF,sBAAsB,CAACG,OAA7C,EAAuD;MACnD,IAAIrD,IAAI,CAACgD,MAAT,EAAkB;QACdP,WAAW,GAAG,OAAd;MACH,CAFD,MAEO;QACHD,QAAQ,GAAG,CAAX;MACH;IACJ;;IAED,IAAIc,WAAW,GAAGlC,cAAc,EAAhC;;IAEA,KAAK,IAAImC,WAAT,IAAwBD,WAAxB,EAAsC;MAClC,IAAIE,SAAS,GAAGZ,QAAQ,CAAEW,WAAW,CAACZ,aAAZ,CAA0BE,YAA1B,CAAwC,eAAxC,CAAF,CAAR,GAAwE,CAAxF,CADkC,CACyD;;MAC3F,IAAIY,UAAU,GAAGD,SAAS,GAAGd,YAA7B;MACA,IAAIgB,cAAc,GAAG1D,IAAI,CAACQ,uBAAL,CAA6BwB,GAA7B,GAAmChC,IAAI,CAAC+C,kBAAxC,GAA6D,CAAE/C,IAAI,CAACQ,uBAAL,CAA6B0B,MAA7B,GAAsC,CAAxC,IAA8CuB,UAAhI;MACA,IAAIE,iBAAiB,GAAGD,cAAc,GAAG1D,IAAI,CAACQ,uBAAL,CAA6B0B,MAAtE,CAJkC,CAMlC;;MACAqB,WAAW,CAACnD,SAAZ,CAAsBa,MAAtB,CAA8B,aAA9B;MACAsC,WAAW,CAACnD,SAAZ,CAAsBa,MAAtB,CAA8B,UAA9B;MACAsC,WAAW,CAACnD,SAAZ,CAAsBa,MAAtB,CAA8B,gBAA9B;MAEA,IAAI2C,KAAK,GAAGF,cAAZ,CAXkC,CAWN;;MAC5B,IAAI1D,IAAI,CAACgD,MAAL,KAAgB,IAApB,EAA2B;QACvBY,KAAK,GAAGD,iBAAR;MACH,CAdiC,CAgBlC;;;MACA,IAAIC,KAAK,GAAGnB,WAAR,IAAuBmB,KAAK,IAAIpB,QAApC,EAA+C;QAC3C;QACA;QACAe,WAAW,CAACnD,SAAZ,CAAsBC,GAAtB,CAA2B,UAA3B;QACAL,IAAI,CAACa,iBAAL,CAAuBgD,IAAvB,CAA6BN,WAA7B;MACH;IACJ,CAjF6B,CAmF9B;;;IACA,IAAIvD,IAAI,CAACa,iBAAL,CAAuBiD,MAA3B,EAAoC;MAChC9D,IAAI,CAACa,iBAAL,CAAwB,CAAxB,EAA4BT,SAA5B,CAAsCC,GAAtC,CAA2C,aAA3C;MACAL,IAAI,CAACa,iBAAL,CAAwBb,IAAI,CAACa,iBAAL,CAAuBiD,MAAvB,GAAgC,CAAxD,EAA4D1D,SAA5D,CAAsEC,GAAtE,CAA2E,gBAA3E;IACH,CAvF6B,CAyF9B;;;IACAkB,cAAc,CAAEJ,IAAF,CAAd;EACH,CA3FD,CA1C0C,CAuI1C;EACA;;;EACAnB,IAAI,CAAC+D,YAAL,GAAoB,YAAW;IAAE;IAC7B;IACA,IAAI/D,IAAI,CAACa,iBAAL,CAAuBiD,MAAvB,GAAgC,CAApC,EAAwC;MACpC,IAAIE,aAAJ;MACA,IAAIC,SAAJ;;MACA,IAAIjE,IAAI,CAACgD,MAAT,EAAkB;QACdgB,aAAa,GAAGhE,IAAI,CAACa,iBAAL,CAAwB,CAAxB,CAAhB;QACAoD,SAAS,GAAG,IAAZ;MACH,CAHD,MAGO;QACHD,aAAa,GAAGhE,IAAI,CAACa,iBAAL,CAAwBb,IAAI,CAACa,iBAAL,CAAuBiD,MAAvB,GAAgC,CAAxD,CAAhB;QACAG,SAAS,GAAG,MAAZ;MACH;;MACD,IAAIC,aAAa,GAAGrE,IAAI,CAACsD,wBAAL,CAA+Ba,aAA/B,CAApB,CAVoC,CAYpC;;MACA,KAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGnE,IAAI,CAACa,iBAAL,CAAuBiD,MAA/C,EAAuDK,GAAG,EAA1D,EAA+D;QAC3DnE,IAAI,CAACa,iBAAL,CAAwBsD,GAAxB,EAA8B/D,SAA9B,CAAwCa,MAAxC,CAAgD,aAAhD;QACAjB,IAAI,CAACa,iBAAL,CAAwBsD,GAAxB,EAA8B/D,SAA9B,CAAwCa,MAAxC,CAAgD,UAAhD;QACAjB,IAAI,CAACa,iBAAL,CAAwBsD,GAAxB,EAA8B/D,SAA9B,CAAwCa,MAAxC,CAAgD,gBAAhD;MACH,CAjBmC,CAiBlC;MAEF;;;MACA,IAAImD,MAAM,GAAGvE,IAAI,CAAC6B,gBAAL,CAAuB3B,SAAvB,EAAmCqE,MAAhD;MACA,IAAIC,SAAS,GAAGH,aAAa,CAACI,mBAAd,IAAqCJ,aAAa,CAACK,SAAnE;;MACA,IAAI,CAACF,SAAL,EAAiB;QACb,IAAIG,UAAU,GAAG3E,IAAI,CAAC4E,cAAL,CAAqBT,aAArB,EAAoC,MAAMpE,KAAK,CAAC8E,SAAhD,CAAjB;QACAL,SAAS,GAAGG,UAAU,CAACG,GAAX,CAAeC,GAA3B;MACH;;MACD/E,IAAI,CAAC6B,gBAAL,CAAuB3B,SAAvB,EAAmC8E,MAAnC,CAA0CC,uBAA1C,CAAmE;QAC/DC,YAAY,EAAE/E,IAAI,CAAC+E,YAD4C;QAE/DC,MAAM,EAAEhF,IAAI,CAACiF,MAFkD;QAG/DZ,SAAS,EAAEA,SAHoD;QAI/DJ,SAAS,EAAEA;MAJoD,CAAnE;IAMH,CAlC0B,CAkCzB;;;IAEFjE,IAAI,CAACW,WAAL,GAAmB,CAAnB;IACAX,IAAI,CAACY,kBAAL,GAA0B,KAA1B;IACAZ,IAAI,CAACM,eAAL,CAAqBF,SAArB,CAA+Ba,MAA/B,CAAuC,0BAAvC;EACH,CAvCD;;EAyCAjB,IAAI,CAACkF,eAAL,GAAuB,YAAW;IAC9BlF,IAAI,CAACc,mBAAL;EACH,CAFD;;EAIAd,IAAI,CAACmF,cAAL,GAAsB,UAAUhE,IAAV,EAAiB;IACnC;IACAnB,IAAI,CAACgD,MAAL,GAAc,KAAd;IACAhD,IAAI,CAACY,kBAAL,GAA0B,IAA1B;IACA,MAAMa,0BAA0B,GAAG5B,IAAI,CAAC6B,gBAAL,CAAuB3B,SAAvB,EAAmC4B,QAAtE;IACA3B,IAAI,CAAC+C,kBAAL,GAA0BtB,0BAA0B,CAAC2D,YAA3B,EAA1B;IACApF,IAAI,CAACW,WAAL,GAAmBX,IAAI,CAAC+C,kBAAxB,CANmC,CAQnC;;IACA,IAAIsC,OAAO,GAAGxF,IAAI,CAAC4E,cAAL,CAAqBtD,IAAI,CAACmE,MAA1B,EAAkC,MAAM1F,KAAK,CAAC2F,UAA9C,CAAd;IACAvF,IAAI,CAACO,cAAL,GAAsB8E,OAAtB;IACArF,IAAI,CAACQ,uBAAL,GAA+BR,IAAI,CAACO,cAAL,CAAoBuB,qBAApB,EAA/B;IACA9B,IAAI,CAAC6B,sBAAL,GAA8BhC,IAAI,CAAC4E,cAAL,CAAqBzE,IAAI,CAACO,cAA1B,EAA0C,MAAMX,KAAK,CAAC4F,cAAtD,CAA9B;IAEA,IAAIC,QAAQ,GAAG5F,IAAI,CAACsD,wBAAL,CAA+BnD,IAAI,CAACO,cAApC,CAAf;IAEAP,IAAI,CAACiF,MAAL,GAAcQ,QAAQ,CAACnB,mBAAT,IAAgCmB,QAAQ,CAAClB,SAAvD;;IACA,IAAI,CAACvE,IAAI,CAACiF,MAAV,EAAmB;MACf,IAAIT,UAAU,GAAG3E,IAAI,CAAC4E,cAAL,CAAqBzE,IAAI,CAACO,cAA1B,EAA0C,MAAMX,KAAK,CAAC8E,SAAtD,CAAjB;MACA1E,IAAI,CAACiF,MAAL,GAAcT,UAAU,CAACG,GAAX,CAAeC,GAA7B;IACH;;IACD5E,IAAI,CAACoD,QAAL,GAAgBqC,QAAQ,CAACpC,OAAzB;IACArD,IAAI,CAAC+E,YAAL,GAAoBU,QAAQ,CAACV,YAA7B;IAEA/E,IAAI,CAACM,eAAL,GAAuBT,IAAI,CAAC4E,cAAL,CAAqBtD,IAAI,CAACmE,MAA1B,EAAkC,MAAM1F,KAAK,CAAC8F,aAA9C,CAAvB,CAxBmC,CAwBmD;;IAEtF1F,IAAI,CAACO,cAAL,CAAoBH,SAApB,CAA8BC,GAA9B,CAAmC,SAAnC;IAEAL,IAAI,CAACM,eAAL,CAAqBF,SAArB,CAA+BC,GAA/B,CAAoC,0BAApC;IAEAL,IAAI,CAACsB,eAAL,GAAuBtB,IAAI,CAACO,cAAL,CAAoBoF,SAApB,CAA8BC,KAArD;EACH,CA/BD,CAtL0C,CAuN1C;EACA;;;EACA5F,IAAI,CAACgB,oBAAL,GAA4B,UAAUG,IAAV,EAAiB;IACzC,IAAIA,IAAI,CAAC0E,IAAL,KAAc,UAAlB,EAA+B;MAC3B7F,IAAI,CAACmF,cAAL,CAAqBhE,IAArB;IACH,CAFD,MAEO,IAAIA,IAAI,CAAC0E,IAAL,KAAc,QAAlB,EAA6B;MAChC;MACA7F,IAAI,CAAC+D,YAAL;IACH,CAHM,MAGA,IAAI5C,IAAI,CAAC0E,IAAL,KAAc,WAAlB,EAAgC;MACnC;MACA7F,IAAI,CAACkF,eAAL;IACH,CAHM,MAGA,IAAIlF,IAAI,CAACY,kBAAT,EAA8B;MACjC;MACAZ,IAAI,CAACkB,SAAL,CAAgBC,IAAhB;IACH;EACJ,CAbD,CAzN0C,CAwO1C;EACA;EACA;;;EACAnB,IAAI,CAAC8F,UAAL,GAAkB,UAAUC,KAAV,EAAkB;IAChC;IACA,IAAI,CAAC/F,IAAI,CAACY,kBAAV,EAA+B;MAC3BmF,KAAK,CAACC,cAAN;;MAEA,IAAIhG,IAAI,CAACU,wBAAT,EAAoC;QAChC,IAAIV,IAAI,CAACU,wBAAL,KAAkCqF,KAAK,CAACT,MAA5C,EAAqD;UACjD;UACAtF,IAAI,CAACc,mBAAL;QACH;MACJ;;MAED,IAAI,CAACd,IAAI,CAACS,iBAAV,EAA8B;QAC1B,IAAIwF,MAAM,GAAGzG,MAAM,CAAEuG,KAAK,CAACT,MAAR,EAAgB;UAC/BY,WAAW,EAAE;QADkB,CAAhB,CAAnB,CAD0B,CAK1B;;QACAlG,IAAI,CAACU,wBAAL,GAAgCqF,KAAK,CAACT,MAAtC;QAEA,IAAIa,aAAa,GAAGF,MAAM,CAACG,GAAP,CAAY,KAAZ,CAApB;QAEAD,aAAa,CAACE,GAAd,CAAmB;UACfpC,SAAS,EAAEzE,MAAM,CAAC8G;QADH,CAAnB,EAV0B,CAYrB;;QAELL,MAAM,CAACM,EAAP,CAAW,yCAAX,EAAsDvG,IAAI,CAACgB,oBAA3D,EAd0B,CAcyD;;QAEnFhB,IAAI,CAACS,iBAAL,GAAyBwF,MAAzB;MACH,CAjBD,MAiBO,IAAIjG,IAAI,CAACU,wBAAT,EAAoC;QACvC;QACA,IAAIV,IAAI,CAACU,wBAAL,KAAkCqF,KAAK,CAACT,MAA5C,EAAqD;UACjD5F,MAAM,CAAC8G,IAAP,CAAa,uEAAb;QACH;MACJ;IACJ;EACJ,CApCD;;EAsCA,OAAOxG,IAAP;AACH;;KAlRQF,uB;AAoRT,eAAeA,uBAAf"},"metadata":{},"sourceType":"module"}