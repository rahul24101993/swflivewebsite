{"ast":null,"code":"/* eslint-disable max-lines */\n// Copyright (c) 2022 Siemens\n\n/**\n * This service is used for splm table as Dom Controller, play table row/cell instead of DOM Structure\n *\n * @module js/splmTableDomController\n *\n * DOM Structure\n * <aw-splm-table>\n *   CLASS_TABLE|aw-splm-table\n *     CLASS_TABLE_CONTAINER|aw-splm-tableContainer\n *       CLASS_COLUMN_RESIZE_GRIP|aw-splm-tableColumnResizeGrip -> grip for resize\n *       CLASS_PIN_CONTAINER|aw-splm-tablePinnedContainer\n *           CLASS_HEADER_ROW|aw-splm-tableHeaderRow\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *               CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *               CLASS_CELL|ui-grid-cell\n *       CLASS_SCROLL_CONTAINER|aw-splm-tableScrollContainer\n *           CLASS_HEADER_ROW|ui-grid-header-cell-row\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *                 CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *             CLASS_CELL|ui-grid-cell\n *     CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *       CLASS_TABLE_MENU|aw-splm-tableMenu\n *\n *\n * CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *   CLASS_TABLE_MENU|aw-splm-tableMenu\n *     CLASS_TABLE_MENU_ITEM|aw-splm-tableMenuItem\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableColumnResizer from 'js/splmTableColumnResizer';\nimport awEventHelperService from 'js/awEventHelperService';\nimport wcagService from 'js/wcagService';\nimport appCtxSvc from 'js/appCtxService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport Cell from 'js/splmTableCellRenderer'; // Bootstrap for _t to make coding pattern consistent\n\n/**\n * Instances of this class represent a column resizer for PL Table\n *\n * @class SimpleTableDomController\n * @param {DOMElement} tableElem - HTML DOM Element for table\n * @param {Array} columnDefs - Array of Column Definitions\n */\n\nvar SPLMTableDomController = function (tableElem, columnDefs, tableEditor, gridContextDispatcher) {\n  // Class definition   //Dummy comment\n  var self = this;\n  var _table = tableElem;\n\n  var _trv = new Trv(tableElem);\n\n  var _menuService = util.getTableMenuService(tableElem);\n\n  var _columnDefs = columnDefs;\n  var _tableInstance = tableElem._tableInstance;\n  var _keyboardService = _tableInstance.keyboardService;\n  var _grip = null; // Pin/freeze context\n\n  var _pinColumnCount = 0;\n  var _pinContainerWidth = 0;\n  var _scrollContainerWidth = 0;\n  var _alignContainersForCheckbox = false;\n  var _scrollColumnsInView = {\n    start: null,\n    end: null\n  };\n  const ariaColIndex = 'aria-colindex';\n  const ariaRowIndex = 'aria-rowindex';\n  const ariaRowCount = 'aria-rowcount';\n  const dataIndexNumber = 'data-indexnumber'; // ////////////////////////////////////////////////\n  // Internal\n  // ////////////////////////////////////////////////\n\n  var _getSortClassName = function (sortType) {\n    if (typeof sortType === 'string') {\n      sortType = sortType.toUpperCase();\n\n      if (sortType === 'ASC') {\n        return Const.CLASS_ICON_SORT_ASC;\n      } else if (sortType === 'DESC') {\n        return Const.CLASS_ICON_SORT_DESC;\n      } else if (sortType === '') {\n        return Const.CLASS_ICON_SORTABLE;\n      }\n    }\n\n    return Const.CLASS_ICON_NON_SORTABLE;\n  };\n\n  self.setPinContext = function (lastPinIndex) {\n    // Get the right most pinnedLeft option then set pinCount\n    if (lastPinIndex !== undefined && lastPinIndex !== null) {\n      _pinColumnCount = lastPinIndex + 1;\n    } else {\n      var rightMostPinIdx = -1;\n\n      _.forEach(_columnDefs, function (column, idx) {\n        if (column.pinnedLeft === true) {\n          rightMostPinIdx = idx;\n        }\n      }); // _pinColumnCount will be greater than zero if any column is pinned or frozen by the user.\n      // We should not reset this value if it is greater than zero.\n\n\n      if (_pinColumnCount === 0) {\n        _pinColumnCount = rightMostPinIdx + 1;\n      }\n    }\n\n    _pinContainerWidth = 0;\n    _scrollContainerWidth = 0;\n\n    for (var i = 0; i < _columnDefs.length; i++) {\n      if (i < _pinColumnCount) {\n        _columnDefs[i].pinnedLeft = true;\n        _columnDefs[i].startPosition = _pinContainerWidth;\n        _pinContainerWidth += _columnDefs[i].drawnWidth;\n      } else {\n        _columnDefs[i].pinnedLeft = false;\n        _columnDefs[i].startPosition = _scrollContainerWidth;\n        _scrollContainerWidth += _columnDefs[i].drawnWidth;\n      }\n    }\n  };\n  /**\n   * @memberOf js/splmTableDomController\n   *\n   * Get pin column count in the table\n   *\n   * @return {Number} pin column count in the table\n   */\n\n\n  self.getPinColumnCount = function () {\n    return _pinColumnCount;\n  };\n  /**\n   * New design decided in 20180724:\n   *   1. If width=<number>, we use it.\n   *   2. If width = *, we make it as minWidth + 25%* minWidth.\n   *   3. If minWidth + 25% > maxWidth, use maxWidth.\n   *   4. Don't use ui-grid column splitter design, put the splitter at the right side of the\n   *      column. Adapt CSS properly\n   *\n   * For the issue we faced in real autoWidth design:\n   *   1. Horizontal Scroll bar will appear/disappear randomly when sum(cellWidth) == canvasWidth.\n   *      - This should be resolved by new design but will rehearsal if it is not.\n   *\n   *   2. The listener for resize when autoWidth exist.\n   *      - This is not needed for new design.\n   */\n\n\n  self.initializeColumnWidths = function () {\n    _.forEach(_columnDefs, function (column) {\n      var width = 0;\n\n      if (column.name === 'icon') {\n        width = util.getTableRowHeight(_tableInstance.gridOptions, Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH);\n\n        if (width !== Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH) {\n          /** We have some pedding in icon rendering column and to render the complete icon, we need to\n           increase width of icon renderer by 8 units **/\n          width += 8;\n        }\n      } else if (column.width > 0) {\n        width = column.width;\n      } else {\n        width = column.minWidth > 0 ? column.minWidth : Const.WIDTH_DEFAULT_MINIMUM_WIDTH;\n        width = Math.floor(1.25 * width);\n        width = column.maxWidth > 0 && column.maxWidth < width ? column.maxWidth : width;\n      }\n\n      column.width = width;\n      column.drawnWidth = width;\n    });\n  }; // set aria-colcount to a number of columns which are visible in the DOM\n\n\n  self.setAriaColCount = function (tableContainer, columns) {\n    if (columns !== undefined) {\n      var tableCols = columns;\n      var visibleCols = tableCols.filter(column => column.visible !== undefined && column.visible);\n      var visibleColsLength = visibleCols.length;\n      tableContainer.setAttribute('aria-colcount', visibleColsLength);\n    } else {\n      tableContainer.setAttribute('aria-colcount', -1);\n    }\n  }; // set aria-colcount to a number of columns which are visible in the DOM\n\n\n  self.setAriaRowCount = function (tableContainer) {\n    if (_tableInstance.gridOptions.transpose === true) {\n      var tableCols = _tableInstance.dataProvider.cols;\n      var visibleCols = tableCols.filter(column => column.visible !== undefined && column.visible);\n      tableContainer.setAttribute(ariaRowCount, visibleCols.length + 1);\n    } else {\n      if (_tableInstance.dataProvider.json && _tableInstance.dataProvider.json.firstPage && _tableInstance.dataProvider.action && _tableInstance.dataProvider.action.inputData.searchInput) {\n        tableContainer.setAttribute(ariaRowCount, _tableInstance.dataProvider.json.firstPage.length + 1);\n      } else {\n        if (_tableInstance.dataProvider.viewModelCollection && _tableInstance.dataProvider.viewModelCollection.loadedVMObjects) {\n          tableContainer.setAttribute(ariaRowCount, _tableInstance.dataProvider.viewModelCollection.loadedVMObjects.length + 1);\n        } else {\n          tableContainer.setAttribute(ariaRowCount, -1);\n        }\n      }\n    }\n  }; // set describedby and aria-labelledby to a caption or label element id which labels or describes the table\n\n\n  self.setAriaLabelledAndDescribedBy = function (directiveElement, tableContainer) {\n    if (directiveElement) {\n      if (directiveElement.getAttribute('labelled-by')) {\n        tableContainer.setAttribute('aria-labelledby', directiveElement.getAttribute('labelled-by'));\n      }\n\n      if (directiveElement.getAttribute('described-by')) {\n        tableContainer.setAttribute('aria-describedby', directiveElement.getAttribute('described-by'));\n      }\n    }\n  }; // Scroll content width must be at least 1px to ensure pin/scroll syncing keeps working\n  // when there are no columns in either of the containers\n\n\n  var _setScrollContentMinWidth = function (scrollContentElement, width) {\n    var adjustedWidth = width > 0 ? width : 1;\n    scrollContentElement.style.minWidth = adjustedWidth + 'px';\n  };\n\n  var _setPinHeaderWidth = function (width) {\n    var headerElem = _trv.getPinHeaderElementFromTable();\n\n    var pinContentElem = _trv.getPinContentElementFromTable();\n\n    headerElem.style.minWidth = String(width) + 'px';\n\n    _setScrollContentMinWidth(pinContentElem, width);\n  };\n\n  var _setScrollHeaderWidth = function (width) {\n    var headerElem = _trv.getScrollHeaderElementFromTable();\n\n    var scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    headerElem.style.minWidth = String(width) + 'px';\n    var scrollContentMinWidth = parseInt(width, 10) - parseInt(scrollContentElem.style.paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth);\n  };\n\n  var _setHeaderColumnWidth = function (columnIdx, width) {\n    var headerCellElem = _trv.getHeaderCellElementFromTable(columnIdx); // update current cell width\n\n\n    headerCellElem.style.width = String(width) + 'px';\n  };\n\n  var _setContentRowWidth = function (rowElem, width) {\n    rowElem.style.minWidth = String(width) + 'px';\n  };\n\n  var _getContentRowCount = function () {\n    var _length = 0;\n\n    var rows = _trv.getScrollContentRowElementsFromTable();\n\n    if (rows) {\n      _length = rows.length;\n    }\n\n    return _length;\n  };\n\n  var _setContentColumnWidth = function (columnIdx, width) {\n    var rowCnt = _getContentRowCount();\n\n    for (var i = 0; i < rowCnt; i++) {\n      var rowCellElem = _trv.getContentCellFromTable(i, columnIdx);\n\n      var prevWidth = self.getColumnWidth(columnIdx);\n\n      if (columnIdx < _pinColumnCount) {\n        var pinRowElem = _trv.getPinContentRowElementFromTable(i);\n\n        _setContentRowWidth(pinRowElem, _pinContainerWidth + width - prevWidth);\n      } else {\n        var scrollRowElem = _trv.getScrollContentRowElementFromTable(i);\n\n        _setContentRowWidth(scrollRowElem, _scrollContainerWidth + width - prevWidth);\n      }\n\n      rowCellElem.style.width = String(width) + 'px';\n    }\n  };\n  /**\n   * Set the class and title for the filter icon element.\n   *\n   * @param {HTMLElement} iconElement - Filter icon element\n   * @param {Object} filter - filter object from column\n   */\n\n\n  var _applyFilterIcon = function (iconElement, filter) {\n    iconElement.classList.add(Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON);\n    iconElement.title = filter.summaryText;\n  };\n  /**\n   * Set the class and title for the filter icon element.\n   *\n   * @param {Object} column - the column\n   * @param {number} columnIndex - the column index\n   * @param {string} sortDirection - the sort direction\n   * @param {number} startPosition - the start position of the column\n   *\n   * @return {HTMLElement} - the header container\n   */\n\n\n  const _buildHeaderCellContainer = function (column, columnIndex, sortDirection, startPosition) {\n    //Header cell container\n    let headerContainer = document.createElement('div');\n    headerContainer.classList.add(Const.CLASS_HEADER_CELL);\n    headerContainer.tabIndex = -1;\n\n    _keyboardService.setOnFocusAndBlur(headerContainer);\n\n    headerContainer.setAttribute('role', 'columnheader');\n    headerContainer.setAttribute(ariaColIndex, columnIndex + 1); // Check whatever for column selection, and select if needed\n    //Column Def Anchor\n\n    let columnDefElem = document.createElement('div');\n    columnDefElem.classList.add(Const.CLASS_COLUMN_DEF);\n    columnDefElem.classList.add(Const.CLASS_CELL_CONTENTS);\n    columnDefElem.classList.add(Const.CLASS_HEADER_CLEARFIX);\n    columnDefElem.classList.add(Const.CLASS_HEADER_CELL_CONTENT);\n    columnDefElem.style.width = String(column.drawnWidth) + 'px';\n    columnDefElem.columnDef = column; // Enable column selection when click on the header element in transpose mode\n\n    if (_tableInstance.gridOptions.transpose === true) {\n      columnDefElem.onclick = SelectionHelper.selectionChanged(_table);\n    }\n\n    if (column.headerTooltip !== false && column.headerTooltip === true) {\n      columnDefElem.title = column.displayName;\n    }\n\n    headerContainer.appendChild(columnDefElem); // Splitter for resize\n    // Firefox limitation: element must be appended on left if it has 'float:right'\n\n    let resizeElem = document.createElement('div');\n    resizeElem.classList.add(Const.CLASS_HEADER_CELL_SPLITTER);\n\n    if (column.enableColumnResizing) {\n      headerContainer.insertBefore(resizeElem, columnDefElem);\n      splmTableColumnResizer.applyColumnResizeHandler(self, resizeElem, _menuService); //last prop = _menu\n    } //Create Inner element\n\n\n    let innerElem = Cell.createHeaderElement(column, tableElem);\n    innerElem.classList.add(Const.CLASS_HEADER_CELL_INNER);\n    columnDefElem.appendChild(innerElem); //Create Sort element\n\n    let sortElem = document.createElement('i');\n    sortElem.classList.add(Const.CLASS_HEADER_CELL_SORT_ICON);\n    sortElem.classList.add(_getSortClassName(sortDirection));\n    sortElem.title = '';\n    columnDefElem.appendChild(sortElem);\n    let sortDir;\n\n    if (sortDirection !== null && sortDirection !== '') {\n      // aria-sort supported sort values are ascending, descending, none and other.\n      sortDir = sortDirection.toLowerCase().includes('desc') ? 'descending' : 'ascending';\n      headerContainer.setAttribute('aria-sort', sortDir);\n    } //Create Filter element\n\n\n    let filterElem = document.createElement('i');\n    filterElem.classList.add(Const.CLASS_HEADER_CELL_FILTER_ICON);\n\n    if (column.filter && column.filter.isFilterApplied) {\n      _applyFilterIcon(filterElem, column.filter);\n    } else {\n      filterElem.title = '';\n    }\n\n    columnDefElem.appendChild(filterElem);\n\n    if (column.enableColumnMenu === true) {\n      const openMenuEvent = event => {\n        if (gridContextDispatcher) {\n          let currentColumnIndex = -1;\n\n          if (_tableInstance.columnProvider.sortCriteria && _tableInstance.columnProvider.sortCriteria.length > 0) {\n            var sortCriteria = _tableInstance.columnProvider.sortCriteria[0];\n            currentColumnIndex = self.getIdxFromColumnName(sortCriteria.fieldName);\n          }\n\n          gridContextDispatcher({\n            type: 'UPDATE_VALUES',\n            columnDef: columnDefElem.columnDef,\n            currentColumnIndex: currentColumnIndex,\n            pinColumnCount: _pinColumnCount,\n            isBulkEditing: util.isBulkEditing(_table)\n          });\n        }\n\n        _menuService.columnMenuHandler(columnDefElem, gridContextDispatcher)(event);\n      };\n\n      columnDefElem.classList.add(Const.CLASS_COLUMN_MENU_ENABLED);\n      columnDefElem.setAttribute('role', 'button');\n      columnDefElem.setAttribute('aria-haspopup', 'true');\n      columnDefElem.addEventListener('click', event => {\n        openMenuEvent(event);\n      });\n      headerContainer.addEventListener('keydown', function (event) {\n        if (wcagService.isValidKeyPress(event)) {\n          openMenuEvent(event);\n        }\n      });\n    }\n\n    column.startPosition = startPosition;\n    return headerContainer;\n  };\n\n  var _insertColumnHeaders = function (headerElement, startIdx, endIdx) {\n    let columnDefs = _columnDefs;\n    let totalColumnHeaderWidth = 0; //only add role=row if we are sure role=columnheader will be added as its descendents else it will cause aria-required-children violation.\n\n    if (startIdx < endIdx) {\n      headerElement.setAttribute('role', 'row'); //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n\n      headerElement.setAttribute(ariaRowIndex, 1);\n    }\n\n    for (let idx = startIdx; idx < endIdx; idx++) {\n      let column = columnDefs[idx];\n      let sortDirection = null;\n\n      if (_tableInstance.gridOptions.enableSorting !== false && column.enableSorting) {\n        if (column.sort && column.sort.direction) {\n          sortDirection = column.sort.direction;\n        } else {\n          sortDirection = '';\n        }\n      }\n\n      const headerContainer = _buildHeaderCellContainer(column, idx, sortDirection, totalColumnHeaderWidth);\n\n      totalColumnHeaderWidth += column.drawnWidth; //Add header container to header element\n\n      headerElement.appendChild(headerContainer);\n    }\n\n    let headerHeight = util.getTableHeaderHeight(_tableInstance.gridOptions, Const.HEIGHT_HEADER) + 'px';\n    headerElement.style.height = headerHeight;\n    headerElement.style.minHeight = headerHeight;\n    headerElement.style.maxHeight = headerHeight;\n    headerElement.style.minWidth = String(totalColumnHeaderWidth) + 'px';\n  };\n\n  var _createGrip = function () {\n    _grip = document.createElement('div');\n\n    _grip.classList.add(Const.CLASS_COLUMN_RESIZE_GRIP);\n\n    _grip.style.position = 'absolute';\n    _grip.style.height = '100%'; // Try to make border in the middle\n\n    var subGrip = document.createElement('div');\n    subGrip.style.borderLeft = '1px solid';\n    subGrip.style.marginLeft = '30px';\n    subGrip.style.height = '100%';\n\n    _grip.appendChild(subGrip);\n\n    _grip.style.zIndex = '1000';\n    _grip.style.cursor = 'col-resize';\n    _grip.style.outline = '20px transparent';\n    _grip.style.width = '60px';\n    _grip.style.display = 'none';\n    return _grip;\n  };\n\n  var removeHoverClassFromRows = function () {\n    var rows = _trv.getTableContainerElementFromTable().getElementsByClassName('ui-grid-row');\n\n    for (var i = 0; i < rows.length; i++) {\n      rows[i].classList.remove(Const.CLASS_ROW_HOVER);\n    }\n  };\n\n  var removeHoverClassesRaf = function () {\n    requestAnimationFrame(function () {\n      removeHoverClassFromRows();\n    });\n  };\n\n  var _constructTableElement = function () {\n    var columnDefs = _columnDefs; // Table Container\n\n    var tableContainer = document.createElement('div');\n    tableContainer.classList.add(Const.CLASS_TABLE_CONTAINER);\n    tableContainer.tabIndex = 0;\n\n    if (_tableInstance.gridOptions.useTree === true) {\n      tableContainer.setAttribute('role', 'treegrid');\n    } else {\n      tableContainer.setAttribute('role', 'grid');\n    }\n\n    if (_tableInstance.dataProvider.selectionModel.mode === 'multiple') {\n      tableContainer.setAttribute('aria-multiselectable', 'true');\n    } else {\n      tableContainer.setAttribute('aria-multiselectable', 'false');\n    }\n\n    if (_tableInstance.gridOptions.enableCellHeaderSelection === true) {\n      tableContainer.classList.add(Const.CLASS_HEADER_SELECTION_ENABLED);\n    }\n\n    self.setAriaRowCount(tableContainer);\n    self.setAriaColCount(tableContainer, _tableInstance.dataProvider.cols);\n\n    _table.appendChild(tableContainer);\n\n    self.initializeColumnWidths(); // Do pin initialization after eval column width so we could\n    // Dummy Comment\n    // collect container size together\n\n    self.setPinContext(); // Create dragging grip.\n\n    tableContainer.appendChild(_createGrip());\n    var pinContainer = document.createElement('div');\n    pinContainer.classList.add(Const.CLASS_PIN_CONTAINER);\n    pinContainer.classList.add(Const.CLASS_PIN_CONTAINER_LEFT);\n\n    if (_tableInstance.gridOptions.transpose === true) {\n      pinContainer.classList.add(Const.CLASS_COMPARE_CONTAINER);\n    }\n\n    var pinHeaderElem = document.createElement('div');\n    pinHeaderElem.classList.add(Const.CLASS_HEADER_ROW);\n\n    _insertColumnHeaders(pinHeaderElem, 0, _pinColumnCount);\n\n    pinContainer.appendChild(pinHeaderElem);\n    var pinScrollContainer = document.createElement('div');\n    pinScrollContainer.classList.add(Const.CLASS_CANVAS);\n    pinScrollContainer.classList.add(Const.CLASS_VIEWPORT);\n    var pinScrollContents = document.createElement('div');\n    pinScrollContents.addEventListener('mouseleave', function () {\n      removeHoverClassesRaf();\n    });\n    pinScrollContents.classList.add(Const.CLASS_SCROLL_CONTENTS);\n\n    _setScrollContentMinWidth(pinScrollContents, parseInt(pinHeaderElem.style.minWidth, 10));\n\n    pinScrollContainer.appendChild(pinScrollContents);\n    pinContainer.appendChild(pinScrollContainer);\n    tableContainer.appendChild(pinContainer);\n    var scrollContainer = document.createElement('div');\n    scrollContainer.classList.add(Const.CLASS_SCROLL_CONTAINER);\n    scrollContainer.style.marginLeft = String(_pinContainerWidth) + 'px'; // Create Columns in memory\n\n    var scrollHeaderElem = document.createElement('div');\n    scrollHeaderElem.classList.add(Const.CLASS_HEADER_ROW);\n\n    _insertColumnHeaders(scrollHeaderElem, _pinColumnCount, columnDefs.length);\n\n    scrollContainer.appendChild(scrollHeaderElem); // Create row Contents in memory\n\n    var rowsContainer = document.createElement('div');\n    rowsContainer.classList.add(Const.CLASS_VIEWPORT);\n    rowsContainer.classList.add(Const.CLASS_CANVAS);\n    var scrollContents = document.createElement('div');\n    scrollContents.addEventListener('mouseleave', function () {\n      removeHoverClassesRaf();\n    });\n    scrollContents.classList.add(Const.CLASS_SCROLL_CONTENTS);\n\n    _setScrollContentMinWidth(scrollContents, parseInt(scrollHeaderElem.style.minWidth, 10));\n\n    rowsContainer.appendChild(scrollContents);\n    scrollContainer.appendChild(rowsContainer);\n    tableContainer.appendChild(scrollContainer);\n  };\n  /**\n   * @memberOf js/aw-splm-table.directive\n   *\n   * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n   * and the given column (columnInfo )\n   * @param {Object} column - Declarative columnInfo object\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   * @param {Number} columnWidth - Width of the iconCellColumn\n   * @param {HTMLElement} rowElem - row DOMElement\n   * @return {HTMLElement} The newly created DOMElement for the property cell\n   */\n\n\n  const _createPropertyCell = function (column, vmo, columnWidth, rowElem) {\n    const cell = util.createElement('div', Const.CLASS_CELL);\n    cell.tabIndex = -1;\n\n    if (_tableInstance.dynamicRowHeightStatus) {\n      cell.classList.add(Const.CLASS_CELL_DYNAMIC);\n    }\n\n    if (column.colSelected) {\n      cell.classList.add(Const.CLASS_COLUMN_SELECTED);\n      cell.classList.add(Const.CLASS_CELL_SELECTED);\n    }\n\n    const defaultRowHeight = appCtxSvc.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n    const rowHeight = util.getTableRowHeight(_tableInstance.gridOptions, defaultRowHeight);\n    cell.style.width = `${columnWidth}px`;\n    cell.style.height = _tableInstance.dynamicRowHeightStatus ? 'auto' : rowHeight + 'px';\n    cell.appendChild(Cell.createElement(column, vmo, tableElem, rowElem));\n\n    if (column.field === 'transposedColumnProperty') {\n      cell.setAttribute('role', 'rowheader');\n    } else {\n      cell.setAttribute('role', 'gridcell');\n    }\n\n    cell.propName = column.field;\n    cell.columnDef = column;\n\n    if (vmo.props) {\n      cell.prop = vmo.props[column.field];\n    }\n\n    const cellTops = cell.getElementsByClassName('aw-splm-tableCellTop');\n\n    if (cellTops.length > 0) {\n      util.addCSSClassForRowHeight(cellTops[0], _tableInstance.gridOptions);\n    }\n\n    const idxNum = document.createAttribute(dataIndexNumber);\n    idxNum.value = column.index;\n\n    if (column.index >= _pinColumnCount) {\n      idxNum.value = column.index - _pinColumnCount;\n    }\n\n    cell.setAttributeNode(idxNum); // aria-colindex always starts with index 1.\n\n    cell.setAttribute(ariaColIndex, column.index + 1); // Set click listener for cell to get editable states\n\n    tableEditor.addCellClickListener(cell, vmo);\n\n    _keyboardService.setOnFocusAndBlur(cell);\n\n    _keyboardService.setupInternalCellNavigation(cell);\n\n    return cell;\n  };\n  /**\n   * Adds the aria attributes for tree if the row is part of a tree table\n   * @param {HTMLElement} row - the row element\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   */\n\n\n  const _setAriaAttributesForTreeRow = function (row, vmo) {\n    if (_tableInstance.gridOptions.useTree === true) {\n      if (vmo.isLeaf === false) {\n        if (vmo.isExpanded === true) {\n          row.setAttribute('aria-expanded', 'true');\n        } else {\n          row.setAttribute('aria-expanded', 'false');\n        }\n      } // aria-level starts from index 1.\n\n\n      row.setAttribute('aria-level', vmo.levelNdx + 1);\n    }\n  };\n  /**\n   * Adds the mouseenter event listener to apply hover styling to the row.\n   * @param {HTMLElement} row - the row element\n   */\n\n\n  const _addRowHoverListener = function (row) {\n    row.addEventListener('mouseenter', function (event) {\n      const hoveredRow = event.currentTarget;\n      requestAnimationFrame(function () {\n        removeHoverClassFromRows();\n        const index = util.getIndexInParent(hoveredRow);\n\n        const scrollRow = _trv.getScrollContentRowElementFromTable(index);\n\n        const pinRow = _trv.getPinContentRowElementFromTable(index);\n\n        scrollRow.classList.add(Const.CLASS_ROW_HOVER);\n        pinRow.classList.add(Const.CLASS_ROW_HOVER);\n      });\n    });\n  };\n  /**\n   * Adds the selection checkbox to the row\n   * @param {HTMLElement} row - the row element\n   * @param {HTMLElement} tableElem - the table element\n   * @param {Object[]} columnDefs - array of column defs\n   */\n\n\n  const _addRowCheckBox = function (row, tableElem, columnDefs) {\n    // var commandBarHtml =\n    // <div class=\"aw-splm-tableCheckBoxPresent\">\n    //   <a class=\"aw-commands-cellCommandCommon\">\n    //     <span class=\"sw-checkbox-val\">\n    //       <input class=\"sw-property-val\" type=\"checkbox\">\n    //       <span class=\"sw-checkbox-pseudo\"></span>\n    //     </span>\n    //   </a>\n    // </div>\n    let checkBox = util.createElement('div', Const.CLASS_CELL_CHECKBOX);\n    let wrapperAElement = util.createElement('a', 'aw-commands-cellCommandCommon');\n    let wrapperCheckboxDiv = util.createElement('span', 'sw-checkbox-val');\n    let inputElement = util.createElement('input', Const.CLASS_CELL_CHECKBOX_BUTTON);\n    let checkboxTypeAttr = document.createAttribute('type');\n    checkboxTypeAttr.value = 'checkbox';\n    inputElement.setAttributeNode(checkboxTypeAttr);\n    let commandDef = columnDefs.filter(function (def) {\n      if (def.isTableCommand || def.isTreeNavigation) {\n        return true;\n      }\n\n      return false;\n    })[0];\n    let propName = commandDef && (commandDef.propertyName || commandDef.name);\n\n    if (propName && row.vmo && row.vmo.props && row.vmo.props[propName]) {\n      let value = row.vmo.props[propName].uiValue;\n      let checkboxLabelAttr = document.createAttribute('aria-label');\n      checkboxLabelAttr.value = value;\n      inputElement.setAttributeNode(checkboxLabelAttr);\n    }\n\n    let spanCheckboxStyle = document.createElement('span');\n    spanCheckboxStyle.classList.add('sw-checkbox-pseudo'); // Do we really need this intermediate span? Commenting for now. Will remove once all table related auto tests pass\n    // var spanCheckElem = document.createElement( 'span' );\n    // spanCheckElem.classList.add( 'check' );\n    // spanCheckboxStyle.appendChild( spanCheckElem );\n\n    wrapperCheckboxDiv.appendChild(inputElement);\n    wrapperCheckboxDiv.appendChild(spanCheckboxStyle);\n    wrapperAElement.appendChild(wrapperCheckboxDiv);\n    checkBox.appendChild(wrapperAElement); // We should not need following lines. Commenting for now. Will remove once all table related auto tests pass\n    // var cellScope = {};\n    // var checkBox = util.createNgElement( commandBarHtml, tableElem, cellScope );\n\n    row.appendChild(checkBox);\n  };\n  /**\n   * Creates and returns a DOMElement for the TableRow of the passed in view model object (vmo) which defines the row\n   * Will Create cells for each column using the vmo properties associated by propertyName.  Also will prepend an\n   * iconCell at the beginning of the row.  Appropriate rowSelection callback will be added too.\n   * @param {Object} vmo - Declarative view model object (e.g. row)\n   * @param {number} rowHeight - the pixel row height\n   * @param {number} startIdx - the column start index\n   * @param {number} endIdx - the column end index\n   *\n   * @return {HTMLElement} row - the created row element\n   */\n\n\n  const _createContentRowElement = function (vmo, rowHeight, startIdx, endIdx) {\n    const columnDefs = _columnDefs;\n    const row = util.createElement('div', Const.CLASS_ROW, Const.CLASS_UI_GRID_ROW, Const.CLASS_ROW_ICON);\n    let rowWidth = 0;\n    row.vmo = vmo; //only add role=row if we are sure role=gridcell or role=rowheader will be added as its descendents else it will cause aria-required-children violation.\n\n    if (startIdx <= endIdx) {\n      row.setAttribute('role', 'row');\n    }\n\n    _setAriaAttributesForTreeRow(row, vmo); // LCS-286849 - jQuery has issues with handling touch to click events on mobile\n\n\n    let target = {\n      default: row,\n      mobile: row\n    };\n    let eventObject = {\n      click: 'touchend'\n    };\n    awEventHelperService.subscribeMouseEvent(target, eventObject, SelectionHelper.selectionChanged(_table));\n    row.oncontextmenu = _menuService.contextSelectionHandler;\n    row.draggable = true;\n\n    _addRowHoverListener(row);\n\n    if (vmo.rowStatus && vmo.rowStatus === 'ADDED') {\n      row.classList.add('aw-jswidgets-change');\n    } else if (vmo.rowStatus && vmo.rowStatus === 'REMOVED') {\n      row.classList.add('aw-jswidgets-oldText');\n    }\n\n    let adjustedColumnDefs = _.sortBy(columnDefs, function (columnDef) {\n      return columnDef.index;\n    });\n\n    _.forEach(adjustedColumnDefs, function (currentColumn) {\n      if (row.vmo.props && row.vmo.props[currentColumn.field]) {\n        row.vmo.props[currentColumn.field].renderingHint = currentColumn.renderingHint;\n      }\n    });\n\n    for (let i = startIdx; i <= endIdx; i++) {\n      const column = adjustedColumnDefs[i];\n      let cell = null;\n      let _width = column.drawnWidth;\n      const showCheckBox = _tableInstance.showCheckBox;\n\n      if (i === 0 && showCheckBox) {\n        _addRowCheckBox(row, tableElem, adjustedColumnDefs);\n      }\n\n      cell = _createPropertyCell(column, vmo, _width, row);\n      rowWidth += _width;\n      row.appendChild(cell);\n    }\n\n    row.style.minWidth = String(rowWidth) + 'px';\n    row.style.minHeight = String(rowHeight) + 'px';\n    return row;\n  };\n  /**\n   * Remove the class and title from the filter icon element.\n   *\n   * @param {HTMLElement} iconElement - Filter icon element\n   */\n\n\n  const _removeFilterIcon = function (iconElement) {\n    iconElement.classList.remove(Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON);\n    iconElement.title = '';\n  };\n\n  self.updateScrollColumnsInView = function (scrollLeft, scrollContainerWidth) {\n    var headerCells = _trv.getScrollHeaderElementFromTable().children; // Find start and end visible columns\n\n\n    var extraColumns = 3;\n    var start = null;\n    var end = null;\n    var totalHeaderCells = headerCells.length; // Return all columns as in view if container width given is null or undefined\n\n    if (scrollContainerWidth === null || scrollContainerWidth === undefined || scrollContainerWidth === 0) {\n      _scrollColumnsInView = {\n        start: 0,\n        end: totalHeaderCells - 1\n      };\n      return;\n    }\n\n    for (var i = 0; i < totalHeaderCells; i++) {\n      var column = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var columnStartPosition = column.startPosition;\n\n      if (columnStartPosition <= scrollLeft) {\n        start = i;\n      }\n\n      if (columnStartPosition <= scrollLeft + scrollContainerWidth) {\n        end = i;\n      }\n    }\n\n    start = start - extraColumns < 0 ? 0 : start - extraColumns;\n    end = end + extraColumns > totalHeaderCells - 1 ? totalHeaderCells - 1 : end + extraColumns;\n    _scrollColumnsInView = {\n      start: start,\n      end: end\n    };\n  };\n\n  self.updateVisibleCells = function (rowParentElem) {\n    const startColumnIdx = _scrollColumnsInView.start;\n    const endColumnIdx = _scrollColumnsInView.end;\n    rowParentElem = rowParentElem.childNodes;\n\n    const scrollHeader = _trv.getScrollHeaderElementFromTable();\n\n    const scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    const headerCells = scrollHeader.children;\n    let minWidth = 0;\n\n    for (let i = startColumnIdx; i < headerCells.length; i++) {\n      const column = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n\n      if (startColumnIdx !== null) {\n        minWidth += column.drawnWidth;\n      }\n    }\n\n    let paddingLeft = null;\n    const scrollHeaderElemMinWidth = scrollHeader.style.minWidth;\n\n    if (startColumnIdx > 0) {\n      const paddingLeftColumnDef = headerCells[startColumnIdx - 1].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      paddingLeft = paddingLeftColumnDef.startPosition + paddingLeftColumnDef.drawnWidth + 'px';\n    } else {\n      paddingLeft = '0px';\n    }\n\n    scrollContentElem.style.paddingLeft = paddingLeft;\n    const scrollContentMinWidth = parseInt(scrollHeaderElemMinWidth, 10) - parseInt(paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth); // Update cell visibility\n\n\n    const scrollRows = rowParentElem;\n\n    for (let j = 0; j < scrollRows.length; j++) {\n      const rowCells = scrollRows[j].children;\n\n      if (rowCells.length === 0) {\n        continue;\n      }\n\n      const row = scrollRows[j];\n      row.style.minWidth = minWidth + 'px';\n      const currentStartIndex = rowCells[0].columnDef.index;\n      const currentEndIndex = rowCells[rowCells.length - 1].columnDef.index;\n      const trueStartColumnIndex = startColumnIdx + _pinColumnCount;\n      const trueEndColumnIndex = endColumnIdx + _pinColumnCount;\n\n      for (let k = rowCells.length - 1; k >= 0; k--) {\n        const cell = rowCells[k];\n        const colIndex = cell.columnDef.index; // Remove out of view cells\n\n        if (colIndex < trueStartColumnIndex || colIndex > trueEndColumnIndex) {\n          util.destroyChildElements(cell);\n          cell.parentElement.removeChild(cell);\n        }\n      }\n\n      for (let l = currentStartIndex - 1; l >= trueStartColumnIndex; l--) {\n        const newCellInsertBefore = _createPropertyCell(_columnDefs[l], row.vmo, _columnDefs[l].drawnWidth, row);\n\n        row.insertBefore(newCellInsertBefore, row.children[0]);\n        tableEditor.updateEditStatusForCell(newCellInsertBefore);\n      }\n\n      for (let m = currentEndIndex + 1; m <= trueEndColumnIndex; m++) {\n        const newCellInsertAfter = _createPropertyCell(_columnDefs[m], row.vmo, _columnDefs[m].drawnWidth, row);\n\n        row.appendChild(newCellInsertAfter);\n        tableEditor.updateEditStatusForCell(newCellInsertAfter);\n      }\n    }\n  }; // LCS-323044 - IE11 - aw-splm-table ascending and descending icon not showing\n  // IE lacks support for multiple arguments in classlist.remove - https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n\n\n  const _removeAllSortDirectionClasses = function (sortElement) {\n    sortElement.classList.remove(Const.CLASS_ICON_SORT_ASC);\n    sortElement.classList.remove(Const.CLASS_ICON_SORT_DESC);\n    sortElement.classList.remove(Const.CLASS_ICON_NON_SORTABLE);\n    sortElement.classList.remove(Const.CLASS_ICON_SORTABLE);\n  }; // ////////////////////////////////////////////////\n  // Public method\n  // ////////////////////////////////////////////////\n\n\n  self.getColumnMinWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].minWidth;\n  };\n\n  self.getColumnMaxWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].maxWidth;\n  };\n\n  self.getColumnWidth = function (columnIdx) {\n    return _columnDefs[columnIdx].drawnWidth;\n  };\n\n  const updateColumnStartPositions = function () {\n    let pinContainerWidth = 0;\n    let scrollContainerWidth = 0;\n\n    for (let i = 0; i < _columnDefs.length; i++) {\n      if (i < _pinColumnCount) {\n        _columnDefs[i].startPosition = pinContainerWidth;\n        pinContainerWidth += _columnDefs[i].drawnWidth;\n      } else {\n        _columnDefs[i].startPosition = scrollContainerWidth;\n        scrollContainerWidth += _columnDefs[i].drawnWidth;\n      }\n    }\n  };\n  /**\n   * @memberOf js/splmTableDomController\n   *\n   * This method is used for updating the column width\n   * This method is also called from resetColumnDefs with 0,0 arguments which needs to be corrected.\n   * @param {Number} columnIdx - column index\n   * @param {Number} deltaWidth - delta width\n   */\n\n\n  self.updateColumnWidth = function (columnIdx, deltaWidth) {\n    let width = self.getColumnWidth(columnIdx) + deltaWidth;\n\n    _setHeaderColumnWidth(columnIdx, width);\n\n    _setContentColumnWidth(columnIdx, width);\n\n    if (columnIdx < _pinColumnCount) {\n      // Set container\n      _pinContainerWidth += deltaWidth;\n\n      _setPinHeaderWidth(_pinContainerWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n    } else {\n      // Set container\n      _scrollContainerWidth += deltaWidth;\n\n      _setScrollHeaderWidth(_scrollContainerWidth);\n    } // Update columnDef start positions\n\n\n    if (deltaWidth !== 0) {\n      _columnDefs[columnIdx].drawnWidth = width;\n\n      _tableInstance.tableInstanceCallbacks.columnsResized({\n        name: _columnDefs[columnIdx].name,\n        delta: deltaWidth\n      });\n    }\n\n    updateColumnStartPositions();\n\n    let scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth);\n\n    if (deltaWidth !== 0) {\n      self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n    }\n  };\n  /**\n   * Update the filter icon for the header of the column name given.\n   *\n   * @param {String} columnName - column name for the header to update\n   */\n\n\n  self.updateFilterIcon = function (columnName) {\n    var headerCells = _trv.getHeaderCellElementsFromTable();\n\n    for (var i = 0; i < headerCells.length; i++) {\n      var columnDef = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var filterIconElement = headerCells[i].getElementsByClassName(Const.CLASS_HEADER_CELL_FILTER_ICON)[0];\n\n      if (columnDef && columnDef.filter && filterIconElement && columnDef.field === columnName) {\n        if (columnDef.filter.isFilterApplied) {\n          _applyFilterIcon(filterIconElement, columnDef.filter);\n        } else {\n          _removeFilterIcon(filterIconElement);\n        }\n\n        break;\n      }\n    }\n  };\n  /**\n   * Update the filter icon for all column headers.\n   */\n\n\n  self.updateAllFilterIcons = function () {\n    var headerCells = _trv.getHeaderCellElementsFromTable();\n\n    for (var i = 0; i < headerCells.length; i++) {\n      var columnDef = headerCells[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n      var filterIconElement = headerCells[i].getElementsByClassName(Const.CLASS_HEADER_CELL_FILTER_ICON)[0];\n\n      if (columnDef && columnDef.filter && filterIconElement) {\n        if (columnDef.filter.isFilterApplied) {\n          _applyFilterIcon(filterIconElement, columnDef.filter);\n        } else {\n          _removeFilterIcon(filterIconElement);\n        }\n      }\n    }\n  };\n  /**\n   * Fit column width with content in canvas\n   * NOTE: This mentod will read computed CSS which may cause reflow\n   *\n   * @param {Number} columnIdx - Last column index.\n   *\n   */\n\n\n  self.fitColumnWidth = function (columnIdx) {\n    var treeNavigation = _columnDefs[columnIdx].isTreeNavigation;\n\n    var cellElems = _trv.queryRowColumnCellElementsFromTable(columnIdx);\n\n    var maxWidth = 0;\n\n    var headerTextElement = _trv.getHeaderCellElementFromTable(columnIdx).getElementsByClassName(Const.CLASS_HEADER_CELL_INNER)[0];\n\n    maxWidth = util.getElementTextWidth(headerTextElement);\n    var filterOption = _tableInstance.gridOptions.isFilteringEnabled;\n    var sortOption = _tableInstance.gridOptions.enableSorting; // This is the space occupied after the column name which includes column menu, splitter, resizeGrip etc.\n\n    if (filterOption || sortOption) {\n      maxWidth += Const.WIDTH_MINIMUM_EXTRA_SPACE;\n    }\n\n    cellElems.forEach(function (cellElem) {\n      var actualWidth; // Tree navigation cell\n\n      if (treeNavigation) {\n        // pass entire cellElem into getCellTextWidth because it calculates\n        // What the width of an unobstructed element with height and width set to auto will be\n        // This will give width of entire cell up until the end of the text for tree nav cells\n        actualWidth = util.getElementTextWidth(cellElem);\n        maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n      } else {\n        // cover text and link for now.\n        var valueElems = cellElem.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT);\n\n        if (valueElems.length === 0) {\n          valueElems = cellElem.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n        }\n\n        for (var i = 0; i < valueElems.length; i++) {\n          actualWidth = util.getElementTextWidth(valueElems[i]);\n          maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n        }\n      }\n    });\n\n    if (maxWidth > 0) {\n      var currentWidth = self.getColumnWidth(columnIdx);\n      var validWidth = self.getValidColumnWidth(columnIdx, maxWidth);\n\n      if (currentWidth !== validWidth) {\n        self.updateColumnWidth(columnIdx, validWidth - currentWidth);\n      }\n    }\n  };\n  /**\n   * Update column visibility for hidden columns\n   *\n   * @param {String} columnName - column name\n   */\n\n\n  self.updateColumnVisibility = function (columnName) {\n    var adjustedColumnIdx = self.getIdxFromColumnName(columnName); // Remove hidden column header from DOM\n\n    var headerCellElem = _trv.getHeaderCellElementFromTable(adjustedColumnIdx);\n\n    if (headerCellElem && headerCellElem.parentElement) {\n      headerCellElem.parentElement.removeChild(headerCellElem);\n    } // Remove hidden column rows from DOM\n\n\n    var rowCount = _getContentRowCount();\n\n    for (var i = 0; i < rowCount; i++) {\n      var rowCellElem = _trv.getContentCellFromTable(i, adjustedColumnIdx);\n\n      if (rowCellElem && rowCellElem.parentElement) {\n        rowCellElem.parentElement.removeChild(rowCellElem);\n      }\n    }\n\n    _columnDefs[adjustedColumnIdx].visible = false;\n\n    _columnDefs.splice(adjustedColumnIdx, 1); // Adjust column indices to account for removed column\n\n\n    _.forEach(_columnDefs, function (columnDef, index) {\n      columnDef.index = index;\n    });\n\n    self.resetColumnDefs(_columnDefs);\n\n    var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n  };\n\n  var _updateCellColumnIndexes = function () {\n    var cellElements = _trv.getContentCellElementsFromTable();\n\n    for (var i = 0; i < cellElements.length; i++) {\n      var cellElement = cellElements[i];\n      var column = cellElement.columnDef;\n      var idxNum = document.createAttribute(dataIndexNumber);\n      idxNum.value = column.index;\n\n      if (column.index >= _pinColumnCount) {\n        idxNum.value = column.index - _pinColumnCount;\n      }\n\n      cellElement.setAttributeNode(idxNum);\n      updateColumnStartPositions();\n    }\n  };\n\n  var _pinHeader = function (columnIdx) {\n    // Check existing column index\n    var newPinCount = columnIdx + 1;\n    var oldPinCount = _pinColumnCount; // Update Existing DOM\n\n    var headerCellElements = _trv.getHeaderCellElementsFromTable();\n\n    var moveFragment = document.createDocumentFragment();\n    var deltaWidth = 0;\n\n    if (oldPinCount < newPinCount) {\n      // Update Header\n      for (var i = oldPinCount; i < newPinCount; i++) {\n        moveFragment.appendChild(headerCellElements[oldPinCount]);\n        deltaWidth += self.getColumnWidth(i);\n      }\n\n      var pinHeaderElem = _trv.queryPinContainerFromTable().toHeader().getElement();\n\n      pinHeaderElem.appendChild(moveFragment);\n\n      _setPinHeaderWidth(_pinContainerWidth + deltaWidth);\n\n      _setScrollHeaderWidth(_scrollContainerWidth - deltaWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth + deltaWidth) + 'px';\n    } else if (oldPinCount > newPinCount) {\n      // Update Header\n      for (var j = newPinCount; j < oldPinCount; j++) {\n        moveFragment.appendChild(headerCellElements[newPinCount]);\n        deltaWidth += self.getColumnWidth(j);\n      }\n\n      var scrollHeaderElem = _trv.queryScrollContainerFromTable().toHeader().getElement();\n\n      scrollHeaderElem.insertBefore(moveFragment, scrollHeaderElem.childNodes[0]);\n\n      _setPinHeaderWidth(_pinContainerWidth - deltaWidth);\n\n      _setScrollHeaderWidth(_scrollContainerWidth + deltaWidth);\n\n      _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth - deltaWidth) + 'px';\n    }\n  };\n\n  var _pinContent = function (columnIdx) {\n    // Check existing column index\n    var newPinCount = columnIdx + 1;\n    var oldPinCount = _pinColumnCount; // Update Existing DOM\n\n    var moveFragment = document.createDocumentFragment();\n\n    var pinContentRowElements = _trv.queryPinContainerFromTable().getContentRowElements();\n\n    var scrollContentRowElements = _trv.queryScrollContainerFromTable().getContentRowElements();\n\n    var count = pinContentRowElements.length;\n    var deltaWidth = 0;\n\n    if (oldPinCount < newPinCount) {\n      for (var i = 0; i < count; i++) {\n        deltaWidth = 0;\n\n        for (var j = oldPinCount; j < newPinCount; j++) {\n          moveFragment.appendChild(scrollContentRowElements[i].children[0]);\n          deltaWidth += self.getColumnWidth(j);\n        }\n\n        pinContentRowElements[i].appendChild(moveFragment);\n\n        _setContentRowWidth(pinContentRowElements[i], _pinContainerWidth + deltaWidth);\n\n        _setContentRowWidth(scrollContentRowElements[i], _scrollContainerWidth - deltaWidth);\n      }\n    } else if (oldPinCount > newPinCount) {\n      for (var k = 0; k < count; k++) {\n        deltaWidth = 0;\n\n        for (var l = newPinCount; l < oldPinCount; l++) {\n          moveFragment.appendChild(pinContentRowElements[k].children[newPinCount]);\n          deltaWidth += self.getColumnWidth(l);\n        }\n\n        scrollContentRowElements[k].insertBefore(moveFragment, scrollContentRowElements[k].childNodes[0]);\n\n        _setContentRowWidth(pinContentRowElements[k], _pinContainerWidth - deltaWidth);\n\n        _setContentRowWidth(scrollContentRowElements[k], _scrollContainerWidth + deltaWidth);\n      }\n    }\n  };\n  /**\n   * Pin the table from column 0 to specific column\n   *\n   * @param {Number} columnIdx - Last column index.\n   *\n   */\n\n\n  self.pinToColumn = function (columnIdx) {\n    // Bring back all cells that were virtualized before moving cells to proper container\n    var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n\n    _pinHeader(columnIdx);\n\n    _pinContent(columnIdx);\n\n    self.setPinContext(columnIdx);\n    let colDef = _columnDefs[columnIdx];\n\n    let pinCanvasElement = _trv.getPinCanvasElementFromTable();\n\n    pinCanvasElement.scrollLeft = colDef.startPosition;\n    let traversalTable = new Trv(_table);\n    util.syncHeader(traversalTable, true, pinCanvasElement.scrollLeft);\n\n    _updateCellColumnIndexes(); // Virtualize cells\n\n\n    self.updateScrollColumnsInView(scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth);\n    self.updateVisibleCells(_trv.getScrollContentElementFromTable());\n  };\n\n  self.resetFreezeScroll = function (columnField) {\n    let startPosition = 0;\n\n    if (_columnDefs && _columnDefs.length) {\n      for (var i = 0; i < _columnDefs.length; i++) {\n        if (_columnDefs[i].field === columnField) {\n          startPosition = _columnDefs[i].startPosition;\n        }\n      }\n    }\n\n    let scrollLeft = startPosition; // set scroll container to this position to keep header focused\n\n    let scrollCanvas = _trv.getScrollCanvasElementFromTable();\n\n    scrollCanvas.scrollLeft = scrollLeft;\n  };\n  /**\n   * Finds the current columns that are pinned in the table\n   *\n   * @returns {Array} all the columns that are pinned\n   */\n\n\n  var _findPinnedColumns = function () {\n    var results = [];\n\n    if (_columnDefs && _columnDefs.length) {\n      for (var i = 0; i < _columnDefs.length; i++) {\n        if (_columnDefs[i].pinnedLeft === true) {\n          results.push(_columnDefs[i]);\n        }\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Checks new columns for any previous pinned columns, then returns index of first found.\n   *\n   * @param {*} newColumns The new columns coming into the table\n   * @param {*} pinnedColumns The old pinned columns that were pinned\n   * @returns {Number} the first index of an incoming column\n   */\n\n\n  var findPinIndex = function (newColumns, pinnedColumns) {\n    var pinIndex;\n\n    if (_.isArray(pinnedColumns) && _.isArray(newColumns)) {\n      for (var i = pinnedColumns.length - 1; i >= 0; i--) {\n        for (var j = 0; j < newColumns.length; j++) {\n          if (pinnedColumns[i].name && (pinnedColumns[i].name === newColumns[j].name || pinnedColumns[i].name === newColumns[j].field)) {\n            pinIndex = newColumns[j].index;\n            break;\n          }\n        }\n\n        if (pinIndex) {\n          break;\n        }\n      }\n    }\n\n    return pinIndex;\n  };\n\n  self.getColumnDefs = function () {\n    return _columnDefs;\n  };\n\n  self.resetColumnDefs = function (columnDefs) {\n    var previouslyPinnedColumns = _findPinnedColumns();\n\n    var currentPinIndex = findPinIndex(columnDefs, previouslyPinnedColumns);\n    _columnDefs = columnDefs;\n    self.initializeColumnWidths();\n    self.setPinContext(currentPinIndex);\n\n    var pinContainerElem = _trv.getPinContainerElementFromTable();\n\n    var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n\n    var pinContentElem = _trv.getPinContentElementFromTable();\n\n    pinHeaderElem.innerHTML = '';\n\n    _insertColumnHeaders(pinHeaderElem, 0, _pinColumnCount);\n\n    pinContainerElem.replaceChild(pinHeaderElem, pinContainerElem.children[0]);\n\n    _setScrollContentMinWidth(pinContentElem, parseInt(pinHeaderElem.style.minWidth, 10));\n\n    var scrollContainerElem = _trv.getScrollContainerElementFromTable();\n\n    var scrollHeaderElem = _trv.getScrollHeaderElementFromTable();\n\n    var scrollContentElem = _trv.getScrollContentElementFromTable();\n\n    scrollHeaderElem.innerHTML = '';\n\n    _insertColumnHeaders(scrollHeaderElem, _pinColumnCount, _columnDefs.length);\n\n    var scrollContentMinWidth = parseInt(scrollHeaderElem.style.minWidth, 10) - parseInt(scrollContentElem.style.paddingLeft, 10);\n\n    _setScrollContentMinWidth(scrollContentElem, scrollContentMinWidth);\n\n    if (scrollContainerElem.children.length === 0) {\n      scrollContainerElem.appendChild(scrollHeaderElem);\n    }\n\n    self.updateColumnWidth(0, 0);\n    self.setAriaColCount(_trv.getTableContainerElementFromTable(), columnDefs);\n  };\n\n  self.isColumnWidthChangeValid = function (columnIdx, deltaWidth) {\n    var targetWidth = self.getColumnWidth(columnIdx) + deltaWidth;\n    return self.getValidColumnWidth(columnIdx, targetWidth) === targetWidth;\n  };\n\n  self.getValidColumnWidth = function (columnIdx, targetWidth) {\n    var maxWidth = self.getColumnMaxWidth(columnIdx);\n    var minWidth = self.getColumnMinWidth(columnIdx);\n    minWidth = minWidth > Const.WIDTH_ALLOWED_MINIMUM_WIDTH ? minWidth : Const.WIDTH_ALLOWED_MINIMUM_WIDTH;\n\n    if (minWidth && targetWidth < minWidth) {\n      targetWidth = minWidth;\n    } else if (maxWidth && targetWidth > maxWidth) {\n      targetWidth = maxWidth;\n    } else {// Do nothing\n    }\n\n    return targetWidth;\n  };\n\n  self.isColumnSplitterDraggable = function (columnIdx) {\n    return _columnDefs[columnIdx].enableColumnResizing !== false;\n  };\n\n  self.getTotalColumnWidth = function (columnIdx) {\n    var width = 0;\n    var sum = columnIdx + 1;\n\n    for (var i = 0; i < sum; i++) {\n      width += self.getColumnWidth(i);\n    }\n\n    return width;\n  };\n\n  self.getIdxFromColumnName = function (columnField) {\n    for (var i = 0; i < _columnDefs.length; i++) {\n      if (_columnDefs[i].field === columnField || _columnDefs[i].name === columnField) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  self.setHeaderCellSortDirection = function (oldColumnIdx, newColumnIdx, sortDirection) {\n    var sortElem;\n    var headerCellElem = null;\n    var sortDir = null;\n\n    if (sortDirection !== null && sortDirection !== '') {\n      // aria-sort supported sort values are ascending, descending, none and other.\n      sortDir = sortDirection.toLowerCase().includes('desc') ? 'descending' : 'ascending';\n    }\n\n    if (oldColumnIdx > -1) {\n      sortElem = _trv.getHeaderCellSortIconElementFromTable(oldColumnIdx);\n\n      _removeAllSortDirectionClasses(sortElem);\n\n      sortElem.classList.add(_getSortClassName(''));\n      headerCellElem = _trv.getHeaderCellElementFromTable(oldColumnIdx);\n\n      if (headerCellElem !== null && headerCellElem.parentElement.hasAttribute('aria-sort')) {\n        headerCellElem.parentElement.removeAttribute('aria-sort');\n      }\n    }\n\n    sortElem = _trv.getHeaderCellSortIconElementFromTable(newColumnIdx);\n\n    _removeAllSortDirectionClasses(sortElem);\n\n    sortElem.classList.add(_getSortClassName(sortDirection));\n    headerCellElem = _trv.getHeaderCellElementFromTable(newColumnIdx);\n\n    if (headerCellElem !== null && sortDir !== null) {\n      headerCellElem.parentElement.setAttribute('aria-sort', sortDir);\n    }\n  };\n\n  self.getScrollCanvasScrollLeftPosition = function () {\n    return _trv.getScrollCanvasElementFromTable().scrollLeft * -1;\n  };\n\n  self.getPinCanvasScrollLeftPosition = function () {\n    return _trv.getPinCanvasElementFromTable().scrollLeft * -1;\n  };\n  /**\n   * Applies the dynamic row heights to each row\n   *\n   * @param {DocumentFragment} contentRowFragment - the fragment of content rows to be applied to the DOM\n   * @param {DocumentFragment} tempContentRowFragment - the temporary fragment of content rows\n   * @param {number} rowHeight - the pixel row height\n   */\n\n\n  const _applyDynamicRowHeights = function (contentRowFragment, tempContentRowFragment, rowHeight) {\n    let tempDivElem = document.createElement('div');\n    tempDivElem.style.position = 'absolute';\n    tempDivElem.style.visibility = 'hidden';\n    tempDivElem.style.height = 'auto';\n    tempDivElem.style.width = 'auto';\n    const clonedNode = tempContentRowFragment.childNodes.length ? tempContentRowFragment : contentRowFragment.cloneNode(true);\n    tempDivElem.appendChild(clonedNode);\n    document.body.appendChild(tempDivElem); // Now loop through rows\n\n    const newRows = tempDivElem.childNodes;\n    const rowsWithVMOs = contentRowFragment.childNodes;\n    const maxRowHeight = rowHeight * Const.MAX_ROW_HEIGHT_ROWS;\n\n    for (let i = 0; i < newRows.length; i++) {\n      const row = newRows[i];\n      const vmo = rowsWithVMOs[i].vmo;\n      let height = 0;\n      const cells = row.childNodes;\n\n      for (let j = 0; j < cells.length; j++) {\n        const cell = cells[j];\n\n        if (cell.childNodes[0] && cell.childNodes[0].classList.contains(Const.CLASS_SPLM_TABLE_ICON_CELL)) {\n          continue;\n        } else if (cell.childNodes[0] && cell.childNodes[0].classList.contains(Const.CLASS_AW_TREE_COMMAND_CELL)) {\n          // check if cell has data\n          const _cell = cell.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT)[0];\n\n          if (_cell) {\n            const cellHeight = _cell.offsetHeight + 15;\n            height = cellHeight > height ? cellHeight : height;\n          } else {\n            height = rowHeight > height ? rowHeight : height;\n          }\n        } else {\n          const cellHeight = cell.offsetHeight + 11;\n          height = cellHeight > height ? cellHeight : height;\n        }\n      } // no larger than max height and no smaller than default row height\n\n\n      height = Math.min(Math.max(height, rowHeight), maxRowHeight);\n      vmo.rowHeight = !vmo.rowHeight || height > vmo.rowHeight ? height : vmo.rowHeight; // Mark each actual cell text with height if exists.\n\n      const cellsWithText = rowsWithVMOs[i].getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC);\n\n      for (let k = 0; k < cellsWithText.length; k++) {\n        cellsWithText[k].style.maxHeight = String(vmo.rowHeight) + 'px';\n      }\n    }\n\n    document.body.removeChild(tempDivElem);\n  };\n  /**\n   * Creates a group of row elements with cells spanning from the start and end column index.\n   *\n   * @param {Array} vmos - the array of vmos to create rows for\n   * @param {number} startIndex - the row start index\n   * @param {number} rowHeight - the pixel row height\n   * @param {number} startColumnIdx - the column start index\n   * @param {number} endColumnIdx - the column end index\n   * @param {boolean} isPin - true if the row contents are for the pin container\n   *\n   * @return {DocumentFragment} Document fragment containing the rows for the passed in vmos\n   */\n\n\n  const _constructContentElement = function (vmos, startIndex, rowHeight, startColumnIdx, endColumnIdx, isPin) {\n    let contentRowFragment = document.createDocumentFragment();\n    let tempContentRowFragment = document.createDocumentFragment();\n\n    for (let keyIdx = 0; keyIdx < vmos.length; keyIdx++) {\n      let vmo = vmos[keyIdx];\n      const rowIndex = keyIdx + startIndex;\n      const idxNum = document.createAttribute(dataIndexNumber);\n      idxNum.value = rowIndex;\n      let row = null;\n      let mockrow = null;\n\n      if (isPin) {\n        row = _createContentRowElement(vmo, rowHeight, startColumnIdx, endColumnIdx);\n        row.classList.add(Const.CLASS_PINNED_ROW);\n      } else {\n        if (_scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null) {\n          startColumnIdx = _scrollColumnsInView.start + _pinColumnCount;\n          endColumnIdx = _scrollColumnsInView.end + _pinColumnCount;\n        }\n\n        row = _createContentRowElement(vmo, rowHeight, startColumnIdx, endColumnIdx);\n\n        if (_tableInstance.dynamicRowHeightStatus) {\n          // If dynamic row height, we need to get the row height with all cells rendered, so endColumnIdx is the last item in columnDefs.\n          mockrow = _createContentRowElement(vmo, rowHeight, startColumnIdx, _columnDefs.length - 1);\n          mockrow.setAttributeNode(idxNum.cloneNode());\n        }\n      }\n\n      row.setAttributeNode(idxNum); //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n\n      if (row.children.length > 0) {\n        row.setAttribute(ariaRowIndex, rowIndex + 2);\n      } // Add id attribute to each cell which will be refered by aria-activedescendant at grid level.\n      // The id attribute should be unique, so this will be a combination of gridid, aria-rowindex, aria-colindex.\n\n\n      let cellElements = row.childNodes;\n      let uniqueIdForCell;\n\n      for (let i = 0; i < cellElements.length; i++) {\n        if (cellElements[i].hasAttribute(ariaColIndex)) {\n          uniqueIdForCell = _tableInstance.gridId + '_row' + row.getAttribute(ariaRowIndex) + '_col' + cellElements[i].getAttribute(ariaColIndex);\n          cellElements[i].setAttribute('id', uniqueIdForCell);\n        }\n      }\n\n      contentRowFragment.appendChild(row);\n\n      if (_tableInstance.dynamicRowHeightStatus && mockrow) {\n        tempContentRowFragment.appendChild(mockrow);\n      }\n\n      if (isPin !== true && _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null) {\n        self.updateVisibleCells(contentRowFragment);\n      }\n    } // Dynamic Row Height - When flag is enabled\n    // find heights for rows by creating div and adding doc fragment\n\n\n    if (_tableInstance.dynamicRowHeightStatus) {\n      _applyDynamicRowHeights(contentRowFragment, tempContentRowFragment, rowHeight);\n    }\n\n    return contentRowFragment;\n  };\n\n  self.constructContentElement = function (vmos, startIndex, rowHeight, isPin) {\n    if (isPin === true) {\n      // Set container\n      var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n\n      if (_tableInstance.showCheckBox === true) {\n        if (!_alignContainersForCheckbox) {\n          _alignContainersForCheckbox = true;\n          _pinContainerWidth += 32;\n          pinHeaderElem.lastChild.style.width = pinHeaderElem.lastChild.clientWidth + 32 + 'px';\n          _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n        }\n      } else if (!_tableInstance.showCheckBox && _alignContainersForCheckbox) {\n        _alignContainersForCheckbox = false;\n        _pinContainerWidth -= 32;\n        pinHeaderElem.lastChild.style.width = '';\n        _trv.getScrollContainerElementFromTable().style.marginLeft = String(_pinContainerWidth) + 'px';\n      }\n\n      return _constructContentElement(vmos, startIndex, rowHeight, 0, _pinColumnCount - 1, isPin);\n    }\n\n    return _constructContentElement(vmos, startIndex, rowHeight, _pinColumnCount, _columnDefs.length - 1, isPin);\n  };\n\n  var _removeContentElement = function (parent, upperCountIdx, lowerCounterIdx) {\n    var parentElement = parent.getElement();\n    var children = parent.getContentRowElements();\n    var uCountIdx = upperCountIdx || children.length - 1;\n    var lCountIdx = lowerCounterIdx || 0;\n\n    if (children && children.length > 0) {\n      for (; uCountIdx >= lCountIdx; uCountIdx--) {\n        // Clean up edit cell scope if needed\n        var editCell = children[uCountIdx].getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP)[0] || children[uCountIdx].getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY)[0];\n\n        if (editCell !== undefined && editCell.parentElement.prop !== undefined) {\n          editCell.parentElement.prop.isEditing = false;\n        } // Cleanup any components being used dynamically\n\n\n        util.cleanupComponents(children[uCountIdx]);\n        parentElement.removeChild(children[uCountIdx]);\n      }\n    }\n  };\n\n  self.removeContentElement = function (upperCountIdx, lowerCounterIdx) {\n    _removeContentElement(_trv.queryPinContentFromTable(), upperCountIdx, lowerCounterIdx);\n\n    _removeContentElement(_trv.queryScrollContentFromTable(), upperCountIdx, lowerCounterIdx);\n  };\n\n  self.clearScrollContents = function () {\n    _trv.getScrollContentElementFromTable().innerHTML = '';\n  };\n\n  self.setSelectable = function (selectable) {\n    if (selectable) {\n      _table.classList.add(Const.CLASS_SELECTION_ENABLED);\n    } else {\n      _table.classList.remove(Const.CLASS_SELECTION_ENABLED);\n    }\n  };\n\n  self.setDraggable = function (draggable) {\n    var rowElements = _table.getElementsByClassName(Const.CLASS_ROW);\n\n    for (var i = 0; i < rowElements.length; i++) {\n      rowElements[i].draggable = draggable;\n    }\n  }; // /////////////////////////////////////////////\n  // Column Resize Grip\n  // /////////////////////////////////////////////\n\n\n  self.showColumnGrip = function (posX) {\n    self.setColumnGripPosition(posX);\n\n    _grip.style.removeProperty('display');\n  };\n\n  self.setColumnGripPosition = function (posX) {\n    _grip.style.marginLeft = String(posX - 30\n    /* match with width*/\n    ) + 'px';\n  };\n\n  self.hideColumnGrip = function () {\n    _grip.style.display = 'none';\n  };\n\n  _constructTableElement();\n\n  self.updateColorIndicatorElements = function (updateVMOs) {\n    var pinRows = _trv.getPinContentRowElementsFromTable();\n\n    _.forEach(pinRows, function (pinRow) {\n      var rowVmo = pinRow.vmo;\n\n      if (updateVMOs.includes(rowVmo)) {\n        var colorIndicatorElement = pinRow.getElementsByClassName(Const.CLASS_AW_CELL_COLOR_INDICATOR)[0];\n\n        if (colorIndicatorElement) {\n          var newColorIndicatorElement = util.createColorIndicatorElement(rowVmo);\n          colorIndicatorElement.parentElement.replaceChild(newColorIndicatorElement, colorIndicatorElement);\n        }\n      }\n    });\n  };\n\n  self.syncContentRowHeights = function (pinnedElems, scrollElems) {\n    if (pinnedElems && pinnedElems.childNodes) {\n      for (let i = 0; i < pinnedElems.childNodes.length; i++) {\n        let row = pinnedElems.childNodes[i];\n        let rowVMO = row.vmo;\n        row.style.height = String(rowVMO.rowHeight) + 'px';\n      }\n    }\n\n    if (scrollElems && scrollElems.childNodes) {\n      for (let i = 0; i < scrollElems.childNodes.length; i++) {\n        let row = scrollElems.childNodes[i];\n        let rowVMO = row.vmo;\n        row.style.height = String(rowVMO.rowHeight) + 'px';\n      }\n    }\n  };\n\n  return self;\n};\n\n_c = SPLMTableDomController;\nexport default SPLMTableDomController;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableDomController\");","map":{"version":3,"names":["_","eventBus","splmTableColumnResizer","awEventHelperService","wcagService","appCtxSvc","Const","util","Trv","SelectionHelper","Cell","SPLMTableDomController","tableElem","columnDefs","tableEditor","gridContextDispatcher","self","_table","_trv","_menuService","getTableMenuService","_columnDefs","_tableInstance","_keyboardService","keyboardService","_grip","_pinColumnCount","_pinContainerWidth","_scrollContainerWidth","_alignContainersForCheckbox","_scrollColumnsInView","start","end","ariaColIndex","ariaRowIndex","ariaRowCount","dataIndexNumber","_getSortClassName","sortType","toUpperCase","CLASS_ICON_SORT_ASC","CLASS_ICON_SORT_DESC","CLASS_ICON_SORTABLE","CLASS_ICON_NON_SORTABLE","setPinContext","lastPinIndex","undefined","rightMostPinIdx","forEach","column","idx","pinnedLeft","i","length","startPosition","drawnWidth","getPinColumnCount","initializeColumnWidths","width","name","getTableRowHeight","gridOptions","WIDTH_DEFAULT_ICON_COLUMN_WIDTH","minWidth","WIDTH_DEFAULT_MINIMUM_WIDTH","Math","floor","maxWidth","setAriaColCount","tableContainer","columns","tableCols","visibleCols","filter","visible","visibleColsLength","setAttribute","setAriaRowCount","transpose","dataProvider","cols","json","firstPage","action","inputData","searchInput","viewModelCollection","loadedVMObjects","setAriaLabelledAndDescribedBy","directiveElement","getAttribute","_setScrollContentMinWidth","scrollContentElement","adjustedWidth","style","_setPinHeaderWidth","headerElem","getPinHeaderElementFromTable","pinContentElem","getPinContentElementFromTable","String","_setScrollHeaderWidth","getScrollHeaderElementFromTable","scrollContentElem","getScrollContentElementFromTable","scrollContentMinWidth","parseInt","paddingLeft","_setHeaderColumnWidth","columnIdx","headerCellElem","getHeaderCellElementFromTable","_setContentRowWidth","rowElem","_getContentRowCount","_length","rows","getScrollContentRowElementsFromTable","_setContentColumnWidth","rowCnt","rowCellElem","getContentCellFromTable","prevWidth","getColumnWidth","pinRowElem","getPinContentRowElementFromTable","scrollRowElem","getScrollContentRowElementFromTable","_applyFilterIcon","iconElement","classList","add","CLASS_HEADER_CELL_FILTER_APPLIED_ICON","title","summaryText","_buildHeaderCellContainer","columnIndex","sortDirection","headerContainer","document","createElement","CLASS_HEADER_CELL","tabIndex","setOnFocusAndBlur","columnDefElem","CLASS_COLUMN_DEF","CLASS_CELL_CONTENTS","CLASS_HEADER_CLEARFIX","CLASS_HEADER_CELL_CONTENT","columnDef","onclick","selectionChanged","headerTooltip","displayName","appendChild","resizeElem","CLASS_HEADER_CELL_SPLITTER","enableColumnResizing","insertBefore","applyColumnResizeHandler","innerElem","createHeaderElement","CLASS_HEADER_CELL_INNER","sortElem","CLASS_HEADER_CELL_SORT_ICON","sortDir","toLowerCase","includes","filterElem","CLASS_HEADER_CELL_FILTER_ICON","isFilterApplied","enableColumnMenu","openMenuEvent","event","currentColumnIndex","columnProvider","sortCriteria","getIdxFromColumnName","fieldName","type","pinColumnCount","isBulkEditing","columnMenuHandler","CLASS_COLUMN_MENU_ENABLED","addEventListener","isValidKeyPress","_insertColumnHeaders","headerElement","startIdx","endIdx","totalColumnHeaderWidth","enableSorting","sort","direction","headerHeight","getTableHeaderHeight","HEIGHT_HEADER","height","minHeight","maxHeight","_createGrip","CLASS_COLUMN_RESIZE_GRIP","position","subGrip","borderLeft","marginLeft","zIndex","cursor","outline","display","removeHoverClassFromRows","getTableContainerElementFromTable","getElementsByClassName","remove","CLASS_ROW_HOVER","removeHoverClassesRaf","requestAnimationFrame","_constructTableElement","CLASS_TABLE_CONTAINER","useTree","selectionModel","mode","enableCellHeaderSelection","CLASS_HEADER_SELECTION_ENABLED","pinContainer","CLASS_PIN_CONTAINER","CLASS_PIN_CONTAINER_LEFT","CLASS_COMPARE_CONTAINER","pinHeaderElem","CLASS_HEADER_ROW","pinScrollContainer","CLASS_CANVAS","CLASS_VIEWPORT","pinScrollContents","CLASS_SCROLL_CONTENTS","scrollContainer","CLASS_SCROLL_CONTAINER","scrollHeaderElem","rowsContainer","scrollContents","_createPropertyCell","vmo","columnWidth","cell","CLASS_CELL","dynamicRowHeightStatus","CLASS_CELL_DYNAMIC","colSelected","CLASS_COLUMN_SELECTED","CLASS_CELL_SELECTED","defaultRowHeight","ctx","layout","HEIGHT_COMPACT_ROW","HEIGHT_ROW","rowHeight","field","propName","props","prop","cellTops","addCSSClassForRowHeight","idxNum","createAttribute","value","index","setAttributeNode","addCellClickListener","setupInternalCellNavigation","_setAriaAttributesForTreeRow","row","isLeaf","isExpanded","levelNdx","_addRowHoverListener","hoveredRow","currentTarget","getIndexInParent","scrollRow","pinRow","_addRowCheckBox","checkBox","CLASS_CELL_CHECKBOX","wrapperAElement","wrapperCheckboxDiv","inputElement","CLASS_CELL_CHECKBOX_BUTTON","checkboxTypeAttr","commandDef","def","isTableCommand","isTreeNavigation","propertyName","uiValue","checkboxLabelAttr","spanCheckboxStyle","_createContentRowElement","CLASS_ROW","CLASS_UI_GRID_ROW","CLASS_ROW_ICON","rowWidth","target","default","mobile","eventObject","click","subscribeMouseEvent","oncontextmenu","contextSelectionHandler","draggable","rowStatus","adjustedColumnDefs","sortBy","currentColumn","renderingHint","_width","showCheckBox","_removeFilterIcon","updateScrollColumnsInView","scrollLeft","scrollContainerWidth","headerCells","children","extraColumns","totalHeaderCells","columnStartPosition","updateVisibleCells","rowParentElem","startColumnIdx","endColumnIdx","childNodes","scrollHeader","scrollHeaderElemMinWidth","paddingLeftColumnDef","scrollRows","j","rowCells","currentStartIndex","currentEndIndex","trueStartColumnIndex","trueEndColumnIndex","k","colIndex","destroyChildElements","parentElement","removeChild","l","newCellInsertBefore","updateEditStatusForCell","m","newCellInsertAfter","_removeAllSortDirectionClasses","sortElement","getColumnMinWidth","getColumnMaxWidth","updateColumnStartPositions","pinContainerWidth","updateColumnWidth","deltaWidth","getScrollContainerElementFromTable","tableInstanceCallbacks","columnsResized","delta","scrollCanvasElement","getScrollCanvasElementFromTable","offsetWidth","updateFilterIcon","columnName","getHeaderCellElementsFromTable","filterIconElement","updateAllFilterIcons","fitColumnWidth","treeNavigation","cellElems","queryRowColumnCellElementsFromTable","headerTextElement","getElementTextWidth","filterOption","isFilteringEnabled","sortOption","WIDTH_MINIMUM_EXTRA_SPACE","cellElem","actualWidth","valueElems","CLASS_WIDGET_TABLE_CELL_TEXT","CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS","currentWidth","validWidth","getValidColumnWidth","updateColumnVisibility","adjustedColumnIdx","rowCount","splice","resetColumnDefs","_updateCellColumnIndexes","cellElements","getContentCellElementsFromTable","cellElement","_pinHeader","newPinCount","oldPinCount","headerCellElements","moveFragment","createDocumentFragment","queryPinContainerFromTable","toHeader","getElement","queryScrollContainerFromTable","_pinContent","pinContentRowElements","getContentRowElements","scrollContentRowElements","count","pinToColumn","colDef","pinCanvasElement","getPinCanvasElementFromTable","traversalTable","syncHeader","resetFreezeScroll","columnField","scrollCanvas","_findPinnedColumns","results","push","findPinIndex","newColumns","pinnedColumns","pinIndex","isArray","getColumnDefs","previouslyPinnedColumns","currentPinIndex","pinContainerElem","getPinContainerElementFromTable","innerHTML","replaceChild","scrollContainerElem","isColumnWidthChangeValid","targetWidth","WIDTH_ALLOWED_MINIMUM_WIDTH","isColumnSplitterDraggable","getTotalColumnWidth","sum","setHeaderCellSortDirection","oldColumnIdx","newColumnIdx","getHeaderCellSortIconElementFromTable","hasAttribute","removeAttribute","getScrollCanvasScrollLeftPosition","getPinCanvasScrollLeftPosition","_applyDynamicRowHeights","contentRowFragment","tempContentRowFragment","tempDivElem","visibility","clonedNode","cloneNode","body","newRows","rowsWithVMOs","maxRowHeight","MAX_ROW_HEIGHT_ROWS","cells","contains","CLASS_SPLM_TABLE_ICON_CELL","CLASS_AW_TREE_COMMAND_CELL","_cell","cellHeight","offsetHeight","min","max","cellsWithText","CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC","_constructContentElement","vmos","startIndex","isPin","keyIdx","rowIndex","mockrow","CLASS_PINNED_ROW","uniqueIdForCell","gridId","constructContentElement","lastChild","clientWidth","_removeContentElement","parent","upperCountIdx","lowerCounterIdx","uCountIdx","lCountIdx","editCell","CLASS_TABLE_EDIT_CELL_TOP","CLASS_TABLE_EDIT_CELL_TOP_ARRAY","isEditing","cleanupComponents","removeContentElement","queryPinContentFromTable","queryScrollContentFromTable","clearScrollContents","setSelectable","selectable","CLASS_SELECTION_ENABLED","setDraggable","rowElements","showColumnGrip","posX","setColumnGripPosition","removeProperty","hideColumnGrip","updateColorIndicatorElements","updateVMOs","pinRows","getPinContentRowElementsFromTable","rowVmo","colorIndicatorElement","CLASS_AW_CELL_COLOR_INDICATOR","newColorIndicatorElement","createColorIndicatorElement","syncContentRowHeights","pinnedElems","scrollElems","rowVMO"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableDomController.js"],"sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2022 Siemens\n/**\n * This service is used for splm table as Dom Controller, play table row/cell instead of DOM Structure\n *\n * @module js/splmTableDomController\n *\n * DOM Structure\n * <aw-splm-table>\n *   CLASS_TABLE|aw-splm-table\n *     CLASS_TABLE_CONTAINER|aw-splm-tableContainer\n *       CLASS_COLUMN_RESIZE_GRIP|aw-splm-tableColumnResizeGrip -> grip for resize\n *       CLASS_PIN_CONTAINER|aw-splm-tablePinnedContainer\n *           CLASS_HEADER_ROW|aw-splm-tableHeaderRow\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *               CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *               CLASS_CELL|ui-grid-cell\n *       CLASS_SCROLL_CONTAINER|aw-splm-tableScrollContainer\n *           CLASS_HEADER_ROW|ui-grid-header-cell-row\n *             CLASS_HEADER_CELL|aw-splm-tableHeaderCell\n *               CLASS_HEADER_CELL_CONTENT|aw-splm-tableHeaderCellContents\n *                 CLASS_HEADER_CELL_LABEL|aw-splm-tableHeaderCellLabel\n *                 CLASS_HEADER_CELL_SORT_ICON|aw-splm-tableHeaderCellSortIcon\n *                 CLASS_HEADER_CELL_MENU_ICON|aw-splm-tableHeaderCellMenuIcon\n *                 CLASS_HEADER_CELL_SPLITTER|aw-splm-tableHeaderCellSplitter\n *           CLASS_VIEWPORT|aw-splm-tableViewport\n *             CLASS_ROW|aw-splm-tableRow\n *             CLASS_CELL|ui-grid-cell\n *     CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *       CLASS_TABLE_MENU|aw-splm-tableMenu\n *\n *\n * CLASS_TABLE_MENU_CONTAINER|aw-splm-tableMenuContainer\n *   CLASS_TABLE_MENU|aw-splm-tableMenu\n *     CLASS_TABLE_MENU_ITEM|aw-splm-tableMenuItem\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableColumnResizer from 'js/splmTableColumnResizer';\nimport awEventHelperService from 'js/awEventHelperService';\nimport wcagService from 'js/wcagService';\nimport appCtxSvc from 'js/appCtxService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport Cell from 'js/splmTableCellRenderer';\n\n// Bootstrap for _t to make coding pattern consistent\n\n/**\n * Instances of this class represent a column resizer for PL Table\n *\n * @class SimpleTableDomController\n * @param {DOMElement} tableElem - HTML DOM Element for table\n * @param {Array} columnDefs - Array of Column Definitions\n */\nvar SPLMTableDomController = function( tableElem, columnDefs, tableEditor, gridContextDispatcher ) {\n    // Class definition   //Dummy comment\n    var self = this;\n    var _table = tableElem;\n    var _trv = new Trv( tableElem );\n    var _menuService = util.getTableMenuService( tableElem );\n    var _columnDefs = columnDefs;\n    var _tableInstance = tableElem._tableInstance;\n    var _keyboardService = _tableInstance.keyboardService;\n\n    var _grip = null;\n    // Pin/freeze context\n    var _pinColumnCount = 0;\n    var _pinContainerWidth = 0;\n    var _scrollContainerWidth = 0;\n    var _alignContainersForCheckbox = false;\n    var _scrollColumnsInView = {\n        start: null,\n        end: null\n    };\n    const ariaColIndex = 'aria-colindex';\n    const ariaRowIndex = 'aria-rowindex';\n    const ariaRowCount = 'aria-rowcount';\n    const dataIndexNumber = 'data-indexnumber';\n\n    // ////////////////////////////////////////////////\n    // Internal\n    // ////////////////////////////////////////////////\n    var _getSortClassName = function( sortType ) {\n        if( typeof sortType === 'string' ) {\n            sortType = sortType.toUpperCase();\n            if( sortType === 'ASC' ) {\n                return Const.CLASS_ICON_SORT_ASC;\n            } else if( sortType === 'DESC' ) {\n                return Const.CLASS_ICON_SORT_DESC;\n            } else if( sortType === '' ) {\n                return Const.CLASS_ICON_SORTABLE;\n            }\n        }\n        return Const.CLASS_ICON_NON_SORTABLE;\n    };\n\n    self.setPinContext = function( lastPinIndex ) {\n        // Get the right most pinnedLeft option then set pinCount\n        if( lastPinIndex !== undefined && lastPinIndex !== null ) {\n            _pinColumnCount = lastPinIndex + 1;\n        } else {\n            var rightMostPinIdx = -1;\n            _.forEach( _columnDefs, function( column, idx ) {\n                if( column.pinnedLeft === true ) {\n                    rightMostPinIdx = idx;\n                }\n            } );\n            // _pinColumnCount will be greater than zero if any column is pinned or frozen by the user.\n            // We should not reset this value if it is greater than zero.\n            if( _pinColumnCount === 0 ) {\n                _pinColumnCount = rightMostPinIdx + 1;\n            }\n        }\n\n        _pinContainerWidth = 0;\n        _scrollContainerWidth = 0;\n        for( var i = 0; i < _columnDefs.length; i++ ) {\n            if( i < _pinColumnCount ) {\n                _columnDefs[ i ].pinnedLeft = true;\n                _columnDefs[ i ].startPosition = _pinContainerWidth;\n                _pinContainerWidth += _columnDefs[ i ].drawnWidth;\n            } else {\n                _columnDefs[ i ].pinnedLeft = false;\n                _columnDefs[ i ].startPosition = _scrollContainerWidth;\n                _scrollContainerWidth += _columnDefs[ i ].drawnWidth;\n            }\n        }\n    };\n\n    /**\n     * @memberOf js/splmTableDomController\n     *\n     * Get pin column count in the table\n     *\n     * @return {Number} pin column count in the table\n     */\n    self.getPinColumnCount = function() {\n        return _pinColumnCount;\n    };\n\n    /**\n     * New design decided in 20180724:\n     *   1. If width=<number>, we use it.\n     *   2. If width = *, we make it as minWidth + 25%* minWidth.\n     *   3. If minWidth + 25% > maxWidth, use maxWidth.\n     *   4. Don't use ui-grid column splitter design, put the splitter at the right side of the\n     *      column. Adapt CSS properly\n     *\n     * For the issue we faced in real autoWidth design:\n     *   1. Horizontal Scroll bar will appear/disappear randomly when sum(cellWidth) == canvasWidth.\n     *      - This should be resolved by new design but will rehearsal if it is not.\n     *\n     *   2. The listener for resize when autoWidth exist.\n     *      - This is not needed for new design.\n     */\n    self.initializeColumnWidths = function() {\n        _.forEach( _columnDefs, function( column ) {\n            var width = 0;\n            if( column.name === 'icon' ) {\n                width = util.getTableRowHeight( _tableInstance.gridOptions, Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH );\n                if( width !== Const.WIDTH_DEFAULT_ICON_COLUMN_WIDTH ) {\n                    /** We have some pedding in icon rendering column and to render the complete icon, we need to\n                     increase width of icon renderer by 8 units **/\n                    width += 8;\n                }\n            } else if( column.width > 0 ) {\n                width = column.width;\n            } else {\n                width = column.minWidth > 0 ? column.minWidth : Const.WIDTH_DEFAULT_MINIMUM_WIDTH;\n                width = Math.floor( 1.25 * width );\n                width = column.maxWidth > 0 && column.maxWidth < width ? column.maxWidth : width;\n            }\n            column.width = width;\n            column.drawnWidth = width;\n        } );\n    };\n\n    // set aria-colcount to a number of columns which are visible in the DOM\n    self.setAriaColCount = function( tableContainer, columns ) {\n        if( columns !== undefined ) {\n            var tableCols = columns;\n            var visibleCols = tableCols.filter( column => column.visible !== undefined && column.visible );\n            var visibleColsLength = visibleCols.length;\n            tableContainer.setAttribute( 'aria-colcount', visibleColsLength );\n        } else {\n            tableContainer.setAttribute( 'aria-colcount', -1 );\n        }\n    };\n\n    // set aria-colcount to a number of columns which are visible in the DOM\n    self.setAriaRowCount = function( tableContainer ) {\n        if( _tableInstance.gridOptions.transpose === true ) {\n            var tableCols = _tableInstance.dataProvider.cols;\n            var visibleCols = tableCols.filter( column => column.visible !== undefined && column.visible );\n            tableContainer.setAttribute( ariaRowCount, visibleCols.length + 1 );\n        } else {\n            if( _tableInstance.dataProvider.json && _tableInstance.dataProvider.json.firstPage && _tableInstance.dataProvider.action && _tableInstance.dataProvider.action.inputData.searchInput ) {\n                tableContainer.setAttribute( ariaRowCount, _tableInstance.dataProvider.json.firstPage.length + 1 );\n            } else {\n                if( _tableInstance.dataProvider.viewModelCollection && _tableInstance.dataProvider.viewModelCollection.loadedVMObjects ) {\n                    tableContainer.setAttribute( ariaRowCount, _tableInstance.dataProvider.viewModelCollection.loadedVMObjects.length + 1 );\n                } else {\n                    tableContainer.setAttribute( ariaRowCount, -1 );\n                }\n            }\n        }\n    };\n\n    // set describedby and aria-labelledby to a caption or label element id which labels or describes the table\n    self.setAriaLabelledAndDescribedBy = function( directiveElement, tableContainer ) {\n        if( directiveElement ) {\n            if( directiveElement.getAttribute( 'labelled-by' ) ) {\n                tableContainer.setAttribute( 'aria-labelledby', directiveElement.getAttribute( 'labelled-by' ) );\n            }\n            if( directiveElement.getAttribute( 'described-by' ) ) {\n                tableContainer.setAttribute( 'aria-describedby', directiveElement.getAttribute( 'described-by' ) );\n            }\n        }\n    };\n    // Scroll content width must be at least 1px to ensure pin/scroll syncing keeps working\n    // when there are no columns in either of the containers\n    var _setScrollContentMinWidth = function( scrollContentElement, width ) {\n        var adjustedWidth = width > 0 ? width : 1;\n        scrollContentElement.style.minWidth = adjustedWidth + 'px';\n    };\n\n    var _setPinHeaderWidth = function( width ) {\n        var headerElem = _trv.getPinHeaderElementFromTable();\n        var pinContentElem = _trv.getPinContentElementFromTable();\n        headerElem.style.minWidth = String( width ) + 'px';\n        _setScrollContentMinWidth( pinContentElem, width );\n    };\n\n    var _setScrollHeaderWidth = function( width ) {\n        var headerElem = _trv.getScrollHeaderElementFromTable();\n        var scrollContentElem = _trv.getScrollContentElementFromTable();\n        headerElem.style.minWidth = String( width ) + 'px';\n        var scrollContentMinWidth = parseInt( width, 10 ) - parseInt( scrollContentElem.style.paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n    };\n\n    var _setHeaderColumnWidth = function( columnIdx, width ) {\n        var headerCellElem = _trv.getHeaderCellElementFromTable( columnIdx );\n\n        // update current cell width\n        headerCellElem.style.width = String( width ) + 'px';\n    };\n\n    var _setContentRowWidth = function( rowElem, width ) {\n        rowElem.style.minWidth = String( width ) + 'px';\n    };\n\n    var _getContentRowCount = function() {\n        var _length = 0;\n        var rows = _trv.getScrollContentRowElementsFromTable();\n        if( rows ) {\n            _length = rows.length;\n        }\n        return _length;\n    };\n\n    var _setContentColumnWidth = function( columnIdx, width ) {\n        var rowCnt = _getContentRowCount();\n        for( var i = 0; i < rowCnt; i++ ) {\n            var rowCellElem = _trv.getContentCellFromTable( i, columnIdx );\n            var prevWidth = self.getColumnWidth( columnIdx );\n            if( columnIdx < _pinColumnCount ) {\n                var pinRowElem = _trv.getPinContentRowElementFromTable( i );\n                _setContentRowWidth( pinRowElem, _pinContainerWidth + width - prevWidth );\n            } else {\n                var scrollRowElem = _trv.getScrollContentRowElementFromTable( i );\n                _setContentRowWidth( scrollRowElem, _scrollContainerWidth + width - prevWidth );\n            }\n            rowCellElem.style.width = String( width ) + 'px';\n        }\n    };\n\n    /**\n     * Set the class and title for the filter icon element.\n     *\n     * @param {HTMLElement} iconElement - Filter icon element\n     * @param {Object} filter - filter object from column\n     */\n    var _applyFilterIcon = function( iconElement, filter ) {\n        iconElement.classList.add( Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON );\n        iconElement.title = filter.summaryText;\n    };\n\n    /**\n     * Set the class and title for the filter icon element.\n     *\n     * @param {Object} column - the column\n     * @param {number} columnIndex - the column index\n     * @param {string} sortDirection - the sort direction\n     * @param {number} startPosition - the start position of the column\n     *\n     * @return {HTMLElement} - the header container\n     */\n    const _buildHeaderCellContainer = function( column, columnIndex, sortDirection, startPosition ) {\n        //Header cell container\n        let headerContainer = document.createElement( 'div' );\n        headerContainer.classList.add( Const.CLASS_HEADER_CELL );\n        headerContainer.tabIndex = -1;\n        _keyboardService.setOnFocusAndBlur( headerContainer );\n        headerContainer.setAttribute( 'role', 'columnheader' );\n        headerContainer.setAttribute( ariaColIndex, columnIndex + 1 );\n\n        // Check whatever for column selection, and select if needed\n\n        //Column Def Anchor\n        let columnDefElem = document.createElement( 'div' );\n        columnDefElem.classList.add( Const.CLASS_COLUMN_DEF );\n        columnDefElem.classList.add( Const.CLASS_CELL_CONTENTS );\n        columnDefElem.classList.add( Const.CLASS_HEADER_CLEARFIX );\n        columnDefElem.classList.add( Const.CLASS_HEADER_CELL_CONTENT );\n        columnDefElem.style.width = String( column.drawnWidth ) + 'px';\n        columnDefElem.columnDef = column;\n\n        // Enable column selection when click on the header element in transpose mode\n        if( _tableInstance.gridOptions.transpose === true ) {\n            columnDefElem.onclick = SelectionHelper.selectionChanged( _table );\n        }\n\n        if( column.headerTooltip !== false && column.headerTooltip === true ) {\n            columnDefElem.title = column.displayName;\n        }\n\n        headerContainer.appendChild( columnDefElem );\n\n        // Splitter for resize\n        // Firefox limitation: element must be appended on left if it has 'float:right'\n        let resizeElem = document.createElement( 'div' );\n        resizeElem.classList.add( Const.CLASS_HEADER_CELL_SPLITTER );\n        if( column.enableColumnResizing ) {\n            headerContainer.insertBefore( resizeElem, columnDefElem );\n            splmTableColumnResizer.applyColumnResizeHandler( self, resizeElem, _menuService ); //last prop = _menu\n        }\n\n        //Create Inner element\n        let innerElem = Cell.createHeaderElement( column, tableElem );\n        innerElem.classList.add( Const.CLASS_HEADER_CELL_INNER );\n        columnDefElem.appendChild( innerElem );\n\n        //Create Sort element\n        let sortElem = document.createElement( 'i' );\n        sortElem.classList.add( Const.CLASS_HEADER_CELL_SORT_ICON );\n        sortElem.classList.add( _getSortClassName( sortDirection ) );\n        sortElem.title = '';\n        columnDefElem.appendChild( sortElem );\n        let sortDir;\n        if( sortDirection !== null && sortDirection !== '' ) {\n            // aria-sort supported sort values are ascending, descending, none and other.\n            sortDir = sortDirection.toLowerCase().includes( 'desc' ) ? 'descending' : 'ascending';\n            headerContainer.setAttribute( 'aria-sort', sortDir );\n        }\n\n        //Create Filter element\n        let filterElem = document.createElement( 'i' );\n        filterElem.classList.add( Const.CLASS_HEADER_CELL_FILTER_ICON );\n        if( column.filter && column.filter.isFilterApplied ) {\n            _applyFilterIcon( filterElem, column.filter );\n        } else {\n            filterElem.title = '';\n        }\n        columnDefElem.appendChild( filterElem );\n\n        if( column.enableColumnMenu === true ) {\n            const openMenuEvent = ( event ) => {\n                if( gridContextDispatcher ) {\n                    let currentColumnIndex = -1;\n                    if( _tableInstance.columnProvider.sortCriteria && _tableInstance.columnProvider.sortCriteria.length > 0 ) {\n                        var sortCriteria = _tableInstance.columnProvider.sortCriteria[ 0 ];\n                        currentColumnIndex = self.getIdxFromColumnName( sortCriteria.fieldName );\n                    }\n                    gridContextDispatcher( {\n                        type: 'UPDATE_VALUES',\n                        columnDef: columnDefElem.columnDef,\n                        currentColumnIndex: currentColumnIndex,\n                        pinColumnCount: _pinColumnCount,\n                        isBulkEditing: util.isBulkEditing( _table )\n                    } );\n                }\n                _menuService.columnMenuHandler( columnDefElem, gridContextDispatcher )( event );\n            };\n\n            columnDefElem.classList.add( Const.CLASS_COLUMN_MENU_ENABLED );\n            columnDefElem.setAttribute( 'role', 'button' );\n            columnDefElem.setAttribute( 'aria-haspopup', 'true' );\n            columnDefElem.addEventListener( 'click', ( event ) => {\n                openMenuEvent( event );\n            } );\n            headerContainer.addEventListener( 'keydown', function( event ) {\n                if( wcagService.isValidKeyPress( event ) ) {\n                    openMenuEvent( event );\n                }\n            } );\n        }\n\n        column.startPosition = startPosition;\n\n        return headerContainer;\n    };\n\n    var _insertColumnHeaders = function( headerElement, startIdx, endIdx ) {\n        let columnDefs = _columnDefs;\n        let totalColumnHeaderWidth = 0;\n        //only add role=row if we are sure role=columnheader will be added as its descendents else it will cause aria-required-children violation.\n        if( startIdx < endIdx ) {\n            headerElement.setAttribute( 'role', 'row' );\n            //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n            headerElement.setAttribute( ariaRowIndex, 1 );\n        }\n        for( let idx = startIdx; idx < endIdx; idx++ ) {\n            let column = columnDefs[ idx ];\n            let sortDirection = null;\n\n            if( _tableInstance.gridOptions.enableSorting !== false && column.enableSorting ) {\n                if( column.sort && column.sort.direction ) {\n                    sortDirection = column.sort.direction;\n                } else {\n                    sortDirection = '';\n                }\n            }\n\n            const headerContainer = _buildHeaderCellContainer( column, idx, sortDirection, totalColumnHeaderWidth );\n            totalColumnHeaderWidth += column.drawnWidth;\n\n            //Add header container to header element\n            headerElement.appendChild( headerContainer );\n        }\n        let headerHeight = util.getTableHeaderHeight( _tableInstance.gridOptions, Const.HEIGHT_HEADER ) + 'px';\n        headerElement.style.height = headerHeight;\n        headerElement.style.minHeight = headerHeight;\n        headerElement.style.maxHeight = headerHeight;\n        headerElement.style.minWidth = String( totalColumnHeaderWidth ) + 'px';\n    };\n\n    var _createGrip = function() {\n        _grip = document.createElement( 'div' );\n        _grip.classList.add( Const.CLASS_COLUMN_RESIZE_GRIP );\n        _grip.style.position = 'absolute';\n        _grip.style.height = '100%';\n\n        // Try to make border in the middle\n        var subGrip = document.createElement( 'div' );\n        subGrip.style.borderLeft = '1px solid';\n        subGrip.style.marginLeft = '30px';\n        subGrip.style.height = '100%';\n        _grip.appendChild( subGrip );\n\n        _grip.style.zIndex = '1000';\n        _grip.style.cursor = 'col-resize';\n        _grip.style.outline = '20px transparent';\n        _grip.style.width = '60px';\n        _grip.style.display = 'none';\n        return _grip;\n    };\n\n    var removeHoverClassFromRows = function() {\n        var rows = _trv.getTableContainerElementFromTable().getElementsByClassName( 'ui-grid-row' );\n        for( var i = 0; i < rows.length; i++ ) {\n            rows[ i ].classList.remove( Const.CLASS_ROW_HOVER );\n        }\n    };\n\n    var removeHoverClassesRaf = function() {\n        requestAnimationFrame( function() {\n            removeHoverClassFromRows();\n        } );\n    };\n\n    var _constructTableElement = function() {\n        var columnDefs = _columnDefs;\n\n        // Table Container\n        var tableContainer = document.createElement( 'div' );\n        tableContainer.classList.add( Const.CLASS_TABLE_CONTAINER );\n        tableContainer.tabIndex = 0;\n        if( _tableInstance.gridOptions.useTree === true ) {\n            tableContainer.setAttribute( 'role', 'treegrid' );\n        } else {\n            tableContainer.setAttribute( 'role', 'grid' );\n        }\n        if( _tableInstance.dataProvider.selectionModel.mode === 'multiple' ) {\n            tableContainer.setAttribute( 'aria-multiselectable', 'true' );\n        } else {\n            tableContainer.setAttribute( 'aria-multiselectable', 'false' );\n        }\n\n        if( _tableInstance.gridOptions.enableCellHeaderSelection === true ) {\n            tableContainer.classList.add( Const.CLASS_HEADER_SELECTION_ENABLED );\n        }\n\n        self.setAriaRowCount( tableContainer );\n        self.setAriaColCount( tableContainer, _tableInstance.dataProvider.cols );\n\n        _table.appendChild( tableContainer );\n\n        self.initializeColumnWidths();\n\n        // Do pin initialization after eval column width so we could\n        // Dummy Comment\n        // collect container size together\n        self.setPinContext();\n\n        // Create dragging grip.\n        tableContainer.appendChild( _createGrip() );\n        var pinContainer = document.createElement( 'div' );\n        pinContainer.classList.add( Const.CLASS_PIN_CONTAINER );\n        pinContainer.classList.add( Const.CLASS_PIN_CONTAINER_LEFT );\n        if( _tableInstance.gridOptions.transpose === true ) {\n            pinContainer.classList.add( Const.CLASS_COMPARE_CONTAINER );\n        }\n\n        var pinHeaderElem = document.createElement( 'div' );\n        pinHeaderElem.classList.add( Const.CLASS_HEADER_ROW );\n        _insertColumnHeaders( pinHeaderElem, 0, _pinColumnCount );\n        pinContainer.appendChild( pinHeaderElem );\n\n        var pinScrollContainer = document.createElement( 'div' );\n        pinScrollContainer.classList.add( Const.CLASS_CANVAS );\n        pinScrollContainer.classList.add( Const.CLASS_VIEWPORT );\n\n        var pinScrollContents = document.createElement( 'div' );\n        pinScrollContents.addEventListener( 'mouseleave', function() {\n            removeHoverClassesRaf();\n        } );\n        pinScrollContents.classList.add( Const.CLASS_SCROLL_CONTENTS );\n        _setScrollContentMinWidth( pinScrollContents, parseInt( pinHeaderElem.style.minWidth, 10 ) );\n\n        pinScrollContainer.appendChild( pinScrollContents );\n        pinContainer.appendChild( pinScrollContainer );\n\n        tableContainer.appendChild( pinContainer );\n\n        var scrollContainer = document.createElement( 'div' );\n        scrollContainer.classList.add( Const.CLASS_SCROLL_CONTAINER );\n        scrollContainer.style.marginLeft = String( _pinContainerWidth ) + 'px';\n\n        // Create Columns in memory\n        var scrollHeaderElem = document.createElement( 'div' );\n        scrollHeaderElem.classList.add( Const.CLASS_HEADER_ROW );\n        _insertColumnHeaders( scrollHeaderElem, _pinColumnCount, columnDefs.length );\n        scrollContainer.appendChild( scrollHeaderElem );\n\n        // Create row Contents in memory\n        var rowsContainer = document.createElement( 'div' );\n        rowsContainer.classList.add( Const.CLASS_VIEWPORT );\n        rowsContainer.classList.add( Const.CLASS_CANVAS );\n\n        var scrollContents = document.createElement( 'div' );\n        scrollContents.addEventListener( 'mouseleave', function() {\n            removeHoverClassesRaf();\n        } );\n        scrollContents.classList.add( Const.CLASS_SCROLL_CONTENTS );\n        _setScrollContentMinWidth( scrollContents, parseInt( scrollHeaderElem.style.minWidth, 10 ) );\n\n        rowsContainer.appendChild( scrollContents );\n\n        scrollContainer.appendChild( rowsContainer );\n        tableContainer.appendChild( scrollContainer );\n    };\n\n    /**\n     * @memberOf js/aw-splm-table.directive\n     *\n     * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n     * and the given column (columnInfo )\n     * @param {Object} column - Declarative columnInfo object\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     * @param {Number} columnWidth - Width of the iconCellColumn\n     * @param {HTMLElement} rowElem - row DOMElement\n     * @return {HTMLElement} The newly created DOMElement for the property cell\n     */\n    const _createPropertyCell = function( column, vmo, columnWidth, rowElem ) {\n        const cell = util.createElement( 'div', Const.CLASS_CELL );\n        cell.tabIndex = -1;\n        if( _tableInstance.dynamicRowHeightStatus ) {\n            cell.classList.add( Const.CLASS_CELL_DYNAMIC );\n        }\n        if( column.colSelected ) {\n            cell.classList.add( Const.CLASS_COLUMN_SELECTED );\n            cell.classList.add( Const.CLASS_CELL_SELECTED );\n        }\n        const defaultRowHeight = appCtxSvc.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;\n        const rowHeight = util.getTableRowHeight( _tableInstance.gridOptions, defaultRowHeight );\n        cell.style.width = `${columnWidth}px`;\n        cell.style.height = _tableInstance.dynamicRowHeightStatus ? 'auto' : rowHeight + 'px';\n\n        cell.appendChild( Cell.createElement( column, vmo, tableElem, rowElem ) );\n\n        if( column.field === 'transposedColumnProperty' ) {\n            cell.setAttribute( 'role', 'rowheader' );\n        } else {\n            cell.setAttribute( 'role', 'gridcell' );\n        }\n\n        cell.propName = column.field;\n        cell.columnDef = column;\n        if( vmo.props ) {\n            cell.prop = vmo.props[ column.field ];\n        }\n\n        const cellTops = cell.getElementsByClassName( 'aw-splm-tableCellTop' );\n        if( cellTops.length > 0 ) {\n            util.addCSSClassForRowHeight( cellTops[ 0 ], _tableInstance.gridOptions );\n        }\n\n        const idxNum = document.createAttribute( dataIndexNumber );\n        idxNum.value = column.index;\n        if( column.index >= _pinColumnCount ) {\n            idxNum.value = column.index - _pinColumnCount;\n        }\n        cell.setAttributeNode( idxNum );\n\n        // aria-colindex always starts with index 1.\n        cell.setAttribute( ariaColIndex, column.index + 1 );\n        // Set click listener for cell to get editable states\n        tableEditor.addCellClickListener( cell, vmo );\n        _keyboardService.setOnFocusAndBlur( cell );\n        _keyboardService.setupInternalCellNavigation( cell );\n\n        return cell;\n    };\n\n    /**\n     * Adds the aria attributes for tree if the row is part of a tree table\n     * @param {HTMLElement} row - the row element\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     */\n    const _setAriaAttributesForTreeRow = function( row, vmo ) {\n        if( _tableInstance.gridOptions.useTree === true ) {\n            if( vmo.isLeaf === false ) {\n                if( vmo.isExpanded === true ) {\n                    row.setAttribute( 'aria-expanded', 'true' );\n                } else {\n                    row.setAttribute( 'aria-expanded', 'false' );\n                }\n            }\n            // aria-level starts from index 1.\n            row.setAttribute( 'aria-level', vmo.levelNdx + 1 );\n        }\n    };\n\n    /**\n     * Adds the mouseenter event listener to apply hover styling to the row.\n     * @param {HTMLElement} row - the row element\n     */\n    const _addRowHoverListener = function( row ) {\n        row.addEventListener( 'mouseenter', function( event ) {\n            const hoveredRow = event.currentTarget;\n            requestAnimationFrame( function() {\n                removeHoverClassFromRows();\n                const index = util.getIndexInParent( hoveredRow );\n                const scrollRow = _trv.getScrollContentRowElementFromTable( index );\n                const pinRow = _trv.getPinContentRowElementFromTable( index );\n                scrollRow.classList.add( Const.CLASS_ROW_HOVER );\n                pinRow.classList.add( Const.CLASS_ROW_HOVER );\n            } );\n        } );\n    };\n\n    /**\n     * Adds the selection checkbox to the row\n     * @param {HTMLElement} row - the row element\n     * @param {HTMLElement} tableElem - the table element\n     * @param {Object[]} columnDefs - array of column defs\n     */\n    const _addRowCheckBox = function( row, tableElem, columnDefs ) {\n        // var commandBarHtml =\n        // <div class=\"aw-splm-tableCheckBoxPresent\">\n        //   <a class=\"aw-commands-cellCommandCommon\">\n        //     <span class=\"sw-checkbox-val\">\n        //       <input class=\"sw-property-val\" type=\"checkbox\">\n        //       <span class=\"sw-checkbox-pseudo\"></span>\n        //     </span>\n        //   </a>\n        // </div>\n        let checkBox = util.createElement( 'div', Const.CLASS_CELL_CHECKBOX );\n        let wrapperAElement = util.createElement( 'a', 'aw-commands-cellCommandCommon' );\n        let wrapperCheckboxDiv = util.createElement( 'span', 'sw-checkbox-val' );\n\n        let inputElement = util.createElement( 'input', Const.CLASS_CELL_CHECKBOX_BUTTON );\n        let checkboxTypeAttr = document.createAttribute( 'type' );\n        checkboxTypeAttr.value = 'checkbox';\n        inputElement.setAttributeNode( checkboxTypeAttr );\n\n        let commandDef = columnDefs.filter( function( def ) {\n            if( def.isTableCommand || def.isTreeNavigation ) {\n                return true;\n            }\n            return false;\n        } )[ 0 ];\n        let propName = commandDef && ( commandDef.propertyName || commandDef.name );\n        if( propName && row.vmo && row.vmo.props && row.vmo.props[ propName ] ) {\n            let value = row.vmo.props[ propName ].uiValue;\n            let checkboxLabelAttr = document.createAttribute( 'aria-label' );\n            checkboxLabelAttr.value = value;\n            inputElement.setAttributeNode( checkboxLabelAttr );\n        }\n\n        let spanCheckboxStyle = document.createElement( 'span' );\n        spanCheckboxStyle.classList.add( 'sw-checkbox-pseudo' );\n\n        // Do we really need this intermediate span? Commenting for now. Will remove once all table related auto tests pass\n        // var spanCheckElem = document.createElement( 'span' );\n        // spanCheckElem.classList.add( 'check' );\n        // spanCheckboxStyle.appendChild( spanCheckElem );\n\n        wrapperCheckboxDiv.appendChild( inputElement );\n        wrapperCheckboxDiv.appendChild( spanCheckboxStyle );\n\n        wrapperAElement.appendChild( wrapperCheckboxDiv );\n\n        checkBox.appendChild( wrapperAElement );\n\n        // We should not need following lines. Commenting for now. Will remove once all table related auto tests pass\n        // var cellScope = {};\n        // var checkBox = util.createNgElement( commandBarHtml, tableElem, cellScope );\n\n        row.appendChild( checkBox );\n    };\n\n    /**\n     * Creates and returns a DOMElement for the TableRow of the passed in view model object (vmo) which defines the row\n     * Will Create cells for each column using the vmo properties associated by propertyName.  Also will prepend an\n     * iconCell at the beginning of the row.  Appropriate rowSelection callback will be added too.\n     * @param {Object} vmo - Declarative view model object (e.g. row)\n     * @param {number} rowHeight - the pixel row height\n     * @param {number} startIdx - the column start index\n     * @param {number} endIdx - the column end index\n     *\n     * @return {HTMLElement} row - the created row element\n     */\n    const _createContentRowElement = function( vmo, rowHeight, startIdx, endIdx ) {\n        const columnDefs = _columnDefs;\n        const row = util.createElement( 'div', Const.CLASS_ROW, Const.CLASS_UI_GRID_ROW, Const.CLASS_ROW_ICON );\n        let rowWidth = 0;\n        row.vmo = vmo;\n        //only add role=row if we are sure role=gridcell or role=rowheader will be added as its descendents else it will cause aria-required-children violation.\n        if( startIdx <= endIdx ) {\n            row.setAttribute( 'role', 'row' );\n        }\n\n        _setAriaAttributesForTreeRow( row, vmo );\n\n        // LCS-286849 - jQuery has issues with handling touch to click events on mobile\n        let target = {\n            default: row,\n            mobile: row\n        };\n        let eventObject = {\n            click: 'touchend'\n        };\n        awEventHelperService.subscribeMouseEvent( target, eventObject, SelectionHelper.selectionChanged( _table ) );\n\n        row.oncontextmenu = _menuService.contextSelectionHandler;\n        row.draggable = true;\n\n        _addRowHoverListener( row );\n\n        if( vmo.rowStatus && vmo.rowStatus === 'ADDED' ) {\n            row.classList.add( 'aw-jswidgets-change' );\n        } else if( vmo.rowStatus && vmo.rowStatus === 'REMOVED' ) {\n            row.classList.add( 'aw-jswidgets-oldText' );\n        }\n\n        let adjustedColumnDefs = _.sortBy( columnDefs, function( columnDef ) {\n            return columnDef.index;\n        } );\n        _.forEach( adjustedColumnDefs, function( currentColumn ) {\n            if( row.vmo.props && row.vmo.props[ currentColumn.field ] ) {\n                row.vmo.props[ currentColumn.field ].renderingHint = currentColumn.renderingHint;\n            }\n        } );\n\n        for( let i = startIdx; i <= endIdx; i++ ) {\n            const column = adjustedColumnDefs[ i ];\n            let cell = null;\n            let _width = column.drawnWidth;\n            const showCheckBox = _tableInstance.showCheckBox;\n            if( i === 0 && showCheckBox ) {\n                _addRowCheckBox( row, tableElem, adjustedColumnDefs );\n            }\n            cell = _createPropertyCell( column, vmo, _width, row );\n\n            rowWidth += _width;\n            row.appendChild( cell );\n        }\n\n        row.style.minWidth = String( rowWidth ) + 'px';\n        row.style.minHeight = String( rowHeight ) + 'px';\n\n        return row;\n    };\n\n    /**\n     * Remove the class and title from the filter icon element.\n     *\n     * @param {HTMLElement} iconElement - Filter icon element\n     */\n    const _removeFilterIcon = function( iconElement ) {\n        iconElement.classList.remove( Const.CLASS_HEADER_CELL_FILTER_APPLIED_ICON );\n        iconElement.title = '';\n    };\n\n    self.updateScrollColumnsInView = function( scrollLeft, scrollContainerWidth ) {\n        var headerCells = _trv.getScrollHeaderElementFromTable().children;\n        // Find start and end visible columns\n        var extraColumns = 3;\n        var start = null;\n        var end = null;\n        var totalHeaderCells = headerCells.length;\n\n        // Return all columns as in view if container width given is null or undefined\n        if( scrollContainerWidth === null || scrollContainerWidth === undefined || scrollContainerWidth === 0 ) {\n            _scrollColumnsInView = { start: 0, end: totalHeaderCells - 1 };\n            return;\n        }\n\n        for( var i = 0; i < totalHeaderCells; i++ ) {\n            var column = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var columnStartPosition = column.startPosition;\n\n            if( columnStartPosition <= scrollLeft ) {\n                start = i;\n            }\n            if( columnStartPosition <= scrollLeft + scrollContainerWidth ) {\n                end = i;\n            }\n        }\n\n        start = start - extraColumns < 0 ? 0 : start - extraColumns;\n        end = end + extraColumns > totalHeaderCells - 1 ? totalHeaderCells - 1 : end + extraColumns;\n\n        _scrollColumnsInView = { start: start, end: end };\n    };\n\n    self.updateVisibleCells = function( rowParentElem ) {\n        const startColumnIdx = _scrollColumnsInView.start;\n        const endColumnIdx = _scrollColumnsInView.end;\n        rowParentElem = rowParentElem.childNodes;\n        const scrollHeader = _trv.getScrollHeaderElementFromTable();\n        const scrollContentElem = _trv.getScrollContentElementFromTable();\n        const headerCells = scrollHeader.children;\n        let minWidth = 0;\n\n        for( let i = startColumnIdx; i < headerCells.length; i++ ) {\n            const column = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            if( startColumnIdx !== null ) {\n                minWidth += column.drawnWidth;\n            }\n        }\n\n        let paddingLeft = null;\n        const scrollHeaderElemMinWidth = scrollHeader.style.minWidth;\n        if( startColumnIdx > 0 ) {\n            const paddingLeftColumnDef = headerCells[ startColumnIdx - 1 ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            paddingLeft = paddingLeftColumnDef.startPosition + paddingLeftColumnDef.drawnWidth + 'px';\n        } else {\n            paddingLeft = '0px';\n        }\n        scrollContentElem.style.paddingLeft = paddingLeft;\n        const scrollContentMinWidth = parseInt( scrollHeaderElemMinWidth, 10 ) - parseInt( paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n\n        // Update cell visibility\n        const scrollRows = rowParentElem;\n        for( let j = 0; j < scrollRows.length; j++ ) {\n            const rowCells = scrollRows[ j ].children;\n            if( rowCells.length === 0 ) {\n                continue;\n            }\n            const row = scrollRows[ j ];\n            row.style.minWidth = minWidth + 'px';\n            const currentStartIndex = rowCells[ 0 ].columnDef.index;\n            const currentEndIndex = rowCells[ rowCells.length - 1 ].columnDef.index;\n            const trueStartColumnIndex = startColumnIdx + _pinColumnCount;\n            const trueEndColumnIndex = endColumnIdx + _pinColumnCount;\n            for( let k = rowCells.length - 1; k >= 0; k-- ) {\n                const cell = rowCells[ k ];\n                const colIndex = cell.columnDef.index;\n\n                // Remove out of view cells\n                if( colIndex < trueStartColumnIndex || colIndex > trueEndColumnIndex ) {\n                    util.destroyChildElements( cell );\n                    cell.parentElement.removeChild( cell );\n                }\n            }\n\n            for( let l = currentStartIndex - 1; l >= trueStartColumnIndex; l-- ) {\n                const newCellInsertBefore = _createPropertyCell( _columnDefs[ l ], row.vmo, _columnDefs[ l ].drawnWidth, row );\n                row.insertBefore( newCellInsertBefore, row.children[ 0 ] );\n                tableEditor.updateEditStatusForCell( newCellInsertBefore );\n            }\n\n            for( let m = currentEndIndex + 1; m <= trueEndColumnIndex; m++ ) {\n                const newCellInsertAfter = _createPropertyCell( _columnDefs[ m ], row.vmo, _columnDefs[ m ].drawnWidth, row );\n                row.appendChild( newCellInsertAfter );\n                tableEditor.updateEditStatusForCell( newCellInsertAfter );\n            }\n        }\n    };\n\n    // LCS-323044 - IE11 - aw-splm-table ascending and descending icon not showing\n    // IE lacks support for multiple arguments in classlist.remove - https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n    const _removeAllSortDirectionClasses = function( sortElement ) {\n        sortElement.classList.remove( Const.CLASS_ICON_SORT_ASC );\n        sortElement.classList.remove( Const.CLASS_ICON_SORT_DESC );\n        sortElement.classList.remove( Const.CLASS_ICON_NON_SORTABLE );\n        sortElement.classList.remove( Const.CLASS_ICON_SORTABLE );\n    };\n\n    // ////////////////////////////////////////////////\n    // Public method\n    // ////////////////////////////////////////////////\n    self.getColumnMinWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].minWidth;\n    };\n\n    self.getColumnMaxWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].maxWidth;\n    };\n\n    self.getColumnWidth = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].drawnWidth;\n    };\n\n    const updateColumnStartPositions = function() {\n        let pinContainerWidth = 0;\n        let scrollContainerWidth = 0;\n        for( let i = 0; i < _columnDefs.length; i++ ) {\n            if( i < _pinColumnCount ) {\n                _columnDefs[ i ].startPosition = pinContainerWidth;\n                pinContainerWidth += _columnDefs[ i ].drawnWidth;\n            } else {\n                _columnDefs[ i ].startPosition = scrollContainerWidth;\n                scrollContainerWidth += _columnDefs[ i ].drawnWidth;\n            }\n        }\n    };\n\n    /**\n     * @memberOf js/splmTableDomController\n     *\n     * This method is used for updating the column width\n     * This method is also called from resetColumnDefs with 0,0 arguments which needs to be corrected.\n     * @param {Number} columnIdx - column index\n     * @param {Number} deltaWidth - delta width\n     */\n    self.updateColumnWidth = function( columnIdx, deltaWidth ) {\n        let width = self.getColumnWidth( columnIdx ) + deltaWidth;\n\n        _setHeaderColumnWidth( columnIdx, width );\n        _setContentColumnWidth( columnIdx, width );\n\n        if( columnIdx < _pinColumnCount ) {\n            // Set container\n            _pinContainerWidth += deltaWidth;\n            _setPinHeaderWidth( _pinContainerWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n        } else {\n            // Set container\n            _scrollContainerWidth += deltaWidth;\n            _setScrollHeaderWidth( _scrollContainerWidth );\n        }\n\n        // Update columnDef start positions\n        if( deltaWidth !== 0 ) {\n            _columnDefs[ columnIdx ].drawnWidth = width;\n\n            _tableInstance.tableInstanceCallbacks.columnsResized( {\n                name: _columnDefs[ columnIdx ].name,\n                delta: deltaWidth\n            } );\n        }\n\n        updateColumnStartPositions();\n        let scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth );\n\n        if( deltaWidth !== 0 ) {\n            self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n        }\n    };\n\n    /**\n     * Update the filter icon for the header of the column name given.\n     *\n     * @param {String} columnName - column name for the header to update\n     */\n    self.updateFilterIcon = function( columnName ) {\n        var headerCells = _trv.getHeaderCellElementsFromTable();\n        for( var i = 0; i < headerCells.length; i++ ) {\n            var columnDef = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var filterIconElement = headerCells[ i ].getElementsByClassName( Const.CLASS_HEADER_CELL_FILTER_ICON )[ 0 ];\n\n            if( columnDef && columnDef.filter && filterIconElement && columnDef.field === columnName ) {\n                if( columnDef.filter.isFilterApplied ) {\n                    _applyFilterIcon( filterIconElement, columnDef.filter );\n                } else {\n                    _removeFilterIcon( filterIconElement );\n                }\n                break;\n            }\n        }\n    };\n\n    /**\n     * Update the filter icon for all column headers.\n     */\n    self.updateAllFilterIcons = function() {\n        var headerCells = _trv.getHeaderCellElementsFromTable();\n        for( var i = 0; i < headerCells.length; i++ ) {\n            var columnDef = headerCells[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n            var filterIconElement = headerCells[ i ].getElementsByClassName( Const.CLASS_HEADER_CELL_FILTER_ICON )[ 0 ];\n\n            if( columnDef && columnDef.filter && filterIconElement ) {\n                if( columnDef.filter.isFilterApplied ) {\n                    _applyFilterIcon( filterIconElement, columnDef.filter );\n                } else {\n                    _removeFilterIcon( filterIconElement );\n                }\n            }\n        }\n    };\n\n    /**\n     * Fit column width with content in canvas\n     * NOTE: This mentod will read computed CSS which may cause reflow\n     *\n     * @param {Number} columnIdx - Last column index.\n     *\n     */\n    self.fitColumnWidth = function( columnIdx ) {\n        var treeNavigation = _columnDefs[ columnIdx ].isTreeNavigation;\n        var cellElems = _trv.queryRowColumnCellElementsFromTable( columnIdx );\n        var maxWidth = 0;\n        var headerTextElement = _trv.getHeaderCellElementFromTable( columnIdx ).getElementsByClassName( Const.CLASS_HEADER_CELL_INNER )[ 0 ];\n        maxWidth = util.getElementTextWidth( headerTextElement );\n\n        var filterOption = _tableInstance.gridOptions.isFilteringEnabled;\n        var sortOption = _tableInstance.gridOptions.enableSorting;\n        // This is the space occupied after the column name which includes column menu, splitter, resizeGrip etc.\n        if( filterOption || sortOption ) {\n            maxWidth += Const.WIDTH_MINIMUM_EXTRA_SPACE;\n        }\n\n        cellElems.forEach( function( cellElem ) {\n            var actualWidth;\n            // Tree navigation cell\n            if( treeNavigation ) {\n                // pass entire cellElem into getCellTextWidth because it calculates\n                // What the width of an unobstructed element with height and width set to auto will be\n                // This will give width of entire cell up until the end of the text for tree nav cells\n                actualWidth = util.getElementTextWidth( cellElem );\n                maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n            } else {\n                // cover text and link for now.\n                var valueElems = cellElem.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT );\n                if( valueElems.length === 0 ) {\n                    valueElems = cellElem.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                }\n                for( var i = 0; i < valueElems.length; i++ ) {\n                    actualWidth = util.getElementTextWidth( valueElems[ i ] );\n                    maxWidth = actualWidth > maxWidth ? actualWidth : maxWidth;\n                }\n            }\n        } );\n\n        if( maxWidth > 0 ) {\n            var currentWidth = self.getColumnWidth( columnIdx );\n            var validWidth = self.getValidColumnWidth( columnIdx, maxWidth );\n            if( currentWidth !== validWidth ) {\n                self.updateColumnWidth( columnIdx, validWidth - currentWidth );\n            }\n        }\n    };\n\n    /**\n     * Update column visibility for hidden columns\n     *\n     * @param {String} columnName - column name\n     */\n    self.updateColumnVisibility = function( columnName ) {\n        var adjustedColumnIdx = self.getIdxFromColumnName( columnName );\n\n        // Remove hidden column header from DOM\n        var headerCellElem = _trv.getHeaderCellElementFromTable( adjustedColumnIdx );\n        if( headerCellElem && headerCellElem.parentElement ) {\n            headerCellElem.parentElement.removeChild( headerCellElem );\n        }\n        // Remove hidden column rows from DOM\n        var rowCount = _getContentRowCount();\n        for( var i = 0; i < rowCount; i++ ) {\n            var rowCellElem = _trv.getContentCellFromTable( i, adjustedColumnIdx );\n            if( rowCellElem && rowCellElem.parentElement ) {\n                rowCellElem.parentElement.removeChild( rowCellElem );\n            }\n        }\n\n        _columnDefs[ adjustedColumnIdx ].visible = false;\n        _columnDefs.splice( adjustedColumnIdx, 1 );\n\n        // Adjust column indices to account for removed column\n        _.forEach( _columnDefs, function( columnDef, index ) {\n            columnDef.index = index;\n        } );\n\n        self.resetColumnDefs( _columnDefs );\n\n        var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n    };\n\n    var _updateCellColumnIndexes = function() {\n        var cellElements = _trv.getContentCellElementsFromTable();\n\n        for( var i = 0; i < cellElements.length; i++ ) {\n            var cellElement = cellElements[ i ];\n            var column = cellElement.columnDef;\n\n            var idxNum = document.createAttribute( dataIndexNumber );\n            idxNum.value = column.index;\n            if( column.index >= _pinColumnCount ) {\n                idxNum.value = column.index - _pinColumnCount;\n            }\n            cellElement.setAttributeNode( idxNum );\n            updateColumnStartPositions();\n        }\n    };\n\n    var _pinHeader = function( columnIdx ) {\n        // Check existing column index\n        var newPinCount = columnIdx + 1;\n        var oldPinCount = _pinColumnCount;\n\n        // Update Existing DOM\n        var headerCellElements = _trv.getHeaderCellElementsFromTable();\n        var moveFragment = document.createDocumentFragment();\n        var deltaWidth = 0;\n        if( oldPinCount < newPinCount ) {\n            // Update Header\n            for( var i = oldPinCount; i < newPinCount; i++ ) {\n                moveFragment.appendChild( headerCellElements[ oldPinCount ] );\n                deltaWidth += self.getColumnWidth( i );\n            }\n            var pinHeaderElem = _trv.queryPinContainerFromTable().toHeader().getElement();\n            pinHeaderElem.appendChild( moveFragment );\n\n            _setPinHeaderWidth( _pinContainerWidth + deltaWidth );\n            _setScrollHeaderWidth( _scrollContainerWidth - deltaWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth + deltaWidth ) + 'px';\n        } else if( oldPinCount > newPinCount ) {\n            // Update Header\n            for( var j = newPinCount; j < oldPinCount; j++ ) {\n                moveFragment.appendChild( headerCellElements[ newPinCount ] );\n                deltaWidth += self.getColumnWidth( j );\n            }\n            var scrollHeaderElem = _trv.queryScrollContainerFromTable().toHeader().getElement();\n            scrollHeaderElem.insertBefore( moveFragment, scrollHeaderElem.childNodes[ 0 ] );\n            _setPinHeaderWidth( _pinContainerWidth - deltaWidth );\n            _setScrollHeaderWidth( _scrollContainerWidth + deltaWidth );\n            _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth - deltaWidth ) + 'px';\n        }\n    };\n\n    var _pinContent = function( columnIdx ) {\n        // Check existing column index\n        var newPinCount = columnIdx + 1;\n        var oldPinCount = _pinColumnCount;\n\n        // Update Existing DOM\n        var moveFragment = document.createDocumentFragment();\n        var pinContentRowElements = _trv.queryPinContainerFromTable().getContentRowElements();\n        var scrollContentRowElements = _trv.queryScrollContainerFromTable().getContentRowElements();\n        var count = pinContentRowElements.length;\n        var deltaWidth = 0;\n        if( oldPinCount < newPinCount ) {\n            for( var i = 0; i < count; i++ ) {\n                deltaWidth = 0;\n                for( var j = oldPinCount; j < newPinCount; j++ ) {\n                    moveFragment.appendChild( scrollContentRowElements[ i ].children[ 0 ] );\n                    deltaWidth += self.getColumnWidth( j );\n                }\n                pinContentRowElements[ i ].appendChild( moveFragment );\n                _setContentRowWidth( pinContentRowElements[ i ], _pinContainerWidth + deltaWidth );\n                _setContentRowWidth( scrollContentRowElements[ i ], _scrollContainerWidth - deltaWidth );\n            }\n        } else if( oldPinCount > newPinCount ) {\n            for( var k = 0; k < count; k++ ) {\n                deltaWidth = 0;\n                for( var l = newPinCount; l < oldPinCount; l++ ) {\n                    moveFragment.appendChild( pinContentRowElements[ k ].children[ newPinCount ] );\n                    deltaWidth += self.getColumnWidth( l );\n                }\n                scrollContentRowElements[ k ].insertBefore( moveFragment, scrollContentRowElements[ k ].childNodes[ 0 ] );\n                _setContentRowWidth( pinContentRowElements[ k ], _pinContainerWidth - deltaWidth );\n                _setContentRowWidth( scrollContentRowElements[ k ], _scrollContainerWidth + deltaWidth );\n            }\n        }\n    };\n\n    /**\n     * Pin the table from column 0 to specific column\n     *\n     * @param {Number} columnIdx - Last column index.\n     *\n     */\n    self.pinToColumn = function( columnIdx ) {\n        // Bring back all cells that were virtualized before moving cells to proper container\n        var scrollCanvasElement = _trv.getScrollCanvasElementFromTable();\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n\n        _pinHeader( columnIdx );\n        _pinContent( columnIdx );\n\n        self.setPinContext( columnIdx );\n\n        let colDef = _columnDefs[ columnIdx ];\n        let pinCanvasElement = _trv.getPinCanvasElementFromTable();\n        pinCanvasElement.scrollLeft = colDef.startPosition;\n        let traversalTable = new Trv( _table );\n        util.syncHeader( traversalTable, true, pinCanvasElement.scrollLeft );\n\n        _updateCellColumnIndexes();\n\n        // Virtualize cells\n        self.updateScrollColumnsInView( scrollCanvasElement.scrollLeft, scrollCanvasElement.offsetWidth );\n        self.updateVisibleCells( _trv.getScrollContentElementFromTable() );\n    };\n\n    self.resetFreezeScroll = function( columnField ) {\n        let startPosition = 0;\n        if( _columnDefs && _columnDefs.length ) {\n            for( var i = 0; i < _columnDefs.length; i++ ) {\n                if( _columnDefs[ i ].field === columnField ) {\n                    startPosition = _columnDefs[ i ].startPosition;\n                }\n            }\n        }\n        let scrollLeft = startPosition;\n        // set scroll container to this position to keep header focused\n        let scrollCanvas = _trv.getScrollCanvasElementFromTable();\n        scrollCanvas.scrollLeft = scrollLeft;\n    };\n\n    /**\n     * Finds the current columns that are pinned in the table\n     *\n     * @returns {Array} all the columns that are pinned\n     */\n    var _findPinnedColumns = function() {\n        var results = [];\n        if( _columnDefs && _columnDefs.length ) {\n            for( var i = 0; i < _columnDefs.length; i++ ) {\n                if( _columnDefs[ i ].pinnedLeft === true ) {\n                    results.push( _columnDefs[ i ] );\n                }\n            }\n        }\n        return results;\n    };\n\n    /**\n     * Checks new columns for any previous pinned columns, then returns index of first found.\n     *\n     * @param {*} newColumns The new columns coming into the table\n     * @param {*} pinnedColumns The old pinned columns that were pinned\n     * @returns {Number} the first index of an incoming column\n     */\n    var findPinIndex = function( newColumns, pinnedColumns ) {\n        var pinIndex;\n        if( _.isArray( pinnedColumns ) && _.isArray( newColumns ) ) {\n            for( var i = pinnedColumns.length - 1; i >= 0; i-- ) {\n                for( var j = 0; j < newColumns.length; j++ ) {\n                    if( pinnedColumns[ i ].name && ( pinnedColumns[ i ].name === newColumns[ j ].name ||\n                            pinnedColumns[ i ].name === newColumns[ j ].field ) ) {\n                        pinIndex = newColumns[ j ].index;\n                        break;\n                    }\n                }\n                if( pinIndex ) {\n                    break;\n                }\n            }\n        }\n        return pinIndex;\n    };\n\n    self.getColumnDefs = function() {\n        return _columnDefs;\n    };\n\n    self.resetColumnDefs = function( columnDefs ) {\n        var previouslyPinnedColumns = _findPinnedColumns();\n        var currentPinIndex = findPinIndex( columnDefs, previouslyPinnedColumns );\n\n        _columnDefs = columnDefs;\n\n        self.initializeColumnWidths();\n        self.setPinContext( currentPinIndex );\n\n        var pinContainerElem = _trv.getPinContainerElementFromTable();\n        var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n        var pinContentElem = _trv.getPinContentElementFromTable();\n        pinHeaderElem.innerHTML = '';\n        _insertColumnHeaders( pinHeaderElem, 0, _pinColumnCount );\n        pinContainerElem.replaceChild( pinHeaderElem, pinContainerElem.children[ 0 ] );\n        _setScrollContentMinWidth( pinContentElem, parseInt( pinHeaderElem.style.minWidth, 10 ) );\n\n        var scrollContainerElem = _trv.getScrollContainerElementFromTable();\n        var scrollHeaderElem = _trv.getScrollHeaderElementFromTable();\n        var scrollContentElem = _trv.getScrollContentElementFromTable();\n        scrollHeaderElem.innerHTML = '';\n        _insertColumnHeaders( scrollHeaderElem, _pinColumnCount, _columnDefs.length );\n        var scrollContentMinWidth = parseInt( scrollHeaderElem.style.minWidth, 10 ) - parseInt( scrollContentElem.style.paddingLeft, 10 );\n        _setScrollContentMinWidth( scrollContentElem, scrollContentMinWidth );\n\n        if( scrollContainerElem.children.length === 0 ) {\n            scrollContainerElem.appendChild( scrollHeaderElem );\n        }\n\n        self.updateColumnWidth( 0, 0 );\n        self.setAriaColCount( _trv.getTableContainerElementFromTable(), columnDefs );\n    };\n\n    self.isColumnWidthChangeValid = function( columnIdx, deltaWidth ) {\n        var targetWidth = self.getColumnWidth( columnIdx ) + deltaWidth;\n        return self.getValidColumnWidth( columnIdx, targetWidth ) === targetWidth;\n    };\n\n    self.getValidColumnWidth = function( columnIdx, targetWidth ) {\n        var maxWidth = self.getColumnMaxWidth( columnIdx );\n        var minWidth = self.getColumnMinWidth( columnIdx );\n        minWidth = minWidth > Const.WIDTH_ALLOWED_MINIMUM_WIDTH ? minWidth : Const.WIDTH_ALLOWED_MINIMUM_WIDTH;\n\n        if( minWidth && targetWidth < minWidth ) {\n            targetWidth = minWidth;\n        } else if( maxWidth && targetWidth > maxWidth ) {\n            targetWidth = maxWidth;\n        } else {\n            // Do nothing\n        }\n        return targetWidth;\n    };\n\n    self.isColumnSplitterDraggable = function( columnIdx ) {\n        return _columnDefs[ columnIdx ].enableColumnResizing !== false;\n    };\n\n    self.getTotalColumnWidth = function( columnIdx ) {\n        var width = 0;\n        var sum = columnIdx + 1;\n        for( var i = 0; i < sum; i++ ) {\n            width += self.getColumnWidth( i );\n        }\n        return width;\n    };\n\n    self.getIdxFromColumnName = function( columnField ) {\n        for( var i = 0; i < _columnDefs.length; i++ ) {\n            if( _columnDefs[ i ].field === columnField || _columnDefs[ i ].name === columnField ) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.setHeaderCellSortDirection = function( oldColumnIdx, newColumnIdx, sortDirection ) {\n        var sortElem;\n        var headerCellElem = null;\n        var sortDir = null;\n        if( sortDirection !== null && sortDirection !== '' ) {\n            // aria-sort supported sort values are ascending, descending, none and other.\n            sortDir = sortDirection.toLowerCase().includes( 'desc' ) ? 'descending' : 'ascending';\n        }\n        if( oldColumnIdx > -1 ) {\n            sortElem = _trv.getHeaderCellSortIconElementFromTable( oldColumnIdx );\n            _removeAllSortDirectionClasses( sortElem );\n            sortElem.classList.add( _getSortClassName( '' ) );\n            headerCellElem = _trv.getHeaderCellElementFromTable( oldColumnIdx );\n            if( headerCellElem !== null && headerCellElem.parentElement.hasAttribute( 'aria-sort' ) ) {\n                headerCellElem.parentElement.removeAttribute( 'aria-sort' );\n            }\n        }\n\n        sortElem = _trv.getHeaderCellSortIconElementFromTable( newColumnIdx );\n        _removeAllSortDirectionClasses( sortElem );\n        sortElem.classList.add( _getSortClassName( sortDirection ) );\n        headerCellElem = _trv.getHeaderCellElementFromTable( newColumnIdx );\n        if( headerCellElem !== null && sortDir !== null ) {\n            headerCellElem.parentElement.setAttribute( 'aria-sort', sortDir );\n        }\n    };\n\n    self.getScrollCanvasScrollLeftPosition = function() {\n        return _trv.getScrollCanvasElementFromTable().scrollLeft * -1;\n    };\n\n    self.getPinCanvasScrollLeftPosition = function() {\n        return _trv.getPinCanvasElementFromTable().scrollLeft * -1;\n    };\n\n    /**\n     * Applies the dynamic row heights to each row\n     *\n     * @param {DocumentFragment} contentRowFragment - the fragment of content rows to be applied to the DOM\n     * @param {DocumentFragment} tempContentRowFragment - the temporary fragment of content rows\n     * @param {number} rowHeight - the pixel row height\n     */\n    const _applyDynamicRowHeights = function( contentRowFragment, tempContentRowFragment, rowHeight ) {\n        let tempDivElem = document.createElement( 'div' );\n        tempDivElem.style.position = 'absolute';\n        tempDivElem.style.visibility = 'hidden';\n        tempDivElem.style.height = 'auto';\n        tempDivElem.style.width = 'auto';\n        const clonedNode = tempContentRowFragment.childNodes.length ? tempContentRowFragment : contentRowFragment.cloneNode( true );\n        tempDivElem.appendChild( clonedNode );\n        document.body.appendChild( tempDivElem );\n\n        // Now loop through rows\n        const newRows = tempDivElem.childNodes;\n        const rowsWithVMOs = contentRowFragment.childNodes;\n\n        const maxRowHeight = rowHeight * Const.MAX_ROW_HEIGHT_ROWS;\n\n        for( let i = 0; i < newRows.length; i++ ) {\n            const row = newRows[ i ];\n            const vmo = rowsWithVMOs[ i ].vmo;\n            let height = 0;\n            const cells = row.childNodes;\n\n            for( let j = 0; j < cells.length; j++ ) {\n                const cell = cells[ j ];\n                if( cell.childNodes[ 0 ] && cell.childNodes[ 0 ].classList.contains( Const.CLASS_SPLM_TABLE_ICON_CELL ) ) {\n                    continue;\n                } else if( cell.childNodes[ 0 ] && cell.childNodes[ 0 ].classList.contains( Const.CLASS_AW_TREE_COMMAND_CELL ) ) {\n                    // check if cell has data\n                    const _cell = cell.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT )[ 0 ];\n                    if( _cell ) {\n                        const cellHeight = _cell.offsetHeight + 15;\n                        height = cellHeight > height ? cellHeight : height;\n                    } else {\n                        height = rowHeight > height ? rowHeight : height;\n                    }\n                } else {\n                    const cellHeight = cell.offsetHeight + 11;\n                    height = cellHeight > height ? cellHeight : height;\n                }\n            }\n\n            // no larger than max height and no smaller than default row height\n            height = Math.min( Math.max( height, rowHeight ), maxRowHeight );\n\n            vmo.rowHeight = !vmo.rowHeight || height > vmo.rowHeight ? height : vmo.rowHeight;\n            // Mark each actual cell text with height if exists.\n            const cellsWithText = rowsWithVMOs[ i ].getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );\n            for( let k = 0; k < cellsWithText.length; k++ ) {\n                cellsWithText[ k ].style.maxHeight = String( vmo.rowHeight ) + 'px';\n            }\n        }\n\n        document.body.removeChild( tempDivElem );\n    };\n\n    /**\n     * Creates a group of row elements with cells spanning from the start and end column index.\n     *\n     * @param {Array} vmos - the array of vmos to create rows for\n     * @param {number} startIndex - the row start index\n     * @param {number} rowHeight - the pixel row height\n     * @param {number} startColumnIdx - the column start index\n     * @param {number} endColumnIdx - the column end index\n     * @param {boolean} isPin - true if the row contents are for the pin container\n     *\n     * @return {DocumentFragment} Document fragment containing the rows for the passed in vmos\n     */\n    const _constructContentElement = function( vmos, startIndex, rowHeight, startColumnIdx, endColumnIdx, isPin ) {\n        let contentRowFragment = document.createDocumentFragment();\n        let tempContentRowFragment = document.createDocumentFragment();\n\n        for( let keyIdx = 0; keyIdx < vmos.length; keyIdx++ ) {\n            let vmo = vmos[ keyIdx ];\n            const rowIndex = keyIdx + startIndex;\n            const idxNum = document.createAttribute( dataIndexNumber );\n            idxNum.value = rowIndex;\n            let row = null;\n            let mockrow = null;\n            if( isPin ) {\n                row = _createContentRowElement( vmo, rowHeight, startColumnIdx, endColumnIdx );\n                row.classList.add( Const.CLASS_PINNED_ROW );\n            } else {\n                if( _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null ) {\n                    startColumnIdx = _scrollColumnsInView.start + _pinColumnCount;\n                    endColumnIdx = _scrollColumnsInView.end + _pinColumnCount;\n                }\n                row = _createContentRowElement( vmo, rowHeight, startColumnIdx, endColumnIdx );\n                if( _tableInstance.dynamicRowHeightStatus ) {\n                    // If dynamic row height, we need to get the row height with all cells rendered, so endColumnIdx is the last item in columnDefs.\n                    mockrow = _createContentRowElement( vmo, rowHeight, startColumnIdx, _columnDefs.length - 1 );\n                    mockrow.setAttributeNode( idxNum.cloneNode() );\n                }\n            }\n\n            row.setAttributeNode( idxNum );\n            //aria-rowindex always starts from 1. For header row, it is 1 and for the actual rows, it starts from 2.\n            if( row.children.length > 0 ) {\n                row.setAttribute( ariaRowIndex, rowIndex + 2 );\n            }\n\n            // Add id attribute to each cell which will be refered by aria-activedescendant at grid level.\n            // The id attribute should be unique, so this will be a combination of gridid, aria-rowindex, aria-colindex.\n            let cellElements = row.childNodes;\n            let uniqueIdForCell;\n            for( let i = 0; i < cellElements.length; i++ ) {\n                if( cellElements[ i ].hasAttribute( ariaColIndex ) ) {\n                    uniqueIdForCell = _tableInstance.gridId + '_row' + row.getAttribute( ariaRowIndex ) + '_col' + cellElements[ i ].getAttribute( ariaColIndex );\n                    cellElements[ i ].setAttribute( 'id', uniqueIdForCell );\n                }\n            }\n            contentRowFragment.appendChild( row );\n            if( _tableInstance.dynamicRowHeightStatus && mockrow ) {\n                tempContentRowFragment.appendChild( mockrow );\n            }\n\n            if( isPin !== true && _scrollColumnsInView.start !== null && _scrollColumnsInView.end !== null ) {\n                self.updateVisibleCells( contentRowFragment );\n            }\n        }\n\n        // Dynamic Row Height - When flag is enabled\n        // find heights for rows by creating div and adding doc fragment\n        if( _tableInstance.dynamicRowHeightStatus ) {\n            _applyDynamicRowHeights( contentRowFragment, tempContentRowFragment, rowHeight );\n        }\n\n        return contentRowFragment;\n    };\n\n    self.constructContentElement = function( vmos, startIndex, rowHeight, isPin ) {\n        if( isPin === true ) {\n            // Set container\n            var pinHeaderElem = _trv.getPinHeaderElementFromTable();\n            if( _tableInstance.showCheckBox === true ) {\n                if( !_alignContainersForCheckbox ) {\n                    _alignContainersForCheckbox = true;\n                    _pinContainerWidth += 32;\n                    pinHeaderElem.lastChild.style.width = pinHeaderElem.lastChild.clientWidth + 32 + 'px';\n                    _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n                }\n            } else if( !_tableInstance.showCheckBox && _alignContainersForCheckbox ) {\n                _alignContainersForCheckbox = false;\n                _pinContainerWidth -= 32;\n\n                pinHeaderElem.lastChild.style.width = '';\n                _trv.getScrollContainerElementFromTable().style.marginLeft = String( _pinContainerWidth ) + 'px';\n            }\n            return _constructContentElement( vmos, startIndex, rowHeight, 0, _pinColumnCount - 1, isPin );\n        }\n\n        return _constructContentElement( vmos, startIndex, rowHeight, _pinColumnCount, _columnDefs.length - 1, isPin );\n    };\n\n    var _removeContentElement = function( parent, upperCountIdx, lowerCounterIdx ) {\n        var parentElement = parent.getElement();\n        var children = parent.getContentRowElements();\n        var uCountIdx = upperCountIdx || children.length - 1;\n        var lCountIdx = lowerCounterIdx || 0;\n\n        if( children && children.length > 0 ) {\n            for( ; uCountIdx >= lCountIdx; uCountIdx-- ) {\n                // Clean up edit cell scope if needed\n                var editCell = children[ uCountIdx ].getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP )[ 0 ] || children[ uCountIdx ].getElementsByClassName( Const\n                    .CLASS_TABLE_EDIT_CELL_TOP_ARRAY )[ 0 ];\n                if( editCell !== undefined && editCell.parentElement.prop !== undefined ) {\n                    editCell.parentElement.prop.isEditing = false;\n                }\n\n                // Cleanup any components being used dynamically\n                util.cleanupComponents( children[ uCountIdx ] );\n                parentElement.removeChild( children[ uCountIdx ] );\n            }\n        }\n    };\n\n    self.removeContentElement = function( upperCountIdx, lowerCounterIdx ) {\n        _removeContentElement( _trv.queryPinContentFromTable(), upperCountIdx, lowerCounterIdx );\n        _removeContentElement( _trv.queryScrollContentFromTable(), upperCountIdx, lowerCounterIdx );\n    };\n\n    self.clearScrollContents = function() {\n        _trv.getScrollContentElementFromTable().innerHTML = '';\n    };\n\n    self.setSelectable = function( selectable ) {\n        if( selectable ) {\n            _table.classList.add( Const.CLASS_SELECTION_ENABLED );\n        } else {\n            _table.classList.remove( Const.CLASS_SELECTION_ENABLED );\n        }\n    };\n\n    self.setDraggable = function( draggable ) {\n        var rowElements = _table.getElementsByClassName( Const.CLASS_ROW );\n        for( var i = 0; i < rowElements.length; i++ ) {\n            rowElements[ i ].draggable = draggable;\n        }\n    };\n\n    // /////////////////////////////////////////////\n    // Column Resize Grip\n    // /////////////////////////////////////////////\n\n    self.showColumnGrip = function( posX ) {\n        self.setColumnGripPosition( posX );\n        _grip.style.removeProperty( 'display' );\n    };\n\n    self.setColumnGripPosition = function( posX ) {\n        _grip.style.marginLeft = String( posX - 30 /* match with width*/ ) + 'px';\n    };\n\n    self.hideColumnGrip = function() {\n        _grip.style.display = 'none';\n    };\n\n    _constructTableElement();\n\n    self.updateColorIndicatorElements = function( updateVMOs ) {\n        var pinRows = _trv.getPinContentRowElementsFromTable();\n        _.forEach( pinRows, function( pinRow ) {\n            var rowVmo = pinRow.vmo;\n            if( updateVMOs.includes( rowVmo ) ) {\n                var colorIndicatorElement = pinRow.getElementsByClassName( Const.CLASS_AW_CELL_COLOR_INDICATOR )[ 0 ];\n                if( colorIndicatorElement ) {\n                    var newColorIndicatorElement = util.createColorIndicatorElement( rowVmo );\n                    colorIndicatorElement.parentElement.replaceChild( newColorIndicatorElement, colorIndicatorElement );\n                }\n            }\n        } );\n    };\n\n    self.syncContentRowHeights = function( pinnedElems, scrollElems ) {\n        if( pinnedElems && pinnedElems.childNodes ) {\n            for( let i = 0; i < pinnedElems.childNodes.length; i++ ) {\n                let row = pinnedElems.childNodes[ i ];\n                let rowVMO = row.vmo;\n                row.style.height = String( rowVMO.rowHeight ) + 'px';\n            }\n        }\n\n        if( scrollElems && scrollElems.childNodes ) {\n            for( let i = 0; i < scrollElems.childNodes.length; i++ ) {\n                let row = scrollElems.childNodes[ i ];\n                let rowVMO = row.vmo;\n                row.style.height = String( rowVMO.rowHeight ) + 'px';\n            }\n        }\n    };\n\n    return self;\n};\n\nexport default SPLMTableDomController;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}