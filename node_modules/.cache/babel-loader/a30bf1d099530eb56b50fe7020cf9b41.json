{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do debugging.\n *\n * @module js/breakpointService\n * @namespace breakpointService\n */ /**\n *  Below is the sample input for breakpoints.\n */let sampleInput={b1:{lifeCycles:{vmName0:['init','mount'],vmName1:['destroy']},actions:{vmName0:{actionId0:['pre'],actionId1:['post']}},globalEvents:{'aw.include':{data1:'data1',data2:'data2'},'aw.*':{data1:'data1',data2:'data2'}},ctx:{'aw.test':['register','unregister','modify']},commands:['cm1','cmd2']},b2:{lifeCycles:{vmName0:['init','mount'],vmName1:['destroy']},actions:{vmName0:{actionId0:['pre'],actionId1:['post']}},globalEvents:{'aw.include':{data1:'data1',data2:'data2'},'aw.*':{data1:'data1',data2:'data2'}},ctx:{'aw.test':['register','unregister','modify']}}};let breakpointsModel={};let optBrkModel=new Map();let enableBrkPoints=true;let isUnminified=/comment/.test(function(){/*\n        comment\n    */});/**\n *\n * @param {*} isEnable boolean true or false to enable or disable the breakpoint.\n */export let enableBreakPoints=isEnable=>{enableBrkPoints=isEnable;};/**\n *  This function is used to give back all the exiting breakpoints\n *  to the chrome extension to re-generate the breakpoint UI.\n *  @returns {*} returns the breakPoinModel Object.\n */export let getAllBreakPoints=()=>{return breakpointsModel;};/**\n * This is a immutable function, which takes two array merge them, remove the\n * duplicates and return a new array.\n * @param {*} array1 The first input array. The array should only contain strings.\n * @param {*} array2 The second input array. The array should only contain strings.\n * @returns {*} a new concatinated array.\n */let mergeAndRemoveDuplicates=(array1,array2)=>{let concatArray=[...array1,...array2];return concatArray.reduce((finalArray,item)=>{if(finalArray.includes(item)){return finalArray;}return[...finalArray,item];},[]);};/**\n *\n * @param {*} model  The input model\n * @param {*} holder the holder object\n */let processInputModel=(model,holder)=>{let keys=Object.keys(model);keys.forEach(key=>{let objValue=model[key]instanceof Array?model[key]:[model[key]];if(!holder.has(key)){holder.set(key,objValue);}else{let srcValue=holder.get(key);let finalArray=mergeAndRemoveDuplicates(srcValue,objValue);holder.set(key,finalArray);}});};/**\n *\n * @param {*} structure The input structure for breakpoints.\n */export let addBreakPoint=structure=>{Object.keys(structure).forEach(breakPointName=>{breakpointsModel[breakPointName]=structure[breakPointName];});generateOptimizedModel();};/**\n * This API is to remove the breakpoint.\n * @param {*} breakPointName name of the breakpoint\n */export let removeBreakPoint=breakPointName=>{if(breakpointsModel[breakPointName]){delete breakpointsModel[breakPointName];generateOptimizedModel();}};export let removeAllBreakPoints=()=>{breakpointsModel={};generateOptimizedModel();};/**\n * This API should be used to check if any condtion\n * matches with any exisitng breakpoint condtions.\n *\n * @param {*} breakpointType Name of the breakpoint type\n * @param  {...any} args This differs for breakpoint types\n * @returns {true/false} boolean\n */export let hasConditionSatisfied=function(breakpointType){let isCondMatched=false;let eventName;let actionId;let stage;let panelId;let ctxKey;let commandName;let fromState;let toState;let dataParserId;if(!isUnminified||!enableBrkPoints){return false;}switch(breakpointType){case'lifeCycles':panelId=arguments.length<=1?undefined:arguments[1];stage=arguments.length<=2?undefined:arguments[2];isCondMatched=optBrkModel.has('lifeCycles')?optBrkModel.get('lifeCycles').breakPointCondSatisfied(panelId,stage):false;break;case'actions':panelId=arguments.length<=1?undefined:arguments[1];actionId=arguments.length<=2?undefined:arguments[2];stage=arguments.length<=3?undefined:arguments[3];isCondMatched=optBrkModel.has('actions')?optBrkModel.get('actions').breakPointCondSatisfied(panelId,actionId,stage):false;break;case'events':panelId=arguments.length<=1?undefined:arguments[1];eventName=arguments.length<=2?undefined:arguments[2];isCondMatched=optBrkModel.has('events')?optBrkModel.get('events').breakPointCondSatisfied(panelId,eventName):false;break;case'dataParsers':panelId=arguments.length<=1?undefined:arguments[1];dataParserId=arguments.length<=2?undefined:arguments[2];isCondMatched=optBrkModel.has('dataParsers')?optBrkModel.get('dataParsers').breakPointCondSatisfied(panelId,dataParserId):false;break;case'globalEvents':eventName=arguments.length<=1?undefined:arguments[1];isCondMatched=optBrkModel.has('globalEvents')?optBrkModel.get('globalEvents').breakPointCondSatisfied(eventName):false;break;case'ctx':ctxKey=arguments.length<=1?undefined:arguments[1];stage=arguments.length<=2?undefined:arguments[2];isCondMatched=optBrkModel.has('ctx')?optBrkModel.get('ctx').breakPointCondSatisfied(ctxKey,stage):false;break;case'commands':commandName=arguments.length<=1?undefined:arguments[1];isCondMatched=optBrkModel.has('commands')?optBrkModel.get('commands').breakPointCondSatisfied(commandName):false;break;case'routes':fromState=arguments.length<=1?undefined:arguments[1];toState=arguments.length<=2?undefined:arguments[2];isCondMatched=optBrkModel.has('routes')?optBrkModel.get('routes').breakPointCondSatisfied(fromState,toState):false;break;}return isCondMatched;};/**\n * This optimized model holds a class object (singleton class) against every breakpoint type.\n * example\n *      {\n *          \"lifeCycles\" : new LifeCycleModel(),\n *          \"actions\" : new ActionModel(),\n *          \"globalEvents\" : new GlobalEventsModel(),\n *          \"ctx\" : new CtxModel() *\n *       }\n */let generateOptimizedModel=()=>{let breakPointTypes=['lifeCycles','actions','globalEvents','ctx','commands','events','routes','dataParsers'];/**\n     *  Whenever we re-generate the optimized view-model\n     *  we should take care to clear all the exiting breakpoints.\n     */for(let breakPointType of breakPointTypes){if(optBrkModel.has(breakPointType)){// Every class from optBrkModel.get( breakPointType ) has clear() method implemented.\noptBrkModel.get(breakPointType).clearConditions();}}for(let breakPointName in breakpointsModel){let breakPointObj=breakpointsModel[breakPointName];for(let breakPointType of breakPointTypes){switch(breakPointType){case'lifeCycles':generateLifeCycleModel(breakPointObj.lifeCycles);break;case'actions':generateActionModel(breakPointObj.actions);break;case'globalEvents':generateGlobalEventsModel(breakPointObj.globalEvents);break;case'events':generateEventModel(breakPointObj.events);break;case'dataParsers':generateDataParserModel(breakPointObj.dataParsers);break;case'ctx':generateCtxModel(breakPointObj.ctx);break;case'commands':generateCommandsModel(breakPointObj.commands);break;case'routes':generateRoutesModel(breakPointObj.routes);break;}}}};/**\n * This is a singleton 'lifeCycles' class, which holds all the breakpoint\n * information related to lifecycles for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n *  @param {*} model the input model to create breakpoints for viewmodel lifeCycle.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n *\n */let generateLifeCycleModel=model=>{class LifeCycleModel{constructor(){if(LifeCycleModel.instance){return LifeCycleModel.instance;}LifeCycleModel.instance=this;this.holder=new Map();return this;}addInput(lifeCycleInput){processInputModel(lifeCycleInput,this.holder);}hasPanelId(panelId){return this.holder.has(panelId);}getStage(panelId){return this.holder.get(panelId);}breakPointCondSatisfied(panelId,stage){if(this.hasPanelId(panelId)){return this.holder.get(panelId).includes(stage);}return false;}clearConditions(){this.holder.clear();}}if(!optBrkModel.has('lifeCycles')){optBrkModel.set('lifeCycles',new LifeCycleModel());}if(model){optBrkModel.get('lifeCycles').addInput(model);}};/**\n *\n * @param {*} model the input model to create breakpoints for viewmodel actions.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */let generateActionModel=model=>{class ActionModel{constructor(){if(ActionModel.instance){return ActionModel.instance;}ActionModel.instance=this;this.modelHolder=new Map();return this;}addInput(actionInputModel){let panelNames=Object.keys(actionInputModel);for(let panelName of panelNames){if(!this.modelHolder.has(panelName)){let actionModel=new Map();let actionObj=actionInputModel[panelName];Object.keys(actionObj).forEach(actionName=>{let actionStage=actionObj[actionName]instanceof Array?actionObj[actionName]:[actionObj[actionName]];actionModel.set(actionName,actionStage);});this.modelHolder.set(panelName,actionModel);}else{let srcActionModel=this.modelHolder.get(panelName);let newActionModel=actionInputModel[panelName];processInputModel(newActionModel,srcActionModel);}}}hasPanelId(panelId){return this.modelHolder.has(panelId);}hasActionId(panelId,actionId){if(this.modelHolder.has(panelId)){return this.modelHolder.get(panelId).has(actionId);}return false;}breakPointCondSatisfied(panelId,actionId,stage){if(this.hasActionId(panelId,actionId)){return this.modelHolder.get(panelId).get(actionId).includes(stage);}return false;}clearConditions(){this.modelHolder.clear();}}if(!optBrkModel.has('actions')){optBrkModel.set('actions',new ActionModel());}if(model){optBrkModel.get('actions').addInput(model);}};let generateEventModel=model=>{class EventModel{constructor(){if(EventModel.instance){return EventModel.instance;}EventModel.instance=this;this.modelHolder=new Map();return this;}addInput(eventInputModel){processInputModel(eventInputModel,this.modelHolder);}hasPanelId(panelId){return this.modelHolder.has(panelId);}hasEventName(panelId,eventName){try{if(this.hasPanelId(panelId)){let eventNames=this.modelHolder.get(panelId);// If user provides an incorrect regular expression\n// the RegExp constructor throws an exception.\n// We do not want to throw any exception due to user error\n// hence, eating up the exception and throwing false.\n//let regexp = RegExp( eventName, 'g' );\n//return eventNames.some( e => regexp.test( e ) );\nreturn eventNames.some(e=>{try{let regexp=RegExp(e,'g');return regexp.test(eventName);}catch(e){return false;}});}return false;}catch(e){return false;}}breakPointCondSatisfied(panelId,eventName){return this.hasEventName(panelId,eventName);}clearConditions(){this.modelHolder.clear();}}if(!optBrkModel.has('events')){optBrkModel.set('events',new EventModel());}if(model){optBrkModel.get('events').addInput(model);}};let generateDataParserModel=model=>{class DataParserModel{constructor(){if(DataParserModel.instance){return DataParserModel.instance;}DataParserModel.instance=this;this.modelHolder=new Map();return this;}addInput(eventInputModel){processInputModel(eventInputModel,this.modelHolder);}hasPanelId(panelId){return this.modelHolder.has(panelId);}hasDataParser(panelId,dataParserId){try{if(this.hasPanelId(panelId)){let dataParsers=this.modelHolder.get(panelId);// If user provides an incorrect regular expression\n// the RegExp constructor throws an exception.\n// We do not want to throw any exception due to user error\n// hence, eating up the exception and throwing false.\n//let regexp = RegExp( eventName, 'g' );\n//return eventNames.some( e => regexp.test( e ) );\nreturn dataParsers.some(e=>{try{let regexp=RegExp(e,'g');return regexp.test(dataParserId);}catch(e){return false;}});}return false;}catch(e){return false;}}breakPointCondSatisfied(panelId,dataParserId){return this.hasDataParser(panelId,dataParserId);}clearConditions(){this.modelHolder.clear();}}if(!optBrkModel.has('dataParsers')){optBrkModel.set('dataParsers',new DataParserModel());}if(model){optBrkModel.get('dataParsers').addInput(model);}};/**\n * This is a singleton 'globalEvents' class, which holds all the breakpoint\n * information related to global events for all breakpoints.\n * This also exposes an API 'breakPointCondSatisfied' which will be consumed to\n * check the breakpoint condition.\n * @param {*} model\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */let generateGlobalEventsModel=model=>{class GlobalEventsModel{constructor(){if(GlobalEventsModel.instance){return GlobalEventsModel.instance;}GlobalEventsModel.instance=this;// ModelHolder is not being used currently. It would be used\n// once we provide the support for matching the eventData\nthis.modelHolder=new Map();this.eventNames=[];return this;}addInput(GlobalEventsModel){Object.keys(GlobalEventsModel).forEach(eventName=>{let eventData=GlobalEventsModel[eventName];this.modelHolder.set(eventName,eventData);this.eventNames.push(eventName);});}hasEventName(eventName){try{// If user provides an incorrect regular expression\n// the RegExp constructor throws an exception.\n// We do not want to throw any exception due to user error\n// hence, eating up the exception and throwing false.\nreturn this.eventNames.some(e=>{try{let regexp=RegExp(e,'g');return regexp.test(eventName);}catch(e){return false;}});}catch(e){return false;}}breakPointCondSatisfied(eventName){return this.hasEventName(eventName);}clearConditions(){this.modelHolder.clear();this.eventNames.length=0;}}if(!optBrkModel.has('globalEvents')){optBrkModel.set('globalEvents',new GlobalEventsModel());}if(model){optBrkModel.get('globalEvents').addInput(model);}};/**\n *\n * @param {*} model the input model to create breakpoints for app context changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */let generateCtxModel=model=>{class CtxModel{constructor(){if(CtxModel.instance){return CtxModel.instance;}CtxModel.instance=this;this.holder=new Map();this.ctxKeys=[];return this;}addInput(ctxInput){processInputModel(ctxInput,this.holder);Object.keys(ctxInput).forEach(ctxkey=>{this.ctxKeys.push(ctxkey);});}hasCtxKey(userKey,stage){try{let userKeyExist=ctxKey=>{try{let regexp=RegExp(ctxKey,'g');return regexp.test(userKey);}catch(_unused){return false;}};if(this.ctxKeys.some(userKeyExist)){return this.holder.get(userKey).includes(stage);}return false;}catch(e){return false;}}getStage(panelId){return this.holder.get(panelId);}breakPointCondSatisfied(ctxKey,stage){return this.hasCtxKey(ctxKey,stage);}clearConditions(){this.holder.clear();}}if(!optBrkModel.has('ctx')){optBrkModel.set('ctx',new CtxModel());}if(model){optBrkModel.get('ctx').addInput(model);}};/**\n *\n * @param {*} model the input model to create breakpoints for commands.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */let generateCommandsModel=model=>{class CommandsModel{constructor(){if(CommandsModel.instance){return CommandsModel.instance;}CommandsModel.instance=this;this.holder=[];return this;}addInput(commands){if(commands instanceof Array){this.holder=[...this.holder,...commands];}this.holder.push(commands);}hasCommandName(commandName){return this.holder.includes(commandName);}breakPointCondSatisfied(commandName){return this.hasCommandName(commandName);}clearConditions(){this.holder.length=0;}}if(!optBrkModel.has('commands')){optBrkModel.set('commands',new CommandsModel());}if(model){optBrkModel.get('commands').addInput(model);}};/**\n *\n * @param {*} model the input model to create breakpoints for route changes.\n * Every class must have atlease two methods to be implemented\n * 1.breakPointCondSatisfied()\n * 2.clearConditions();\n */let generateRoutesModel=model=>{class RoutesModel{constructor(){if(RoutesModel.instance){return RoutesModel.instance;}RoutesModel.instance=this;this.holder=new Map();return this;}addInput(model){Object.keys(model).forEach(fromState=>{let toState=model[fromState]?model[fromState]:null;this.holder.set(fromState,toState);});}breakPointCondSatisfied(fromState,toState){if(this.holder.has(fromState)){if(!this.holder.get(fromState)){return true;}return this.holder.get(fromState)===toState;}return false;}clearConditions(){this.holder.clear();}}if(!optBrkModel.has('routes')){optBrkModel.set('routes',new RoutesModel());}if(model){optBrkModel.get('routes').addInput(model);}};let breakpointSvc={addBreakPoint,removeBreakPoint,removeAllBreakPoints,hasConditionSatisfied,enableBreakPoints,getAllBreakPoints};export default breakpointSvc;window.breakpointSvc=breakpointSvc;","map":null,"metadata":{},"sourceType":"module"}