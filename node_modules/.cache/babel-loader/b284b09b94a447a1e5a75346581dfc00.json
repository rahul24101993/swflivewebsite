{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This service is used for plTable as Column Rearrangement\n *\n * @module js/splmTableColumnRearrangement\n *\n */import _ from'lodash';import eventBus from'js/eventBus';import splmTableDragHandler from'js/splmTableDragHandler';import Const from'js/splmTableConstants';import util from'js/splmTableUtils';/**\n * Instances of this class represent a column rearrangement utility for PL Table\n *\n * @class SPLMTableColumnRearrangement\n * @param {DOMElement} tableElem - HTML DOM Element for table\n */var SPLMTableColumnRearrangement=function(tableElem){var _columnRearrangementInProgress=false;var _columnsRearranged=false;var self=this;/**\n     * Switch the column indexes of the column definitions attached to the headers.\n     *\n     * @param {DOMElement} header1 - first header\n     * @param {DOMElement} header2 - second header\n     *\n     * @returns {Boolean} was column index switch successful?\n     */var switchColumnDefIndexes=function(header1,header2){var header1ColumnDefElement=header1.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];var header2ColumnDefElement=header2.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];if(header1ColumnDefElement&&header1ColumnDefElement.columnDef&&header2ColumnDefElement&&header2ColumnDefElement.columnDef){var tempColumnIndex=header1ColumnDefElement.columnDef.index;header1ColumnDefElement.columnDef.index=header2ColumnDefElement.columnDef.index;header2ColumnDefElement.columnDef.index=tempColumnIndex;return true;}return false;};/**\n     * Rearrange the column headers if the position parameter is outside the bounds of the original header element.\n     *\n     * @param {HTMLElement} element - the header element\n     * @param {Number} positionX - The X position to check for position of drag\n     *\n     * @returns {Boolean} if the columns were rearranged\n     */var rearrangeColumnHeaders=function(element,positionX){var elementBoundingBox=element.getBoundingClientRect();var nextSibling=element.nextSibling;var previousSibling=element.previousSibling;if(nextSibling&&positionX>elementBoundingBox.right+nextSibling.getBoundingClientRect().width/3&&nextSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE)&&switchColumnDefIndexes(nextSibling,element)){element.parentNode.insertBefore(nextSibling,element);return true;}else if(previousSibling&&positionX<elementBoundingBox.left-previousSibling.getBoundingClientRect().width/2&&previousSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE)&&switchColumnDefIndexes(previousSibling,element)){element.parentNode.insertBefore(element,previousSibling);return true;}return false;};/**\n     * Rearrange the content cells based on the columnDef indexes now.\n     * @param {Number} originalPosition - The original index of the column\n     * @param {Object} columnDef - the column definition\n     */var rearrangeContent=function(originalPosition,columnDef){if(originalPosition===columnDef.index){return;}var targetIndex=originalPosition<columnDef.index?-1:1;var targetContentElements=util.getColumnContentCellElementsByIndex(tableElem,columnDef.index+targetIndex);var draggedContentElements=util.getColumnContentCellElementsByIndex(tableElem,columnDef.index);for(var i=0;i<draggedContentElements.length;i++){var currentContentElement=draggedContentElements[i];var currentTargetContentElement=targetContentElements[i];if(originalPosition<columnDef.index){currentTargetContentElement=currentTargetContentElement.nextSibling;}currentContentElement.parentNode.insertBefore(currentContentElement,currentTargetContentElement);}};/**\n     * Attaches the drag header events to the header element paramter.\n     *\n     * @param {DOMElement} element - header element to attach drag events\n     */var attachDragHeader=function(element){var nextX=0;var currentX=0;var clonedElement;var columnDef;var originalPosition;element.classList.add(Const.CLASS_HEADER_DRAGGABLE);var columnDefElement=element.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];var startDragElement=function(customEvent){// Clean up menu if exist\nvar menuService=util.getTableMenuService(tableElem);menuService.ensureAllTableMenusDismissed();var event=customEvent?customEvent.detail:window.event;clonedElement=element.cloneNode(true);clonedElement.classList.add(Const.CLASS_UTILITY_HIDDEN);clonedElement.setAttribute('id',clonedElement.id+'ClonedHeader');// Attachment to container because of rendering problems when attached to the row\nvar elementContainer=util.closestElement(element,'.'+Const.CLASS_PIN_CONTAINER+',.'+Const.CLASS_SCROLL_CONTAINER);var scrollLeft=elementContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0].scrollLeft;elementContainer.appendChild(clonedElement);clonedElement.style.left=element.offsetLeft-scrollLeft+'px';clonedElement.style.top=element.offsetTop+'px';currentX=event.clientX;if(columnDefElement&&columnDefElement.columnDef){columnDef=columnDefElement.columnDef;originalPosition=columnDef.index;}};/**\n         *  Event to run when movement of header is in progress. Moves the element and any headers it moves over.\n         *\n         * @param {DOMEvent} customEvent - event being sent ( wrapped from 'mousemove' )\n         */var dragElement=function(customEvent){var event=customEvent?customEvent.detail:window.event;if(!_columnRearrangementInProgress){element.classList.add('stationaryHeader');clonedElement.classList.add('dragHeader');clonedElement.classList.remove(Const.CLASS_UTILITY_HIDDEN);_columnRearrangementInProgress=true;}nextX=currentX-event.clientX;currentX=event.clientX;clonedElement.style.left=clonedElement.offsetLeft-nextX+'px';_columnsRearranged=rearrangeColumnHeaders(element,event.clientX)||_columnsRearranged;};/**\n         * End the drag movement and replace the original header element visibility.\n         *\n         */var closeDragElement=function(){element.classList.remove('stationaryHeader');clonedElement.parentNode.removeChild(clonedElement);_columnRearrangementInProgress=false;if(_columnsRearranged){_columnsRearranged=false;var eventData={name:columnDef.name,originalPosition:originalPosition};tableElem._tableInstance.tableInstanceCallbacks.columnsRearranged(eventData);rearrangeContent(originalPosition,columnDef);}};// Column Header = Label + Sort Icon + Splitter\n// Sort Icon will occupy all spaces by flex-grow\nvar contentsElement=element.getElementsByClassName(Const.CLASS_CELL_CONTENTS)[0];splmTableDragHandler.enableDragging(contentsElement);contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_START,startDragElement);contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG,dragElement);contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_END,closeDragElement);};/**\n     * Initializes the table with header column rearrangement by dragging.\n     */self.initialize=function(){var headerCellElements=tableElem.getElementsByClassName(Const.CLASS_HEADER_CELL);_.forEach(headerCellElements,function(headerCellElement){var columnDefinition;var foundElements=headerCellElement.getElementsByClassName(Const.CLASS_COLUMN_DEF);if(foundElements.length>0){columnDefinition=foundElements[0].columnDef;}if(columnDefinition&&columnDefinition.enableColumnMoving!==false){attachDragHeader(headerCellElement);}});};self.initialize();return self;};export default SPLMTableColumnRearrangement;","map":null,"metadata":{},"sourceType":"module"}