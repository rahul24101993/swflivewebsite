{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\services\\\\src\\\\js\\\\moduleLoader.js\";\n/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* global\nafxWeakImport\nAFX_EXTRA_DEPS\n*/\n\n/**\n * mock for dynamic import\n *\n * @module js/moduleLoader\n *\n * @namespace moduleLoader\n */\n\nimport _ from 'lodash';\nimport loadable from '@loadable/component';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwBaseService from 'js/awBaseService';\nimport { parseImports } from 'js/utils';\nimport { getImageAliasFromId } from 'js/imageRegistry';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet _includedComponentCache = {}; // revisitme - like John said we can do deps: () => callback directly. But approach\n// below is lowest impact solution\n\nconst dynImportRegistration = {\n  'js/browserUtils': async () => await import('js/browserUtils')\n};\n/**\n * register dynamic import entry to dynImportRegistration.\n * mainly used by all JSON loader.\n * has best compatibility to existing declUtils design\n * @param {String} name module name when we use it in JSON\n * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`\n */\n\nexport const registerDynImportEntry = (name, callback) => {\n  dynImportRegistration[name] = callback;\n};\nAFX_EXTRA_DEPS;\nexport const loadDynModule = name => {\n  if (dynImportRegistration[name] !== undefined) {\n    return new Promise(resolve => {\n      dynImportRegistration[name]().then(obj => {\n        const resolved = obj && obj.__esModule && obj.default ? obj.default : obj;\n\n        if (resolved.prototype instanceof AwBaseService) {\n          return resolve(resolved.instance);\n        }\n\n        return resolve(resolved);\n      });\n    });\n  }\n\n  throw Error(`Library ${name} does not exist!`);\n};\nexport const afxDynamicImport = (deps, func) => {\n  let modules = [];\n\n  for (const contri of deps) {\n    modules.push(loadDynModule(contri));\n  }\n\n  return new Promise(resolve => {\n    // LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick\n    // behavior in requirejs.\n    setTimeout(() => {\n      return Promise.all(modules).then(response => {\n        return resolve(func.apply(null, response.map(obj => obj && obj.__esModule && obj.default ? obj.default : obj)));\n      });\n    }, 0);\n  });\n};\n/**\n * Get angular injected module if necessary\n *\n * @param {*} moduleObj - The loaded module\n * @return {Object} Updated dep module\n */\n\nconst getModuleInstance = moduleObj => {\n  if (moduleObj && moduleObj.prototype instanceof AwBaseService) {\n    return moduleObj.instance;\n  }\n\n  return moduleObj;\n};\n/**\n * Get a module synchronously. Returns null if module is not loaded.\n *\n * @param {*} depModuleName -\n *\n * @returns {Object|null} Reference to module API object.\n */\n\n\nexport const getDependentModule = depModuleName => {\n  /** revisitme\n   *  remove me later (loadModule)\n   */\n  return loadDynModule(depModuleName); // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n  // afxWeakImport will be setup either in aw_polyfill or afxImport\n  //return afxWeakImport( depModuleName );\n};\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\n\nexport const loadDependentModule = depModule => {\n  return getDependentModule(depModule);\n  /**\n   * revsitme\n   * afxDynamicImport is not supported yet\n   */\n  // return AwPromiseService.instance( function( resolve, reject ) {\n  //     if( depModule ) {\n  //         afxDynamicImport( [ depModule ], function( depModule2 ) {\n  //             resolve( getModuleInstance( depModule2 ) );\n  //         }, reject );\n  //     } else {\n  //         resolve();\n  //     }\n  // } );\n};\nexport const loadStaticDependentModule = depModule => {\n  if (depModule) {\n    return getModuleInstance(depModule);\n  }\n\n  return undefined;\n};\n/**\n * @param {String[]} depModules - The dependent modules to load.\n * @return {Promise} This promise will be resolved when the given module has been loaded.\n */\n\nexport const loadDependentModules = depModules => {\n  return AwPromiseService.instance(function (resolve, reject) {\n    if (depModules && depModules.length > 0) {\n      afxDynamicImport(depModules, function () {\n        let retModulesMap = {}; // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n        // This interface has bug for the else block, in no case it\n        // will return arg as string which can run injector.get(arg)\n        // who is using this interface will only supports angularJS service\n        // with other limitaton\n        //\n        // They are:\n        // - AFX\n        //   - find function.deps in actionService\n        //     - Example: src\\thinclient\\requirementscommandpanelsjs\\src\\viewmodel\\Arm0ExportToRoundTripWordDocumentViewModel.json\n        //     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc\n        //       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method\n        //       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')\n        //   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)\n        //   - highlighterService -> this is fine which is a blind load\n        // - AW\n        //   - Ase0DualSaveHandler -> this is fine which is a blind load\n        //   - aw-gantt.controller -> this is fine which is a blind load\n        //\n        // - Long term solution\n        //   - Rewrite the interface to retrun array only. Refactor all caller\n        // - Short term solution\n        //   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)\n        //\n        // - How function definition works today\n        //   - Not all function definition supports deps, only function in viewModel ( details see schema )\n        //   - all the function imple should be sync otherwise you will get a unexpected promise object\n        //   - It has different behavior in different place:\n        //     - inputData.data: \"{{function:testFunc}}\"\n        //       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.\n        //       - While loading the deps by this function, it will blindly add key-module pare to depModules,\n        //         For example you will get someActionService['functionSvcName'] = functionService, with all\n        //         method provided by someActionService together...\n        //       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules\n        //         recursively to get the corrct function\n        //         - But if a same function exist in someActionService, it will still take priority...\n        //\n        //     - outputData: \"{{function: testFunc}}\"\n        //       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD\n        //         BE the actual key in deps. For example:\n        //         - You define { functions: { aaa: { functionName: showInfo }}}\n        //         - When use it, we use {{function:showInfo}}, not {{function:aaa}}\n        //       - No matter what you put in deps, it will always go to main dep (action dep)\n        //         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)\n\n        _.forEach(arguments, function (arg, idx) {\n          let moduleName = depModules[idx].replace(/^.*\\//, '');\n\n          if (arg.prototype instanceof AwBaseService) {\n            retModulesMap[moduleName] = arg.instance;\n          } else {\n            retModulesMap[moduleName] = arg;\n          }\n        });\n\n        resolve(retModulesMap);\n      });\n    } else {\n      resolve();\n    }\n  });\n};\n/**\n * Loading the imported JS\n *\n * @param {StringArray} moduleNames - Array of module's to 'import'.\n *\n * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent\n *         modules.\n */\n\nexport const loadImports = moduleNames => {\n  return AwPromiseService.instance(function (resolve, reject) {\n    if (moduleNames && moduleNames.length > 0) {\n      afxDynamicImport(moduleNames, function () {\n        var moduleObjs = [];\n\n        _.forEach(arguments, function (arg) {\n          if (arg) {\n            if (arg.prototype instanceof AwBaseService) {\n              moduleObjs.push(arg.instance);\n            } else {\n              moduleObjs.push(arg);\n            }\n          }\n        });\n\n        resolve(moduleObjs);\n      });\n    } else {\n      resolve();\n    }\n  });\n};\n/**\n * Loading the imported svgs dynamically.\n *\n * @param {String} imageId - String ImageId which can either be complete alias or just imageId.\n * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.\n * @returns Dynamic Image Component\n */\n\nexport const includeImage = (imageId, exactMatch) => {\n  if (imageId) {\n    let DynamicComponent = _includedComponentCache[imageId];\n\n    if (!DynamicComponent) {\n      const imageAlias = exactMatch ? imageId : getImageAliasFromId(imageId);\n      DynamicComponent = loadable(() => {\n        try {\n          return loadDynModule(imageAlias).then(resolved => resolved.SvgComponent);\n        } catch (error) {\n          console.log(error.message);\n          return Promise.resolve(() => null);\n        }\n      }, {\n        fallback: /*#__PURE__*/_jsxDEV(\"svg\", {\n          style: {\n            width: '16px',\n            height: '16px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 257,\n          columnNumber: 28\n        }, this)\n      });\n      _includedComponentCache[imageId] = DynamicComponent;\n    } // add viewId to facilitate debug\n\n\n    return /*#__PURE__*/_jsxDEV(DynamicComponent, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 16\n    }, this);\n  }\n};\nexport const includeComponent = (componentName, prop) => {\n  if (componentName) {\n    let DynamicComponent = _includedComponentCache[componentName];\n    let viewId = prop.viewId ? prop.viewId : componentName;\n\n    if (!DynamicComponent) {\n      DynamicComponent = loadable(() => {\n        try {\n          return loadDynModule(`viewmodel/${componentName}ViewModel`);\n        } catch (error) {\n          console.log(error.message);\n          return Promise.resolve(() => null);\n        }\n      });\n      _includedComponentCache[componentName] = DynamicComponent;\n    } // add viewId to facilitate debug\n\n\n    return /*#__PURE__*/_jsxDEV(DynamicComponent, {\n      viewId: viewId,\n      ...prop\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 16\n    }, this);\n  }\n};\nwindow.afxDynamicImport = afxDynamicImport; // dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build\n// AFX_CONFIG_ENTRY\n\nregisterDynImportEntry('lodash', () => import('lodash'));\nregisterDynImportEntry('js/configurationService', () => import('js/configurationService'));\nregisterDynImportEntry('js/viewModelService', () => import('js/viewModelService')); // export default for test purpose\n\nexport default {\n  getDependentModule,\n  loadDependentModule,\n  includeComponent,\n  loadStaticDependentModule,\n  loadDependentModules,\n  loadImports,\n  includeImage\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/moduleLoader.js"],"names":["_includedComponentCache","dynImportRegistration","registerDynImportEntry","AFX_EXTRA_DEPS","loadDynModule","name","resolve","obj","resolved","Error","afxDynamicImport","modules","setTimeout","response","func","getModuleInstance","moduleObj","getDependentModule","depModuleName","loadDependentModule","depModule","loadStaticDependentModule","loadDependentModules","depModules","retModulesMap","_","moduleName","arg","loadImports","moduleNames","moduleObjs","includeImage","DynamicComponent","imageAlias","exactMatch","getImageAliasFromId","loadable","console","error","Promise","fallback","width","height","includeComponent","viewId","prop","componentName","window"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* global\nafxWeakImport\nAFX_EXTRA_DEPS\n*/\n\n/**\n * mock for dynamic import\n *\n * @module js/moduleLoader\n *\n * @namespace moduleLoader\n */\n\nimport _ from 'lodash';\nimport loadable from '@loadable/component';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwBaseService from 'js/awBaseService';\nimport { parseImports } from 'js/utils';\nimport { getImageAliasFromId } from 'js/imageRegistry';\n\nlet _includedComponentCache = {};\n\n// revisitme - like John said we can do deps: () => callback directly. But approach\n// below is lowest impact solution\nconst dynImportRegistration = {\n    'js/browserUtils': async () => await import( 'js/browserUtils' )\n};\n\n/**\n * register dynamic import entry to dynImportRegistration.\n * mainly used by all JSON loader.\n * has best compatibility to existing declUtils design\n * @param {String} name module name when we use it in JSON\n * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`\n */\nexport const registerDynImportEntry = ( name, callback ) => {\n    dynImportRegistration[ name ] = callback;\n};\n\nAFX_EXTRA_DEPS;\n\nexport const loadDynModule = name => {\n    if( dynImportRegistration[ name ] !== undefined ) {\n        return new Promise( resolve => {\n            dynImportRegistration[ name ]().then( obj => {\n                const resolved = obj && obj.__esModule && obj.default ? obj.default : obj;\n                if( resolved.prototype instanceof AwBaseService ) {\n                    return resolve( resolved.instance );\n                }\n                return resolve( resolved );\n            } );\n        } );\n    }\n    throw Error( `Library ${name} does not exist!` );\n};\n\nexport const afxDynamicImport = ( deps, func ) => {\n    let modules = [];\n    for( const contri of deps ) {\n        modules.push( loadDynModule( contri ) );\n    }\n\n    return new Promise( resolve => {\n        // LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick\n        // behavior in requirejs.\n        setTimeout( () => {\n            return Promise.all( modules ).then( response => {\n                return resolve( func.apply( null, response.map( obj => obj && obj.__esModule && obj.default ? obj.default : obj ) ) );\n            } );\n        }, 0 );\n    } );\n};\n\n/**\n * Get angular injected module if necessary\n *\n * @param {*} moduleObj - The loaded module\n * @return {Object} Updated dep module\n */\nconst getModuleInstance = ( moduleObj ) => {\n    if( moduleObj && moduleObj.prototype instanceof AwBaseService ) {\n        return moduleObj.instance;\n    }\n    return moduleObj;\n};\n\n/**\n * Get a module synchronously. Returns null if module is not loaded.\n *\n * @param {*} depModuleName -\n *\n * @returns {Object|null} Reference to module API object.\n */\nexport const getDependentModule = depModuleName => {\n    /** revisitme\n     *  remove me later (loadModule)\n     */\n    return loadDynModule( depModuleName );\n\n    // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n    // afxWeakImport will be setup either in aw_polyfill or afxImport\n    //return afxWeakImport( depModuleName );\n};\n\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\nexport const loadDependentModule = depModule => {\n    return getDependentModule( depModule );\n    /**\n     * revsitme\n     * afxDynamicImport is not supported yet\n     */\n    // return AwPromiseService.instance( function( resolve, reject ) {\n    //     if( depModule ) {\n    //         afxDynamicImport( [ depModule ], function( depModule2 ) {\n    //             resolve( getModuleInstance( depModule2 ) );\n    //         }, reject );\n    //     } else {\n    //         resolve();\n    //     }\n    // } );\n};\n\nexport const loadStaticDependentModule = depModule => {\n    if( depModule ) {\n        return getModuleInstance( depModule );\n    }\n    return undefined;\n};\n\n/**\n * @param {String[]} depModules - The dependent modules to load.\n * @return {Promise} This promise will be resolved when the given module has been loaded.\n */\nexport const loadDependentModules = depModules => {\n    return AwPromiseService.instance( function( resolve, reject ) {\n        if( depModules && depModules.length > 0 ) {\n            afxDynamicImport( depModules, function() {\n                let retModulesMap = {};\n                // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n                // This interface has bug for the else block, in no case it\n                // will return arg as string which can run injector.get(arg)\n                // who is using this interface will only supports angularJS service\n                // with other limitaton\n                //\n                // They are:\n                // - AFX\n                //   - find function.deps in actionService\n                //     - Example: src\\thinclient\\requirementscommandpanelsjs\\src\\viewmodel\\Arm0ExportToRoundTripWordDocumentViewModel.json\n                //     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc\n                //       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method\n                //       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')\n                //   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)\n                //   - highlighterService -> this is fine which is a blind load\n                // - AW\n                //   - Ase0DualSaveHandler -> this is fine which is a blind load\n                //   - aw-gantt.controller -> this is fine which is a blind load\n                //\n                // - Long term solution\n                //   - Rewrite the interface to retrun array only. Refactor all caller\n                // - Short term solution\n                //   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)\n                //\n                // - How function definition works today\n                //   - Not all function definition supports deps, only function in viewModel ( details see schema )\n                //   - all the function imple should be sync otherwise you will get a unexpected promise object\n                //   - It has different behavior in different place:\n                //     - inputData.data: \"{{function:testFunc}}\"\n                //       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.\n                //       - While loading the deps by this function, it will blindly add key-module pare to depModules,\n                //         For example you will get someActionService['functionSvcName'] = functionService, with all\n                //         method provided by someActionService together...\n                //       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules\n                //         recursively to get the corrct function\n                //         - But if a same function exist in someActionService, it will still take priority...\n                //\n                //     - outputData: \"{{function: testFunc}}\"\n                //       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD\n                //         BE the actual key in deps. For example:\n                //         - You define { functions: { aaa: { functionName: showInfo }}}\n                //         - When use it, we use {{function:showInfo}}, not {{function:aaa}}\n                //       - No matter what you put in deps, it will always go to main dep (action dep)\n                //         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)\n                _.forEach( arguments, function( arg, idx ) {\n                    let moduleName = depModules[ idx ].replace( /^.*\\//, '' );\n\n                    if( arg.prototype instanceof AwBaseService ) {\n                        retModulesMap[ moduleName ] = arg.instance;\n                    } else {\n                        retModulesMap[ moduleName ] = arg;\n                    }\n                } );\n                resolve( retModulesMap );\n            } );\n        } else {\n            resolve();\n        }\n    } );\n};\n\n/**\n * Loading the imported JS\n *\n * @param {StringArray} moduleNames - Array of module's to 'import'.\n *\n * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent\n *         modules.\n */\nexport const loadImports = moduleNames => {\n    return AwPromiseService.instance( function( resolve, reject ) {\n        if( moduleNames && moduleNames.length > 0 ) {\n            afxDynamicImport( moduleNames, function() {\n                var moduleObjs = [];\n                _.forEach( arguments, function( arg ) {\n                    if( arg ) {\n                        if( arg.prototype instanceof AwBaseService ) {\n                            moduleObjs.push( arg.instance );\n                        } else {\n                            moduleObjs.push( arg );\n                        }\n                    }\n                } );\n                resolve( moduleObjs );\n            } );\n        } else {\n            resolve();\n        }\n    } );\n};\n\n/**\n * Loading the imported svgs dynamically.\n *\n * @param {String} imageId - String ImageId which can either be complete alias or just imageId.\n * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.\n * @returns Dynamic Image Component\n */\nexport const includeImage = ( imageId, exactMatch ) => {\n    if( imageId ) {\n        let DynamicComponent = _includedComponentCache[ imageId ];\n        if( !DynamicComponent ) {\n            const imageAlias = exactMatch ? imageId : getImageAliasFromId( imageId );\n            DynamicComponent = loadable( () => {\n                try {\n                    return loadDynModule( imageAlias ).then( resolved => resolved.SvgComponent );\n                } catch ( error ) {\n                    console.log( error.message );\n                    return Promise.resolve( () => null );\n                }\n            }, { fallback: <svg style={{ width: '16px', height: '16px' }}></svg> } );\n            _includedComponentCache[ imageId ] = DynamicComponent;\n        }\n        // add viewId to facilitate debug\n        return <DynamicComponent/>;\n    }\n};\n\nexport const includeComponent = ( componentName, prop ) => {\n    if( componentName ) {\n        let DynamicComponent = _includedComponentCache[ componentName ];\n        let viewId = prop.viewId ? prop.viewId : componentName;\n        if( !DynamicComponent ) {\n            DynamicComponent = loadable( () => {\n                try {\n                    return loadDynModule( `viewmodel/${componentName}ViewModel` );\n                } catch ( error ) {\n                    console.log( error.message );\n                    return Promise.resolve( () => null );\n                }\n            } );\n            _includedComponentCache[ componentName ] = DynamicComponent;\n        }\n        // add viewId to facilitate debug\n        return <DynamicComponent viewId={viewId} { ...prop} />;\n    }\n};\n\nwindow.afxDynamicImport = afxDynamicImport;\n\n// dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build\n// AFX_CONFIG_ENTRY\nregisterDynImportEntry('lodash', () => import('lodash'));\nregisterDynImportEntry('js/configurationService', () => import('js/configurationService'));\nregisterDynImportEntry('js/viewModelService', () => import('js/viewModelService'));\n\n// export default for test purpose\nexport default {\n    getDependentModule,\n    loadDependentModule,\n    includeComponent,\n    loadStaticDependentModule,\n    loadDependentModules,\n    loadImports,\n    includeImage\n};\n"]},"metadata":{},"sourceType":"module"}