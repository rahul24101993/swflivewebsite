{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * This service manages tiles drag and reorder functionality.\n *\n * @module js/tileDragService\n */\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\n/**\n   * Static Strings referencing css classes\n   */\n\nvar TILEMAIN_CSS_CLASS = 'aw-tile-tileMain';\nvar TILE_CONT_CSS_CLASS = 'sw-column.aw-tile-tileContainer';\nvar TILE_DRAGGABLE_CSS_CLASS = 'aw-tile-draggable';\nvar TILEGROUP_CSS_CLASS = 'aw-tile-tileGroup';\nvar PLACEHOLDER_GROUP_CSS_CLASS = 'aw-tile-placeHolderGroupSep';\nvar PLACEHOLDER_TILE_CSS_CLASS = 'aw-tile-placeHolderTile';\nvar DRAGTILE_CSS_CLASS = 'aw-tile-dragTile';\nvar TILE_GROUP_TAGNAME = 'aw-tile-group';\nvar TILE_MAIN_CONTAINER_CSS_CLASS = 'aw-tile-mainContainer';\n/**\n   * <pre>\n   * Greater Than 0 If some basic event activity should be logged.\n   * Greater Than 1 If some more fine-grained event activity should be logged.\n   * </pre>\n   */\n\nvar _debug_logEventActivity = 0;\nvar placeHolderTile;\nlet draggedTileInfo;\nlet droppedTileInfo;\n/**\n   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n   *\n   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n   *            test.\n   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n   */\n\nvar _isValidToDrop = function (event) {\n  return true;\n};\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   * @param {Boolean} isNewGroup - If a new tile group is to be created\n   *\n   * @return {Element} The Element where we need to reorder and insert dragged tile after this.\n   */\n\n\nvar _findDropTargetElement = function (event, isNewGroup) {\n  var dropTarget = {};\n  dropTarget.inPlace = false;\n  let eventSrc = event.currentTarget;\n\n  if (isNewGroup) {\n    var placeholderGroup = $('.' + TILE_MAIN_CONTAINER_CSS_CLASS).find('.' + PLACEHOLDER_GROUP_CSS_CLASS);\n    dropTarget.element = placeholderGroup.prev('.' + TILEGROUP_CSS_CLASS); // For the use case of the previous element not being an actual tile group\n\n    while (dropTarget.element.hasClass('aw-tile-emptyTileGroup')) {\n      dropTarget.element = dropTarget.element.prev('.' + TILEGROUP_CSS_CLASS);\n    } // If the new group is in the 1st tile group location\n\n\n    if (dropTarget.element.length === 0) {\n      dropTarget.element = dropTarget.element.prevObject;\n    }\n\n    dropTarget.element = dropTarget.element[0];\n    return dropTarget;\n  }\n\n  dropTarget.element = $('.aw-tile-mainContainer .aw-tile-placeHolderTile');\n\n  if (dropTarget.element.length === 0) {\n    if (!$(eventSrc).hasClass(TILE_DRAGGABLE_CSS_CLASS)) {\n      // find the closest\n      var parentTileElem = $(eventSrc).closest('.' + TILE_DRAGGABLE_CSS_CLASS); // if its not on the parent level, then try to find it in the children\n\n      if (parentTileElem.length === 0) {\n        parentTileElem = $(eventSrc).find('.' + TILE_DRAGGABLE_CSS_CLASS);\n      }\n\n      if (parentTileElem && parentTileElem.length > 0) {\n        dropTarget.element = parentTileElem[0];\n      }\n    } else {\n      dropTarget.element = eventSrc;\n    }\n  } else {\n    //  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'\n    if (dropTarget.element[0].style.order === '0' && dropTarget.element.next().length !== 0) {\n      dropTarget.element = dropTarget.element.next();\n      dropTarget.inPlace = true;\n    } else {\n      dropTarget.element = dropTarget.element.prev();\n    }\n  }\n\n  return dropTarget;\n};\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   *\n   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order\n   * of dragged tile.\n   */\n\n\nvar _findDragEnterElement = function (event) {\n  var dragEnterElement;\n  let eventSrc = event.target; // find the closest\n\n  let parentTileElem = $(eventSrc).closest('.' + TILE_DRAGGABLE_CSS_CLASS);\n\n  if (parentTileElem && parentTileElem.length > 0) {\n    dragEnterElement = parentTileElem[0];\n  } else if ($(eventSrc).hasClass(TILEGROUP_CSS_CLASS)) {\n    dragEnterElement = $(eventSrc);\n  }\n\n  return dragEnterElement;\n};\n/**\n   * Remove place holder elements from DOM.\n   */\n\n\nvar _removePlaceHolders = function () {\n  $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).remove();\n  $('.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS).remove();\n};\n/**\n   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping\n   *\n   * @return {Element} The Element which represents dummy placeHolder tileGroup\n   */\n\n\nvar _createPlaceHolderTileGroup = function () {\n  // hidden tile to place it where dragging tile will dropped\n  var newTileGroup = $('<div class=\"' + TILEGROUP_CSS_CLASS + '\"></div>');\n  newTileGroup.addClass(PLACEHOLDER_GROUP_CSS_CLASS);\n  return newTileGroup;\n};\n/**\n   * Create dummy placeHolder Tile element to represent the position in the UI before dropping\n   *\n   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element\n   *\n   * @return {Element} The Element which represents dummy placeHolder tile\n   */\n\n\nvar _createPlaceHolderTile = function (sourceTile) {\n  // hidden tile to place it where dragging tile will dropped\n  placeHolderTile = $('<div class=\"' + PLACEHOLDER_TILE_CSS_CLASS + '\"></div>');\n  placeHolderTile.addClass(TILEMAIN_CSS_CLASS);\n\n  if ($(sourceTile).hasClass('aw-tile-doubleSize')) {\n    placeHolderTile.addClass('aw-tile-doubleSize');\n  } else if ($(sourceTile).hasClass('aw-tile-tripleSize')) {\n    placeHolderTile.addClass('aw-tile-tripleSize');\n  } else if ($(sourceTile).hasClass('aw-tile-quadroSize')) {\n    placeHolderTile.addClass('aw-tile-quadroSize');\n  }\n\n  if ($(sourceTile).hasClass('aw-tile-doubleVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-doubleVerticalSize');\n  } else if ($(sourceTile).hasClass('aw-tile-tripleVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-tripleVerticalSize');\n  } else if ($(sourceTile).hasClass('aw-tile-quadroVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-quadroVerticalSize');\n  }\n\n  return placeHolderTile;\n};\n/**\n   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements\n   *\n   * @param {Element} dragTileIn - The DOM element for dragging tile\n   * @param {Element} element - container element for dragging tile\n   */\n\n\nvar _cleanUp = function (dragTileIn, element) {\n  _removePlaceHolders();\n\n  if (dragTileIn) {\n    dragTileIn.removeAttribute('id');\n  } else {\n    let dragTile = document.querySelector('#draggedTile');\n    dragTile.classList.remove(DRAGTILE_CSS_CLASS);\n    dragTile.removeAttribute('id');\n    let tileContElem = dragTile;\n  }\n\n  placeHolderTile = null;\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('Cleaning up');\n  }\n};\n/**\n   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n   * 'target'.\n   *\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Element} targetElement - The target element associate with dragEnter event\n   */\n\n\nvar _processDragEnterInternal = function (event, targetElement, targetObjects) {\n  event.preventDefault(); // place phantom tile instead dragging one\n\n  if (placeHolderTile && targetElement && targetObjects) {\n    // reordering in existing tiles\n    if ($(targetElement).hasClass(TILEMAIN_CSS_CLASS) && $(targetElement).hasClass(TILE_DRAGGABLE_CSS_CLASS)) {\n      _removePlaceHolders();\n\n      var targetCssOrder = targetElement.style.order;\n      var order = parseInt(targetCssOrder, 10);\n      var side;\n      var element = $(targetElement)[0];\n      var mouseX = event.clientX;\n      var elementWidth = element.offsetWidth;\n      var halfElementWidth = elementWidth / 2;\n\n      if (mouseX > halfElementWidth + element.offsetLeft) {\n        side = 'right';\n      } else {\n        side = 'left';\n      } // If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after\n\n\n      if (order === 0 && side === 'left') {\n        placeHolderTile.insertBefore(targetElement);\n        $(placeHolderTile).css('order', 0);\n      } else {\n        placeHolderTile.insertAfter(targetElement);\n        $(placeHolderTile).css('order', order++);\n      }\n\n      _.forEach($(placeHolderTile).nextAll(), function (nextSib) {\n        if (nextSib) {\n          nextSib.style.order = order++;\n        }\n      });\n\n      if (_debug_logEventActivity >= 1) {\n        var tgtTile = targetObjects[0].tile;\n        postLog('processDragEnter - PlaceHolder Tile Inserted: ' + tgtTile.displayName);\n      }\n    } else if ($(targetElement).hasClass(TILEGROUP_CSS_CLASS)) {\n      // vertically or horizontally creating new group\n      _removePlaceHolders();\n\n      var targetGroupElem = $(targetElement);\n\n      var placeHolderTileGroup = _createPlaceHolderTileGroup();\n\n      placeHolderTileGroup.insertBefore(targetGroupElem[0]);\n\n      if (_debug_logEventActivity >= 1) {\n        postLog('processDragEnter - Insert vertical or horizontal placeHolder Group');\n      }\n    }\n\n    droppedTileInfo = {\n      targetTile: targetObjects[0].tile,\n      targetTileGroup: targetObjects[0].tileGroup,\n      viewModel: targetObjects.viewModel\n    };\n  }\n};\n/**\n   * Get base order value from the input parameter's order number\n   * <p>\n   * ex: 212 -> returns 200; 399 -> returns 300\n   *\n   * @param {Number} orderNumber - order number\n   * @returns {Number} base order number if orderNumber is defined, otherwise 0\n   */\n\n\nfunction getBaseOrder(orderNumber) {\n  if (!orderNumber) {\n    return 0;\n  }\n\n  var tensAndOnesDigits = orderNumber % 100;\n  return orderNumber - tensAndOnesDigits;\n}\n/**\n   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n   *\n   * @param {DragEvent} event - The DragEvent to set the DragData on.\n   * @param {Object} dragDataMap - Map of name/value pairs to add.\n   */\n\n\nfunction addDragDataToDragEvent(event, dragDataMap) {\n  if (event.dataTransfer && dragDataMap) {\n    event.dataTransfer.setData('text', JSON.stringify({\n      sourceTile: dragDataMap.sourceTile,\n      sourceGroupName: dragDataMap.sourceTileGroup.groupName\n    }));\n  }\n\n  draggedTileInfo = dragDataMap;\n}\n/**\n   * Update the drag image for the DragEvent based on draggable element.\n   *\n   * @param {DragEvent} event - The DragEvent to set the image on.\n   * @param {DOMElement} draggableElem - element being dragged.\n   */\n\n\nfunction updateDragImage(event, draggableElem) {\n  /**\n     * Internet Explorer doesn't support setDragImage at all.\n     * <P>\n     * See: http://mereskin.github.io/dnd/\n     */\n  if (!browserUtils.isIE && event.dataTransfer) {\n    /**\n       * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n       * should be resolved after moving the list view to a flex display.\n       */\n    event.dataTransfer.setDragImage(draggableElem, 0, 0);\n  }\n}\n/**\n   * Processes drag start event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   * @param {Element} element - The DOM element considered the 'source' of the given drag event.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   */\n\n\nfunction processDragStart(event, element, targetObjects) {\n  let callBackAPIs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let srcElement = event.target;\n  let sourceTile = targetObjects[0].tile;\n  let sourceTileGroup = targetObjects[0].tileGroup;\n  let tileContElem = srcElement.parentElement.parentElement;\n\n  if (sourceTile) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('processDragStart - Source Tile name: ' + sourceTile.displayName + ' && Source Tile Group name: ' + sourceTileGroup.groupName);\n    }\n\n    element.data('dragging', true);\n    var containerId = element.data('containerId');\n\n    if (!containerId) {\n      containerId = Date.now();\n      element.data('containerId', containerId);\n    }\n\n    let width = 0;\n\n    for (let index = 0; index < 3; index++) {\n      if (index < sourceTileGroup.tiles.length) {\n        width += sourceTileGroup.tiles[index].tileSize + 1;\n      } else {\n        break;\n      }\n    } // // Default width for the single width tile\n\n\n    let parentTileMinWidth = 155 * width + 'px';\n    tileContElem.parentElement.style.minWidth = parentTileMinWidth;\n    tileContElem.setAttribute('id', 'draggedTile');\n    tileContElem.classList.add(DRAGTILE_CSS_CLASS);\n\n    if (event.dataTransfer) {\n      event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n\n    updateDragImage(event, tileContElem);\n    addDragDataToDragEvent(event, {\n      sourceTile: sourceTile,\n      sourceTileGroup: sourceTileGroup\n    });\n    placeHolderTile = _createPlaceHolderTile(srcElement);\n  } else {\n    if (_debug_logEventActivity >= 2) {\n      postLog('processDragStart - no tile Info, Set element data \"dragging\" to false');\n    } // No data so there is no reason to let the object be dragged.\n\n\n    element.data('dragging', false);\n    event.preventDefault();\n  }\n}\n/**\n   * Processes drag over event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   */\n\n\nfunction processDragOver(event) {\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = 'move'; // only allow moves\n  }\n}\n/**\n   * Processes drag enter event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.\n   */\n\n\nfunction processDragEnter(event, targetElement, targetObjects) {\n  if (_isValidToDrop(event)) {\n    let targetData = targetObjects[0].tile;\n    let targetTileGroup = targetObjects[0].tileGroup;\n\n    if (targetData) {\n      if (_debug_logEventActivity >= 2) {\n        if (targetData.tiles) {\n          postLog('processDragEnter - Target tileGroup: ' + targetData.groupName);\n        } else if (targetTileGroup && targetData.displayName) {\n          postLog('processDragEnter - Target tile: ' + targetData.displayName + ' && Target Item tileGroup: ' + targetTileGroup.groupName);\n        } else if (targetTileGroup && !targetData.displayName) {\n          postLog('processDragEnter - Target Item tileGroup: ' + targetTileGroup.groupName);\n        }\n      }\n\n      if (!targetData.tiles && (!targetTileGroup || !targetTileGroup.groupName)) {\n        return;\n      }\n\n      if (event.dataTransfer) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n      }\n\n      let debounceProcessDragEnter = _.debounce(_processDragEnterInternal, 100);\n\n      debounceProcessDragEnter(event, targetElement, targetObjects);\n    }\n  }\n}\n/**\n   * Processes drag leave event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   */\n\n\nfunction processDragLeave(event) {\n  event.preventDefault();\n\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = 'move'; // only allow moves\n  }\n}\n/**\n   * Processes drag end event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   */\n\n\nfunction processDragEnd(event, element, targetObjects) {\n  event.preventDefault();\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDragEnd - Processing drag end');\n  }\n\n  let evtElement = event.target.parentElement.parentElement;\n  $(evtElement).removeClass(DRAGTILE_CSS_CLASS);\n  $(evtElement).removeAttr('id');\n  let tileContElem = event.target;\n}\n/**\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   * @param {Object}  targetObjects\n   */\n\n\nfunction processDrop(event, callBackAPIs, element, targetObjects, props) {\n  const propertyToUpdate = props;\n  event.stopPropagation();\n  event.preventDefault();\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDrop - Processing drop');\n  }\n\n  let dragTile = document.querySelector('#draggedTile');\n  var isNewGroup = false;\n  dragTile.classList.remove(DRAGTILE_CSS_CLASS);\n  dragTile.parentElement.style.minWidth = '';\n  let tileContElem = dragTile.firstElementChild.firstElementChild;\n\n  if ($('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).length > 0) {\n    var prevSiblings = $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).prevAll();\n    var nextSiblings = $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).nextAll();\n    var index = 0;\n\n    _.forEachRight(prevSiblings, function (sibling) {\n      if (sibling.id !== 'draggedTile') {\n        sibling.style.order = index;\n        index++;\n      }\n    });\n\n    if (dragTile) {\n      dragTile.style.order = index;\n      index++;\n\n      if (_debug_logEventActivity >= 1) {\n        postLog('processDrop - Set new order style for dragged tile');\n      }\n    }\n\n    _.forEach(nextSiblings, function (sibling) {\n      if (sibling.id !== 'draggedTile') {\n        sibling.style.order = index;\n        index++;\n      }\n    });\n  } else if ($('.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS).length > 0) {\n    isNewGroup = true;\n  }\n\n  let targetElement = _findDropTargetElement(event, isNewGroup);\n\n  if (!targetElement.element) {\n    _cleanUp(dragTile);\n\n    return;\n  }\n\n  let draggingData = event.dataTransfer.getData('text');\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDrop - Retrieving drag data');\n  }\n\n  if (draggingData) {\n    var dragDataTile = JSON.parse(draggingData);\n    var targetTile = droppedTileInfo.targetTile;\n    let targetTileGroup = droppedTileInfo.targetTileGroup;\n    let canvasViewModel = droppedTileInfo.viewModel;\n\n    if (!isNewGroup && updateOrder && targetTile !== dragDataTile.sourceTile) {\n      updateOrder(canvasViewModel, dragDataTile.sourceTile, dragDataTile.sourceGroupName, targetTile, targetTileGroup, targetElement.inPlace, propertyToUpdate);\n    } else if (isNewGroup && createNewGroup) {\n      var tileGroupElemData = targetObjects[0].tile;\n      var tileGroupData;\n\n      if (tileGroupElemData) {\n        tileGroupData = tileGroupElemData.tileGroup;\n      }\n\n      createNewGroup(dragDataTile.sourceTile, dragDataTile.sourceGroupName, tileGroupData, propertyToUpdate);\n    }\n\n    if (_debug_logEventActivity >= 1) {\n      postLog('processDrop - Dropping data: ' + draggingData);\n    }\n  }\n\n  _cleanUp(dragTile);\n}\n\nexport const dragStartFn = _ref => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref;\n  let targetObjectsDragStart;\n  event.stopPropagation();\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n\n  if (event.target.nodeName === '#text') {\n    jqElement.data('dragging', false);\n    event.preventDefault();\n  } else {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragstart: ' + event);\n    }\n\n    targetObjectsDragStart = assignViewModelToObject(targetObjects, declViewModel);\n    processDragStart(event, jqElement, targetObjectsDragStart, {});\n  }\n};\nexport const dragEndFn = _ref2 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref2;\n  let targetObjectsDragEnd;\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragend: ' + event);\n    }\n\n    jqElement.data('dragging', false);\n\n    var target = _findDropTargetElement(event);\n\n    if (!target) {\n      return;\n    }\n\n    targetObjectsDragEnd = assignViewModelToObject(targetObjects, declViewModel);\n    processDragEnd(event, jqElement, targetObjectsDragEnd);\n  }\n};\nexport const dragOverFn = _ref3 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref3;\n  event.stopPropagation();\n  event.preventDefault();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragover: ' + event);\n    }\n\n    if (_isValidToDrop(event)) {\n      if (event.dataTransfer && !browserUtils.isQt) {\n        event.dataTransfer.dropEffect = 'move'; // only allow moves\n      }\n\n      event.stopPropagation();\n      event.preventDefault();\n\n      var debounceProcessDragOver = _.debounce(processDragOver, 100);\n\n      debounceProcessDragOver(event);\n    }\n  }\n};\nexport const dragEnterFn = _ref4 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref4;\n  let targetObjectsDragEnter;\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragenter: ' + event);\n    }\n\n    var target = _findDragEnterElement(event);\n\n    if (!target) {\n      return;\n    }\n\n    targetObjectsDragEnter = assignViewModelToObject(targetObjects, declViewModel);\n    targetObjects.viewModel = declViewModel;\n    processDragEnter(event, target, targetObjectsDragEnter);\n  }\n};\nexport const createNewGroup = function (viewModel, sourceTile, sourceGroupName, targetTileGroup) {\n  var sourceGroup = self.getTileGroup(sourceGroupName);\n  var sourceGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, sourceGroup);\n  var targetGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, targetTileGroup);\n  var sourceTileIn = retrieveTileInTileGroup(sourceTile, sourceGroupIndx);\n  var sourceTileIndx = viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n  var baseOrder = 0;\n  var newGroupIncrement = 100;\n\n  if (targetTileGroup && targetTileGroup.tiles.length > 0) {\n    baseOrder = getBaseOrder(targetTileGroup.tiles[0].orderNumber);\n  } // remove tile from source group\n\n\n  var srcGroup = viewModel.tileGroups[sourceGroupIndx];\n  srcGroup.tiles.splice(sourceTileIndx, 1);\n  var srcGroupNull = false; // If we removed the last tile in the group\n\n  if (srcGroup.tiles.length === 0) {\n    srcGroupNull = true;\n  } // create new group using current time\n\n\n  var newGroup = {};\n  newGroup.groupName = 'group' + new Date().getTime(); // add sourceTile to newly created group\n\n  newGroup.tiles = [];\n  newGroup.tiles.push(sourceTileIn);\n  newGroup.tiles.forEach(function (tile, indx) {\n    tile.orderNumber = baseOrder + newGroupIncrement + indx;\n    tile.isDirty = true;\n  }); // update tileGroups array\n\n  if (sourceGroupIndx === targetGroupIndx && srcGroupNull) {\n    viewModel.tileGroups.splice(targetGroupIndx, 0, newGroup);\n  } else {\n    viewModel.tileGroups.splice(targetGroupIndx + 1, 0, newGroup);\n  }\n\n  var newGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, newGroup); // update order number for all tiles in each and every tile group\n\n  _.forEach(viewModel.tileGroups, function (tileGroup, index) {\n    if (index > newGroupIndx && tileGroup.tiles.length > 0) {\n      var grpBaseOrder = getBaseOrder(tileGroup.tiles[0].orderNumber);\n      tileGroup.tiles.map(function (tile, indx) {\n        tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n        return tile;\n      });\n    }\n  });\n};\nexport const updateOrder = function (viewModel, sourceTile, sourceGroupName, targetTile, targetTileGroup, inPlace, propertyToUpdate) {\n  if (targetTile) {\n    var targetTileOrder = targetTile.orderNumber;\n    var targetGroup = getTileGroup(viewModel, targetTileGroup.groupName);\n    var sourceGroup = getTileGroup(viewModel, sourceGroupName);\n    var sourceGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, sourceGroup);\n    var targetGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, targetGroup);\n    var sourceTileIn = retrieveTileInTileGroup(viewModel, sourceTile, sourceGroupIndx);\n    var sourceTileIndx = viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n    var targetTileIndx = targetTileGroup.tiles.indexOf(targetTile);\n    var targetBaseOrder = getBaseOrder(targetTileOrder);\n\n    if (sourceGroupIndx === targetGroupIndx) {\n      // same group rearrange\n      reOrderInSameGroup(sourceTileIn, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace);\n    } else {\n      // different group rearrange\n      reOrderInDifferentGroup(viewModel, sourceTileIn, sourceTileIndx, sourceGroupIndx, targetTileIndx, targetGroupIndx, targetBaseOrder, inPlace, propertyToUpdate);\n    }\n  }\n};\nexport const getTileGroup = function (viewModel, groupName) {\n  var tileGroupIn;\n\n  _.forEach(viewModel.tileGroups, function (tileGroup) {\n    if (tileGroup.groupName === groupName) {\n      tileGroupIn = tileGroup;\n      return false;\n    }\n\n    return true;\n  });\n\n  return tileGroupIn;\n};\nexport const retrieveTileInTileGroup = function (viewModel, tile, groupIndex) {\n  var retrievedTile;\n\n  if (viewModel.tileGroups[groupIndex] && !_.isEmpty(viewModel.tileGroups[groupIndex].tiles)) {\n    _.forEach(viewModel.tileGroups[groupIndex].tiles, function (tileObj) {\n      if (_.isEqual(tileObj.displayName, tile.displayName)) {\n        retrievedTile = tileObj;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return retrievedTile;\n};\nexport const reOrderInSameGroup = function (sourceTile, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace) {\n  if (targetTileGroup) {\n    targetTileGroup.tiles.splice(sourceTileIndx, 1);\n    var targetTileIndx = targetTileGroup.tiles.indexOf(targetTile);\n\n    if (inPlace) {\n      targetTileGroup.tiles.splice(targetTileIndx, 0, sourceTile);\n    } else {\n      targetTileGroup.tiles.splice(targetTileIndx + 1, 0, sourceTile);\n    }\n\n    _.forEach(targetTileGroup.tiles, function reorderTiles(tile, index) {\n      if (tile) {\n        tile.orderNumber = targetBaseOrder + index;\n        tile.isDirty = true;\n      }\n    });\n  }\n};\nexport const reOrderInDifferentGroup = function (viewModel, sourceTile, sourceTileIndex, sourceGroupIndex, targetTileIndex, targetGroupIndex, targetBaseOrder, inPlace, propertyToUpdate) {\n  const {\n    dispatch\n  } = viewModel;\n  const propertyName = propertyToUpdate;\n  let updatedTileGroups = { ...viewModel.getData()\n  }.tileGroups;\n  var sourceBaseOrder = getBaseOrder(sourceTile.orderNumber);\n  var srcGroup = updatedTileGroups[sourceGroupIndex];\n  var targetGroupDifferent = updatedTileGroups[targetGroupIndex]; // remove tile from source group\n\n  srcGroup.tiles.splice(sourceTileIndex, 1); // add tile to target group\n\n  if (inPlace) {\n    targetGroupDifferent.tiles.splice(targetTileIndex, 0, sourceTile);\n  } else {\n    targetGroupDifferent.tiles.splice(targetTileIndex + 1, 0, sourceTile);\n  } // modify order in source group\n\n\n  srcGroup.tiles.map(function (tile, idx) {\n    tile.orderNumber = sourceBaseOrder + idx;\n    tile.isDirty = true;\n    return tile;\n  });\n  updatedTileGroups[sourceGroupIndex] = srcGroup; // modify order in target group\n\n  targetGroupDifferent.tiles.map(function (tile, idx) {\n    tile.orderNumber = targetBaseOrder + idx;\n    tile.isDirty = true;\n    return tile;\n  });\n  updatedTileGroups[targetGroupIndex] = targetGroupDifferent;\n  let propertyPath = propertyName ? 'data.' + propertyName : 'data.tileGroups';\n  dispatch({\n    path: propertyPath,\n    value: [...updatedTileGroups]\n  });\n};\nexport const dragLeaveFn = _ref5 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref5;\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragleave: ' + event);\n    }\n\n    var debounceProcessDragLeave = _.debounce(processDragLeave, 100);\n\n    debounceProcessDragLeave(event);\n  }\n};\nexport const dropFn = (props, _ref6) => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref6;\n  let targetObjectsDrop;\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('drop: ' + event);\n    }\n\n    jqElement.data('dragging', false);\n    targetObjectsDrop = assignViewModelToObject(targetObjects, declViewModel);\n    processDrop(event, {}, jqElement, targetObjectsDrop, props);\n  }\n};\nexport const postLog = message => {\n  logger.info(message);\n};\n\nconst retrieveTileGroupIndex = (tileGroups, group) => {\n  if (tileGroups) {\n    return tileGroups.indexOf(group);\n  }\n\n  return -1;\n};\n\nconst assignViewModelToObject = (targetObjects, declViewModel) => {\n  let targetObjectsUpdated = { ...targetObjects\n  };\n  targetObjectsUpdated.viewModel = declViewModel;\n  return targetObjectsUpdated;\n};\n\nexport default {\n  getBaseOrder,\n  addDragDataToDragEvent,\n  updateDragImage,\n  processDragStart,\n  processDragOver,\n  processDragEnter,\n  processDragLeave,\n  processDragEnd,\n  processDrop,\n  dragStartFn,\n  dragEndFn,\n  dragOverFn,\n  dragEnterFn,\n  dragLeaveFn,\n  dropFn,\n  updateOrder,\n  createNewGroup,\n  reOrderInSameGroup,\n  reOrderInDifferentGroup,\n  retrieveTileInTileGroup,\n  getTileGroup,\n  postLog\n};","map":{"version":3,"names":["$","_","browserUtils","logger","TILEMAIN_CSS_CLASS","TILE_CONT_CSS_CLASS","TILE_DRAGGABLE_CSS_CLASS","TILEGROUP_CSS_CLASS","PLACEHOLDER_GROUP_CSS_CLASS","PLACEHOLDER_TILE_CSS_CLASS","DRAGTILE_CSS_CLASS","TILE_GROUP_TAGNAME","TILE_MAIN_CONTAINER_CSS_CLASS","_debug_logEventActivity","placeHolderTile","draggedTileInfo","droppedTileInfo","_isValidToDrop","event","_findDropTargetElement","isNewGroup","dropTarget","inPlace","eventSrc","currentTarget","placeholderGroup","find","element","prev","hasClass","length","prevObject","parentTileElem","closest","style","order","next","_findDragEnterElement","dragEnterElement","target","_removePlaceHolders","remove","_createPlaceHolderTileGroup","newTileGroup","addClass","_createPlaceHolderTile","sourceTile","_cleanUp","dragTileIn","removeAttribute","dragTile","document","querySelector","classList","tileContElem","postLog","_processDragEnterInternal","targetElement","targetObjects","preventDefault","targetCssOrder","parseInt","side","mouseX","clientX","elementWidth","offsetWidth","halfElementWidth","offsetLeft","insertBefore","css","insertAfter","forEach","nextAll","nextSib","tgtTile","tile","displayName","targetGroupElem","placeHolderTileGroup","targetTile","targetTileGroup","tileGroup","viewModel","getBaseOrder","orderNumber","tensAndOnesDigits","addDragDataToDragEvent","dragDataMap","dataTransfer","setData","JSON","stringify","sourceGroupName","sourceTileGroup","groupName","updateDragImage","draggableElem","isIE","setDragImage","processDragStart","callBackAPIs","srcElement","parentElement","data","containerId","Date","now","width","index","tiles","tileSize","parentTileMinWidth","minWidth","setAttribute","add","effectAllowed","processDragOver","processDragEnter","targetData","debounceProcessDragEnter","debounce","processDragLeave","processDragEnd","evtElement","removeClass","removeAttr","processDrop","props","propertyToUpdate","stopPropagation","firstElementChild","prevSiblings","prevAll","nextSiblings","forEachRight","sibling","id","draggingData","getData","dragDataTile","parse","canvasViewModel","updateOrder","createNewGroup","tileGroupElemData","tileGroupData","dragStartFn","declViewModel","targetObjectsDragStart","panelElement","children","jqElement","nodeName","assignViewModelToObject","dragEndFn","targetObjectsDragEnd","dragOverFn","isQt","dropEffect","debounceProcessDragOver","dragEnterFn","targetObjectsDragEnter","sourceGroup","self","getTileGroup","sourceGroupIndx","retrieveTileGroupIndex","tileGroups","targetGroupIndx","sourceTileIn","retrieveTileInTileGroup","sourceTileIndx","indexOf","baseOrder","newGroupIncrement","srcGroup","splice","srcGroupNull","newGroup","getTime","push","indx","isDirty","newGroupIndx","grpBaseOrder","map","targetTileOrder","targetGroup","targetTileIndx","targetBaseOrder","reOrderInSameGroup","reOrderInDifferentGroup","tileGroupIn","groupIndex","retrievedTile","isEmpty","tileObj","isEqual","reorderTiles","sourceTileIndex","sourceGroupIndex","targetTileIndex","targetGroupIndex","dispatch","propertyName","updatedTileGroups","sourceBaseOrder","targetGroupDifferent","idx","propertyPath","path","value","dragLeaveFn","debounceProcessDragLeave","dropFn","targetObjectsDrop","message","info","group","targetObjectsUpdated"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/tile/src/js/tileDragService.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * This service manages tiles drag and reorder functionality.\n *\n * @module js/tileDragService\n */\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\n\n/**\n   * Static Strings referencing css classes\n   */\nvar TILEMAIN_CSS_CLASS = 'aw-tile-tileMain';\nvar TILE_CONT_CSS_CLASS = 'sw-column.aw-tile-tileContainer';\nvar TILE_DRAGGABLE_CSS_CLASS = 'aw-tile-draggable';\nvar TILEGROUP_CSS_CLASS = 'aw-tile-tileGroup';\nvar PLACEHOLDER_GROUP_CSS_CLASS = 'aw-tile-placeHolderGroupSep';\nvar PLACEHOLDER_TILE_CSS_CLASS = 'aw-tile-placeHolderTile';\nvar DRAGTILE_CSS_CLASS = 'aw-tile-dragTile';\nvar TILE_GROUP_TAGNAME = 'aw-tile-group';\nvar TILE_MAIN_CONTAINER_CSS_CLASS = 'aw-tile-mainContainer';\n\n/**\n   * <pre>\n   * Greater Than 0 If some basic event activity should be logged.\n   * Greater Than 1 If some more fine-grained event activity should be logged.\n   * </pre>\n   */\nvar _debug_logEventActivity = 0;\n\nvar placeHolderTile;\nlet draggedTileInfo;\nlet droppedTileInfo;\n\n/**\n   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n   *\n   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n   *            test.\n   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n   */\nvar _isValidToDrop = function( event ) {\n    return true;\n};\n\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   * @param {Boolean} isNewGroup - If a new tile group is to be created\n   *\n   * @return {Element} The Element where we need to reorder and insert dragged tile after this.\n   */\nvar _findDropTargetElement = function( event, isNewGroup ) {\n    var dropTarget = {};\n    dropTarget.inPlace = false;\n    let eventSrc = event.currentTarget;\n\n    if( isNewGroup ) {\n        var placeholderGroup = $( '.' + TILE_MAIN_CONTAINER_CSS_CLASS ).find( '.' + PLACEHOLDER_GROUP_CSS_CLASS );\n        dropTarget.element = placeholderGroup.prev( '.' + TILEGROUP_CSS_CLASS );\n\n        // For the use case of the previous element not being an actual tile group\n        while( dropTarget.element.hasClass( 'aw-tile-emptyTileGroup' ) ) {\n            dropTarget.element = dropTarget.element.prev( '.' + TILEGROUP_CSS_CLASS );\n        }\n\n        // If the new group is in the 1st tile group location\n        if( dropTarget.element.length === 0 ) {\n            dropTarget.element = dropTarget.element.prevObject;\n        }\n\n        dropTarget.element = dropTarget.element[ 0 ];\n        return dropTarget;\n    }\n\n    dropTarget.element = $( '.aw-tile-mainContainer .aw-tile-placeHolderTile' );\n\n    if( dropTarget.element.length === 0 ) {\n        if( !$( eventSrc ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {\n            // find the closest\n            var parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );\n            // if its not on the parent level, then try to find it in the children\n            if( parentTileElem.length === 0 ) {\n                parentTileElem = $( eventSrc ).find( '.' + TILE_DRAGGABLE_CSS_CLASS );\n            }\n\n            if( parentTileElem && parentTileElem.length > 0 ) {\n                dropTarget.element = parentTileElem[ 0 ];\n            }\n        } else {\n            dropTarget.element = eventSrc;\n        }\n    } else {\n        //  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'\n        if( dropTarget.element[ 0 ].style.order === '0' && dropTarget.element.next().length !== 0 ) {\n            dropTarget.element = dropTarget.element.next();\n            dropTarget.inPlace = true;\n        } else {\n            dropTarget.element = dropTarget.element.prev();\n        }\n    }\n\n    return dropTarget;\n};\n\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   *\n   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order\n   * of dragged tile.\n   */\nvar _findDragEnterElement = function( event ) {\n    var dragEnterElement;\n    let eventSrc = event.target;\n    // find the closest\n    let parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );\n\n    if( parentTileElem && parentTileElem.length > 0 ) {\n        dragEnterElement = parentTileElem[ 0 ];\n    } else if( $( eventSrc ).hasClass( TILEGROUP_CSS_CLASS ) ) {\n        dragEnterElement = $( eventSrc );\n    }\n\n    return dragEnterElement;\n};\n\n/**\n   * Remove place holder elements from DOM.\n   */\nvar _removePlaceHolders = function() {\n    $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).remove();\n    $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).remove();\n};\n\n/**\n   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping\n   *\n   * @return {Element} The Element which represents dummy placeHolder tileGroup\n   */\nvar _createPlaceHolderTileGroup = function() {\n    // hidden tile to place it where dragging tile will dropped\n    var newTileGroup = $( '<div class=\"' + TILEGROUP_CSS_CLASS + '\"></div>' );\n    newTileGroup.addClass( PLACEHOLDER_GROUP_CSS_CLASS );\n    return newTileGroup;\n};\n\n/**\n   * Create dummy placeHolder Tile element to represent the position in the UI before dropping\n   *\n   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element\n   *\n   * @return {Element} The Element which represents dummy placeHolder tile\n   */\nvar _createPlaceHolderTile = function( sourceTile ) {\n    // hidden tile to place it where dragging tile will dropped\n    placeHolderTile = $( '<div class=\"' + PLACEHOLDER_TILE_CSS_CLASS + '\"></div>' );\n    placeHolderTile.addClass( TILEMAIN_CSS_CLASS );\n\n    if( $( sourceTile ).hasClass( 'aw-tile-doubleSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-doubleSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-tripleSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-quadroSize' );\n    }\n\n    if( $( sourceTile ).hasClass( 'aw-tile-doubleVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-doubleVerticalSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-tripleVerticalSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-quadroVerticalSize' );\n    }\n\n    return placeHolderTile;\n};\n\n/**\n   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements\n   *\n   * @param {Element} dragTileIn - The DOM element for dragging tile\n   * @param {Element} element - container element for dragging tile\n   */\nvar _cleanUp = function( dragTileIn, element ) {\n    _removePlaceHolders();\n\n    if( dragTileIn ) {\n        dragTileIn.removeAttribute( 'id' );\n    } else {\n        let dragTile = document.querySelector( '#draggedTile' );\n        dragTile.classList.remove( DRAGTILE_CSS_CLASS );\n        dragTile.removeAttribute( 'id' );\n        let tileContElem = dragTile;\n    }\n\n    placeHolderTile = null;\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'Cleaning up' );\n    }\n};\n\n/**\n   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n   * 'target'.\n   *\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Element} targetElement - The target element associate with dragEnter event\n   */\nvar _processDragEnterInternal = function( event, targetElement, targetObjects ) {\n    event.preventDefault();\n    // place phantom tile instead dragging one\n    if( placeHolderTile && targetElement && targetObjects ) {\n        // reordering in existing tiles\n        if( $( targetElement ).hasClass( TILEMAIN_CSS_CLASS ) && $( targetElement ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {\n            _removePlaceHolders();\n\n            var targetCssOrder = targetElement.style.order;\n            var order = parseInt( targetCssOrder, 10 );\n\n            var side;\n            var element = $( targetElement )[ 0 ];\n            var mouseX = event.clientX;\n            var elementWidth = element.offsetWidth;\n            var halfElementWidth = elementWidth / 2;\n            if( mouseX > halfElementWidth + element.offsetLeft ) {\n                side = 'right';\n            } else {\n                side = 'left';\n            }\n\n            // If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after\n            if( order === 0 && side === 'left' ) {\n                placeHolderTile.insertBefore( targetElement );\n                $( placeHolderTile ).css( 'order', 0 );\n            } else {\n                placeHolderTile.insertAfter( targetElement );\n                $( placeHolderTile ).css( 'order', order++ );\n            }\n\n            _.forEach( $( placeHolderTile ).nextAll(), function( nextSib ) {\n                if( nextSib ) {\n                    nextSib.style.order = order++;\n                }\n            } );\n\n            if( _debug_logEventActivity >= 1 ) {\n                var tgtTile = targetObjects[0].tile;\n\n                postLog( 'processDragEnter - PlaceHolder Tile Inserted: ' + tgtTile.displayName );\n            }\n        } else if( $( targetElement ).hasClass( TILEGROUP_CSS_CLASS ) ) { // vertically or horizontally creating new group\n            _removePlaceHolders();\n\n            var targetGroupElem = $( targetElement );\n            var placeHolderTileGroup = _createPlaceHolderTileGroup();\n            placeHolderTileGroup.insertBefore( targetGroupElem[ 0 ] );\n\n            if( _debug_logEventActivity >= 1 ) {\n                postLog( 'processDragEnter - Insert vertical or horizontal placeHolder Group' );\n            }\n        }\n        droppedTileInfo = {\n            targetTile: targetObjects[0].tile,\n            targetTileGroup: targetObjects[0].tileGroup,\n            viewModel: targetObjects.viewModel\n        };\n    }\n};\n\n/**\n   * Get base order value from the input parameter's order number\n   * <p>\n   * ex: 212 -> returns 200; 399 -> returns 300\n   *\n   * @param {Number} orderNumber - order number\n   * @returns {Number} base order number if orderNumber is defined, otherwise 0\n   */\nfunction getBaseOrder( orderNumber ) {\n    if( !orderNumber ) {\n        return 0;\n    }\n    var tensAndOnesDigits = orderNumber % 100;\n    return orderNumber - tensAndOnesDigits;\n}\n\n/**\n   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n   *\n   * @param {DragEvent} event - The DragEvent to set the DragData on.\n   * @param {Object} dragDataMap - Map of name/value pairs to add.\n   */\nfunction addDragDataToDragEvent( event, dragDataMap ) {\n    if( event.dataTransfer && dragDataMap ) {\n        event.dataTransfer.setData( 'text', JSON.stringify( {\n            sourceTile: dragDataMap.sourceTile,\n            sourceGroupName: dragDataMap.sourceTileGroup.groupName\n        } ) );\n    }\n    draggedTileInfo = dragDataMap;\n}\n\n/**\n   * Update the drag image for the DragEvent based on draggable element.\n   *\n   * @param {DragEvent} event - The DragEvent to set the image on.\n   * @param {DOMElement} draggableElem - element being dragged.\n   */\nfunction updateDragImage( event, draggableElem ) {\n    /**\n       * Internet Explorer doesn't support setDragImage at all.\n       * <P>\n       * See: http://mereskin.github.io/dnd/\n       */\n    if( !browserUtils.isIE && event.dataTransfer ) {\n        /**\n           * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n           * should be resolved after moving the list view to a flex display.\n           */\n        event.dataTransfer.setDragImage( draggableElem, 0, 0 );\n    }\n}\n\n/**\n   * Processes drag start event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   * @param {Element} element - The DOM element considered the 'source' of the given drag event.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   */\nfunction processDragStart( event, element, targetObjects, callBackAPIs = {} ) {\n    let srcElement = event.target;\n    let sourceTile = targetObjects[0].tile;\n    let sourceTileGroup = targetObjects[0].tileGroup;\n    let tileContElem = srcElement.parentElement.parentElement;\n\n    if( sourceTile ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'processDragStart - Source Tile name: ' + sourceTile.displayName +\n                 ' && Source Tile Group name: ' + sourceTileGroup.groupName );\n        }\n\n        element.data( 'dragging', true );\n        var containerId = element.data( 'containerId' );\n\n        if( !containerId ) {\n            containerId = Date.now();\n            element.data( 'containerId', containerId );\n        }\n        let width = 0;\n        for( let index = 0; index < 3; index++ ) {\n            if ( index < sourceTileGroup.tiles.length ) {\n                width += sourceTileGroup.tiles[index].tileSize + 1;\n            } else {\n                break;\n            }\n        }\n\n        // // Default width for the single width tile\n        let parentTileMinWidth = 155 * width + 'px';\n        tileContElem.parentElement.style.minWidth = parentTileMinWidth;\n        tileContElem.setAttribute( 'id', 'draggedTile' );\n        tileContElem.classList.add( DRAGTILE_CSS_CLASS );\n\n        if( event.dataTransfer ) {\n            event.dataTransfer.effectAllowed = 'move'; // only allow moves\n        }\n\n        updateDragImage( event, tileContElem );\n        addDragDataToDragEvent( event, {\n            sourceTile: sourceTile,\n            sourceTileGroup: sourceTileGroup\n        } );\n\n        placeHolderTile = _createPlaceHolderTile( srcElement );\n    } else {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'processDragStart - no tile Info, Set element data \"dragging\" to false' );\n        }\n\n        // No data so there is no reason to let the object be dragged.\n        element.data( 'dragging', false );\n        event.preventDefault();\n    }\n}\n\n/**\n   * Processes drag over event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   */\nfunction processDragOver( event ) {\n    if( event.dataTransfer ) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n}\n\n/**\n   * Processes drag enter event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.\n   */\nfunction processDragEnter( event, targetElement, targetObjects ) {\n    if( _isValidToDrop( event ) ) {\n        let targetData = targetObjects[0].tile;\n        let targetTileGroup = targetObjects[0].tileGroup;\n        if( targetData ) {\n            if( _debug_logEventActivity >= 2 ) {\n                if( targetData.tiles ) {\n                    postLog( 'processDragEnter - Target tileGroup: ' + targetData.groupName );\n                } else if( targetTileGroup && targetData.displayName ) {\n                    postLog( 'processDragEnter - Target tile: ' + targetData.displayName +\n                          ' && Target Item tileGroup: ' + targetTileGroup.groupName );\n                } else if( targetTileGroup && !targetData.displayName ) {\n                    postLog( 'processDragEnter - Target Item tileGroup: ' + targetTileGroup.groupName );\n                }\n            }\n\n            if( !targetData.tiles && ( !targetTileGroup || !targetTileGroup.groupName ) ) {\n                return;\n            }\n\n            if( event.dataTransfer ) {\n                event.dataTransfer.effectAllowed = 'move'; // only allow moves\n            }\n\n            let debounceProcessDragEnter = _.debounce( _processDragEnterInternal, 100 );\n            debounceProcessDragEnter( event, targetElement, targetObjects );\n        }\n    }\n}\n\n/**\n   * Processes drag leave event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   */\nfunction processDragLeave( event ) {\n    event.preventDefault();\n\n    if( event.dataTransfer ) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n}\n\n/**\n   * Processes drag end event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   */\nfunction processDragEnd( event, element, targetObjects ) {\n    event.preventDefault();\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDragEnd - Processing drag end' );\n    }\n\n    let evtElement = event.target.parentElement.parentElement;\n    $( evtElement ).removeClass( DRAGTILE_CSS_CLASS );\n    $( evtElement ).removeAttr( 'id' );\n\n    let tileContElem = event.target;\n}\n\n/**\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   * @param {Object}  targetObjects\n   */\nfunction processDrop( event, callBackAPIs, element, targetObjects, props ) {\n    const propertyToUpdate = props;\n    event.stopPropagation();\n    event.preventDefault();\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDrop - Processing drop' );\n    }\n\n    let dragTile = document.querySelector( '#draggedTile' );\n    var isNewGroup = false;\n    dragTile.classList.remove( DRAGTILE_CSS_CLASS );\n    dragTile.parentElement.style.minWidth = '';\n    let tileContElem = dragTile.firstElementChild.firstElementChild;\n\n    if( $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).length > 0 ) {\n        var prevSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).prevAll();\n        var nextSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).nextAll();\n        var index = 0;\n\n        _.forEachRight( prevSiblings, function( sibling ) {\n            if( sibling.id !== 'draggedTile' ) {\n                sibling.style.order = index;\n                index++;\n            }\n        } );\n\n        if( dragTile ) {\n            dragTile.style.order = index;\n            index++;\n            if( _debug_logEventActivity >= 1 ) {\n                postLog( 'processDrop - Set new order style for dragged tile' );\n            }\n        }\n\n        _.forEach( nextSiblings, function( sibling ) {\n            if( sibling.id !== 'draggedTile' ) {\n                sibling.style.order = index;\n                index++;\n            }\n        } );\n    } else if( $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).length > 0 ) {\n        isNewGroup = true;\n    }\n\n    let targetElement = _findDropTargetElement( event, isNewGroup );\n    if( !targetElement.element ) {\n        _cleanUp( dragTile );\n        return;\n    }\n\n    let draggingData = event.dataTransfer.getData( 'text' );\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDrop - Retrieving drag data' );\n    }\n\n    if( draggingData ) {\n        var dragDataTile = JSON.parse( draggingData );\n        var targetTile = droppedTileInfo.targetTile;\n        let targetTileGroup = droppedTileInfo.targetTileGroup;\n        let canvasViewModel = droppedTileInfo.viewModel;\n        if( !isNewGroup && updateOrder && targetTile !== dragDataTile.sourceTile ) {\n            updateOrder( canvasViewModel, dragDataTile.sourceTile, dragDataTile.sourceGroupName, targetTile, targetTileGroup, targetElement.inPlace, propertyToUpdate );\n        } else if( isNewGroup && createNewGroup ) {\n            var tileGroupElemData = targetObjects[0].tile;\n            var tileGroupData;\n\n            if( tileGroupElemData ) {\n                tileGroupData = tileGroupElemData.tileGroup;\n            }\n            createNewGroup( dragDataTile.sourceTile, dragDataTile.sourceGroupName, tileGroupData, propertyToUpdate );\n        }\n\n        if( _debug_logEventActivity >= 1 ) {\n            postLog( 'processDrop - Dropping data: ' + draggingData );\n        }\n    }\n\n    _cleanUp( dragTile );\n}\n\nexport const dragStartFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragStart;\n    event.stopPropagation();\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    if( event.target.nodeName === '#text' ) {\n        jqElement.data( 'dragging', false );\n        event.preventDefault();\n    } else {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragstart: ' + event );\n        }\n        targetObjectsDragStart = assignViewModelToObject( targetObjects, declViewModel );\n        processDragStart( event, jqElement, targetObjectsDragStart, {} );\n    }\n};\n\nexport const dragEndFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragEnd;\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragend: ' + event );\n        }\n\n        jqElement.data( 'dragging', false );\n\n        var target = _findDropTargetElement( event );\n        if( !target ) {\n            return;\n        }\n        targetObjectsDragEnd = assignViewModelToObject( targetObjects, declViewModel );\n        processDragEnd( event, jqElement, targetObjectsDragEnd );\n    }\n};\n\nexport const dragOverFn = ( { event, targetObjects, declViewModel } ) => {\n    event.stopPropagation();\n    event.preventDefault();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragover: ' + event );\n        }\n\n        if( _isValidToDrop( event ) ) {\n            if( event.dataTransfer && !browserUtils.isQt ) {\n                event.dataTransfer.dropEffect = 'move'; // only allow moves\n            }\n\n            event.stopPropagation();\n            event.preventDefault();\n            var debounceProcessDragOver = _.debounce( processDragOver, 100 );\n            debounceProcessDragOver( event );\n        }\n    }\n};\n\nexport const dragEnterFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragEnter;\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragenter: ' + event );\n        }\n\n        var target = _findDragEnterElement( event );\n        if( !target ) {\n            return;\n        }\n        targetObjectsDragEnter = assignViewModelToObject( targetObjects, declViewModel );\n        targetObjects.viewModel = declViewModel;\n        processDragEnter( event, target, targetObjectsDragEnter );\n    }\n};\n\nexport const createNewGroup = function( viewModel, sourceTile, sourceGroupName, targetTileGroup ) {\n    var sourceGroup = self.getTileGroup( sourceGroupName );\n    var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );\n    var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetTileGroup );\n\n    var sourceTileIn = retrieveTileInTileGroup( sourceTile, sourceGroupIndx );\n    var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n\n    var baseOrder = 0;\n    var newGroupIncrement = 100;\n    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {\n        baseOrder = getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );\n    }\n\n    // remove tile from source group\n    var srcGroup = viewModel.tileGroups[ sourceGroupIndx ];\n    srcGroup.tiles.splice( sourceTileIndx, 1 );\n\n    var srcGroupNull = false;\n    // If we removed the last tile in the group\n    if( srcGroup.tiles.length === 0 ) {\n        srcGroupNull = true;\n    }\n\n    // create new group using current time\n    var newGroup = {};\n    newGroup.groupName = 'group' + new Date().getTime();\n\n    // add sourceTile to newly created group\n    newGroup.tiles = [];\n    newGroup.tiles.push( sourceTileIn );\n\n    newGroup.tiles.forEach( function( tile, indx ) {\n        tile.orderNumber = baseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n    } );\n\n    // update tileGroups array\n    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {\n        viewModel.tileGroups.splice( targetGroupIndx, 0, newGroup );\n    } else {\n        viewModel.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );\n    }\n\n    var newGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, newGroup );\n\n    // update order number for all tiles in each and every tile group\n    _.forEach( viewModel.tileGroups, function( tileGroup, index ) {\n        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {\n            var grpBaseOrder = getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );\n            tileGroup.tiles.map( function( tile, indx ) {\n                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n                tile.isDirty = true;\n                return tile;\n            } );\n        }\n    } );\n};\n\nexport const updateOrder = function( viewModel, sourceTile, sourceGroupName, targetTile, targetTileGroup, inPlace, propertyToUpdate ) {\n    if( targetTile ) {\n        var targetTileOrder = targetTile.orderNumber;\n\n        var targetGroup = getTileGroup( viewModel, targetTileGroup.groupName );\n        var sourceGroup = getTileGroup( viewModel, sourceGroupName );\n        var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );\n        var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetGroup );\n\n        var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );\n\n        var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );\n        var targetBaseOrder = getBaseOrder( targetTileOrder );\n\n        if( sourceGroupIndx === targetGroupIndx ) { // same group rearrange\n            reOrderInSameGroup( sourceTileIn, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace );\n        } else { // different group rearrange\n            reOrderInDifferentGroup( viewModel, sourceTileIn, sourceTileIndx, sourceGroupIndx, targetTileIndx,\n                targetGroupIndx, targetBaseOrder, inPlace, propertyToUpdate );\n        }\n    }\n};\n\nexport const getTileGroup = function( viewModel, groupName ) {\n    var tileGroupIn;\n    _.forEach( viewModel.tileGroups, function( tileGroup ) {\n        if( tileGroup.groupName === groupName ) {\n            tileGroupIn = tileGroup;\n            return false;\n        }\n        return true;\n    } );\n\n    return tileGroupIn;\n};\n\nexport const retrieveTileInTileGroup = function( viewModel, tile, groupIndex ) {\n    var retrievedTile;\n\n    if( viewModel.tileGroups[ groupIndex ] && !_.isEmpty( viewModel.tileGroups[ groupIndex ].tiles ) ) {\n        _.forEach( viewModel.tileGroups[ groupIndex ].tiles, function( tileObj ) {\n            if( _.isEqual( tileObj.displayName, tile.displayName ) ) {\n                retrievedTile = tileObj;\n                return false;\n            }\n            return true;\n        } );\n    }\n\n    return retrievedTile;\n};\n\nexport const reOrderInSameGroup = function( sourceTile, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace ) {\n    if( targetTileGroup ) {\n        targetTileGroup.tiles.splice( sourceTileIndx, 1 );\n\n        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );\n        if( inPlace ) {\n            targetTileGroup.tiles.splice( targetTileIndx, 0, sourceTile );\n        } else {\n            targetTileGroup.tiles.splice( targetTileIndx + 1, 0, sourceTile );\n        }\n\n        _.forEach( targetTileGroup.tiles, function reorderTiles( tile, index ) {\n            if( tile ) {\n                tile.orderNumber = targetBaseOrder + index;\n                tile.isDirty = true;\n            }\n        } );\n    }\n};\n\nexport const reOrderInDifferentGroup = function( viewModel, sourceTile, sourceTileIndex, sourceGroupIndex, targetTileIndex,\n    targetGroupIndex, targetBaseOrder, inPlace, propertyToUpdate ) {\n    const { dispatch } = viewModel;\n    const propertyName = propertyToUpdate;\n    let updatedTileGroups = { ...viewModel.getData() }.tileGroups;\n    var sourceBaseOrder = getBaseOrder( sourceTile.orderNumber );\n    var srcGroup = updatedTileGroups[ sourceGroupIndex ];\n    var targetGroupDifferent = updatedTileGroups[ targetGroupIndex ];\n    // remove tile from source group\n    srcGroup.tiles.splice( sourceTileIndex, 1 );\n    // add tile to target group\n    if( inPlace ) {\n        targetGroupDifferent.tiles.splice( targetTileIndex, 0, sourceTile );\n    } else {\n        targetGroupDifferent.tiles.splice( targetTileIndex + 1, 0, sourceTile );\n    }\n\n    // modify order in source group\n    srcGroup.tiles.map( function( tile, idx ) {\n        tile.orderNumber = sourceBaseOrder + idx;\n        tile.isDirty = true;\n        return tile;\n    } );\n    updatedTileGroups[ sourceGroupIndex ] = srcGroup;\n    // modify order in target group\n    targetGroupDifferent.tiles.map( function( tile, idx ) {\n        tile.orderNumber = targetBaseOrder + idx;\n        tile.isDirty = true;\n        return tile;\n    } );\n    updatedTileGroups[ targetGroupIndex ] = targetGroupDifferent;\n    let propertyPath = propertyName ? 'data.' + propertyName : 'data.tileGroups';\n    dispatch( { path: propertyPath, value: [ ...updatedTileGroups ] } );\n};\n\nexport const dragLeaveFn = ( { event, targetObjects, declViewModel } ) => {\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragleave: ' + event );\n        }\n        var debounceProcessDragLeave = _.debounce( processDragLeave, 100 );\n        debounceProcessDragLeave( event );\n    }\n};\n\nexport const dropFn = ( props, {  event, targetObjects, declViewModel } ) => {\n    let targetObjectsDrop;\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'drop: ' + event );\n        }\n\n        jqElement.data( 'dragging', false );\n        targetObjectsDrop = assignViewModelToObject( targetObjects, declViewModel );\n        processDrop( event, {}, jqElement, targetObjectsDrop, props );\n    }\n};\n\nexport const postLog = ( message ) => {\n    logger.info( message );\n};\n\nconst retrieveTileGroupIndex = ( tileGroups, group ) => {\n    if( tileGroups ) {\n        return tileGroups.indexOf( group );\n    }\n    return -1;\n};\n\nconst assignViewModelToObject = ( targetObjects, declViewModel ) => {\n    let targetObjectsUpdated = { ...targetObjects };\n    targetObjectsUpdated.viewModel = declViewModel;\n    return targetObjectsUpdated;\n};\n\nexport default {\n    getBaseOrder,\n    addDragDataToDragEvent,\n    updateDragImage,\n    processDragStart,\n    processDragOver,\n    processDragEnter,\n    processDragLeave,\n    processDragEnd,\n    processDrop,\n    dragStartFn,\n    dragEndFn,\n    dragOverFn,\n    dragEnterFn,\n    dragLeaveFn,\n    dropFn,\n    updateOrder,\n    createNewGroup,\n    reOrderInSameGroup,\n    reOrderInDifferentGroup,\n    retrieveTileInTileGroup,\n    getTileGroup,\n    postLog\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}