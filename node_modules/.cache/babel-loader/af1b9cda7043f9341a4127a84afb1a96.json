{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides high level functionalities to work with view model.\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport declViewModProcFact from 'js/viewModelProcessingFactory';\nimport messagingSvc from 'js/messagingService';\nimport actionSvc from 'js/actionService';\nimport conditionSvc from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport declDataCtxService from 'js/declarativeDataCtxService';\nimport Debug from 'debug';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport declUtils from './declUtils';\nimport debugService from 'js/debugService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { loadDynModule } from 'js/moduleLoader';\nvar trace = new Debug('viewModel');\nvar exports = {};\n\nconst eveulateEventCondition = function (eventObj, declViewModel, matched, props, context, fields) {\n  var conditionResult = false;\n\n  if (eventObj.condition) {\n    var conditionExpression = null;\n\n    if (_.startsWith(eventObj.condition, 'conditions.')) {\n      var conditionObject = _.get(declViewModel._internal, eventObj.condition);\n\n      conditionExpression = conditionObject.expression;\n    } else {\n      conditionExpression = eventObj.condition;\n    }\n\n    let currContext = null;\n\n    if (context) {\n      if (context.scope) {\n        currContext = context.scope;\n      } else {\n        currContext = context;\n      }\n    } else {\n      currContext = {\n        data: declViewModel,\n        props: props,\n        subPanelContext: props.subPanelContext,\n        fields\n      };\n    }\n\n    conditionResult = conditionSvc.evaluateCondition(declUtils.getLatestContext(currContext, declViewModel), conditionExpression, context); // if conditionResult is undefined or null we should consider result as false.\n\n    if (!conditionResult) {\n      conditionResult = false;\n    }\n  }\n\n  return eventObj.condition && conditionResult || eventObj.criteria && matched || !(eventObj.condition || eventObj.criteria);\n};\n\nconst processMessageOnEvent = function (declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields) {\n  var allMessages = _.cloneDeep(declViewModel._internal.messages);\n\n  if (!context.scope) {\n    context.scope = {\n      data: declViewModel,\n      ctx: appCtxSvc.ctx,\n      props,\n      getProps,\n      parameters: inputArgs ? inputArgs : null,\n      fields,\n      getFields\n    };\n    context.scope.parameters = context.scope.parameters ? { ...context.scope.parameters,\n      commandActionExecutor: {\n        runActionWithViewModel\n      }\n    } : {\n      commandActionExecutor: {\n        runActionWithViewModel\n      }\n    };\n  }\n\n  messagingSvc.reportNotyMessage(declViewModel, allMessages, eventObj.message, context.scope);\n};\n\nconst processActionOnEventHavingScope = function (context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields) {\n  context.scope.parameters = inputArgs ? inputArgs : null;\n  context.scope.parameters = context.scope.parameters ? { ...context.scope.parameters,\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  } : {\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  };\n  context.scope.props = props;\n  context.scope.getProps = getProps;\n  context.scope.fields = fields;\n  context.scope.getFields = getFields;\n  exports.executeCommand(declViewModel, eventObj.action, context.scope);\n};\n\nconst processActionOnEventWithScope = function (declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields) {\n  var scope = {\n    data: declViewModel,\n    ctx: appCtxSvc.ctx,\n    parameters: inputArgs ? inputArgs : null,\n    subPanelContext: subPanelContext,\n    props,\n    getProps,\n    fields,\n    getFields\n  };\n  scope.parameters = scope.parameters ? { ...scope.parameters,\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  } : {\n    commandActionExecutor: {\n      runActionWithViewModel\n    }\n  };\n  exports.executeCommand(declViewModel, eventObj.action, scope);\n};\n\nconst reteriveInputParOfEvent = function (context, inputArgs, eventObj, declViewModel) {\n  var contextObj = {\n    eventData: context\n  };\n  inputArgs = _.cloneDeep(eventObj.inputArgs);\n\n  if (inputArgs) {\n    try {\n      declDataCtxService.applyScope(declViewModel, inputArgs, null, contextObj, null);\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  return inputArgs;\n};\n\nconst handleEventDataCache = function (eventObj, declViewModel, context) {\n  if (eventObj.eventId) {\n    if (!declViewModel.eventMap) {\n      declViewModel.eventMap = {};\n    }\n\n    const key = eventObj.eventId;\n    const value = {};\n    value[key] = context;\n    declViewModel.eventMap[eventObj.eventId] = value[key];\n    declViewModel.data.eventMap = { ...declViewModel.eventMap\n    };\n  }\n\n  declViewModel.eventData = context;\n  declViewModel.data.eventData = context;\n}; // eslint-disable-next-line complexity\n\n\nexport let handleRegisteredEvent = function (context, declViewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields) {\n  if (declViewModel.getData && _.isFunction(declViewModel.getData)) {\n    declViewModel.data = declViewModel.getData();\n  }\n\n  const props = getProps();\n  const fields = getFields();\n  const subPanelContext = props.subPanelContext;\n  debugService.debug('events', declViewModel._internal.panelId, eventObj.eventId);\n\n  if (limitEventScope && context._source !== declViewModel._internal.modelId) {\n    return;\n  } // Check if the event source is set to 'current' and _source id is available.\n  // If yes, make event listeners only listen to events fired by the current view model instance.\n\n\n  if (eventObj.eventSource === 'current' && context._source && context._source !== declViewModel._internal.modelId) {\n    return;\n  }\n\n  if (!declUtils.isValidModelAndEventData(declViewModel, context)) {\n    logger.error('_processEventRegistration: ' + 'Invalid input: eventId=' + eventObj.eventId);\n    return;\n  }\n\n  var matched = true;\n  /**\n   * @deprecated : 'criteria' is deprecated we should use condition instead.\n   */\n\n  _.forEach(eventObj.criteria, function (value, key) {\n    // For panel change events, the context doesn't have a scope, so check the properties on context directly.\n    if (_.get(context.scope, key) !== value && _.get(context, key) !== value) {\n      matched = false;\n    }\n  });\n  /**\n   * \"onEvent\": [ { \"eventId\": \"someEvent\", \"condition\": \"conditions.shouldIDoSomething\",\n   * \"action\":\"doSomething\" } ]\n   */\n\n\n  var isEventExecutable = eveulateEventCondition(eventObj, declViewModel, matched, props, context, fields);\n\n  if (logger.isDeclarativeLogEnabled()) {\n    debugService.debugEventSub(eventObj, declViewModel, context, isEventExecutable);\n  }\n\n  if (isEventExecutable) {\n    var inputArgs = null; // Store the context eventData on declViewModel's eventData\n\n    if (eventObj.cacheEventData) {\n      // const { dispatch } = declViewModel;\n      // let finalObj = {};\n      handleEventDataCache(eventObj, declViewModel, context);\n    } // If an event has some eventData and the same eventdata is required in the action,\n    // associated with event, then user can construct inputArgs.\n    // \"eventId\": \"AWEvent.test\",\n    //     \"action\": \"fireSaveEdit\",\n    //         \"inputArgs\": {\n    //         \"param1\": \"{{eventData.operation1}}\",\n    //         \"param3\": {\n    //             \"param4\": \"{{eventData.operation4}}\",\n    //             \"param5\": \"{{eventData.operation5}}\"\n    //         }\n    //     }\n    // Later the same input Args can be reused in action through {{parameters.param1}}.\n\n\n    if (eventObj.inputArgs) {\n      inputArgs = reteriveInputParOfEvent(context, inputArgs, eventObj, declViewModel);\n    }\n\n    if (eventObj.message) {\n      processMessageOnEvent(declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields);\n    } else if (context && context.scope) {\n      processActionOnEventHavingScope(context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields);\n    } else {\n      processActionOnEventWithScope(declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields);\n    }\n  }\n};\n/**\n * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with\n * any data that is bound to various values including localized messages.\n *\n * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.\n *            <P>\n *            Note: The JSON contents are actually represented in the 'data' property of this object.\n *\n * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be\n *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)\n *\n * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a\n *            sub-panel\n * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by\n *            the current view model\n * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.\n *\n * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive\n *\n * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's\n *         JSON.\n */\n\nexport let populateViewModelPropertiesFromJson = function (declViewModelJson, declViewModelTarget, subPanelId, limitEventScope, cacheI18nKey, subPanelContext) {\n  if (!declViewModelJson) {\n    return AwPromiseService.instance.reject('No ViewModel JSON object specified');\n  }\n\n  if (declViewModelTarget) {\n    if (!declViewModelTarget._internal.eventSubscriptions) {\n      return AwPromiseService.instance.reject('Target ViewModel missing required event property');\n    }\n\n    if (!declViewModelTarget._internal.origDeclViewModelJson) {\n      return AwPromiseService.instance.reject('Target ViewModel missing required JSON object property');\n    }\n  }\n  /**\n   * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved\n   * 'declViewModel'.\n   */\n\n\n  var newDeclViewModel = declViewModProcFact.processViewModel(declViewModelJson, subPanelContext);\n  var jsonData = declViewModelJson;\n  /**\n   * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')\n   */\n\n  var resDeclViewModel;\n\n  if (declViewModelTarget) {\n    resDeclViewModel = declViewModelTarget;\n    /**\n     * Consolidate 'fresh' JSON properties into the given 'target'\n     * <P>\n     * Move all of the now populated 'data' properties into the 'target'\n     */\n\n    _.forEach(jsonData.data, function (propValue, propName) {\n      resDeclViewModel[propName] = newDeclViewModel[propName];\n    });\n\n    resDeclViewModel.dataProviders = declUtils.consolidateObjects(resDeclViewModel.dataProviders, newDeclViewModel.dataProviders);\n    resDeclViewModel.grids = declUtils.consolidateObjects(resDeclViewModel.grids, newDeclViewModel.grids);\n    resDeclViewModel.columnProviders = declUtils.consolidateObjects(resDeclViewModel.columnProviders, newDeclViewModel.columnProviders);\n    resDeclViewModel.chartProviders = declUtils.consolidateObjects(resDeclViewModel.chartProviders, newDeclViewModel.chartProviders);\n    resDeclViewModel.commands = declUtils.consolidateObjects(resDeclViewModel.commands, newDeclViewModel.commands);\n    resDeclViewModel.commandHandlers = declUtils.consolidateObjects(resDeclViewModel.commandHandlers, newDeclViewModel.commandHandlers);\n    resDeclViewModel.commandPlacements = declUtils.consolidateObjects(resDeclViewModel.commandPlacements, newDeclViewModel.commandPlacements); // Consolidate all properties from view model object in newDeclViewModel\n\n    var vmo = newDeclViewModel.vmo;\n\n    if (vmo) {\n      if (jsonData.data.objects) {\n        // Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.\n        //                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {\n        //                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,\n        //                                    jsonData.data.owningObjUid, dataPropValue[0] );\n        //                                if( dataPropValue[0].selected ) {\n        //                                    resDeclViewModel.vmo = newVmo;\n        //                                }\n        //                            } );\n        // The above code is no longer required. As there is no need to create a separate viewModelobject instance of\n        // of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),\n        // we already created  resDeclViewModel.vmo instance while forming the\n        // newDeclViewModel.\n        // Also difficult to determine which widgets are binded to which viewModel Object\n        resDeclViewModel.vmo = newDeclViewModel.vmo;\n        resDeclViewModel = declUtils.consolidateObjects(resDeclViewModel, newDeclViewModel.vmo.props);\n        resDeclViewModel.attachEvents();\n      } else {\n        resDeclViewModel.vmo = resDeclViewModel.attachModelObject(vmo.uid, jsonData.data.operationName, jsonData.data.owningObjUid);\n      }\n    }\n\n    resDeclViewModel._internal.consolidateJsonData(jsonData);\n\n    newDeclViewModel._internal.destroy(false);\n  } else {\n    resDeclViewModel = newDeclViewModel;\n    /**\n     * Move over fresh JSON properties\n     */\n\n    resDeclViewModel._internal.setJsonData(jsonData);\n    /**\n     * Object used to hold details of context changes that are being delayed (debounced).\n     */\n\n\n    resDeclViewModel._internal.pendingContextChanges = {};\n    /**\n     * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things\n     * calm down a bit.\n     *\n     * When running in test mode this function will not be debounced\n     *\n     * @private\n     */\n    // revisitme charu\n    // resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {\n    //     maxWait: 10000,\n    //     trailing: true,\n    //     leading: false\n    // } );\n\n    /**\n    * revisitme Shaishav\n    * Hint: It was agreed that we do not need these event subscriptions are not required anymore.\n    * Keeping comments till we support all the usecases in new declarative engine\n    /**\n     * Listener for appCtx registration events\n    var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {\n        if( context ) {\n            if( _logCtxPathActivity_1 ) {\n                logger.info( 'appCtx.register Subscribe: ' + context.name );\n            }\n             resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;\n             resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );\n        }\n    }, 'viewModelService' );\n     /**\n     * Listener for command panel 'reveal' events\n    var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {\n        /**\n         * Only call the default \"reveal\" action on reveal of main panel which doesn't have a panel ID\n         * in this context. Check if the view model available on scope is same as the result view model.\n         * In case two declarative panels are displayed on a page, then it results in two subscriptions\n         * to the panel reveal event. Use the decl view model comparison to execute action against\n         * reveal for appropriate panel\n        if( context.scope && !context.scope.panelId ) {\n            var declViewModel = context.scope.data;\n             if( declViewModel === resDeclViewModel ) {\n                exports.executeCommand( declViewModel, 'reveal', context.scope );\n            }\n        }\n    }, 'viewModelService' );\n     /**\n     * Remember these subscriptions to allow unsubscribe later.\n    resDeclViewModel._internal.eventSubscriptions.push( subDef1 );\n    resDeclViewModel._internal.eventSubscriptions.push( subDef2 );\n    */\n  }\n  /**\n   * Register any fresh 'eventBus' conditions\n   */\n\n  /**\n   * revisitme Shaishav\n   * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService\n  if( jsonData.onEvent ) {\n      var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,\n          limitEventScope, subPanelContext );\n      if( !declUtils.isNil( subPanelId ) ) {\n          if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {\n              resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;\n          } else {\n              _.forEach( eventSubscriptions, function( eventSubs ) {\n                  resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );\n              } );\n          }\n      } else {\n          resDeclViewModel._internal.eventSubscriptions = _.union(\n              resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );\n      }\n  }\n   */\n\n  /**\n   * Queue up loading and processing of the other model resources\n   */\n\n  /**\n   * revisitme Shaishav\n  * Hint: It was agreed that\n  * 1) We do not need load imports as we will rely on ES6 import / export\n  * 2) i18n population is already happening in the declreact/viewModelService.js\n  * 3) We have to populate TC preferences into the same flow when this revisitme is removed\n  * 4) Keeping comments till we support all the usecases in new declarative engine\n  var importsPromise = null;\n   if( jsonData.imports ) {\n      importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );\n  }\n   var prefPromise = null;\n   if( jsonData.preferences && jsonData.preferences.length > 0 ) {\n      prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );\n  }\n   var i18nPromise = null;\n   if( jsonData.i18n ) {\n      i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );\n  }\n   /**\n   * Wait for them all to complete\n  return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(\n      function( results ) {\n          resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,\n              results[ 1 ] );\n           resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );\n           declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );\n           return resDeclViewModel;\n      } );\n   */\n\n\n  return resDeclViewModel;\n};\n/**\n * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the\n *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.\n *\n * @param {DeclViewModel} declViewModel -\n */\n\nexport let setupLifeCycle = function (dataCtxNode, declViewModel) {\n  dataCtxNode.data = declViewModel;\n  dataCtxNode.i18n = declViewModel.i18n;\n  dataCtxNode.ctx = appCtxSvc.ctx;\n\n  if (!dataCtxNode.conditions) {\n    dataCtxNode.conditions = declViewModel.getConditionStates();\n  }\n\n  debugService.debug('lifeCycles', declViewModel._internal.panelId, 'mount');\n\n  if (declViewModel._internal.ports) {\n    if (!syncViewModelCacheService.get('syncViewModelCache')) {\n      syncViewModelCacheService.set('syncViewModelCache', {});\n    }\n\n    const id = dataCtxNode.data._internal.modelId;\n    const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n\n    if (syncViewModelCacheService.get(path) === null || syncViewModelCacheService.get(path) === undefined) {\n      syncViewModelCacheService.set('syncViewModelCache', Object.assign(syncViewModelCacheService.get('syncViewModelCache'), {\n        [dataCtxNode.data._internal.viewId]: {\n          [id]: dataCtxNode\n        }\n      }));\n    } else {\n      syncViewModelCacheService.set(path, { ...syncViewModelCacheService.get(path),\n        [id]: dataCtxNode\n      });\n    }\n\n    dataCtxNode.ports = declViewModel._internal.ports;\n  }\n  /**\n   * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)\n   * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be\n   * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the\n   * declViewModel.\n   * <P>\n   * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very\n   * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The\n   * process will use this reference to the 'original' to resolve the event processing.\n   * <P>\n   * This property is nulled out when this declViewModel is destroyed.\n   * <P>\n   * **** This property should not be used for any other purpose until we can determine it won't cause more memory\n   * issues. *****\n   */\n\n\n  if (!dataCtxNode.data._internal.dataCtxNodeId) {\n    dataCtxNode.data._internal.dataCtxNodeId = dataCtxNode.$id;\n    dataCtxNode.data._internal.origCtxNode = dataCtxNode;\n  }\n  /**\n   * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.\n   */\n\n\n  var handleDestroyEvent = function () {\n    var declViewModel2 = dataCtxNode.data;\n\n    var cleanupDataCtxNode = function () {\n      // remove vm from the syncViewModelCacheService\n      if (declViewModel2 && declViewModel2._internal && declViewModel2._internal.ports) {\n        syncViewModelCacheService.set('syncViewModelCache.' + declViewModel2._internal.viewId, null);\n      }\n      /**\n       * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be\n       * destroyed.\n       */\n\n\n      if (declViewModel2 && declViewModel2._internal.dataCtxNodeId !== dataCtxNode.$id) {\n        dataCtxNode.data = null;\n        dataCtxNode.conditions = null;\n        dataCtxNode.ctx = null;\n        dataCtxNode.i18n = null;\n        dataCtxNode.dataProvider = null;\n        dataCtxNode.eventMap = null;\n        dataCtxNode.eventData = null;\n        dataCtxNode.subPanelContext = null;\n        return;\n      }\n\n      if (declViewModel2) {\n        if (declViewModel2._internal.destroy) {\n          declViewModel2._internal.destroy(true);\n        } else {\n          logger.warn('Attempt to delete a \"dataCtxNode.data\" that did not have a destroy method: ' + declViewModel2);\n        }\n\n        dataCtxNode.conditions = null;\n        dataCtxNode.data = null;\n        dataCtxNode.ctx = null;\n        dataCtxNode.i18n = null;\n        dataCtxNode.dataProvider = null;\n        dataCtxNode.eventMap = null;\n        dataCtxNode.eventData = null;\n        dataCtxNode.subPanelContext = null;\n      }\n    };\n\n    debugService.debug('lifeCycles', declViewModel._internal.panelId, 'destroy');\n\n    var onUnmountAction = _.get(declViewModel, '_internal.lifecycleHooks.onUnmount');\n\n    if (onUnmountAction) {\n      declViewModel.isUnmounting = true;\n      exports.executeCommand(declViewModel, onUnmountAction, dataCtxNode).then(function () {\n        cleanupDataCtxNode();\n      });\n    } else {\n      cleanupDataCtxNode();\n    }\n  };\n\n  if (dataCtxNode.$$destroyed) {\n    trace('View model attached to destroyed scope', declViewModel, dataCtxNode);\n    handleDestroyEvent();\n  } else {\n    /** revisitme Shaishav: What's the alternative for the whole if / else block?\n        dataCtxNode.$on( '$destroy', handleDestroyEvent );\n    */\n  }\n\n  var onInitAction = _.get(declViewModel, '_internal.lifecycleHooks.onInit');\n\n  if (onInitAction) {\n    exports.executeCommand(declViewModel, onInitAction, dataCtxNode);\n  }\n};\n/**\n * return true for actionType dataProvider otherwise false\n * @param {string} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\nvar _isDataProviderAction = function (actionOrProviderId, declViewModel) {\n  if (declViewModel._internal.actions) {\n    var action = declViewModel._internal.actions[actionOrProviderId];\n\n    if (action && action.actionType === 'dataProvider' && declViewModel.dataProviders) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * return true for actionType other than dataProvider\n * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\n\nvar _isAnAction = function (actionOrProviderId, declViewModel) {\n  return declViewModel._internal.actions && declViewModel._internal.actions[actionOrProviderId];\n};\n/**\n *\n * return true for dataProvider and false for action\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\n\n\nvar _isDataProvider = function (actionOrProviderId, declViewModel) {\n  return declViewModel.dataProviders && declViewModel.dataProviders[actionOrProviderId];\n};\n/**\n * Execute command\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {String} dataCtxNode - The AngularJS scope of this action command\n *\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n *\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @returns {null|Promise} ...\n */\n\n\nexport let executeCommand = function (declViewModel, actionOrProviderId, dataCtxNode, prop, viewData) {\n  if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    return AwPromiseService.instance.resolve();\n  }\n\n  var action = null;\n\n  if (declViewModel._internal.actions) {\n    action = declViewModel._internal.actions[actionOrProviderId];\n  }\n  /**\n   * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>\n   * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.\n   */\n\n\n  if (_isDataProviderAction(actionOrProviderId, declViewModel) && action) {\n    /** action ID will be used for better logging */\n    action.actionId = actionOrProviderId;\n    return actionSvc.performDataProviderAction(declViewModel, action, dataCtxNode);\n  } else if (_isAnAction(actionOrProviderId, declViewModel)) {\n    declViewModel.getToken().addAction(action);\n    /** action ID will be used for better logging */\n\n    action.actionId = actionOrProviderId;\n\n    if (action.deps) {\n      var doAction = function (depModuleObj) {\n        /**\n         * Check if the declViewModel got destroyed while we were waiting for the dependent module to be\n         * loaded. This can happen, for example, when multiple subscribers are listening to a common\n         * event like 'selection' and one of them (I'm look at you GWT) causes the panel the\n         * declViewModel is associated with to close (thus destroying the $scope and the declViewModel\n         * associated with it).\n         * <P>\n         * If so: There is nothing more that can be done with the declViewModel and we just want to log\n         * a warning about the situation and move on.\n         */\n        if (declViewModel.isDestroyed()) {\n          declUtils.logLifeCycleIssue(declViewModel, action, 'The command action was therefore not executed.', 'executeCommand');\n        } else {\n          /**\n           * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n           * event processing was started.\n           */\n          var localDataCtx = declUtils.resolveLocalDataCtx(declViewModel, dataCtxNode); // _deps will be undefined when try to load viewModelService inside itself\n\n          var _depModuleObj = depModuleObj;\n\n          if (!depModuleObj && action.deps === 'js/viewModelService') {\n            _depModuleObj = exports;\n          }\n\n          return actionSvc.executeAction(declViewModel, action, localDataCtx, _depModuleObj, null, prop, viewData).then(function () {\n            declViewModel.getToken().removeAction(action);\n          }).catch(function (x) {\n            declViewModel.getToken().removeAction(action);\n            trace('exception', x);\n            logger.error('exception', x); //return AwPromiseService.instance.reject( x );\n          });\n        }\n\n        return undefined;\n      };\n      /**\n      * revisitme Jesse\n      * Hint: This needs to be uncommented once we have afxWeakImport supported\n      * Keeping comments till we support all the usecases in new declarative engine\n      var depModuleObj = moduleLoader.getDependentModule( action.deps );\n       if( depModuleObj ) {\n          return doAction( depModuleObj );\n      }\n       return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {\n          return doAction( depModuleObject );\n      } );\n      */\n\n\n      return loadDynModule(action.deps).then(function (depModuleObject) {\n        return doAction(depModuleObject);\n      });\n    }\n\n    return actionSvc.executeAction(declViewModel, action, dataCtxNode, null, null, prop, viewData).then(function () {\n      declViewModel.getToken().removeAction(action);\n    }).catch(function (x) {\n      declViewModel.getToken().removeAction(action);\n      trace('exception', x);\n      logger.error('exception: ' + x); //return AwPromiseService.instance.reject( x );\n    });\n  } else if (_isDataProvider(actionOrProviderId, declViewModel)) {\n    action = {};\n    action.actionType = 'dataProvider';\n    action.method = actionOrProviderId;\n    return actionSvc.performDataProviderAction(declViewModel, action, dataCtxNode);\n  }\n\n  return AwPromiseService.instance.resolve();\n};\nexports = {\n  populateViewModelPropertiesFromJson,\n  setupLifeCycle,\n  executeCommand\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/viewModelService.js"],"names":["trace","exports","eveulateEventCondition","conditionResult","eventObj","conditionExpression","_","conditionObject","declViewModel","currContext","context","data","props","subPanelContext","fields","conditionSvc","declUtils","processMessageOnEvent","allMessages","ctx","appCtxSvc","parameters","inputArgs","getFields","commandActionExecutor","runActionWithViewModel","messagingSvc","processActionOnEventHavingScope","processActionOnEventWithScope","scope","reteriveInputParOfEvent","contextObj","eventData","declDataCtxService","handleEventDataCache","key","value","eventMap","handleRegisteredEvent","getProps","debugService","limitEventScope","logger","matched","isEventExecutable","populateViewModelPropertiesFromJson","AwPromiseService","declViewModelTarget","newDeclViewModel","declViewModProcFact","jsonData","resDeclViewModel","vmo","setupLifeCycle","dataCtxNode","syncViewModelCacheService","id","path","handleDestroyEvent","declViewModel2","cleanupDataCtxNode","onUnmountAction","onInitAction","_isDataProviderAction","action","_isAnAction","_isDataProvider","executeCommand","actionSvc","doAction","localDataCtx","_depModuleObj"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAA,gBAAA,MAAA,qBAAA;AACA,OAAA,mBAAA,MAAA,+BAAA;AACA,OAAA,YAAA,MAAA,qBAAA;AACA,OAAA,SAAA,MAAA,kBAAA;AACA,OAAA,YAAA,MAAA,qBAAA;AACA,OAAA,SAAA,MAAA,kBAAA;AACA,OAAA,kBAAA,MAAA,8BAAA;AACA,OAAA,KAAA,MAAA,OAAA;AACA,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,MAAA,MAAA,WAAA;AACA,OAAA,SAAA,MAAA,aAAA;AACA,OAAA,YAAA,MAAA,iBAAA;AACA,OAAA,yBAAA,MAAA,8BAAA;AACA,SAAA,aAAA,QAAA,iBAAA;AAEA,IAAIA,KAAK,GAAG,IAAA,KAAA,CAAZ,WAAY,CAAZ;AAEA,IAAIC,OAAO,GAAX,EAAA;;AAEA,MAAMC,sBAAsB,GAAG,UAAA,QAAA,EAAA,aAAA,EAAA,OAAA,EAAA,KAAA,EAAA,OAAA,EAAA,MAAA,EAAqE;EAChG,IAAIC,eAAe,GAAnB,KAAA;;EAEA,IAAIC,QAAQ,CAAZ,SAAA,EAAyB;IACrB,IAAIC,mBAAmB,GAAvB,IAAA;;IAEA,IAAIC,CAAC,CAADA,UAAAA,CAAcF,QAAQ,CAAtBE,SAAAA,EAAJ,aAAIA,CAAJ,EAAwD;MACpD,IAAIC,eAAe,GAAGD,CAAC,CAADA,GAAAA,CAAOE,aAAa,CAApBF,SAAAA,EAAgCF,QAAQ,CAA9D,SAAsBE,CAAtB;;MAEAD,mBAAmB,GAAGE,eAAe,CAArCF,UAAAA;IAHJ,CAAA,MAIO;MACHA,mBAAmB,GAAGD,QAAQ,CAA9BC,SAAAA;IACH;;IACD,IAAII,WAAW,GAAf,IAAA;;IACA,IAAA,OAAA,EAAc;MACV,IAAIC,OAAO,CAAX,KAAA,EAAoB;QAChBD,WAAW,GAAGC,OAAO,CAArBD,KAAAA;MADJ,CAAA,MAEO;QACHA,WAAW,GAAXA,OAAAA;MACH;IALL,CAAA,MAMO;MACHA,WAAW,GAAG;QAAEE,IAAI,EAAN,aAAA;QAAuBC,KAAK,EAA5B,KAAA;QAAqCC,eAAe,EAAED,KAAK,CAA3D,eAAA;QAA6EE;MAA7E,CAAdL;IACH;;IACDN,eAAe,GAAGY,YAAY,CAAZA,iBAAAA,CAAgCC,SAAS,CAATA,gBAAAA,CAAAA,WAAAA,EAAhCD,aAAgCC,CAAhCD,EAAAA,mBAAAA,EApBG,OAoBHA,CAAlBZ,CApBqB,CAsBrB;;IACA,IAAI,CAAJ,eAAA,EAAuB;MACnBA,eAAe,GAAfA,KAAAA;IACH;EACJ;;EACD,OAAOC,QAAQ,CAARA,SAAAA,IAAAA,eAAAA,IAAyCA,QAAQ,CAARA,QAAAA,IAAzCA,OAAAA,IACH,EAAGA,QAAQ,CAARA,SAAAA,IAAsBA,QAAQ,CADrC,QACI,CADJ;AA9BJ,CAAA;;AAkCA,MAAMa,qBAAqB,GAAG,UAAA,aAAA,EAAA,OAAA,EAAA,KAAA,EAAA,QAAA,EAAA,SAAA,EAAA,sBAAA,EAAA,QAAA,EAAA,MAAA,EAAA,SAAA,EAAoH;EAC9I,IAAIC,WAAW,GAAGZ,CAAC,CAADA,SAAAA,CAAaE,aAAa,CAAbA,SAAAA,CAA/B,QAAkBF,CAAlB;;EACA,IAAI,CAACI,OAAO,CAAZ,KAAA,EAAqB;IACjBA,OAAO,CAAPA,KAAAA,GAAgB;MACZC,IAAI,EADQ,aAAA;MAEZQ,GAAG,EAAEC,SAAS,CAFF,GAAA;MAAA,KAAA;MAAA,QAAA;MAKZC,UAAU,EAAEC,SAAS,GAAA,SAAA,GALT,IAAA;MAAA,MAAA;MAOZC;IAPY,CAAhBb;IASAA,OAAO,CAAPA,KAAAA,CAAAA,UAAAA,GAA2B,OAAO,CAAP,KAAA,CAAA,UAAA,GAA2B,EAClD,GAAGA,OAAO,CAAPA,KAAAA,CAD+C,UAAA;MAElDc,qBAAqB,EAAE;QACnBC;MADmB;IAF2B,CAA3B,GAKvB;MACAD,qBAAqB,EAAE;QACnBC;MADmB;IADvB,CALJf;EAUH;;EACDgB,YAAY,CAAZA,iBAAAA,CAAAA,aAAAA,EAAAA,WAAAA,EAA4DtB,QAAQ,CAApEsB,OAAAA,EACIhB,OAAO,CADXgB,KAAAA;AAvBJ,CAAA;;AA2BA,MAAMC,+BAA+B,GAAG,UAAA,OAAA,EAAA,SAAA,EAAA,sBAAA,EAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAA,QAAA,EAAA,MAAA,EAAA,SAAA,EAAoH;EACxJjB,OAAO,CAAPA,KAAAA,CAAAA,UAAAA,GAA2BY,SAAS,GAAA,SAAA,GAApCZ,IAAAA;EACAA,OAAO,CAAPA,KAAAA,CAAAA,UAAAA,GAA2B,OAAO,CAAP,KAAA,CAAA,UAAA,GAA2B,EAClD,GAAGA,OAAO,CAAPA,KAAAA,CAD+C,UAAA;IAElDc,qBAAqB,EAAE;MACnBC;IADmB;EAF2B,CAA3B,GAKvB;IACAD,qBAAqB,EAAE;MACnBC;IADmB;EADvB,CALJf;EAUAA,OAAO,CAAPA,KAAAA,CAAAA,KAAAA,GAAAA,KAAAA;EACAA,OAAO,CAAPA,KAAAA,CAAAA,QAAAA,GAAAA,QAAAA;EACAA,OAAO,CAAPA,KAAAA,CAAAA,MAAAA,GAAAA,MAAAA;EACAA,OAAO,CAAPA,KAAAA,CAAAA,SAAAA,GAAAA,SAAAA;EAEAT,OAAO,CAAPA,cAAAA,CAAAA,aAAAA,EAAuCG,QAAQ,CAA/CH,MAAAA,EAAwDS,OAAO,CAA/DT,KAAAA;AAjBJ,CAAA;;AAoBA,MAAM2B,6BAA6B,GAAG,UAAA,aAAA,EAAA,SAAA,EAAA,eAAA,EAAA,KAAA,EAAA,QAAA,EAAA,sBAAA,EAAA,QAAA,EAAA,MAAA,EAAA,SAAA,EAA4H;EAC9J,IAAIC,KAAK,GAAG;IACRlB,IAAI,EADI,aAAA;IAERQ,GAAG,EAAEC,SAAS,CAFN,GAAA;IAGRC,UAAU,EAAEC,SAAS,GAAA,SAAA,GAHb,IAAA;IAIRT,eAAe,EAJP,eAAA;IAAA,KAAA;IAAA,QAAA;IAAA,MAAA;IAQRU;EARQ,CAAZ;EAUAM,KAAK,CAALA,UAAAA,GAAmB,KAAK,CAAL,UAAA,GAAmB,EAClC,GAAGA,KAAK,CAD0B,UAAA;IAElCL,qBAAqB,EAAE;MACnBC;IADmB;EAFW,CAAnB,GAKf;IACAD,qBAAqB,EAAE;MACnBC;IADmB;EADvB,CALJI;EAUA5B,OAAO,CAAPA,cAAAA,CAAAA,aAAAA,EAAuCG,QAAQ,CAA/CH,MAAAA,EAAAA,KAAAA;AArBJ,CAAA;;AAwBA,MAAM6B,uBAAuB,GAAG,UAAA,OAAA,EAAA,SAAA,EAAA,QAAA,EAAA,aAAA,EAAwD;EACpF,IAAIC,UAAU,GAAG;IACbC,SAAS,EAAEtB;EADE,CAAjB;EAGAY,SAAS,GAAGhB,CAAC,CAADA,SAAAA,CAAaF,QAAQ,CAAjCkB,SAAYhB,CAAZgB;;EACA,IAAA,SAAA,EAAgB;IACZ,IAAI;MACAW,kBAAkB,CAAlBA,UAAAA,CAAAA,aAAAA,EAAAA,SAAAA,EAAAA,IAAAA,EAAAA,UAAAA,EAAAA,IAAAA;IADJ,CAAA,CAEE,OAAA,KAAA,EAAgB;MACd,MAAM,IAAA,KAAA,CAAN,KAAM,CAAN;IACH;EACJ;;EACD,OAAA,SAAA;AAZJ,CAAA;;AAeA,MAAMC,oBAAoB,GAAG,UAAA,QAAA,EAAA,aAAA,EAAA,OAAA,EAA6C;EACtE,IAAI9B,QAAQ,CAAZ,OAAA,EAAuB;IACnB,IAAI,CAACI,aAAa,CAAlB,QAAA,EAA8B;MAC1BA,aAAa,CAAbA,QAAAA,GAAAA,EAAAA;IACH;;IAED,MAAM2B,GAAG,GAAG/B,QAAQ,CAApB,OAAA;IACA,MAAMgC,KAAK,GAAX,EAAA;IACAA,KAAK,CAALA,GAAK,CAALA,GAAAA,OAAAA;IACA5B,aAAa,CAAbA,QAAAA,CAAwBJ,QAAQ,CAAhCI,OAAAA,IAA6C4B,KAAK,CAAlD5B,GAAkD,CAAlDA;IACAA,aAAa,CAAbA,IAAAA,CAAAA,QAAAA,GAA8B,EAAE,GAAGA,aAAa,CAAC6B;IAAnB,CAA9B7B;EACH;;EAEDA,aAAa,CAAbA,SAAAA,GAAAA,OAAAA;EACAA,aAAa,CAAbA,IAAAA,CAAAA,SAAAA,GAAAA,OAAAA;AAdJ,CAAA,C,CAiBA;;;AACA,OAAO,IAAI8B,qBAAqB,GAAG,UAAA,OAAA,EAAA,aAAA,EAAA,QAAA,EAAA,eAAA,EAAA,QAAA,EAAA,sBAAA,EAAA,SAAA,EAA2G;EAC1I,IAAI9B,aAAa,CAAbA,OAAAA,IAAyBF,CAAC,CAADA,UAAAA,CAAcE,aAAa,CAAxD,OAA6BF,CAA7B,EAAqE;IACjEE,aAAa,CAAbA,IAAAA,GAAqBA,aAAa,CAAlCA,OAAqBA,EAArBA;EACH;;EACD,MAAMI,KAAK,GAAG2B,QAAd,EAAA;EACA,MAAMzB,MAAM,GAAGS,SAAf,EAAA;EACA,MAAMV,eAAe,GAAGD,KAAK,CAA7B,eAAA;EACA4B,YAAY,CAAZA,KAAAA,CAAAA,QAAAA,EAA8BhC,aAAa,CAAbA,SAAAA,CAA9BgC,OAAAA,EAA+DpC,QAAQ,CAAvEoC,OAAAA;;EAEA,IAAIC,eAAe,IAAI/B,OAAO,CAAPA,OAAAA,KAAoBF,aAAa,CAAbA,SAAAA,CAA3C,OAAA,EAA6E;IACzE;EAVsI,CAAA,CAa1I;EACA;;;EACA,IAAIJ,QAAQ,CAARA,WAAAA,KAAAA,SAAAA,IAAsCM,OAAO,CAA7CN,OAAAA,IAAyDM,OAAO,CAAPA,OAAAA,KAAoBF,aAAa,CAAbA,SAAAA,CAAjF,OAAA,EAAmH;IAC/G;EACH;;EAED,IAAI,CAACQ,SAAS,CAATA,wBAAAA,CAAAA,aAAAA,EAAL,OAAKA,CAAL,EAAoE;IAChE0B,MAAM,CAANA,KAAAA,CAAc,gCAAA,yBAAA,GAA4DtC,QAAQ,CAAlFsC,OAAAA;IACA;EACH;;EAED,IAAIC,OAAO,GAAX,IAAA;EAEA;AACJ;AACA;;EACIrC,CAAC,CAADA,OAAAA,CAAWF,QAAQ,CAAnBE,QAAAA,EAA8B,UAAA,KAAA,EAAA,GAAA,EAAuB;IACjD;IACA,IAAIA,CAAC,CAADA,GAAAA,CAAOI,OAAO,CAAdJ,KAAAA,EAAAA,GAAAA,MAAAA,KAAAA,IAAyCA,CAAC,CAADA,GAAAA,CAAAA,OAAAA,EAAAA,GAAAA,MAA7C,KAAA,EAA+E;MAC3EqC,OAAO,GAAPA,KAAAA;IACH;EAJLrC,CAAAA;EAOA;AACJ;AACA;AACA;;;EAEI,IAAIsC,iBAAiB,GAAG1C,sBAAsB,CAAA,QAAA,EAAA,aAAA,EAAA,OAAA,EAAA,KAAA,EAAA,OAAA,EAA9C,MAA8C,CAA9C;;EAEA,IAAIwC,MAAM,CAAV,uBAAIA,EAAJ,EAAuC;IACnCF,YAAY,CAAZA,aAAAA,CAAAA,QAAAA,EAAAA,aAAAA,EAAAA,OAAAA,EAAAA,iBAAAA;EACH;;EACD,IAAA,iBAAA,EAAwB;IACpB,IAAIlB,SAAS,GADO,IACpB,CADoB,CAEpB;;IACA,IAAIlB,QAAQ,CAAZ,cAAA,EAA8B;MAC1B;MACA;MACA8B,oBAAoB,CAAA,QAAA,EAAA,aAAA,EAApBA,OAAoB,CAApBA;IANgB,CAAA,CAQpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IAEA,IAAI9B,QAAQ,CAAZ,SAAA,EAAyB;MACrBkB,SAAS,GAAGQ,uBAAuB,CAAA,OAAA,EAAA,SAAA,EAAA,QAAA,EAAnCR,aAAmC,CAAnCA;IACH;;IAED,IAAIlB,QAAQ,CAAZ,OAAA,EAAuB;MACnBa,qBAAqB,CAAA,aAAA,EAAA,OAAA,EAAA,KAAA,EAAA,QAAA,EAAA,SAAA,EAAA,sBAAA,EAAA,QAAA,EAAA,MAAA,EAArBA,SAAqB,CAArBA;IADJ,CAAA,MAEO,IAAIP,OAAO,IAAIA,OAAO,CAAtB,KAAA,EAA+B;MAClCiB,+BAA+B,CAAA,OAAA,EAAA,SAAA,EAAA,sBAAA,EAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAA,QAAA,EAAA,MAAA,EAA/BA,SAA+B,CAA/BA;IADG,CAAA,MAEA;MACHC,6BAA6B,CAAA,aAAA,EAAA,SAAA,EAAA,eAAA,EAAA,KAAA,EAAA,QAAA,EAAA,sBAAA,EAAA,QAAA,EAAA,MAAA,EAA7BA,SAA6B,CAA7BA;IACH;EACJ;AA9EE,CAAA;AAiFP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIiB,mCAAmC,GAAG,UAAA,iBAAA,EAAA,mBAAA,EAAA,UAAA,EAAA,eAAA,EAAA,YAAA,EAAA,eAAA,EACI;EACjD,IAAI,CAAJ,iBAAA,EAAyB;IACrB,OAAOC,gBAAgB,CAAhBA,QAAAA,CAAAA,MAAAA,CAAP,oCAAOA,CAAP;EACH;;EAED,IAAA,mBAAA,EAA0B;IACtB,IAAI,CAACC,mBAAmB,CAAnBA,SAAAA,CAAL,kBAAA,EAAwD;MACpD,OAAOD,gBAAgB,CAAhBA,QAAAA,CAAAA,MAAAA,CAAP,kDAAOA,CAAP;IACH;;IAED,IAAI,CAACC,mBAAmB,CAAnBA,SAAAA,CAAL,qBAAA,EAA2D;MACvD,OAAOD,gBAAgB,CAAhBA,QAAAA,CAAAA,MAAAA,CAAP,wDAAOA,CAAP;IACH;EACJ;EAED;AACJ;AACA;AACA;;;EACI,IAAIE,gBAAgB,GAAGC,mBAAmB,CAAnBA,gBAAAA,CAAAA,iBAAAA,EAAvB,eAAuBA,CAAvB;EACA,IAAIC,QAAQ,GAAZ,iBAAA;EAEA;AACJ;AACA;;EACI,IAAA,gBAAA;;EAEA,IAAA,mBAAA,EAA0B;IACtBC,gBAAgB,GAAhBA,mBAAAA;IAEA;AACR;AACA;AACA;AACA;;IACQ7C,CAAC,CAADA,OAAAA,CAAW4C,QAAQ,CAAnB5C,IAAAA,EAA0B,UAAA,SAAA,EAAA,QAAA,EAAgC;MACtD6C,gBAAgB,CAAhBA,QAAgB,CAAhBA,GAA+BH,gBAAgB,CAA/CG,QAA+C,CAA/CA;IADJ7C,CAAAA;;IAIA6C,gBAAgB,CAAhBA,aAAAA,GAAiCnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,aAAAA,EAC7BgC,gBAAgB,CADpBG,aAAiCnC,CAAjCmC;IAGAA,gBAAgB,CAAhBA,KAAAA,GAAyBnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,KAAAA,EACrBgC,gBAAgB,CADpBG,KAAyBnC,CAAzBmC;IAGAA,gBAAgB,CAAhBA,eAAAA,GAAmCnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,eAAAA,EAC/BgC,gBAAgB,CADpBG,eAAmCnC,CAAnCmC;IAGAA,gBAAgB,CAAhBA,cAAAA,GAAkCnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,cAAAA,EAC9BgC,gBAAgB,CADpBG,cAAkCnC,CAAlCmC;IAGAA,gBAAgB,CAAhBA,QAAAA,GAA4BnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,QAAAA,EACxBgC,gBAAgB,CADpBG,QAA4BnC,CAA5BmC;IAGAA,gBAAgB,CAAhBA,eAAAA,GAAmCnC,SAAS,CAATA,kBAAAA,CAA8BmC,gBAAgB,CAA9CnC,eAAAA,EAC/BgC,gBAAgB,CADpBG,eAAmCnC,CAAnCmC;IAGAA,gBAAgB,CAAhBA,iBAAAA,GAAqCnC,SAAS,CAATA,kBAAAA,CACjCmC,gBAAgB,CADiBnC,iBAAAA,EACGgC,gBAAgB,CA/BlC,iBA8BehC,CAArCmC,CA9BsB,CAiCtB;;IACA,IAAIC,GAAG,GAAGJ,gBAAgB,CAA1B,GAAA;;IACA,IAAA,GAAA,EAAU;MACN,IAAIE,QAAQ,CAARA,IAAAA,CAAJ,OAAA,EAA4B;QACxB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACAC,gBAAgB,CAAhBA,GAAAA,GAAuBH,gBAAgB,CAAvCG,GAAAA;QACAA,gBAAgB,GAAGnC,SAAS,CAATA,kBAAAA,CAAAA,gBAAAA,EACfgC,gBAAgB,CAAhBA,GAAAA,CADJG,KAAmBnC,CAAnBmC;QAEAA,gBAAgB,CAAhBA,YAAAA;MAjBJ,CAAA,MAkBO;QACHA,gBAAgB,CAAhBA,GAAAA,GAAuBA,gBAAgB,CAAhBA,iBAAAA,CAAoCC,GAAG,CAAvCD,GAAAA,EACnBD,QAAQ,CAARA,IAAAA,CADmBC,aAAAA,EACUD,QAAQ,CAARA,IAAAA,CADjCC,YAAuBA,CAAvBA;MAEH;IACJ;;IAEDA,gBAAgB,CAAhBA,SAAAA,CAAAA,mBAAAA,CAAAA,QAAAA;;IACAH,gBAAgB,CAAhBA,SAAAA,CAAAA,OAAAA,CAAAA,KAAAA;EA7DJ,CAAA,MA8DO;IACHG,gBAAgB,GAAhBA,gBAAAA;IAEA;AACR;AACA;;IACQA,gBAAgB,CAAhBA,SAAAA,CAAAA,WAAAA,CAAAA,QAAAA;IAEA;AACR;AACA;;;IACQA,gBAAgB,CAAhBA,SAAAA,CAAAA,qBAAAA,GAAAA,EAAAA;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ;IACA;IACA;IACA;IACA;IACA;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAMK;EAED;AACJ;AACA;;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;AACJ;AACA;;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAUI,OAAA,gBAAA;AAnOG,CAAA;AAsOP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,cAAc,GAAG,UAAA,WAAA,EAAA,aAAA,EAAuC;EAC/DC,WAAW,CAAXA,IAAAA,GAAAA,aAAAA;EACAA,WAAW,CAAXA,IAAAA,GAAmB9C,aAAa,CAAhC8C,IAAAA;EACAA,WAAW,CAAXA,GAAAA,GAAkBlC,SAAS,CAA3BkC,GAAAA;;EAEA,IAAI,CAACA,WAAW,CAAhB,UAAA,EAA8B;IAC1BA,WAAW,CAAXA,UAAAA,GAAyB9C,aAAa,CAAtC8C,kBAAyB9C,EAAzB8C;EACH;;EAEDd,YAAY,CAAZA,KAAAA,CAAAA,YAAAA,EAAkChC,aAAa,CAAbA,SAAAA,CAAlCgC,OAAAA,EAAAA,OAAAA;;EAEA,IAAIhC,aAAa,CAAbA,SAAAA,CAAJ,KAAA,EAAoC;IAChC,IAAI,CAAC+C,yBAAyB,CAAzBA,GAAAA,CAAL,oBAAKA,CAAL,EAA6D;MACzDA,yBAAyB,CAAzBA,GAAAA,CAAAA,oBAAAA,EAAAA,EAAAA;IACH;;IACD,MAAMC,EAAE,GAAGF,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAAX,OAAA;IACA,MAAMG,IAAI,GAAG,wBAAwBH,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAArC,MAAA;;IACA,IAAIC,yBAAyB,CAAzBA,GAAAA,CAAAA,IAAAA,MAAAA,IAAAA,IAAkDA,yBAAyB,CAAzBA,GAAAA,CAAAA,IAAAA,MAAtD,SAAA,EAA4G;MACxGA,yBAAyB,CAAzBA,GAAAA,CAAAA,oBAAAA,EAAqD,MAAM,CAAN,MAAA,CAAeA,yBAAyB,CAAzBA,GAAAA,CAAf,oBAAeA,CAAf,EAAsE;QACvH,CAAED,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAAF,MAAA,GAAuC;UACnC,CAAA,EAAA,GAAQA;QAD2B;MADgF,CAAtE,CAArDC;IADJ,CAAA,MAMO;MACHA,yBAAyB,CAAzBA,GAAAA,CAAAA,IAAAA,EAAqC,EAAE,GAAGA,yBAAyB,CAAzBA,GAAAA,CAAL,IAAKA,CAAL;QAA4C,CAAA,EAAA,GAAQD;MAApD,CAArCC;IACH;;IACDD,WAAW,CAAXA,KAAAA,GAAoB9C,aAAa,CAAbA,SAAAA,CAApB8C,KAAAA;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,IAAI,CAACA,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAAL,aAAA,EAAgD;IAC5CA,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAAAA,aAAAA,GAA2CA,WAAW,CAAtDA,GAAAA;IACAA,WAAW,CAAXA,IAAAA,CAAAA,SAAAA,CAAAA,WAAAA,GAAAA,WAAAA;EACH;EAED;AACJ;AACA;;;EACI,IAAII,kBAAkB,GAAG,YAAW;IAChC,IAAIC,cAAc,GAAGL,WAAW,CAAhC,IAAA;;IACA,IAAIM,kBAAkB,GAAG,YAAW;MAChC;MACA,IAAID,cAAc,IAAIA,cAAc,CAAhCA,SAAAA,IAA8CA,cAAc,CAAdA,SAAAA,CAAlD,KAAA,EAAmF;QAC/EJ,yBAAyB,CAAzBA,GAAAA,CAA+B,wBAAwBI,cAAc,CAAdA,SAAAA,CAAvDJ,MAAAA,EAAAA,IAAAA;MACH;MAED;AACZ;AACA;AACA;;;MACY,IAAII,cAAc,IAAIA,cAAc,CAAdA,SAAAA,CAAAA,aAAAA,KAA2CL,WAAW,CAA5E,GAAA,EAAmF;QAC/EA,WAAW,CAAXA,IAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,UAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,GAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,IAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,YAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,QAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,SAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,eAAAA,GAAAA,IAAAA;QACA;MACH;;MAED,IAAA,cAAA,EAAqB;QACjB,IAAIK,cAAc,CAAdA,SAAAA,CAAJ,OAAA,EAAuC;UACnCA,cAAc,CAAdA,SAAAA,CAAAA,OAAAA,CAAAA,IAAAA;QADJ,CAAA,MAEO;UACHjB,MAAM,CAANA,IAAAA,CAAa,gFAAbA,cAAAA;QAEH;;QACDY,WAAW,CAAXA,UAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,IAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,GAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,IAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,YAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,QAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,SAAAA,GAAAA,IAAAA;QACAA,WAAW,CAAXA,eAAAA,GAAAA,IAAAA;MACH;IArCL,CAAA;;IAuCAd,YAAY,CAAZA,KAAAA,CAAAA,YAAAA,EAAkChC,aAAa,CAAbA,SAAAA,CAAlCgC,OAAAA,EAAAA,SAAAA;;IACA,IAAIqB,eAAe,GAAGvD,CAAC,CAADA,GAAAA,CAAAA,aAAAA,EAAtB,oCAAsBA,CAAtB;;IACA,IAAA,eAAA,EAAsB;MAClBE,aAAa,CAAbA,YAAAA,GAAAA,IAAAA;MACAP,OAAO,CAAPA,cAAAA,CAAAA,aAAAA,EAAAA,eAAAA,EAAAA,WAAAA,EAAAA,IAAAA,CAA4E,YAAW;QACnF2D,kBAAkB;MADtB3D,CAAAA;IAFJ,CAAA,MAKO;MACH2D,kBAAkB;IACrB;EAlDL,CAAA;;EAqDA,IAAIN,WAAW,CAAf,WAAA,EAA8B;IAC1BtD,KAAK,CAAA,wCAAA,EAAA,aAAA,EAALA,WAAK,CAALA;IACA0D,kBAAkB;EAFtB,CAAA,MAGO;IACH;AACR;AACA;EACK;;EAED,IAAII,YAAY,GAAGxD,CAAC,CAADA,GAAAA,CAAAA,aAAAA,EAAnB,iCAAmBA,CAAnB;;EACA,IAAA,YAAA,EAAmB;IACfL,OAAO,CAAPA,cAAAA,CAAAA,aAAAA,EAAAA,YAAAA,EAAAA,WAAAA;EACH;AArHE,CAAA;AAwHP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAI8D,qBAAqB,GAAG,UAAA,kBAAA,EAAA,aAAA,EAA8C;EACtE,IAAIvD,aAAa,CAAbA,SAAAA,CAAJ,OAAA,EAAsC;IAClC,IAAIwD,MAAM,GAAGxD,aAAa,CAAbA,SAAAA,CAAAA,OAAAA,CAAb,kBAAaA,CAAb;;IACA,IAAIwD,MAAM,IAAIA,MAAM,CAANA,UAAAA,KAAVA,cAAAA,IAAkDxD,aAAa,CAAnE,aAAA,EAAoF;MAChF,OAAA,IAAA;IACH;EACJ;;EACD,OAAA,KAAA;AAPJ,CAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIyD,WAAW,GAAG,UAAA,kBAAA,EAAA,aAAA,EAA8C;EAC5D,OAAOzD,aAAa,CAAbA,SAAAA,CAAAA,OAAAA,IAAmCA,aAAa,CAAbA,SAAAA,CAAAA,OAAAA,CAA1C,kBAA0CA,CAA1C;AADJ,CAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI0D,eAAe,GAAG,UAAA,kBAAA,EAAA,aAAA,EAA8C;EAChE,OAAO1D,aAAa,CAAbA,aAAAA,IAA+BA,aAAa,CAAbA,aAAAA,CAAtC,kBAAsCA,CAAtC;AADJ,CAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAI2D,cAAc,GAAG,UAAA,aAAA,EAAA,kBAAA,EAAA,WAAA,EAAA,IAAA,EAAA,QAAA,EAA2E;EACnG,IAAI,CAACnD,SAAS,CAATA,0BAAAA,CAAAA,aAAAA,EAAL,WAAKA,CAAL,EAA0E;IACtE,OAAO8B,gBAAgB,CAAhBA,QAAAA,CAAP,OAAOA,EAAP;EACH;;EAED,IAAIkB,MAAM,GAAV,IAAA;;EAEA,IAAIxD,aAAa,CAAbA,SAAAA,CAAJ,OAAA,EAAsC;IAClCwD,MAAM,GAAGxD,aAAa,CAAbA,SAAAA,CAAAA,OAAAA,CAATwD,kBAASxD,CAATwD;EACH;EAED;AACJ;AACA;AACA;;;EAEI,IAAID,qBAAqB,CAAA,kBAAA,EAArBA,aAAqB,CAArBA,IAAJ,MAAA,EAA2E;IACvE;IACAC,MAAM,CAANA,QAAAA,GAAAA,kBAAAA;IACA,OAAOI,SAAS,CAATA,yBAAAA,CAAAA,aAAAA,EAAAA,MAAAA,EAAP,WAAOA,CAAP;EAHJ,CAAA,MAIO,IAAIH,WAAW,CAAA,kBAAA,EAAf,aAAe,CAAf,EAAuD;IAC1DzD,aAAa,CAAbA,QAAAA,GAAAA,SAAAA,CAAAA,MAAAA;IACA;;IACAwD,MAAM,CAANA,QAAAA,GAAAA,kBAAAA;;IACA,IAAIA,MAAM,CAAV,IAAA,EAAkB;MACd,IAAIK,QAAQ,GAAG,UAAA,YAAA,EAAyB;QACpC;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB,IAAI7D,aAAa,CAAjB,WAAIA,EAAJ,EAAkC;UAC9BQ,SAAS,CAATA,iBAAAA,CAAAA,aAAAA,EAAAA,MAAAA,EAAAA,gDAAAA,EAAAA,gBAAAA;QADJ,CAAA,MAGO;UACH;AACpB;AACA;AACA;UACoB,IAAIsD,YAAY,GAAGtD,SAAS,CAATA,mBAAAA,CAAAA,aAAAA,EALhB,WAKgBA,CAAnB,CALG,CAOH;;UACA,IAAIuD,aAAa,GAAjB,YAAA;;UAEA,IAAI,CAAA,YAAA,IAAiBP,MAAM,CAANA,IAAAA,KAArB,qBAAA,EAA6D;YACzDO,aAAa,GAAbA,OAAAA;UACH;;UAED,OAAO,SAAS,CAAT,aAAA,CAAA,aAAA,EAAA,MAAA,EAAA,YAAA,EAAA,aAAA,EAAA,IAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,CAA0G,YAAW;YACxH/D,aAAa,CAAbA,QAAAA,GAAAA,YAAAA,CAAAA,MAAAA;UADG,CAAA,EAAA,KAAA,CAEI,UAAA,CAAA,EAAc;YACrBA,aAAa,CAAbA,QAAAA,GAAAA,YAAAA,CAAAA,MAAAA;YACAR,KAAK,CAAA,WAAA,EAALA,CAAK,CAALA;YACA0C,MAAM,CAANA,KAAAA,CAAAA,WAAAA,EAHqB,CAGrBA,EAHqB,CAIrB;UANJ,CAAO,CAAP;QAQH;;QACD,OAAA,SAAA;MArCJ,CAAA;MAwCA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;MAGY,OAAO,aAAa,CAAEsB,MAAM,CAArB,IAAa,CAAb,CAAA,IAAA,CAAmC,UAAA,eAAA,EAA4B;QAClE,OAAOK,QAAQ,CAAf,eAAe,CAAf;MADJ,CAAO,CAAP;IAGH;;IACD,OAAO,SAAS,CAAT,aAAA,CAAA,aAAA,EAAA,MAAA,EAAA,WAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,CAAgG,YAAW;MAC9G7D,aAAa,CAAbA,QAAAA,GAAAA,YAAAA,CAAAA,MAAAA;IADG,CAAA,EAAA,KAAA,CAEI,UAAA,CAAA,EAAc;MACrBA,aAAa,CAAbA,QAAAA,GAAAA,YAAAA,CAAAA,MAAAA;MACAR,KAAK,CAAA,WAAA,EAALA,CAAK,CAALA;MACA0C,MAAM,CAANA,KAAAA,CAAc,gBAHO,CAGrBA,EAHqB,CAIrB;IANJ,CAAO,CAAP;EA/DG,CAAA,MAuEA,IAAIwB,eAAe,CAAA,kBAAA,EAAnB,aAAmB,CAAnB,EAA2D;IAC9DF,MAAM,GAANA,EAAAA;IACAA,MAAM,CAANA,UAAAA,GAAAA,cAAAA;IACAA,MAAM,CAANA,MAAAA,GAAAA,kBAAAA;IACA,OAAOI,SAAS,CAATA,yBAAAA,CAAAA,aAAAA,EAAAA,MAAAA,EAAP,WAAOA,CAAP;EACH;;EAED,OAAOtB,gBAAgB,CAAhBA,QAAAA,CAAP,OAAOA,EAAP;AAlGG,CAAA;AAqGP7C,OAAO,GAAG;EAAA,mCAAA;EAAA,cAAA;EAGNkE;AAHM,CAAVlE;AAKA,eAAA,OAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides high level functionalities to work with view model.\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport declViewModProcFact from 'js/viewModelProcessingFactory';\nimport messagingSvc from 'js/messagingService';\nimport actionSvc from 'js/actionService';\nimport conditionSvc from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport declDataCtxService from 'js/declarativeDataCtxService';\nimport Debug from 'debug';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport declUtils from './declUtils';\nimport debugService from 'js/debugService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { loadDynModule } from 'js/moduleLoader';\n\nvar trace = new Debug( 'viewModel' );\n\nvar exports = {};\n\nconst eveulateEventCondition = function( eventObj, declViewModel, matched, props, context, fields ) {\n    var conditionResult = false;\n\n    if( eventObj.condition ) {\n        var conditionExpression = null;\n\n        if( _.startsWith( eventObj.condition, 'conditions.' ) ) {\n            var conditionObject = _.get( declViewModel._internal, eventObj.condition );\n\n            conditionExpression = conditionObject.expression;\n        } else {\n            conditionExpression = eventObj.condition;\n        }\n        let currContext = null;\n        if( context ) {\n            if( context.scope ) {\n                currContext = context.scope;\n            } else {\n                currContext = context;\n            }\n        } else {\n            currContext = { data: declViewModel, props: props, subPanelContext: props.subPanelContext, fields };\n        }\n        conditionResult = conditionSvc.evaluateCondition( declUtils.getLatestContext( currContext, declViewModel ), conditionExpression, context );\n\n        // if conditionResult is undefined or null we should consider result as false.\n        if( !conditionResult ) {\n            conditionResult = false;\n        }\n    }\n    return eventObj.condition && conditionResult || eventObj.criteria && matched ||\n        !( eventObj.condition || eventObj.criteria );\n};\n\nconst processMessageOnEvent = function( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields ) {\n    var allMessages = _.cloneDeep( declViewModel._internal.messages );\n    if( !context.scope ) {\n        context.scope = {\n            data: declViewModel,\n            ctx: appCtxSvc.ctx,\n            props,\n            getProps,\n            parameters: inputArgs ? inputArgs : null,\n            fields,\n            getFields\n        };\n        context.scope.parameters = context.scope.parameters ? {\n            ...context.scope.parameters,\n            commandActionExecutor: {\n                runActionWithViewModel\n            }\n        } : {\n            commandActionExecutor: {\n                runActionWithViewModel\n            }\n        };\n    }\n    messagingSvc.reportNotyMessage( declViewModel, allMessages, eventObj.message,\n        context.scope );\n};\n\nconst processActionOnEventHavingScope = function( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields ) {\n    context.scope.parameters = inputArgs ? inputArgs : null;\n    context.scope.parameters = context.scope.parameters ? {\n        ...context.scope.parameters,\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    } : {\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    };\n    context.scope.props = props;\n    context.scope.getProps = getProps;\n    context.scope.fields = fields;\n    context.scope.getFields = getFields;\n\n    exports.executeCommand( declViewModel, eventObj.action, context.scope );\n};\n\nconst processActionOnEventWithScope = function( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields ) {\n    var scope = {\n        data: declViewModel,\n        ctx: appCtxSvc.ctx,\n        parameters: inputArgs ? inputArgs : null,\n        subPanelContext: subPanelContext,\n        props,\n        getProps,\n        fields,\n        getFields\n    };\n    scope.parameters = scope.parameters ? {\n        ...scope.parameters,\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    } : {\n        commandActionExecutor: {\n            runActionWithViewModel\n        }\n    };\n    exports.executeCommand( declViewModel, eventObj.action, scope );\n};\n\nconst reteriveInputParOfEvent = function( context, inputArgs, eventObj, declViewModel ) {\n    var contextObj = {\n        eventData: context\n    };\n    inputArgs = _.cloneDeep( eventObj.inputArgs );\n    if( inputArgs ) {\n        try {\n            declDataCtxService.applyScope( declViewModel, inputArgs, null, contextObj, null );\n        } catch ( error ) {\n            throw new Error( error );\n        }\n    }\n    return inputArgs;\n};\n\nconst handleEventDataCache = function( eventObj, declViewModel, context ) {\n    if( eventObj.eventId ) {\n        if( !declViewModel.eventMap ) {\n            declViewModel.eventMap = {};\n        }\n\n        const key = eventObj.eventId;\n        const value = {};\n        value[ key ] = context;\n        declViewModel.eventMap[ eventObj.eventId ] = value[ key ];\n        declViewModel.data.eventMap = { ...declViewModel.eventMap };\n    }\n\n    declViewModel.eventData = context;\n    declViewModel.data.eventData = context;\n};\n\n// eslint-disable-next-line complexity\nexport let handleRegisteredEvent = function( context, declViewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields ) {\n    if( declViewModel.getData && _.isFunction( declViewModel.getData ) ) {\n        declViewModel.data = declViewModel.getData();\n    }\n    const props = getProps();\n    const fields = getFields();\n    const subPanelContext = props.subPanelContext;\n    debugService.debug( 'events', declViewModel._internal.panelId, eventObj.eventId );\n\n    if( limitEventScope && context._source !== declViewModel._internal.modelId ) {\n        return;\n    }\n\n    // Check if the event source is set to 'current' and _source id is available.\n    // If yes, make event listeners only listen to events fired by the current view model instance.\n    if( eventObj.eventSource === 'current' && context._source && context._source !== declViewModel._internal.modelId ) {\n        return;\n    }\n\n    if( !declUtils.isValidModelAndEventData( declViewModel, context ) ) {\n        logger.error( '_processEventRegistration: ' + 'Invalid input: eventId=' + eventObj.eventId );\n        return;\n    }\n\n    var matched = true;\n\n    /**\n     * @deprecated : 'criteria' is deprecated we should use condition instead.\n     */\n    _.forEach( eventObj.criteria, function( value, key ) {\n        // For panel change events, the context doesn't have a scope, so check the properties on context directly.\n        if( _.get( context.scope, key ) !== value && _.get( context, key ) !== value ) {\n            matched = false;\n        }\n    } );\n\n    /**\n     * \"onEvent\": [ { \"eventId\": \"someEvent\", \"condition\": \"conditions.shouldIDoSomething\",\n     * \"action\":\"doSomething\" } ]\n     */\n\n    var isEventExecutable = eveulateEventCondition( eventObj, declViewModel, matched, props, context, fields );\n\n    if( logger.isDeclarativeLogEnabled() ) {\n        debugService.debugEventSub( eventObj, declViewModel, context, isEventExecutable );\n    }\n    if( isEventExecutable ) {\n        var inputArgs = null;\n        // Store the context eventData on declViewModel's eventData\n        if( eventObj.cacheEventData ) {\n            // const { dispatch } = declViewModel;\n            // let finalObj = {};\n            handleEventDataCache( eventObj, declViewModel, context );\n        }\n        // If an event has some eventData and the same eventdata is required in the action,\n        // associated with event, then user can construct inputArgs.\n        // \"eventId\": \"AWEvent.test\",\n        //     \"action\": \"fireSaveEdit\",\n        //         \"inputArgs\": {\n        //         \"param1\": \"{{eventData.operation1}}\",\n        //         \"param3\": {\n        //             \"param4\": \"{{eventData.operation4}}\",\n        //             \"param5\": \"{{eventData.operation5}}\"\n        //         }\n        //     }\n        // Later the same input Args can be reused in action through {{parameters.param1}}.\n\n        if( eventObj.inputArgs ) {\n            inputArgs = reteriveInputParOfEvent( context, inputArgs, eventObj, declViewModel );\n        }\n\n        if( eventObj.message ) {\n            processMessageOnEvent( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields );\n        } else if( context && context.scope ) {\n            processActionOnEventHavingScope( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields );\n        } else {\n            processActionOnEventWithScope( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields );\n        }\n    }\n};\n\n/**\n * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with\n * any data that is bound to various values including localized messages.\n *\n * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.\n *            <P>\n *            Note: The JSON contents are actually represented in the 'data' property of this object.\n *\n * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be\n *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)\n *\n * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a\n *            sub-panel\n * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by\n *            the current view model\n * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.\n *\n * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive\n *\n * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's\n *         JSON.\n */\nexport let populateViewModelPropertiesFromJson = function( declViewModelJson, declViewModelTarget, subPanelId,\n    limitEventScope, cacheI18nKey, subPanelContext ) {\n    if( !declViewModelJson ) {\n        return AwPromiseService.instance.reject( 'No ViewModel JSON object specified' );\n    }\n\n    if( declViewModelTarget ) {\n        if( !declViewModelTarget._internal.eventSubscriptions ) {\n            return AwPromiseService.instance.reject( 'Target ViewModel missing required event property' );\n        }\n\n        if( !declViewModelTarget._internal.origDeclViewModelJson ) {\n            return AwPromiseService.instance.reject( 'Target ViewModel missing required JSON object property' );\n        }\n    }\n\n    /**\n     * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved\n     * 'declViewModel'.\n     */\n    var newDeclViewModel = declViewModProcFact.processViewModel( declViewModelJson, subPanelContext );\n    var jsonData = declViewModelJson;\n\n    /**\n     * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')\n     */\n    var resDeclViewModel;\n\n    if( declViewModelTarget ) {\n        resDeclViewModel = declViewModelTarget;\n\n        /**\n         * Consolidate 'fresh' JSON properties into the given 'target'\n         * <P>\n         * Move all of the now populated 'data' properties into the 'target'\n         */\n        _.forEach( jsonData.data, function( propValue, propName ) {\n            resDeclViewModel[ propName ] = newDeclViewModel[ propName ];\n        } );\n\n        resDeclViewModel.dataProviders = declUtils.consolidateObjects( resDeclViewModel.dataProviders,\n            newDeclViewModel.dataProviders );\n\n        resDeclViewModel.grids = declUtils.consolidateObjects( resDeclViewModel.grids,\n            newDeclViewModel.grids );\n\n        resDeclViewModel.columnProviders = declUtils.consolidateObjects( resDeclViewModel.columnProviders,\n            newDeclViewModel.columnProviders );\n\n        resDeclViewModel.chartProviders = declUtils.consolidateObjects( resDeclViewModel.chartProviders,\n            newDeclViewModel.chartProviders );\n\n        resDeclViewModel.commands = declUtils.consolidateObjects( resDeclViewModel.commands,\n            newDeclViewModel.commands );\n\n        resDeclViewModel.commandHandlers = declUtils.consolidateObjects( resDeclViewModel.commandHandlers,\n            newDeclViewModel.commandHandlers );\n\n        resDeclViewModel.commandPlacements = declUtils.consolidateObjects(\n            resDeclViewModel.commandPlacements, newDeclViewModel.commandPlacements );\n\n        // Consolidate all properties from view model object in newDeclViewModel\n        var vmo = newDeclViewModel.vmo;\n        if( vmo ) {\n            if( jsonData.data.objects ) {\n                // Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.\n                //                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {\n                //                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,\n                //                                    jsonData.data.owningObjUid, dataPropValue[0] );\n                //                                if( dataPropValue[0].selected ) {\n                //                                    resDeclViewModel.vmo = newVmo;\n                //                                }\n                //                            } );\n                // The above code is no longer required. As there is no need to create a separate viewModelobject instance of\n                // of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),\n                // we already created  resDeclViewModel.vmo instance while forming the\n                // newDeclViewModel.\n                // Also difficult to determine which widgets are binded to which viewModel Object\n                resDeclViewModel.vmo = newDeclViewModel.vmo;\n                resDeclViewModel = declUtils.consolidateObjects( resDeclViewModel,\n                    newDeclViewModel.vmo.props );\n                resDeclViewModel.attachEvents();\n            } else {\n                resDeclViewModel.vmo = resDeclViewModel.attachModelObject( vmo.uid,\n                    jsonData.data.operationName, jsonData.data.owningObjUid );\n            }\n        }\n\n        resDeclViewModel._internal.consolidateJsonData( jsonData );\n        newDeclViewModel._internal.destroy( false );\n    } else {\n        resDeclViewModel = newDeclViewModel;\n\n        /**\n         * Move over fresh JSON properties\n         */\n        resDeclViewModel._internal.setJsonData( jsonData );\n\n        /**\n         * Object used to hold details of context changes that are being delayed (debounced).\n         */\n        resDeclViewModel._internal.pendingContextChanges = {};\n\n        /**\n         * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things\n         * calm down a bit.\n         *\n         * When running in test mode this function will not be debounced\n         *\n         * @private\n         */\n        // revisitme charu\n        // resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {\n        //     maxWait: 10000,\n        //     trailing: true,\n        //     leading: false\n        // } );\n\n        /**\n        * revisitme Shaishav\n        * Hint: It was agreed that we do not need these event subscriptions are not required anymore.\n        * Keeping comments till we support all the usecases in new declarative engine\n        /**\n         * Listener for appCtx registration events\n        var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {\n            if( context ) {\n                if( _logCtxPathActivity_1 ) {\n                    logger.info( 'appCtx.register Subscribe: ' + context.name );\n                }\n\n                resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;\n\n                resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Listener for command panel 'reveal' events\n        var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {\n            /**\n             * Only call the default \"reveal\" action on reveal of main panel which doesn't have a panel ID\n             * in this context. Check if the view model available on scope is same as the result view model.\n             * In case two declarative panels are displayed on a page, then it results in two subscriptions\n             * to the panel reveal event. Use the decl view model comparison to execute action against\n             * reveal for appropriate panel\n            if( context.scope && !context.scope.panelId ) {\n                var declViewModel = context.scope.data;\n\n                if( declViewModel === resDeclViewModel ) {\n                    exports.executeCommand( declViewModel, 'reveal', context.scope );\n                }\n            }\n        }, 'viewModelService' );\n\n        /**\n         * Remember these subscriptions to allow unsubscribe later.\n        resDeclViewModel._internal.eventSubscriptions.push( subDef1 );\n        resDeclViewModel._internal.eventSubscriptions.push( subDef2 );\n        */\n    }\n\n    /**\n     * Register any fresh 'eventBus' conditions\n     */\n    /**\n     * revisitme Shaishav\n     * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService\n    if( jsonData.onEvent ) {\n        var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,\n            limitEventScope, subPanelContext );\n        if( !declUtils.isNil( subPanelId ) ) {\n            if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {\n                resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;\n            } else {\n                _.forEach( eventSubscriptions, function( eventSubs ) {\n                    resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );\n                } );\n            }\n        } else {\n            resDeclViewModel._internal.eventSubscriptions = _.union(\n                resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );\n        }\n    }\n     */\n\n    /**\n     * Queue up loading and processing of the other model resources\n     */\n    /**\n     * revisitme Shaishav\n    * Hint: It was agreed that\n    * 1) We do not need load imports as we will rely on ES6 import / export\n    * 2) i18n population is already happening in the declreact/viewModelService.js\n    * 3) We have to populate TC preferences into the same flow when this revisitme is removed\n    * 4) Keeping comments till we support all the usecases in new declarative engine\n    var importsPromise = null;\n\n    if( jsonData.imports ) {\n        importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );\n    }\n\n    var prefPromise = null;\n\n    if( jsonData.preferences && jsonData.preferences.length > 0 ) {\n        prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );\n    }\n\n    var i18nPromise = null;\n\n    if( jsonData.i18n ) {\n        i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );\n    }\n\n    /**\n     * Wait for them all to complete\n    return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(\n        function( results ) {\n            resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,\n                results[ 1 ] );\n\n            resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );\n\n            declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );\n\n            return resDeclViewModel;\n        } );\n     */\n    return resDeclViewModel;\n};\n\n/**\n * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the\n *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.\n *\n * @param {DeclViewModel} declViewModel -\n */\nexport let setupLifeCycle = function( dataCtxNode, declViewModel ) {\n    dataCtxNode.data = declViewModel;\n    dataCtxNode.i18n = declViewModel.i18n;\n    dataCtxNode.ctx = appCtxSvc.ctx;\n\n    if( !dataCtxNode.conditions ) {\n        dataCtxNode.conditions = declViewModel.getConditionStates();\n    }\n\n    debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'mount' );\n\n    if( declViewModel._internal.ports ) {\n        if( !syncViewModelCacheService.get( 'syncViewModelCache' ) ) {\n            syncViewModelCacheService.set( 'syncViewModelCache', {} );\n        }\n        const id = dataCtxNode.data._internal.modelId;\n        const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n        if( syncViewModelCacheService.get( path ) === null || syncViewModelCacheService.get( path ) === undefined ) {\n            syncViewModelCacheService.set( 'syncViewModelCache', Object.assign( syncViewModelCacheService.get( 'syncViewModelCache' ), {\n                [ dataCtxNode.data._internal.viewId ]: {\n                    [ id ]: dataCtxNode\n                }\n            } ) );\n        } else {\n            syncViewModelCacheService.set( path, { ...syncViewModelCacheService.get( path ), [ id ]: dataCtxNode } );\n        }\n        dataCtxNode.ports = declViewModel._internal.ports;\n    }\n\n    /**\n     * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)\n     * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be\n     * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the\n     * declViewModel.\n     * <P>\n     * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very\n     * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The\n     * process will use this reference to the 'original' to resolve the event processing.\n     * <P>\n     * This property is nulled out when this declViewModel is destroyed.\n     * <P>\n     * **** This property should not be used for any other purpose until we can determine it won't cause more memory\n     * issues. *****\n     */\n    if( !dataCtxNode.data._internal.dataCtxNodeId ) {\n        dataCtxNode.data._internal.dataCtxNodeId = dataCtxNode.$id;\n        dataCtxNode.data._internal.origCtxNode = dataCtxNode;\n    }\n\n    /**\n     * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.\n     */\n    var handleDestroyEvent = function() {\n        var declViewModel2 = dataCtxNode.data;\n        var cleanupDataCtxNode = function() {\n            // remove vm from the syncViewModelCacheService\n            if( declViewModel2 && declViewModel2._internal && declViewModel2._internal.ports ) {\n                syncViewModelCacheService.set( 'syncViewModelCache.' + declViewModel2._internal.viewId, null );\n            }\n\n            /**\n             * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be\n             * destroyed.\n             */\n            if( declViewModel2 && declViewModel2._internal.dataCtxNodeId !== dataCtxNode.$id ) {\n                dataCtxNode.data = null;\n                dataCtxNode.conditions = null;\n                dataCtxNode.ctx = null;\n                dataCtxNode.i18n = null;\n                dataCtxNode.dataProvider = null;\n                dataCtxNode.eventMap = null;\n                dataCtxNode.eventData = null;\n                dataCtxNode.subPanelContext = null;\n                return;\n            }\n\n            if( declViewModel2 ) {\n                if( declViewModel2._internal.destroy ) {\n                    declViewModel2._internal.destroy( true );\n                } else {\n                    logger.warn( 'Attempt to delete a \"dataCtxNode.data\" that did not have a destroy method: ' +\n                        declViewModel2 );\n                }\n                dataCtxNode.conditions = null;\n                dataCtxNode.data = null;\n                dataCtxNode.ctx = null;\n                dataCtxNode.i18n = null;\n                dataCtxNode.dataProvider = null;\n                dataCtxNode.eventMap = null;\n                dataCtxNode.eventData = null;\n                dataCtxNode.subPanelContext = null;\n            }\n        };\n        debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'destroy' );\n        var onUnmountAction = _.get( declViewModel, '_internal.lifecycleHooks.onUnmount' );\n        if( onUnmountAction ) {\n            declViewModel.isUnmounting = true;\n            exports.executeCommand( declViewModel, onUnmountAction, dataCtxNode ).then( function() {\n                cleanupDataCtxNode();\n            } );\n        } else {\n            cleanupDataCtxNode();\n        }\n    };\n\n    if( dataCtxNode.$$destroyed ) {\n        trace( 'View model attached to destroyed scope', declViewModel, dataCtxNode );\n        handleDestroyEvent();\n    } else {\n        /** revisitme Shaishav: What's the alternative for the whole if / else block?\n            dataCtxNode.$on( '$destroy', handleDestroyEvent );\n        */\n    }\n\n    var onInitAction = _.get( declViewModel, '_internal.lifecycleHooks.onInit' );\n    if( onInitAction ) {\n        exports.executeCommand( declViewModel, onInitAction, dataCtxNode );\n    }\n};\n\n/**\n * return true for actionType dataProvider otherwise false\n * @param {string} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isDataProviderAction = function( actionOrProviderId, declViewModel ) {\n    if( declViewModel._internal.actions ) {\n        var action = declViewModel._internal.actions[ actionOrProviderId ];\n        if( action && action.actionType === 'dataProvider' && declViewModel.dataProviders ) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * return true for actionType other than dataProvider\n * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isAnAction = function( actionOrProviderId, declViewModel ) {\n    return declViewModel._internal.actions && declViewModel._internal.actions[ actionOrProviderId ];\n};\n\n/**\n *\n * return true for dataProvider and false for action\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @returns {true|false} ...\n */\nvar _isDataProvider = function( actionOrProviderId, declViewModel ) {\n    return declViewModel.dataProviders && declViewModel.dataProviders[ actionOrProviderId ];\n};\n\n/**\n * Execute command\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.\n *\n * @param {String} actionOrProviderId - The name of command action or data provider to be executed.\n *\n * @param {String} dataCtxNode - The AngularJS scope of this action command\n *\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n *\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @returns {null|Promise} ...\n */\nexport let executeCommand = function( declViewModel, actionOrProviderId, dataCtxNode, prop, viewData ) {\n    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        return AwPromiseService.instance.resolve();\n    }\n\n    var action = null;\n\n    if( declViewModel._internal.actions ) {\n        action = declViewModel._internal.actions[ actionOrProviderId ];\n    }\n\n    /**\n     * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>\n     * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.\n     */\n\n    if( _isDataProviderAction( actionOrProviderId, declViewModel ) && action ) {\n        /** action ID will be used for better logging */\n        action.actionId = actionOrProviderId;\n        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );\n    } else if( _isAnAction( actionOrProviderId, declViewModel ) ) {\n        declViewModel.getToken().addAction( action );\n        /** action ID will be used for better logging */\n        action.actionId = actionOrProviderId;\n        if( action.deps ) {\n            var doAction = function( depModuleObj ) {\n                /**\n                 * Check if the declViewModel got destroyed while we were waiting for the dependent module to be\n                 * loaded. This can happen, for example, when multiple subscribers are listening to a common\n                 * event like 'selection' and one of them (I'm look at you GWT) causes the panel the\n                 * declViewModel is associated with to close (thus destroying the $scope and the declViewModel\n                 * associated with it).\n                 * <P>\n                 * If so: There is nothing more that can be done with the declViewModel and we just want to log\n                 * a warning about the situation and move on.\n                 */\n                if( declViewModel.isDestroyed() ) {\n                    declUtils.logLifeCycleIssue( declViewModel, action, 'The command action was therefore not executed.',\n                        'executeCommand' );\n                } else {\n                    /**\n                     * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n                     * event processing was started.\n                     */\n                    var localDataCtx = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );\n\n                    // _deps will be undefined when try to load viewModelService inside itself\n                    var _depModuleObj = depModuleObj;\n\n                    if( !depModuleObj && action.deps === 'js/viewModelService' ) {\n                        _depModuleObj = exports;\n                    }\n\n                    return actionSvc.executeAction( declViewModel, action, localDataCtx, _depModuleObj, null, prop, viewData ).then( function() {\n                        declViewModel.getToken().removeAction( action );\n                    } ).catch( function( x ) {\n                        declViewModel.getToken().removeAction( action );\n                        trace( 'exception', x );\n                        logger.error( 'exception', x );\n                        //return AwPromiseService.instance.reject( x );\n                    } );\n                }\n                return undefined;\n            };\n\n            /**\n            * revisitme Jesse\n            * Hint: This needs to be uncommented once we have afxWeakImport supported\n            * Keeping comments till we support all the usecases in new declarative engine\n            var depModuleObj = moduleLoader.getDependentModule( action.deps );\n\n            if( depModuleObj ) {\n                return doAction( depModuleObj );\n            }\n\n            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {\n                return doAction( depModuleObject );\n            } );\n            */\n            return loadDynModule( action.deps ).then( function( depModuleObject ) {\n                return doAction( depModuleObject );\n            } );\n        }\n        return actionSvc.executeAction( declViewModel, action, dataCtxNode, null, null, prop, viewData ).then( function() {\n            declViewModel.getToken().removeAction( action );\n        } ).catch( function( x ) {\n            declViewModel.getToken().removeAction( action );\n            trace( 'exception', x );\n            logger.error( 'exception: ' + x );\n            //return AwPromiseService.instance.reject( x );\n        } );\n    } else if( _isDataProvider( actionOrProviderId, declViewModel ) ) {\n        action = {};\n        action.actionType = 'dataProvider';\n        action.method = actionOrProviderId;\n        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );\n    }\n\n    return AwPromiseService.instance.resolve();\n};\n\nexports = {\n    populateViewModelPropertiesFromJson,\n    setupLifeCycle,\n    executeCommand\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}