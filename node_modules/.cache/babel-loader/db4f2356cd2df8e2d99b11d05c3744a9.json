{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-disable complexity */ /**\n * This module provides access to service APIs that help to convert the model object to view model object\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/viewModelObjectService\n */import uwPropertySvc from'js/uwPropertyService';import cdm from'soa/kernel/clientDataModel';import lovService from'js/lovService';import visualIndicatorSvc from'js/visualIndicatorService';import colorDecoratorSvc from'js/colorDecoratorService';import cmm from'soa/kernel/clientMetaModel';import awIconSvc from'js/awIconService';import dateTimeSvc from'js/dateTimeService';import _ from'lodash';import logger from'js/logger';import declUtils from'js/declUtils';import eventBus from'js/eventBus';var exports={};/**\n * This is added to handle relational property specified in objectset. prop specified as \"relName.relProp\", need to\n * extract the actual prop name to extract value from the refModel Object\n *\n * @param {Object} prop - The IViewModelPropObject of an IViewModelObject (from serverVMO or modelObject property)\n * @param {String} propName - The property name\n * @param {IModelObject} refModelObject - The actual IModelObject for which we are creating ViewModelObject\n *\n * @return {ModelObjectProperty|null} The Result.\n */var getSourceObjectProp=function(prop,propName,refModelObject){var srcObj=null;if(!_.isEmpty(prop.intermediateObjectUids)){srcObj=cdm.getObject(prop.intermediateObjectUids[prop.intermediateObjectUids.length-1]);}else{srcObj=refModelObject;}var srcObjProp=srcObj?srcObj.props[propName]:null;if(!srcObjProp&&/\\./.test(propName)){var actualPropName=uwPropertySvc.getBasePropertyName(propName);srcObjProp=srcObj?srcObj.props[actualPropName]:null;}return srcObjProp;};var getPropValue=function(uw_displayValue,prop,propType,uw_dbValue,isDateAdjusted){uw_displayValue[0]=_.isString(prop.displayValue[0])?prop.displayValue[0]:new String(prop.displayValue[0]);if(propType==='DATE'){// eslint-disable-line no-lonely-if\nuw_dbValue=new Date(prop.value[0]).getTime();uw_displayValue[0]=isDateAdjusted?dateTimeSvc.formatDate(new Date(prop.displayValue[0]).getTime()):prop.displayValue[0];}else if(propType==='DATETIME'){// eslint-disable-line no-lonely-if\nuw_dbValue=new Date(prop.value[0]).getTime();uw_displayValue[0]=dateTimeSvc.formatSessionDateTime(new Date(prop.displayValue[0]).getTime());}else if((propType==='DOUBLE'||propType==='INTEGER')&&prop.value[0]){uw_dbValue=Number(prop.value[0]);}else if(propType==='CHAR'&&prop.displayValue[0]){uw_dbValue=prop.displayValue[0];}else{uw_dbValue=prop.value[0];}return uw_dbValue;};var getPropValueOnArray=function(uw_dbValue,prop,propType,uw_displayValue,isDateAdjusted){uw_dbValue=[];for(var i=0;i<prop.value.length;i++){var isCharArray=false;/**\n         * For character data types, TC server returns character ASCII values as the property internal\n         * value. Since AW doesn't differentiate between character and string types, the property object\n         * needs to created with display values as internal values. So passing the UI values as internal\n         * value.\n         */if(propType==='STRINGARRAY'&&prop.isCharArray){isCharArray=true;}uw_displayValue[i]=prop.displayValue[i];if(propType==='DATEARRAY'){uw_dbValue[i]=new Date(prop.value[i]).getTime();uw_displayValue[i]=isDateAdjusted?dateTimeSvc.formatDate(new Date(prop.displayValue[i]).getTime()):prop.displayValue[i];}else if(propType==='DATETIMEARRAY'){uw_dbValue[i]=new Date(prop.value[i]).getTime();uw_displayValue[i]=dateTimeSvc.formatSessionDateTime(new Date(prop.displayValue[i]).getTime());}else if((propType==='DOUBLEARRAY'||propType==='INTEGERARRAY')&&prop.value[i]){uw_dbValue[i]=Number(prop.value[i]);}else if(isCharArray&&prop.displayValue[i]){uw_dbValue[i]=prop.displayValue[i];}else{uw_dbValue[i]=prop.value[i];}}return uw_dbValue;};var getPropValueNotArray=function(prop,uw_displayValue,propType,uw_dbValue){if(_.isNil(prop.displayValue[0])){uw_displayValue[0]='';}else{var tempDisplayValue=new String(prop.displayValue[0]);uw_displayValue[0]=_.isString(prop.displayValue[0])?prop.displayValue[0]:tempDisplayValue;}if(propType==='DATE'){// eslint-disable-line no-lonely-if\nuw_dbValue=new Date(prop.value).getTime();uw_displayValue[0]=dateTimeSvc.formatDate(new Date(prop.displayValue[0]).getTime());}else if(propType==='DATETIME'){// eslint-disable-line no-lonely-if\nuw_dbValue=new Date(prop.value[0]).getTime();uw_displayValue[0]=dateTimeSvc.formatSessionDateTime(new Date(prop.displayValue[0]).getTime());}else if((propType==='DOUBLE'||propType==='INTEGER')&&prop.value&&isFinite(prop.value)&&prop.value!==null&&prop.value!==''&&!_.isArray(prop.value)){uw_dbValue=Number(prop.value);}else if(propType==='CHAR'&&prop.value){uw_dbValue=prop.displayValue[0];}else{uw_dbValue=prop.value;}return uw_dbValue;};/**\n *\n * @param {String} propType - The property type\n * @param {*} prop - The property value as defined in definition\n * @param {boolean} isDateAdjusted - isDateAdjusted\n * @returns {Object} - Object containing value and display value\n */var getPropertyValues=function(propType,prop,isDateAdjusted){var uw_dbValue=null;var uw_displayValue=null;if(!_.isUndefined(prop.value)&&!_.isNull(prop.value)){uw_displayValue=[];if(prop.isArray){uw_dbValue=getPropValueOnArray(uw_dbValue,prop,propType,uw_displayValue,isDateAdjusted);}else if(_.isArray(prop.value)&&prop.value.length>0){uw_dbValue=getPropValue(uw_displayValue,prop,propType,uw_dbValue,isDateAdjusted);}else{uw_dbValue=getPropValueNotArray(prop,uw_displayValue,propType,uw_dbValue);}}else if(!prop.value&&propType==='BOOLEAN'){uw_displayValue=[];if(_.isNil(prop.displayValue[0])){uw_displayValue[0]='';}else{var tempDisplayValue=new String(prop.displayValue[0]);uw_displayValue[0]=_.isString(prop.displayValue[0])?prop.displayValue[0]:tempDisplayValue;}uw_dbValue=prop.value;}else{uw_displayValue=prop.displayValue;}return{value:uw_dbValue,displayValue:uw_displayValue};};/**\n * format serverVMO/modelObject property as par consistent API schema\n *\n * @constructor\n *\n * @param {propObject} prop - The IModelObject to create a ViewModelObject for.\n * @param {string} propName - The IModelObject to create a ViewModelObject for.\n * @param {serverVMO} modelObject - The IModelObject to create a ViewModelObject for.\n * @param {serverVMO} serverVMO - The IModelObject to create a ViewModelObject for.\n * @param {string} operationName - operationName\n */var formatProperties=function(prop,propName,modelObject,serverVMO,operationName){var propValue=prop instanceof Object?Object.assign({},prop):new Object();var hasServerVMO=serverVMO&&serverVMO.props&&serverVMO.props.hasOwnProperty(propName);var initialValue='';var inputDbValues=null;var displayValues=null;var propDesc=prop.propertyDescriptor;propValue.isModifiable=false;if(!declUtils.isNil(prop.hasLOV)){propValue.hasLOV=prop.hasLOV;}else{propValue.hasLOV=propDesc&&propDesc.lovCategory>0;}if(hasServerVMO){propValue.propType=exports.getClientPropertyType(prop.type,prop.isArray===true);propValue.isRequired=prop.isRequired===true;propValue.displayName=prop.propertyDisplayName?prop.propertyDisplayName:null;propValue.referenceTypeName=prop.ReferencedTypeName?prop.ReferencedTypeName:'';propValue.isModifiable=prop.isModifiable===true;propValue.isCharArray=prop.type===1;initialValue=prop.initialValue?prop.initialValue:null;if(prop.hasRevRuleAttached){propValue.hasRevRuleAttached=prop.hasRevRuleAttached===true;}if(propValue.propType==='DATE'||propValue.propType==='DATEARRAY'){let propFromServerVMO=serverVMO.props[propName];//for date type property, set default value false to isTimeEnabled\npropValue.isTimeEnabled=false;if(propFromServerVMO){propValue.isTimeEnabled=_.isUndefined(propFromServerVMO.isTimeEnabled)?false:propFromServerVMO.isTimeEnabled;}}}else{var constantsMap;if(propDesc){propValue.isArray=propDesc.anArray;propValue.propType=exports.getClientPropertyType(propDesc.valueType,propValue.isArray);propValue.isCharArray=propDesc.valueType===1;propValue.displayName=propDesc.displayName;propValue.maxLength=propDesc.maxLength;propValue.maxArraySize=propDesc.maxArraySize?propDesc.maxArraySize:-1;constantsMap=propDesc.constantsMap;}if(constantsMap){initialValue=constantsMap.initialValue;propValue.initialValue=constantsMap.initialValue;propValue.isEditable=constantsMap.editable==='1';propValue.isRequired=constantsMap.required==='1';propValue.isAutoAssignable=constantsMap.autoassignable==='1';propValue.isRichText=constantsMap.Fnd0RichText==='1';propValue.isEnabled=constantsMap.editable?constantsMap.editable==='1':true;propValue.referenceTypeName=constantsMap.ReferencedTypeName||'';if(propValue.propType==='DATE'||propValue.propType==='DATEARRAY'){//from SOA getTypeDescriptions2, timeEnabled is undefined when Fnd0EnableTimeForDateProperty is default false.\npropValue.isTimeEnabled=_.isUndefined(constantsMap.timeEnabled)?false:constantsMap.timeEnabled==='1';}// If isModifiable is false on the modelObject, use that first over propertyDescriptor's constantsMap default value\nif(modelObject&&modelObject.props&&modelObject.props.is_modifiable&&modelObject.props.is_modifiable.dbValues&&modelObject.props.is_modifiable.dbValues[0]==='0'){propValue.isModifiable=false;}else{propValue.isModifiable=constantsMap.modifiable==='1';}}}if(_.isNil(propValue.isModifiable)){propValue.isModifiable=false;}if(operationName&&_.isString(operationName)){if(/^(EDIT|REVISE|SAVEAS|CREATE)$/i.test(operationName)){if(hasServerVMO){propValue.isEditable=prop.isModifiable===true;}else{propValue.isEditable=prop.modifiable===true;}}// Set isEnabled flag to 'true' for all properties for SaveAs ,Revise and Create operations.\n// <P>\n// Note: Create panel would require the below change when its converted to declarative.\nif(/^(REVISE|SAVEAS|CREATE)$/i.test(operationName)){propValue.isEnabled=true;}}if(propValue.isDCP){inputDbValues=prop&&prop.dbValues||[];displayValues=prop&&prop.uiValues||[];if(propValue.propType==='DATE'||propValue.propType==='DATEARRAY'){//For DCP property, replace displayValues with the date formatted dbValues value\nvar tempDisplayValues=[];for(var indx=0;indx<inputDbValues.length;indx++){if(propValue.isTimeEnabled===false){tempDisplayValues.push(dateTimeSvc.formatSessionDate(inputDbValues[indx]));}else{tempDisplayValues.push(dateTimeSvc.formatSessionDateTime(inputDbValues[indx]));}}if(tempDisplayValues.length>0){displayValues=tempDisplayValues;}}}else{var srcObjProp=getSourceObjectProp(prop,propName,modelObject);inputDbValues=srcObjProp&&srcObjProp.dbValues||[];displayValues=srcObjProp&&srcObjProp.uiValues||[];}propValue.dbValues=inputDbValues;if(inputDbValues&&inputDbValues.length>0){propValue.value=inputDbValues;}else if(initialValue!==''){propValue.value=initialValue;}else{propValue.value=null;}propValue.displayValue=displayValues;return propValue;};/**\n * Processing and assigning modelObject and serverVMO property on ViewModelObject\n * It is post processing.\n *\n * @constructor\n * @param {IModelObject} modelObject - The IModelObject to create a ViewModelObject for.\n * @param {IModelObject} viewModelObject - The IModelObject to create a ViewModelObject for.\n * @param {String} owningObjUid - The intended purpose for the new ViewModelOject (e.g. 'edit').\n */var alignPropertiesOnVMO=function(modelObject,viewModelObject,owningObjUid){_.forOwn(modelObject.props,function(propValue,propName){var propDesc=propValue.propertyDescriptor;if(propDesc){viewModelObject.propertyDescriptors[propName]=propDesc;}viewModelObject.props[propName].propertyDescriptor=propValue.propertyDescriptor;viewModelObject.props[propName].intermediateObjectUids=propValue.intermediateObjectUids;viewModelObject.props[propName].isDCP=propValue.isDCP||false;if(!viewModelObject.props[propName].lovApi&&viewModelObject.props[propName].hasLov){lovService.initNativeCellLovApi(viewModelObject.props[propName],null,viewModelObject.operationName,viewModelObject,owningObjUid);}});if(modelObject.type==='Awp0XRTObjectSetRow'&&modelObject.props.awp0Target){const target=cdm.getObject(modelObject.props.awp0Target.dbValues[0]);if(target){for(const prop of Object.values(modelObject.props)){if(!prop.propertyDescriptor&&target.props[prop.propertyName]){prop.propertyDescriptor=target.props[prop.propertyName].propertyDescriptor;}}for(const prop of Object.values(viewModelObject.props)){if(!prop.propertyDescriptor&&target.props[prop.propertyName]){prop.propertyDescriptor=target.props[prop.propertyName].propertyDescriptor;}}}}return viewModelObject;};/**\n * Update this model object's awp cell properties which are stored as key/value inside an array property\n * awp0CellProperties.\n *\n * @param {ViewModelObject} viewModelObject - The object to update properties on.\n */var updateCellProperties=function(viewModelObject){/**\n     * Pull any cell properties out of their encoded string and have them as 1st class properties of the\n     * ViewModelObject.\n     */if(viewModelObject.props&&viewModelObject.props.awp0CellProperties){// We should look up for dbValue always,'dbValues' is redundant and need to cleanup any dependency on that\n// dbValue could be array or string based on the mode object\nvar dbValue=viewModelObject.props.awp0CellProperties.dbValue;viewModelObject.cellProperties={};for(var ii=0;ii<dbValue.length;ii++){var keyValue=dbValue[ii].split('\\\\:');var value=keyValue[1]||'';value=value.replace('{__UTC_DATE_TIME}','');if(ii===0){viewModelObject.cellHeader1=value;}else if(ii===1){viewModelObject.cellHeader2=value;}else if(value){var key=keyValue[0];viewModelObject.cellProperties[key]={key:key,value:value};}}}};/**\n * Update this model object's Thumbnail URL based on the FMS ticket stored in the awp0ThumbnailImageTicket property\n *\n * @param {ViewModelObject} viewModelObject - The object to update properties on.\n */var updateIcons=function(viewModelObject){if(viewModelObject&&viewModelObject.props){viewModelObject.thumbnailURL=awIconSvc.getThumbnailFileUrl(viewModelObject);viewModelObject.typeIconURL=awIconSvc.getTypeIconFileUrl(viewModelObject);if(viewModelObject.thumbnailURL){viewModelObject.hasThumbnail=true;}else{viewModelObject.hasThumbnail=false;}}};/**\n * Get Model object from uid\n * @param {String} uid - The UID of the object whose Model object is required\n * @returns {modelObj} modelObject\n */var getModelObject=function(uid){return cdm.getObject(uid);};/**\n * Update this model object's status indicators\n *\n * @param {ViewModelObject} viewModelObject - The object to update properties on.\n */var updateStatusIndicators=function(viewModelObject){if(viewModelObject.props){// Since we dont want to add another dependency in visualIndicatorSvc on cdm, we are passing callback here\n// This will be called from visualIndicatorSvc when there is a need to get model object from UID.\nvar getObjCb=getModelObject;var adaptedVmo=viewModelObject;if(viewModelObject.type==='Awp0XRTObjectSetRow'){// Get underlying target object's UID if 'awp0Target' property exists\nif(viewModelObject.props&&viewModelObject.props.awp0Target){var targetUID=viewModelObject.props.awp0Target.dbValue;var targetMO=cdm.getObject(targetUID);if(targetMO){adaptedVmo=exports.constructViewModelObjectFromModelObject(targetMO,'edit',null,null,true);}}}var indicators=visualIndicatorSvc.getVisualIndicators(adaptedVmo,getObjCb);viewModelObject.indicators=indicators;}};/**\n * Update this model object's status indicators\n * @param {ViewModelObject|ViewModelObjectArray} vmoIn - The object(s) to update properties on.\n * @param {Boolean} skipEvent - if true will skip event.\n */var updateColorDecorators=function(vmoIn,skipEvent){colorDecoratorSvc.setDecoratorStyles(vmoIn,skipEvent);};/**\n * Method to construct VMO from serverVMO and modelObject\n *\n * @constructor\n *\n * @param {IModelObject} modelObject - The IModelObject to create a ViewModelObject for.\n * @param {String} operationName - The intended purpose for the new ViewModelOject (e.g. 'edit').\n * @param {String} owningObjUid - The UID of owning object.\n * @param {Object} serverVMO - (Optional) A property map from the server with values to include on the returned VMO.\n * @param {boolean}  skipIconUpdate - to udpate values\n */export let constructViewModelObjectFromModelObject=function(modelObject,operationName,owningObjUid,serverVMO,skipIconUpdate){var basicVMO={};basicVMO.props={};basicVMO.propertyDescriptors={};if(modelObject){if(serverVMO){basicVMO.uid=serverVMO.uid||modelObject.uid;if(serverVMO.alternateID||modelObject.alternateID){basicVMO.alternateID=serverVMO.alternateID||modelObject.alternateID;}basicVMO.type=serverVMO.type||modelObject.type;basicVMO.modelType=serverVMO.modelType||modelObject.modelType;if(!basicVMO.modelType){basicVMO.modelType=cmm.getType(basicVMO.type);}if(serverVMO.rowStatus){basicVMO.rowStatus=serverVMO.rowStatus;}var vmoProps=serverVMO.props;var moProps=modelObject.props;_.forEach(moProps,function(propValue,propName){if(propValue){if(vmoProps[propName]){var moPropValueClone=_.clone(propValue);_.merge(moPropValueClone,vmoProps[propName]);basicVMO.props[propName]=formatProperties(moPropValueClone,propName,modelObject,serverVMO,operationName);}else{basicVMO.props[propName]=formatProperties(propValue,propName,modelObject,serverVMO,operationName);}}});/**\n             * Check for the case of the serverVMO having a property NOT currently in the modelObject.\n             * <P>\n             * Note: Not sure when this could happen, but need to handle it.\n             */_.forEach(vmoProps,function(propValue,propName){if(propValue&&!moProps[propName]){basicVMO.props[propName]=formatProperties(propValue,propName,modelObject,serverVMO,operationName);}});}else{basicVMO.uid=modelObject.uid;if(modelObject.alternateID){basicVMO.alternateID=modelObject.alternateID;}basicVMO.type=modelObject.type;basicVMO.modelType=modelObject.modelType;if(!basicVMO.modelType){basicVMO.modelType=cmm.getType(basicVMO.type);}basicVMO.props={};_.forEach(modelObject.props,function(propValue,propName){if(propValue){basicVMO.props[propName]=formatProperties(propValue,propName,modelObject,serverVMO,operationName);}});}}var vmo=exports.constructViewModelObject(basicVMO,false);vmo.operationName=operationName;if(basicVMO.rowStatus){vmo.rowStatus=basicVMO.rowStatus;}var updateVMO=alignPropertiesOnVMO(basicVMO,vmo,owningObjUid);updateCellProperties(updateVMO);if(!skipIconUpdate){updateIcons(updateVMO);updateStatusIndicators(updateVMO);updateColorDecorators(updateVMO,true);}return updateVMO;};/**\n * Update this model object's status indicators\n * @param {prop} prop - The object(s) to update properties on.\n * @param {ViewModelProperty} viewProp - if true will skip event.\n * @param {type} propType - if true will skip event.\n */var populateViewModelProperty=function(prop,viewProp,propType){if(!declUtils.isNil(prop.autofocus)){uwPropertySvc.setAutoFocus(viewProp,prop.autofocus);}if(prop.labelPosition){uwPropertySvc.setPropertyLabelDisplay(viewProp,prop.labelPosition,true);if(prop.labelPosition==='PROPERTY_LABEL_AT_SIDE'){viewProp.editLayoutSide=true;}}if(prop.renderingStyle){uwPropertySvc.setPropertyLabelDisplay(viewProp,prop.renderingStyle,true);}// Add pattern information\nif(prop.patterns){viewProp.patterns=prop.patterns;if(prop.condition){viewProp.condition=prop.condition;}}// Add preferredPattern information\nviewProp.preferredPattern=prop.preferredPattern;// Add patternAutoAssignFlags information\nif(prop.patternAutoAssignFlags){viewProp.patternAutoAssignFlags=prop.patternAutoAssignFlags;}if(prop.validationCriteria){viewProp.validationCriteria=prop.validationCriteria;}if(!_.isUndefined(prop.oldValue)){viewProp.oldValue=prop.oldValue;}else if(prop.oldValues){viewProp.oldValues=prop.oldValues;}if(prop.vertical){viewProp.vertical=prop.vertical;}if(!viewProp.propApi){viewProp.propApi={};}if(propType==='BOOLEAN'&&prop.propertyRadioTrueText&&prop.propertyRadioFalseText){viewProp.propertyRadioTrueText=prop.propertyRadioTrueText;viewProp.propertyRadioFalseText=prop.propertyRadioFalseText;}};/**\n * @param {Object} prop -\n * @param {String} propName -\n * @param {Object} owningObj -\n * @param {boolean} isDateAdjusted -\n *\n * @returns {ViewModelProperty} New object initialized with the given data.\n */export let constructViewModelProperty=function(prop,propName,// eslint-disable-line\nowningObj,isDateAdjusted){var isArray=prop.isArray;var propType=prop.propType;var displayName='';if(prop.displayName){displayName=prop.displayName;}else if(prop.propertyDisplayName){displayName=prop.propertyDisplayName;}var isEditable=_.isUndefined(prop.isEditable)?false:prop.isEditable;var isModifiable=_.isUndefined(prop.isModifiable)?true:prop.isModifiable;var isRequired=prop.isRequired===true;var isAutoAssign=prop.isAutoAssign===true;var isAutoAssignable=prop.isAutoAssignable===true;var isRichText=prop.isRichText===true;var isEnabled=_.isUndefined(prop.isEnabled)?true:prop.isEnabled!==false;// default value\nvar referenceTypeName=prop.referenceTypeName?prop.referenceTypeName:'';var maxLength=_.isUndefined(prop.maxLength)?0:prop.maxLength;var maxArraySize=prop.maxArraySize?prop.maxArraySize:-1;var hasLov=prop.hasLOV===true;var isLocalizable=prop.isLocalizable===true;var isNull=false;var error=null;var renderingHint=prop.renderingHint?prop.renderingHint:'';var numberOfCharacters=-1;var numberOfLines=prop.numberOfLines?prop.numberOfLines:-1;var isSelectOnly=false;var requiredText=prop.requiredText;var isTimeEnabled=prop.isTimeEnabled!==false;var values=getPropertyValues(propType,prop,isDateAdjusted);if(propType==='CHAR'||propType==='STRINGARRAY'&&prop.isCharArray){maxLength=1;}if(propType&&propType==='DATETIME'){propType='DATE';}var viewProp=uwPropertySvc.createViewModelProperty(propName,displayName,propType,values.value,values.displayValue);if(propType==='STRING'||propType==='STRINGARRAY'){viewProp.inputType='text';}if(requiredText){uwPropertySvc.setPlaceHolderText(viewProp,requiredText);// need to add in VMO\n}isSelectOnly=_.isUndefined(prop.isSelectOnly)?true:prop.isSelectOnly;uwPropertySvc.setIsSelectOnly(viewProp,isSelectOnly,true);if(prop.hasRevRuleAttached){viewProp.hasRevRuleAttached=true;}populateViewModelProperty(prop,viewProp,propType);uwPropertySvc.setHasLov(viewProp,hasLov);uwPropertySvc.setIsRequired(viewProp,isRequired);uwPropertySvc.setIsArray(viewProp,isArray);uwPropertySvc.setIsAutoAssign(viewProp,isAutoAssign);uwPropertySvc.setIsAutoAssignable(viewProp,isAutoAssignable);uwPropertySvc.setIsEditable(viewProp,isEditable);uwPropertySvc.setIsRichText(viewProp,isRichText);uwPropertySvc.setIsEnabled(viewProp,isEnabled);uwPropertySvc.setIsLocalizable(viewProp,isLocalizable);uwPropertySvc.setIsNull(viewProp,isNull);uwPropertySvc.setLength(viewProp,maxLength);uwPropertySvc.setRenderingHint(viewProp,renderingHint);uwPropertySvc.setError(viewProp,error);uwPropertySvc.setNumberOfCharacters(viewProp,numberOfCharacters);uwPropertySvc.setNumberOfLines(viewProp,numberOfLines);uwPropertySvc.setArrayLength(viewProp,maxArraySize);uwPropertySvc.setIsPropertyModifiable(viewProp,isModifiable);uwPropertySvc.setReferenceType(viewProp,referenceTypeName);uwPropertySvc.setTimeEnabled(viewProp,isTimeEnabled);viewProp.initialize=false;viewProp.parentUid=owningObj?owningObj.uid:'';viewProp.dbValues=prop.dbValues?prop.dbValues:prop.value;viewProp.uiValues=values.displayValue;viewProp.uiValue=uwPropertySvc.getUiValue(viewProp.uiValues);viewProp.sourceObjectLastSavedDate=prop.srcObjLsd;viewProp.srcObjectTypeName=prop.srcObjectTypeName;viewProp.iconName=prop.iconName;viewProp.iconSource=prop.iconSource;viewProp.action=prop.action;viewProp.tooltip=prop.tooltip;return viewProp;};// constructViewModelProperty\n/**\n * Class used to help view specific state information.\n *\n * @constructor\n *\n * @param {IModelObject} modelObject - The IModelObject to create a ViewModelObject for.\n * @param {boolean} isDateAdjusted - isDateAdjusted\n */var ViewModelObject=function(modelObject,isDateAdjusted){// eslint-disable-line complexity\nvar self=this;self.props={};self.propertyDescriptors={};self.visible=true;self.uid=modelObject.uid;self.type=modelObject.type;self.modelType=modelObject.modelType;if(modelObject.alternateID){self.alternateID=modelObject.alternateID;}_.forOwn(modelObject.props,function(propValue,propName){if(propValue){self.props[propName]=exports.constructViewModelProperty(propValue,propName,self,isDateAdjusted);}});};/**\n * @return {String|Object} Displayable 'id' of this ViewModelObject (if possible, else the UID or '???' is\n *         returned).\n */ViewModelObject.prototype.toString=function(){if(this.cellHeader1){return this.cellHeader1;}else if(this.props.object_string&&this.props.object_string.uiValues[0]){return this.props.object_string.uiValues[0];}else if(this.uid){return this.uid;}return'???';};/**\n * Return array propertyNameValue objects (property name + real prop values) of the properties that have been\n * modified.\n *\n * @return {StringArray} Array of property names.\n */ViewModelObject.prototype.getDirtyProps=function(){var propertyNameValues=[];for(var prop in this.props){if(this.props.hasOwnProperty(prop)){if(uwPropertySvc.isModified(this.props[prop])){var propNameValue={};propNameValue.name=prop;propNameValue.values=uwPropertySvc.getValueStrings(this.props[prop]);propertyNameValues.push(propNameValue);}}}return propertyNameValues;};/**\n * Return array propertyNameValue objects (property name + real prop values) of the properties that have been\n * modified. The return objects can be passed to SOA without any further conversion.\n *\n * @return {StringArray} Array of property names.\n */ViewModelObject.prototype.getSaveableDirtyProps=function(){var propertyNameValues=this.getDirtyProps();_.forEach(propertyNameValues,function(propObject){var propVals=propObject.values;for(var i=0;i<propVals.length;i++){propVals[i]=String(propVals[i]);}});return propertyNameValues;};/**\n * Return array propertyNameValue objects (property name + real prop values) of the properties that have been\n * modified. The return objects can be passed to SOA without any further conversion.\n *\n * @return {StringArray} Array of property names.\n */ViewModelObject.prototype.getAutoAssignableProps=function(){var propertyNameValues=[];for(var prop in this.props){if(this.props.hasOwnProperty(prop)&&this.props[prop].isAutoAssignable){var propNameValue={};propNameValue.name=prop;propNameValue.values=uwPropertySvc.getValueStrings(this.props[prop]);propertyNameValues.push(propNameValue);}}_.forEach(propertyNameValues,function(propObject){var propVals=propObject.values;for(var i=0;i<propVals.length;i++){propVals[i]=String(propVals[i]);}});return propertyNameValues;};/**\n * This function sets the vmo edit state\n * @param {Object} vmo the view model object.\n * @param {Boolean} editState the edit state.\n */export const setEditState=function(vmo,editState){vmo.isEditing=editState;};/**\n * Resets the 'isEditable' on the view model (and 'modifiable' flags on the backing model object) for all view\n * properties.\n *\n * @param {Object} vmo - the view model object\n * @param {Boolean} skipDigest - (Optional) TRUE if the 'triggerDigestCycle' function should NOT be called<BR> FALSE\n *            if it SHOULD be called when there is a value change.\n */export const clearEditableStates=function(vmo,skipDigest){setEditState(vmo,false);_.forEach(vmo.props,function(prop2){uwPropertySvc.resetUpdates(prop2);uwPropertySvc.setIsEditable(prop2,false);});};/**\n * Resets the 'isEditable' on the view model (and 'modifiable' flags on the backing model object) for all view\n * properties.\n *\n * @param {Boolean} skipDigest - (Optional) TRUE if the 'triggerDigestCycle' function should NOT be called<BR> FALSE\n *            if it SHOULD be called when there is a value change.\n */ViewModelObject.prototype.clearEditiableStates=function(skipDigest){clearEditableStates(this,skipDigest);};/**\n * Sets the 'isEditable' of viewModelProperties if property in the associated IModelObject can be modified.\n *\n * @param {Boolean} editable - TRUE if the properties are to be marked as 'editable'.\n * @param {Boolean} override - TRUE if the editing state should be updated an announced even if not currently\n *            different than the desired state.\n * @param {Boolean} skipDigest - (Optional) TRUE if the 'triggerDigestCycle' function should NOT be called.\n */ViewModelObject.prototype.setEditableStates=function(editable,override,skipDigest){exports.setEditableStates(this,editable,override,skipDigest);};/**\n * Retrieves the id of the object, currently set to uid.\n *\n * Could change in future if each vmo (with cardinality) has their own unique id instead of 'uid'.\n *\n * @returns {String} The ID.\n */ViewModelObject.prototype.getId=function(){return this.uid;};/**\n\n * Retrieve the ViewModelProperty object with the same basePropertyName and sourceObjectUid as the parameters.\n\n *\n\n * @param {String} basePropertyName - the base property name trying to be matched\n\n * @param {String} uid - unique id\n\n *\n\n * @returns {ViewModelProperty} The found property.\n\n */ViewModelObject.prototype.retrievePropertyWithBasePropertyName=function(basePropertyName,uid){var foundProperty=null;_.forEach(this.props,function(currentProperty,key){var currentBasePropertyName=uwPropertySvc.getBasePropertyName(key);if(currentBasePropertyName===basePropertyName){var sourceObjectUid=uwPropertySvc.getSourceObjectUid(currentProperty);if(sourceObjectUid===uid){foundProperty=currentProperty;return false;}}});return foundProperty;};/**\n\n * create VMO API for all interface such as dataParser , viewModelCollection\n\n *\n\n * @constructor\n\n *\n\n * @param {IModelObject} modelObject - The IModelObject to create a ViewModelObject for.\n\n * @param {boolean} isDateAdjusted isDateAdjusted\n\n */export let constructViewModelObject=function(modelObject,isDateAdjusted){return new ViewModelObject(modelObject,isDateAdjusted);};/**\n\n * Get view model property type based on the value type and array flag.\n\n *\n\n * @param {Integer} valueType - The valueType for this property\n\n * @param {Boolean} isArray - array flag\n\n *\n\n * @return {propertyType} propertyType based off the integer value of valueType (String/Double/char etc.)\n\n */export let getClientPropertyType=function(valueType,isArray){// eslint-disable-line complexity\nvar propertyType;switch(valueType){case 1:if(isArray){propertyType='STRINGARRAY';}else{propertyType='CHAR';}break;case 2:if(isArray){propertyType='DATEARRAY';}else{propertyType='DATE';}break;case 3:case 4:if(isArray){propertyType='DOUBLEARRAY';}else{propertyType='DOUBLE';}break;case 5:if(isArray){propertyType='INTEGERARRAY';}else{propertyType='INTEGER';}break;case 6:if(isArray){propertyType='BOOLEANARRAY';}else{propertyType='BOOLEAN';}break;case 7:if(isArray){propertyType='INTEGERARRAY';}else{propertyType='SHORT';}break;case 8:if(isArray){propertyType='STRINGARRAY';}else{propertyType='STRING';}break;case 9:case 10:case 11:case 12:case 13:case 14:if(isArray){propertyType='OBJECTARRAY';}else{propertyType='OBJECT';}break;default:propertyType='UNKNOWN';break;}return propertyType;};/**\n\n * Sets the 'isEditable' of viewModelProperties if property in the associated IModelObject can be modified.\n\n *\n\n * @param {ViewModelObject} vmo - The viewModelObject containing the 'props' to be checked.\n\n * @param {Boolean} editable - TRUE if the properties are to be marked as 'editable'.\n\n * @param {Boolean} override - TRUE if the editing state should be updated an announced even if not currently\n\n *            different than the desired state.\n\n * @param {Boolean} skipDigest - (Optional) TRUE if the 'triggerDigestCycle' function should NOT be called.\n\n */export let setEditableStates=function(vmo,editable,override,skipDigest){setEditState(vmo,editable);var modelObject=cdm.getObject(vmo.uid);var isEditableNil=declUtils.isNil(editable);_.forEach(vmo.props,function(propValue,propName){if(propValue){if(isEditableNil){var modelProp=modelObject.props[propName];if(modelProp){propValue.isEditable=modelProp.modifiable;uwPropertySvc.setEditable(propValue,modelProp.modifiable);/**\n\n                     * Note : uwPropertySvc.setEditable method does not fire any property change event, Calling\n\n                     * uwPropertySvc.setEditState instead. No need to set viewProp.editableInViewModel separately as it\n\n                     * will be taken care by setEditStates method. This change is done as part of handling upload\n\n                     * dataset use case.\n\n                     */uwPropertySvc.setEditState(propValue,modelProp.modifiable,true);}}else{propValue.isEditable=editable;uwPropertySvc.setEditable(propValue,editable);/**\n\n                 * Note : uwPropertySvc.setEditable method does not fire any property change event, Calling\n\n                 * uwPropertySvc.setEditState instead . No need to set viewProp.editableInViewModel separately as it\n\n                 * will be taken care by setEditStates method. This changes is done as part of handling upload\n\n                 * dataset use case.\n\n                 */uwPropertySvc.setEditState(propValue,editable,override,true);}}});};/**\n\n/**\n\n * @param {String|Object} input - UID of the ModelObject to create a ViewModelObject wrapper for OR model object\n\n * @param {String} operationName - if \"EDIT\", then the VMO is modifiable. (null is acceptable)\n\n * @param {String} owningObjUid - The UID of owning object\n\n * @param {ViewModelObject} serverVMO -\n\n *\n\n * @return {ViewModelObject} Newly created ViewModelObject wrapper initialized with properties from the given\n\n *         inputs.\n\n */export let createViewModelObject=function(input,operationName,owningObjUid,serverVMO){var modelObject=input;if(_.isString(input)){modelObject=cdm.getObject(input);}else if(input&&input.uid&&!serverVMO){modelObject=cdm.getObject(input.uid);}if(!modelObject){logger.error('viewModelObject.createViewModelObject: '+'Unable to locate ModelObject in the clientDataModel with UID='+input);return null;}return exports.constructViewModelObjectFromModelObject(modelObject,operationName,owningObjUid,serverVMO);};/**\n\n * This is a preProcessor to 'updateSourceObjectPropertiesByViewModelObject' to trivially ignore updating existing\n\n * (loaded) VMOs in the given collection.\n\n *\n\n * @param {ViewModelObjectArray} loadedVMOs - Collection of viewModelObjects to consider for updating.\n\n *\n\n * @param {IModelObjectArray} updatedCDMObjects - CDM Objects that have been reported as updated or modified.\n\n */export let updateViewModelObjectCollection=function(loadedVMOs,updatedCDMObjects){/**\n\n     * Check if there is nothing to work on or with.\n\n     */if(_.isEmpty(loadedVMOs)||_.isEmpty(updatedCDMObjects)){return;}/**\n\n     * Create a map containing the unique UID of all the loaded viewModelObjects so that we can trivially ignore any\n\n     * changed CDM objects NOT in this viewModelCollection.\n\n     * <P>\n\n     * Note: The map needs to consider all the different UIDs a modified object could be referenced by it. The UID\n\n     * checks mirror the check made in 'updateSourceObjectPropertiesByViewModelObject'.\n\n     */var vmoMap={};_.forEach(loadedVMOs,function cdmHandlerCheck(vmo){if(vmo.uid){vmoMap[vmo.uid]=true;if(!_.isEmpty(vmo.props)){if(vmo.type==='Awp0XRTObjectSetRow'&&vmo.props.awp0Target&&vmo.props.awp0Target.dbValue){vmoMap[vmo.props.awp0Target.dbValue]=true;}_.forEach(vmo.props,function(vmProp){var sourceObjectUid=uwPropertySvc.getSourceObjectUid(vmProp);if(sourceObjectUid){vmoMap[sourceObjectUid]=true;}if(vmProp.parentUid){vmoMap[vmProp.parentUid]=true;}});}}});/**\n\n     * Check if we ended up with NO viewModelObjects.\n\n     */if(_.isEmpty(vmoMap)){return;}/**\n\n     * Loop for each modified object and update any VMOs effected by it.\n\n     */_.forEach(updatedCDMObjects,function _updateViewModelCollection(updatedObj){if(updatedObj.uid&&vmoMap[updatedObj.uid]){var updatedVmo=exports.createViewModelObject(updatedObj,'EDIT');if(updatedVmo&&updatedVmo.props){exports.updateSourceObjectPropertiesByViewModelObject(updatedVmo,loadedVMOs);}}});};/**\n\n * Updates all the viewModelObjects with the updatedVMO, depending on the property's sourceUid.\n\n *\n\n * @param {ViewModelObject} updatedVMO - view model object with updated information\n\n * @param {ViewModelObjectArray} origVMOs - all the view model objects that need to be updated\n\n */export let updateSourceObjectPropertiesByViewModelObject=function(updatedVMO,origVMOs,propsToUpdate){if(updatedVMO&&updatedVMO.props&&origVMOs){var updatedUid=updatedVMO.uid;var updatedProps={};_.forEach(origVMOs,function(vmo){if(vmo&&vmo.props){var vmoChanged=false;if(vmo.type==='Awp0XRTObjectSetRow'&&vmo.props.awp0Target&&vmo.props.awp0Target.dbValue===updatedUid){_.forEach(vmo.props,function(vmProp,key){// If this is not one of the props we want to update, continue\nif(propsToUpdate&&propsToUpdate.length>0&&propsToUpdate.indexOf(key)===-1){return true;}var updatedProp=updatedVMO.props[key];if(updatedProp){uwPropertySvc.copyModelData(vmProp,updatedProp);if(updatedProps[vmo.uid]===undefined){updatedProps[vmo.uid]=[];}updatedProps[vmo.uid].push(vmProp.propertyName);vmoChanged=true;}});}_.forEach(vmo.props,function(vmProp){var sourceObjectUid=uwPropertySvc.getSourceObjectUid(vmProp);// Need to handle both situations, where a DCP property is passed through the DCP object, or the\n// original object containing the property\nif(sourceObjectUid===updatedUid||vmProp.parentUid===updatedUid){var propertyNameLookup=vmProp.propertyName;if(sourceObjectUid===updatedUid&&sourceObjectUid!==vmProp.parentUid){propertyNameLookup=uwPropertySvc.getBasePropertyName(propertyNameLookup);}// If this is not one of the props we want to update, continue\nif(propsToUpdate&&propsToUpdate.length>0&&propsToUpdate.indexOf(propertyNameLookup)===-1){return true;}var updatedProp=updatedVMO.props[propertyNameLookup];if(updatedProp){var updatedPropSourceUid=uwPropertySvc.getSourceObjectUid(updatedProp);if(sourceObjectUid===updatedPropSourceUid){uwPropertySvc.copyModelData(vmProp,updatedProp);if(updatedProps[vmo.uid]===undefined){updatedProps[vmo.uid]=[];}updatedProps[vmo.uid].push(vmProp.propertyName);vmoChanged=true;}}}});_.forEach(updatedVMO.props,function(updatedVmProp){var updatedVmPropSourceUid=uwPropertySvc.getSourceObjectUid(updatedVmProp);// Need to handle both situations, where a DCP property is passed through the DCP object, or the\n// original object containing the property\nif(vmo.uid===updatedVmPropSourceUid||updatedVmProp.parentUid===vmo.uid){var updatedPropNameLookup=updatedVmProp.propertyName;if(updatedVmPropSourceUid===vmo.uid&&updatedVmPropSourceUid!==updatedVmProp.parentUid){updatedPropNameLookup=uwPropertySvc.getBasePropertyName(updatedPropNameLookup);}// If this is not one of the props we want to update, continue\nif(propsToUpdate&&propsToUpdate.length>0&&propsToUpdate.indexOf(updatedPropNameLookup)===-1){return true;}if(!vmo.props[updatedPropNameLookup]){vmo.props[updatedPropNameLookup]=updatedVmProp;if(updatedProps[vmo.uid]===undefined){updatedProps[vmo.uid]=[];}updatedProps[vmo.uid].push(updatedPropNameLookup);vmoChanged=true;}}});if(vmoChanged){updateCellProperties(vmo);updateStatusIndicators(vmo);updateColorDecorators(vmo);updateIcons(vmo);}}});eventBus.publish('viewModelObject.propsUpdated',updatedProps);}};/**\n\n * Update all existing VMO properties from the underlying CDM object's property value (with the same name).\n\n *\n\n * <pre>\n\n * </pre>\n\n *\n\n * @param {Object} vmo view model object\n\n */export let updateVMOProperties=function(vmo){if(!vmo.uid){return;}var modelObj=cdm.getObject(vmo.uid);if(!modelObj||!modelObj.props){return;}_.forEach(vmo.props,function(vmoProp,propName){if(modelObj.props.hasOwnProperty(propName)){var moProp=modelObj.props[propName];vmoProp.dbValues=moProp.dbValues;vmoProp.uiValues=moProp.uiValues;vmoProp.uiValue=moProp.getDisplayValue();if(moProp.uiValues){vmoProp.displayValues=moProp.uiValues;}else{vmoProp.displayValues=[];}vmoProp.isEditable=moProp.propertyDescriptor.constantsMap.editable==='1'&&moProp.modifiable;vmoProp.isLocalizable=moProp.propertyDescriptor.constantsMap.localizable==='1';}});updateCellProperties(vmo);updateStatusIndicators(vmo);updateColorDecorators(vmo);updateIcons(vmo);};/**\n\n * Test if the given object 'is-a' TreeLoadInput created by this service.\n\n *\n\n * @param {Object} objectToTest - Object to check prototype history of.\n\n * @return {Boolean} TRUE if the given object is a TreeLoadInput.\n\n */export let isViewModelObject=function(objectToTest){return objectToTest instanceof ViewModelObject;};/**\n * This recursive function returns the given vmos and their cached children if present\n * @param {* } vmObjects the view model objects.\n * @param {* } vmObjectsAcc the accumulation of the view model objects and their cached children.\n * @returns {* } vmObjects and any cached children.\n */export const getLoadedAndCachedViewModelObjects=function(vmObjects,vmObjectsAcc){if(!vmObjectsAcc){vmObjectsAcc=[];}_.forEach(vmObjects,vmo=>{vmObjectsAcc.push(vmo);if(vmo.__expandState){getLoadedAndCachedViewModelObjects(vmo.__expandState.expandedNodes,vmObjectsAcc);}});return vmObjectsAcc;};/**\n * This function gets the vmos that are not in edit\n * @param {* } vmObjects the view model objects.\n * @returns {* } vmObjects that are not in edit.\n */export const getVmosNotInEdit=function(vmObjects){return vmObjects.filter(vmObject=>{return!vmObject.isEditing;});};exports={constructViewModelProperty,constructViewModelObject,getClientPropertyType,setEditableStates,clearEditableStates,constructViewModelObjectFromModelObject,createViewModelObject,updateViewModelObjectCollection,updateSourceObjectPropertiesByViewModelObject,updateVMOProperties,isViewModelObject,getLoadedAndCachedViewModelObjects,getVmosNotInEdit,setEditState};export default exports;","map":null,"metadata":{},"sourceType":"module"}