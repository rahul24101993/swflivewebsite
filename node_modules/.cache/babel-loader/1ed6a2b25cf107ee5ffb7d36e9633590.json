{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * This service provides data patch operation to sepecific data object.\n *\n * @module js/store\n */import _ from'lodash';import{parseDataPath}from'js/declReactUtils';/**\n * Get data patch based on dispatch action\n * action could be:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {object} data scope for evaluation\n * @param {object} action dispatch action input\n * @returns {Array} patch array\n */export function getPatch(data,action){let res={};if(action.path===undefined){const scope=action.scope;for(var path in action.value){const value=action.value[path];path=scope?\"\".concat(scope,\".\").concat(path):path;if(_.get(data,path)!==value){res[path]=value;}}}else{const path=action.scope&&action.path?\"\".concat(action.scope,\".\").concat(action.path):action.scope||action.path;const value=action.value;if(path){if(_.get(data,path)!==value){res[path]=value;}}else if(path===''){res=data!==value&&_.isObject(value)?value:{};}else{// logically if path is always string this is not needed\nthrow Error('getPatch: Invalid path!');}}return res;}/**\n * Update data by specific path\n * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }\n * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }\n * @returns {object} updated data as mutation result\n */export const patchData=(patch,data)=>_.reduce(patch,(data,value,path)=>value===undefined?_.unset(data,path)&&data||data:_.set(data,path,value),data);/**\n * Update data. Only works for immutable framework\n * action could be:\n * {\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {function} updateFn view update function\n * @returns {function} updateFn accepts data and action\n */export const createReducer=updateFn=>(data,action)=>{const patch=getPatch(data,action);if(!_.isEmpty(patch)){return updateFn(patch,data);}return data;};/**\n * reducer for react Reducer hook, return 'immutable' object when value change\n * @param {object} data data object\n * @param {object} action action as { path, value }\n * @returns {function} reducer function used for react hook\n */export const reducer=createReducer((patch,data)=>({...patchData(patch,data)}));/**\n * compose key-dispatch function map to one dispatch function\n * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }\n * @returns {object} function pair dispatch and getDispatch\n */export const composeDispatch=dispatchFnMap=>{const dispatch=action=>{const actions=[];if(action.scope){// this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }\nactions.push(action);}else if(action.path===undefined){// re-assemble value to data and ctx\n// TODO: we can be more smart to identify the scope cluster more accurately\n// for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can\n// save more performance\nconst values=action.value;const patchMap=_.reduce(values,(res,value,dataPath)=>{const{scope,path}=parseDataPath(dataPath);res[scope]=res[scope]||{};res[scope][path]=value;return res;},{});_.forEach(patchMap,(value,scope)=>actions.push({scope,value}));}else{// re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to\nconst value=action.value;const dataPath=action.scope&&action.path?\"\".concat(action.scope,\".\").concat(action.path):action.scope||action.path;let{scope,path}=parseDataPath(dataPath);// path should be exist in this else branch, need to maintain that intention\npath=path||'';actions.push({scope,path,value});}actions.forEach(action=>getDispatch(action.scope)({...action,scope:undefined}));};const getDispatch=(dataPath,updateFn)=>{const{scope,path}=parseDataPath(dataPath);// TODO: error out for last branch\nupdateFn=updateFn||dispatchFnMap[scope]||(()=>null);return path?action=>{action.scope=action.scope?\"\".concat(path,\".\").concat(action.scope):path;return updateFn(action);}:updateFn;};return{dispatch,getDispatch};};","map":null,"metadata":{},"sourceType":"module"}