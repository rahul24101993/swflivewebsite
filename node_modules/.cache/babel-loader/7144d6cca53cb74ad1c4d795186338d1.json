{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module provides methods to process data parse configurations in the Declarative View Model\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined in this module is\n * injected by AngularJS.\n *\n * @module js/dataMapperService\n */import declarativeDataCtxSvc from'js/declarativeDataCtxService';import viewModelObjectService from'js/viewModelObjectService';import uwPropertySvc from'js/uwPropertyService';import visualIndicatorSvc from'js/visualIndicatorService';/** revisitme Shaishav\n * Hint: We need to bring following services\nimport awIconSvc from 'js/awIconService';\n*/import dateTimeSvc from'js/dateTimeService';import _ from'lodash';import logger from'js/logger';import declUtils from'js/declUtils';import debugService from'js/debugService';/**\n * Cached reference to dependent services\n */ /**\n * Marker text within a value used to indicate when a property contains a UTC date/time that needs to be converted\n * to to local time zone and session specific format.\n *\n * @private\n */var UTC_DATE_TIME_MARKER='{__UTC_DATE_TIME}';/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */var exports={};/**\n * Check if valid prop type\n * @param {String} type - Property type string\n * @return {boolean} Reference to service API.\n */var isValidPropType=function(type){return /^(BOOLEAN|DATE|DATETIME|DOUBLE|INTEGER|STRING|OBJECT)$/.test(type);};/**\n * Check if valid array prop type\n * @param {String} type - Property type string\n * @return {boolean} Reference to service API.\n */var isValidArrayPropType=function(type){return /^(BOOLEAN|DATE|DATETIME|DOUBLE|INTEGER|STRING|OBJECT)ARRAY$/.test(type);};/**\n * @param {String} propType - The property type\n * @param {Boolean} isArray - If the property is of array type\n * @returns {String} - The correct property type\n */var getPropertyType=function(propType,isArray){propType=propType.toUpperCase();if(isArray){if(isValidArrayPropType(propType)){return propType;}else if(isValidPropType(propType)){return propType+'ARRAY';}}else{if(isValidPropType(propType)){return propType;}}logger.warn('Unknown property type '+propType);return'UNKNOWN';};const uuidv4=()=>{return'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,function(c){// eslint-disable-next-line no-bitwise\nconst r=Math.random()*16|0;// eslint-disable-next-line no-bitwise\nconst v=c==='x'?r:r&0x3|0x8;return v.toString(16);});};/**\n * Convert one single response object to VMO\n * @param {Object} dataParseDef - The data parse definition\n * @returns {Object} - VMO containing view model properties\n */var constructViewModelObject=function(dataParseDef){var serverVMO={props:{}};serverVMO.uid=dataParseDef.identifier||uuidv4();serverVMO.type=dataParseDef.type;serverVMO.modelType=dataParseDef.modelType;_.forOwn(dataParseDef,function(val,key){if(key==='props'){_.forOwn(val,function(propDef,propId){serverVMO.props[propId]={};Object.assign(serverVMO.props[propId],propDef);serverVMO.props[propId].displayName=propDef.displayName||propDef.name;serverVMO.props[propId].propType=getPropertyType(propDef.type,propDef.isArray);serverVMO.props[propId].isArray=propDef.isArray===true;serverVMO.props[propId].displayValue=_.isArray(propDef.displayValue)?propDef.displayValue:[propDef.displayValue];if(propDef.isArray===true){serverVMO.props[propId].value=_.isArray(propDef.value)?propDef.value:[propDef.value];}else{serverVMO.props[propId].value=propDef.value;}});}});return viewModelObjectService.constructViewModelObject(serverVMO,true);};/**\n * Replace any occurrences of UTC date/time values with the {@link #UTC_DATE_TIME_MARKER} with the date/time in the\n * local time zone.\n *\n * @private\n *\n * @param { Object } cellProperties - object of cellProperties to consider.\n * @return { Object } Object if values after replacement of any strings.\n */var _convertUTCTimeValues=function(cellProperties){for(var prop in cellProperties){if(Object.prototype.hasOwnProperty.call(cellProperties,prop)){var value=cellProperties[prop].value;var markerNdx=value?value.indexOf(UTC_DATE_TIME_MARKER):-1;if(markerNdx!==-1){var prefix=value.substring(0,markerNdx);var utc=value.substring(markerNdx+UTC_DATE_TIME_MARKER.length);var date=new Date(utc);cellProperties[prop].value=prefix+dateTimeSvc.formatSessionDateTime(date);}}}return cellProperties;};/**\n * Convert one single response object to afx object\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context.\n * @param {Object} dataParseDefinition - The data parse definition\n * @param {Object} dataCtxNode - The data context node.\n * @param {Object} depModuleObj - The dependent module\n * @returns {Object} - vmo containing view model properties\n */var convertResponseObjToVMO=function(declViewModel,dataParseDefinition,dataCtxNode,depModuleObj){var functionsList=declViewModel.getFunctions();var dataParseDef=_.cloneDeep(dataParseDefinition);declarativeDataCtxSvc.applyScope(declViewModel,dataParseDef,functionsList,dataCtxNode,depModuleObj);var viewModelObject=constructViewModelObject(dataParseDef);_.forOwn(dataParseDef,function(val,key){if(key==='props'){_.forOwn(val,function(propDef,propId){if(propDef.dataProvider&&declViewModel.dataProviders){viewModelObject.props[propId].dataProvider=declViewModel.dataProviders[propDef.dataProvider];uwPropertySvc.setHasLov(viewModelObject.props[propId],true);viewModelObject.props[propId].emptyLOVEntry=propDef.emptyLOVEntry;viewModelObject.props[propId].isSelectOnly=propDef.isSelectOnly;}viewModelObject.props[propId].getViewModel=function(){return declViewModel;};if(viewModelObject.props[propId].type==='DATE'){viewModelObject.props[propId].dateApi=viewModelObject.props[propId].dateApi||{};viewModelObject.props[propId].dateApi.isDateEnabled=true;viewModelObject.props[propId].dateApi.isTimeEnabled=false;if(propDef.type==='DATETIME'){viewModelObject.props[propId].dateApi.isTimeEnabled=true;}}});}else{viewModelObject[key]=val;}});if(viewModelObject&&viewModelObject.indicators){var indicators=visualIndicatorSvc.getIndicatorFromJSON(viewModelObject.indicators);if(indicators.length>0){viewModelObject.indicators=indicators;}}if(viewModelObject&&viewModelObject.cellProperties){var cellProperties=_convertUTCTimeValues(viewModelObject.cellProperties);if(cellProperties){viewModelObject.cellProperties=cellProperties;}}/** revisitme Shaishav\n     * Hint: We need to bring aw icon service\n    if( viewModelObject && !viewModelObject.typeIconURL ) {\n        var typeIconURL = awIconSvc.getTypeIconFileUrl( viewModelObject );\n        if( typeIconURL ) {\n            viewModelObject.typeIconURL = typeIconURL;\n        }\n    }\n\n    if( !viewModelObject.thumbnailURL ) {\n        var thumbnailURL = awIconSvc.getThumbnailFileUrl( viewModelObject );\n        if( thumbnailURL ) {\n            viewModelObject.thumbnailURL = thumbnailURL;\n        }\n    }\n    */viewModelObject.hasThumbnail=!declUtils.isNil(dataParseDef.thumbnailURL);// Set thumbnail flag\nreturn viewModelObject;};/**\n * Apply the DataParseDefinitions to an array of response objects (as returned from a server).\n * This returns an array of objects which are consumable by various afx widgets.\n *\n * @param {Object} sourceObj - The object to apply dataParseDefinitions\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context.\n * @param {ObjectArray} actionDataParsers - The dataParseDefinitions.\n * @param {Object} dataCtxNode - The data context node.\n * @param {Object} depModuleObj - The dependent module\n * @return {Object} - the modified sourceObj with dataParseDefinition applied\n */export let applyDataParseDefinitions=function(sourceObj,declViewModel,actionDataParsers,dataCtxNode,depModuleObj){if(!_.isArray(actionDataParsers)){return sourceObj;}if(logger.isDeclarativeLogEnabled()){debugService.debugPreProcessingDataParser(sourceObj,declViewModel,actionDataParsers,dataCtxNode);}_.forEach(actionDataParsers,function(actionDpd){var dataParseDefinition=declViewModel.getDataParseDefinition(actionDpd.id);if(_.isUndefined(dataParseDefinition)){logger.warn('Missing DataParseDefinition with id '+actionDpd.id+' in DeclViewModel');return;}if(dataParseDefinition.typeHierarchy){dataParseDefinition.modelType={typeHierarchyArray:'{{response.typeHierarchy}}'};}var responseObjsPath=actionDpd.responseObjs;var responseObjs=_.get(sourceObj,responseObjsPath);debugService.debug('dataParsers',declViewModel._internal.panelId,actionDpd.id,responseObjs);var afxObjects=null;if(_.isArray(responseObjs)){afxObjects=[];_.forEach(responseObjs,function(responseObj){dataCtxNode.response=responseObj;dataCtxNode.i18n=dataCtxNode.i18n||dataCtxNode.data.i18n;var afxObject=convertResponseObjToVMO(declViewModel,dataParseDefinition,dataCtxNode,depModuleObj);delete dataCtxNode.response;afxObjects.push(afxObject);});}else if(_.isObject(responseObjs)){dataCtxNode.response=responseObjs;afxObjects=convertResponseObjToVMO(declViewModel,dataParseDefinition,dataCtxNode,depModuleObj);delete dataCtxNode.response;}_.set(sourceObj,responseObjsPath,afxObjects);});if(logger.isDeclarativeLogEnabled()){debugService.debugPostProcessingDataParser(sourceObj,declViewModel,actionDataParsers,dataCtxNode);}return sourceObj;};exports={applyDataParseDefinitions};export default exports;","map":null,"metadata":{},"sourceType":"module"}