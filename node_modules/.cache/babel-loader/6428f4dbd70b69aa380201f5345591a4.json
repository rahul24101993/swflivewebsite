{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\pltable\\\\src\\\\js\\\\splmTableEditor.js\";\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the edit function for PL Table.\n *\n * @module js/splmTableEditor\n */\n\nimport SPLMTableFillDown from 'js/splmTableFillDown';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport uwPropertyService from 'js/uwPropertyService';\nimport browserUtils from 'js/browserUtils';\nimport { getEditContext, displayAutoSaveOnGuidanceMessage, displayCellEditDisabledGuidanceMessage } from 'js/splmTableDirectEditUtils';\nimport { includeComponent } from 'js/moduleLoader';\nimport { renderComponent } from 'js/declReactUtils';\nimport { AppCtxComponent } from 'js/reactAppCtx';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Cell from 'js/splmTableCellRenderer';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar SPLMTableEditor = function (tableElem, directiveElem, gridContextDispatcher) {\n  let _trv = new Trv(tableElem);\n\n  let _fillDown = new SPLMTableFillDown(tableElem);\n\n  let _lovValueChangedEventSubs = {};\n  let _blurHandler = null;\n  let _focusProp = null;\n\n  let _tableInstance = util.getTableInstance(tableElem);\n\n  let _selectedCellInfo = null;\n  let _saveEditPromise = null;\n  let _isEditablePromise = null;\n  let _escapeKeyHandler = null;\n  let _enterKeyHandler = null;\n  let _fillDownSaveInprogress = false;\n  const ariaReadOnly = 'aria-readonly';\n  const ariaActiveDescendant = 'aria-activedescendant'; // cache local event subscription\n\n  let _eventBusSubs = [];\n  let self = this; // eslint-disable-line no-invalid-this\n\n  const destroyLovEventListeners = function () {\n    _.forEach(_lovValueChangedEventSubs, function (subscription) {\n      eventBus.unsubscribe(subscription);\n    });\n\n    _lovValueChangedEventSubs = {};\n  };\n\n  self.destroy = function () {\n    destroyLovEventListeners();\n\n    _.forEach(_eventBusSubs, function (sub) {\n      eventBus.unsubscribe(sub);\n    });\n\n    _eventBusSubs = [];\n  };\n\n  self.setFocusProp = function (prop) {\n    _focusProp = prop;\n  };\n\n  const triggerBlurHandler = function () {\n    if (_blurHandler) {\n      _blurHandler();\n    }\n  };\n\n  self.updateEditStatus = function () {\n    triggerBlurHandler();\n\n    var cellElems = _trv.getContentCellElementsFromTable();\n\n    _.forEach(cellElems, function (elem) {\n      self.updateEditStatusForCell(elem);\n    });\n\n    if (!util.isBulkEditing(tableElem)) {\n      _focusProp = null;\n      destroyLovEventListeners();\n    }\n  };\n\n  const toggleLinkStyle = function (element, isLinkStyle) {\n    if (isLinkStyle) {\n      // disabled to active link\n      var linkElements = element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n\n      for (var i = linkElements.length; i > 0; i--) {\n        var linkElem = linkElements[i - 1];\n\n        if (linkElem && linkElem.classList) {\n          linkElem.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n          linkElem.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n        }\n      }\n    } else {\n      // active to disabled links\n      linkElements = element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n\n      for (var j = linkElements.length; j > 0; j--) {\n        var linkElem1 = linkElements[j - 1];\n\n        if (linkElem1 && linkElem1.classList) {\n          linkElem1.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);\n          linkElem1.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);\n        }\n      }\n    }\n  };\n  /**\n   * Ensure the drag handle is the last element in the parent container.\n   *\n   * @param {DOMElement} cell - cell with drag handle to re-append\n   */\n\n\n  const ensureDragHandleLastChild = function (cell) {\n    var dragHandleElements = cell.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE);\n\n    if (dragHandleElements.length > 0) {\n      dragHandleElements[0].parentElement.appendChild(dragHandleElements[0]);\n    }\n  };\n\n  const reverseEditCell = function (cell, vmo, column, cellElemProperty) {\n    if (cell.parentElement === null) {\n      return;\n    }\n\n    cell.isElementInEdit = false;\n    var editCells = null;\n\n    if (cellElemProperty.isArray) {\n      editCells = cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY);\n    } else {\n      editCells = cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP);\n    }\n\n    var isErrorProperty = false;\n    var cellTopElement = Cell.createElement(column, vmo, tableElem, cell.parentElement);\n\n    if (_tableInstance.dynamicRowHeightStatus === true) {\n      Cell.addDynamicCellHeight(vmo, cellTopElement);\n    }\n\n    if (editCells.length > 0) {\n      var editCell = editCells[0];\n\n      if (cellElemProperty.isArray) {\n        const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n\n        if (editArrayPopup) {\n          editArrayPopup.hide();\n        }\n      } else {\n        editCell.parentElement.removeChild(editCell);\n      }\n\n      setTimeout(function () {\n        util.cleanupComponents(editCell);\n        var propertyErrorElements = editCell.getElementsByClassName('aw-widgets-propertyError');\n\n        if (propertyErrorElements.length > 0) {\n          isErrorProperty = true;\n        }\n\n        if (isErrorProperty) {\n          cellTopElement.classList.add('aw-widgets-propertyError');\n        }\n\n        if (!cellElemProperty.isArray) {\n          util.destroyElement(editCell);\n        }\n      }, 1000);\n    }\n\n    cell.classList.remove(Const.CLASS_AW_IS_EDITING);\n    cell.appendChild(cellTopElement);\n    var cellTopElements = cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP);\n\n    if (cellTopElements.length > 0) {\n      cellTopElements[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);\n    }\n\n    ensureDragHandleLastChild(cell);\n  };\n\n  const removeFocusEvents = function (cellElem) {\n    const useCapture = true;\n    cellElem.removeEventListener('focus', cellElem.onFocusEvent, useCapture);\n    cellElem.onFocusEvent = null;\n    cellElem.removeEventListener('mousedown', cellElem.onFocusClickEvent);\n    cellElem.onFocusClickEvent = null;\n  };\n\n  let _isUserClick = false;\n  let _isCtrlKey = false;\n\n  const addFocusEvent = function (cellElem, vmo) {\n    removeFocusEvents(cellElem);\n\n    const onFocusEvent = function (event) {\n      // Update row selection if clicking on editable cell. This is needed because UW widget stops propagation of the event\n      // to the row element when it is created.\n      if (_isUserClick) {\n        let eventObj;\n\n        if (browserUtils.isIE) {\n          eventObj = document.createEvent('MouseEvent');\n          eventObj.initMouseEvent('click', true, true, window, 0, eventObj.screenX, eventObj.screenY, eventObj.clientX, eventObj.clientY, _isCtrlKey, false, false, false, 0, null);\n        } else {\n          eventObj = new MouseEvent('click', {\n            ctrlKey: _isCtrlKey\n          });\n        }\n\n        cellElem.parentElement.dispatchEvent(eventObj);\n        _isUserClick = false;\n        _isCtrlKey = false;\n      }\n\n      self.editCell(cellElem, vmo);\n    };\n\n    cellElem.onFocusEvent = onFocusEvent;\n    const useCapture = true; // LCS-357443: IE does not focus the cell when using element.onfocus.\n    // Instead focus event must be added with addEventListener and useCapture as true.\n\n    cellElem.addEventListener('focus', onFocusEvent, useCapture);\n\n    const isFocusClickEvent = function (event) {\n      _isUserClick = true;\n      _isCtrlKey = event.ctrlKey;\n    };\n\n    cellElem.isFocusClickEvent = isFocusClickEvent;\n    cellElem.addEventListener('mousedown', isFocusClickEvent);\n  };\n\n  const addEditStatus = function (cellElem, cellElemProperty, vmo) {\n    if (cellElem.children[0]) {\n      cellElem.children[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);\n      var rowHeight = util.getTableRowHeight(_tableInstance.gridOptions, undefined);\n\n      if (rowHeight !== undefined) {\n        cellElem.children[0].style.height = rowHeight + 'px';\n      }\n    } else {\n      logger.debug(cellElem.propName + ' has no child');\n    }\n\n    addFocusEvent(cellElem, vmo);\n\n    _fillDown.enableFillDown(cellElem);\n\n    toggleLinkStyle(cellElem, false); // for saved cells in partial edit status\n\n    var cellTop = cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0] || cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP)[0] || cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY)[0];\n    Cell.updateCellChangedClass(cellElemProperty, cellTop);\n\n    if (_focusProp === cellElem.prop) {\n      self.editCell(cellElem, vmo);\n    }\n  };\n\n  const removeBlurHandler = function () {\n    const useCapture = true;\n    document.body.removeEventListener('click', _blurHandler, useCapture);\n\n    _trv.getScrollCanvasElementFromTable().removeEventListener('scroll', _blurHandler, useCapture);\n\n    _trv.getPinCanvasElementFromTable().removeEventListener('scroll', _blurHandler, useCapture);\n  };\n\n  const removeEscapeAndEnterHandlers = function (cell) {\n    document.body.removeEventListener('keydown', _escapeKeyHandler, true);\n    cell.removeEventListener('keydown', _enterKeyHandler, true);\n    _escapeKeyHandler = null;\n    _enterKeyHandler = null;\n  };\n\n  const setBlurHandler = function (blurHandler) {\n    _blurHandler = blurHandler;\n  };\n\n  const removeEditStatus = function (cellElem, cellElemProperty, vmo, skipCellCreation) {\n    const cellTopElem = cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];\n\n    if (cellTopElem && (cellTopElem.classList.contains(Const.CLASS_AW_EDITABLE_CELL) || cellTopElem.classList.contains(Const.CLASS_CELL_CHANGED)) || cellElem.propIsEditableCache) {\n      if (!cellElemProperty.isArray && !cellElem.isSelected) {\n        _fillDown.disableFillDown(cellElem);\n      }\n\n      if (!skipCellCreation) {\n        cellElem.removeChild(cellTopElem);\n        reverseEditCell(cellElem, vmo, cellElem.columnDef, cellElemProperty);\n      }\n\n      cellElem.children[0].classList.remove(Const.CLASS_AW_EDITABLE_CELL);\n      removeFocusEvents(cellElem);\n    }\n\n    toggleLinkStyle(cellElem, true);\n  };\n\n  self.updateEditStatusForCell = function (cellElem) {\n    var cellElemProperty = cellElem.prop;\n    let vmo = util.getViewModelObjectByCellElement(cellElem);\n    vmo = getVmoById(vmo.alternateID || vmo.uid); // get latest vmo from collection rather than cached\n\n    var vmoProp = vmo && vmo.props && vmo.props[cellElem.propName];\n\n    if (cellElem.propName && cellElemProperty && cellElem.columnDef.isTreeNavigation !== true) {\n      // LCS-142669 - read modifiable besides of isEditable\n      if ((cellElemProperty.isEditable || vmoProp && vmoProp.isEditable) && cellElem.columnDef.modifiable !== false && util.isBulkEditing(tableElem)) {\n        addEditStatus(cellElem, cellElemProperty, vmo);\n      } else if (cellElem.isSelected && cellElem.propIsEditableCache && cellElemProperty.isPropInEdit) {\n        addEditStatus(cellElem, cellElemProperty, vmo);\n      } else {\n        removeEditStatus(cellElem, cellElemProperty, vmo);\n\n        if (util.isBulkEditing(tableElem)) {\n          cellElem.setAttribute(ariaReadOnly, 'true');\n        } else if (cellElem.hasAttribute(ariaReadOnly) && cellElem.propIsEditableCache !== false) {\n          cellElem.removeAttribute(ariaReadOnly);\n        }\n      }\n    } else if (util.isBulkEditing(tableElem)) {\n      cellElem.setAttribute(ariaReadOnly, 'true');\n    } else if (cellElem.hasAttribute(ariaReadOnly) && cellElem.propIsEditableCache !== false) {\n      cellElem.removeAttribute(ariaReadOnly);\n    }\n  };\n  /**\n   * Subscribe to lovValueChangedEvent. Update dependent cells\n   */\n\n\n  const subscribeToLovValueChangedEvent = function (cell, vmo, prop) {\n    return eventBus.subscribe(prop.propertyName + '.lovValueChanged', function () {\n      // Update dependent LOVS only\n      if (!prop.lovApi || !prop.lovApi.behaviorData || prop.lovApi.behaviorData.style !== 'Interdependent') {\n        return;\n      }\n\n      prop.lovApi.behaviorData.dependendProps.forEach(function (propertyName) {\n        // Only update cells for other props\n        if (prop.propertyName !== propertyName) {\n          var row = cell.parentElement; // Find the cell\n\n          _.forEach(row.children, function (cellElem) {\n            if (cellElem.propName === propertyName) {\n              // Update cell content\n              var oldCellTop = cellElem.children[0];\n              var newCellTop = Cell.createElement(cellElem.columnDef, row.vmo, tableElem, row);\n\n              if (_tableInstance.dynamicRowHeightStatus === true) {\n                Cell.addDynamicCellHeight(vmo, newCellTop);\n              }\n\n              newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);\n              cellElem.replaceChild(newCellTop, oldCellTop);\n              cellElem.isDependantEdit = true;\n\n              if (!util.isBulkEditing(tableElem) && util.isAutoSaveEnabled(tableElem)) {\n                self.removeAllCellSelection();\n                self.editCell(cellElem, vmo);\n              }\n\n              return false;\n            }\n\n            return true;\n          });\n        }\n      });\n    });\n  };\n  /**\n   * Cancels edits if isDirty() comes back false\n   */\n\n\n  const cancelEditsIfNotDirty = function () {\n    const context = getEditContext(_tableInstance);\n    let editHandler = null;\n    let isDirtyPromise;\n\n    if (context) {\n      editHandler = editHandlerSvc.getEditHandler(context);\n      isDirtyPromise = editHandler.isDirty();\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      isDirtyPromise = _tableInstance.dataProvider.isDirty();\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      isDirtyPromise = _tableInstance.declViewModel.isDirty();\n    }\n\n    if (isDirtyPromise) {\n      isDirtyPromise.then(function (isDirty) {\n        // If the handler is not dirty cancel edits to get out of edit mode.\n        if (!isDirty) {\n          if (editHandler) {\n            editHandler.cancelEdits();\n          } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n            const dataCtxNode = {\n              data: _tableInstance.declViewModel,\n              ctx: appCtxService.ctx\n            };\n\n            _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n          } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n            _tableInstance.declViewModel.cancelEdits();\n          }\n        }\n      });\n    }\n  };\n  /**\n   * Handles cell editing functionality for the blur event\n   * @param {Event} event - the blur event\n   * @param {DOMElement} cell - The cell element\n   * @param {ViewModelProperty} prop - The property\n   * @param {ViewModelObject} vmo - The view model object\n   */\n\n\n  const handleCellEditBlur = function (event, cell, prop, vmo) {\n    // Autosave the cell on blur when in autosave mode\n    if (!util.isBulkEditing(tableElem) && util.isAutoSaveEnabled(tableElem) && event && !_fillDownSaveInprogress) {\n      // Stop the event bubbling so save can finish first, we will resend the click when save is finished\n      event.stopPropagation();\n      event.preventDefault();\n\n      _fillDown.disableFillDown(cell); // get target vmo/prop if clicking on table so we can resend click to it after\n\n\n      const tableCell = util.closestElement(event.target, '.ui-grid-cell');\n      let vmo;\n      let propName;\n\n      if (tableCell) {\n        propName = tableCell.propName;\n        vmo = util.getViewModelObjectByCellElement(tableCell);\n      }\n\n      _saveEditPromise = self.saveEdit([cell]).then(() => {\n        _saveEditPromise = null;\n\n        if (!tableCell) {\n          let clickElement = event.target; // Elements like svg don't have a click function, so bubble up till we have a clickable element.\n\n          while (!clickElement.click) {\n            clickElement = clickElement.parentElement;\n          }\n\n          clickElement.click();\n        } else {\n          // reselect table cell\n          let uid = vmo && vmo.alternateID || vmo.uid;\n          let cellToSelect = util.getCellElementsByPropertyAndUid(tableElem, propName, uid)[0];\n          cellToSelect && cellToSelect.click && cellToSelect.click();\n        }\n      });\n    } else if (!util.isBulkEditing(tableElem) && !util.isAutoSaveEnabled(tableElem)) {\n      cancelEditsIfNotDirty();\n      removeEditStatus(cell, prop, vmo, true);\n    }\n  };\n  /**\n   * Returns the focusable cell info if it is focusable\n   *\n   * @param {Object} column - the column\n   * @param {ViewModelObject} vmo - the vmo\n   *\n   * @return {Object} the focusable cell's info\n   */\n\n\n  const getFocusableCellInfo = function (column, vmo) {\n    if (column.modifiable !== false && !column.isTreeNavigation) {\n      const propName = column.propertyName || column.field;\n      const prop = vmo.props[propName];\n\n      if (prop && prop.isEditable) {\n        return {\n          vmo: vmo,\n          column: column\n        };\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Returns the info of the next focusable cell\n   *\n   * @param {ViewModelObject} currentVMO - the current vmo\n   * @param {Object} currentColumn - the current column\n   * @param {boolean} reverseDirection - true if going in the reverse direction\n   *\n   * @return {Object} the next focusable cell's info\n   */\n\n\n  const getNextFocusableCellInfo = (currentVMO, currentColumn, reverseDirection) => {\n    let columns = _tableInstance.dataProvider.cols.filter(function (col) {\n      return !col.hiddenFlag;\n    });\n\n    const currentIdx = columns.indexOf(currentColumn); // Reverse the columns order if we are going in reverse\n\n    if (reverseDirection) {\n      columns = columns.slice().reverse();\n    }\n\n    for (let i = currentIdx + 1; i < columns.length; i++) {\n      const col = columns[i];\n      const focusableCellInfo = getFocusableCellInfo(col, currentVMO);\n\n      if (focusableCellInfo) {\n        return focusableCellInfo;\n      }\n    } // If no cell was found, check next vmo until found  -- Limit - Until end of data, will not page while looking\n\n\n    const loadedVMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n\n    const currentVMOIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(currentVMO.uid);\n\n    for (let i = currentVMOIndex + 1; i < loadedVMOs.length; i++) {\n      const nextVMO = loadedVMOs[i];\n\n      for (let y = 0; y < columns.length; y++) {\n        const col = columns[y];\n        const focusableCellInfo = getFocusableCellInfo(col, nextVMO);\n\n        if (focusableCellInfo) {\n          return focusableCellInfo;\n        }\n      }\n    } // If we still haven't found anything, then there are no more editable cells available, return null\n\n\n    return null;\n  };\n  /**\n   * Attaches the keydown handler to a cell\n   * @param {DOMElement} cellElem The cell element\n   */\n\n\n  const attachKeydownHandler = cellElem => {\n    cellElem.onkeydown = event => {\n      if (event.code !== 'Tab') {\n        return;\n      }\n\n      let reverseTab = false;\n\n      if (event.shiftKey) {\n        reverseTab = true;\n      } // Now check vmo for next editable column.\n\n\n      const closestVMO = event.target.closest('.ui-grid-row').vmo;\n      const column = event.target.closest('.ui-grid-cell').columnDef;\n      const nextEditableInfo = getNextFocusableCellInfo(closestVMO, column, reverseTab); // Scroll to that cell if exists\n\n      if (nextEditableInfo) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        const vmoIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(nextEditableInfo.vmo.uid);\n\n        triggerBlurHandler();\n\n        _tableInstance.renderer.scrollToRowIndex([vmoIndex]);\n\n        if (!nextEditableInfo.column.pinnedLeft) {\n          _tableInstance.renderer.scrollToColumn(nextEditableInfo.column);\n        }\n\n        setTimeout(() => {\n          // Get the cell and focus it after it is scrolled into view\n          const firstRowOnDom = tableElem.getElementsByClassName('ui-grid-row')[0];\n\n          if (firstRowOnDom) {\n            const editableRowRelativeIdx = vmoIndex - firstRowOnDom.getAttribute('data-indexNumber');\n            let rowElem;\n\n            if (nextEditableInfo.column.pinnedLeft) {\n              rowElem = _trv.getPinContentRowElementFromTable(editableRowRelativeIdx);\n            } else {\n              rowElem = _trv.getScrollContentRowElementFromTable(editableRowRelativeIdx);\n            }\n\n            const cellElems = rowElem && rowElem.getElementsByClassName('ui-grid-cell') || [];\n\n            const foundCell = _.filter(cellElems, {\n              columnDef: nextEditableInfo.column\n            })[0];\n\n            if (foundCell) {\n              self.editCell(foundCell, nextEditableInfo.vmo);\n            }\n          }\n        }, 200);\n      }\n    };\n  };\n\n  const attachEscapeKeyHandler = (cell, prop, vmo, column) => {\n    // Set listener for Escape key and reverse edit cell\n    _escapeKeyHandler = event => {\n      if (event.key !== 'Escape') {\n        return;\n      }\n\n      const currentCell = util.closestElement(event.target, '.' + Const.CLASS_CELL);\n\n      if (currentCell === cell && cell.isElementInEdit) {\n        event.stopPropagation();\n        uwPropertyService.resetUpdates(prop);\n        reverseEditCell(cell, vmo, column, prop);\n\n        if (!util.isBulkEditing(tableElem)) {\n          prop.isPropInEdit = false;\n          removeEditStatus(cell, prop, vmo, true); // Check if isDirty still, is so, do nothing, else cancel edits\n\n          cancelEditsIfNotDirty();\n          removeEscapeAndEnterHandlers(cell);\n          cell.focus();\n        } else {\n          // Readd click handler to allow cell to go back into edit\n          addFocusEvent(cell, vmo);\n        }\n      } else {\n        const context = getEditContext(_tableInstance);\n        let editHandler = editHandlerSvc.getEditHandler(context);\n\n        if (editHandler) {\n          editHandler.cancelEdits();\n        } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n          const dataCtxNode = {\n            data: _tableInstance.declViewModel,\n            ctx: appCtxService.ctx\n          };\n\n          _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n        } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n          _tableInstance.declViewModel.cancelEdits();\n        }\n      }\n    };\n\n    document.body.addEventListener('keydown', _escapeKeyHandler, true);\n  };\n\n  const attachEnterKeyHandler = (cell, blurHandler) => {\n    const hasPopupExpanded = element => {\n      const popupVisible = element.getElementsByClassName('aw-jswidgets-popUpVisible');\n      const expanded = element.getElementsByClassName('aw-jswidgets-expanded');\n      return popupVisible.length + expanded.length > 0;\n    };\n\n    _enterKeyHandler = event => {\n      if (event.key === 'Enter' && !event.altKey && !util.isBulkEditing(tableElem)) {\n        const currentCell = util.closestElement(event.target, '.' + Const.CLASS_CELL); // Special handling for array properties\n\n        const isArrayProperty = currentCell.prop && currentCell.prop.isArray;\n\n        if (isArrayProperty) {\n          if (event.target.value === '') {\n            event.stopPropagation();\n            blurHandler(event);\n\n            if (!util.isBulkEditing(tableElem)) {\n              currentCell.focus();\n            }\n          }\n        } else {\n          // If there isn't a popup in the children, then call blurhandler\n          if (currentCell && !hasPopupExpanded(currentCell)) {\n            event.stopPropagation();\n            blurHandler(event);\n\n            if (_saveEditPromise) {\n              _saveEditPromise.then(function () {\n                currentCell.focus();\n              });\n            } else {\n              currentCell.focus();\n            }\n          }\n        }\n      }\n    };\n\n    cell.addEventListener('keydown', _enterKeyHandler, true);\n  };\n  /**\n   * Publishes teh cell start edit event\n   * @param {DOMElement} cell The cell element\n   * @param {Object} vmo the view model object\n   */\n\n\n  const publishCellStartEditEvent = function (cell, vmo) {\n    const eventData = {\n      columnInfo: cell.columnDef,\n      gridId: tableElem.id,\n      vmo: vmo\n    };\n    eventBus.publish(tableElem.id + '.cellStartEdit', eventData);\n  };\n\n  const getVmoById = function (vmoId) {\n    let idx = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(vmoId);\n\n    return _tableInstance.dataProvider.viewModelCollection.loadedVMObjects[idx];\n  };\n  /**\n   * Unsubscribes from the hold lov value change event and subscribes to a new one\n   * @param {DOMElement} cell the cell element\n   * @param {Object} vmo the view model object\n   * @param {Object} prop The property\n   */\n\n\n  const handleLovValueChangedEvent = function (cell, vmo, prop) {\n    const lovValueChangedEventSub = subscribeToLovValueChangedEvent(cell, vmo, prop);\n    let oldLovSubscr = _lovValueChangedEventSubs[prop.parentUid + prop.propertyName];\n\n    if (oldLovSubscr) {\n      eventBus.unsubscribe(oldLovSubscr);\n      delete _lovValueChangedEventSubs[prop.parentUid + prop.propertyName];\n    }\n\n    _lovValueChangedEventSubs[prop.parentUid + prop.propertyName] = lovValueChangedEventSub;\n  };\n\n  const isUserInteractingWithDropDown = (prop, event) => {\n    if (prop.hasLov && event) {\n      const listBoxDrop = document.querySelector('.sw-lov-contentContainer');\n\n      if (listBoxDrop && listBoxDrop.contains(event.target)) {\n        return true;\n      }\n    } else if (prop.type && event && (prop.type === 'DATE' || prop.type === 'DATEARRAY')) {\n      const datePicker = document.querySelector('.flatpickr-calendar.open');\n\n      if (datePicker && datePicker.contains(event.target)) {\n        return true;\n      }\n\n      const dateTimeDrop = document.querySelector('.sw-popup-contentContainer .aw-base-scrollPanel');\n\n      if (dateTimeDrop && dateTimeDrop.contains(event.target)) {\n        return true;\n      }\n    } else if (prop.type && event && prop.type === 'STRING' && prop.isRichText) {\n      const ckEditor = document.getElementsByClassName('ck-body-wrapper')[0];\n\n      if (ckEditor && ckEditor.contains(event.target)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Creates the edit cell and attaches it to the DOM\n   * @param {Object} vmo - the view model object\n   * @param {AwColumnDef} column The column definition\n   * @param {DOMElement} cell The cell element\n   */\n\n\n  const createAndAttachEditCell = function (vmo, column, cell) {\n    // for array fields, application should use popup to display it,\n    // or you will face cut off issues: LCS-161794\n    const prop = vmo.props[cell.propName];\n    prop.autofocus = true;\n    let editNonArrayClass = prop.isArray ? Const.CLASS_TABLE_EDIT_CELL_ARRAY : Const.CLASS_TABLE_EDIT_CELL_NON_ARRAY;\n    let editCellElem = util.createElement('div', 'aw-splm-tableEditCellTop', editNonArrayClass);\n    let editContainer = util.createElement('div', 'aw-jswidgets-tableEditContainer', 'aw-jswidgets-cellTop');\n    /* revisitme Brad\n     * Revisit/revise for support of column def providing rendering hint\n     * column.renderingHint\n     */\n\n    let propertyValElem = includeComponent('SplmTableCellEditor', {\n      vmo,\n      name: prop.propertyName\n    });\n    renderComponent( /*#__PURE__*/_jsxDEV(AppCtxComponent, {\n      children: propertyValElem\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 718,\n      columnNumber: 26\n    }, this), editContainer);\n    editCellElem.appendChild(editContainer);\n    attachKeydownHandler(editCellElem);\n    Cell.updateCellChangedClass(prop, editCellElem.getElementsByClassName(Const.CLASS_AW_JS_CELL_TOP)[0]);\n\n    if (prop.isArray && _tableInstance.gridOptions.popupContext && _tableInstance.gridOptions.popupContext.editArrayPopup) {\n      const cellBoundingArea = cell.getBoundingClientRect();\n      const popupOptions = {\n        whenParentScrolls: 'follow',\n        innerClassName: Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY,\n        autoFocus: false,\n        parent: cell,\n        reference: cell,\n        overlapOnReference: true,\n        containerWidth: cellBoundingArea.width,\n        width: cellBoundingArea.width,\n        forceCloseOthers: false\n      };\n      const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n\n      if (editArrayPopup) {\n        editArrayPopup.hide().then(() => {\n          editArrayPopup.show(popupOptions).then(popupRef => {\n            self.popupRef = popupRef;\n          });\n        });\n      }\n    } else {\n      cell.insertBefore(editCellElem, cell.childNodes[0]);\n    }\n  };\n  /**\n   * Starts the edit of the cell\n   * @param {DOMElement} cell The cell element\n   * @param {Object} vmo the view model object\n   */\n\n\n  self.editCell = function (cell, vmo) {\n    const column = cell.columnDef;\n    const prop = cell.prop;\n\n    if (!cell.isDependantEdit && (!cell.isSelected && !util.isBulkEditing(tableElem) || cell.isElementInEdit === true)) {\n      return;\n    }\n\n    gridContextDispatcher({\n      type: 'UPDATE_VALUES',\n      editVmo: vmo,\n      editPropertyName: cell.propName\n    });\n    publishCellStartEditEvent(cell, vmo); // Trigger blur handler\n\n    triggerBlurHandler();\n    cell.isElementInEdit = true;\n    prop.isPropInEdit = true;\n    cell.classList.add(Const.CLASS_AW_IS_EDITING); // Handle possible lov value changes\n\n    handleLovValueChangedEvent(cell, vmo, prop); // Remove cell top\n\n    let editableGridCell = cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];\n\n    if (editableGridCell) {\n      cell.removeChild(editableGridCell);\n    }\n\n    let originAutoFocus = prop.autofocus;\n    createAndAttachEditCell(vmo, column, cell);\n    removeFocusEvents(cell);\n\n    const blurHandler = function (event) {\n      // Only revert edit status if scrolling with array (popup)\n      if (event && event.type === 'scroll' && cell.prop && !cell.prop.isArray) {\n        return;\n      }\n\n      let selectedCell = null;\n\n      if (event && event.type !== 'keydown') {\n        _focusProp = null;\n        selectedCell = util.closestElement(event.target, `.${Const.CLASS_CELL}`);\n      }\n\n      if (!cell.isElementInEdit) {\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers(cell);\n      } else if (selectedCell !== cell && cell.isElementInEdit) {\n        // Close panels\n        let panelContext = appCtxService.getCtx('panelContext');\n\n        if (panelContext && panelContext.addTypeRef === true) {\n          // If clicking on different cell close the panel else leave it open\n          if (cell.propName !== prop.propertyName || cell.parentElement.vmo.uid !== prop.parentUid) {\n            eventBus.publish('completed', {\n              source: 'toolAndInfoPanel'\n            });\n          } else {\n            return;\n          }\n        }\n\n        if (isUserInteractingWithDropDown(prop, event)) {\n          return true;\n        } // Remove the blur handler since cell is going out of edit\n\n\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers(cell); // Reverse the cell edit\n\n        reverseEditCell(cell, vmo, column, prop);\n        prop.autofocus = originAutoFocus;\n        prop.isPropInEdit = false;\n        cell.isSelected = false;\n        delete cell.isDependantEdit; // Handle cell editing functionality on blur\n\n        handleCellEditBlur(event, cell, prop, vmo); // Readd click handler to allow cell to go back into edit\n\n        addFocusEvent(cell, vmo);\n      }\n    }; // Add blur handler to take cell out of edit on click away\n\n\n    removeBlurHandler();\n    removeEscapeAndEnterHandlers(cell); // Setting useCapture to true is needed for autosave since it allows us to detect the click before the target\n    // element does.\n\n    const useCapture = true;\n    document.body.addEventListener('click', blurHandler, useCapture);\n\n    const scrollViewportElem = _trv.getScrollCanvasElementFromTable();\n\n    const pinViewportElem = _trv.getPinCanvasElementFromTable();\n\n    scrollViewportElem.removeEventListener('scroll', blurHandler, useCapture);\n    pinViewportElem.removeEventListener('scroll', blurHandler, useCapture);\n    scrollViewportElem.addEventListener('scroll', blurHandler, useCapture);\n    pinViewportElem.addEventListener('scroll', blurHandler, useCapture);\n    attachEscapeKeyHandler(cell, prop, vmo, column);\n    attachEnterKeyHandler(cell, blurHandler);\n    setBlurHandler(blurHandler);\n  };\n\n  self.isPropertiesEditablePromise = function (editOptions) {\n    let editPromise;\n    const editContext = getEditContext(_tableInstance);\n\n    if (editContext) {\n      // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n      // can be editing at any given time.\n      const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n\n      if (previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler(editContext) && previousActiveHandler.editInProgress()) {\n        editPromise = new Promise(resolve => {\n          previousActiveHandler.leaveConfirmation(() => {\n            editHandlerSvc.setActiveEditHandlerContext(editContext);\n            editHandlerSvc.startEdit(editOptions).then(() => {\n              resolve();\n            });\n          });\n        });\n      } else {\n        editHandlerSvc.setActiveEditHandlerContext(editContext);\n        editPromise = editHandlerSvc.startEdit(editOptions);\n      }\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      const dataCtxNode = {\n        data: _tableInstance.declViewModel,\n        ctx: appCtxService.ctx\n      };\n      editPromise = _tableInstance.dataProvider.startEdit(dataCtxNode, _tableInstance.declViewModel, editOptions);\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      editPromise = _tableInstance.declViewModel.startEdit(editOptions);\n    }\n\n    return editPromise ? editPromise : Promise.resolve(false);\n  };\n  /**\n   * Checks if the provided cell/property is editable by calling startEdit on the editHandler or editConfig\n   * @param {Object} vmo The view model object\n   * @param {DOMElement} cellElem The cell element\n   *\n   * @returns {Promise<Boolean>} Promise that will resolve to the editability of the property\n   */\n\n\n  const isCellEditable = async function (vmo, cellElem) {\n    // Allow save to finish before checking start edit\n    if (_saveEditPromise) {\n      await _saveEditPromise;\n    }\n\n    let prop = vmo.props[cellElem.propName];\n    let propertyNames = [prop.propertyName]; // Need to pass all dependent props to ensure we have latest lsd\n\n    if (prop.lovApi && prop.lovApi.behaviorData && prop.lovApi.behaviorData.style === 'Interdependent') {\n      propertyNames = prop.lovApi.behaviorData.dependendProps;\n    }\n\n    let editOpts = {\n      vmos: [vmo],\n      propertyNames: propertyNames,\n      autoSave: util.isAutoSaveEnabled(tableElem)\n    };\n    const result = await self.isPropertiesEditablePromise(editOpts);\n\n    if (result === false) {\n      return false;\n    } // update prop to latest\n\n\n    prop = vmo.props[cellElem.propName];\n    return prop && prop.isEditable && prop.isEnabled !== false;\n  };\n  /**\n   * Saved the provided cell/property that was edited\n   * @param {DOMElement[]} cells the cells to save\n   * @returns {Promise<Boolean>} Promise that will resolve when save is complete\n   */\n\n\n  self.saveEdit = function (cells) {\n    let isPartialSaveDisabled = true;\n    let editPromise = null;\n    const editContext = getEditContext(_tableInstance);\n\n    if (editContext) {\n      editPromise = editHandlerSvc.saveEdits(editContext, isPartialSaveDisabled, util.isAutoSaveEnabled(tableElem));\n    } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n      const dataCtxNode = {\n        data: _tableInstance.declViewModel,\n        ctx: appCtxService.ctx\n      };\n      editPromise = _tableInstance.dataProvider.saveEdits(dataCtxNode, _tableInstance.declViewModel);\n    } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n      editPromise = _tableInstance.declViewModel.saveEdits();\n    }\n\n    if (editPromise) {\n      return editPromise.finally(function () {\n        self.setCellEditingContext(false);\n\n        for (let i = 0; i < cells.length; i++) {\n          if (document.body.contains(cells[i])) {\n            self.updateEditStatusForCell(cells[i]);\n          }\n        } // Clear prop is editable cache to ensure newly selected cell makes a startEdit call, since\n        // our save call will likely invalidate the editable cache. This is also ensuring that double click on\n        // another cell takes that cell into edit instead of selected state.\n\n\n        self.clearPropIsEditableCache();\n      });\n    }\n\n    return Promise.resolve(false);\n  };\n  /**\n   * Removes the selected and selectedEditable css classes from any elements that have them\n   */\n\n\n  const removeCellSelection = function () {\n    // Remove all other \"selected\" classes from cells\n    let selected1 = Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE));\n    let selected2 = Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED));\n    let elems = selected1.concat(selected2);\n\n    for (let i = 0; i < elems.length; i++) {\n      elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n      elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED);\n      let containerElement = null; // The below method can result in undefined value.\n\n      containerElement = _trv.getTableContainerElementFromTable();\n\n      if (containerElement && containerElement.hasAttribute(ariaActiveDescendant)) {\n        containerElement.removeAttribute(ariaActiveDescendant);\n      }\n    }\n  };\n  /**\n   * Updates the cell to be selected and sets selection/edit info to false on old selected cell\n   * @param {DOMElement} cell The new selected cell\n   * @param {Boolean} persistEditableFlag flag to denote if isEditable should be persisted\n   */\n\n\n  const updateSelectedCell = function (cell, persistEditableFlag) {\n    if (_selectedCellInfo && _selectedCellInfo.cell) {\n      let _cell = _selectedCellInfo.cell;\n      _cell.isSelected = false;\n      const vmo = getVmoById(_selectedCellInfo.vmoId); // If prop edit is not enabled we should not touch the prop.isEditable flag\n\n      if (!persistEditableFlag && vmo && _cell.prop && util.isPropEditEnabled(tableElem) && !util.isBulkEditing(tableElem)) {\n        _cell.prop.isEditable = false;\n\n        if (vmo.props && vmo.props[_cell.propName]) {\n          vmo.props[_cell.propName].isEditable = false;\n        }\n      }\n    }\n\n    if (cell) {\n      cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED);\n      cell.isSelected = true;\n      let refVmo = util.getViewModelObjectByCellElement(cell);\n      let vmoId = refVmo.alternateID || refVmo.uid;\n      _selectedCellInfo = {\n        cell: cell,\n        vmoId: vmoId\n      };\n      let containerElement = null; // The below method can result in undefined value.\n\n      containerElement = _trv.getTableContainerElementFromTable();\n\n      if (containerElement) {\n        containerElement.setAttribute(ariaActiveDescendant, cell.getAttribute('id'));\n      }\n    } else {\n      _selectedCellInfo = null;\n    }\n  };\n\n  self.clearPropIsEditableCache = function (persistEditableFlag) {\n    const cellElems = _trv.getContentCellElementsFromTable();\n\n    _.forEach(cellElems, function (elem) {\n      delete elem.propIsEditableCache;\n\n      if (elem.hasAttribute(ariaReadOnly)) {\n        elem.removeAttribute(ariaReadOnly);\n      }\n    }); // Reset cell selection since we are clearing editibility cache\n    // making the editability selection classes no longer valid\n\n\n    removeCellSelection();\n    const currentSelectedCell = _selectedCellInfo ? _selectedCellInfo.cell : null;\n    updateSelectedCell(null, persistEditableFlag);\n\n    if (currentSelectedCell && currentSelectedCell.parentElement) {\n      const eventObject = {\n        ctrlKey: false,\n        shiftKey: false,\n        type: 'click'\n      };\n      self.onClickHandler(eventObject, currentSelectedCell, util.getViewModelObjectByCellElement(currentSelectedCell));\n    }\n  };\n  /**\n   * Update the cell editability by using the cached editability or loading the editability if it is not cached\n   * @param {DOMElement} cell - The cell element to get editability for\n   * @param {Object} vmo - the row's view model object\n   */\n\n\n  const updateCellEditability = function (cell, vmo) {\n    // Make some SOA call here for getting the editability\n    removeCellSelection();\n    updateSelectedCell(cell); // Check if cellEdit is enabled and if this cell/prop type supports edit\n\n    const isCellEditSupported = util.isPropEditEnabled(tableElem) && cell.propName && cell.prop && cell.columnDef.isTreeNavigation !== true;\n\n    if (!isCellEditSupported) {\n      cell.setAttribute(ariaReadOnly, 'true');\n      return;\n    } // If prop is modified we can restore editability cache since we know it has not been saved\n    // and was previously editable\n\n\n    if (uwPropertyService.isModified(cell.prop) && cell.propIsEditableCache === undefined && !util.isAutoSaveEnabled(tableElem)) {\n      cell.propIsEditableCache = true;\n    } // Check if editability info exists, if not\n    // Check columnDef if editable, if not add readonly class\n    // If editable, make startEdit call to get editability for cell\n\n\n    if (cell.columnDef.name !== 'icon' && cell.columnDef.modifiable !== false && cell.propIsEditableCache === undefined) {\n      // only allow one check at a time.\n      const cellEditablePromise = function () {\n        return isCellEditable(vmo, cell).then(function (isEditable) {\n          cell.propIsEditableCache = isEditable;\n\n          if (cell.propIsEditableCache === false) {\n            cell.setAttribute(ariaReadOnly, 'true');\n          } else if (cell.hasAttribute(ariaReadOnly)) {\n            cell.removeAttribute(ariaReadOnly);\n          }\n\n          if (cell.isSelected) {\n            if (isEditable) {\n              cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n            }\n\n            _fillDown.enableFillDown(cell);\n          }\n        }).then(function () {\n          delete cell.isCellEditablePromise;\n          _isEditablePromise = null;\n        });\n      };\n\n      if (_isEditablePromise) {\n        _isEditablePromise.then(function () {\n          removeCellSelection();\n          updateSelectedCell(cell);\n          _isEditablePromise = cellEditablePromise();\n          cell.isCellEditablePromise = _isEditablePromise;\n        });\n      } else {\n        _isEditablePromise = cellEditablePromise();\n        cell.isCellEditablePromise = _isEditablePromise;\n      }\n\n      return;\n    }\n\n    if (cell.propIsEditableCache) {\n      // Mark the prop as editable since the cache tells us it is editable\n      cell.prop.isEditable = true;\n      vmo.props[cell.propName].isEditable = true;\n      cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);\n\n      if (cell.hasAttribute(ariaReadOnly)) {\n        cell.removeAttribute(ariaReadOnly);\n      }\n    } else if (cell.propIsEditableCache === false) {\n      cell.setAttribute(ariaReadOnly, 'true');\n    }\n  };\n\n  let _guidanceMessageInitialized = false;\n\n  const publishCellNotEditable = function (vmo, prop) {\n    eventBus.publish(_tableInstance.gridId + '.plTable.cellNotEditable', {\n      vmo: vmo,\n      prop: prop\n    });\n  };\n  /**\n   * Updates ctx and the editHandler/editConfig to be in editing mode when autosave is off.\n   * Doing this ensures the edit command will get toggled when editing in autosave off mode.\n   * @param {Boolean} isEditing - If in edit\n   */\n\n\n  self.setCellEditingContext = function (isEditing) {\n    // Enable/disable caching\n    if (isEditing) {\n      _tableInstance.dataProvider.cacheCollapse = isEditing;\n    } else {\n      _tableInstance.dataProvider.restoreInitialCacheCollapseState();\n    }\n\n    _tableInstance.controller.setDraggable(!isEditing); // For autosave off we need to see _editing flag and update ctx to get commands to switch over\n\n\n    if (!util.isAutoSaveEnabled(tableElem)) {\n      const editContext = getEditContext(_tableInstance);\n\n      if (editContext) {\n        const editHandler = editHandlerSvc.getEditHandler(editContext);\n        editHandler._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx('editInProgress', editHandler._editing); // Need to ensure this handler is active so that save command will call this handler\n\n        editHandlerSvc.setActiveEditHandlerContext(editContext); // We need to ensure edit handler and edithandlerState to be in sync.\n\n        if (editHandler.editStateChangeDispatcher) {\n          editHandler.editStateChangeDispatcher({\n            type: 'SET_EDIT_STATE_CHANGED',\n            value: editHandler._editing\n          });\n        }\n      } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n        _tableInstance.dataProvider._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx(_tableInstance.dataProvider._appCtxEditInProgress, _tableInstance.dataProvider._editing);\n      } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n        _tableInstance.declViewModel._editing = isEditing; // Add to the appCtx about the editing state\n\n        appCtxService.updateCtx(_tableInstance.declViewModel._internal.eventTopicEditInProgress, _tableInstance.declViewModel._editing);\n      }\n    } // Display guidance message when auto save is off for auto save only table\n\n\n    const isAutoSaveContextTrue = appCtxService.getCtx('autoSave') && appCtxService.getCtx('autoSave.dbValue');\n\n    if (!isAutoSaveContextTrue && tableElem._tableInstance.gridOptions.forceAutoSave && isEditing && !util.isCellEditing(tableElem) && !_guidanceMessageInitialized) {\n      _guidanceMessageInitialized = true;\n      displayAutoSaveOnGuidanceMessage(tableElem);\n    }\n\n    util.setIsCellEditing(tableElem, isEditing);\n  };\n\n  let _cellEditDisabledMessageInitialized = null;\n\n  const isCellSelectedNotEditable = function (cell) {\n    return cell && cell.isSelected && cell.prop && cell.prop.isEditable === false;\n  };\n  /**\n   * Handles the direct edit handling for cell selection\n   * @param {HTMLElement} cell The cell\n   * @param {Object} vmo the view model object\n   */\n\n\n  const handleDirectEdit = function (cell, vmo) {\n    // Start edit\n    removeCellSelection(); // Check if prop isEditable needs to be reset since cache says it is true\n\n    if (!cell.prop.isEditable) {\n      cell.prop.isEditable = true;\n\n      if (vmo.props && vmo.props[cell.propName]) {\n        vmo.props[cell.propName].isEditable = true;\n      }\n    } // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n    // can be editing at any given time.\n\n\n    const editContext = getEditContext(_tableInstance);\n    const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n\n    if (editContext && previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler(editContext) && previousActiveHandler.editInProgress()) {\n      previousActiveHandler.leaveConfirmation(() => {\n        editHandlerSvc.setActiveEditHandlerContext(editContext); // Reregister leaveHandler since we are making the handler active again without calling startEdit\n\n        editHandlerSvc.getEditHandler(editContext).reregisterLeaveHandler();\n        self.editCell(cell, vmo);\n        self.setCellEditingContext(true);\n      });\n    } else {\n      self.editCell(cell, vmo);\n      self.setCellEditingContext(true);\n    }\n  };\n  /**\n   * Handles cell click when pending isEditable Promise\n   * @param {HTMLElement} cell The cell\n   * @param {Object} vmo The view model object\n   */\n\n\n  const handlePendingEditSelection = async function (cell, vmo) {\n    // Prevent multiple calls to resolve editable promise\n    cell.isCellEditablePromiseResolving = true;\n    await cell.isCellEditablePromise;\n    delete cell.isCellEditablePromiseResolving;\n\n    if (cell.isSelected) {\n      if (cell.propIsEditableCache) {\n        _focusProp = cell.prop;\n        removeCellSelection(); // Check if prop isEditable needs to be reset since cache says it is true\n\n        if (!cell.prop.isEditable) {\n          cell.prop.isEditable = true;\n\n          if (vmo.props && vmo.props[cell.propName]) {\n            vmo.props[cell.propName].isEditable = true;\n          }\n        }\n\n        self.editCell(cell, vmo);\n        self.setCellEditingContext(true);\n      } else {\n        publishCellNotEditable(vmo, cell.prop);\n      }\n    }\n  };\n  /**\n   * Click handler for cell/row. Will select the cell and row or start edit as needed\n   *\n   * @param {Event} event the click event\n   * @param {DOMElement} cell the cell in question\n   * @param {ViewModelObject} vmo The vmo for the row\n   */\n\n\n  self.onClickHandler = async (event, cell, vmo) => {\n    if (util.isBulkEditing(tableElem)) {\n      return;\n    }\n\n    if (event.ctrlKey) {\n      triggerBlurHandler();\n      removeCellSelection();\n      updateSelectedCell(null);\n\n      if (util.isCellHeaderSelectionEnabled(tableElem)) {\n        SelectionHelper.setCellHeaderSelection(null, tableElem);\n      }\n\n      return;\n    }\n\n    if (cell.isSelected && cell.propIsEditableCache && !cell.isElementInEdit) {\n      handleDirectEdit(cell, vmo);\n    } else if (cell.isSelected && util.isPropEditEnabled(tableElem) === false && !_cellEditDisabledMessageInitialized) {\n      // Display guidance message when cell editing is disabled\n      _cellEditDisabledMessageInitialized = true;\n      displayCellEditDisabledGuidanceMessage(tableElem);\n    } else if (cell.isSelected && cell.isCellEditablePromise && !cell.isCellEditablePromiseResolving) {\n      handlePendingEditSelection(cell, vmo);\n    } else if (!cell.isSelected && !event.shiftKey) {\n      await updateCellEditability(cell, vmo);\n\n      _fillDown.enableFillDown(cell);\n\n      if (util.isCellHeaderSelectionEnabled(tableElem)) {\n        SelectionHelper.setCellHeaderSelection(cell, tableElem);\n      }\n    } else if (event.shiftKey) {\n      triggerBlurHandler();\n      removeCellSelection();\n      updateSelectedCell(null);\n    } else if (!cell.isCellEditablePromiseResolving && isCellSelectedNotEditable(cell)) {\n      publishCellNotEditable(vmo, cell.prop);\n    }\n  };\n  /**\n   * Adds the onclick event listener for an individual cell and gets its editability\n   * @param {DOMElement} cell - The cell to set the listener for\n   * @param {Object} vmo - The row's VMO\n   */\n\n\n  self.addCellClickListener = function (cell, vmo) {\n    cell.onclick = function (event) {\n      // if command click or url/anchor tag click don't select/handle select\n      if (!event.target.closest('.aw-command, a.aw-splm-tablePropertyValueLinks')) {\n        self.onClickHandler(event, cell, vmo);\n      }\n    };\n\n    cell.oncontextmenu = function (event) {\n      if (!util.isBulkEditing(tableElem) && !cell.isSelected) {\n        updateCellEditability(cell, vmo);\n      }\n    };\n  };\n  /**\n   * Removes the cell selected classes as well as the selected attribute for the cell.\n   */\n\n\n  self.removeAllCellSelection = function () {\n    removeCellSelection();\n    updateSelectedCell();\n  };\n  /**\n   * Checks if the current selected cell is on the newly selected vmo(s), if not remove selection\n   * @param {Object} eventData event data\n   */\n\n\n  const checkCellAndVMOSelection = function (eventData) {\n    let selectedObjects = eventData.selectedObjects;\n\n    if (_selectedCellInfo && _selectedCellInfo.vmoId) {\n      const vmo = getVmoById(_selectedCellInfo.vmoId);\n\n      if (selectedObjects.indexOf(vmo) === -1) {\n        self.removeAllCellSelection();\n      }\n    }\n  };\n\n  const isEligibleForCopyDown = function (columnDef) {\n    if (util.isPropEditEnabled(tableElem) && columnDef.isTreeNavigation !== true && columnDef.name !== 'icon' && columnDef.modifiable !== false) {\n      return true;\n    }\n\n    return false;\n  };\n\n  const copyPropertyToCellContent = function (sourceProperty, vmoUid) {\n    let cellElements = util.getCellElementsByPropertyAndUid(tableElem, sourceProperty.propertyName, vmoUid);\n\n    for (let i = 0; i < cellElements.length; i++) {\n      let cellElem = cellElements[i];\n      let row = cellElem.parentElement;\n      let oldCellTop = cellElem.children[0];\n      let newCellTop = Cell.createElement(cellElem.columnDef, row.vmo, tableElem, row);\n\n      if (util.isBulkEditing(tableElem)) {\n        newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);\n      }\n\n      cellElem.replaceChild(newCellTop, oldCellTop);\n    }\n  };\n\n  const copyFillDownProperty = function (targetProperty, sourceProperty) {\n    targetProperty.uiValue = sourceProperty.uiValue;\n    targetProperty.dbValue = sourceProperty.dbValue;\n    targetProperty.valueUpdated = true;\n    uwPropertyService.updateViewModelProperty(targetProperty);\n  };\n\n  const loadCellEditabilityForTargetCells = function (uid2CellMap, vmos, propertyNames) {\n    let editOpts = {\n      vmos: vmos,\n      propertyNames: propertyNames,\n      autoSave: util.isAutoSaveEnabled(tableElem)\n    };\n    return self.isPropertiesEditablePromise(editOpts).then(function (result) {\n      for (let currentVmo of vmos) {\n        let cell = uid2CellMap[currentVmo.uid];\n\n        if (cell) {\n          cell.propIsEditableCache = result === false ? false : cell.prop && cell.prop.isEditable;\n\n          if (cell.propIsEditableCache === false) {\n            cell.setAttribute(ariaReadOnly, 'true');\n          }\n        }\n      }\n\n      return Promise.resolve(result);\n    });\n  };\n\n  const modifyPropsForCellEdit = function (result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp) {\n    if (result === false) {\n      return;\n    }\n\n    let propsModified = false;\n\n    for (let i = 0; i < vmosToEdit.length; i++) {\n      let currentVMO = vmosToEdit[i];\n      const targetProp = currentVMO.props[eventData.propertyName];\n\n      if (sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable) {\n        propsModified = true;\n        cellsToSave.push(cellMap[currentVMO.uid]); // update the target using the source\n\n        copyFillDownProperty(targetProp, sourceProp);\n        copyPropertyToCellContent(sourceProp, currentVMO.uid);\n      }\n    }\n\n    if (propsModified) {\n      if (util.isAutoSaveEnabled(tableElem)) {\n        self.saveEdit(cellsToSave);\n      } else {\n        self.setCellEditingContext(true);\n      }\n    }\n  };\n\n  const prepareTargetCellPropsInfo = function (vmo, eventData, vmosToEdit, columnDef) {\n    if (isEligibleForCopyDown(columnDef)) {\n      vmosToEdit.push(vmo);\n    }\n  };\n\n  const populateTargetCellPropsLegacyEdit = function (vmo, eventData, sourceProp) {\n    const targetProp = vmo.props[eventData.propertyName];\n\n    if (sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable) {\n      // update the target using the source\n      copyFillDownProperty(targetProp, sourceProp);\n      copyPropertyToCellContent(sourceProp, vmo.uid);\n    }\n  };\n\n  self.fillDownCompleteHandler = eventData => {\n    // get the VMOs from the table\n    let VMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n    let $source = VMOs.filter(function (vmo) {\n      return vmo.uid === eventData.source;\n    });\n    let sourceProp = $source[0] && $source[0].props[eventData.propertyName];\n    let vmosToEdit = [];\n    let cellMap = {};\n    let cellsToSave = []; // Reverse the vmo order if we are going down\n\n    if (eventData.direction !== 'up') {\n      VMOs = VMOs.slice().reverse();\n    } // Attempt to apply the source value to the target properties\n\n\n    let foundLastTarget = false;\n\n    for (let vmo of VMOs) {\n      // Iterate over the vmos until we find the last target prop.\n      if (!foundLastTarget && vmo.uid === eventData.endTarget) {\n        foundLastTarget = true;\n      }\n\n      if (!foundLastTarget) {\n        continue;\n      } // Stop iterating if we reach the source prop\n\n\n      if (vmo.uid === eventData.source) {\n        break;\n      }\n\n      const columnDef = util.getColumnDef(eventData.propertyName, _tableInstance.dataProvider); // Populate target cell props ( bulk edit mode ) or prepare the target prop info ( direct edit )\n\n      if (util.isBulkEditing(tableElem)) {\n        populateTargetCellPropsLegacyEdit(vmo, eventData, sourceProp);\n      } else {\n        const targetCell = util.getCellElementsByPropertyAndUid(tableElem, eventData.propertyName, vmo.uid)[0];\n\n        if (targetCell) {\n          cellMap[vmo.uid] = targetCell;\n        }\n\n        prepareTargetCellPropsInfo(vmo, eventData, vmosToEdit, columnDef);\n      }\n    } // Load editabilty and apply value to editable cells\n\n\n    if (!util.isBulkEditing(tableElem)) {\n      _fillDownSaveInprogress = true;\n      let propertyNames = [eventData.propertyName];\n      loadCellEditabilityForTargetCells(cellMap, vmosToEdit, propertyNames).then(result => {\n        modifyPropsForCellEdit(result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp);\n        _fillDownSaveInprogress = false;\n      });\n    }\n  };\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectNone`, self.removeAllCellSelection));\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectAll`, self.removeAllCellSelection));\n\n  _eventBusSubs.push(eventBus.subscribe(`${_tableInstance.dataProvider.name}.selectionChangeEvent`, checkCellAndVMOSelection));\n};\n\n_c2 = SPLMTableEditor;\n_c = SPLMTableEditor;\nexport default SPLMTableEditor;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableEditor\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableEditor\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableEditor.js"],"names":["SPLMTableEditor","_trv","_fillDown","_lovValueChangedEventSubs","_blurHandler","_focusProp","_tableInstance","util","_selectedCellInfo","_saveEditPromise","_isEditablePromise","_escapeKeyHandler","_enterKeyHandler","_fillDownSaveInprogress","ariaReadOnly","ariaActiveDescendant","_eventBusSubs","self","destroyLovEventListeners","_","eventBus","triggerBlurHandler","cellElems","toggleLinkStyle","linkElements","element","Const","i","linkElem","j","linkElem1","ensureDragHandleLastChild","dragHandleElements","cell","reverseEditCell","editCells","cellElemProperty","isErrorProperty","cellTopElement","Cell","editCell","editArrayPopup","setTimeout","propertyErrorElements","cellTopElements","removeFocusEvents","useCapture","cellElem","_isUserClick","_isCtrlKey","addFocusEvent","onFocusEvent","browserUtils","eventObj","document","ctrlKey","isFocusClickEvent","event","addEditStatus","rowHeight","logger","cellTop","removeBlurHandler","removeEscapeAndEnterHandlers","setBlurHandler","removeEditStatus","cellTopElem","vmo","getVmoById","vmoProp","subscribeToLovValueChangedEvent","prop","row","oldCellTop","newCellTop","cancelEditsIfNotDirty","context","getEditContext","editHandler","editHandlerSvc","isDirtyPromise","dataCtxNode","data","ctx","appCtxService","handleCellEditBlur","tableCell","propName","clickElement","uid","cellToSelect","getFocusableCellInfo","column","getNextFocusableCellInfo","columns","col","currentIdx","focusableCellInfo","loadedVMOs","currentVMOIndex","currentVMO","nextVMO","y","attachKeydownHandler","reverseTab","closestVMO","nextEditableInfo","vmoIndex","firstRowOnDom","tableElem","editableRowRelativeIdx","rowElem","foundCell","columnDef","attachEscapeKeyHandler","currentCell","uwPropertyService","attachEnterKeyHandler","hasPopupExpanded","popupVisible","expanded","isArrayProperty","blurHandler","publishCellStartEditEvent","eventData","columnInfo","gridId","idx","handleLovValueChangedEvent","lovValueChangedEventSub","oldLovSubscr","isUserInteractingWithDropDown","listBoxDrop","datePicker","dateTimeDrop","ckEditor","createAndAttachEditCell","editNonArrayClass","editCellElem","editContainer","propertyValElem","includeComponent","name","propertyName","renderComponent","cellBoundingArea","popupOptions","whenParentScrolls","innerClassName","autoFocus","parent","reference","overlapOnReference","containerWidth","width","forceCloseOthers","popupRef","gridContextDispatcher","type","editVmo","editPropertyName","editableGridCell","originAutoFocus","selectedCell","CLASS_CELL","panelContext","source","scrollViewportElem","pinViewportElem","editContext","previousActiveHandler","editPromise","resolve","Promise","isCellEditable","propertyNames","editOpts","vmos","autoSave","result","isPartialSaveDisabled","cells","removeCellSelection","selected1","Array","selected2","elems","containerElement","updateSelectedCell","_cell","refVmo","vmoId","elem","currentSelectedCell","eventObject","shiftKey","updateCellEditability","isCellEditSupported","cellEditablePromise","_guidanceMessageInitialized","publishCellNotEditable","value","_editing","isAutoSaveContextTrue","displayAutoSaveOnGuidanceMessage","_cellEditDisabledMessageInitialized","isCellSelectedNotEditable","handleDirectEdit","handlePendingEditSelection","SelectionHelper","displayCellEditDisabledGuidanceMessage","checkCellAndVMOSelection","selectedObjects","isEligibleForCopyDown","copyPropertyToCellContent","cellElements","sourceProperty","copyFillDownProperty","targetProperty","loadCellEditabilityForTargetCells","uid2CellMap","currentVmo","modifyPropsForCellEdit","propsModified","vmosToEdit","targetProp","sourceProp","cellsToSave","cellMap","prepareTargetCellPropsInfo","populateTargetCellPropsLegacyEdit","VMOs","$source","foundLastTarget","targetCell"],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the edit function for PL Table.\n *\n * @module js/splmTableEditor\n */\n\nimport SPLMTableFillDown from 'js/splmTableFillDown';\nimport _ from 'lodash';\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport uwPropertyService from 'js/uwPropertyService';\nimport browserUtils from 'js/browserUtils';\nimport { getEditContext, displayAutoSaveOnGuidanceMessage, displayCellEditDisabledGuidanceMessage } from 'js/splmTableDirectEditUtils';\nimport { includeComponent } from 'js/moduleLoader';\nimport { renderComponent } from 'js/declReactUtils';\nimport { AppCtxComponent } from 'js/reactAppCtx';\nimport Trv from 'js/splmTableTraversal';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Cell from 'js/splmTableCellRenderer';\nimport SelectionHelper from 'js/splmTableSelectionHelper';\n\nvar SPLMTableEditor = function( tableElem, directiveElem, gridContextDispatcher ) {\n    let _trv = new Trv( tableElem );\n    let _fillDown = new SPLMTableFillDown( tableElem );\n    let _lovValueChangedEventSubs = {};\n    let _blurHandler = null;\n    let _focusProp = null;\n    let _tableInstance = util.getTableInstance( tableElem );\n    let _selectedCellInfo = null;\n    let _saveEditPromise = null;\n    let _isEditablePromise = null;\n    let _escapeKeyHandler = null;\n    let _enterKeyHandler = null;\n    let _fillDownSaveInprogress = false;\n    const ariaReadOnly = 'aria-readonly';\n    const ariaActiveDescendant = 'aria-activedescendant';\n\n    // cache local event subscription\n    let _eventBusSubs = [];\n\n    let self = this; // eslint-disable-line no-invalid-this\n\n    const destroyLovEventListeners = function() {\n        _.forEach( _lovValueChangedEventSubs, function( subscription ) {\n            eventBus.unsubscribe( subscription );\n        } );\n        _lovValueChangedEventSubs = {};\n    };\n\n    self.destroy = function() {\n        destroyLovEventListeners();\n        _.forEach( _eventBusSubs, function( sub ) {\n            eventBus.unsubscribe( sub );\n        } );\n        _eventBusSubs = [];\n    };\n\n    self.setFocusProp = function( prop ) {\n        _focusProp = prop;\n    };\n\n    const triggerBlurHandler = function() {\n        if( _blurHandler ) {\n            _blurHandler();\n        }\n    };\n\n    self.updateEditStatus = function() {\n        triggerBlurHandler();\n        var cellElems = _trv.getContentCellElementsFromTable();\n        _.forEach( cellElems, function( elem ) {\n            self.updateEditStatusForCell( elem );\n        } );\n        if( !util.isBulkEditing( tableElem ) ) {\n            _focusProp = null;\n            destroyLovEventListeners();\n        }\n    };\n\n    const toggleLinkStyle = function( element, isLinkStyle ) {\n        if( isLinkStyle ) {\n            // disabled to active link\n            var linkElements = element.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n            for( var i = linkElements.length; i > 0; i-- ) {\n                var linkElem = linkElements[ i - 1 ];\n                if( linkElem && linkElem.classList ) {\n                    linkElem.classList.add( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                    linkElem.classList.remove( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n                }\n            }\n        } else {\n            // active to disabled links\n            linkElements = element.getElementsByClassName( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n            for( var j = linkElements.length; j > 0; j-- ) {\n                var linkElem1 = linkElements[ j - 1 ];\n                if( linkElem1 && linkElem1.classList ) {\n                    linkElem1.classList.add( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );\n                    linkElem1.classList.remove( Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );\n                }\n            }\n        }\n    };\n\n    /**\n     * Ensure the drag handle is the last element in the parent container.\n     *\n     * @param {DOMElement} cell - cell with drag handle to re-append\n     */\n    const ensureDragHandleLastChild = function( cell ) {\n        var dragHandleElements = cell.getElementsByClassName( Const.CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE );\n        if( dragHandleElements.length > 0 ) {\n            dragHandleElements[ 0 ].parentElement.appendChild( dragHandleElements[ 0 ] );\n        }\n    };\n\n    const reverseEditCell = function( cell, vmo, column, cellElemProperty ) {\n        if( cell.parentElement === null ) {\n            return;\n        }\n        cell.isElementInEdit = false;\n        var editCells = null;\n        if( cellElemProperty.isArray ) {\n            editCells = cell.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY );\n        } else {\n            editCells = cell.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP );\n        }\n        var isErrorProperty = false;\n        var cellTopElement = Cell.createElement( column, vmo, tableElem, cell.parentElement );\n        if( _tableInstance.dynamicRowHeightStatus === true ) {\n            Cell.addDynamicCellHeight( vmo, cellTopElement );\n        }\n        if( editCells.length > 0 ) {\n            var editCell = editCells[ 0 ];\n            if( cellElemProperty.isArray ) {\n                const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n                if( editArrayPopup ) {\n                    editArrayPopup.hide();\n                }\n            } else {\n                editCell.parentElement.removeChild( editCell );\n            }\n\n            setTimeout( function() {\n                util.cleanupComponents( editCell );\n                var propertyErrorElements = editCell.getElementsByClassName( 'aw-widgets-propertyError' );\n                if( propertyErrorElements.length > 0 ) {\n                    isErrorProperty = true;\n                }\n                if( isErrorProperty ) {\n                    cellTopElement.classList.add( 'aw-widgets-propertyError' );\n                }\n                if( !cellElemProperty.isArray ) {\n                    util.destroyElement( editCell );\n                }\n            }, 1000 );\n        }\n\n        cell.classList.remove( Const.CLASS_AW_IS_EDITING );\n        cell.appendChild( cellTopElement );\n\n        var cellTopElements = cell.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP );\n\n        if( cellTopElements.length > 0 ) {\n            cellTopElements[ 0 ].classList.add( Const.CLASS_AW_EDITABLE_CELL );\n        }\n\n        ensureDragHandleLastChild( cell );\n    };\n\n    const removeFocusEvents = function( cellElem ) {\n        const useCapture = true;\n        cellElem.removeEventListener( 'focus', cellElem.onFocusEvent, useCapture );\n        cellElem.onFocusEvent = null;\n        cellElem.removeEventListener( 'mousedown', cellElem.onFocusClickEvent );\n        cellElem.onFocusClickEvent = null;\n    };\n\n    let _isUserClick = false;\n    let _isCtrlKey = false;\n    const addFocusEvent = function( cellElem, vmo ) {\n        removeFocusEvents( cellElem );\n        const onFocusEvent = function( event ) {\n            // Update row selection if clicking on editable cell. This is needed because UW widget stops propagation of the event\n            // to the row element when it is created.\n            if( _isUserClick ) {\n                let eventObj;\n                if( browserUtils.isIE ) {\n                    eventObj = document.createEvent( 'MouseEvent' );\n                    eventObj.initMouseEvent( 'click', true, true, window, 0, eventObj.screenX, eventObj.screenY, eventObj.clientX, eventObj.clientY, _isCtrlKey, false, false, false, 0, null );\n                } else {\n                    eventObj = new MouseEvent( 'click', { ctrlKey: _isCtrlKey } );\n                }\n                cellElem.parentElement.dispatchEvent( eventObj );\n                _isUserClick = false;\n                _isCtrlKey = false;\n            }\n            self.editCell( cellElem, vmo );\n        };\n\n        cellElem.onFocusEvent = onFocusEvent;\n        const useCapture = true;\n        // LCS-357443: IE does not focus the cell when using element.onfocus.\n        // Instead focus event must be added with addEventListener and useCapture as true.\n        cellElem.addEventListener( 'focus', onFocusEvent, useCapture );\n\n        const isFocusClickEvent = function( event ) {\n            _isUserClick = true;\n            _isCtrlKey = event.ctrlKey;\n        };\n        cellElem.isFocusClickEvent = isFocusClickEvent;\n        cellElem.addEventListener( 'mousedown', isFocusClickEvent );\n    };\n\n    const addEditStatus = function( cellElem, cellElemProperty, vmo ) {\n        if( cellElem.children[ 0 ] ) {\n            cellElem.children[ 0 ].classList.add( Const.CLASS_AW_EDITABLE_CELL );\n            var rowHeight = util.getTableRowHeight( _tableInstance.gridOptions, undefined );\n            if( rowHeight !== undefined ) {\n                cellElem.children[ 0 ].style.height = rowHeight + 'px';\n            }\n        } else {\n            logger.debug( cellElem.propName + ' has no child' );\n        }\n\n        addFocusEvent( cellElem, vmo );\n\n        _fillDown.enableFillDown( cellElem );\n        toggleLinkStyle( cellElem, false );\n\n        // for saved cells in partial edit status\n        var cellTop = cellElem.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ] || cellElem.getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP )[ 0 ] || cellElem\n            .getElementsByClassName( Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY )[ 0 ];\n        Cell.updateCellChangedClass( cellElemProperty, cellTop );\n\n        if( _focusProp === cellElem.prop ) {\n            self.editCell( cellElem, vmo );\n        }\n    };\n\n    const removeBlurHandler = function() {\n        const useCapture = true;\n        document.body.removeEventListener( 'click', _blurHandler, useCapture );\n        _trv.getScrollCanvasElementFromTable().removeEventListener( 'scroll', _blurHandler, useCapture );\n        _trv.getPinCanvasElementFromTable().removeEventListener( 'scroll', _blurHandler, useCapture );\n    };\n\n    const removeEscapeAndEnterHandlers = function( cell ) {\n        document.body.removeEventListener( 'keydown', _escapeKeyHandler, true );\n        cell.removeEventListener( 'keydown', _enterKeyHandler, true );\n        _escapeKeyHandler = null;\n        _enterKeyHandler = null;\n    };\n\n    const setBlurHandler = function( blurHandler ) {\n        _blurHandler = blurHandler;\n    };\n\n    const removeEditStatus = function( cellElem, cellElemProperty, vmo, skipCellCreation ) {\n        const cellTopElem = cellElem.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ];\n        if( cellTopElem && ( cellTopElem.classList.contains( Const.CLASS_AW_EDITABLE_CELL ) || cellTopElem.classList.contains( Const.CLASS_CELL_CHANGED ) ) ||\n            cellElem.propIsEditableCache ) {\n            if( !cellElemProperty.isArray && !cellElem.isSelected ) {\n                _fillDown.disableFillDown( cellElem );\n            }\n            if( !skipCellCreation ) {\n                cellElem.removeChild( cellTopElem );\n                reverseEditCell( cellElem, vmo, cellElem.columnDef, cellElemProperty );\n            }\n            cellElem.children[ 0 ].classList.remove( Const.CLASS_AW_EDITABLE_CELL );\n            removeFocusEvents( cellElem );\n        }\n        toggleLinkStyle( cellElem, true );\n    };\n\n    self.updateEditStatusForCell = function( cellElem ) {\n        var cellElemProperty = cellElem.prop;\n        let vmo = util.getViewModelObjectByCellElement( cellElem );\n        vmo = getVmoById( vmo.alternateID || vmo.uid ); // get latest vmo from collection rather than cached\n        var vmoProp = vmo && vmo.props && vmo.props[ cellElem.propName ];\n\n        if( cellElem.propName && cellElemProperty && cellElem.columnDef.isTreeNavigation !== true ) {\n            // LCS-142669 - read modifiable besides of isEditable\n            if( ( cellElemProperty.isEditable || vmoProp && vmoProp.isEditable ) && cellElem.columnDef.modifiable !== false && util.isBulkEditing( tableElem ) ) {\n                addEditStatus( cellElem, cellElemProperty, vmo );\n            } else if( cellElem.isSelected && cellElem.propIsEditableCache && cellElemProperty.isPropInEdit ) {\n                addEditStatus( cellElem, cellElemProperty, vmo );\n            } else {\n                removeEditStatus( cellElem, cellElemProperty, vmo );\n                if( util.isBulkEditing( tableElem ) ) {\n                    cellElem.setAttribute( ariaReadOnly, 'true' );\n                } else if( cellElem.hasAttribute( ariaReadOnly ) && cellElem.propIsEditableCache !== false ) {\n                    cellElem.removeAttribute( ariaReadOnly );\n                }\n            }\n        } else if( util.isBulkEditing( tableElem ) ) {\n            cellElem.setAttribute( ariaReadOnly, 'true' );\n        } else if( cellElem.hasAttribute( ariaReadOnly ) && cellElem.propIsEditableCache !== false ) {\n            cellElem.removeAttribute( ariaReadOnly );\n        }\n    };\n\n    /**\n     * Subscribe to lovValueChangedEvent. Update dependent cells\n     */\n    const subscribeToLovValueChangedEvent = function( cell, vmo, prop ) {\n        return eventBus.subscribe( prop.propertyName + '.lovValueChanged', function() {\n            // Update dependent LOVS only\n            if( !prop.lovApi || !prop.lovApi.behaviorData || prop.lovApi.behaviorData.style !== 'Interdependent' ) {\n                return;\n            }\n\n            prop.lovApi.behaviorData.dependendProps.forEach( function( propertyName ) {\n                // Only update cells for other props\n                if( prop.propertyName !== propertyName ) {\n                    var row = cell.parentElement;\n                    // Find the cell\n                    _.forEach( row.children, function( cellElem ) {\n                        if( cellElem.propName === propertyName ) {\n                            // Update cell content\n                            var oldCellTop = cellElem.children[ 0 ];\n                            var newCellTop = Cell.createElement( cellElem.columnDef, row.vmo, tableElem, row );\n                            if( _tableInstance.dynamicRowHeightStatus === true ) {\n                                Cell.addDynamicCellHeight( vmo, newCellTop );\n                            }\n                            newCellTop.classList.add( Const.CLASS_AW_EDITABLE_CELL );\n                            cellElem.replaceChild( newCellTop, oldCellTop );\n                            cellElem.isDependantEdit = true;\n                            if( !util.isBulkEditing( tableElem ) && util.isAutoSaveEnabled( tableElem ) ) {\n                                self.removeAllCellSelection();\n                                self.editCell( cellElem, vmo );\n                            }\n                            return false;\n                        }\n                        return true;\n                    } );\n                }\n            } );\n        } );\n    };\n\n    /**\n     * Cancels edits if isDirty() comes back false\n     */\n    const cancelEditsIfNotDirty = function() {\n        const context = getEditContext( _tableInstance );\n        let editHandler = null;\n        let isDirtyPromise;\n        if( context ) {\n            editHandler = editHandlerSvc.getEditHandler( context );\n            isDirtyPromise = editHandler.isDirty();\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            isDirtyPromise = _tableInstance.dataProvider.isDirty();\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            isDirtyPromise = _tableInstance.declViewModel.isDirty();\n        }\n\n        if( isDirtyPromise ) {\n            isDirtyPromise.then( function( isDirty ) {\n                // If the handler is not dirty cancel edits to get out of edit mode.\n                if( !isDirty ) {\n                    if( editHandler ) {\n                        editHandler.cancelEdits();\n                    } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                        const dataCtxNode = {\n                            data: _tableInstance.declViewModel,\n                            ctx: appCtxService.ctx\n                        };\n                        _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n                    } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                        _tableInstance.declViewModel.cancelEdits();\n                    }\n                }\n            } );\n        }\n    };\n\n    /**\n     * Handles cell editing functionality for the blur event\n     * @param {Event} event - the blur event\n     * @param {DOMElement} cell - The cell element\n     * @param {ViewModelProperty} prop - The property\n     * @param {ViewModelObject} vmo - The view model object\n     */\n    const handleCellEditBlur = function( event, cell, prop, vmo ) {\n        // Autosave the cell on blur when in autosave mode\n        if( !util.isBulkEditing( tableElem ) && util.isAutoSaveEnabled( tableElem ) && event && !_fillDownSaveInprogress ) {\n            // Stop the event bubbling so save can finish first, we will resend the click when save is finished\n            event.stopPropagation();\n            event.preventDefault();\n            _fillDown.disableFillDown( cell );\n\n            // get target vmo/prop if clicking on table so we can resend click to it after\n            const tableCell = util.closestElement( event.target, '.ui-grid-cell' );\n            let vmo;\n            let propName;\n            if( tableCell ) {\n                propName = tableCell.propName;\n                vmo = util.getViewModelObjectByCellElement( tableCell );\n            }\n            _saveEditPromise = self.saveEdit( [ cell ] ).then( () => {\n                _saveEditPromise = null;\n                if( !tableCell ) {\n                    let clickElement = event.target;\n                    // Elements like svg don't have a click function, so bubble up till we have a clickable element.\n                    while( !clickElement.click ) {\n                        clickElement = clickElement.parentElement;\n                    }\n                    clickElement.click();\n                } else {\n                    // reselect table cell\n                    let uid = vmo && vmo.alternateID || vmo.uid;\n                    let cellToSelect = util.getCellElementsByPropertyAndUid( tableElem, propName, uid )[ 0 ];\n                    cellToSelect && cellToSelect.click && cellToSelect.click();\n                }\n            } );\n        } else if( !util.isBulkEditing( tableElem ) && !util.isAutoSaveEnabled( tableElem ) ) {\n            cancelEditsIfNotDirty();\n            removeEditStatus( cell, prop, vmo, true );\n        }\n    };\n\n    /**\n     * Returns the focusable cell info if it is focusable\n     *\n     * @param {Object} column - the column\n     * @param {ViewModelObject} vmo - the vmo\n     *\n     * @return {Object} the focusable cell's info\n     */\n    const getFocusableCellInfo = function( column, vmo ) {\n        if( column.modifiable !== false && !column.isTreeNavigation ) {\n            const propName = column.propertyName || column.field;\n            const prop = vmo.props[ propName ];\n            if( prop && prop.isEditable ) {\n                return {\n                    vmo: vmo,\n                    column: column\n                };\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the info of the next focusable cell\n     *\n     * @param {ViewModelObject} currentVMO - the current vmo\n     * @param {Object} currentColumn - the current column\n     * @param {boolean} reverseDirection - true if going in the reverse direction\n     *\n     * @return {Object} the next focusable cell's info\n     */\n    const getNextFocusableCellInfo = ( currentVMO, currentColumn, reverseDirection ) => {\n        let columns = _tableInstance.dataProvider.cols.filter( function( col ) {\n            return !col.hiddenFlag;\n        } );\n        const currentIdx = columns.indexOf( currentColumn );\n\n        // Reverse the columns order if we are going in reverse\n        if( reverseDirection ) {\n            columns = columns.slice().reverse();\n        }\n\n        for( let i = currentIdx + 1; i < columns.length; i++ ) {\n            const col = columns[ i ];\n            const focusableCellInfo = getFocusableCellInfo( col, currentVMO );\n            if( focusableCellInfo ) {\n                return focusableCellInfo;\n            }\n        }\n\n        // If no cell was found, check next vmo until found  -- Limit - Until end of data, will not page while looking\n        const loadedVMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n        const currentVMOIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( currentVMO.uid );\n        for( let i = currentVMOIndex + 1; i < loadedVMOs.length; i++ ) {\n            const nextVMO = loadedVMOs[ i ];\n            for( let y = 0; y < columns.length; y++ ) {\n                const col = columns[ y ];\n                const focusableCellInfo = getFocusableCellInfo( col, nextVMO );\n                if( focusableCellInfo ) {\n                    return focusableCellInfo;\n                }\n            }\n        }\n\n        // If we still haven't found anything, then there are no more editable cells available, return null\n        return null;\n    };\n\n    /**\n     * Attaches the keydown handler to a cell\n     * @param {DOMElement} cellElem The cell element\n     */\n    const attachKeydownHandler = ( cellElem ) => {\n        cellElem.onkeydown = ( event ) => {\n            if( event.code !== 'Tab' ) {\n                return;\n            }\n\n            let reverseTab = false;\n            if( event.shiftKey ) {\n                reverseTab = true;\n            }\n\n            // Now check vmo for next editable column.\n            const closestVMO = event.target.closest( '.ui-grid-row' ).vmo;\n            const column = event.target.closest( '.ui-grid-cell' ).columnDef;\n            const nextEditableInfo = getNextFocusableCellInfo( closestVMO, column, reverseTab );\n\n            // Scroll to that cell if exists\n            if( nextEditableInfo ) {\n                event.preventDefault();\n                event.stopPropagation();\n\n                const vmoIndex = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( nextEditableInfo.vmo.uid );\n\n                triggerBlurHandler();\n\n                _tableInstance.renderer.scrollToRowIndex( [ vmoIndex ] );\n                if( !nextEditableInfo.column.pinnedLeft ) {\n                    _tableInstance.renderer.scrollToColumn( nextEditableInfo.column );\n                }\n\n                setTimeout( () => {\n                    // Get the cell and focus it after it is scrolled into view\n                    const firstRowOnDom = tableElem.getElementsByClassName( 'ui-grid-row' )[ 0 ];\n                    if( firstRowOnDom ) {\n                        const editableRowRelativeIdx = vmoIndex - firstRowOnDom.getAttribute( 'data-indexNumber' );\n                        let rowElem;\n                        if( nextEditableInfo.column.pinnedLeft ) {\n                            rowElem = _trv.getPinContentRowElementFromTable( editableRowRelativeIdx );\n                        } else {\n                            rowElem = _trv.getScrollContentRowElementFromTable( editableRowRelativeIdx );\n                        }\n                        const cellElems = rowElem && rowElem.getElementsByClassName( 'ui-grid-cell' ) || [];\n                        const foundCell = _.filter( cellElems, { columnDef: nextEditableInfo.column } )[ 0 ];\n                        if( foundCell ) {\n                            self.editCell( foundCell, nextEditableInfo.vmo );\n                        }\n                    }\n                }, 200 );\n            }\n        };\n    };\n\n    const attachEscapeKeyHandler = ( cell, prop, vmo, column ) => {\n        // Set listener for Escape key and reverse edit cell\n        _escapeKeyHandler = ( event ) => {\n            if( event.key !== 'Escape' ) {\n                return;\n            }\n\n            const currentCell = util.closestElement( event.target, '.' + Const.CLASS_CELL );\n            if( currentCell === cell && cell.isElementInEdit ) {\n                event.stopPropagation();\n                uwPropertyService.resetUpdates( prop );\n                reverseEditCell( cell, vmo, column, prop );\n                if( !util.isBulkEditing( tableElem ) ) {\n                    prop.isPropInEdit = false;\n                    removeEditStatus( cell, prop, vmo, true );\n\n                    // Check if isDirty still, is so, do nothing, else cancel edits\n                    cancelEditsIfNotDirty();\n                    removeEscapeAndEnterHandlers( cell );\n                    cell.focus();\n                } else {\n                    // Readd click handler to allow cell to go back into edit\n                    addFocusEvent( cell, vmo );\n                }\n            } else {\n                const context = getEditContext( _tableInstance );\n                let editHandler = editHandlerSvc.getEditHandler( context );\n                if( editHandler ) {\n                    editHandler.cancelEdits();\n                } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                    const dataCtxNode = {\n                        data: _tableInstance.declViewModel,\n                        ctx: appCtxService.ctx\n                    };\n                    _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n                } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                    _tableInstance.declViewModel.cancelEdits();\n                }\n            }\n        };\n        document.body.addEventListener( 'keydown', _escapeKeyHandler, true );\n    };\n\n    const attachEnterKeyHandler = ( cell, blurHandler ) => {\n        const hasPopupExpanded = ( element ) => {\n            const popupVisible = element.getElementsByClassName( 'aw-jswidgets-popUpVisible' );\n            const expanded = element.getElementsByClassName( 'aw-jswidgets-expanded' );\n            return popupVisible.length + expanded.length > 0;\n        };\n\n        _enterKeyHandler = ( event ) => {\n            if( event.key === 'Enter' && !event.altKey && !util.isBulkEditing( tableElem ) ) {\n                const currentCell = util.closestElement( event.target, '.' + Const.CLASS_CELL );\n                // Special handling for array properties\n                const isArrayProperty = currentCell.prop && currentCell.prop.isArray;\n                if( isArrayProperty ) {\n                    if( event.target.value === '' ) {\n                        event.stopPropagation();\n                        blurHandler( event );\n                        if( !util.isBulkEditing( tableElem ) ) {\n                            currentCell.focus();\n                        }\n                    }\n                } else {\n                    // If there isn't a popup in the children, then call blurhandler\n                    if( currentCell && !hasPopupExpanded( currentCell ) ) {\n                        event.stopPropagation();\n                        blurHandler( event );\n                        if( _saveEditPromise ) {\n                            _saveEditPromise.then( function() {\n                                currentCell.focus();\n                            } );\n                        } else {\n                            currentCell.focus();\n                        }\n                    }\n                }\n            }\n        };\n        cell.addEventListener( 'keydown', _enterKeyHandler, true );\n    };\n\n    /**\n     * Publishes teh cell start edit event\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */\n    const publishCellStartEditEvent = function( cell, vmo ) {\n        const eventData = {\n            columnInfo: cell.columnDef,\n            gridId: tableElem.id,\n            vmo: vmo\n        };\n\n        eventBus.publish( tableElem.id + '.cellStartEdit', eventData );\n    };\n\n    const getVmoById = function( vmoId ) {\n        let idx = _tableInstance.dataProvider.viewModelCollection.findViewModelObjectById( vmoId );\n        return _tableInstance.dataProvider.viewModelCollection.loadedVMObjects[ idx ];\n    };\n\n    /**\n     * Unsubscribes from the hold lov value change event and subscribes to a new one\n     * @param {DOMElement} cell the cell element\n     * @param {Object} vmo the view model object\n     * @param {Object} prop The property\n     */\n    const handleLovValueChangedEvent = function( cell, vmo, prop ) {\n        const lovValueChangedEventSub = subscribeToLovValueChangedEvent( cell, vmo, prop );\n        let oldLovSubscr = _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ];\n        if( oldLovSubscr ) {\n            eventBus.unsubscribe( oldLovSubscr );\n            delete _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ];\n        }\n        _lovValueChangedEventSubs[ prop.parentUid + prop.propertyName ] = lovValueChangedEventSub;\n    };\n\n    const isUserInteractingWithDropDown = ( prop, event ) => {\n        if( prop.hasLov && event ) {\n            const listBoxDrop = document.querySelector( '.sw-lov-contentContainer' );\n            if( listBoxDrop && listBoxDrop.contains( event.target ) ) {\n                return true;\n            }\n        } else if( prop.type && event && ( prop.type === 'DATE' || prop.type === 'DATEARRAY' ) ) {\n            const datePicker = document.querySelector( '.flatpickr-calendar.open' );\n            if( datePicker && datePicker.contains( event.target ) ) {\n                return true;\n            }\n            const dateTimeDrop = document.querySelector( '.sw-popup-contentContainer .aw-base-scrollPanel' );\n            if( dateTimeDrop && dateTimeDrop.contains( event.target ) ) {\n                return true;\n            }\n        } else if( prop.type && event && prop.type === 'STRING' && prop.isRichText ) {\n            const ckEditor = document.getElementsByClassName( 'ck-body-wrapper' )[ 0 ];\n            if( ckEditor && ckEditor.contains( event.target ) ) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Creates the edit cell and attaches it to the DOM\n     * @param {Object} vmo - the view model object\n     * @param {AwColumnDef} column The column definition\n     * @param {DOMElement} cell The cell element\n     */\n    const createAndAttachEditCell = function( vmo, column, cell ) {\n        // for array fields, application should use popup to display it,\n        // or you will face cut off issues: LCS-161794\n        const prop = vmo.props[ cell.propName ];\n        prop.autofocus = true;\n        let editNonArrayClass = prop.isArray ? Const.CLASS_TABLE_EDIT_CELL_ARRAY : Const.CLASS_TABLE_EDIT_CELL_NON_ARRAY;\n        let editCellElem = util.createElement( 'div', 'aw-splm-tableEditCellTop', editNonArrayClass );\n        let editContainer = util.createElement( 'div', 'aw-jswidgets-tableEditContainer', 'aw-jswidgets-cellTop' );\n\n        /* revisitme Brad\n         * Revisit/revise for support of column def providing rendering hint\n         * column.renderingHint\n         */\n        let propertyValElem = includeComponent( 'SplmTableCellEditor', {\n            vmo,\n            name: prop.propertyName\n        } );\n\n        renderComponent( <AppCtxComponent>{propertyValElem}</AppCtxComponent>, editContainer );\n        editCellElem.appendChild( editContainer );\n\n        attachKeydownHandler( editCellElem );\n\n        Cell.updateCellChangedClass( prop, editCellElem.getElementsByClassName( Const.CLASS_AW_JS_CELL_TOP )[ 0 ] );\n        if( prop.isArray && _tableInstance.gridOptions.popupContext && _tableInstance.gridOptions.popupContext.editArrayPopup ) {\n            const cellBoundingArea = cell.getBoundingClientRect();\n            const popupOptions = {\n                whenParentScrolls: 'follow',\n                innerClassName: Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY,\n                autoFocus: false,\n                parent: cell,\n                reference: cell,\n                overlapOnReference: true,\n                containerWidth: cellBoundingArea.width,\n                width: cellBoundingArea.width,\n                forceCloseOthers: false\n            };\n            const editArrayPopup = _tableInstance.gridOptions.popupContext.editArrayPopup;\n            if( editArrayPopup ) {\n                editArrayPopup.hide().then( () => {\n                    editArrayPopup.show( popupOptions ).then( ( popupRef ) => {\n                        self.popupRef = popupRef;\n                    } );\n                } );\n            }\n        } else {\n            cell.insertBefore( editCellElem, cell.childNodes[ 0 ] );\n        }\n    };\n\n    /**\n     * Starts the edit of the cell\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */\n    self.editCell = function( cell, vmo ) {\n        const column = cell.columnDef;\n        const prop = cell.prop;\n        if( !cell.isDependantEdit && ( !cell.isSelected && !util.isBulkEditing( tableElem ) || cell.isElementInEdit === true ) ) {\n            return;\n        }\n\n        gridContextDispatcher( {\n            type: 'UPDATE_VALUES',\n            editVmo: vmo,\n            editPropertyName: cell.propName\n        } );\n\n        publishCellStartEditEvent( cell, vmo );\n\n        // Trigger blur handler\n        triggerBlurHandler();\n\n        cell.isElementInEdit = true;\n        prop.isPropInEdit = true;\n\n        cell.classList.add( Const.CLASS_AW_IS_EDITING );\n\n        // Handle possible lov value changes\n        handleLovValueChangedEvent( cell, vmo, prop );\n\n        // Remove cell top\n        let editableGridCell = cell.getElementsByClassName( Const.CLASS_TABLE_CELL_TOP )[ 0 ];\n        if( editableGridCell ) {\n            cell.removeChild( editableGridCell );\n        }\n\n        let originAutoFocus = prop.autofocus;\n        createAndAttachEditCell( vmo, column, cell );\n        removeFocusEvents( cell );\n\n        const blurHandler = function( event ) {\n            // Only revert edit status if scrolling with array (popup)\n            if( event && event.type === 'scroll' && cell.prop && !cell.prop.isArray ) {\n                return;\n            }\n            let selectedCell = null;\n            if( event && event.type !== 'keydown' ) {\n                _focusProp = null;\n                selectedCell = util.closestElement( event.target, `.${Const.CLASS_CELL}` );\n            }\n            if( !cell.isElementInEdit ) {\n                removeBlurHandler();\n                removeEscapeAndEnterHandlers( cell );\n            } else if( selectedCell !== cell && cell.isElementInEdit ) {\n                // Close panels\n                let panelContext = appCtxService.getCtx( 'panelContext' );\n                if( panelContext && panelContext.addTypeRef === true ) {\n                    // If clicking on different cell close the panel else leave it open\n                    if( cell.propName !== prop.propertyName || cell.parentElement.vmo.uid !== prop.parentUid ) {\n                        eventBus.publish( 'completed', {\n                            source: 'toolAndInfoPanel'\n                        } );\n                    } else {\n                        return;\n                    }\n                }\n\n                if( isUserInteractingWithDropDown( prop, event ) ) {\n                    return true;\n                }\n\n                // Remove the blur handler since cell is going out of edit\n                removeBlurHandler();\n                removeEscapeAndEnterHandlers( cell );\n\n                // Reverse the cell edit\n                reverseEditCell( cell, vmo, column, prop );\n\n                prop.autofocus = originAutoFocus;\n                prop.isPropInEdit = false;\n\n                cell.isSelected = false;\n                delete cell.isDependantEdit;\n\n                // Handle cell editing functionality on blur\n                handleCellEditBlur( event, cell, prop, vmo );\n\n                // Readd click handler to allow cell to go back into edit\n                addFocusEvent( cell, vmo );\n            }\n        };\n\n        // Add blur handler to take cell out of edit on click away\n        removeBlurHandler();\n        removeEscapeAndEnterHandlers( cell );\n\n        // Setting useCapture to true is needed for autosave since it allows us to detect the click before the target\n        // element does.\n        const useCapture = true;\n        document.body.addEventListener( 'click', blurHandler, useCapture );\n\n        const scrollViewportElem = _trv.getScrollCanvasElementFromTable();\n        const pinViewportElem = _trv.getPinCanvasElementFromTable();\n\n        scrollViewportElem.removeEventListener( 'scroll', blurHandler, useCapture );\n        pinViewportElem.removeEventListener( 'scroll', blurHandler, useCapture );\n        scrollViewportElem.addEventListener( 'scroll', blurHandler, useCapture );\n        pinViewportElem.addEventListener( 'scroll', blurHandler, useCapture );\n\n        attachEscapeKeyHandler( cell, prop, vmo, column );\n        attachEnterKeyHandler( cell, blurHandler );\n\n        setBlurHandler( blurHandler );\n    };\n\n    self.isPropertiesEditablePromise = function( editOptions ) {\n        let editPromise;\n        const editContext = getEditContext( _tableInstance );\n        if( editContext ) {\n            // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n            // can be editing at any given time.\n            const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n            if( previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler( editContext ) && previousActiveHandler.editInProgress() ) {\n                editPromise = new Promise( ( resolve ) => {\n                    previousActiveHandler.leaveConfirmation( () => {\n                        editHandlerSvc.setActiveEditHandlerContext( editContext );\n                        editHandlerSvc.startEdit( editOptions ).then( () => {\n                            resolve();\n                        } );\n                    } );\n                } );\n            } else {\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                editPromise = editHandlerSvc.startEdit( editOptions );\n            }\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            const dataCtxNode = {\n                data: _tableInstance.declViewModel,\n                ctx: appCtxService.ctx\n            };\n            editPromise = _tableInstance.dataProvider.startEdit( dataCtxNode, _tableInstance.declViewModel, editOptions );\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            editPromise = _tableInstance.declViewModel.startEdit( editOptions );\n        }\n\n        return editPromise ? editPromise : Promise.resolve( false );\n    };\n\n    /**\n     * Checks if the provided cell/property is editable by calling startEdit on the editHandler or editConfig\n     * @param {Object} vmo The view model object\n     * @param {DOMElement} cellElem The cell element\n     *\n     * @returns {Promise<Boolean>} Promise that will resolve to the editability of the property\n     */\n    const isCellEditable = async function( vmo, cellElem ) {\n        // Allow save to finish before checking start edit\n        if( _saveEditPromise ) {\n            await _saveEditPromise;\n        }\n        let prop = vmo.props[ cellElem.propName ];\n        let propertyNames = [ prop.propertyName ];\n        // Need to pass all dependent props to ensure we have latest lsd\n        if( prop.lovApi && prop.lovApi.behaviorData && prop.lovApi.behaviorData.style === 'Interdependent' ) {\n            propertyNames = prop.lovApi.behaviorData.dependendProps;\n        }\n        let editOpts = {\n            vmos: [ vmo ],\n            propertyNames: propertyNames,\n            autoSave: util.isAutoSaveEnabled( tableElem )\n        };\n        const result = await self.isPropertiesEditablePromise( editOpts );\n\n        if( result === false ) {\n            return false;\n        }\n        // update prop to latest\n        prop = vmo.props[ cellElem.propName ];\n        return prop && prop.isEditable && prop.isEnabled !== false;\n    };\n\n    /**\n     * Saved the provided cell/property that was edited\n     * @param {DOMElement[]} cells the cells to save\n     * @returns {Promise<Boolean>} Promise that will resolve when save is complete\n     */\n    self.saveEdit = function( cells ) {\n        let isPartialSaveDisabled = true;\n        let editPromise = null;\n        const editContext = getEditContext( _tableInstance );\n        if( editContext ) {\n            editPromise = editHandlerSvc.saveEdits( editContext, isPartialSaveDisabled, util.isAutoSaveEnabled( tableElem ) );\n        } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n            const dataCtxNode = {\n                data: _tableInstance.declViewModel,\n                ctx: appCtxService.ctx\n            };\n            editPromise = _tableInstance.dataProvider.saveEdits( dataCtxNode, _tableInstance.declViewModel );\n        } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n            editPromise = _tableInstance.declViewModel.saveEdits();\n        }\n\n        if( editPromise ) {\n            return editPromise.finally( function() {\n                self.setCellEditingContext( false );\n                for( let i = 0; i < cells.length; i++ ) {\n                    if( document.body.contains( cells[ i ] ) ) {\n                        self.updateEditStatusForCell( cells[ i ] );\n                    }\n                }\n                // Clear prop is editable cache to ensure newly selected cell makes a startEdit call, since\n                // our save call will likely invalidate the editable cache. This is also ensuring that double click on\n                // another cell takes that cell into edit instead of selected state.\n                self.clearPropIsEditableCache();\n            } );\n        }\n        return Promise.resolve( false );\n    };\n\n    /**\n     * Removes the selected and selectedEditable css classes from any elements that have them\n     */\n    const removeCellSelection = function() {\n        // Remove all other \"selected\" classes from cells\n        let selected1 = Array.prototype.slice.call( tableElem.getElementsByClassName( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE ) );\n        let selected2 = Array.prototype.slice.call( tableElem.getElementsByClassName( Const.CLASS_TABLE_CELL_SELECTED ) );\n        let elems = selected1.concat( selected2 );\n        for( let i = 0; i < elems.length; i++ ) {\n            elems[ i ].classList.remove( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n            elems[ i ].classList.remove( Const.CLASS_TABLE_CELL_SELECTED );\n            let containerElement = null;\n            // The below method can result in undefined value.\n            containerElement = _trv.getTableContainerElementFromTable();\n            if( containerElement && containerElement.hasAttribute( ariaActiveDescendant ) ) {\n                containerElement.removeAttribute( ariaActiveDescendant );\n            }\n        }\n    };\n\n    /**\n     * Updates the cell to be selected and sets selection/edit info to false on old selected cell\n     * @param {DOMElement} cell The new selected cell\n     * @param {Boolean} persistEditableFlag flag to denote if isEditable should be persisted\n     */\n    const updateSelectedCell = function( cell, persistEditableFlag ) {\n        if( _selectedCellInfo && _selectedCellInfo.cell ) {\n            let _cell = _selectedCellInfo.cell;\n            _cell.isSelected = false;\n            const vmo = getVmoById( _selectedCellInfo.vmoId );\n            // If prop edit is not enabled we should not touch the prop.isEditable flag\n            if( !persistEditableFlag && vmo && _cell.prop && util.isPropEditEnabled( tableElem ) && !util.isBulkEditing( tableElem ) ) {\n                _cell.prop.isEditable = false;\n                if( vmo.props && vmo.props[ _cell.propName ] ) {\n                    vmo.props[ _cell.propName ].isEditable = false;\n                }\n            }\n        }\n\n        if( cell ) {\n            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED );\n            cell.isSelected = true;\n            let refVmo = util.getViewModelObjectByCellElement( cell );\n            let vmoId = refVmo.alternateID || refVmo.uid;\n            _selectedCellInfo = {\n                cell: cell,\n                vmoId: vmoId\n            };\n            let containerElement = null;\n            // The below method can result in undefined value.\n            containerElement = _trv.getTableContainerElementFromTable();\n            if( containerElement ) {\n                containerElement.setAttribute( ariaActiveDescendant, cell.getAttribute( 'id' ) );\n            }\n        } else {\n            _selectedCellInfo = null;\n        }\n    };\n\n    self.clearPropIsEditableCache = function( persistEditableFlag ) {\n        const cellElems = _trv.getContentCellElementsFromTable();\n        _.forEach( cellElems, function( elem ) {\n            delete elem.propIsEditableCache;\n            if( elem.hasAttribute( ariaReadOnly ) ) {\n                elem.removeAttribute( ariaReadOnly );\n            }\n        } );\n        // Reset cell selection since we are clearing editibility cache\n        // making the editability selection classes no longer valid\n        removeCellSelection();\n        const currentSelectedCell = _selectedCellInfo ? _selectedCellInfo.cell : null;\n        updateSelectedCell( null, persistEditableFlag );\n        if( currentSelectedCell && currentSelectedCell.parentElement ) {\n            const eventObject = {\n                ctrlKey: false,\n                shiftKey: false,\n                type: 'click'\n            };\n            self.onClickHandler( eventObject, currentSelectedCell, util.getViewModelObjectByCellElement( currentSelectedCell ) );\n        }\n    };\n\n    /**\n     * Update the cell editability by using the cached editability or loading the editability if it is not cached\n     * @param {DOMElement} cell - The cell element to get editability for\n     * @param {Object} vmo - the row's view model object\n     */\n    const updateCellEditability = function( cell, vmo ) {\n        // Make some SOA call here for getting the editability\n        removeCellSelection();\n        updateSelectedCell( cell );\n\n        // Check if cellEdit is enabled and if this cell/prop type supports edit\n        const isCellEditSupported = util.isPropEditEnabled( tableElem ) && cell.propName && cell.prop && cell.columnDef.isTreeNavigation !== true;\n        if( !isCellEditSupported ) {\n            cell.setAttribute( ariaReadOnly, 'true' );\n            return;\n        }\n\n        // If prop is modified we can restore editability cache since we know it has not been saved\n        // and was previously editable\n        if( uwPropertyService.isModified( cell.prop ) && cell.propIsEditableCache === undefined && !util.isAutoSaveEnabled( tableElem ) ) {\n            cell.propIsEditableCache = true;\n        }\n\n        // Check if editability info exists, if not\n        // Check columnDef if editable, if not add readonly class\n        // If editable, make startEdit call to get editability for cell\n        if( cell.columnDef.name !== 'icon' && cell.columnDef.modifiable !== false && cell.propIsEditableCache === undefined ) {\n            // only allow one check at a time.\n            const cellEditablePromise = function() {\n                return isCellEditable( vmo, cell ).then( function( isEditable ) {\n                    cell.propIsEditableCache = isEditable;\n                    if( cell.propIsEditableCache === false ) {\n                        cell.setAttribute( ariaReadOnly, 'true' );\n                    } else if( cell.hasAttribute( ariaReadOnly ) ) {\n                        cell.removeAttribute( ariaReadOnly );\n                    }\n                    if( cell.isSelected ) {\n                        if( isEditable ) {\n                            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n                        }\n                        _fillDown.enableFillDown( cell );\n                    }\n                } ).then( function() {\n                    delete cell.isCellEditablePromise;\n                    _isEditablePromise = null;\n                } );\n            };\n            if( _isEditablePromise ) {\n                _isEditablePromise.then( function() {\n                    removeCellSelection();\n                    updateSelectedCell( cell );\n                    _isEditablePromise = cellEditablePromise();\n                    cell.isCellEditablePromise = _isEditablePromise;\n                } );\n            } else {\n                _isEditablePromise = cellEditablePromise();\n                cell.isCellEditablePromise = _isEditablePromise;\n            }\n            return;\n        }\n\n        if( cell.propIsEditableCache ) {\n            // Mark the prop as editable since the cache tells us it is editable\n            cell.prop.isEditable = true;\n            vmo.props[ cell.propName ].isEditable = true;\n            cell.classList.add( Const.CLASS_TABLE_CELL_SELECTED_EDITABLE );\n            if( cell.hasAttribute( ariaReadOnly ) ) {\n                cell.removeAttribute( ariaReadOnly );\n            }\n        } else if( cell.propIsEditableCache === false ) {\n            cell.setAttribute( ariaReadOnly, 'true' );\n        }\n    };\n\n    let _guidanceMessageInitialized = false;\n\n    const publishCellNotEditable = function( vmo, prop ) {\n        eventBus.publish( _tableInstance.gridId + '.plTable.cellNotEditable', {\n            vmo: vmo,\n            prop: prop\n        } );\n    };\n\n    /**\n     * Updates ctx and the editHandler/editConfig to be in editing mode when autosave is off.\n     * Doing this ensures the edit command will get toggled when editing in autosave off mode.\n     * @param {Boolean} isEditing - If in edit\n     */\n    self.setCellEditingContext = function( isEditing ) {\n        // Enable/disable caching\n        if( isEditing ) {\n            _tableInstance.dataProvider.cacheCollapse = isEditing;\n        } else {\n            _tableInstance.dataProvider.restoreInitialCacheCollapseState();\n        }\n        _tableInstance.controller.setDraggable( !isEditing );\n\n        // For autosave off we need to see _editing flag and update ctx to get commands to switch over\n        if( !util.isAutoSaveEnabled( tableElem ) ) {\n            const editContext = getEditContext( _tableInstance );\n            if( editContext ) {\n                const editHandler = editHandlerSvc.getEditHandler( editContext );\n                editHandler._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( 'editInProgress', editHandler._editing );\n                // Need to ensure this handler is active so that save command will call this handler\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                // We need to ensure edit handler and edithandlerState to be in sync.\n                if( editHandler.editStateChangeDispatcher ) {\n                    editHandler.editStateChangeDispatcher( {\n                        type: 'SET_EDIT_STATE_CHANGED',\n                        value: editHandler._editing\n                    } );\n                }\n            } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                _tableInstance.dataProvider._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( _tableInstance.dataProvider._appCtxEditInProgress, _tableInstance.dataProvider._editing );\n            } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                _tableInstance.declViewModel._editing = isEditing;\n                // Add to the appCtx about the editing state\n                appCtxService.updateCtx( _tableInstance.declViewModel._internal.eventTopicEditInProgress, _tableInstance.declViewModel._editing );\n            }\n        }\n\n        // Display guidance message when auto save is off for auto save only table\n        const isAutoSaveContextTrue = appCtxService.getCtx( 'autoSave' ) && appCtxService.getCtx( 'autoSave.dbValue' );\n        if( !isAutoSaveContextTrue && tableElem._tableInstance.gridOptions.forceAutoSave && isEditing && !util.isCellEditing( tableElem ) && !_guidanceMessageInitialized ) {\n            _guidanceMessageInitialized = true;\n            displayAutoSaveOnGuidanceMessage( tableElem );\n        }\n\n        util.setIsCellEditing( tableElem, isEditing );\n    };\n\n    let _cellEditDisabledMessageInitialized = null;\n\n    const isCellSelectedNotEditable = function( cell ) {\n        return cell && cell.isSelected && cell.prop && cell.prop.isEditable === false;\n    };\n\n    /**\n     * Handles the direct edit handling for cell selection\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo the view model object\n     */\n    const handleDirectEdit = function( cell, vmo ) {\n        // Start edit\n        removeCellSelection();\n        // Check if prop isEditable needs to be reset since cache says it is true\n        if( !cell.prop.isEditable ) {\n            cell.prop.isEditable = true;\n            if( vmo.props && vmo.props[ cell.propName ] ) {\n                vmo.props[ cell.propName ].isEditable = true;\n            }\n        }\n        // Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n        // can be editing at any given time.\n        const editContext = getEditContext( _tableInstance );\n        const previousActiveHandler = editHandlerSvc.getActiveEditHandler();\n        if( editContext && previousActiveHandler && previousActiveHandler !== editHandlerSvc.getEditHandler( editContext ) && previousActiveHandler.editInProgress() ) {\n            previousActiveHandler.leaveConfirmation( () => {\n                editHandlerSvc.setActiveEditHandlerContext( editContext );\n                // Reregister leaveHandler since we are making the handler active again without calling startEdit\n                editHandlerSvc.getEditHandler( editContext ).reregisterLeaveHandler();\n                self.editCell( cell, vmo );\n                self.setCellEditingContext( true );\n            } );\n        } else {\n            self.editCell( cell, vmo );\n            self.setCellEditingContext( true );\n        }\n    };\n\n    /**\n     * Handles cell click when pending isEditable Promise\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo The view model object\n     */\n    const handlePendingEditSelection = async function( cell, vmo ) {\n        // Prevent multiple calls to resolve editable promise\n        cell.isCellEditablePromiseResolving = true;\n        await cell.isCellEditablePromise;\n        delete cell.isCellEditablePromiseResolving;\n        if( cell.isSelected ) {\n            if( cell.propIsEditableCache ) {\n                _focusProp = cell.prop;\n                removeCellSelection();\n                // Check if prop isEditable needs to be reset since cache says it is true\n                if( !cell.prop.isEditable ) {\n                    cell.prop.isEditable = true;\n                    if( vmo.props && vmo.props[ cell.propName ] ) {\n                        vmo.props[ cell.propName ].isEditable = true;\n                    }\n                }\n                self.editCell( cell, vmo );\n                self.setCellEditingContext( true );\n            } else {\n                publishCellNotEditable( vmo, cell.prop );\n            }\n        }\n    };\n\n    /**\n     * Click handler for cell/row. Will select the cell and row or start edit as needed\n     *\n     * @param {Event} event the click event\n     * @param {DOMElement} cell the cell in question\n     * @param {ViewModelObject} vmo The vmo for the row\n     */\n    self.onClickHandler = async( event, cell, vmo ) => {\n        if( util.isBulkEditing( tableElem ) ) {\n            return;\n        }\n\n        if( event.ctrlKey ) {\n            triggerBlurHandler();\n            removeCellSelection();\n            updateSelectedCell( null );\n            if( util.isCellHeaderSelectionEnabled( tableElem ) ) {\n                SelectionHelper.setCellHeaderSelection( null, tableElem );\n            }\n            return;\n        }\n\n        if( cell.isSelected && cell.propIsEditableCache && !cell.isElementInEdit ) {\n            handleDirectEdit( cell, vmo );\n        } else if( cell.isSelected && util.isPropEditEnabled( tableElem ) === false && !_cellEditDisabledMessageInitialized ) {\n            // Display guidance message when cell editing is disabled\n            _cellEditDisabledMessageInitialized = true;\n            displayCellEditDisabledGuidanceMessage( tableElem );\n        } else if( cell.isSelected && cell.isCellEditablePromise && !cell.isCellEditablePromiseResolving ) {\n            handlePendingEditSelection( cell, vmo );\n        } else if( !cell.isSelected && !event.shiftKey ) {\n            await updateCellEditability( cell, vmo );\n            _fillDown.enableFillDown( cell );\n            if( util.isCellHeaderSelectionEnabled( tableElem ) ) {\n                SelectionHelper.setCellHeaderSelection( cell, tableElem );\n            }\n        } else if( event.shiftKey ) {\n            triggerBlurHandler();\n            removeCellSelection();\n            updateSelectedCell( null );\n        } else if( !cell.isCellEditablePromiseResolving && isCellSelectedNotEditable( cell ) ) {\n            publishCellNotEditable( vmo, cell.prop );\n        }\n    };\n\n    /**\n     * Adds the onclick event listener for an individual cell and gets its editability\n     * @param {DOMElement} cell - The cell to set the listener for\n     * @param {Object} vmo - The row's VMO\n     */\n    self.addCellClickListener = function( cell, vmo ) {\n        cell.onclick = function( event ) {\n            // if command click or url/anchor tag click don't select/handle select\n            if( !event.target.closest( '.aw-command, a.aw-splm-tablePropertyValueLinks' ) ) {\n                self.onClickHandler( event, cell, vmo );\n            }\n        };\n\n        cell.oncontextmenu = function( event ) {\n            if( !util.isBulkEditing( tableElem ) && !cell.isSelected ) {\n                updateCellEditability( cell, vmo );\n            }\n        };\n    };\n\n    /**\n     * Removes the cell selected classes as well as the selected attribute for the cell.\n     */\n    self.removeAllCellSelection = function() {\n        removeCellSelection();\n        updateSelectedCell();\n    };\n\n    /**\n     * Checks if the current selected cell is on the newly selected vmo(s), if not remove selection\n     * @param {Object} eventData event data\n     */\n    const checkCellAndVMOSelection = function( eventData ) {\n        let selectedObjects = eventData.selectedObjects;\n        if( _selectedCellInfo && _selectedCellInfo.vmoId ) {\n            const vmo = getVmoById( _selectedCellInfo.vmoId );\n            if( selectedObjects.indexOf( vmo ) === -1 ) {\n                self.removeAllCellSelection();\n            }\n        }\n    };\n\n    const isEligibleForCopyDown = function( columnDef ) {\n        if( util.isPropEditEnabled( tableElem ) && columnDef.isTreeNavigation !== true && columnDef.name !== 'icon' && columnDef.modifiable !== false ) {\n            return true;\n        }\n        return false;\n    };\n\n    const copyPropertyToCellContent = function( sourceProperty, vmoUid ) {\n        let cellElements = util.getCellElementsByPropertyAndUid( tableElem, sourceProperty.propertyName, vmoUid );\n        for( let i = 0; i < cellElements.length; i++ ) {\n            let cellElem = cellElements[ i ];\n            let row = cellElem.parentElement;\n            let oldCellTop = cellElem.children[ 0 ];\n            let newCellTop = Cell.createElement( cellElem.columnDef, row.vmo, tableElem, row );\n            if( util.isBulkEditing( tableElem ) ) {\n                newCellTop.classList.add( Const.CLASS_AW_EDITABLE_CELL );\n            }\n            cellElem.replaceChild( newCellTop, oldCellTop );\n        }\n    };\n\n    const copyFillDownProperty = function( targetProperty, sourceProperty ) {\n        targetProperty.uiValue = sourceProperty.uiValue;\n        targetProperty.dbValue = sourceProperty.dbValue;\n        targetProperty.valueUpdated = true;\n        uwPropertyService.updateViewModelProperty( targetProperty );\n    };\n\n    const loadCellEditabilityForTargetCells = function( uid2CellMap, vmos, propertyNames ) {\n        let editOpts = {\n            vmos: vmos,\n            propertyNames: propertyNames,\n            autoSave: util.isAutoSaveEnabled( tableElem )\n        };\n\n        return self.isPropertiesEditablePromise( editOpts ).then( function( result ) {\n            for( let currentVmo of vmos ) {\n                let cell = uid2CellMap[ currentVmo.uid ];\n                if( cell ) {\n                    cell.propIsEditableCache = result === false ? false : cell.prop && cell.prop.isEditable;\n                    if( cell.propIsEditableCache === false ) {\n                        cell.setAttribute( ariaReadOnly, 'true' );\n                    }\n                }\n            }\n            return Promise.resolve( result );\n        } );\n    };\n\n    const modifyPropsForCellEdit = function( result, vmosToEdit, eventData, cellsToSave, cellMap, sourceProp ) {\n        if( result === false ) {\n            return;\n        }\n        let propsModified = false;\n        for( let i = 0; i < vmosToEdit.length; i++ ) {\n            let currentVMO = vmosToEdit[ i ];\n            const targetProp = currentVMO.props[ eventData.propertyName ];\n\n            if( sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable ) {\n                propsModified = true;\n                cellsToSave.push( cellMap[ currentVMO.uid ] );\n                // update the target using the source\n                copyFillDownProperty( targetProp, sourceProp );\n                copyPropertyToCellContent( sourceProp, currentVMO.uid );\n            }\n        }\n        if( propsModified ) {\n            if( util.isAutoSaveEnabled( tableElem ) ) {\n                self.saveEdit( cellsToSave );\n            } else {\n                self.setCellEditingContext( true );\n            }\n        }\n    };\n\n    const prepareTargetCellPropsInfo = function( vmo, eventData, vmosToEdit, columnDef ) {\n        if( isEligibleForCopyDown( columnDef ) ) {\n            vmosToEdit.push( vmo );\n        }\n    };\n\n    const populateTargetCellPropsLegacyEdit = function( vmo, eventData, sourceProp ) {\n        const targetProp = vmo.props[ eventData.propertyName ];\n        if( sourceProp && targetProp && targetProp.isPropertyModifiable && targetProp.editable ) {\n            // update the target using the source\n            copyFillDownProperty( targetProp, sourceProp );\n            copyPropertyToCellContent( sourceProp, vmo.uid );\n        }\n    };\n\n    self.fillDownCompleteHandler = ( eventData ) => {\n        // get the VMOs from the table\n        let VMOs = _tableInstance.dataProvider.viewModelCollection.loadedVMObjects;\n\n        let $source = VMOs.filter( function( vmo ) {\n            return vmo.uid === eventData.source;\n        } );\n\n        let sourceProp = $source[ 0 ] && $source[ 0 ].props[ eventData.propertyName ];\n        let vmosToEdit = [];\n        let cellMap = {};\n        let cellsToSave = [];\n\n        // Reverse the vmo order if we are going down\n        if( eventData.direction !== 'up' ) {\n            VMOs = VMOs.slice().reverse();\n        }\n\n        // Attempt to apply the source value to the target properties\n        let foundLastTarget = false;\n        for( let vmo of VMOs ) {\n            // Iterate over the vmos until we find the last target prop.\n            if( !foundLastTarget && vmo.uid === eventData.endTarget ) {\n                foundLastTarget = true;\n            }\n            if( !foundLastTarget ) {\n                continue;\n            }\n\n            // Stop iterating if we reach the source prop\n            if( vmo.uid === eventData.source ) {\n                break;\n            }\n\n            const columnDef = util.getColumnDef( eventData.propertyName, _tableInstance.dataProvider );\n\n            // Populate target cell props ( bulk edit mode ) or prepare the target prop info ( direct edit )\n            if( util.isBulkEditing( tableElem ) ) {\n                populateTargetCellPropsLegacyEdit( vmo, eventData, sourceProp );\n            } else {\n                const targetCell = util.getCellElementsByPropertyAndUid( tableElem, eventData.propertyName, vmo.uid )[ 0 ];\n                if( targetCell ) {\n                    cellMap[ vmo.uid ] = targetCell;\n                }\n                prepareTargetCellPropsInfo( vmo, eventData, vmosToEdit, columnDef );\n            }\n        }\n\n        // Load editabilty and apply value to editable cells\n        if( !util.isBulkEditing( tableElem ) ) {\n            _fillDownSaveInprogress = true;\n            let propertyNames = [ eventData.propertyName ];\n            loadCellEditabilityForTargetCells( cellMap, vmosToEdit, propertyNames ).then( ( result ) => {\n                modifyPropsForCellEdit( result, vmosToEdit, eventData, cellsToSave, cellMap,\n                    sourceProp );\n                _fillDownSaveInprogress = false;\n            } );\n        }\n    };\n\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectNone`, self.removeAllCellSelection ) );\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectAll`, self.removeAllCellSelection ) );\n    _eventBusSubs.push( eventBus.subscribe( `${_tableInstance.dataProvider.name}.selectionChangeEvent`, checkCellAndVMOSelection ) );\n};\n\nexport default SPLMTableEditor;\n"]},"metadata":{},"sourceType":"module"}