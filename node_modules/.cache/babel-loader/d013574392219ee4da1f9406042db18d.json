{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\components\\\\src\\\\js\\\\AwTileCanvasService.js\";\nimport AwTileGroup from 'viewmodel/AwTileGroupViewModel';\nimport domUtils from 'js/domUtils';\nimport eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport tileDragSvc from 'js/tileDragService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst eleRef = domUtils.DOMAPIs;\nexport const awTileCanvasRenderFunction = props => {\n  const {\n    viewModel,\n    ctxMin,\n    actions,\n    i18n,\n    fields,\n    grids,\n    formProp,\n    messages,\n    ...prop\n  } = props;\n  const {\n    data\n  } = viewModel;\n  const {\n    dndHandler\n  } = prop;\n  let callback = getStartTileEditFn(viewModel, prop);\n  let subscriptions = viewModel.data.subscriptions;\n  let subscribedEventsStr = getEventSubscribtionsList(subscriptions);\n\n  if (_.isEmpty(viewModel.data.tileGroups) && !_.isEmpty(prop.tileGroups)) {\n    initialize(prop, viewModel);\n  }\n\n  const unPinTileCallback = () => {\n    if (!_.isEmpty(viewModel.data.tileGroups)) {\n      resetTilesEditFlag(viewModel);\n\n      _.defer(function () {\n        prop.unPinTileCallback && prop.unPinTileCallback(viewModel);\n      });\n    }\n  };\n\n  const tileClickCallback = () => {\n    if (!_.isEmpty(viewModel.data.tileGroups)) {\n      let vmprop = { ...viewModel.getData()\n      };\n      vmprop.isGatewayInEditMode = false;\n      viewModel.dispatch({\n        path: 'data',\n        value: { ...vmprop\n        }\n      });\n\n      _.defer(function () {\n        prop.tileClickCallback && prop.tileClickCallback(viewModel);\n      });\n    }\n  };\n\n  const handleDrag = (event, target, targetVMO) => {\n    if (dndHandler && dndHandler[event.type]) {\n      let fun = dndHandler[event.type];\n      fun(event, {\n        targetElement: target,\n        targetVMO: targetVMO\n      });\n    }\n  };\n\n  const handleDrop = (event, target, targetVMO) => {\n    if (dndHandler && dndHandler[event.type]) {\n      let funDrop = dndHandler[event.type];\n      funDrop(event, {\n        targetElement: target,\n        targetVMO: targetVMO\n      });\n    }\n  };\n\n  const handleDragAndDrop = {\n    drag: handleDrag,\n    drop: handleDrop,\n    draggable: true\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"aw-tile-canvas\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      \"data-locator\": \"tile-canvas\",\n      className: getCanvasClass(viewModel),\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"aw-tile-mainContainer aw-layout-flexColumnContainer\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"aw-tile-tileGroups aw-layout-flexRowContainer\",\n          children: [(prop.tileGroups || []).map((tileGroup, index) => createTileGroup(index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, e => {\n            callback(e);\n            tileGroup.toggleEdit && tileGroup.toggleEdit();\n          })), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"aw-tile-tileGroups\",\n            children: /*#__PURE__*/_jsxDEV(AwTileGroup, {\n              tileGroup: data.dummyTileGroup\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 76,\n              columnNumber: 29\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 65,\n    columnNumber: 9\n  }, this);\n};\n\nconst initialize = (prop, viewModel) => {\n  let data = { ...viewModel.getData()\n  };\n  data.tileGroups = prop.tileGroups || [];\n  viewModel.dispatch({\n    path: 'data',\n    value: { ...data\n    }\n  });\n};\n\nconst getCanvasClass = viewModel => {\n  let canvasClass = ['aw-tile-tileCanvasPanel aw-layout-flexColumn'];\n  canvasClass.push(viewModel.data.isGatewayInEditMode ? 'aw-tile-editMode' : '');\n  return canvasClass.join(' ');\n};\n\nconst createTileGroup = (index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, callback) => {\n  tileGroup.editTileCallback = callback;\n  tileGroup.isGatewayInEditMode = viewModel.data.isGatewayInEditMode; //tileGroup.handleDragAndDrop = handleDragAndDrop;\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: getTileGroupClass(tileGroup),\n    children: /*#__PURE__*/_jsxDEV(AwTileGroup, {\n      tileGroup: tileGroup,\n      handleDragAndDrop: handleDragAndDrop,\n      unPinTileCallback: unPinTileCallback,\n      tileClickCallback: tileClickCallback\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 13\n    }, this)\n  }, index, false, {\n    fileName: _jsxFileName,\n    lineNumber: 102,\n    columnNumber: 9\n  }, this);\n};\n\nconst getTileGroupClass = tileGroup => {\n  let tileGroupClass = ['aw-tile-tileGroup aw-layout-flexRowContainer'];\n  tileGroupClass.push(tileGroup.tiles.length === 0 ? 'aw-tile-emptyTileGroup' : '');\n  return tileGroupClass.join(' ');\n};\n/**\n * Callback Fn triggered from AwTile for tile edit\n * @param {*} viewModel viewModel\n * @returns {*} anonymous function triggered on 'contextmenu'\n */\n\n\nlet _removeHanlder = [];\n\nconst getStartTileEditFn = (viewModel, prop) => {\n  let canvasViewModel = { ...viewModel\n  };\n  return event => {\n    let data = { ...canvasViewModel.getData()\n    };\n    data.isGatewayInEditMode = true;\n    canvasViewModel.dispatch({\n      path: 'data',\n      value: { ...data\n      }\n    });\n    emptyHandler();\n    let handler = handleDocumentClick.bind(null, canvasViewModel, prop);\n    document.addEventListener('click', handler);\n    document.addEventListener('touchstart', handler);\n\n    _removeHanlder.push(() => document.removeEventListener('click', handler));\n\n    _removeHanlder.push(() => document.removeEventListener('touchstart', handler));\n  };\n};\n/**\n *\n * @param {*} viewModel canvasViewModel\n * @param {*} event onClick MouseEvent\n */\n\n\nconst handleDocumentClick = function (viewModel, prop, event) {\n  if (event && event.target && event.target.parentElement) {\n    let isEditingTile = domUtils.DOMAPIs.closest(event.target, '.aw-tile-tileContainer');\n\n    if (!isEditingTile || isEditingTile.length === 0) {\n      stopEditing(viewModel, prop);\n    }\n  }\n};\n\nconst stopEditing = (viewModel, prop) => {\n  resetTilesEditFlag(viewModel);\n  let dirtyTiles = findDirtyTiles(viewModel);\n\n  if (dirtyTiles && dirtyTiles.tiles.length > 0) {\n    eventBus.publish('gateway.updateTile', dirtyTiles);\n    prop.updateTileCallback && prop.updateTileCallback();\n  }\n\n  emptyHandler();\n};\n\nconst emptyHandler = () => {\n  if (_removeHanlder.length > 0) {\n    _removeHanlder.forEach(tile => tile());\n\n    _removeHanlder = [];\n  }\n};\n\nconst resetTilesEditFlag = viewModel => {\n  _.forEach(viewModel.data.tileGroups, tileGroup => {\n    if (tileGroup && tileGroup.tiles) {\n      _.forEach(tileGroup.tiles, tile => {\n        if (tile && tile.editing) {\n          delete tile.editing;\n        }\n      });\n    }\n  });\n\n  let vmprop = { ...viewModel.getData()\n  };\n  vmprop.isGatewayInEditMode = false;\n  viewModel.dispatch({\n    path: 'data',\n    value: { ...vmprop\n    }\n  });\n};\n\nconst findDirtyTiles = viewModel => {\n  var dirtyTiles = {};\n  dirtyTiles.tiles = [];\n  dirtyTiles.groupNames = [];\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup) {\n    if (tileGroup && tileGroup.tiles) {\n      _.forEach(tileGroup.tiles, function (tile) {\n        if (tile && tile.isDirty) {\n          // reset dirty state and return the tile info\n          delete tile.isDirty;\n          delete tile.$$hashKey;\n\n          _.forEach(tile.content, function (content) {\n            if (content) {\n              delete content.$$hashKey;\n            }\n          });\n\n          dirtyTiles.tiles.push(tile);\n          dirtyTiles.groupNames.push(tileGroup.groupName);\n        }\n      });\n    }\n  });\n\n  return dirtyTiles;\n};\n\nconst getEventSubscribtionsList = subscriptions => {\n  let subscribedEventsStr = [];\n\n  if (subscriptions.length !== 0) {\n    subscriptions.map(eventSubscribed => {\n      subscribedEventsStr.push(eventSubscribed.topic);\n    });\n  }\n\n  return subscribedEventsStr;\n};\n/**\n * Create New Tile Group while DnD tiles\n *\n * @param {*} sourceTile sourceTile\n * @param {*} sourceGroupName sourceGroupName\n * @param {*} targetTileGroup targetTileGroup\n */\n\n\nexport const createNewTileGroup = (sourceTile, sourceGroupName, targetTileGroup) => {\n  //TODO: hook viewModel while working on Drag n Drop. May be pass from the DnD service or something\n  let viewModel;\n  var sourceGroup = getTileGroup(viewModel, sourceGroupName);\n  var sourceGroupIndx = viewModel && viewModel.data.tileGroups.indexOf(sourceGroup);\n  var targetGroupIndx = viewModel && viewModel.tileGroups.indexOf(targetTileGroup);\n  var sourceTileIn = retrieveTileInTileGroup(viewModel, sourceTile, sourceGroupIndx);\n  var sourceTileIndx = viewModel && viewModel.data.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n  var baseOrder = 0;\n  var newGroupIncrement = 100;\n\n  if (targetTileGroup && targetTileGroup.tiles.length > 0) {\n    baseOrder = tileDragSvc.getBaseOrder(targetTileGroup.tiles[0].orderNumber);\n  } // remove tile from source group\n\n\n  var srcGroup = viewModel && viewModel.data.tileGroups[sourceGroupIndx];\n  srcGroup.tiles.splice(sourceTileIndx, 1);\n  var srcGroupNull = false; // If we removed the last tile in the group\n\n  if (srcGroup.tiles.length === 0) {\n    srcGroupNull = true;\n  } // create new group using current time\n\n\n  var newGroup = {};\n  newGroup.groupName = 'group' + new Date().getTime(); // add sourceTile to newly created group\n\n  newGroup.tiles = [];\n  newGroup.tiles.push(sourceTileIn);\n  newGroup.tiles.forEach(function (tile, indx) {\n    tile.orderNumber = baseOrder + newGroupIncrement + indx;\n    tile.isDirty = true;\n  }); // update tileGroups array\n\n  if (sourceGroupIndx === targetGroupIndx && srcGroupNull) {\n    viewModel && viewModel.data.tileGroups.splice(targetGroupIndx, 0, newGroup);\n  } else {\n    viewModel && viewModel.data.tileGroups.splice(targetGroupIndx + 1, 0, newGroup);\n  }\n\n  var newGroupIndx = viewModel && viewModel.data.tileGroups.indexOf(newGroup); // update order number for all tiles in each and every tile group\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup, index) {\n    if (index > newGroupIndx && tileGroup.tiles.length > 0) {\n      var grpBaseOrder = tileDragSvc.getBaseOrder(tileGroup.tiles[0].orderNumber);\n      tileGroup.tiles.map(function (tile, indx) {\n        tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n        return tile;\n      });\n    }\n  });\n\n  viewModel && viewModel.dispatch({\n    path: 'data',\n    value: { ...viewModel.data\n    }\n  });\n};\n\nconst getTileGroup = (viewModel, groupName) => {\n  var tileGroupIn;\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup) {\n    if (tileGroup.groupName === groupName) {\n      tileGroupIn = tileGroup;\n      return false;\n    }\n\n    return null;\n  });\n\n  return tileGroupIn;\n};\n\nconst retrieveTileInTileGroup = (viewModel, tile, groupIndex) => {\n  var retrievedTile;\n\n  if (viewModel && viewModel.data.tileGroups[groupIndex] && !_.isEmpty(viewModel && viewModel.data.tileGroups[groupIndex].tiles)) {\n    _.forEach(viewModel.data.tileGroups[groupIndex].tiles, function (tileObj) {\n      if (_.isEqual(tileObj, tile)) {\n        retrievedTile = tileObj;\n        return false;\n      }\n\n      return null;\n    });\n  }\n\n  return retrievedTile;\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/components/src/js/AwTileCanvasService.js"],"names":["eleRef","domUtils","awTileCanvasRenderFunction","props","prop","data","dndHandler","callback","getStartTileEditFn","subscriptions","viewModel","subscribedEventsStr","getEventSubscribtionsList","_","initialize","unPinTileCallback","resetTilesEditFlag","tileClickCallback","vmprop","path","value","handleDrag","event","fun","targetElement","targetVMO","handleDrop","funDrop","handleDragAndDrop","drag","drop","draggable","getCanvasClass","createTileGroup","e","tileGroup","dummyTileGroup","canvasClass","getTileGroupClass","tileGroupClass","_removeHanlder","canvasViewModel","emptyHandler","handler","handleDocumentClick","document","isEditingTile","stopEditing","dirtyTiles","findDirtyTiles","eventBus","tile","content","eventSubscribed","createNewTileGroup","sourceGroup","getTileGroup","sourceGroupIndx","targetGroupIndx","sourceTileIn","retrieveTileInTileGroup","sourceTileIndx","baseOrder","newGroupIncrement","targetTileGroup","tileDragSvc","srcGroup","srcGroupNull","newGroup","newGroupIndx","index","grpBaseOrder","tileGroupIn","retrievedTile"],"mappings":";AAAA,OAAA,WAAA,MAAA,gCAAA;AACA,OAAA,QAAA,MAAA,aAAA;AACA,OAAA,QAAA,MAAA,aAAA;AACA,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,WAAA,MAAA,oBAAA;;AACA,MAAMA,MAAM,GAAGC,QAAQ,CAAvB,OAAA;AAEA,OAAO,MAAMC,0BAA0B,GAAKC,KAAF,IAAa;EACnD,MAAM;IAAA,SAAA;IAAA,MAAA;IAAA,OAAA;IAAA,IAAA;IAAA,MAAA;IAAA,KAAA;IAAA,QAAA;IAAA,QAAA;IASF,GAAGC;EATD,IAAN,KAAA;EAWA,MAAM;IAAEC;EAAF,IAAN,SAAA;EACA,MAAM;IAAEC;EAAF,IAAN,IAAA;EACA,IAAIC,QAAQ,GAAGC,kBAAkB,CAAA,SAAA,EAAjC,IAAiC,CAAjC;EACA,IAAIC,aAAa,GAAGC,SAAS,CAATA,IAAAA,CAApB,aAAA;EACA,IAAIC,mBAAmB,GAAGC,yBAAyB,CAAnD,aAAmD,CAAnD;;EAEA,IAAIC,CAAC,CAADA,OAAAA,CAAWH,SAAS,CAATA,IAAAA,CAAXG,UAAAA,KAA0C,CAACA,CAAC,CAADA,OAAAA,CAAWT,IAAI,CAA9D,UAA+CS,CAA/C,EAA8E;IAC1EC,UAAU,CAAA,IAAA,EAAVA,SAAU,CAAVA;EACH;;EAED,MAAMC,iBAAiB,GAAG,MAAM;IAC5B,IAAI,CAACF,CAAC,CAADA,OAAAA,CAAWH,SAAS,CAATA,IAAAA,CAAhB,UAAKG,CAAL,EAA8C;MAC1CG,kBAAkB,CAAlBA,SAAkB,CAAlBA;;MACAH,CAAC,CAADA,KAAAA,CAAS,YAAW;QAChBT,IAAI,CAAJA,iBAAAA,IAA0BA,IAAI,CAAJA,iBAAAA,CAA1BA,SAA0BA,CAA1BA;MADJS,CAAAA;IAGH;EANL,CAAA;;EASA,MAAMI,iBAAiB,GAAG,MAAM;IAC5B,IAAI,CAACJ,CAAC,CAADA,OAAAA,CAAWH,SAAS,CAATA,IAAAA,CAAhB,UAAKG,CAAL,EAA8C;MAC1C,IAAIK,MAAM,GAAG,EAAE,GAAGR,SAAS,CAATA,OAAAA;MAAL,CAAb;MACAQ,MAAM,CAANA,mBAAAA,GAAAA,KAAAA;MACAR,SAAS,CAATA,QAAAA,CAAoB;QAAES,IAAI,EAAN,MAAA;QAAgBC,KAAK,EAAE,EAAE,GAAGF;QAAL;MAAvB,CAApBR;;MACAG,CAAC,CAADA,KAAAA,CAAS,YAAW;QAChBT,IAAI,CAAJA,iBAAAA,IAA0BA,IAAI,CAAJA,iBAAAA,CAA1BA,SAA0BA,CAA1BA;MADJS,CAAAA;IAGH;EARL,CAAA;;EAWA,MAAMQ,UAAU,GAAG,CAAA,KAAA,EAAA,MAAA,EAAA,SAAA,KAAkC;IACjD,IAAIf,UAAU,IAAIA,UAAU,CAAEgB,KAAK,CAAnC,IAA4B,CAA5B,EAA6C;MACzC,IAAIC,GAAG,GAAGjB,UAAU,CAAEgB,KAAK,CAA3B,IAAoB,CAApB;MACAC,GAAG,CAAA,KAAA,EAAS;QAAEC,aAAa,EAAf,MAAA;QAAyBC,SAAS,EAAEA;MAApC,CAAT,CAAHF;IACH;EAJL,CAAA;;EAOA,MAAMG,UAAU,GAAG,CAAA,KAAA,EAAA,MAAA,EAAA,SAAA,KAAkC;IACjD,IAAIpB,UAAU,IAAIA,UAAU,CAAEgB,KAAK,CAAnC,IAA4B,CAA5B,EAA6C;MACzC,IAAIK,OAAO,GAAGrB,UAAU,CAAEgB,KAAK,CAA/B,IAAwB,CAAxB;MACAK,OAAO,CAAA,KAAA,EAAS;QAAEH,aAAa,EAAf,MAAA;QAAyBC,SAAS,EAAEA;MAApC,CAAT,CAAPE;IACH;EAJL,CAAA;;EAMA,MAAMC,iBAAiB,GAAG;IAAEC,IAAI,EAAN,UAAA;IAAoBC,IAAI,EAAxB,UAAA;IAAsCC,SAAS,EAAE;EAAjD,CAA1B;EACA,OAAA,aACI,OAAA,CAAA,KAAA,EAAA;IAAK,SAAS,EAAd,gBAAA;IAAA,QAAA,EAAA,aACI,OAAA,CAAA,KAAA,EAAA;MAAK,gBAAL,aAAA;MAAgC,SAAS,EAAEC,cAAc,CAAzD,SAAyD,CAAzD;MAAA,QAAA,EAAA,aACI,OAAA,CAAA,KAAA,EAAA;QAAK,SAAS,EAAd,qDAAA;QAAA,QAAA,EAAA,aACI,OAAA,CAAA,KAAA,EAAA;UAAK,SAAS,EAAd,+CAAA;UAAA,QAAA,EAAA,CAEQ,CAAE5B,IAAI,CAAJA,UAAAA,IAAF,EAAA,EAAA,GAAA,CAA+B,CAAA,SAAA,EAAA,KAAA,KAAuB6B,eAAe,CAAA,KAAA,EAAA,SAAA,EAAA,SAAA,EAAA,iBAAA,EAAA,iBAAA,EAAA,iBAAA,EAA0FC,CAAF,IAAQ;YACjK3B,QAAQ,CAARA,CAAQ,CAARA;YACA4B,SAAS,CAATA,UAAAA,IAAwBA,SAAS,CAAjCA,UAAwBA,EAAxBA;UAJZ,CAE6E,CAArE,CAFR,EAAA,aAOI,OAAA,CAAA,KAAA,EAAA;YAAK,SAAS,EAAd,oBAAA;YAAA,QAAA,EAAA,aACI,OAAA,CAAA,WAAA,EAAA;cAAa,SAAS,EAAE9B,IAAI,CAAC+B;YAA7B,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;cAAA,QAAA,EAAA,YAAA;cAAA,UAAA,EAAA,EAAA;cAAA,YAAA,EAAA;YAAA,CAAA,EAAA,IAAA;UADJ,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;YAAA,QAAA,EAAA,YAAA;YAAA,UAAA,EAAA,EAAA;YAAA,YAAA,EAAA;UAAA,CAAA,EAPJ,IAOI,CAPJ;QAAA,CAAA,EAAA,KAAA,CAAA,EAAA,IAAA,EAAA;UAAA,QAAA,EAAA,YAAA;UAAA,UAAA,EAAA,EAAA;UAAA,YAAA,EAAA;QAAA,CAAA,EAAA,IAAA;MADJ,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;QAAA,QAAA,EAAA,YAAA;QAAA,UAAA,EAAA,EAAA;QAAA,YAAA,EAAA;MAAA,CAAA,EAAA,IAAA;IADJ,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;MAAA,QAAA,EAAA,YAAA;MAAA,UAAA,EAAA,EAAA;MAAA,YAAA,EAAA;IAAA,CAAA,EAAA,IAAA;EADJ,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;IAAA,QAAA,EAAA,YAAA;IAAA,UAAA,EAAA,EAAA;IAAA,YAAA,EAAA;EAAA,CAAA,EADJ,IACI,CADJ;AAxDG,CAAA;;AA6EP,MAAMtB,UAAU,GAAG,CAAA,IAAA,EAAA,SAAA,KAAuB;EACtC,IAAIT,IAAI,GAAG,EAAE,GAAGK,SAAS,CAATA,OAAAA;EAAL,CAAX;EACAL,IAAI,CAAJA,UAAAA,GAAkBD,IAAI,CAAJA,UAAAA,IAAlBC,EAAAA;EACAK,SAAS,CAATA,QAAAA,CAAoB;IAAES,IAAI,EAAN,MAAA;IAAgBC,KAAK,EAAE,EAAE,GAAGf;IAAL;EAAvB,CAApBK;AAHJ,CAAA;;AAMA,MAAMsB,cAAc,GAAKtB,SAAF,IAAiB;EACpC,IAAI2B,WAAW,GAAG,CAAlB,8CAAkB,CAAlB;EACAA,WAAW,CAAXA,IAAAA,CAAkB3B,SAAS,CAATA,IAAAA,CAAAA,mBAAAA,GAAAA,kBAAAA,GAAlB2B,EAAAA;EACA,OAAOA,WAAW,CAAXA,IAAAA,CAAP,GAAOA,CAAP;AAHJ,CAAA;;AAMA,MAAMJ,eAAe,GAAG,CAAA,KAAA,EAAA,SAAA,EAAA,SAAA,EAAA,iBAAA,EAAA,iBAAA,EAAA,iBAAA,EAAA,QAAA,KAAsG;EAC1HE,SAAS,CAATA,gBAAAA,GAAAA,QAAAA;EACAA,SAAS,CAATA,mBAAAA,GAAgCzB,SAAS,CAATA,IAAAA,CAF0F,mBAE1HyB,CAF0H,CAG1H;;EACA,OAAA,aACI,OAAA,CAAA,KAAA,EAAA;IAAiB,SAAS,EAAEG,iBAAiB,CAA7C,SAA6C,CAA7C;IAAA,QAAA,EAAA,aACI,OAAA,CAAA,WAAA,EAAA;MAAa,SAAS,EAAtB,SAAA;MAAmC,iBAAiB,EAApD,iBAAA;MAAyE,iBAAiB,EAA1F,iBAAA;MAA+G,iBAAiB,EAAErB;IAAlI,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,EAAA;MAAA,QAAA,EAAA,YAAA;MAAA,UAAA,EAAA,GAAA;MAAA,YAAA,EAAA;IAAA,CAAA,EAAA,IAAA;EADJ,CAAA,EAAA,KAAA,EAAA,KAAA,EAAA;IAAA,QAAA,EAAA,YAAA;IAAA,UAAA,EAAA,GAAA;IAAA,YAAA,EAAA;EAAA,CAAA,EADJ,IACI,CADJ;AAJJ,CAAA;;AAWA,MAAMqB,iBAAiB,GAAKH,SAAF,IAAiB;EACvC,IAAII,cAAc,GAAG,CAArB,8CAAqB,CAArB;EACAA,cAAc,CAAdA,IAAAA,CAAqBJ,SAAS,CAATA,KAAAA,CAAAA,MAAAA,KAAAA,CAAAA,GAAAA,wBAAAA,GAArBI,EAAAA;EACA,OAAOA,cAAc,CAAdA,IAAAA,CAAP,GAAOA,CAAP;AAHJ,CAAA;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,cAAc,GAAlB,EAAA;;AACA,MAAMhC,kBAAkB,GAAG,CAAA,SAAA,EAAA,IAAA,KAAuB;EAC9C,IAAIiC,eAAe,GAAG,EAAE,GAAG/B;EAAL,CAAtB;EACA,OAASY,KAAF,IAAa;IAChB,IAAIjB,IAAI,GAAG,EAAE,GAAGoC,eAAe,CAAfA,OAAAA;IAAL,CAAX;IACApC,IAAI,CAAJA,mBAAAA,GAAAA,IAAAA;IACAoC,eAAe,CAAfA,QAAAA,CAA0B;MAAEtB,IAAI,EAAN,MAAA;MAAgBC,KAAK,EAAE,EAAE,GAAGf;MAAL;IAAvB,CAA1BoC;IACAC,YAAY;IAEZ,IAAIC,OAAO,GAAGC,mBAAmB,CAAnBA,IAAAA,CAAAA,IAAAA,EAAAA,eAAAA,EAAd,IAAcA,CAAd;IAEAC,QAAQ,CAARA,gBAAAA,CAAAA,OAAAA,EAAAA,OAAAA;IACAA,QAAQ,CAARA,gBAAAA,CAAAA,YAAAA,EAAAA,OAAAA;;IAEAL,cAAc,CAAdA,IAAAA,CAAqB,MAAMK,QAAQ,CAARA,mBAAAA,CAAAA,OAAAA,EAA3BL,OAA2BK,CAA3BL;;IACAA,cAAc,CAAdA,IAAAA,CAAqB,MAAMK,QAAQ,CAARA,mBAAAA,CAAAA,YAAAA,EAA3BL,OAA2BK,CAA3BL;EAZJ,CAAA;AAFJ,CAAA;AAkBA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,mBAAmB,GAAG,UAAA,SAAA,EAAA,IAAA,EAAA,KAAA,EAAmC;EAC3D,IAAItB,KAAK,IAAIA,KAAK,CAAdA,MAAAA,IAAyBA,KAAK,CAALA,MAAAA,CAA7B,aAAA,EAA0D;IACtD,IAAIwB,aAAa,GAAG7C,QAAQ,CAARA,OAAAA,CAAAA,OAAAA,CAA0BqB,KAAK,CAA/BrB,MAAAA,EAApB,wBAAoBA,CAApB;;IACA,IAAI,CAAA,aAAA,IAAkB6C,aAAa,CAAbA,MAAAA,KAAtB,CAAA,EAAmD;MAC/CC,WAAW,CAAA,SAAA,EAAXA,IAAW,CAAXA;IACH;EACJ;AANL,CAAA;;AASA,MAAMA,WAAW,GAAG,CAAA,SAAA,EAAA,IAAA,KAAuB;EACvC/B,kBAAkB,CAAlBA,SAAkB,CAAlBA;EAEA,IAAIgC,UAAU,GAAGC,cAAc,CAA/B,SAA+B,CAA/B;;EACA,IAAID,UAAU,IAAIA,UAAU,CAAVA,KAAAA,CAAAA,MAAAA,GAAlB,CAAA,EAAgD;IAC5CE,QAAQ,CAARA,OAAAA,CAAAA,oBAAAA,EAAAA,UAAAA;IACA9C,IAAI,CAAJA,kBAAAA,IAA2BA,IAAI,CAA/BA,kBAA2BA,EAA3BA;EACH;;EAEDsC,YAAY;AAThB,CAAA;;AAYA,MAAMA,YAAY,GAAG,MAAM;EACvB,IAAIF,cAAc,CAAdA,MAAAA,GAAJ,CAAA,EAAgC;IAC5BA,cAAc,CAAdA,OAAAA,CAA0BW,IAAF,IAAYA,IAApCX,EAAAA;;IACAA,cAAc,GAAdA,EAAAA;EACH;AAJL,CAAA;;AAOA,MAAMxB,kBAAkB,GAAKN,SAAF,IAAiB;EACxCG,CAAC,CAADA,OAAAA,CAAWH,SAAS,CAATA,IAAAA,CAAXG,UAAAA,EAAwCsB,SAAF,IAAiB;IACnD,IAAIA,SAAS,IAAIA,SAAS,CAA1B,KAAA,EAAmC;MAC/BtB,CAAC,CAADA,OAAAA,CAAWsB,SAAS,CAApBtB,KAAAA,EAA8BsC,IAAF,IAAY;QACpC,IAAIA,IAAI,IAAIA,IAAI,CAAhB,OAAA,EAA2B;UACvB,OAAOA,IAAI,CAAX,OAAA;QACH;MAHLtC,CAAAA;IAKH;EAPLA,CAAAA;;EASA,IAAIK,MAAM,GAAG,EAAE,GAAGR,SAAS,CAATA,OAAAA;EAAL,CAAb;EACAQ,MAAM,CAANA,mBAAAA,GAAAA,KAAAA;EACAR,SAAS,CAATA,QAAAA,CAAoB;IAAES,IAAI,EAAN,MAAA;IAAgBC,KAAK,EAAE,EAAE,GAAGF;IAAL;EAAvB,CAApBR;AAZJ,CAAA;;AAeA,MAAMuC,cAAc,GAAKvC,SAAF,IAAiB;EACpC,IAAIsC,UAAU,GAAd,EAAA;EACAA,UAAU,CAAVA,KAAAA,GAAAA,EAAAA;EACAA,UAAU,CAAVA,UAAAA,GAAAA,EAAAA;;EAEAnC,CAAC,CAADA,OAAAA,CAAYH,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAzBG,UAAAA,EAAoD,UAAA,SAAA,EAAsB;IACtE,IAAIsB,SAAS,IAAIA,SAAS,CAA1B,KAAA,EAAmC;MAC/BtB,CAAC,CAADA,OAAAA,CAAWsB,SAAS,CAApBtB,KAAAA,EAA4B,UAAA,IAAA,EAAiB;QACzC,IAAIsC,IAAI,IAAIA,IAAI,CAAhB,OAAA,EAA2B;UACvB;UACA,OAAOA,IAAI,CAAX,OAAA;UACA,OAAOA,IAAI,CAAX,SAAA;;UACAtC,CAAC,CAADA,OAAAA,CAAWsC,IAAI,CAAftC,OAAAA,EAAyB,UAAA,OAAA,EAAoB;YACzC,IAAA,OAAA,EAAc;cACV,OAAOuC,OAAO,CAAd,SAAA;YACH;UAHLvC,CAAAA;;UAMAmC,UAAU,CAAVA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA;UACAA,UAAU,CAAVA,UAAAA,CAAAA,IAAAA,CAA4Bb,SAAS,CAArCa,SAAAA;QACH;MAbLnC,CAAAA;IAeH;EAjBLA,CAAAA;;EAoBA,OAAA,UAAA;AAzBJ,CAAA;;AA4BA,MAAMD,yBAAyB,GAAKH,aAAF,IAAqB;EACnD,IAAIE,mBAAmB,GAAvB,EAAA;;EACA,IAAIF,aAAa,CAAbA,MAAAA,KAAJ,CAAA,EAAiC;IAC7BA,aAAa,CAAbA,GAAAA,CAAqB4C,eAAF,IAAuB;MACtC1C,mBAAmB,CAAnBA,IAAAA,CAA0B0C,eAAe,CAAzC1C,KAAAA;IADJF,CAAAA;EAGH;;EACD,OAAA,mBAAA;AAPJ,CAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAM6C,kBAAkB,GAAG,CAAA,UAAA,EAAA,eAAA,EAAA,eAAA,KAAoD;EAClF;EACA,IAAA,SAAA;EAEA,IAAIC,WAAW,GAAGC,YAAY,CAAA,SAAA,EAA9B,eAA8B,CAA9B;EACA,IAAIC,eAAe,GAAG/C,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,OAAAA,CAAnC,WAAmCA,CAAnC;EACA,IAAIgD,eAAe,GAAGhD,SAAS,IAAIA,SAAS,CAATA,UAAAA,CAAAA,OAAAA,CAAnC,eAAmCA,CAAnC;EAEA,IAAIiD,YAAY,GAAGC,uBAAuB,CAAA,SAAA,EAAA,UAAA,EAA1C,eAA0C,CAA1C;EACA,IAAIC,cAAc,GAAGnD,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,eAAAA,EAAAA,KAAAA,CAAAA,OAAAA,CAAlC,YAAkCA,CAAlC;EAEA,IAAIoD,SAAS,GAAb,CAAA;EACA,IAAIC,iBAAiB,GAArB,GAAA;;EACA,IAAIC,eAAe,IAAIA,eAAe,CAAfA,KAAAA,CAAAA,MAAAA,GAAvB,CAAA,EAA0D;IACtDF,SAAS,GAAGG,WAAW,CAAXA,YAAAA,CAA0BD,eAAe,CAAfA,KAAAA,CAAAA,CAAAA,EAAtCF,WAAYG,CAAZH;EAd8E,CAAA,CAiBlF;;;EACA,IAAII,QAAQ,GAAGxD,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAA5B,eAA4BA,CAA5B;EACAwD,QAAQ,CAARA,KAAAA,CAAAA,MAAAA,CAAAA,cAAAA,EAAAA,CAAAA;EAEA,IAAIC,YAAY,GArBkE,KAqBlF,CArBkF,CAsBlF;;EACA,IAAID,QAAQ,CAARA,KAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAAkC;IAC9BC,YAAY,GAAZA,IAAAA;EAxB8E,CAAA,CA2BlF;;;EACA,IAAIC,QAAQ,GAAZ,EAAA;EACAA,QAAQ,CAARA,SAAAA,GAAqB,UAAU,IAAA,IAAA,GA7BmD,OA6BnD,EAA/BA,CA7BkF,CA+BlF;;EACAA,QAAQ,CAARA,KAAAA,GAAAA,EAAAA;EACAA,QAAQ,CAARA,KAAAA,CAAAA,IAAAA,CAAAA,YAAAA;EAEAA,QAAQ,CAARA,KAAAA,CAAAA,OAAAA,CAAwB,UAAA,IAAA,EAAA,IAAA,EAAuB;IAC3CjB,IAAI,CAAJA,WAAAA,GAAmBW,SAAS,GAATA,iBAAAA,GAAnBX,IAAAA;IACAA,IAAI,CAAJA,OAAAA,GAAAA,IAAAA;EArC8E,CAmClFiB,EAnCkF,CAwClF;;EACA,IAAIX,eAAe,KAAfA,eAAAA,IAAJ,YAAA,EAA0D;IACtD/C,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,eAAAA,EAAAA,CAAAA,EAAbA,QAAaA,CAAbA;EADJ,CAAA,MAEO;IACHA,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAkCgD,eAAe,GAAjDhD,CAAAA,EAAAA,CAAAA,EAAbA,QAAaA,CAAbA;EACH;;EAED,IAAI2D,YAAY,GAAG3D,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,OAAAA,CA/CkD,QA+ClDA,CAAhC,CA/CkF,CAiDlF;;EACAG,CAAC,CAADA,OAAAA,CAAWH,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAxBG,UAAAA,EAAmD,UAAA,SAAA,EAAA,KAAA,EAA6B;IAC5E,IAAIyD,KAAK,GAALA,YAAAA,IAAwBnC,SAAS,CAATA,KAAAA,CAAAA,MAAAA,GAA5B,CAAA,EAAyD;MACrD,IAAIoC,YAAY,GAAGN,WAAW,CAAXA,YAAAA,CAA0B9B,SAAS,CAATA,KAAAA,CAAAA,CAAAA,EAA7C,WAAmB8B,CAAnB;MACA9B,SAAS,CAATA,KAAAA,CAAAA,GAAAA,CAAqB,UAAA,IAAA,EAAA,IAAA,EAAuB;QACxCgB,IAAI,CAAJA,WAAAA,GAAmBoB,YAAY,GAAZA,iBAAAA,GAAnBpB,IAAAA;QACAA,IAAI,CAAJA,OAAAA,GAAAA,IAAAA;QACA,OAAA,IAAA;MAHJhB,CAAAA;IAKH;EARLtB,CAAAA;;EAUAH,SAAS,IAAK,SAAS,CAAT,QAAA,CAAoB;IAAES,IAAI,EAAN,MAAA;IAAgBC,KAAK,EAAE,EAAE,GAAGV,SAAS,CAACL;IAAf;EAAvB,CAApB,CAAdK;AA5DG,CAAA;;AA+DP,MAAM8C,YAAY,GAAG,CAAA,SAAA,EAAA,SAAA,KAA4B;EAC7C,IAAA,WAAA;;EAEA3C,CAAC,CAADA,OAAAA,CAAWH,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAxBG,UAAAA,EAAmD,UAAA,SAAA,EAAsB;IACrE,IAAIsB,SAAS,CAATA,SAAAA,KAAJ,SAAA,EAAwC;MACpCqC,WAAW,GAAXA,SAAAA;MACA,OAAA,KAAA;IACH;;IACD,OAAA,IAAA;EALJ3D,CAAAA;;EAQA,OAAA,WAAA;AAXJ,CAAA;;AAcA,MAAM+C,uBAAuB,GAAG,CAAA,SAAA,EAAA,IAAA,EAAA,UAAA,KAAmC;EAC/D,IAAA,aAAA;;EAEA,IAAIlD,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAbA,UAAaA,CAAbA,IAAwD,CAACG,CAAC,CAADA,OAAAA,CAAWH,SAAS,IAAIA,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,UAAAA,EAArF,KAA6DG,CAA7D,EAAuI;IACnIA,CAAC,CAADA,OAAAA,CAAWH,SAAS,CAATA,IAAAA,CAAAA,UAAAA,CAAAA,UAAAA,EAAXG,KAAAA,EAA0D,UAAA,OAAA,EAAoB;MAC1E,IAAIA,CAAC,CAADA,OAAAA,CAAAA,OAAAA,EAAJ,IAAIA,CAAJ,EAAiC;QAC7B4D,aAAa,GAAbA,OAAAA;QACA,OAAA,KAAA;MACH;;MACD,OAAA,IAAA;IALJ5D,CAAAA;EAOH;;EAED,OAAA,aAAA;AAbJ,CAAA","sourcesContent":["import AwTileGroup from 'viewmodel/AwTileGroupViewModel';\nimport domUtils from 'js/domUtils';\nimport eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport tileDragSvc from 'js/tileDragService';\nconst eleRef = domUtils.DOMAPIs;\n\nexport const awTileCanvasRenderFunction = ( props ) => {\n    const {\n        viewModel,\n        ctxMin,\n        actions,\n        i18n,\n        fields,\n        grids,\n        formProp,\n        messages,\n        ...prop\n    } = props;\n    const { data } = viewModel;\n    const { dndHandler } = prop;\n    let callback = getStartTileEditFn( viewModel, prop );\n    let subscriptions = viewModel.data.subscriptions;\n    let subscribedEventsStr = getEventSubscribtionsList( subscriptions );\n\n    if( _.isEmpty( viewModel.data.tileGroups ) && !_.isEmpty( prop.tileGroups ) ) {\n        initialize( prop, viewModel );\n    }\n\n    const unPinTileCallback = () => {\n        if( !_.isEmpty( viewModel.data.tileGroups ) ) {\n            resetTilesEditFlag( viewModel );\n            _.defer( function() {\n                prop.unPinTileCallback && prop.unPinTileCallback( viewModel );\n            } );\n        }\n    };\n\n    const tileClickCallback = () => {\n        if( !_.isEmpty( viewModel.data.tileGroups ) ) {\n            let vmprop = { ...viewModel.getData() };\n            vmprop.isGatewayInEditMode = false;\n            viewModel.dispatch( { path: 'data', value: { ...vmprop } } );\n            _.defer( function() {\n                prop.tileClickCallback && prop.tileClickCallback( viewModel );\n            } );\n        }\n    };\n\n    const handleDrag = (  event, target, targetVMO  ) => {\n        if( dndHandler && dndHandler[ event.type ] ) {\n            let fun = dndHandler[ event.type ];\n            fun( event, { targetElement: target, targetVMO: targetVMO } );\n        }\n    };\n\n    const handleDrop = (  event, target, targetVMO  ) => {\n        if( dndHandler && dndHandler[ event.type ] ) {\n            let funDrop = dndHandler[ event.type ];\n            funDrop( event, { targetElement: target, targetVMO: targetVMO } );\n        }\n    };\n    const handleDragAndDrop = { drag: handleDrag, drop: handleDrop, draggable: true };\n    return (\n        <div className='aw-tile-canvas'>\n            <div data-locator='tile-canvas' className={getCanvasClass( viewModel )}>\n                <div className='aw-tile-mainContainer aw-layout-flexColumnContainer'>\n                    <div className='aw-tile-tileGroups aw-layout-flexRowContainer'>\n                        {\n                            ( prop.tileGroups || [] ).map( ( tileGroup, index ) =>createTileGroup( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, ( e ) =>{\n                                callback( e );\n                                tileGroup.toggleEdit && tileGroup.toggleEdit();\n                            } ) )\n                        }\n                        <div className='aw-tile-tileGroups'>\n                            <AwTileGroup tileGroup={data.dummyTileGroup}></AwTileGroup>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nconst initialize = ( prop, viewModel ) => {\n    let data = { ...viewModel.getData() };\n    data.tileGroups = prop.tileGroups || [];\n    viewModel.dispatch( { path: 'data', value: { ...data } } );\n};\n\nconst getCanvasClass = ( viewModel ) => {\n    let canvasClass = [ 'aw-tile-tileCanvasPanel aw-layout-flexColumn' ];\n    canvasClass.push( viewModel.data.isGatewayInEditMode ? 'aw-tile-editMode' : '' );\n    return canvasClass.join( ' ' );\n};\n\nconst createTileGroup = ( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, callback ) => {\n    tileGroup.editTileCallback = callback;\n    tileGroup.isGatewayInEditMode = viewModel.data.isGatewayInEditMode;\n    //tileGroup.handleDragAndDrop = handleDragAndDrop;\n    return (\n        <div key={index} className={getTileGroupClass( tileGroup )}>\n            <AwTileGroup tileGroup={tileGroup} handleDragAndDrop={handleDragAndDrop} unPinTileCallback={unPinTileCallback} tileClickCallback={tileClickCallback}></AwTileGroup>\n        </div>\n    );\n};\n\nconst getTileGroupClass = ( tileGroup ) => {\n    let tileGroupClass = [ 'aw-tile-tileGroup aw-layout-flexRowContainer' ];\n    tileGroupClass.push( tileGroup.tiles.length === 0 ? 'aw-tile-emptyTileGroup' : '' );\n    return tileGroupClass.join( ' ' );\n};\n\n/**\n * Callback Fn triggered from AwTile for tile edit\n * @param {*} viewModel viewModel\n * @returns {*} anonymous function triggered on 'contextmenu'\n */\nlet _removeHanlder = [];\nconst getStartTileEditFn = ( viewModel, prop ) => {\n    let canvasViewModel = { ...viewModel };\n    return ( event ) => {\n        let data = { ...canvasViewModel.getData() };\n        data.isGatewayInEditMode = true;\n        canvasViewModel.dispatch( { path: 'data', value: { ...data } } );\n        emptyHandler();\n\n        let handler = handleDocumentClick.bind( null, canvasViewModel, prop );\n\n        document.addEventListener( 'click', handler );\n        document.addEventListener( 'touchstart', handler );\n\n        _removeHanlder.push( () => document.removeEventListener( 'click', handler ) );\n        _removeHanlder.push( () => document.removeEventListener( 'touchstart', handler ) );\n    };\n};\n\n/**\n *\n * @param {*} viewModel canvasViewModel\n * @param {*} event onClick MouseEvent\n */\nconst handleDocumentClick = function( viewModel, prop, event ) {\n    if( event && event.target && event.target.parentElement ) {\n        let isEditingTile = domUtils.DOMAPIs.closest( event.target, '.aw-tile-tileContainer' );\n        if( !isEditingTile || isEditingTile.length === 0 ) {\n            stopEditing( viewModel, prop );\n        }\n    }\n};\n\nconst stopEditing = ( viewModel, prop ) => {\n    resetTilesEditFlag( viewModel );\n\n    let dirtyTiles = findDirtyTiles( viewModel );\n    if( dirtyTiles && dirtyTiles.tiles.length > 0 ) {\n        eventBus.publish( 'gateway.updateTile', dirtyTiles );\n        prop.updateTileCallback && prop.updateTileCallback();\n    }\n\n    emptyHandler();\n};\n\nconst emptyHandler = () => {\n    if( _removeHanlder.length > 0 ) {\n        _removeHanlder.forEach( ( tile ) => tile() );\n        _removeHanlder = [];\n    }\n};\n\nconst resetTilesEditFlag = ( viewModel ) => {\n    _.forEach( viewModel.data.tileGroups, ( tileGroup ) => {\n        if( tileGroup && tileGroup.tiles ) {\n            _.forEach( tileGroup.tiles, ( tile ) => {\n                if( tile && tile.editing ) {\n                    delete tile.editing;\n                }\n            } );\n        }\n    } );\n    let vmprop = { ...viewModel.getData() };\n    vmprop.isGatewayInEditMode = false;\n    viewModel.dispatch( { path: 'data', value: { ...vmprop } } );\n};\n\nconst findDirtyTiles = ( viewModel ) => {\n    var dirtyTiles = {};\n    dirtyTiles.tiles = [];\n    dirtyTiles.groupNames = [];\n\n    _.forEach(  viewModel && viewModel.data.tileGroups, function( tileGroup ) {\n        if( tileGroup && tileGroup.tiles ) {\n            _.forEach( tileGroup.tiles, function( tile ) {\n                if( tile && tile.isDirty ) {\n                    // reset dirty state and return the tile info\n                    delete tile.isDirty;\n                    delete tile.$$hashKey;\n                    _.forEach( tile.content, function( content ) {\n                        if( content ) {\n                            delete content.$$hashKey;\n                        }\n                    } );\n\n                    dirtyTiles.tiles.push( tile );\n                    dirtyTiles.groupNames.push( tileGroup.groupName );\n                }\n            } );\n        }\n    } );\n\n    return dirtyTiles;\n};\n\nconst getEventSubscribtionsList = ( subscriptions ) => {\n    let subscribedEventsStr = [];\n    if( subscriptions.length !== 0 ) {\n        subscriptions.map( ( eventSubscribed ) => {\n            subscribedEventsStr.push( eventSubscribed.topic );\n        } );\n    }\n    return subscribedEventsStr;\n};\n\n/**\n * Create New Tile Group while DnD tiles\n *\n * @param {*} sourceTile sourceTile\n * @param {*} sourceGroupName sourceGroupName\n * @param {*} targetTileGroup targetTileGroup\n */\nexport const createNewTileGroup = ( sourceTile, sourceGroupName, targetTileGroup ) => {\n    //TODO: hook viewModel while working on Drag n Drop. May be pass from the DnD service or something\n    let viewModel;\n\n    var sourceGroup = getTileGroup( viewModel, sourceGroupName );\n    var sourceGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( sourceGroup );\n    var targetGroupIndx = viewModel && viewModel.tileGroups.indexOf( targetTileGroup );\n\n    var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );\n    var sourceTileIndx = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n\n    var baseOrder = 0;\n    var newGroupIncrement = 100;\n    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {\n        baseOrder = tileDragSvc.getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );\n    }\n\n    // remove tile from source group\n    var srcGroup = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ];\n    srcGroup.tiles.splice( sourceTileIndx, 1 );\n\n    var srcGroupNull = false;\n    // If we removed the last tile in the group\n    if( srcGroup.tiles.length === 0 ) {\n        srcGroupNull = true;\n    }\n\n    // create new group using current time\n    var newGroup = {};\n    newGroup.groupName = 'group' + new Date().getTime();\n\n    // add sourceTile to newly created group\n    newGroup.tiles = [];\n    newGroup.tiles.push( sourceTileIn );\n\n    newGroup.tiles.forEach( function( tile, indx ) {\n        tile.orderNumber = baseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n    } );\n\n    // update tileGroups array\n    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {\n        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx, 0, newGroup );\n    } else {\n        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );\n    }\n\n    var newGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( newGroup );\n\n    // update order number for all tiles in each and every tile group\n    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup, index ) {\n        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {\n            var grpBaseOrder = tileDragSvc.getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );\n            tileGroup.tiles.map( function( tile, indx ) {\n                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n                tile.isDirty = true;\n                return tile;\n            } );\n        }\n    } );\n    viewModel &&  viewModel.dispatch( { path: 'data', value: { ...viewModel.data } } );\n};\n\nconst getTileGroup = ( viewModel, groupName ) => {\n    var tileGroupIn;\n\n    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup ) {\n        if( tileGroup.groupName === groupName ) {\n            tileGroupIn = tileGroup;\n            return false;\n        }\n        return null;\n    } );\n\n    return tileGroupIn;\n};\n\nconst retrieveTileInTileGroup = ( viewModel, tile, groupIndex ) => {\n    var retrievedTile;\n\n    if( viewModel && viewModel.data.tileGroups[ groupIndex ] && !_.isEmpty( viewModel && viewModel.data.tileGroups[ groupIndex ].tiles ) ) {\n        _.forEach( viewModel.data.tileGroups[ groupIndex ].tiles, function( tileObj ) {\n            if( _.isEqual( tileObj, tile ) ) {\n                retrievedTile = tileObj;\n                return false;\n            }\n            return null;\n        } );\n    }\n\n    return retrievedTile;\n};\n"]},"metadata":{},"sourceType":"module"}