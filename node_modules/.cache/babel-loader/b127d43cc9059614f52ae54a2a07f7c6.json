{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to manage AngularJS Scope\n * <P>\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/declarativeDataCtxService\n */import dynamicPropertySvc from'js/dynamicPropertyService';import awConstantsSvc from'js/awConstantsService';import AwInterpolateService from'js/awInterpolateService';import adapterService from'js/adapterService';import AwPromiseService from'js/awPromiseService';import appCtxService from'js/appCtxService';import assert from'js/assert';import _ from'lodash';import declUtils from'js/declUtils';import parsingUtils from'js/parsingUtils';import logger from'js/logger';/**\n * Cached reference to dependent services\n */ /**\n * Cached reference to adapter service\n */ /**\n * {Boolean} TRUE if use of the $interpolate API should be logged.\n */var _debug_logInterpolatingActivity;/**\n * {Boolean} TRUE if we are NOT able to find a property on the $scope when referenced in a data binding expression.\n */var _debug_logMissingProperties;/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */var exports={};var parametersList=function(funcToCall,$scope){var funcParams=funcToCall.parameters;var params=[];var i;if(funcParams){for(i=0;i<funcParams.length;i++){var param=funcParams[i];var results2=param.match(parsingUtils.REGEX_DATABINDING);if(results2&&results2.length===4){var newParam=results2[2];var realizedFuncParam=parsingUtils.parentGet($scope,newParam);params.push(realizedFuncParam);}else{params.push(param);}}}return params;};/**\n * Apply the scope object of the input.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {Object} inputDataToUpdate - The 'inputData' from an 'action' who's properties are to be updated with\n *            current values from the 'declViewModel' and/or dependent function calls.\n *\n * @param {Object} functionsList - List of functions read from JSON\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n */export let applyScope=function(declViewModel,inputDataToUpdate,functionsList,dataCtxNode,depModuleObj){if(!declUtils.isValidModelAndDataCtxNode(declViewModel,dataCtxNode)){return;}assert(inputDataToUpdate,'Missing \"inputDataToUpdate\" parameter');// eslint-disable-next-line consistent-return\n_.forEach(inputDataToUpdate,function(propValue,propName){// eslint-disable-line complexity\nif(!propValue){return true;}var propValueType=typeof propValue;/**\n         * Check if propValue is undefined or a simple string\n         */if(propValueType==='string'){/**\n             * Check if it is a replacement case\n             * <P>\n             * Note: The regex will only extract 4 segments w/the following for [1] & [3]<BR>\n             * results[1] === '{{' && results[3] === '}}'\n             */var results=propValue.match(parsingUtils.REGEX_DATABINDING);if(results&&results.length===4){var newVal=results[2];if(!/^(function:|dataParseDefinitions:|Constants.|ports:|dragAndDropParams)/.test(newVal)){// dataCtxNode.ctx is always old,\n// ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/504\n// var val2 = parsingUtils.parentGet( dataCtxNode, newVal );\nvar val2=parsingUtils.parentGet({...dataCtxNode,ctx:{...dataCtxNode.ctx,...appCtxService.ctx}},newVal);inputDataToUpdate[propName]=val2;if(_debug_logMissingProperties&&val2===undefined){logger.warn('Unable to find property on the current $scope: '+newVal);}}else if(_.startsWith(newVal,'dragAndDropParams')){var val2=parsingUtils.parentGet(dataCtxNode,newVal);inputDataToUpdate[propName]=val2;}else if(_.startsWith(newVal,'function:')){var functionName=newVal.replace('function:','');var funcToCall=functionsList[functionName];if(!funcToCall){assert(funcToCall,'Missing function: '+functionName);}var params=parametersList(funcToCall,dataCtxNode);if(depModuleObj){if(depModuleObj[funcToCall.functionName]){inputDataToUpdate[propName]=depModuleObj[funcToCall.functionName].apply(depModuleObj,params);}else{_.forEach(depModuleObj,function(value,key){if(funcToCall.deps.includes(key)){inputDataToUpdate[propName]=depModuleObj[key][funcToCall.functionName].apply(depModuleObj[key],params);}});}}else{inputDataToUpdate[propName]=undefined;}}else if(_.startsWith(newVal,'dataParseDefinitions:')){if(declViewModel._internal.dataParseDefinitions){var parseDefName=newVal.replace('dataParseDefinitions:','');var dynmData=_.get(declViewModel._internal.dataParseDefinitions,parseDefName);if(dynmData){inputDataToUpdate[propName]=dynamicPropertySvc.processDataParseDefination(dynmData,dataCtxNode);}}}else if(_.startsWith(newVal,'Constants.')){var val=awConstantsSvc.getConstant(newVal);if(val){inputDataToUpdate[propName]=val;}}else if(_.startsWith(newVal,'ports:')){if(declViewModel._internal.ports){var resolvedInput=_.get(declViewModel._internal.ports,newVal.replace('ports:',''));if(resolvedInput){inputDataToUpdate[propName]=resolvedInput;}}}}else if(propValue==='undefined'){inputDataToUpdate[propName]=undefined;}else if(propValue.match(/\\{\\{.*}}/g)){if(_debug_logInterpolatingActivity){logger.info('Interpolating '+propName+': '+propValue);}// If * was used to intentionally trigger interpolation remove it\nif(propValue.charAt(0)==='*'){propValue=propValue.substr(1);}inputDataToUpdate[propName]=AwInterpolateService.instance(propValue)({...dataCtxNode,i18n:dataCtxNode.data.i18n});}}else if(propValueType==='object'){/**\n             * Recurse to handle lower levels of {{ }} replacements\n             */exports.applyScope(declViewModel,propValue,functionsList,dataCtxNode,depModuleObj);}else{return true;}return undefined;});};/**\n * Resolve a specific response value based on the input parameters.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to process response into.\n *\n * @param {Object} response - The 'response' from a previous operation that will be used to determine the returned\n *            value based on the given input expression..\n *\n * @param {String} inputExpression - The expression that identifies where/how to determine the returned value (e.g.\n *            \"{{function:processTemplates}}\" \"{{templatesOutput[0].workflowTemplates}}\",\n *            \"{{dataParseDefinitions:xxxxxxxx}}\")\n *\n * @param {Object} depModuleObj - Module object that contains any functions to execute based on the\n *            'inputExpression' contents.\n * @param {Object} dataCtxNode - localContext\n *\n * @return {Object} The resolved value based on the given input parameters.\n */export let getOutput=function(declViewModel,response,inputExpression,depModuleObj,dataCtxNode){var expression=parsingUtils.getStringBetweenDoubleMustaches(inputExpression);if(_.startsWith(expression,'function:')){var functionName=expression.replace('function:','');var functionsList=declViewModel._internal.functions;if(functionsList){var funcToCall=functionsList[functionName];if(!funcToCall){return depModuleObj[functionName](response);}var params=parametersList(funcToCall,dataCtxNode);params.unshift(response);// evaluate function\nif(depModuleObj&&depModuleObj[funcToCall.functionName]){return depModuleObj[funcToCall.functionName].apply(depModuleObj,params);}else if(depModuleObj){var funcDependancies=Object.keys(depModuleObj);for(var index=0;index<funcDependancies.length;index++){var key=funcDependancies[index];if(funcToCall.deps&&funcToCall.deps.includes(key)){return depModuleObj[key][funcToCall.functionName].apply(depModuleObj,params);}}}}// evaluate function\nreturn depModuleObj[functionName](response);}else if(_.startsWith(expression,'dataParseDefinitions:')){if(declViewModel._internal.dataParseDefinitions){var parseDefName=expression.replace('dataParseDefinitions:','');var dynmData=_.get(declViewModel._internal.dataParseDefinitions,parseDefName);if(dynmData){return dynamicPropertySvc.processDataParseDefination(dynmData,declViewModel,response);}}}else if(_.startsWith(expression,'json:')){var jsonStringVariable=expression.replace('json:','');var jsonString=_.get(response,jsonStringVariable);return parsingUtils.parseJsonString(jsonString);}if(_.isString(inputExpression)){return _.get(response,inputExpression);}// support plain primitive JavaScript type in expression\nreturn inputExpression;};/**\n * Apply an expression object of inout.\n *\n * @param {Object} inputDataToUpdate - The object containing an expression.(e.g. \"$adapt\" : \"{{ctx.mselected}}\")\n *\n * @return {Promise} A promise object resolved with the results of the action.\n */export let applyExpression=function(inputDataToUpdate){var adaptedPromises={};if(inputDataToUpdate){_.forEach(inputDataToUpdate,function(paramVal,paramKey){if(typeof paramVal==='object'&&paramVal&&paramVal.$adapt!==undefined){var input=[];if(Array.isArray(paramVal.$adapt)){input=paramVal.$adapt;}else{input.push(paramVal.$adapt);}var path=null;if(paramVal.path!==undefined){path=paramVal.path;}var adaptPlaceHolder={paramKey:paramKey,paramPath:path,paramValArray:Array.isArray(paramVal.$adapt)};adaptedPromises[JSON.stringify(adaptPlaceHolder)]=adapterService.getAdaptedObjects(input,paramVal.isFullyAdapted);}});}else{inputDataToUpdate={};}return AwPromiseService.instance.all(adaptedPromises).then(function(results){_.forEach(results,function(resultVal,resultKey){var resultKeyObj=JSON.parse(resultKey);if(resultVal&&resultVal.length>0){if(resultKeyObj.paramPath){var assignedValues=[];_.forEach(resultVal,function(resultObj){assignedValues.push(_.get(resultObj,resultKeyObj.paramPath));});inputDataToUpdate[resultKeyObj.paramKey]=resultKeyObj.paramValArray?assignedValues:assignedValues[0];}else{inputDataToUpdate[resultKeyObj.paramKey]=resultKeyObj.paramValArray?resultVal:resultVal[0];}}else{delete inputDataToUpdate[resultKeyObj.paramKey];}});return;});};exports={applyScope,getOutput,applyExpression};export default exports;","map":null,"metadata":{},"sourceType":"module"}