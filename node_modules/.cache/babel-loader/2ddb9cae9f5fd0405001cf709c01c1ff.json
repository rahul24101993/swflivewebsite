{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Module for condition/expression parser utilities\n *\n * @module js/expressionParserUtils\n */\nimport _ from 'lodash';\nimport parsingUtils from 'js/parsingUtils';\nimport dateParserUtils from 'js/dateParserUtils';\nimport Debug from 'debug';\nimport AwParseService from 'js/awParseService';\nvar trace = new Debug('expressionParserUtils');\nvar exports = {};\n/**\n * Reference to operators in expression objects\n */\n\nexport let $SOURCE = '$source';\nexport let $QUERY = '$query';\nexport let $ADAPT = '$adapt';\nexport let $ALL = '$all';\nexport let $AND = '$and';\nexport let $OR = '$or';\nexport let $EVENTSOURCE = '$eventSource';\nexport let $NOT = '$not';\n/**\n * Map used to point to the utility function name based on the expression\n */\n\nvar _map_expr2Function = {\n  $eq: 'equalTo',\n  $lt: 'lessThan',\n  $lte: 'lessThanOrEqualTo',\n  $gt: 'greaterThan',\n  $gte: 'greaterThanOrEqualTo',\n  $ne: 'notEqualTo',\n  $neq: 'notEqualsTo',\n  $in: 'within',\n  $notin: 'notIn',\n  $isNull: 'isNull',\n  $notNull: 'notNull',\n  $vlookup: 'vlookup',\n  $regexp: 'regexp',\n  $notinrange: 'notInRange',\n  $notinregexp: 'notInRegexp',\n  $typeOf: 'typeOf'\n};\n/**\n * Gets dbValue for a non array property.\n *\n * @param {Object} prop - property object\n *\n * @return {Object} dbValue of the property\n */\n\nvar _getDbValueForProp = function (prop) {\n  var propValue = null;\n\n  if (prop && prop.dbValue) {\n    propValue = prop.dbValue;\n  } else if (prop && prop.dbValues && prop.dbValues.length > 0) {\n    propValue = prop.dbValues[0];\n  }\n\n  return propValue;\n};\n/**\n * Traverses given path in the received object and returns the value\n * @param {String} path dot separated path\n * @param {Object} obj object to be traversed for finding the value against received path\n *\n * @return {Object} returns object as resolved by traversing the path inside the object\n */\n\n\nexport let resolve = function (path, obj) {\n  var resolvedObj;\n\n  if (path && _.isString(path) && obj && _.isObject(obj)) {\n    resolvedObj = path.split('.').reduce(function (prev, curr) {\n      return prev ? prev = _.get(prev, curr) : undefined;\n    }, obj);\n  }\n\n  return resolvedObj;\n};\n/**\n * Update dynamic values against the query operator. Ex: \"$eq\": \"{{ctx.selected.props.object_string.dbValues[0]}}\"\n * @param {Object} query Object containing operator as key and value that needs to be resolved from data node\n * @param {Object} dataNode Object used to resolve the values\n * @return {Object} updated query\n */\n\nexport let updateDynamicValues = function (query, dataNode) {\n  // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n  // Do copy only at level 0\n  // LCS-168813 - AW404-Comparison use cases fails as color swab is not made available\n  // _.clone( var, true ) is not in lodash any more...we should use _.cloneDeep\n  // there are still several usage for _.clone(var, true), it gets copied here and that\n  // is why we cause the regression.\n  var updatedQuery = _.cloneDeep(query);\n\n  return updateDynamicValuesInternal(updatedQuery, dataNode);\n};\n/**\n *get expression data type\n *\n * @param {object} value - date object\n *\n * @return {String} dataType like - date,string,number\n */\n\nexport let getExpressionDataType = function (value) {\n  try {\n    var dataType;\n\n    if (value) {\n      if (dateParserUtils.isDate(value)) {\n        dataType = 'Date';\n      } else if (_.isNumber(value[0]) && _.isNumber(value[1])) {\n        dataType = 'Number';\n      } else if (_.isString(value[0]) && _.isString(value[1])) {\n        dataType = 'String';\n      }\n    }\n\n    return dataType;\n  } catch (e) {\n    trace('Error in expression', e, value);\n    return undefined;\n  }\n};\n\nvar updateDynamicValuesInternal = function (updatedQuery, dataNode) {\n  var expression = {};\n  var expressionDataType;\n\n  _.forEach(updatedQuery, function (value, key) {\n    if (key === '$notinrange' || dateParserUtils.isDate(value)) {\n      expressionDataType = exports.getExpressionDataType(value);\n\n      if (expressionDataType) {\n        expression = dateParserUtils.getExpressionDateValue(value, expressionDataType);\n        updatedQuery.expressionType = expressionDataType;\n        value = expression.value;\n        updatedQuery[key] = expression.value;\n      }\n    }\n\n    if (_.isString(value) && _.startsWith(value, '{{')) {\n      var dynamicValToResolve = parsingUtils.getStringBetweenDoubleMustaches(value);\n      updatedQuery[key] = exports.resolve(dynamicValToResolve, dataNode);\n    } else if (_.isObject(value)) {\n      updatedQuery[key] = exports.updateDynamicValues(value, dataNode);\n    }\n  });\n\n  return updatedQuery;\n};\n/**\n * Evaluates eventSource expression\n * @param {Object} exp eventSource expression\n * @param {Object} contextObj context object\n * @return {Boolean} verdict of expression evaluation\n */\n\n\nexport let evaluateEventSourceExpression = function (exp, contextObj) {\n  let eventSourceVal = exp[exports.$EVENTSOURCE];\n  let evalResult = false;\n\n  if (contextObj && contextObj.data && contextObj._source) {\n    let {\n      data,\n      _source\n    } = contextObj; // need to check self/view-id/view-name\n\n    if (_source === data._internal.modelId && (eventSourceVal === 'self' || eventSourceVal === data._internal.viewId || eventSourceVal === data._internal.panelId)) {\n      evalResult = true;\n    }\n  }\n\n  return evalResult;\n};\n\nlet checkOperatorResult = function (performAND, performOR, performNOT, evalCheckResult, result) {\n  if (performAND) {\n    return evalCheckResult && result;\n  } else if (performOR) {\n    return evalCheckResult || result;\n  } else if (performNOT) {\n    return !result;\n  }\n\n  return result;\n};\n/**\n * Evaluates checks using expression parser utils\n * @param {Object} query Object definition containing query details to be evaluated on received object\n * @param {Array} objects Array of objects against which the query needs to be evaluated\n * @param {Object} adapterSvc Adapter service\n * @return {Boolean} verdict of expression evaluation\n */\n\n\nexport let evaluateExpressions = function (query, objects, adapterSvc) {\n  var newValue = false;\n  var queryToUse = query;\n  var values = objects;\n\n  if (!_.isArray(objects)) {\n    values = [objects];\n  } // determine whether all or atleast one result(s) should match\n\n\n  var matchAll = queryToUse[exports.$ALL]; // fetch the inner query that is value of $all\n\n  queryToUse = matchAll || queryToUse; // evaluate the check on each of the value\n\n  newValue = values.reduce(function (valReduceResult, value) {\n    // determine existence of multiple checks against same source inside the query\n    var performAND = queryToUse[exports.$AND] || queryToUse[exports.$ALL];\n    var performOR = queryToUse[exports.$OR];\n    var performNOT = queryToUse[exports.$NOT]; // create array of checks to be evaluated on the source\n\n    var evalChecks = performAND || performOR || [queryToUse];\n    evalChecks = performNOT ? [performNOT] : evalChecks;\n    var verdict = evalChecks.reduce(function (evalCheckResult, evalCheck) {\n      var path = exports.resolve(exports.$SOURCE, evalCheck); // path i.e. $source can optionally have $adapt indicating the propValue needs to be adapted before use\n\n      var shouldAdapt = path && path[exports.$ADAPT];\n      path = shouldAdapt || path;\n\n      if (!path && evalCheck && evalCheck[exports.$EVENTSOURCE]) {\n        const evalResult = evaluateEventSourceExpression(evalCheck, value);\n        return checkOperatorResult(performAND, performOR, performNOT, evalCheckResult, evalResult);\n      }\n\n      var condition = exports.resolve(exports.$QUERY, evalCheck) || evalCheck;\n      var propValue = path ? exports.resolve(path, value) : value;\n\n      if (evalCheck.__useSourceParsing) {\n        propValue = AwParseService.instance(path)(value);\n      }\n\n      if (shouldAdapt) {\n        var valuesToAdapt = _.isArray(propValue) ? propValue : [propValue];\n        propValue = adapterSvc.getAdaptedObjectsSync(valuesToAdapt);\n      } // determine whether the query has nested queries with $all / $and / $or / $source\n\n\n      var recurseExpressionEvaluation = condition && (condition[exports.$NOT] || condition[exports.$ALL] || condition[exports.$AND] || condition[exports.$OR] || condition[exports.$SOURCE]);\n      var result;\n\n      if (recurseExpressionEvaluation) {\n        result = exports.evaluateExpressions(condition, propValue, adapterSvc);\n      } else {\n        result = exports.evaluateConditionExpression(condition, null, propValue);\n      }\n\n      return checkOperatorResult(performAND, performOR, performNOT, evalCheckResult, result);\n    }, performAND);\n    return matchAll ? valReduceResult && verdict : valReduceResult || verdict;\n  }, matchAll);\n  /**  When query contains nested $all and the values object is empty it returns the matAll query back to parseExpression API\n   *   which converts it to boolean ie. true and gives wrong output\n   *   for example\n   *   {\n   *      \"$source\": \"ctx.mselected\",\n   *      \"$query\":{\n   *         \"$all\":{\n   *            \"$source\":\"moduleType.typeHierarchyArray\",\n   *            \"$query\":{\n   *               \"$in\":[\n   *                   \"ItemRevision\"\n   *               ]\n   *            }\n   *         }\n   *       }\n   *   }\n   *   In this case is ctx.mselected is empty array i.e no selection in UI then above query returns true.\n   *   Below is the fix for the same.\n   */\n\n  return values.length === 0 && matchAll ? false : newValue;\n};\n/**\n * Evaluate conditions eg. 1. \"conditions\": { \"subscriptionId\": { \"$eq\": \"{{uid}}\" } } eg. 2. \"conditions\": {\n * \"object_desc\": { \"$eq\": \"Plane\" }, \"object_name\": { \"$eq\": \"Plane001\" } }\n *\n * @param {Object} conditions - map of conditions\n * @param { Object } vmoObj - view model object properties map\n * @return {Boolean} TRUE if all conditions are valid\n */\n\nexport let evaluateConditions = function (conditions, vmoObj) {\n  var isValid = true;\n  var vmoProps = vmoObj.props;\n\n  for (var propName in conditions) {\n    if (conditions[propName]) {\n      if (_.isObject(conditions[propName])) {\n        var condition = conditions[propName];\n        var vmoProp = vmoProps[propName];\n\n        var propValue = _getDbValueForProp(vmoProp);\n\n        var compareTo = {};\n\n        for (var key in condition) {\n          var value = condition[key];\n          var propKey = propName + '@' + key;\n\n          if (_.startsWith(value, '{{')) {\n            var propToCompare = parsingUtils.getStringBetweenDoubleMustaches(value);\n            var prop = vmoProps[propToCompare];\n\n            if (!prop) {\n              compareTo[propKey] = vmoObj[propToCompare];\n            } else {\n              compareTo[propKey] = _getDbValueForProp(prop);\n            }\n          } else {\n            compareTo[propKey] = value;\n          }\n        }\n\n        isValid = exports.evaluateConditionExpression(condition, propName, propValue, compareTo);\n      } else {\n        isValid = false;\n      }\n    } // break if even one condition is invalid\n\n\n    if (!isValid) {\n      break;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluate condition expression\n *\n * @param {Object} condition - condition object\n * @param {Object} propName - property name\n * @param {Object} propValue - real value of the property\n * @param {Object} compareTo - real value of the property\n * @return {Boolean} TRUE if conditions are valid\n */\n\nexport let evaluateConditionExpression = function (condition, propName, propValue, compareTo) {\n  var isValid = false;\n  var resolvedPropValue = null;\n\n  if (condition) {\n    for (var key in condition) {\n      if (key !== 'expressionType') {\n        if (_.startsWith(key, '$') && _.has(_map_expr2Function, key)) {\n          var functionName = _map_expr2Function[key];\n\n          if (_.startsWith(condition[key], '{{')) {\n            resolvedPropValue = compareTo[propName + '@' + key];\n          } else {\n            resolvedPropValue = condition[key];\n          }\n\n          if (condition.expressionType === 'Date' && propValue && resolvedPropValue) {\n            var parsedDates = dateParserUtils.getParsedDates(propValue, resolvedPropValue);\n            resolvedPropValue = parsedDates.queryDate;\n            propValue = parsedDates.sourceDate;\n          }\n\n          isValid = exports[functionName](resolvedPropValue, propValue, condition.expressionType);\n        } else {\n          isValid = false;\n        }\n      }\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let equalTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() === propValue.toString();\n  } else {\n    isValid = condValue === propValue;\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether viewmodel property is of a particular type .\n *\n * @param {Object} vmo - viewmodel object\n * @param {String} type - type of property.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let typeOf = function (type, vmo) {\n  var typeHieararchyArray = [];\n\n  if (vmo) {\n    if (vmo.modelType && _.isArray(vmo.modelType.typeHierarchyArray)) {\n      typeHieararchyArray = vmo.modelType.typeHierarchyArray;\n    } else if (_.isArray(vmo.typeHierarchy)) {\n      typeHieararchyArray = vmo.typeHierarchy;\n    } else if (vmo.type) {\n      typeHieararchyArray = vmo.type;\n    }\n  }\n\n  return typeHieararchyArray.includes(type);\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let within = function (condValue, propValue) {\n  var isValid = false;\n  var testValue = _.isArray(propValue) ? propValue : [propValue];\n  var values = _.isArray(condValue) ? condValue : [condValue];\n  isValid = values.some(function (value) {\n    return _.indexOf(testValue, value) >= 0;\n  });\n  return isValid;\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let notInRange = function (condValue, propValue, type) {\n  var isNotInRange = false;\n  var isConditionValid = false;\n\n  if (condValue && condValue.length === 2 && propValue && type) {\n    var conditionLeft = condValue[0];\n    var conditionRight = condValue[1];\n\n    switch (type) {\n      case 'Date':\n        if (_.isFinite(conditionLeft) && _.isFinite(conditionRight) && _.isFinite(propValue)) {\n          isConditionValid = true;\n        }\n\n        break;\n\n      case 'Number':\n        conditionLeft = Number(conditionLeft);\n        conditionRight = Number(conditionRight);\n        propValue = Number(propValue);\n        isConditionValid = true;\n        break;\n\n      case 'String':\n        conditionLeft = conditionLeft.toString();\n        conditionRight = conditionRight.toString();\n        isConditionValid = true;\n        break;\n    }\n\n    if (isConditionValid && conditionLeft > propValue || conditionRight < propValue) {\n      isNotInRange = true;\n    }\n  }\n\n  return isNotInRange;\n};\n/**\n * Evaluating whether property value is not in the condition value array.\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition values do not contain property value\n */\n\nexport let notIn = function (condValue, propValue) {\n  var verdict = exports.within(condValue, propValue);\n  return !verdict;\n};\n/**\n * Evaluating whether condition value is less than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than condition value\n */\n\nexport let lessThan = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn < condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is less than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than or equal to condition value\n */\n\nexport let lessThanOrEqualTo = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn <= condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is greater than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than condition value\n */\n\nexport let greaterThan = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn > condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is greater than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than or equal to condition value\n */\n\nexport let greaterThanOrEqualTo = function (condValue, propValue) {\n  var isValid = false;\n  var condValueIn = Number(condValue);\n  var propValueIn = Number(propValue);\n\n  if (_.isFinite(condValueIn) && _.isFinite(propValueIn)) {\n    if (propValueIn >= condValueIn) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let notEqualTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() !== propValue.toString();\n  } else {\n    isValid = condValue !== propValue;\n  }\n\n  return isValid;\n};\n/**\n * Applicable for validation criteria -  Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let notEqualsTo = function (condValue, propValue) {\n  var isValid = false;\n\n  if (condValue && propValue) {\n    isValid = condValue.toString() !== propValue.toString();\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\n\nexport let regexp = function (condValue, propValue) {\n  var isValid = false;\n  var regexp;\n  var value = propValue ? String(propValue) : '';\n\n  if (_.isString(condValue)) {\n    regexp = new RegExp(condValue);\n  } else if (_.isObject(condValue) && condValue.$pattern) {\n    try {\n      regexp = new RegExp(condValue.$pattern, condValue.$options);\n    } catch (err) {\n      // Invalid options\n      isValid = false;\n    }\n  }\n\n  if (regexp) {\n    isValid = regexp.test(value);\n  }\n\n  return isValid;\n};\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\n\nexport let notInRegexp = function (condValue, propValue) {\n  if (condValue && propValue) {\n    return !exports.regexp(condValue, propValue);\n  }\n\n  return false;\n};\n/**\n * Enables looking up a value in given range and matching another value with the value at the same index but\n * different column in the range\n *\n * Example: Range is an array of arrays where first array holds objects and second array holds array of values.\n * range : [\n *   [ {\"uid\":\"v1\"}, {\"uid\":\"v11\"}, {\"uid\":\"v111\"} ],\n *   [ [\"color1\"], [\"color2\"], [\"color3\"] ]\n * }\n *\n * Calling vlookup with following inputs will return true:\n * vlookupInput = {\n *  \"lookupValue\" : \"v11\",\n *  \"lookupValueKey\" : \"uid\",\n *  \"matchKey\" : 1,\n *  \"matchValue\": \"color2\"\n * }\n * vlookup( vlookupInput, range ) :: returns true\n *\n * @param {Object} vlookupInput - Javascript object holding the lookupValue, lookupValueKey, matchKey and matchValue\n * @param {Object} range -        Javascript object with each value as array of string/int/boolean or objects OR\n *                                    array of string/int/boolean or object arrays\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\n\nexport let vlookup = function (vlookupInput, range) {\n  var lookupValueKey = vlookupInput.lookupValueKey;\n  var lookupValue = vlookupInput.lookupValue;\n  var matchKey = vlookupInput.matchKey;\n  var matchValue = vlookupInput.matchValue;\n  var valToMatchFromRange; // determine the lookup strategy based on type of range object\n\n  if (_.isArray(range)) {\n    // range is an array of arrays\n    var matchIndex = -1;\n\n    _.forEach(range, function (value) {\n      var values = _.isArray(value) ? value : [value];\n\n      _.forEach(values, function (currVal, arrPos) {\n        if (currVal) {\n          var lookupValToMatch = lookupValueKey ? currVal[lookupValueKey] : currVal;\n\n          if (lookupValue === lookupValToMatch) {\n            matchIndex = arrPos;\n            return false;\n          }\n        }\n\n        return undefined;\n      });\n\n      if (matchIndex > -1) {\n        valToMatchFromRange = matchKey ? range[matchKey][matchIndex] : Object.keys(range)[matchIndex];\n        valToMatchFromRange = valToMatchFromRange && _.isArray(valToMatchFromRange) && valToMatchFromRange.length > 0 ? valToMatchFromRange[0] : valToMatchFromRange;\n        return false;\n      }\n\n      return undefined;\n    });\n  } else {\n    // range is an object with key value pair\n    _.forEach(range, function (value, key) {\n      if (key === lookupValue) {\n        valToMatchFromRange = value;\n        return false;\n      }\n\n      return undefined;\n    });\n  }\n\n  return valToMatchFromRange === matchValue;\n};\n/* Gets eval function to cache for quicker evals in future */\n\n/**\n *\n * @param {String} condKey - $in\n * @param {String} propKey - modelType.typeHierarchy\n */\n\nexport let getEvaluationFn = function (condKey, propKey) {\n  if (condKey[0] === '$') {\n    return exports[_map_expr2Function[condKey]];\n  }\n\n  return function () {\n    return false;\n  };\n};\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\n\nexport let isNull = function (condValue, propValue) {\n  return !propValue;\n};\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\n\nexport let notNull = function (condValue, propValue) {\n  return !exports.isNull(condValue, propValue);\n};\nexports = {\n  $SOURCE,\n  $QUERY,\n  $ADAPT,\n  $ALL,\n  $AND,\n  $OR,\n  $EVENTSOURCE,\n  $NOT,\n  resolve,\n  updateDynamicValues,\n  evaluateExpressions,\n  evaluateConditions,\n  evaluateConditionExpression,\n  evaluateEventSourceExpression,\n  equalTo,\n  within,\n  notInRange,\n  notIn,\n  lessThan,\n  lessThanOrEqualTo,\n  greaterThan,\n  greaterThanOrEqualTo,\n  notEqualTo,\n  notEqualsTo,\n  regexp,\n  notInRegexp,\n  vlookup,\n  isNull,\n  notNull,\n  getExpressionDataType,\n  typeOf,\n  getEvaluationFn\n};\nexport default exports;","map":{"version":3,"names":["_","parsingUtils","dateParserUtils","Debug","AwParseService","trace","exports","$SOURCE","$QUERY","$ADAPT","$ALL","$AND","$OR","$EVENTSOURCE","$NOT","_map_expr2Function","$eq","$lt","$lte","$gt","$gte","$ne","$neq","$in","$notin","$isNull","$notNull","$vlookup","$regexp","$notinrange","$notinregexp","$typeOf","_getDbValueForProp","prop","propValue","dbValue","dbValues","length","resolve","path","obj","resolvedObj","isString","isObject","split","reduce","prev","curr","get","undefined","updateDynamicValues","query","dataNode","updatedQuery","cloneDeep","updateDynamicValuesInternal","getExpressionDataType","value","dataType","isDate","isNumber","e","expression","expressionDataType","forEach","key","getExpressionDateValue","expressionType","startsWith","dynamicValToResolve","getStringBetweenDoubleMustaches","evaluateEventSourceExpression","exp","contextObj","eventSourceVal","evalResult","data","_source","_internal","modelId","viewId","panelId","checkOperatorResult","performAND","performOR","performNOT","evalCheckResult","result","evaluateExpressions","objects","adapterSvc","newValue","queryToUse","values","isArray","matchAll","valReduceResult","evalChecks","verdict","evalCheck","shouldAdapt","condition","__useSourceParsing","instance","valuesToAdapt","getAdaptedObjectsSync","recurseExpressionEvaluation","evaluateConditionExpression","evaluateConditions","conditions","vmoObj","isValid","vmoProps","props","propName","vmoProp","compareTo","propKey","propToCompare","resolvedPropValue","has","functionName","parsedDates","getParsedDates","queryDate","sourceDate","equalTo","condValue","toString","typeOf","type","vmo","typeHieararchyArray","modelType","typeHierarchyArray","typeHierarchy","includes","within","testValue","some","indexOf","notInRange","isNotInRange","isConditionValid","conditionLeft","conditionRight","isFinite","Number","notIn","lessThan","condValueIn","propValueIn","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","notEqualTo","notEqualsTo","regexp","String","RegExp","$pattern","$options","err","test","notInRegexp","vlookup","vlookupInput","range","lookupValueKey","lookupValue","matchKey","matchValue","valToMatchFromRange","matchIndex","currVal","arrPos","lookupValToMatch","Object","keys","getEvaluationFn","condKey","isNull","notNull"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/expressionParserUtils.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Module for condition/expression parser utilities\n *\n * @module js/expressionParserUtils\n */\nimport _ from 'lodash';\nimport parsingUtils from 'js/parsingUtils';\nimport dateParserUtils from 'js/dateParserUtils';\nimport Debug from 'debug';\nimport AwParseService from 'js/awParseService';\n\nvar trace = new Debug( 'expressionParserUtils' );\nvar exports = {};\n\n/**\n * Reference to operators in expression objects\n */\n\nexport let $SOURCE = '$source';\nexport let $QUERY = '$query';\nexport let $ADAPT = '$adapt';\nexport let $ALL = '$all';\nexport let $AND = '$and';\nexport let $OR = '$or';\nexport let $EVENTSOURCE = '$eventSource';\nexport let $NOT = '$not';\n\n/**\n * Map used to point to the utility function name based on the expression\n */\nvar _map_expr2Function = {\n    $eq: 'equalTo',\n    $lt: 'lessThan',\n    $lte: 'lessThanOrEqualTo',\n    $gt: 'greaterThan',\n    $gte: 'greaterThanOrEqualTo',\n    $ne: 'notEqualTo',\n    $neq: 'notEqualsTo',\n    $in: 'within',\n    $notin: 'notIn',\n    $isNull: 'isNull',\n    $notNull: 'notNull',\n    $vlookup: 'vlookup',\n    $regexp: 'regexp',\n    $notinrange: 'notInRange',\n    $notinregexp: 'notInRegexp',\n    $typeOf: 'typeOf'\n};\n\n/**\n * Gets dbValue for a non array property.\n *\n * @param {Object} prop - property object\n *\n * @return {Object} dbValue of the property\n */\nvar _getDbValueForProp = function( prop ) {\n    var propValue = null;\n    if( prop && prop.dbValue ) {\n        propValue = prop.dbValue;\n    } else if( prop && prop.dbValues && prop.dbValues.length > 0 ) {\n        propValue = prop.dbValues[ 0 ];\n    }\n\n    return propValue;\n};\n\n/**\n * Traverses given path in the received object and returns the value\n * @param {String} path dot separated path\n * @param {Object} obj object to be traversed for finding the value against received path\n *\n * @return {Object} returns object as resolved by traversing the path inside the object\n */\nexport let resolve = function( path, obj ) {\n    var resolvedObj;\n    if( path && _.isString( path ) && obj && _.isObject( obj ) ) {\n        resolvedObj = path.split( '.' ).reduce( function( prev, curr ) {\n            return prev ? prev = _.get( prev, curr ) : undefined;\n        }, obj );\n    }\n\n    return resolvedObj;\n};\n\n/**\n * Update dynamic values against the query operator. Ex: \"$eq\": \"{{ctx.selected.props.object_string.dbValues[0]}}\"\n * @param {Object} query Object containing operator as key and value that needs to be resolved from data node\n * @param {Object} dataNode Object used to resolve the values\n * @return {Object} updated query\n */\nexport let updateDynamicValues = function( query, dataNode ) {\n    // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n    // Do copy only at level 0\n    // LCS-168813 - AW404-Comparison use cases fails as color swab is not made available\n    // _.clone( var, true ) is not in lodash any more...we should use _.cloneDeep\n    // there are still several usage for _.clone(var, true), it gets copied here and that\n    // is why we cause the regression.\n    var updatedQuery = _.cloneDeep( query );\n    return updateDynamicValuesInternal( updatedQuery, dataNode );\n};\n\n/**\n *get expression data type\n *\n * @param {object} value - date object\n *\n * @return {String} dataType like - date,string,number\n */\nexport let getExpressionDataType = function( value ) {\n    try {\n        var dataType;\n        if( value ) {\n            if( dateParserUtils.isDate( value ) ) {\n                dataType = 'Date';\n            } else if( _.isNumber( value[ 0 ] ) && _.isNumber( value[ 1 ] ) ) {\n                dataType = 'Number';\n            } else if( _.isString( value[ 0 ] ) && _.isString( value[ 1 ] ) ) {\n                dataType = 'String';\n            }\n        }\n        return dataType;\n    } catch ( e ) {\n        trace( 'Error in expression', e, value );\n        return undefined;\n    }\n};\n\nvar updateDynamicValuesInternal = function( updatedQuery, dataNode ) {\n    var expression = {};\n    var expressionDataType;\n    _.forEach( updatedQuery, function( value, key ) {\n        if( key === '$notinrange' || dateParserUtils.isDate( value ) ) {\n            expressionDataType = exports.getExpressionDataType( value );\n            if( expressionDataType ) {\n                expression = dateParserUtils.getExpressionDateValue( value, expressionDataType );\n                updatedQuery.expressionType = expressionDataType;\n                value = expression.value;\n                updatedQuery[ key ] = expression.value;\n            }\n        }\n\n        if( _.isString( value ) && _.startsWith( value, '{{' ) ) {\n            var dynamicValToResolve = parsingUtils.getStringBetweenDoubleMustaches( value );\n            updatedQuery[ key ] = exports.resolve( dynamicValToResolve, dataNode );\n        } else if( _.isObject( value ) ) {\n            updatedQuery[ key ] = exports.updateDynamicValues( value, dataNode );\n        }\n    } );\n    return updatedQuery;\n};\n\n/**\n * Evaluates eventSource expression\n * @param {Object} exp eventSource expression\n * @param {Object} contextObj context object\n * @return {Boolean} verdict of expression evaluation\n */\nexport let evaluateEventSourceExpression = function( exp, contextObj ) {\n    let eventSourceVal = exp[ exports.$EVENTSOURCE ];\n    let evalResult = false;\n    if( contextObj && contextObj.data && contextObj._source ) {\n        let { data, _source } = contextObj;\n        // need to check self/view-id/view-name\n        if( _source === data._internal.modelId && ( eventSourceVal === 'self' || eventSourceVal === data._internal.viewId || eventSourceVal === data._internal.panelId ) ) {\n            evalResult = true;\n        }\n    }\n    return evalResult;\n};\n\nlet checkOperatorResult = function( performAND, performOR, performNOT, evalCheckResult, result ) {\n    if( performAND ) {\n        return evalCheckResult && result;\n    } else if( performOR ) {\n        return evalCheckResult || result;\n    } else if( performNOT ) {\n        return !result;\n    }\n    return result;\n};\n\n/**\n * Evaluates checks using expression parser utils\n * @param {Object} query Object definition containing query details to be evaluated on received object\n * @param {Array} objects Array of objects against which the query needs to be evaluated\n * @param {Object} adapterSvc Adapter service\n * @return {Boolean} verdict of expression evaluation\n */\nexport let evaluateExpressions = function( query, objects, adapterSvc ) {\n    var newValue = false;\n    var queryToUse = query;\n    var values = objects;\n    if( !_.isArray( objects ) ) {\n        values = [ objects ];\n    }\n    // determine whether all or atleast one result(s) should match\n    var matchAll = queryToUse[ exports.$ALL ];\n\n    // fetch the inner query that is value of $all\n    queryToUse = matchAll || queryToUse;\n\n    // evaluate the check on each of the value\n    newValue = values.reduce( function( valReduceResult, value ) {\n        // determine existence of multiple checks against same source inside the query\n        var performAND = queryToUse[ exports.$AND ] || queryToUse[ exports.$ALL ];\n        var performOR = queryToUse[ exports.$OR ];\n        var performNOT = queryToUse[ exports.$NOT ];\n\n        // create array of checks to be evaluated on the source\n        var evalChecks = performAND || performOR || [ queryToUse ];\n        evalChecks = performNOT ? [ performNOT ] : evalChecks;\n        var verdict = evalChecks.reduce( function( evalCheckResult, evalCheck ) {\n            var path = exports.resolve( exports.$SOURCE, evalCheck );\n            // path i.e. $source can optionally have $adapt indicating the propValue needs to be adapted before use\n            var shouldAdapt = path && path[ exports.$ADAPT ];\n            path = shouldAdapt || path;\n\n            if( !path && evalCheck && evalCheck[ exports.$EVENTSOURCE ] ) {\n                const evalResult = evaluateEventSourceExpression( evalCheck, value );\n                return checkOperatorResult( performAND, performOR, performNOT, evalCheckResult, evalResult );\n            }\n\n            var condition = exports.resolve( exports.$QUERY, evalCheck ) || evalCheck;\n            var propValue = path ? exports.resolve( path, value ) : value;\n            if( evalCheck.__useSourceParsing ) {\n                propValue = AwParseService.instance( path )( value );\n            }\n\n            if( shouldAdapt ) {\n                var valuesToAdapt = _.isArray( propValue ) ? propValue : [ propValue ];\n                propValue = adapterSvc.getAdaptedObjectsSync( valuesToAdapt );\n            }\n\n            // determine whether the query has nested queries with $all / $and / $or / $source\n            var recurseExpressionEvaluation = condition && ( condition[ exports.$NOT ] ||\n                condition[ exports.$ALL ] || condition[ exports.$AND ] || condition[ exports.$OR ] || condition[ exports.$SOURCE ] );\n            var result;\n            if( recurseExpressionEvaluation ) {\n                result = exports.evaluateExpressions( condition, propValue, adapterSvc );\n            } else {\n                result = exports.evaluateConditionExpression( condition, null, propValue );\n            }\n\n            return checkOperatorResult( performAND, performOR, performNOT, evalCheckResult, result );\n        }, performAND );\n\n        return matchAll ? valReduceResult && verdict : valReduceResult || verdict;\n    }, matchAll );\n    /**  When query contains nested $all and the values object is empty it returns the matAll query back to parseExpression API\n     *   which converts it to boolean ie. true and gives wrong output\n     *   for example\n     *   {\n     *      \"$source\": \"ctx.mselected\",\n     *      \"$query\":{\n     *         \"$all\":{\n     *            \"$source\":\"moduleType.typeHierarchyArray\",\n     *            \"$query\":{\n     *               \"$in\":[\n     *                   \"ItemRevision\"\n     *               ]\n     *            }\n     *         }\n     *       }\n     *   }\n     *   In this case is ctx.mselected is empty array i.e no selection in UI then above query returns true.\n     *   Below is the fix for the same.\n     */\n    return values.length === 0 && matchAll ? false : newValue;\n};\n\n/**\n * Evaluate conditions eg. 1. \"conditions\": { \"subscriptionId\": { \"$eq\": \"{{uid}}\" } } eg. 2. \"conditions\": {\n * \"object_desc\": { \"$eq\": \"Plane\" }, \"object_name\": { \"$eq\": \"Plane001\" } }\n *\n * @param {Object} conditions - map of conditions\n * @param { Object } vmoObj - view model object properties map\n * @return {Boolean} TRUE if all conditions are valid\n */\nexport let evaluateConditions = function( conditions, vmoObj ) {\n    var isValid = true;\n    var vmoProps = vmoObj.props;\n    for( var propName in conditions ) {\n        if( conditions[ propName ] ) {\n            if( _.isObject( conditions[ propName ] ) ) {\n                var condition = conditions[ propName ];\n                var vmoProp = vmoProps[ propName ];\n                var propValue = _getDbValueForProp( vmoProp );\n\n                var compareTo = {};\n                for( var key in condition ) {\n                    var value = condition[ key ];\n\n                    var propKey = propName + '@' + key;\n                    if( _.startsWith( value, '{{' ) ) {\n                        var propToCompare = parsingUtils.getStringBetweenDoubleMustaches( value );\n                        var prop = vmoProps[ propToCompare ];\n                        if( !prop ) {\n                            compareTo[ propKey ] = vmoObj[ propToCompare ];\n                        } else {\n                            compareTo[ propKey ] = _getDbValueForProp( prop );\n                        }\n                    } else {\n                        compareTo[ propKey ] = value;\n                    }\n                }\n\n                isValid = exports.evaluateConditionExpression( condition, propName, propValue, compareTo );\n            } else {\n                isValid = false;\n            }\n        }\n        // break if even one condition is invalid\n        if( !isValid ) {\n            break;\n        }\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {Object} condition - condition object\n * @param {Object} propName - property name\n * @param {Object} propValue - real value of the property\n * @param {Object} compareTo - real value of the property\n * @return {Boolean} TRUE if conditions are valid\n */\nexport let evaluateConditionExpression = function( condition, propName, propValue, compareTo ) {\n    var isValid = false;\n    var resolvedPropValue = null;\n\n    if( condition ) {\n        for( var key in condition ) {\n            if( key !== 'expressionType' ) {\n                if( _.startsWith( key, '$' ) && _.has( _map_expr2Function, key ) ) {\n                    var functionName = _map_expr2Function[ key ];\n                    if( _.startsWith( condition[ key ], '{{' ) ) {\n                        resolvedPropValue = compareTo[ propName + '@' + key ];\n                    } else {\n                        resolvedPropValue = condition[ key ];\n                    }\n                    if( condition.expressionType === 'Date' && propValue && resolvedPropValue ) {\n                        var parsedDates = dateParserUtils.getParsedDates( propValue, resolvedPropValue );\n                        resolvedPropValue = parsedDates.queryDate;\n                        propValue = parsedDates.sourceDate;\n                    }\n                    isValid = exports[ functionName ]( resolvedPropValue, propValue, condition.expressionType );\n                } else {\n                    isValid = false;\n                }\n            }\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\nexport let equalTo = function( condValue, propValue ) {\n    var isValid = false;\n    if( condValue && propValue ) {\n        isValid = condValue.toString() === propValue.toString();\n    } else {\n        isValid = condValue === propValue;\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether viewmodel property is of a particular type .\n *\n * @param {Object} vmo - viewmodel object\n * @param {String} type - type of property.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let typeOf = function( type, vmo ) {\n    var typeHieararchyArray = [];\n    if( vmo ) {\n        if( vmo.modelType && _.isArray( vmo.modelType.typeHierarchyArray ) ) {\n            typeHieararchyArray = vmo.modelType.typeHierarchyArray;\n        } else if( _.isArray( vmo.typeHierarchy ) ) {\n            typeHieararchyArray = vmo.typeHierarchy;\n        } else if( vmo.type ) {\n            typeHieararchyArray = vmo.type;\n        }\n    }\n\n    return typeHieararchyArray.includes( type );\n};\n\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let within = function( condValue, propValue ) {\n    var isValid = false;\n    var testValue = _.isArray( propValue ) ? propValue : [ propValue ];\n    var values = _.isArray( condValue ) ? condValue : [ condValue ];\n    isValid = values.some( function( value ) {\n        return _.indexOf( testValue, value ) >= 0;\n    } );\n    return isValid;\n};\n/**\n * Evaluating whether property value contains the condition value .\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition value is equal to property value\n */\n\nexport let notInRange = function( condValue, propValue, type ) {\n    var isNotInRange = false;\n    var isConditionValid = false;\n\n    if( condValue && condValue.length === 2 && propValue && type ) {\n        var conditionLeft = condValue[ 0 ];\n        var conditionRight = condValue[ 1 ];\n        switch ( type ) {\n            case 'Date':\n                if( _.isFinite( conditionLeft ) && _.isFinite( conditionRight ) && _.isFinite( propValue ) ) {\n                    isConditionValid = true;\n                }\n                break;\n\n            case 'Number':\n                conditionLeft = Number( conditionLeft );\n                conditionRight = Number( conditionRight );\n                propValue = Number( propValue );\n                isConditionValid = true;\n                break;\n\n            case 'String':\n                conditionLeft = conditionLeft.toString();\n                conditionRight = conditionRight.toString();\n                isConditionValid = true;\n                break;\n        }\n        if( isConditionValid && conditionLeft > propValue || conditionRight < propValue ) {\n            isNotInRange = true;\n        }\n    }\n\n    return isNotInRange;\n};\n\n/**\n * Evaluating whether property value is not in the condition value array.\n *\n * @param {Array} condValue - condition value array\n * @param {Array} propValue - property value to compare with. It should be an array containing values.\n *\n * @return {Boolean} TRUE if condition values do not contain property value\n */\n\nexport let notIn = function( condValue, propValue ) {\n    var verdict = exports.within( condValue, propValue );\n    return !verdict;\n};\n\n/**\n * Evaluating whether condition value is less than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than condition value\n */\nexport let lessThan = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn < condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is less than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is less than or equal to condition value\n */\nexport let lessThanOrEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn <= condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is greater than property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than condition value\n */\nexport let greaterThan = function( condValue, propValue ) {\n    var isValid = false;\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn > condValueIn ) {\n            isValid = true;\n        }\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is greater than or equal to property value. Only applicable for numbers\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if property value is greater than or equal to condition value\n */\nexport let greaterThanOrEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    var condValueIn = Number( condValue );\n    var propValueIn = Number( propValue );\n\n    if( _.isFinite( condValueIn ) && _.isFinite( propValueIn ) ) {\n        if( propValueIn >= condValueIn ) {\n            isValid = true;\n        }\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let notEqualTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    if( condValue && propValue ) {\n        isValid = condValue.toString() !== propValue.toString();\n    } else {\n        isValid = condValue !== propValue;\n    }\n    return isValid;\n};\n\n/**\n * Applicable for validation criteria -  Evaluating whether condition value is not equal to property value.\n *\n * @param {String} condValue - condition value\n * @param {String} propValue - property value to compare with\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let notEqualsTo = function( condValue, propValue ) {\n    var isValid = false;\n\n    if( condValue && propValue ) {\n        isValid = condValue.toString() !== propValue.toString();\n    }\n\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\nexport let regexp = function( condValue, propValue ) {\n    var isValid = false;\n    var regexp;\n    var value = propValue ? String( propValue ) : '';\n    if( _.isString( condValue ) ) {\n        regexp = new RegExp( condValue );\n    } else if( _.isObject( condValue ) && condValue.$pattern ) {\n        try {\n            regexp = new RegExp( condValue.$pattern, condValue.$options );\n        } catch ( err ) {\n            // Invalid options\n            isValid = false;\n        }\n    }\n    if( regexp ) {\n        isValid = regexp.test( value );\n    }\n    return isValid;\n};\n\n/**\n * Evaluating whether condition value matches the property value\n *\n * @param {String|Object} condValue - condition value. It can be a string to be transformed into a pattern,\n * or an object containing a $pattern and $options properties used to construct the RegExp object.\n * @param {String} propValue - property value to match against\n *\n * @return {Boolean} TRUE if condition matches the property value\n */\nexport let notInRegexp = function( condValue, propValue ) {\n    if( condValue && propValue ) {\n        return !exports.regexp( condValue, propValue );\n    }\n    return false;\n};\n\n/**\n * Enables looking up a value in given range and matching another value with the value at the same index but\n * different column in the range\n *\n * Example: Range is an array of arrays where first array holds objects and second array holds array of values.\n * range : [\n *   [ {\"uid\":\"v1\"}, {\"uid\":\"v11\"}, {\"uid\":\"v111\"} ],\n *   [ [\"color1\"], [\"color2\"], [\"color3\"] ]\n * }\n *\n * Calling vlookup with following inputs will return true:\n * vlookupInput = {\n *  \"lookupValue\" : \"v11\",\n *  \"lookupValueKey\" : \"uid\",\n *  \"matchKey\" : 1,\n *  \"matchValue\": \"color2\"\n * }\n * vlookup( vlookupInput, range ) :: returns true\n *\n * @param {Object} vlookupInput - Javascript object holding the lookupValue, lookupValueKey, matchKey and matchValue\n * @param {Object} range -        Javascript object with each value as array of string/int/boolean or objects OR\n *                                    array of string/int/boolean or object arrays\n *\n * @return {Boolean} TRUE if condition value is not equal to property value\n */\nexport let vlookup = function( vlookupInput, range ) {\n    var lookupValueKey = vlookupInput.lookupValueKey;\n    var lookupValue = vlookupInput.lookupValue;\n    var matchKey = vlookupInput.matchKey;\n    var matchValue = vlookupInput.matchValue;\n\n    var valToMatchFromRange;\n\n    // determine the lookup strategy based on type of range object\n    if( _.isArray( range ) ) {\n        // range is an array of arrays\n        var matchIndex = -1;\n        _.forEach( range, function( value ) {\n            var values = _.isArray( value ) ? value : [ value ];\n            _.forEach( values, function( currVal, arrPos ) {\n                if( currVal ) {\n                    var lookupValToMatch = lookupValueKey ? currVal[ lookupValueKey ] : currVal;\n                    if( lookupValue === lookupValToMatch ) {\n                        matchIndex = arrPos;\n                        return false;\n                    }\n                }\n                return undefined;\n            } );\n\n            if( matchIndex > -1 ) {\n                valToMatchFromRange = matchKey ? range[ matchKey ][ matchIndex ] : Object.keys( range )[ matchIndex ];\n                valToMatchFromRange = valToMatchFromRange && _.isArray( valToMatchFromRange ) && valToMatchFromRange.length > 0 ? valToMatchFromRange[ 0 ] : valToMatchFromRange;\n                return false;\n            }\n            return undefined;\n        } );\n    } else {\n        // range is an object with key value pair\n        _.forEach( range, function( value, key ) {\n            if( key === lookupValue ) {\n                valToMatchFromRange = value;\n                return false;\n            }\n            return undefined;\n        } );\n    }\n\n    return valToMatchFromRange === matchValue;\n};\n\n/* Gets eval function to cache for quicker evals in future */\n/**\n *\n * @param {String} condKey - $in\n * @param {String} propKey - modelType.typeHierarchy\n */\nexport let getEvaluationFn = function( condKey, propKey ) {\n    if( condKey[ 0 ] === '$' ) {\n        return exports[ _map_expr2Function[ condKey ] ];\n    }\n    return function() {\n        return false;\n    };\n};\n\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\nexport let isNull = function( condValue, propValue ) {\n    return !propValue;\n};\n\n/**\n * Evaluating whether property value is null\n *\n * @param {String} condValue - condition value - this is ignored\n * @param {String} propValue - property value to check for null reference\n *\n * @return {Boolean} TRUE if property value is null\n */\nexport let notNull = function( condValue, propValue ) {\n    return !exports.isNull( condValue, propValue );\n};\n\nexports = {\n    $SOURCE,\n    $QUERY,\n    $ADAPT,\n    $ALL,\n    $AND,\n    $OR,\n    $EVENTSOURCE,\n    $NOT,\n    resolve,\n    updateDynamicValues,\n    evaluateExpressions,\n    evaluateConditions,\n    evaluateConditionExpression,\n    evaluateEventSourceExpression,\n    equalTo,\n    within,\n    notInRange,\n    notIn,\n    lessThan,\n    lessThanOrEqualTo,\n    greaterThan,\n    greaterThanOrEqualTo,\n    notEqualTo,\n    notEqualsTo,\n    regexp,\n    notInRegexp,\n    vlookup,\n    isNull,\n    notNull,\n    getExpressionDataType,\n    typeOf,\n    getEvaluationFn\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}