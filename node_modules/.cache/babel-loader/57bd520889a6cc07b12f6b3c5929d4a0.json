{"ast":null,"code":"/* eslint-disable max-lines */ // Copyright (c) 2020 Siemens\n/**\n * This module defines the edit function for PL Table.\n *\n * @module js/splmTableEditor\n */import SPLMTableFillDown from'js/splmTableFillDown';import _ from'lodash';import appCtxService from'js/appCtxService';import editHandlerSvc from'js/editHandlerService';import eventBus from'js/eventBus';import logger from'js/logger';import uwPropertyService from'js/uwPropertyService';import browserUtils from'js/browserUtils';import{getEditContext,displayAutoSaveOnGuidanceMessage,displayCellEditDisabledGuidanceMessage}from'js/splmTableDirectEditUtils';import{includeComponent}from'js/moduleLoader';import{renderComponent}from'js/declReactUtils';import{AppCtxComponent}from'js/reactAppCtx';import Trv from'js/splmTableTraversal';import Const from'js/splmTableConstants';import util from'js/splmTableUtils';import Cell from'js/splmTableCellRenderer';import SelectionHelper from'js/splmTableSelectionHelper';import{jsx as _jsx}from\"react/jsx-runtime\";var SPLMTableEditor=function(tableElem,directiveElem,gridContextDispatcher){let _trv=new Trv(tableElem);let _fillDown=new SPLMTableFillDown(tableElem);let _lovValueChangedEventSubs={};let _blurHandler=null;let _focusProp=null;let _tableInstance=util.getTableInstance(tableElem);let _selectedCellInfo=null;let _saveEditPromise=null;let _isEditablePromise=null;let _escapeKeyHandler=null;let _enterKeyHandler=null;let _fillDownSaveInprogress=false;const ariaReadOnly='aria-readonly';const ariaActiveDescendant='aria-activedescendant';// cache local event subscription\nlet _eventBusSubs=[];let self=this;// eslint-disable-line no-invalid-this\nconst destroyLovEventListeners=function(){_.forEach(_lovValueChangedEventSubs,function(subscription){eventBus.unsubscribe(subscription);});_lovValueChangedEventSubs={};};self.destroy=function(){destroyLovEventListeners();_.forEach(_eventBusSubs,function(sub){eventBus.unsubscribe(sub);});_eventBusSubs=[];};self.setFocusProp=function(prop){_focusProp=prop;};const triggerBlurHandler=function(){if(_blurHandler){_blurHandler();}};self.updateEditStatus=function(){triggerBlurHandler();var cellElems=_trv.getContentCellElementsFromTable();_.forEach(cellElems,function(elem){self.updateEditStatusForCell(elem);});if(!util.isBulkEditing(tableElem)){_focusProp=null;destroyLovEventListeners();}};const toggleLinkStyle=function(element,isLinkStyle){if(isLinkStyle){// disabled to active link\nvar linkElements=element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);for(var i=linkElements.length;i>0;i--){var linkElem=linkElements[i-1];if(linkElem&&linkElem.classList){linkElem.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);linkElem.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);}}}else{// active to disabled links\nlinkElements=element.getElementsByClassName(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);for(var j=linkElements.length;j>0;j--){var linkElem1=linkElements[j-1];if(linkElem1&&linkElem1.classList){linkElem1.classList.add(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED);linkElem1.classList.remove(Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS);}}}};/**\n     * Ensure the drag handle is the last element in the parent container.\n     *\n     * @param {DOMElement} cell - cell with drag handle to re-append\n     */const ensureDragHandleLastChild=function(cell){var dragHandleElements=cell.getElementsByClassName(Const.CLASS_WIDGET_TABLE_CELL_DRAG_HANDLE);if(dragHandleElements.length>0){dragHandleElements[0].parentElement.appendChild(dragHandleElements[0]);}};const reverseEditCell=function(cell,vmo,column,cellElemProperty){if(cell.parentElement===null){return;}cell.isElementInEdit=false;var editCells=null;if(cellElemProperty.isArray){editCells=cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY);}else{editCells=cell.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP);}var isErrorProperty=false;var cellTopElement=Cell.createElement(column,vmo,tableElem,cell.parentElement);if(_tableInstance.dynamicRowHeightStatus===true){Cell.addDynamicCellHeight(vmo,cellTopElement);}if(editCells.length>0){var editCell=editCells[0];if(cellElemProperty.isArray){const editArrayPopup=_tableInstance.gridOptions.popupContext.editArrayPopup;if(editArrayPopup){editArrayPopup.hide();}}else{editCell.parentElement.removeChild(editCell);}setTimeout(function(){util.cleanupComponents(editCell);var propertyErrorElements=editCell.getElementsByClassName('aw-widgets-propertyError');if(propertyErrorElements.length>0){isErrorProperty=true;}if(isErrorProperty){cellTopElement.classList.add('aw-widgets-propertyError');}if(!cellElemProperty.isArray){util.destroyElement(editCell);}},1000);}cell.classList.remove(Const.CLASS_AW_IS_EDITING);cell.appendChild(cellTopElement);var cellTopElements=cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP);if(cellTopElements.length>0){cellTopElements[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);}ensureDragHandleLastChild(cell);};const removeFocusEvents=function(cellElem){const useCapture=true;cellElem.removeEventListener('focus',cellElem.onFocusEvent,useCapture);cellElem.onFocusEvent=null;cellElem.removeEventListener('mousedown',cellElem.onFocusClickEvent);cellElem.onFocusClickEvent=null;};let _isUserClick=false;let _isCtrlKey=false;const addFocusEvent=function(cellElem,vmo){removeFocusEvents(cellElem);const onFocusEvent=function(event){// Update row selection if clicking on editable cell. This is needed because UW widget stops propagation of the event\n// to the row element when it is created.\nif(_isUserClick){let eventObj;if(browserUtils.isIE){eventObj=document.createEvent('MouseEvent');eventObj.initMouseEvent('click',true,true,window,0,eventObj.screenX,eventObj.screenY,eventObj.clientX,eventObj.clientY,_isCtrlKey,false,false,false,0,null);}else{eventObj=new MouseEvent('click',{ctrlKey:_isCtrlKey});}cellElem.parentElement.dispatchEvent(eventObj);_isUserClick=false;_isCtrlKey=false;}self.editCell(cellElem,vmo);};cellElem.onFocusEvent=onFocusEvent;const useCapture=true;// LCS-357443: IE does not focus the cell when using element.onfocus.\n// Instead focus event must be added with addEventListener and useCapture as true.\ncellElem.addEventListener('focus',onFocusEvent,useCapture);const isFocusClickEvent=function(event){_isUserClick=true;_isCtrlKey=event.ctrlKey;};cellElem.isFocusClickEvent=isFocusClickEvent;cellElem.addEventListener('mousedown',isFocusClickEvent);};const addEditStatus=function(cellElem,cellElemProperty,vmo){if(cellElem.children[0]){cellElem.children[0].classList.add(Const.CLASS_AW_EDITABLE_CELL);var rowHeight=util.getTableRowHeight(_tableInstance.gridOptions,undefined);if(rowHeight!==undefined){cellElem.children[0].style.height=rowHeight+'px';}}else{logger.debug(cellElem.propName+' has no child');}addFocusEvent(cellElem,vmo);_fillDown.enableFillDown(cellElem);toggleLinkStyle(cellElem,false);// for saved cells in partial edit status\nvar cellTop=cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0]||cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP)[0]||cellElem.getElementsByClassName(Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY)[0];Cell.updateCellChangedClass(cellElemProperty,cellTop);if(_focusProp===cellElem.prop){self.editCell(cellElem,vmo);}};const removeBlurHandler=function(){const useCapture=true;document.body.removeEventListener('click',_blurHandler,useCapture);_trv.getScrollCanvasElementFromTable().removeEventListener('scroll',_blurHandler,useCapture);_trv.getPinCanvasElementFromTable().removeEventListener('scroll',_blurHandler,useCapture);};const removeEscapeAndEnterHandlers=function(cell){document.body.removeEventListener('keydown',_escapeKeyHandler,true);cell.removeEventListener('keydown',_enterKeyHandler,true);_escapeKeyHandler=null;_enterKeyHandler=null;};const setBlurHandler=function(blurHandler){_blurHandler=blurHandler;};const removeEditStatus=function(cellElem,cellElemProperty,vmo,skipCellCreation){const cellTopElem=cellElem.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];if(cellTopElem&&(cellTopElem.classList.contains(Const.CLASS_AW_EDITABLE_CELL)||cellTopElem.classList.contains(Const.CLASS_CELL_CHANGED))||cellElem.propIsEditableCache){if(!cellElemProperty.isArray&&!cellElem.isSelected){_fillDown.disableFillDown(cellElem);}if(!skipCellCreation){cellElem.removeChild(cellTopElem);reverseEditCell(cellElem,vmo,cellElem.columnDef,cellElemProperty);}cellElem.children[0].classList.remove(Const.CLASS_AW_EDITABLE_CELL);removeFocusEvents(cellElem);}toggleLinkStyle(cellElem,true);};self.updateEditStatusForCell=function(cellElem){var cellElemProperty=cellElem.prop;let vmo=util.getViewModelObjectByCellElement(cellElem);vmo=getVmoById(vmo.alternateID||vmo.uid);// get latest vmo from collection rather than cached\nvar vmoProp=vmo&&vmo.props&&vmo.props[cellElem.propName];if(cellElem.propName&&cellElemProperty&&cellElem.columnDef.isTreeNavigation!==true){// LCS-142669 - read modifiable besides of isEditable\nif((cellElemProperty.isEditable||vmoProp&&vmoProp.isEditable)&&cellElem.columnDef.modifiable!==false&&util.isBulkEditing(tableElem)){addEditStatus(cellElem,cellElemProperty,vmo);}else if(cellElem.isSelected&&cellElem.propIsEditableCache&&cellElemProperty.isPropInEdit){addEditStatus(cellElem,cellElemProperty,vmo);}else{removeEditStatus(cellElem,cellElemProperty,vmo);if(util.isBulkEditing(tableElem)){cellElem.setAttribute(ariaReadOnly,'true');}else if(cellElem.hasAttribute(ariaReadOnly)&&cellElem.propIsEditableCache!==false){cellElem.removeAttribute(ariaReadOnly);}}}else if(util.isBulkEditing(tableElem)){cellElem.setAttribute(ariaReadOnly,'true');}else if(cellElem.hasAttribute(ariaReadOnly)&&cellElem.propIsEditableCache!==false){cellElem.removeAttribute(ariaReadOnly);}};/**\n     * Subscribe to lovValueChangedEvent. Update dependent cells\n     */const subscribeToLovValueChangedEvent=function(cell,vmo,prop){return eventBus.subscribe(prop.propertyName+'.lovValueChanged',function(){// Update dependent LOVS only\nif(!prop.lovApi||!prop.lovApi.behaviorData||prop.lovApi.behaviorData.style!=='Interdependent'){return;}prop.lovApi.behaviorData.dependendProps.forEach(function(propertyName){// Only update cells for other props\nif(prop.propertyName!==propertyName){var row=cell.parentElement;// Find the cell\n_.forEach(row.children,function(cellElem){if(cellElem.propName===propertyName){// Update cell content\nvar oldCellTop=cellElem.children[0];var newCellTop=Cell.createElement(cellElem.columnDef,row.vmo,tableElem,row);if(_tableInstance.dynamicRowHeightStatus===true){Cell.addDynamicCellHeight(vmo,newCellTop);}newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);cellElem.replaceChild(newCellTop,oldCellTop);cellElem.isDependantEdit=true;if(!util.isBulkEditing(tableElem)&&util.isAutoSaveEnabled(tableElem)){self.removeAllCellSelection();self.editCell(cellElem,vmo);}return false;}return true;});}});});};/**\n     * Cancels edits if isDirty() comes back false\n     */const cancelEditsIfNotDirty=function(){const context=getEditContext(_tableInstance);let editHandler=null;let isDirtyPromise;if(context){editHandler=editHandlerSvc.getEditHandler(context);isDirtyPromise=editHandler.isDirty();}else if(_tableInstance.dataProvider.getEditConfiguration()){isDirtyPromise=_tableInstance.dataProvider.isDirty();}else if(_tableInstance.declViewModel.getEditConfiguration()){isDirtyPromise=_tableInstance.declViewModel.isDirty();}if(isDirtyPromise){isDirtyPromise.then(function(isDirty){// If the handler is not dirty cancel edits to get out of edit mode.\nif(!isDirty){if(editHandler){editHandler.cancelEdits();}else if(_tableInstance.dataProvider.getEditConfiguration()){const dataCtxNode={data:_tableInstance.declViewModel,ctx:appCtxService.ctx};_tableInstance.dataProvider.cancelEdits(dataCtxNode,_tableInstance.declViewModel);}else if(_tableInstance.declViewModel.getEditConfiguration()){_tableInstance.declViewModel.cancelEdits();}}});}};/**\n     * Handles cell editing functionality for the blur event\n     * @param {Event} event - the blur event\n     * @param {DOMElement} cell - The cell element\n     * @param {ViewModelProperty} prop - The property\n     * @param {ViewModelObject} vmo - The view model object\n     */const handleCellEditBlur=function(event,cell,prop,vmo){// Autosave the cell on blur when in autosave mode\nif(!util.isBulkEditing(tableElem)&&util.isAutoSaveEnabled(tableElem)&&event&&!_fillDownSaveInprogress){// Stop the event bubbling so save can finish first, we will resend the click when save is finished\nevent.stopPropagation();event.preventDefault();_fillDown.disableFillDown(cell);// get target vmo/prop if clicking on table so we can resend click to it after\nconst tableCell=util.closestElement(event.target,'.ui-grid-cell');let vmo;let propName;if(tableCell){propName=tableCell.propName;vmo=util.getViewModelObjectByCellElement(tableCell);}_saveEditPromise=self.saveEdit([cell]).then(()=>{_saveEditPromise=null;if(!tableCell){let clickElement=event.target;// Elements like svg don't have a click function, so bubble up till we have a clickable element.\nwhile(!clickElement.click){clickElement=clickElement.parentElement;}clickElement.click();}else{// reselect table cell\nlet uid=vmo&&vmo.alternateID||vmo.uid;let cellToSelect=util.getCellElementsByPropertyAndUid(tableElem,propName,uid)[0];cellToSelect&&cellToSelect.click&&cellToSelect.click();}});}else if(!util.isBulkEditing(tableElem)&&!util.isAutoSaveEnabled(tableElem)){cancelEditsIfNotDirty();removeEditStatus(cell,prop,vmo,true);}};/**\n     * Returns the focusable cell info if it is focusable\n     *\n     * @param {Object} column - the column\n     * @param {ViewModelObject} vmo - the vmo\n     *\n     * @return {Object} the focusable cell's info\n     */const getFocusableCellInfo=function(column,vmo){if(column.modifiable!==false&&!column.isTreeNavigation){const propName=column.propertyName||column.field;const prop=vmo.props[propName];if(prop&&prop.isEditable){return{vmo:vmo,column:column};}}return null;};/**\n     * Returns the info of the next focusable cell\n     *\n     * @param {ViewModelObject} currentVMO - the current vmo\n     * @param {Object} currentColumn - the current column\n     * @param {boolean} reverseDirection - true if going in the reverse direction\n     *\n     * @return {Object} the next focusable cell's info\n     */const getNextFocusableCellInfo=(currentVMO,currentColumn,reverseDirection)=>{let columns=_tableInstance.dataProvider.cols.filter(function(col){return!col.hiddenFlag;});const currentIdx=columns.indexOf(currentColumn);// Reverse the columns order if we are going in reverse\nif(reverseDirection){columns=columns.slice().reverse();}for(let i=currentIdx+1;i<columns.length;i++){const col=columns[i];const focusableCellInfo=getFocusableCellInfo(col,currentVMO);if(focusableCellInfo){return focusableCellInfo;}}// If no cell was found, check next vmo until found  -- Limit - Until end of data, will not page while looking\nconst loadedVMOs=_tableInstance.dataProvider.viewModelCollection.loadedVMObjects;const currentVMOIndex=_tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(currentVMO.uid);for(let i=currentVMOIndex+1;i<loadedVMOs.length;i++){const nextVMO=loadedVMOs[i];for(let y=0;y<columns.length;y++){const col=columns[y];const focusableCellInfo=getFocusableCellInfo(col,nextVMO);if(focusableCellInfo){return focusableCellInfo;}}}// If we still haven't found anything, then there are no more editable cells available, return null\nreturn null;};/**\n     * Attaches the keydown handler to a cell\n     * @param {DOMElement} cellElem The cell element\n     */const attachKeydownHandler=cellElem=>{cellElem.onkeydown=event=>{if(event.code!=='Tab'){return;}let reverseTab=false;if(event.shiftKey){reverseTab=true;}// Now check vmo for next editable column.\nconst closestVMO=event.target.closest('.ui-grid-row').vmo;const column=event.target.closest('.ui-grid-cell').columnDef;const nextEditableInfo=getNextFocusableCellInfo(closestVMO,column,reverseTab);// Scroll to that cell if exists\nif(nextEditableInfo){event.preventDefault();event.stopPropagation();const vmoIndex=_tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(nextEditableInfo.vmo.uid);triggerBlurHandler();_tableInstance.renderer.scrollToRowIndex([vmoIndex]);if(!nextEditableInfo.column.pinnedLeft){_tableInstance.renderer.scrollToColumn(nextEditableInfo.column);}setTimeout(()=>{// Get the cell and focus it after it is scrolled into view\nconst firstRowOnDom=tableElem.getElementsByClassName('ui-grid-row')[0];if(firstRowOnDom){const editableRowRelativeIdx=vmoIndex-firstRowOnDom.getAttribute('data-indexNumber');let rowElem;if(nextEditableInfo.column.pinnedLeft){rowElem=_trv.getPinContentRowElementFromTable(editableRowRelativeIdx);}else{rowElem=_trv.getScrollContentRowElementFromTable(editableRowRelativeIdx);}const cellElems=rowElem&&rowElem.getElementsByClassName('ui-grid-cell')||[];const foundCell=_.filter(cellElems,{columnDef:nextEditableInfo.column})[0];if(foundCell){self.editCell(foundCell,nextEditableInfo.vmo);}}},200);}};};const attachEscapeKeyHandler=(cell,prop,vmo,column)=>{// Set listener for Escape key and reverse edit cell\n_escapeKeyHandler=event=>{if(event.key!=='Escape'){return;}const currentCell=util.closestElement(event.target,'.'+Const.CLASS_CELL);if(currentCell===cell&&cell.isElementInEdit){event.stopPropagation();uwPropertyService.resetUpdates(prop);reverseEditCell(cell,vmo,column,prop);if(!util.isBulkEditing(tableElem)){prop.isPropInEdit=false;removeEditStatus(cell,prop,vmo,true);// Check if isDirty still, is so, do nothing, else cancel edits\ncancelEditsIfNotDirty();removeEscapeAndEnterHandlers(cell);cell.focus();}else{// Readd click handler to allow cell to go back into edit\naddFocusEvent(cell,vmo);}}else{const context=getEditContext(_tableInstance);let editHandler=editHandlerSvc.getEditHandler(context);if(editHandler){editHandler.cancelEdits();}else if(_tableInstance.dataProvider.getEditConfiguration()){const dataCtxNode={data:_tableInstance.declViewModel,ctx:appCtxService.ctx};_tableInstance.dataProvider.cancelEdits(dataCtxNode,_tableInstance.declViewModel);}else if(_tableInstance.declViewModel.getEditConfiguration()){_tableInstance.declViewModel.cancelEdits();}}};document.body.addEventListener('keydown',_escapeKeyHandler,true);};const attachEnterKeyHandler=(cell,blurHandler)=>{const hasPopupExpanded=element=>{const popupVisible=element.getElementsByClassName('aw-jswidgets-popUpVisible');const expanded=element.getElementsByClassName('aw-jswidgets-expanded');return popupVisible.length+expanded.length>0;};_enterKeyHandler=event=>{if(event.key==='Enter'&&!event.altKey&&!util.isBulkEditing(tableElem)){const currentCell=util.closestElement(event.target,'.'+Const.CLASS_CELL);// Special handling for array properties\nconst isArrayProperty=currentCell.prop&&currentCell.prop.isArray;if(isArrayProperty){if(event.target.value===''){event.stopPropagation();blurHandler(event);if(!util.isBulkEditing(tableElem)){currentCell.focus();}}}else{// If there isn't a popup in the children, then call blurhandler\nif(currentCell&&!hasPopupExpanded(currentCell)){event.stopPropagation();blurHandler(event);if(_saveEditPromise){_saveEditPromise.then(function(){currentCell.focus();});}else{currentCell.focus();}}}}};cell.addEventListener('keydown',_enterKeyHandler,true);};/**\n     * Publishes teh cell start edit event\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */const publishCellStartEditEvent=function(cell,vmo){const eventData={columnInfo:cell.columnDef,gridId:tableElem.id,vmo:vmo};eventBus.publish(tableElem.id+'.cellStartEdit',eventData);};const getVmoById=function(vmoId){let idx=_tableInstance.dataProvider.viewModelCollection.findViewModelObjectById(vmoId);return _tableInstance.dataProvider.viewModelCollection.loadedVMObjects[idx];};/**\n     * Unsubscribes from the hold lov value change event and subscribes to a new one\n     * @param {DOMElement} cell the cell element\n     * @param {Object} vmo the view model object\n     * @param {Object} prop The property\n     */const handleLovValueChangedEvent=function(cell,vmo,prop){const lovValueChangedEventSub=subscribeToLovValueChangedEvent(cell,vmo,prop);let oldLovSubscr=_lovValueChangedEventSubs[prop.parentUid+prop.propertyName];if(oldLovSubscr){eventBus.unsubscribe(oldLovSubscr);delete _lovValueChangedEventSubs[prop.parentUid+prop.propertyName];}_lovValueChangedEventSubs[prop.parentUid+prop.propertyName]=lovValueChangedEventSub;};const isUserInteractingWithDropDown=(prop,event)=>{if(prop.hasLov&&event){const listBoxDrop=document.querySelector('.sw-lov-contentContainer');if(listBoxDrop&&listBoxDrop.contains(event.target)){return true;}}else if(prop.type&&event&&(prop.type==='DATE'||prop.type==='DATEARRAY')){const datePicker=document.querySelector('.flatpickr-calendar.open');if(datePicker&&datePicker.contains(event.target)){return true;}const dateTimeDrop=document.querySelector('.sw-popup-contentContainer .aw-base-scrollPanel');if(dateTimeDrop&&dateTimeDrop.contains(event.target)){return true;}}else if(prop.type&&event&&prop.type==='STRING'&&prop.isRichText){const ckEditor=document.getElementsByClassName('ck-body-wrapper')[0];if(ckEditor&&ckEditor.contains(event.target)){return true;}}return false;};/**\n     * Creates the edit cell and attaches it to the DOM\n     * @param {Object} vmo - the view model object\n     * @param {AwColumnDef} column The column definition\n     * @param {DOMElement} cell The cell element\n     */const createAndAttachEditCell=function(vmo,column,cell){// for array fields, application should use popup to display it,\n// or you will face cut off issues: LCS-161794\nconst prop=vmo.props[cell.propName];prop.autofocus=true;let editNonArrayClass=prop.isArray?Const.CLASS_TABLE_EDIT_CELL_ARRAY:Const.CLASS_TABLE_EDIT_CELL_NON_ARRAY;let editCellElem=util.createElement('div','aw-splm-tableEditCellTop',editNonArrayClass);let editContainer=util.createElement('div','aw-jswidgets-tableEditContainer','aw-jswidgets-cellTop');/* revisitme Brad\n         * Revisit/revise for support of column def providing rendering hint\n         * column.renderingHint\n         */let propertyValElem=includeComponent('SplmTableCellEditor',{vmo,name:prop.propertyName});renderComponent(/*#__PURE__*/_jsx(AppCtxComponent,{children:propertyValElem}),editContainer);editCellElem.appendChild(editContainer);attachKeydownHandler(editCellElem);Cell.updateCellChangedClass(prop,editCellElem.getElementsByClassName(Const.CLASS_AW_JS_CELL_TOP)[0]);if(prop.isArray&&_tableInstance.gridOptions.popupContext&&_tableInstance.gridOptions.popupContext.editArrayPopup){const cellBoundingArea=cell.getBoundingClientRect();const popupOptions={whenParentScrolls:'follow',innerClassName:Const.CLASS_TABLE_EDIT_CELL_TOP_ARRAY,autoFocus:false,parent:cell,reference:cell,overlapOnReference:true,containerWidth:cellBoundingArea.width,width:cellBoundingArea.width,forceCloseOthers:false};const editArrayPopup=_tableInstance.gridOptions.popupContext.editArrayPopup;if(editArrayPopup){editArrayPopup.hide().then(()=>{editArrayPopup.show(popupOptions).then(popupRef=>{self.popupRef=popupRef;});});}}else{cell.insertBefore(editCellElem,cell.childNodes[0]);}};/**\n     * Starts the edit of the cell\n     * @param {DOMElement} cell The cell element\n     * @param {Object} vmo the view model object\n     */self.editCell=function(cell,vmo){const column=cell.columnDef;const prop=cell.prop;if(!cell.isDependantEdit&&(!cell.isSelected&&!util.isBulkEditing(tableElem)||cell.isElementInEdit===true)){return;}gridContextDispatcher({type:'UPDATE_VALUES',editVmo:vmo,editPropertyName:cell.propName});publishCellStartEditEvent(cell,vmo);// Trigger blur handler\ntriggerBlurHandler();cell.isElementInEdit=true;prop.isPropInEdit=true;cell.classList.add(Const.CLASS_AW_IS_EDITING);// Handle possible lov value changes\nhandleLovValueChangedEvent(cell,vmo,prop);// Remove cell top\nlet editableGridCell=cell.getElementsByClassName(Const.CLASS_TABLE_CELL_TOP)[0];if(editableGridCell){cell.removeChild(editableGridCell);}let originAutoFocus=prop.autofocus;createAndAttachEditCell(vmo,column,cell);removeFocusEvents(cell);const blurHandler=function(event){// Only revert edit status if scrolling with array (popup)\nif(event&&event.type==='scroll'&&cell.prop&&!cell.prop.isArray){return;}let selectedCell=null;if(event&&event.type!=='keydown'){_focusProp=null;selectedCell=util.closestElement(event.target,\".\".concat(Const.CLASS_CELL));}if(!cell.isElementInEdit){removeBlurHandler();removeEscapeAndEnterHandlers(cell);}else if(selectedCell!==cell&&cell.isElementInEdit){// Close panels\nlet panelContext=appCtxService.getCtx('panelContext');if(panelContext&&panelContext.addTypeRef===true){// If clicking on different cell close the panel else leave it open\nif(cell.propName!==prop.propertyName||cell.parentElement.vmo.uid!==prop.parentUid){eventBus.publish('completed',{source:'toolAndInfoPanel'});}else{return;}}if(isUserInteractingWithDropDown(prop,event)){return true;}// Remove the blur handler since cell is going out of edit\nremoveBlurHandler();removeEscapeAndEnterHandlers(cell);// Reverse the cell edit\nreverseEditCell(cell,vmo,column,prop);prop.autofocus=originAutoFocus;prop.isPropInEdit=false;cell.isSelected=false;delete cell.isDependantEdit;// Handle cell editing functionality on blur\nhandleCellEditBlur(event,cell,prop,vmo);// Readd click handler to allow cell to go back into edit\naddFocusEvent(cell,vmo);}};// Add blur handler to take cell out of edit on click away\nremoveBlurHandler();removeEscapeAndEnterHandlers(cell);// Setting useCapture to true is needed for autosave since it allows us to detect the click before the target\n// element does.\nconst useCapture=true;document.body.addEventListener('click',blurHandler,useCapture);const scrollViewportElem=_trv.getScrollCanvasElementFromTable();const pinViewportElem=_trv.getPinCanvasElementFromTable();scrollViewportElem.removeEventListener('scroll',blurHandler,useCapture);pinViewportElem.removeEventListener('scroll',blurHandler,useCapture);scrollViewportElem.addEventListener('scroll',blurHandler,useCapture);pinViewportElem.addEventListener('scroll',blurHandler,useCapture);attachEscapeKeyHandler(cell,prop,vmo,column);attachEnterKeyHandler(cell,blurHandler);setBlurHandler(blurHandler);};self.isPropertiesEditablePromise=function(editOptions){let editPromise;const editContext=getEditContext(_tableInstance);if(editContext){// Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n// can be editing at any given time.\nconst previousActiveHandler=editHandlerSvc.getActiveEditHandler();if(previousActiveHandler&&previousActiveHandler!==editHandlerSvc.getEditHandler(editContext)&&previousActiveHandler.editInProgress()){editPromise=new Promise(resolve=>{previousActiveHandler.leaveConfirmation(()=>{editHandlerSvc.setActiveEditHandlerContext(editContext);editHandlerSvc.startEdit(editOptions).then(()=>{resolve();});});});}else{editHandlerSvc.setActiveEditHandlerContext(editContext);editPromise=editHandlerSvc.startEdit(editOptions);}}else if(_tableInstance.dataProvider.getEditConfiguration()){const dataCtxNode={data:_tableInstance.declViewModel,ctx:appCtxService.ctx};editPromise=_tableInstance.dataProvider.startEdit(dataCtxNode,_tableInstance.declViewModel,editOptions);}else if(_tableInstance.declViewModel.getEditConfiguration()){editPromise=_tableInstance.declViewModel.startEdit(editOptions);}return editPromise?editPromise:Promise.resolve(false);};/**\n     * Checks if the provided cell/property is editable by calling startEdit on the editHandler or editConfig\n     * @param {Object} vmo The view model object\n     * @param {DOMElement} cellElem The cell element\n     *\n     * @returns {Promise<Boolean>} Promise that will resolve to the editability of the property\n     */const isCellEditable=async function(vmo,cellElem){// Allow save to finish before checking start edit\nif(_saveEditPromise){await _saveEditPromise;}let prop=vmo.props[cellElem.propName];let propertyNames=[prop.propertyName];// Need to pass all dependent props to ensure we have latest lsd\nif(prop.lovApi&&prop.lovApi.behaviorData&&prop.lovApi.behaviorData.style==='Interdependent'){propertyNames=prop.lovApi.behaviorData.dependendProps;}let editOpts={vmos:[vmo],propertyNames:propertyNames,autoSave:util.isAutoSaveEnabled(tableElem)};const result=await self.isPropertiesEditablePromise(editOpts);if(result===false){return false;}// update prop to latest\nprop=vmo.props[cellElem.propName];return prop&&prop.isEditable&&prop.isEnabled!==false;};/**\n     * Saved the provided cell/property that was edited\n     * @param {DOMElement[]} cells the cells to save\n     * @returns {Promise<Boolean>} Promise that will resolve when save is complete\n     */self.saveEdit=function(cells){let isPartialSaveDisabled=true;let editPromise=null;const editContext=getEditContext(_tableInstance);if(editContext){editPromise=editHandlerSvc.saveEdits(editContext,isPartialSaveDisabled,util.isAutoSaveEnabled(tableElem));}else if(_tableInstance.dataProvider.getEditConfiguration()){const dataCtxNode={data:_tableInstance.declViewModel,ctx:appCtxService.ctx};editPromise=_tableInstance.dataProvider.saveEdits(dataCtxNode,_tableInstance.declViewModel);}else if(_tableInstance.declViewModel.getEditConfiguration()){editPromise=_tableInstance.declViewModel.saveEdits();}if(editPromise){return editPromise.finally(function(){self.setCellEditingContext(false);for(let i=0;i<cells.length;i++){if(document.body.contains(cells[i])){self.updateEditStatusForCell(cells[i]);}}// Clear prop is editable cache to ensure newly selected cell makes a startEdit call, since\n// our save call will likely invalidate the editable cache. This is also ensuring that double click on\n// another cell takes that cell into edit instead of selected state.\nself.clearPropIsEditableCache();});}return Promise.resolve(false);};/**\n     * Removes the selected and selectedEditable css classes from any elements that have them\n     */const removeCellSelection=function(){// Remove all other \"selected\" classes from cells\nlet selected1=Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE));let selected2=Array.prototype.slice.call(tableElem.getElementsByClassName(Const.CLASS_TABLE_CELL_SELECTED));let elems=selected1.concat(selected2);for(let i=0;i<elems.length;i++){elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);elems[i].classList.remove(Const.CLASS_TABLE_CELL_SELECTED);let containerElement=null;// The below method can result in undefined value.\ncontainerElement=_trv.getTableContainerElementFromTable();if(containerElement&&containerElement.hasAttribute(ariaActiveDescendant)){containerElement.removeAttribute(ariaActiveDescendant);}}};/**\n     * Updates the cell to be selected and sets selection/edit info to false on old selected cell\n     * @param {DOMElement} cell The new selected cell\n     * @param {Boolean} persistEditableFlag flag to denote if isEditable should be persisted\n     */const updateSelectedCell=function(cell,persistEditableFlag){if(_selectedCellInfo&&_selectedCellInfo.cell){let _cell=_selectedCellInfo.cell;_cell.isSelected=false;const vmo=getVmoById(_selectedCellInfo.vmoId);// If prop edit is not enabled we should not touch the prop.isEditable flag\nif(!persistEditableFlag&&vmo&&_cell.prop&&util.isPropEditEnabled(tableElem)&&!util.isBulkEditing(tableElem)){_cell.prop.isEditable=false;if(vmo.props&&vmo.props[_cell.propName]){vmo.props[_cell.propName].isEditable=false;}}}if(cell){cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED);cell.isSelected=true;let refVmo=util.getViewModelObjectByCellElement(cell);let vmoId=refVmo.alternateID||refVmo.uid;_selectedCellInfo={cell:cell,vmoId:vmoId};let containerElement=null;// The below method can result in undefined value.\ncontainerElement=_trv.getTableContainerElementFromTable();if(containerElement){containerElement.setAttribute(ariaActiveDescendant,cell.getAttribute('id'));}}else{_selectedCellInfo=null;}};self.clearPropIsEditableCache=function(persistEditableFlag){const cellElems=_trv.getContentCellElementsFromTable();_.forEach(cellElems,function(elem){delete elem.propIsEditableCache;if(elem.hasAttribute(ariaReadOnly)){elem.removeAttribute(ariaReadOnly);}});// Reset cell selection since we are clearing editibility cache\n// making the editability selection classes no longer valid\nremoveCellSelection();const currentSelectedCell=_selectedCellInfo?_selectedCellInfo.cell:null;updateSelectedCell(null,persistEditableFlag);if(currentSelectedCell&&currentSelectedCell.parentElement){const eventObject={ctrlKey:false,shiftKey:false,type:'click'};self.onClickHandler(eventObject,currentSelectedCell,util.getViewModelObjectByCellElement(currentSelectedCell));}};/**\n     * Update the cell editability by using the cached editability or loading the editability if it is not cached\n     * @param {DOMElement} cell - The cell element to get editability for\n     * @param {Object} vmo - the row's view model object\n     */const updateCellEditability=function(cell,vmo){// Make some SOA call here for getting the editability\nremoveCellSelection();updateSelectedCell(cell);// Check if cellEdit is enabled and if this cell/prop type supports edit\nconst isCellEditSupported=util.isPropEditEnabled(tableElem)&&cell.propName&&cell.prop&&cell.columnDef.isTreeNavigation!==true;if(!isCellEditSupported){cell.setAttribute(ariaReadOnly,'true');return;}// If prop is modified we can restore editability cache since we know it has not been saved\n// and was previously editable\nif(uwPropertyService.isModified(cell.prop)&&cell.propIsEditableCache===undefined&&!util.isAutoSaveEnabled(tableElem)){cell.propIsEditableCache=true;}// Check if editability info exists, if not\n// Check columnDef if editable, if not add readonly class\n// If editable, make startEdit call to get editability for cell\nif(cell.columnDef.name!=='icon'&&cell.columnDef.modifiable!==false&&cell.propIsEditableCache===undefined){// only allow one check at a time.\nconst cellEditablePromise=function(){return isCellEditable(vmo,cell).then(function(isEditable){cell.propIsEditableCache=isEditable;if(cell.propIsEditableCache===false){cell.setAttribute(ariaReadOnly,'true');}else if(cell.hasAttribute(ariaReadOnly)){cell.removeAttribute(ariaReadOnly);}if(cell.isSelected){if(isEditable){cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);}_fillDown.enableFillDown(cell);}}).then(function(){delete cell.isCellEditablePromise;_isEditablePromise=null;});};if(_isEditablePromise){_isEditablePromise.then(function(){removeCellSelection();updateSelectedCell(cell);_isEditablePromise=cellEditablePromise();cell.isCellEditablePromise=_isEditablePromise;});}else{_isEditablePromise=cellEditablePromise();cell.isCellEditablePromise=_isEditablePromise;}return;}if(cell.propIsEditableCache){// Mark the prop as editable since the cache tells us it is editable\ncell.prop.isEditable=true;vmo.props[cell.propName].isEditable=true;cell.classList.add(Const.CLASS_TABLE_CELL_SELECTED_EDITABLE);if(cell.hasAttribute(ariaReadOnly)){cell.removeAttribute(ariaReadOnly);}}else if(cell.propIsEditableCache===false){cell.setAttribute(ariaReadOnly,'true');}};let _guidanceMessageInitialized=false;const publishCellNotEditable=function(vmo,prop){eventBus.publish(_tableInstance.gridId+'.plTable.cellNotEditable',{vmo:vmo,prop:prop});};/**\n     * Updates ctx and the editHandler/editConfig to be in editing mode when autosave is off.\n     * Doing this ensures the edit command will get toggled when editing in autosave off mode.\n     * @param {Boolean} isEditing - If in edit\n     */self.setCellEditingContext=function(isEditing){// Enable/disable caching\nif(isEditing){_tableInstance.dataProvider.cacheCollapse=isEditing;}else{_tableInstance.dataProvider.restoreInitialCacheCollapseState();}_tableInstance.controller.setDraggable(!isEditing);// For autosave off we need to see _editing flag and update ctx to get commands to switch over\nif(!util.isAutoSaveEnabled(tableElem)){const editContext=getEditContext(_tableInstance);if(editContext){const editHandler=editHandlerSvc.getEditHandler(editContext);editHandler._editing=isEditing;// Add to the appCtx about the editing state\nappCtxService.updateCtx('editInProgress',editHandler._editing);// Need to ensure this handler is active so that save command will call this handler\neditHandlerSvc.setActiveEditHandlerContext(editContext);// We need to ensure edit handler and edithandlerState to be in sync.\nif(editHandler.editStateChangeDispatcher){editHandler.editStateChangeDispatcher({type:'SET_EDIT_STATE_CHANGED',value:editHandler._editing});}}else if(_tableInstance.dataProvider.getEditConfiguration()){_tableInstance.dataProvider._editing=isEditing;// Add to the appCtx about the editing state\nappCtxService.updateCtx(_tableInstance.dataProvider._appCtxEditInProgress,_tableInstance.dataProvider._editing);}else if(_tableInstance.declViewModel.getEditConfiguration()){_tableInstance.declViewModel._editing=isEditing;// Add to the appCtx about the editing state\nappCtxService.updateCtx(_tableInstance.declViewModel._internal.eventTopicEditInProgress,_tableInstance.declViewModel._editing);}}// Display guidance message when auto save is off for auto save only table\nconst isAutoSaveContextTrue=appCtxService.getCtx('autoSave')&&appCtxService.getCtx('autoSave.dbValue');if(!isAutoSaveContextTrue&&tableElem._tableInstance.gridOptions.forceAutoSave&&isEditing&&!util.isCellEditing(tableElem)&&!_guidanceMessageInitialized){_guidanceMessageInitialized=true;displayAutoSaveOnGuidanceMessage(tableElem);}util.setIsCellEditing(tableElem,isEditing);};let _cellEditDisabledMessageInitialized=null;const isCellSelectedNotEditable=function(cell){return cell&&cell.isSelected&&cell.prop&&cell.prop.isEditable===false;};/**\n     * Handles the direct edit handling for cell selection\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo the view model object\n     */const handleDirectEdit=function(cell,vmo){// Start edit\nremoveCellSelection();// Check if prop isEditable needs to be reset since cache says it is true\nif(!cell.prop.isEditable){cell.prop.isEditable=true;if(vmo.props&&vmo.props[cell.propName]){vmo.props[cell.propName].isEditable=true;}}// Trigger leave confirmation on previous active handler in case it was editing since only one editHandler\n// can be editing at any given time.\nconst editContext=getEditContext(_tableInstance);const previousActiveHandler=editHandlerSvc.getActiveEditHandler();if(editContext&&previousActiveHandler&&previousActiveHandler!==editHandlerSvc.getEditHandler(editContext)&&previousActiveHandler.editInProgress()){previousActiveHandler.leaveConfirmation(()=>{editHandlerSvc.setActiveEditHandlerContext(editContext);// Reregister leaveHandler since we are making the handler active again without calling startEdit\neditHandlerSvc.getEditHandler(editContext).reregisterLeaveHandler();self.editCell(cell,vmo);self.setCellEditingContext(true);});}else{self.editCell(cell,vmo);self.setCellEditingContext(true);}};/**\n     * Handles cell click when pending isEditable Promise\n     * @param {HTMLElement} cell The cell\n     * @param {Object} vmo The view model object\n     */const handlePendingEditSelection=async function(cell,vmo){// Prevent multiple calls to resolve editable promise\ncell.isCellEditablePromiseResolving=true;await cell.isCellEditablePromise;delete cell.isCellEditablePromiseResolving;if(cell.isSelected){if(cell.propIsEditableCache){_focusProp=cell.prop;removeCellSelection();// Check if prop isEditable needs to be reset since cache says it is true\nif(!cell.prop.isEditable){cell.prop.isEditable=true;if(vmo.props&&vmo.props[cell.propName]){vmo.props[cell.propName].isEditable=true;}}self.editCell(cell,vmo);self.setCellEditingContext(true);}else{publishCellNotEditable(vmo,cell.prop);}}};/**\n     * Click handler for cell/row. Will select the cell and row or start edit as needed\n     *\n     * @param {Event} event the click event\n     * @param {DOMElement} cell the cell in question\n     * @param {ViewModelObject} vmo The vmo for the row\n     */self.onClickHandler=async(event,cell,vmo)=>{if(util.isBulkEditing(tableElem)){return;}if(event.ctrlKey){triggerBlurHandler();removeCellSelection();updateSelectedCell(null);if(util.isCellHeaderSelectionEnabled(tableElem)){SelectionHelper.setCellHeaderSelection(null,tableElem);}return;}if(cell.isSelected&&cell.propIsEditableCache&&!cell.isElementInEdit){handleDirectEdit(cell,vmo);}else if(cell.isSelected&&util.isPropEditEnabled(tableElem)===false&&!_cellEditDisabledMessageInitialized){// Display guidance message when cell editing is disabled\n_cellEditDisabledMessageInitialized=true;displayCellEditDisabledGuidanceMessage(tableElem);}else if(cell.isSelected&&cell.isCellEditablePromise&&!cell.isCellEditablePromiseResolving){handlePendingEditSelection(cell,vmo);}else if(!cell.isSelected&&!event.shiftKey){await updateCellEditability(cell,vmo);_fillDown.enableFillDown(cell);if(util.isCellHeaderSelectionEnabled(tableElem)){SelectionHelper.setCellHeaderSelection(cell,tableElem);}}else if(event.shiftKey){triggerBlurHandler();removeCellSelection();updateSelectedCell(null);}else if(!cell.isCellEditablePromiseResolving&&isCellSelectedNotEditable(cell)){publishCellNotEditable(vmo,cell.prop);}};/**\n     * Adds the onclick event listener for an individual cell and gets its editability\n     * @param {DOMElement} cell - The cell to set the listener for\n     * @param {Object} vmo - The row's VMO\n     */self.addCellClickListener=function(cell,vmo){cell.onclick=function(event){// if command click or url/anchor tag click don't select/handle select\nif(!event.target.closest('.aw-command, a.aw-splm-tablePropertyValueLinks')){self.onClickHandler(event,cell,vmo);}};cell.oncontextmenu=function(event){if(!util.isBulkEditing(tableElem)&&!cell.isSelected){updateCellEditability(cell,vmo);}};};/**\n     * Removes the cell selected classes as well as the selected attribute for the cell.\n     */self.removeAllCellSelection=function(){removeCellSelection();updateSelectedCell();};/**\n     * Checks if the current selected cell is on the newly selected vmo(s), if not remove selection\n     * @param {Object} eventData event data\n     */const checkCellAndVMOSelection=function(eventData){let selectedObjects=eventData.selectedObjects;if(_selectedCellInfo&&_selectedCellInfo.vmoId){const vmo=getVmoById(_selectedCellInfo.vmoId);if(selectedObjects.indexOf(vmo)===-1){self.removeAllCellSelection();}}};const isEligibleForCopyDown=function(columnDef){if(util.isPropEditEnabled(tableElem)&&columnDef.isTreeNavigation!==true&&columnDef.name!=='icon'&&columnDef.modifiable!==false){return true;}return false;};const copyPropertyToCellContent=function(sourceProperty,vmoUid){let cellElements=util.getCellElementsByPropertyAndUid(tableElem,sourceProperty.propertyName,vmoUid);for(let i=0;i<cellElements.length;i++){let cellElem=cellElements[i];let row=cellElem.parentElement;let oldCellTop=cellElem.children[0];let newCellTop=Cell.createElement(cellElem.columnDef,row.vmo,tableElem,row);if(util.isBulkEditing(tableElem)){newCellTop.classList.add(Const.CLASS_AW_EDITABLE_CELL);}cellElem.replaceChild(newCellTop,oldCellTop);}};const copyFillDownProperty=function(targetProperty,sourceProperty){targetProperty.uiValue=sourceProperty.uiValue;targetProperty.dbValue=sourceProperty.dbValue;targetProperty.valueUpdated=true;uwPropertyService.updateViewModelProperty(targetProperty);};const loadCellEditabilityForTargetCells=function(uid2CellMap,vmos,propertyNames){let editOpts={vmos:vmos,propertyNames:propertyNames,autoSave:util.isAutoSaveEnabled(tableElem)};return self.isPropertiesEditablePromise(editOpts).then(function(result){for(let currentVmo of vmos){let cell=uid2CellMap[currentVmo.uid];if(cell){cell.propIsEditableCache=result===false?false:cell.prop&&cell.prop.isEditable;if(cell.propIsEditableCache===false){cell.setAttribute(ariaReadOnly,'true');}}}return Promise.resolve(result);});};const modifyPropsForCellEdit=function(result,vmosToEdit,eventData,cellsToSave,cellMap,sourceProp){if(result===false){return;}let propsModified=false;for(let i=0;i<vmosToEdit.length;i++){let currentVMO=vmosToEdit[i];const targetProp=currentVMO.props[eventData.propertyName];if(sourceProp&&targetProp&&targetProp.isPropertyModifiable&&targetProp.editable){propsModified=true;cellsToSave.push(cellMap[currentVMO.uid]);// update the target using the source\ncopyFillDownProperty(targetProp,sourceProp);copyPropertyToCellContent(sourceProp,currentVMO.uid);}}if(propsModified){if(util.isAutoSaveEnabled(tableElem)){self.saveEdit(cellsToSave);}else{self.setCellEditingContext(true);}}};const prepareTargetCellPropsInfo=function(vmo,eventData,vmosToEdit,columnDef){if(isEligibleForCopyDown(columnDef)){vmosToEdit.push(vmo);}};const populateTargetCellPropsLegacyEdit=function(vmo,eventData,sourceProp){const targetProp=vmo.props[eventData.propertyName];if(sourceProp&&targetProp&&targetProp.isPropertyModifiable&&targetProp.editable){// update the target using the source\ncopyFillDownProperty(targetProp,sourceProp);copyPropertyToCellContent(sourceProp,vmo.uid);}};self.fillDownCompleteHandler=eventData=>{// get the VMOs from the table\nlet VMOs=_tableInstance.dataProvider.viewModelCollection.loadedVMObjects;let $source=VMOs.filter(function(vmo){return vmo.uid===eventData.source;});let sourceProp=$source[0]&&$source[0].props[eventData.propertyName];let vmosToEdit=[];let cellMap={};let cellsToSave=[];// Reverse the vmo order if we are going down\nif(eventData.direction!=='up'){VMOs=VMOs.slice().reverse();}// Attempt to apply the source value to the target properties\nlet foundLastTarget=false;for(let vmo of VMOs){// Iterate over the vmos until we find the last target prop.\nif(!foundLastTarget&&vmo.uid===eventData.endTarget){foundLastTarget=true;}if(!foundLastTarget){continue;}// Stop iterating if we reach the source prop\nif(vmo.uid===eventData.source){break;}const columnDef=util.getColumnDef(eventData.propertyName,_tableInstance.dataProvider);// Populate target cell props ( bulk edit mode ) or prepare the target prop info ( direct edit )\nif(util.isBulkEditing(tableElem)){populateTargetCellPropsLegacyEdit(vmo,eventData,sourceProp);}else{const targetCell=util.getCellElementsByPropertyAndUid(tableElem,eventData.propertyName,vmo.uid)[0];if(targetCell){cellMap[vmo.uid]=targetCell;}prepareTargetCellPropsInfo(vmo,eventData,vmosToEdit,columnDef);}}// Load editabilty and apply value to editable cells\nif(!util.isBulkEditing(tableElem)){_fillDownSaveInprogress=true;let propertyNames=[eventData.propertyName];loadCellEditabilityForTargetCells(cellMap,vmosToEdit,propertyNames).then(result=>{modifyPropsForCellEdit(result,vmosToEdit,eventData,cellsToSave,cellMap,sourceProp);_fillDownSaveInprogress=false;});}};_eventBusSubs.push(eventBus.subscribe(\"\".concat(_tableInstance.dataProvider.name,\".selectNone\"),self.removeAllCellSelection));_eventBusSubs.push(eventBus.subscribe(\"\".concat(_tableInstance.dataProvider.name,\".selectAll\"),self.removeAllCellSelection));_eventBusSubs.push(eventBus.subscribe(\"\".concat(_tableInstance.dataProvider.name,\".selectionChangeEvent\"),checkCellAndVMOSelection));};export default SPLMTableEditor;","map":null,"metadata":{},"sourceType":"module"}