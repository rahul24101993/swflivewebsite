{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\components\\\\src\\\\js\\\\AwTabContainerService.js\";\nimport _ from 'lodash';\nimport { registerTabSet, unregisterTabSet } from 'js/tabRegistry.service';\nimport tabOverflowSvc from 'js/tabOverflowService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport declUtils from 'js/declUtils';\nimport AwTab from 'viewmodel/AwTabViewModel';\nimport AwButton from 'viewmodel/AwButtonViewModel';\nimport AwTabSetOverflow from 'viewmodel/AwTabSetOverflowViewModel';\nimport AwPopup from 'viewmodel/AwPopupViewModel';\nimport AwStateService from 'js/awStateService';\nimport * as cas from 'js/centralAggregationService';\nimport localeService from 'js/localeService';\nimport analyticsSvc from 'js/analyticsService';\nimport wcagSvc from 'js/wcagService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet tabObserver = null;\nlet currentSelectedTabName;\nlet moreText = '';\nlet lessText = '';\n\nconst initializeObserver = (data, dispatch, tabsetRef) => {\n  if (resizeObserverSvc.supportsResizeObserver()) {\n    const callback = _.debounce(() => {\n      data.overflowConfig.hideMore = !tabOverflowSvc.hasOverflowForTabs(tabsetRef, 'HORIZONTAL');\n      tabOverflowSvc.updateTabIndexOnOverflow(tabsetRef, 'HORIZONTAL');\n      dispatch({\n        path: 'data',\n        value: { ...data\n        }\n      });\n    }, 200, {\n      maxWait: 10000,\n      trailing: true,\n      leading: false\n    });\n\n    if (tabsetRef !== null && tabsetRef !== undefined) {\n      tabObserver = resizeObserverSvc.observe(tabsetRef, callback);\n    }\n  }\n};\n/**\n * Listen to subPanelContext and log user gesture\n *  @param { subPanelContext } selection data from component props\n *  @param { data } viewModel data\n */\n\n\nexport const onSelectionDataChange = (subPanelContext, data) => {\n  logUserGesture(subPanelContext, data);\n};\n/**\n * Collect subject data like parent selection\n * @param {object} subPanelContext from component's props\n * @returns {object}\n */\n\nconst getSubject = subPanelContext => {\n  let subject = {};\n\n  if (!_.isEmpty(subPanelContext)) {\n    let pselected = subPanelContext.pselected ? subPanelContext.pselected : '';\n    let selected = subPanelContext.selected ? subPanelContext.selected : '';\n    subject = {\n      pselected: pselected,\n      selected: selected\n    };\n  }\n\n  return subject;\n};\n/**\n * Collect user gesture and transmit it to Central Aggregation Service\n *  @param { subPanelContext } subPanelContext from component props\n *  @param { data} viewModel data\n */\n\n\nconst logUserGesture = (subPanelContext, data) => {\n  let currentSelectedTabId = '';\n  currentSelectedTabId = data.currentSelectedTabId ? data.currentSelectedTabId : data.tabsModel.findIndex(tab => tab.selectedTab);\n  let widgetInfo = {\n    currentSelectedTabId: currentSelectedTabId,\n    tabSetId: data.tabSetId,\n    tabsModel: data.tabsModel\n  };\n  cas.notify({\n    widgetInfo: widgetInfo,\n    userGesture: 'onTabLoad',\n    subject: getSubject(subPanelContext)\n  });\n};\n/**\n * Method to publish analytics to server\n * @param {Number} tabModelId - id of the clicked tab\n * @param {String} tabModelName - name of the clicked tab\n */\n\n\nconst publishAnalytics = (tabModelId, tabModelName) => {\n  let sanEventData = {\n    sanAnalyticsType: 'Tab',\n    sanCommandId: tabModelId,\n    sanCommandTitle: tabModelName\n  };\n  analyticsSvc.logCommands(sanEventData);\n};\n\nexport const onMount = (elementRefList, prop, data) => {\n  let tabsetRef = elementRefList.get('tabset').current;\n  localeService.getLocalizedTextFromKey('BaseMessages.MORE_LINK_TEXT', true).then(value => moreText = value);\n  localeService.getLocalizedTextFromKey('BaseMessages.LESS_LINK_TEXT', true).then(value => lessText = value);\n  initializeObserver(data, data.dispatch, tabsetRef);\n}; //onUnmount\n\nexport const unRegisterTabSet = tabSetId => {\n  unregisterTabSet(tabSetId);\n\n  if (tabObserver) {\n    tabObserver();\n  }\n};\n\nconst initiateTabSetOverFlow = (overflownTabs, data, dispatch) => {\n  data.overflowConfig.overflownTabs = overflownTabs ? overflownTabs : [];\n  data.overflowConfig.isClicked = true;\n  data.overflowConfig.currentTabIndex = null;\n  data.overflowConfig.replacedTabIndex = null;\n  dispatch({\n    path: 'data',\n    value: { ...data\n    }\n  });\n};\n\nconst updateTabsIndices = (newSelectedTab, data, breakIndex) => {\n  let newSelNdx = newSelectedTab.tabIndex;\n  let temp;\n  temp = data.tabsModel[breakIndex];\n  data.tabsModel[breakIndex] = newSelectedTab;\n  data.tabsModel[newSelNdx] = temp;\n  return breakIndex;\n};\n\nconst isNewSelnFromOverFlowPopup = (index, data) => {\n  if (index >= data.tabsModel.length - data.overflowConfig.overflownTabs.length) {\n    return true;\n  }\n\n  return false;\n};\n\nconst setTabSelection = (data, tabSetOverflowPopup, callback, props) => {\n  let tabToBeSelected = data.tabsModel.find(tab => tab.selectedTab);\n\n  if (!tabToBeSelected && data.currentSelectedTabId) {\n    tabToBeSelected = data.tabsModel.find(tab => tab.pageId === data.currentSelectedTabId);\n  }\n\n  if (!tabToBeSelected || !tabToBeSelected.displayTab) {\n    data.tabsModel.some(tab => {\n      if (tab.displayTab) {\n        tabToBeSelected = tab;\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  if (tabToBeSelected && (!tabToBeSelected.selectedTab || !data.manualTabSelection && tabToBeSelected.selectedTab && tabToBeSelected.autoSelectTabOnLoad)) {\n    data.tabsModel.map((tabModel, index) => {\n      tabModel.selectedTab = false;\n      tabModel.tabIndex = index;\n    });\n\n    if (isNewSelnFromOverFlowPopup(tabToBeSelected.tabIndex, data)) {\n      updateTabsIndices(tabToBeSelected, data);\n\n      if (tabSetOverflowPopup.open) {\n        tabSetOverflowPopup.hide();\n      }\n    }\n\n    tabToBeSelected.selectedTab = true;\n\n    if (callback && tabToBeSelected.pageId !== data.currentSelectedTabId) {\n      data.currentSelectedTabId = tabToBeSelected.pageId;\n      callback(tabToBeSelected.pageId, tabToBeSelected.name, data.tabsModel);\n    }\n  } // Predictive UI: Notify subscribers when user gestures changes on tab selection/load\n\n\n  if (tabToBeSelected && tabToBeSelected.name !== currentSelectedTabName && data.tabsModel.length > 0) {\n    currentSelectedTabName = tabToBeSelected.name;\n    logUserGesture(props.subPanelContext, data);\n  }\n};\n\nexport const awTabContainerRenderFn = props => {\n  const {\n    actions,\n    viewModel,\n    elementRefList,\n    tabsModel,\n    callback,\n    tabSetId,\n    tabContainerModel\n  } = props;\n  let overflownTabs = [];\n  let {\n    tabSetOverflowPopup\n  } = actions;\n  const {\n    data,\n    dispatch\n  } = viewModel;\n  let tabsetRef = elementRefList.get('tabset').current;\n  const tabsModelForContainer = tabsModel || tabContainerModel;\n  /**\n   * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.\n   *\n   * @method calculateOverflow\n   */\n\n  const calculateTabSwitching = function (initialTabsModel, currentSelectedTab) {\n    var calculateBreakIndex = tabOverflowSvc.calculateBreakIndex();\n    var visibleTabs = data.tabsModel;\n\n    if (visibleTabs.length <= 1) {\n      return;\n    }\n\n    return calculateBreakIndex(initialTabsModel, tabsetRef, currentSelectedTab);\n  }; //swicth tabs here based on local state after overflow item click\n\n\n  let selectedTabModel = tabsModelForContainer.find(tab => tab.selectedTab);\n  let selectedTabIndex = tabsModelForContainer.findIndex(tab => tab.selectedTab); //If we have a selected tab on first render, we need to check if it's in the overflow to make it visible\n\n  let isInitialOverflowCalculation = data.overflowConfig && !data.overflowConfig.currentTabIndex && selectedTabIndex && !data.manualTabSelection;\n\n  if (isInitialOverflowCalculation || data.overflowConfig && data.overflowConfig.currentTabIndex && selectedTabIndex !== data.overflowConfig.replacedTabIndex || !data.manualTabSelection && selectedTabIndex && selectedTabModel && selectedTabIndex > 0 && selectedTabModel.autoSelectTabOnLoad) {\n    var breakTabIndex = calculateTabSwitching(tabsModelForContainer, selectedTabModel);\n\n    if (breakTabIndex) {\n      let temp = tabsModelForContainer[breakTabIndex];\n      tabsModelForContainer[breakTabIndex] = tabsModelForContainer[selectedTabIndex];\n      tabsModelForContainer[selectedTabIndex] = temp;\n    }\n  }\n\n  data.tabsModel = tabsModelForContainer.map(tab => {\n    if (declUtils.isNil(tab.displayTab)) {\n      tab.displayTab = true;\n    }\n\n    return tab;\n  });\n  /**\n   *  Highlight tab in the targeted tab set\n   *  @param {String} tabName the name of tab to be highlighted\n   */\n\n  const onHighlightTab = function (targetTab) {\n    let elementToHighlight;\n\n    if (targetTab && targetTab.displayTab) {\n      let tabContainerDomEl = tabsetRef.querySelectorAll('.sw-tabContainer>.sw-tab');\n      let tabElements = [...tabContainerDomEl];\n      let targetTabElement = tabElements.find(element => element.innerText === targetTab.name);\n      elementToHighlight = targetTabElement.querySelector('a');\n\n      if (elementToHighlight) {\n        wcagSvc.afxFocusElement(elementToHighlight);\n      }\n    } else if (!data.overflowConfig.hideMore) {\n      elementToHighlight = tabsetRef.parentNode.querySelector('.sw-tab-overflowButton.sw-jswidget-controlArrow');\n\n      if (elementToHighlight) {\n        wcagSvc.afxFocusElement(elementToHighlight);\n      }\n    }\n  };\n\n  const onTabSelected = selectedTabModel => {\n    //before change the tab update the params so we can navigate back to previous tab with old params\n    const previousTabIndex = data.tabsModel.findIndex(tab => tab.selectedTab);\n    data.tabsModel[previousTabIndex].params = AwStateService.instance.params;\n    data.previousSelectedTabId = data.tabsModel.find(tab => tab.selectedTab).pageId;\n    data.tabsModel.map(tabModel => tabModel.selectedTab = false);\n    data.currentSelectedTabId = selectedTabModel.pageId;\n    selectedTabModel.selectedTab = true;\n    data.manualTabSelection = true;\n    data.overflowConfig.currentTabIndex = null;\n    data.overflowConfig.replacedTabIndex = null;\n    var breakIndexFromCalc = calculateTabSwitching(data.tabsModel, selectedTabModel);\n\n    if (tabSetOverflowPopup.open && isNewSelnFromOverFlowPopup(selectedTabModel.tabIndex, data)) {\n      let breakIndex = updateTabsIndices(selectedTabModel, data, breakIndexFromCalc);\n      tabSetOverflowPopup.hide();\n      data.overflowConfig.currentTabIndex = selectedTabModel.tabIndex;\n      data.overflowConfig.replacedTabIndex = breakIndex;\n    } // Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.\n\n\n    if (callback && data.previousSelectedTabId !== data.currentSelectedTabId) {\n      callback(selectedTabModel.pageId, selectedTabModel.name, data.tabsModel);\n    }\n\n    publishAnalytics(selectedTabModel.pageId, selectedTabModel.name); //Update the overflow config object in the current view model too.\n    //This is done to cater to the standalone aw-tab-container scenario\n\n    dispatch({\n      path: 'data.overflowConfig',\n      value: { ...data.overflowConfig\n      }\n    });\n  };\n  /**\n   * Recalculate how many tabs can fit in the tab container before overflow occurs.\n   *\n   * @method calculateOverflow\n   */\n\n\n  const calculateOverflow = function () {\n    var overflowBreakPointCalculatorForTabs = tabOverflowSvc.overflowBreakPointCalculatorForTabs();\n    var visibleTabs = data.tabsModel;\n\n    if (visibleTabs.length <= 1) {\n      return;\n    }\n\n    var breakIndex = overflowBreakPointCalculatorForTabs(tabsetRef, 'HORIZONTAL'); // has tab overflow\n\n    if (breakIndex !== visibleTabs.length) {\n      overflownTabs = visibleTabs.slice(breakIndex);\n      initiateTabSetOverFlow(overflownTabs, data, dispatch);\n      tabSetOverflowPopup.show();\n    }\n  };\n\n  const getButtonClassNames = () => {\n    return tabSetOverflowPopup.open ? 'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight' : 'sw-tab-overflowButton sw-jswidget-controlArrow';\n  };\n\n  const showMoreButton = () => {\n    if (!data.overflowConfig.hideMore) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sw-tab-overflowContainer\",\n        children: [/*#__PURE__*/_jsxDEV(AwButton, {\n          domRef: tabSetOverflowPopup.reference,\n          className: getButtonClassNames(),\n          tooltip: tabSetOverflowPopup.open ? lessText : moreText,\n          \"aria-label\": tabSetOverflowPopup.open ? lessText : moreText,\n          iconId: \"miscSmallChevronRight\",\n          action: calculateOverflow\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 296,\n          columnNumber: 21\n        }, this), tabSetOverflowPopup.open && /*#__PURE__*/_jsxDEV(AwPopup, { ...tabSetOverflowPopup.options,\n          children: /*#__PURE__*/_jsxDEV(AwTabSetOverflow, {\n            overflownTabs: data.overflowConfig.overflownTabs,\n            isClicked: data.overflowConfig.isClicked,\n            event: event,\n            onTabSelected: onTabSelected\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 304,\n            columnNumber: 29\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 303,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 17\n      }, this);\n    }\n  };\n\n  setTabSelection(data, tabSetOverflowPopup, callback, props);\n\n  if (tabSetId) {\n    data.tabSetId = tabSetId;\n    unregisterTabSet(tabSetId);\n    registerTabSet(tabSetId, {\n      changeTab: onTabSelected,\n      tabs: data.tabsModel,\n      highlightTab: onHighlightTab\n    });\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"sw-row align-items-center flex-shrink\",\n    children: [/*#__PURE__*/_jsxDEV(\"ul\", {\n      role: \"tablist\",\n      className: \"sw-tabContainer\",\n      ref: elementRefList.get('tabset'),\n      children: data.tabsModel && data.tabsModel.map((tabModel, index) => {\n        if (tabModel.displayTab) {\n          tabModel.tabIndex = index;\n          return /*#__PURE__*/_jsxDEV(AwTab, {\n            tabModel: tabModel,\n            onTabSelected: onTabSelected,\n            onTabClose: props.onTabClose\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 334,\n            columnNumber: 32\n          }, this);\n        }\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 13\n    }, this), showMoreButton()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 329,\n    columnNumber: 9\n  }, this);\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/components/src/js/AwTabContainerService.js"],"names":["tabObserver","moreText","lessText","initializeObserver","resizeObserverSvc","callback","data","tabOverflowSvc","dispatch","path","value","maxWait","trailing","leading","tabsetRef","onSelectionDataChange","logUserGesture","getSubject","subPanelContext","subject","_","pselected","selected","currentSelectedTabId","tab","widgetInfo","tabSetId","tabsModel","cas","userGesture","publishAnalytics","sanEventData","sanAnalyticsType","sanCommandId","sanCommandTitle","tabModelName","analyticsSvc","onMount","elementRefList","localeService","unRegisterTabSet","unregisterTabSet","initiateTabSetOverFlow","overflownTabs","updateTabsIndices","newSelNdx","newSelectedTab","temp","isNewSelnFromOverFlowPopup","index","setTabSelection","tabToBeSelected","tabModel","tabSetOverflowPopup","currentSelectedTabName","props","awTabContainerRenderFn","tabContainerModel","tabsModelForContainer","calculateTabSwitching","calculateBreakIndex","visibleTabs","selectedTabModel","selectedTabIndex","isInitialOverflowCalculation","breakTabIndex","declUtils","onHighlightTab","targetTab","tabContainerDomEl","tabElements","targetTabElement","element","elementToHighlight","wcagSvc","onTabSelected","previousTabIndex","AwStateService","breakIndexFromCalc","breakIndex","overflowConfig","calculateOverflow","overflowBreakPointCalculatorForTabs","getButtonClassNames","showMoreButton","registerTabSet","changeTab","tabs","highlightTab","onTabClose"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport { registerTabSet, unregisterTabSet } from 'js/tabRegistry.service';\nimport tabOverflowSvc from 'js/tabOverflowService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport declUtils from 'js/declUtils';\nimport AwTab from 'viewmodel/AwTabViewModel';\nimport AwButton from 'viewmodel/AwButtonViewModel';\nimport AwTabSetOverflow from 'viewmodel/AwTabSetOverflowViewModel';\nimport AwPopup from 'viewmodel/AwPopupViewModel';\nimport AwStateService from 'js/awStateService';\nimport * as cas from 'js/centralAggregationService';\nimport localeService from 'js/localeService';\nimport analyticsSvc from 'js/analyticsService';\nimport wcagSvc from 'js/wcagService';\n\nlet tabObserver = null;\nlet currentSelectedTabName;\nlet moreText = '';\nlet lessText = '';\n\nconst initializeObserver = ( data, dispatch, tabsetRef ) => {\n    if( resizeObserverSvc.supportsResizeObserver() ) {\n        const callback = _.debounce( () => {\n            data.overflowConfig.hideMore = !tabOverflowSvc.hasOverflowForTabs( tabsetRef, 'HORIZONTAL' );\n            tabOverflowSvc.updateTabIndexOnOverflow( tabsetRef, 'HORIZONTAL' );\n            dispatch( { path: 'data', value: { ...data } } );\n        }, 200, {\n            maxWait: 10000,\n            trailing: true,\n            leading: false\n        } );\n        if( tabsetRef !== null && tabsetRef !== undefined ) {\n            tabObserver = resizeObserverSvc.observe( tabsetRef, callback );\n        }\n    }\n};\n/**\n * Listen to subPanelContext and log user gesture\n *  @param { subPanelContext } selection data from component props\n *  @param { data } viewModel data\n */\nexport const onSelectionDataChange = ( subPanelContext, data ) => {\n    logUserGesture( subPanelContext, data );\n};\n\n/**\n * Collect subject data like parent selection\n * @param {object} subPanelContext from component's props\n * @returns {object}\n */\nconst getSubject = subPanelContext => {\n    let subject = {};\n    if( !_.isEmpty( subPanelContext ) ) {\n        let pselected = subPanelContext.pselected ? subPanelContext.pselected : '';\n        let selected = subPanelContext.selected ? subPanelContext.selected : '';\n        subject = { pselected: pselected, selected: selected };\n    }\n    return subject;\n};\n/**\n * Collect user gesture and transmit it to Central Aggregation Service\n *  @param { subPanelContext } subPanelContext from component props\n *  @param { data} viewModel data\n */\nconst logUserGesture = ( subPanelContext, data ) => {\n    let currentSelectedTabId = '';\n    currentSelectedTabId = data.currentSelectedTabId ? data.currentSelectedTabId : data.tabsModel.findIndex( tab => tab.selectedTab );\n    let widgetInfo = { currentSelectedTabId: currentSelectedTabId, tabSetId: data.tabSetId, tabsModel: data.tabsModel };\n    cas.notify( {\n        widgetInfo: widgetInfo,\n        userGesture: 'onTabLoad',\n        subject: getSubject( subPanelContext )\n    } );\n};\n\n/**\n * Method to publish analytics to server\n * @param {Number} tabModelId - id of the clicked tab\n * @param {String} tabModelName - name of the clicked tab\n */\nconst publishAnalytics = ( tabModelId, tabModelName ) => {\n    let sanEventData = {\n        sanAnalyticsType: 'Tab',\n        sanCommandId: tabModelId,\n        sanCommandTitle: tabModelName\n    };\n    analyticsSvc.logCommands( sanEventData );\n};\n\nexport const onMount = ( elementRefList, prop, data ) => {\n    let tabsetRef = elementRefList.get( 'tabset' ).current;\n    localeService.getLocalizedTextFromKey( 'BaseMessages.MORE_LINK_TEXT', true ).then( value => moreText = value );\n    localeService.getLocalizedTextFromKey( 'BaseMessages.LESS_LINK_TEXT', true ).then( value => lessText = value );\n    initializeObserver( data, data.dispatch, tabsetRef );\n};\n\n//onUnmount\nexport const unRegisterTabSet = ( tabSetId ) => {\n    unregisterTabSet( tabSetId );\n    if( tabObserver ) {\n        tabObserver();\n    }\n};\n\nconst initiateTabSetOverFlow = ( overflownTabs, data, dispatch ) => {\n    data.overflowConfig.overflownTabs = overflownTabs ? overflownTabs : [];\n    data.overflowConfig.isClicked = true;\n    data.overflowConfig.currentTabIndex = null;\n    data.overflowConfig.replacedTabIndex = null;\n    dispatch( { path: 'data', value: { ...data } } );\n};\n\nconst updateTabsIndices = ( newSelectedTab, data, breakIndex ) => {\n    let newSelNdx = newSelectedTab.tabIndex;\n    let temp;\n    temp = data.tabsModel[ breakIndex ];\n    data.tabsModel[ breakIndex ] = newSelectedTab;\n    data.tabsModel[ newSelNdx ] = temp;\n\n    return breakIndex;\n};\n\nconst isNewSelnFromOverFlowPopup = ( index, data ) => {\n    if( index >= data.tabsModel.length - data.overflowConfig.overflownTabs.length ) {\n        return true;\n    }\n    return false;\n};\n\nconst setTabSelection = ( data, tabSetOverflowPopup, callback, props ) => {\n    let tabToBeSelected = data.tabsModel.find( tab => tab.selectedTab );\n    if( !tabToBeSelected && data.currentSelectedTabId ) {\n        tabToBeSelected = data.tabsModel.find( tab => tab.pageId === data.currentSelectedTabId );\n    }\n    if( !tabToBeSelected || !tabToBeSelected.displayTab ) {\n        data.tabsModel.some( tab => {\n            if( tab.displayTab ) {\n                tabToBeSelected = tab;\n                return true;\n            }\n            return false;\n        } );\n    }\n\n    if( tabToBeSelected && ( !tabToBeSelected.selectedTab || !data.manualTabSelection && tabToBeSelected.selectedTab && tabToBeSelected.autoSelectTabOnLoad ) ) {\n        data.tabsModel.map( ( tabModel, index ) => {\n            tabModel.selectedTab = false;\n            tabModel.tabIndex = index;\n        } );\n        if( isNewSelnFromOverFlowPopup( tabToBeSelected.tabIndex, data ) ) {\n            updateTabsIndices( tabToBeSelected, data );\n            if( tabSetOverflowPopup.open ) {\n                tabSetOverflowPopup.hide();\n            }\n        }\n        tabToBeSelected.selectedTab = true;\n        if( callback && tabToBeSelected.pageId !== data.currentSelectedTabId ) {\n            data.currentSelectedTabId = tabToBeSelected.pageId;\n            callback( tabToBeSelected.pageId, tabToBeSelected.name, data.tabsModel );\n        }\n    }\n\n    // Predictive UI: Notify subscribers when user gestures changes on tab selection/load\n    if( tabToBeSelected && tabToBeSelected.name !== currentSelectedTabName && data.tabsModel.length > 0 ) {\n        currentSelectedTabName = tabToBeSelected.name;\n        logUserGesture( props.subPanelContext, data );\n    }\n};\n\nexport const awTabContainerRenderFn = ( props ) => {\n    const { actions, viewModel, elementRefList, tabsModel, callback, tabSetId, tabContainerModel } = props;\n    let overflownTabs = [];\n    let { tabSetOverflowPopup } = actions;\n    const { data, dispatch } = viewModel;\n    let tabsetRef = elementRefList.get( 'tabset' ).current;\n    const tabsModelForContainer = tabsModel || tabContainerModel;\n    /**\n     * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.\n     *\n     * @method calculateOverflow\n     */\n    const calculateTabSwitching = function( initialTabsModel, currentSelectedTab ) {\n        var calculateBreakIndex = tabOverflowSvc.calculateBreakIndex();\n        var visibleTabs = data.tabsModel;\n        if( visibleTabs.length <= 1 ) {\n            return;\n        }\n        return calculateBreakIndex( initialTabsModel, tabsetRef, currentSelectedTab );\n    };\n\n    //swicth tabs here based on local state after overflow item click\n    let selectedTabModel = tabsModelForContainer.find( tab => tab.selectedTab );\n    let selectedTabIndex = tabsModelForContainer.findIndex( tab => tab.selectedTab );\n    //If we have a selected tab on first render, we need to check if it's in the overflow to make it visible\n    let isInitialOverflowCalculation = data.overflowConfig && !data.overflowConfig.currentTabIndex && selectedTabIndex && !data.manualTabSelection;\n\n    if( isInitialOverflowCalculation || data.overflowConfig && data.overflowConfig.currentTabIndex && selectedTabIndex !== data.overflowConfig.replacedTabIndex ||\n        !data.manualTabSelection && selectedTabIndex && selectedTabModel && selectedTabIndex > 0 && selectedTabModel.autoSelectTabOnLoad ) {\n        var breakTabIndex = calculateTabSwitching( tabsModelForContainer, selectedTabModel );\n\n        if( breakTabIndex ) {\n            let temp = tabsModelForContainer[ breakTabIndex ];\n            tabsModelForContainer[ breakTabIndex ] = tabsModelForContainer[ selectedTabIndex ];\n            tabsModelForContainer[ selectedTabIndex ] = temp;\n        }\n    }\n\n    data.tabsModel = tabsModelForContainer.map( ( tab ) => {\n        if( declUtils.isNil( tab.displayTab ) ) {\n            tab.displayTab = true;\n        }\n        return tab;\n    } );\n    /**\n     *  Highlight tab in the targeted tab set\n     *  @param {String} tabName the name of tab to be highlighted\n     */\n    const onHighlightTab = function( targetTab ) {\n        let elementToHighlight;\n        if( targetTab && targetTab.displayTab ) {\n            let tabContainerDomEl = tabsetRef.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n            let tabElements = [ ...tabContainerDomEl ];\n            let targetTabElement = tabElements.find( element => element.innerText === targetTab.name );\n            elementToHighlight = targetTabElement.querySelector( 'a' );\n            if( elementToHighlight ) {\n                wcagSvc.afxFocusElement( elementToHighlight );\n            }\n        } else if( !data.overflowConfig.hideMore ) {\n            elementToHighlight = tabsetRef.parentNode.querySelector( '.sw-tab-overflowButton.sw-jswidget-controlArrow' );\n            if( elementToHighlight ) {\n                wcagSvc.afxFocusElement( elementToHighlight );\n            }\n        }\n    };\n\n    const onTabSelected = selectedTabModel => {\n        //before change the tab update the params so we can navigate back to previous tab with old params\n        const previousTabIndex = data.tabsModel.findIndex( tab => tab.selectedTab );\n        data.tabsModel[ previousTabIndex ].params = AwStateService.instance.params;\n\n        data.previousSelectedTabId = data.tabsModel.find( tab => tab.selectedTab ).pageId;\n        data.tabsModel.map( ( tabModel ) => tabModel.selectedTab = false );\n        data.currentSelectedTabId = selectedTabModel.pageId;\n        selectedTabModel.selectedTab = true;\n        data.manualTabSelection = true;\n        data.overflowConfig.currentTabIndex = null;\n        data.overflowConfig.replacedTabIndex = null;\n\n        var breakIndexFromCalc = calculateTabSwitching( data.tabsModel, selectedTabModel );\n\n        if( tabSetOverflowPopup.open && isNewSelnFromOverFlowPopup( selectedTabModel.tabIndex, data ) ) {\n            let breakIndex = updateTabsIndices( selectedTabModel, data, breakIndexFromCalc );\n            tabSetOverflowPopup.hide();\n\n            data.overflowConfig.currentTabIndex = selectedTabModel.tabIndex;\n            data.overflowConfig.replacedTabIndex = breakIndex;\n        }\n        // Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.\n        if( callback && data.previousSelectedTabId !== data.currentSelectedTabId ) {\n            callback( selectedTabModel.pageId, selectedTabModel.name, data.tabsModel );\n        }\n        publishAnalytics( selectedTabModel.pageId, selectedTabModel.name );\n        //Update the overflow config object in the current view model too.\n        //This is done to cater to the standalone aw-tab-container scenario\n        dispatch( { path: 'data.overflowConfig', value: { ...data.overflowConfig } } );\n    };\n\n    /**\n     * Recalculate how many tabs can fit in the tab container before overflow occurs.\n     *\n     * @method calculateOverflow\n     */\n    const calculateOverflow = function() {\n        var overflowBreakPointCalculatorForTabs = tabOverflowSvc.overflowBreakPointCalculatorForTabs();\n        var visibleTabs = data.tabsModel;\n        if( visibleTabs.length <= 1 ) {\n            return;\n        }\n        var breakIndex = overflowBreakPointCalculatorForTabs( tabsetRef, 'HORIZONTAL' );\n        // has tab overflow\n        if( breakIndex !== visibleTabs.length ) {\n            overflownTabs = visibleTabs.slice( breakIndex );\n            initiateTabSetOverFlow( overflownTabs, data, dispatch );\n            tabSetOverflowPopup.show();\n        }\n    };\n\n    const getButtonClassNames = () => {\n        return tabSetOverflowPopup.open ? 'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight' : 'sw-tab-overflowButton sw-jswidget-controlArrow';\n    };\n\n    const showMoreButton = () => {\n        if( !data.overflowConfig.hideMore ) {\n            return (\n                <div className ='sw-tab-overflowContainer'>\n                    <AwButton domRef={tabSetOverflowPopup.reference}\n                        className={getButtonClassNames()}\n                        tooltip={tabSetOverflowPopup.open ? lessText : moreText}\n                        aria-label={tabSetOverflowPopup.open ? lessText : moreText}\n                        iconId='miscSmallChevronRight'\n                        action={calculateOverflow}></AwButton>\n                    { tabSetOverflowPopup.open &&\n                        <AwPopup {...tabSetOverflowPopup.options}>\n                            <AwTabSetOverflow overflownTabs={data.overflowConfig.overflownTabs}\n                                isClicked={data.overflowConfig.isClicked}\n                                event={event}\n                                onTabSelected={onTabSelected}>\n                            </AwTabSetOverflow>\n                        </AwPopup>\n                    }\n                </div>\n            );\n        }\n    };\n\n    setTabSelection( data, tabSetOverflowPopup, callback, props );\n\n    if( tabSetId ) {\n        data.tabSetId = tabSetId;\n        unregisterTabSet( tabSetId );\n        registerTabSet( tabSetId, {\n            changeTab: onTabSelected,\n            tabs: data.tabsModel,\n            highlightTab: onHighlightTab\n        } );\n    }\n\n    return (\n        <div className='sw-row align-items-center flex-shrink' >\n            <ul role='tablist' className='sw-tabContainer' ref={elementRefList.get( 'tabset' )}>\n                { data.tabsModel && data.tabsModel.map( ( tabModel, index ) => {\n                    if( tabModel.displayTab ) {\n                        tabModel.tabIndex = index;\n                        return <AwTab key={index} tabModel={tabModel} onTabSelected={onTabSelected}  onTabClose={props.onTabClose}></AwTab>;\n                    }\n                } )}\n            </ul>\n            {showMoreButton()}\n        </div>\n    );\n};\n"]},"metadata":{},"sourceType":"module"}