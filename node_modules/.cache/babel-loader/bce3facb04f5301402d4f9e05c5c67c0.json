{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * View model collection factory\n * This factory creates ViewModelCollection instances which maintain the loaded ViewModelObjects and exposes APIs to\n * access the information of collection.\n *\n * @module js/viewModelCollectionFactory\n */import cdm from'soa/kernel/clientDataModel';import viewModelObjectSvc from'js/viewModelObjectService';import uwPropertySvc from'js/uwPropertyService';import _ from'lodash';import eventBus from'js/eventBus';import logger from'js/logger';import browserUtils from'js/browserUtils';// eslint-disable-next-line valid-jsdoc\n/**\n * {Number} The debug ID of the 'next' instance of a certain class.\n */var _debug_nextId={viewModelCollection:0};/**\n * {Number} The current number of 'active' instances of a certain class.\n */var _debug_currentCount={viewModelCollection:0};/**\n * {Boolean} TRUE if create/destroy events should be logged for all non-dataProvider objects from this\n * service.\n */var _debug_logMiscModelLifeCycle=false;/**\n * Based on the given uid this function retrieves the IModelObject instance from the ClientDataModel and\n * creates a new instance of a ViewModelObject based on the model object passed in.\n *\n * @param {String} uid - ID of the new ViewModelObject.\n *\n * @return {ViewModelObject} New ViewModelObject (or NULL if no match was found in the ClientDataModel).\n */function _createViewModelObject(uid){if(uid){return viewModelObjectSvc.createViewModelObject(uid,'EDIT');}return null;}/**\n * Class used to maintain data for various DataProviders.\n *\n * @param {String} name of the viewModelCollection\n * @constructor ViewModelCollection\n */var ViewModelCollection=function(name){var self=this;/**\n     * Name of this view model collection (usually the same as the dataprovider name)\n     */self.name=name;/**\n     * Array of ViewModelObjects currently being managed in this 'virtual' collection.\n     */self.loadedVMObjects=[];/**\n     * The number of ViewModelObjects currently in this 'virtual' collection (should be same as length of\n     * 'loadedVMObjects').\n     */self.totalObjectsLoaded=0;/**\n     * The number of ViewModelObjects possible in this 'virtual' collection.\n     */self.totalFound=0;/**\n     * {SubDefArray} Collection of eventBus subscription definitions.\n     */var _eventBusSubDefs=[];/**\n     * {String} Topic to publish for each 'cdm.new' event.\n     */var _eventTopicNew='vmc.new.'+self.name;/**\n     * {String} Topic to publish for each 'cdm.modified.' event.\n     */var _eventTopicModified='vmc.modified.'+self.name;/**\n     * {Object} Cached (shared) data object to publish for 'vmc.new.xxx' events.\n     */var _eventDataNew={vmc:self,newObjects:null};/**\n     * {Object} Cached (shared) data object to publish for 'vmc.modified.xxx' events.\n     */var _eventDataModified={vmc:self,modifiedObjects:null};/**\n     * Updates the loaded objects array and total objects loaded counter.\n     *\n     * @param {Array} results - Array of model objects or objects\n     *\n     * @param {String} uidInResponse - if response object doesn't have uid at top level, then this attribute\n     *            should specify the level where uid is available. Example:\n     *\n     * <pre>\n     *    responseObject: {\n     *        test: {\n     *            uid: 'AAAAAAAA'\n     *        }\n     *    },\n     *    uidInResponse: 'test.uid'\n     * </pre>\n     *\n     * @param {Boolean} preSelection - if the objects should inherit 'selected' status\n     *\n     * @param {Boolean} prepend - Insert Before current start index. (optional)\n     *\n     * @memberof ViewModelCollection\n     */self.updateModelObjects=function(results,uidInResponse,preSelection,prepend){var actualResults=results.objects||results;if(!_.isEmpty(actualResults)){var preprendVMObjects=[];_.forEach(actualResults,function(object){var vmObject=null;var uid=null;if(results.objects){uid=object.uid;vmObject=viewModelObjectSvc.createViewModelObject(uid,'EDIT',null,object);}else if(object.uid){// Retrieve object's UID\nuid=object.uid;var modelObj=cdm.getObject(uid);// If object is there in the CDM, convert it to VM object\nif(modelObj){if(viewModelObjectSvc.isViewModelObject(object)||object.dataMapper){// if VMObject is passed, use it directly instead of creating again\nvmObject=object;}else{// Get underlying target object's UID if 'awp0Target' property exists\nif(modelObj.props&&modelObj.props.awp0Target){uid=modelObj.props.awp0Target.dbValues[0];}vmObject=_createViewModelObject(uid);}}else{// If object is not there in the CDM, it is a VM object\nvmObject=object;}}else if(uidInResponse){// if object doesn't have any UID, then retrieve the UID from the structure provided\nuid=_.get(object,uidInResponse);vmObject=_createViewModelObject(uid);}else{// for static objects\nvmObject=object;}if(vmObject&&!prepend){if(preSelection&&!_.isUndefined(object.selected)){vmObject.selected=object.selected;}self.loadedVMObjects.push(vmObject);}if(vmObject&&prepend){if(preSelection&&!_.isUndefined(object.selected)){vmObject.selected=object.selected;}preprendVMObjects.push(vmObject);}// update total count for loaded objects\nself.totalObjectsLoaded++;});if(!_.isEmpty(preprendVMObjects)){self.loadedVMObjects=preprendVMObjects.concat(self.loadedVMObjects);}// if moreValuesExist of the LOV results,\nif(actualResults.moreValuesExist){self.moreValuesExist=actualResults.moreValuesExist;}}};self.createModelObjects=function(results,uidInResponse,preSelection,prepend){let actualResults=results.objects||results;let loadedVMObjects=[];if(!_.isEmpty(actualResults)){var preprendVMObjects=[];_.forEach(actualResults,function(object){let vmObject=null;let uid=null;if(results.objects){uid=object.uid;vmObject=viewModelObjectSvc.createViewModelObject(uid,'EDIT',null,object);}else if(object.uid){// Retrieve object's UID\nuid=object.uid;let modelObj=cdm.getObject(uid);// If object is there in the CDM, convert it to VM object\nif(modelObj){if(viewModelObjectSvc.isViewModelObject(object)||object.dataMapper){// if VMObject is passed, use it directly instead of creating again\nvmObject=object;}else{// Get underlying target object's UID if 'awp0Target' property exists\nif(modelObj.props&&modelObj.props.awp0Target){uid=modelObj.props.awp0Target.dbValues[0];}vmObject=_createViewModelObject(uid);}}else{// If object is not there in the CDM, it is a VM object\nvmObject=object;}}else if(uidInResponse){// if object doesn't have any UID, then retrieve the UID from the structure provided\nuid=_.get(object,uidInResponse);vmObject=_createViewModelObject(uid);}else{// for static objects\nvmObject=object;}if(vmObject&&!prepend){if(preSelection&&!_.isUndefined(object.selected)){vmObject.selected=object.selected;}loadedVMObjects.push(vmObject);}if(vmObject&&prepend){if(preSelection&&!_.isUndefined(object.selected)){vmObject.selected=object.selected;}preprendVMObjects.push(vmObject);}});if(!_.isEmpty(preprendVMObjects)){loadedVMObjects=preprendVMObjects.concat(self.loadedVMObjects);}// if moreValuesExist of the LOV results,\nif(actualResults.moreValuesExist){self.moreValuesExist=actualResults.moreValuesExist;}}return loadedVMObjects;};/**\n     * @param {ObjectArray} viewModelObjects - The array to set as the currently loaded view model objects\n     *            being managed within this viewModelCollection.\n     */self.setViewModelObjects=function(viewModelObjects){self.totalObjectsLoaded=viewModelObjects.length;//create a new reference to trigger update.\nself.loadedVMObjects=[...viewModelObjects];};/**\n     * Returns view model object at specified index.\n     *\n     * @param {Number} index - specified index\n     * @return {Object} Null or object at given index\n     * @memberof ViewModelCollection\n     */self.getViewModelObject=function(index){if(self.loadedVMObjects){return self.loadedVMObjects[index];}return null;};/**\n     * Returns view model objects with the specified id (can be uid).\n     *\n     * @param {String} id - specific id of the view model object\n     * @return {Array} Empty or with view model objects found\n     * @memberof ViewModelCollection\n     */self.getViewModelObjects=function(id){var returnViewModelObjects=[];_.forEach(self.loadedVMObjects,function(vmo){if(id===vmo.getId()){returnViewModelObjects.push(vmo);}});return returnViewModelObjects;};/**\n     * Set total objects found\n     *\n     * @param {Number} totalFound - total found\n     * @memberof ViewModelCollection\n     */self.setTotalObjectsFound=function(totalFound){self.totalFound=totalFound;};/**\n     * Return total objects found\n     *\n     * @memberof ViewModelCollection\n     *\n     * @returns {Number} Total objects found.\n     */self.getTotalObjectsFound=function(){return self.totalFound;};/**\n     * Return total unique objects found, unique by id.\n     *\n     * @memberof ViewModelCollection\n     *\n     * @returns {Number} Total unique objects found, unique by id.\n     */self.getTotalUniqueObjectsLoaded=function(){var uniqueUids={};_.forEach(self.loadedVMObjects,function(vmo){if(vmo.getId){uniqueUids[vmo.getId()]=null;}else if(vmo.uid){//This is the case of ViewModelTreeNode which doesn't contain getId method as its not a VMO. getId is added when the props are loaded.\nuniqueUids[vmo.uid]=null;}});// return totalObjectsLoaded if no ids were found on the objects\nreturn Object.keys(uniqueUids).length||self.totalObjectsLoaded;};/**\n     * Return True/False if there are more objects to be loaded.\n     *\n     * @memberof ViewModelCollection\n     *\n     * @return {Boolean} True/False if there are more objects to be loaded.\n     */self.hasMoreObjectsToLoad=function(){return self.getTotalUniqueObjectsLoaded()<self.getTotalObjectsFound();};/**\n     * To support infinite scroll, if total found are greater than loaded objects then return\n     * totalObjectsLoaded + 3 else return total objects loaded\n     *\n     * @memberof ViewModelCollection\n     *\n     * @return {Number} Total objects loaded\n     */self.getVirtualLength=function(){var retValue=self.totalObjectsLoaded;if(self.totalObjectsLoaded>0&&self.hasMoreObjectsToLoad()){retValue+=3;}return retValue;};/**\n     * Returns total objects loaded\n     *\n     * @memberof ViewModelCollection\n     *\n     * @return {Number} total objects loaded\n     */self.getTotalObjectsLoaded=function(){return self.totalObjectsLoaded;};/**\n     * Reset loaded objects array and total objects loaded counter\n     *\n     * @memberof ViewModelCollection\n     */self.clear=function(){self.loadedVMObjects=[];self.totalObjectsLoaded=0;self.totalFound=0;};/**\n     * Return loaded view model objects\n     *\n     * @memberof ViewModelCollection\n     * @return {Array} loaded view model objects\n     */self.getLoadedViewModelObjects=function(){return self.loadedVMObjects;};/**\n     * Get all the editable properties\n     *\n     * @return {ViewModelPropertyArray} Collection of editable properties.\n     */self.getAllEditableProperties=function(){var allEditableProperties=[];_.forEach(self.loadedVMObjects,function(vmo){_.forEach(vmo.props,function(prop){if(prop.isEditable){allEditableProperties.push(prop);}});});return allEditableProperties;};/**\n     * Get all the modified properties\n     *\n     * @return {ViewModelPropertyArray} Collection of modified properties.\n     */self.getAllModifiedProperties=function(){var allModifiedProperties=[];_.forEach(self.loadedVMObjects,function(vmo){_.forEach(vmo.props,function(prop){if(uwPropertySvc.isModified(prop)){allModifiedProperties.push({property:prop,viewModelObject:vmo});}});});return allModifiedProperties;};/**\n     * Check editability on all properties\n     */self.checkEditableOnProperties=function(){_.forEach(self.loadedVMObjects,function(vmo){viewModelObjectSvc.updateVMOProperties(vmo);});};/**\n     * Reset all 'editable' status properties from the underlying object.\n     */self.clearEditiableStates=function(){_.forEach(self.loadedVMObjects,function(vmo){vmo.clearEditiableStates(true);});/** revisitme billa\n         * HINT: We don't need this now\n         * uwPropertySvc.triggerDigestCycle();\n         */};/**\n     * Returns 1st ViewModelObject index in the collection whose 'id' (or 'uid') matches specified value.\n     *\n     * @memberof ViewModelCollection\n     *\n     * @param {String} idToFind - The ID (or UID) of the ViewModelObject to find.\n     * @return {Number} Index in the ViewModelSelection of the ViewModelObject found (or -1 if not found).\n     */self.findViewModelObjectById=function(idToFind){for(var ndx=0;ndx<self.loadedVMObjects.length;ndx++){var vmo=self.loadedVMObjects[ndx];if(vmo.alternateID&&vmo.alternateID===idToFind){return ndx;}if(vmo.id&&vmo.id===idToFind){return ndx;}if(vmo.uid&&vmo.uid===idToFind){return ndx;}}return-1;};/**\n     * Remove the passed in objects (array of viewModelTreeNodes)\n     *\n     * @param {Array} objectsToRemove an array of viewModelTreeNodes keyed by uid\n     */self.removeLoadedObjects=function(objectsToRemove){if(objectsToRemove&&objectsToRemove.length>0){_.remove(self.loadedVMObjects,function(treeNode){var i=0;var doRemove=false;while(i<objectsToRemove.length&&!doRemove){if(treeNode.uid===objectsToRemove[i].uid){doRemove=true;}i++;}return doRemove;});}};/**\n     * Free up all resources held/managed by this object.\n     * <P>\n     * Note: After this function, no API call should be considered valid. This function is intended to be\n     * called when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a\n     * GC event), any objects managed by this class may be considered a 'memory leak'.\n     */self.destroy=function(){self._isDestroyed=true;_debug_currentCount.viewModelCollection--;if(_debug_logMiscModelLifeCycle){logger.info('Destroying ViewModelCollection: '+self._modelId+' # Remaining:'+_debug_currentCount.viewModelCollection);}_.forEach(_eventBusSubDefs,function(subDef){eventBus.unsubscribe(subDef);});_eventBusSubDefs=null;self.clear();};/**\n     * ---------------------------------------------------------------------------<BR>\n     * Property & Function definition complete....Finish initialization. <BR>\n     * ---------------------------------------------------------------------------<BR>\n     */self._modelId=_debug_nextId.viewModelCollection++;_debug_currentCount.viewModelCollection++;if(_debug_logMiscModelLifeCycle){logger.info('Created ViewModelCollection: '+self._modelId);}_eventBusSubDefs.push(eventBus.subscribe('cdm.new',function(event){_eventDataNew.newObjects=event.newObjects;eventBus.publish(_eventTopicNew,_eventDataNew);}));_eventBusSubDefs.push(eventBus.subscribe('cdm.modified',function(event){_eventDataModified.modifiedObjects=event.modifiedObjects;eventBus.publish(_eventTopicModified,_eventDataModified);/**\n         * Post process cdm event to update any of the reported objects that may be loaded in this\n         * viewModelCollection.\n         */viewModelObjectSvc.updateViewModelObjectCollection(self.loadedVMObjects,event.modifiedObjects);}));// Listen for CDM Deleted events (will be unregistered onDestroy)\n_eventBusSubDefs.push(eventBus.subscribe('cdm.deleted',function(event){/**\n         * Post process cdm deleted event to remove any deleted objects from viewModelCollection collection\n         * of loadedVMObjects and then set the totalObjectsLoaded count.\n         */let updateRequired=false;if(event.deletedObjectUids&&event.deletedObjectUids.length>0){_.forEach(event.deletedObjectUids,function(deletedUid){// remove the found object by uid from the collection of loadedVMObjects\n_.remove(self.loadedVMObjects,function(vmo){if(vmo.uid===deletedUid){updateRequired=true;return true;}});});if(updateRequired){self.update(self.loadedVMObjects,self.loadedVMObjects.length);}}}));};_debug_logMiscModelLifeCycle=browserUtils.getUrlAttributes().logMiscModelLifeCycle==='';var exports={};/**\n * Create new instance of view model collection\n *\n * @param {String} name - name of the ViewModelCollection\n * @return {ViewModelCollection} Returns view model collection object\n */export let createViewModelCollection=function(name){return new ViewModelCollection(name);};exports={createViewModelCollection};export default exports;","map":null,"metadata":{},"sourceType":"module"}