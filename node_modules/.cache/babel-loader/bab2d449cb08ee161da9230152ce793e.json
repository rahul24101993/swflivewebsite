{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is for exposing the native js data provider behavior. The module supports loading the module from GWT\n * and getting the native JS code invoked.\n *\n * @module js/splmTableInfiniteScrollService\n */\nimport logger from 'js/logger';\nimport browserUtils from 'js/browserUtils';\nimport SPLMTableMomentumScrolling from 'js/splmTableMomentumScrolling';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\n/**\n * Native infinite scroll.\n *\n * @constructor\n * @param {Number} containerHeight the container height\n */\n\nlet SPLMTableInfiniteScroll = function (containerHeight) {\n  let self = this;\n  let settings = {};\n  let currentScrollTop = 0; // Holds the last scroll position to detect scroll down or up\n\n  let previousScrollTop = 0;\n  let rowElements = []; // contains cache of rendered list\n\n  let rowHeightCache = [];\n  let initialized = false;\n  let containerHeightInitialized = false;\n  let _containerHeight = containerHeight;\n\n  let _visibleAreaHeight = _containerHeight - settings.headerHeight;\n\n  let initialRowIndex = 0;\n  let extraVisibleRowCount = 14; // keep it even for easier scrolling/calculations\n\n  let visibleRowsCount = 0;\n  let currentScrollLeft = 0;\n  let scrollToRowInProgress = false;\n  let scrollToRowScrollTop = null;\n  let maintainScrollPosition = false;\n  let disablePinScrollEvent = false;\n  let userPinScrollsDetected = 0;\n  let scrollContainerWidth = 0;\n  let verticalScrollDebounceTime = browserUtils.isIE || browserUtils.isFirefox ? 200 : 0;\n  let horizontalScrollDebounceTime = browserUtils.isIE ? 500 : 0;\n  let verticalScrollDebounceMaxWait = browserUtils.isIE || browserUtils.isFirefox ? Infinity : 0;\n  let momentumScrolling = new SPLMTableMomentumScrolling();\n  let lastScrollTimeStamp = new Date();\n  let elapsedMSSinceLastScroll = 0; // LCS-133249 Scrolling performance issue\n  // Do scroll syncing at very beginning\n\n  let extraTop = 0;\n\n  let horizontalScrollDebounceEvent = _.debounce(function () {\n    if (settings.scrollViewportElem && settings.scrollViewportElem.offsetWidth) {\n      scrollContainerWidth = settings.scrollViewportElem.offsetWidth;\n    }\n\n    settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n    settings.updateVisibleCells(settings.scrollParentElem);\n  }, horizontalScrollDebounceTime);\n\n  let verticalScrollDebounceEvent = _.debounce(function () {\n    handleScrollEventInternal();\n  }, verticalScrollDebounceTime, {\n    maxWait: verticalScrollDebounceMaxWait\n  });\n\n  self.initializeGrid = function (obj) {\n    settings = obj;\n    settings.pinParentElem = settings.pinViewportElem.children[0];\n    settings.scrollParentElem = settings.scrollViewportElem.children[0];\n    settings.totalFound = settings.loadedVMObjects.length;\n    settings.dynamicRowHeightStatus = settings.dynamicRowHeightStatus || false;\n    initializeEvents();\n    momentumScrolling.enable(settings.pinViewportElem, settings.scrollViewportElem);\n    initialized = true;\n  };\n  /**\n   * Calculates the visible area of the table\n   * @returns {Number} the visible height\n   */\n\n\n  let calculateVisibleAreaHeight = function () {\n    return _containerHeight - settings.headerHeight;\n  };\n\n  self.checkForResize = _.debounce(async function () {\n    elapsedMSSinceLastScroll = new Date() - lastScrollTimeStamp;\n\n    if (elapsedMSSinceLastScroll < 200) {\n      return;\n    }\n\n    let newClientWidth = settings.scrollViewportElem.offsetWidth;\n\n    if (newClientWidth !== scrollContainerWidth) {\n      if (newClientWidth > scrollContainerWidth) {\n        scrollContainerWidth = newClientWidth;\n        settings.updateScrollColumnsInView(currentScrollLeft);\n      } else {\n        scrollContainerWidth = newClientWidth;\n        settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n      }\n\n      settings.updateVisibleCells(settings.scrollParentElem);\n      self.handlePinViewportScrollbarPadding();\n    }\n\n    if (settings.directiveElem.clientHeight !== _containerHeight) {\n      _containerHeight = settings.directiveElem.clientHeight;\n      let rowContainerHeight = settings.scrollViewportElem.clientHeight || settings.pinViewportElem.clientHeight || _containerHeight;\n      let rowCount = Math.floor(rowContainerHeight / settings.rowHeight);\n      _visibleAreaHeight = calculateVisibleAreaHeight();\n      setVisibleRowsCount(rowCount);\n      await self.handleScroll();\n    }\n  }, 200);\n\n  self.isInitialized = function () {\n    return initialized;\n  };\n  /**\n   * Renders the initial rows on initialization once table div has been rendered so that\n   * the height can be computed properly\n   */\n\n\n  self.renderInitialRows = function () {\n    self.initializeProperties();\n    settings.initialRowIndex = initialRowIndex;\n    self.handleScroll();\n  };\n\n  self.getFirstRenderedItemIndex = function () {\n    var firstRenderedItemIndex = 0;\n    var firstElem = rowElements[0];\n    firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n    return firstRenderedItemIndex;\n  };\n\n  self.getLastRenderedItemIndex = function () {\n    var lastRenderedItemIndex = 0;\n    var lastElem = rowElements[rowElements.length - 1];\n    lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n    return lastRenderedItemIndex;\n  };\n  /**\n   * set the object set height\n   * @param {Number} heightVal The container height\n   */\n\n\n  self.setContainerHeight = function (heightVal) {\n    _containerHeight = heightVal;\n    _visibleAreaHeight = calculateVisibleAreaHeight(); // LCS-140092 - AW UxRefresh does not allow scrolling in Qt WebEngine Browser\n    // 100% is not working in Qt WebEngine, use heightVal here\n\n    settings.scrollViewportElem.style.maxHeight = String(_visibleAreaHeight) + 'px';\n    settings.pinViewportElem.style.maxHeight = String(_visibleAreaHeight) + 'px';\n  };\n  /**\n   * Set if dynamic row height is enabled or not\n   *\n   * @param {Boolean} isEnabled if DRH is enabled or not\n   */\n\n\n  self.setDynamicRowHeight = function (isEnabled) {\n    settings.dynamicRowHeightStatus = isEnabled;\n\n    if (settings.tableElem._tableInstance) {\n      settings.tableElem._tableInstance.dynamicRowHeightStatus = isEnabled;\n    }\n  };\n  /**\n   * Sets the extra visible row count 10 < x < 30\n   *\n   * @param {Number} rowCount The number of rows to set\n   */\n\n\n  function setExtraVisibleRowCount(rowCount) {\n    extraVisibleRowCount = Math.max(10, Math.min(30, rowCount));\n  }\n  /**\n   * Sets the visible row count\n   *\n   * @param {Number} rowCount the number of visible rows\n   */\n\n\n  function setVisibleRowsCount(rowCount) {\n    visibleRowsCount = rowCount;\n    setExtraVisibleRowCount(rowCount);\n  }\n  /**\n   * Convenience method to get certain row height from cache\n   *\n   * @param {Number} index The row's index\n   * @returns {Number} the row's height\n   */\n\n\n  function getHeightFromCache(index) {\n    if (rowHeightCache[index]) {\n      if (index === rowHeightCache.length - 1) {\n        return rowHeightCache[index];\n      }\n\n      return rowHeightCache[index] - 1; // The -1 is because of the -1 margin added to the rows. May change in future\n    }\n\n    return settings.rowHeight;\n  }\n  /**\n   * Calculates the element's top position (scrollTop or just top)\n   * using the row height cache and its index\n   *\n   * @param {Number} elementIdx The element's index\n   * @returns {Number} the top position for the element\n   */\n\n\n  function calculateElementTopPosition(elementIdx) {\n    let runningTop = 0;\n\n    for (let idx = 0; idx < elementIdx; idx++) {\n      runningTop += getHeightFromCache(idx);\n    }\n\n    return runningTop;\n  }\n  /**\n   * Calculates the row index based off of the scrollTop. Uses the row height cache\n   * and will return the index that the scrollTop reaches to.\n   *\n   * @param {Number} scrollTop The scroll top to calculate the element idx start from\n   * @returns {Number} the element's idx\n   */\n\n\n  function calculateElementIndexFromScrollTop(scrollTop) {\n    let runningTotal = 0;\n    let index = 0;\n\n    while (runningTotal < scrollTop) {\n      runningTotal += getHeightFromCache(index);\n      index++;\n    }\n\n    return index;\n  }\n  /**\n   * Calculates the last visible row's index\n   *\n   * @returns {Number} the last visible row's index\n   */\n\n\n  function calculateLastVisibleRowIndex() {\n    return calculateElementIndexFromScrollTop(currentScrollTop + _visibleAreaHeight) - 1;\n  }\n  /**\n   * Initialize scroll properties\n   */\n\n\n  self.initializeProperties = function () {\n    // Clear the row height cache\n    rowHeightCache = []; // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n    // Use given clientHeight to save one computed CSS reading\n\n    if (_containerHeight === undefined) {\n      _containerHeight = containerHeight > 0 ? containerHeight : settings.directiveElem.clientHeight;\n      _visibleAreaHeight = calculateVisibleAreaHeight();\n    } else if (containerHeightInitialized === false) {\n      self.setContainerHeight(_containerHeight);\n    }\n\n    containerHeightInitialized = true; // Table should have height of at least one row.\n\n    settings.scrollViewportElem.style.minHeight = String(settings.rowHeight) + 'px';\n    settings.pinViewportElem.style.minHeight = String(settings.rowHeight) + 'px';\n    let scrollCanvasHeight = _visibleAreaHeight;\n\n    if (scrollCanvasHeight < 0) {\n      scrollCanvasHeight = 0;\n    }\n\n    let rowCount = Math.floor(scrollCanvasHeight / settings.rowHeight);\n    setVisibleRowsCount(rowCount);\n    logger.trace('Table scroll service: Visible row count - ' + visibleRowsCount);\n  };\n  /**\n   * Updates the container and top space heights so the rows are positioned correctly\n   */\n\n\n  self.updateRowAlignment = function () {\n    let topHeight = 0;\n\n    if (rowElements) {\n      let firstElement = rowElements[0];\n\n      if (firstElement && firstElement.getAttribute('data-indexNumber')) {\n        let firstElementIdx = parseInt(firstElement.getAttribute('data-indexNumber'));\n\n        if (settings.treeTableEditSettings) {\n          topHeight = (firstElementIdx - settings.treeTableEditSettings.firstIndex) * settings.rowHeight;\n        } else {\n          topHeight = calculateElementTopPosition(firstElementIdx);\n        }\n      }\n    }\n\n    settings.pinParentElem.style.top = topHeight + 'px';\n    settings.scrollParentElem.style.top = topHeight + 'px';\n    let scrollContentHeight; // If tree table and editing, use treeEditSettings.lastIndex - the first index to get number of rows in total\n\n    if (settings.treeTableEditSettings) {\n      scrollContentHeight = (settings.treeTableEditSettings.lastIndex - settings.treeTableEditSettings.firstIndex + 1) * settings.rowHeight - topHeight;\n    } else {\n      scrollContentHeight = calculateElementTopPosition(settings.totalFound) - topHeight;\n    }\n\n    settings.pinParentElem.style.height = scrollContentHeight + 'px';\n    settings.scrollParentElem.style.height = scrollContentHeight + 'px';\n  };\n  /**\n   * Returns the row height as an int\n   * @returns {Number} The row Height\n   */\n\n\n  self.getRowHeight = function () {\n    return settings.rowHeight;\n  };\n  /**\n   * Scrolls the table up/down one row.\n   *\n   * @param {Boolean} isScrollDown - scroll down indicator, false for scroll up\n   * @returns {Number} returns the new scrollTop of the scrollViewportElement\n   */\n\n\n  self.manualScroll = function (isScrollDown) {\n    let scrollDistance = isScrollDown ? self.getRowHeight() : -self.getRowHeight();\n    settings.scrollViewportElem.scrollTop += scrollDistance;\n    return settings.scrollViewportElem.scrollTop;\n  };\n  /**\n   * Get scrollTop of the scroll viewport.\n   *\n   * @returns {Number} returns the scrollTop of the scrollViewportElement\n   */\n\n\n  self.getScrollTop = function () {\n    return settings.scrollViewportElem.scrollTop;\n  };\n  /**\n   * Sets the row height\n   *\n   *  @param {int} rowHeight - the height of the row in pixels\n   */\n\n\n  self.setRowHeight = function (rowHeight) {\n    settings.rowHeight = rowHeight;\n  };\n  /**\n   * Gets the total objects found\n   * @returns {Number} The total number of objects found\n   */\n\n\n  self.getTotalFound = function () {\n    return settings.totalFound;\n  };\n  /**\n   * Sets the loaded view model objects\n   *\n   *  @param {[ViewModelObject]} loadedViewModelObjects - the collection of view model objects\n   */\n\n\n  self.setLoadedVMObjects = function (loadedViewModelObjects) {\n    // Maintain the scroll position\n    if (maintainScrollPosition === true) {\n      // This will set the variables for maintaining scroll position.\n      // The values are used when handleScroll is called again.\n      setValuesForMaintainingScroll(loadedViewModelObjects.length - settings.totalFound);\n    }\n\n    settings.loadedVMObjects = loadedViewModelObjects;\n    settings.totalFound = loadedViewModelObjects.length;\n  };\n\n  self.setScrollPositionToBeMaintained = function () {\n    maintainScrollPosition = true;\n  };\n  /**\n   * Sets the proper variables to maintain the scroll position\n   * @param {integer} rowDifferenceCount - the difference in rows used to calculate maintained scroll position\n   */\n\n\n  function setValuesForMaintainingScroll(rowDifferenceCount) {\n    maintainScrollPosition = false;\n    scrollToRowInProgress = true;\n    let currentRow = calculateElementIndexFromScrollTop(settings.scrollViewportElem.scrollTop);\n    let scrollToRow = currentRow + rowDifferenceCount;\n    scrollToRowScrollTop = calculateElementTopPosition(scrollToRow);\n  }\n\n  self.isScrollToRowInProgress = function () {\n    return scrollToRowInProgress;\n  };\n\n  let scrollEndTimer;\n  /**\n   * Handles Scroll End logic\n   * Deletes excess rows when user has stopped scrolling for 500ms\n   * This prevents excessive deleting while trying to also create new rows and scroll table\n   */\n\n  function handleScrollEndEvent() {\n    if (scrollEndTimer) {\n      clearTimeout(scrollEndTimer);\n    }\n\n    scrollEndTimer = setTimeout(function () {\n      removeExtraRows();\n    }, 300);\n  }\n  /**\n   * Initialize Scroll Event to table\n   */\n\n\n  function initializeEvents() {\n    settings.scrollViewportElem.removeEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem.removeEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem.removeEventListener('scroll', handlePinScrollEvent);\n    settings.scrollViewportElem.addEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem.addEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem.addEventListener('scroll', handlePinScrollEvent);\n  }\n  /**\n   * Add a padding to the pin viewport to align pin rows with content rows\n   * when scrolled to the bottom.\n   *\n   * @param {Number} tempExtraTop - amount of padding in pixels\n   */\n\n\n  function addPinViewportScrollbarPadding(tempExtraTop) {\n    settings.pinViewportElem.style.top = String(tempExtraTop * -1) + 'px';\n    extraTop = tempExtraTop;\n  }\n  /**\n   * Remove the padding to the pin viewport used for row alignment.\n   */\n\n\n  function removePinViewportScrollbarPadding() {\n    settings.pinViewportElem.style.top = '0px';\n    extraTop = 0;\n  }\n  /**\n   * Apply/remove extra top for pinViewport if the scrollViewport is now visible/invisible\n   */\n\n\n  self.handlePinViewportScrollbarPadding = function () {\n    const pinViewportElem = settings.pinViewportElem;\n    const scrollViewportElem = settings.scrollViewportElem;\n\n    if (currentScrollTop >= 0) {\n      if (pinViewportElem.style.top === '0px' && scrollViewportElem.clientWidth > 0) {\n        let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n\n        if (tempExtraTop > 0) {\n          addPinViewportScrollbarPadding(tempExtraTop);\n        }\n      } else if (pinViewportElem.style.top !== '0px' && scrollViewportElem.clientWidth <= 0) {\n        removePinViewportScrollbarPadding();\n      }\n    }\n  };\n  /**\n   * Scroll Event Handler\n   */\n\n\n  function handleScrollEvent(e) {\n    lastScrollTimeStamp = new Date();\n    let oldScrollTop = currentScrollTop;\n    currentScrollTop = settings.scrollViewportElem.scrollTop;\n    let oldScrollLeft = currentScrollLeft;\n    currentScrollLeft = settings.scrollViewportElem.scrollLeft;\n\n    if (oldScrollTop === currentScrollTop && currentScrollTop < 0 && oldScrollLeft === currentScrollLeft && currentScrollLeft < 0) {\n      e.preventDefault();\n      e.stopPropagation();\n    } // LCS-133249 Scrolling performance issue\n    // Do scroll syncing at very beginning\n\n\n    let pinViewportElem = settings.pinViewportElem;\n\n    if (userPinScrollsDetected === 0 && (oldScrollTop !== currentScrollTop || currentScrollTop === 0)) {\n      disablePinScrollEvent = true;\n      pinViewportElem.scrollTop = currentScrollTop;\n    }\n\n    settings.onStartScroll();\n\n    if (oldScrollLeft !== currentScrollLeft && currentScrollLeft >= 0) {\n      settings.syncHeader(false, currentScrollLeft);\n      horizontalScrollDebounceEvent();\n    }\n\n    if (oldScrollTop !== currentScrollTop && currentScrollTop >= 0) {\n      let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n\n      if (tempExtraTop > 0) {\n        if (settings.scrollViewportElem.clientWidth > 0) {\n          addPinViewportScrollbarPadding(tempExtraTop);\n        }\n      } else if (extraTop > 0) {\n        // For non IE/Edge, need to set top back when scroll up\n        removePinViewportScrollbarPadding();\n      }\n\n      verticalScrollDebounceEvent();\n    }\n\n    userPinScrollsDetected -= 1;\n\n    if (userPinScrollsDetected < 0) {\n      userPinScrollsDetected = 0;\n    }\n  }\n  /**\n   * Real processing method for scroll event after debounce/requestAnimationFrame\n   */\n\n\n  function handleScrollEventInternal() {\n    let func;\n    let isScrollDown = currentScrollTop > previousScrollTop;\n\n    if (isScrollDown) {\n      func = self.handleScrollDown;\n    } else {\n      func = handleScrollUp;\n    }\n\n    previousScrollTop = currentScrollTop; // Do scroll shadow\n\n    if (currentScrollTop > 0) {\n      if (!settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)) {\n        settings.tableElem.classList.add(Const.CLASS_TABLE_SCROLLED);\n      }\n    } else {\n      if (settings.tableElem.classList.contains(Const.CLASS_TABLE_SCROLLED)) {\n        settings.tableElem.classList.remove(Const.CLASS_TABLE_SCROLLED);\n      }\n    }\n\n    func.call();\n  }\n  /**\n   * Method to handle scroll down\n   */\n\n\n  self.handleScrollDown = function () {\n    if (rowElements && rowElements.length) {\n      let lastChildElem = rowElements[rowElements.length - 1];\n      let lastIndexNumber = parseInt(lastChildElem.getAttribute('data-indexNumber'));\n      let lastItemBottomPosition;\n\n      if (settings.treeTableEditSettings) {\n        lastItemBottomPosition = (lastIndexNumber - settings.treeTableEditSettings.firstIndex) * settings.rowHeight + settings.rowHeight;\n      } else {\n        lastItemBottomPosition = calculateElementTopPosition(lastIndexNumber + 1);\n      }\n\n      let lastVisibleRowIndex = calculateLastVisibleRowIndex();\n      let lastItemAboveTop = lastItemBottomPosition < currentScrollTop;\n\n      if (lastItemAboveTop === true) {\n        // Check if all the elements are rendered.\n        if (lastIndexNumber + 1 < settings.totalFound) {\n          // Last element went up and page is empty. Need to calculate the page number now\n          self.handleScroll();\n        }\n      } else if (lastItemBottomPosition < calculateElementTopPosition(lastVisibleRowIndex + extraVisibleRowCount)) {\n        let extraBlankRowsInView = lastVisibleRowIndex - lastIndexNumber;\n        extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView; // Last element went up and element is still in the page. Can do continuous rendering\n\n        let startCount = lastIndexNumber + 1;\n        let endCount = startCount + extraVisibleRowCount + extraBlankRowsInView;\n        renderPageData(startCount, endCount);\n      }\n    } else {\n      self.handleScroll();\n    }\n  };\n  /**\n   * Method to handle wheel scroll event\n   *\n   * @param {Object} e - the event\n   */\n\n\n  function handlePinScrollEvent(e) {\n    if (disablePinScrollEvent === true) {\n      disablePinScrollEvent = false;\n      return;\n    }\n\n    var currentPinScrollLeft = settings.pinViewportElem.scrollLeft;\n    settings.syncHeader(true, currentPinScrollLeft); // If scrollTop is same as currentScrollTop then nothing else needs to be done.\n\n    if (settings.pinViewportElem.scrollTop === currentScrollTop) {\n      return;\n    }\n\n    userPinScrollsDetected += 1;\n\n    if (settings.pinViewportElem.scrollTop !== settings.pinViewportElem.scrollHeight - settings.pinViewportElem.offsetHeight) {\n      settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop;\n    } else {\n      settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop + 40;\n    } // Prevent scrolling the parent div\n\n\n    e.preventDefault();\n  }\n  /**\n   * Method call by handleScrollUp and handleScrollDown which processing page rendering\n   *\n   */\n\n\n  self.handleScroll = function () {\n    var currentStartIndex;\n\n    if (settings.initialRowIndex) {\n      self.updateRowAlignment();\n      var newScrollIdx = calculateElementIndexFromScrollTop(calculateElementTopPosition(settings.initialRowIndex) - _visibleAreaHeight * 0.75);\n      var newScrollTop = calculateElementTopPosition(newScrollIdx);\n      delete settings.initialRowIndex;\n      currentScrollTop = newScrollTop < 0 ? 0 : newScrollTop;\n      currentStartIndex = newScrollIdx;\n      settings.scrollViewportElem.scrollTop = currentScrollTop;\n    }\n\n    if (scrollToRowInProgress === true) {\n      self.updateRowAlignment();\n      settings.scrollViewportElem.scrollTop = scrollToRowScrollTop;\n      scrollToRowInProgress = false;\n      scrollToRowScrollTop = null;\n    }\n\n    if (!currentStartIndex) {\n      currentStartIndex = calculateElementIndexFromScrollTop(currentScrollTop);\n    }\n\n    var start = currentStartIndex - extraVisibleRowCount;\n    var end = currentStartIndex + visibleRowsCount + extraVisibleRowCount;\n\n    if (end > settings.totalFound - 1) {\n      var offset = end - settings.totalFound - 1;\n      end -= offset;\n      start -= offset;\n    }\n\n    renderPageData(start, end, true);\n    previousScrollTop = currentScrollTop;\n  };\n  /**\n   * Method to handle scroll up\n   */\n\n\n  function handleScrollUp() {\n    if (rowElements && rowElements.length) {\n      var firstChildElem = rowElements[0];\n      var firstItemIndex = parseInt(firstChildElem.getAttribute('data-indexNumber'));\n      var firstItemTopPosition;\n\n      if (settings.treeTableEditSettings) {\n        firstItemTopPosition = (firstItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight;\n      } else {\n        firstItemTopPosition = calculateElementTopPosition(firstItemIndex);\n      }\n\n      var firstVisibleElem = calculateElementIndexFromScrollTop(currentScrollTop);\n      var firstItemBelowBottom = firstItemTopPosition > currentScrollTop + _visibleAreaHeight;\n\n      if (firstItemBelowBottom === true) {\n        self.handleScroll();\n      } else if (firstItemTopPosition > calculateElementTopPosition(firstVisibleElem - extraVisibleRowCount)) {\n        var extraBlankRowsInView = firstItemIndex - firstVisibleElem;\n        extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n        var endCount = firstItemIndex - 1;\n        var startCount = endCount - extraVisibleRowCount - extraBlankRowsInView;\n        renderPageData(startCount, endCount);\n      }\n    } else {\n      self.handleScroll();\n    }\n  }\n  /**\n   * Sets up scrolling for trees while in edit mode\n   * @param {Boolean} isEditing if the table is in edit mode or not\n   */\n\n\n  self.setupTreeEditScroll = function (isEditing) {\n    if (!isEditing) {\n      if (settings.treeTableEditSettings) {\n        // Find our current scroll position\n        var relativeIdx = settings.scrollViewportElem.scrollTop / self.getRowHeight();\n        var scrollTop = (relativeIdx + settings.treeTableEditSettings.firstIndex - 1) * self.getRowHeight(); // Remove tree Edit settings\n\n        delete settings.treeTableEditSettings; // Reset alignment/rows\n\n        self.updateRowAlignment();\n        self.handleScroll(); // Reset our scroll position to what we were at\n\n        settings.pinViewportElem.scrollTop = scrollTop;\n        settings.scrollViewportElem.scrollTop = scrollTop;\n      }\n\n      return;\n    } // If no element in table, return\n\n\n    if (!rowElements || !rowElements[0]) {\n      return;\n    } // Find first row that contains data\n\n\n    var firstChildElem = rowElements[0];\n    var firstIndex = parseInt(firstChildElem.getAttribute('data-indexNumber'));\n    var hasProps = settings.loadedVMObjects[firstIndex].props;\n\n    while (hasProps && firstIndex > 0) {\n      hasProps = settings.loadedVMObjects[firstIndex - 1].props;\n\n      if (hasProps) {\n        firstIndex--;\n      }\n    } // Find last row that contains data\n\n\n    var lastChildElem = rowElements[rowElements.length - 1];\n    var lastIndex = parseInt(lastChildElem.getAttribute('data-indexNumber'));\n    hasProps = settings.loadedVMObjects[lastIndex].props;\n\n    while (hasProps && lastIndex < settings.totalFound - 1) {\n      hasProps = settings.loadedVMObjects[lastIndex + 1].props;\n\n      if (hasProps) {\n        lastIndex++;\n      }\n    }\n\n    settings.treeTableEditSettings = {\n      firstIndex: firstIndex,\n      lastIndex: lastIndex,\n      totalDataLength: lastIndex + 1\n    }; // update the container height\n\n    self.updateRowAlignment();\n  };\n  /**\n   *  Remove rows from lower-bound to upper-bound\n   *\n   * @param {Object} upperCountIdx - event\n   * @param {Object} lowerCounterIdx - event\n   */\n\n\n  function removeRows(upperCountIdx, lowerCounterIdx) {\n    settings.removeRows(upperCountIdx, lowerCounterIdx);\n    rowElements = settings.scrollParentElem.querySelectorAll(settings.rowSelector);\n  }\n  /**\n   *  Resets infinite scroll back to a starting state\n   */\n\n\n  self.resetInfiniteScroll = function () {\n    self.setLoadedVMObjects([]);\n    self.resetInitialRowIndex();\n    rowHeightCache = [];\n    settings.scrollViewportElem.scrollTop = 0;\n    settings.pinViewportElem.style.top = '0px';\n    settings.scrollViewportElem.style.top = '0px';\n    currentScrollTop = 0;\n    self.handleScroll();\n  };\n  /**\n   * Resets the row height cache\n   */\n\n\n  self.resetRowHeightCache = function () {\n    rowHeightCache = [];\n  };\n  /**\n   * Method to render rows\n   *\n   * @param {Number} startIndex Start render index\n   * @param {Number} endIndex End render Index\n   */\n\n\n  function renderRows(startIndex, endIndex) {\n    settings.renderRows(startIndex, endIndex);\n    rowElements = settings.scrollParentElem.querySelectorAll(settings.rowSelector);\n\n    if (settings.dynamicRowHeightStatus) {\n      // check if last value of rowHeightCache is in new set of rendered data, otherwise can cause off by 1.\n      let lastCacheIdx = rowHeightCache.length - 1;\n      let firstElemIdx = rowElements[0].getAttribute('data-indexnumber');\n      let lastElemIdx = rowElements[rowElements.length - 1].getAttribute('data-indexnumber');\n\n      if (lastCacheIdx < firstElemIdx || lastCacheIdx > lastElemIdx) {\n        // Delete last cache value to prevent off by 1 caused by margin\n        rowHeightCache[rowHeightCache.length - 1] = null;\n      } // Loop through rowElements to update row cache\n\n\n      for (let rowElement of rowElements) {\n        let index = parseInt(rowElement.getAttribute('data-indexnumber'));\n        rowHeightCache[index] = rowElement.offsetHeight;\n      }\n    }\n  }\n  /**\n   * Method to render rows\n   *\n   * @param {int} startCount - event\n   * @param {int} endCount - event\n   * @param {int} removeAllChild - event\n   */\n\n\n  function renderPageData(startCount, endCount, removeAllChild) {\n    var totalDataLength; // Check if table is tree table and is editing\n\n    if (settings.treeTableEditSettings) {\n      if (startCount < settings.treeTableEditSettings.firstIndex) {\n        startCount = settings.treeTableEditSettings.firstIndex;\n      }\n\n      if (endCount > settings.treeTableEditSettings.lastIndex) {\n        endCount = settings.treeTableEditSettings.lastIndex;\n      }\n\n      totalDataLength = settings.treeTableEditSettings.totalDataLength;\n    } else {\n      // Check to avoid negative indexing\n      if (startCount < 0) {\n        startCount = 0;\n      }\n\n      totalDataLength = settings.totalFound;\n    }\n\n    if (startCount >= totalDataLength) {\n      if (totalDataLength === 0) {\n        // if collection becomes empty, then remove all the existing list rows\n        removeRows(rowElements.length - 1, 0);\n        self.updateRowAlignment();\n      } else {\n        settings.updateScrollColumnsInView(currentScrollLeft, scrollContainerWidth);\n        renderRows(startCount, endCount);\n      }\n\n      if (startCount === totalDataLength) {\n        logger.trace('Table scroll service: Rendering of page data complete. No more data to render.');\n        return;\n      }\n    } // check to avoid wrong indexing for startCount\n\n\n    if (startCount > totalDataLength) {\n      endCount -= startCount;\n      startCount = 0;\n    } // check to avoid wrong indexing for endCount\n\n\n    if (endCount >= totalDataLength) {\n      endCount = totalDataLength - 1;\n    }\n\n    if (removeAllChild) {\n      // remove the elements from the dom tree.\n      removeRows(rowElements.length - 1, 0);\n    }\n\n    renderRows(startCount, endCount);\n    self.updateRowAlignment();\n    afterGridRender();\n  }\n  /**\n   * Remove extra rows\n   */\n\n\n  function removeExtraRows() {\n    const rowParentElem = settings.scrollParentElem;\n    rowElements = rowParentElem.querySelectorAll(settings.rowSelector);\n\n    if (rowElements.length === 0) {\n      logger.error('Rendering error');\n    } else {\n      let extraChildCount;\n      let invisibleRowsCount;\n      let invisibleRowsHeight;\n      const firstElem = rowElements[0];\n      const firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n\n      if (settings.treeTableEditSettings) {\n        invisibleRowsHeight = (firstRenderedItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight - currentScrollTop;\n      } else {\n        // Simply checking if there are invisible rows, actual height doesn't matter as is not used\n        invisibleRowsHeight = calculateElementTopPosition(firstRenderedItemIndex) - currentScrollTop;\n      }\n\n      if (invisibleRowsHeight < 0) {\n        invisibleRowsCount = Math.abs(calculateElementIndexFromScrollTop(currentScrollTop) - firstRenderedItemIndex);\n        extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n\n        if (extraChildCount > 0) {\n          // remove the elements from the dom tree.\n          removeRows(extraChildCount, 0);\n        }\n      }\n\n      const lastElem = rowElements[rowElements.length - 1];\n      const lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n      const visRowsHeight = visibleRowsCount * settings.rowHeight + currentScrollTop;\n      const lastVisibleRowIndex = calculateLastVisibleRowIndex();\n\n      if (settings.treeTableEditSettings) {\n        invisibleRowsHeight = (lastRenderedItemIndex - settings.treeTableEditSettings.firstIndex) * settings.rowHeight + settings.rowHeight - visRowsHeight;\n      } else {\n        // Simply checking if there are invisible rows, so actual height doesn't matter here as it will not be used.\n        invisibleRowsHeight = lastRenderedItemIndex - lastVisibleRowIndex;\n      }\n\n      if (invisibleRowsHeight > 0) {\n        invisibleRowsCount = lastRenderedItemIndex - lastVisibleRowIndex;\n        extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n\n        if (extraChildCount > 0) {\n          removeRows(rowElements.length - 1, rowElements.length - extraChildCount - 1);\n        }\n      }\n    }\n\n    self.updateRowAlignment();\n  }\n  /**\n   * After grid rendered\n   */\n\n\n  function afterGridRender() {\n    var firstRenderedItemIndex = 0;\n    var lastRenderedItemIndex = 0;\n    var firstElem = rowElements[0];\n    firstRenderedItemIndex = parseInt(firstElem.getAttribute('data-indexNumber'));\n    var lastElem = rowElements[rowElements.length - 1];\n    lastRenderedItemIndex = parseInt(lastElem.getAttribute('data-indexNumber'));\n    var firstRenderedItem = {\n      index: firstRenderedItemIndex,\n      uid: firstElem.vmo.uid,\n      levelNdx: firstElem.vmo.levelNdx\n    };\n    var lastRenderedItem = {\n      index: lastRenderedItemIndex,\n      uid: lastElem.vmo.uid,\n      levelNdx: lastElem.vmo.levelNdx\n    };\n    settings.afterGridRenderCallback(firstRenderedItem, lastRenderedItem);\n  }\n\n  self.destroyGrid = function () {\n    settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener('scroll', handleScrollEvent);\n    settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener('scroll', handleScrollEndEvent);\n    settings.pinViewportElem && settings.pinViewportElem.removeEventListener('scroll', handlePinScrollEvent);\n    momentumScrolling.disable();\n    self.checkForResize.cancel();\n    horizontalScrollDebounceEvent.cancel();\n    verticalScrollDebounceEvent.cancel();\n  };\n  /**\n   * Scrolls to the given row\n   *\n   * @param {integer[]} rowIndexes Index to scroll to\n   * @returns {boolean} returns false if a row is in view\n   */\n\n\n  self.scrollToRowIndex = function (rowIndexes) {\n    // Only scroll to row if it is out of view\n    if (self.isInitialized() === true) {\n      var scrollToRowElementPosition = null;\n      var firstRowElementIndex = 0;\n      var lastIndexNumber = 0;\n\n      if (rowElements.length > 0) {\n        firstRowElementIndex = Number(rowElements[0].getAttribute('data-indexnumber'));\n        lastIndexNumber = Number(rowElements[rowElements.length - 1].getAttribute('data-indexnumber'));\n      }\n\n      var scrollCanvasRect = settings.scrollViewportElem.getBoundingClientRect();\n\n      for (var i = 0; i < rowIndexes.length; i++) {\n        var rowIndex = rowIndexes[i];\n\n        if (rowElements.length > 0) {\n          if (rowIndex > lastIndexNumber || rowIndex < firstRowElementIndex) {\n            initialRowIndex = rowIndex;\n            continue;\n          }\n\n          scrollToRowElementPosition = rowElements[rowIndex - firstRowElementIndex].getBoundingClientRect();\n\n          if (scrollToRowElementPosition.top < scrollCanvasRect.top || scrollToRowElementPosition.bottom > scrollCanvasRect.bottom) {\n            initialRowIndex = rowIndex;\n            continue;\n          }\n\n          initialRowIndex = rowIndex;\n        }\n\n        return false;\n      } // Check if attempting to scroll past maximum scrollTop, if so set flag\n\n\n      var maxScrollTop = settings.scrollViewportElem.scrollHeight - settings.scrollViewportElem.clientHeight;\n      var newScrollTop = Math.floor(calculateElementTopPosition(initialRowIndex) - _visibleAreaHeight * 0.75);\n      var initialRowIndexOnDom = initialRowIndex - firstRowElementIndex;\n\n      if (rowElements[initialRowIndexOnDom]) {\n        scrollToRowElementPosition = rowElements[initialRowIndexOnDom].getBoundingClientRect();\n\n        if (scrollToRowElementPosition.top < scrollCanvasRect.top && scrollToRowElementPosition.bottom > scrollCanvasRect.top) {\n          newScrollTop = calculateElementTopPosition(initialRowIndex);\n        } else if (scrollToRowElementPosition.top < scrollCanvasRect.bottom && scrollToRowElementPosition.bottom > scrollCanvasRect.bottom) {\n          newScrollTop = settings.scrollViewportElem.scrollTop + (scrollToRowElementPosition.bottom - scrollCanvasRect.bottom);\n        }\n      }\n\n      if (newScrollTop > maxScrollTop) {\n        scrollToRowInProgress = true;\n        scrollToRowScrollTop = newScrollTop;\n      }\n\n      settings.scrollViewportElem.scrollTop = newScrollTop;\n    } else {\n      initialRowIndex = rowIndexes[0];\n    }\n\n    return true;\n  };\n  /**\n   * Scrolls to scroll container column\n   * @param {Object} column - The column to scroll to\n   */\n\n\n  self.scrollToColumn = function (column) {\n    if (column.startPosition <= currentScrollLeft || column.startPosition > currentScrollLeft + scrollContainerWidth) {\n      settings.scrollViewportElem.scrollLeft = column.startPosition - 10;\n    }\n  };\n\n  self.isInitialRowIndexInView = function () {\n    let firstRowElementIndex = Number(rowElements[0].getAttribute('data-indexnumber'));\n    let initialRowElement = rowElements[initialRowIndex - firstRowElementIndex];\n\n    if (initialRowElement === undefined) {\n      return false;\n    }\n\n    let initialRowElementIndex = initialRowElement.getAttribute('data-indexnumber');\n    let firstVisibleIndex = calculateElementIndexFromScrollTop(currentScrollTop);\n    let lastVisibleIndex = calculateLastVisibleRowIndex();\n\n    if (initialRowElementIndex < firstVisibleIndex || initialRowIndex > lastVisibleIndex) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Resets the initial row index to 0 so that infinite scroll service will\n   * start the rendering of rows at the top.\n   */\n\n\n  self.resetInitialRowIndex = function () {\n    initialRowIndex = 0;\n  };\n};\n\n_c2 = SPLMTableInfiniteScroll;\n_c = SPLMTableInfiniteScroll;\nexport default SPLMTableInfiniteScroll;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableInfiniteScroll\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableInfiniteScroll\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableInfiniteScrollService.js"],"names":["SPLMTableInfiniteScroll","self","settings","currentScrollTop","previousScrollTop","rowElements","rowHeightCache","initialized","containerHeightInitialized","_containerHeight","_visibleAreaHeight","initialRowIndex","extraVisibleRowCount","visibleRowsCount","currentScrollLeft","scrollToRowInProgress","scrollToRowScrollTop","maintainScrollPosition","disablePinScrollEvent","userPinScrollsDetected","scrollContainerWidth","verticalScrollDebounceTime","browserUtils","horizontalScrollDebounceTime","verticalScrollDebounceMaxWait","momentumScrolling","lastScrollTimeStamp","elapsedMSSinceLastScroll","extraTop","horizontalScrollDebounceEvent","verticalScrollDebounceEvent","handleScrollEventInternal","maxWait","initializeEvents","calculateVisibleAreaHeight","newClientWidth","rowContainerHeight","rowCount","Math","setVisibleRowsCount","firstRenderedItemIndex","firstElem","parseInt","lastRenderedItemIndex","lastElem","String","setExtraVisibleRowCount","index","runningTop","idx","getHeightFromCache","runningTotal","calculateElementIndexFromScrollTop","containerHeight","scrollCanvasHeight","logger","topHeight","firstElement","firstElementIdx","calculateElementTopPosition","scrollContentHeight","scrollDistance","isScrollDown","setValuesForMaintainingScroll","loadedViewModelObjects","currentRow","scrollToRow","clearTimeout","scrollEndTimer","setTimeout","removeExtraRows","tempExtraTop","pinViewportElem","scrollViewportElem","addPinViewportScrollbarPadding","removePinViewportScrollbarPadding","oldScrollTop","oldScrollLeft","e","func","Const","lastChildElem","lastIndexNumber","lastItemBottomPosition","lastVisibleRowIndex","calculateLastVisibleRowIndex","lastItemAboveTop","extraBlankRowsInView","startCount","endCount","renderPageData","currentPinScrollLeft","newScrollIdx","newScrollTop","currentStartIndex","start","end","offset","firstChildElem","firstItemIndex","firstItemTopPosition","firstVisibleElem","firstItemBelowBottom","relativeIdx","scrollTop","firstIndex","hasProps","lastIndex","totalDataLength","lastCacheIdx","firstElemIdx","lastElemIdx","rowElement","removeRows","renderRows","afterGridRender","rowParentElem","invisibleRowsHeight","invisibleRowsCount","extraChildCount","visRowsHeight","firstRenderedItem","uid","levelNdx","lastRenderedItem","scrollToRowElementPosition","firstRowElementIndex","Number","scrollCanvasRect","i","rowIndexes","rowIndex","maxScrollTop","initialRowIndexOnDom","column","initialRowElement","initialRowElementIndex","firstVisibleIndex","lastVisibleIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is for exposing the native js data provider behavior. The module supports loading the module from GWT\n * and getting the native JS code invoked.\n *\n * @module js/splmTableInfiniteScrollService\n */\nimport logger from 'js/logger';\nimport browserUtils from 'js/browserUtils';\nimport SPLMTableMomentumScrolling from 'js/splmTableMomentumScrolling';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\n\n/**\n * Native infinite scroll.\n *\n * @constructor\n * @param {Number} containerHeight the container height\n */\nlet SPLMTableInfiniteScroll = function( containerHeight ) {\n    let self = this;\n    let settings = {};\n\n    let currentScrollTop = 0; // Holds the last scroll position to detect scroll down or up\n    let previousScrollTop = 0;\n    let rowElements = []; // contains cache of rendered list\n    let rowHeightCache = [];\n    let initialized = false;\n    let containerHeightInitialized = false;\n    let _containerHeight = containerHeight;\n    let _visibleAreaHeight = _containerHeight - settings.headerHeight;\n    let initialRowIndex = 0;\n    let extraVisibleRowCount = 14; // keep it even for easier scrolling/calculations\n    let visibleRowsCount = 0;\n    let currentScrollLeft = 0;\n    let scrollToRowInProgress = false;\n    let scrollToRowScrollTop = null;\n    let maintainScrollPosition = false;\n    let disablePinScrollEvent = false;\n    let userPinScrollsDetected = 0;\n    let scrollContainerWidth = 0;\n    let verticalScrollDebounceTime = browserUtils.isIE || browserUtils.isFirefox ? 200 : 0;\n    let horizontalScrollDebounceTime = browserUtils.isIE ? 500 : 0;\n    let verticalScrollDebounceMaxWait = browserUtils.isIE || browserUtils.isFirefox ? Infinity : 0;\n    let momentumScrolling = new SPLMTableMomentumScrolling();\n    let lastScrollTimeStamp = new Date();\n    let elapsedMSSinceLastScroll = 0;\n\n    // LCS-133249 Scrolling performance issue\n    // Do scroll syncing at very beginning\n    let extraTop = 0;\n\n    let horizontalScrollDebounceEvent = _.debounce( function() {\n        if( settings.scrollViewportElem && settings.scrollViewportElem.offsetWidth ) {\n            scrollContainerWidth = settings.scrollViewportElem.offsetWidth;\n        }\n        settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n        settings.updateVisibleCells( settings.scrollParentElem );\n    }, horizontalScrollDebounceTime );\n\n    let verticalScrollDebounceEvent = _.debounce( function() {\n        handleScrollEventInternal();\n    }, verticalScrollDebounceTime, {\n        maxWait: verticalScrollDebounceMaxWait\n    } );\n\n    self.initializeGrid = function( obj ) {\n        settings = obj;\n        settings.pinParentElem = settings.pinViewportElem.children[ 0 ];\n        settings.scrollParentElem = settings.scrollViewportElem.children[ 0 ];\n        settings.totalFound = settings.loadedVMObjects.length;\n        settings.dynamicRowHeightStatus = settings.dynamicRowHeightStatus || false;\n        initializeEvents();\n        momentumScrolling.enable( settings.pinViewportElem, settings.scrollViewportElem );\n        initialized = true;\n    };\n\n    /**\n     * Calculates the visible area of the table\n     * @returns {Number} the visible height\n     */\n    let calculateVisibleAreaHeight = function() {\n        return _containerHeight - settings.headerHeight;\n    };\n\n    self.checkForResize = _.debounce( async function() {\n        elapsedMSSinceLastScroll = new Date() - lastScrollTimeStamp;\n        if( elapsedMSSinceLastScroll < 200 ) {\n            return;\n        }\n        let newClientWidth = settings.scrollViewportElem.offsetWidth;\n        if( newClientWidth !== scrollContainerWidth ) {\n            if( newClientWidth > scrollContainerWidth ) {\n                scrollContainerWidth = newClientWidth;\n                settings.updateScrollColumnsInView( currentScrollLeft );\n            } else {\n                scrollContainerWidth = newClientWidth;\n                settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n            }\n            settings.updateVisibleCells( settings.scrollParentElem );\n            self.handlePinViewportScrollbarPadding();\n        }\n\n        if( settings.directiveElem.clientHeight !== _containerHeight ) {\n            _containerHeight = settings.directiveElem.clientHeight;\n            let rowContainerHeight = settings.scrollViewportElem.clientHeight || settings.pinViewportElem.clientHeight || _containerHeight;\n            let rowCount = Math.floor( rowContainerHeight / settings.rowHeight );\n            _visibleAreaHeight = calculateVisibleAreaHeight();\n            setVisibleRowsCount( rowCount );\n            await self.handleScroll();\n        }\n    }, 200 );\n\n    self.isInitialized = function() {\n        return initialized;\n    };\n\n    /**\n     * Renders the initial rows on initialization once table div has been rendered so that\n     * the height can be computed properly\n     */\n    self.renderInitialRows = function() {\n        self.initializeProperties();\n        settings.initialRowIndex = initialRowIndex;\n        self.handleScroll();\n    };\n\n    self.getFirstRenderedItemIndex = function() {\n        var firstRenderedItemIndex = 0;\n        var firstElem = rowElements[ 0 ];\n        firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n        return firstRenderedItemIndex;\n    };\n\n    self.getLastRenderedItemIndex = function() {\n        var lastRenderedItemIndex = 0;\n        var lastElem = rowElements[ rowElements.length - 1 ];\n        lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n        return lastRenderedItemIndex;\n    };\n\n    /**\n     * set the object set height\n     * @param {Number} heightVal The container height\n     */\n    self.setContainerHeight = function( heightVal ) {\n        _containerHeight = heightVal;\n        _visibleAreaHeight = calculateVisibleAreaHeight();\n        // LCS-140092 - AW UxRefresh does not allow scrolling in Qt WebEngine Browser\n        // 100% is not working in Qt WebEngine, use heightVal here\n        settings.scrollViewportElem.style.maxHeight = String( _visibleAreaHeight ) + 'px';\n        settings.pinViewportElem.style.maxHeight = String( _visibleAreaHeight ) + 'px';\n    };\n\n    /**\n     * Set if dynamic row height is enabled or not\n     *\n     * @param {Boolean} isEnabled if DRH is enabled or not\n     */\n    self.setDynamicRowHeight = function( isEnabled ) {\n        settings.dynamicRowHeightStatus = isEnabled;\n        if( settings.tableElem._tableInstance ) {\n            settings.tableElem._tableInstance.dynamicRowHeightStatus = isEnabled;\n        }\n    };\n\n    /**\n     * Sets the extra visible row count 10 < x < 30\n     *\n     * @param {Number} rowCount The number of rows to set\n     */\n    function setExtraVisibleRowCount( rowCount ) {\n        extraVisibleRowCount = Math.max( 10, Math.min( 30, rowCount ) );\n    }\n\n    /**\n     * Sets the visible row count\n     *\n     * @param {Number} rowCount the number of visible rows\n     */\n    function setVisibleRowsCount( rowCount ) {\n        visibleRowsCount = rowCount;\n        setExtraVisibleRowCount( rowCount );\n    }\n\n    /**\n     * Convenience method to get certain row height from cache\n     *\n     * @param {Number} index The row's index\n     * @returns {Number} the row's height\n     */\n    function getHeightFromCache( index ) {\n        if( rowHeightCache[ index ] ) {\n            if( index === rowHeightCache.length - 1 ) {\n                return rowHeightCache[ index ];\n            }\n            return rowHeightCache[ index ] - 1; // The -1 is because of the -1 margin added to the rows. May change in future\n        }\n        return settings.rowHeight;\n    }\n\n    /**\n     * Calculates the element's top position (scrollTop or just top)\n     * using the row height cache and its index\n     *\n     * @param {Number} elementIdx The element's index\n     * @returns {Number} the top position for the element\n     */\n    function calculateElementTopPosition( elementIdx ) {\n        let runningTop = 0;\n        for( let idx = 0; idx < elementIdx; idx++ ) {\n            runningTop += getHeightFromCache( idx );\n        }\n        return runningTop;\n    }\n\n    /**\n     * Calculates the row index based off of the scrollTop. Uses the row height cache\n     * and will return the index that the scrollTop reaches to.\n     *\n     * @param {Number} scrollTop The scroll top to calculate the element idx start from\n     * @returns {Number} the element's idx\n     */\n    function calculateElementIndexFromScrollTop( scrollTop ) {\n        let runningTotal = 0;\n        let index = 0;\n        while( runningTotal < scrollTop ) {\n            runningTotal += getHeightFromCache( index );\n            index++;\n        }\n        return index;\n    }\n\n    /**\n     * Calculates the last visible row's index\n     *\n     * @returns {Number} the last visible row's index\n     */\n    function calculateLastVisibleRowIndex() {\n        return calculateElementIndexFromScrollTop( currentScrollTop + _visibleAreaHeight ) - 1;\n    }\n\n    /**\n     * Initialize scroll properties\n     */\n    self.initializeProperties = function() {\n        // Clear the row height cache\n        rowHeightCache = [];\n        // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation\n        // Use given clientHeight to save one computed CSS reading\n        if( _containerHeight === undefined ) {\n            _containerHeight = containerHeight > 0 ? containerHeight : settings.directiveElem.clientHeight;\n            _visibleAreaHeight = calculateVisibleAreaHeight();\n        } else if( containerHeightInitialized === false ) {\n            self.setContainerHeight( _containerHeight );\n        }\n        containerHeightInitialized = true;\n\n        // Table should have height of at least one row.\n        settings.scrollViewportElem.style.minHeight = String( settings.rowHeight ) + 'px';\n        settings.pinViewportElem.style.minHeight = String( settings.rowHeight ) + 'px';\n\n        let scrollCanvasHeight = _visibleAreaHeight;\n        if( scrollCanvasHeight < 0 ) {\n            scrollCanvasHeight = 0;\n        }\n\n        let rowCount = Math.floor( scrollCanvasHeight / settings.rowHeight );\n        setVisibleRowsCount( rowCount );\n\n        logger.trace( 'Table scroll service: Visible row count - ' + visibleRowsCount );\n    };\n\n    /**\n     * Updates the container and top space heights so the rows are positioned correctly\n     */\n    self.updateRowAlignment = function() {\n        let topHeight = 0;\n\n        if( rowElements ) {\n            let firstElement = rowElements[ 0 ];\n            if( firstElement && firstElement.getAttribute( 'data-indexNumber' ) ) {\n                let firstElementIdx = parseInt( firstElement.getAttribute( 'data-indexNumber' ) );\n                if( settings.treeTableEditSettings ) {\n                    topHeight = ( firstElementIdx - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight;\n                } else {\n                    topHeight = calculateElementTopPosition( firstElementIdx );\n                }\n            }\n        }\n\n        settings.pinParentElem.style.top = topHeight + 'px';\n        settings.scrollParentElem.style.top = topHeight + 'px';\n\n        let scrollContentHeight;\n        // If tree table and editing, use treeEditSettings.lastIndex - the first index to get number of rows in total\n        if( settings.treeTableEditSettings ) {\n            scrollContentHeight = ( settings.treeTableEditSettings.lastIndex - settings.treeTableEditSettings.firstIndex + 1 ) * settings.rowHeight - topHeight;\n        } else {\n            scrollContentHeight = calculateElementTopPosition( settings.totalFound ) - topHeight;\n        }\n\n        settings.pinParentElem.style.height = scrollContentHeight + 'px';\n        settings.scrollParentElem.style.height = scrollContentHeight + 'px';\n    };\n\n    /**\n     * Returns the row height as an int\n     * @returns {Number} The row Height\n     */\n    self.getRowHeight = function() {\n        return settings.rowHeight;\n    };\n\n    /**\n     * Scrolls the table up/down one row.\n     *\n     * @param {Boolean} isScrollDown - scroll down indicator, false for scroll up\n     * @returns {Number} returns the new scrollTop of the scrollViewportElement\n     */\n    self.manualScroll = function( isScrollDown ) {\n        let scrollDistance = isScrollDown ? self.getRowHeight() : -self.getRowHeight();\n        settings.scrollViewportElem.scrollTop += scrollDistance;\n        return settings.scrollViewportElem.scrollTop;\n    };\n\n    /**\n     * Get scrollTop of the scroll viewport.\n     *\n     * @returns {Number} returns the scrollTop of the scrollViewportElement\n     */\n    self.getScrollTop = function() {\n        return settings.scrollViewportElem.scrollTop;\n    };\n\n    /**\n     * Sets the row height\n     *\n     *  @param {int} rowHeight - the height of the row in pixels\n     */\n    self.setRowHeight = function( rowHeight ) {\n        settings.rowHeight = rowHeight;\n    };\n\n    /**\n     * Gets the total objects found\n     * @returns {Number} The total number of objects found\n     */\n    self.getTotalFound = function() {\n        return settings.totalFound;\n    };\n\n    /**\n     * Sets the loaded view model objects\n     *\n     *  @param {[ViewModelObject]} loadedViewModelObjects - the collection of view model objects\n     */\n    self.setLoadedVMObjects = function( loadedViewModelObjects ) {\n        // Maintain the scroll position\n        if( maintainScrollPosition === true ) {\n            // This will set the variables for maintaining scroll position.\n            // The values are used when handleScroll is called again.\n            setValuesForMaintainingScroll( loadedViewModelObjects.length - settings.totalFound );\n        }\n        settings.loadedVMObjects = loadedViewModelObjects;\n        settings.totalFound = loadedViewModelObjects.length;\n    };\n\n    self.setScrollPositionToBeMaintained = function() {\n        maintainScrollPosition = true;\n    };\n\n    /**\n     * Sets the proper variables to maintain the scroll position\n     * @param {integer} rowDifferenceCount - the difference in rows used to calculate maintained scroll position\n     */\n    function setValuesForMaintainingScroll( rowDifferenceCount ) {\n        maintainScrollPosition = false;\n        scrollToRowInProgress = true;\n        let currentRow = calculateElementIndexFromScrollTop( settings.scrollViewportElem.scrollTop );\n        let scrollToRow = currentRow + rowDifferenceCount;\n        scrollToRowScrollTop = calculateElementTopPosition( scrollToRow );\n    }\n\n    self.isScrollToRowInProgress = function() {\n        return scrollToRowInProgress;\n    };\n\n    let scrollEndTimer;\n\n    /**\n     * Handles Scroll End logic\n     * Deletes excess rows when user has stopped scrolling for 500ms\n     * This prevents excessive deleting while trying to also create new rows and scroll table\n     */\n    function handleScrollEndEvent() {\n        if( scrollEndTimer ) {\n            clearTimeout( scrollEndTimer );\n        }\n        scrollEndTimer = setTimeout( function() {\n            removeExtraRows();\n        }, 300 );\n    }\n\n    /**\n     * Initialize Scroll Event to table\n     */\n    function initializeEvents() {\n        settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem.removeEventListener( 'scroll', handlePinScrollEvent );\n        settings.scrollViewportElem.addEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem.addEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem.addEventListener( 'scroll', handlePinScrollEvent );\n    }\n\n    /**\n     * Add a padding to the pin viewport to align pin rows with content rows\n     * when scrolled to the bottom.\n     *\n     * @param {Number} tempExtraTop - amount of padding in pixels\n     */\n    function addPinViewportScrollbarPadding( tempExtraTop ) {\n        settings.pinViewportElem.style.top = String( tempExtraTop * -1 ) + 'px';\n        extraTop = tempExtraTop;\n    }\n\n    /**\n     * Remove the padding to the pin viewport used for row alignment.\n     */\n    function removePinViewportScrollbarPadding() {\n        settings.pinViewportElem.style.top = '0px';\n        extraTop = 0;\n    }\n\n    /**\n     * Apply/remove extra top for pinViewport if the scrollViewport is now visible/invisible\n     */\n    self.handlePinViewportScrollbarPadding = function() {\n        const pinViewportElem = settings.pinViewportElem;\n        const scrollViewportElem = settings.scrollViewportElem;\n        if( currentScrollTop >= 0 ) {\n            if( pinViewportElem.style.top === '0px' && scrollViewportElem.clientWidth > 0 ) {\n                let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n                if( tempExtraTop > 0 ) {\n                    addPinViewportScrollbarPadding( tempExtraTop );\n                }\n            } else if( pinViewportElem.style.top !== '0px' && scrollViewportElem.clientWidth <= 0 ) {\n                removePinViewportScrollbarPadding();\n            }\n        }\n    };\n\n    /**\n     * Scroll Event Handler\n     */\n    function handleScrollEvent( e ) {\n        lastScrollTimeStamp = new Date();\n        let oldScrollTop = currentScrollTop;\n        currentScrollTop = settings.scrollViewportElem.scrollTop;\n        let oldScrollLeft = currentScrollLeft;\n        currentScrollLeft = settings.scrollViewportElem.scrollLeft;\n\n        if( oldScrollTop === currentScrollTop && currentScrollTop < 0 && oldScrollLeft === currentScrollLeft && currentScrollLeft < 0 ) {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n\n        // LCS-133249 Scrolling performance issue\n        // Do scroll syncing at very beginning\n        let pinViewportElem = settings.pinViewportElem;\n        if( userPinScrollsDetected === 0 && ( oldScrollTop !== currentScrollTop || currentScrollTop === 0 ) ) {\n            disablePinScrollEvent = true;\n            pinViewportElem.scrollTop = currentScrollTop;\n        }\n\n        settings.onStartScroll();\n\n        if( oldScrollLeft !== currentScrollLeft && currentScrollLeft >= 0 ) {\n            settings.syncHeader( false, currentScrollLeft );\n            horizontalScrollDebounceEvent();\n        }\n\n        if( oldScrollTop !== currentScrollTop && currentScrollTop >= 0 ) {\n            let tempExtraTop = pinViewportElem.offsetHeight + currentScrollTop - pinViewportElem.scrollHeight;\n            if( tempExtraTop > 0 ) {\n                if( settings.scrollViewportElem.clientWidth > 0 ) {\n                    addPinViewportScrollbarPadding( tempExtraTop );\n                }\n            } else if( extraTop > 0 ) {\n                // For non IE/Edge, need to set top back when scroll up\n                removePinViewportScrollbarPadding();\n            }\n\n            verticalScrollDebounceEvent();\n        }\n\n        userPinScrollsDetected -= 1;\n        if( userPinScrollsDetected < 0 ) {\n            userPinScrollsDetected = 0;\n        }\n    }\n\n    /**\n     * Real processing method for scroll event after debounce/requestAnimationFrame\n     */\n    function handleScrollEventInternal() {\n        let func;\n        let isScrollDown = currentScrollTop > previousScrollTop;\n        if( isScrollDown ) {\n            func = self.handleScrollDown;\n        } else {\n            func = handleScrollUp;\n        }\n        previousScrollTop = currentScrollTop;\n\n        // Do scroll shadow\n        if( currentScrollTop > 0 ) {\n            if( !settings.tableElem.classList.contains( Const.CLASS_TABLE_SCROLLED ) ) {\n                settings.tableElem.classList.add( Const.CLASS_TABLE_SCROLLED );\n            }\n        } else {\n            if( settings.tableElem.classList.contains( Const.CLASS_TABLE_SCROLLED ) ) {\n                settings.tableElem.classList.remove( Const.CLASS_TABLE_SCROLLED );\n            }\n        }\n\n        func.call();\n    }\n\n    /**\n     * Method to handle scroll down\n     */\n    self.handleScrollDown = function() {\n        if( rowElements && rowElements.length ) {\n            let lastChildElem = rowElements[ rowElements.length - 1 ];\n            let lastIndexNumber = parseInt( lastChildElem.getAttribute( 'data-indexNumber' ) );\n            let lastItemBottomPosition;\n            if( settings.treeTableEditSettings ) {\n                lastItemBottomPosition = ( lastIndexNumber - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight + settings.rowHeight;\n            } else {\n                lastItemBottomPosition = calculateElementTopPosition( lastIndexNumber + 1 );\n            }\n            let lastVisibleRowIndex = calculateLastVisibleRowIndex();\n            let lastItemAboveTop = lastItemBottomPosition < currentScrollTop;\n            if( lastItemAboveTop === true ) {\n                // Check if all the elements are rendered.\n                if( lastIndexNumber + 1 < settings.totalFound ) {\n                    // Last element went up and page is empty. Need to calculate the page number now\n                    self.handleScroll();\n                }\n            } else if( lastItemBottomPosition < calculateElementTopPosition( lastVisibleRowIndex + extraVisibleRowCount ) ) {\n                let extraBlankRowsInView = lastVisibleRowIndex - lastIndexNumber;\n                extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n                // Last element went up and element is still in the page. Can do continuous rendering\n                let startCount = lastIndexNumber + 1;\n                let endCount = startCount + extraVisibleRowCount + extraBlankRowsInView;\n                renderPageData( startCount, endCount );\n            }\n        } else {\n            self.handleScroll();\n        }\n    };\n\n    /**\n     * Method to handle wheel scroll event\n     *\n     * @param {Object} e - the event\n     */\n    function handlePinScrollEvent( e ) {\n        if( disablePinScrollEvent === true ) {\n            disablePinScrollEvent = false;\n            return;\n        }\n\n        var currentPinScrollLeft = settings.pinViewportElem.scrollLeft;\n        settings.syncHeader( true, currentPinScrollLeft );\n\n        // If scrollTop is same as currentScrollTop then nothing else needs to be done.\n        if( settings.pinViewportElem.scrollTop === currentScrollTop ) {\n            return;\n        }\n\n        userPinScrollsDetected += 1;\n\n        if( settings.pinViewportElem.scrollTop !== settings.pinViewportElem.scrollHeight - settings.pinViewportElem.offsetHeight ) {\n            settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop;\n        } else {\n            settings.scrollViewportElem.scrollTop = settings.pinViewportElem.scrollTop + 40;\n        }\n\n        // Prevent scrolling the parent div\n        e.preventDefault();\n    }\n\n    /**\n     * Method call by handleScrollUp and handleScrollDown which processing page rendering\n     *\n     */\n    self.handleScroll = function() {\n        var currentStartIndex;\n\n        if( settings.initialRowIndex ) {\n            self.updateRowAlignment();\n            var newScrollIdx = calculateElementIndexFromScrollTop( calculateElementTopPosition( settings.initialRowIndex ) - _visibleAreaHeight * 0.75 );\n            var newScrollTop = calculateElementTopPosition( newScrollIdx );\n            delete settings.initialRowIndex;\n            currentScrollTop = newScrollTop < 0 ? 0 : newScrollTop;\n            currentStartIndex = newScrollIdx;\n            settings.scrollViewportElem.scrollTop = currentScrollTop;\n        }\n        if( scrollToRowInProgress === true ) {\n            self.updateRowAlignment();\n            settings.scrollViewportElem.scrollTop = scrollToRowScrollTop;\n            scrollToRowInProgress = false;\n            scrollToRowScrollTop = null;\n        }\n\n        if( !currentStartIndex ) {\n            currentStartIndex = calculateElementIndexFromScrollTop( currentScrollTop );\n        }\n\n        var start = currentStartIndex - extraVisibleRowCount;\n        var end = currentStartIndex + visibleRowsCount + extraVisibleRowCount;\n        if( end > settings.totalFound - 1 ) {\n            var offset = end - settings.totalFound - 1;\n            end -= offset;\n            start -= offset;\n        }\n        renderPageData( start, end, true );\n        previousScrollTop = currentScrollTop;\n    };\n\n    /**\n     * Method to handle scroll up\n     */\n    function handleScrollUp() {\n        if( rowElements && rowElements.length ) {\n            var firstChildElem = rowElements[ 0 ];\n            var firstItemIndex = parseInt( firstChildElem.getAttribute( 'data-indexNumber' ) );\n            var firstItemTopPosition;\n            if( settings.treeTableEditSettings ) {\n                firstItemTopPosition = ( firstItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight;\n            } else {\n                firstItemTopPosition = calculateElementTopPosition( firstItemIndex );\n            }\n            var firstVisibleElem = calculateElementIndexFromScrollTop( currentScrollTop );\n            var firstItemBelowBottom = firstItemTopPosition > currentScrollTop + _visibleAreaHeight;\n            if( firstItemBelowBottom === true ) {\n                self.handleScroll();\n            } else if( firstItemTopPosition > calculateElementTopPosition( firstVisibleElem - extraVisibleRowCount ) ) {\n                var extraBlankRowsInView = firstItemIndex - firstVisibleElem;\n                extraBlankRowsInView = extraBlankRowsInView < 0 ? 0 : extraBlankRowsInView;\n                var endCount = firstItemIndex - 1;\n\n                var startCount = endCount - extraVisibleRowCount - extraBlankRowsInView;\n                renderPageData( startCount, endCount );\n            }\n        } else {\n            self.handleScroll();\n        }\n    }\n\n    /**\n     * Sets up scrolling for trees while in edit mode\n     * @param {Boolean} isEditing if the table is in edit mode or not\n     */\n    self.setupTreeEditScroll = function( isEditing ) {\n        if( !isEditing ) {\n            if( settings.treeTableEditSettings ) {\n                // Find our current scroll position\n                var relativeIdx = settings.scrollViewportElem.scrollTop / self.getRowHeight();\n                var scrollTop = ( relativeIdx + settings.treeTableEditSettings.firstIndex - 1 ) * self.getRowHeight();\n                // Remove tree Edit settings\n                delete settings.treeTableEditSettings;\n                // Reset alignment/rows\n                self.updateRowAlignment();\n                self.handleScroll();\n                // Reset our scroll position to what we were at\n                settings.pinViewportElem.scrollTop = scrollTop;\n                settings.scrollViewportElem.scrollTop = scrollTop;\n            }\n            return;\n        }\n\n        // If no element in table, return\n        if( !rowElements || !rowElements[ 0 ] ) {\n            return;\n        }\n\n        // Find first row that contains data\n        var firstChildElem = rowElements[ 0 ];\n        var firstIndex = parseInt( firstChildElem.getAttribute( 'data-indexNumber' ) );\n        var hasProps = settings.loadedVMObjects[ firstIndex ].props;\n\n        while( hasProps && firstIndex > 0 ) {\n            hasProps = settings.loadedVMObjects[ firstIndex - 1 ].props;\n            if( hasProps ) {\n                firstIndex--;\n            }\n        }\n\n        // Find last row that contains data\n        var lastChildElem = rowElements[ rowElements.length - 1 ];\n        var lastIndex = parseInt( lastChildElem.getAttribute( 'data-indexNumber' ) );\n        hasProps = settings.loadedVMObjects[ lastIndex ].props;\n\n        while( hasProps && lastIndex < settings.totalFound - 1 ) {\n            hasProps = settings.loadedVMObjects[ lastIndex + 1 ].props;\n            if( hasProps ) {\n                lastIndex++;\n            }\n        }\n\n        settings.treeTableEditSettings = {\n            firstIndex: firstIndex,\n            lastIndex: lastIndex,\n            totalDataLength: lastIndex + 1\n        };\n\n        // update the container height\n        self.updateRowAlignment();\n    };\n\n    /**\n     *  Remove rows from lower-bound to upper-bound\n     *\n     * @param {Object} upperCountIdx - event\n     * @param {Object} lowerCounterIdx - event\n     */\n    function removeRows( upperCountIdx, lowerCounterIdx ) {\n        settings.removeRows( upperCountIdx, lowerCounterIdx );\n        rowElements = settings.scrollParentElem.querySelectorAll( settings.rowSelector );\n    }\n\n    /**\n     *  Resets infinite scroll back to a starting state\n     */\n    self.resetInfiniteScroll = function() {\n        self.setLoadedVMObjects( [] );\n        self.resetInitialRowIndex();\n        rowHeightCache = [];\n        settings.scrollViewportElem.scrollTop = 0;\n        settings.pinViewportElem.style.top = '0px';\n        settings.scrollViewportElem.style.top = '0px';\n        currentScrollTop = 0;\n        self.handleScroll();\n    };\n\n    /**\n     * Resets the row height cache\n     */\n    self.resetRowHeightCache = function() {\n        rowHeightCache = [];\n    };\n\n    /**\n     * Method to render rows\n     *\n     * @param {Number} startIndex Start render index\n     * @param {Number} endIndex End render Index\n     */\n    function renderRows( startIndex, endIndex ) {\n        settings.renderRows( startIndex, endIndex );\n        rowElements = settings.scrollParentElem.querySelectorAll( settings.rowSelector );\n        if( settings.dynamicRowHeightStatus ) {\n            // check if last value of rowHeightCache is in new set of rendered data, otherwise can cause off by 1.\n            let lastCacheIdx = rowHeightCache.length - 1;\n            let firstElemIdx = rowElements[ 0 ].getAttribute( 'data-indexnumber' );\n            let lastElemIdx = rowElements[ rowElements.length - 1 ].getAttribute( 'data-indexnumber' );\n\n            if( lastCacheIdx < firstElemIdx || lastCacheIdx > lastElemIdx ) {\n                // Delete last cache value to prevent off by 1 caused by margin\n                rowHeightCache[ rowHeightCache.length - 1 ] = null;\n            }\n            // Loop through rowElements to update row cache\n            for( let rowElement of rowElements ) {\n                let index = parseInt( rowElement.getAttribute( 'data-indexnumber' ) );\n                rowHeightCache[ index ] = rowElement.offsetHeight;\n            }\n        }\n    }\n\n    /**\n     * Method to render rows\n     *\n     * @param {int} startCount - event\n     * @param {int} endCount - event\n     * @param {int} removeAllChild - event\n     */\n    function renderPageData( startCount, endCount, removeAllChild ) {\n        var totalDataLength;\n        // Check if table is tree table and is editing\n        if( settings.treeTableEditSettings ) {\n            if( startCount < settings.treeTableEditSettings.firstIndex ) {\n                startCount = settings.treeTableEditSettings.firstIndex;\n            }\n\n            if( endCount > settings.treeTableEditSettings.lastIndex ) {\n                endCount = settings.treeTableEditSettings.lastIndex;\n            }\n            totalDataLength = settings.treeTableEditSettings.totalDataLength;\n        } else {\n            // Check to avoid negative indexing\n            if( startCount < 0 ) {\n                startCount = 0;\n            }\n            totalDataLength = settings.totalFound;\n        }\n\n        if( startCount >= totalDataLength ) {\n            if( totalDataLength === 0 ) {\n                // if collection becomes empty, then remove all the existing list rows\n                removeRows( rowElements.length - 1, 0 );\n                self.updateRowAlignment();\n            } else {\n                settings.updateScrollColumnsInView( currentScrollLeft, scrollContainerWidth );\n                renderRows( startCount, endCount );\n            }\n\n            if( startCount === totalDataLength ) {\n                logger.trace( 'Table scroll service: Rendering of page data complete. No more data to render.' );\n                return;\n            }\n        }\n\n        // check to avoid wrong indexing for startCount\n        if( startCount > totalDataLength ) {\n            endCount -= startCount;\n            startCount = 0;\n        }\n\n        // check to avoid wrong indexing for endCount\n        if( endCount >= totalDataLength ) {\n            endCount = totalDataLength - 1;\n        }\n\n        if( removeAllChild ) {\n            // remove the elements from the dom tree.\n            removeRows( rowElements.length - 1, 0 );\n        }\n\n        renderRows( startCount, endCount );\n\n        self.updateRowAlignment();\n\n        afterGridRender();\n    }\n\n    /**\n     * Remove extra rows\n     */\n    function removeExtraRows() {\n        const rowParentElem = settings.scrollParentElem;\n        rowElements = rowParentElem.querySelectorAll( settings.rowSelector );\n\n        if( rowElements.length === 0 ) {\n            logger.error( 'Rendering error' );\n        } else {\n            let extraChildCount;\n            let invisibleRowsCount;\n            let invisibleRowsHeight;\n\n            const firstElem = rowElements[ 0 ];\n            const firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n            if( settings.treeTableEditSettings ) {\n                invisibleRowsHeight = ( firstRenderedItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight - currentScrollTop;\n            } else {\n                // Simply checking if there are invisible rows, actual height doesn't matter as is not used\n                invisibleRowsHeight = calculateElementTopPosition( firstRenderedItemIndex ) - currentScrollTop;\n            }\n            if( invisibleRowsHeight < 0 ) {\n                invisibleRowsCount = Math.abs( calculateElementIndexFromScrollTop( currentScrollTop ) - firstRenderedItemIndex );\n                extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n                if( extraChildCount > 0 ) {\n                    // remove the elements from the dom tree.\n                    removeRows( extraChildCount, 0 );\n                }\n            }\n\n            const lastElem = rowElements[ rowElements.length - 1 ];\n            const lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n            const visRowsHeight = visibleRowsCount * settings.rowHeight + currentScrollTop;\n            const lastVisibleRowIndex = calculateLastVisibleRowIndex();\n            if( settings.treeTableEditSettings ) {\n                invisibleRowsHeight = ( lastRenderedItemIndex - settings.treeTableEditSettings.firstIndex ) * settings.rowHeight + settings.rowHeight - visRowsHeight;\n            } else {\n                // Simply checking if there are invisible rows, so actual height doesn't matter here as it will not be used.\n                invisibleRowsHeight = lastRenderedItemIndex - lastVisibleRowIndex;\n            }\n            if( invisibleRowsHeight > 0 ) {\n                invisibleRowsCount = lastRenderedItemIndex - lastVisibleRowIndex;\n                extraChildCount = invisibleRowsCount - extraVisibleRowCount;\n                if( extraChildCount > 0 ) {\n                    removeRows( rowElements.length - 1, rowElements.length - extraChildCount - 1 );\n                }\n            }\n        }\n        self.updateRowAlignment();\n    }\n\n    /**\n     * After grid rendered\n     */\n    function afterGridRender() {\n        var firstRenderedItemIndex = 0;\n        var lastRenderedItemIndex = 0;\n\n        var firstElem = rowElements[ 0 ];\n        firstRenderedItemIndex = parseInt( firstElem.getAttribute( 'data-indexNumber' ) );\n\n        var lastElem = rowElements[ rowElements.length - 1 ];\n        lastRenderedItemIndex = parseInt( lastElem.getAttribute( 'data-indexNumber' ) );\n\n        var firstRenderedItem = {\n            index: firstRenderedItemIndex,\n            uid: firstElem.vmo.uid,\n            levelNdx: firstElem.vmo.levelNdx\n        };\n\n        var lastRenderedItem = {\n            index: lastRenderedItemIndex,\n            uid: lastElem.vmo.uid,\n            levelNdx: lastElem.vmo.levelNdx\n        };\n\n        settings.afterGridRenderCallback( firstRenderedItem, lastRenderedItem );\n    }\n\n    self.destroyGrid = function() {\n        settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEvent );\n        settings.scrollViewportElem && settings.scrollViewportElem.removeEventListener( 'scroll', handleScrollEndEvent );\n        settings.pinViewportElem && settings.pinViewportElem.removeEventListener( 'scroll', handlePinScrollEvent );\n        momentumScrolling.disable();\n        self.checkForResize.cancel();\n        horizontalScrollDebounceEvent.cancel();\n        verticalScrollDebounceEvent.cancel();\n    };\n\n    /**\n     * Scrolls to the given row\n     *\n     * @param {integer[]} rowIndexes Index to scroll to\n     * @returns {boolean} returns false if a row is in view\n     */\n    self.scrollToRowIndex = function( rowIndexes ) {\n        // Only scroll to row if it is out of view\n        if( self.isInitialized() === true ) {\n            var scrollToRowElementPosition = null;\n            var firstRowElementIndex = 0;\n            var lastIndexNumber = 0;\n            if( rowElements.length > 0 ) {\n                firstRowElementIndex = Number( rowElements[ 0 ].getAttribute( 'data-indexnumber' ) );\n                lastIndexNumber = Number( rowElements[ rowElements.length - 1 ].getAttribute( 'data-indexnumber' ) );\n            }\n\n            var scrollCanvasRect = settings.scrollViewportElem.getBoundingClientRect();\n            for( var i = 0; i < rowIndexes.length; i++ ) {\n                var rowIndex = rowIndexes[ i ];\n\n                if( rowElements.length > 0 ) {\n                    if( rowIndex > lastIndexNumber || rowIndex < firstRowElementIndex ) {\n                        initialRowIndex = rowIndex;\n                        continue;\n                    }\n\n                    scrollToRowElementPosition = rowElements[ rowIndex - firstRowElementIndex ].getBoundingClientRect();\n                    if( scrollToRowElementPosition.top < scrollCanvasRect.top || scrollToRowElementPosition.bottom > scrollCanvasRect.bottom ) {\n                        initialRowIndex = rowIndex;\n                        continue;\n                    }\n\n                    initialRowIndex = rowIndex;\n                }\n                return false;\n            }\n\n            // Check if attempting to scroll past maximum scrollTop, if so set flag\n            var maxScrollTop = settings.scrollViewportElem.scrollHeight - settings.scrollViewportElem.clientHeight;\n            var newScrollTop = Math.floor( calculateElementTopPosition( initialRowIndex ) - _visibleAreaHeight * 0.75 );\n            var initialRowIndexOnDom = initialRowIndex - firstRowElementIndex;\n\n            if( rowElements[ initialRowIndexOnDom ] ) {\n                scrollToRowElementPosition = rowElements[ initialRowIndexOnDom ].getBoundingClientRect();\n                if( scrollToRowElementPosition.top < scrollCanvasRect.top && scrollToRowElementPosition.bottom > scrollCanvasRect.top ) {\n                    newScrollTop = calculateElementTopPosition( initialRowIndex );\n                } else if( scrollToRowElementPosition.top < scrollCanvasRect.bottom && scrollToRowElementPosition.bottom > scrollCanvasRect.bottom ) {\n                    newScrollTop = settings.scrollViewportElem.scrollTop + ( scrollToRowElementPosition.bottom - scrollCanvasRect.bottom );\n                }\n            }\n\n            if( newScrollTop > maxScrollTop ) {\n                scrollToRowInProgress = true;\n                scrollToRowScrollTop = newScrollTop;\n            }\n            settings.scrollViewportElem.scrollTop = newScrollTop;\n        } else {\n            initialRowIndex = rowIndexes[ 0 ];\n        }\n\n        return true;\n    };\n\n    /**\n     * Scrolls to scroll container column\n     * @param {Object} column - The column to scroll to\n     */\n    self.scrollToColumn = function( column ) {\n        if( column.startPosition <= currentScrollLeft || column.startPosition > currentScrollLeft + scrollContainerWidth ) {\n            settings.scrollViewportElem.scrollLeft = column.startPosition - 10;\n        }\n    };\n\n    self.isInitialRowIndexInView = function() {\n        let firstRowElementIndex = Number( rowElements[ 0 ].getAttribute( 'data-indexnumber' ) );\n        let initialRowElement = rowElements[ initialRowIndex - firstRowElementIndex ];\n        if( initialRowElement === undefined ) {\n            return false;\n        }\n\n        let initialRowElementIndex = initialRowElement.getAttribute( 'data-indexnumber' );\n        let firstVisibleIndex = calculateElementIndexFromScrollTop( currentScrollTop );\n        let lastVisibleIndex = calculateLastVisibleRowIndex();\n\n        if( initialRowElementIndex < firstVisibleIndex || initialRowIndex > lastVisibleIndex ) {\n            return false;\n        }\n\n        return true;\n    };\n\n    /**\n     * Resets the initial row index to 0 so that infinite scroll service will\n     * start the rendering of rows at the top.\n     */\n    self.resetInitialRowIndex = function() {\n        initialRowIndex = 0;\n    };\n};\n\nexport default SPLMTableInfiniteScroll;\n"]},"metadata":{},"sourceType":"module"}