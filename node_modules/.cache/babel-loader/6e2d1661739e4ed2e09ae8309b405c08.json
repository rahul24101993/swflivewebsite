{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* global afxDynamicImport afxWeakImport */ /**\n * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/declUtils\n */import assert from'js/assert';import _ from'lodash';import logger from'js/logger';import moduleLoader from'js/moduleLoader';/** revisitme Shaishav\n * Hint: We need to integrate with appCtxService\nimport appCtxSvc from 'js/appCtxService';\n*/import parsingUtils from'js/parsingUtils';import browserUtils from'js/browserUtils';import appCtxSvc from'js/appCtxService';// Service\nimport AwParseService from'js/awParseService';var exports={};var MSG_1='Required DeclViewModel not specified';var MSG_PREFIX_1='Invalid to process with destroyed DeclViewModel: ';var MSG_PREFIX_2='Invalid to process with destroyed DataContextNode: ';/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */var _actionPropsToLog=['actionId','actionType','method','serviceName','deps','steps'];/**\n * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's\n * URL.\n */var _debug_logLifeCycleIssues=browserUtils.getUrlAttributes().logLifeCycleIssues!==undefined;/**\n * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid\n * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema\n * checker).\n */export let attrHolderPropName=['dbValue','displayName','dispValue','isArray','isEditable','isRequired','isEnabled','displayValue','value','isModifiable','isAutoAssign','isAutoAssignable','labelPosition','requiredText','type','propName','hasLov','dataProvider','isSelectOnly','isRichText','referenceTypeName','maxLength','maxArraySize','renderingHint','autofocus','propertyDisplayName','patterns','preferredPattern','patternAutoAssignFlags','condition','validationCriteria','oldValue','oldValues','vertical','propertyRadioTrueText','propertyRadioFalseText','numberOfLines','iconName'];/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */export const loadDependentModule=depModule=>{return moduleLoader.loadDependentModule(depModule);};/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */export let buildLifeCycleIssueMessage=function(declViewModel,action,consequence,methodName){var errorMsg='Attempted processing after an associated DeclViewModel was destroyed...';if(consequence){errorMsg+='\\n';errorMsg+=consequence;}if(declViewModel){errorMsg+='\\n';errorMsg+='DeclViewModel: ';errorMsg+=declViewModel;}if(methodName){errorMsg+='\\n';errorMsg+='Method: ';errorMsg+=methodName;}if(action){errorMsg+='\\n';errorMsg+='Action:';errorMsg+='\\n';errorMsg+=JSON.stringify(action,_actionPropsToLog,2);}return errorMsg;};/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */export let logLifeCycleIssue=function(declViewModel,action,consequence,methodName){var errorMsg=exports.buildLifeCycleIssueMessage(declViewModel,action,consequence,methodName);if(_debug_logLifeCycleIssues){logger.warn(errorMsg);}return errorMsg;};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */export let assertValidModel=function(declViewModel){assert(declViewModel,MSG_1);if(!declViewModel._internal||declViewModel._internal.isDestroyed){assert(false,MSG_PREFIX_1+declViewModel);}};/**\n * Clone scope without copying angular scope's internal properties.\n *\n * @param {Object} scope - Object to clone.\n *\n * @return {Object} an object that holds data from provided Object\n */export let cloneData=function(scope){var object={};_.forOwn(scope,function(value,key){if(!_.startsWith(key,'$')){object[key]=value;}});return object;};/**\n * update data for fileData\n *\n * @param {Object} fileData - key string value the location of the file\n * @param {Object} data the view model data object\n */ /** revisitme Shaishav\n * Hint: We need a jquery free solution here\nexport let updateFormData = function( fileData, data ) {\n    if( fileData && fileData.value ) {\n        var form = $( '#fileUploadForm' );\n        data.formData = new FormData( $( form )[ 0 ] );\n        data.formData.append( fileData.key, fileData.value );\n    }\n};\n*/ /**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */export let assertValidModelWithOriginalJSON=function(declViewModel){assert(declViewModel,MSG_1);if(!declViewModel._internal||declViewModel._internal.isDestroyed){assert(false,MSG_PREFIX_1+declViewModel);}assert(declViewModel._internal.origDeclViewModelJson,'Required DeclViewModel JSON object not specified');};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n */export let assertValidModelAndDataCtxNode=function(declViewModel,dataCtxNode){assert(declViewModel,MSG_1);if(!declViewModel._internal||declViewModel._internal.isDestroyed){assert(false,MSG_PREFIX_1+declViewModel);}if(!declViewModel.isUnmounting&&(!dataCtxNode||dataCtxNode.$$destroyed)){assert(false,MSG_PREFIX_2+(dataCtxNode?dataCtxNode.$id:'???')+' DeclViewModel='+declViewModel);}};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */export let isValidModelAndDataCtxNode=function(declViewModel,dataCtxNode){if(!declViewModel){if(_debug_logLifeCycleIssues){logger.warn(MSG_1);}return false;}if(!declViewModel._internal||declViewModel._internal.isDestroyed){exports.logLifeCycleIssue(declViewModel,null,null,'isValidModelAndDataCtxNode');return false;}if(!declViewModel.isUnmounting&&dataCtxNode&&dataCtxNode.$$destroyed){if(_debug_logLifeCycleIssues){logger.warn(MSG_PREFIX_2+dataCtxNode.$id+' DeclViewModel='+declViewModel);}return false;}return true;};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n * @param {DeclAction} action - The declAction object to test.\n */export let assertValidModelDataCtxNodeAndAction=function(declViewModel,dataCtxNode,action){assert(declViewModel,MSG_1);if(declViewModel._internal.isDestroyed){assert(false,MSG_PREFIX_1+declViewModel+' actionType: '+action.actionType+' method: '+action.method+' deps: '+action.deps);}if(!declViewModel.isUnmounting&&(!dataCtxNode||dataCtxNode.$$destroyed)){assert(false,MSG_PREFIX_2+(dataCtxNode?dataCtxNode.$id:'???')+' DeclViewModel='+declViewModel+' actionType: '+action.actionType+' method: '+action.method+' deps: '+action.deps);}};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @param {DeclAction} action - The declAction object to test.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n */export let assertValidModelDataCtxNodeAndAction2=function(declViewModel,dataCtxNode,action,consequence,methodName){assert(declViewModel,MSG_1);if(declViewModel._internal.isDestroyed){assert(false,exports.buildLifeCycleIssueMessage(declViewModel,action,consequence,methodName));}if(!declViewModel.isUnmounting&&(!dataCtxNode||dataCtxNode.$$destroyed)){assert(false,MSG_PREFIX_2+(dataCtxNode?dataCtxNode.$id:'???')+exports.buildLifeCycleIssueMessage(declViewModel,action,consequence,methodName));}};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n */export let assertValidModelAndEventData=function(declViewModel,eventData){assert(declViewModel,MSG_1);if(!declViewModel._internal||declViewModel._internal.isDestroyed){assert(false,MSG_PREFIX_1+declViewModel);}if(eventData&&eventData.scope&&eventData.scope.$$destroyed){assert(false,MSG_PREFIX_2+(eventData.scope?eventData.scope.$id:'???')+' DeclViewModel='+declViewModel);}};/**\n * Evaluate message with its parameters\n *\n * @param {String} messageString - The message String.\n *\n * @param {String} messageParams - The message parameters.\n *\n * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to\n *            search within.\n *\n * @return {String} Result string after applying passed parameters.\n */export let applyMessageParams=function(messageString,messageParams,messageContext){var placeHolders=messageString.match(/\\{[0-9]*\\}/g);var resultString=messageString;if(placeHolders&&messageParams){for(var i in placeHolders){if(placeHolders.hasOwnProperty(i)){var placeHolder=placeHolders[i];var index=placeHolder;index=_.trimStart(index,'{');index=_.trimEnd(index,'}');var key=parsingUtils.getStringBetweenDoubleMustaches(messageParams[index]);var replacementString=_.get(messageContext,key);resultString=resultString.replace(placeHolder,replacementString);}}}return resultString;};/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */export let isValidModelAndEventData=function(declViewModel,eventData){if(!declViewModel){logger.warn(MSG_1);return false;}if(!declViewModel._internal||declViewModel._internal.isDestroyed){logger.warn(MSG_PREFIX_1+declViewModel);return false;}if(eventData&&eventData.scope&&eventData.scope.$$destroyed){logger.warn(MSG_PREFIX_2+(eventData.scope?eventData.scope.$id:'???')+' DeclViewModel='+declViewModel);return false;}return true;};/**\n * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was\n * started.\n * <P>\n * If so: Use the dataCtxNode the DeclViewModel was originally created on.\n * <P>\n * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the\n * event was processed.\n *\n * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check\n * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.\n *\n * @returns {Object} The dataCtxNode object to use.\n */export let resolveLocalDataCtx=function(declViewModel,dataCtxNode){if(dataCtxNode.$$destroyed){return declViewModel._internal.origCtxNode;}return dataCtxNode;};/**\n * Return true if provided value is 'nil' (i.e. not null or undefined).\n *\n * @param {Object} value - The value to test.\n *\n * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).\n */export let isNil=function(value){return value===undefined||value===null;};/**\n * Return a empty function\n *\n * @returns {null} null\n */export const noop=()=>null;/**\n * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given\n * 'dataCtxNode'.\n *\n * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the\n *            lookup of the 'declViewModel'.\n *\n * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as\n *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.\n *\n * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is\n *            TRUE.\n *\n * @return {DeclViewModel} The 'declViewModel' found.\n */export let findViewModel=function(dataCtxNode,setInScope){/**\n     * Check for the case where the declViewModel is already set on the given node.\n     */if(dataCtxNode.data){/** revisitme\n        if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {\n            dataCtxNode.ctx = appCtxSvc.ctx;\n        }\n        */return dataCtxNode.data;}/**\n     * Look for the model on a 'parent' node.\n     */var currCtxNode=dataCtxNode;while(currCtxNode&&!currCtxNode.data){currCtxNode=currCtxNode.$parent;}if(currCtxNode){if(setInScope){dataCtxNode.data=currCtxNode.data;/** revisitme\n            if( appCtxSvc ) {\n                dataCtxNode.ctx = appCtxSvc.ctx;\n            }\n            */ //if subPanelContext is available on scope then add it dataCtxNode\nif(currCtxNode.subPanelContext){dataCtxNode.subPanelContext=currCtxNode.subPanelContext;}/**\n             * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.\n             */if(dataCtxNode.$on){dataCtxNode.$on('$destroy',function(data){data.currentScope.data=null;data.currentScope.ctx=null;});}}return currCtxNode.data;}return null;};/**\n * Consolidate the second object's properties into the first one\n *\n * @param {Object} targetObj - The 'target' object to merge to\n * @param {Object} sourceObj - The 'source' object to be merge from\n *\n * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.\n */export let consolidateObjects=function(targetObj,sourceObj){var returnObj=null;if(targetObj){returnObj=targetObj;_.forEach(sourceObj,function(n,key){returnObj[key]=n;});}else if(sourceObj){returnObj=sourceObj;}return returnObj;};/**\n * Create custom event. Mainly for IE\n *\n * @param {String} eventName - Name of the event\n *\n * @param {Object} eventDetail - Object for event detail\n\n * @param {Object} canBubble -is bubble is up/down\n\n * @param {Object} isCancellable - event can ne canclable or not\n *\n * @return {DOMElement} created DOMElement\n */export let createCustomEvent=function(eventName,eventDetail,canBubble,isCancellable){if(browserUtils.isNonEdgeIE){var evt=document.createEvent('CustomEvent');evt.initCustomEvent(eventName,canBubble,isCancellable,eventDetail);return evt;}return new CustomEvent(eventName,{detail:eventDetail,bubbles:canBubble});};/**\n * process output data\n * @param {JSON} outputData output data definition\n * @param {object} result function result\n * @returns {object} data patch as:\n * {\n *     \"ctx.b\": 3,\n *     \"data.c\": 5\n * }\n */export const processOutputData=(outputData,result)=>{if(outputData){const value={};for(let vmPath in outputData){let valPath=outputData[vmPath];let res=undefined;if(_.isBoolean(valPath)){res=valPath;}else{var expression=parsingUtils.getStringBetweenDoubleMustaches(valPath);if(_.startsWith(expression,'json:')){var jsonStringVariable=expression.replace('json:','');var jsonString=_.get(result,jsonStringVariable);res=parsingUtils.parseJsonString(jsonString);}else{res=valPath&&valPath.length>0?_.get(result,valPath):result;}}// TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'\nvalue[/^ctx\\./.test(vmPath)?vmPath:\"data.\".concat(vmPath)]=res;}return value;}return undefined;};/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}\n * @param {Object} evaluationEnv - the data environment for expression evaluation\n * evaluation\n *\n * @return {Boolean} the evaluated condition result\n */export let evaluateCondition=function(declViewModel,expression,evaluationEnv){let parse=AwParseService.instance;return parse(expression)(evaluationEnv);};/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} condition name of condition\n *\n * @return {String} the evaluated condition result\n */export let getConditionExpression=function(declViewModel,condition){var conditionExpression=null;if(_.startsWith(condition,'conditions.')){var conditionObject=_.get(declViewModel._internal,condition);conditionExpression=conditionObject.expression;}else{conditionExpression=condition;}return conditionExpression;};/**\n * Evaluate condition name\n *\n * @param {String} conditionString name of condition\n *\n * @return {String} the evaluated condition result\n */export let getConditionName=function(conditionString){if(_.startsWith(conditionString,'conditions.')){var index=conditionString.indexOf('.');return conditionString.substr(index+1);}return null;};/**\n * Get dirty properties of the view model object\n *\n * @param {Object} vmo - the view model object\n *\n * @return {Array} the dirty properties of the view model object\n */export let getAllModifiedValues=function(vmo){var modifiedProperties=[];if(vmo){modifiedProperties=vmo.getDirtyProps();}return modifiedProperties;};/**\n * Update the properties of the view model property with new values\n *\n * @param {Object} dataObject - view model object.\n * @param {Object} dataProperty - view model object property.\n * @param {Object} dataPropertyValue - view model object property value.\n */export let updatePropertyValues=function(dataObject,dataProperty,dataPropertyValue){dataObject[dataProperty]=dataPropertyValue;return{data:{...dataObject}};};/**\n * get type hierarchy from modleObject or view model Object\n *\n * @param {Object} dataObject - view model object.\n *\n *  @return {Array} - hierarchy of model object names\n\n */export let getTypeHierarchy=function(dataObject){return dataObject.typeHierarchy||dataObject.modelType&&dataObject.modelType.typeHierarchyArray;};/**\n *  get functions used in action input/output data\n */let getActionDataFunc=function(value,functionsUsedInActions){if(typeof value==='string'){var results=value.match(parsingUtils.REGEX_DATABINDING);if(results&&results.length===4){var newVal=results[2];if(_.startsWith(newVal,'function:')){functionsUsedInActions.push(newVal.replace('function:',''));}}}return functionsUsedInActions;};/**\n * Get Function dependancies\n *\n * @param {Object} action - The action object\n *\n * @param {Object} viewModel - The view model\n *\n * @return {Array} - The Array contains function dependancies to load.\n */export let getFunctionDeps=function(action,viewModel){var depsToLoad=[];var functionsUsedInActions=[];const functions=viewModel.functions;// get functions used in action input data\nif(action&&action.inputData){_.forEach(action.inputData.request,function(value){getActionDataFunc(value,functionsUsedInActions);});}if(action&&action.outputData){_.forEach(action.outputData,function(value){getActionDataFunc(value,functionsUsedInActions);});}if(action&&action.dataParsers&&action.dataParsers.length){_.forEach(action.dataParsers,dataParser=>{const dataParserDef=viewModel.dataParseDefinitions[dataParser.id];const fnUsedInDataParsers=getFunctionUsageRecursive(dataParserDef);_.forEach(fnUsedInDataParsers,fnUsed=>getActionDataFunc(fnUsed,functionsUsedInActions));});}if(functions){_.forEach(functions,function(func){if(func.deps&&depsToLoad.includes(func.deps)===false&&functionsUsedInActions.includes(func.functionName)){depsToLoad.push(func.deps);}});}return depsToLoad;};const getFunctionUsageRecursive=object=>{let values=[];_.each(object,value=>{if(_.isString(value)&&value.startsWith('{{function:')){values.push(value);}else if(_.isObject(value)){values=values.concat(getFunctionUsageRecursive(value));}});return values;};/**\n * Build common proprty Place holder\n *\n *\n * @param {Object} prop - raw property\n *\n * @return {object}  - propAttrHolder will blank if not valid VMP else filled\n */export let buildPropHolder=prop=>{let propAttrHolder={};_.forEach(prop,function(dataPropValue,dataPropName){if(exports.attrHolderPropName.indexOf(dataPropName)>-1){propAttrHolder[dataPropName]=dataPropValue;}});return propAttrHolder;};export let getLatestContext=function(dataCtxNode,declViewModel){let subPanelContext=null;let ports=null;let conditions=null;if(dataCtxNode&&dataCtxNode.getProps&&_.isFunction(dataCtxNode.getProps)){let props=dataCtxNode.getProps();dataCtxNode.props=props;subPanelContext=props.subPanelContext;}if(dataCtxNode&&dataCtxNode.getFields&&_.isFunction(dataCtxNode.getFields)){dataCtxNode.fields=dataCtxNode.getFields();}if(declViewModel&&declViewModel.getData&&_.isFunction(declViewModel.getData)){let val=declViewModel.getData();if(val.hasOwnProperty('data')){declViewModel.data=val.data;}else{declViewModel.data=val;}}if(dataCtxNode&&!dataCtxNode.conditions&&declViewModel){conditions=declViewModel.conditions;dataCtxNode.conditions=conditions;}if(!dataCtxNode){dataCtxNode={};}else{ports=dataCtxNode.ports;}return{...dataCtxNode,data:declViewModel,ctx:{...dataCtxNode.ctx,...appCtxSvc.ctx},parameters:dataCtxNode.parameters,subPanelContext:subPanelContext?subPanelContext:declViewModel.subPanelContext,commandContext:dataCtxNode.commandContext,pasteContext:dataCtxNode.pasteContext,ports:ports?ports:declViewModel._internal.ports};};exports={buildLifeCycleIssueMessage,logLifeCycleIssue,assertValidModel,cloneData,/** revisitme\n    updateFormData,\n    */assertValidModelWithOriginalJSON,assertValidModelAndDataCtxNode,isValidModelAndDataCtxNode,assertValidModelDataCtxNodeAndAction,assertValidModelDataCtxNodeAndAction2,assertValidModelAndEventData,isValidModelAndEventData,applyMessageParams,resolveLocalDataCtx,isNil,findViewModel,consolidateObjects,createCustomEvent,evaluateCondition,getConditionExpression,getConditionName,getAllModifiedValues,updatePropertyValues,getFunctionDeps,getTypeHierarchy,processOutputData,noop,loadDependentModule,attrHolderPropName,buildPropHolder,getLatestContext};export default exports;","map":null,"metadata":{},"sourceType":"module"}