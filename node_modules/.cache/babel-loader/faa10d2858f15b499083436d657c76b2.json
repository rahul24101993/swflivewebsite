{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls in batch\n *\n * @module js/batchActionService\n *\n * @namespace batchActionService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport conditionSvc from 'js/conditionService';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\n/**\n * Define public API\n */\n\nvar exports = {};\n/**\n * Execute the given 'all actions in Steps' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} batchActions - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n */\n\nexport let executeBatchActions = function (declViewModel, batchActions, dataCtxNode, actionService) {\n  var tasks = [];\n\n  if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    return undefined;\n  }\n\n  if (batchActions.steps) {\n    for (var step = 0; step < batchActions.steps.length; step++) {\n      tasks.push(exports._executeActionWrapper(batchActions.steps[step], declViewModel, dataCtxNode, actionService));\n    }\n  }\n\n  return tasks.reduce(function (promiseChain, task) {\n    return promiseChain.then(function (respData) {\n      return task(respData);\n    });\n  }, AwPromiseService.instance.resolve());\n};\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} step - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {Object} index - The current index of action in Steps\n * @param {Object[]} steps - The steps under 'batch' action type\n * @param {Object} actionService - The referance to action service\n * @param {Object} actionResp - the action Response\n *\n */\n\nconst parseConditonExp = (expression, evaluationEnv) => {\n  //This is not acomplete fix, needs to be revisited - LCS-565498\n  const exp = conditionSvc.getRealExpression(expression, evaluationEnv);\n\n  if (_.isString(exp)) {\n    return exp;\n  } //If the condition is object based, return the original expression\n\n\n  return expression;\n};\n\nexport let _executeActionWrapper = function (stepDef, declViewModel, dataCtxNode, actionService) {\n  return function (actionResp) {\n    var action = null;\n    var outputFlag = false;\n    var inputArgs = null;\n\n    if (declViewModel._internal.actions) {\n      action = declViewModel._internal.actions[stepDef.action];\n    }\n\n    var conditionResult = false;\n\n    if (stepDef.outputArg && action) {\n      outputFlag = true;\n      action.outputArg = _.cloneDeep(stepDef.outputArg);\n    }\n\n    let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n    localContext.response = actionResp;\n    localContext = { ...localContext,\n      ...declViewModel.atomicData\n    };\n\n    if (stepDef.condition) {\n      var conditionExpression = parseConditonExp(stepDef.condition, declViewModel._internal);\n\n      if (conditionExpression !== null) {\n        conditionResult = conditionSvc.evaluateCondition(localContext, conditionExpression);\n      } // if conditionResult is undefined or null we should consider result as false.\n\n\n      if (!conditionResult) {\n        conditionResult = false;\n      }\n    }\n\n    var isEventExecutable = stepDef.condition && conditionResult || !stepDef.condition;\n\n    if (isEventExecutable) {\n      if (stepDef.inputArg) {\n        inputArgs = _.cloneDeep(stepDef.inputArg);\n\n        try {\n          declarativeDataCtxService.applyScope(localContext.data, inputArgs, null, actionResp, null);\n        } catch (error) {\n          throw new Error(error);\n        }\n\n        if (localContext && localContext.scope) {\n          localContext.scope.parameters = inputArgs ? inputArgs : null;\n        } else {\n          localContext = { ...localContext,\n            parameters: inputArgs ? inputArgs : null\n          };\n        }\n      }\n\n      if (action.deps) {\n        /** action ID will be used for better logging */\n        action.actionId = stepDef.action;\n\n        var doAction = function (depModuleObj) {\n          if (declViewModel.isDestroyed()) {\n            logger.warn('Attempt to execute a command after its DeclViewModel was destroyed...' + '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n            'DeclViewModel: ' + declViewModel + '\\n' + //\n            'Action       : ' + stepDef.action);\n          } else {\n            /**\n             * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n             * event processing was started.\n             */\n            var localDataCtx = declUtils.resolveLocalDataCtx(localContext.data, localContext); // _deps will be undefined when try to load viewModelService inside itself\n\n            var _depModuleObj = depModuleObj;\n            return actionService.executeAction(localContext.data, action, localDataCtx, _depModuleObj, outputFlag);\n          }\n\n          return undefined;\n        };\n\n        return moduleLoader.loadDependentModule(action.deps).then(doAction);\n      }\n\n      return actionService.executeAction(localContext.data, action, localContext, null, outputFlag);\n    }\n\n    return AwPromiseService.instance.resolve(actionResp);\n  };\n};\nexports = {\n  executeBatchActions,\n  _executeActionWrapper\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/batchActionService.js"],"names":["exports","executeBatchActions","tasks","declUtils","batchActions","step","task","AwPromiseService","parseConditonExp","exp","conditionSvc","_","_executeActionWrapper","action","outputFlag","inputArgs","declViewModel","stepDef","conditionResult","localContext","atomicData","conditionExpression","isEventExecutable","declarativeDataCtxService","parameters","doAction","logger","localDataCtx","_depModuleObj","actionService","moduleLoader"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls in batch\n *\n * @module js/batchActionService\n *\n * @namespace batchActionService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport conditionSvc from 'js/conditionService';\nimport declarativeDataCtxService from 'js/declarativeDataCtxService';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\n\n/**\n * Define public API\n */\nvar exports = {};\n\n/**\n * Execute the given 'all actions in Steps' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} batchActions - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n */\n\nexport let executeBatchActions = function( declViewModel, batchActions, dataCtxNode, actionService ) {\n    var tasks = [];\n    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        return undefined;\n    }\n    if( batchActions.steps ) {\n        for( var step = 0; step < batchActions.steps.length; step++ ) {\n            tasks.push( exports._executeActionWrapper( batchActions.steps[ step ], declViewModel, dataCtxNode, actionService ) );\n        }\n    }\n    return tasks.reduce( function( promiseChain, task ) {\n        return promiseChain.then( function( respData ) {\n            return task( respData );\n        } );\n    }, AwPromiseService.instance.resolve() );\n};\n\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} step - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {Object} index - The current index of action in Steps\n * @param {Object[]} steps - The steps under 'batch' action type\n * @param {Object} actionService - The referance to action service\n * @param {Object} actionResp - the action Response\n *\n */\nconst parseConditonExp = ( expression, evaluationEnv ) => {\n    //This is not acomplete fix, needs to be revisited - LCS-565498\n    const exp = conditionSvc.getRealExpression( expression, evaluationEnv );\n    if( _.isString( exp ) ) {\n        return exp;\n    }\n    //If the condition is object based, return the original expression\n    return expression;\n};\nexport let _executeActionWrapper = function( stepDef, declViewModel, dataCtxNode, actionService ) {\n    return function( actionResp ) {\n        var action = null;\n        var outputFlag = false;\n        var inputArgs = null;\n\n        if( declViewModel._internal.actions ) {\n            action = declViewModel._internal.actions[ stepDef.action ];\n        }\n\n        var conditionResult = false;\n\n        if( stepDef.outputArg && action ) {\n            outputFlag = true;\n            action.outputArg = _.cloneDeep( stepDef.outputArg );\n        }\n\n        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n        localContext.response = actionResp;\n        localContext = { ...localContext, ...declViewModel.atomicData };\n\n        if( stepDef.condition ) {\n            var conditionExpression = parseConditonExp( stepDef.condition, declViewModel._internal );\n            if( conditionExpression !== null ) {\n                conditionResult = conditionSvc.evaluateCondition( localContext, conditionExpression );\n            }\n            // if conditionResult is undefined or null we should consider result as false.\n            if( !conditionResult ) {\n                conditionResult = false;\n            }\n        }\n        var isEventExecutable = stepDef.condition && conditionResult || !stepDef.condition;\n        if( isEventExecutable ) {\n            if( stepDef.inputArg ) {\n                inputArgs = _.cloneDeep( stepDef.inputArg );\n                try {\n                    declarativeDataCtxService.applyScope( localContext.data, inputArgs, null, actionResp, null );\n                } catch ( error ) {\n                    throw new Error( error );\n                }\n                if( localContext && localContext.scope ) {\n                    localContext.scope.parameters = inputArgs ? inputArgs : null;\n                } else {\n                    localContext = { ...localContext, parameters: inputArgs ? inputArgs : null };\n                }\n            }\n            if( action.deps ) {\n                /** action ID will be used for better logging */\n                action.actionId = stepDef.action;\n\n                var doAction = function( depModuleObj ) {\n                    if( declViewModel.isDestroyed() ) {\n                        logger.warn( 'Attempt to execute a command after its DeclViewModel was destroyed...' +\n                            '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n                            'DeclViewModel: ' + declViewModel + '\\n' + //\n                            'Action       : ' + stepDef.action );\n                    } else {\n                        /**\n                         * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n                         * event processing was started.\n                         */\n                        var localDataCtx = declUtils.resolveLocalDataCtx( localContext.data, localContext );\n\n                        // _deps will be undefined when try to load viewModelService inside itself\n                        var _depModuleObj = depModuleObj;\n                        return actionService.executeAction( localContext.data, action, localDataCtx, _depModuleObj, outputFlag );\n                    }\n                    return undefined;\n                };\n                return moduleLoader.loadDependentModule( action.deps ).then( doAction );\n            }\n            return actionService.executeAction( localContext.data, action, localContext, null, outputFlag );\n        }\n        return AwPromiseService.instance.resolve( actionResp );\n    };\n};\n\nexports = {\n    executeBatchActions,\n    _executeActionWrapper\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}