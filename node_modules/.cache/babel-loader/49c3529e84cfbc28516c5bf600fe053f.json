{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).\n *\n * @module js/awTableStateService\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport localStrg from 'js/localStorage';\nimport uwUtilSvc from './uwUtilService';\n/**\n * {String} Expansion state of a node when expanded\n */\n\nvar _EXPAND_FULL = 'full';\n/**\n * {String} The primary topic (i.e. key) used to store state information.\n */\n\nvar _LS_TOPIC = 'awTreeTableState';\n/**\n * {String} The current local storage schema version accepted.\n */\n\nvar _LS_TOPIC_VERSION = '1.0.1';\n/**\n * {String} A common location that is included in the declViewModel's path that needs to be removed before reporting\n * the ID of the declViewModel's ID.\n */\n\nvar _VM_DIR_NAME = '/viewmodel/';\n/**\n * {Boolean} TRUE if various activities of this services should be logged.\n */\n\nvar _debug_logTableStateActivity = false;\n/**\n * {Boolean} TRUE if all levels should be expanded (as they become visible).\n */\n\nvar _expandAll = false;\n/**\n * {Object} The keys of this object are the unique 'roots' requesting saves.\n */\n\nvar _pendingSaveStateRequests = {};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node to find the path to all the 'parent' nodes up the levels\n *            currently in the viewModelCollection of the associated dataProvider.\n *\n * @return {StringArray} An array of node IDs that identify the given node (as element [0]) in its hierarchy up to\n *         the 'top' node (as element [length-1]).\n */\n\nvar _buildNodePath = function (declViewModel, gridId, targetNode) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n  /**\n   * Find target\n   */\n\n\n  var vmRows = uwDataProvider.getViewModelCollection().getLoadedViewModelObjects();\n  var targetNdx = -1;\n\n  for (var ndx = 0; ndx < vmRows.length; ndx++) {\n    if (uwUtilSvc.getEvaluatedId(vmRows[ndx]) === uwUtilSvc.getEvaluatedId(targetNode)) {\n      targetNdx = ndx;\n      break;\n    }\n  }\n\n  if (targetNdx < 0) {\n    return [];\n  }\n  /**\n   * Build path by looking 'up' the rows\n   */\n\n\n  var pathIDs = [uwUtilSvc.getEvaluatedId(targetNode)];\n  var currRowNdx = targetNdx;\n  var currNextLevel = targetNode.levelNdx - 1;\n\n  while (currNextLevel > -1) {\n    for (var ndx2 = currRowNdx - 1; ndx2 >= 0; ndx2--) {\n      //\n      var currRow = vmRows[ndx2];\n\n      if (currRow.levelNdx === currNextLevel) {\n        pathIDs.push(uwUtilSvc.getEvaluatedId(currRow));\n        currNextLevel = currRow.levelNdx - 1;\n      }\n    }\n  }\n\n  return pathIDs;\n};\n/**\n * Return the structure object of the given 'target' node (and set with the 'target' 'childNdx') and create any\n * missing 'parent' structure nodes (if necessary).\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to return the object for.\n *\n * @return {Object} The structure object of the given 'target' node (and set with the 'target' 'childNdx').\n */\n\n\nvar _assureStructureNode = function (declViewModel, gridId, ttState, targetNode) {\n  var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n\n  if (!ttState.structure) {\n    ttState.structure = {};\n  }\n  /**\n   * Start at the top and work down based on the 'target' path.\n   */\n\n\n  var currStructureNode = ttState.structure;\n\n  for (var ndx = pathIDs.length - 1; ndx >= 0; ndx--) {\n    var pathID = pathIDs[ndx];\n\n    if (!currStructureNode[pathID]) {\n      currStructureNode[pathID] = {};\n    }\n\n    currStructureNode = currStructureNode[pathID];\n  }\n\n  currStructureNode.childNdx = targetNode.childNdx;\n  return currStructureNode;\n};\n/**\n * Delete the structure object of the given 'target' node.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to delete the state for.\n */\n\n\nvar _removeStructureNode = function (declViewModel, gridId, ttState, targetNode) {\n  if (ttState.structure) {\n    var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n    /**\n     * Start at the top and work down based on the 'target' path.\n     */\n\n\n    var currParentNode = ttState.structure;\n    var parentNodes = {};\n\n    for (var ndx = pathIDs.length - 1; ndx > 0; ndx--) {\n      var pathID = pathIDs[ndx];\n      currParentNode = currParentNode[pathID];\n\n      if (!currParentNode) {\n        break;\n      }\n\n      parentNodes[pathID] = currParentNode;\n    }\n    /**\n     * Starting at the lowest level, delete any structure objects that are not empty.\n     */\n\n\n    if (currParentNode) {\n      currParentNode = ttState.structure;\n      var keys = Object.keys(parentNodes);\n\n      for (var ndx2 = keys.length - 1; ndx2 > 1; ndx2--) {\n        var key = keys[ndx2];\n        currParentNode = parentNodes[key];\n\n        if (Object.keys(currParentNode).length < 2) {\n          var immParent = parentNodes[keys[ndx2 - 1]];\n          delete immParent[key];\n        }\n      }\n    }\n  }\n};\n/**\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {String} nodeId - ID of the node to return the object for,\n *\n * @return {Object} The state object associated with the given node (or NULL if no state exists for it.\n */\n\n\nvar _getNodeState = function (ttState, nodeId) {\n  if (!ttState.nodeStates) {\n    ttState.nodeStates = {};\n    return null;\n  }\n\n  return ttState.nodeStates[nodeId];\n};\n/**\n * @return {Object} The top-level object (loaded from local storage) containing the state information for all tables\n *         currently being tracked.\n */\n\n\nvar _getAllStates = function () {\n  var allStates;\n  var allStatesStr = localStrg.get(_LS_TOPIC);\n\n  if (allStatesStr) {\n    try {\n      allStates = JSON.parse(allStatesStr);\n\n      if (allStates.schemaVersion !== _LS_TOPIC_VERSION) {\n        allStates = null;\n      }\n    } catch (ex) {// Handled below\n    }\n  }\n\n  if (!allStates) {\n    allStates = {\n      schemaVersion: _LS_TOPIC_VERSION\n    };\n  }\n\n  return allStates;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {UwDataProvider} The current dataProvider associated with the given table.\n */\n\n\nvar _getDataProvider = function (declViewModel, gridId) {\n  var declGrid = declViewModel._internal.grids[gridId];\n  assert(declGrid, 'Table definition not found');\n  var uwDataProvider = declViewModel.dataProviders[declGrid.dataProvider];\n  assert(uwDataProvider, 'Table dataProvider is not valid');\n  return uwDataProvider;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {String} The unique ID of the view model object that 'owns' the table's data (i.e. The ID of an assembly)\n *         (or 'nonTreeRoot' if there is no 'topNode' set on the associated dataProvider).\n */\n\n\nvar _getRootId = function (declViewModel, gridId) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n\n  return uwDataProvider.topTreeNode ? uwUtilSvc.getEvaluatedId(uwDataProvider.topTreeNode) : 'nonTreeRoot';\n};\n/**\n * @param {Object} allStates - The top-level object (loaded from local storage) containing the state information for\n *            all tables currently being tracked.\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the state for the given declModel/declGrid.\n */\n\n\nvar _getTreeTableGridState = function (allStates, declViewModel, gridId) {\n  assert(declViewModel, 'Invalid DeclViewModel');\n  assert(declViewModel._internal.panelId, 'Invalid DeclViewModel');\n  assert(gridId, 'Invalid table ID');\n  var declViewModelId = declViewModel._internal.panelId;\n  var vmDirNdx = declViewModelId.indexOf(_VM_DIR_NAME);\n\n  if (vmDirNdx !== -1) {\n    declViewModelId = declViewModelId.substring(vmDirNdx + _VM_DIR_NAME.length);\n  }\n\n  if (!allStates[declViewModelId]) {\n    allStates[declViewModelId] = {};\n  }\n\n  if (!allStates[declViewModelId][gridId]) {\n    allStates[declViewModelId][gridId] = {};\n  }\n\n  return allStates[declViewModelId][gridId];\n};\n/**\n * This save state function is 'debounced' to only save data after updated 'quiets down' for ~2 second.\n *\n * @private\n */\n\n\nvar _pingSaveStateDebounce = _.debounce(function () {\n  /**\n   * Check if we have pending requests<BR>\n   * If so: Process the pending requests.\n   */\n  if (!_.isEmpty(_pendingSaveStateRequests)) {\n    var saveStateRequests = _pendingSaveStateRequests;\n    _pendingSaveStateRequests = {};\n\n    var allStates = _getAllStates();\n\n    _.forEach(saveStateRequests, function (req) {\n      /**\n       * Since a ping can time out *after* a declViewModel has been destroyed, check if the pending request\n       * has a valid declViewModel.\n       */\n      if (!req.declViewModel.isDestroyed()) {\n        var gridState = _getTreeTableGridState(allStates, req.declViewModel, req.gridId);\n\n        var rootId = _getRootId(req.declViewModel, req.gridId);\n\n        gridState[rootId] = req.ttState;\n      }\n    });\n\n    if (_debug_logTableStateActivity) {\n      logger.info('Saving table states');\n    }\n\n    localStrg.publish(_LS_TOPIC, JSON.stringify(allStates));\n  }\n}, 500, {\n  maxWait: 10000,\n  trailing: true,\n  leading: false\n});\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n */\n\n\nvar _saveTreeTableState = function (declViewModel, gridId, ttState) {\n  var rootId = _getRootId(declViewModel, gridId);\n\n  _pendingSaveStateRequests[rootId] = {\n    declViewModel: declViewModel,\n    gridId: gridId,\n    ttState: ttState\n  };\n\n  _pingSaveStateDebounce();\n};\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service Objects<BR>\n * -------------------------------------------------------------------------<BR>\n */\n\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service API<BR>\n * -------------------------------------------------------------------------<BR>\n */\n\n\nvar exports = {};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n */\n\nexport let clearAllStates = function (declViewModel, gridId) {\n  /**\n   * Check if any of the new 'child' nodes are known to be expanded.<BR>\n   * If so: Setup to async expand them later.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n  ttState.nodeStates = {};\n  ttState.structure = {}; // clear from local storage\n\n  _saveTreeTableState(declViewModel, gridId, ttState);\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNodeArray} nodesToTest - The nodes to test expansion status for.\n *\n * @return {Map} An object that maps a tree node ID to a data object with the following properties for each of the\n *         given nodes that are currently expanded:\n *\n * <pre>\n * {\n *     expanded: true,\n *     nodeToExpand: [node from nodesToTest]\n * }\n * </pre>\n */\n\nexport let findExpandedNodes = function (declViewModel, gridId, nodesToTest) {\n  /**\n   * Check if any of the new 'child' nodes are known to be expanded.<BR>\n   * If so: Setup to async expand them later.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n  var expandNodeRequests = {};\n\n  if (!_.isEmpty(ttState.nodeStates)) {\n    _.forEach(nodesToTest, function (testNode) {\n      if (_expandAll) {\n        expandNodeRequests[uwUtilSvc.getEvaluatedId(testNode)] = {\n          expanded: true,\n          nodeToExpand: testNode\n        };\n      } else {\n        var nodeState = ttState.nodeStates[uwUtilSvc.getEvaluatedId(testNode)];\n\n        if (nodeState && nodeState.expansion === _EXPAND_FULL) {\n          expandNodeRequests[uwUtilSvc.getEvaluatedId(testNode)] = {\n            expanded: true,\n            nodeToExpand: testNode\n          };\n        }\n      }\n    });\n  }\n\n  return expandNodeRequests;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the table state for the given declModel/declGrid.\n */\n\nexport let getTreeTableState = function (declViewModel, gridId) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n\n  if (!uwDataProvider.ttState) {\n    var allStates = _getAllStates();\n\n    var gridState = _getTreeTableGridState(allStates, declViewModel, gridId);\n\n    var rootId = _getRootId(declViewModel, gridId);\n\n    if (_debug_logTableStateActivity) {\n      logger.info('Reading table states for: ' + rootId);\n    }\n\n    if (!gridState[rootId]) {\n      gridState[rootId] = {\n        structure: {},\n        nodeStates: {}\n      };\n    }\n\n    uwDataProvider.ttState = gridState[rootId]; // <pre>\n    // Possible fix for scroll to problem...investigate later w/ related changes in 'aw.table.controller'.\n    // if( uwDataProvider.ttState ) {\n    //     uwDataProvider.isFocusedLoad = true;\n    // }\n    // </pre>\n  }\n\n  return uwDataProvider.ttState;\n};\n/**\n * @param {Object} ttState - (Optional) An object holding the table state for a given declModel/declGrid.\n * @param {ViewModelTreeNodeArray} nodeToTest - The nodes to test status for.\n *\n * @return {Boolean} TRUE if the given node is currently expanded.\n */\n\nexport let isNodeExpanded = function (ttState, nodeToTest) {\n  if (ttState.nodeStates) {\n    var nodeState = ttState.nodeStates[uwUtilSvc.getEvaluatedId(nodeToTest)];\n    return nodeState && nodeState.expansion === _EXPAND_FULL;\n  }\n\n  return false;\n};\n/**\n * Clear the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just collapsed.\n */\n\nexport let saveRowCollapsed = function (declViewModel, gridId, targetNode) {\n  /**\n   * Forget we are expanding this node.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  _assureStructureNode(declViewModel, gridId, ttState, targetNode);\n\n  var nodeState = _getNodeState(ttState, uwUtilSvc.getEvaluatedId(targetNode));\n\n  if (nodeState && nodeState.expansion) {\n    delete nodeState.expansion;\n\n    if (_.isEmpty(nodeState)) {\n      delete ttState.nodeStates[uwUtilSvc.getEvaluatedId(targetNode)];\n\n      _removeStructureNode(declViewModel, gridId, ttState, targetNode);\n    }\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n/**\n * Update the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just expanded.\n */\n\nexport let saveRowExpanded = function (declViewModel, gridId, targetNode) {\n  /**\n   * Remember we are expanding this node.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  _assureStructureNode(declViewModel, gridId, ttState, targetNode);\n\n  var nodeState = _getNodeState(ttState, uwUtilSvc.getEvaluatedId(targetNode));\n\n  if (!nodeState) {\n    ttState.nodeStates[uwUtilSvc.getEvaluatedId(targetNode)] = {\n      expansion: _EXPAND_FULL\n    };\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  } else if (nodeState.expansion !== _EXPAND_FULL) {\n    nodeState.expansion = _EXPAND_FULL;\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n/**\n * Update the persisted current top row in the table. .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node of the currently visible top row of the table.\n */\n\nexport let saveScrollTopRow = function (declViewModel, gridId, targetNode) {\n  var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  if (!ttState.topRowPath || _.difference(ttState.topRowPath, pathIDs).length !== 0) {\n    ttState.topRowPath = pathIDs;\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n_debug_logTableStateActivity = browserUtils.getUrlAttributes().logTableStateActivity === '';\nexports = {\n  clearAllStates,\n  findExpandedNodes,\n  getTreeTableState,\n  isNodeExpanded,\n  saveRowCollapsed,\n  saveRowExpanded,\n  saveScrollTopRow\n};\nexport default exports;","map":{"version":3,"names":["assert","_","browserUtils","logger","localStrg","uwUtilSvc","_EXPAND_FULL","_LS_TOPIC","_LS_TOPIC_VERSION","_VM_DIR_NAME","_debug_logTableStateActivity","_expandAll","_pendingSaveStateRequests","_buildNodePath","declViewModel","gridId","targetNode","uwDataProvider","_getDataProvider","vmRows","getViewModelCollection","getLoadedViewModelObjects","targetNdx","ndx","length","getEvaluatedId","pathIDs","currRowNdx","currNextLevel","levelNdx","ndx2","currRow","push","_assureStructureNode","ttState","structure","currStructureNode","pathID","childNdx","_removeStructureNode","currParentNode","parentNodes","keys","Object","key","immParent","_getNodeState","nodeId","nodeStates","_getAllStates","allStates","allStatesStr","get","JSON","parse","schemaVersion","ex","declGrid","_internal","grids","dataProviders","dataProvider","_getRootId","topTreeNode","_getTreeTableGridState","panelId","declViewModelId","vmDirNdx","indexOf","substring","_pingSaveStateDebounce","debounce","isEmpty","saveStateRequests","forEach","req","isDestroyed","gridState","rootId","info","publish","stringify","maxWait","trailing","leading","_saveTreeTableState","exports","clearAllStates","getTreeTableState","findExpandedNodes","nodesToTest","expandNodeRequests","testNode","expanded","nodeToExpand","nodeState","expansion","isNodeExpanded","nodeToTest","saveRowCollapsed","saveRowExpanded","saveScrollTopRow","topRowPath","difference","getUrlAttributes","logTableStateActivity"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/propertyrender/src/js/awTableStateService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).\n *\n * @module js/awTableStateService\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport localStrg from 'js/localStorage';\nimport uwUtilSvc from './uwUtilService';\n\n/**\n * {String} Expansion state of a node when expanded\n */\nvar _EXPAND_FULL = 'full';\n\n/**\n * {String} The primary topic (i.e. key) used to store state information.\n */\nvar _LS_TOPIC = 'awTreeTableState';\n\n/**\n * {String} The current local storage schema version accepted.\n */\nvar _LS_TOPIC_VERSION = '1.0.1';\n\n/**\n * {String} A common location that is included in the declViewModel's path that needs to be removed before reporting\n * the ID of the declViewModel's ID.\n */\nvar _VM_DIR_NAME = '/viewmodel/';\n\n/**\n * {Boolean} TRUE if various activities of this services should be logged.\n */\nvar _debug_logTableStateActivity = false;\n\n/**\n * {Boolean} TRUE if all levels should be expanded (as they become visible).\n */\nvar _expandAll = false;\n\n/**\n * {Object} The keys of this object are the unique 'roots' requesting saves.\n */\nvar _pendingSaveStateRequests = {};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node to find the path to all the 'parent' nodes up the levels\n *            currently in the viewModelCollection of the associated dataProvider.\n *\n * @return {StringArray} An array of node IDs that identify the given node (as element [0]) in its hierarchy up to\n *         the 'top' node (as element [length-1]).\n */\nvar _buildNodePath = function( declViewModel, gridId, targetNode ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    /**\n     * Find target\n     */\n    var vmRows = uwDataProvider.getViewModelCollection().getLoadedViewModelObjects();\n\n    var targetNdx = -1;\n\n    for( var ndx = 0; ndx < vmRows.length; ndx++ ) {\n        if( uwUtilSvc.getEvaluatedId( vmRows[ ndx ] ) === uwUtilSvc.getEvaluatedId( targetNode ) ) {\n            targetNdx = ndx;\n            break;\n        }\n    }\n\n    if( targetNdx < 0 ) {\n        return [];\n    }\n\n    /**\n     * Build path by looking 'up' the rows\n     */\n    var pathIDs = [ uwUtilSvc.getEvaluatedId( targetNode ) ];\n\n    var currRowNdx = targetNdx;\n    var currNextLevel = targetNode.levelNdx - 1;\n\n    while( currNextLevel > -1 ) {\n        for( var ndx2 = currRowNdx - 1; ndx2 >= 0; ndx2-- ) {\n            //\n            var currRow = vmRows[ ndx2 ];\n\n            if( currRow.levelNdx === currNextLevel ) {\n                pathIDs.push( uwUtilSvc.getEvaluatedId( currRow ) );\n                currNextLevel = currRow.levelNdx - 1;\n            }\n        }\n    }\n\n    return pathIDs;\n};\n\n/**\n * Return the structure object of the given 'target' node (and set with the 'target' 'childNdx') and create any\n * missing 'parent' structure nodes (if necessary).\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to return the object for.\n *\n * @return {Object} The structure object of the given 'target' node (and set with the 'target' 'childNdx').\n */\nvar _assureStructureNode = function( declViewModel, gridId, ttState, targetNode ) {\n    var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n    if( !ttState.structure ) {\n        ttState.structure = {};\n    }\n\n    /**\n     * Start at the top and work down based on the 'target' path.\n     */\n    var currStructureNode = ttState.structure;\n\n    for( var ndx = pathIDs.length - 1; ndx >= 0; ndx-- ) {\n        var pathID = pathIDs[ ndx ];\n\n        if( !currStructureNode[ pathID ] ) {\n            currStructureNode[ pathID ] = {};\n        }\n\n        currStructureNode = currStructureNode[ pathID ];\n    }\n\n    currStructureNode.childNdx = targetNode.childNdx;\n\n    return currStructureNode;\n};\n\n/**\n * Delete the structure object of the given 'target' node.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to delete the state for.\n */\nvar _removeStructureNode = function( declViewModel, gridId, ttState, targetNode ) {\n    if( ttState.structure ) {\n        var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n        /**\n         * Start at the top and work down based on the 'target' path.\n         */\n        var currParentNode = ttState.structure;\n\n        var parentNodes = {};\n\n        for( var ndx = pathIDs.length - 1; ndx > 0; ndx-- ) {\n            var pathID = pathIDs[ ndx ];\n\n            currParentNode = currParentNode[ pathID ];\n\n            if( !currParentNode ) {\n                break;\n            }\n\n            parentNodes[ pathID ] = currParentNode;\n        }\n\n        /**\n         * Starting at the lowest level, delete any structure objects that are not empty.\n         */\n        if( currParentNode ) {\n            currParentNode = ttState.structure;\n\n            var keys = Object.keys( parentNodes );\n\n            for( var ndx2 = keys.length - 1; ndx2 > 1; ndx2-- ) {\n                var key = keys[ ndx2 ];\n\n                currParentNode = parentNodes[ key ];\n\n                if( Object.keys( currParentNode ).length < 2 ) {\n                    var immParent = parentNodes[ keys[ ndx2 - 1 ] ];\n\n                    delete immParent[ key ];\n                }\n            }\n        }\n    }\n};\n\n/**\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {String} nodeId - ID of the node to return the object for,\n *\n * @return {Object} The state object associated with the given node (or NULL if no state exists for it.\n */\nvar _getNodeState = function( ttState, nodeId ) {\n    if( !ttState.nodeStates ) {\n        ttState.nodeStates = {};\n        return null;\n    }\n\n    return ttState.nodeStates[ nodeId ];\n};\n\n/**\n * @return {Object} The top-level object (loaded from local storage) containing the state information for all tables\n *         currently being tracked.\n */\nvar _getAllStates = function() {\n    var allStates;\n\n    var allStatesStr = localStrg.get( _LS_TOPIC );\n\n    if( allStatesStr ) {\n        try {\n            allStates = JSON.parse( allStatesStr );\n\n            if( allStates.schemaVersion !== _LS_TOPIC_VERSION ) {\n                allStates = null;\n            }\n        } catch ( ex ) {\n            // Handled below\n        }\n    }\n\n    if( !allStates ) {\n        allStates = {\n            schemaVersion: _LS_TOPIC_VERSION\n        };\n    }\n\n    return allStates;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {UwDataProvider} The current dataProvider associated with the given table.\n */\nvar _getDataProvider = function( declViewModel, gridId ) {\n    var declGrid = declViewModel._internal.grids[ gridId ];\n\n    assert( declGrid, 'Table definition not found' );\n\n    var uwDataProvider = declViewModel.dataProviders[ declGrid.dataProvider ];\n\n    assert( uwDataProvider, 'Table dataProvider is not valid' );\n\n    return uwDataProvider;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {String} The unique ID of the view model object that 'owns' the table's data (i.e. The ID of an assembly)\n *         (or 'nonTreeRoot' if there is no 'topNode' set on the associated dataProvider).\n */\nvar _getRootId = function( declViewModel, gridId ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    return uwDataProvider.topTreeNode ? uwUtilSvc.getEvaluatedId( uwDataProvider.topTreeNode ) : 'nonTreeRoot';\n};\n\n/**\n * @param {Object} allStates - The top-level object (loaded from local storage) containing the state information for\n *            all tables currently being tracked.\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the state for the given declModel/declGrid.\n */\nvar _getTreeTableGridState = function( allStates, declViewModel, gridId ) {\n    assert( declViewModel, 'Invalid DeclViewModel' );\n    assert( declViewModel._internal.panelId, 'Invalid DeclViewModel' );\n    assert( gridId, 'Invalid table ID' );\n\n    var declViewModelId = declViewModel._internal.panelId;\n\n    var vmDirNdx = declViewModelId.indexOf( _VM_DIR_NAME );\n\n    if( vmDirNdx !== -1 ) {\n        declViewModelId = declViewModelId.substring( vmDirNdx + _VM_DIR_NAME.length );\n    }\n\n    if( !allStates[ declViewModelId ] ) {\n        allStates[ declViewModelId ] = {};\n    }\n\n    if( !allStates[ declViewModelId ][ gridId ] ) {\n        allStates[ declViewModelId ][ gridId ] = {};\n    }\n\n    return allStates[ declViewModelId ][ gridId ];\n};\n\n/**\n * This save state function is 'debounced' to only save data after updated 'quiets down' for ~2 second.\n *\n * @private\n */\nvar _pingSaveStateDebounce = _.debounce( function() {\n    /**\n     * Check if we have pending requests<BR>\n     * If so: Process the pending requests.\n     */\n    if( !_.isEmpty( _pendingSaveStateRequests ) ) {\n        var saveStateRequests = _pendingSaveStateRequests;\n\n        _pendingSaveStateRequests = {};\n\n        var allStates = _getAllStates();\n\n        _.forEach( saveStateRequests, function( req ) {\n            /**\n             * Since a ping can time out *after* a declViewModel has been destroyed, check if the pending request\n             * has a valid declViewModel.\n             */\n            if( !req.declViewModel.isDestroyed() ) {\n                var gridState = _getTreeTableGridState( allStates, req.declViewModel, req.gridId );\n\n                var rootId = _getRootId( req.declViewModel, req.gridId );\n\n                gridState[ rootId ] = req.ttState;\n            }\n        } );\n\n        if( _debug_logTableStateActivity ) {\n            logger.info( 'Saving table states' );\n        }\n\n        localStrg.publish( _LS_TOPIC, JSON.stringify( allStates ) );\n    }\n}, 500, {\n    maxWait: 10000,\n    trailing: true,\n    leading: false\n} );\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n */\nvar _saveTreeTableState = function( declViewModel, gridId, ttState ) {\n    var rootId = _getRootId( declViewModel, gridId );\n\n    _pendingSaveStateRequests[ rootId ] = {\n        declViewModel: declViewModel,\n        gridId: gridId,\n        ttState: ttState\n    };\n\n    _pingSaveStateDebounce();\n};\n\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service Objects<BR>\n * -------------------------------------------------------------------------<BR>\n */\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service API<BR>\n * -------------------------------------------------------------------------<BR>\n */\nvar exports = {};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n */\nexport let clearAllStates = function( declViewModel, gridId ) {\n    /**\n     * Check if any of the new 'child' nodes are known to be expanded.<BR>\n     * If so: Setup to async expand them later.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    ttState.nodeStates = {};\n    ttState.structure = {};\n\n    // clear from local storage\n    _saveTreeTableState( declViewModel, gridId, ttState );\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNodeArray} nodesToTest - The nodes to test expansion status for.\n *\n * @return {Map} An object that maps a tree node ID to a data object with the following properties for each of the\n *         given nodes that are currently expanded:\n *\n * <pre>\n * {\n *     expanded: true,\n *     nodeToExpand: [node from nodesToTest]\n * }\n * </pre>\n */\nexport let findExpandedNodes = function( declViewModel, gridId, nodesToTest ) {\n    /**\n     * Check if any of the new 'child' nodes are known to be expanded.<BR>\n     * If so: Setup to async expand them later.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    var expandNodeRequests = {};\n\n    if( !_.isEmpty( ttState.nodeStates ) ) {\n        _.forEach( nodesToTest, function( testNode ) {\n            if( _expandAll ) {\n                expandNodeRequests[ uwUtilSvc.getEvaluatedId( testNode ) ] = {\n                    expanded: true,\n                    nodeToExpand: testNode\n                };\n            } else {\n                var nodeState = ttState.nodeStates[ uwUtilSvc.getEvaluatedId( testNode ) ];\n\n                if( nodeState && nodeState.expansion === _EXPAND_FULL ) {\n                    expandNodeRequests[ uwUtilSvc.getEvaluatedId( testNode ) ] = {\n                        expanded: true,\n                        nodeToExpand: testNode\n                    };\n                }\n            }\n        } );\n    }\n\n    return expandNodeRequests;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the table state for the given declModel/declGrid.\n */\nexport let getTreeTableState = function( declViewModel, gridId ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    if( !uwDataProvider.ttState ) {\n        var allStates = _getAllStates();\n\n        var gridState = _getTreeTableGridState( allStates, declViewModel, gridId );\n\n        var rootId = _getRootId( declViewModel, gridId );\n\n        if( _debug_logTableStateActivity ) {\n            logger.info( 'Reading table states for: ' + rootId );\n        }\n\n        if( !gridState[ rootId ] ) {\n            gridState[ rootId ] = {\n                structure: {},\n                nodeStates: {}\n            };\n        }\n\n        uwDataProvider.ttState = gridState[ rootId ];\n\n        // <pre>\n        // Possible fix for scroll to problem...investigate later w/ related changes in 'aw.table.controller'.\n        // if( uwDataProvider.ttState ) {\n        //     uwDataProvider.isFocusedLoad = true;\n        // }\n        // </pre>\n    }\n\n    return uwDataProvider.ttState;\n};\n\n/**\n * @param {Object} ttState - (Optional) An object holding the table state for a given declModel/declGrid.\n * @param {ViewModelTreeNodeArray} nodeToTest - The nodes to test status for.\n *\n * @return {Boolean} TRUE if the given node is currently expanded.\n */\nexport let isNodeExpanded = function( ttState, nodeToTest ) {\n    if( ttState.nodeStates ) {\n        var nodeState = ttState.nodeStates[ uwUtilSvc.getEvaluatedId( nodeToTest ) ];\n\n        return nodeState && nodeState.expansion === _EXPAND_FULL;\n    }\n\n    return false;\n};\n\n/**\n * Clear the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just collapsed.\n */\nexport let saveRowCollapsed = function( declViewModel, gridId, targetNode ) {\n    /**\n     * Forget we are expanding this node.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    _assureStructureNode( declViewModel, gridId, ttState, targetNode );\n\n    var nodeState = _getNodeState( ttState, uwUtilSvc.getEvaluatedId( targetNode ) );\n\n    if( nodeState && nodeState.expansion ) {\n        delete nodeState.expansion;\n\n        if( _.isEmpty( nodeState ) ) {\n            delete ttState.nodeStates[ uwUtilSvc.getEvaluatedId( targetNode ) ];\n\n            _removeStructureNode( declViewModel, gridId, ttState, targetNode );\n        }\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n/**\n * Update the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just expanded.\n */\nexport let saveRowExpanded = function( declViewModel, gridId, targetNode ) {\n    /**\n     * Remember we are expanding this node.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    _assureStructureNode( declViewModel, gridId, ttState, targetNode );\n\n    var nodeState = _getNodeState( ttState, uwUtilSvc.getEvaluatedId( targetNode ) );\n\n    if( !nodeState ) {\n        ttState.nodeStates[ uwUtilSvc.getEvaluatedId( targetNode ) ] = {\n            expansion: _EXPAND_FULL\n        };\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    } else if( nodeState.expansion !== _EXPAND_FULL ) {\n        nodeState.expansion = _EXPAND_FULL;\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n/**\n * Update the persisted current top row in the table. .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node of the currently visible top row of the table.\n */\nexport let saveScrollTopRow = function( declViewModel, gridId, targetNode ) {\n    var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    if( !ttState.topRowPath || _.difference( ttState.topRowPath, pathIDs ).length !== 0 ) {\n        ttState.topRowPath = pathIDs;\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n_debug_logTableStateActivity = browserUtils.getUrlAttributes().logTableStateActivity === '';\n\nexports = {\n    clearAllStates,\n    findExpandedNodes,\n    getTreeTableState,\n    isNodeExpanded,\n    saveRowCollapsed,\n    saveRowExpanded,\n    saveScrollTopRow\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}