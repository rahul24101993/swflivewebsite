{"ast":null,"code":"// Copyright (c) 2022 Siemens\n/* eslint-disable sonarjs/cognitive-complexity */ /**\n * This is the Teamcenter SOA Service. It's the central pipeline for invoking JSON SOA APIs & FMS APIs from the client.\n *\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/soaService\n */import AwPromiseService from'js/awPromiseService';import AwHttpService from'js/awHttpService';import cdm from'soa/kernel/clientDataModel';import cmm from'soa/kernel/clientMetaModel';import propPolicySvc from'soa/kernel/propertyPolicyService';import appCtxSvc from'js/appCtxService';import typeCacheSvc from'soa/kernel/typeCacheService';import configSvc from'js/configurationService';import _ from'lodash';import assert from'assert';import Debug from'debug';import logger from'js/logger';import eventBus from'js/eventBus';import browserUtils from'js/browserUtils';import localStrg from'js/localStorage';/**\n * Boolean to indicate if we're signed into the server. This is just an observer state. True signin state is\n * managed by the Session Manager.\n *\n * @private\n */let _signedIn=false;/**\n * Date/Time of the last progress 'start'. This is used to compute the amount of time a single SOA post takes.\n *\n * @private\n */const _lastStartDate={};/**\n * List of type names which have been deemed invalid based upon the previous server responses.\n *\n * @private\n */let _invalidTypeNames=['contents'];/**\n * Types that need loaded if available.\n * On AW startup.\n * @private\n */let _awStartupPreferences;/**\n * Types cache timestamp\n *\n * @private\n */let _typeCacheLMD;/**\n * Regular expression used to test if a string ends with \"[]\"\n */const REGEX_ARRAY_SUFFIX=/\\[\\]$/i;/**\n * Constant for operation name used for get TC Session Info\n *\n * @type {string}\n */const GET_SESSION_INFO={serviceName:'Internal-AWS2-2017-12-DataManagement',operationName:'getTCSessionAnalyticsInfo'};/**\n * SOA redirect\n */let _redirectSoaSvc;export const setSoaRedirect=function(redirect){_redirectSoaSvc=redirect;};/** Debug trace function */const trace=new Debug('soaService');/** Object to track which types are currently being loaded such that getTypeDescriptions2 is not duplicated for the same type */const _typeLoadInProgress={};/** client ID used in SOA header */let _clientId='ActiveWorkspaceClient';/** timeout to allow polling SOA calls to be made after last non-polling call */let _pollingTimeout=15*60;// 15 minutes default\nlet pendingRequests=0;/**\n * Initialize 'bodyElement[key]' based on given information.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @param {String} key - key\n * @param {Boolean} deleted - was the key just deleted?\n */function initializeField(state,typeName,bodyElement,key,deleted){switch(typeName){case'String':case'Date':bodyElement[key]='';break;case'int':case'float':case'double':bodyElement[key]=0;break;case'boolean':bodyElement[key]=false;break;case'ModelObj':case'ModelObject':bodyElement[key]={uid:deleted?cdm.NULL_UID:'',type:deleted?'unknownType':''};break;default:if(REGEX_ARRAY_SUFFIX.test(typeName)){// Array\nbodyElement[key]=[];}else if(state.schemaService.hasOwnProperty(typeName)&&_.isArray(state.schemaService[typeName])){// Enum support... default to first entry\nbodyElement[key]=state.schemaService[typeName][0];}else{// Object or map\nbodyElement[key]={};}}}/**\n * TRUE if the given element is in the schema.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element to evaluate to determine if element should be a map\n *\n * @returns {Boolean} TRUE if the given element is in the schema.\n */function isMap(state,schemaElement){if(Object.keys(schemaElement).length===2&&schemaElement.hasOwnProperty('key')&&schemaElement.hasOwnProperty('value')&&!state.schemaService.hasOwnProperty(schemaElement.key)){return true;}return false;}/**\n * Validate element type & recurse if non-trivial type.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @returns {Object} ...\n */function validateElementType(state,typeName,bodyElement){// eslint-disable-line complexity\nswitch(typeName){case'String':case'Date':if(!_.isString(bodyElement)){state.issues.push('INVALID FIELD: Expected string, not '+typeof bodyElement+' --'+state.stack.join('.'));}break;case'int':case'float':case'double':if(!_.isNumber(bodyElement)){state.issues.push('INVALID FIELD: Expected number, not '+typeof bodyElement+' --'+state.stack.join('.'));}break;case'boolean':if(!_.isBoolean(bodyElement)){state.issues.push('INVALID FIELD: Expected boolean, not '+typeof bodyElement+' --'+state.stack.join('.'));}break;case'ModelObj':case'ModelObject':if(!bodyElement||!bodyElement.uid||!bodyElement.type){return{uid:!bodyElement||!bodyElement.uid?cdm.NULL_UID:bodyElement.uid,type:!bodyElement||!bodyElement.type?'unknownType':bodyElement.type};}if(Object.keys(bodyElement).length!==2){// replace with new object if it's not already uid & type only\nreturn{uid:bodyElement.uid,type:bodyElement.type};}break;case'ICreateInput':if(!bodyElement||!bodyElement.boName||!_.isString(bodyElement.boName)){state.issues.push('INVALID FIELD VALUE: Expect type of ICreateInput');}break;default:if(state.schemaService.hasOwnProperty(typeName)){if(_.isArray(state.schemaService[typeName])){// Enum\nif(state.schemaService[typeName].indexOf(bodyElement)===-1){state.issues.push('INVALID FIELD VALUE: Not valid enum value '+typeName+' expected '+state.schemaService[typeName].toString()+' --'+state.stack.join('.'));}}else{// Object processing\ndefaultAndValidateElementRecurse(state,state.schemaService[typeName],bodyElement);}}else if(REGEX_ARRAY_SUFFIX.test(typeName)){// Array processing\nif(!_.isArray(bodyElement)){state.issues.push('INVALID FIELD: Expected array, not '+typeof bodyElement+' --'+state.stack.join('.'));return undefined;}const typeName2=typeName.substring(0,typeName.length-2);let replacementArray=null;for(let ii=bodyElement.length-1;ii>=0;ii--){state.stack.push(ii);const replacement=validateElementType(state,typeName2,bodyElement[ii]);if(replacement){if(!replacementArray){// we should probably replace the array in case caller is using for something else...\nreplacementArray=bodyElement.slice(0);}replacementArray[ii]=replacement;}state.stack.pop();}if(replacementArray){return replacementArray;}}else if(/^(String|Int|Bool|Double|Float|Date|Tag)(|Vector)Map/.test(typeName)){// Map processing\nlet typeName2;if(typeName.indexOf('String')===0){typeName2='String';}else if(typeName.indexOf('Date')===0){typeName2='Date';}else if(typeName.indexOf('Int')===0){typeName2='int';}else if(typeName.indexOf('Float')===0){typeName2='float';}else if(typeName.indexOf('Double')===0){typeName2='double';}else if(typeName.indexOf('Bool')===0){typeName2='boolean';}else if(typeName.indexOf('Tag')===0){typeName2='ModelObject';}if(/VectorMap/g.test(typeName)){typeName2+='[]';}_.forEach(bodyElement,function(value,key){let valueFinal=value;if(!_.isString(key)){state.issues.push('INVALID FIELD: Expected string, not '+typeof key+' --'+state.stack.join('.'));return;}if(typeName2){if(!bodyElement[key]){initializeField(state,typeName2,bodyElement,key,false);valueFinal=bodyElement[key];}if(typeName2){if(!bodyElement[key]){initializeField(state,typeName2,bodyElement,key,false);valueFinal=bodyElement[key];}state.stack.push(key);const replacement=validateElementType(state,typeName2,valueFinal);if(replacement){bodyElement[key]=replacement;}state.stack.pop();}else{state.issues.push('INVALID FIELD: Unsupported map type of '+typeName+' --'+state.stack.join('.'));}state.stack.pop();}else{state.issues.push('INVALID FIELD: Unsupported map type of '+typeName+' --'+state.stack.join('.'));}});}else{state.issues.push('INVALID FIELD: Unsupported type of '+typeName+' --'+state.stack.join('.'));}}}/**\n * Recursive method for default & validate SOA operation body.\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element/cursor for the walk\n * @param {Object} bodyElement - body element/cursor for the walk\n * @private\n */function defaultAndValidateElementRecurse(state,schemaElement,bodyElement){// Walk schema to add any missing fields\nconst isMapLcl=isMap(state,schemaElement);if(!isMapLcl){_.forEach(schemaElement,function(typeName,key2){let deleted=false;if(bodyElement.hasOwnProperty(key2)&&bodyElement[key2]===null){delete bodyElement[key2];deleted=true;}if(!bodyElement.hasOwnProperty(key2)||!bodyElement[key2]){initializeField(state,typeName,bodyElement,key2,deleted);}});}// Walk body element to validate against schema & recurse\nlet replacement=null;_.forEach(bodyElement,function forEachdefaultAndValidateElementRecurse(value,key2){if(isMapLcl){if(_.isArray(bodyElement)){for(let ii=0;ii<bodyElement[0].length;ii++){state.stack.push(ii);replacement=validateElementType(state,schemaElement.key,bodyElement[0][ii]);if(replacement){bodyElement[0][ii]=replacement;}replacement=validateElementType(state,schemaElement.value,bodyElement[1][ii]);if(replacement){bodyElement[1][ii]=replacement;}state.stack.pop();}}else{for(const mapKey in bodyElement){if(bodyElement.hasOwnProperty(key2)){state.stack.push(key2);replacement=validateElementType(state,schemaElement.key,mapKey);if(replacement){const oldValue=bodyElement[mapKey];delete bodyElement[mapKey];bodyElement[replacement]=oldValue;}replacement=validateElementType(state,schemaElement.value,bodyElement[mapKey]);if(replacement){bodyElement[mapKey]=replacement;}state.stack.pop();}}}}else if(schemaElement.hasOwnProperty(key2)){state.stack.push(key2);replacement=validateElementType(state,schemaElement[key2],value);if(replacement){bodyElement[key2]=replacement;}state.stack.pop();}else{state.issues.push('INVALID FIELD: Unexpected type of '+state.stack.join('.')+'.'+key2);delete bodyElement[key2];}});}/**\n * Default & validate SOA operation body.\n *\n * @param {Object} schemaService - schema for service\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @param {Object} body - request body\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */function defaultAndValidateElement(schemaService,serviceName,operationName,body){const state={// If caller has passed null, they've indicated that there's an empty body.\nbody:body?body:{},serviceName:serviceName,operationName:operationName,schemaService:schemaService,issues:[],stack:[]};if(state.schemaService){state.operation=state.schemaService[state.operationName];if(state.operation){// Walk body make sure it aligns to the schema\ndefaultAndValidateElementRecurse(state,state.operation,state.body);if(state.issues.length>0){logger.error('Invalid SOA request body!\\n'+state.issues.join('\\n')+'\\n\\nInput body:',state.body);}}else{logger.error('No SOA operation for '+state.serviceName+' '+state.operationName+'! Skipping validation & default of SOA input.');}}else{logger.error('No SOA service for '+state.serviceName+'! Skipping validation & default of SOA input.');}return state.body;}// Response processing\n/**\n * Process an array of objects to create a single string of messages.\n *\n * @param {Object} messages - array of objects containing message fields\n * @param {Object} msgObj - message object with message value & level\n */function getMessageString(messages,msgObj){_.forEach(messages,function(object){if(msgObj.msg.length>0){msgObj.msg+='\\n';}msgObj.msg+=object.message;msgObj.level=_.max([msgObj.level,object.level]);});}/**\n * Return a reference to a new 'error' object set with the given error information.\n *\n * @param {Object} errIn - error in\n *\n * @returns {Object} - JavaScript Error object\n */export const createError=function(errIn){const msgObj={msg:'',level:0};if(errIn.message){msgObj.msg=errIn.message;}else if(errIn.status||errIn.statusText){msgObj.msg=errIn.status+' '+errIn.statusText;}else if(errIn.PartialErrors){_.forEach(errIn.PartialErrors,function(partialError){getMessageString(partialError.errorValues,msgObj);});}else if(errIn.partialErrors){_.forEach(errIn.partialErrors,function(partialError){getMessageString(partialError.errorValues,msgObj);});}else if(errIn.messages){getMessageString(errIn.messages,msgObj);}else{msgObj.msg=errIn.toString();}if(errIn.data&&errIn.data.messages){getMessageString(errIn.data.messages,msgObj);}const error=new Error(msgObj.msg);error.cause=errIn;error.level=msgObj.level;return error;};/**\n * @param {Object} response - response\n * @return {Object|null} service data\n */function getServiceData(response){if(response.hasOwnProperty('.QName')&&/\\.ServiceData$/.test(response['.QName'])){return response;}else if(response.ServiceData){// If the service data is a member field, update the service data reference\nreturn response.ServiceData;}}/**\n * Process SOA partial exceptions in response.\n *\n * @param {Object} response JSON response data\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @return {Object} response JSON response data\n */function processExceptions(response,serviceName,operationName){const serviceData=getServiceData(response);if(serviceData&&serviceData.partialErrors||response.PartialErrors&&!_.isEmpty(response.PartialErrors)){// Publish SAN event to log the SOA errors to analytics\nlet qName='unknown';if(response.hasOwnProperty('.QName')){qName=response['.QName'];}eventBus.publishOnChannel({channel:'SAN_Events',topic:'aw-command-logErrros',data:{sanQName:qName,sanPartialErrors:serviceData&&serviceData.partialErrors||response,sanServiceName:serviceName,sanOperationName:operationName,sanLogCorrelationID:logger.getCorrelationID()}});}// Should we search for 'Exception' in QName?\nif(response&&response.hasOwnProperty('.QName')){if(/InvalidUserException$/.test(response['.QName'])){if(operationName===GET_SESSION_INFO.operationName){// This is the trivial case of initial connection to the server.\nthrow exports.createError(response);}// hit the InvalidUserException during a non-login related SOA call.\n// this is a session time-out situation.\neventBus.publish('session.stale',{});console.log('Encountered Session timeout. SOA Request for service: '+serviceName+', '+// eslint-disable-line no-console\noperationName+'  Will refresh the page in order to re-Authenticate.');// assumption is that we've timed out, so need to \"reAuthenticate\".\n// Legacy GWT logic would call the session manager to reauthenticate(), but that\n// pattern is no longer used.  In general we just will reload the page and\n// that will update the authentication state and trigger reauthentication.\nlocation.reload(false);// trigger a page refresh, that will reload and authenticate again.\n}// FIXME this should be conditioned with a QName check...\nif(/Exception$/.test(response['.QName'])){throw exports.createError(response);}}return response;}/**\n * @private\n * @param {Object} parent - parent element\n * @param {Array} modelObjs - Array of {ModelObject} found in response\n * @param {Object} typeNames - array of referenced type names\n */function extractModelObjAndTypeFromResponse(parent,modelObjs,typeNames){_.forEach(parent,function(child,key){if(_.isPlainObject(child)){if(child.hasOwnProperty('uid')&&child.hasOwnProperty('type')){if(child.uid&&child.uid!==cdm.NULL_UID){if(modelObjs){modelObjs.push(child);}else{const modelObj=cdm.getObject(child.uid);if(modelObj){parent[key]=modelObj;}}}if(typeNames&&child.type&&child.type!=='unknownType'){typeNames[child.type.toString()]=null;}}else{extractModelObjAndTypeFromResponse(child,modelObjs,typeNames);}}else if(_.isArray(child)){extractModelObjAndTypeFromResponse(child,modelObjs,typeNames);}});}/**\n * @private\n * @param {Object} response - Response from SOA service.\n * @param {Array} modelObjs - Array of {ModelObject} from SOA service.\n * @returns {Object} Response from SOA service.\n */function processResponseObjects(response,modelObjs){const serviceData=getServiceData(response);let updatedObjs=[];if(modelObjs&&modelObjs.length>0){// Add objects to CDM\ncdm.cacheObjects(modelObjs);updatedObjs=modelObjs;// To support the anti-pattern of code pulling the modelObject from the response, we need to update the response serviceData.\nextractModelObjAndTypeFromResponse(response);}if(serviceData){if(serviceData.created){const createdObjects=[];_.forEach(serviceData.created,function(uid){const createdObject=cdm.getObject(uid);if(createdObject){createdObjects.push(createdObject);}});if(createdObjects.length){eventBus.publish('cdm.created',{createdObjects:createdObjects});}}if(serviceData.updated){const updatedObjects=[];_.forEach(serviceData.updated,function(uid){if(!cmm.isTypeUid(uid)){const updatedObject=cdm.getObject(uid);if(updatedObject){updatedObjects.push(updatedObject);}}});if(updatedObjects.length){eventBus.publish('cdm.updated',{updatedObjects:updatedObjects});}}if(serviceData.deleted){// Remove objects from CDM\ncdm.removeObjects(serviceData.deleted);}}const currentStore=appCtxSvc.getCtx('vmo')||{};let timeNow=Date.now();let values={};if(updatedObjs.length){for(const mo of updatedObjs){let refUid=getRefUid(mo);let uidVal=mo.uid;currentStore[uidVal]={type:mo.type,time:timeNow,ref:refUid};if(uidVal){values[uidVal]=true;}}const storeValues=Object.entries(currentStore);if(!_.isEmpty(values)){for(const[uid,{type,ref}]of storeValues){if(values[ref]){currentStore[uid]={type:type,time:timeNow,ref:ref};}}}appCtxSvc.registerCtx('vmo',currentStore);}return response;}const getRefUid=mo=>{if(mo.type==='Awp0XRTObjectSetRow'&&mo.props&&mo.props.awp0Target){return mo.props.awp0Target.dbValues[0];}return null;};/**\n * Process service data in HTTP response.\n *\n * @param {Object} response - JSON response data\n * @param {String} operationName - operation name\n * @return {Promise} Promise resolved once types are loaded\n */function processResponseTypes(response,operationName){if(response){const modelObjs=[];const typeNamesObj={};const qName=response['.QName'];if(qName!=='http://teamcenter.com/Schemas/Soa/2011-06/MetaModel.TypeSchema'){extractModelObjAndTypeFromResponse(response,modelObjs,typeNamesObj);}const typeNames=Object.keys(typeNamesObj);if(operationName===GET_SESSION_INFO.operationName&&response.extraInfoOut){if(response.extraInfoOut.AWC_StartupTypes){_typeCacheLMD=response.extraInfoOut.typeCacheLMD;_awStartupPreferences=response.extraInfoOut.AWC_StartupTypes.split(',');// Always include TC_Project even if not in the start up preference\nif(!_.includes(_awStartupPreferences,'TC_Project')){_awStartupPreferences.push('TC_Project');}// Always include ListOfValuesString even if not in the start up preference\nif(!_.includes(_awStartupPreferences,'ListOfValuesString')){_awStartupPreferences.push('ListOfValuesString');}}const loadedTypes=typeCacheSvc.getLocalTypes(_typeCacheLMD);cmm.cacheTypes(loadedTypes);}return exports.ensureModelTypesLoaded(typeNames).then(function(){// Just in case we have more types, let's go get them...\nreturn processResponseObjects(response,modelObjs);});}return AwPromiseService.instance.resolve();}/**\n *\n * Gets the effective property policy\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {boolean} isSelectedPropertyPolicy - boolean which indicates whether the selected property is required\n *            or not.\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */function getEffectivePropertyPolicy(propertyPolicyOverride,isSelectedPropertyPolicy){if(_.isString(propertyPolicyOverride)){return JSON.parse(propertyPolicyOverride);}if(_.isObject(propertyPolicyOverride)){// No need to pass a property policy for this call.\nreturn propertyPolicyOverride;}return propPolicySvc.getEffectivePolicy(exports,isSelectedPropertyPolicy);}/**\n * @param {String} clientId - client ID used in SOA header\n */export const setClientIdHeader=function(clientId){_clientId=clientId;};/**\n * @return {String} client ID used in SOA header\n */export const getClientIdHeader=function(){return _clientId;};/**\n * @param {Number} pollingTimeout - timeout to allow polling SOA calls to be made after last non-polling call (minutes)\n */export const setPollingTimeout=function(pollingTimeout){if(pollingTimeout){_pollingTimeout=pollingTimeout*60;}};/**\n * Teamcenter SOA request.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @param {Boolean} checkPartialErrors - check for partial errors in the response\n * @param {Boolean} polling - true if this is a polling call\n *\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */export const request=function(serviceName,operationName,body){let{propertyPolicyOverride,ignoreHost=false,headerStateOverride=false,checkPartialErrors=false,polling=false}=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};assert(serviceName,'Service name not provided!');assert(operationName,'Operation name not provided!');// Support polling SOA calls to have a timeout. This stops an idle client\n// browser from making polling calls.This is required because the TC web\n// tier needs to be able to allow it's session to timeout.\nif(_pollingTimeout>0){if(polling){// Determine when last call was made.\nconst timeOfLastCall=_.toNumber(localStrg.get('soaService.timeOfLastCall'));if(timeOfLastCall){const secsSinceLastCall=(Date.now()-timeOfLastCall)/1000;// If longer than polling timeout, avoid call.\nif(secsSinceLastCall>_pollingTimeout){return AwPromiseService.instance.reject(new Error('Polling call skipped due to client inactivity.'));}}}else{// localStorage is being used because SOA calls from other\n// browsers tabs allow this tab to make the polling call.\nlocalStrg.publish('soaService.timeOfLastCall',Date.now());}}let isSelectedPropertyPolicy=false;let endPt;let promise;if(GET_SESSION_INFO.serviceName===serviceName&&GET_SESSION_INFO.operationName===operationName){// avoid loading schema for get session info call\nconst schemaService={};schemaService[GET_SESSION_INFO.operationName]={};// extraInfoIn: \"String[]\"\npromise=AwPromiseService.instance.resolve(schemaService);}else{promise=configSvc.getCfg('schema.'+serviceName).then(function(schemaService){return schemaService;},function(){// none found\nlogger.warn('No SOA schema definition found!');return{};});}return promise.then(function(schemaService){if(appCtxSvc.ctx.aw_hosting_enabled&&!appCtxSvc.ctx.aw_hosting_soa_support_checked){appCtxSvc.ctx.aw_hosting_soa_support_checked=true;}if(body){isSelectedPropertyPolicy=propPolicySvc.checkForSelectedObject(body);}const jsonData={header:{state:{clientVersion:'10000.1.2',/**\n                     * Correlation ID for logging purposes (debug).\n                     */logCorrelationID:logger.getCorrelationID(),/**\n                     * Permanent ID/recipes are used for the runtime business objectâ€™s (BOMLine objects) opaque UIDs\n                     * in requests/responses.\n                     * <p>\n                     * If the unloadObjects key is not in the request headers, all business objects are unloaded at\n                     * the top of each request; see the processTagManager ITK for more information.\n                     */stateless:true,/**\n                     * If true, All business objects are unloaded at the top of each request; see the\n                     * processTagManager ITK for more information. Previously controlled through the stateless flag.\n                     * <p>\n                     * When is stateless=true mode this value must be explicitly set to false to keep objects\n                     * loaded.\n                     */unloadObjects:true,/**\n                     * If true, process server-session state key/value pairs found in the request headers. This\n                     * turns all session state into client-session data. The standalone AW client should set this to\n                     * true, while the hosted AW client should set it false (or not send it at all).\n                     */enableServerStateHeaders:!_redirectSoaSvc,/**\n                     */formatProperties:true},policy:getEffectivePropertyPolicy(propertyPolicyOverride,isSelectedPropertyPolicy)},body:defaultAndValidateElement(schemaService,serviceName,operationName,body)};mergeHeaderState(jsonData.header.state,headerStateOverride);if(appCtxSvc&&appCtxSvc.getCtx('objectQuotaContext.useObjectQuota')){/**\n             * If true, All business objects are unloaded at the top of each request. Applications might want to\n             * rely on object quota based unload. In such cases they can use \"objectQuotaContext\" to override this\n             * behavior and reset this flag to avail this feature\n             */jsonData.header.state.unloadObjects=false;}if(!_redirectSoaSvc&&_clientId!==''){jsonData.header.state.clientID=_clientId;}const headers={// Only US-ASCII characters are allowed in HTTP headers\n// http://stackoverflow.com/questions/34670413/regexp-to-validate-a-http-header-value/34710882#34710882\n'Log-Correlation-ID':jsonData.header.state.logCorrelationID.replace(/[^\\x20-\\x7E]+/g,'')};if(GET_SESSION_INFO.serviceName===serviceName&&GET_SESSION_INFO.operationName===operationName){headers.clientIP='browser-client';}let awSession=localStrg.get('awSession');if(awSession){try{awSession=JSON.parse(awSession);if(!appCtxSvc.ctx.aw_hosting_enabled){if(awSession.groupMemberUID){jsonData.header.state.groupMember=awSession.groupMemberUID;}if(awSession.roleName){jsonData.header.state.role=awSession.roleName;}}if(awSession.locale){jsonData.header.state.locale=awSession.locale;}}catch(err){logger.debug(err);localStrg.removeItem('awSession');}}endPt=serviceName+'/'+operationName;if(logger.isTraceEnabled()){logger.trace('\\n'+'soaService.post to '+endPt,jsonData);}pendingRequests++;eventBus.publish('progress.start',{endPoint:endPt});/**\n         * Check if there is a 'host' process that is handling SOA processing<BR>\n         * If so: Send the 'endPt' and data to that service.\n         */ // The only case the client will make its own login call when hosted would be when it needs credentials.\n// If such a call is made, we should not make it through the host. This is the only case when AW talks directly to the server.\n// This will allow Viewer to show up in hosts.\nif(_redirectSoaSvc&&!ignoreHost){return _redirectSoaSvc.post(serviceName,operationName,jsonData);}const $http=AwHttpService.instance;trace('HTTP call start',serviceName,operationName);return $http.post(browserUtils.getBaseURL()+'tc/JsonRestServices/'+endPt,jsonData,{headers:headers}).then(function(response){trace('HTTP call complete',serviceName,operationName);assert(response,'No response given for '+endPt);const body2=response.data;assert(typeof body2!=='string'||body2.indexOf('<?xml version')===-1,'Unexpected response body for: '+endPt);return body2;});}).then(function(response){pendingRequests--;eventBus.publish('progress.end',{endPoint:endPt});if(logger.isTraceEnabled()){logger.trace('endPt='+endPt,response);}return processExceptions(response,serviceName,operationName);},function(err){pendingRequests--;eventBus.publish('progress.end',{endPoint:endPt});throw exports.createError(err);}).then(function(response){if(!propertyPolicyOverride&&!isSelectedPropertyPolicy){loadPropertiesIfRequired(response);}return processResponseTypes(response,operationName);}).then(function(response){if(checkPartialErrors&&response){if(response.PartialErrors){throw exports.createError(response.PartialErrors);}const serviceData=getServiceData(response);if(serviceData&&serviceData.partialErrors){throw exports.createError(serviceData);}}return response;});};/**\n * Merge default header state with the given overrides\n *\n * @param {Object|String} defaultHeaderState - SOA header state default (or NULL)\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n */function mergeHeaderState(defaultHeaderState,headerStateOverride){const keys=headerStateOverride?Object.keys(headerStateOverride):[];for(let i=0;i<keys.length;++i){defaultHeaderState[keys[i]]=headerStateOverride[keys[i]];}}/**\n * Calls getProperties Soa to load additional properties if required.\n *\n * @param {Object} response - JSON response data\n */function loadPropertiesIfRequired(response){if(response){const serviceData=getServiceData(response);if(serviceData){const responseObjects=[];if(serviceData.updated){for(let ii2=0;ii2<serviceData.updated.length;ii2++){const updatedUid=serviceData.updated[ii2];if(!cmm.isTypeUid(updatedUid)){const updatedObject=cdm.getObject(updatedUid);if(updatedObject){responseObjects.push(updatedObject);}}}}if(serviceData.created){for(let ii=0;ii<serviceData.created.length;ii++){const createdObject=cdm.getObject(serviceData.created[ii]);if(createdObject){responseObjects.push(createdObject);}}}if(responseObjects.length>0&&propPolicySvc.checkForSelectedObject(null,responseObjects)){exports.request('Core-2006-03-DataManagement','getProperties',{objects:responseObjects,attributes:[]},{propertyPolicyOverride:propPolicySvc.getEffectivePolicy(null,true)});}}}}/**\n * SOA post unchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */export const postUnchecked=function(serviceName,operationName,body,propertyPolicyOverride,ignoreHost,headerStateOverride){return exports.request(serviceName,operationName,body,{propertyPolicyOverride,ignoreHost,headerStateOverride});};/**\n * SOA post.\n *\n * If the response contains partial errors, it will be treated as an exception & thrown. If this isn't desired,\n * use postUnchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */export const post=function(serviceName,operationName,body,propertyPolicyOverride,ignoreHost){return exports.request(serviceName,operationName,body,{propertyPolicyOverride,ignoreHost,checkPartialErrors:true});};/**\n * Set session information into local storage (if needed)\n *\n * @param {Boolean} signOut - sign out\n */export const setSessionInfo=function(signOut){if(!signOut){const userSession=cdm.getUserSession();if(userSession){// Store all the required fields to support the SOA header\nconst awSession={groupMemberUID:_.get(userSession,'props.fnd0groupmember.dbValues.0'),locale:_.get(userSession,'props.fnd0locale.dbValues.0'),roleName:_.get(userSession,'props.role_name.dbValues.0')};localStrg.publish('awSession',JSON.stringify(awSession));}}else{localStrg.removeItem('awSession');}};/**\n * Perform an async get of current Teamcenter session information.\n *\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */export const getTCSessionInfo=function(ignoreHost){// Ensure we have the required properties for the UserSession.\nconst policyId=propPolicySvc.register({types:[{name:'UserSession',properties:[{name:'awp0RevRule',modifiers:[{name:'includeIsModifiable',Value:'true'}]},{name:'user',modifiers:[{name:'withProperties',Value:'true'}]},{name:'user_id'},{name:'group',modifiers:[{name:'withProperties',Value:'true'}]},{name:'group_name'},{name:'project'},{name:'role'},{name:'role_name'},{name:'fnd0locale'},{name:'fnd0LocationCode'},{name:'fnd0groupmember'}]},{name:'Group',properties:[{name:'privilege'}]},{name:'User',properties:[{name:'home_folder'}]}]});return exports.request(GET_SESSION_INFO.serviceName,GET_SESSION_INFO.operationName,{},{ignoreHost,checkPartialErrors:true}).then(function(response){propPolicySvc.unregister(policyId);exports.setSessionInfo();return response;}).catch(function(err){propPolicySvc.unregister(policyId);// Since we have no session, clear the session from localStorage to ensure we don't try to use it.\nlocalStrg.removeItem('awSession');throw err;});};/**\n * Get Type Descriptions from server.\n *\n * Note, this is hidden in this file to avoid anyone else directly calling this.\n *\n * @private\n *\n * @param {StringArray} typeNames - Array of type names\n *\n * @return {Promise} Promise who's resolution is the result of the SOA 'getTypeDescriptions2' operation.\n */async function getTypeDescriptions(typeNames){assert(typeNames&&typeNames.length>0,'No type names provided!');typeNames.sort();const typeNamesFinal=_.uniq(typeNames,true);const typesToLoad=typeNamesFinal.filter(type=>{if(!_typeLoadInProgress[type]){return type;}});const currentTypesBeingLoadedPromises=typeNamesFinal.filter(type=>!typesToLoad.includes(type)).map(type=>{if(_typeLoadInProgress[type]){return _typeLoadInProgress[type];}});const newLoadPromises=[];if(typesToLoad.length>0){const loadTypesPromise=exports.request('Core-2015-10-Session','getTypeDescriptions2',{typeNames:typesToLoad,options:{PropertyExclusions:['LovReferences','NamingRules','RendererReferences'],TypeExclusions:['DirectChildTypesInfo','RevisionNamingRules','ToolInfo']}},{propertyPolicyOverride:{}});for(const type of typesToLoad){_typeLoadInProgress[type]=loadTypesPromise;}newLoadPromises.push(loadTypesPromise);}const response=await Promise.all([...currentTypesBeingLoadedPromises,...newLoadPromises]);for(const type of typesToLoad){delete _typeLoadInProgress[type];}return response;}/**\n * Verify async that the given model types are loaded into the client's meta model.\n *\n * @param {StringArray} typeNames - An array of type names to ensure are cached.\n *\n * @return {Promise} Promise who's resolution is a 'null' value since the types are now loaded into the cache.\n *         This 'null' result is required because the GWT-side wrapper requires an AsyncCallback<Void> callback\n *         (not AsyncCallback<IJsAarray>).\n */export const ensureModelTypesLoaded=function(typeNames){/**\n     * Handle trivial case\n     */if(!typeNames){return AwPromiseService.instance.reject('Invalid type name array specified');}/**\n     * From the input list of type names, get a list of unique type names not in the CMM already.\n     */const missingTypeNames=[];_.forEach(typeNames,function(typeName){if(!cmm.containsType(typeName)&&_invalidTypeNames.indexOf(typeName)===-1){missingTypeNames.push(typeName);}});/**\n     * Check if we have any missing.\n     */if(missingTypeNames.length>0){// logger.info( \"Missing Types: \" + JSON.stringify( missingTypeNames ) );\nreturn getTypeDescriptions(missingTypeNames).then(function(responseGetTypeDescriptions){for(const response of responseGetTypeDescriptions){if(response&&response.types){const modelTypes=response.types;const modelTypes2=[];_.forEach(modelTypes,function(typeName){if(!cmm.containsType(typeName)){modelTypes2.push(typeName);}});if(modelTypes2.length>0){cmm.cacheTypes(modelTypes2);// Cache the types in localStorage.\ntypeCacheSvc.setLocalTypes(modelTypes2,_awStartupPreferences,_typeCacheLMD,true);}}// Capture invalid type names\n_.forEach(missingTypeNames,function(typeName){if(!cmm.containsType(typeName)){// add empty type to avoid future server calls\n_invalidTypeNames.push(typeName);_invalidTypeNames.sort();_invalidTypeNames=_.uniq(_invalidTypeNames,true);}});}return null;});}return AwPromiseService.instance.resolve();};/**\n * Setup to log all events fired on the 'soajs' eventBus event channel.\n */if(logger&&logger.isTraceEnabled()){eventBus.subscribe('#',function(data,envelope){let msg='eventBus: '+envelope.topic+' @ '+envelope.timeStamp;if(data&&data.endPoint){if(envelope.topic==='progress.start'){_lastStartDate[data.endPoint]=envelope.timeStamp;}else if(envelope.topic==='progress.end'&&_lastStartDate[data.endPoint]){const msDelta=envelope.timeStamp.getTime()-_lastStartDate[data.endPoint].getTime();msg=msg+'\\n'+'          Time: '+msDelta+'ms'+'    '+data.endPoint;_lastStartDate[data.endPoint]=null;}}if(logger.isTraceEnabled()){// Just print, using logger.trace causes infinite recursion\nconsole.debug(msg,envelope);// eslint-disable-line no-console\n}},'soa_kernel_soaService');}/**\n * Determine if the user is currently signed in.\n *\n * @return {boolean} is signed in?\n */export const isSignedIn=function(){return _signedIn;};export const getPendingRequestsCount=function(){return pendingRequests;};/**\n * Subscribe to listen when we are signed in/out. Just tracking state locally. NOTE - for non User/PW\n * authentication, this state may not be 100% accurate.\n */eventBus.subscribe('session.signIn',function(){_signedIn=true;},'soa_kernel_soaService');eventBus.subscribe('session.signOut',function(){_signedIn=false;},'soa_kernel_soaService');const exports={createError,postUnchecked,post,request,setSessionInfo,getTCSessionInfo,ensureModelTypesLoaded,isSignedIn,setClientIdHeader,getClientIdHeader,setPollingTimeout,setSoaRedirect,getPendingRequestsCount};export default exports;","map":null,"metadata":{},"sourceType":"module"}