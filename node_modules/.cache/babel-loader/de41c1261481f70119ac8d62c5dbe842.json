{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is responsible to process drag and drop handlers on the declViewModel if drag and\n * drop configuration is defined for that particular view.\n * It is also responsible to attach the drag and drop listners to applicable views and widgets.\n *\n * @module js/declDragAndDropService\n */\nimport cfgSvc from 'js/configurationService';\nimport moduleLoader from 'js/moduleLoader';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport appCtxSvc from 'js/appCtxService';\nimport conditionSvc from 'js/conditionService';\nimport logger from 'js/logger';\nimport domUtils from 'js/domUtils';\nimport awConfiguration from 'js/awConfiguration';\nconst eleRef = domUtils.DOMAPIs;\nlet exports;\nconst PRE_LOADED_DEPS = '_internal.preLoadedDeps';\nconst DRAG_HANDLERS = '_internal.dragHandlers';\nconst DROP_HANDLERS = '_internal.dropHandlers';\nconst DEPS_TO_LOAD = '_internal.depsToLoad';\nconst dndAttr = {\n  dragstart: 'onDrag',\n  dragenter: 'onDragEnter',\n  dragleave: 'onDragLeave',\n  dragover: 'onDragOver',\n  drop: 'onDrop',\n  dragend: 'onDragEnd'\n};\nlet defaultDragHandler = null;\nlet defaultDropHandler = null;\nlet dragDropConfig = null;\nlet viewHandlersMap = new Map();\n\nconst loadConfiguration = () => {\n  /*\n   * Get the drag and drop configuration\n   */\n  dragDropConfig = cfgSvc.getCfgCached('dragAndDrop');\n  let defaultDragAndDropConfig = awConfiguration.get('solutionDef.defaultDragAndDropHandlers');\n\n  if (defaultDragAndDropConfig && defaultDragAndDropConfig !== '{{defaultDragAndDropHandlers}}') {\n    defaultDragHandler = defaultDragAndDropConfig.dragHandler !== '' ? defaultDragAndDropConfig.dragHandler : null;\n    defaultDropHandler = defaultDragAndDropConfig.dropHandler !== '' ? defaultDragAndDropConfig.dropHandler : null;\n  }\n};\n\nconst createDragAndDropHandlersMap = () => {\n  const setViewHandlers = (viewName, handlerDef, handlerkey) => {\n    let key = handlerkey === 'dragActions' ? 'dragHandlers' : 'dropHandlers';\n\n    if (!viewHandlersMap.has(viewName)) {\n      viewHandlersMap.set(viewName, {\n        dragHandlers: [],\n        dropHandlers: []\n      });\n    }\n\n    let def = viewHandlersMap.get(viewName);\n    let obj = {};\n\n    _.forOwn(handlerDef[handlerkey], function (value, hkey) {\n      obj[hkey.toLowerCase()] = value;\n    });\n\n    let viewHandlerDef = {\n      condition: {},\n      handlers: obj\n    };\n\n    if (handlerDef.activeWhen) {\n      viewHandlerDef.condition.activeWhen = handlerDef.activeWhen;\n    }\n\n    def[key].push(viewHandlerDef);\n  };\n\n  const processHandlers = (handlers, handlerkey) => {\n    _.forEach(handlers, (handlerDef, handlerName) => {\n      if (handlerName === defaultDragHandler || handlerName === defaultDropHandler) {\n        return;\n      }\n\n      _.forEach(handlerDef.views, viewName => {\n        setViewHandlers(viewName, handlerDef, handlerkey);\n      });\n    });\n  };\n\n  if (dragDropConfig) {\n    let handlers = dragDropConfig.dragHandlers;\n    processHandlers(handlers, 'dragActions');\n    handlers = dragDropConfig.dropHandlers;\n    processHandlers(handlers, 'dropActions');\n  }\n};\n\nconst getTargetEleAndVMOs = (event, callbackAPIs) => {\n  let target = {};\n  let isSourceEle = event.type === 'dragstart';\n\n  if (callbackAPIs.getTargetElementAndVmo) {\n    target = callbackAPIs.getTargetElementAndVmo(event, isSourceEle);\n  }\n\n  return {\n    targetElement: target.targetElement,\n    targetObjects: target.targetVMO\n  };\n};\n\nconst getAction = (declViewModel, actionName) => {\n  const dragAndDropInput = '{{dragAndDropParams}}';\n\n  let action = _.get(declViewModel, '_internal.actions.' + actionName);\n\n  if (action) {\n    //adding actionId ref to action object for consistency with declViewModel actions\n    action.actionId = actionName;\n\n    if (!action.inputData) {\n      _.set(action, 'inputData', {\n        dndParams: dragAndDropInput\n      });\n    } else {\n      let inputData = { ...action.inputData,\n        dndParams: dragAndDropInput\n      };\n\n      _.set(action, 'inputData', inputData);\n    }\n\n    return action;\n  }\n\n  return null;\n};\n\nconst evaluateActiveWhen = (handlerObj, dragAndDropConfig, declViewModel) => {\n  if (handlerObj.condition) {\n    handlerObj = handlerObj.condition;\n  }\n\n  if (!handlerObj.activeWhen) {\n    return true;\n  }\n\n  if (declViewModel.dataProviders && Object.keys(declViewModel.dataProviders).length === 0) {\n    declViewModel.dataProviders = null;\n  }\n\n  return conditionSvc.evaluateConditionExpression(handlerObj, {\n    data: declViewModel,\n    ctx: appCtxSvc.ctx\n  }, {\n    clauseName: 'activeWhen',\n    conditionList: dragAndDropConfig\n  });\n};\n/*\n * Attaching dragenter, dragover and drop listners at the document level\n * These listners are mainly required for file drag and drop. Whenever a file is dragged from Os to the browser, by\n * default the effectAllowed property that is set by OS(defaults to copy/move depending on the file type) will be set\n * as the dropEffect.\n * So as soon as the file is dragged on browser, the default dropEffect would be enabled(copy/move) and thus drop is enabled\n * if the no events listners for drag and drop are defined for the particular part of the page. Further the default browser behavior\n * to open the dropped file would be performed.\n *\n * These listners basically set the drop effect to false during dragenter and dragover phase, thus preventing drop.\n *\n * Note: A file specific check is not added during dragenter and dragover phase as doing so would lead to undefined dropEffect\n * state(instead of block) for objects that are being dragged on non-droppable drop areas.\n */\n\n\nconst attachDocEventListners = () => {\n  const setDropEffect = event => {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  };\n\n  document.addEventListener('dragover', setDropEffect);\n  document.addEventListener('dragenter', setDropEffect);\n  document.addEventListener('drop', setDropEffect);\n};\n\nconst setDragAndDropHandlersOnVM = (declViewModel, path, activeHandlerActions, actionsDefs) => {\n  const setDnDActionsOnVM = (declViewModel, handlerActions) => {\n    let declVmActions = _.get(declViewModel, '_internal.actions');\n\n    if (!declVmActions) {\n      _.set(declViewModel, '_internal.actions', handlerActions);\n    } else {\n      Object.assign(declVmActions, handlerActions);\n    }\n  };\n\n  const getHandlerActionsAndDepsToLoad = activeHandlerActions => {\n    let depsToLoad = [];\n    let handlerActions = {};\n\n    _.forEach(activeHandlerActions, actionName => {\n      let actionDef = actionsDefs[actionName];\n\n      if (!actionDef) {\n        return;\n      }\n\n      handlerActions[actionName] = actionDef;\n      let found = depsToLoad.some(dep => dep === actionDef.deps);\n\n      if (!found) {\n        depsToLoad.push(actionDef.deps);\n      }\n    });\n\n    return {\n      handlerActions,\n      depsToLoad\n    };\n  }; //Set drag and drop handler references on the declViewModel\n  //These handler references will be used by widgets to setup drag and drop\n\n\n  _.set(declViewModel, path, activeHandlerActions);\n\n  let handlers = getHandlerActionsAndDepsToLoad(activeHandlerActions);\n  setDnDActionsOnVM(declViewModel, handlers.handlerActions);\n  let handlerDeps = _.get(declViewModel, DEPS_TO_LOAD) ? _.get(declViewModel, DEPS_TO_LOAD) : [];\n  handlerDeps = [...new Set([...handlerDeps, ...handlers.depsToLoad])];\n\n  _.set(declViewModel, DEPS_TO_LOAD, handlerDeps);\n};\n\nconst processDnDEvent = (data, event) => {\n  if (data.effectAllowed) {\n    event.dataTransfer.effectAllowed = data.effectAllowed;\n  }\n\n  if (data.dropEffect) {\n    event.dataTransfer.dropEffect = data.dropEffect;\n  }\n\n  if (data.preventDefault) {\n    event.preventDefault();\n  }\n\n  if (data.stopPropagation) {\n    event.stopPropagation();\n  }\n\n  if (!_.isEmpty(data.setDragImage)) {\n    event.dataTransfer.setDragImage(data.setDragImage.dragImage, data.setDragImage.xOffset, data.setDragImage.yOffset);\n  }\n};\n\nexport const areDnDHandelersDefined = function (declViewModel) {\n  let dragProviders = _.get(declViewModel, DRAG_HANDLERS);\n\n  let dropProviders = _.get(declViewModel, DROP_HANDLERS);\n\n  return dragProviders || dropProviders;\n};\n/**\n * Setup drag and drop listners on the element if drag and drophandlers are defined on the declViewModel\n * @param {Element} element: The DOM element on which the drag and drop listeners are to be attached.\n *\n * @param {Object} callbackAPIs:Callback functions used for various reasons of interaction with the\n *            container(element).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @param {Object} dataProvider: The dataProvider associated with the widget(if applicable)\n */\n\nexport const setupDragAndDrop = function (declViewModel, declObj, getProps) {\n  let dragProviders = _.get(declViewModel, DRAG_HANDLERS);\n\n  let dropProviders = _.get(declViewModel, DROP_HANDLERS);\n\n  const processDnDParamsAndGetCtxNode = (declViewModel, event, target, callbackAPIs, dataProvider) => {\n    let dataCtxNode = { ...declObj,\n      props: getProps()\n    };\n    let obj = [];\n\n    if (target.targetVMO && target.targetVMO.length > 0) {\n      obj = target.targetVMO;\n    } else if (declViewModel.vmo) {\n      obj = [declViewModel.vmo];\n    }\n\n    if (!dataCtxNode) {\n      dataCtxNode = {};\n    }\n\n    dataCtxNode.dragAndDropParams = {\n      event: event,\n      targetElement: target.targetElement,\n      targetObjects: obj,\n      declViewModel,\n      callbackAPIs,\n      dataProvider\n    };\n    return dataCtxNode;\n  };\n\n  const executeHandler = (declViewModel, handlerAction, dataCtxNode, event) => {\n    let action = getAction(declViewModel, handlerAction);\n\n    if (!action) {\n      logger.error('Missing action definition for ' + handlerAction);\n      return;\n    }\n\n    let depModuleObj = _.get(declViewModel, PRE_LOADED_DEPS);\n\n    let retData = actionService.performActionSync(declViewModel, action, dataCtxNode, depModuleObj[action.deps]);\n\n    if (retData) {\n      processDnDEvent(retData, event);\n    }\n  };\n\n  const getEventCallbackFn = function (handlerAction, event) {\n    let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callbackAPIs = arguments.length > 3 ? arguments[3] : undefined;\n    let dataProvider = arguments.length > 4 ? arguments[4] : undefined;\n\n    if (target.targetElement && target.targetElement.nodeName.toLowerCase() !== 'aw-include') {\n      event.stopPropagation();\n    } //setting a flag on declVM indicate that a that an element from it is being dragged\n    //This is mainly required to prevent selection of a list cell the list when it is dragged\n\n\n    if (event.type === 'dragstart') {\n      declViewModel._swDragging = true;\n    }\n\n    if ((event.type === 'dragend' || event.type === 'drop') && declViewModel._swDragging) {\n      delete declViewModel._swDragging;\n    }\n\n    let dataCtxNode = processDnDParamsAndGetCtxNode(declViewModel, event, target, callbackAPIs, dataProvider);\n\n    if (handlerAction && handlerAction !== '') {\n      executeHandler(declViewModel, handlerAction, dataCtxNode, event);\n    }\n  };\n\n  let dndHandler = null;\n\n  if (dragProviders || dropProviders) {\n    dndHandler = {};\n\n    const createCallback = (eventType, handlerAction) => {\n      let callBackFn = getEventCallbackFn.bind(null, handlerAction);\n      dndHandler[eventType] = callBackFn;\n    };\n\n    const createEventListener = providers => {\n      Object.keys(providers).forEach(providerName => {\n        createCallback(providerName.toLowerCase(), providers[providerName]);\n      });\n    };\n\n    if (dragProviders) {\n      createEventListener(dragProviders);\n    }\n\n    if (dropProviders) {\n      createEventListener(dropProviders);\n    }\n  }\n\n  declViewModel.dndHandler = dndHandler;\n};\n/**\n * Process the active drag and drop handlers on the declViewModel, if any. Also sets up the drag and drop\n * listners of the view element if active drop handler is found.\n * lement).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @returns {Boolean} Returns whether or not active drop handler is defined for the view.\n */\n\nexport const setupDragAndDropOnView = function (declViewModel) {\n  let activeHandler = null;\n\n  if (!dragDropConfig) {\n    return false;\n  }\n\n  let currentViewName = _.get(declViewModel, '_internal.viewId');\n\n  const isHandlerActiveForView = (viewName, handlerType) => {\n    let handlers = viewHandlersMap.get(viewName);\n\n    if (handlers && handlers[handlerType].length) {\n      return handlers[handlerType].some(handlerObj => {\n        if (evaluateActiveWhen(handlerObj, dragDropConfig, declViewModel)) {\n          activeHandler = handlerObj;\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return false;\n  };\n\n  const attachDefaultHandler = (handlerPath, handlerName, handlerActionKey) => {\n    let handler = _.get(dragDropConfig, handlerName);\n\n    if (handler && handler.views[0] === '*' && evaluateActiveWhen(handler, dragDropConfig, declViewModel)) {\n      setDragAndDropHandlersOnVM(declViewModel, handlerPath, handler[handlerActionKey], dragDropConfig.actions);\n    }\n  };\n\n  let isDragHandlerActive = isHandlerActiveForView(currentViewName, 'dragHandlers');\n\n  if (isDragHandlerActive && activeHandler) {\n    setDragAndDropHandlersOnVM(declViewModel, DRAG_HANDLERS, activeHandler.handlers, dragDropConfig.actions);\n  } else if (!isDragHandlerActive && defaultDragHandler) {\n    attachDefaultHandler(DRAG_HANDLERS, 'dragHandlers.' + defaultDragHandler, 'dragActions');\n  }\n\n  activeHandler = null;\n  let isDropHandlerActive = isHandlerActiveForView(currentViewName, 'dropHandlers');\n\n  if (isDropHandlerActive && activeHandler) {\n    setDragAndDropHandlersOnVM(declViewModel, DROP_HANDLERS, activeHandler.handlers, dragDropConfig.actions);\n  } else if (!isDropHandlerActive && defaultDropHandler) {\n    attachDefaultHandler(DROP_HANDLERS, 'dropHandlers.' + defaultDropHandler, 'dropActions');\n  }\n\n  return true;\n};\nexport const getDragHandler = function (declViewModel) {\n  return _.get(declViewModel, DRAG_HANDLERS);\n};\nexport const getDropHandler = function (declViewModel) {\n  return _.get(declViewModel, DROP_HANDLERS);\n};\nexport const updateDeps = function (declViewModel) {\n  const setPreLoadedDepsOnVM = (declViewModel, deps) => {\n    let loadedDeps = _.get(declViewModel, PRE_LOADED_DEPS);\n\n    if (!loadedDeps) {\n      _.set(declViewModel, PRE_LOADED_DEPS, deps);\n    } else {\n      Object.assign(declViewModel._internal.preLoadedDeps, deps);\n    }\n  };\n\n  const getDeps = async depsToPreLoad => {\n    let dependenciesToPreload = {};\n    let depTobBeLoaded = [];\n    depsToPreLoad.forEach(depToLoad => {\n      if (dependenciesToPreload[depToLoad]) {\n        return;\n      }\n\n      depTobBeLoaded.push(depToLoad);\n    });\n\n    if (depTobBeLoaded.length) {\n      let depModuleObjs = await moduleLoader.loadDependentModules(depTobBeLoaded);\n\n      if (depModuleObjs) {\n        _.forEach(depModuleObjs, (value, key) => {\n          dependenciesToPreload['js/' + key] = value;\n        });\n      }\n    }\n\n    return dependenciesToPreload;\n  };\n\n  let depsToLoad = _.get(declViewModel, DEPS_TO_LOAD);\n\n  if (depsToLoad) {\n    getDeps(depsToLoad).then(deps => {\n      setPreLoadedDepsOnVM(declViewModel, deps);\n    });\n  }\n};\n\nconst highlightView = eventData => {\n  const isViewElement = element => {\n    return element.classList.contains('aw-widgets-droppable');\n  };\n\n  if (!_.isUndefined(eventData) && !_.isUndefined(eventData.targetElement) && isViewElement(eventData.targetElement)) {\n    var isHighlightFlag = eventData.isHighlightFlag;\n    var target = eventData.targetElement;\n\n    if (isHighlightFlag) {\n      target.classList.add('aw-widgets-dropframe');\n      target.classList.add('aw-theme-dropframe');\n    } else {\n      target.classList.remove('aw-theme-dropframe');\n      target.classList.remove('aw-widgets-dropframe');\n    }\n  }\n};\n\nconst callBackAPIsForView = {\n  highlightTarget: highlightView,\n  getTargetElementAndVmo: event => {\n    let target = eleRef.closest(event.target, '.aw-widgets-droppable');\n    return {\n      targetElement: target,\n      targetVMO: null\n    };\n  }\n}; //  fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );\n\nexport const setViewDnd = function (dndHandlers) {\n  var obj = {};\n\n  let callBackForView = event => {\n    let target = eleRef.closest(event.target, '.aw-widgets-droppable');\n\n    if (dndHandlers && dndHandlers[event.type]) {\n      let fun = dndHandlers[event.type];\n      fun(event, {\n        targetElement: target,\n        targetVMO: []\n      }, callBackAPIsForView, null);\n    }\n  };\n\n  Object.keys(dndHandlers).forEach(providerName => {\n    obj[dndAttr[providerName]] = callBackForView;\n  });\n  return obj;\n};\n\nconst initialization = () => {\n  loadConfiguration();\n  createDragAndDropHandlersMap(); //Attach event listner to block the drop effect on the page for files\n  //attachDocEventListners();\n};\n\ninitialization();\nexports = {\n  updateDeps,\n  setupDragAndDropOnView,\n  setupDragAndDrop,\n  getDragHandler,\n  getDropHandler,\n  areDnDHandelersDefined,\n  setDragAndDropHandlersOnVM,\n  initialization,\n  // exporting this method so that this service is testable\n  setViewDnd\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/declDragAndDropService.js"],"names":["eleRef","domUtils","PRE_LOADED_DEPS","DRAG_HANDLERS","DROP_HANDLERS","DEPS_TO_LOAD","dndAttr","dragstart","dragenter","dragleave","dragover","drop","dragend","defaultDragHandler","defaultDropHandler","dragDropConfig","viewHandlersMap","loadConfiguration","cfgSvc","defaultDragAndDropConfig","awConfiguration","createDragAndDropHandlersMap","setViewHandlers","key","handlerkey","dragHandlers","dropHandlers","def","obj","_","handlerDef","hkey","viewHandlerDef","condition","handlers","processHandlers","handlerName","viewName","getTargetEleAndVMOs","target","isSourceEle","event","callbackAPIs","targetElement","targetObjects","targetVMO","getAction","dragAndDropInput","action","dndParams","inputData","evaluateActiveWhen","handlerObj","declViewModel","Object","data","ctx","appCtxSvc","clauseName","conditionList","dragAndDropConfig","attachDocEventListners","setDropEffect","document","setDragAndDropHandlersOnVM","setDnDActionsOnVM","declVmActions","getHandlerActionsAndDepsToLoad","activeHandlerActions","depsToLoad","handlerActions","actionName","actionDef","actionsDefs","found","dep","handlerDeps","processDnDEvent","areDnDHandelersDefined","dragProviders","dropProviders","setupDragAndDrop","processDnDParamsAndGetCtxNode","dataCtxNode","props","getProps","dataProvider","executeHandler","logger","depModuleObj","retData","actionService","getEventCallbackFn","handlerAction","dndHandler","createCallback","callBackFn","createEventListener","providers","providerName","setupDragAndDropOnView","activeHandler","currentViewName","isHandlerActiveForView","attachDefaultHandler","handler","isDragHandlerActive","isDropHandlerActive","getDragHandler","getDropHandler","updateDeps","setPreLoadedDepsOnVM","loadedDeps","getDeps","dependenciesToPreload","depTobBeLoaded","depsToPreLoad","depToLoad","depModuleObjs","moduleLoader","deps","highlightView","eventData","isViewElement","element","isHighlightFlag","callBackAPIsForView","highlightTarget","getTargetElementAndVmo","setViewDnd","callBackForView","dndHandlers","fun","initialization","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is responsible to process drag and drop handlers on the declViewModel if drag and\n * drop configuration is defined for that particular view.\n * It is also responsible to attach the drag and drop listners to applicable views and widgets.\n *\n * @module js/declDragAndDropService\n */\n\nimport cfgSvc from 'js/configurationService';\nimport moduleLoader from 'js/moduleLoader';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport appCtxSvc from 'js/appCtxService';\nimport conditionSvc from 'js/conditionService';\nimport logger from 'js/logger';\nimport domUtils from 'js/domUtils';\nimport awConfiguration from 'js/awConfiguration';\nconst eleRef = domUtils.DOMAPIs;\n\nlet exports;\n\nconst PRE_LOADED_DEPS = '_internal.preLoadedDeps';\nconst DRAG_HANDLERS = '_internal.dragHandlers';\nconst DROP_HANDLERS = '_internal.dropHandlers';\nconst DEPS_TO_LOAD = '_internal.depsToLoad';\n\nconst dndAttr = {\n    dragstart: 'onDrag',\n    dragenter: 'onDragEnter',\n    dragleave: 'onDragLeave',\n    dragover: 'onDragOver',\n    drop: 'onDrop',\n    dragend: 'onDragEnd'\n};\n\nlet defaultDragHandler = null;\nlet defaultDropHandler = null;\nlet dragDropConfig = null;\nlet viewHandlersMap = new Map();\n\nconst loadConfiguration = () => {\n    /*\n     * Get the drag and drop configuration\n     */\n    dragDropConfig = cfgSvc.getCfgCached( 'dragAndDrop' );\n    let defaultDragAndDropConfig = awConfiguration.get( 'solutionDef.defaultDragAndDropHandlers' );\n    if( defaultDragAndDropConfig && defaultDragAndDropConfig !== '{{defaultDragAndDropHandlers}}' ) {\n        defaultDragHandler = defaultDragAndDropConfig.dragHandler !== '' ? defaultDragAndDropConfig.dragHandler : null;\n        defaultDropHandler = defaultDragAndDropConfig.dropHandler !== '' ? defaultDragAndDropConfig.dropHandler : null;\n    }\n};\n\nconst createDragAndDropHandlersMap = () => {\n    const setViewHandlers = ( viewName, handlerDef, handlerkey ) => {\n        let key = handlerkey === 'dragActions' ? 'dragHandlers' : 'dropHandlers';\n\n        if( !viewHandlersMap.has( viewName ) ) {\n            viewHandlersMap.set( viewName, {\n                dragHandlers: [],\n                dropHandlers: []\n            } );\n        }\n        let def = viewHandlersMap.get( viewName );\n\n        let obj = {};\n\n        _.forOwn( handlerDef[ handlerkey ], function( value, hkey ) {\n            obj[ hkey.toLowerCase() ] = value;\n        } );\n\n        let viewHandlerDef = {\n            condition: {},\n            handlers: obj\n        };\n        if( handlerDef.activeWhen ) {\n            viewHandlerDef.condition.activeWhen = handlerDef.activeWhen;\n        }\n        def[ key ].push( viewHandlerDef );\n    };\n\n    const processHandlers = ( handlers, handlerkey ) => {\n        _.forEach( handlers, ( handlerDef, handlerName ) => {\n            if( handlerName === defaultDragHandler || handlerName === defaultDropHandler ) {\n                return;\n            }\n            _.forEach( handlerDef.views, ( viewName ) => {\n                setViewHandlers( viewName, handlerDef, handlerkey );\n            } );\n        } );\n    };\n    if( dragDropConfig ) {\n        let handlers = dragDropConfig.dragHandlers;\n        processHandlers( handlers, 'dragActions' );\n        handlers = dragDropConfig.dropHandlers;\n        processHandlers( handlers, 'dropActions' );\n    }\n};\n\nconst getTargetEleAndVMOs = ( event, callbackAPIs ) => {\n    let target = {};\n    let isSourceEle = event.type === 'dragstart';\n    if( callbackAPIs.getTargetElementAndVmo ) {\n        target = callbackAPIs.getTargetElementAndVmo( event, isSourceEle );\n    }\n    return {\n        targetElement: target.targetElement,\n        targetObjects: target.targetVMO\n    };\n};\n\nconst getAction = ( declViewModel, actionName ) => {\n    const dragAndDropInput = '{{dragAndDropParams}}';\n    let action = _.get( declViewModel, '_internal.actions.' + actionName );\n\n    if( action ) {\n        //adding actionId ref to action object for consistency with declViewModel actions\n        action.actionId = actionName;\n        if( !action.inputData ) {\n            _.set( action, 'inputData', { dndParams: dragAndDropInput } );\n        } else {\n            let inputData = { ...action.inputData, dndParams: dragAndDropInput };\n            _.set( action, 'inputData', inputData );\n        }\n        return action;\n    }\n    return null;\n};\n\nconst evaluateActiveWhen = ( handlerObj, dragAndDropConfig, declViewModel ) => {\n    if( handlerObj.condition ) {\n        handlerObj = handlerObj.condition;\n    }\n    if( !handlerObj.activeWhen ) {\n        return true;\n    }\n\n    if( declViewModel.dataProviders && Object.keys( declViewModel.dataProviders ).length === 0 ) {\n        declViewModel.dataProviders = null;\n    }\n    return conditionSvc.evaluateConditionExpression( handlerObj, { data: declViewModel, ctx: appCtxSvc.ctx }, { clauseName: 'activeWhen', conditionList: dragAndDropConfig } );\n};\n\n/*\n * Attaching dragenter, dragover and drop listners at the document level\n * These listners are mainly required for file drag and drop. Whenever a file is dragged from Os to the browser, by\n * default the effectAllowed property that is set by OS(defaults to copy/move depending on the file type) will be set\n * as the dropEffect.\n * So as soon as the file is dragged on browser, the default dropEffect would be enabled(copy/move) and thus drop is enabled\n * if the no events listners for drag and drop are defined for the particular part of the page. Further the default browser behavior\n * to open the dropped file would be performed.\n *\n * These listners basically set the drop effect to false during dragenter and dragover phase, thus preventing drop.\n *\n * Note: A file specific check is not added during dragenter and dragover phase as doing so would lead to undefined dropEffect\n * state(instead of block) for objects that are being dragged on non-droppable drop areas.\n */\nconst attachDocEventListners = () => {\n    const setDropEffect = ( event ) => {\n        event.stopPropagation();\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'none';\n    };\n    document.addEventListener( 'dragover', setDropEffect );\n    document.addEventListener( 'dragenter', setDropEffect );\n    document.addEventListener( 'drop', setDropEffect );\n};\n\nconst setDragAndDropHandlersOnVM = ( declViewModel, path, activeHandlerActions, actionsDefs ) => {\n    const setDnDActionsOnVM = ( declViewModel, handlerActions ) => {\n        let declVmActions = _.get( declViewModel, '_internal.actions' );\n        if( !declVmActions ) {\n            _.set( declViewModel, '_internal.actions', handlerActions );\n        } else {\n            Object.assign( declVmActions, handlerActions );\n        }\n    };\n\n    const getHandlerActionsAndDepsToLoad = ( activeHandlerActions ) => {\n        let depsToLoad = [];\n        let handlerActions = {};\n        _.forEach( activeHandlerActions, ( actionName ) => {\n            let actionDef = actionsDefs[ actionName ];\n            if( !actionDef ) {\n                return;\n            }\n            handlerActions[ actionName ] = actionDef;\n            let found = depsToLoad.some( ( dep ) => dep === actionDef.deps );\n            if( !found ) {\n                depsToLoad.push( actionDef.deps );\n            }\n        } );\n        return {\n            handlerActions,\n            depsToLoad\n        };\n    };\n\n    //Set drag and drop handler references on the declViewModel\n    //These handler references will be used by widgets to setup drag and drop\n    _.set( declViewModel, path, activeHandlerActions );\n\n    let handlers = getHandlerActionsAndDepsToLoad( activeHandlerActions );\n\n    setDnDActionsOnVM( declViewModel, handlers.handlerActions );\n\n    let handlerDeps = _.get( declViewModel, DEPS_TO_LOAD ) ? _.get( declViewModel, DEPS_TO_LOAD ) : [];\n    handlerDeps = [ ...new Set( [ ...handlerDeps, ...handlers.depsToLoad ] ) ];\n    _.set( declViewModel, DEPS_TO_LOAD, handlerDeps );\n};\n\nconst processDnDEvent = ( data, event ) => {\n    if( data.effectAllowed ) {\n        event.dataTransfer.effectAllowed = data.effectAllowed;\n    }\n\n    if( data.dropEffect ) {\n        event.dataTransfer.dropEffect = data.dropEffect;\n    }\n\n    if( data.preventDefault ) {\n        event.preventDefault();\n    }\n\n    if( data.stopPropagation ) {\n        event.stopPropagation();\n    }\n\n    if( !_.isEmpty( data.setDragImage ) ) {\n        event.dataTransfer.setDragImage( data.setDragImage.dragImage, data.setDragImage.xOffset, data.setDragImage.yOffset );\n    }\n};\n\nexport const areDnDHandelersDefined = function( declViewModel ) {\n    let dragProviders = _.get( declViewModel, DRAG_HANDLERS );\n    let dropProviders = _.get( declViewModel, DROP_HANDLERS );\n    return dragProviders || dropProviders;\n};\n\n/**\n * Setup drag and drop listners on the element if drag and drophandlers are defined on the declViewModel\n * @param {Element} element: The DOM element on which the drag and drop listeners are to be attached.\n *\n * @param {Object} callbackAPIs:Callback functions used for various reasons of interaction with the\n *            container(element).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @param {Object} dataProvider: The dataProvider associated with the widget(if applicable)\n */\nexport const setupDragAndDrop = function( declViewModel, declObj, getProps ) {\n    let dragProviders = _.get( declViewModel, DRAG_HANDLERS );\n    let dropProviders = _.get( declViewModel, DROP_HANDLERS );\n    const processDnDParamsAndGetCtxNode = ( declViewModel, event, target, callbackAPIs, dataProvider ) => {\n        let dataCtxNode = { ...declObj, props: getProps() };\n        let obj = [];\n        if( target.targetVMO && target.targetVMO.length > 0 ) {\n            obj = target.targetVMO;\n        } else if( declViewModel.vmo ) {\n            obj = [ declViewModel.vmo ];\n        }\n        if( !dataCtxNode ) {\n            dataCtxNode = {};\n        }\n        dataCtxNode.dragAndDropParams = {\n            event: event,\n            targetElement: target.targetElement,\n            targetObjects: obj,\n            declViewModel,\n            callbackAPIs,\n            dataProvider\n        };\n        return dataCtxNode;\n    };\n    const executeHandler = ( declViewModel, handlerAction, dataCtxNode, event ) => {\n        let action = getAction( declViewModel, handlerAction );\n        if( !action ) {\n            logger.error( 'Missing action definition for ' + handlerAction );\n            return;\n        }\n        let depModuleObj = _.get( declViewModel, PRE_LOADED_DEPS );\n        let retData = actionService.performActionSync( declViewModel, action, dataCtxNode, depModuleObj[ action.deps ] );\n        if( retData ) {\n            processDnDEvent( retData, event );\n        }\n    };\n    const getEventCallbackFn = ( handlerAction, event, target = {}, callbackAPIs, dataProvider ) => {\n        if( target.targetElement && target.targetElement.nodeName.toLowerCase() !== 'aw-include' ) {\n            event.stopPropagation();\n        }\n        //setting a flag on declVM indicate that a that an element from it is being dragged\n        //This is mainly required to prevent selection of a list cell the list when it is dragged\n        if( event.type === 'dragstart' ) {\n            declViewModel._swDragging = true;\n        }\n        if( ( event.type === 'dragend' || event.type === 'drop' ) && declViewModel._swDragging ) {\n            delete declViewModel._swDragging;\n        }\n        let dataCtxNode = processDnDParamsAndGetCtxNode( declViewModel, event, target, callbackAPIs, dataProvider );\n        if( handlerAction && handlerAction !== '' ) {\n            executeHandler( declViewModel, handlerAction, dataCtxNode, event );\n        }\n    };\n    let dndHandler = null;\n    if( dragProviders || dropProviders ) {\n        dndHandler = {};\n        const createCallback = ( eventType, handlerAction ) => {\n            let callBackFn = getEventCallbackFn.bind( null, handlerAction );\n            dndHandler[ eventType ] = callBackFn;\n        };\n        const createEventListener = ( providers ) => {\n            Object.keys( providers ).forEach( ( providerName ) => {\n                createCallback( providerName.toLowerCase(), providers[ providerName ] );\n            } );\n        };\n        if( dragProviders ) {\n            createEventListener( dragProviders );\n        }\n        if( dropProviders ) {\n            createEventListener( dropProviders );\n        }\n    }\n    declViewModel.dndHandler = dndHandler;\n};\n\n/**\n * Process the active drag and drop handlers on the declViewModel, if any. Also sets up the drag and drop\n * listners of the view element if active drop handler is found.\n * lement).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @returns {Boolean} Returns whether or not active drop handler is defined for the view.\n */\nexport const setupDragAndDropOnView = function( declViewModel ) {\n    let activeHandler = null;\n    if( !dragDropConfig ) {\n        return false;\n    }\n    let currentViewName = _.get( declViewModel, '_internal.viewId' );\n    const isHandlerActiveForView = ( viewName, handlerType ) => {\n        let handlers = viewHandlersMap.get( viewName );\n        if( handlers && handlers[ handlerType ].length ) {\n            return handlers[ handlerType ].some( ( handlerObj ) => {\n                if( evaluateActiveWhen( handlerObj, dragDropConfig, declViewModel ) ) {\n                    activeHandler = handlerObj;\n                    return true;\n                }\n                return false;\n            } );\n        }\n        return false;\n    };\n    const attachDefaultHandler = ( handlerPath, handlerName, handlerActionKey ) => {\n        let handler = _.get( dragDropConfig, handlerName );\n        if( handler && handler.views[ 0 ] === '*' && evaluateActiveWhen( handler, dragDropConfig, declViewModel ) ) {\n            setDragAndDropHandlersOnVM( declViewModel, handlerPath, handler[ handlerActionKey ], dragDropConfig.actions );\n        }\n    };\n    let isDragHandlerActive = isHandlerActiveForView( currentViewName, 'dragHandlers' );\n    if( isDragHandlerActive && activeHandler ) {\n        setDragAndDropHandlersOnVM( declViewModel, DRAG_HANDLERS, activeHandler.handlers, dragDropConfig.actions );\n    } else if( !isDragHandlerActive && defaultDragHandler ) {\n        attachDefaultHandler( DRAG_HANDLERS, 'dragHandlers.' + defaultDragHandler, 'dragActions' );\n    }\n    activeHandler = null;\n    let isDropHandlerActive = isHandlerActiveForView( currentViewName, 'dropHandlers' );\n    if( isDropHandlerActive && activeHandler ) {\n        setDragAndDropHandlersOnVM( declViewModel, DROP_HANDLERS, activeHandler.handlers, dragDropConfig.actions );\n    } else if( !isDropHandlerActive && defaultDropHandler ) {\n        attachDefaultHandler( DROP_HANDLERS, 'dropHandlers.' + defaultDropHandler, 'dropActions' );\n    }\n    return true;\n};\n\nexport const getDragHandler = function( declViewModel ) {\n    return _.get( declViewModel, DRAG_HANDLERS );\n};\n\nexport const getDropHandler = function( declViewModel ) {\n    return _.get( declViewModel, DROP_HANDLERS );\n};\n\nexport const updateDeps = function( declViewModel ) {\n    const setPreLoadedDepsOnVM = ( declViewModel, deps ) => {\n        let loadedDeps = _.get( declViewModel, PRE_LOADED_DEPS );\n        if( !loadedDeps ) {\n            _.set( declViewModel, PRE_LOADED_DEPS, deps );\n        } else {\n            Object.assign( declViewModel._internal.preLoadedDeps, deps );\n        }\n    };\n\n    const getDeps = async( depsToPreLoad ) => {\n        let dependenciesToPreload = {};\n        let depTobBeLoaded = [];\n\n        depsToPreLoad.forEach( ( depToLoad ) => {\n            if( dependenciesToPreload[ depToLoad ] ) {\n                return;\n            }\n            depTobBeLoaded.push( depToLoad );\n        } );\n\n        if( depTobBeLoaded.length ) {\n            let depModuleObjs = await moduleLoader.loadDependentModules( depTobBeLoaded );\n            if( depModuleObjs ) {\n                _.forEach( depModuleObjs, ( value, key ) => {\n                    dependenciesToPreload[ 'js/' + key ] = value;\n                } );\n            }\n        }\n        return dependenciesToPreload;\n    };\n    let depsToLoad = _.get( declViewModel, DEPS_TO_LOAD );\n    if( depsToLoad ) {\n        getDeps( depsToLoad ).then( ( deps ) => {\n            setPreLoadedDepsOnVM( declViewModel, deps );\n        } );\n    }\n};\n\nconst highlightView = ( eventData ) => {\n    const isViewElement = ( element ) => {\n        return element.classList.contains( 'aw-widgets-droppable' );\n    };\n    if( !_.isUndefined( eventData ) && !_.isUndefined( eventData.targetElement ) && isViewElement( eventData.targetElement ) ) {\n        var isHighlightFlag = eventData.isHighlightFlag;\n        var target = eventData.targetElement;\n        if( isHighlightFlag ) {\n            target.classList.add( 'aw-widgets-dropframe' );\n            target.classList.add( 'aw-theme-dropframe' );\n        } else {\n            target.classList.remove( 'aw-theme-dropframe' );\n            target.classList.remove( 'aw-widgets-dropframe' );\n        }\n    }\n};\n\nconst callBackAPIsForView = {\n    highlightTarget: highlightView,\n    getTargetElementAndVmo: ( event ) => {\n        let target = eleRef.closest( event.target, '.aw-widgets-droppable' );\n        return {\n            targetElement: target,\n            targetVMO: null\n        };\n    }\n};\n\n//  fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );\nexport const setViewDnd = function( dndHandlers ) {\n    var obj = {};\n    let callBackForView = ( event ) => {\n        let target = eleRef.closest( event.target, '.aw-widgets-droppable' );\n        if( dndHandlers && dndHandlers[ event.type ] ) {\n            let fun = dndHandlers[ event.type ];\n            fun( event, { targetElement: target, targetVMO: [] }, callBackAPIsForView, null );\n        }\n    };\n    Object.keys( dndHandlers ).forEach( ( providerName ) => {\n        obj[ dndAttr[ providerName ] ] = callBackForView;\n    } );\n    return obj;\n};\n\nconst initialization = () => {\n    loadConfiguration();\n    createDragAndDropHandlersMap();\n    //Attach event listner to block the drop effect on the page for files\n    //attachDocEventListners();\n};\ninitialization();\n\nexports = {\n    updateDeps,\n    setupDragAndDropOnView,\n    setupDragAndDrop,\n    getDragHandler,\n    getDropHandler,\n    areDnDHandelersDefined,\n    setDragAndDropHandlersOnVM,\n    initialization, // exporting this method so that this service is testable\n    setViewDnd\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}