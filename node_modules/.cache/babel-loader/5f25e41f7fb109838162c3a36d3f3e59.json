{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context\n *\n * @publishedApolloService\n *\n * @module js/conditionService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport adapterService from 'js/adapterService';\nimport expressionParserUtils from 'js/expressionParserUtils';\nvar exports = {};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Any} The evaluated expression result.\n */\n\nexport let parseExpression = function (declViewModel, expression, evaluationEnv, depModuleObj) {\n  var evaluationContext = {};\n\n  _.assign(evaluationContext, declViewModel, evaluationEnv, depModuleObj);\n\n  if (_.isObject(expression)) {\n    // loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values\n    var updatedExpression = expressionParserUtils.updateDynamicValues(expression, evaluationContext);\n    return expressionParserUtils.evaluateExpressions(updatedExpression, evaluationContext, adapterService);\n  }\n\n  return AwParseService.instance(expression)(evaluationContext);\n};\n/**\n * Evaluate condition expression and ensure a boolean is returned\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Boolean} The evaluated condition result.\n */\n\nexport let evaluateCondition = function (declViewModel, expression, evaluationEnv, depModuleObj) {\n  return Boolean(exports.parseExpression(declViewModel, expression, evaluationEnv, depModuleObj));\n};\n\nconst _evaluateConditionBasedExpression = function (condition, declViewModel, evaluateDepParams) {\n  var finalConditionExpression;\n\n  if (_.startsWith(condition, 'conditions.')) {\n    if (declViewModel._internal) {\n      finalConditionExpression = _.get(declViewModel._internal, condition);\n    } else {\n      finalConditionExpression = _.get(evaluateDepParams.conditionList, condition);\n    }\n  } // for condition\": 'ctx.xyz || ctx.abc' or condition\": '!ctx.xyz' or condition\": '!conditions.xyz'\n\n\n  if (finalConditionExpression === undefined) {\n    finalConditionExpression = condition;\n  } else if (finalConditionExpression.expression) {\n    finalConditionExpression = finalConditionExpression.expression;\n  }\n\n  if (evaluateDepParams) {\n    return evaluateCondition(declViewModel, finalConditionExpression, evaluateDepParams.evaluationEnv, evaluateDepParams.depModuleObj);\n  }\n\n  return evaluateCondition(declViewModel, finalConditionExpression);\n};\n/**\n * Evaluate all variants of condition\n *\n * @param {String} condition - condition to evaluate\n * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object\n * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb\n *                                {Object} conditionList- Conditions object of viewmodel\n *                                {String} clauseName -\"activewhen\",\"visiblewhen\"\n *                                {Object} evaluationEnv -specific data required for this call like ctx.\n *                                {Object} depModuleObj\n * @return {Boolean} return true, if expression evalutes to true.\n */\n\n\nexport let evaluateConditionExpression = function (condition, declViewModel, evaluateDepParams) {\n  if (evaluateDepParams && typeof condition[evaluateDepParams.clauseName] === 'boolean') {\n    return condition[evaluateDepParams.clauseName];\n    /*\n     *    activewhen: true\n     */\n  } else if (evaluateDepParams && condition[evaluateDepParams.clauseName]) {\n    condition = _.get(condition, evaluateDepParams.clauseName + '.condition');\n\n    if (typeof condition === 'boolean') {\n      return condition;\n    }\n  }\n\n  if (condition && condition.length) {\n    /*\n      evaluate * conditions expression\n      *: {\n          condition: \"conditions.xyz\"\n      }\n      */\n    return _evaluateConditionBasedExpression(condition, declViewModel, evaluateDepParams);\n  }\n\n  return false;\n};\n/**\n * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of\n * the condition differs from the old value\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} queries - The array of objects containing query definitions\n * @param {Array} values - The array of objects of changed value to be used for each of the query object\n * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage\n * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed\n * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.\n * @param {Object} trackValues - Whether or not to track expression value changes.\n */\n\nlet processWatch = function (conditionStates, conditionName, queries, values, adaptExpressions, performAnd, conditionExpressions, trackValues, viewModelName) {\n  var oldValue = conditionStates[conditionName];\n  var newValue = queries.reduce(function (prevVerdict, currQuery, queryIndex) {\n    var verdict;\n    var valuesToUse = values[queryIndex];\n\n    if (currQuery && _.isObject(currQuery) && values && values.length === queries.length) {\n      // determine whether object requires to be adapted\n      if (adaptExpressions[queryIndex]) {\n        var valuesToAdapt = _.isArray(valuesToUse) ? valuesToUse : [valuesToUse];\n        valuesToUse = adapterService.getAdaptedObjectsSync(valuesToAdapt);\n      } // expression is an object, hence process the query object inside it\n\n\n      verdict = expressionParserUtils.evaluateExpressions(currQuery, valuesToUse, adapterService);\n    } else {\n      // expression is simple string with boolean result\n      verdict = Boolean(values && valuesToUse);\n    }\n\n    var newExpressionValue = valuesToUse;\n    var conditionVal;\n\n    if (conditionExpressions) {\n      conditionVal = conditionExpressions[conditionName];\n    }\n\n    if (trackValues && conditionExpressions && conditionVal[0] !== newExpressionValue) {\n      eventBus.publish('condition.expressionValueChanged', {\n        condition: 'conditions.' + conditionName,\n        oldValue: conditionExpressions[conditionName],\n        newValue: newExpressionValue\n      });\n    }\n\n    return performAnd ? prevVerdict && verdict : prevVerdict || verdict;\n  }, performAnd);\n\n  if (logger.isDeclarativeLogEnabled()) {\n    debugService.debugConditions(conditionName, newValue, queries, viewModelName);\n  }\n\n  if (oldValue !== newValue) {\n    eventBus.publish('condition.valueChanged', {\n      condition: 'conditions.' + conditionName,\n      oldValue: oldValue,\n      newValue: newValue\n    });\n  }\n};\n/**\n * Register a watch for given expression on provided scope and update conditionStates[conditionName] when\n * expression's value changes.\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} expressions - Array of expression to be watched for value change.\n * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.\n * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression\n * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback\n * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not\n * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing\n */\n\n\nexport let registerWatch = function (conditionStates, dataCtxNode, conditionName, expressions, conditionExpressions, queries, adaptExpressions, deepWatch, performAnd) {\n  if (!queries) {\n    var watchQueryAdaptInfo = {\n      watchers: [],\n      queries: [],\n      adapt: []\n    };\n    var multiAttributeANDExpression;\n    var multiAttributeORExpression;\n\n    _.forEach(expressions, function (expr) {\n      multiAttributeANDExpression = expr[expressionParserUtils.$AND];\n      multiAttributeORExpression = expr[expressionParserUtils.$OR];\n      var expressionsFinal = multiAttributeANDExpression || multiAttributeORExpression || expressions;\n\n      _.forEach(expressionsFinal, function (finalExpr) {\n        var sourceToWatch = expressionParserUtils.resolve(expressionParserUtils.$SOURCE, finalExpr);\n        var needsToAdapt = sourceToWatch && sourceToWatch[expressionParserUtils.$ADAPT];\n        sourceToWatch = needsToAdapt || sourceToWatch || finalExpr;\n        var executeQuery = expressionParserUtils.resolve(expressionParserUtils.$QUERY, finalExpr);\n        watchQueryAdaptInfo.watchers.push(sourceToWatch);\n        watchQueryAdaptInfo.queries.push(executeQuery || finalExpr);\n        watchQueryAdaptInfo.adapt.push(Boolean(needsToAdapt));\n      });\n    });\n\n    exports.registerWatch(conditionStates, dataCtxNode, conditionName, watchQueryAdaptInfo.watchers, conditionExpressions, watchQueryAdaptInfo.queries, watchQueryAdaptInfo.adapt, true, multiAttributeANDExpression);\n  } else {\n    // process expressions, queries and adaptExpressions array\n    var dynamicValueResolvedQueries = queries.map(function (query) {\n      return expressionParserUtils.updateDynamicValues(query, dataCtxNode);\n    }); // revisitme Charu - add support for trackChanges\n\n    processWatch(conditionStates, conditionName, dynamicValueResolvedQueries, dataCtxNode.expressions[conditionName], adaptExpressions, performAnd, conditionExpressions, dataCtxNode.declViewModelJson.conditions[conditionName].trackValues, dataCtxNode.declViewModelJson._viewModelId);\n  }\n};\n/**\n * Expand a string based expression to include nested conditions\n *\n * @param {String} expression - a string expression to evaluate\n * @param {Object} internalViewModel - the object containing other expressions\n * @returns {String} the new string expression\n */\n\nexport let getRealExpression = function (expression, internalViewModel) {\n  //Since getRealExpression() api operates on string expressions, object types should be filtered.\n  if (_.isString(expression)) {\n    var conditionIndex = expression.indexOf('conditions.');\n\n    if (conditionIndex > -1) {\n      var substring = expression.substring(conditionIndex);\n      var endConditionIndex = substring.search('[^a-zA-Z0-9._]');\n      endConditionIndex = endConditionIndex > -1 ? conditionIndex + endConditionIndex : expression.length;\n      var referenceCondition = expression.substring(conditionIndex, endConditionIndex);\n      var evaluatedCondition = _.get(internalViewModel, referenceCondition) || {};\n      var returnExpression = null;\n\n      if (_.isString(evaluatedCondition.expression)) {\n        returnExpression = expression.replace(referenceCondition, '(' + evaluatedCondition.expression + ')');\n      } else {\n        return evaluatedCondition.expression;\n      }\n\n      return getRealExpression(returnExpression, internalViewModel);\n    }\n\n    return expression;\n  }\n\n  return undefined;\n};\nexports = {\n  parseExpression,\n  registerWatch,\n  evaluateCondition,\n  evaluateConditionExpression,\n  getRealExpression\n};\nexport default exports;","map":{"version":3,"names":["_","logger","eventBus","debugService","AwParseService","adapterService","expressionParserUtils","exports","parseExpression","declViewModel","expression","evaluationEnv","depModuleObj","evaluationContext","assign","isObject","updatedExpression","updateDynamicValues","evaluateExpressions","instance","evaluateCondition","Boolean","_evaluateConditionBasedExpression","condition","evaluateDepParams","finalConditionExpression","startsWith","_internal","get","conditionList","undefined","evaluateConditionExpression","clauseName","length","processWatch","conditionStates","conditionName","queries","values","adaptExpressions","performAnd","conditionExpressions","trackValues","viewModelName","oldValue","newValue","reduce","prevVerdict","currQuery","queryIndex","verdict","valuesToUse","valuesToAdapt","isArray","getAdaptedObjectsSync","newExpressionValue","conditionVal","publish","isDeclarativeLogEnabled","debugConditions","registerWatch","dataCtxNode","expressions","deepWatch","watchQueryAdaptInfo","watchers","adapt","multiAttributeANDExpression","multiAttributeORExpression","forEach","expr","$AND","$OR","expressionsFinal","finalExpr","sourceToWatch","resolve","$SOURCE","needsToAdapt","$ADAPT","executeQuery","$QUERY","push","dynamicValueResolvedQueries","map","query","declViewModelJson","conditions","_viewModelId","getRealExpression","internalViewModel","isString","conditionIndex","indexOf","substring","endConditionIndex","search","referenceCondition","evaluatedCondition","returnExpression","replace"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/conditionService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context\n *\n * @publishedApolloService\n *\n * @module js/conditionService\n */\n\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport debugService from 'js/debugService';\nimport AwParseService from 'js/awParseService';\nimport adapterService from 'js/adapterService';\nimport expressionParserUtils from 'js/expressionParserUtils';\n\nvar exports = {};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Any} The evaluated expression result.\n */\nexport let parseExpression = function( declViewModel, expression, evaluationEnv, depModuleObj ) {\n    var evaluationContext = {};\n    _.assign( evaluationContext, declViewModel, evaluationEnv, depModuleObj );\n    if( _.isObject( expression ) ) {\n        // loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values\n        var updatedExpression = expressionParserUtils.updateDynamicValues( expression, evaluationContext );\n        return expressionParserUtils.evaluateExpressions( updatedExpression, evaluationContext, adapterService );\n    }\n\n    return AwParseService.instance( expression )( evaluationContext );\n};\n\n/**\n * Evaluate condition expression and ensure a boolean is returned\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.\n * @param {String} expression - Expression\n * @param {Object} evaluationEnv - The data environment for expression evaluation.\n * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.\n *\n * @return {Boolean} The evaluated condition result.\n */\nexport let evaluateCondition = function( declViewModel, expression, evaluationEnv, depModuleObj ) {\n    return Boolean( exports.parseExpression( declViewModel, expression, evaluationEnv, depModuleObj ) );\n};\n\nconst _evaluateConditionBasedExpression = function( condition, declViewModel, evaluateDepParams ) {\n    var finalConditionExpression;\n    if( _.startsWith( condition, 'conditions.' ) ) {\n        if( declViewModel._internal ) {\n            finalConditionExpression = _.get( declViewModel._internal, condition );\n        } else {\n            finalConditionExpression = _.get( evaluateDepParams.conditionList, condition );\n        }\n    }\n    // for condition\": 'ctx.xyz || ctx.abc' or condition\": '!ctx.xyz' or condition\": '!conditions.xyz'\n    if( finalConditionExpression === undefined ) {\n        finalConditionExpression = condition;\n    } else if( finalConditionExpression.expression ) {\n        finalConditionExpression = finalConditionExpression.expression;\n    }\n\n    if( evaluateDepParams ) {\n        return evaluateCondition( declViewModel, finalConditionExpression, evaluateDepParams.evaluationEnv, evaluateDepParams.depModuleObj );\n    }\n    return evaluateCondition( declViewModel, finalConditionExpression );\n};\n\n/**\n * Evaluate all variants of condition\n *\n * @param {String} condition - condition to evaluate\n * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object\n * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb\n *                                {Object} conditionList- Conditions object of viewmodel\n *                                {String} clauseName -\"activewhen\",\"visiblewhen\"\n *                                {Object} evaluationEnv -specific data required for this call like ctx.\n *                                {Object} depModuleObj\n * @return {Boolean} return true, if expression evalutes to true.\n */\nexport let evaluateConditionExpression = function( condition, declViewModel, evaluateDepParams ) {\n    if( evaluateDepParams && typeof condition[ evaluateDepParams.clauseName ] === 'boolean' ) {\n        return condition[ evaluateDepParams.clauseName ];\n        /*\n         *    activewhen: true\n         */\n    } else if( evaluateDepParams && condition[ evaluateDepParams.clauseName ] ) {\n        condition = _.get( condition, evaluateDepParams.clauseName + '.condition' );\n\n        if( typeof condition === 'boolean' ) {\n            return condition;\n        }\n    }\n    if( condition && condition.length ) {\n        /*\n          evaluate * conditions expression\n          *: {\n              condition: \"conditions.xyz\"\n          }\n          */\n        return _evaluateConditionBasedExpression( condition, declViewModel, evaluateDepParams );\n    }\n    return false;\n};\n\n/**\n * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of\n * the condition differs from the old value\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} queries - The array of objects containing query definitions\n * @param {Array} values - The array of objects of changed value to be used for each of the query object\n * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage\n * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed\n * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.\n * @param {Object} trackValues - Whether or not to track expression value changes.\n */\nlet processWatch = function( conditionStates, conditionName, queries, values, adaptExpressions, performAnd, conditionExpressions, trackValues, viewModelName ) {\n    var oldValue = conditionStates[ conditionName ];\n    var newValue = queries.reduce( function( prevVerdict, currQuery, queryIndex ) {\n        var verdict;\n        var valuesToUse = values[ queryIndex ];\n        if( currQuery && _.isObject( currQuery ) && values && values.length === queries.length ) {\n            // determine whether object requires to be adapted\n            if( adaptExpressions[ queryIndex ] ) {\n                var valuesToAdapt = _.isArray( valuesToUse ) ? valuesToUse : [ valuesToUse ];\n                valuesToUse = adapterService.getAdaptedObjectsSync( valuesToAdapt );\n            }\n            // expression is an object, hence process the query object inside it\n            verdict = expressionParserUtils.evaluateExpressions( currQuery, valuesToUse, adapterService );\n        } else {\n            // expression is simple string with boolean result\n            verdict = Boolean( values && valuesToUse );\n        }\n\n        var newExpressionValue = valuesToUse;\n        var conditionVal;\n        if( conditionExpressions ) {\n            conditionVal = conditionExpressions[ conditionName ];\n        }\n        if( trackValues && conditionExpressions && conditionVal[ 0 ] !== newExpressionValue ) {\n            eventBus.publish( 'condition.expressionValueChanged', {\n                condition: 'conditions.' + conditionName,\n                oldValue: conditionExpressions[ conditionName ],\n                newValue: newExpressionValue\n            } );\n        }\n        return performAnd ? prevVerdict && verdict : prevVerdict || verdict;\n    }, performAnd );\n\n    if( logger.isDeclarativeLogEnabled() ) {\n        debugService.debugConditions( conditionName, newValue, queries, viewModelName );\n    }\n\n    if( oldValue !== newValue ) {\n        eventBus.publish( 'condition.valueChanged', {\n            condition: 'conditions.' + conditionName,\n            oldValue: oldValue,\n            newValue: newValue\n        } );\n    }\n};\n\n/**\n * Register a watch for given expression on provided scope and update conditionStates[conditionName] when\n * expression's value changes.\n *\n * @param {Object} conditionStates - The set of conditions to announce any expression changes to.\n * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.\n * @param {String} conditionName - The name of the condition to update when the expression changes.\n * @param {Array} expressions - Array of expression to be watched for value change.\n * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.\n * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression\n * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback\n * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not\n * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing\n */\nexport let registerWatch = function( conditionStates, dataCtxNode, conditionName, expressions, conditionExpressions, queries, adaptExpressions, deepWatch, performAnd ) {\n    if( !queries ) {\n        var watchQueryAdaptInfo = {\n            watchers: [],\n            queries: [],\n            adapt: []\n        };\n\n        var multiAttributeANDExpression;\n        var multiAttributeORExpression;\n        _.forEach( expressions, function( expr ) {\n            multiAttributeANDExpression = expr[ expressionParserUtils.$AND ];\n            multiAttributeORExpression = expr[ expressionParserUtils.$OR ];\n\n            var expressionsFinal = multiAttributeANDExpression || multiAttributeORExpression || expressions;\n            _.forEach( expressionsFinal, function( finalExpr ) {\n                var sourceToWatch = expressionParserUtils.resolve( expressionParserUtils.$SOURCE, finalExpr );\n                var needsToAdapt = sourceToWatch && sourceToWatch[ expressionParserUtils.$ADAPT ];\n                sourceToWatch = needsToAdapt || sourceToWatch || finalExpr;\n\n                var executeQuery = expressionParserUtils.resolve( expressionParserUtils.$QUERY, finalExpr );\n                watchQueryAdaptInfo.watchers.push( sourceToWatch );\n                watchQueryAdaptInfo.queries.push( executeQuery || finalExpr );\n                watchQueryAdaptInfo.adapt.push( Boolean( needsToAdapt ) );\n            } );\n        } );\n\n        exports.registerWatch( conditionStates, dataCtxNode, conditionName, watchQueryAdaptInfo.watchers, conditionExpressions, watchQueryAdaptInfo.queries,\n            watchQueryAdaptInfo.adapt, true, multiAttributeANDExpression );\n    } else {\n        // process expressions, queries and adaptExpressions array\n        var dynamicValueResolvedQueries = queries.map( function( query ) {\n            return expressionParserUtils.updateDynamicValues( query, dataCtxNode );\n        } );\n\n        // revisitme Charu - add support for trackChanges\n        processWatch( conditionStates, conditionName, dynamicValueResolvedQueries, dataCtxNode.expressions[ conditionName ], adaptExpressions, performAnd, conditionExpressions, dataCtxNode\n            .declViewModelJson.conditions[\n                conditionName ].trackValues, dataCtxNode.declViewModelJson._viewModelId );\n    }\n};\n\n/**\n * Expand a string based expression to include nested conditions\n *\n * @param {String} expression - a string expression to evaluate\n * @param {Object} internalViewModel - the object containing other expressions\n * @returns {String} the new string expression\n */\nexport let getRealExpression = function( expression, internalViewModel ) {\n    //Since getRealExpression() api operates on string expressions, object types should be filtered.\n    if( _.isString( expression ) ) {\n        var conditionIndex = expression.indexOf( 'conditions.' );\n        if( conditionIndex > -1 ) {\n            var substring = expression.substring( conditionIndex );\n            var endConditionIndex = substring.search( '[^a-zA-Z0-9._]' );\n            endConditionIndex = endConditionIndex > -1 ? conditionIndex + endConditionIndex : expression.length;\n            var referenceCondition = expression.substring( conditionIndex, endConditionIndex );\n            var evaluatedCondition = _.get( internalViewModel, referenceCondition ) || {};\n            var returnExpression = null;\n            if( _.isString( evaluatedCondition.expression ) ) {\n                returnExpression = expression.replace( referenceCondition, '(' + evaluatedCondition.expression + ')' );\n            } else {\n                return evaluatedCondition.expression;\n            }\n            return getRealExpression( returnExpression, internalViewModel );\n        }\n        return expression;\n    }\n    return undefined;\n};\n\nexports = {\n    parseExpression,\n    registerWatch,\n    evaluateCondition,\n    evaluateConditionExpression,\n    getRealExpression\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}