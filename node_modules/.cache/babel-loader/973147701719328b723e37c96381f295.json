{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */ /**\n * Tab Overflow Service to manage tabs.\n */let exports={};/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */export let hasOverflowForTabs=(tabContainerElem,tabContainerAlignment,tabElem)=>{let propName=tabContainerAlignment==='HORIZONTAL'?'offsetTop':'offsetLeft';var tabElement=tabElem;if(!tabElement){let currentTabElems=tabContainerElem?tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab'):undefined;tabElement=currentTabElems?currentTabElems[currentTabElems.length-1]:undefined;}//We just check the element's offsetTop against the container's offset top to determine if there's an overflow\nif(!tabContainerElem||!tabElement){return false;}return tabElement[propName]>tabContainerElem[propName];};/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */export let overflowBreakPointCalculatorForTabs=function(){var tabElems;var breakIndex=0;return function(tabContainerElem,tabContainerAlignment){if(!tabContainerElem){return breakIndex;}tabElems=tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');breakIndex=tabElems.length;for(var i=tabElems.length-1;i>=0;i--){// find the first tab which doesn't have overflow in reverse order\nif(!hasOverflowForTabs(tabContainerElem,tabContainerAlignment,tabElems[i])){breakIndex=i+1;break;}}return breakIndex;};};export let updateTabIndexOnOverflow=function(tabContainerElement,tabContainerAlignment){let tabElements=tabContainerElement.querySelectorAll('.sw-tabContainer >.sw-tab');for(var i=tabElements.length-1;i>=0;i--){var tabElementAnchor=tabElements[i].querySelector('a:not(.disabled)');if(tabElementAnchor){if(hasOverflowForTabs(tabContainerElement,tabContainerAlignment,tabElements[i])){tabElementAnchor.setAttribute('tabindex',-1);}else{tabElementAnchor.setAttribute('tabindex',0);}}}};/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */const isTabsOverflown=function(tabContainerElem,tabElems,tabPadding){let totalWidth=0;for(var i=0;i<tabElems.length;i++){totalWidth+=tabElems[i].getClientRects()[0].width+tabPadding;}return Math.round(totalWidth)>tabContainerElem.clientWidth;};/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */export let calculateBreakIndex=function(){var tabElems;var breakIndex=0;return function(tabsModelForContainer,tabContainerElem,selectedTabModel){if(!tabContainerElem){return breakIndex;}tabElems=tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');let arr=[...tabElems];var tabPadding=16;if(selectedTabModel&&isTabsOverflown(tabContainerElem,arr,tabPadding)){let selectedTabObject=arr.find(element=>{const anchor=element.getElementsByTagName('a')[0];if(anchor){return anchor.getAttribute('name')===String(selectedTabModel.pageId);}return false;});let initialTabPadding=16;let totalWidth=0;if(selectedTabObject){totalWidth=selectedTabObject.getClientRects()[0].width+tabPadding+initialTabPadding;}for(var i=0;i<tabsModelForContainer.length;i++){let currentTabObject=arr.find(element=>{const anchor=element.getElementsByTagName('a')[0];if(anchor){return anchor.getAttribute('name')===String(tabsModelForContainer[i].pageId);}return false;});if(currentTabObject){totalWidth+=currentTabObject.getClientRects()[0].width+tabPadding;}if(totalWidth>tabContainerElem.clientWidth){breakIndex=i;break;}}return breakIndex;}};};exports={overflowBreakPointCalculatorForTabs,hasOverflowForTabs,updateTabIndexOnOverflow,calculateBreakIndex};export default exports;","map":null,"metadata":{},"sourceType":"module"}