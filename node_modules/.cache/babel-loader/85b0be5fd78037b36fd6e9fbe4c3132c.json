{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * This service manages tiles drag and reorder functionality.\n *\n * @module js/tileDragService\n */import $ from'jquery';import _ from'lodash';import browserUtils from'js/browserUtils';import logger from'js/logger';/**\n   * Static Strings referencing css classes\n   */var TILEMAIN_CSS_CLASS='aw-tile-tileMain';var TILE_CONT_CSS_CLASS='sw-column.aw-tile-tileContainer';var TILE_DRAGGABLE_CSS_CLASS='aw-tile-draggable';var TILEGROUP_CSS_CLASS='aw-tile-tileGroup';var PLACEHOLDER_GROUP_CSS_CLASS='aw-tile-placeHolderGroupSep';var PLACEHOLDER_TILE_CSS_CLASS='aw-tile-placeHolderTile';var DRAGTILE_CSS_CLASS='aw-tile-dragTile';var TILE_GROUP_TAGNAME='aw-tile-group';var TILE_MAIN_CONTAINER_CSS_CLASS='aw-tile-mainContainer';/**\n   * <pre>\n   * Greater Than 0 If some basic event activity should be logged.\n   * Greater Than 1 If some more fine-grained event activity should be logged.\n   * </pre>\n   */var _debug_logEventActivity=0;var placeHolderTile;let draggedTileInfo;let droppedTileInfo;/**\n   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n   *\n   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n   *            test.\n   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n   */var _isValidToDrop=function(event){return true;};/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   * @param {Boolean} isNewGroup - If a new tile group is to be created\n   *\n   * @return {Element} The Element where we need to reorder and insert dragged tile after this.\n   */var _findDropTargetElement=function(event,isNewGroup){var dropTarget={};dropTarget.inPlace=false;let eventSrc=event.currentTarget;if(isNewGroup){var placeholderGroup=$('.'+TILE_MAIN_CONTAINER_CSS_CLASS).find('.'+PLACEHOLDER_GROUP_CSS_CLASS);dropTarget.element=placeholderGroup.prev('.'+TILEGROUP_CSS_CLASS);// For the use case of the previous element not being an actual tile group\nwhile(dropTarget.element.hasClass('aw-tile-emptyTileGroup')){dropTarget.element=dropTarget.element.prev('.'+TILEGROUP_CSS_CLASS);}// If the new group is in the 1st tile group location\nif(dropTarget.element.length===0){dropTarget.element=dropTarget.element.prevObject;}dropTarget.element=dropTarget.element[0];return dropTarget;}dropTarget.element=$('.aw-tile-mainContainer .aw-tile-placeHolderTile');if(dropTarget.element.length===0){if(!$(eventSrc).hasClass(TILE_DRAGGABLE_CSS_CLASS)){// find the closest\nvar parentTileElem=$(eventSrc).closest('.'+TILE_DRAGGABLE_CSS_CLASS);// if its not on the parent level, then try to find it in the children\nif(parentTileElem.length===0){parentTileElem=$(eventSrc).find('.'+TILE_DRAGGABLE_CSS_CLASS);}if(parentTileElem&&parentTileElem.length>0){dropTarget.element=parentTileElem[0];}}else{dropTarget.element=eventSrc;}}else{//  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'\nif(dropTarget.element[0].style.order==='0'&&dropTarget.element.next().length!==0){dropTarget.element=dropTarget.element.next();dropTarget.inPlace=true;}else{dropTarget.element=dropTarget.element.prev();}}return dropTarget;};/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   *\n   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order\n   * of dragged tile.\n   */var _findDragEnterElement=function(event){var dragEnterElement;let eventSrc=event.target;// find the closest\nlet parentTileElem=$(eventSrc).closest('.'+TILE_DRAGGABLE_CSS_CLASS);if(parentTileElem&&parentTileElem.length>0){dragEnterElement=parentTileElem[0];}else if($(eventSrc).hasClass(TILEGROUP_CSS_CLASS)){dragEnterElement=$(eventSrc);}return dragEnterElement;};/**\n   * Remove place holder elements from DOM.\n   */var _removePlaceHolders=function(){$('.'+PLACEHOLDER_TILE_CSS_CLASS+'.'+TILEMAIN_CSS_CLASS).remove();$('.'+TILEGROUP_CSS_CLASS+'.'+PLACEHOLDER_GROUP_CSS_CLASS).remove();};/**\n   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping\n   *\n   * @return {Element} The Element which represents dummy placeHolder tileGroup\n   */var _createPlaceHolderTileGroup=function(){// hidden tile to place it where dragging tile will dropped\nvar newTileGroup=$('<div class=\"'+TILEGROUP_CSS_CLASS+'\"></div>');newTileGroup.addClass(PLACEHOLDER_GROUP_CSS_CLASS);return newTileGroup;};/**\n   * Create dummy placeHolder Tile element to represent the position in the UI before dropping\n   *\n   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element\n   *\n   * @return {Element} The Element which represents dummy placeHolder tile\n   */var _createPlaceHolderTile=function(sourceTile){// hidden tile to place it where dragging tile will dropped\nplaceHolderTile=$('<div class=\"'+PLACEHOLDER_TILE_CSS_CLASS+'\"></div>');placeHolderTile.addClass(TILEMAIN_CSS_CLASS);if($(sourceTile).hasClass('aw-tile-doubleSize')){placeHolderTile.addClass('aw-tile-doubleSize');}else if($(sourceTile).hasClass('aw-tile-tripleSize')){placeHolderTile.addClass('aw-tile-tripleSize');}else if($(sourceTile).hasClass('aw-tile-quadroSize')){placeHolderTile.addClass('aw-tile-quadroSize');}if($(sourceTile).hasClass('aw-tile-doubleVerticalSize')){placeHolderTile.addClass('aw-tile-doubleVerticalSize');}else if($(sourceTile).hasClass('aw-tile-tripleVerticalSize')){placeHolderTile.addClass('aw-tile-tripleVerticalSize');}else if($(sourceTile).hasClass('aw-tile-quadroVerticalSize')){placeHolderTile.addClass('aw-tile-quadroVerticalSize');}return placeHolderTile;};/**\n   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements\n   *\n   * @param {Element} dragTileIn - The DOM element for dragging tile\n   * @param {Element} element - container element for dragging tile\n   */var _cleanUp=function(dragTileIn,element){_removePlaceHolders();if(dragTileIn){dragTileIn.removeAttribute('id');}else{let dragTile=document.querySelector('#draggedTile');dragTile.classList.remove(DRAGTILE_CSS_CLASS);dragTile.removeAttribute('id');let tileContElem=dragTile;}placeHolderTile=null;if(_debug_logEventActivity>=1){postLog('Cleaning up');}};/**\n   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n   * 'target'.\n   *\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Element} targetElement - The target element associate with dragEnter event\n   */var _processDragEnterInternal=function(event,targetElement,targetObjects){event.preventDefault();// place phantom tile instead dragging one\nif(placeHolderTile&&targetElement&&targetObjects){// reordering in existing tiles\nif($(targetElement).hasClass(TILEMAIN_CSS_CLASS)&&$(targetElement).hasClass(TILE_DRAGGABLE_CSS_CLASS)){_removePlaceHolders();var targetCssOrder=targetElement.style.order;var order=parseInt(targetCssOrder,10);var side;var element=$(targetElement)[0];var mouseX=event.clientX;var elementWidth=element.offsetWidth;var halfElementWidth=elementWidth/2;if(mouseX>halfElementWidth+element.offsetLeft){side='right';}else{side='left';}// If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after\nif(order===0&&side==='left'){placeHolderTile.insertBefore(targetElement);$(placeHolderTile).css('order',0);}else{placeHolderTile.insertAfter(targetElement);$(placeHolderTile).css('order',order++);}_.forEach($(placeHolderTile).nextAll(),function(nextSib){if(nextSib){nextSib.style.order=order++;}});if(_debug_logEventActivity>=1){var tgtTile=targetObjects[0].tile;postLog('processDragEnter - PlaceHolder Tile Inserted: '+tgtTile.displayName);}}else if($(targetElement).hasClass(TILEGROUP_CSS_CLASS)){// vertically or horizontally creating new group\n_removePlaceHolders();var targetGroupElem=$(targetElement);var placeHolderTileGroup=_createPlaceHolderTileGroup();placeHolderTileGroup.insertBefore(targetGroupElem[0]);if(_debug_logEventActivity>=1){postLog('processDragEnter - Insert vertical or horizontal placeHolder Group');}}droppedTileInfo={targetTile:targetObjects[0].tile,targetTileGroup:targetObjects[0].tileGroup,viewModel:targetObjects.viewModel};}};/**\n   * Get base order value from the input parameter's order number\n   * <p>\n   * ex: 212 -> returns 200; 399 -> returns 300\n   *\n   * @param {Number} orderNumber - order number\n   * @returns {Number} base order number if orderNumber is defined, otherwise 0\n   */function getBaseOrder(orderNumber){if(!orderNumber){return 0;}var tensAndOnesDigits=orderNumber%100;return orderNumber-tensAndOnesDigits;}/**\n   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n   *\n   * @param {DragEvent} event - The DragEvent to set the DragData on.\n   * @param {Object} dragDataMap - Map of name/value pairs to add.\n   */function addDragDataToDragEvent(event,dragDataMap){if(event.dataTransfer&&dragDataMap){event.dataTransfer.setData('text',JSON.stringify({sourceTile:dragDataMap.sourceTile,sourceGroupName:dragDataMap.sourceTileGroup.groupName}));}draggedTileInfo=dragDataMap;}/**\n   * Update the drag image for the DragEvent based on draggable element.\n   *\n   * @param {DragEvent} event - The DragEvent to set the image on.\n   * @param {DOMElement} draggableElem - element being dragged.\n   */function updateDragImage(event,draggableElem){/**\n       * Internet Explorer doesn't support setDragImage at all.\n       * <P>\n       * See: http://mereskin.github.io/dnd/\n       */if(!browserUtils.isIE&&event.dataTransfer){/**\n           * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n           * should be resolved after moving the list view to a flex display.\n           */event.dataTransfer.setDragImage(draggableElem,0,0);}}/**\n   * Processes drag start event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   * @param {Element} element - The DOM element considered the 'source' of the given drag event.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   */function processDragStart(event,element,targetObjects){let callBackAPIs=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let srcElement=event.target;let sourceTile=targetObjects[0].tile;let sourceTileGroup=targetObjects[0].tileGroup;let tileContElem=srcElement.parentElement.parentElement;if(sourceTile){if(_debug_logEventActivity>=2){postLog('processDragStart - Source Tile name: '+sourceTile.displayName+' && Source Tile Group name: '+sourceTileGroup.groupName);}element.data('dragging',true);var containerId=element.data('containerId');if(!containerId){containerId=Date.now();element.data('containerId',containerId);}let width=0;for(let index=0;index<3;index++){if(index<sourceTileGroup.tiles.length){width+=sourceTileGroup.tiles[index].tileSize+1;}else{break;}}// // Default width for the single width tile\nlet parentTileMinWidth=155*width+'px';tileContElem.parentElement.style.minWidth=parentTileMinWidth;tileContElem.setAttribute('id','draggedTile');tileContElem.classList.add(DRAGTILE_CSS_CLASS);if(event.dataTransfer){event.dataTransfer.effectAllowed='move';// only allow moves\n}updateDragImage(event,tileContElem);addDragDataToDragEvent(event,{sourceTile:sourceTile,sourceTileGroup:sourceTileGroup});placeHolderTile=_createPlaceHolderTile(srcElement);}else{if(_debug_logEventActivity>=2){postLog('processDragStart - no tile Info, Set element data \"dragging\" to false');}// No data so there is no reason to let the object be dragged.\nelement.data('dragging',false);event.preventDefault();}}/**\n   * Processes drag over event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   */function processDragOver(event){if(event.dataTransfer){event.dataTransfer.effectAllowed='move';// only allow moves\n}}/**\n   * Processes drag enter event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.\n   */function processDragEnter(event,targetElement,targetObjects){if(_isValidToDrop(event)){let targetData=targetObjects[0].tile;let targetTileGroup=targetObjects[0].tileGroup;if(targetData){if(_debug_logEventActivity>=2){if(targetData.tiles){postLog('processDragEnter - Target tileGroup: '+targetData.groupName);}else if(targetTileGroup&&targetData.displayName){postLog('processDragEnter - Target tile: '+targetData.displayName+' && Target Item tileGroup: '+targetTileGroup.groupName);}else if(targetTileGroup&&!targetData.displayName){postLog('processDragEnter - Target Item tileGroup: '+targetTileGroup.groupName);}}if(!targetData.tiles&&(!targetTileGroup||!targetTileGroup.groupName)){return;}if(event.dataTransfer){event.dataTransfer.effectAllowed='move';// only allow moves\n}let debounceProcessDragEnter=_.debounce(_processDragEnterInternal,100);debounceProcessDragEnter(event,targetElement,targetObjects);}}}/**\n   * Processes drag leave event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   */function processDragLeave(event){event.preventDefault();if(event.dataTransfer){event.dataTransfer.effectAllowed='move';// only allow moves\n}}/**\n   * Processes drag end event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   */function processDragEnd(event,element,targetObjects){event.preventDefault();if(_debug_logEventActivity>=1){postLog('processDragEnd - Processing drag end');}let evtElement=event.target.parentElement.parentElement;$(evtElement).removeClass(DRAGTILE_CSS_CLASS);$(evtElement).removeAttr('id');let tileContElem=event.target;}/**\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   * @param {Object}  targetObjects\n   */function processDrop(event,callBackAPIs,element,targetObjects,props){const propertyToUpdate=props;event.stopPropagation();event.preventDefault();if(_debug_logEventActivity>=1){postLog('processDrop - Processing drop');}let dragTile=document.querySelector('#draggedTile');var isNewGroup=false;dragTile.classList.remove(DRAGTILE_CSS_CLASS);dragTile.parentElement.style.minWidth='';let tileContElem=dragTile.firstElementChild.firstElementChild;if($('.'+PLACEHOLDER_TILE_CSS_CLASS+'.'+TILEMAIN_CSS_CLASS).length>0){var prevSiblings=$('.'+PLACEHOLDER_TILE_CSS_CLASS+'.'+TILEMAIN_CSS_CLASS).prevAll();var nextSiblings=$('.'+PLACEHOLDER_TILE_CSS_CLASS+'.'+TILEMAIN_CSS_CLASS).nextAll();var index=0;_.forEachRight(prevSiblings,function(sibling){if(sibling.id!=='draggedTile'){sibling.style.order=index;index++;}});if(dragTile){dragTile.style.order=index;index++;if(_debug_logEventActivity>=1){postLog('processDrop - Set new order style for dragged tile');}}_.forEach(nextSiblings,function(sibling){if(sibling.id!=='draggedTile'){sibling.style.order=index;index++;}});}else if($('.'+TILEGROUP_CSS_CLASS+'.'+PLACEHOLDER_GROUP_CSS_CLASS).length>0){isNewGroup=true;}let targetElement=_findDropTargetElement(event,isNewGroup);if(!targetElement.element){_cleanUp(dragTile);return;}let draggingData=event.dataTransfer.getData('text');if(_debug_logEventActivity>=1){postLog('processDrop - Retrieving drag data');}if(draggingData){var dragDataTile=JSON.parse(draggingData);var targetTile=droppedTileInfo.targetTile;let targetTileGroup=droppedTileInfo.targetTileGroup;let canvasViewModel=droppedTileInfo.viewModel;if(!isNewGroup&&updateOrder&&targetTile!==dragDataTile.sourceTile){updateOrder(canvasViewModel,dragDataTile.sourceTile,dragDataTile.sourceGroupName,targetTile,targetTileGroup,targetElement.inPlace,propertyToUpdate);}else if(isNewGroup&&createNewGroup){var tileGroupElemData=targetObjects[0].tile;var tileGroupData;if(tileGroupElemData){tileGroupData=tileGroupElemData.tileGroup;}createNewGroup(dragDataTile.sourceTile,dragDataTile.sourceGroupName,tileGroupData,propertyToUpdate);}if(_debug_logEventActivity>=1){postLog('processDrop - Dropping data: '+draggingData);}}_cleanUp(dragTile);}export const dragStartFn=_ref=>{let{event,targetObjects,declViewModel}=_ref;let targetObjectsDragStart;event.stopPropagation();let panelElement=document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');var jqElement=$(panelElement);if(event.target.nodeName==='#text'){jqElement.data('dragging',false);event.preventDefault();}else{if(_debug_logEventActivity>=2){postLog('dragstart: '+event);}targetObjectsDragStart=assignViewModelToObject(targetObjects,declViewModel);processDragStart(event,jqElement,targetObjectsDragStart,{});}};export const dragEndFn=_ref2=>{let{event,targetObjects,declViewModel}=_ref2;let targetObjectsDragEnd;let panelElement=document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');var jqElement=$(panelElement);event.stopPropagation();if(event){if(_debug_logEventActivity>=2){postLog('dragend: '+event);}jqElement.data('dragging',false);var target=_findDropTargetElement(event);if(!target){return;}targetObjectsDragEnd=assignViewModelToObject(targetObjects,declViewModel);processDragEnd(event,jqElement,targetObjectsDragEnd);}};export const dragOverFn=_ref3=>{let{event,targetObjects,declViewModel}=_ref3;event.stopPropagation();event.preventDefault();if(event){if(_debug_logEventActivity>=2){postLog('dragover: '+event);}if(_isValidToDrop(event)){if(event.dataTransfer&&!browserUtils.isQt){event.dataTransfer.dropEffect='move';// only allow moves\n}event.stopPropagation();event.preventDefault();var debounceProcessDragOver=_.debounce(processDragOver,100);debounceProcessDragOver(event);}}};export const dragEnterFn=_ref4=>{let{event,targetObjects,declViewModel}=_ref4;let targetObjectsDragEnter;event.stopPropagation();if(event){if(_debug_logEventActivity>=2){postLog('dragenter: '+event);}var target=_findDragEnterElement(event);if(!target){return;}targetObjectsDragEnter=assignViewModelToObject(targetObjects,declViewModel);targetObjects.viewModel=declViewModel;processDragEnter(event,target,targetObjectsDragEnter);}};export const createNewGroup=function(viewModel,sourceTile,sourceGroupName,targetTileGroup){var sourceGroup=self.getTileGroup(sourceGroupName);var sourceGroupIndx=retrieveTileGroupIndex(viewModel.tileGroups,sourceGroup);var targetGroupIndx=retrieveTileGroupIndex(viewModel.tileGroups,targetTileGroup);var sourceTileIn=retrieveTileInTileGroup(sourceTile,sourceGroupIndx);var sourceTileIndx=viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);var baseOrder=0;var newGroupIncrement=100;if(targetTileGroup&&targetTileGroup.tiles.length>0){baseOrder=getBaseOrder(targetTileGroup.tiles[0].orderNumber);}// remove tile from source group\nvar srcGroup=viewModel.tileGroups[sourceGroupIndx];srcGroup.tiles.splice(sourceTileIndx,1);var srcGroupNull=false;// If we removed the last tile in the group\nif(srcGroup.tiles.length===0){srcGroupNull=true;}// create new group using current time\nvar newGroup={};newGroup.groupName='group'+new Date().getTime();// add sourceTile to newly created group\nnewGroup.tiles=[];newGroup.tiles.push(sourceTileIn);newGroup.tiles.forEach(function(tile,indx){tile.orderNumber=baseOrder+newGroupIncrement+indx;tile.isDirty=true;});// update tileGroups array\nif(sourceGroupIndx===targetGroupIndx&&srcGroupNull){viewModel.tileGroups.splice(targetGroupIndx,0,newGroup);}else{viewModel.tileGroups.splice(targetGroupIndx+1,0,newGroup);}var newGroupIndx=retrieveTileGroupIndex(viewModel.tileGroups,newGroup);// update order number for all tiles in each and every tile group\n_.forEach(viewModel.tileGroups,function(tileGroup,index){if(index>newGroupIndx&&tileGroup.tiles.length>0){var grpBaseOrder=getBaseOrder(tileGroup.tiles[0].orderNumber);tileGroup.tiles.map(function(tile,indx){tile.orderNumber=grpBaseOrder+newGroupIncrement+indx;tile.isDirty=true;return tile;});}});};export const updateOrder=function(viewModel,sourceTile,sourceGroupName,targetTile,targetTileGroup,inPlace,propertyToUpdate){if(targetTile){var targetTileOrder=targetTile.orderNumber;var targetGroup=getTileGroup(viewModel,targetTileGroup.groupName);var sourceGroup=getTileGroup(viewModel,sourceGroupName);var sourceGroupIndx=retrieveTileGroupIndex(viewModel.tileGroups,sourceGroup);var targetGroupIndx=retrieveTileGroupIndex(viewModel.tileGroups,targetGroup);var sourceTileIn=retrieveTileInTileGroup(viewModel,sourceTile,sourceGroupIndx);var sourceTileIndx=viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);var targetTileIndx=targetTileGroup.tiles.indexOf(targetTile);var targetBaseOrder=getBaseOrder(targetTileOrder);if(sourceGroupIndx===targetGroupIndx){// same group rearrange\nreOrderInSameGroup(sourceTileIn,sourceTileIndx,targetTile,targetTileGroup,targetBaseOrder,inPlace);}else{// different group rearrange\nreOrderInDifferentGroup(viewModel,sourceTileIn,sourceTileIndx,sourceGroupIndx,targetTileIndx,targetGroupIndx,targetBaseOrder,inPlace,propertyToUpdate);}}};export const getTileGroup=function(viewModel,groupName){var tileGroupIn;_.forEach(viewModel.tileGroups,function(tileGroup){if(tileGroup.groupName===groupName){tileGroupIn=tileGroup;return false;}return true;});return tileGroupIn;};export const retrieveTileInTileGroup=function(viewModel,tile,groupIndex){var retrievedTile;if(viewModel.tileGroups[groupIndex]&&!_.isEmpty(viewModel.tileGroups[groupIndex].tiles)){_.forEach(viewModel.tileGroups[groupIndex].tiles,function(tileObj){if(_.isEqual(tileObj.displayName,tile.displayName)){retrievedTile=tileObj;return false;}return true;});}return retrievedTile;};export const reOrderInSameGroup=function(sourceTile,sourceTileIndx,targetTile,targetTileGroup,targetBaseOrder,inPlace){if(targetTileGroup){targetTileGroup.tiles.splice(sourceTileIndx,1);var targetTileIndx=targetTileGroup.tiles.indexOf(targetTile);if(inPlace){targetTileGroup.tiles.splice(targetTileIndx,0,sourceTile);}else{targetTileGroup.tiles.splice(targetTileIndx+1,0,sourceTile);}_.forEach(targetTileGroup.tiles,function reorderTiles(tile,index){if(tile){tile.orderNumber=targetBaseOrder+index;tile.isDirty=true;}});}};export const reOrderInDifferentGroup=function(viewModel,sourceTile,sourceTileIndex,sourceGroupIndex,targetTileIndex,targetGroupIndex,targetBaseOrder,inPlace,propertyToUpdate){const{dispatch}=viewModel;const propertyName=propertyToUpdate;let updatedTileGroups={...viewModel.getData()}.tileGroups;var sourceBaseOrder=getBaseOrder(sourceTile.orderNumber);var srcGroup=updatedTileGroups[sourceGroupIndex];var targetGroupDifferent=updatedTileGroups[targetGroupIndex];// remove tile from source group\nsrcGroup.tiles.splice(sourceTileIndex,1);// add tile to target group\nif(inPlace){targetGroupDifferent.tiles.splice(targetTileIndex,0,sourceTile);}else{targetGroupDifferent.tiles.splice(targetTileIndex+1,0,sourceTile);}// modify order in source group\nsrcGroup.tiles.map(function(tile,idx){tile.orderNumber=sourceBaseOrder+idx;tile.isDirty=true;return tile;});updatedTileGroups[sourceGroupIndex]=srcGroup;// modify order in target group\ntargetGroupDifferent.tiles.map(function(tile,idx){tile.orderNumber=targetBaseOrder+idx;tile.isDirty=true;return tile;});updatedTileGroups[targetGroupIndex]=targetGroupDifferent;let propertyPath=propertyName?'data.'+propertyName:'data.tileGroups';dispatch({path:propertyPath,value:[...updatedTileGroups]});};export const dragLeaveFn=_ref5=>{let{event,targetObjects,declViewModel}=_ref5;event.stopPropagation();if(event){if(_debug_logEventActivity>=2){postLog('dragleave: '+event);}var debounceProcessDragLeave=_.debounce(processDragLeave,100);debounceProcessDragLeave(event);}};export const dropFn=(props,_ref6)=>{let{event,targetObjects,declViewModel}=_ref6;let targetObjectsDrop;let panelElement=document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');var jqElement=$(panelElement);event.stopPropagation();if(event){if(_debug_logEventActivity>=2){postLog('drop: '+event);}jqElement.data('dragging',false);targetObjectsDrop=assignViewModelToObject(targetObjects,declViewModel);processDrop(event,{},jqElement,targetObjectsDrop,props);}};export const postLog=message=>{logger.info(message);};const retrieveTileGroupIndex=(tileGroups,group)=>{if(tileGroups){return tileGroups.indexOf(group);}return-1;};const assignViewModelToObject=(targetObjects,declViewModel)=>{let targetObjectsUpdated={...targetObjects};targetObjectsUpdated.viewModel=declViewModel;return targetObjectsUpdated;};export default{getBaseOrder,addDragDataToDragEvent,updateDragImage,processDragStart,processDragOver,processDragEnter,processDragLeave,processDragEnd,processDrop,dragStartFn,dragEndFn,dragOverFn,dragEnterFn,dragLeaveFn,dropFn,updateOrder,createNewGroup,reOrderInSameGroup,reOrderInDifferentGroup,retrieveTileInTileGroup,getTileGroup,postLog};","map":null,"metadata":{},"sourceType":"module"}