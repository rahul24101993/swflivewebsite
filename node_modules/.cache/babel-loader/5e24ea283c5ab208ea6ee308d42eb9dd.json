{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/propertyPolicyService\n */\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport awConfiguration from 'js/awConfiguration';\nimport moduleLoader from 'js/moduleLoader';\n/**\n * Angular services\n */\n\nvar exports = {};\n/**\n * Map of policy id to registered policy.\n *\n * @private\n */\n\nexport let _policyId2policy = {};\n/**\n * Registration of time stamp for property policies.\n *\n * @private\n */\n\nexport let _policyId2registrationTimeStamp = {};\n/**\n * Registration counter for property policies.\n *\n * @private\n */\n\nexport let _policyCount = 0;\n/**\n * Effective property policy for subsequent server calls.\n *\n * @private\n */\n\nexport let _effectivePolicy = {};\n/**\n * Cache of last SOA service used by getEffectivePolicy()\n *\n * @private\n */\n\nexport let _soaSvc = null;\n/**\n * Parent selections.\n *\n * @private\n */\n\nexport let _parentSelections = [];\n/**\n * Current selections.\n *\n * @private\n */\n\nexport let _currentSelections = [];\n/**\n * List of selected policy Id's.\n *\n * @private\n */\n\nexport let _selectedPolicyIds = [];\n/**\n * List of generic policy Id's.\n *\n * @private\n */\n\nexport let _genericPolicyIds = [];\n/**\n * boolean to indicate whether the last effective policy was build from selected property policy or not.\n *\n * @private\n */\n\nexport let _selectedPropertyUsed = false; // /**\n//  * Sort input array by name field of elements.\n//  *\n//  * @param array array to sort\n//  * @private\n//  */\n// function sort( array ) {\n//     if( array ) {\n//         array.sort( function( a, b ) {\n//             return a.name.localeCompare( b.name );\n//         } );\n//     }\n// }\n\n/**\n * @param {String} typeName - type name\n * @param {String} propName - property name\n * @return {String} defining type name (whether on this type or one of it's parents)\n */\n\nfunction getParentType(typeName, propName) {\n  var modelType = cmm.getType(typeName);\n\n  if (modelType && modelType.propertyDescriptorsMap.hasOwnProperty(propName)) {\n    var parentModelType = cmm.getType(modelType.parentTypeName);\n\n    if (parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty(propName)) {\n      return getParentType(parentModelType.name, propName);\n    }\n\n    return modelType.name;\n  }\n\n  return null;\n}\n/**\n * Merge modifier into modifier array.\n *\n * @param {Array} modifiers - array of modifiers\n * @param {Object} modifierToMerge - modifier to merge into array\n * @private\n */\n\n\nfunction mergeModifier(modifiers, modifierToMerge) {\n  var modifier = _.find(modifiers, _.matchesProperty('name', modifierToMerge.name));\n\n  if (!modifier) {\n    modifier = {\n      name: modifierToMerge.name,\n      Value: modifierToMerge.Value\n    };\n    modifiers.push(modifier);\n  } else if (modifier.Value !== modifierToMerge.Value) {\n    logger.error('Modifier conflict!');\n  }\n}\n/**\n * Merge property into property array.\n *\n * @param {Array} properties - array of properties\n * @param {Object} propertyToMerge - property to merge into array\n * @private\n */\n\n\nfunction mergeProperty(properties, propertyToMerge) {\n  var property = _.find(properties, _.matchesProperty('name', propertyToMerge.name));\n\n  if (!property) {\n    property = {\n      name: propertyToMerge.name\n    };\n    properties.push(property);\n  }\n\n  if (propertyToMerge.modifiers && propertyToMerge.modifiers.length > 0) {\n    if (!property.modifiers) {\n      property.modifiers = [];\n    }\n\n    _.forEach(propertyToMerge.modifiers, function (modifier) {\n      mergeModifier(property.modifiers, modifier);\n    });\n  }\n}\n/**\n * Merge type into type array.\n *\n * @param {Array} types - array of types\n * @param {Object} typeToMerge - type to merge into array\n * @private\n */\n\n\nfunction mergeType(types, typeToMerge) {\n  var type = _.find(types, _.matchesProperty('name', typeToMerge.name));\n\n  if (!type) {\n    type = {\n      name: typeToMerge.name\n    };\n    types.push(type);\n  }\n\n  if (typeToMerge.properties && typeToMerge.properties.length > 0) {\n    if (!type.properties) {\n      type.properties = [];\n    }\n\n    _.forEach(typeToMerge.properties, function (property) {\n      mergeProperty(type.properties, property);\n    });\n  }\n\n  if (typeToMerge.modifiers && typeToMerge.modifiers.length > 0) {\n    if (!type.modifiers) {\n      type.modifiers = [];\n    }\n\n    _.forEach(typeToMerge.modifiers, function (modifier) {\n      mergeModifier(type.modifiers, modifier);\n    });\n  }\n}\n/**\n * Effective property policy for use by Teamcenter SOA server call header.\n *\n * @param {Object} soaSvc - SOA service to avoid cyclic reference\n * @param {boolean} isSelectedProperty - flag indicating the policy type to use.\n * @return {Object} effective property policy\n */\n\n\nexport let getEffectivePolicy = function (soaSvc, isSelectedProperty) {\n  if (soaSvc) {\n    exports._soaSvc = soaSvc;\n  }\n\n  var policyIdsForEffectPolicy = exports._genericPolicyIds;\n\n  if (isSelectedProperty) {\n    policyIdsForEffectPolicy = exports._selectedPolicyIds;\n  } // we need to check which policy type (selected or generic ) was used to build the effective property policy\n\n\n  if (!exports._effectivePolicy || isSelectedProperty !== exports._selectedPropertyUsed) {\n    var effectivePolicy = {\n      useRefCount: false // do we need to set this? ie does the server default to zero anyway?\n\n    };\n    exports._selectedPropertyUsed = isSelectedProperty;\n\n    _.forEach(policyIdsForEffectPolicy, function (policyId) {\n      var policy = exports._policyId2policy[policyId];\n\n      if (policy.types) {\n        if (!effectivePolicy.types) {\n          effectivePolicy.types = [];\n        }\n\n        _.forEach(policy.types, function (type) {\n          mergeType(effectivePolicy.types, type);\n        });\n      }\n\n      if (policy.modifiers && policy.modifiers.length > 0) {\n        if (!effectivePolicy.modifiers) {\n          effectivePolicy.modifiers = [];\n        }\n\n        _.forEach(policy.modifiers, function (modifier) {\n          mergeModifier(effectivePolicy.modifiers, modifier);\n        });\n      }\n    }); //            // Sort the effective policy for debug purposes\n    //            sort( effectivePolicy.types );\n    //            if( effectivePolicy.types ) {\n    //                _.forEach( effectivePolicy.types, function( type ) {\n    //                    sort( type.modifiers );\n    //                    if( type.properties ) {\n    //                        sort( type.properties );\n    //                        _.forEach( type.properties, function( property ) {\n    //                            sort( property.modifiers );\n    //                        } );\n    //                    }\n    //                } );\n    //            }\n    //            sort( effectivePolicy.modifiers );\n\n\n    exports._effectivePolicy = effectivePolicy;\n  }\n\n  return exports._effectivePolicy;\n};\n/**\n * Returns true if at least one selected object is present in the input body.\n *\n * @param {Object} body - input body\n * @param {StringArray} modelObjectUidList - model object uid's\n * @return {Boolean} true if at least one selected object is present in the input body.\n */\n\nexport let checkForSelectedObject = function (body, modelObjectUidList) {\n  var isFound = false;\n  var modelObjectUids = modelObjectUidList;\n\n  if (!modelObjectUidList) {\n    modelObjectUids = [];\n    extractModelObjects(body, modelObjectUids);\n  }\n\n  if (modelObjectUids.length > 0) {\n    var totalSelectedModelObject = getSelectedModelObjects();\n\n    for (var i = 0; i < totalSelectedModelObject.length; i++) {\n      if (modelObjectUids.indexOf(totalSelectedModelObject[i]) > -1) {\n        isFound = true;\n        break;\n      }\n    }\n  }\n\n  return isFound;\n};\n/**\n * Returns a list of all the selected model objects. This list includes the parent and the child selections.\n *\n * @private\n * @return {IModelObjectArray} An array of total selected model objects uid's list.\n */\n\nfunction getSelectedModelObjects() {\n  var selectedModelObjects = []; // add current selected objects to the selected objects list .\n\n  for (var i = 0; i < exports._currentSelections.length; i++) {\n    if (selectedModelObjects.indexOf(exports._currentSelections[i]) === -1) {\n      selectedModelObjects.push(exports._currentSelections[i]);\n    }\n  } // add parent selected objects to the selected objects list .\n\n\n  for (var ii = 0; ii < exports._parentSelections.length; ii++) {\n    if (selectedModelObjects.indexOf(exports._parentSelections[ii]) === -1) {\n      selectedModelObjects.push(exports._parentSelections[ii]);\n    }\n  }\n\n  return selectedModelObjects;\n}\n/**\n * Extracts model object uid's from the body\n *\n * @private\n * @param {Object} body - input body\n * @param {StringArray} uids - Array of {ModelObject} uid's found in body\n */\n\n\nfunction extractModelObjects(body, uids) {\n  _.forEach(body, function (child) {\n    if (_.isPlainObject(child)) {\n      if (child.hasOwnProperty('uid') && child.hasOwnProperty('type')) {\n        if (child.uid && child.uid !== 'AAAAAAAAAAAAAA') {\n          uids.push(child.uid);\n        }\n      } else {\n        extractModelObjects(child, uids);\n      }\n    } else if (_.isArray(child)) {\n      extractModelObjects(child, uids);\n    }\n  });\n}\n/**\n * Set's the selected model objects.\n *\n * @param {StringArray} selectedObectuids selected object uid's\n */\n\n\nexport let setSelectedObjects = function (selectedObectuids) {\n  if (selectedObectuids) {\n    exports._currentSelections = selectedObectuids;\n  } else {\n    exports._currentSelections = [];\n  }\n};\n/**\n * Add's the selected model object to parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\n\nexport let addToParentSelection = function (selectedObectuid) {\n  if (!exports._parentSelections) {\n    exports._parentSelections = [];\n  } else {\n    exports._parentSelections.push(selectedObectuid);\n  }\n};\n/**\n * removes the model object from parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\n\nexport let removeFromParentSelection = function (selectedObectuid) {\n  // Remove the selected object\n  if (exports._parentSelections.lastIndexOf(selectedObectuid) > -1) {\n    exports._parentSelections.splice(exports._parentSelections.lastIndexOf(selectedObectuid), 1);\n  }\n};\n/**\n * Register property policy.\n *\n * @param {Object} policy - property policy\n * @param {String} policyString - property policy string\n * @param {String} policyType - property type\n * @return {String} property policy ID\n */\n\nexport let register = function (policy, policyString, policyType) {\n  var policyFinal = policy;\n  var timeS = Date.now();\n\n  if (!policyFinal) {\n    policyFinal = JSON.parse(policyString);\n  }\n\n  var nextId = ++exports._policyCount; // Create policy id\n\n  var policyId = 'policy' + nextId; // Cache policy\n\n  exports._policyId2policy[policyId] = policyFinal; // depending upon the policy type add the policy to generic list\n\n  if (!policyType) {\n    exports._genericPolicyIds.push(policyId);\n  }\n\n  exports._selectedPolicyIds.push(policyId); // Clear cache of effective policy\n\n\n  exports._effectivePolicy = null;\n  var currentTime = dateTimeSvc.formatTime(timeS);\n\n  if (logger.isTraceEnabled()) {\n    logger.trace('Register Property Policy Id: ' + policyId + ' TimeStamp: ' + currentTime + ' Policy data:', policyFinal);\n  }\n\n  if (policyString) {\n    exports._policyId2registrationTimeStamp[policyId] = {\n      time: currentTime,\n      policy: policyFinal\n    };\n  } // Return new cached policy id\n\n\n  return policyId;\n};\n/**\n * Register property policy.\n *\n * @param {String} policyId - cached property policy ID\n */\n\nexport let unregister = function (policyId) {\n  // Remove the policy id from selected property policy id list\n  if (exports._selectedPolicyIds.indexOf(policyId) > -1) {\n    exports._selectedPolicyIds.splice(exports._selectedPolicyIds.indexOf(policyId), 1);\n  } // Remove the policy id from generic property policy id list\n\n\n  if (exports._genericPolicyIds.indexOf(policyId) > -1) {\n    exports._genericPolicyIds.splice(exports._genericPolicyIds.indexOf(policyId), 1);\n  }\n\n  if (exports._policyId2policy.hasOwnProperty(policyId)) {\n    delete exports._policyId2policy[policyId];\n\n    if (logger.isTraceEnabled()) {\n      logger.trace('Unregister Property Policy Id: ' + policyId + ' TimeStamp: ' + dateTimeSvc.formatTime(Date.now()));\n    }\n\n    delete exports._policyId2registrationTimeStamp[policyId]; // Clear cache of effective policy\n\n    exports._effectivePolicy = null;\n  }\n};\n/**\n * @param {Object} policy - property policy to validate\n * @param {number} callCount - call count to avoid infinite loop if a type name is invalid & can't be loaded\n */\n\nfunction validatePolicy(policy, callCount) {\n  if (policy.types) {\n    if (callCount < 5 && exports._soaSvc) {\n      var typeNames = [];\n\n      _.forEach(policy.types, function (type) {\n        var modelType = cmm.getType(type.name);\n\n        if (!modelType) {\n          typeNames.push(type.name);\n        } else {\n          _.forEach(modelType.typeHierarchyArray, function (name2) {\n            if (!cmm.containsType(name2)) {\n              typeNames.push(name2);\n            }\n          });\n        }\n      });\n\n      const sortedTypeNames = typeNames.sort();\n      typeNames = _.uniq(sortedTypeNames, true);\n\n      if (typeNames) {\n        var promise = exports._soaSvc.ensureModelTypesLoaded(typeNames);\n\n        if (promise) {\n          promise.then(function () {\n            return validatePolicy(policy, ++callCount);\n          });\n          return;\n        }\n      }\n    }\n\n    var output = [];\n\n    _.forEach(policy.types, function (type) {\n      var modelType = cmm.getType(type.name);\n\n      if (modelType) {\n        if (type.properties) {\n          var parentModelType = cmm.getType(modelType.parentTypeName);\n\n          _.forEach(type.properties, function (property) {\n            if (property) {\n              if (!modelType.propertyDescriptorsMap.hasOwnProperty(property.name)) {\n                output.push('Invalid property [' + property.name + '] on type [' + type.name + ']');\n              } else if (parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty(property.name)) {\n                output.push('Wrong type for property [' + property.name + '] on type [' + type.name + '], should be on type [' + getParentType(parentModelType.name, property.name) + ']');\n              } else {\n                output.push('Effective property [' + property.name + '] on type [' + type.name + ']');\n              }\n            } else {\n              output.push('Empty property on type [' + type.name + ']');\n            }\n          });\n        }\n      } else {\n        output.push('Invalid type [' + type.name + ']');\n      }\n\n      if (!type.properties && !type.modifiers) {\n        output.push('Missing properties for type [' + type.name + ']');\n      }\n    });\n\n    if (output.length > 0) {\n      output.sort();\n      logger.info(output.join('\\n'));\n    }\n  }\n}\n/**\n * @param {Array} modelObjects array of model objects\n * @param {Array} propNames array of property names\n */\n\n\nexport let validatePropertyRegistration = function (modelObjects, propNames) {\n  var policy = exports.getEffectivePolicy();\n  var msg = '';\n\n  _.forEach(modelObjects, function (modelObject) {\n    if (modelObject) {\n      var modelType = modelObject.modelType;\n\n      _.forEach(propNames, function (propName) {\n        if (modelType.propertyDescriptorsMap.hasOwnProperty(propName) && policy.types) {\n          var found = false;\n\n          for (var kk = 0; kk < policy.types.length && !found; kk++) {\n            var type = policy.types[kk];\n\n            if (type.properties && modelType.typeHierarchyArray.indexOf(type.name) > -1) {\n              for (var ll = 0; ll < type.properties.length && !found; ll++) {\n                var property = type.properties[ll];\n\n                if (property.name === propName) {\n                  found = true;\n                }\n              }\n            }\n          }\n\n          if (!found) {\n            msg += '\\n\\tType [' + modelType.displayName + '] PropertyName [' + propName + ']';\n          }\n        }\n      });\n    }\n  });\n\n  if (msg) {\n    logger.debug('Property Policy registration is missing for the following:' + msg);\n  }\n};\n/**\n * Register a policy which may need to be loaded from a separate json file.\n *\n * @param {Object|String} propertyPolicy - A property policy object or a path to the file containing the policy\n *\n * @return {Promise} A promise that will be resolved with the new policy id\n */\n\nexport let registerPolicyAsync = function (propertyPolicy) {\n  // If it's a string it's a path to a policy file that needs to be loaded\n  if (typeof propertyPolicy === 'string') {\n    if (propertyPolicy.startsWith('/')) {\n      propertyPolicy = propertyPolicy.slice(1);\n    }\n\n    return moduleLoader.loadDependentModule(propertyPolicy).then(result => {\n      return exports.register(result);\n    });\n  } // Otherwise it must be the actual policy object\n\n\n  return AwPromiseService.instance.when(exports.register(propertyPolicy));\n};\nexports = {\n  _policyId2policy,\n  _policyId2registrationTimeStamp,\n  _policyCount,\n  _effectivePolicy,\n  _soaSvc,\n  _parentSelections,\n  _currentSelections,\n  _selectedPolicyIds,\n  _genericPolicyIds,\n  _selectedPropertyUsed,\n  getEffectivePolicy,\n  checkForSelectedObject,\n  setSelectedObjects,\n  addToParentSelection,\n  removeFromParentSelection,\n  register,\n  unregister,\n  validatePropertyRegistration,\n  registerPolicyAsync\n};\nexport default exports;\n/**\n * Catch the event for logging all registered policies in the current session and logging the effective policy\n * in the session\n */\n\neventBus.subscribe('cdm.logDiagnostics', function () {\n  var policy = exports.getEffectivePolicy();\n  logger.info('Property Policy Audit Console Logging :');\n\n  _.forEach(exports._policyId2registrationTimeStamp, function (times, policyId) {\n    logger.debug('Registered Property Policy Id \"' + policyId + '\" @ ' + times.time + ':', times.policy);\n  });\n\n  logger.debug('Effective Property Policy in session:', policy);\n  validatePolicy(policy, 1);\n}, 'soa_kernel_propertyPolicyService');","map":{"version":3,"names":["AwHttpService","AwPromiseService","dateTimeSvc","cmm","_","eventBus","logger","awConfiguration","moduleLoader","exports","_policyId2policy","_policyId2registrationTimeStamp","_policyCount","_effectivePolicy","_soaSvc","_parentSelections","_currentSelections","_selectedPolicyIds","_genericPolicyIds","_selectedPropertyUsed","getParentType","typeName","propName","modelType","getType","propertyDescriptorsMap","hasOwnProperty","parentModelType","parentTypeName","name","mergeModifier","modifiers","modifierToMerge","modifier","find","matchesProperty","Value","push","error","mergeProperty","properties","propertyToMerge","property","length","forEach","mergeType","types","typeToMerge","type","getEffectivePolicy","soaSvc","isSelectedProperty","policyIdsForEffectPolicy","effectivePolicy","useRefCount","policyId","policy","checkForSelectedObject","body","modelObjectUidList","isFound","modelObjectUids","extractModelObjects","totalSelectedModelObject","getSelectedModelObjects","i","indexOf","selectedModelObjects","ii","uids","child","isPlainObject","uid","isArray","setSelectedObjects","selectedObectuids","addToParentSelection","selectedObectuid","removeFromParentSelection","lastIndexOf","splice","register","policyString","policyType","policyFinal","timeS","Date","now","JSON","parse","nextId","currentTime","formatTime","isTraceEnabled","trace","time","unregister","validatePolicy","callCount","typeNames","typeHierarchyArray","name2","containsType","sortedTypeNames","sort","uniq","promise","ensureModelTypesLoaded","then","output","info","join","validatePropertyRegistration","modelObjects","propNames","msg","modelObject","found","kk","ll","displayName","debug","registerPolicyAsync","propertyPolicy","startsWith","slice","loadDependentModule","result","instance","when","subscribe","times"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/kernel/propertyPolicyService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/propertyPolicyService\n */\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport awConfiguration from 'js/awConfiguration';\nimport moduleLoader from 'js/moduleLoader';\n/**\n * Angular services\n */\n\nvar exports = {};\n\n/**\n * Map of policy id to registered policy.\n *\n * @private\n */\nexport let _policyId2policy = {};\n\n/**\n * Registration of time stamp for property policies.\n *\n * @private\n */\nexport let _policyId2registrationTimeStamp = {};\n\n/**\n * Registration counter for property policies.\n *\n * @private\n */\nexport let _policyCount = 0;\n\n/**\n * Effective property policy for subsequent server calls.\n *\n * @private\n */\nexport let _effectivePolicy = {};\n\n/**\n * Cache of last SOA service used by getEffectivePolicy()\n *\n * @private\n */\nexport let _soaSvc = null;\n\n/**\n * Parent selections.\n *\n * @private\n */\nexport let _parentSelections = [];\n\n/**\n * Current selections.\n *\n * @private\n */\nexport let _currentSelections = [];\n\n/**\n * List of selected policy Id's.\n *\n * @private\n */\nexport let _selectedPolicyIds = [];\n\n/**\n * List of generic policy Id's.\n *\n * @private\n */\nexport let _genericPolicyIds = [];\n\n/**\n * boolean to indicate whether the last effective policy was build from selected property policy or not.\n *\n * @private\n */\nexport let _selectedPropertyUsed = false;\n// /**\n//  * Sort input array by name field of elements.\n//  *\n//  * @param array array to sort\n//  * @private\n//  */\n// function sort( array ) {\n//     if( array ) {\n//         array.sort( function( a, b ) {\n//             return a.name.localeCompare( b.name );\n//         } );\n//     }\n// }\n\n/**\n * @param {String} typeName - type name\n * @param {String} propName - property name\n * @return {String} defining type name (whether on this type or one of it's parents)\n */\nfunction getParentType( typeName, propName ) {\n    var modelType = cmm.getType( typeName );\n    if( modelType && modelType.propertyDescriptorsMap.hasOwnProperty( propName ) ) {\n        var parentModelType = cmm.getType( modelType.parentTypeName );\n        if( parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty( propName ) ) {\n            return getParentType( parentModelType.name, propName );\n        }\n        return modelType.name;\n    }\n    return null;\n}\n\n/**\n * Merge modifier into modifier array.\n *\n * @param {Array} modifiers - array of modifiers\n * @param {Object} modifierToMerge - modifier to merge into array\n * @private\n */\nfunction mergeModifier( modifiers, modifierToMerge ) {\n    var modifier = _.find( modifiers, _.matchesProperty( 'name', modifierToMerge.name ) );\n    if( !modifier ) {\n        modifier = {\n            name: modifierToMerge.name,\n            Value: modifierToMerge.Value\n        };\n        modifiers.push( modifier );\n    } else if( modifier.Value !== modifierToMerge.Value ) {\n        logger.error( 'Modifier conflict!' );\n    }\n}\n\n/**\n * Merge property into property array.\n *\n * @param {Array} properties - array of properties\n * @param {Object} propertyToMerge - property to merge into array\n * @private\n */\nfunction mergeProperty( properties, propertyToMerge ) {\n    var property = _.find( properties, _.matchesProperty( 'name', propertyToMerge.name ) );\n    if( !property ) {\n        property = {\n            name: propertyToMerge.name\n        };\n        properties.push( property );\n    }\n    if( propertyToMerge.modifiers && propertyToMerge.modifiers.length > 0 ) {\n        if( !property.modifiers ) {\n            property.modifiers = [];\n        }\n        _.forEach( propertyToMerge.modifiers, function( modifier ) {\n            mergeModifier( property.modifiers, modifier );\n        } );\n    }\n}\n\n/**\n * Merge type into type array.\n *\n * @param {Array} types - array of types\n * @param {Object} typeToMerge - type to merge into array\n * @private\n */\nfunction mergeType( types, typeToMerge ) {\n    var type = _.find( types, _.matchesProperty( 'name', typeToMerge.name ) );\n    if( !type ) {\n        type = {\n            name: typeToMerge.name\n        };\n        types.push( type );\n    }\n    if( typeToMerge.properties && typeToMerge.properties.length > 0 ) {\n        if( !type.properties ) {\n            type.properties = [];\n        }\n        _.forEach( typeToMerge.properties, function( property ) {\n            mergeProperty( type.properties, property );\n        } );\n    }\n    if( typeToMerge.modifiers && typeToMerge.modifiers.length > 0 ) {\n        if( !type.modifiers ) {\n            type.modifiers = [];\n        }\n        _.forEach( typeToMerge.modifiers, function( modifier ) {\n            mergeModifier( type.modifiers, modifier );\n        } );\n    }\n}\n\n/**\n * Effective property policy for use by Teamcenter SOA server call header.\n *\n * @param {Object} soaSvc - SOA service to avoid cyclic reference\n * @param {boolean} isSelectedProperty - flag indicating the policy type to use.\n * @return {Object} effective property policy\n */\nexport let getEffectivePolicy = function( soaSvc, isSelectedProperty ) {\n    if( soaSvc ) {\n        exports._soaSvc = soaSvc;\n    }\n\n    var policyIdsForEffectPolicy = exports._genericPolicyIds;\n    if( isSelectedProperty ) {\n        policyIdsForEffectPolicy = exports._selectedPolicyIds;\n    }\n    // we need to check which policy type (selected or generic ) was used to build the effective property policy\n    if( !exports._effectivePolicy || isSelectedProperty !== exports._selectedPropertyUsed ) {\n        var effectivePolicy = {\n            useRefCount: false\n            // do we need to set this? ie does the server default to zero anyway?\n        };\n        exports._selectedPropertyUsed = isSelectedProperty;\n        _.forEach( policyIdsForEffectPolicy, function( policyId ) {\n            var policy = exports._policyId2policy[ policyId ];\n            if( policy.types ) {\n                if( !effectivePolicy.types ) {\n                    effectivePolicy.types = [];\n                }\n                _.forEach( policy.types, function( type ) {\n                    mergeType( effectivePolicy.types, type );\n                } );\n            }\n\n            if( policy.modifiers && policy.modifiers.length > 0 ) {\n                if( !effectivePolicy.modifiers ) {\n                    effectivePolicy.modifiers = [];\n                }\n                _.forEach( policy.modifiers, function( modifier ) {\n                    mergeModifier( effectivePolicy.modifiers, modifier );\n                } );\n            }\n        } );\n\n        //            // Sort the effective policy for debug purposes\n        //            sort( effectivePolicy.types );\n        //            if( effectivePolicy.types ) {\n        //                _.forEach( effectivePolicy.types, function( type ) {\n        //                    sort( type.modifiers );\n        //                    if( type.properties ) {\n        //                        sort( type.properties );\n        //                        _.forEach( type.properties, function( property ) {\n        //                            sort( property.modifiers );\n        //                        } );\n        //                    }\n        //                } );\n        //            }\n        //            sort( effectivePolicy.modifiers );\n\n        exports._effectivePolicy = effectivePolicy;\n    }\n    return exports._effectivePolicy;\n};\n\n/**\n * Returns true if at least one selected object is present in the input body.\n *\n * @param {Object} body - input body\n * @param {StringArray} modelObjectUidList - model object uid's\n * @return {Boolean} true if at least one selected object is present in the input body.\n */\nexport let checkForSelectedObject = function( body, modelObjectUidList ) {\n    var isFound = false;\n    var modelObjectUids = modelObjectUidList;\n    if( !modelObjectUidList ) {\n        modelObjectUids = [];\n        extractModelObjects( body, modelObjectUids );\n    }\n    if( modelObjectUids.length > 0 ) {\n        var totalSelectedModelObject = getSelectedModelObjects();\n        for( var i = 0; i < totalSelectedModelObject.length; i++ ) {\n            if( modelObjectUids.indexOf( totalSelectedModelObject[ i ] ) > -1 ) {\n                isFound = true;\n                break;\n            }\n        }\n    }\n    return isFound;\n};\n\n/**\n * Returns a list of all the selected model objects. This list includes the parent and the child selections.\n *\n * @private\n * @return {IModelObjectArray} An array of total selected model objects uid's list.\n */\nfunction getSelectedModelObjects() {\n    var selectedModelObjects = [];\n\n    // add current selected objects to the selected objects list .\n    for( var i = 0; i < exports._currentSelections.length; i++ ) {\n        if( selectedModelObjects.indexOf( exports._currentSelections[ i ] ) === -1 ) {\n            selectedModelObjects.push( exports._currentSelections[ i ] );\n        }\n    }\n\n    // add parent selected objects to the selected objects list .\n    for( var ii = 0; ii < exports._parentSelections.length; ii++ ) {\n        if( selectedModelObjects.indexOf( exports._parentSelections[ ii ] ) === -1 ) {\n            selectedModelObjects.push( exports._parentSelections[ ii ] );\n        }\n    }\n\n    return selectedModelObjects;\n}\n\n/**\n * Extracts model object uid's from the body\n *\n * @private\n * @param {Object} body - input body\n * @param {StringArray} uids - Array of {ModelObject} uid's found in body\n */\nfunction extractModelObjects( body, uids ) {\n    _.forEach( body, function( child ) {\n        if( _.isPlainObject( child ) ) {\n            if( child.hasOwnProperty( 'uid' ) && child.hasOwnProperty( 'type' ) ) {\n                if( child.uid && child.uid !== 'AAAAAAAAAAAAAA' ) {\n                    uids.push( child.uid );\n                }\n            } else {\n                extractModelObjects( child, uids );\n            }\n        } else if( _.isArray( child ) ) {\n            extractModelObjects( child, uids );\n        }\n    } );\n}\n\n/**\n * Set's the selected model objects.\n *\n * @param {StringArray} selectedObectuids selected object uid's\n */\nexport let setSelectedObjects = function( selectedObectuids ) {\n    if( selectedObectuids ) {\n        exports._currentSelections = selectedObectuids;\n    } else {\n        exports._currentSelections = [];\n    }\n};\n\n/**\n * Add's the selected model object to parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\nexport let addToParentSelection = function( selectedObectuid ) {\n    if( !exports._parentSelections ) {\n        exports._parentSelections = [];\n    } else {\n        exports._parentSelections.push( selectedObectuid );\n    }\n};\n\n/**\n * removes the model object from parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\nexport let removeFromParentSelection = function( selectedObectuid ) {\n    // Remove the selected object\n    if( exports._parentSelections.lastIndexOf( selectedObectuid ) > -1 ) {\n        exports._parentSelections.splice( exports._parentSelections.lastIndexOf( selectedObectuid ), 1 );\n    }\n};\n\n/**\n * Register property policy.\n *\n * @param {Object} policy - property policy\n * @param {String} policyString - property policy string\n * @param {String} policyType - property type\n * @return {String} property policy ID\n */\nexport let register = function( policy, policyString, policyType ) {\n    var policyFinal = policy;\n\n    var timeS = Date.now();\n\n    if( !policyFinal ) {\n        policyFinal = JSON.parse( policyString );\n    }\n\n    var nextId = ++exports._policyCount;\n\n    // Create policy id\n    var policyId = 'policy' + nextId;\n\n    // Cache policy\n    exports._policyId2policy[ policyId ] = policyFinal;\n\n    // depending upon the policy type add the policy to generic list\n    if( !policyType ) {\n        exports._genericPolicyIds.push( policyId );\n    }\n\n    exports._selectedPolicyIds.push( policyId );\n\n    // Clear cache of effective policy\n    exports._effectivePolicy = null;\n\n    var currentTime = dateTimeSvc.formatTime( timeS );\n\n    if( logger.isTraceEnabled() ) {\n        logger.trace( 'Register Property Policy Id: ' + policyId + ' TimeStamp: ' + currentTime + ' Policy data:',\n            policyFinal );\n    }\n\n    if( policyString ) {\n        exports._policyId2registrationTimeStamp[ policyId ] = {\n            time: currentTime,\n            policy: policyFinal\n        };\n    }\n\n    // Return new cached policy id\n    return policyId;\n};\n\n/**\n * Register property policy.\n *\n * @param {String} policyId - cached property policy ID\n */\nexport let unregister = function( policyId ) {\n    // Remove the policy id from selected property policy id list\n    if( exports._selectedPolicyIds.indexOf( policyId ) > -1 ) {\n        exports._selectedPolicyIds.splice( exports._selectedPolicyIds.indexOf( policyId ), 1 );\n    }\n    // Remove the policy id from generic property policy id list\n    if( exports._genericPolicyIds.indexOf( policyId ) > -1 ) {\n        exports._genericPolicyIds.splice( exports._genericPolicyIds.indexOf( policyId ), 1 );\n    }\n\n    if( exports._policyId2policy.hasOwnProperty( policyId ) ) {\n        delete exports._policyId2policy[ policyId ];\n\n        if( logger.isTraceEnabled() ) {\n            logger.trace( 'Unregister Property Policy Id: ' + policyId + ' TimeStamp: ' +\n                dateTimeSvc.formatTime( Date.now() ) );\n        }\n\n        delete exports._policyId2registrationTimeStamp[ policyId ];\n        // Clear cache of effective policy\n        exports._effectivePolicy = null;\n    }\n};\n\n/**\n * @param {Object} policy - property policy to validate\n * @param {number} callCount - call count to avoid infinite loop if a type name is invalid & can't be loaded\n */\nfunction validatePolicy( policy, callCount ) {\n    if( policy.types ) {\n        if( callCount < 5 && exports._soaSvc ) {\n            var typeNames = [];\n            _.forEach( policy.types, function( type ) {\n                var modelType = cmm.getType( type.name );\n                if( !modelType ) {\n                    typeNames.push( type.name );\n                } else {\n                    _.forEach( modelType.typeHierarchyArray, function( name2 ) {\n                        if( !cmm.containsType( name2 ) ) {\n                            typeNames.push( name2 );\n                        }\n                    } );\n                }\n            } );\n            const sortedTypeNames = typeNames.sort();\n            typeNames = _.uniq( sortedTypeNames, true );\n            if( typeNames ) {\n                var promise = exports._soaSvc.ensureModelTypesLoaded( typeNames );\n                if( promise ) {\n                    promise.then( function() {\n                        return validatePolicy( policy, ++callCount );\n                    } );\n                    return;\n                }\n            }\n        }\n\n        var output = [];\n        _.forEach( policy.types, function( type ) {\n            var modelType = cmm.getType( type.name );\n            if( modelType ) {\n                if( type.properties ) {\n                    var parentModelType = cmm.getType( modelType.parentTypeName );\n                    _.forEach( type.properties, function( property ) {\n                        if( property ) {\n                            if( !modelType.propertyDescriptorsMap.hasOwnProperty( property.name ) ) {\n                                output.push( 'Invalid property [' + property.name + '] on type [' +\n                                    type.name + ']' );\n                            } else if( parentModelType &&\n                                parentModelType.propertyDescriptorsMap.hasOwnProperty( property.name ) ) {\n                                output.push( 'Wrong type for property [' + property.name + '] on type [' +\n                                    type.name + '], should be on type [' +\n                                    getParentType( parentModelType.name, property.name ) + ']' );\n                            } else {\n                                output.push( 'Effective property [' + property.name + '] on type [' +\n                                    type.name + ']' );\n                            }\n                        } else {\n                            output.push( 'Empty property on type [' + type.name + ']' );\n                        }\n                    } );\n                }\n            } else {\n                output.push( 'Invalid type [' + type.name + ']' );\n            }\n            if( !type.properties && !type.modifiers ) {\n                output.push( 'Missing properties for type [' + type.name + ']' );\n            }\n        } );\n\n        if( output.length > 0 ) {\n            output.sort();\n            logger.info( output.join( '\\n' ) );\n        }\n    }\n}\n\n/**\n * @param {Array} modelObjects array of model objects\n * @param {Array} propNames array of property names\n */\nexport let validatePropertyRegistration = function( modelObjects, propNames ) {\n    var policy = exports.getEffectivePolicy();\n    var msg = '';\n    _.forEach( modelObjects, function( modelObject ) {\n        if( modelObject ) {\n            var modelType = modelObject.modelType;\n            _.forEach( propNames, function( propName ) {\n                if( modelType.propertyDescriptorsMap.hasOwnProperty( propName ) && policy.types ) {\n                    var found = false;\n                    for( var kk = 0; kk < policy.types.length && !found; kk++ ) {\n                        var type = policy.types[ kk ];\n                        if( type.properties && modelType.typeHierarchyArray.indexOf( type.name ) > -1 ) {\n                            for( var ll = 0; ll < type.properties.length && !found; ll++ ) {\n                                var property = type.properties[ ll ];\n                                if( property.name === propName ) {\n                                    found = true;\n                                }\n                            }\n                        }\n                    }\n                    if( !found ) {\n                        msg += '\\n\\tType [' + modelType.displayName + '] PropertyName [' + propName + ']';\n                    }\n                }\n            } );\n        }\n    } );\n\n    if( msg ) {\n        logger.debug( 'Property Policy registration is missing for the following:' + msg );\n    }\n};\n\n/**\n * Register a policy which may need to be loaded from a separate json file.\n *\n * @param {Object|String} propertyPolicy - A property policy object or a path to the file containing the policy\n *\n * @return {Promise} A promise that will be resolved with the new policy id\n */\nexport let registerPolicyAsync = function( propertyPolicy ) {\n    // If it's a string it's a path to a policy file that needs to be loaded\n    if( typeof propertyPolicy === 'string' ) {\n        if( propertyPolicy.startsWith( '/' ) ) {\n            propertyPolicy = propertyPolicy.slice( 1 );\n        }\n        return moduleLoader.loadDependentModule( propertyPolicy ).then( ( result ) => {\n            return exports.register( result );\n        } );\n    }\n    // Otherwise it must be the actual policy object\n    return AwPromiseService.instance.when( exports.register( propertyPolicy ) );\n};\n\nexports = {\n    _policyId2policy,\n    _policyId2registrationTimeStamp,\n    _policyCount,\n    _effectivePolicy,\n    _soaSvc,\n    _parentSelections,\n    _currentSelections,\n    _selectedPolicyIds,\n    _genericPolicyIds,\n    _selectedPropertyUsed,\n    getEffectivePolicy,\n    checkForSelectedObject,\n    setSelectedObjects,\n    addToParentSelection,\n    removeFromParentSelection,\n    register,\n    unregister,\n    validatePropertyRegistration,\n    registerPolicyAsync\n};\nexport default exports;\n\n/**\n * Catch the event for logging all registered policies in the current session and logging the effective policy\n * in the session\n */\neventBus.subscribe( 'cdm.logDiagnostics', function() {\n    var policy = exports.getEffectivePolicy();\n    logger.info( 'Property Policy Audit Console Logging :' );\n\n    _.forEach( exports._policyId2registrationTimeStamp, function( times, policyId ) {\n        logger.debug( 'Registered Property Policy Id \"' + policyId + '\" @ ' + times.time + ':', times.policy );\n    } );\n\n    logger.debug( 'Effective Property Policy in session:', policy );\n\n    validatePolicy( policy, 1 );\n}, 'soa_kernel_propertyPolicyService' );\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}