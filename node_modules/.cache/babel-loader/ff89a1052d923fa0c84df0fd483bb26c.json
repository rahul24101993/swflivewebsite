{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/actionService\n *\n * @namespace actionService\n */\nimport soaSvc from 'soa/kernel/soaService';\nimport declarativeDataCtxSvc from 'js/declarativeDataCtxService';\nimport propertyPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingSvc from 'js/messagingService';\nimport conditionSvc from 'js/conditionService';\nimport navigationService from 'js/navigationService';\nimport adapterSvc from 'js/adapterService';\nimport dataMapperSvc from 'js/dataMapperService';\nimport cfgSvc from 'js/configurationService';\nimport batchActionService from 'js/batchActionService';\n/** revisitme Shaishav\n * Hint: We need to bring following services\nimport wysModeSvc from 'js/wysiwygModeService';\n*/\n\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport declUtils from 'js/declUtils';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader'; // Services\n\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport ClipboardService from 'js/clipboardService';\nimport debugService from 'js/debugService';\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\n\nvar _actionPropsToLog = ['actionId', 'actionType', 'method', 'serviceName', 'deps', 'actionId'];\n/**\n * {Boolean} TRUE if 'action' activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current\n * document's URL.\n */\n\nvar _logActionActivity = browserUtils.getUrlAttributes().logActionActivity !== undefined;\n/**\n * {Boolean} TRUE if 'action' event activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current\n * document's URL.\n */\n\n\nvar _logActionEventActivity = browserUtils.getUrlAttributes().logActionEventActivity !== undefined;\n/**\n * Define public API\n */\n\n\nvar exports = {};\n/**\n * Makes SOA call with given action and inputData. return the promise object.\n *\n * @param {Object} action - The 'declAction' object.\n * @param {Object} inputData - The 'inputData' object.\n *\n * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a\n *         problem).\n */\n\nvar _callSOA = function (action, inputData, propertyPolicyOverride) {\n  var promise = null;\n\n  if (action.actionType === 'TcSoaService') {\n    if (action.serviceName) {\n      if (action.inputData) {\n        promise = soaSvc.postUnchecked(action.serviceName, action.method, inputData, propertyPolicyOverride, null, action.headerState);\n      } else {\n        promise = AwPromiseService.instance.reject('No TcSoaService input data specified');\n      }\n    } else {\n      promise = AwPromiseService.instance.reject('No TcSoaService service specified');\n    }\n  } else {\n    promise = AwPromiseService.instance.reject('Unknown action type: ' + action.actionType);\n  }\n\n  return promise;\n};\n\nvar actionInputDataLogging = function (action, inputData) {\n  /**\n   * Now that any binding has happened, log the current action (if necessary)\n   */\n  if (_logActionActivity) {\n    logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2));\n\n    if (action.actionType === 'RESTService') {\n      logger.info('RESTService.inputData: ' + '\\n' + JSON.stringify(inputData, null, 2));\n    } else if (action.actionType === 'GraphQL' || action.actionType === 'JSFunctionAsync' && action.method === 'callGraphQL') {\n      logger.info('GraphQL.inputData: ' + '\\n' + JSON.stringify(inputData, null, 2));\n\n      if (action.outputData) {\n        logger.info('GraphQL.outputData: ' + '\\n' + JSON.stringify(action.outputData, null, 2));\n      }\n    }\n  }\n};\n\nvar processActionTypeEvent = function (declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred) {\n  setTimeout(function () {\n    if (!declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action not processed.', 'applyExpression');\n      return;\n    } // here needs updated info and eveulation context\n\n\n    let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n    /**\n     * Loop for each 'event' type action and publish the ones who's conditions are\n     * currently TRUE.\n     */\n\n    _.forEach(action.inputData.events, function (event) {\n      var conditionValue = true;\n\n      if (event.condition) {\n        conditionValue = conditionSvc.evaluateConditionExpression(event.condition, localContext.data, {\n          evaluationEnv: { ...localContext\n          },\n          depModuleObj\n        });\n      }\n\n      if (conditionValue) {\n        if (_logActionEventActivity) {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'ActionEvent: ' + event.name);\n        }\n\n        var eventDataToPublish = {};\n\n        if (event.eventData) {\n          eventDataToPublish = _.cloneDeep(event.eventData);\n          declarativeDataCtxSvc.applyScope(localContext.data, eventDataToPublish, functionsList, localContext, depModuleObj);\n        }\n\n        eventDataToPublish._source = declViewModel._internal.modelId;\n\n        if (event.excludeLocalDataCtx !== true) {\n          eventDataToPublish.scope = localContext;\n        }\n\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugEventPub(action, event, localContext.data, localContext, eventDataToPublish);\n        }\n\n        eventBus.publish(event.name, eventDataToPublish, true);\n      }\n    });\n\n    deferred.resolve();\n  }, 0);\n};\n\nvar processActionTypeJsFun = function (inputData, action, deferred, depModuleObj) {\n  var params = [];\n\n  _.forEach(inputData, function (param) {\n    params.push(param);\n  });\n\n  try {\n    const applyFn = depModuleObj[action.method].apply(depModuleObj, params);\n\n    if (typeof (applyFn === null || applyFn === void 0 ? void 0 : applyFn.then) === 'function') {\n      applyFn.then(resolved => {\n        deferred.resolve(resolved);\n      }, err => {\n        deferred.reject(err);\n      });\n    } else {\n      deferred.resolve(applyFn);\n    }\n  } catch (error) {\n    deferred.reject({\n      errorCode: error\n    });\n  }\n};\n\nvar getActionInputData = function (action, inputData) {\n  if (action.inputData) {\n    inputData = _.cloneDeep(action.inputData);\n  } else if (action.navigationParams) {\n    if (typeof action.navigationParams === 'string') {\n      inputData = {\n        navigationParams: action.navigationParams\n      };\n    } else {\n      inputData = _.cloneDeep(action.navigationParams);\n    }\n  }\n\n  return inputData;\n};\n\nvar eveulateActionParameters = function (dataCtxNode, action, inputData) {\n  // if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data\n  // does not exist. In that case we need to process the dataCtxNode.parameter section to get default value\n  // for the parameters We might have some inputdata, which is referring to parameters section. The\n  // below code scans the action.inputData for \"{{parameters\" keyword as value in action.inputdata.\n  // {action: parameters: { \"param1\": \"{{data.xyz}}\"}, inputdata : { \"key1\":\"{{parameter.param1}}\"}}\n  // and replaces them with the default value specified in parameters in action.inputdata :\n  // {\"key1\":\"{{data.param1}}\" later we resolve the inputData, this helps us not to use applyScope\n  // twice.\n  if (!dataCtxNode.parameters && action.parameters) {\n    var keySequence = [];\n    var pattern = /^{{parameters/;\n\n    _.forEach(action.inputData, function processInputData(value, key) {\n      if (value && _.isObject(value)) {\n        keySequence.push(key);\n\n        _.forEach(value, processInputData);\n\n        keySequence.pop();\n      } else if (value && _.isString(value) && pattern.test(value)) {\n        keySequence.push(key);\n        var eventMapKey = keySequence.join('.');\n        var parameterKey = parsingUtils.getStringBetweenDoubleMustaches(value);\n\n        _.set(inputData, eventMapKey, _.get(action, parameterKey, null));\n\n        keySequence.pop();\n      }\n    });\n  }\n};\n\nvar resolveInputData = function (inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError) {\n  if (inputData) {\n    if (declViewModel.isDestroyed()) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action results not applied to data context.', '_performAction');\n    } else {\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n      try {\n        declarativeDataCtxSvc.applyScope(localContext.data, inputData, functionsList, localContext, depModuleObj);\n      } catch (error) {\n        inputError = error;\n      }\n    }\n  }\n\n  return inputError;\n};\n\nvar _processAllDataProvider = function (dataProviderArray, declViewModel, dataCtxNode) {\n  var promises = [];\n\n  _.forEach(dataProviderArray, function (providerObj) {\n    var provider = providerObj.dataProvider;\n    /**\n     * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those\n     * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize\n     * the dataProvider and let it decide what to load.\n     */\n\n    if (provider.json.firstPage) {\n      var firstPageObjs = [];\n\n      _.forEach(provider.json.firstPage, function (uid) {\n        var vmos = declViewModel.objects[uid];\n\n        if (Array.isArray(vmos)) {\n          Array.prototype.push.apply(firstPageObjs, vmos);\n        } else if (vmos !== undefined) {\n          // LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.\n          firstPageObjs.push(vmos);\n        }\n      });\n      /**\n       * This code evaluates the page size to determine if we need to increment total. This is\n       * necessary for object sets, as we do not know the totalFound.\n       */\n\n\n      var maxToLoad;\n\n      if (provider.action && provider.action.inputData) {\n        var actionInputData = provider.action.inputData;\n\n        if (actionInputData.searchInput) {\n          maxToLoad = actionInputData.searchInput.maxToLoad;\n        }\n      }\n\n      var totalFound = firstPageObjs.length > 0 ? firstPageObjs.length + 1 : 0;\n\n      if (maxToLoad) {\n        totalFound = firstPageObjs.length === maxToLoad ? firstPageObjs.length + 1 : firstPageObjs.length;\n      }\n\n      provider.update(firstPageObjs, totalFound);\n    } else {\n      var args = [dataCtxNode, declViewModel];\n      promises.push(provider[providerObj.action].apply(provider, args));\n    }\n  });\n\n  return AwPromiseService.instance.all(promises);\n};\n/**\n * Execute the given 'dataprovider action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.\n */\n\n\nexport let performDataProviderAction = function (declViewModel, action, dataCtxNode) {\n  var dataProviderArray = [];\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel);\n\n  var createDataProviderInput = function (dataProvider, action) {\n    return {\n      dataProvider: dataProvider,\n      action: action ? action : 'initialize'\n    };\n  };\n\n  if (action.methods && _.isArray(action.methods)) {\n    _.forEach(action.methods, function (method) {\n      var dataProvider = declViewModel.dataProviders[method];\n      var dpAction = action.inputData && action.inputData.action ? action.inputData.action : 'initialize';\n\n      if (dataProvider) {\n        dataProviderArray.push(createDataProviderInput(dataProvider, dpAction));\n      }\n    });\n  } else if (action.method) {\n    if (action.inputData && action.inputData.action) {\n      // Table edit use case\n      var dpAction = action.inputData.action;\n      dataProviderArray.push(createDataProviderInput(declViewModel.dataProviders[action.method], dpAction));\n    } else {\n      // with the new implementation resetDataProvider will re-initialize the dataprovider.\n      declViewModel.dataProviders[action.method].resetDataProvider();\n    }\n  } else {\n    logger.warn('Missing action method(s) name for action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2));\n  }\n\n  if (!_.isEmpty(dataProviderArray)) {\n    const {\n      dispatch\n    } = declViewModel;\n    return _processAllDataProvider(dataProviderArray, declViewModel, dataCtxNode).then(() => {\n      // Rules to use dispatch:\n      // - Make sure it is 'immutable change' otherwise it is not getting rerender\n      // - Make sure 'immutable change' dosen't change the object type with no indention\n      //   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object\n      dispatch({\n        path: 'dataProviders',\n        value: { ...declViewModel.dataProviders\n        }\n      });\n    });\n  }\n\n  return 0;\n};\n\nvar processActionTypePopup = function (declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj) {\n  var _dataCtxNode$commandC;\n\n  let popupAction = declViewModel.actions[action.actionId];\n  let updateOptions = inputData && inputData.options || {}; // override popupAction if defined in commandContext - AwCommandService\n  // options could be overridden and customized\n\n  if ((_dataCtxNode$commandC = dataCtxNode.commandContext) !== null && _dataCtxNode$commandC !== void 0 && _dataCtxNode$commandC.popupAction) {\n    // case: it's a normal command\n    popupAction = dataCtxNode.commandContext.popupAction;\n  } else if (!popupAction.show) {\n    // case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.\n    popupAction = appCtxSvc.getCtx('globalPopup');\n  } // case customized popup actions - inject popupAction as last params for action.method\n  // application manages when / how to invoke show / hide\n\n\n  if (action.method && action.deps) {\n    let params = [];\n\n    _.forEach(inputData, function (param) {\n      params.push(param);\n    });\n\n    params.push(popupAction, updateOptions);\n\n    try {\n      const applyFn = depModuleObj[action.method].apply(depModuleObj, params);\n\n      if (typeof (applyFn === null || applyFn === void 0 ? void 0 : applyFn.then) === 'function') {\n        applyFn.then(resolved => {\n          deferred.resolve(resolved);\n        }, err => {\n          deferred.reject(err);\n        });\n      } else {\n        deferred.resolve(applyFn);\n      }\n    } catch (error) {\n      deferred.reject({\n        errorCode: error\n      });\n    } // default plain popup actions\n\n  } else {\n    // TODO: build params based on inputData, props, viewData\n    let evaluatedOptions = inputData && inputData.options || null; // only apply dynamic options\n    // if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {\n    //     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {\n    //         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );\n    //         return result;\n    //     }, {} );\n    // }\n\n    try {\n      popupAction.show(evaluatedOptions).then(function (resolved) {\n        deferred.resolve(resolved);\n      }, function (err) {\n        deferred.reject(err);\n      });\n    } catch (error2) {\n      deferred.reject({\n        errorCode: error2\n      });\n    }\n  }\n};\n\nvar processActionTypeCopy = function (inputData, promise) {\n  /**\n   * This actionType is needed when we are dealing with OS commands like copying to clipboard\n   * which needs to run without any defer mechanism. Since document.execCommand('copy') will\n   * be successful only when it runs through a user click event and not with defer and digest\n   * cycle event. we can use this actionType for other copy command too apart from shareURL\n   * since it calls the same document.execCommand('copy') function after copying it to\n   * awclipboard.\n   */\n\n  /**\n   * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.\n   */\n  if (inputData.copyType === 'URL') {\n    var adaptedObjects = adapterSvc.getAdaptedObjectsSync(inputData.objectToCopy);\n    ClipboardService.instance.copyUrlToClipboard(adaptedObjects);\n    promise = AwPromiseService.instance.when();\n  } else if (inputData.copyType === 'Object') {\n    ClipboardService.instance.copyHyperlinkToClipboard(inputData.objectToCopy);\n    promise = AwPromiseService.instance.when();\n  }\n\n  return promise;\n};\n\nvar processActionTypeNaviagte = function (action, inputData) {\n  if (action.navigateTo) {\n    if (inputData.navigationParams) {\n      inputData = inputData.navigationParams;\n    }\n\n    return navigationService.navigate(action, inputData);\n  }\n\n  return AwPromiseService.instance.reject('Missing navigate to in action type: ' + action.actionType + ' for actionId: ' + action.actionId);\n};\n\nvar processActionTypeEdit = function (action, declViewModel) {\n  var methods = ['startEdit', 'saveEdits', 'cancelEdits', 'isDirty'];\n\n  if (action.method && methods.indexOf(action.method) !== -1) {\n    return declViewModel[action.method].apply(declViewModel);\n  }\n\n  return AwPromiseService.instance.reject('Not a valid edit action : ' + action.method);\n};\n\nvar processActionTypeSync = function (action, inputData, declViewModel) {\n  if (inputData.port) {\n    return import('js/syncStrategyService').then(function (syncStrategyService) {\n      return syncStrategyService.updatePort(declViewModel, inputData, exports);\n    });\n  }\n\n  return AwPromiseService.instance.reject('Missing port to in action type: ' + action.actionType + ' for actionId: ' + action.actionId);\n};\n\nvar loadCustomActionDependentModule = function (customAction) {\n  var depModuleObj = moduleLoader.getDependentModule(customAction.deps);\n\n  if (depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }\n\n  return moduleLoader.loadDependentModule(customAction.deps).then(function success(depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }, function reject(error) {\n    return AwPromiseService.instance.reject(error);\n  });\n};\n/**\n * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will\n * be returned.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n * @param {Object} action - The 'declAction' to be executed.\n * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.\n * @param {Object} dataCtxNode - The data context node which holds interpolation values.\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n */\n\n\nvar _performAction = function (declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride) {\n  if (!action) {\n    return AwPromiseService.instance.reject('Missing action parameter');\n  }\n\n  if (!action.actionType) {\n    return AwPromiseService.instance.reject('Missing action type for actionId: ' + action.actionId);\n  }\n\n  var inputData = null;\n  var inputError = null;\n  /**\n   * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.\n   * <P>\n   * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the\n   * time the action is queued to be executed and when we get here.\n   */\n\n  if (action.altInputData) {\n    inputData = action.altInputData;\n  } else {\n    inputData = getActionInputData(action, inputData);\n    eveulateActionParameters(dataCtxNode, action, inputData);\n    inputError = resolveInputData(inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError);\n  }\n  /**\n   * Now that any binding has happened, log the current action (if necessary)\n   */\n\n\n  actionInputDataLogging(action, inputData);\n  /**\n   * Check for an input error\n   */\n\n  var promise = null;\n  var deferred;\n\n  if (inputError) {\n    promise = AwPromiseService.instance.reject({\n      errorCode: inputError\n    });\n    return promise;\n  }\n\n  return declarativeDataCtxSvc.applyExpression(inputData).then(function () {\n    debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel, inputData);\n\n    if (action.actionType === 'dataProvider') {\n      promise = exports.performDataProviderAction(declViewModel, action, dataCtxNode);\n    } else if (action.actionType === 'TcSoaService') {\n      promise = _callSOA(action, inputData, propertyPolicyOverride);\n    } else if (action.actionType === 'RESTService') {\n      promise = AwHttpService.instance(inputData.request);\n    } else if (action.actionType === 'Event') {\n      if (action.inputData) {\n        deferred = AwPromiseService.instance.defer();\n        processActionTypeEvent(declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred);\n        promise = deferred.promise;\n      }\n    } else if (action.actionType === 'JSFunction' || action.actionType === 'JSFunctionAsync') {\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypeJsFun(inputData, action, deferred, depModuleObj);\n    } else if (action.actionType === 'Test') {\n      /**\n       * This actionType is meant to allow automated testing without the need for a live server to\n       * load dependent modules. The resolved data for the deferred action is just the same object\n       * that was given as the 'inputData'.\n       */\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      deferred.resolve(inputData);\n    } else if (action.actionType === 'popup') {\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypePopup(declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj);\n    } else if (action.actionType === 'Copy') {\n      promise = processActionTypeCopy(inputData, promise);\n    } else if (action.actionType === 'Navigate') {\n      promise = processActionTypeNaviagte(action, inputData);\n    } else if (action.actionType === 'Edit') {\n      promise = processActionTypeEdit(action, declViewModel);\n    } else if (action.actionType === 'batchJob') {\n      promise = batchActionService.executeBatchActions(declViewModel, action, dataCtxNode, exports);\n    } else if (action.actionType === 'Sync') {\n      return processActionTypeSync(action, inputData, declViewModel);\n    } else {\n      // process custom Action Type\n      deferred = AwPromiseService.instance.defer();\n      promise = deferred.promise;\n      processActionTypeCustom(action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj);\n    } // end of custom action\n\n\n    return promise;\n  });\n};\n\nvar processActionTypeCustom = function (action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj) {\n  cfgSvc.getCfg('actionTemplateDefs').then(function (actionTemplateDefs) {\n    if (actionTemplateDefs[action.actionType]) {\n      var customAction = _.cloneDeep(actionTemplateDefs[action.actionType]); // resolver for inputData defined at successive action template defs that include\n      // ctx, data and inputData\n\n\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n      var resolver = { ...localContext,\n        inputData: inputData\n      }; // load the dependent modules if deps is specified\n\n      if (customAction.deps) {\n        var depModuleObjPromise = loadCustomActionDependentModule(customAction);\n        depModuleObjPromise.then(function (depModuleObj) {\n          deferred.resolve(_performAction(declViewModel, customAction, functionsList, resolver, depModuleObj));\n        });\n      } else {\n        deferred.resolve(_performAction(declViewModel, customAction, functionsList, resolver, depModuleObj));\n      }\n    } else {\n      logger.error('error :: action type ->' + action.actionType + ' is missing.');\n      deferred.reject('Unknown action type: ' + action.actionType);\n    }\n  });\n};\n\nvar processDefaultErrorMsg = function (err, action) {\n  //var msg = null;\n  //var level = 1;\n  if (_.isString(err)) {\n    /**msg = err;\n    level = 3; */\n  } else if (err && err.message) {\n    /**msg = err.message.replace( /\\n/g, '<br>' );\n    level = err.level ? err.level : 3; */\n  } else {\n    /**msg = 'Unknown error message type for action ' + action.method;\n    level = 3;*/\n    logger.error(err);\n  }\n  /** revisitme Shaishav\n       * Hint: We need to bring wysiwygModeService\n       if( level <= 1 ) {\n           logger.info( msg );\n       } else {\n           wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );\n       }\n  */\n\n};\n\nvar processDefaultErrorTypeObject = function (err, isReported) {\n  var errInfo = null;\n\n  if (err.config && err.status && (err.status < 200 || err.status > 299)) {\n    /**\n     * Error from Angular's $http service.\n     */\n    errInfo = {\n      url: err.config.url,\n      method: err.config.method,\n      status: err.status,\n      statusText: err.statusText\n    };\n  } else if (err.cause && err.cause.config) {\n    /**\n     * Error due to lost network connectivity, server crash etc.\n     */\n    errInfo = {\n      url: err.cause.config.url,\n      method: err.cause.config.method,\n      status: err.cause.status,\n      statusText: err.cause.statusText\n    };\n  }\n\n  if (errInfo !== null) {\n    var errMsg = 'The HTTP \"' + errInfo.method + '\" method to url \"' + errInfo.url + '\" failed';\n\n    if (_.isString(errInfo.statusText) && errInfo.statusText.length > 0) {\n      errMsg = errMsg + ' (status = \"' + errInfo.statusText + '\").';\n    } else {\n      errMsg = errMsg + ' (status = \"' + errInfo.status + '\").';\n    }\n\n    isReported = true;\n    logger.error(errMsg);\n  }\n\n  return isReported;\n};\n\nconst parseConditonExp = (expression, evaluationEnv) => {\n  //This is not acomplete fix, needs to be revisited - LCS-565498\n  const exp = conditionSvc.getRealExpression(expression, evaluationEnv);\n\n  if (_.isString(exp)) {\n    return exp;\n  } //If the condition is object based, return the original expression\n\n\n  return expression;\n};\n/**\n * Process the events of the executed action\n *\n * @param {DeclViewModel} declViewModel - The declarative view model\n * @param {DeclAction} action - The declarative action.\n * @param {Object} events - The events of an action object on the View model\n * @param {Object} evaluationEnv - The environment on which to evaluate event conditions\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing\n *            action 'failure'.\n */\n\n\nvar _processActionEvents = function (declViewModel, action, events, evaluationEnv, dataCtxNode, depModuleObj, isSuccess) {\n  /**\n   * Check if there is no reason to continue.\n   */\n  if (_.isEmpty(events)) {\n    return;\n  } //new in afx 3.1.0\n\n\n  if (declViewModel.isDestroyed()) {\n    declUtils.logLifeCycleIssue(declViewModel, action, 'Action event(s) not processed.', '_processActionEvents');\n    return;\n  }\n\n  var functionsList = declViewModel._internal.functions;\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'events');\n\n  _.forEach(events, function (event) {\n    /**\n     * Fire event when condition value is true\n     */\n    var conditionValue = true;\n\n    if (event.condition) {\n      const expression = parseConditonExp(event.condition, declViewModel._internal);\n      conditionValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n        evaluationEnv,\n        depModuleObj\n      });\n    }\n\n    if (conditionValue) {\n      if (_logActionEventActivity) {\n        if (isSuccess) {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'SuccessEvent: ' + event.name);\n        } else {\n          logger.info('action: ' + '\\n' + JSON.stringify(action, _actionPropsToLog, 2) + '\\n' + 'FailureEvent: ' + event.name);\n        }\n      }\n\n      var eventData = {};\n\n      if (event.eventData) {\n        eventData = _.cloneDeep(event.eventData);\n        declarativeDataCtxSvc.applyScope(declViewModel, eventData, functionsList, dataCtxNode, depModuleObj);\n      }\n\n      if (event.excludeLocalDataCtx !== true) {\n        eventData.scope = dataCtxNode;\n      }\n\n      eventData._source = declViewModel._internal.modelId;\n      eventBus.publish(event.name, eventData, true);\n\n      if (logger.isDeclarativeLogEnabled()) {\n        debugService.debugEventPub(action, event, declViewModel, dataCtxNode, eventData);\n      }\n    }\n  });\n};\n\nvar processActionFailureEvents = function (events, err, evaluationEnv, declViewModel, action, dataCtxNode, depModuleObj) {\n  if (events && events.failure) {\n    var _err$response;\n\n    if (err.cause && err.cause.partialErrors) {\n      /**\n       * Add the error in the evaluation env for each of the events\n       */\n      _.forEach(events.failure, function (failureEvt) {\n        _.forEach(err.cause.partialErrors, function (partialError) {\n          if (partialError.errorValues) {\n            _.forEach(partialError.errorValues, function (errorValue) {\n              if (errorValue.code) {\n                evaluationEnv.errorCode = errorValue;\n\n                if (!evaluationEnv.errorCodes) {\n                  evaluationEnv.errorCodes = [];\n                }\n\n                evaluationEnv.errorCodes.push(errorValue);\n              }\n            });\n          }\n        });\n\n        _processActionEvents(declViewModel, action, [failureEvt], evaluationEnv, dataCtxNode, depModuleObj, false);\n      }); // If REST call is failed with error\n\n    } else if (err.status || (_err$response = err.response) !== null && _err$response !== void 0 && _err$response.status) {\n      // Add the error in the evaluation env for each of the events\n      evaluationEnv.errorCode = err;\n\n      _processActionEvents(declViewModel, action, events.failure, evaluationEnv, dataCtxNode, depModuleObj, false);\n    } else {\n      // Process all events in bulk\n      _processActionEvents(declViewModel, action, events.failure, evaluationEnv, dataCtxNode, depModuleObj, false);\n    }\n  }\n};\n\nvar processPartialError = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj) {\n  let matchingMessages = [];\n\n  _.forEach(err.cause.partialErrors, function (partialError) {\n    if (partialError.errorValues) {\n      _.forEach(partialError.errorValues, function (errorValue) {\n        if (errorValue.code) {\n          _.forEach(actionMessages.failure, function (failureErr) {\n            var condValue = true;\n\n            if (failureErr.condition) {\n              evaluationEnv.errorCode = errorValue;\n              const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n              condValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n                evaluationEnv,\n                depModuleObj\n              });\n            }\n\n            if (condValue) {\n              if (!failureErr.errorCode) {\n                failureErr.errorCode = [];\n              }\n\n              failureErr.errorCode.push(errorValue);\n\n              if (matchingMessages.indexOf(failureErr) === -1) {\n                matchingMessages.push(failureErr);\n              }\n            }\n          });\n        }\n      });\n    }\n  });\n\n  return matchingMessages;\n};\n\nvar processActionHavingCause = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj) {\n  let allMessages = null;\n  let isReported = false;\n\n  _.forEach(err.cause.messages, function (message) {\n    if (message.code) {\n      _.forEach(actionMessages.failure, function (failureErr) {\n        let conditionResult = false;\n\n        if (failureErr.condition) {\n          // two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123\n          evaluationEnv.errorCode = failureErr.condition.indexOf('.code') > -1 ? message : message.code;\n          const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n          conditionResult = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n            evaluationEnv,\n            depModuleObj\n          });\n        }\n\n        if (conditionResult || failureErr.message && failureErr.condition === undefined) {\n          isReported = true;\n\n          if (!allMessages) {\n            allMessages = _.cloneDeep(declViewModel._internal.messages);\n          }\n\n          evaluationEnv.errorCode = message.message;\n          messagingSvc.reportNotyMessage(declViewModel, allMessages, failureErr.message, evaluationEnv);\n        }\n      });\n    }\n  });\n\n  return isReported;\n};\n\nvar processActionHavingErrorCode = function (err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode) {\n  var isReported = false;\n  var allMessages = null;\n  /**\n   * Notify error raised by a JS function call\n   */\n\n  _.forEach(actionMessages.failure, function (failureErr) {\n    var condValue = true;\n\n    if (failureErr.condition) {\n      var _err$response2;\n\n      if (err.status || (_err$response2 = err.response) !== null && _err$response2 !== void 0 && _err$response2.status) {\n        // In case failure is from REST call\n        evaluationEnv.errorCode = err;\n      } else {\n        evaluationEnv.errorCode = err.errorCode;\n      }\n\n      const expression = parseConditonExp(failureErr.condition, declViewModel._internal);\n      condValue = conditionSvc.evaluateConditionExpression(expression, declViewModel, {\n        evaluationEnv,\n        depModuleObj\n      });\n    }\n\n    if (condValue) {\n      isReported = true;\n\n      if (!allMessages) {\n        allMessages = _.cloneDeep(declViewModel._internal.messages);\n      }\n\n      messagingSvc.reportNotyMessage(declViewModel, allMessages, failureErr.message, dataCtxNode, depModuleObj);\n    }\n  });\n\n  return isReported;\n};\n\nvar processActionFailureMessage = function (actionMessages, err, evaluationEnv, declViewModel, depModuleObj, isReported, dataCtxNode) {\n  if (actionMessages && actionMessages.failure) {\n    var _err$response3;\n\n    if (err.cause && err.cause.partialErrors) {\n      // Notify error message when condition matched\n      var allMessages;\n\n      if (actionMessages.failure.length > 0) {\n        var matchingMessages = [];\n        var scopedAllMessages = [];\n\n        var reportError = function (failureErr, idx) {\n          evaluationEnv.errorCode = failureErr.errorCode.reduce((acc, err, index, arr) => {\n            acc += err.message + (arr.length - 1 === index ? '' : '<br/>');\n            return acc;\n          }, '');\n          messagingSvc.reportNotyMessage(declViewModel, scopedAllMessages[idx], failureErr.message, evaluationEnv);\n          failureErr.errorCode = null;\n        };\n\n        matchingMessages = processPartialError(err, actionMessages, evaluationEnv, declViewModel, depModuleObj);\n\n        if (!allMessages && matchingMessages.length > 0) {\n          allMessages = _.cloneDeep(declViewModel._internal.messages);\n          scopedAllMessages.push(allMessages);\n          isReported = true;\n        }\n\n        matchingMessages.forEach(function (message, index) {\n          reportError(message, index);\n        });\n      } else {\n        /**\n         * Notify SOA error message when no condition specified\n         var errMessage = messagingSvc.getSOAErrorMessage( err ); */\n        isReported = true;\n        /** revisitme Shaishav\n         * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module\n         * should not depend on layer 3 modules. We need to correct that.\n        wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );\n        */\n      }\n    } else if (err.cause && err.cause.messages) {\n      isReported = processActionHavingCause(err, actionMessages, evaluationEnv, declViewModel, depModuleObj);\n    } else if (err.errorCode || err.status || (_err$response3 = err.response) !== null && _err$response3 !== void 0 && _err$response3.status) {\n      isReported = processActionHavingErrorCode(err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode);\n    }\n  }\n\n  return isReported;\n};\n\nvar performOutputDataMapping = function (resolvedAssignments, declViewModel, prop) {\n  const {\n    dispatch,\n    updateAtomicData\n  } = declViewModel;\n  let finalObj = {};\n\n  for (prop in resolvedAssignments) {\n    // special property\n    const basePath = prop.split('.')[0];\n\n    if (declViewModel.atomicData && declViewModel.atomicData[basePath]) {\n      _.set(declViewModel.atomicData, prop, resolvedAssignments[prop]);\n\n      updateAtomicData[basePath](_.cloneDeep(declViewModel.atomicData[basePath]));\n    } else {\n      let key = `data.${prop}`;\n      finalObj[key] = resolvedAssignments[prop];\n    }\n  }\n\n  if (dispatch && Object.keys(finalObj).length > 0) {\n    dispatch({\n      value: finalObj\n    });\n\n    _.forEach(resolvedAssignments, function (fromPath, toPath) {\n      _.set(declViewModel, toPath, fromPath);\n    });\n  }\n};\n\nvar loadFuncDependency = function (action, declViewModel, depModuleObj) {\n  // load function deps\n  var functionDeps = declUtils.getFunctionDeps(action, declViewModel._internal); // Filter already loaded deps\n\n  _.forEach(depModuleObj, function (funcValue, funcKey) {\n    var loaded = _.find(functionDeps, function (funcDep) {\n      // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n      // funcKey here is module name, fundDep here is js/fileName\n      // luckly it is passing today\n      return funcDep.includes(funcKey);\n    });\n\n    if (loaded) {\n      _.remove(functionDeps, function (funcDep) {\n        return funcDep === loaded;\n      });\n    }\n  });\n\n  return functionDeps;\n};\n\nvar getActionPolicyInfo = function (action, declViewModel, functionsList, dataCtxNode, depModuleObj) {\n  if (action.policy && action.actionType === 'TcSoaService') {\n    var policy = _.cloneDeep(action.policy);\n\n    declarativeDataCtxSvc.applyScope(declViewModel, policy, functionsList, dataCtxNode, depModuleObj);\n\n    if (policy.override === true) {\n      return {\n        propertyPolicyOverride: {\n          types: policy.types\n        }\n      };\n    }\n\n    return {\n      actionPolicyId: propertyPolicySvc.register({\n        types: policy.types\n      }, action.method + '_Policy')\n    };\n  }\n\n  return {};\n};\n/**\n * Process the 'Success' part of the executed action\n *\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\n\n\nvar _processSuccess = function (declViewModel, action, dataCtxNode, depModuleObj) {\n  var events = action.events;\n  var actionMessages = action.actionMessages;\n  var allMessages;\n  let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n  if (events && events.success) {\n    _processActionEvents(localContext.data, action, events.success, localContext, localContext, depModuleObj, true);\n  }\n\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'actionMessages');\n\n  if (actionMessages && actionMessages.success) {\n    _.forEach(actionMessages.success, function (successMessage) {\n      if (successMessage) {\n        var condValue = true;\n\n        if (successMessage.condition) {\n          const expression = parseConditonExp(successMessage.condition, declViewModel._internal);\n          condValue = conditionSvc.evaluateConditionExpression(expression, localContext.data, {\n            evaluationEnv: { ...localContext\n            },\n            depModuleObj\n          });\n        }\n\n        if (condValue) {\n          if (!allMessages) {\n            allMessages = _.cloneDeep(declViewModel._internal.messages);\n          }\n\n          messagingSvc.reportNotyMessage(localContext.data, allMessages, successMessage.message, localContext);\n        }\n      } else {\n        logger.error('Invalid action successMessage:' + successMessage);\n      }\n    });\n  }\n};\n/**\n * Process the error and the 'Failure' part of the executed action\n *\n * @param {Object} err - JavaScript Error object\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\n\n\nvar _processError = function (err, declViewModel, action, dataCtxNode, depModuleObj) {\n  var events = action.events;\n  var actionMessages = action.actionMessages;\n  let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n  processActionFailureEvents(events, err, localContext, localContext.data, action, localContext, depModuleObj);\n  var isReported = false;\n  debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'actionMessages');\n  isReported = processActionFailureMessage(actionMessages, err, localContext, localContext.data, depModuleObj, isReported, localContext);\n\n  if (!isReported && typeof err === 'object') {\n    isReported = processDefaultErrorTypeObject(err, isReported);\n  }\n  /**\n   * Fall back, report error if not raised till this point\n   */\n\n\n  if (!isReported) {\n    processDefaultErrorMsg(err, action);\n  }\n};\n/**\n * @param {DeclViewModel} declViewModel - Model that owns the action.\n * @param {DeclAction} action - Action to 'finish'.\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.\n * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.\n * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.\n */\n\n\nvar _finishAction = function (declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred) {\n  var err = null;\n\n  if (!_.isEmpty(actionResponseObj)) {\n    if (!_.isEmpty(actionResponseObj.partialErrors) || !_.isEmpty(actionResponseObj.PartialErrors)) {\n      err = soaSvc.createError(actionResponseObj);\n    }\n\n    if (actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors) {\n      err = soaSvc.createError(actionResponseObj.ServiceData);\n    }\n  }\n\n  if (err) {\n    _processError(err, declViewModel, action, dataCtxNode, depModuleObj);\n\n    deferred.reject(err);\n  } else {\n    _processSuccess(declViewModel, action, dataCtxNode, depModuleObj);\n\n    deferred.resolve(actionResponseObj);\n  }\n};\n\nvar performOutputDataMappingForBatch = function (resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred) {\n  var data = {\n    actionData: []\n  };\n\n  _.forEach(resolvedAssignments, function (fromPath, toPath) {\n    _.set(data.actionData, toPath, fromPath);\n  });\n\n  _finishAction(declViewModel, action, dataCtxNode, depModuleObj, data, deferred);\n};\n\nvar resolveActionOutputData = function (action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode) {\n  var deferredAssignments = {};\n  /**\n   * Loop for each mapping in the 'outputData' spec\n   */\n\n  var index = 0;\n\n  _.forEach(action.outputData, function (fromPath, toPath) {\n    var fromObj;\n\n    if (mapDataOnAction && action.outputArg) {\n      toPath = action.outputArg[index];\n    }\n\n    if (_.isBoolean(fromPath)) {\n      fromObj = fromPath;\n    } else if (_.isEmpty(fromPath)) {\n      /**\n       * To support action as JS function call, assign function return value as the result\n       * when empty value expression specified\n       */\n      fromObj = actionResponseObj;\n    } else if (_.isString(fromPath) && fromPath.indexOf('result.') === 0) {\n      /**\n       * If fromPath has a 'result.' prefix, parse the expression within fromPath to get\n       * the correct value.\n       */\n      var fromResultPath = fromPath.split('result.')[1];\n      fromObj = _.get(actionResponseObj, fromResultPath);\n    } else {\n      /**\n       * If fromPath is defined, parse the expression within fromPath to get the correct\n       * value.\n       */\n      let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n      fromObj = declarativeDataCtxSvc.getOutput(declViewModel, actionResponseObj, fromPath, depModuleObj, localContext);\n    }\n    /**\n     * If the toPath starts with ctx. update the appCtxService\n     */\n\n\n    if (toPath.indexOf('ctx.') === 0) {\n      var toCtxName = toPath.split('ctx.')[1];\n      appCtxSvc.updatePartialCtx(toCtxName, fromObj);\n    } else if (_.startsWith(toPath, 'ports.')) {\n      if (dataCtxNode.ports) {\n        _.set(dataCtxNode.ports, toPath.replace('ports.', ''), fromObj);\n      }\n    } else {\n      // The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the\n      // case in cleaner way\n      deferredAssignments[toPath] = AwPromiseService.instance.when(fromObj);\n    }\n\n    index += 1;\n  });\n\n  return deferredAssignments;\n};\n/**\n * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.\n * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}\n * @param {DeclAction} action - {DeclAction} being performed\n * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on\n * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the\n * 'deferred' remains untouched.\n */\n\n\nvar _isViewModelDestroyed = function (declViewModel, actionResponseObj, action, deferred, methodName) {\n  /**\n   * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can\n   * happen, for example, when multiple subscribers are listening to a common event like 'selection' and\n   * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close\n   * (thus destroying the dataCtxNode and the declViewModel associated with it).\n   * <P>\n   * If so: There is nothing more that can be done with the declViewModel and we just want to log a\n   * warning about the life cycle issue and 'resolve' the given 'deferred'.\n   */\n  if (declViewModel.isDestroyed()) {\n    /**\n     * If the action is trying to actually do something with the response and the view model is\n     * destroyed log an error\n     */\n    if (actionResponseObj) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action was therefore not finished.', methodName);\n    } // Otherwise do nothing\n\n\n    deferred.resolve();\n    return true;\n  }\n\n  return false;\n};\n/**\n * Perform a SOA action. Support calling SOA service, return the response object.\n *\n * @param {Object} action - The 'declAction' to be executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n */\n\n\nexport let performSOAAction = function (action) {\n  var deferred = AwPromiseService.instance.defer();\n\n  _callSOA(action, action.inputData).then(function (actionResponseObj) {\n    if (!declUtils.isNil(actionResponseObj)) {\n      var err = null;\n\n      if (actionResponseObj.partialErrors || actionResponseObj.PartialErrors) {\n        err = soaSvc.createError(actionResponseObj);\n      }\n\n      if (actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors) {\n        err = soaSvc.createError(actionResponseObj.ServiceData);\n      }\n\n      if (err) {\n        deferred.reject(err);\n      } else if (!_.isEmpty(action.outputData)) {\n        deferred.resolve(actionResponseObj);\n      }\n    }\n  }, function (err) {\n    deferred.reject(err);\n  });\n\n  return deferred.promise;\n};\n/**\n * Perform a action synchronously. Specificly for 'syncFunction' actionType.\n * Returns nothing.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n *\n * @param {Object} action - The 'declAction' to be executed.\n *\n * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.\n *\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n *\n * @returns {Object} The result of the called function.\n */\n\nexport let performActionSync = function (declViewModel, action, dataCtxNode, depModuleObj) {\n  if (!action) {\n    logger.error('Missing action definition for actionId ' + action.actionId);\n    return null;\n  }\n\n  if (!action.actionType) {\n    logger.error('Missing action type for actionId: ' + action.actionId);\n    return null;\n  }\n\n  if (action.actionType !== 'syncFunction') {\n    logger.error('Invalid action type for actionId: ' + action.actionId);\n    return null;\n  }\n\n  var inputData = null;\n  let inputError = null;\n\n  if (action.inputData) {\n    inputData = _.cloneDeep(action.inputData);\n  }\n\n  if (inputData) {\n    if (declViewModel.isDestroyed()) {\n      declUtils.logLifeCycleIssue(declViewModel, action, 'Action results not applied to data context.', 'performActionSync');\n    } else {\n      try {\n        // this may require it  latest info update to latest\n        let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n        declarativeDataCtxSvc.applyScope(localContext.data, inputData, null, localContext, depModuleObj);\n      } catch (error) {\n        inputError = error;\n      }\n    }\n  }\n\n  if (inputError) {\n    return null;\n  }\n  /**\n   * Collect function parameters from input data\n   */\n\n\n  var params = [];\n\n  _.forEach(inputData, function (param) {\n    params.push(param);\n  });\n\n  try {\n    return depModuleObj[action.method].apply(depModuleObj, params);\n  } catch (err) {\n    logger.error('Action ' + action.actionId + ' cannot be executed\\n' + err);\n  }\n\n  return null;\n};\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in\n *            the execution.\n * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on\n * viewModel/ctx.\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.\n */\n\nexport let executeAction = function (declViewModel, action, dataCtxNode, depModuleObj, mapDataOnAction, prop) {\n  // Note: Clipboard Service is not following the correct\n  // another approach is we can try to create asyncLoad method\n  // for all these case and merge them with current thenable flow\n\n  /** revisitme Shaishav\n   * Hint: Need to find the reason for this line. It is failing to compile in afx-next\n  ClipboardService.instance;\n  */\n  declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, null, 'executeAction (a)');\n  var deferred = AwPromiseService.instance.defer();\n  var functionsList = declViewModel._internal.functions;\n  var {\n    actionPolicyId,\n    propertyPolicyOverride\n  } = getActionPolicyInfo(action, declViewModel, functionsList, dataCtxNode, depModuleObj); // load function deps\n\n  var functionDeps = loadFuncDependency(action, declViewModel, depModuleObj);\n  /**\n   * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.\n   * This should probably be made right in the future as part of better performance work.\n   */\n\n  moduleLoader.loadDependentModules(functionDeps).then(function (functionDependancies) {\n    _.forEach(functionDependancies, function (funcDepVal, funcDepKey) {\n      depModuleObj[funcDepKey] = funcDepVal;\n    });\n\n    var promise = _performAction(declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride);\n\n    if (!promise) {\n      deferred.resolved();\n      return;\n    }\n\n    promise.then(function (actionResponseObj) {\n      /**\n       * Remove any policies that were registered for this action.\n       */\n      if (actionPolicyId) {\n        propertyPolicySvc.unregister(actionPolicyId);\n      }\n\n      if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (b)')) {\n        return;\n      }\n      /**\n       * Check if we have a response and an output data map to work with.\n       * <P>\n       * If so: Process all the action output definitions and stick them on the dataCtxNode.\n       * <P>\n       * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action\n       * object to handle boolean or number type object responses (D-47571).\n       */\n\n\n      if (!declUtils.isNil(actionResponseObj) && !_.isEmpty(action.outputData)) {\n        var deferredAssignments = {};\n        /* If dataParsers are defined, then run the actionResponseObj through them before pipelining\n         * to outPutData.\n         */\n\n        if (_.isArray(action.dataParsers)) {\n          actionResponseObj = dataMapperSvc.applyDataParseDefinitions(actionResponseObj, declViewModel, action.dataParsers, dataCtxNode, depModuleObj);\n        }\n\n        deferredAssignments = resolveActionOutputData(action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode);\n        AwPromiseService.instance.all(deferredAssignments).then(function (resolvedAssignments) {\n          //new in afx 3.1.0\n          if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (c)')) {\n            return;\n          }\n\n          if (mapDataOnAction) {\n            performOutputDataMappingForBatch(resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred);\n          } else {\n            performOutputDataMapping(resolvedAssignments, declViewModel, prop); // Update binding when data changed\n\n            _.defer(function () {\n              //new in afx 3.1.0\n              if (_isViewModelDestroyed(declViewModel, actionResponseObj, action, deferred, 'executeAction (d)')) {\n                return;\n              }\n\n              _finishAction(declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred);\n            });\n          }\n\n          debugService.debug('actions', declViewModel._internal.panelId, action.actionId, 'post', action, declViewModel, resolvedAssignments);\n\n          if (logger.isTraceEnabled()) {\n            let actionName = action.actionId ? action.actionId : action.method;\n            let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n            logger.trace('Action: ', actionName2);\n          }\n        });\n      } else {\n        _finishAction(declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred);\n\n        if (logger.isTraceEnabled()) {\n          let actionName = action.actionId ? action.actionId : action.method;\n          let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n          logger.trace('Action: ', actionName2);\n        }\n      }\n    }, function (err) {\n      // Extract error message from response and store it in view model\n      var error = _.cloneDeep(err);\n\n      _.set(declViewModel, 'error', error);\n\n      if (actionPolicyId) {\n        propertyPolicySvc.unregister(actionPolicyId);\n      }\n\n      _processError(err, declViewModel, action, dataCtxNode, depModuleObj);\n\n      deferred.reject(err);\n    });\n  });\n  return deferred.promise;\n};\nexports = {\n  performSOAAction,\n  executeAction,\n  performDataProviderAction,\n  performActionSync\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/actionService.js"],"names":["_actionPropsToLog","_logActionActivity","browserUtils","_logActionEventActivity","exports","_callSOA","promise","action","soaSvc","AwPromiseService","actionInputDataLogging","logger","JSON","processActionTypeEvent","setTimeout","declUtils","localContext","_","conditionValue","event","evaluationEnv","depModuleObj","eventDataToPublish","declarativeDataCtxSvc","declViewModel","debugService","eventBus","deferred","processActionTypeJsFun","params","applyFn","resolved","err","errorCode","error","getActionInputData","inputData","navigationParams","eveulateActionParameters","dataCtxNode","keySequence","pattern","value","eventMapKey","parameterKey","parsingUtils","resolveInputData","inputError","_processAllDataProvider","promises","provider","providerObj","firstPageObjs","vmos","Array","actionInputData","maxToLoad","totalFound","args","performDataProviderAction","dataProviderArray","createDataProviderInput","dataProvider","dpAction","dispatch","path","dataProviders","processActionTypePopup","popupAction","updateOptions","appCtxSvc","evaluatedOptions","error2","processActionTypeCopy","adaptedObjects","adapterSvc","ClipboardService","processActionTypeNaviagte","navigationService","processActionTypeEdit","methods","processActionTypeSync","syncStrategyService","loadCustomActionDependentModule","moduleLoader","customAction","_performAction","AwHttpService","batchActionService","processActionTypeCustom","cfgSvc","actionTemplateDefs","resolver","depModuleObjPromise","processDefaultErrorMsg","processDefaultErrorTypeObject","errInfo","url","method","status","statusText","errMsg","isReported","parseConditonExp","exp","conditionSvc","_processActionEvents","functionsList","expression","eventData","processActionFailureEvents","events","partialError","errorValue","processPartialError","matchingMessages","actionMessages","condValue","failureErr","processActionHavingCause","allMessages","message","conditionResult","messagingSvc","processActionHavingErrorCode","processActionFailureMessage","scopedAllMessages","reportError","acc","arr","performOutputDataMapping","updateAtomicData","finalObj","basePath","prop","resolvedAssignments","key","Object","loadFuncDependency","functionDeps","loaded","funcDep","getActionPolicyInfo","policy","propertyPolicyOverride","types","actionPolicyId","_processSuccess","successMessage","_processError","_finishAction","actionResponseObj","performOutputDataMappingForBatch","data","actionData","resolveActionOutputData","deferredAssignments","index","mapDataOnAction","toPath","fromObj","fromPath","fromResultPath","toCtxName","_isViewModelDestroyed","performSOAAction","performActionSync","executeAction","propertyPolicySvc","dataMapperSvc","actionName","actionName2"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/actionService\n *\n * @namespace actionService\n */\n\nimport soaSvc from 'soa/kernel/soaService';\nimport declarativeDataCtxSvc from 'js/declarativeDataCtxService';\nimport propertyPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingSvc from 'js/messagingService';\nimport conditionSvc from 'js/conditionService';\nimport navigationService from 'js/navigationService';\nimport adapterSvc from 'js/adapterService';\nimport dataMapperSvc from 'js/dataMapperService';\nimport cfgSvc from 'js/configurationService';\nimport batchActionService from 'js/batchActionService';\n/** revisitme Shaishav\n * Hint: We need to bring following services\nimport wysModeSvc from 'js/wysiwygModeService';\n*/\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport declUtils from 'js/declUtils';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n\n// Services\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport ClipboardService from 'js/clipboardService';\nimport debugService from 'js/debugService';\n\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\nvar _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'actionId' ];\n\n/**\n * {Boolean} TRUE if 'action' activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current\n * document's URL.\n */\nvar _logActionActivity = browserUtils.getUrlAttributes().logActionActivity !== undefined;\n\n/**\n * {Boolean} TRUE if 'action' event activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current\n * document's URL.\n */\nvar _logActionEventActivity = browserUtils.getUrlAttributes().logActionEventActivity !== undefined;\n\n/**\n * Define public API\n */\nvar exports = {};\n\n/**\n * Makes SOA call with given action and inputData. return the promise object.\n *\n * @param {Object} action - The 'declAction' object.\n * @param {Object} inputData - The 'inputData' object.\n *\n * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a\n *         problem).\n */\nvar _callSOA = function( action, inputData, propertyPolicyOverride ) {\n    var promise = null;\n    if( action.actionType === 'TcSoaService' ) {\n        if( action.serviceName ) {\n            if( action.inputData ) {\n                promise = soaSvc.postUnchecked( action.serviceName, action.method, inputData, propertyPolicyOverride, null, action.headerState );\n            } else {\n                promise = AwPromiseService.instance.reject( 'No TcSoaService input data specified' );\n            }\n        } else {\n            promise = AwPromiseService.instance.reject( 'No TcSoaService service specified' );\n        }\n    } else {\n        promise = AwPromiseService.instance.reject( 'Unknown action type: ' + action.actionType );\n    }\n    return promise;\n};\n\nvar actionInputDataLogging = function( action, inputData ) {\n    /**\n     * Now that any binding has happened, log the current action (if necessary)\n     */\n    if( _logActionActivity ) {\n        logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) );\n\n        if( action.actionType === 'RESTService' ) {\n            logger.info( 'RESTService.inputData: ' + '\\n' + JSON.stringify( inputData, null, 2 ) );\n        } else if( action.actionType === 'GraphQL' || action.actionType === 'JSFunctionAsync' && action.method === 'callGraphQL' ) {\n            logger.info( 'GraphQL.inputData: ' + '\\n' + JSON.stringify( inputData, null, 2 ) );\n            if( action.outputData ) {\n                logger.info( 'GraphQL.outputData: ' + '\\n' + JSON.stringify( action.outputData, null, 2 ) );\n            }\n        }\n    }\n};\n\nvar processActionTypeEvent = function( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred ) {\n    setTimeout( function() {\n        if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action not processed.',\n                'applyExpression' );\n            return;\n        }\n        // here needs updated info and eveulation context\n        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n        /**\n         * Loop for each 'event' type action and publish the ones who's conditions are\n         * currently TRUE.\n         */\n        _.forEach( action.inputData.events, function( event ) {\n            var conditionValue = true;\n\n            if( event.condition ) {\n                conditionValue = conditionSvc.evaluateConditionExpression( event.condition, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );\n            }\n\n            if( conditionValue ) {\n                if( _logActionEventActivity ) {\n                    logger.info( 'action: ' + '\\n' +\n                        JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'ActionEvent: ' + event.name );\n                }\n\n                var eventDataToPublish = {};\n\n                if( event.eventData ) {\n                    eventDataToPublish = _.cloneDeep( event.eventData );\n\n                    declarativeDataCtxSvc.applyScope( localContext.data, eventDataToPublish,\n                        functionsList, localContext, depModuleObj );\n                }\n\n                eventDataToPublish._source = declViewModel._internal.modelId;\n\n                if( event.excludeLocalDataCtx !== true ) {\n                    eventDataToPublish.scope = localContext;\n                }\n\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugEventPub( action, event, localContext.data, localContext, eventDataToPublish );\n                }\n\n                eventBus.publish( event.name, eventDataToPublish, true );\n            }\n        } );\n\n        deferred.resolve();\n    }, 0 );\n};\n\nvar processActionTypeJsFun = function( inputData, action, deferred, depModuleObj ) {\n    var params = [];\n    _.forEach( inputData, function( param ) {\n        params.push( param );\n    } );\n    try {\n        const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );\n        if( typeof applyFn?.then === 'function' ) {\n            applyFn.then(\n                resolved => {\n                    deferred.resolve( resolved );\n                },\n                err => {\n                    deferred.reject( err );\n                } );\n        } else {\n            deferred.resolve( applyFn );\n        }\n    } catch ( error ) {\n        deferred.reject( {\n            errorCode: error\n        } );\n    }\n};\n\nvar getActionInputData = function( action, inputData ) {\n    if( action.inputData ) {\n        inputData = _.cloneDeep( action.inputData );\n    } else if( action.navigationParams ) {\n        if( typeof action.navigationParams === 'string' ) {\n            inputData = { navigationParams: action.navigationParams };\n        } else {\n            inputData = _.cloneDeep( action.navigationParams );\n        }\n    }\n    return inputData;\n};\n\nvar eveulateActionParameters = function( dataCtxNode, action, inputData ) {\n    // if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data\n    // does not exist. In that case we need to process the dataCtxNode.parameter section to get default value\n    // for the parameters We might have some inputdata, which is referring to parameters section. The\n    // below code scans the action.inputData for \"{{parameters\" keyword as value in action.inputdata.\n    // {action: parameters: { \"param1\": \"{{data.xyz}}\"}, inputdata : { \"key1\":\"{{parameter.param1}}\"}}\n    // and replaces them with the default value specified in parameters in action.inputdata :\n    // {\"key1\":\"{{data.param1}}\" later we resolve the inputData, this helps us not to use applyScope\n    // twice.\n    if( !dataCtxNode.parameters && action.parameters ) {\n        var keySequence = [];\n        var pattern = /^{{parameters/;\n        _.forEach( action.inputData, function processInputData( value, key ) {\n            if( value && _.isObject( value ) ) {\n                keySequence.push( key );\n                _.forEach( value, processInputData );\n                keySequence.pop();\n            } else if( value && _.isString( value ) && pattern.test( value ) ) {\n                keySequence.push( key );\n                var eventMapKey = keySequence.join( '.' );\n                var parameterKey = parsingUtils.getStringBetweenDoubleMustaches( value );\n                _.set( inputData, eventMapKey, _.get( action, parameterKey, null ) );\n                keySequence.pop();\n            }\n        } );\n    }\n};\n\nvar resolveInputData = function( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError ) {\n    if( inputData ) {\n        if( declViewModel.isDestroyed() ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',\n                '_performAction' );\n        } else {\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            try {\n                declarativeDataCtxSvc.applyScope( localContext.data, inputData, functionsList, localContext,\n                    depModuleObj );\n            } catch ( error ) {\n                inputError = error;\n            }\n        }\n    }\n    return inputError;\n};\n\nvar _processAllDataProvider = function( dataProviderArray, declViewModel, dataCtxNode ) {\n    var promises = [];\n\n    _.forEach( dataProviderArray, function( providerObj ) {\n        var provider = providerObj.dataProvider;\n        /**\n         * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those\n         * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize\n         * the dataProvider and let it decide what to load.\n         */\n\n        if( provider.json.firstPage ) {\n            var firstPageObjs = [];\n\n            _.forEach( provider.json.firstPage, function( uid ) {\n                var vmos = declViewModel.objects[ uid ];\n                if( Array.isArray( vmos ) ) {\n                    Array.prototype.push.apply( firstPageObjs, vmos );\n                } else if( vmos !== undefined ) { // LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.\n                    firstPageObjs.push( vmos );\n                }\n            } );\n\n            /**\n             * This code evaluates the page size to determine if we need to increment total. This is\n             * necessary for object sets, as we do not know the totalFound.\n             */\n            var maxToLoad;\n            if( provider.action && provider.action.inputData ) {\n                var actionInputData = provider.action.inputData;\n                if( actionInputData.searchInput ) {\n                    maxToLoad = actionInputData.searchInput.maxToLoad;\n                }\n            }\n\n            var totalFound = firstPageObjs.length > 0 ? firstPageObjs.length + 1 : 0;\n            if( maxToLoad ) {\n                totalFound = firstPageObjs.length === maxToLoad ? firstPageObjs.length + 1 :\n                    firstPageObjs.length;\n            }\n\n            provider.update( firstPageObjs, totalFound );\n        } else {\n            var args = [ dataCtxNode, declViewModel ];\n            promises.push( provider[ providerObj.action ].apply( provider, args ) );\n        }\n    } );\n\n    return AwPromiseService.instance.all( promises );\n};\n\n/**\n * Execute the given 'dataprovider action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.\n */\nexport let performDataProviderAction = function( declViewModel, action, dataCtxNode ) {\n    var dataProviderArray = [];\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel );\n    var createDataProviderInput = function( dataProvider, action ) {\n        return {\n            dataProvider: dataProvider,\n            action: action ? action : 'initialize'\n        };\n    };\n\n    if( action.methods && _.isArray( action.methods ) ) {\n        _.forEach( action.methods, function( method ) {\n            var dataProvider = declViewModel.dataProviders[ method ];\n            var dpAction = action.inputData && action.inputData.action ? action.inputData.action : 'initialize';\n            if( dataProvider ) {\n                dataProviderArray.push( createDataProviderInput( dataProvider, dpAction ) );\n            }\n        } );\n    } else if( action.method ) {\n        if( action.inputData && action.inputData.action ) {\n            // Table edit use case\n            var dpAction = action.inputData.action;\n            dataProviderArray.push( createDataProviderInput( declViewModel.dataProviders[ action.method ], dpAction ) );\n        } else {\n            // with the new implementation resetDataProvider will re-initialize the dataprovider.\n            declViewModel.dataProviders[ action.method ].resetDataProvider();\n        }\n    } else {\n        logger.warn( 'Missing action method(s) name for action: ' + '\\n' +\n            JSON.stringify( action, _actionPropsToLog, 2 ) );\n    }\n\n    if( !_.isEmpty( dataProviderArray ) ) {\n        const { dispatch } = declViewModel;\n        return _processAllDataProvider( dataProviderArray, declViewModel, dataCtxNode )\n            .then( () => {\n                // Rules to use dispatch:\n                // - Make sure it is 'immutable change' otherwise it is not getting rerender\n                // - Make sure 'immutable change' dosen't change the object type with no indention\n                //   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object\n                dispatch( { path: 'dataProviders', value: { ...declViewModel.dataProviders } } );\n            } );\n    }\n    return 0;\n};\n\nvar processActionTypePopup = function( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj ) {\n    let popupAction = declViewModel.actions[ action.actionId ];\n    let updateOptions = inputData && inputData.options || {};\n    // override popupAction if defined in commandContext - AwCommandService\n    // options could be overridden and customized\n    if( dataCtxNode.commandContext?.popupAction ) {\n        // case: it's a normal command\n        popupAction = dataCtxNode.commandContext.popupAction;\n    } else if( !popupAction.show ) {\n        // case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.\n        popupAction = appCtxSvc.getCtx( 'globalPopup' );\n    }\n\n    // case customized popup actions - inject popupAction as last params for action.method\n    // application manages when / how to invoke show / hide\n    if( action.method && action.deps ) {\n        let params = [];\n        _.forEach( inputData, function( param ) {\n            params.push( param );\n        } );\n        params.push( popupAction, updateOptions );\n        try {\n            const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );\n            if( typeof applyFn?.then === 'function' ) {\n                applyFn.then(\n                    resolved => {\n                        deferred.resolve( resolved );\n                    },\n                    err => {\n                        deferred.reject( err );\n                    } );\n            } else {\n                deferred.resolve( applyFn );\n            }\n        } catch ( error ) {\n            deferred.reject( {\n                errorCode: error\n            } );\n        }\n        // default plain popup actions\n    } else {\n        // TODO: build params based on inputData, props, viewData\n        let evaluatedOptions = inputData && inputData.options || null;\n        // only apply dynamic options\n        // if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {\n        //     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {\n        //         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );\n        //         return result;\n        //     }, {} );\n        // }\n        try {\n            popupAction.show( evaluatedOptions ).then(\n                function( resolved ) {\n                    deferred.resolve( resolved );\n                },\n                function( err ) {\n                    deferred.reject( err );\n                } );\n        } catch ( error2 ) {\n            deferred.reject( {\n                errorCode: error2\n            } );\n        }\n    }\n};\n\nvar processActionTypeCopy = function( inputData, promise ) {\n    /**\n     * This actionType is needed when we are dealing with OS commands like copying to clipboard\n     * which needs to run without any defer mechanism. Since document.execCommand('copy') will\n     * be successful only when it runs through a user click event and not with defer and digest\n     * cycle event. we can use this actionType for other copy command too apart from shareURL\n     * since it calls the same document.execCommand('copy') function after copying it to\n     * awclipboard.\n     */\n    /**\n     * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.\n     */\n    if( inputData.copyType === 'URL' ) {\n        var adaptedObjects = adapterSvc.getAdaptedObjectsSync( inputData.objectToCopy );\n\n        ClipboardService.instance.copyUrlToClipboard( adaptedObjects );\n\n        promise = AwPromiseService.instance.when();\n    } else if( inputData.copyType === 'Object' ) {\n        ClipboardService.instance.copyHyperlinkToClipboard( inputData.objectToCopy );\n\n        promise = AwPromiseService.instance.when();\n    }\n    return promise;\n};\n\nvar processActionTypeNaviagte = function( action, inputData ) {\n    if( action.navigateTo ) {\n        if( inputData.navigationParams ) {\n            inputData = inputData.navigationParams;\n        }\n        return navigationService.navigate( action, inputData );\n    }\n    return AwPromiseService.instance.reject( 'Missing navigate to in action type: ' + action.actionType +\n        ' for actionId: ' + action.actionId );\n};\n\nvar processActionTypeEdit = function( action, declViewModel ) {\n    var methods = [ 'startEdit', 'saveEdits', 'cancelEdits', 'isDirty' ];\n\n    if( action.method && methods.indexOf( action.method ) !== -1 ) {\n        return declViewModel[ action.method ].apply( declViewModel );\n    }\n    return AwPromiseService.instance.reject( 'Not a valid edit action : ' + action.method );\n};\n\nvar processActionTypeSync = function( action, inputData, declViewModel ) {\n    if( inputData.port ) {\n        return import( 'js/syncStrategyService' ).then( function( syncStrategyService ) {\n            return syncStrategyService.updatePort( declViewModel, inputData, exports );\n        } );\n    }\n    return AwPromiseService.instance.reject( 'Missing port to in action type: ' + action.actionType + ' for actionId: ' + action.actionId );\n};\n\nvar loadCustomActionDependentModule = function( customAction ) {\n    var depModuleObj = moduleLoader.getDependentModule( customAction.deps );\n\n    if( depModuleObj ) {\n        return AwPromiseService.instance.resolve( depModuleObj );\n    }\n    return moduleLoader.loadDependentModule( customAction.deps ).then( function success( depModuleObj ) {\n        return AwPromiseService.instance.resolve( depModuleObj );\n    }, function reject( error ) {\n        return AwPromiseService.instance.reject( error );\n    } );\n};\n\n/**\n * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will\n * be returned.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n * @param {Object} action - The 'declAction' to be executed.\n * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.\n * @param {Object} dataCtxNode - The data context node which holds interpolation values.\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n */\nvar _performAction = function( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride ) {\n    if( !action ) {\n        return AwPromiseService.instance.reject( 'Missing action parameter' );\n    }\n\n    if( !action.actionType ) {\n        return AwPromiseService.instance.reject( 'Missing action type for actionId: ' + action.actionId );\n    }\n\n    var inputData = null;\n    var inputError = null;\n\n    /**\n     * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.\n     * <P>\n     * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the\n     * time the action is queued to be executed and when we get here.\n     */\n\n    if( action.altInputData ) {\n        inputData = action.altInputData;\n    } else {\n        inputData = getActionInputData( action, inputData );\n\n        eveulateActionParameters( dataCtxNode, action, inputData );\n\n        inputError = resolveInputData( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError );\n    }\n\n    /**\n     * Now that any binding has happened, log the current action (if necessary)\n     */\n    actionInputDataLogging( action, inputData );\n\n    /**\n     * Check for an input error\n     */\n    var promise = null;\n\n    var deferred;\n\n    if( inputError ) {\n        promise = AwPromiseService.instance.reject( {\n            errorCode: inputError\n        } );\n        return promise;\n    }\n\n    return declarativeDataCtxSvc.applyExpression( inputData ).then(\n        function() {\n            debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel, inputData );\n            if( action.actionType === 'dataProvider' ) {\n                promise = exports.performDataProviderAction( declViewModel, action, dataCtxNode );\n            } else if( action.actionType === 'TcSoaService' ) {\n                promise = _callSOA( action, inputData, propertyPolicyOverride );\n            } else if( action.actionType === 'RESTService' ) {\n                promise = AwHttpService.instance( inputData.request );\n            } else if( action.actionType === 'Event' ) {\n                if( action.inputData ) {\n                    deferred = AwPromiseService.instance.defer();\n                    processActionTypeEvent( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred );\n                    promise = deferred.promise;\n                }\n            } else if( action.actionType === 'JSFunction' || action.actionType === 'JSFunctionAsync' ) {\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypeJsFun( inputData, action, deferred, depModuleObj );\n            } else if( action.actionType === 'Test' ) {\n                /**\n                 * This actionType is meant to allow automated testing without the need for a live server to\n                 * load dependent modules. The resolved data for the deferred action is just the same object\n                 * that was given as the 'inputData'.\n                 */\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                deferred.resolve( inputData );\n            } else if( action.actionType === 'popup' ) {\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypePopup( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj );\n            } else if( action.actionType === 'Copy' ) {\n                promise = processActionTypeCopy( inputData, promise );\n            } else if( action.actionType === 'Navigate' ) {\n                promise = processActionTypeNaviagte( action, inputData );\n            } else if( action.actionType === 'Edit' ) {\n                promise = processActionTypeEdit( action, declViewModel );\n            } else if( action.actionType === 'batchJob' ) {\n                promise = batchActionService.executeBatchActions( declViewModel, action, dataCtxNode, exports );\n            } else if( action.actionType === 'Sync' ) {\n                return processActionTypeSync( action, inputData, declViewModel );\n            } else {\n                // process custom Action Type\n                deferred = AwPromiseService.instance.defer();\n                promise = deferred.promise;\n                processActionTypeCustom( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj );\n            } // end of custom action\n            return promise;\n        } );\n};\n\nvar processActionTypeCustom = function( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj ) {\n    cfgSvc.getCfg( 'actionTemplateDefs' ).then( function( actionTemplateDefs ) {\n        if( actionTemplateDefs[ action.actionType ] ) {\n            var customAction = _.cloneDeep( actionTemplateDefs[ action.actionType ] );\n            // resolver for inputData defined at successive action template defs that include\n            // ctx, data and inputData\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            var resolver = {\n                ...localContext,\n                inputData: inputData\n            };\n            // load the dependent modules if deps is specified\n            if( customAction.deps ) {\n                var depModuleObjPromise = loadCustomActionDependentModule( customAction );\n\n                depModuleObjPromise.then( function( depModuleObj ) {\n                    deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );\n                } );\n            } else {\n                deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );\n            }\n        } else {\n            logger.error( 'error :: action type ->' + action.actionType + ' is missing.' );\n            deferred.reject( 'Unknown action type: ' + action.actionType );\n        }\n    } );\n};\n\nvar processDefaultErrorMsg = function( err, action ) {\n    //var msg = null;\n    //var level = 1;\n    if( _.isString( err ) ) {\n        /**msg = err;\n        level = 3; */\n    } else if( err && err.message ) {\n        /**msg = err.message.replace( /\\n/g, '<br>' );\n        level = err.level ? err.level : 3; */\n    } else {\n        /**msg = 'Unknown error message type for action ' + action.method;\n        level = 3;*/\n        logger.error( err );\n    }\n    /** revisitme Shaishav\n         * Hint: We need to bring wysiwygModeService\n         if( level <= 1 ) {\n             logger.info( msg );\n         } else {\n             wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );\n         }\n    */\n};\n\nvar processDefaultErrorTypeObject = function( err, isReported ) {\n    var errInfo = null;\n    if( err.config && err.status && ( err.status < 200 || err.status > 299 ) ) {\n        /**\n         * Error from Angular's $http service.\n         */\n        errInfo = {\n            url: err.config.url,\n            method: err.config.method,\n            status: err.status,\n            statusText: err.statusText\n        };\n    } else if( err.cause && err.cause.config ) {\n        /**\n         * Error due to lost network connectivity, server crash etc.\n         */\n        errInfo = {\n            url: err.cause.config.url,\n            method: err.cause.config.method,\n            status: err.cause.status,\n            statusText: err.cause.statusText\n        };\n    }\n\n    if( errInfo !== null ) {\n        var errMsg = 'The HTTP \"' + errInfo.method + '\" method to url \"' + errInfo.url + '\" failed';\n\n        if( _.isString( errInfo.statusText ) && errInfo.statusText.length > 0 ) {\n            errMsg = errMsg + ' (status = \"' + errInfo.statusText + '\").';\n        } else {\n            errMsg = errMsg + ' (status = \"' + errInfo.status + '\").';\n        }\n\n        isReported = true;\n\n        logger.error( errMsg );\n    }\n    return isReported;\n};\n\nconst parseConditonExp = ( expression, evaluationEnv ) => {\n    //This is not acomplete fix, needs to be revisited - LCS-565498\n    const exp = conditionSvc.getRealExpression( expression, evaluationEnv );\n    if( _.isString( exp ) ) {\n        return exp;\n    }\n    //If the condition is object based, return the original expression\n    return expression;\n};\n\n/**\n * Process the events of the executed action\n *\n * @param {DeclViewModel} declViewModel - The declarative view model\n * @param {DeclAction} action - The declarative action.\n * @param {Object} events - The events of an action object on the View model\n * @param {Object} evaluationEnv - The environment on which to evaluate event conditions\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing\n *            action 'failure'.\n */\nvar _processActionEvents = function( declViewModel, action, events, evaluationEnv, dataCtxNode, depModuleObj,\n    isSuccess ) {\n    /**\n     * Check if there is no reason to continue.\n     */\n    if( _.isEmpty( events ) ) {\n        return;\n    }\n\n    //new in afx 3.1.0\n    if( declViewModel.isDestroyed() ) {\n        declUtils.logLifeCycleIssue( declViewModel, action, 'Action event(s) not processed.', '_processActionEvents' );\n        return;\n    }\n\n    var functionsList = declViewModel._internal.functions;\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'events' );\n\n    _.forEach( events, function( event ) {\n        /**\n         * Fire event when condition value is true\n         */\n        var conditionValue = true;\n\n        if( event.condition ) {\n            const expression = parseConditonExp( event.condition, declViewModel._internal );\n            conditionValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n        }\n\n        if( conditionValue ) {\n            if( _logActionEventActivity ) {\n                if( isSuccess ) {\n                    logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'SuccessEvent: ' + event.name );\n                } else {\n                    logger.info( 'action: ' + '\\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\\n' +\n                        'FailureEvent: ' + event.name );\n                }\n            }\n            var eventData = {};\n            if( event.eventData ) {\n                eventData = _.cloneDeep( event.eventData );\n                declarativeDataCtxSvc.applyScope( declViewModel, eventData, functionsList, dataCtxNode,\n                    depModuleObj );\n            }\n            if( event.excludeLocalDataCtx !== true ) {\n                eventData.scope = dataCtxNode;\n            }\n            eventData._source = declViewModel._internal.modelId;\n            eventBus.publish( event.name, eventData, true );\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugEventPub( action, event, declViewModel, dataCtxNode, eventData );\n            }\n        }\n    } );\n};\n\nvar processActionFailureEvents = function( events, err, evaluationEnv, declViewModel, action, dataCtxNode, depModuleObj ) {\n    if( events && events.failure ) {\n        if( err.cause && err.cause.partialErrors ) {\n            /**\n             * Add the error in the evaluation env for each of the events\n             */\n            _.forEach( events.failure, function( failureEvt ) {\n                _.forEach( err.cause.partialErrors, function( partialError ) {\n                    if( partialError.errorValues ) {\n                        _.forEach( partialError.errorValues, function( errorValue ) {\n                            if( errorValue.code ) {\n                                evaluationEnv.errorCode = errorValue;\n\n                                if( !evaluationEnv.errorCodes ) {\n                                    evaluationEnv.errorCodes = [];\n                                }\n\n                                evaluationEnv.errorCodes.push( errorValue );\n                            }\n                        } );\n                    }\n                } );\n\n                _processActionEvents( declViewModel, action, [ failureEvt ], evaluationEnv, dataCtxNode,\n                    depModuleObj, false );\n            } );\n\n            // If REST call is failed with error\n        } else if( err.status || err.response?.status  ) {\n            // Add the error in the evaluation env for each of the events\n            evaluationEnv.errorCode = err;\n\n            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,\n                depModuleObj, false );\n        } else {\n            // Process all events in bulk\n            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,\n                depModuleObj, false );\n        }\n    }\n};\n\nvar processPartialError = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {\n    let matchingMessages = [];\n    _.forEach( err.cause.partialErrors, function( partialError ) {\n        if( partialError.errorValues ) {\n            _.forEach( partialError.errorValues, function( errorValue ) {\n                if( errorValue.code ) {\n                    _.forEach( actionMessages.failure, function( failureErr ) {\n                        var condValue = true;\n\n                        if( failureErr.condition ) {\n                            evaluationEnv.errorCode = errorValue;\n                            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n                            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n                        }\n\n                        if( condValue ) {\n                            if( !failureErr.errorCode ) {\n                                failureErr.errorCode = [];\n                            }\n                            failureErr.errorCode.push( errorValue );\n\n                            if( matchingMessages.indexOf( failureErr ) === -1 ) {\n                                matchingMessages.push( failureErr );\n                            }\n                        }\n                    } );\n                }\n            } );\n        }\n    } );\n    return matchingMessages;\n};\n\nvar processActionHavingCause = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {\n    let allMessages = null;\n    let isReported = false;\n    _.forEach( err.cause.messages, function( message ) {\n        if( message.code ) {\n            _.forEach( actionMessages.failure, function( failureErr ) {\n                let conditionResult = false;\n                if( failureErr.condition ) {\n                    // two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123\n                    evaluationEnv.errorCode = failureErr.condition.indexOf( '.code' ) > -1 ? message : message.code;\n                    const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n                    conditionResult = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n                }\n                if( conditionResult || failureErr.message && failureErr.condition === undefined ) {\n                    isReported = true;\n\n                    if( !allMessages ) {\n                        allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    }\n\n                    evaluationEnv.errorCode = message.message;\n                    messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message, evaluationEnv );\n                }\n            } );\n        }\n    } );\n    return isReported;\n};\n\nvar processActionHavingErrorCode = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode ) {\n    var isReported = false;\n    var allMessages = null;\n    /**\n     * Notify error raised by a JS function call\n     */\n    _.forEach( actionMessages.failure, function( failureErr ) {\n        var condValue = true;\n        if( failureErr.condition ) {\n            if( err.status || err.response?.status ) {\n                // In case failure is from REST call\n                evaluationEnv.errorCode = err;\n            } else {\n                evaluationEnv.errorCode = err.errorCode;\n            }\n            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );\n            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );\n        }\n        if( condValue ) {\n            isReported = true;\n\n            if( !allMessages ) {\n                allMessages = _.cloneDeep( declViewModel._internal.messages );\n            }\n\n            messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message,\n                dataCtxNode, depModuleObj );\n        }\n    } );\n\n    return isReported;\n};\n\nvar processActionFailureMessage = function( actionMessages, err, evaluationEnv, declViewModel, depModuleObj, isReported, dataCtxNode ) {\n    if( actionMessages && actionMessages.failure ) {\n        if( err.cause && err.cause.partialErrors ) {\n            // Notify error message when condition matched\n            var allMessages;\n            if( actionMessages.failure.length > 0 ) {\n                var matchingMessages = [];\n                var scopedAllMessages = [];\n                var reportError = function( failureErr, idx ) {\n                    evaluationEnv.errorCode = failureErr.errorCode.reduce( ( acc, err, index, arr ) => {\n                        acc += err.message + ( arr.length - 1 === index ? '' : '<br/>' );\n                        return acc;\n                    }, '' );\n\n                    messagingSvc.reportNotyMessage( declViewModel, scopedAllMessages[ idx ], failureErr.message,\n                        evaluationEnv );\n                    failureErr.errorCode = null;\n                };\n\n                matchingMessages = processPartialError( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );\n                if( !allMessages && matchingMessages.length > 0 ) {\n                    allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    scopedAllMessages.push( allMessages );\n                    isReported = true;\n                }\n                matchingMessages.forEach( function( message, index ) {\n                    reportError( message, index );\n                } );\n            } else {\n                /**\n                 * Notify SOA error message when no condition specified\n\n                var errMessage = messagingSvc.getSOAErrorMessage( err ); */\n                isReported = true;\n                /** revisitme Shaishav\n                 * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module\n                 * should not depend on layer 3 modules. We need to correct that.\n                wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );\n                */\n            }\n        } else if( err.cause && err.cause.messages ) {\n            isReported = processActionHavingCause( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );\n        } else if( err.errorCode || err.status || err.response?.status ) {\n            isReported = processActionHavingErrorCode( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode );\n        }\n    }\n    return isReported;\n};\n\nvar performOutputDataMapping = function( resolvedAssignments, declViewModel, prop ) {\n    const { dispatch, updateAtomicData } = declViewModel;\n    let finalObj = {};\n\n    for( prop in resolvedAssignments ) {\n        // special property\n        const basePath = prop.split( '.' )[ 0 ];\n        if( declViewModel.atomicData && declViewModel.atomicData[ basePath ] ) {\n            _.set( declViewModel.atomicData, prop, resolvedAssignments[ prop ] );\n            updateAtomicData[ basePath ]( _.cloneDeep( declViewModel.atomicData[ basePath ] ) );\n        } else {\n            let key = `data.${prop}`;\n            finalObj[ key ] = resolvedAssignments[ prop ];\n        }\n    }\n\n    if( dispatch && Object.keys( finalObj ).length > 0 ) {\n        dispatch( { value: finalObj } );\n\n        _.forEach( resolvedAssignments, function( fromPath, toPath ) {\n            _.set( declViewModel, toPath, fromPath );\n        } );\n    }\n};\n\nvar loadFuncDependency = function( action, declViewModel, depModuleObj ) {\n    // load function deps\n    var functionDeps = declUtils.getFunctionDeps( action, declViewModel._internal );\n\n    // Filter already loaded deps\n    _.forEach( depModuleObj, function( funcValue, funcKey ) {\n        var loaded = _.find( functionDeps, function( funcDep ) {\n            // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n            // funcKey here is module name, fundDep here is js/fileName\n            // luckly it is passing today\n            return funcDep.includes( funcKey );\n        } );\n        if( loaded ) {\n            _.remove( functionDeps, function( funcDep ) {\n                return funcDep === loaded;\n            } );\n        }\n    } );\n\n    return functionDeps;\n};\n\nvar getActionPolicyInfo = function( action, declViewModel, functionsList, dataCtxNode, depModuleObj ) {\n    if( action.policy && action.actionType === 'TcSoaService' ) {\n        var policy = _.cloneDeep( action.policy );\n\n        declarativeDataCtxSvc.applyScope( declViewModel, policy, functionsList, dataCtxNode, depModuleObj );\n        if( policy.override === true ) {\n            return { propertyPolicyOverride: { types: policy.types } };\n        }\n        return { actionPolicyId: propertyPolicySvc.register( { types: policy.types }, action.method + '_Policy' ) };\n    }\n    return {};\n};\n\n/**\n * Process the 'Success' part of the executed action\n *\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\nvar _processSuccess = function( declViewModel, action, dataCtxNode, depModuleObj ) {\n    var events = action.events;\n    var actionMessages = action.actionMessages;\n    var allMessages;\n\n    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n\n    if( events && events.success ) {\n        _processActionEvents( localContext.data, action, events.success, localContext, localContext, depModuleObj,\n            true );\n    }\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );\n\n    if( actionMessages && actionMessages.success ) {\n        _.forEach( actionMessages.success, function( successMessage ) {\n            if( successMessage ) {\n                var condValue = true;\n\n                if( successMessage.condition ) {\n                    const expression = parseConditonExp( successMessage.condition, declViewModel._internal );\n                    condValue = conditionSvc.evaluateConditionExpression( expression, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );\n                }\n\n                if( condValue ) {\n                    if( !allMessages ) {\n                        allMessages = _.cloneDeep( declViewModel._internal.messages );\n                    }\n\n                    messagingSvc.reportNotyMessage( localContext.data, allMessages, successMessage.message,\n                        localContext );\n                }\n            } else {\n                logger.error( 'Invalid action successMessage:' + successMessage );\n            }\n        } );\n    }\n};\n\n/**\n * Process the error and the 'Failure' part of the executed action\n *\n * @param {Object} err - JavaScript Error object\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */\nvar _processError = function( err, declViewModel, action, dataCtxNode, depModuleObj ) {\n    var events = action.events;\n    var actionMessages = action.actionMessages;\n    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n\n    processActionFailureEvents( events, err, localContext, localContext.data, action, localContext, depModuleObj );\n\n    var isReported = false;\n\n    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );\n\n    isReported = processActionFailureMessage( actionMessages, err, localContext, localContext.data, depModuleObj, isReported, localContext );\n\n    if( !isReported && typeof err === 'object' ) {\n        isReported = processDefaultErrorTypeObject( err, isReported );\n    }\n\n    /**\n     * Fall back, report error if not raised till this point\n     */\n    if( !isReported ) {\n        processDefaultErrorMsg( err, action );\n    }\n};\n\n/**\n * @param {DeclViewModel} declViewModel - Model that owns the action.\n * @param {DeclAction} action - Action to 'finish'.\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.\n * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.\n * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.\n */\nvar _finishAction = function( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred ) {\n    var err = null;\n\n    if( !_.isEmpty( actionResponseObj ) ) {\n        if( !_.isEmpty( actionResponseObj.partialErrors ) || !_.isEmpty( actionResponseObj.PartialErrors ) ) {\n            err = soaSvc.createError( actionResponseObj );\n        }\n\n        if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {\n            err = soaSvc.createError( actionResponseObj.ServiceData );\n        }\n    }\n\n    if( err ) {\n        _processError( err, declViewModel, action, dataCtxNode, depModuleObj );\n\n        deferred.reject( err );\n    } else {\n        _processSuccess( declViewModel, action, dataCtxNode, depModuleObj );\n\n        deferred.resolve( actionResponseObj );\n    }\n};\n\nvar performOutputDataMappingForBatch = function( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred ) {\n    var data = { actionData: [] };\n    _.forEach( resolvedAssignments, function( fromPath, toPath ) {\n        _.set( data.actionData, toPath, fromPath );\n    } );\n    _finishAction( declViewModel, action, dataCtxNode, depModuleObj, data,\n        deferred );\n};\n\nvar resolveActionOutputData = function( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode ) {\n    var deferredAssignments = {};\n    /**\n     * Loop for each mapping in the 'outputData' spec\n     */\n    var index = 0;\n    _.forEach( action.outputData, function( fromPath, toPath ) {\n        var fromObj;\n\n        if( mapDataOnAction && action.outputArg ) {\n            toPath = action.outputArg[ index ];\n        }\n\n        if( _.isBoolean( fromPath ) ) {\n            fromObj = fromPath;\n        } else if( _.isEmpty( fromPath ) ) {\n            /**\n             * To support action as JS function call, assign function return value as the result\n             * when empty value expression specified\n             */\n            fromObj = actionResponseObj;\n        } else if( _.isString( fromPath ) && fromPath.indexOf( 'result.' ) === 0 ) {\n            /**\n             * If fromPath has a 'result.' prefix, parse the expression within fromPath to get\n             * the correct value.\n             */\n            var fromResultPath = fromPath.split( 'result.' )[ 1 ];\n\n            fromObj = _.get( actionResponseObj, fromResultPath );\n        } else {\n            /**\n             * If fromPath is defined, parse the expression within fromPath to get the correct\n             * value.\n             */\n            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n            fromObj = declarativeDataCtxSvc.getOutput( declViewModel, actionResponseObj, fromPath,\n                depModuleObj, localContext );\n        }\n\n        /**\n         * If the toPath starts with ctx. update the appCtxService\n         */\n        if( toPath.indexOf( 'ctx.' ) === 0 ) {\n            var toCtxName = toPath.split( 'ctx.' )[ 1 ];\n            appCtxSvc.updatePartialCtx( toCtxName, fromObj );\n        } else if( _.startsWith( toPath, 'ports.' ) ) {\n            if( dataCtxNode.ports ) {\n                _.set( dataCtxNode.ports, toPath.replace( 'ports.', '' ), fromObj );\n            }\n        } else {\n            // The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the\n            // case in cleaner way\n            deferredAssignments[ toPath ] = AwPromiseService.instance.when( fromObj );\n        }\n        index += 1;\n    } );\n\n    return deferredAssignments;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.\n * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}\n * @param {DeclAction} action - {DeclAction} being performed\n * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on\n * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the\n * 'deferred' remains untouched.\n */\nvar _isViewModelDestroyed = function( declViewModel, actionResponseObj, action, deferred, methodName ) {\n    /**\n     * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can\n     * happen, for example, when multiple subscribers are listening to a common event like 'selection' and\n     * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close\n     * (thus destroying the dataCtxNode and the declViewModel associated with it).\n     * <P>\n     * If so: There is nothing more that can be done with the declViewModel and we just want to log a\n     * warning about the life cycle issue and 'resolve' the given 'deferred'.\n     */\n    if( declViewModel.isDestroyed() ) {\n        /**\n         * If the action is trying to actually do something with the response and the view model is\n         * destroyed log an error\n         */\n        if( actionResponseObj ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action was therefore not finished.',\n                methodName );\n        }\n\n        // Otherwise do nothing\n        deferred.resolve();\n\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Perform a SOA action. Support calling SOA service, return the response object.\n *\n * @param {Object} action - The 'declAction' to be executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n */\nexport let performSOAAction = function( action ) {\n    var deferred = AwPromiseService.instance.defer();\n    _callSOA( action, action.inputData ).then( function( actionResponseObj ) {\n        if( !declUtils.isNil( actionResponseObj ) ) {\n            var err = null;\n            if( actionResponseObj.partialErrors || actionResponseObj.PartialErrors ) {\n                err = soaSvc.createError( actionResponseObj );\n            }\n\n            if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {\n                err = soaSvc.createError( actionResponseObj.ServiceData );\n            }\n            if( err ) {\n                deferred.reject( err );\n            } else if( !_.isEmpty( action.outputData ) ) {\n                deferred.resolve( actionResponseObj );\n            }\n        }\n    }, function( err ) {\n        deferred.reject( err );\n    } );\n    return deferred.promise;\n};\n\n/**\n * Perform a action synchronously. Specificly for 'syncFunction' actionType.\n * Returns nothing.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n *\n * @param {Object} action - The 'declAction' to be executed.\n *\n * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.\n *\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n *\n * @returns {Object} The result of the called function.\n */\nexport let performActionSync = function( declViewModel, action, dataCtxNode, depModuleObj ) {\n    if( !action ) {\n        logger.error( 'Missing action definition for actionId ' + action.actionId );\n        return null;\n    }\n\n    if( !action.actionType ) {\n        logger.error( 'Missing action type for actionId: ' + action.actionId );\n        return null;\n    }\n\n    if( action.actionType !== 'syncFunction' ) {\n        logger.error( 'Invalid action type for actionId: ' + action.actionId );\n        return null;\n    }\n    var inputData = null;\n    let inputError = null;\n\n    if( action.inputData ) {\n        inputData = _.cloneDeep( action.inputData );\n    }\n\n    if( inputData ) {\n        if( declViewModel.isDestroyed() ) {\n            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',\n                'performActionSync' );\n        } else {\n            try {\n                // this may require it  latest info update to latest\n                let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n                declarativeDataCtxSvc.applyScope( localContext.data, inputData, null, localContext,\n                    depModuleObj );\n            } catch ( error ) {\n                inputError = error;\n            }\n        }\n    }\n\n    if( inputError ) {\n        return null;\n    }\n\n    /**\n     * Collect function parameters from input data\n     */\n    var params = [];\n\n    _.forEach( inputData, function( param ) {\n        params.push( param );\n    } );\n\n    try {\n        return depModuleObj[ action.method ].apply( depModuleObj, params );\n    } catch ( err ) {\n        logger.error( 'Action ' + action.actionId + ' cannot be executed\\n' + err );\n    }\n    return null;\n};\n\n/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in\n *            the execution.\n * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on\n * viewModel/ctx.\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.\n */\nexport let executeAction = function( declViewModel, action, dataCtxNode, depModuleObj, mapDataOnAction, prop ) {\n    // Note: Clipboard Service is not following the correct\n    // another approach is we can try to create asyncLoad method\n    // for all these case and merge them with current thenable flow\n    /** revisitme Shaishav\n     * Hint: Need to find the reason for this line. It is failing to compile in afx-next\n    ClipboardService.instance;\n    */\n\n    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, 'executeAction (a)' );\n\n    var deferred = AwPromiseService.instance.defer();\n\n    var functionsList = declViewModel._internal.functions;\n    var { actionPolicyId, propertyPolicyOverride } = getActionPolicyInfo( action, declViewModel, functionsList, dataCtxNode, depModuleObj );\n    // load function deps\n    var functionDeps = loadFuncDependency( action, declViewModel, depModuleObj );\n\n    /**\n     * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.\n     * This should probably be made right in the future as part of better performance work.\n     */\n    moduleLoader.loadDependentModules( functionDeps ).then( function( functionDependancies ) {\n        _.forEach( functionDependancies, function( funcDepVal, funcDepKey ) {\n            depModuleObj[ funcDepKey ] = funcDepVal;\n        } );\n\n        var promise = _performAction( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride );\n\n        if( !promise ) {\n            deferred.resolved();\n            return;\n        }\n\n        promise.then( function( actionResponseObj ) {\n            /**\n             * Remove any policies that were registered for this action.\n             */\n            if( actionPolicyId ) {\n                propertyPolicySvc.unregister( actionPolicyId );\n            }\n\n            if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (b)' ) ) {\n                return;\n            }\n\n            /**\n             * Check if we have a response and an output data map to work with.\n             * <P>\n             * If so: Process all the action output definitions and stick them on the dataCtxNode.\n             * <P>\n             * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action\n             * object to handle boolean or number type object responses (D-47571).\n             */\n            if( !declUtils.isNil( actionResponseObj ) && !_.isEmpty( action.outputData ) ) {\n                var deferredAssignments = {};\n\n                /* If dataParsers are defined, then run the actionResponseObj through them before pipelining\n                 * to outPutData.\n                 */\n                if( _.isArray( action.dataParsers ) ) {\n                    actionResponseObj = dataMapperSvc.applyDataParseDefinitions( actionResponseObj, declViewModel, action.dataParsers, dataCtxNode, depModuleObj );\n                }\n\n                deferredAssignments = resolveActionOutputData( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode );\n\n                AwPromiseService.instance.all( deferredAssignments ).then(\n                    function( resolvedAssignments ) {\n                        //new in afx 3.1.0\n                        if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (c)' ) ) {\n                            return;\n                        }\n\n                        if( mapDataOnAction ) {\n                            performOutputDataMappingForBatch( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred );\n                        } else {\n                            performOutputDataMapping( resolvedAssignments, declViewModel, prop );\n\n                            // Update binding when data changed\n                            _.defer( function() {\n                                //new in afx 3.1.0\n                                if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (d)' ) ) {\n                                    return;\n                                }\n\n                                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj,\n                                    deferred );\n                            } );\n                        }\n                        debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'post', action, declViewModel, resolvedAssignments );\n                        if( logger.isTraceEnabled() ) {\n                            let actionName = action.actionId ? action.actionId : action.method;\n                            let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n                            logger.trace( 'Action: ', actionName2 );\n                        }\n                    } );\n            } else {\n                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred );\n                if( logger.isTraceEnabled() ) {\n                    let actionName = action.actionId ? action.actionId : action.method;\n                    let actionName2 = declViewModel._internal.viewId + '::' + actionName;\n                    logger.trace( 'Action: ', actionName2 );\n                }\n            }\n        }, function( err ) {\n            // Extract error message from response and store it in view model\n            var error = _.cloneDeep( err );\n            _.set( declViewModel, 'error', error );\n            if( actionPolicyId ) {\n                propertyPolicySvc.unregister( actionPolicyId );\n            }\n            _processError( err, declViewModel, action, dataCtxNode, depModuleObj );\n            deferred.reject( err );\n        } );\n    } );\n\n    return deferred.promise;\n};\n\nexports = {\n    performSOAAction,\n    executeAction,\n    performDataProviderAction,\n    performActionSync\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}