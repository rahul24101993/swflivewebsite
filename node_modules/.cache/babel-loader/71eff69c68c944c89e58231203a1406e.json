{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/clientMetaModel\n */import iconMapSvc from'js/iconMapService';import _ from'lodash';/**\n * Object used to implement a typeName-to-PropertyType cache map.\n */var _name2modelType={};/**\n * Reference to the 'iconService' set into this module and used to reuse type file information.\n * <P>\n * Note: We are trying to avoid a cyclic reference since 'iconService' required CMM to do its work.\n */ /**\n * @type {Object} map of property descriptors for reuse; property name to PropertyDescriptor or PropertyDescriptor[]\n */var _propertyDescriptors={};let exports;/**\n * Get the resolved filename of the SVG icon.\n *\n * @param {Object} modelType - The Teamcenter ModelObject's 'modelType' object which\n * @return {String} type icon file name\n */export let getTypeIconFileName=function(modelType){for(var ii=0;ii<modelType.typeHierarchyArray.length;ii++){var typeName=modelType.typeHierarchyArray[ii];var typeFileName=iconMapSvc.getTypeFileName(typeName);if(typeFileName){return typeFileName;}}return iconMapSvc.getTypeFileName('MissingImage');};/**\n * @param {Object} modelTypeSOA - model type object returned from SOA\n */var ModelType=function(modelTypeSOA){this.abstract=modelTypeSOA.abstract;this.children=modelTypeSOA.children;this.displayName=modelTypeSOA.displayName;this.name=modelTypeSOA.name;this.owningType=modelTypeSOA.owningType;this.parentTypeName=modelTypeSOA.parentTypeName;this.primary=modelTypeSOA.primary?true:undefined;this.references=modelTypeSOA.references;this.typeHierarchyArray=modelTypeSOA.typeHierarchy?modelTypeSOA.typeHierarchy.split(','):null;this.typeUid=modelTypeSOA.typeUid;this.uid=modelTypeSOA.uid;this.constantsMap={};this.propertyDescriptorsMap={};// To support property processing in CDM during model object caching, create a map of the property descriptors.\nif(modelTypeSOA.propertyDescriptors){for(var jj=modelTypeSOA.propertyDescriptors.length-1;jj>=0;jj--){var propertyDescriptorSOA=modelTypeSOA.propertyDescriptors[jj];var propName=propertyDescriptorSOA.name;var pd=new PropertyDescriptor(propertyDescriptorSOA);var cachedPD=_propertyDescriptors[propName];if(cachedPD){if(_.isArray(cachedPD)){// is array\nvar foundPD=false;_.forEach(cachedPD,function(pd2){if(_.isEqual(pd,pd2)){pd=pd2;foundPD=true;return false;// break\n}});if(!foundPD){// not in array already, add new one\ncachedPD.push(pd);}}else if(_.isEqual(pd,cachedPD)){// not array & equal to cached pd\npd=cachedPD;}else{// not equal to cached PD, so we create array to track both\n_propertyDescriptors[propName]=[cachedPD,pd];}}else{// first encounter of this property descriptor, so cache it\n_propertyDescriptors[propName]=pd;}this.propertyDescriptorsMap[propName]=pd;}}if(modelTypeSOA.constants){for(jj=modelTypeSOA.constants.length-1;jj>=0;jj--){var constant=modelTypeSOA.constants[jj];this.constantsMap[constant.name]=constant.value;}}if(!this.constantsMap.IconFileName&&this.typeHierarchyArray){this.constantsMap.IconFileName=exports.getTypeIconFileName(this);}};/**\n * @param {Object} propertyDescriptorSOA - property descriptor object returned from SOA\n */var PropertyDescriptor=function(propertyDescriptorSOA){this.anArray=propertyDescriptorSOA.anArray?true:undefined;this.basedOn=propertyDescriptorSOA.basedOn;this.compoundObjType=propertyDescriptorSOA.compoundObjType;this.displayName=propertyDescriptorSOA.displayName;this.fieldType=propertyDescriptorSOA.fieldType;this.lovCategory=propertyDescriptorSOA.lovCategory;this.maxArraySize=propertyDescriptorSOA.maxArraySize;this.maxLength=propertyDescriptorSOA.maxLength;this.minValue=propertyDescriptorSOA.minValue;this.name=propertyDescriptorSOA.name;this.propertyType=propertyDescriptorSOA.propertyType;this.propertyType2=propertyDescriptorSOA.propertyType2;this.valueType=propertyDescriptorSOA.valueType;this.constantsMap={};if(propertyDescriptorSOA.constants){for(var kk=propertyDescriptorSOA.constants.length-1;kk>=0;kk--){var constant=propertyDescriptorSOA.constants[kk];this.constantsMap[constant.name]=constant.value;}}};/**\n * Does client meta model contain type?\n *\n * @param {String} name - property type name.\n * @return {Boolean} true if model type is contained within the CMM\n */export let containsType=function(name){return _name2modelType.hasOwnProperty(name);};/**\n * Get model type by type name.\n *\n * @param {String} name - type name (or UID)\n * @return {ModelType|null} model type if contained within CMM\n */export let getType=function(name){if(exports.containsType(name)){return _name2modelType[name];}if(exports.isTypeUid(name)){return exports.getType(exports.extractTypeNameFromUID(name));}return null;};/**\n * @param {ModelObject} modelObject - ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject represents a 'type' object.\n */export let isTypeObject=function(modelObject){/**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */return exports.isTypeUid(modelObject.uid);};/**\n * Returns True if this type is child of the give type.\n *\n * @param {String} typeName - name of class\n * @param {ModelType} modelType - view model object's model type.\n * @return {Boolean} true if this type is child of the give type.\n */export let isInstanceOf=function(typeName,modelType){if(typeName&&modelType){if(typeName===modelType.name||modelType.typeHierarchyArray&&modelType.typeHierarchyArray.indexOf(typeName)>-1){return true;}}return false;};/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject UID represents a 'type' object.\n */export let isTypeUid=function(uid){/**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */return uid&&/^TYPE::/i.test(uid);};/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {String} type name extracted from UID\n */export let extractTypeNameFromUID=function(uid){return uid.split('::')[1];};/**\n * Cache model types into client meta model.\n *\n * @param {ModelType[]} modelTypes - Array of {ModelType} objects.\n */export let cacheTypes=function(modelTypes){for(var ii=modelTypes.length-1;ii>=0;ii--){var modelType=modelTypes[ii];// Don't update cache if a model type comes across again\nif(!exports.containsType(modelType.name)){_name2modelType[modelType.name]=new ModelType(modelType);}}};exports={getTypeIconFileName,containsType,getType,isTypeObject,isInstanceOf,isTypeUid,extractTypeNameFromUID,cacheTypes};export default exports;","map":null,"metadata":{},"sourceType":"module"}