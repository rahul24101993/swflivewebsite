{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/preferenceService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport soaSvc from 'soa/kernel/soaService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport eventBus from 'js/eventBus';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingService from 'js/messagingService';\nvar exports = {};\n/**\n * @private\n */\n\nvar _prefName2preference = {}; // Preference types: 0 = String, 1 = Logical, 2 = Integer, 3 = Double, 4 = Date\n\n/**\n * TRUE if bulk preferences are loaded\n *\n * @private\n */\n\nvar _areBulkPreferencesLoaded = false;\n/**\n * Stores all the bulk load entries\n *\n * @private\n */\n\nvar _bulkLoadPreferences = [];\n/**\n * Stores listener to appCtx.update\n *\n * @private\n */\n\nvar _onAppCtxUpdateListener = null;\n/**\n * @param {Object} context - context return from appCtx.updatePartialCtx\n */\n\nfunction onCtxPartialUpdateHandler(context) {\n  if (context.name === 'preferences') {\n    exports.setStringValue(context.target, context.value[context.name][context.target]);\n  }\n}\n/**\n * This is the method which conditionally calls the server for the preference values.\n *\n * @param {StringArray} names - Array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise} promise\n * @private\n */\n\n\nfunction getPrefs(names, bulkCache) {\n  names.sort(); // debug help only\n\n  if (bulkCache) {\n    _bulkLoadPreferences = names;\n    return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'getPreferences', {\n      preferenceNames: names,\n      includePreferenceDescriptions: false\n    }, {}).then(function (result) {\n      if (result && result.response) {\n        if (_onAppCtxUpdateListener) {\n          eventBus.unsubscribe(_onAppCtxUpdateListener);\n        }\n\n        var prefCtx = {};\n\n        _.forEach(result.response, function (pref) {\n          // clean up unused stuff...\n          if (pref.definition) {\n            delete pref.definition.category;\n            delete pref.definition.protectionScope;\n            delete pref.definition.isOOTBPreference;\n            delete pref.definition.isEnvEnabled;\n            delete pref.definition.isDisabled;\n            delete pref.definition.description;\n          }\n\n          if (pref.values) {\n            delete pref.values.valueOrigination;\n          } // Remove the preferences from the list which have been fetched successfully\n\n\n          _bulkLoadPreferences.splice(_bulkLoadPreferences.indexOf(pref.definition.name), 1); // store\n\n\n          _prefName2preference[pref.definition.name] = pref;\n\n          if (pref.values.values) {\n            prefCtx[pref.definition.name] = pref.values.values;\n          }\n        });\n\n        appCtxSvc.updateCtx('preferences', prefCtx);\n\n        if (_onAppCtxUpdateListener) {\n          _onAppCtxUpdateListener = eventBus.subscribe('appCtx.update', onCtxPartialUpdateHandler);\n        } // Fill the remaining preferences(returned from server as part of partial errors) with null values into the cache\n\n\n        _.forEach(_bulkLoadPreferences, function (pref) {\n          var defaultPreferenceValJson = {\n            definition: {\n              name: pref\n            },\n            values: {\n              values: [null]\n            }\n          };\n          _prefName2preference[pref] = defaultPreferenceValJson;\n        });\n\n        _areBulkPreferencesLoaded = true; // Empty the list after processing\n\n        _bulkLoadPreferences = [];\n        eventBus.publish('bulkPreferencesLoaded', {});\n      }\n\n      var timeoutPref = _prefName2preference.AWC_Notification_Timeout;\n\n      if (timeoutPref && timeoutPref.definition.name === 'AWC_Notification_Timeout' && timeoutPref.values && timeoutPref.values.values && timeoutPref.values.values.length > 0) {\n        var prefTimeout = timeoutPref.values.values[0];\n\n        if (!isNaN(prefTimeout) && prefTimeout.trim() !== '') {\n          var timeout = 0;\n\n          if (prefTimeout > 0) {\n            timeout = prefTimeout;\n          } // this sets the info to the value from preference and error * 10, which is what used to happen earlier\n\n\n          messagingService.setTimeout('INFO', timeout);\n        }\n      }\n\n      const pollingTimeout = _.get(_prefName2preference, 'AWC_Polling_Timeout.values.values[0]');\n\n      soaSvc.setPollingTimeout(_.toNumber(pollingTimeout));\n      return _prefName2preference;\n    });\n  } // using cached value for preferences\n\n\n  return AwPromiseService.instance.resolve(_prefName2preference);\n}\n/**\n * This is the method calls the server to set the preference values.\n *\n * @param {Object} prefName2Values - map of preference name to preference values\n * @return {Promise} promise\n * @private\n */\n\n\nfunction setPrefs(prefName2Values) {\n  var body = {\n    preferenceInput: []\n  };\n\n  _.forEach(prefName2Values, function (values, name) {\n    var pref = _prefName2preference[name]; // Remove the null entries from values array if any\n\n    _.forEach(values, function (value) {\n      if (value === null) {\n        values.splice(values.indexOf(value), 1);\n      }\n    });\n\n    if (!pref || !_.isEqual(pref.values.values, values)) {\n      body.preferenceInput.push({\n        preferenceName: name,\n        values: values\n      });\n    }\n  });\n\n  if (body.preferenceInput.length === 0) {\n    // using cached value for preferences\n    // no server call required\n    return AwPromiseService.instance.resolve(null);\n  }\n\n  return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'setPreferences2', body, {}).then(function () {\n    // Update the client side cache for the successfully set preference\n    _.forEach(prefName2Values, function (values, name) {\n      var pref = _prefName2preference[name];\n\n      if (pref) {\n        pref.values.values = values;\n      }\n    }); // nothing to return\n\n\n    return null;\n  });\n}\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\n\n\nexport let getStringValue = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      return pref.values.values[0];\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let getStringValues = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      return pref.values.values;\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} names - array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise.<Object>} promise will resolve to the preference string array value\n */\n\nexport let getMultiStringValues = function (names, bulkCache) {\n  return getPrefs(names, bulkCache).then(function (prefName2preference) {\n    var response = {};\n\n    _.forEach(names, function (name) {\n      var pref = prefName2preference[name];\n\n      if (pref) {\n        response[name] = pref.values.values;\n      }\n    });\n\n    return response;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference logical value\n */\n\nexport let getLogicalValue = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      assert(pref.definition.type === 1, 'Querying logical value for a non-string preference');\n      assert(!pref.definition.isArray, 'Querying logical value for array preference');\n      return pref.values.values[0];\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference logical array value\n */\n\nexport let getLogicalValues = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      assert(pref.definition.type === 1, 'Querying logical values for a non-string preference');\n      assert(pref.definition.isArray, 'Querying logical values for a non-array preference');\n      return pref.values.values;\n    }\n\n    return null;\n  });\n};\n/**\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let queryAll = function () {\n  return getPrefs(['*']).then(function (prefName2preference) {\n    return prefName2preference;\n  });\n};\n/**\n * This is the method which calls the server to get all preference values that can be modified by the current user\n *\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let getExpandedPrefs = function () {\n  return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'getPreferences', {\n    preferenceNames: ['*'],\n    includePreferenceDescriptions: true\n  }, {}).then(function (result) {\n    /**\n     * Checks to see if a preference has a user created version of it that should override it.\n     *\n     * @param {String} name - Name to check.\n     * @param {String} origin - Origin of the preference.\n     *\n     * @returns {Booolean} TRUE if a preference has a user created version of it that should override it.\n     */\n    function uniqueUserPref(name, origin) {\n      if (origin === 'User') {\n        return true;\n      }\n\n      for (var i in result.response) {\n        if (result.response[i].definition.name === name && result.response[i].values.valueOrigination !== origin) {\n          return false; // we want the user preference to override the other preference\n        }\n      }\n\n      return true;\n    }\n\n    for (var i = 0; i < result.response.length; i++) {\n      if (!uniqueUserPref(result.response[i].definition.name, result.response[i].values.valueOrigination)) {\n        result.response.splice(i, 1);\n        i--;\n      }\n    }\n\n    return result.response;\n  });\n};\n/**\n * @param {String} name - preference name\n * @param {StringArray} value - preference values\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\n\nexport let setStringValue = function (name, value) {\n  var input = {};\n  input[name] = value;\n  return setPrefs(input);\n};\n/**\n * @param {StringArray} names - array of preference name\n * @param {StringArrayArray} values - array of preference values\n * @return {Promise.<StringArray>} promise will resolve to the preference string value\n */\n\nexport let setStringValues = function (names, values) {\n  var input = {};\n\n  for (var ii = 0; ii < names.length; ii++) {\n    input[names[ii]] = values[ii];\n  }\n\n  return setPrefs(input);\n};\n/**\n * @return {boolean} areBulkPreferencesLoaded\n */\n\nexport let areBulkPreferencesLoaded = function () {\n  return _areBulkPreferencesLoaded;\n};\n/**\n * Get any preferences that are already loaded. Primarily used for when a sync check of a preference is necessary.\n *\n * @return {Object} The currently loaded preferences. Key is name, value is value list.\n */\n\nexport let getLoadedPrefs = function () {\n  var loadedPrefs = {};\n\n  for (var i in _prefName2preference) {\n    // TODO: Could use definition to format pref somehow\n    // For now just make sure everything is an array\n    loadedPrefs[i] = _prefName2preference[i].values.values ? _prefName2preference[i].values.values : [];\n  }\n\n  return loadedPrefs;\n};\n_onAppCtxUpdateListener = eventBus.subscribe('appCtx.update', onCtxPartialUpdateHandler);\nexports = {\n  getStringValue,\n  getStringValues,\n  getMultiStringValues,\n  getLogicalValue,\n  getLogicalValues,\n  queryAll,\n  getExpandedPrefs,\n  setStringValue,\n  setStringValues,\n  areBulkPreferencesLoaded,\n  getLoadedPrefs\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/preferenceService.js"],"names":["exports","_prefName2preference","_areBulkPreferencesLoaded","_bulkLoadPreferences","_onAppCtxUpdateListener","context","names","preferenceNames","includePreferenceDescriptions","result","eventBus","prefCtx","_","pref","appCtxSvc","defaultPreferenceValJson","definition","name","values","timeoutPref","prefTimeout","isNaN","timeout","messagingService","pollingTimeout","soaSvc","AwPromiseService","body","preferenceInput","value","preferenceName","getStringValue","prefName2preference","getStringValues","getMultiStringValues","response","getLogicalValue","assert","getLogicalValues","queryAll","getExpandedPrefs","origin","i","uniqueUserPref","setStringValue","input","setPrefs","setStringValues","ii","areBulkPreferencesLoaded","getLoadedPrefs","loadedPrefs"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/preferenceService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport soaSvc from 'soa/kernel/soaService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport eventBus from 'js/eventBus';\n\nimport appCtxSvc from 'js/appCtxService';\nimport messagingService from 'js/messagingService';\n\nvar exports = {};\n\n/**\n * @private\n */\nvar _prefName2preference = {};\n\n// Preference types: 0 = String, 1 = Logical, 2 = Integer, 3 = Double, 4 = Date\n\n/**\n * TRUE if bulk preferences are loaded\n *\n * @private\n */\nvar _areBulkPreferencesLoaded = false;\n\n/**\n * Stores all the bulk load entries\n *\n * @private\n */\nvar _bulkLoadPreferences = [];\n\n/**\n * Stores listener to appCtx.update\n *\n * @private\n */\nvar _onAppCtxUpdateListener = null;\n\n/**\n * @param {Object} context - context return from appCtx.updatePartialCtx\n */\nfunction onCtxPartialUpdateHandler( context ) {\n    if( context.name === 'preferences' ) {\n        exports.setStringValue( context.target, context.value[ context.name ][ context.target ] );\n    }\n}\n\n/**\n * This is the method which conditionally calls the server for the preference values.\n *\n * @param {StringArray} names - Array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise} promise\n * @private\n */\nfunction getPrefs( names, bulkCache ) {\n    names.sort(); // debug help only\n\n    if( bulkCache ) {\n        _bulkLoadPreferences = names;\n        return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'getPreferences', {\n            preferenceNames: names,\n            includePreferenceDescriptions: false\n        }, {} ).then( function( result ) {\n            if( result && result.response ) {\n                if( _onAppCtxUpdateListener ) {\n                    eventBus.unsubscribe( _onAppCtxUpdateListener );\n                }\n\n                var prefCtx = {};\n\n                _.forEach( result.response, function( pref ) {\n                    // clean up unused stuff...\n                    if( pref.definition ) {\n                        delete pref.definition.category;\n                        delete pref.definition.protectionScope;\n                        delete pref.definition.isOOTBPreference;\n                        delete pref.definition.isEnvEnabled;\n                        delete pref.definition.isDisabled;\n                        delete pref.definition.description;\n                    }\n                    if( pref.values ) {\n                        delete pref.values.valueOrigination;\n                    }\n                    // Remove the preferences from the list which have been fetched successfully\n                    _bulkLoadPreferences.splice( _bulkLoadPreferences.indexOf( pref.definition.name ), 1 );\n                    // store\n                    _prefName2preference[ pref.definition.name ] = pref;\n\n                    if( pref.values.values ) {\n                        prefCtx[ pref.definition.name ] = pref.values.values;\n                    }\n                } );\n\n                appCtxSvc.updateCtx( 'preferences', prefCtx );\n\n                if( _onAppCtxUpdateListener ) {\n                    _onAppCtxUpdateListener = eventBus.subscribe( 'appCtx.update', onCtxPartialUpdateHandler );\n                }\n\n                // Fill the remaining preferences(returned from server as part of partial errors) with null values into the cache\n                _.forEach( _bulkLoadPreferences, function( pref ) {\n                    var defaultPreferenceValJson = {\n                        definition: {\n                            name: pref\n                        },\n                        values: {\n                            values: [ null ]\n                        }\n                    };\n                    _prefName2preference[ pref ] = defaultPreferenceValJson;\n                } );\n\n                _areBulkPreferencesLoaded = true;\n                // Empty the list after processing\n                _bulkLoadPreferences = [];\n                eventBus.publish( 'bulkPreferencesLoaded', {} );\n            }\n\n            var timeoutPref = _prefName2preference.AWC_Notification_Timeout;\n            if( timeoutPref &&\n                timeoutPref.definition.name === 'AWC_Notification_Timeout' &&\n                timeoutPref.values && timeoutPref.values.values && timeoutPref.values.values.length > 0 ) {\n                var prefTimeout = timeoutPref.values.values[ 0 ];\n                if( !isNaN( prefTimeout ) && prefTimeout.trim() !== '' ) {\n                    var timeout = 0;\n                    if( prefTimeout > 0 ) {\n                        timeout = prefTimeout;\n                    }\n                    // this sets the info to the value from preference and error * 10, which is what used to happen earlier\n                    messagingService.setTimeout( 'INFO', timeout );\n                }\n            }\n\n            const pollingTimeout = _.get( _prefName2preference, 'AWC_Polling_Timeout.values.values[0]' );\n            soaSvc.setPollingTimeout( _.toNumber( pollingTimeout ) );\n\n            return _prefName2preference;\n        } );\n    }\n\n    // using cached value for preferences\n    return AwPromiseService.instance.resolve( _prefName2preference );\n}\n\n/**\n * This is the method calls the server to set the preference values.\n *\n * @param {Object} prefName2Values - map of preference name to preference values\n * @return {Promise} promise\n * @private\n */\nfunction setPrefs( prefName2Values ) {\n    var body = {\n        preferenceInput: []\n    };\n\n    _.forEach( prefName2Values, function( values, name ) {\n        var pref = _prefName2preference[ name ];\n        // Remove the null entries from values array if any\n        _.forEach( values, function( value ) {\n            if( value === null ) {\n                values.splice( values.indexOf( value ), 1 );\n            }\n        } );\n        if( !pref || !_.isEqual( pref.values.values, values ) ) {\n            body.preferenceInput.push( {\n                preferenceName: name,\n                values: values\n            } );\n        }\n    } );\n\n    if( body.preferenceInput.length === 0 ) {\n        // using cached value for preferences\n        // no server call required\n        return AwPromiseService.instance.resolve( null );\n    }\n\n    return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'setPreferences2', body, {} ).then(\n        function() {\n            // Update the client side cache for the successfully set preference\n            _.forEach( prefName2Values, function( values, name ) {\n                var pref = _prefName2preference[ name ];\n                if( pref ) {\n                    pref.values.values = values;\n                }\n            } );\n            // nothing to return\n            return null;\n        } );\n}\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\nexport let getStringValue = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            return pref.values.values[ 0 ];\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let getStringValues = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            return pref.values.values;\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} names - array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise.<Object>} promise will resolve to the preference string array value\n */\nexport let getMultiStringValues = function( names, bulkCache ) {\n    return getPrefs( names, bulkCache ).then( function( prefName2preference ) {\n        var response = {};\n        _.forEach( names, function( name ) {\n            var pref = prefName2preference[ name ];\n            if( pref ) {\n                response[ name ] = pref.values.values;\n            }\n        } );\n        return response;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference logical value\n */\nexport let getLogicalValue = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            assert( pref.definition.type === 1, 'Querying logical value for a non-string preference' );\n            assert( !pref.definition.isArray, 'Querying logical value for array preference' );\n            return pref.values.values[ 0 ];\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference logical array value\n */\nexport let getLogicalValues = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            assert( pref.definition.type === 1, 'Querying logical values for a non-string preference' );\n            assert( pref.definition.isArray, 'Querying logical values for a non-array preference' );\n            return pref.values.values;\n        }\n        return null;\n    } );\n};\n\n/**\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let queryAll = function() {\n    return getPrefs( [ '*' ] ).then( function( prefName2preference ) {\n        return prefName2preference;\n    } );\n};\n\n/**\n * This is the method which calls the server to get all preference values that can be modified by the current user\n *\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let getExpandedPrefs = function() {\n    return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'getPreferences', {\n        preferenceNames: [ '*' ],\n        includePreferenceDescriptions: true\n    }, {} )\n        .then(\n            function( result ) {\n                /**\n                 * Checks to see if a preference has a user created version of it that should override it.\n                 *\n                 * @param {String} name - Name to check.\n                 * @param {String} origin - Origin of the preference.\n                 *\n                 * @returns {Booolean} TRUE if a preference has a user created version of it that should override it.\n                 */\n                function uniqueUserPref( name, origin ) {\n                    if( origin === 'User' ) {\n                        return true;\n                    }\n                    for( var i in result.response ) {\n                        if( result.response[ i ].definition.name === name &&\n                            result.response[ i ].values.valueOrigination !== origin ) {\n                            return false; // we want the user preference to override the other preference\n                        }\n                    }\n                    return true;\n                }\n\n                for( var i = 0; i < result.response.length; i++ ) {\n                    if( !uniqueUserPref( result.response[ i ].definition.name,\n                        result.response[ i ].values.valueOrigination ) ) {\n                        result.response.splice( i, 1 );\n                        i--;\n                    }\n                }\n\n                return result.response;\n            } );\n};\n\n/**\n * @param {String} name - preference name\n * @param {StringArray} value - preference values\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\nexport let setStringValue = function( name, value ) {\n    var input = {};\n    input[ name ] = value;\n    return setPrefs( input );\n};\n\n/**\n * @param {StringArray} names - array of preference name\n * @param {StringArrayArray} values - array of preference values\n * @return {Promise.<StringArray>} promise will resolve to the preference string value\n */\nexport let setStringValues = function( names, values ) {\n    var input = {};\n    for( var ii = 0; ii < names.length; ii++ ) {\n        input[ names[ ii ] ] = values[ ii ];\n    }\n    return setPrefs( input );\n};\n\n/**\n * @return {boolean} areBulkPreferencesLoaded\n */\nexport let areBulkPreferencesLoaded = function() {\n    return _areBulkPreferencesLoaded;\n};\n\n/**\n * Get any preferences that are already loaded. Primarily used for when a sync check of a preference is necessary.\n *\n * @return {Object} The currently loaded preferences. Key is name, value is value list.\n */\nexport let getLoadedPrefs = function() {\n    var loadedPrefs = {};\n    for( var i in _prefName2preference ) {\n        // TODO: Could use definition to format pref somehow\n        // For now just make sure everything is an array\n        loadedPrefs[ i ] = _prefName2preference[ i ].values.values ? _prefName2preference[ i ].values.values : [];\n    }\n    return loadedPrefs;\n};\n\n_onAppCtxUpdateListener = eventBus.subscribe( 'appCtx.update', onCtxPartialUpdateHandler );\n\nexports = {\n    getStringValue,\n    getStringValues,\n    getMultiStringValues,\n    getLogicalValue,\n    getLogicalValues,\n    queryAll,\n    getExpandedPrefs,\n    setStringValue,\n    setStringValues,\n    areBulkPreferencesLoaded,\n    getLoadedPrefs\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}