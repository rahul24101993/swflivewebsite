{"ast":null,"code":"/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/* global AFX_UTEST */\n\n/**\n * This service is used to manage the sync strategies.\n *\n * @module js/syncStrategyService\n *\n */\nimport _ from 'lodash';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport cfgSvc from 'js/configurationService';\nimport viewModelSvc from 'js/viewModelService';\nimport conditionSvc from 'js/conditionService';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport actionService from 'js/actionService';\n\nlet _syncStrategyMap;\n\nconst _vmPathCache = {};\nvar _strategies = null;\nlet _declViewModel = null;\nvar exports = {};\n/**\n * Create the declartive viewModel from all combined syncStrategy.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */\n\nfunction createViewModel(viewModel) {\n  viewModel._viewModelId = 'syncStrategyViewModel_' + Math.random();\n  viewModel.skipClone = true;\n  return viewModelSvc.populateViewModelPropertiesFromJson(viewModel, null, null, true);\n}\n\nexport const setupSyncStrategy = dataCtxNode => {\n  const id = dataCtxNode.data._internal.modelId;\n  const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n  syncViewModelCacheService.set(path + '.' + id, dataCtxNode);\n};\nexport const loadConfiguration = async function () {\n  await cfgSvc.getCfg('syncStrategy').then(strategies => {\n    _strategies = strategies;\n\n    if (!_strategies && AFX_UTEST) {\n      _strategies = {};\n    }\n\n    _syncStrategyMap = new Map(); // handler relatioin w.r.t to source\n\n    if (!_vmPathCache.handlersRelation) {\n      _vmPathCache.handlersRelation = {};\n    } // target relation with source\n\n\n    if (!_vmPathCache.targetRelationToSource) {\n      _vmPathCache.targetRelationToSource = {};\n    }\n    /*\n        <sourceView>: {\n            \"<port1>\": ['<handler1>', '<handler2>'],\n            \"<port2>\": ['<handler3>', '<handler4>'],\n        }\n    */\n\n\n    for (var key in _strategies.syncStrategyHandlers) {\n      let handler = _strategies.syncStrategyHandlers[key];\n      let syncStrategyId = handler.id;\n      let synConfigObject = _strategies.syncStrategies[syncStrategyId];\n      let sPort = synConfigObject.source.port;\n      let sViewHierarchy = synConfigObject.source.view.split('/');\n      let sView = sViewHierarchy[sViewHierarchy.length - 1];\n\n      if (!_syncStrategyMap.has(sView)) {\n        _syncStrategyMap.set(sView, {\n          ports: {}\n        });\n      }\n\n      if (!_syncStrategyMap.get(sView).ports[sPort]) {\n        _syncStrategyMap.get(sView).ports[sPort] = [];\n      }\n\n      _syncStrategyMap.get(sView).ports[sPort].push(key);\n    }\n  });\n};\n\nconst getDeclViewModel = function () {\n  return createViewModel(_strategies);\n};\n\nconst _fireTargetAction = function (targetViewModel, value, strategyConfig) {\n  if (targetViewModel && targetViewModel.data) {\n    const targetPort = Object.assign({}, targetViewModel.data.getPortById(strategyConfig.target.port)); // if port of target is present, then only fire action\n\n    if (!_.isNil(targetPort) && !_.isEmpty(targetPort)) {\n      // adding input object to targets port\n      targetPort.syncObject = value; // adding ports as a sibling to data in VM.\n\n      const portsData = { ...targetViewModel.ports,\n        [strategyConfig.target.port]: targetPort\n      }; // zarq9k: Cannot do dispatch on unmount process.\n      // Need to re-think on strategy. It is a point fix.\n\n      if (targetViewModel.data && targetViewModel.data.dispatch) {\n        targetViewModel.data.dispatch({\n          path: 'ports',\n          value: portsData\n        });\n        targetViewModel.data.ports = portsData;\n        targetViewModel.ports = targetViewModel.data.ports;\n        return viewModelSvc.executeCommand(targetViewModel.data, targetPort.onChangeAction, targetViewModel);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }\n\n    return AwPromiseService.instance.resolve({\n      errorCode: 'NO_TARGET_PORT_FOUND',\n      errorMessage: `No port is configured for view: ${targetViewModel.data._internal.viewId}`\n    });\n  }\n\n  return AwPromiseService.instance.resolve();\n};\n\nconst _executePreProcessingAction = function (actionName, syncContext, value) {\n  var deferred = AwPromiseService.instance.defer();\n  var action = _strategies.actions[actionName];\n\n  if (action.deps) {\n    /** action ID will be used for better logging */\n    action.actionId = action.method;\n\n    var doAction = function (depModuleObj) {\n      if (_declViewModel.isDestroyed()) {\n        logger.warn('Attempt to execute a command after its DeclViewModel was destroyed...' + '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n        'DeclViewModel: ' + _declViewModel + '\\n' + //\n        'Action       : ' + action);\n        return AwPromiseService.instance.reject();\n      }\n      /**\n       * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n       * event processing was started.\n       */\n\n\n      _declViewModel.value = value;\n      var dataCtxNode = {\n        data: _declViewModel,\n        ctx: appCtxSvc.ctx,\n        syncContext: syncContext\n      };\n      var localDataCtx = declUtils.resolveLocalDataCtx(_declViewModel, dataCtxNode); // _deps will be undefined when try to load viewModelService inside itself\n\n      var _depModuleObj = depModuleObj;\n      return actionService.executeAction(_declViewModel, action, localDataCtx, _depModuleObj, true);\n    };\n\n    return moduleLoader.getDependentModule(action.deps).then(depModuleObj => {\n      return doAction(depModuleObj);\n    });\n  }\n\n  return deferred.Promise;\n};\n\nconst _runAction = function (handler, syncContext, value, targetViewModel, syncStrategyDef) {\n  return _executePreProcessingAction(handler.action, syncContext, value).then(function (response) {\n    // response data is avaiable on response.actionData\n    return _fireTargetAction(targetViewModel, response.actionData, syncStrategyDef);\n  });\n};\n\nconst _executeHandlerAction = function (handler, syncContext, value, targetViewModel, syncStrategyDef) {\n  if (!_declViewModel) {\n    _declViewModel = getDeclViewModel();\n  }\n\n  return _runAction(handler, syncContext, value, targetViewModel, syncStrategyDef);\n};\n\nconst _evaluateActiveWhen = function (strategyObject, syncContext) {\n  return conditionSvc.evaluateConditionExpression(strategyObject, {\n    syncContext: syncContext,\n    ctx: appCtxSvc.ctx\n  }, {\n    clauseName: 'activeWhen',\n    conditionList: _strategies\n  });\n};\n\nconst _requestUpdate = function (viewId, modelId, portName, value) {\n  if (_syncStrategyMap.get(viewId) && _syncStrategyMap.get(viewId).ports[portName]) {\n    var syncExecutePromises = [];\n\n    if (_vmPathCache[viewId]) {\n      const srcObj = _vmPathCache[viewId][modelId];\n\n      var allHandlers = _syncStrategyMap.get(viewId).ports[portName];\n\n      _.forEach(srcObj.handlers, function (handler, name) {\n        if (allHandlers.indexOf(name) > -1 && handler.target) {\n          Object.values(handler.target).forEach(targetViewModel => {\n            const syncStrategyDef = _strategies.syncStrategies[handler.id];\n            const syncContext = {\n              targetViewModel: targetViewModel,\n              sourceViewModel: srcObj.vm\n            }; // evaluate activewhen\n\n            if (_evaluateActiveWhen(handler, syncContext)) {\n              if (handler.action) {\n                var launch = _executeHandlerAction(handler, syncContext, value, targetViewModel, syncStrategyDef);\n\n                syncExecutePromises.push(launch);\n              } else {\n                syncExecutePromises.push(_fireTargetAction(targetViewModel, value, syncStrategyDef));\n              }\n            }\n          });\n        }\n      });\n    }\n\n    if (syncExecutePromises.length) {\n      return AwPromiseService.instance.all(syncExecutePromises);\n    }\n  }\n\n  return AwPromiseService.instance.resolve({\n    errorCode: 'NO_ACTIVE_ACTION_FOUND',\n    errorMessage: `No sync action fired for view: ${viewId} with port: ${portName}`\n  });\n};\n/**\n * triggerSyncStrategy\n * @param {Object} declViewModel decl view model of source\n * @param {String} inputData resolved inputData from actionService\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\n\n\nexport const updatePort = function (declViewModel, inputData) {\n  const viewId = declViewModel._internal.viewId;\n  const modelId = declViewModel._internal.modelId;\n  const portName = inputData.port;\n  const newValue = inputData.syncObject;\n  const vmCacheMap = syncViewModelCacheService.get('syncViewModelCache');\n\n  if (vmCacheMap[viewId] && vmCacheMap[viewId][modelId]) {\n    const sourceVm = vmCacheMap[viewId][modelId];\n\n    if (sourceVm && sourceVm.data && sourceVm.data.getPortById(portName)) {\n      let sourceVmData = sourceVm.data;\n      let sPortObject = Object.assign({}, sourceVmData.getPortById(portName));\n      sPortObject.syncObject = newValue ? newValue : sourceVm.ports[portName].syncObject; // adding ports as a sibling to data in VM.\n\n      const portsData = { ...sourceVm.ports,\n        [portName]: sPortObject\n      };\n      sourceVmData.dispatch({\n        path: 'ports',\n        value: portsData\n      });\n      return _requestUpdate(viewId, modelId, portName, newValue);\n    }\n  }\n\n  return AwPromiseService.instance.resolve({\n    errorCode: 'NO_PORT_FOUND',\n    errorMessage: `No port is configured for view: ${viewId}`\n  });\n};\n/**\n * revisitme: find out the solution for this API to support other use cases\n * @param {*} viewPath viewpath\n * @returns {Array} array of elements\n */\n\nexport const getElementArray = function (viewPath) {\n  var elementString = '';\n  var body = document.body;\n  var elementPathArray = viewPath.split('/');\n\n  if (elementPathArray && elementPathArray.length > 1) {\n    // aw-include[name='commonRoot'] aw-include[name='commonLocation'] aw-include[name='showcaseMain']\"\n    elementPathArray.forEach(function (viewName) {\n      elementString = elementString + 'aw-include[name=\"' + viewName + '\"] ';\n    });\n  } else {\n    // aw-include[view-id='commonRoot']\n    var uniqueViewElement = body.querySelectorAll('aw-include[view-id=\"' + elementPathArray[0] + '\"] ');\n\n    if (uniqueViewElement && uniqueViewElement.length === 1) {\n      return uniqueViewElement;\n    } // aw-include[name='commonRoot']\n\n\n    elementString = 'aw-include[name=\"' + elementPathArray[0] + '\"] ';\n  } // revisitme : currently supporting only viewName use case, figure out impact of following commented line\n  // return body.querySelectorAll( elementString );\n\n\n  return ['dummyelement'];\n};\n\nconst validateViewPath = function (context, viewPath, viewId) {\n  const viewPathArray = viewPath.split('/');\n  let initialCheck = viewPathArray[viewPathArray.length - 1] === viewId;\n\n  if (initialCheck && viewPathArray.length > 1) {\n    let preIndex = -1;\n    let currIndex = 0;\n    let comViewPathArray = context.props.viewPath.split('/');\n\n    for (let i = 0; i < viewPathArray.length; i++) {\n      currIndex = comViewPathArray.indexOf[viewPathArray[i]];\n\n      if (currIndex === -1 && currIndex < preIndex) {\n        initialCheck = false;\n        break;\n      } else {\n        preIndex = currIndex;\n      }\n    }\n  }\n\n  return initialCheck;\n};\n\nconst getViewNameFromPath = function (viewPath) {\n  const viewPathArray = viewPath.split('/');\n  return viewPathArray[viewPathArray.length - 1];\n};\n\nconst _addToCachePaths = function (declViewModel) {\n  const viewId = declViewModel.data._internal.viewId;\n  const modelId = declViewModel.data._internal.modelId;\n  const vmCacheMap = syncViewModelCacheService.get('syncViewModelCache');\n\n  const _cachingAsSource = () => {\n    const allHandlersName = Object.values(_syncStrategyMap.get(viewId).ports).flatMap(h => h);\n    const handlers = allHandlersName.reduce((handlersObj, name) => {\n      const {\n        id,\n        action,\n        activeWhen\n      } = _strategies.syncStrategyHandlers[name];\n\n      if (validateViewPath(declViewModel, _strategies.syncStrategies[id].source.view, viewId)) {\n        const targetObj = _strategies.syncStrategies[id].target;\n        const targetVm = vmCacheMap[getViewNameFromPath(targetObj.view)];\n        handlersObj[name] = {\n          id,\n          action,\n          activeWhen,\n          target: targetVm ? targetVm : {}\n        };\n        _vmPathCache.handlersRelation[name] = {\n          viewId: viewId,\n          modelId: modelId\n        };\n      }\n\n      return handlersObj;\n    }, {}); // handling for multiple entry for same viewId\n\n    if (!_vmPathCache[viewId]) {\n      _vmPathCache[viewId] = {};\n    }\n\n    _vmPathCache[viewId][modelId] = {\n      get vm() {\n        return syncViewModelCacheService.get('syncViewModelCache')[viewId][modelId];\n      },\n\n      handlers: handlers\n    };\n  }; // vm act as source\n\n\n  if (_syncStrategyMap.get(viewId) && (!_vmPathCache[viewId] || !_vmPathCache[viewId][modelId])) {\n    _cachingAsSource();\n  } // vm act as target\n\n\n  const asTarget = Object.entries(_strategies.syncStrategies).reduce((acc, obj) => {\n    if (validateViewPath(declViewModel, obj[1].target.view, viewId)) {\n      acc.push(obj[0]);\n    }\n\n    return acc;\n  }, []);\n\n  const _cachingAsTarget = () => {\n    const targetHandler = Object.entries(_strategies.syncStrategyHandlers).reduce((acc, obj) => {\n      if (asTarget.indexOf(obj[1].id) > -1) {\n        acc[obj[0]] = obj[1];\n      }\n\n      return acc;\n    }, {});\n\n    _.forEach(targetHandler, (obj, key) => {\n      const matchingSrc = _vmPathCache.handlersRelation[key];\n\n      if (matchingSrc && _syncStrategyMap.get(matchingSrc.viewId)) {\n        const view = getViewNameFromPath(_strategies.syncStrategies[obj.id].target.view);\n        const trgVm = vmCacheMap[view];\n        const handlers = _vmPathCache[matchingSrc.viewId][matchingSrc.modelId].handlers;\n        handlers[key].target = trgVm ? trgVm : {};\n\n        if (!_vmPathCache.targetRelationToSource[view]) {\n          _vmPathCache.targetRelationToSource[view] = [];\n        }\n\n        _vmPathCache.targetRelationToSource[view].push({\n          source: {\n            viewId: matchingSrc.viewId,\n            modelId: matchingSrc.modelId\n          },\n          modelId: modelId,\n          handlerId: obj.id,\n          handlerName: key\n        });\n      }\n    });\n  };\n\n  if (asTarget && asTarget.length) {\n    _cachingAsTarget();\n  }\n};\n\nconst _removeFromCachePaths = function (declViewModel) {\n  const viewId = declViewModel.data._internal.viewId; // clear relations\n\n  _.forEach(_vmPathCache.handlersRelation, (obj, key) => {\n    if (obj.viewId === viewId) {\n      delete _vmPathCache.handlersRelation[key];\n    }\n  }); // clear target relation with source\n\n\n  if (_vmPathCache.targetRelationToSource[viewId]) {\n    delete _vmPathCache.targetRelationToSource[viewId];\n  } // clear vm from vmPathCache\n\n\n  if (_vmPathCache[viewId]) {\n    delete _vmPathCache[viewId];\n  }\n};\n\nconst _updateOnMount = function (declVm) {\n  const syncExecutePromises = [];\n  const viewId = declVm.data._internal.viewId;\n  const allRelations = _vmPathCache.targetRelationToSource[viewId];\n  allRelations && allRelations.forEach(relObj => {\n    const strategyDef = _strategies.syncStrategies[relObj.handlerId];\n\n    if (_vmPathCache[relObj.source.viewId]) {\n      const sourceObj = _vmPathCache[relObj.source.viewId][relObj.source.modelId]; // check whether the src is loaded or not\n\n      if (sourceObj) {\n        const handler = _strategies.syncStrategyHandlers[relObj.handlerName];\n        const sourceVm = sourceObj.vm;\n        let srcPortData = sourceVm.ports ? sourceVm.ports[strategyDef.source.port] : null;\n        const syncContext = {\n          targetViewModel: declVm,\n          sourceViewModel: sourceVm\n        }; // evaluate activewhen\n\n        const isActive = _evaluateActiveWhen(handler, syncContext);\n\n        if (isActive && handler.action) {\n          const launch = _executeHandlerAction(handler, syncContext, srcPortData, declVm, strategyDef);\n\n          syncExecutePromises.push(launch);\n        } else if (isActive) {\n          srcPortData = srcPortData ? srcPortData.syncObject : null;\n          syncExecutePromises.push(_fireTargetAction(declVm, srcPortData, strategyDef));\n        }\n      }\n    }\n  });\n\n  if (syncExecutePromises.length) {\n    return AwPromiseService.instance.all(syncExecutePromises);\n  }\n\n  return AwPromiseService.instance.resolve({\n    code: 'NO_OUTSTANDING_REQUEST_PRESENT',\n    message: 'view model mount completed'\n  });\n};\n\nconst _updateOnUnmount = function (declVm) {\n  const syncExecutePromises = [];\n  const viewId = declVm.data._internal.viewId;\n  const modelId = declVm.data._internal.modelId;\n\n  if (_vmPathCache[viewId]) {\n    const allHandlers = Object.values(_vmPathCache[viewId][modelId])[1];\n\n    _.forEach(allHandlers, handler => {\n      const syncStrategyDef = _strategies.syncStrategies[handler.id];\n      syncExecutePromises.push(_fireTargetAction(Object.values(handler.target)[0], '', syncStrategyDef));\n    });\n  }\n\n  if (syncExecutePromises.length) {\n    return AwPromiseService.instance.all(syncExecutePromises);\n  }\n\n  return AwPromiseService.instance.resolve({\n    code: 'NO_OUTSTANDING_REQUEST_PRESENT',\n    message: 'view model unmount completed'\n  });\n};\n/**\n * triggerSyncStrategy\n * @param {Object} declVm decl viewModel of view\n * @param {String} isMount if vm loaded, then true. if vm unloaded, then false\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\n\n\nexport const updateVmOnMountUnmount = function (declVm, isMount) {\n  if (isMount) {\n    // need to add entry to cache as src and trg\n    _addToCachePaths(declVm); // target mounted\n\n\n    return _updateOnMount(declVm);\n  } // if source unmount, reset all the targets.\n\n\n  _updateOnUnmount(declVm); // need to remove entry from cache\n\n\n  return _removeFromCachePaths(declVm);\n};\nloadConfiguration();\nexports = {\n  updatePort,\n  updateVmOnMountUnmount,\n  loadConfiguration,\n  getElementArray,\n  setupSyncStrategy\n};\nexport default exports;","map":{"version":3,"names":["_","AwPromiseService","appCtxSvc","cfgSvc","viewModelSvc","conditionSvc","declUtils","moduleLoader","logger","syncViewModelCacheService","actionService","_syncStrategyMap","_vmPathCache","_strategies","_declViewModel","exports","createViewModel","viewModel","_viewModelId","Math","random","skipClone","populateViewModelPropertiesFromJson","setupSyncStrategy","dataCtxNode","id","data","_internal","modelId","path","viewId","set","loadConfiguration","getCfg","then","strategies","AFX_UTEST","Map","handlersRelation","targetRelationToSource","key","syncStrategyHandlers","handler","syncStrategyId","synConfigObject","syncStrategies","sPort","source","port","sViewHierarchy","view","split","sView","length","has","ports","get","push","getDeclViewModel","_fireTargetAction","targetViewModel","value","strategyConfig","targetPort","Object","assign","getPortById","target","isNil","isEmpty","syncObject","portsData","dispatch","executeCommand","onChangeAction","instance","resolve","errorCode","errorMessage","_executePreProcessingAction","actionName","syncContext","deferred","defer","action","actions","deps","actionId","method","doAction","depModuleObj","isDestroyed","warn","reject","ctx","localDataCtx","resolveLocalDataCtx","_depModuleObj","executeAction","getDependentModule","Promise","_runAction","syncStrategyDef","response","actionData","_executeHandlerAction","_evaluateActiveWhen","strategyObject","evaluateConditionExpression","clauseName","conditionList","_requestUpdate","portName","syncExecutePromises","srcObj","allHandlers","forEach","handlers","name","indexOf","values","sourceViewModel","vm","launch","all","updatePort","declViewModel","inputData","newValue","vmCacheMap","sourceVm","sourceVmData","sPortObject","getElementArray","viewPath","elementString","body","document","elementPathArray","viewName","uniqueViewElement","querySelectorAll","validateViewPath","context","viewPathArray","initialCheck","preIndex","currIndex","comViewPathArray","props","i","getViewNameFromPath","_addToCachePaths","_cachingAsSource","allHandlersName","flatMap","h","reduce","handlersObj","activeWhen","targetObj","targetVm","asTarget","entries","acc","obj","_cachingAsTarget","targetHandler","matchingSrc","trgVm","handlerId","handlerName","_removeFromCachePaths","_updateOnMount","declVm","allRelations","relObj","strategyDef","sourceObj","srcPortData","isActive","code","message","_updateOnUnmount","updateVmOnMountUnmount","isMount"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/syncStrategyService.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/* global AFX_UTEST */\n\n/**\n * This service is used to manage the sync strategies.\n *\n * @module js/syncStrategyService\n *\n */\nimport _ from 'lodash';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport cfgSvc from 'js/configurationService';\nimport viewModelSvc from 'js/viewModelService';\nimport conditionSvc from 'js/conditionService';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport actionService from 'js/actionService';\n\nlet _syncStrategyMap;\nconst _vmPathCache = {};\nvar _strategies = null;\nlet _declViewModel = null;\nvar exports = {};\n\n/**\n * Create the declartive viewModel from all combined syncStrategy.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */\nfunction createViewModel( viewModel ) {\n    viewModel._viewModelId = 'syncStrategyViewModel_' + Math.random();\n    viewModel.skipClone = true;\n    return viewModelSvc.populateViewModelPropertiesFromJson( viewModel, null, null, true );\n}\n\nexport const setupSyncStrategy = ( dataCtxNode ) => {\n    const id = dataCtxNode.data._internal.modelId;\n    const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n    syncViewModelCacheService.set( path + '.' + id, dataCtxNode );\n};\nexport const loadConfiguration = async function() {\n    await cfgSvc.getCfg( 'syncStrategy' ).then( strategies => {\n        _strategies = strategies;\n        if( !_strategies && AFX_UTEST ) {\n            _strategies = {};\n        }\n        _syncStrategyMap = new Map();\n        // handler relatioin w.r.t to source\n        if( !_vmPathCache.handlersRelation ) {\n            _vmPathCache.handlersRelation = {};\n        }\n\n        // target relation with source\n        if( !_vmPathCache.targetRelationToSource ) {\n            _vmPathCache.targetRelationToSource = {};\n        }\n\n        /*\n            <sourceView>: {\n                \"<port1>\": ['<handler1>', '<handler2>'],\n                \"<port2>\": ['<handler3>', '<handler4>'],\n            }\n        */\n        for( var key in _strategies.syncStrategyHandlers ) {\n            let handler = _strategies.syncStrategyHandlers[ key ];\n            let syncStrategyId = handler.id;\n            let synConfigObject = _strategies.syncStrategies[ syncStrategyId ];\n            let sPort = synConfigObject.source.port;\n            let sViewHierarchy = synConfigObject.source.view.split( '/' );\n            let sView = sViewHierarchy[ sViewHierarchy.length - 1 ];\n\n            if( !_syncStrategyMap.has( sView ) ) {\n                _syncStrategyMap.set( sView, { ports: {} } );\n            }\n            if( !_syncStrategyMap.get( sView ).ports[ sPort ] ) {\n                _syncStrategyMap.get( sView ).ports[ sPort ] = [];\n            }\n\n            _syncStrategyMap.get( sView ).ports[ sPort ].push( key );\n        }\n    } );\n};\n\nconst getDeclViewModel = function() {\n    return createViewModel( _strategies );\n};\n\nconst _fireTargetAction = function( targetViewModel, value, strategyConfig ) {\n    if( targetViewModel && targetViewModel.data ) {\n        const targetPort = Object.assign( {}, targetViewModel.data.getPortById( strategyConfig.target.port ) );\n        // if port of target is present, then only fire action\n        if( !_.isNil( targetPort ) && !_.isEmpty( targetPort ) ) {\n            // adding input object to targets port\n            targetPort.syncObject = value;\n            // adding ports as a sibling to data in VM.\n            const portsData = {\n                ...targetViewModel.ports,\n                [ strategyConfig.target.port ]: targetPort\n            };\n            // zarq9k: Cannot do dispatch on unmount process.\n            // Need to re-think on strategy. It is a point fix.\n            if( targetViewModel.data && targetViewModel.data.dispatch ) {\n                targetViewModel.data.dispatch( { path: 'ports', value: portsData } );\n                targetViewModel.data.ports = portsData;\n                targetViewModel.ports = targetViewModel.data.ports;\n                return viewModelSvc.executeCommand( targetViewModel.data, targetPort.onChangeAction, targetViewModel );\n            }\n            return AwPromiseService.instance.resolve();\n        }\n        return AwPromiseService.instance.resolve( { errorCode: 'NO_TARGET_PORT_FOUND', errorMessage: `No port is configured for view: ${targetViewModel.data._internal.viewId}` } );\n    }\n    return AwPromiseService.instance.resolve();\n};\n\nconst _executePreProcessingAction = function( actionName, syncContext, value ) {\n    var deferred = AwPromiseService.instance.defer();\n    var action = _strategies.actions[ actionName ];\n    if( action.deps ) {\n        /** action ID will be used for better logging */\n        action.actionId = action.method;\n\n        var doAction = function( depModuleObj ) {\n            if( _declViewModel.isDestroyed() ) {\n                logger.warn( 'Attempt to execute a command after its DeclViewModel was destroyed...' +\n                    '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n                    'DeclViewModel: ' + _declViewModel + '\\n' + //\n                    'Action       : ' + action );\n                return AwPromiseService.instance.reject();\n            }\n            /**\n             * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n             * event processing was started.\n             */\n            _declViewModel.value = value;\n            var dataCtxNode = {\n                data: _declViewModel,\n                ctx: appCtxSvc.ctx,\n                syncContext: syncContext\n            };\n            var localDataCtx = declUtils.resolveLocalDataCtx( _declViewModel, dataCtxNode );\n\n            // _deps will be undefined when try to load viewModelService inside itself\n            var _depModuleObj = depModuleObj;\n            return actionService.executeAction( _declViewModel, action, localDataCtx, _depModuleObj, true );\n        };\n        return moduleLoader.getDependentModule( action.deps ).then( depModuleObj => {\n            return doAction( depModuleObj );\n        } );\n    }\n    return deferred.Promise;\n};\n\nconst _runAction = function( handler, syncContext, value, targetViewModel, syncStrategyDef ) {\n    return _executePreProcessingAction( handler.action, syncContext, value ).then( function( response ) {\n        // response data is avaiable on response.actionData\n        return _fireTargetAction( targetViewModel, response.actionData, syncStrategyDef );\n    } );\n};\n\nconst _executeHandlerAction = function( handler, syncContext, value, targetViewModel, syncStrategyDef ) {\n    if( !_declViewModel ) {\n        _declViewModel = getDeclViewModel();\n    }\n    return _runAction( handler, syncContext, value, targetViewModel, syncStrategyDef );\n};\n\nconst _evaluateActiveWhen = function( strategyObject, syncContext ) {\n    return conditionSvc.evaluateConditionExpression( strategyObject, { syncContext: syncContext, ctx: appCtxSvc.ctx }, { clauseName: 'activeWhen', conditionList: _strategies } );\n};\n\nconst _requestUpdate = function( viewId, modelId, portName, value ) {\n    if( _syncStrategyMap.get( viewId ) && _syncStrategyMap.get( viewId ).ports[ portName ] ) {\n        var syncExecutePromises = [];\n        if( _vmPathCache[ viewId ] ) {\n            const srcObj = _vmPathCache[ viewId ][ modelId ];\n            var allHandlers = _syncStrategyMap.get( viewId ).ports[ portName ];\n            _.forEach( srcObj.handlers, function( handler, name ) {\n                if( allHandlers.indexOf( name ) > -1 && handler.target ) {\n                    Object.values( handler.target ).forEach( ( targetViewModel ) => {\n                        const syncStrategyDef = _strategies.syncStrategies[ handler.id ];\n                        const syncContext = { targetViewModel: targetViewModel, sourceViewModel: srcObj.vm };\n                        // evaluate activewhen\n                        if( _evaluateActiveWhen( handler, syncContext ) ) {\n                            if( handler.action ) {\n                                var launch = _executeHandlerAction( handler, syncContext, value, targetViewModel, syncStrategyDef );\n                                syncExecutePromises.push( launch );\n                            } else {\n                                syncExecutePromises.push( _fireTargetAction( targetViewModel, value, syncStrategyDef ) );\n                            }\n                        }\n                    } );\n                }\n            } );\n        }\n        if( syncExecutePromises.length ) {\n            return AwPromiseService.instance.all( syncExecutePromises );\n        }\n    }\n    return AwPromiseService.instance.resolve( { errorCode: 'NO_ACTIVE_ACTION_FOUND', errorMessage: `No sync action fired for view: ${viewId} with port: ${portName}` } );\n};\n\n/**\n * triggerSyncStrategy\n * @param {Object} declViewModel decl view model of source\n * @param {String} inputData resolved inputData from actionService\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\nexport const updatePort = function( declViewModel, inputData ) {\n    const viewId = declViewModel._internal.viewId;\n    const modelId = declViewModel._internal.modelId;\n    const portName = inputData.port;\n    const newValue = inputData.syncObject;\n    const vmCacheMap = syncViewModelCacheService.get( 'syncViewModelCache' );\n\n    if( vmCacheMap[ viewId ] && vmCacheMap[ viewId ][ modelId ] ) {\n        const sourceVm = vmCacheMap[ viewId ][ modelId ];\n        if( sourceVm && sourceVm.data && sourceVm.data.getPortById( portName ) ) {\n            let sourceVmData = sourceVm.data;\n            let sPortObject = Object.assign( {}, sourceVmData.getPortById( portName ) );\n            sPortObject.syncObject = newValue ? newValue : sourceVm.ports[ portName ].syncObject;\n            // adding ports as a sibling to data in VM.\n            const portsData = {\n                ...sourceVm.ports,\n                [ portName ]: sPortObject\n            };\n            sourceVmData.dispatch( { path: 'ports', value: portsData } );\n\n            return _requestUpdate( viewId, modelId, portName, newValue );\n        }\n    }\n    return AwPromiseService.instance.resolve( { errorCode: 'NO_PORT_FOUND', errorMessage: `No port is configured for view: ${viewId}` } );\n};\n\n/**\n * revisitme: find out the solution for this API to support other use cases\n * @param {*} viewPath viewpath\n * @returns {Array} array of elements\n */\nexport const getElementArray = function( viewPath ) {\n    var elementString = '';\n    var body = document.body;\n    var elementPathArray = viewPath.split( '/' );\n    if( elementPathArray && elementPathArray.length > 1 ) {\n        // aw-include[name='commonRoot'] aw-include[name='commonLocation'] aw-include[name='showcaseMain']\"\n        elementPathArray.forEach( function( viewName ) {\n            elementString = elementString + 'aw-include[name=\"' + viewName + '\"] ';\n        } );\n    } else {\n        // aw-include[view-id='commonRoot']\n        var uniqueViewElement = body.querySelectorAll( 'aw-include[view-id=\"' + elementPathArray[ 0 ] + '\"] ' );\n        if( uniqueViewElement && uniqueViewElement.length === 1 ) {\n            return uniqueViewElement;\n        }\n        // aw-include[name='commonRoot']\n        elementString = 'aw-include[name=\"' + elementPathArray[ 0 ] + '\"] ';\n    }\n\n    // revisitme : currently supporting only viewName use case, figure out impact of following commented line\n    // return body.querySelectorAll( elementString );\n    return [ 'dummyelement' ];\n};\n\nconst validateViewPath = function( context, viewPath, viewId ) {\n    const viewPathArray = viewPath.split( '/' );\n    let initialCheck = viewPathArray[ viewPathArray.length - 1 ] === viewId;\n    if( initialCheck && viewPathArray.length > 1 ) {\n        let preIndex = -1;\n        let currIndex = 0;\n        let comViewPathArray = context.props.viewPath.split( '/' );\n        for( let i = 0; i < viewPathArray.length; i++ ) {\n            currIndex = comViewPathArray.indexOf[ viewPathArray[ i ] ];\n            if( currIndex === -1 && currIndex < preIndex ) {\n                initialCheck = false;\n                break;\n            } else {\n                preIndex = currIndex;\n            }\n        }\n    }\n    return initialCheck;\n};\n\nconst getViewNameFromPath = function( viewPath ) {\n    const viewPathArray = viewPath.split( '/' );\n    return viewPathArray[ viewPathArray.length - 1 ];\n};\n\nconst _addToCachePaths = function( declViewModel ) {\n    const viewId = declViewModel.data._internal.viewId;\n    const modelId = declViewModel.data._internal.modelId;\n    const vmCacheMap = syncViewModelCacheService.get( 'syncViewModelCache' );\n\n    const _cachingAsSource = () => {\n        const allHandlersName = Object.values( _syncStrategyMap.get( viewId ).ports ).flatMap( h => h );\n\n        const handlers = allHandlersName.reduce( ( handlersObj, name ) => {\n            const { id, action, activeWhen } = _strategies.syncStrategyHandlers[ name ];\n            if( validateViewPath( declViewModel, _strategies.syncStrategies[ id ].source.view, viewId ) ) {\n                const targetObj = _strategies.syncStrategies[ id ].target;\n                const targetVm = vmCacheMap[ getViewNameFromPath( targetObj.view ) ];\n                handlersObj[ name ] = {\n                    id,\n                    action,\n                    activeWhen,\n                    target: targetVm ? targetVm : {}\n                };\n\n                _vmPathCache.handlersRelation[ name ] = {\n                    viewId: viewId,\n                    modelId: modelId\n                };\n            }\n\n            return handlersObj;\n        }, {} );\n\n        // handling for multiple entry for same viewId\n        if( !_vmPathCache[ viewId ] ) {\n            _vmPathCache[ viewId ] = {};\n        }\n        _vmPathCache[ viewId ][ modelId ] = {\n            get vm() {\n                return syncViewModelCacheService.get( 'syncViewModelCache' )[ viewId ][ modelId ];\n            },\n            handlers: handlers\n        };\n    };\n\n    // vm act as source\n    if( _syncStrategyMap.get( viewId ) && ( !_vmPathCache[ viewId ] || !_vmPathCache[ viewId ][ modelId ] ) ) {\n        _cachingAsSource();\n    }\n\n    // vm act as target\n    const asTarget = Object.entries( _strategies.syncStrategies ).reduce( ( acc, obj ) => {\n        if( validateViewPath( declViewModel, obj[ 1 ].target.view, viewId ) ) {\n            acc.push( obj[ 0 ] );\n        }\n        return acc;\n    }, [] );\n\n    const _cachingAsTarget = () => {\n        const targetHandler = Object.entries( _strategies.syncStrategyHandlers ).reduce( ( acc, obj ) => {\n            if( asTarget.indexOf( obj[ 1 ].id ) > -1 ) {\n                acc[ obj[ 0 ] ] = obj[ 1 ];\n            }\n            return acc;\n        }, {} );\n\n        _.forEach( targetHandler, ( obj, key ) => {\n            const matchingSrc = _vmPathCache.handlersRelation[ key ];\n            if( matchingSrc && _syncStrategyMap.get( matchingSrc.viewId ) ) {\n                const view = getViewNameFromPath( _strategies.syncStrategies[ obj.id ].target.view );\n                const trgVm = vmCacheMap[ view ];\n                const handlers = _vmPathCache[ matchingSrc.viewId ][ matchingSrc.modelId ].handlers;\n                handlers[ key ].target = trgVm ? trgVm : {};\n\n                if( !_vmPathCache.targetRelationToSource[ view ] ) {\n                    _vmPathCache.targetRelationToSource[ view ] = [];\n                }\n                _vmPathCache.targetRelationToSource[ view ].push( {\n                    source: {\n                        viewId: matchingSrc.viewId,\n                        modelId: matchingSrc.modelId\n                    },\n                    modelId: modelId,\n                    handlerId: obj.id,\n                    handlerName: key\n                } );\n            }\n        } );\n    };\n\n    if( asTarget && asTarget.length ) {\n        _cachingAsTarget();\n    }\n};\n\nconst _removeFromCachePaths = function( declViewModel ) {\n    const viewId = declViewModel.data._internal.viewId;\n\n    // clear relations\n    _.forEach( _vmPathCache.handlersRelation, ( obj, key ) => {\n        if( obj.viewId === viewId ) {\n            delete _vmPathCache.handlersRelation[ key ];\n        }\n    } );\n\n    // clear target relation with source\n    if( _vmPathCache.targetRelationToSource[ viewId ] ) {\n        delete _vmPathCache.targetRelationToSource[ viewId ];\n    }\n    // clear vm from vmPathCache\n    if( _vmPathCache[ viewId ] ) {\n        delete _vmPathCache[ viewId ];\n    }\n};\n\nconst _updateOnMount = function( declVm ) {\n    const syncExecutePromises = [];\n    const viewId = declVm.data._internal.viewId;\n    const allRelations = _vmPathCache.targetRelationToSource[ viewId ];\n    allRelations && allRelations.forEach( ( relObj ) => {\n        const strategyDef = _strategies.syncStrategies[ relObj.handlerId ];\n        if( _vmPathCache[ relObj.source.viewId ] ) {\n            const sourceObj = _vmPathCache[ relObj.source.viewId ][ relObj.source.modelId ];\n            // check whether the src is loaded or not\n            if( sourceObj ) {\n                const handler = _strategies.syncStrategyHandlers[ relObj.handlerName ];\n                const sourceVm = sourceObj.vm;\n                let srcPortData = sourceVm.ports ? sourceVm.ports[ strategyDef.source.port ] : null;\n                const syncContext = { targetViewModel: declVm, sourceViewModel: sourceVm };\n\n                // evaluate activewhen\n                const isActive = _evaluateActiveWhen( handler, syncContext );\n                if( isActive && handler.action ) {\n                    const launch = _executeHandlerAction( handler, syncContext, srcPortData, declVm, strategyDef );\n                    syncExecutePromises.push( launch );\n                } else if( isActive ) {\n                    srcPortData = srcPortData ? srcPortData.syncObject : null;\n                    syncExecutePromises.push( _fireTargetAction( declVm, srcPortData, strategyDef ) );\n                }\n            }\n        }\n    } );\n\n    if( syncExecutePromises.length ) {\n        return AwPromiseService.instance.all( syncExecutePromises );\n    }\n    return AwPromiseService.instance.resolve( { code: 'NO_OUTSTANDING_REQUEST_PRESENT', message: 'view model mount completed' } );\n};\n\nconst _updateOnUnmount = function( declVm ) {\n    const syncExecutePromises = [];\n\n    const viewId = declVm.data._internal.viewId;\n    const modelId = declVm.data._internal.modelId;\n    if( _vmPathCache[ viewId ] ) {\n        const allHandlers = Object.values( _vmPathCache[ viewId ][ modelId ] )[ 1 ];\n\n        _.forEach( allHandlers, ( handler ) => {\n            const syncStrategyDef = _strategies.syncStrategies[ handler.id ];\n            syncExecutePromises.push( _fireTargetAction( Object.values( handler.target )[ 0 ], '', syncStrategyDef ) );\n        } );\n    }\n\n    if( syncExecutePromises.length ) {\n        return AwPromiseService.instance.all( syncExecutePromises );\n    }\n    return AwPromiseService.instance.resolve( { code: 'NO_OUTSTANDING_REQUEST_PRESENT', message: 'view model unmount completed' } );\n};\n\n/**\n * triggerSyncStrategy\n * @param {Object} declVm decl viewModel of view\n * @param {String} isMount if vm loaded, then true. if vm unloaded, then false\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\nexport const updateVmOnMountUnmount = function( declVm, isMount ) {\n    if( isMount ) {\n        // need to add entry to cache as src and trg\n        _addToCachePaths( declVm );\n        // target mounted\n        return _updateOnMount( declVm );\n    }\n    // if source unmount, reset all the targets.\n    _updateOnUnmount( declVm );\n    // need to remove entry from cache\n    return _removeFromCachePaths( declVm );\n};\n\nloadConfiguration();\n\nexports = {\n    updatePort,\n    updateVmOnMountUnmount,\n    loadConfiguration,\n    getElementArray,\n    setupSyncStrategy\n};\n\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}