{"ast":null,"code":"/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service manages the 'source' object information placed into 'localStorage' during drag-n-drop operations.\n *\n * @module js/dragAndDropService\n */\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport dms from 'soa/dataManagementService';\nimport soaSvc from 'soa/kernel/soaService';\nimport cfgSvc from 'js/configurationService';\nimport messagingSvc from 'js/messagingService';\nimport localeService from 'js/localeService';\nimport appCtxSvc from 'js/appCtxService';\nimport adapterSvc from 'js/adapterService';\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport declUtils from 'js/declUtils';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport dragAndDropUtils from 'js/dragAndDropUtils'; // Service\n\nimport AwBaseService from 'js/awBaseService';\nimport AwStateService from 'js/awStateService';\nimport pasteService from 'js/pasteService';\nimport AwPromiseService from 'js/awPromiseService';\nimport htmlUtils from 'js/htmlUtils'; // Class for load handler\n// This file is too complex to convert it to a complete class\n\nclass DragAndDropService extends AwBaseService {\n  static reset() {\n    AwBaseService.reset();\n    delete this._defaultPasteHandler;\n    delete this._pasteFileHandler;\n  }\n\n  constructor() {\n    super(); // The following check is to support Karma testing which invokes this multiple times.\n\n    if (!_cfgLoadPromise && !(this.constructor._defaultPasteHandler || this.constructor._pasteFileHandler)) {\n      _cfgLoadPromise = cfgSvc.getCfg('paste').then(pasteProvider => {\n        if (pasteProvider.defaultPasteHandler) {\n          return declUtils.loadDependentModule(pasteProvider.defaultPasteHandler.dep).then(dep => {\n            this.constructor._defaultPasteHandler = dep;\n            return pasteProvider;\n          });\n        }\n\n        return pasteProvider;\n      }).then(pasteProvider => {\n        if (pasteProvider.defaultPasteFileHandler) {\n          return declUtils.loadDependentModule(pasteProvider.defaultPasteFileHandler.dep).then(dep => {\n            this.constructor._pasteFileHandler = dep;\n            return pasteProvider;\n          });\n        }\n      }).then(function () {\n        _cfgLoadPromise = null;\n      });\n    }\n  }\n\n  get pasteHandler() {\n    return this.constructor._defaultPasteHandler;\n  }\n\n  get pasteFileHandler() {\n    return this.constructor._pasteFileHandler;\n  }\n\n}\n/**\n * Data formats to put the data in. It would be better to only use aw_interop_type here, but that isn't working\n * with Chrome.\n */\n\n\nvar DATA_FORMATS = ['text/html', 'aw_interop_type'];\n/** Dataset type */\n\nvar TYPE_NAME_DATASET = 'Dataset';\n/** This is set to true if any of the dragged objects have a type set.\n */\n\nvar modelsHaveTypes;\n/**\n * {DOMElement} root container for the page.\n */\n\nvar mainReference;\n/**\n * {Boolean} TRUE if the drag event should have it's 'dataTransfer' object set/maintained.\n */\n\nvar _includeDataTransfer = true;\n/**\n * {Boolean} TRUE if various drag event activities should publish 'hosting' related events.\n */\n\nvar _publishHostingEvents = false;\n/**\n * {Function} A callback used to create the 'InteropObjectRef' encodings necessary to communicate more complex\n * selection information via drag event data format properties.\n * <P>\n * Note: Until the hosting 'InteropObjectRefFactory' is converted from GWT to native JS we must rely on it for\n * conversion of IModelObjects to the special encoding used for communications of 'source' objects to the host.\n */\n\nvar _createInteropObjectRefFn;\n/**\n * Temporary promise reference for loading of the configuration data. This is used to allow code to wait until\n * ready before doing work.\n *\n * @private\n */\n\n\nvar _cfgLoadPromise;\n/**\n * <pre>\n * Greater Than 0 If some basic event activity should be logged.\n * Greater Than 1 If some more fine-grained event activity should be logged.\n * </pre>\n */\n\n\nvar _debug_logEventActivity = 0;\nconst HOSTING_DRAG_DROP_EVENT = 'hosting.DragDropEvent';\nconst UI_GRID_ROW_CLASS = '.ui-grid-row';\nconst DROP_CLASS = '.aw-widgets-droppable';\nconst DRAG_DROP_HIGHLIGHT_EVENT = 'dragDropEvent.highlight';\nvar urlAttributes = browserUtils.getUrlAttributes();\n\nif (urlAttributes.logDnDEventActivity !== undefined) {\n  _debug_logEventActivity = 1;\n\n  if (urlAttributes.logDnDEventActivity > 0) {\n    _debug_logEventActivity = urlAttributes.logDnDEventActivity;\n  }\n}\n/**\n * TRUE if the type that was not valid for a target is logged. This is very handy when debugging issues.\n */\n\n\nvar m_debug_LogRejectedSourceType = false;\n/**\n * Map used to hold an unresolved {Promise} for a given 'evaluation key' *while* the async server call is being\n * made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\n\nvar m_mapKey2Promise = {};\n/**\n * Map used to hold the *result* of a previous async server call for a given 'evaluation key'.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\n\nvar m_mapKey2Result = {};\n/**\n * TRUE if dragging files from the OS file should be allowed.\n */\n\nvar m_supportingFileDrop = true;\n/**\n * Set used to hold an 'unresolved source type lookup key' *while( the async server call is being made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'unresolved source type lookup key'.\n * <P>\n * Note: The 'unresolved source type lookup key' is formed by a union of MissingSourceTypes.\n */\n\nvar m_typeLookupInProgress = {};\nlet isGlobalHighlightPublished = false; //* **********************************************************************\n\n/**\n * Clear out any 'dragData' that may have been created by the last Drag-n-Drop operation.\n */\n\nvar _clearCachedData = function () {\n  localStrg.publish('awDragData');\n};\n/**\n * @param {StringArray} validSourceTypes The 'sourceTypes' {@link JavaScriptObject} property from the\n *            pasteConfig for the given 'target' object type or its ancestor types up the hierarchy (or NULL if\n *            no match was found).\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n *\n * @returns {Object} A {@link Map} that relates 'source' types to the 1 or more possible relationship types that\n *         are valid for the 'owner' (i.e. 'target') {@link IModelObject}.\n */\n\n\nvar _createSourceType2RelationsMap = function (validSourceTypes, targetElement) {\n  var sourceType2RelationsMap = {};\n  var validSourceObjects = $(targetElement).data('validSourceTypes');\n\n  if (validSourceObjects) {\n    for (var i = 0; i < validSourceTypes.length; i++) {\n      var sourceType = validSourceTypes[i];\n      var validSourceObj = validSourceObjects[sourceType];\n      var relations = [];\n\n      if (validSourceObj.relation) {\n        relations.push(validSourceObj.relation);\n      } else {\n        relations.push('');\n      }\n\n      sourceType2RelationsMap[sourceType] = relations;\n    }\n  }\n\n  return sourceType2RelationsMap;\n};\n/**\n * Remove from selection any non-'target' object currently selected (like the ones we may have just pasted) so\n * that the 'target' can be cleanly selected later.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject the 'source' ViewModelObject(s) are being\n *            dropped onto.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAll = function (targetVMO, callbackAPIs) {\n  callbackAPIs.clearSelectionFn(targetVMO);\n};\n/**\n * Get the adapted objects corresponding to the VMOs if any.\n *\n * @param {ObjectArray} vmos - Array of viewmodel objects.\n *\n * @return {Array} Returns array of adapadted objects if any or else returns the vmos\n */\n\n\nconst getAdaptedObjects = vmos => {\n  return dragAndDropUtils.getObjects(vmos);\n};\n/**\n * Synchronously create Datasets, upload the given JS Files and attach the files to the Datasets using the\n * correct relation types and the tickets used to upload the files.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {ObjectArray} sourceFiles - The 'source' JS File objects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAllAndPasteSourceFiles = function (targetElement, targetVMO, sourceFiles, callbackAPIs) {\n  if (sourceFiles && sourceFiles.length > 0) {\n    _deselectAll(targetVMO, callbackAPIs);\n\n    _pasteSourceFiles(targetElement, targetVMO, sourceFiles, callbackAPIs);\n  }\n};\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObject(s) being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAllAndPasteSourceObjects = function (targetElement, targetVMO, sourceObjects, callbackAPIs) {\n  if (sourceObjects && sourceObjects.length > 0) {\n    _deselectAll(targetVMO, callbackAPIs);\n\n    _pasteSourceObjects(targetElement, targetVMO, sourceObjects, callbackAPIs);\n  }\n};\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element.\n *\n * @param {ObjectArray} sourceFiles - The array 'source' JS File objects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _dropFiles = function (targetElement, sourceFiles, callbackAPIs) {\n  var targetVMOs = callbackAPIs.getElementViewModelObjectFn(targetElement);\n\n  if (!targetVMOs || targetVMOs.length === 0) {\n    var targetUID = $(targetElement).data('dropuid');\n\n    if (targetUID) {\n      targetVMOs = [];\n      targetVMOs.push(exports.getTargetObjectByUid(targetUID));\n    }\n  }\n\n  if (targetVMOs && targetVMOs.length !== 0) {\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMOs[0].modelType)) {\n      adapterSvc.getAdaptedObjects(targetVMOs).then(function (adaptedObjs) {\n        _deselectAllAndPasteSourceFiles(targetElement, adaptedObjs[0], sourceFiles, callbackAPIs);\n      });\n    } else {\n      _deselectAllAndPasteSourceFiles(targetElement, targetVMOs[0], sourceFiles, callbackAPIs);\n    }\n  }\n\n  _clearCachedData();\n};\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _dropModelObjects = function (targetElement, sourceUIDs, callbackAPIs) {\n  var targetVMOs = callbackAPIs.getElementViewModelObjectFn(targetElement);\n\n  if (!targetVMOs || targetVMOs.length === 0) {\n    var targetUID = $(targetElement).data('dropuid');\n\n    if (targetUID) {\n      targetVMOs = [];\n      targetVMOs.push(exports.getTargetObjectByUid(targetUID));\n    }\n  }\n\n  if (targetVMOs && targetVMOs.length !== 0) {\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMOs[0].modelType)) {\n      adapterSvc.getAdaptedObjects(targetVMOs).then(function (adaptedObjs) {\n        _dropModelObjectsInternal(targetElement, sourceUIDs, callbackAPIs, adaptedObjs);\n      });\n    } else {\n      _dropModelObjectsInternal(targetElement, sourceUIDs, callbackAPIs, targetVMOs);\n    }\n  }\n};\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n *\n * @param {Object} targetVMOs - View model object of target.\n */\n\n\nvar _dropModelObjectsInternal = function (targetElement, sourceUIDs, callbackAPIs, targetVMOs) {\n  var sourceObjects = [];\n  var missingSourceUIDs = [];\n  /**\n   * Attempt to locate the 'source' objects in this browser's CDM cache.\n   * <P>\n   * Note: When 'source' objects are being dragged from another browser they may not have been loaded into the\n   * 'target' browser.\n   */\n\n  if (sourceUIDs) {\n    for (var i = 0; i < sourceUIDs.length; i++) {\n      var sourceObject = cdm.getObject(sourceUIDs[i]);\n\n      if (sourceObject) {\n        sourceObjects.push(sourceObject);\n      } else {\n        missingSourceUIDs.push(sourceUIDs[i]);\n      }\n    }\n  }\n  /**\n   * Check if NO 'source' objects are missing\n   * <P>\n   * If so: Process the past now\n   */\n\n\n  if (!missingSourceUIDs || missingSourceUIDs.length === 0) {\n    _deselectAllAndPasteSourceObjects(targetElement, targetVMOs[0], sourceObjects, callbackAPIs);\n\n    _clearCachedData();\n  } else {\n    /**\n     * Attempt to locate the missing 'source' objects on the server.\n     */\n    dms.loadObjects(missingSourceUIDs, function () {\n      /**\n       * Attempt to locate the (formerly) missing 'targets' and add them to the list of 'source' objects\n       * to drop on the 'target'\n       */\n      for (var j = 0; j < missingSourceUIDs.length; j++) {\n        var sourceObject = cdm.getObject(missingSourceUIDs[j]);\n\n        if (sourceObject) {\n          sourceObjects.push(sourceObject);\n        } else {// var sourceTypes = _getCachedSourceTypes();\n          // logger.warn( 'Unable to locate \\'source\\' IModelObject\\' (not loaded yet): ' +\n          //     missingSourceUIDs[ j ] + ' of type: ' + sourceTypes[ 0 ] );\n        }\n      }\n\n      if (sourceObjects && sourceObjects.length > 0) {\n        _deselectAllAndPasteSourceObjects(targetElement, targetVMOs[0], sourceObjects, callbackAPIs);\n      }\n\n      _clearCachedData();\n    });\n  }\n};\n/**\n * Starting with the given DOM Element and walking up the DOM, look for the 1st DOM Element with the\n * 'containerId' property set.\n *\n * @param {Element} testElement - The element to start the search at.\n *\n * @return {Number} The ID of the 'parent' element that has the 'containerId' set on it (or NULL if no Element\n *         was found).\n */\n\n\nvar _findContainerId = function (testElement) {\n  var currElement = testElement;\n\n  while (currElement) {\n    var containerId = $(currElement).data('containerId');\n\n    if (containerId) {\n      return containerId.toString();\n    }\n\n    currElement = currElement.parentElement;\n  }\n\n  return null;\n};\n/**\n * When object drag is cancelled , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {bool}_isDragCancelFlag -  true or false\n */\n\n\nvar _isDragCancelled = function (event) {\n  var _isDragCancelFlag = false;\n\n  if (event.x <= 0 || event.y <= 0) {\n    _isDragCancelFlag = true;\n  } else if (event.screenX <= 0 || event.screenY <= 0) {\n    _isDragCancelFlag = true;\n  } else {\n    _isDragCancelFlag = false;\n  }\n\n  return _isDragCancelFlag;\n};\n/**\n * When object is dragged over a cell list container , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\n\n\nvar _isDragWithinCellListContainer = function (event) {\n  var isCellListContainerFlag = false;\n  var cellListContainer = htmlUtils.closestElement(event.target, '.aw-widgets-cellListContainer');\n\n  if (_.isUndefined(cellListContainer) || cellListContainer === null) {\n    isCellListContainerFlag = false;\n  } else {\n    isCellListContainerFlag = true;\n  }\n\n  return isCellListContainerFlag;\n};\n/**\n * When object is dragged over a table row border, this check ensures the drag cursor does not go back to 'Not allowed' because of global\n * dragenter event since table row border is an invalid drop target\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\n\n\nvar _isDragWithinTableContainer = function (event) {\n  var isTableFlag = false;\n  var tableContainer = htmlUtils.closestElement(event.target, UI_GRID_ROW_CLASS);\n\n  if (_.isUndefined(tableContainer) || tableContainer === null) {\n    if (event && event.target && event.target.classList && event.target.classList.contains('ui-grid-row')) {\n      isTableFlag = true;\n    }\n  } else {\n    isTableFlag = true;\n  }\n\n  return isTableFlag;\n};\n/**\n * When object is dragged over the white area, this check ensures  dragenter, dragleave , dragover events on document do not trigger any action in turn giving\n * a flickering of highlight effect on the container\n *\n * @param {event} event - Drag event\n * @return {Object} bool - flag to suggest if drag is within an applicable and valid container\n */\n\n\nvar _isDragWithinApplicableValidContainer = function (event) {\n  var bool = false;\n  var jqTarget = $(event.target);\n  var jqContainer = jqTarget.closest(UI_GRID_ROW_CLASS);\n\n  if (jqContainer && jqContainer.length <= 0) {\n    jqContainer = jqTarget.closest('.aw-widgets-cellListItem');\n\n    if (jqContainer.length <= 0) {\n      jqContainer = jqTarget.closest(DROP_CLASS);\n\n      if (jqContainer.length <= 0) {\n        // this is when user just enters a cellListContainer from white area\n        if (jqTarget && jqTarget[0] && jqTarget[0].children && jqTarget[0].children.length > 0 && jqTarget[0].children[0].classList && jqTarget[0].children[0].classList.contains('aw-widgets-cellListContainer')) {\n          jqContainer = jqTarget[0].children;\n        }\n      }\n    }\n  }\n\n  if (jqContainer && jqContainer.length > 0 && exports.isValidObjectToDrop(event, jqContainer[0])) {\n    bool = true;\n  }\n\n  return bool;\n};\n/**\n * @param {event} event - Dragover event\n *\n * @return {Object} targetElement - choose or drop file widget which do not require validation or\n *                                   'undefined' if not over Choose or Drop File widgets\n */\n\n\nvar _isDragOverChooseOrDropFileContainer = function (event) {\n  var targetElement = null;\n\n  if (event && event.target && event.target.classList && event.target.classList.contains('aw-widgets-chooseordropfile')) {\n    targetElement = event.target;\n  } else {\n    var cfContainer = htmlUtils.closestElement(event.target, '.aw-widgets-chooseordropfile');\n\n    if (cfContainer) {\n      targetElement = cfContainer;\n    }\n  }\n\n  return targetElement;\n};\n/**\n * Determine if the DragEvent is over a white space on the page or on an applicable valid drop container\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\n\n\nexport let processDragOver = function (event, isCurrentTargetOverGlobalArea) {\n  // If drag is over Choose File or Drop File container , unhighlight other highlighted containers, highlight this\n  // container and set drop effect to 'Copy' ; these containers have a special css(in addition) to identify : 'aw-widgets-chooseordropfile'\n  var chooseFileContainer = _isDragOverChooseOrDropFileContainer(event);\n\n  if (chooseFileContainer) {\n    // Adding listeners to Choose/Drop File type widgets which mandatorily should have 'aw-widgets-chooseordropfile' associated\n    // along with 'aw-widgets-droppable' css class  to participate in highlight\n    chooseFileContainer.addEventListener('dragover', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS OVER CHOOSE/DROP FILE ZONE----------');\n      }\n\n      exports.processDragLeaveGlobal(event); // clear all the highlights\n\n      if (!exports.dataTransferContainsFiles(event)) {\n        _setDropEffect(event, 'none');\n\n        event.stopPropagation();\n      } else {\n        eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n          event: event,\n          isGlobalArea: false,\n          isHighlightFlag: true,\n          targetElement: chooseFileContainer\n        });\n\n        _setDropEffect(event, 'copy');\n\n        event.stopPropagation(); // required or else it hangs the page if file dragged over container for longer period of time.\n\n        event.preventDefault();\n      }\n    });\n    chooseFileContainer.addEventListener('dragleave', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS LEAVING CHOOSE/DROP FILE ZONE----------');\n      }\n\n      _setDropEffect(event, 'none');\n\n      exports.processDragLeaveGlobal(event);\n      event.stopPropagation();\n      event.preventDefault();\n    });\n    chooseFileContainer.addEventListener('drop', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS DROPPED IN CHOOSE/DROP FILE ZONE----------');\n      }\n\n      _setDropEffect(event, 'none');\n\n      exports.processDragLeaveGlobal(event);\n      event.stopPropagation();\n      event.preventDefault();\n    });\n  }\n\n  var sourceUIDs = exports.getCachedSourceUids();\n\n  if (sourceUIDs) {\n    dragAndDropUtils.loadVMOsIfNotAlreadyLoaded(sourceUIDs);\n  }\n\n  _processDragOverInternal(event, isCurrentTargetOverGlobalArea);\n};\n/**\n * Starting with the 'target' of the given DragEvent and walking up the DOM, look for the 1st DOM Element with the\n * 'validSourceTypes' property set.\n *\n * @param {DragEvent} event - The event to start the search at.\n * @param {Bool} isCurrentTargetOverGlobalArea - is the dragged file over white/invalid area\n * @return {Element} The Element that has the 'validSourceTypes' property set on it (or NULL if no Element was\n *         found).\n */\n\nvar _findDropTargetElement = function (event) {\n  var targetElements = [];\n  /**\n   * Get the JQuery element for the event 'target' and look for common 'container' elements 'up' the DOM Tree.\n   */\n\n  var jqTarget = $(event.target);\n  var jqContainer = jqTarget.closest(UI_GRID_ROW_CLASS);\n\n  if (jqContainer !== undefined && jqContainer.length <= 0) {\n    jqContainer = jqTarget.closest('.aw-widgets-cellListItem');\n\n    if (jqContainer.length <= 0) {\n      jqContainer = jqTarget.closest(DROP_CLASS);\n    }\n  }\n\n  var targetElement;\n\n  if (jqContainer && jqContainer.length > 0) {\n    targetElement = jqContainer.get(0);\n  } else {\n    targetElement = jqTarget.get(0);\n  }\n\n  targetElements.push(targetElement);\n  /**\n   * Get the AngularJS element for the target 'container' element and try to find a {ViewModelObject} associated\n   * with it.\n   */\n\n  if (targetElements) {\n    _.forEach(targetElements, function (targetElement) {\n      //revisitme: fix the code as per react framework\n      // var ngTargetElement = ngModule.element( targetElement );\n      // var $scope = ngTargetElement.scope();\n      var targetVMO = null; // $scope &&\n      //     ( $scope.vmo || $scope.item ||\n      //         $scope.row && $scope.row.entity ||\n      //         $scope.data && $scope.data.vmo ) ||\n      //     targetElement.vmo || ngTargetElement.get( 0 ).vmo;\n\n      if (targetVMO) {\n        if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMO.modelType)) {\n          adapterSvc.getAdaptedObjects([targetVMO]).then(function (adaptedObjs) {\n            _setValidSourceTypesOnTarget(targetElement, adaptedObjs[0]);\n          });\n        } else {\n          _setValidSourceTypesOnTarget(targetElement, targetVMO);\n        }\n      }\n    });\n  }\n\n  return targetElements;\n};\n/**\n * Check if we have NOT already stored the collection of 'valid' 'source' types this 'target' will accept.\n * <P>\n * If so: Get that collection now.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - View model object of target.\n */\n\n\nvar _setValidSourceTypesOnTarget = function (targetElement, targetVMO) {\n  if (targetElement) {\n    var jqElement = $(targetElement);\n    var validSourceTypes = jqElement.data('validSourceTypes');\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n\n    if (!validSourceTypes && pasteHandler) {\n      validSourceTypes = pasteHandler.getObjectValidSourceTypes(targetVMO);\n      jqElement.data('validSourceTypes', validSourceTypes);\n      jqElement.data('dropuid', targetVMO.uid);\n\n      var containerId = _findContainerId(targetElement);\n\n      if (containerId) {\n        jqElement.data('containerId', containerId);\n      }\n    }\n  }\n};\n/**\n * @return {Object} The Object that represents cached drag data set when the drag operation began.\n */\n\n\nvar _getCachedDragData = function () {\n  var dragDataJSON = localStrg.get('awDragData');\n\n  if (dragDataJSON && dragDataJSON !== 'undefined') {\n    return JSON.parse(dragDataJSON);\n  }\n\n  return null;\n};\n/**\n * @param {String} dataTransferItem - The 'dataTransfer' Item to extract from.\n * @return {String} The type code of the given\n */\n\n\nfunction _getDataTransferType(dataTransferItem) {\n  var extensionIndex = dataTransferItem.lastIndexOf('/');\n\n  if (extensionIndex >= 0) {\n    return dataTransferItem.substring(extensionIndex + 1);\n  }\n\n  return '';\n}\n/**\n * @param {DragEvent} event - The DragEvent to extract the info from.\n *\n * @return {ObjectArray} Array of JS Files.\n */\n\n\nvar _getDataTransferSourceFiles = function (event) {\n  return event.dataTransfer.files;\n};\n/**\n * Return the 'source' element from the given drag event. The name of the element in the event can vary\n * depending on the browser the client is running with.\n *\n * @param {DragEvent} event - The event to extract the 'source' element from.\n *\n * @return {Element} The DOM element considered the 'source' of the given drag event.\n */\n\n\nvar _getEventSource = function (event) {\n  if (event.srcElement) {\n    return event.srcElement;\n  }\n\n  return event.target;\n};\n/**\n * Get the first child image element of the passed in element.\n *\n * @param {Element} sourceElement - element being dragged\n *\n * @return {Element} drag image element or returns passed in element if no image found.\n */\n\n\nvar _getFirstChildImage = function (sourceElement) {\n  var image = $(sourceElement).find('img:first')[0];\n  return image ? image : sourceElement;\n};\n/**\n * @param {String} uid - ID of the object to include in the URL.\n *\n * @return {String} The URL 'prefix' used to open an object in the 'show object' location of AW.\n */\n\n\nvar _getShowObjectURL = function (uid) {\n  // Have to decode as ui-router returns encoded URL (which is then decoded again by browser)\n  return window.decodeURIComponent(document.location.origin + document.location.pathname + AwStateService.instance.href('com_siemens_splm_clientfx_tcui_xrt_showObject', {\n    uid: uid\n  }));\n};\n/**\n * Returns the correct element to be dragged\n *\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} The correct drag element\n */\n\n\nvar _getDragElement = function (event, count) {\n  var element;\n\n  if (event && event.target && event.target.classList) {\n    if (event.target.classList.contains('aw-widgets-cellListItemContainer')) {\n      element = event.target.parentElement; // Cell element\n    } else if (event.target.classList.contains('ui-grid-cell')) {\n      var target = $(event.target);\n      var closest = target.closest(UI_GRID_ROW_CLASS);\n\n      if (closest && closest.length > 0 && count === 1) {\n        element = target.closest(UI_GRID_ROW_CLASS).get(0); // Table element\n      } else {\n        element = event.target;\n      }\n    }\n  }\n\n  return element;\n};\n/**\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} image element\n */\n\n\nvar _getMultiDragImage = function (event, count) {\n  var targetImage = _getDragElement(event, count);\n\n  var strWidth;\n  var strHeight;\n  var cloneImage = null;\n\n  if (targetImage) {\n    cloneImage = targetImage.cloneNode(true); // If cell, remove command icon/text\n\n    if (targetImage.classList && targetImage.classList.contains('aw-widgets-cellListItem')) {\n      // Keep the image from being duplicated at the top of the page\n      targetImage.style.position = 'relative';\n      strWidth = targetImage.offsetWidth - 50 + 'px';\n      strHeight = targetImage.offsetHeight - 10 + 'px'; // Remove commands from image\n\n      cloneImage.children[0].removeChild(cloneImage.children[0].children[1]); // Remove text from image\n\n      var cloneImageText = cloneImage.getElementsByClassName('aw-widgets-cellListCellTitleBlock')[0].parentNode;\n\n      if (cloneImageText) {\n        for (var i = 1; i < cloneImageText.children.length; i++) {\n          cloneImageText.removeChild(cloneImageText.children[i]);\n          i--;\n        }\n      }\n    } else {\n      // Else it is a row\n      strWidth = '150px';\n      strHeight = '100%';\n    }\n\n    cloneImage.id = 'dragCount';\n    cloneImage.style.maxWidth = strWidth;\n    cloneImage.style.minWidth = strWidth;\n    cloneImage.style.maxHeight = strHeight;\n    cloneImage.style.minHeight = strHeight;\n    cloneImage.style.position = 'absolute';\n    cloneImage.style.left = '0px';\n    cloneImage.style.top = '0px';\n    cloneImage.style.zIndex = '99';\n    cloneImage.classList.add('aw-theme-multidragimage');\n    cloneImage.classList.add('aw-widgets-multidragimage'); // the image that is dragged needs to be visible, so it is added to the existing node\n\n    targetImage.children[0].appendChild(cloneImage); // create a second offset image\n\n    var cloneImage2 = cloneImage.cloneNode(true);\n    cloneImage2.style.left = '5px';\n    cloneImage2.style.top = '5px'; // create a third offset image & append if necessary\n\n    var cloneImage3 = cloneImage.cloneNode(true);\n    cloneImage.appendChild(cloneImage2);\n\n    if (count > 2) {\n      cloneImage3.style.left = '10px';\n      cloneImage3.style.top = '10px';\n      cloneImage.appendChild(cloneImage3);\n    }\n  }\n\n  return cloneImage;\n};\n/**\n * Returns the 'validSourceTypes' property on the 'target' element being dropped onto.\n *\n * @param {Element} targetElement - The Element that will be dropped onto (i.e. the data 'target').\n *\n * @return {StringArray} Array of valid 'sourceTypes' (or an empty array if no 'sourceTypes' are valid).\n */\n\n\nvar _getValidSourceTypes = function (targetElement) {\n  var validSourceTypes = $(targetElement).data('validSourceTypes');\n\n  if (validSourceTypes) {\n    return Object.keys(validSourceTypes);\n  }\n\n  return [];\n};\n/**\n * Use the given ViewModelObject to return a string description of it.\n *\n * @param {ViewModelObject} vmo - The ViewModelObject to query.\n *\n * @return {String} Description of given ViewModelObject (or it's UID if no other name is possible).\n */\n\n\nvar _getViewModelObjectName = function (vmo) {\n  if (vmo.props.object_string) {\n    return vmo.props.object_string.displayValues[0];\n  } else if (vmo.props.items_tag) {\n    return vmo.props.items_tag.displayValues[0];\n  } else if (vmo.props.object_name) {\n    return vmo.props.object_name.displayValues[0];\n  } else if (vmo.props.object_desc && vmo.props.object_desc.length > 0) {\n    return vmo.props.object_desc.displayValues[0];\n  } else if (vmo.props.job_name) {\n    return vmo.props.job_name.displayValues[0];\n  } else if (vmo.props.awp0CellProperties) {\n    return vmo.props.awp0CellProperties.displayValues[0];\n  }\n\n  return vmo.uid;\n};\n/**\n * Check the user agent string to see if the browser is the NX embedded browser, the NX QT browser puts \"ugraf\"\n * in the user agent string.\n *\n * @return {boolean} true if NX browser false otherwise\n */\n\n\nvar _isNxWebBrowser = function () {\n  return navigator.userAgent.indexOf('ugraf') >= 0;\n};\n/**\n * @param {StringArray} validSourceTypes - Array of 'source' types this 'target' will accept.\n * @param {StringArray} sourceTypes - Arrays of 'source' types determined from the event's 'dataTransfer' being\n *            dragged.\n *\n * @return {Boolean} TRUE if ALL the given 'source' types are valid to drop onto the 'target' based on the given\n *         'validSourceTypes'.\n */\n\n\nvar _isValidObjectToDropInternal = function (validSourceTypes, sourceTypes) {\n  /**\n   * Check if we have anything to work with.\n   */\n  if (validSourceTypes && validSourceTypes.length > 0 && sourceTypes && sourceTypes.length > 0) {\n    /**\n     * Check if all the 'sources' matches at least one valid type for the 'target' Element.\n     * <P>\n     * If so: We will consider the drop of these 'sources' onto that 'target'.\n     */\n    for (var i = 0; i < sourceTypes.length; i++) {\n      var sourceType = sourceTypes[i];\n      var sourceTypeFound = null;\n      /**\n       * Consider each valid 'source' type the 'target' will accept.\n       */\n\n      for (var j = 0; j < validSourceTypes.length; j++) {\n        var validSourceType = validSourceTypes[j];\n        /**\n         * Check for an exact match\n         */\n\n        if (sourceType === validSourceType) {\n          sourceTypeFound = validSourceType;\n          break;\n        }\n        /**\n         * Get all the ancestor types for this 'source' type and see if one of them is valid for this\n         * 'target'.\n         */\n\n\n        var sourceModelType = cmm.getType(sourceType);\n\n        if (sourceModelType) {\n          var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n          if (sourceTypeHeirarchy) {\n            for (var k = 1; k < sourceTypeHeirarchy.length; k++) {\n              if (sourceTypeHeirarchy[k] === validSourceType) {\n                sourceTypeFound = validSourceType;\n                break;\n              }\n            }\n          }\n        } else {\n          logger.warn('Unable to locate \\'source\\' type (not loaded yet?): ' + sourceType);\n        }\n      }\n      /**\n       * Check if NONE of the valid 'source' types apply.\n       */\n\n\n      if (!sourceTypeFound) {\n        if (m_debug_LogRejectedSourceType) {\n          logger.warn('This \\'source\\' type is not valid for the \\'target\\': ' + sourceType);\n        }\n\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * @param {Object} pasteInput - An Object that maps a unique 'relationType' to the array of 'source'\n *            IModelObjects that should be pasted onto the 'target' with that 'relationType'.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\n\n\nvar _pasteFiles = function (pasteInput) {\n  let pasteFileHandler = DragAndDropService.instance.pasteFileHandler;\n  return pasteFileHandler.pasteFilesWithHandler(pasteInput).then(function (response) {\n    if (response && response.isOsFiles) {\n      const {\n        pasteFilesInput\n      } = response;\n      var deferred = AwPromiseService.instance.defer();\n\n      _.forEach(pasteFilesInput, function (input) {\n        const {\n          targetObject,\n          relationType,\n          sourceObjects\n        } = input;\n        pasteService.execute(targetObject, sourceObjects, relationType, {\n          isDragDropIntent: true\n        }).then(function (res) {\n          var eventData = {\n            relatedModified: [targetObject],\n            refreshLocationFlag: false,\n            createdObjects: sourceObjects\n          };\n          eventBus.publish('cdm.relatedModified', eventData);\n          deferred.resolve(res[0]);\n        }, function (err) {\n          deferred.reject(err);\n        });\n      });\n\n      return deferred.promise;\n    }\n\n    return response;\n  });\n};\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Array} sourceFiles - The 'source' JS File objects being dropped.\n * @param {FunctionArray} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _pasteSourceFiles = function (targetElement, targetVMO, sourceFiles, callbackAPIs) {\n  /**\n   * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n   * type.\n   */\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (!validSourceTypes || validSourceTypes.length === 0) {\n    validSourceTypes = [];\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n    var sourceTypesObject = pasteHandler.getObjectValidSourceTypes(targetVMO);\n\n    if (sourceTypesObject && typeof sourceTypesObject === 'object') {\n      var sourceTypes = Object.keys(sourceTypesObject);\n\n      if (sourceTypes) {\n        for (var counter = 0; counter < sourceTypes.length; counter++) {\n          var validSourceType = sourceTypes[counter];\n\n          if (cmm.containsType(validSourceType)) {\n            validSourceTypes.push(validSourceType);\n          }\n        }\n      }\n    }\n  }\n\n  var sourceType2RelationMap = _createSourceType2RelationsMap(validSourceTypes, targetElement);\n\n  var pasteRelation2SourceObjectsMap = {};\n\n  if (sourceFiles) {\n    for (var i = 0; i < sourceFiles.length; i++) {\n      var sourceObject = sourceFiles[i];\n      /**\n       * Get all the ancestor types for this 'source' type and see if one of them is valid.\n       * <P>\n       * Note: For dropping files we look to see if the 'target' accepts a 'Dataset' since that is what will\n       * ultimately be created.\n       */\n\n      var sourceModelType = cmm.getType(TYPE_NAME_DATASET);\n\n      if (sourceModelType) {\n        var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n        for (var j = 0; j < sourceTypeHeirarchy.length; j++) {\n          var currSourceType = sourceTypeHeirarchy[j];\n          var relationType = sourceType2RelationMap[currSourceType];\n\n          if (relationType) {\n            var sourceObjectsForType = pasteRelation2SourceObjectsMap[relationType];\n\n            if (!sourceObjectsForType) {\n              sourceObjectsForType = [];\n              pasteRelation2SourceObjectsMap[relationType] = sourceObjectsForType;\n            }\n\n            sourceObjectsForType.push(sourceObject);\n            break;\n          }\n        }\n      } else {\n        logger.warn('Unable to locate \\'source\\' type\\' (not loaded yet?): ' + TYPE_NAME_DATASET);\n      }\n    }\n  }\n\n  _scheduleSelectTarget(targetElement, targetVMO, callbackAPIs);\n  /**\n   * Paste 'sources' to 'target' for each unique 'relation' type.\n   */\n\n\n  var pasteInput = [];\n\n  _.forEach(pasteRelation2SourceObjectsMap, function (value, key) {\n    var curr = {};\n    curr.targetObject = targetVMO;\n    curr.relationType = key;\n    curr.sourceObjects = value;\n    pasteInput.push(curr);\n  });\n\n  var startTime = Date.now();\n\n  _pasteFiles(pasteInput).then(function (result) {\n    var stopTime = Date.now();\n    var pasteInputJS = pasteInput;\n    var sourceObjectsJS = result.sourceObjects;\n\n    if (_debug_logEventActivity > 1) {\n      var durationMs = stopTime - startTime;\n      var durationSec = durationMs / 1000.0;\n      var duration = durationSec;\n      logger.info('Time to process (' + sourceObjectsJS.length + ') files: ' + duration + 'sec');\n    }\n\n    var localTextBundle = {};\n    localTextBundle.dropCompletedDocument = localeService.getLoadedTextFromKey('dragAndDropMessages.dropCompletedDocument');\n    localTextBundle.dropCompleted = localeService.getLoadedTextFromKey('dragAndDropMessages.dropCompleted');\n    /**\n     * Based on passed parameters in return from create SOA post the correct success message to the user.\n     */\n\n    var droppedOnObject = pasteInputJS[0].targetObject.cellHeader1;\n\n    if (!droppedOnObject) {\n      droppedOnObject = pasteInputJS[0].targetObject.props.object_string.uiValues[0];\n    }\n\n    if (!droppedOnObject) {\n      droppedOnObject = '???';\n    }\n\n    if (result.docCreated) {\n      var dropCompletedDocumentMsg = localTextBundle.dropCompletedDocument;\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{0}', result.docName);\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{1}', droppedOnObject);\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{2}', sourceObjectsJS.length);\n      messagingSvc.showInfo(dropCompletedDocumentMsg);\n    } else {\n      var dropCompletedMsg = localTextBundle.dropCompleted;\n      dropCompletedMsg = dropCompletedMsg.replace('{0}', sourceObjectsJS.length);\n      dropCompletedMsg = dropCompletedMsg.replace('{1}', droppedOnObject);\n      messagingSvc.showInfo(dropCompletedMsg);\n    }\n  }, function (ex) {\n    logger.error('uploadFailures' + ex);\n  });\n};\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObjects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _pasteSourceObjects = function (targetElement, targetVMO, sourceObjects, callbackAPIs) {\n  /**\n   * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n   * type.\n   */\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (!validSourceTypes || validSourceTypes.length === 0) {\n    validSourceTypes = [];\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n    var sourceTypesObject = pasteHandler.getObjectValidSourceTypes(targetVMO);\n    var sourceTypes = Object.keys(sourceTypesObject);\n\n    if (sourceTypes) {\n      for (var counter = 0; counter < sourceTypes.length; counter++) {\n        var validSourceType = sourceTypes[counter];\n\n        if (cmm.containsType(validSourceType)) {\n          validSourceTypes.push(validSourceType);\n        }\n      }\n    }\n  }\n\n  var sourceType2RelationMap = _createSourceType2RelationsMap(validSourceTypes, targetElement);\n\n  var pasteRelation2SourceObjectsMap = {};\n\n  if (sourceObjects) {\n    for (var i = 0; i < sourceObjects.length; i++) {\n      var sourceObject = sourceObjects[i];\n      /**\n       * Get all the ancestor types for this 'source' type and see if one of them is valid.\n       */\n\n      var sourceType = sourceObject.type;\n      var sourceModelType = cmm.getType(sourceType);\n\n      if (sourceModelType) {\n        var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n        for (var j = 0; j < sourceTypeHeirarchy.length; j++) {\n          var sourceParentType = sourceTypeHeirarchy[j];\n          var relationType = sourceType2RelationMap[sourceParentType];\n\n          if (relationType) {\n            var sourceObjectsForType = pasteRelation2SourceObjectsMap[relationType];\n\n            if (!sourceObjectsForType) {\n              sourceObjectsForType = [];\n              pasteRelation2SourceObjectsMap[relationType] = sourceObjectsForType;\n            }\n\n            sourceObjectsForType.push(sourceObject);\n            break;\n          }\n        }\n      } else {\n        logger.warn('Unable to locate \\'source\\' type\\' (not loaded yet?): ' + sourceType);\n      }\n    }\n  }\n\n  _scheduleSelectTarget(targetElement, targetVMO, callbackAPIs);\n  /**\n   * Paste each unique 'relation' type.\n   */\n\n\n  var keys = Object.keys(pasteRelation2SourceObjectsMap);\n\n  if (keys && keys.length > 0) {\n    var pasteInput = [];\n\n    _.forEach(pasteRelation2SourceObjectsMap, function (value, key) {\n      var jso = {};\n      jso.targetObject = targetVMO;\n      jso.relationType = key;\n      jso.sourceObjects = value;\n      pasteInput.push(jso);\n    });\n\n    exports.publishDropEvent(pasteInput);\n  }\n};\n/**\n * Determine all the valid containers on the page . Check if the 'target'  is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event - DragEnter or DragOver event from global area\n * @return {Object} validHighlightableContainers - All valid applicable containers for highlighing\n */\n\n\nvar getApplicableContainersFromGlobalArea = function (event) {\n  var validHighlightableContainers = [];\n  var isValid = false;\n  var targetElements = document.body.querySelectorAll(DROP_CLASS);\n\n  if (targetElements) {\n    _.forEach(targetElements, function (targetElement) {\n      isValid = exports.isValidObjectToDrop(event, targetElement);\n\n      if (isValid) {\n        validHighlightableContainers.push(targetElement);\n      }\n    });\n  }\n\n  if (validHighlightableContainers.length === 0) {\n    if (_debug_logEventActivity >= 1) {\n      logger.info('No valid containers found on the entire page');\n    }\n  } else {\n    if (_debug_logEventActivity >= 1) {\n      logger.info(validHighlightableContainers.length + ' valid containers found , highlight in progress');\n    }\n  }\n\n  return validHighlightableContainers;\n};\n/**\n * Set the type of drag-and-drop operation currently selected or sets the operation to a new type. The value\n * must be 'none', 'copy', 'link' or 'move'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n * @param {String} value - The 'dropEffect' value to set .\n */\n\n\nvar _setDropEffect = function (event, value) {\n  event.dataTransfer.dropEffect = value;\n};\n/**\n * Once the last 'paste' is complete, select the 'target' object to show the results of the 'drop'. This should\n * cause the new 'sources' in that object.\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _scheduleSelectTarget = function (targetElement, targetVMO, callbackAPIs) {\n  callbackAPIs.selectResultFn(targetElement, targetVMO);\n}; //* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n\n\nvar exports = {};\n/**\n * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n *\n * @param {DragEvent} event - The DragEvent to set the DragData on.\n * @param {Object} dragDataMap - Map of name/value pairs to add.\n */\n\nexport let addDragDataToDragEvent = function (event, dragDataMap) {\n  if (_includeDataTransfer) {\n    try {\n      _.forEach(dragDataMap, function (value, name) {\n        event.dataTransfer.setData(name, value);\n      });\n    } catch (ex) {\n      // Current versions of Internet Explorer can only have types \"Text\" and \"URL\"\n      _.forEach(dragDataMap, function (value, name) {\n        // Only deal with the interop error from IE, to address DnD issue D-24972\n        if (name === 'aw_interop_type') {\n          event.dataTransfer.setData('text', value);\n        }\n      });\n    }\n  }\n};\n/**\n * @return {StringArray} An array of strings (placed into localStorage' at the start of a drag operation) that\n *         represent the UIDs of 'source' objects being dragged (or NULL if no types were found).\n */\n\nexport let getCachedSourceUids = function () {\n  var dragDataJSON = localStrg.get('awDragData');\n\n  if (dragDataJSON && dragDataJSON !== 'undefined') {\n    var dragData = JSON.parse(dragDataJSON);\n\n    if (dragData.uidList) {\n      return dragData.uidList;\n    }\n  }\n\n  return null;\n};\n/**\n * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n * <P>\n * Note: There will be multiple things being dragged over. We should look at the type (Files, ModelObject,\n * Text). Do we have three handlers, or a smarter handler?\n * <P>\n * For a smarter handler, if this is a folder, it can take objects. This should only cause the drop indicator to\n * be shown for objects.\n *\n * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n *            test.\n * @param {Object} targetElement - targetElement when object is over an invalid area . When drag is over a valid area,  targetElement\n *            is evaluated from event\n * @returns {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n */\n\nexport let isValidObjectToDrop = function (event, targetElement) {\n  // eslint-disable-line complexity\n\n  /**\n   * Find the DOM Element (potentially above the 'target' event's origin) where all the DnD information is\n   * stored.\n   */\n  if (_.isUndefined(targetElement)) {\n    targetElement = _findDropTargetElement(event)[0];\n  }\n\n  if (!targetElement) {\n    return false;\n  }\n\n  if (targetElement.classList && targetElement.classList.contains('aw-widgets-chooseordropfile') && exports.dataTransferContainsFiles(event)) {\n    return true;\n  }\n  /**\n   * Check if we do NOT want to allow files from the OS to be dropped and the 'dataTransfer' contains at least\n   * one file.\n   */\n\n\n  if (!m_supportingFileDrop && exports.dataTransferContainsFiles(event)) {\n    return false;\n  }\n  /**\n   * Check if the 'target' does not have information we need to process or that there are no 'source' objects\n   * being dragged.\n   * <P>\n   * If so: No need to consider it as a valid drop (onto itself).\n   */\n\n\n  var targetUID = $(targetElement).data('dropuid');\n\n  if (!targetUID || targetUID.length === 0) {\n    return false;\n  }\n  /**\n   * Make sure we have cached 'source' information to work with.\n   */\n  //            var sourceContainerId = null;\n\n\n  var sourceUids = null;\n  var sourceTypes = null;\n\n  var sourceDragData = _getCachedDragData();\n\n  if (sourceDragData) {\n    //                sourceContainerId = sourceDragData.containerId;\n    sourceUids = sourceDragData.uidList;\n    sourceTypes = sourceDragData.typeList;\n  }\n  /**\n   * Check if the 'target' is actually in the list of 'source' objects being dragged.\n   * <P>\n   * If so: No need to consider it as a valid drop (onto itself).\n   */\n\n\n  if (sourceUids && sourceUids.length > 0 && _.indexOf(sourceUids, targetUID) !== -1) {\n    return false;\n  }\n  /**\n   * Get the types that are valid to drop on this 'target' and check if the current drag operation 'source'\n   * contains at least one of that type.\n   */\n\n\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (validSourceTypes && validSourceTypes.length > 0) {\n    /**\n     * Check if the only 'sources' are JS Files on the event.\n     * <P>\n     * If so: Build a list of 'source' types based on the file extensions.\n     * <P>\n     * If not: Use the IModelObject 'sources'\n     */\n    if ((!sourceTypes || sourceTypes.length === 0) && exports.dataTransferContainsFiles(event)) {\n      /**\n       * Get any file type information carried in the 'dataTransfer' property.\n       * <P>\n       * Check if there are NONE\n       * <P>\n       * If so: Then just assume the source is just one or more 'DataSet'.\n       */\n      var fileTypes = exports.getDataTransferFileTypes(event);\n\n      if (fileTypes && fileTypes.length === 0) {\n        fileTypes.push(TYPE_NAME_DATASET);\n      }\n      /**\n       * Create key used to track status and remember the result of the validity test.\n       */\n\n\n      var sb = targetUID;\n\n      for (var i = 0; i < validSourceTypes.length; i++) {\n        sb += ',';\n        sb += validSourceTypes[i];\n      }\n\n      if (fileTypes) {\n        for (var j = 0; j < fileTypes.length; j++) {\n          sb += ',';\n          sb += fileTypes[j];\n        }\n      }\n\n      var mapKey = sb;\n      /**\n       * Check if we already know the result from the last time we asked this question for the same\n       * 'source' types and 'target'.\n       */\n\n      var result = m_mapKey2Result[mapKey];\n\n      if (result) {\n        return result.value;\n      }\n\n      var promise = m_mapKey2Promise[mapKey];\n\n      if (!promise) {\n        m_mapKey2Promise[mapKey] = exports.getDataTransferSourceTypes(targetUID, fileTypes).then(function (result2) {\n          delete m_mapKey2Promise[mapKey];\n          m_mapKey2Result[mapKey] = {\n            value: result2 && result2.length > 0 && _isValidObjectToDropInternal(validSourceTypes, result2)\n          };\n        }, function () {\n          delete m_mapKey2Promise[mapKey];\n          m_mapKey2Result[mapKey] = {\n            value: false\n          };\n        });\n      }\n\n      return false;\n    }\n    /**\n     * Check if any of the valid 'source' types are NOT currently loaded.\n     * <P>\n     * Note: We need them loaded so we can walk their type hierarchy while looking for a match.\n     */\n\n\n    var missingSourceTypes = null;\n    var availableSourceTypes = null;\n\n    for (var ii = 0; ii < validSourceTypes.length; ii++) {\n      var validSourceType = validSourceTypes[ii];\n\n      if (!cmm.containsType(validSourceType)) {\n        if (!missingSourceTypes) {\n          missingSourceTypes = [];\n        }\n\n        missingSourceTypes.push(validSourceType);\n      } else {\n        if (!availableSourceTypes) {\n          availableSourceTypes = [];\n        }\n\n        availableSourceTypes.push(validSourceType);\n      }\n    }\n    /**\n     * Check if any 'source' types are missing (not loaded yet).\n     * <P>\n     * If available 'source' types is null and missing 'source' types is not null, Then: Return 'false' for\n     * this drop but queue up a server request to get the type so that during further (future) dragging will\n     * see the type as loaded.\n     */\n\n\n    if (!availableSourceTypes && missingSourceTypes) {\n      var sb2 = targetUID;\n\n      for (var jj = 0; jj < missingSourceTypes.length; jj++) {\n        if (jj > 0) {\n          sb2 += ',';\n        }\n\n        sb2 += missingSourceTypes[jj];\n      }\n\n      var key = sb2;\n\n      if (!m_typeLookupInProgress[key]) {\n        m_typeLookupInProgress[key] = key;\n        soaSvc.ensureModelTypesLoaded(missingSourceTypes).then(function () {\n          /**\n           * Nothing to do now other than removing the lookup placeholder. We just wanted to make sure\n           * the type is loaded for the NEXT time we look for it.\n           */\n          delete m_typeLookupInProgress[key];\n        }, function (err) {\n          logger.error('Unable to get model types: ' + err);\n        });\n      }\n\n      return false;\n    }\n\n    return _isValidObjectToDropInternal(availableSourceTypes, sourceTypes);\n  }\n\n  return false;\n};\n/**\n * Get map of data format to drag data based on the given 'source' IModelObjects.\n *\n * @param {ViewModelObjectArray} sourceVMOs - The 'source' ViewModelObjects being dragged.\n * @param {String} containerId - The ID of the UI 'container' of the 'source' objects.\n *\n */\n\nexport let processAWInteropAndHosting = function (sourceVMOs, containerId) {\n  /**\n   * Create collections of data associated with the 'source' objects.\n   */\n  var uidList = [];\n  var typeSet = {};\n  var interopObjectRefs = [];\n  var firstObjectUrl = '';\n  var first = true;\n  modelsHaveTypes = false;\n  sourceVMOs.forEach(modelObject => {\n    if (modelObject.type) {\n      modelsHaveTypes = true;\n    }\n\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', modelObject.modelType)) {\n      var adaptedObjs = adapterSvc.getAdaptedObjectsSync([modelObject]);\n      modelObject = adaptedObjs[0];\n    }\n    /**\n     * Grab the first uid from the list for the url and the type\n     */\n\n\n    if (first) {\n      first = false;\n      firstObjectUrl = _getShowObjectURL(modelObject.uid);\n    }\n    /**\n     * Add the UID and type of this object into the collections\n     */\n\n\n    if (modelObject.uid) {\n      uidList.push(modelObject.uid);\n    }\n\n    typeSet[modelObject.type] = modelObject.type;\n\n    if (_createInteropObjectRefFn) {\n      /**\n       * Generate a hosting InteropObjectRef to be used by host applications (i.e. NX) for\n       * interpreting this 'source' object.\n       */\n      var objRefArrayList = _createInteropObjectRefFn(modelObject);\n\n      _.forEach(objRefArrayList, function (objRef) {\n        interopObjectRefs.push(objRef);\n      });\n    } else {\n      if (_debug_logEventActivity) {\n        logger.warn('Unable to determine InteropObjectRef information due to missing callback function');\n      }\n    }\n  });\n  var dragData = {\n    'text/uri-list': firstObjectUrl,\n    'text/plain': firstObjectUrl\n  };\n  /**\n   * Include application interop references (if necessary)\n   */\n\n  if (interopObjectRefs && interopObjectRefs.length > 0 && _includeDataTransfer) {\n    /**\n     * Create the JSON message for interop with host applications.\n     */\n    var dragDataInterop = {\n      DragTargets: interopObjectRefs\n    };\n    var jsonString = JSON.stringify(dragDataInterop);\n    /**\n     * Add data for each data format\n     * <P>\n     * Note: Need multiple data formats right now to handle compatibility with different browsers.\n     */\n\n    for (var j = 0; j < DATA_FORMATS.length; j++) {\n      dragData[DATA_FORMATS[j]] = jsonString;\n    }\n  }\n\n  dragData['text/uri-list'] = firstObjectUrl;\n  dragData['text/plain'] = firstObjectUrl;\n  /**\n   * Put the other formats onto the dataTransport\n   * <P>\n   * Note: We need the UIDs and types in the 'keys' (for checking while dragging since the values are not\n   * available at that time) and the 'values' to be able to access the data without it being changed to lower\n   * case by the browser itself.\n   */\n\n  var dragDataJSO = {};\n  dragDataJSO.containerId = containerId;\n  dragDataJSO.uidList = uidList;\n  dragDataJSO.firstObjectUrl = firstObjectUrl;\n  dragDataJSO.typeList = [];\n\n  _.forEach(typeSet, function (type) {\n    dragDataJSO.typeList.push(type);\n  });\n\n  localStrg.publish('awDragData', JSON.stringify(dragDataJSO));\n  addDragDataToDragEvent(event, dragData);\n};\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n */\n\nexport let processDragEnd = function (event) {\n  // eslint-disable-line no-unused-vars\n  _clearCachedData();\n};\n/**\n * Remove Highlight from the drop area with CSS class(s) and prevent the 'default' behavior (which we assume to\n * be 'do not allow drop' for objects or 'load file into page' for files).\n *\n * @param {DragEvent} event -\n */\n\nexport let processDragLeave = function (event) {\n  event.preventDefault();\n};\n/**\n * Remove Highlight when object drag is skipped or object dragged outside white/invalid area\n *\n * @param {DragEvent} event -\n */\n\nexport let processDragLeaveGlobal = function (event) {\n  if (_.isUndefined(mainReference)) {\n    mainReference = document.body;\n  }\n\n  var allHighlightedTargets = mainReference.querySelectorAll('.aw-theme-dropframe.aw-widgets-dropframe');\n\n  if (allHighlightedTargets) {\n    isGlobalHighlightPublished = false;\n\n    _.forEach(allHighlightedTargets, function (target) {\n      eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: true,\n        isHighlightFlag: false,\n        targetElement: target\n      });\n    });\n  }\n};\n/**\n * Determine if the DragEvent is over a 'target' that is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\n\nvar _processDragOverInternal = function (event, isCurrentTargetOverGlobalArea) {\n  exports.processDragLeaveGlobal(event); // clearing all other highlights triggered due to file drag in global area\n\n  if (isCurrentTargetOverGlobalArea) {\n    if (exports.dataTransferContainsURLs(event)) {\n      _setDropEffect(event, 'copy');\n    } else {\n      _setDropEffect(event, 'none');\n\n      event.stopPropagation();\n      event.preventDefault();\n      var allHighlightableTargets = getApplicableContainersFromGlobalArea(event);\n\n      if (allHighlightableTargets) {\n        _.forEach(allHighlightableTargets, function (targetElement) {\n          eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n            event: event,\n            isGlobalArea: true,\n            isHighlightFlag: true,\n            targetElement: targetElement\n          });\n        });\n      }\n    }\n  } else {\n    if (exports.isValidObjectToDrop(event)) {\n      eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: false,\n        isHighlightFlag: true,\n        targetElement: _findDropTargetElement(event)[0]\n      });\n\n      _setDropEffect(event, 'copy'); // when dragged object is on a valid container, the dragged effect should be \\'Copy\\'\n\n\n      event.stopPropagation();\n      event.preventDefault();\n    } else {\n      // this ensures if the drop target is an applicable one however not a valid one , all the highlights are gone and a no drop cursor is shown\n      _setDropEffect(event, 'none');\n\n      event.dataTransfer.effectAllowed = 'none';\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n};\n/**\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nexport let processDrop = function (event, callbackAPIs) {\n  event.stopPropagation();\n  event.preventDefault();\n\n  var targetElement = _findDropTargetElement(event)[0];\n\n  if (!targetElement) {\n    _clearCachedData();\n\n    return;\n  }\n\n  eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n    event: event,\n    isGlobalArea: false,\n    isHighlightFlag: false,\n    targetElement: targetElement\n  });\n  var sourceUids = exports.getCachedSourceUids();\n\n  if (sourceUids && sourceUids.length > 0) {\n    _dropModelObjects(targetElement, sourceUids, callbackAPIs);\n  } else {\n    var sourceFiles = _getDataTransferSourceFiles(event);\n\n    if (sourceFiles && sourceFiles.length > 0 && sourceFiles.item(0).size > 0) {\n      _dropFiles(targetElement, sourceFiles, callbackAPIs);\n    } else {\n      var dropFolderFailureDocument = localeService.getLoadedTextFromKey('dragAndDropMessages.dropFolderFailureDocument');\n      dropFolderFailureDocument = dropFolderFailureDocument.replace('{0}', sourceFiles.item(0).name);\n      messagingSvc.showError(dropFolderFailureDocument);\n\n      _clearCachedData();\n    }\n  }\n};\n/**\n * Set the current types of operations that are possible. Must be one of 'none', 'copy', 'copyLink', 'copyMove',\n * 'link', 'linkMove', 'move', 'all' or 'uninitialized'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n *\n * @param {String} value - The 'effectAllowed' allowed value to set.\n */\n\nexport let setEffectAllowed = function (event, value) {\n  try {\n    event.dataTransfer.effectAllowed = value;\n  } catch (ex) {// Do nothing\n  }\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various reasons of interaction with the\n *            container/frame:\n *\n * @param {Object} dataProvider - DataProvider for the panelElement\n * <P>\n * getElementViewModelObjectFn: Used to query the 'source' or 'target' ViewModelObject(s) under any given\n * DragEvent.\n * <P>\n * clearSelectionFn: Used to clear all currently selected 'source' objects just before the drop operation is\n * performed.\n * <P>\n * selectResultFn: Used to select the 'target' when the drop operation is complete.\n */\n\nexport let setupDragAndDrop = function (panelElement, callbackAPIs, dataProvider) {\n  // Init class here\n  DragAndDropService.instance;\n  var jqPanelElement = $(panelElement);\n  var showDropAreaAttr = jqPanelElement.attr('show-drop-area');\n  /**\n   * Set valid source types to the target drop element by retrieving from objectSetSource in data provider\n   */\n\n  var dropContainer = jqPanelElement.hasClass('aw-widgets-droppable') && !showDropAreaAttr ? jqPanelElement : jqPanelElement.find(DROP_CLASS);\n\n  if (dropContainer) {\n    var dropContScope = null; //ngModule.element( dropContainer ).scope();\n\n    if (dropContScope) {\n      var sourceType2RelationMap = {};\n      var declViewModel = declUtils.findViewModel(dropContScope, false, null); // ui-grid uses scope.dataprovider and plTable uses scope.dataProvider\n\n      var dropTableDataProvider = dataProvider || dropContScope.dataprovider || dropContScope.dataProvider;\n\n      if (dropTableDataProvider && dropTableDataProvider.validSourceTypes) {\n        var objectSetSources = dropTableDataProvider.validSourceTypes.split(',');\n\n        _.forEach(objectSetSources, function (source) {\n          var relationSources = source.split('.');\n          var sourceType = relationSources[1];\n\n          if (!sourceType2RelationMap[sourceType]) {\n            sourceType2RelationMap[sourceType] = [];\n            var relationObj = {\n              relation: relationSources[0]\n            };\n            sourceType2RelationMap[sourceType] = relationObj;\n          }\n        });\n      } else if (declViewModel && declViewModel.vmo) {\n        // fetch valid source types from paste service for vmo inside decl view model\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n\n        if (pasteHandler) {\n          sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes(declViewModel.vmo);\n        } else if (_cfgLoadPromise) {\n          _cfgLoadPromise.then(function () {\n            pasteHandler = DragAndDropService.instance.pasteHandler;\n            sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes(declViewModel.vmo);\n            dropContainer.data('validSourceTypes', sourceType2RelationMap);\n          });\n        }\n      }\n\n      dropContainer.data('validSourceTypes', sourceType2RelationMap);\n\n      if (declViewModel && declViewModel.vmo) {\n        // add the decl view model VMO as drop uid on the container\n        dropContainer.data('dropuid', declViewModel.vmo.uid);\n      }\n    }\n  }\n\n  callbackAPIs.dragStartFn = function (event) {\n    if (event) {\n      /**\n       * Determine some hosting related options at the start.\n       */\n      _includeDataTransfer = appCtxSvc.ctx.aw_host_type !== 'ADOBE';\n      _publishHostingEvents = appCtxSvc.ctx.aw_hosting_enabled; // D-52947: Prevent issues when text is highlighted as drag starts. Event.target may be text.\n\n      if (event.target.nodeName === '#text') {\n        jqPanelElement.data('dragging', false);\n        event.preventDefault();\n      } else {\n        if (_debug_logEventActivity >= 2) {\n          logger.info('dragstart: ' + '\\n' + JSON.stringify(event, null, 2));\n        }\n\n        if (_publishHostingEvents) {\n          eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n            type: 'dragstart',\n            event: event\n          });\n        }\n\n        var srcElement = _getEventSource(event);\n\n        var sourceVMOs = callbackAPIs.getElementViewModelObjectFn(srcElement, false);\n\n        if (sourceVMOs && sourceVMOs.length > 0) {\n          if (_debug_logEventActivity >= 1) {\n            logger.info('Source Item UID: ' + _getViewModelObjectName(sourceVMOs[0]));\n          }\n\n          $(panelElement).data('dragging', true);\n          var containerId = jqPanelElement.data('containerId');\n\n          if (!containerId) {\n            containerId = Date.now();\n            jqPanelElement.data('containerId', containerId);\n          }\n\n          exports.processAWInteropAndHosting(sourceVMOs, containerId.toString());\n          exports.updateDragImage(event, sourceVMOs.length);\n\n          if (!_includeDataTransfer) {\n            event.dataTransfer.clearData();\n          }\n        } else {\n          // No data so there is no reason to let the object be dragged.\n          jqPanelElement.data('dragging', false);\n          event.preventDefault();\n        }\n      }\n    }\n  };\n\n  callbackAPIs.dragEndFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragend: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      var element = _getDragElement(event);\n\n      if (element) {\n        var dragImage = element.getElementsByClassName('aw-widgets-multidragimage')[0];\n\n        if (dragImage) {\n          element.style.position = '';\n          dragImage.parentNode.removeChild(dragImage);\n        }\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragend',\n          event: event\n        });\n      }\n\n      jqPanelElement.data('dragging', false);\n    }\n  };\n\n  callbackAPIs.dragOverFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 3) {\n        logger.info('dragover: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragover',\n          event: event\n        });\n      }\n\n      event.stopPropagation();\n      exports.processDragOver(event, false);\n    }\n  };\n\n  callbackAPIs.dragEnterFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragenter: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragenter',\n          event: event\n        });\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      var target = _findDropTargetElement(event)[0];\n\n      if (!target) {\n        return;\n      }\n\n      if (exports.isValidObjectToDrop(event)) {\n        var targetVMOs = callbackAPIs.getElementViewModelObjectFn(target, true);\n\n        if (targetVMOs && targetVMOs.length > 0) {\n          if (_debug_logEventActivity >= 1) {\n            logger.info('Target Item Name: ' + _getViewModelObjectName(targetVMOs[0]));\n          }\n\n          var debounceProcessDragEnter = _.debounce(exports.processDragEnter, 100);\n\n          debounceProcessDragEnter(event, targetVMOs[0]);\n        }\n      }\n    }\n  };\n\n  callbackAPIs.dragLeaveFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragleave: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragleave',\n          event: event\n        });\n      }\n\n      var debounceProcessDragLeave = _.debounce(exports.processDragLeave, 100);\n\n      debounceProcessDragLeave(event);\n    }\n  };\n\n  callbackAPIs.dropFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('drop: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'drop',\n          event: event\n        });\n      }\n\n      jqPanelElement.data('dragging', false);\n      exports.processDrop(event, callbackAPIs);\n    }\n  };\n\n  panelElement.addEventListener('dragstart', callbackAPIs.dragStartFn);\n  panelElement.addEventListener('dragend', callbackAPIs.dragEndFn);\n  panelElement.addEventListener('dragover', callbackAPIs.dragOverFn);\n  panelElement.addEventListener('dragenter', callbackAPIs.dragEnterFn);\n  panelElement.addEventListener('dragleave', callbackAPIs.dragLeaveFn);\n  panelElement.addEventListener('drop', callbackAPIs.dropFn);\n};\nexport let dragLeaveEventOnGlobalWindow = function (event) {\n  processDragLeaveGlobal(event);\n\n  if (exports.dataTransferContainsFiles(event)) {\n    //\n    _clearCachedData();\n  }\n};\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {ViewModelObject} targetVMO - The ViewModelObject associated with the given event's 'target' DOM\n *            Element.\n */\n\nexport let processDragEnter = function (event, targetVMO) {\n  /**\n   * Look 'up' the DOM Element tree (starting at the given event's 'target') looking for the 1st 'droppable'\n   * element (i.e. the 'drop container').\n   */\n  var currElement = _findDropTargetElement(event)[0];\n\n  _setValidSourceTypesOnTarget(currElement, targetVMO);\n\n  event.preventDefault();\n};\nexport let dragEndEventOnGlobalWindow = function (event) {\n  processDragLeaveGlobal(event);\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\nexport let tearDownDragAndDrop = function (panelElement, callbackAPIs) {\n  if (callbackAPIs.dragStartFn) {\n    panelElement.removeEventListener('dragstart', callbackAPIs.dragStartFn);\n    panelElement.removeEventListener('dragend', callbackAPIs.dragEndFn);\n    panelElement.removeEventListener('dragover', callbackAPIs.dragOverFn);\n    panelElement.removeEventListener('dragenter', callbackAPIs.dragEnterFn);\n    panelElement.removeEventListener('dragleave', callbackAPIs.dragLeaveFn);\n    panelElement.removeEventListener('drop', callbackAPIs.dropFn);\n    callbackAPIs.dragStartFn = null;\n    callbackAPIs.dragEndFn = null;\n    callbackAPIs.dragOverFn = null;\n    callbackAPIs.dragEnterFn = null;\n    callbackAPIs.dragLeaveFn = null;\n    callbackAPIs.dropFn = null;\n  }\n};\n/**\n * Update the drag image for the DragEvent based on the number of objects being dragged.\n *\n * @param {DragEvent} event - The DragEvent to set the image on.\n *\n * @param {Number} count - The number of objects being dragged\n */\n\nexport let updateDragImage = function (event, count) {\n  /**\n   * Internet Explorer doesn't support setDragImage at all (and some 'hosts' do not want 'dataTransfer').\n   * <P>\n   * See: http://mereskin.github.io/dnd/\n   */\n  if (!browserUtils.isIE && _includeDataTransfer) {\n    /**\n     * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n     * should be resolved after moving the list view to a flex display.\n     */\n    var dragImage;\n\n    if (_isNxWebBrowser()) {\n      dragImage = _getFirstChildImage(event.target);\n    } else if (count > 1) {\n      dragImage = _getMultiDragImage(event, count);\n    } else {\n      dragImage = _getDragElement(event, 1);\n    }\n\n    if (dragImage) {\n      event.dataTransfer.setDragImage(dragImage, 0, 0);\n    }\n  }\n};\n/**\n * Return the target model object for given UID\n *\n * @param {String} uid - UID of the modelObject on which source objects are dragged\n * @return {Object} Modelobject on which source objects are dragged\n */\n\nexport let getTargetObjectByUid = function (uid) {\n  return cdm.getObject(uid);\n};\n/**\n * Return an array of viewModelObjects that contains all currently selected viewModelObjects if the given UID is\n * contained in the set of selected viewModelObjects.\n *\n * @param {Object} dataProvider - data provider\n * @param {String} dragUID - UID of the modelObject being dragged.\n * @return {Array} array of viewModelObjects that are being dragged.\n */\n\nexport let getSourceObjects = function (dataProvider, dragUID) {\n  var sourceObjs = [];\n\n  if (!dataProvider) {\n    return sourceObjs;\n  }\n\n  var selectObjects = dataProvider.getSelectedObjects();\n  /**\n   * Check if the given UID is in the current set of selected objects.\n   */\n\n  var found = false;\n\n  if (selectObjects && selectObjects.length > 0) {\n    // eslint-disable-next-line consistent-return\n    _.forEach(selectObjects, function (selObj) {\n      if (selObj.uid === dragUID) {\n        found = true;\n        return false;\n      }\n    });\n  }\n\n  if (found) {\n    sourceObjs = _.clone(selectObjects);\n  }\n\n  return sourceObjs;\n};\n/**\n * Look for support of the 'files' in the 'dataTranfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'files' property is found in the 'dataTransfer' property of the event.\n */\n\nexport let dataTransferContainsFiles = function (event) {\n  if (event.dataTransfer) {\n    var types = event.dataTransfer.types;\n\n    if (types) {\n      for (var i = 0; i < types.length; ++i) {\n        if (types[i] === 'Files') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Look for support of the 'urls' in the 'dataTransfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'text/html' property is found in the 'dataTransfer' property of the event.\n */\n\nexport let dataTransferContainsURLs = function (event) {\n  if (event.dataTransfer) {\n    var types = event.dataTransfer.types;\n\n    if (types) {\n      for (var i = 0; i < types.length; ++i) {\n        if (types[i] === 'text/html') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * @param {DragEvent} event - The event to extract the files types from the 'dataTransfer' property.\n *\n * @return {StringArray} The set of unique file types.\n */\n\nexport let getDataTransferFileTypes = function (event) {\n  var dtTypes = [];\n\n  if (event.dataTransfer.items) {\n    var itemObjs = event.dataTransfer.items;\n\n    if (itemObjs) {\n      for (var i = 0; i < itemObjs.length; i++) {\n        var fileExt = _getDataTransferType(itemObjs[i].type);\n\n        if (fileExt && dtTypes.indexOf(fileExt) === -1) {\n          dtTypes.push(fileExt);\n        }\n      }\n    }\n  }\n\n  return dtTypes;\n};\n/**\n * Returns underlying Object for the given 'source' type.\n *\n * @param {String} targetUID - The UID of the IModelObject that will be the dropped onto (i.e. the data\n *            'target').\n *\n * @param {StringArray} fileTypes - The array with the set of unique file types.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\n\nexport let getDataTransferSourceTypes = function (targetUID, fileTypes) {\n  var targetObject = cdm.getObject(targetUID);\n  var request = {\n    parent: targetObject,\n    fileExtensions: fileTypes\n  };\n  return soaSvc.postUnchecked('Internal-AWS2-2015-10-DataManagement', 'getDatasetTypesWithDefaultRelation', request).then(function (response) {\n    if (response.partialErrors || response.PartialErrors || response.ServiceData && response.ServiceData.partialErrors) {\n      return [];\n    }\n\n    var dsTypes = [];\n    var output = response.output;\n\n    if (output) {\n      for (var i = 0; i < output.length; i++) {\n        var dsInfos = output[i].datasetTypesWithDefaultRelInfo;\n\n        if (dsInfos) {\n          const j = 0;\n          var dsInfo = dsInfos[j];\n          var dsUid = dsInfo.datasetType.uid;\n          var dsType = cdm.getObject(dsUid);\n          var type = dsType.props.object_string.dbValues[0];\n          dsTypes.push(type);\n        }\n      }\n    }\n\n    return soaSvc.ensureModelTypesLoaded(dsTypes).then(function () {\n      return dsTypes;\n    });\n  }, function (e) {\n    logger.trace(e);\n    return [];\n  });\n};\n/**\n * Set a callback function to use to encode 'source' objects in support of hosting.\n *\n * @param {Function} callBackFn - Function used to create InteropObjectRefs that are added to the information\n *            carried for 'source' objects in dragEvents.\n */\n\nexport let setCreateInteropObjectRef = function (callBackFn) {\n  _createInteropObjectRefFn = callBackFn;\n};\n/**\n * Publish a 'drop' topic on the 'paste' channel of the Native JS 'eventBus' with the given data.\n *\n * @param {ObjectArray} pasteInput - An array of objects that maps a unique 'relationType' to the array of\n *            'sourceObjects' {@link IModelObject} s that should be pasted onto the 'targetObject' with that\n *            'relationType'.\n */\n\nexport let publishDropEvent = function (pasteInput) {\n  eventBus.publishOnChannel({\n    channel: 'paste',\n    topic: 'drop',\n    data: {\n      pasteInput: pasteInput\n    }\n  });\n};\n\nconst _globalDragEnterAndOver = event => {\n  exports.processDragOver(event, true);\n};\n\nexport let registerEvents = function () {\n  // LCS-148724 , Adding listeners to global area i.e the area outside panelElement of setupDragAndDrop() function\n  document.body.addEventListener('dragenter', function (event) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (!_isDragWithinApplicableValidContainer(event) || _isDragOverChooseOrDropFileContainer(event)) {\n      // below check is to avoid global dragenter events in turn flickering highlight when within a table or list\n      if (!_isDragWithinTableContainer(event) && !_isDragWithinCellListContainer(event)) {\n        if (_debug_logEventActivity >= 1) {\n          logger.info('GLOBAL DRAG ENTER EVENT, DRAG NOT WITHIN A TABLE, NOT ALLOWED cursor should be shown => tag name :' + event.target.tagName);\n        }\n\n        _setDropEffect(event, 'none'); // to avoid 'Copy' cursor feedback when file just enters the page\n\n\n        _globalDragEnterAndOver(event);\n      } else {\n        if (_debug_logEventActivity >= 1) {\n          logger.info('GLOBAL DRAG ENTER EVENT, DRAG WITHIN A TABLE, COPY cursor should be shown => tag name :' + event.target.tagName);\n        }\n\n        _setDropEffect(event, 'copy');\n      }\n    }\n  });\n  document.body.addEventListener('dragover', function (event) {\n    if (!_isDragWithinApplicableValidContainer(event) || _isDragOverChooseOrDropFileContainer(event)) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('GLOBAL DRAG OVER EVENT ');\n      }\n\n      _globalDragEnterAndOver(event);\n    }\n  });\n  document.body.addEventListener('dragleave', function (event) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (_debug_logEventActivity >= 1) {\n      logger.info('GLOBAL DRAG LEAVE EVENT, Object either dragged outside the global window OR over an applicable valid container on the page OR over an applicable invalid container on the page');\n    }\n\n    if (_isDragCancelled(event)) {\n      isGlobalHighlightPublished = false;\n      exports.dragLeaveEventOnGlobalWindow(event);\n    }\n  });\n  document.body.addEventListener('dragend', function (event) {\n    if (_debug_logEventActivity >= 1) {\n      logger.info('GLOBAL DRAG END EVENT ');\n    }\n\n    isGlobalHighlightPublished = false;\n    exports.dragEndEventOnGlobalWindow(event);\n  });\n};\nexport const disableDragAndDrop = panelElement => {\n  const stopEventBubbling = event => {\n    event.stopPropagation();\n  };\n\n  const setDropEffectNone = event => {\n    stopEventBubbling(event);\n    event.dataTransfer.dropEffect = 'none';\n  };\n\n  panelElement.addEventListener('dragover', setDropEffectNone);\n  panelElement.addEventListener('dragenter', stopEventBubbling);\n  panelElement.addEventListener('dragleave', stopEventBubbling);\n  panelElement.addEventListener('drop', stopEventBubbling);\n};\nexports = {\n  disableDragAndDrop,\n  addDragDataToDragEvent,\n  getCachedSourceUids,\n  isValidObjectToDrop,\n  processAWInteropAndHosting,\n  processDragEnd,\n  processDragLeave,\n  processDragLeaveGlobal,\n  processDrop,\n  setEffectAllowed,\n  setupDragAndDrop,\n  dragLeaveEventOnGlobalWindow,\n  dragEndEventOnGlobalWindow,\n  tearDownDragAndDrop,\n  updateDragImage,\n  getTargetObjectByUid,\n  getSourceObjects,\n  dataTransferContainsFiles,\n  dataTransferContainsURLs,\n  getDataTransferFileTypes,\n  getDataTransferSourceTypes,\n  setCreateInteropObjectRef,\n  publishDropEvent,\n  registerEvents,\n  processDragOver,\n  processDragEnter\n};\nexport default exports;\n/*\n * Register the global drag and drop events only for AW.\n */\n\nif (appCtxSvc.ctx && appCtxSvc.ctx.tcSessionData) {//registerEvents();\n}","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/dragAndDropService.js"],"names":["reset","AwBaseService","constructor","_cfgLoadPromise","pasteProvider","dep","pasteHandler","pasteFileHandler","DATA_FORMATS","TYPE_NAME_DATASET","_includeDataTransfer","_publishHostingEvents","_debug_logEventActivity","HOSTING_DRAG_DROP_EVENT","UI_GRID_ROW_CLASS","DROP_CLASS","DRAG_DROP_HIGHLIGHT_EVENT","urlAttributes","browserUtils","m_debug_LogRejectedSourceType","m_mapKey2Promise","m_mapKey2Result","m_supportingFileDrop","m_typeLookupInProgress","isGlobalHighlightPublished","_clearCachedData","localStrg","_createSourceType2RelationsMap","sourceType2RelationsMap","validSourceObjects","$","i","validSourceTypes","sourceType","validSourceObj","relations","_deselectAll","callbackAPIs","getAdaptedObjects","vmos","dragAndDropUtils","_deselectAllAndPasteSourceFiles","sourceFiles","_pasteSourceFiles","_deselectAllAndPasteSourceObjects","sourceObjects","_pasteSourceObjects","_dropFiles","targetVMOs","targetUID","exports","cmm","adapterSvc","adaptedObjs","_dropModelObjects","_dropModelObjectsInternal","missingSourceUIDs","sourceUIDs","sourceObject","cdm","dms","j","_findContainerId","currElement","containerId","_isDragCancelled","_isDragCancelFlag","event","_isDragWithinCellListContainer","isCellListContainerFlag","cellListContainer","htmlUtils","_","_isDragWithinTableContainer","isTableFlag","tableContainer","_isDragWithinApplicableValidContainer","bool","jqTarget","jqContainer","_isDragOverChooseOrDropFileContainer","targetElement","cfContainer","processDragOver","chooseFileContainer","logger","_setDropEffect","eventBus","isGlobalArea","isHighlightFlag","_processDragOverInternal","_findDropTargetElement","targetElements","targetVMO","_setValidSourceTypesOnTarget","jqElement","DragAndDropService","_getCachedDragData","dragDataJSON","JSON","extensionIndex","dataTransferItem","_getDataTransferSourceFiles","_getEventSource","_getFirstChildImage","image","_getShowObjectURL","document","uid","_getDragElement","element","target","closest","count","_getMultiDragImage","targetImage","cloneImage","strWidth","strHeight","cloneImageText","cloneImage2","cloneImage3","_getValidSourceTypes","Object","_getViewModelObjectName","vmo","_isNxWebBrowser","navigator","_isValidObjectToDropInternal","sourceTypes","sourceTypeFound","validSourceType","sourceModelType","sourceTypeHeirarchy","k","_pasteFiles","response","pasteFilesInput","deferred","AwPromiseService","pasteService","isDragDropIntent","eventData","relatedModified","refreshLocationFlag","createdObjects","res","sourceTypesObject","counter","sourceType2RelationMap","pasteRelation2SourceObjectsMap","currSourceType","relationType","sourceObjectsForType","_scheduleSelectTarget","pasteInput","curr","startTime","Date","stopTime","pasteInputJS","sourceObjectsJS","result","durationMs","durationSec","duration","localTextBundle","localeService","droppedOnObject","dropCompletedDocumentMsg","messagingSvc","dropCompletedMsg","sourceParentType","keys","jso","getApplicableContainersFromGlobalArea","validHighlightableContainers","isValid","addDragDataToDragEvent","name","getCachedSourceUids","dragData","isValidObjectToDrop","sourceUids","sourceDragData","fileTypes","sb","mapKey","promise","value","result2","missingSourceTypes","availableSourceTypes","ii","sb2","jj","key","soaSvc","processAWInteropAndHosting","uidList","typeSet","interopObjectRefs","firstObjectUrl","first","modelsHaveTypes","sourceVMOs","modelObject","objRefArrayList","_createInteropObjectRefFn","dragDataInterop","DragTargets","jsonString","dragDataJSO","processDragEnd","processDragLeave","processDragLeaveGlobal","mainReference","allHighlightedTargets","allHighlightableTargets","processDrop","dropFolderFailureDocument","setEffectAllowed","setupDragAndDrop","jqPanelElement","showDropAreaAttr","dropContainer","dropContScope","declViewModel","declUtils","dropTableDataProvider","dataProvider","objectSetSources","relationSources","source","relationObj","relation","appCtxSvc","type","srcElement","dragImage","debounceProcessDragEnter","debounceProcessDragLeave","panelElement","dragLeaveEventOnGlobalWindow","processDragEnter","dragEndEventOnGlobalWindow","tearDownDragAndDrop","updateDragImage","getTargetObjectByUid","getSourceObjects","sourceObjs","selectObjects","found","selObj","dataTransferContainsFiles","types","dataTransferContainsURLs","getDataTransferFileTypes","dtTypes","itemObjs","fileExt","_getDataTransferType","getDataTransferSourceTypes","targetObject","request","parent","fileExtensions","dsTypes","output","dsInfos","dsInfo","dsUid","dsType","setCreateInteropObjectRef","publishDropEvent","channel","topic","data","_globalDragEnterAndOver","registerEvents","disableDragAndDrop","stopEventBubbling","setDropEffectNone"],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service manages the 'source' object information placed into 'localStorage' during drag-n-drop operations.\n *\n * @module js/dragAndDropService\n */\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport dms from 'soa/dataManagementService';\nimport soaSvc from 'soa/kernel/soaService';\nimport cfgSvc from 'js/configurationService';\nimport messagingSvc from 'js/messagingService';\nimport localeService from 'js/localeService';\nimport appCtxSvc from 'js/appCtxService';\nimport adapterSvc from 'js/adapterService';\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport declUtils from 'js/declUtils';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport dragAndDropUtils from 'js/dragAndDropUtils';\n\n// Service\nimport AwBaseService from 'js/awBaseService';\nimport AwStateService from 'js/awStateService';\nimport pasteService from 'js/pasteService';\nimport AwPromiseService from 'js/awPromiseService';\nimport htmlUtils from 'js/htmlUtils';\n\n// Class for load handler\n// This file is too complex to convert it to a complete class\nclass DragAndDropService extends AwBaseService {\n    static reset() {\n        AwBaseService.reset();\n        delete this._defaultPasteHandler;\n        delete this._pasteFileHandler;\n    }\n\n    constructor() {\n        super();\n\n        // The following check is to support Karma testing which invokes this multiple times.\n        if( !_cfgLoadPromise && !( this.constructor._defaultPasteHandler || this.constructor._pasteFileHandler ) ) {\n            _cfgLoadPromise = cfgSvc.getCfg( 'paste' ).then( ( pasteProvider ) => {\n                if( pasteProvider.defaultPasteHandler ) {\n                    return declUtils.loadDependentModule( pasteProvider.defaultPasteHandler.dep ).then( ( dep ) => {\n                        this.constructor._defaultPasteHandler = dep;\n                        return pasteProvider;\n                    } );\n                }\n                return pasteProvider;\n            } ).then( ( pasteProvider ) => {\n                if( pasteProvider.defaultPasteFileHandler ) {\n                    return declUtils.loadDependentModule( pasteProvider.defaultPasteFileHandler.dep ).then( ( dep ) => {\n                        this.constructor._pasteFileHandler = dep;\n                        return pasteProvider;\n                    } );\n                }\n            } ).then( function() {\n                _cfgLoadPromise = null;\n            } );\n        }\n    }\n\n    get pasteHandler() {\n        return this.constructor._defaultPasteHandler;\n    }\n\n    get pasteFileHandler() {\n        return this.constructor._pasteFileHandler;\n    }\n}\n\n/**\n * Data formats to put the data in. It would be better to only use aw_interop_type here, but that isn't working\n * with Chrome.\n */\nvar DATA_FORMATS = [ 'text/html', 'aw_interop_type' ];\n\n/** Dataset type */\nvar TYPE_NAME_DATASET = 'Dataset';\n\n/** This is set to true if any of the dragged objects have a type set.\n */\nvar modelsHaveTypes;\n\n/**\n * {DOMElement} root container for the page.\n */\nvar mainReference;\n/**\n * {Boolean} TRUE if the drag event should have it's 'dataTransfer' object set/maintained.\n */\nvar _includeDataTransfer = true;\n\n/**\n * {Boolean} TRUE if various drag event activities should publish 'hosting' related events.\n */\nvar _publishHostingEvents = false;\n\n/**\n * {Function} A callback used to create the 'InteropObjectRef' encodings necessary to communicate more complex\n * selection information via drag event data format properties.\n * <P>\n * Note: Until the hosting 'InteropObjectRefFactory' is converted from GWT to native JS we must rely on it for\n * conversion of IModelObjects to the special encoding used for communications of 'source' objects to the host.\n */\nvar _createInteropObjectRefFn;\n\n/**\n * Temporary promise reference for loading of the configuration data. This is used to allow code to wait until\n * ready before doing work.\n *\n * @private\n */\nvar _cfgLoadPromise;\n\n/**\n * <pre>\n * Greater Than 0 If some basic event activity should be logged.\n * Greater Than 1 If some more fine-grained event activity should be logged.\n * </pre>\n */\nvar _debug_logEventActivity = 0;\n\nconst HOSTING_DRAG_DROP_EVENT = 'hosting.DragDropEvent';\nconst UI_GRID_ROW_CLASS = '.ui-grid-row';\nconst DROP_CLASS = '.aw-widgets-droppable';\nconst DRAG_DROP_HIGHLIGHT_EVENT = 'dragDropEvent.highlight';\n\nvar urlAttributes = browserUtils.getUrlAttributes();\n\nif( urlAttributes.logDnDEventActivity !== undefined ) {\n    _debug_logEventActivity = 1;\n\n    if( urlAttributes.logDnDEventActivity > 0 ) {\n        _debug_logEventActivity = urlAttributes.logDnDEventActivity;\n    }\n}\n\n/**\n * TRUE if the type that was not valid for a target is logged. This is very handy when debugging issues.\n */\nvar m_debug_LogRejectedSourceType = false;\n\n/**\n * Map used to hold an unresolved {Promise} for a given 'evaluation key' *while* the async server call is being\n * made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\nvar m_mapKey2Promise = {};\n\n/**\n * Map used to hold the *result* of a previous async server call for a given 'evaluation key'.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\nvar m_mapKey2Result = {};\n\n/**\n * TRUE if dragging files from the OS file should be allowed.\n */\nvar m_supportingFileDrop = true;\n\n/**\n * Set used to hold an 'unresolved source type lookup key' *while( the async server call is being made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'unresolved source type lookup key'.\n * <P>\n * Note: The 'unresolved source type lookup key' is formed by a union of MissingSourceTypes.\n */\nvar m_typeLookupInProgress = {};\n\nlet isGlobalHighlightPublished = false;\n\n//* **********************************************************************\n\n/**\n * Clear out any 'dragData' that may have been created by the last Drag-n-Drop operation.\n */\nvar _clearCachedData = function() {\n    localStrg.publish( 'awDragData' );\n};\n\n/**\n * @param {StringArray} validSourceTypes The 'sourceTypes' {@link JavaScriptObject} property from the\n *            pasteConfig for the given 'target' object type or its ancestor types up the hierarchy (or NULL if\n *            no match was found).\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n *\n * @returns {Object} A {@link Map} that relates 'source' types to the 1 or more possible relationship types that\n *         are valid for the 'owner' (i.e. 'target') {@link IModelObject}.\n */\nvar _createSourceType2RelationsMap = function( validSourceTypes, targetElement ) {\n    var sourceType2RelationsMap = {};\n\n    var validSourceObjects = $( targetElement ).data( 'validSourceTypes' );\n\n    if( validSourceObjects ) {\n        for( var i = 0; i < validSourceTypes.length; i++ ) {\n            var sourceType = validSourceTypes[ i ];\n\n            var validSourceObj = validSourceObjects[ sourceType ];\n\n            var relations = [];\n\n            if( validSourceObj.relation ) {\n                relations.push( validSourceObj.relation );\n            } else {\n                relations.push( '' );\n            }\n\n            sourceType2RelationsMap[ sourceType ] = relations;\n        }\n    }\n\n    return sourceType2RelationsMap;\n};\n\n/**\n * Remove from selection any non-'target' object currently selected (like the ones we may have just pasted) so\n * that the 'target' can be cleanly selected later.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject the 'source' ViewModelObject(s) are being\n *            dropped onto.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAll = function( targetVMO, callbackAPIs ) {\n    callbackAPIs.clearSelectionFn( targetVMO );\n};\n\n/**\n * Get the adapted objects corresponding to the VMOs if any.\n *\n * @param {ObjectArray} vmos - Array of viewmodel objects.\n *\n * @return {Array} Returns array of adapadted objects if any or else returns the vmos\n */\nconst getAdaptedObjects = ( vmos ) => {\n    return dragAndDropUtils.getObjects( vmos );\n};\n\n/**\n * Synchronously create Datasets, upload the given JS Files and attach the files to the Datasets using the\n * correct relation types and the tickets used to upload the files.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {ObjectArray} sourceFiles - The 'source' JS File objects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAllAndPasteSourceFiles = function( targetElement, targetVMO, sourceFiles, callbackAPIs ) {\n    if( sourceFiles && sourceFiles.length > 0 ) {\n        _deselectAll( targetVMO, callbackAPIs );\n\n        _pasteSourceFiles( targetElement, targetVMO, sourceFiles, callbackAPIs );\n    }\n};\n\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObject(s) being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAllAndPasteSourceObjects = function( targetElement, targetVMO, sourceObjects, callbackAPIs ) {\n    if( sourceObjects && sourceObjects.length > 0 ) {\n        _deselectAll( targetVMO, callbackAPIs );\n\n        _pasteSourceObjects( targetElement, targetVMO, sourceObjects, callbackAPIs );\n    }\n};\n\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element.\n *\n * @param {ObjectArray} sourceFiles - The array 'source' JS File objects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _dropFiles = function( targetElement, sourceFiles, callbackAPIs ) {\n    var targetVMOs = callbackAPIs.getElementViewModelObjectFn( targetElement );\n    if( !targetVMOs || targetVMOs.length === 0 ) {\n        var targetUID = $( targetElement ).data( 'dropuid' );\n        if( targetUID ) {\n            targetVMOs = [];\n            targetVMOs.push( exports.getTargetObjectByUid( targetUID ) );\n        }\n    }\n\n    if( targetVMOs && targetVMOs.length !== 0 ) {\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMOs[ 0 ].modelType ) ) {\n            adapterSvc.getAdaptedObjects( targetVMOs ).then( function( adaptedObjs ) {\n                _deselectAllAndPasteSourceFiles( targetElement, adaptedObjs[ 0 ], sourceFiles, callbackAPIs );\n            } );\n        } else {\n            _deselectAllAndPasteSourceFiles( targetElement, targetVMOs[ 0 ], sourceFiles, callbackAPIs );\n        }\n    }\n    _clearCachedData();\n};\n\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _dropModelObjects = function( targetElement, sourceUIDs, callbackAPIs ) {\n    var targetVMOs = callbackAPIs.getElementViewModelObjectFn( targetElement );\n    if( !targetVMOs || targetVMOs.length === 0 ) {\n        var targetUID = $( targetElement ).data( 'dropuid' );\n        if( targetUID ) {\n            targetVMOs = [];\n            targetVMOs.push( exports.getTargetObjectByUid( targetUID ) );\n        }\n    }\n    if( targetVMOs && targetVMOs.length !== 0 ) {\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMOs[ 0 ].modelType ) ) {\n            adapterSvc.getAdaptedObjects( targetVMOs ).then( function( adaptedObjs ) {\n                _dropModelObjectsInternal( targetElement, sourceUIDs, callbackAPIs, adaptedObjs );\n            } );\n        } else {\n            _dropModelObjectsInternal( targetElement, sourceUIDs, callbackAPIs, targetVMOs );\n        }\n    }\n};\n\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n *\n * @param {Object} targetVMOs - View model object of target.\n */\nvar _dropModelObjectsInternal = function( targetElement, sourceUIDs, callbackAPIs, targetVMOs ) {\n    var sourceObjects = [];\n    var missingSourceUIDs = [];\n    /**\n     * Attempt to locate the 'source' objects in this browser's CDM cache.\n     * <P>\n     * Note: When 'source' objects are being dragged from another browser they may not have been loaded into the\n     * 'target' browser.\n     */\n    if( sourceUIDs ) {\n        for( var i = 0; i < sourceUIDs.length; i++ ) {\n            var sourceObject = cdm.getObject( sourceUIDs[ i ] );\n            if( sourceObject ) {\n                sourceObjects.push( sourceObject );\n            } else {\n                missingSourceUIDs.push( sourceUIDs[ i ] );\n            }\n        }\n    }\n    /**\n     * Check if NO 'source' objects are missing\n     * <P>\n     * If so: Process the past now\n     */\n    if( !missingSourceUIDs || missingSourceUIDs.length === 0 ) {\n        _deselectAllAndPasteSourceObjects( targetElement, targetVMOs[ 0 ], sourceObjects, callbackAPIs );\n        _clearCachedData();\n    } else {\n        /**\n         * Attempt to locate the missing 'source' objects on the server.\n         */\n        dms.loadObjects( missingSourceUIDs, function() {\n            /**\n             * Attempt to locate the (formerly) missing 'targets' and add them to the list of 'source' objects\n             * to drop on the 'target'\n             */\n            for( var j = 0; j < missingSourceUIDs.length; j++ ) {\n                var sourceObject = cdm.getObject( missingSourceUIDs[ j ] );\n                if( sourceObject ) {\n                    sourceObjects.push( sourceObject );\n                } else {\n                    // var sourceTypes = _getCachedSourceTypes();\n                    // logger.warn( 'Unable to locate \\'source\\' IModelObject\\' (not loaded yet): ' +\n                    //     missingSourceUIDs[ j ] + ' of type: ' + sourceTypes[ 0 ] );\n                }\n            }\n            if( sourceObjects && sourceObjects.length > 0 ) {\n                _deselectAllAndPasteSourceObjects( targetElement, targetVMOs[ 0 ], sourceObjects, callbackAPIs );\n            }\n            _clearCachedData();\n        } );\n    }\n};\n\n/**\n * Starting with the given DOM Element and walking up the DOM, look for the 1st DOM Element with the\n * 'containerId' property set.\n *\n * @param {Element} testElement - The element to start the search at.\n *\n * @return {Number} The ID of the 'parent' element that has the 'containerId' set on it (or NULL if no Element\n *         was found).\n */\nvar _findContainerId = function( testElement ) {\n    var currElement = testElement;\n\n    while( currElement ) {\n        var containerId = $( currElement ).data( 'containerId' );\n\n        if( containerId ) {\n            return containerId.toString();\n        }\n\n        currElement = currElement.parentElement;\n    }\n\n    return null;\n};\n\n/**\n * When object drag is cancelled , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {bool}_isDragCancelFlag -  true or false\n */\nvar _isDragCancelled = function( event ) {\n    var _isDragCancelFlag = false;\n    if( event.x <= 0 || event.y <= 0 ) {\n        _isDragCancelFlag = true;\n    } else if( event.screenX <= 0 || event.screenY <= 0 ) {\n        _isDragCancelFlag = true;\n    } else {\n        _isDragCancelFlag = false;\n    }\n\n    return _isDragCancelFlag;\n};\n\n/**\n * When object is dragged over a cell list container , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\nvar _isDragWithinCellListContainer = function( event ) {\n    var isCellListContainerFlag = false;\n    var cellListContainer = htmlUtils.closestElement( event.target, '.aw-widgets-cellListContainer' );\n    if( _.isUndefined( cellListContainer ) || cellListContainer === null ) {\n        isCellListContainerFlag = false;\n    } else {\n        isCellListContainerFlag = true;\n    }\n    return isCellListContainerFlag;\n};\n\n/**\n * When object is dragged over a table row border, this check ensures the drag cursor does not go back to 'Not allowed' because of global\n * dragenter event since table row border is an invalid drop target\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\nvar _isDragWithinTableContainer = function( event ) {\n    var isTableFlag = false;\n    var tableContainer = htmlUtils.closestElement( event.target, UI_GRID_ROW_CLASS );\n    if( _.isUndefined( tableContainer ) || tableContainer === null ) {\n        if( event && event.target && event.target.classList && event.target.classList.contains( 'ui-grid-row' ) ) {\n            isTableFlag = true;\n        }\n    } else {\n        isTableFlag = true;\n    }\n    return isTableFlag;\n};\n\n/**\n * When object is dragged over the white area, this check ensures  dragenter, dragleave , dragover events on document do not trigger any action in turn giving\n * a flickering of highlight effect on the container\n *\n * @param {event} event - Drag event\n * @return {Object} bool - flag to suggest if drag is within an applicable and valid container\n */\nvar _isDragWithinApplicableValidContainer = function( event ) {\n    var bool = false;\n    var jqTarget = $( event.target );\n\n    var jqContainer = jqTarget.closest( UI_GRID_ROW_CLASS );\n\n    if( jqContainer && jqContainer.length <= 0 ) {\n        jqContainer = jqTarget.closest( '.aw-widgets-cellListItem' );\n        if( jqContainer.length <= 0 ) {\n            jqContainer = jqTarget.closest( DROP_CLASS );\n\n            if( jqContainer.length <= 0 ) { // this is when user just enters a cellListContainer from white area\n                if( jqTarget &&\n                    jqTarget[ 0 ] &&\n                    jqTarget[ 0 ].children &&\n                    jqTarget[ 0 ].children.length > 0 &&\n                    jqTarget[ 0 ].children[ 0 ].classList &&\n                    jqTarget[ 0 ].children[ 0 ].classList.contains(\n                        'aw-widgets-cellListContainer' ) ) {\n                    jqContainer = jqTarget[ 0 ].children;\n                }\n            }\n        }\n    }\n    if( jqContainer && jqContainer.length > 0 && exports.isValidObjectToDrop( event, jqContainer[ 0 ] ) ) {\n        bool = true;\n    }\n    return bool;\n};\n\n/**\n * @param {event} event - Dragover event\n *\n * @return {Object} targetElement - choose or drop file widget which do not require validation or\n *                                   'undefined' if not over Choose or Drop File widgets\n */\nvar _isDragOverChooseOrDropFileContainer = function( event ) {\n    var targetElement = null;\n    if( event && event.target && event.target.classList && event.target.classList.contains( 'aw-widgets-chooseordropfile' ) ) {\n        targetElement = event.target;\n    } else {\n        var cfContainer = htmlUtils.closestElement( event.target, '.aw-widgets-chooseordropfile' );\n        if( cfContainer ) {\n            targetElement = cfContainer;\n        }\n    }\n    return targetElement;\n};\n\n/**\n * Determine if the DragEvent is over a white space on the page or on an applicable valid drop container\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\nexport let processDragOver = function( event, isCurrentTargetOverGlobalArea ) {\n    // If drag is over Choose File or Drop File container , unhighlight other highlighted containers, highlight this\n    // container and set drop effect to 'Copy' ; these containers have a special css(in addition) to identify : 'aw-widgets-chooseordropfile'\n    var chooseFileContainer = _isDragOverChooseOrDropFileContainer( event );\n    if( chooseFileContainer ) {\n        // Adding listeners to Choose/Drop File type widgets which mandatorily should have 'aw-widgets-chooseordropfile' associated\n        // along with 'aw-widgets-droppable' css class  to participate in highlight\n        chooseFileContainer.addEventListener( 'dragover', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS OVER CHOOSE/DROP FILE ZONE----------' );\n            }\n            exports.processDragLeaveGlobal( event ); // clear all the highlights\n            if( !exports.dataTransferContainsFiles( event ) ) {\n                _setDropEffect( event, 'none' );\n                event.stopPropagation();\n            } else {\n                eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                    event: event,\n                    isGlobalArea: false,\n                    isHighlightFlag: true,\n                    targetElement: chooseFileContainer\n                } );\n                _setDropEffect( event, 'copy' );\n                event.stopPropagation(); // required or else it hangs the page if file dragged over container for longer period of time.\n                event.preventDefault();\n            }\n        } );\n        chooseFileContainer.addEventListener( 'dragleave', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS LEAVING CHOOSE/DROP FILE ZONE----------' );\n            }\n            _setDropEffect( event, 'none' );\n            exports.processDragLeaveGlobal( event );\n            event.stopPropagation();\n            event.preventDefault();\n        } );\n        chooseFileContainer.addEventListener( 'drop', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS DROPPED IN CHOOSE/DROP FILE ZONE----------' );\n            }\n            _setDropEffect( event, 'none' );\n            exports.processDragLeaveGlobal( event );\n            event.stopPropagation();\n            event.preventDefault();\n        } );\n    }\n    var sourceUIDs = exports.getCachedSourceUids();\n\n    if( sourceUIDs ) {\n        dragAndDropUtils.loadVMOsIfNotAlreadyLoaded( sourceUIDs );\n    }\n\n    _processDragOverInternal( event, isCurrentTargetOverGlobalArea );\n};\n\n/**\n * Starting with the 'target' of the given DragEvent and walking up the DOM, look for the 1st DOM Element with the\n * 'validSourceTypes' property set.\n *\n * @param {DragEvent} event - The event to start the search at.\n * @param {Bool} isCurrentTargetOverGlobalArea - is the dragged file over white/invalid area\n * @return {Element} The Element that has the 'validSourceTypes' property set on it (or NULL if no Element was\n *         found).\n */\nvar _findDropTargetElement = function( event ) {\n    var targetElements = [];\n    /**\n     * Get the JQuery element for the event 'target' and look for common 'container' elements 'up' the DOM Tree.\n     */\n    var jqTarget = $( event.target );\n\n    var jqContainer = jqTarget.closest( UI_GRID_ROW_CLASS );\n\n    if( jqContainer !== undefined && jqContainer.length <= 0 ) {\n        jqContainer = jqTarget.closest( '.aw-widgets-cellListItem' );\n\n        if( jqContainer.length <= 0 ) {\n            jqContainer = jqTarget.closest( DROP_CLASS );\n        }\n    }\n\n    var targetElement;\n\n    if( jqContainer && jqContainer.length > 0 ) {\n        targetElement = jqContainer.get( 0 );\n    } else {\n        targetElement = jqTarget.get( 0 );\n    }\n    targetElements.push( targetElement );\n\n    /**\n     * Get the AngularJS element for the target 'container' element and try to find a {ViewModelObject} associated\n     * with it.\n     */\n    if( targetElements ) {\n        _.forEach( targetElements, function( targetElement ) {\n            //revisitme: fix the code as per react framework\n            // var ngTargetElement = ngModule.element( targetElement );\n\n            // var $scope = ngTargetElement.scope();\n\n            var targetVMO = null;\n            // $scope &&\n            //     ( $scope.vmo || $scope.item ||\n            //         $scope.row && $scope.row.entity ||\n            //         $scope.data && $scope.data.vmo ) ||\n            //     targetElement.vmo || ngTargetElement.get( 0 ).vmo;\n\n            if( targetVMO ) {\n                if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMO.modelType ) ) {\n                    adapterSvc.getAdaptedObjects( [ targetVMO ] ).then( function( adaptedObjs ) {\n                        _setValidSourceTypesOnTarget( targetElement, adaptedObjs[ 0 ] );\n                    } );\n                } else {\n                    _setValidSourceTypesOnTarget( targetElement, targetVMO );\n                }\n            }\n        } );\n    }\n\n    return targetElements;\n};\n\n/**\n * Check if we have NOT already stored the collection of 'valid' 'source' types this 'target' will accept.\n * <P>\n * If so: Get that collection now.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - View model object of target.\n */\nvar _setValidSourceTypesOnTarget = function( targetElement, targetVMO ) {\n    if( targetElement ) {\n        var jqElement = $( targetElement );\n        var validSourceTypes = jqElement.data( 'validSourceTypes' );\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        if( !validSourceTypes && pasteHandler ) {\n            validSourceTypes = pasteHandler.getObjectValidSourceTypes( targetVMO );\n            jqElement.data( 'validSourceTypes', validSourceTypes );\n            jqElement.data( 'dropuid', targetVMO.uid );\n            var containerId = _findContainerId( targetElement );\n            if( containerId ) {\n                jqElement.data( 'containerId', containerId );\n            }\n        }\n    }\n};\n\n/**\n * @return {Object} The Object that represents cached drag data set when the drag operation began.\n */\nvar _getCachedDragData = function() {\n    var dragDataJSON = localStrg.get( 'awDragData' );\n    if( dragDataJSON && dragDataJSON !== 'undefined' ) {\n        return JSON.parse( dragDataJSON );\n    }\n    return null;\n};\n\n/**\n * @param {String} dataTransferItem - The 'dataTransfer' Item to extract from.\n * @return {String} The type code of the given\n */\nfunction _getDataTransferType( dataTransferItem ) {\n    var extensionIndex = dataTransferItem.lastIndexOf( '/' );\n\n    if( extensionIndex >= 0 ) {\n        return dataTransferItem.substring( extensionIndex + 1 );\n    }\n\n    return '';\n}\n\n/**\n * @param {DragEvent} event - The DragEvent to extract the info from.\n *\n * @return {ObjectArray} Array of JS Files.\n */\nvar _getDataTransferSourceFiles = function( event ) {\n    return event.dataTransfer.files;\n};\n\n/**\n * Return the 'source' element from the given drag event. The name of the element in the event can vary\n * depending on the browser the client is running with.\n *\n * @param {DragEvent} event - The event to extract the 'source' element from.\n *\n * @return {Element} The DOM element considered the 'source' of the given drag event.\n */\nvar _getEventSource = function( event ) {\n    if( event.srcElement ) {\n        return event.srcElement;\n    }\n\n    return event.target;\n};\n\n/**\n * Get the first child image element of the passed in element.\n *\n * @param {Element} sourceElement - element being dragged\n *\n * @return {Element} drag image element or returns passed in element if no image found.\n */\nvar _getFirstChildImage = function( sourceElement ) {\n    var image = $( sourceElement ).find( 'img:first' )[ 0 ];\n\n    return image ? image : sourceElement;\n};\n\n/**\n * @param {String} uid - ID of the object to include in the URL.\n *\n * @return {String} The URL 'prefix' used to open an object in the 'show object' location of AW.\n */\nvar _getShowObjectURL = function( uid ) {\n    // Have to decode as ui-router returns encoded URL (which is then decoded again by browser)\n    return window.decodeURIComponent( document.location.origin + document.location.pathname +\n        AwStateService.instance.href( 'com_siemens_splm_clientfx_tcui_xrt_showObject', {\n            uid: uid\n        } ) );\n};\n\n/**\n * Returns the correct element to be dragged\n *\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} The correct drag element\n */\nvar _getDragElement = function( event, count ) {\n    var element;\n\n    if( event && event.target && event.target.classList ) {\n        if( event.target.classList.contains( 'aw-widgets-cellListItemContainer' ) ) {\n            element = event.target.parentElement; // Cell element\n        } else if( event.target.classList.contains( 'ui-grid-cell' ) ) {\n            var target = $( event.target );\n            var closest = target.closest( UI_GRID_ROW_CLASS );\n            if( closest && closest.length > 0 && count === 1 ) {\n                element = target.closest( UI_GRID_ROW_CLASS ).get( 0 ); // Table element\n            } else {\n                element = event.target;\n            }\n        }\n    }\n\n    return element;\n};\n\n/**\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} image element\n */\nvar _getMultiDragImage = function( event, count ) {\n    var targetImage = _getDragElement( event, count );\n\n    var strWidth;\n    var strHeight;\n\n    var cloneImage = null;\n    if( targetImage ) {\n        cloneImage = targetImage.cloneNode( true );\n\n        // If cell, remove command icon/text\n        if( targetImage.classList && targetImage.classList.contains( 'aw-widgets-cellListItem' ) ) {\n            // Keep the image from being duplicated at the top of the page\n            targetImage.style.position = 'relative';\n\n            strWidth = targetImage.offsetWidth - 50 + 'px';\n            strHeight = targetImage.offsetHeight - 10 + 'px';\n\n            // Remove commands from image\n            cloneImage.children[ 0 ].removeChild( cloneImage.children[ 0 ].children[ 1 ] );\n\n            // Remove text from image\n            var cloneImageText = cloneImage.getElementsByClassName( 'aw-widgets-cellListCellTitleBlock' )[ 0 ].parentNode;\n            if( cloneImageText ) {\n                for( var i = 1; i < cloneImageText.children.length; i++ ) {\n                    cloneImageText.removeChild( cloneImageText.children[ i ] );\n                    i--;\n                }\n            }\n        } else { // Else it is a row\n            strWidth = '150px';\n            strHeight = '100%';\n        }\n\n        cloneImage.id = 'dragCount';\n\n        cloneImage.style.maxWidth = strWidth;\n        cloneImage.style.minWidth = strWidth;\n        cloneImage.style.maxHeight = strHeight;\n        cloneImage.style.minHeight = strHeight;\n\n        cloneImage.style.position = 'absolute';\n        cloneImage.style.left = '0px';\n        cloneImage.style.top = '0px';\n        cloneImage.style.zIndex = '99';\n        cloneImage.classList.add( 'aw-theme-multidragimage' );\n        cloneImage.classList.add( 'aw-widgets-multidragimage' );\n\n        // the image that is dragged needs to be visible, so it is added to the existing node\n        targetImage.children[ 0 ].appendChild( cloneImage );\n\n        // create a second offset image\n        var cloneImage2 = cloneImage.cloneNode( true );\n\n        cloneImage2.style.left = '5px';\n        cloneImage2.style.top = '5px';\n\n        // create a third offset image & append if necessary\n        var cloneImage3 = cloneImage.cloneNode( true );\n\n        cloneImage.appendChild( cloneImage2 );\n\n        if( count > 2 ) {\n            cloneImage3.style.left = '10px';\n            cloneImage3.style.top = '10px';\n\n            cloneImage.appendChild( cloneImage3 );\n        }\n    }\n\n    return cloneImage;\n};\n\n/**\n * Returns the 'validSourceTypes' property on the 'target' element being dropped onto.\n *\n * @param {Element} targetElement - The Element that will be dropped onto (i.e. the data 'target').\n *\n * @return {StringArray} Array of valid 'sourceTypes' (or an empty array if no 'sourceTypes' are valid).\n */\nvar _getValidSourceTypes = function( targetElement ) {\n    var validSourceTypes = $( targetElement ).data( 'validSourceTypes' );\n    if( validSourceTypes ) {\n        return Object.keys( validSourceTypes );\n    }\n    return [];\n};\n\n/**\n * Use the given ViewModelObject to return a string description of it.\n *\n * @param {ViewModelObject} vmo - The ViewModelObject to query.\n *\n * @return {String} Description of given ViewModelObject (or it's UID if no other name is possible).\n */\nvar _getViewModelObjectName = function( vmo ) {\n    if( vmo.props.object_string ) {\n        return vmo.props.object_string.displayValues[ 0 ];\n    } else if( vmo.props.items_tag ) {\n        return vmo.props.items_tag.displayValues[ 0 ];\n    } else if( vmo.props.object_name ) {\n        return vmo.props.object_name.displayValues[ 0 ];\n    } else if( vmo.props.object_desc && vmo.props.object_desc.length > 0 ) {\n        return vmo.props.object_desc.displayValues[ 0 ];\n    } else if( vmo.props.job_name ) {\n        return vmo.props.job_name.displayValues[ 0 ];\n    } else if( vmo.props.awp0CellProperties ) {\n        return vmo.props.awp0CellProperties.displayValues[ 0 ];\n    }\n\n    return vmo.uid;\n};\n\n/**\n * Check the user agent string to see if the browser is the NX embedded browser, the NX QT browser puts \"ugraf\"\n * in the user agent string.\n *\n * @return {boolean} true if NX browser false otherwise\n */\nvar _isNxWebBrowser = function() {\n    return navigator.userAgent.indexOf( 'ugraf' ) >= 0;\n};\n\n/**\n * @param {StringArray} validSourceTypes - Array of 'source' types this 'target' will accept.\n * @param {StringArray} sourceTypes - Arrays of 'source' types determined from the event's 'dataTransfer' being\n *            dragged.\n *\n * @return {Boolean} TRUE if ALL the given 'source' types are valid to drop onto the 'target' based on the given\n *         'validSourceTypes'.\n */\nvar _isValidObjectToDropInternal = function( validSourceTypes, sourceTypes ) {\n    /**\n     * Check if we have anything to work with.\n     */\n    if( validSourceTypes && validSourceTypes.length > 0 && sourceTypes && sourceTypes.length > 0 ) {\n        /**\n         * Check if all the 'sources' matches at least one valid type for the 'target' Element.\n         * <P>\n         * If so: We will consider the drop of these 'sources' onto that 'target'.\n         */\n        for( var i = 0; i < sourceTypes.length; i++ ) {\n            var sourceType = sourceTypes[ i ];\n\n            var sourceTypeFound = null;\n\n            /**\n             * Consider each valid 'source' type the 'target' will accept.\n             */\n            for( var j = 0; j < validSourceTypes.length; j++ ) {\n                var validSourceType = validSourceTypes[ j ];\n\n                /**\n                 * Check for an exact match\n                 */\n                if( sourceType === validSourceType ) {\n                    sourceTypeFound = validSourceType;\n                    break;\n                }\n\n                /**\n                 * Get all the ancestor types for this 'source' type and see if one of them is valid for this\n                 * 'target'.\n                 */\n                var sourceModelType = cmm.getType( sourceType );\n\n                if( sourceModelType ) {\n                    var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                    if( sourceTypeHeirarchy ) {\n                        for( var k = 1; k < sourceTypeHeirarchy.length; k++ ) {\n                            if( sourceTypeHeirarchy[ k ] === validSourceType ) {\n                                sourceTypeFound = validSourceType;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    logger.warn( 'Unable to locate \\'source\\' type (not loaded yet?): ' + sourceType );\n                }\n            }\n\n            /**\n             * Check if NONE of the valid 'source' types apply.\n             */\n            if( !sourceTypeFound ) {\n                if( m_debug_LogRejectedSourceType ) {\n                    logger.warn( 'This \\'source\\' type is not valid for the \\'target\\': ' + sourceType );\n                }\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * @param {Object} pasteInput - An Object that maps a unique 'relationType' to the array of 'source'\n *            IModelObjects that should be pasted onto the 'target' with that 'relationType'.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\nvar _pasteFiles = function( pasteInput ) {\n    let pasteFileHandler = DragAndDropService.instance.pasteFileHandler;\n    return pasteFileHandler.pasteFilesWithHandler( pasteInput ).then( function( response ) {\n        if( response && response.isOsFiles ) {\n            const { pasteFilesInput } = response;\n            var deferred = AwPromiseService.instance.defer();\n\n            _.forEach( pasteFilesInput, function( input ) {\n                const { targetObject, relationType, sourceObjects } = input;\n                pasteService.execute( targetObject, sourceObjects, relationType, { isDragDropIntent: true } ).then( function( res ) {\n                    var eventData = {\n                        relatedModified: [ targetObject ],\n                        refreshLocationFlag: false,\n                        createdObjects: sourceObjects\n                    };\n                    eventBus.publish( 'cdm.relatedModified', eventData );\n                    deferred.resolve( res[ 0 ] );\n                }, function( err ) {\n                    deferred.reject( err );\n                } );\n            } );\n\n            return deferred.promise;\n        }\n        return response;\n    } );\n};\n\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Array} sourceFiles - The 'source' JS File objects being dropped.\n * @param {FunctionArray} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _pasteSourceFiles = function( targetElement, targetVMO, sourceFiles, callbackAPIs ) {\n    /**\n     * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n     * type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n    if( !validSourceTypes || validSourceTypes.length === 0 ) {\n        validSourceTypes = [];\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        var sourceTypesObject = pasteHandler.getObjectValidSourceTypes( targetVMO );\n        if( sourceTypesObject && typeof sourceTypesObject === 'object' ) {\n            var sourceTypes = Object.keys( sourceTypesObject );\n\n            if( sourceTypes ) {\n                for( var counter = 0; counter < sourceTypes.length; counter++ ) {\n                    var validSourceType = sourceTypes[ counter ];\n                    if( cmm.containsType( validSourceType ) ) {\n                        validSourceTypes.push( validSourceType );\n                    }\n                }\n            }\n        }\n    }\n\n    var sourceType2RelationMap = _createSourceType2RelationsMap( validSourceTypes, targetElement );\n\n    var pasteRelation2SourceObjectsMap = {};\n\n    if( sourceFiles ) {\n        for( var i = 0; i < sourceFiles.length; i++ ) {\n            var sourceObject = sourceFiles[ i ];\n\n            /**\n             * Get all the ancestor types for this 'source' type and see if one of them is valid.\n             * <P>\n             * Note: For dropping files we look to see if the 'target' accepts a 'Dataset' since that is what will\n             * ultimately be created.\n             */\n            var sourceModelType = cmm.getType( TYPE_NAME_DATASET );\n\n            if( sourceModelType ) {\n                var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                for( var j = 0; j < sourceTypeHeirarchy.length; j++ ) {\n                    var currSourceType = sourceTypeHeirarchy[ j ];\n\n                    var relationType = sourceType2RelationMap[ currSourceType ];\n\n                    if( relationType ) {\n                        var sourceObjectsForType = pasteRelation2SourceObjectsMap[ relationType ];\n\n                        if( !sourceObjectsForType ) {\n                            sourceObjectsForType = [];\n\n                            pasteRelation2SourceObjectsMap[ relationType ] = sourceObjectsForType;\n                        }\n\n                        sourceObjectsForType.push( sourceObject );\n                        break;\n                    }\n                }\n            } else {\n                logger.warn( 'Unable to locate \\'source\\' type\\' (not loaded yet?): ' + TYPE_NAME_DATASET );\n            }\n        }\n    }\n\n    _scheduleSelectTarget( targetElement, targetVMO, callbackAPIs );\n\n    /**\n     * Paste 'sources' to 'target' for each unique 'relation' type.\n     */\n    var pasteInput = [];\n\n    _.forEach( pasteRelation2SourceObjectsMap, function( value, key ) {\n        var curr = {};\n\n        curr.targetObject = targetVMO;\n        curr.relationType = key;\n        curr.sourceObjects = value;\n\n        pasteInput.push( curr );\n    } );\n\n    var startTime = Date.now();\n\n    _pasteFiles( pasteInput ).then( function( result ) {\n        var stopTime = Date.now();\n\n        var pasteInputJS = pasteInput;\n        var sourceObjectsJS = result.sourceObjects;\n\n        if( _debug_logEventActivity > 1 ) {\n            var durationMs = stopTime - startTime;\n\n            var durationSec = durationMs / 1000.0;\n            var duration = durationSec;\n\n            logger.info( 'Time to process (' + sourceObjectsJS.length + ') files: ' + duration + 'sec' );\n        }\n        var localTextBundle = {};\n        localTextBundle.dropCompletedDocument = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropCompletedDocument' );\n        localTextBundle.dropCompleted = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropCompleted' );\n\n        /**\n         * Based on passed parameters in return from create SOA post the correct success message to the user.\n         */\n\n        var droppedOnObject = pasteInputJS[ 0 ].targetObject.cellHeader1;\n\n        if( !droppedOnObject ) {\n            droppedOnObject = pasteInputJS[ 0 ].targetObject.props.object_string.uiValues[ 0 ];\n        }\n\n        if( !droppedOnObject ) {\n            droppedOnObject = '???';\n        }\n\n        if( result.docCreated ) {\n            var dropCompletedDocumentMsg = localTextBundle.dropCompletedDocument;\n\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{0}', result.docName );\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{1}', droppedOnObject );\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{2}', sourceObjectsJS.length );\n\n            messagingSvc.showInfo( dropCompletedDocumentMsg );\n        } else {\n            var dropCompletedMsg = localTextBundle.dropCompleted;\n\n            dropCompletedMsg = dropCompletedMsg.replace( '{0}', sourceObjectsJS.length );\n            dropCompletedMsg = dropCompletedMsg.replace( '{1}', droppedOnObject );\n\n            messagingSvc.showInfo( dropCompletedMsg );\n        }\n    }, function( ex ) {\n        logger.error( 'uploadFailures' + ex );\n    } );\n};\n\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObjects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _pasteSourceObjects = function( targetElement, targetVMO, sourceObjects, callbackAPIs ) {\n    /**\n     * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n     * type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n    if( !validSourceTypes || validSourceTypes.length === 0 ) {\n        validSourceTypes = [];\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        var sourceTypesObject = pasteHandler.getObjectValidSourceTypes( targetVMO );\n        var sourceTypes = Object.keys( sourceTypesObject );\n\n        if( sourceTypes ) {\n            for( var counter = 0; counter < sourceTypes.length; counter++ ) {\n                var validSourceType = sourceTypes[ counter ];\n                if( cmm.containsType( validSourceType ) ) {\n                    validSourceTypes.push( validSourceType );\n                }\n            }\n        }\n    }\n\n    var sourceType2RelationMap = _createSourceType2RelationsMap( validSourceTypes, targetElement );\n\n    var pasteRelation2SourceObjectsMap = {};\n\n    if( sourceObjects ) {\n        for( var i = 0; i < sourceObjects.length; i++ ) {\n            var sourceObject = sourceObjects[ i ];\n\n            /**\n             * Get all the ancestor types for this 'source' type and see if one of them is valid.\n             */\n            var sourceType = sourceObject.type;\n\n            var sourceModelType = cmm.getType( sourceType );\n\n            if( sourceModelType ) {\n                var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                for( var j = 0; j < sourceTypeHeirarchy.length; j++ ) {\n                    var sourceParentType = sourceTypeHeirarchy[ j ];\n\n                    var relationType = sourceType2RelationMap[ sourceParentType ];\n\n                    if( relationType ) {\n                        var sourceObjectsForType = pasteRelation2SourceObjectsMap[ relationType ];\n\n                        if( !sourceObjectsForType ) {\n                            sourceObjectsForType = [];\n\n                            pasteRelation2SourceObjectsMap[ relationType ] = sourceObjectsForType;\n                        }\n\n                        sourceObjectsForType.push( sourceObject );\n\n                        break;\n                    }\n                }\n            } else {\n                logger.warn( 'Unable to locate \\'source\\' type\\' (not loaded yet?): ' + sourceType );\n            }\n        }\n    }\n\n    _scheduleSelectTarget( targetElement, targetVMO, callbackAPIs );\n\n    /**\n     * Paste each unique 'relation' type.\n     */\n    var keys = Object.keys( pasteRelation2SourceObjectsMap );\n\n    if( keys && keys.length > 0 ) {\n        var pasteInput = [];\n\n        _.forEach( pasteRelation2SourceObjectsMap, function( value, key ) {\n            var jso = {};\n\n            jso.targetObject = targetVMO;\n            jso.relationType = key;\n            jso.sourceObjects = value;\n\n            pasteInput.push( jso );\n        } );\n\n        exports.publishDropEvent( pasteInput );\n    }\n};\n\n/**\n * Determine all the valid containers on the page . Check if the 'target'  is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event - DragEnter or DragOver event from global area\n * @return {Object} validHighlightableContainers - All valid applicable containers for highlighing\n */\nvar getApplicableContainersFromGlobalArea = function( event ) {\n    var validHighlightableContainers = [];\n    var isValid = false;\n    var targetElements = document.body.querySelectorAll( DROP_CLASS );\n    if( targetElements ) {\n        _.forEach( targetElements, function( targetElement ) {\n            isValid = exports.isValidObjectToDrop( event, targetElement );\n            if( isValid ) {\n                validHighlightableContainers.push( targetElement );\n            }\n        } );\n    }\n    if( validHighlightableContainers.length === 0 ) {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( 'No valid containers found on the entire page' );\n        }\n    } else {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( validHighlightableContainers.length + ' valid containers found , highlight in progress' );\n        }\n    }\n\n    return validHighlightableContainers;\n};\n\n/**\n * Set the type of drag-and-drop operation currently selected or sets the operation to a new type. The value\n * must be 'none', 'copy', 'link' or 'move'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n * @param {String} value - The 'dropEffect' value to set .\n */\nvar _setDropEffect = function( event, value ) {\n    event.dataTransfer.dropEffect = value;\n};\n\n/**\n * Once the last 'paste' is complete, select the 'target' object to show the results of the 'drop'. This should\n * cause the new 'sources' in that object.\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _scheduleSelectTarget = function( targetElement, targetVMO, callbackAPIs ) {\n    callbackAPIs.selectResultFn( targetElement, targetVMO );\n};\n\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n\nvar exports = {};\n\n/**\n * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n *\n * @param {DragEvent} event - The DragEvent to set the DragData on.\n * @param {Object} dragDataMap - Map of name/value pairs to add.\n */\nexport let addDragDataToDragEvent = function( event, dragDataMap ) {\n    if( _includeDataTransfer ) {\n        try {\n            _.forEach( dragDataMap, function( value, name ) {\n                event.dataTransfer.setData( name, value );\n            } );\n        } catch ( ex ) {\n            // Current versions of Internet Explorer can only have types \"Text\" and \"URL\"\n            _.forEach( dragDataMap, function( value, name ) {\n                // Only deal with the interop error from IE, to address DnD issue D-24972\n                if( name === 'aw_interop_type' ) {\n                    event.dataTransfer.setData( 'text', value );\n                }\n            } );\n        }\n    }\n};\n\n/**\n * @return {StringArray} An array of strings (placed into localStorage' at the start of a drag operation) that\n *         represent the UIDs of 'source' objects being dragged (or NULL if no types were found).\n */\nexport let getCachedSourceUids = function() {\n    var dragDataJSON = localStrg.get( 'awDragData' );\n\n    if( dragDataJSON && dragDataJSON !== 'undefined' ) {\n        var dragData = JSON.parse( dragDataJSON );\n\n        if( dragData.uidList ) {\n            return dragData.uidList;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n * <P>\n * Note: There will be multiple things being dragged over. We should look at the type (Files, ModelObject,\n * Text). Do we have three handlers, or a smarter handler?\n * <P>\n * For a smarter handler, if this is a folder, it can take objects. This should only cause the drop indicator to\n * be shown for objects.\n *\n * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n *            test.\n * @param {Object} targetElement - targetElement when object is over an invalid area . When drag is over a valid area,  targetElement\n *            is evaluated from event\n * @returns {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n */\nexport let isValidObjectToDrop = function( event, targetElement ) { // eslint-disable-line complexity\n    /**\n     * Find the DOM Element (potentially above the 'target' event's origin) where all the DnD information is\n     * stored.\n     */\n\n    if( _.isUndefined( targetElement ) ) {\n        targetElement = _findDropTargetElement( event )[ 0 ];\n    }\n    if( !targetElement ) {\n        return false;\n    }\n\n    if( targetElement.classList && targetElement.classList.contains( 'aw-widgets-chooseordropfile' ) && exports.dataTransferContainsFiles( event ) ) {\n        return true;\n    }\n\n    /**\n     * Check if we do NOT want to allow files from the OS to be dropped and the 'dataTransfer' contains at least\n     * one file.\n     */\n    if( !m_supportingFileDrop && exports.dataTransferContainsFiles( event ) ) {\n        return false;\n    }\n\n    /**\n     * Check if the 'target' does not have information we need to process or that there are no 'source' objects\n     * being dragged.\n     * <P>\n     * If so: No need to consider it as a valid drop (onto itself).\n     */\n    var targetUID = $( targetElement ).data( 'dropuid' );\n\n    if( !targetUID || targetUID.length === 0 ) {\n        return false;\n    }\n\n    /**\n     * Make sure we have cached 'source' information to work with.\n     */\n    //            var sourceContainerId = null;\n    var sourceUids = null;\n    var sourceTypes = null;\n\n    var sourceDragData = _getCachedDragData();\n\n    if( sourceDragData ) {\n        //                sourceContainerId = sourceDragData.containerId;\n        sourceUids = sourceDragData.uidList;\n        sourceTypes = sourceDragData.typeList;\n    }\n\n    /**\n     * Check if the 'target' is actually in the list of 'source' objects being dragged.\n     * <P>\n     * If so: No need to consider it as a valid drop (onto itself).\n     */\n    if( sourceUids && sourceUids.length > 0 && _.indexOf( sourceUids, targetUID ) !== -1 ) {\n        return false;\n    }\n\n    /**\n     * Get the types that are valid to drop on this 'target' and check if the current drag operation 'source'\n     * contains at least one of that type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n\n    if( validSourceTypes && validSourceTypes.length > 0 ) {\n        /**\n         * Check if the only 'sources' are JS Files on the event.\n         * <P>\n         * If so: Build a list of 'source' types based on the file extensions.\n         * <P>\n         * If not: Use the IModelObject 'sources'\n         */\n        if( ( !sourceTypes || sourceTypes.length === 0 ) && exports.dataTransferContainsFiles( event ) ) {\n            /**\n             * Get any file type information carried in the 'dataTransfer' property.\n             * <P>\n             * Check if there are NONE\n             * <P>\n             * If so: Then just assume the source is just one or more 'DataSet'.\n             */\n            var fileTypes = exports.getDataTransferFileTypes( event );\n\n            if( fileTypes && fileTypes.length === 0 ) {\n                fileTypes.push( TYPE_NAME_DATASET );\n            }\n\n            /**\n             * Create key used to track status and remember the result of the validity test.\n             */\n            var sb = targetUID;\n\n            for( var i = 0; i < validSourceTypes.length; i++ ) {\n                sb += ',';\n                sb += validSourceTypes[ i ];\n            }\n\n            if( fileTypes ) {\n                for( var j = 0; j < fileTypes.length; j++ ) {\n                    sb += ',';\n                    sb += fileTypes[ j ];\n                }\n            }\n            var mapKey = sb;\n\n            /**\n             * Check if we already know the result from the last time we asked this question for the same\n             * 'source' types and 'target'.\n             */\n            var result = m_mapKey2Result[ mapKey ];\n\n            if( result ) {\n                return result.value;\n            }\n\n            var promise = m_mapKey2Promise[ mapKey ];\n\n            if( !promise ) {\n                m_mapKey2Promise[ mapKey ] = exports.getDataTransferSourceTypes( targetUID, fileTypes ).then( function( result2 ) {\n                    delete m_mapKey2Promise[ mapKey ];\n\n                    m_mapKey2Result[ mapKey ] = {\n                        value: result2 && result2.length > 0 &&\n                            _isValidObjectToDropInternal( validSourceTypes, result2 )\n                    };\n                }, function() {\n                    delete m_mapKey2Promise[ mapKey ];\n\n                    m_mapKey2Result[ mapKey ] = {\n                        value: false\n                    };\n                } );\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if any of the valid 'source' types are NOT currently loaded.\n         * <P>\n         * Note: We need them loaded so we can walk their type hierarchy while looking for a match.\n         */\n        var missingSourceTypes = null;\n        var availableSourceTypes = null;\n\n        for( var ii = 0; ii < validSourceTypes.length; ii++ ) {\n            var validSourceType = validSourceTypes[ ii ];\n\n            if( !cmm.containsType( validSourceType ) ) {\n                if( !missingSourceTypes ) {\n                    missingSourceTypes = [];\n                }\n\n                missingSourceTypes.push( validSourceType );\n            } else {\n                if( !availableSourceTypes ) {\n                    availableSourceTypes = [];\n                }\n                availableSourceTypes.push( validSourceType );\n            }\n        }\n\n        /**\n         * Check if any 'source' types are missing (not loaded yet).\n         * <P>\n         * If available 'source' types is null and missing 'source' types is not null, Then: Return 'false' for\n         * this drop but queue up a server request to get the type so that during further (future) dragging will\n         * see the type as loaded.\n         */\n        if( !availableSourceTypes && missingSourceTypes ) {\n            var sb2 = targetUID;\n\n            for( var jj = 0; jj < missingSourceTypes.length; jj++ ) {\n                if( jj > 0 ) {\n                    sb2 += ',';\n                }\n\n                sb2 += missingSourceTypes[ jj ];\n            }\n\n            var key = sb2;\n\n            if( !m_typeLookupInProgress[ key ] ) {\n                m_typeLookupInProgress[ key ] = key;\n\n                soaSvc.ensureModelTypesLoaded( missingSourceTypes ).then( function() {\n                    /**\n                     * Nothing to do now other than removing the lookup placeholder. We just wanted to make sure\n                     * the type is loaded for the NEXT time we look for it.\n                     */\n                    delete m_typeLookupInProgress[ key ];\n                }, function( err ) {\n                    logger.error( 'Unable to get model types: ' + err );\n                } );\n            }\n\n            return false;\n        }\n\n        return _isValidObjectToDropInternal( availableSourceTypes, sourceTypes );\n    }\n\n    return false;\n};\n\n/**\n * Get map of data format to drag data based on the given 'source' IModelObjects.\n *\n * @param {ViewModelObjectArray} sourceVMOs - The 'source' ViewModelObjects being dragged.\n * @param {String} containerId - The ID of the UI 'container' of the 'source' objects.\n *\n */\nexport let processAWInteropAndHosting = function( sourceVMOs, containerId ) {\n    /**\n     * Create collections of data associated with the 'source' objects.\n     */\n    var uidList = [];\n    var typeSet = {};\n\n    var interopObjectRefs = [];\n\n    var firstObjectUrl = '';\n\n    var first = true;\n\n    modelsHaveTypes = false;\n\n    sourceVMOs.forEach( ( modelObject ) => {\n        if( modelObject.type ) {\n            modelsHaveTypes = true;\n        }\n\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', modelObject.modelType ) ) {\n            var adaptedObjs = adapterSvc.getAdaptedObjectsSync( [ modelObject ] );\n            modelObject = adaptedObjs[ 0 ];\n        }\n\n        /**\n         * Grab the first uid from the list for the url and the type\n         */\n        if( first ) {\n            first = false;\n            firstObjectUrl = _getShowObjectURL( modelObject.uid );\n        }\n\n        /**\n         * Add the UID and type of this object into the collections\n         */\n        if( modelObject.uid ) {\n            uidList.push( modelObject.uid );\n        }\n\n        typeSet[ modelObject.type ] = modelObject.type;\n\n        if( _createInteropObjectRefFn ) {\n            /**\n             * Generate a hosting InteropObjectRef to be used by host applications (i.e. NX) for\n             * interpreting this 'source' object.\n             */\n            var objRefArrayList = _createInteropObjectRefFn( modelObject );\n\n            _.forEach( objRefArrayList, function( objRef ) {\n                interopObjectRefs.push( objRef );\n            } );\n        } else {\n            if( _debug_logEventActivity ) {\n                logger.warn( 'Unable to determine InteropObjectRef information due to missing callback function' );\n            }\n        }\n    } );\n\n    var dragData = {\n        'text/uri-list': firstObjectUrl,\n        'text/plain': firstObjectUrl\n    };\n\n    /**\n     * Include application interop references (if necessary)\n     */\n    if( interopObjectRefs && interopObjectRefs.length > 0 && _includeDataTransfer ) {\n        /**\n         * Create the JSON message for interop with host applications.\n         */\n        var dragDataInterop = {\n            DragTargets: interopObjectRefs\n        };\n\n        var jsonString = JSON.stringify( dragDataInterop );\n\n        /**\n         * Add data for each data format\n         * <P>\n         * Note: Need multiple data formats right now to handle compatibility with different browsers.\n         */\n        for( var j = 0; j < DATA_FORMATS.length; j++ ) {\n            dragData[ DATA_FORMATS[ j ] ] = jsonString;\n        }\n    }\n\n    dragData[ 'text/uri-list' ] = firstObjectUrl;\n    dragData[ 'text/plain' ] = firstObjectUrl;\n\n    /**\n     * Put the other formats onto the dataTransport\n     * <P>\n     * Note: We need the UIDs and types in the 'keys' (for checking while dragging since the values are not\n     * available at that time) and the 'values' to be able to access the data without it being changed to lower\n     * case by the browser itself.\n     */\n    var dragDataJSO = {};\n\n    dragDataJSO.containerId = containerId;\n    dragDataJSO.uidList = uidList;\n    dragDataJSO.firstObjectUrl = firstObjectUrl;\n\n    dragDataJSO.typeList = [];\n\n    _.forEach( typeSet, function( type ) {\n        dragDataJSO.typeList.push( type );\n    } );\n\n    localStrg.publish( 'awDragData', JSON.stringify( dragDataJSO ) );\n    addDragDataToDragEvent( event, dragData );\n};\n\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n */\nexport let processDragEnd = function( event ) { // eslint-disable-line no-unused-vars\n    _clearCachedData();\n};\n\n/**\n * Remove Highlight from the drop area with CSS class(s) and prevent the 'default' behavior (which we assume to\n * be 'do not allow drop' for objects or 'load file into page' for files).\n *\n * @param {DragEvent} event -\n */\nexport let processDragLeave = function( event ) {\n    event.preventDefault();\n};\n\n/**\n * Remove Highlight when object drag is skipped or object dragged outside white/invalid area\n *\n * @param {DragEvent} event -\n */\nexport let processDragLeaveGlobal = function( event ) {\n    if( _.isUndefined( mainReference ) ) {\n        mainReference = document.body;\n    }\n    var allHighlightedTargets = mainReference.querySelectorAll( '.aw-theme-dropframe.aw-widgets-dropframe' );\n    if( allHighlightedTargets ) {\n        isGlobalHighlightPublished = false;\n        _.forEach( allHighlightedTargets, function( target ) {\n            eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                event: event,\n                isGlobalArea: true,\n                isHighlightFlag: false,\n                targetElement: target\n            } );\n        } );\n    }\n};\n\n/**\n * Determine if the DragEvent is over a 'target' that is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\nvar _processDragOverInternal = function( event, isCurrentTargetOverGlobalArea ) {\n    exports.processDragLeaveGlobal( event ); // clearing all other highlights triggered due to file drag in global area\n\n    if( isCurrentTargetOverGlobalArea ) {\n        if( exports.dataTransferContainsURLs( event ) ) {\n            _setDropEffect( event, 'copy' );\n        } else {\n            _setDropEffect( event, 'none' );\n            event.stopPropagation();\n            event.preventDefault();\n            var allHighlightableTargets = getApplicableContainersFromGlobalArea( event );\n            if( allHighlightableTargets ) {\n                _.forEach( allHighlightableTargets, function( targetElement ) {\n                    eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                        event: event,\n                        isGlobalArea: true,\n                        isHighlightFlag: true,\n                        targetElement: targetElement\n                    } );\n                } );\n            }\n        }\n    } else {\n        if( exports.isValidObjectToDrop( event ) ) {\n            eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                event: event,\n                isGlobalArea: false,\n                isHighlightFlag: true,\n                targetElement: _findDropTargetElement( event )[ 0 ]\n            } );\n            _setDropEffect( event, 'copy' ); // when dragged object is on a valid container, the dragged effect should be \\'Copy\\'\n            event.stopPropagation();\n            event.preventDefault();\n        } else { // this ensures if the drop target is an applicable one however not a valid one , all the highlights are gone and a no drop cursor is shown\n            _setDropEffect( event, 'none' );\n            event.dataTransfer.effectAllowed = 'none';\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }\n};\n\n/**\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nexport let processDrop = function( event, callbackAPIs ) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    var targetElement = _findDropTargetElement( event )[ 0 ];\n\n    if( !targetElement ) {\n        _clearCachedData();\n        return;\n    }\n\n    eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: false,\n        isHighlightFlag: false,\n        targetElement: targetElement\n    } );\n\n    var sourceUids = exports.getCachedSourceUids();\n    if( sourceUids && sourceUids.length > 0 ) {\n        _dropModelObjects( targetElement, sourceUids, callbackAPIs );\n    } else {\n        var sourceFiles = _getDataTransferSourceFiles( event );\n        if( sourceFiles && sourceFiles.length > 0 && sourceFiles.item( 0 ).size > 0 ) {\n            _dropFiles( targetElement, sourceFiles, callbackAPIs );\n        } else {\n            var dropFolderFailureDocument = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropFolderFailureDocument' );\n            dropFolderFailureDocument = dropFolderFailureDocument.replace( '{0}', sourceFiles.item( 0 ).name );\n            messagingSvc.showError( dropFolderFailureDocument );\n            _clearCachedData();\n        }\n    }\n};\n\n/**\n * Set the current types of operations that are possible. Must be one of 'none', 'copy', 'copyLink', 'copyMove',\n * 'link', 'linkMove', 'move', 'all' or 'uninitialized'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n *\n * @param {String} value - The 'effectAllowed' allowed value to set.\n */\nexport let setEffectAllowed = function( event, value ) {\n    try {\n        event.dataTransfer.effectAllowed = value;\n    } catch ( ex ) {\n        // Do nothing\n    }\n};\n\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various reasons of interaction with the\n *            container/frame:\n *\n * @param {Object} dataProvider - DataProvider for the panelElement\n * <P>\n * getElementViewModelObjectFn: Used to query the 'source' or 'target' ViewModelObject(s) under any given\n * DragEvent.\n * <P>\n * clearSelectionFn: Used to clear all currently selected 'source' objects just before the drop operation is\n * performed.\n * <P>\n * selectResultFn: Used to select the 'target' when the drop operation is complete.\n */\nexport let setupDragAndDrop = function( panelElement, callbackAPIs, dataProvider ) {\n    // Init class here\n    DragAndDropService.instance;\n\n    var jqPanelElement = $( panelElement );\n\n    var showDropAreaAttr = jqPanelElement.attr( 'show-drop-area' );\n    /**\n     * Set valid source types to the target drop element by retrieving from objectSetSource in data provider\n     */\n    var dropContainer = jqPanelElement.hasClass( 'aw-widgets-droppable' ) && !showDropAreaAttr ? jqPanelElement : jqPanelElement.find( DROP_CLASS );\n    if( dropContainer ) {\n        var dropContScope = null; //ngModule.element( dropContainer ).scope();\n        if( dropContScope ) {\n            var sourceType2RelationMap = {};\n            var declViewModel = declUtils.findViewModel( dropContScope, false, null );\n            // ui-grid uses scope.dataprovider and plTable uses scope.dataProvider\n            var dropTableDataProvider = dataProvider || dropContScope.dataprovider || dropContScope.dataProvider;\n\n            if( dropTableDataProvider && dropTableDataProvider.validSourceTypes ) {\n                var objectSetSources = dropTableDataProvider.validSourceTypes.split( ',' );\n                _.forEach( objectSetSources, function( source ) {\n                    var relationSources = source.split( '.' );\n                    var sourceType = relationSources[ 1 ];\n                    if( !sourceType2RelationMap[ sourceType ] ) {\n                        sourceType2RelationMap[ sourceType ] = [];\n\n                        var relationObj = {\n                            relation: relationSources[ 0 ]\n                        };\n\n                        sourceType2RelationMap[ sourceType ] = relationObj;\n                    }\n                } );\n            } else if( declViewModel && declViewModel.vmo ) {\n                // fetch valid source types from paste service for vmo inside decl view model\n                let pasteHandler = DragAndDropService.instance.pasteHandler;\n                if( pasteHandler ) {\n                    sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes( declViewModel.vmo );\n                } else if( _cfgLoadPromise ) {\n                    _cfgLoadPromise.then( function() {\n                        pasteHandler = DragAndDropService.instance.pasteHandler;\n                        sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes( declViewModel.vmo );\n                        dropContainer.data( 'validSourceTypes', sourceType2RelationMap );\n                    } );\n                }\n            }\n\n            dropContainer.data( 'validSourceTypes', sourceType2RelationMap );\n\n            if( declViewModel && declViewModel.vmo ) {\n                // add the decl view model VMO as drop uid on the container\n                dropContainer.data( 'dropuid', declViewModel.vmo.uid );\n            }\n        }\n    }\n\n    callbackAPIs.dragStartFn = function( event ) {\n        if( event ) {\n            /**\n             * Determine some hosting related options at the start.\n             */\n            _includeDataTransfer = appCtxSvc.ctx.aw_host_type !== 'ADOBE';\n            _publishHostingEvents = appCtxSvc.ctx.aw_hosting_enabled;\n\n            // D-52947: Prevent issues when text is highlighted as drag starts. Event.target may be text.\n            if( event.target.nodeName === '#text' ) {\n                jqPanelElement.data( 'dragging', false );\n                event.preventDefault();\n            } else {\n                if( _debug_logEventActivity >= 2 ) {\n                    logger.info( 'dragstart: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n                }\n\n                if( _publishHostingEvents ) {\n                    eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                        type: 'dragstart',\n                        event: event\n                    } );\n                }\n\n                var srcElement = _getEventSource( event );\n                var sourceVMOs = callbackAPIs.getElementViewModelObjectFn( srcElement, false );\n\n                if( sourceVMOs && sourceVMOs.length > 0 ) {\n                    if( _debug_logEventActivity >= 1 ) {\n                        logger.info( 'Source Item UID: ' + _getViewModelObjectName( sourceVMOs[ 0 ] ) );\n                    }\n\n                    $( panelElement ).data( 'dragging', true );\n\n                    var containerId = jqPanelElement.data( 'containerId' );\n\n                    if( !containerId ) {\n                        containerId = Date.now();\n                        jqPanelElement.data( 'containerId', containerId );\n                    }\n\n                    exports.processAWInteropAndHosting( sourceVMOs, containerId.toString() );\n                    exports.updateDragImage( event, sourceVMOs.length );\n\n                    if( !_includeDataTransfer ) {\n                        event.dataTransfer.clearData();\n                    }\n                } else {\n                    // No data so there is no reason to let the object be dragged.\n                    jqPanelElement.data( 'dragging', false );\n                    event.preventDefault();\n                }\n            }\n        }\n    };\n\n    callbackAPIs.dragEndFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragend: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            var element = _getDragElement( event );\n\n            if( element ) {\n                var dragImage = element.getElementsByClassName( 'aw-widgets-multidragimage' )[ 0 ];\n\n                if( dragImage ) {\n                    element.style.position = '';\n                    dragImage.parentNode.removeChild( dragImage );\n                }\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragend',\n                    event: event\n                } );\n            }\n\n            jqPanelElement.data( 'dragging', false );\n        }\n    };\n\n    callbackAPIs.dragOverFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 3 ) {\n                logger.info( 'dragover: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragover',\n                    event: event\n                } );\n            }\n\n            event.stopPropagation();\n            exports.processDragOver( event, false );\n        }\n    };\n\n    callbackAPIs.dragEnterFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragenter: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragenter',\n                    event: event\n                } );\n            }\n            event.preventDefault();\n            event.stopPropagation();\n\n            var target = _findDropTargetElement( event )[ 0 ];\n            if( !target ) {\n                return;\n            }\n\n            if( exports.isValidObjectToDrop( event ) ) {\n                var targetVMOs = callbackAPIs.getElementViewModelObjectFn( target, true );\n\n                if( targetVMOs && targetVMOs.length > 0 ) {\n                    if( _debug_logEventActivity >= 1 ) {\n                        logger.info( 'Target Item Name: ' + _getViewModelObjectName( targetVMOs[ 0 ] ) );\n                    }\n\n                    var debounceProcessDragEnter = _.debounce( exports.processDragEnter, 100 );\n                    debounceProcessDragEnter( event, targetVMOs[ 0 ] );\n                }\n            }\n        }\n    };\n\n    callbackAPIs.dragLeaveFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragleave: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragleave',\n                    event: event\n                } );\n            }\n\n            var debounceProcessDragLeave = _.debounce( exports.processDragLeave, 100 );\n\n            debounceProcessDragLeave( event );\n        }\n    };\n\n    callbackAPIs.dropFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'drop: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'drop',\n                    event: event\n                } );\n            }\n\n            jqPanelElement.data( 'dragging', false );\n\n            exports.processDrop( event, callbackAPIs );\n        }\n    };\n\n    panelElement.addEventListener( 'dragstart', callbackAPIs.dragStartFn );\n    panelElement.addEventListener( 'dragend', callbackAPIs.dragEndFn );\n    panelElement.addEventListener( 'dragover', callbackAPIs.dragOverFn );\n    panelElement.addEventListener( 'dragenter', callbackAPIs.dragEnterFn );\n    panelElement.addEventListener( 'dragleave', callbackAPIs.dragLeaveFn );\n    panelElement.addEventListener( 'drop', callbackAPIs.dropFn );\n};\n\nexport let dragLeaveEventOnGlobalWindow = function( event ) {\n    processDragLeaveGlobal( event );\n    if( exports.dataTransferContainsFiles( event ) ) { //\n        _clearCachedData();\n    }\n};\n\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {ViewModelObject} targetVMO - The ViewModelObject associated with the given event's 'target' DOM\n *            Element.\n */\nexport let processDragEnter = function( event, targetVMO ) {\n    /**\n     * Look 'up' the DOM Element tree (starting at the given event's 'target') looking for the 1st 'droppable'\n     * element (i.e. the 'drop container').\n     */\n    var currElement = _findDropTargetElement( event )[ 0 ];\n    _setValidSourceTypesOnTarget( currElement, targetVMO );\n    event.preventDefault();\n};\n\nexport let dragEndEventOnGlobalWindow = function( event ) {\n    processDragLeaveGlobal( event );\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nexport let tearDownDragAndDrop = function( panelElement, callbackAPIs ) {\n    if( callbackAPIs.dragStartFn ) {\n        panelElement.removeEventListener( 'dragstart', callbackAPIs.dragStartFn );\n        panelElement.removeEventListener( 'dragend', callbackAPIs.dragEndFn );\n        panelElement.removeEventListener( 'dragover', callbackAPIs.dragOverFn );\n        panelElement.removeEventListener( 'dragenter', callbackAPIs.dragEnterFn );\n        panelElement.removeEventListener( 'dragleave', callbackAPIs.dragLeaveFn );\n        panelElement.removeEventListener( 'drop', callbackAPIs.dropFn );\n\n        callbackAPIs.dragStartFn = null;\n        callbackAPIs.dragEndFn = null;\n        callbackAPIs.dragOverFn = null;\n        callbackAPIs.dragEnterFn = null;\n        callbackAPIs.dragLeaveFn = null;\n        callbackAPIs.dropFn = null;\n    }\n};\n\n/**\n * Update the drag image for the DragEvent based on the number of objects being dragged.\n *\n * @param {DragEvent} event - The DragEvent to set the image on.\n *\n * @param {Number} count - The number of objects being dragged\n */\nexport let updateDragImage = function( event, count ) {\n    /**\n     * Internet Explorer doesn't support setDragImage at all (and some 'hosts' do not want 'dataTransfer').\n     * <P>\n     * See: http://mereskin.github.io/dnd/\n     */\n    if( !browserUtils.isIE && _includeDataTransfer ) {\n        /**\n         * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n         * should be resolved after moving the list view to a flex display.\n         */\n        var dragImage;\n\n        if( _isNxWebBrowser() ) {\n            dragImage = _getFirstChildImage( event.target );\n        } else if( count > 1 ) {\n            dragImage = _getMultiDragImage( event, count );\n        } else {\n            dragImage = _getDragElement( event, 1 );\n        }\n\n        if( dragImage ) {\n            event.dataTransfer.setDragImage( dragImage, 0, 0 );\n        }\n    }\n};\n\n/**\n * Return the target model object for given UID\n *\n * @param {String} uid - UID of the modelObject on which source objects are dragged\n * @return {Object} Modelobject on which source objects are dragged\n */\nexport let getTargetObjectByUid = function( uid ) {\n    return cdm.getObject( uid );\n};\n\n/**\n * Return an array of viewModelObjects that contains all currently selected viewModelObjects if the given UID is\n * contained in the set of selected viewModelObjects.\n *\n * @param {Object} dataProvider - data provider\n * @param {String} dragUID - UID of the modelObject being dragged.\n * @return {Array} array of viewModelObjects that are being dragged.\n */\nexport let getSourceObjects = function( dataProvider, dragUID ) {\n    var sourceObjs = [];\n    if( !dataProvider ) {\n        return sourceObjs;\n    }\n\n    var selectObjects = dataProvider.getSelectedObjects();\n    /**\n     * Check if the given UID is in the current set of selected objects.\n     */\n    var found = false;\n\n    if( selectObjects && selectObjects.length > 0 ) {\n        // eslint-disable-next-line consistent-return\n        _.forEach( selectObjects, function( selObj ) {\n            if( selObj.uid === dragUID ) {\n                found = true;\n                return false;\n            }\n        } );\n    }\n\n    if( found ) {\n        sourceObjs = _.clone( selectObjects );\n    }\n\n    return sourceObjs;\n};\n\n/**\n * Look for support of the 'files' in the 'dataTranfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'files' property is found in the 'dataTransfer' property of the event.\n */\nexport let dataTransferContainsFiles = function( event ) {\n    if( event.dataTransfer ) {\n        var types = event.dataTransfer.types;\n\n        if( types ) {\n            for( var i = 0; i < types.length; ++i ) {\n                if( types[ i ] === 'Files' ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * Look for support of the 'urls' in the 'dataTransfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'text/html' property is found in the 'dataTransfer' property of the event.\n */\nexport let dataTransferContainsURLs = function( event ) {\n    if( event.dataTransfer ) {\n        var types = event.dataTransfer.types;\n        if( types ) {\n            for( var i = 0; i < types.length; ++i ) {\n                if( types[ i ] === 'text/html' ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * @param {DragEvent} event - The event to extract the files types from the 'dataTransfer' property.\n *\n * @return {StringArray} The set of unique file types.\n */\nexport let getDataTransferFileTypes = function( event ) {\n    var dtTypes = [];\n\n    if( event.dataTransfer.items ) {\n        var itemObjs = event.dataTransfer.items;\n\n        if( itemObjs ) {\n            for( var i = 0; i < itemObjs.length; i++ ) {\n                var fileExt = _getDataTransferType( itemObjs[ i ].type );\n\n                if( fileExt && dtTypes.indexOf( fileExt ) === -1 ) {\n                    dtTypes.push( fileExt );\n                }\n            }\n        }\n    }\n\n    return dtTypes;\n};\n\n/**\n * Returns underlying Object for the given 'source' type.\n *\n * @param {String} targetUID - The UID of the IModelObject that will be the dropped onto (i.e. the data\n *            'target').\n *\n * @param {StringArray} fileTypes - The array with the set of unique file types.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\nexport let getDataTransferSourceTypes = function( targetUID, fileTypes ) {\n    var targetObject = cdm.getObject( targetUID );\n\n    var request = {\n        parent: targetObject,\n        fileExtensions: fileTypes\n    };\n\n    return soaSvc.postUnchecked( 'Internal-AWS2-2015-10-DataManagement', 'getDatasetTypesWithDefaultRelation',\n        request ).then(\n        function( response ) {\n            if( response.partialErrors || response.PartialErrors || response.ServiceData &&\n                response.ServiceData.partialErrors ) {\n                return [];\n            }\n\n            var dsTypes = [];\n\n            var output = response.output;\n\n            if( output ) {\n                for( var i = 0; i < output.length; i++ ) {\n                    var dsInfos = output[ i ].datasetTypesWithDefaultRelInfo;\n\n                    if( dsInfos ) {\n                        const j = 0;\n                        var dsInfo = dsInfos[ j ];\n                        var dsUid = dsInfo.datasetType.uid;\n\n                        var dsType = cdm.getObject( dsUid );\n\n                        var type = dsType.props.object_string.dbValues[ 0 ];\n\n                        dsTypes.push( type );\n                    }\n                }\n            }\n\n            return soaSvc.ensureModelTypesLoaded( dsTypes ).then( function() {\n                return dsTypes;\n            } );\n        },\n        function( e ) {\n            logger.trace( e );\n            return [];\n        } );\n};\n\n/**\n * Set a callback function to use to encode 'source' objects in support of hosting.\n *\n * @param {Function} callBackFn - Function used to create InteropObjectRefs that are added to the information\n *            carried for 'source' objects in dragEvents.\n */\nexport let setCreateInteropObjectRef = function( callBackFn ) {\n    _createInteropObjectRefFn = callBackFn;\n};\n\n/**\n * Publish a 'drop' topic on the 'paste' channel of the Native JS 'eventBus' with the given data.\n *\n * @param {ObjectArray} pasteInput - An array of objects that maps a unique 'relationType' to the array of\n *            'sourceObjects' {@link IModelObject} s that should be pasted onto the 'targetObject' with that\n *            'relationType'.\n */\nexport let publishDropEvent = function( pasteInput ) {\n    eventBus.publishOnChannel( {\n        channel: 'paste',\n        topic: 'drop',\n        data: {\n            pasteInput: pasteInput\n        }\n    } );\n};\n\nconst _globalDragEnterAndOver = ( event ) => {\n    exports.processDragOver( event, true );\n};\n\nexport let registerEvents = function() {\n    // LCS-148724 , Adding listeners to global area i.e the area outside panelElement of setupDragAndDrop() function\n    document.body.addEventListener( 'dragenter', function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        if( !_isDragWithinApplicableValidContainer( event ) || _isDragOverChooseOrDropFileContainer( event ) ) {\n            // below check is to avoid global dragenter events in turn flickering highlight when within a table or list\n            if( !_isDragWithinTableContainer( event ) && !_isDragWithinCellListContainer( event ) ) {\n                if( _debug_logEventActivity >= 1 ) {\n                    logger.info( 'GLOBAL DRAG ENTER EVENT, DRAG NOT WITHIN A TABLE, NOT ALLOWED cursor should be shown => tag name :' + event.target.tagName );\n                }\n                _setDropEffect( event, 'none' ); // to avoid 'Copy' cursor feedback when file just enters the page\n                _globalDragEnterAndOver( event );\n            } else {\n                if( _debug_logEventActivity >= 1 ) {\n                    logger.info( 'GLOBAL DRAG ENTER EVENT, DRAG WITHIN A TABLE, COPY cursor should be shown => tag name :' + event.target.tagName );\n                }\n                _setDropEffect( event, 'copy' );\n            }\n        }\n    } );\n    document.body.addEventListener( 'dragover', function( event ) {\n        if( !_isDragWithinApplicableValidContainer( event ) || _isDragOverChooseOrDropFileContainer( event ) ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( 'GLOBAL DRAG OVER EVENT ' );\n            }\n            _globalDragEnterAndOver( event );\n        }\n    } );\n    document.body.addEventListener( 'dragleave', function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info(\n                'GLOBAL DRAG LEAVE EVENT, Object either dragged outside the global window OR over an applicable valid container on the page OR over an applicable invalid container on the page'\n            );\n        }\n        if( _isDragCancelled( event ) ) {\n            isGlobalHighlightPublished = false;\n            exports.dragLeaveEventOnGlobalWindow( event );\n        }\n    } );\n    document.body.addEventListener( 'dragend', function( event ) {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( 'GLOBAL DRAG END EVENT ' );\n        }\n        isGlobalHighlightPublished = false;\n        exports.dragEndEventOnGlobalWindow( event );\n    } );\n};\n\nexport const disableDragAndDrop = ( panelElement ) => {\n    const stopEventBubbling = ( event ) => {\n        event.stopPropagation();\n    };\n\n    const setDropEffectNone = ( event ) => {\n        stopEventBubbling( event );\n        event.dataTransfer.dropEffect = 'none';\n    };\n\n    panelElement.addEventListener( 'dragover', setDropEffectNone );\n    panelElement.addEventListener( 'dragenter', stopEventBubbling );\n    panelElement.addEventListener( 'dragleave', stopEventBubbling );\n    panelElement.addEventListener( 'drop', stopEventBubbling );\n};\n\nexports = {\n    disableDragAndDrop,\n    addDragDataToDragEvent,\n    getCachedSourceUids,\n    isValidObjectToDrop,\n    processAWInteropAndHosting,\n    processDragEnd,\n    processDragLeave,\n    processDragLeaveGlobal,\n    processDrop,\n    setEffectAllowed,\n    setupDragAndDrop,\n    dragLeaveEventOnGlobalWindow,\n    dragEndEventOnGlobalWindow,\n    tearDownDragAndDrop,\n    updateDragImage,\n    getTargetObjectByUid,\n    getSourceObjects,\n    dataTransferContainsFiles,\n    dataTransferContainsURLs,\n    getDataTransferFileTypes,\n    getDataTransferSourceTypes,\n    setCreateInteropObjectRef,\n    publishDropEvent,\n    registerEvents,\n    processDragOver,\n    processDragEnter\n};\nexport default exports;\n\n/*\n * Register the global drag and drop events only for AW.\n */\nif( appCtxSvc.ctx && appCtxSvc.ctx.tcSessionData ) {\n    //registerEvents();\n}\n"]},"metadata":{},"sourceType":"module"}