{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/* eslint-env es6 */ /**\n * This utility module provides low-level support for JS Injection.\n *\n * NOTE: better to install it in bootstrap step\n *\n * @module js/splmStatsJsService\n */let _procs=[];let _enabled=false;let _setTimeout=null;let _appendChildFn=null;/**\n * install JS service\n */export const install=function(){if(!_enabled){_setTimeout=window.setTimeout;window.setTimeout=function(){const _realFunc=arguments[0];arguments[0]=wrapFunction(null,_realFunc);return _setTimeout.apply(this,arguments);};// try to fix webpack script load issue\n_appendChildFn=document.head.appendChild;document.head.appendChild=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(enabled()&&_procs.length>0){const elem=args[0];// restirct it to only onload script exist\nif(elem.tagName==='SCRIPT'&&elem.src&&elem.onload){// wrap onLoad script\nconst _onloadFn=elem.onload;const _onerrorFn=elem.onerror||(()=>{});elem.onload=function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}if(enabled()&&_procs.length>0){const endTime=window.performance.now();// console.log( `Done: ${elem.src}` );\nconst res=_onloadFn.apply(null,args);try{_procs.forEach(function(proc){proc.done({name:name,startTime:endTime,endTime:endTime});});}catch(ex){// TODO: Do nothing for now, will fill it up before EOD 1905\n}return res;}return _onloadFn.apply(null,args);};elem.onerror=function(){for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}if(enabled()&&_procs.length>0){const endTime=window.performance.now();// console.log( `Done: ${elem.src}` );\nconst res=_onerrorFn.apply(null,args);try{_procs.forEach(function(proc){proc.done({name:name,startTime:endTime,endTime:endTime});});}catch(ex){// TODO: Do nothing for now, will fill it up before EOD 1905\n}return res;}return _onerrorFn.apply(null,args);};try{_procs.forEach(function(proc){proc.start();});}catch(ex){// TODO: Do nothing for now, will fill it up before EOD 1905\n}return _appendChildFn.apply(document.head,args);}}return _appendChildFn.apply(document.head,args);};_enabled=true;}};/**\n * Wrapping JS function with plStats injection\n *\n * @param {Object} thisArg - Explicit passing of the \"this\" object for whatever function we are replacing\n * @param {Function} func - Function we are replacing\n * @param {String} name - the name (if any) of the function/object we are replacing\n *\n * @returns {Object} result - The result of whatever function we are replacing. Must be careful to return this value for functions (not setTimeout) that\n * are expecting a return value\n */export const wrapFunction=function(thisArg,func,name){return function _splmStatsJsWrapperFunction(){if(!func||!func.apply){return undefined;}if(enabled()&&_procs.length>0){const startTime=window.performance.now();try{_procs.forEach(function(proc){proc.start();});}catch(ex){// TODO: Do nothing for now, will fill it up before EOD 1905\n}const res=func.apply(thisArg,arguments);const endTime=window.performance.now();try{_procs.forEach(function(proc){proc.done({name:name,startTime:startTime,endTime:endTime});});}catch(ex){// TODO: Do nothing for now, will fill it up before EOD 1905\n}return res;}return func.apply(thisArg,arguments);};};/**\n * @returns {Boolean} Has JSService already underwent wrapping? If so we dont want to do it again\n */export const enabled=function(){return _enabled;};/**\n * Angular caches setTimeout after it is initialized so this doesn't do anything\n */export const uninstall=function(){if(_enabled){window.setTimeout=_setTimeout;document.head.appendChild=_appendChildFn;_setTimeout=null;_enabled=false;}};export const addProc=function(proc){_procs.push(proc);};export const removeProc=function(proc){_procs=_procs.filter(procObj=>proc!==procObj);};export default{install,wrapFunction,enabled,uninstall,addProc,removeProc};","map":null,"metadata":{},"sourceType":"module"}