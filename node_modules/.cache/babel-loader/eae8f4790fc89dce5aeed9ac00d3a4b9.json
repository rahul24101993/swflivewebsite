{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Service to manage native contributions using a registry object generated at build time. Uses ES6 import to load pieces\n * defined in the registry on demand. Also defines the {@link NgServices.contributionService} which is accessible\n * through injection.\n *\n * @module js/contribution.service\n */import AwPromiseService from'js/awPromiseService';import cfgSvc2 from'js/configurationService';import _ from'lodash';import Debug from'debug';import logger from'js/logger';import{afxDynamicImport}from'js/moduleLoader';var trace=new Debug('contributionService');let exports={};/**\n * Load the set of contributions that are mapped to the given key string.\n *\n * Each contribution should return a function. The function will be called with the key of the contribution\n * and a promise to resolve with the object. With this method contributions have the ability to get the\n * contribution dynamically instead of returning a static object.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @return {Promise} A promise containing the objects that have been contributed.\n */export let loadContributions=function(key){return cfgSvc2.getCfg('contributions').then(function(contributionProviders){if(contributionProviders[key]){// return AwPromiseService.instance.all( modules ).then( values => values );\nreturn AwPromiseService.instance(function(resolve){// Allow module loader to manage the caching / registry\ntrace('Loading contributions',key);afxDynamicImport(contributionProviders[key],function handleLoadedContribution(){trace('Contribution load complete',key);// Create a promise for each contribution function\nvar promises=[];// Number of arguments is not known so have parse manually as array\n_.forEach(Array.prototype.slice.call(arguments),function(arg,index){if(_.isFunction(arg)){var deferredLp=AwPromiseService.instance.defer();arg(key,deferredLp);promises.push(deferredLp.promise);}else{logger.error(contributionProviders[key][index]+' did not return a contribution function');}});// And resolve the main promise once all are resolved\nresolve(AwPromiseService.instance.all(promises));});});}logger.trace(key+' not found in contribution registry');return[];});};/**\n * Support a callback based pattern when angular is not loaded. This should only be used before the angular start.\n *\n * Async contributions are not supported with this pattern, so any contributions that support this method must\n * return the value directly.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @param {Function} callback - A callback to call with the newly loaded contributions\n */export let requireBeforeAppInitialize=function(key,callback){// The following fallback is to support the bootstrap usage.\nvar contributionProviders=cfgSvc2.getCfgCached('contributions');if(contributionProviders[key]){// Allow module loader to manage the caching / registry\nafxDynamicImport(contributionProviders[key],function(){var result=[];// Number of arguments is not known so have parse manually as array\n_.forEach(Array.prototype.slice.call(arguments),function(arg,index){if(_.isFunction(arg)){result.push(arg(key));}else{logger.error(contributionProviders[key][index]+' did not return a contribution function');}});callback(result);});}else{logger.trace(key+' not found in contribution registry');callback([]);}};exports={loadContributions,requireBeforeAppInitialize};export default exports;","map":null,"metadata":{},"sourceType":"module"}