{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Defines {@link wcagService} which provides services for accessibility related functionalities\n *\n * @module js/wcagService\n */import $ from'jquery';import localeSvc from'js/localeService';import popupUtils from'js/popupUtils';import logger from'js/logger';import _ from'lodash';import domUtils from'js/domUtils';let exports={};let dom=domUtils.DOMAPIs;let groupCmdParent=null;let focusableCandidates=['button:not(.disabled), [href]:not(.disabled), input:not(.disabled), select:not(.disabled), textarea:not(.disabled), [tabindex]:not(.disabled)','summary:not(.disabled)'];const ENTER_KEY_CODE_VALUE='Enter';const SPACE_KEY_CODE_VALUE='Space';const MAIN_SELECTOR='main.aw-layout-workareaMain';/**\n * Helper function to update aria-label on targetelement located by childlocator\n * @param {Object} containerDOMElement - The element which contains landmark element\n * @param {string} childLocator - string identifying landmakr element within containerDOMElement\n * @param {string} messageFile Name of file containing messages\n */export let updateArialabel=function(containerDOMElement,childLocator,messageFile){let targetElement=null;if(containerDOMElement===null){targetElement=$(childLocator).length>0?$(childLocator)[0]:null;}else if($(containerDOMElement).find(childLocator).length>0){targetElement=$(containerDOMElement).find(childLocator)[0];}else if(childLocator.length===0){targetElement=containerDOMElement;}if(targetElement!==null){let ariaLabelKey=targetElement.getAttribute('aria-label').substring(5);localeSvc.getLocalizedText(messageFile,ariaLabelKey).then(function(localizedVal){targetElement.setAttribute('aria-label',localizedVal);});}};/**\n * This API is a helper function to add aria-label to duplicate 'main' landmarks.\n *\n */export let updateArialabelForDuplicateLandmarks=function(){let mainEls=document.querySelectorAll(MAIN_SELECTOR);let cnt=1;// below check is to ensure we do not have this attribute set in case there is just one\n// instance of the landmark on a page\nif(mainEls&&mainEls.length!==1){for(let i=0;i<mainEls.length;i++){localeSvc.getLocalizedText('UIElementsMessages','mainLabel').then(function(localizedVal){let ariaLabelledByAttr=document.createAttribute('aria-label');ariaLabelledByAttr.value=localizedVal+cnt;cnt++;mainEls[i].setAttributeNode(ariaLabelledByAttr);});}}};/**\n * This API is a helper function to add missing button in form to avoid SiteImprove violations.\n *\n */export let updateMissingButtonInForm=function(containerDOMElement){if(containerDOMElement){let BUTTON_CLASS='aw-hide-form-button';let BUTTON_EL='button';let formElem=null;if(containerDOMElement.tagName&&containerDOMElement.tagName==='FORM'){formElem=containerDOMElement;}else{formElem=containerDOMElement.querySelector('form');}// intent is to check for the presence of dummy hidden disabled button. Not necessary to check the\n// presence of an already existing functional button within the form since even if one or more\n// functional buttons exist within the form , it does not cause any functional failures because\n// the dummy button is disabled and hence not submit-able.\nif(!formElem.querySelector(BUTTON_EL+'.'+BUTTON_CLASS)){let buttonNode=document.createElement(BUTTON_EL);buttonNode.type='submit';buttonNode.classList.add(BUTTON_CLASS);buttonNode.disabled=true;buttonNode.setAttribute('aria-hidden',true);formElem.appendChild(buttonNode);}}};/**\n * This API is a helper function to find all the focusable children of a DOMElement.\n *\n * @param {DOMElement} containerElement the container to look for focusable children\n * @return {NodeList} all the focusable children\n */export let findFocusableChildren=function(containerElement){return containerElement.querySelectorAll(focusableCandidates);};/**\n * Finds the next focusable child in the containing element if one child is already focused.\n * Otherwise, can send first focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnFirstChildIfNone whether to return first focusable child if no next child found\n * @return {Node} next focusable child, or first focusable child if none found (option)\n */export let findNextFocusableChild=function(containerElement,returnFirstChildIfNone){let nextFocusableChild=null;const focusableElements=findFocusableChildren(containerElement);if(focusableElements&&focusableElements.length){for(let i=0;i<focusableElements.length;i++){if(focusableElements[i]===document.activeElement){if(i+1<focusableElements.length){nextFocusableChild=focusableElements[i+1];}break;}}if(!nextFocusableChild&&returnFirstChildIfNone){nextFocusableChild=focusableElements[0];}}return nextFocusableChild;};/**\n * Finds the previous focusable child in the containing element if one child is already focused.\n * Otherwise, can send last focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnLastChildIfNone whether to return last focusable child if no previous child found\n * @return {Node} previous focusable child, or last focusable child if none found (option)\n */export let findPreviousFocusableChild=function(containerElement,returnLastChildIfNone){let previousFocusableChild=null;const focusableElements=findFocusableChildren(containerElement);if(focusableElements&&focusableElements.length){for(let i=0;i<focusableElements.length;i++){if(focusableElements[i]===document.activeElement){if(i>0){previousFocusableChild=focusableElements[i-1];}break;}}if(!previousFocusableChild&&returnLastChildIfNone){previousFocusableChild=focusableElements[focusableElements.length-1];}}return previousFocusableChild;};export let setParentOfGroupCmds=function(referenceElement){groupCmdParent=referenceElement;};export let getParentOfGroupCmds=function(){return groupCmdParent;};let isNotyMsgPresentInDOM=function(notyMessageContainer){return document.body.contains(notyMessageContainer);};let isNotyMsgNotfocussed=function(focussableElements){return document.activeElement!==focussableElements[0];};let renderFocusToNotyMsg=function(){let notyMsgContainerId='noty_bottom_layout_container';let notyMessageContainer=document.getElementById(notyMsgContainerId);if(isNotyMsgPresentInDOM(notyMessageContainer)){let focussableElements=findFocusableChildren(notyMessageContainer);if(isNotyMsgNotfocussed(focussableElements)){focussableElements[0].focus();}}};export let skipToFirstFocusableElement=function(container,checkActiveFocusInContainer,selectedElementCSS){// If there is already focused element in container, donot skip to focusbale ele\nlet currentFocusedEle=document.activeElement;if(container===undefined||container===null||checkActiveFocusInContainer!==false&&container.contains(currentFocusedEle)){return true;}let elementLoading=$(container).find('.aw-element-loading, .aw-jswidgets-loading');if(elementLoading.length===0){// If there is no element in loading state, then only start focus\n//Try focus on first selected element\nif(selectedElementCSS&&selectedElementCSS.length>0){let elementToFocus=$(container).find(selectedElementCSS);if(elementToFocus.length>0){elementToFocus[0].focus();renderFocusToNotyMsg();if(document.activeElement===elementToFocus[0]){//Focus successful\nreturn true;}}}let focusable=findFocusableChildren(container);if(focusable&&focusable.length>0){for(let focusableEle of focusable){if($(focusableEle).is(':visible')){focusableEle.focus();renderFocusToNotyMsg();return true;}}}else{//Check if element it self is focusable\ncontainer.focus();renderFocusToNotyMsg();if(document.activeElement===container){//Focus successful\nreturn true;}}}return false;};let trapFocus=panelRef=>event=>{let{panelEl:element,options}=panelRef;// apply exclude cases- LCS-443560 - Commands in overflow do not process events after SOA completion\nif(popupUtils.checkIgnore(options,event.target)){return;}// If new focus element is NOT in current popup element, focus on reference and hide\nif(!element.contains(event.target)){// only do this when tab move to the last element\nif(event.target.id&&event.target.id.includes(element.id)){skipToFirstFocusableElement(panelRef.options.reference,panelRef.options.checkActiveFocusInContainer);// do not hide an element if the api not available, for example noty_msg should not be hidden\n// once focus reaches the sentinel\nif(panelRef.options.api){panelRef.options.api.hide(panelRef);}}}};// Bracket the dialog node with two invisible, focusable nodes.\n// While this dialog is open, we use these to make sure that focus never\n// leaves the document even if dialogNode is the first or last node.\nlet createSentinel=(element,id)=>{let preDiv=document.createElement('div');let preNode=element.parentNode.insertBefore(preDiv,element);preNode.tabIndex=0;preNode.id=\"pre-\".concat(id);let postDiv=document.createElement('div');let postNode=element.parentNode.insertBefore(postDiv,element.nextSibling);postNode.tabIndex=0;postNode.id=\"post-\".concat(id);return()=>{if(element.parentNode){//check for presence before removing\nif(_.includes(element.parentNode.childNodes,preNode)){element.parentNode.removeChild(preNode);}if(_.includes(element.parentNode.childNodes,postNode)){element.parentNode.removeChild(postNode);}}};};let configureFocusListener=panelRef=>{const focusHandler=trapFocus(panelRef);document.addEventListener('focus',focusHandler,true);return()=>{document.removeEventListener('focus',focusHandler,true);};};export let configureAutoFocus=function(dialogNode,popupRef){const removeHandlers=[];const{reference,selectedElementCSS}=popupRef.options;removeHandlers.push(createSentinel(dialogNode,popupRef.id));removeHandlers.push(configureFocusListener(popupRef));// honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.\nconst onClose=()=>{if(reference){skipToFirstFocusableElement(reference);setParentOfGroupCmds(reference);}};focusFirstDescendantWithDelay(dialogNode,selectedElementCSS);return{removeHandlers,onClose};};export let focusFirstDescendantWithDelay=function(element,selectedElementCSS){let timer=setInterval(()=>{// if not existed anymore or element is already rendered\nif(!element){clearInterval(timer);return;}// still available\nif(element.childNodes){for(var i=0;i<element.childNodes.length;i++){var child=element.childNodes[i];if(child.tagName&&skipToFirstFocusableElement(child,null,selectedElementCSS)){clearInterval(timer);return true;}}}},50);// clean resource when reach max limit\nsetTimeout(()=>clearInterval(timer),5000);};/**\n * Helper function to add 'Skip to Main' functionality in order to support\n * enter/click option on 'Skip to Main' Bypass block\n */export let initializeSkipToMain=function(){let mainElement=document.querySelector(MAIN_SELECTOR);if(mainElement){let focusable=findFocusableChildren(mainElement);if(focusable&&focusable.length>0){let firstFocusable=focusable[0];firstFocusable.focus();}}else{logger.error('missing main landmark');}};/**\n *  Helper function to apply/unapply focus to 'main' landmark when\n *  a page is focussed for the first time using tab click and when\n *  Skip to main link gets focussed\n */export let applyFocusOnMain=function(){let skipToMainLinkElem=null;let mainElement=document.querySelector(MAIN_SELECTOR);skipToMainLinkElem=document.querySelector('a.aw-skip-to-main');if(skipToMainLinkElem!==null&&mainElement!==null){dom.on(skipToMainLinkElem,'focus',()=>{mainElement.classList.add('aw-apply-focus-to-main');});dom.on(skipToMainLinkElem,'blur',()=>{mainElement.classList.remove('aw-apply-focus-to-main');});}};/**\n * get key name - supports modern browsers and IE11\n *\n * @param {Object} event keyboard event object ($event)\n * @returns {String} key name\n */export let getKeyName=function(event){// change space key to string literal 'Space'\nreturn event.key===' '?SPACE_KEY_CODE_VALUE:event.key;};/**\n * check if the keyboard event is equivalent to a mouse click\n *\n * @param {Object} event keyboard event object ($event)\n * @param {boolean} ignoreSpacebar - if the element accepts space as a valid key stroke eg: lov\n * @returns {boolean} true if valid synthetic 'click' pressed\n */let isValidKeyPress=function(event,ignoreSpacebar){let keyPressed=getKeyName(event);if(ignoreSpacebar){if(keyPressed===ENTER_KEY_CODE_VALUE){return true;}}else{// Default space bar press scrolls the page. Preventing that behavior\nif(keyPressed===SPACE_KEY_CODE_VALUE){event.preventDefault();}// Check if keyboard event is equivalent to a mouse click\nif(keyPressed===ENTER_KEY_CODE_VALUE||keyPressed===SPACE_KEY_CODE_VALUE){return true;}}return false;};export let handleMoveUpOrDown=(event,container)=>{let keyPressed=getKeyName(event);if(keyPressed==='ArrowUp'||keyPressed==='ArrowDown'){if(event.key==='ArrowUp'){event.preventDefault();const nextChildUp=findPreviousFocusableChild(container,true);nextChildUp&&nextChildUp.focus();}else{event.preventDefault();const nextChildDown=findNextFocusableChild(container,true);nextChildDown&&nextChildDown.focus();}}};// When Element is removed from DOM/ mouse clicked, then focus is lost and then\n// on next press of tab, where should be focus starting point- we have to manually manage focus\n// In order to do this, we add 'aw-focus-startpoint' CSS to element that will be focus starting\n// point on next press of tab key press -check solution below\n//https://sarahmhigley.com/writing/focus-navigation-start-point/#assistive-tech-support\nexport let updateFocusStartPoint=eletoUpdateFocus=>{if(eletoUpdateFocus!==null){//Remove flying focus from any existing elements\n$('.aw-focus-startpoint').removeClass('aw-focus-startpoint');//Update flying focus on\neletoUpdateFocus.classList.add('aw-focus-startpoint');}};/**\n * use this function when you want to programatically focus an element\n * and show the focus style normally reserved for keyboard-mode.\n * @param {Object} elementToFocus - dom element about to get focus\n */export let afxFocusElement=elementToFocus=>{elementToFocus.focus();document.body.classList.add('keyboard');};/**\n * use this function to check if the user is operating in keyboard-mode.\n * This is determined based on the user's most recent action.\n * returns true if from keyboard. 'false' if from mouse.\n * @returns {boolean} true if it is a keyboard event\n */export let areWeInKeyboardMode=()=>{if(document.body.classList.contains('keyboard')){return true;}return false;};exports={updateArialabel,updateArialabelForDuplicateLandmarks,updateMissingButtonInForm,initializeSkipToMain,findFocusableChildren,findNextFocusableChild,findPreviousFocusableChild,skipToFirstFocusableElement,setParentOfGroupCmds,getParentOfGroupCmds,focusFirstDescendantWithDelay,applyFocusOnMain,isValidKeyPress,configureAutoFocus,getKeyName,handleMoveUpOrDown,updateFocusStartPoint,afxFocusElement,areWeInKeyboardMode};export default exports;","map":null,"metadata":{},"sourceType":"module"}