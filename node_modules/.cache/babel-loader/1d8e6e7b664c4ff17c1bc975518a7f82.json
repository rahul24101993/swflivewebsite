{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * @module js/awSPLMTableNativeService\n */import*as eventBus from'js/eventBus';import _ from'lodash';import logger from'js/logger';import arrayUtils from'js/arrayUtils';import splmTableFactory from'js/splmTableFactory';import awTableSvc from'js/awTableService';import resizeObserverSvc from'js/resizeObserver.service';import columnFilterService from'js/awColumnFilterService';import awTableStateSvc from'js/awTableStateService';import uwUtilSvc from'js/uwUtilService';import viewModelObjectService from'js/viewModelObjectService';import splmTableSelectionHelper from'js/splmTableSelectionHelper';import*as cfgSvc from'js/awConfiguration';import declarativeDataCtxService from'js/declarativeDataCtxService';import util from'js/splmTableUtils';export const initializeTable=function(element,viewModelCollection,dataCtxNode,declGridParam,runActionWithViewModel){// revisitme:\n// tstark - leave for refactor\n// - viewModelCollection has no use here.\n// - passing element as ref can save one factor of memory leak.\n// - But the dataCtxNode and declGridParam is too complex, we have viewModel -> data -> dataProvider,\n//   almost impossible to know where the closure is getting hold. The fact I know is by dummy the data,\n//   the symptom will go away\nlet tableCallbacks={};let declGridObj={...declGridParam};const gridid=declGridObj.gridid;const dataProvider=declGridObj.dataProviderInstance;const columnProvider=declGridObj.columnProviderInstance;declarativeDataCtxService.applyScope(dataCtxNode.data,declGridObj.gridOptions,null,dataCtxNode,null);let gridOptions=declGridObj.gridOptions;let declViewModel=dataCtxNode.data;var instanceEventSubcr=[];var tableInstance=null;let tableElem=null;var _previousSelections=[];const tableInstanceCallbacks={};columnProvider.setColumnFilters([]);/**\n      * Refresh the table content by invoking the action to reload first page of data provider\n      */var reloadDataProvider=function(){if(gridid){if(dataProvider&&dataProvider.json&&dataProvider.json.firstPage){delete dataProvider.json.firstPage;}dataProvider.resetDataProvider();/**\n              * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n              * tstark - leave for refactor\n              * Delete firstPage results only on dataProvider reset\n             if( dataProvider && dataProvider.json && dataProvider.json.firstPage ) {\n                 delete dataProvider.json.firstPage;\n             }\n             viewModelSvc.executeCommand( declViewModel, dataProvider, dataCtxNode );\n              */}};if(gridid){var propertyProvider=declViewModel.dataProviders[declGridObj.propertyProvider];if(!columnProvider.sortCallback){columnProvider.sortCallback=function(){reloadDataProvider();};}// Attach enableArrangeMenu to gridOptions because we are not passing grid into splmTable\ngridOptions=gridOptions||{};gridOptions.enableArrangeMenu=declGridObj.enableArrangeMenu;gridOptions.showContextMenu=!_.isNil(declGridObj.showContextMenu)?declGridObj.showContextMenu:gridOptions.showContextMenu;gridOptions.showDecorators=declGridObj.showDecorators;gridOptions.useTree=declGridObj.useTree;// Turn on grid menu if arrange command is enabled, only if not set by grid\nif(gridOptions.enableGridMenu===undefined&&gridOptions.enableArrangeMenu){gridOptions.enableGridMenu=true;}// Turn on XXLARGE header height if enableHeaderIcon is enabled\nif(gridOptions.enableHeaderIcon===true){gridOptions.headerHeight='XXLARGE';}var _loadTreeProperties=function(propertyLoadRequest){var propertyLoadInput=awTableSvc.createPropertyLoadInput([propertyLoadRequest]);return propertyProvider.getProperties(dataCtxNode,propertyLoadInput).then(function(propertyLoadResult){if(dataProvider.topNodeUid){_.forEach(propertyLoadResult.updatedNodes,function(vmo){if(vmo.uid===dataProvider.topNodeUid){// Assign on props doesn't work if it's undefined, doing this for now to make it work.\nif(dataProvider.topTreeNode.props===undefined){dataProvider.topTreeNode.props={};}_.assign(dataProvider.topTreeNode.props,vmo.props);}// Reset edit state since props have loaded\nviewModelObjectService.setEditState(vmo,false);delete vmo.isPropLoading;});if(propertyLoadResult.updatedNodes){tableInstance.refresh();}}if(!propertyLoadResult.columnConfig){// Notify table to refresh if no columnConfig change to reflect new prop values in vmos\ntableInstance.refresh();}else if(propertyLoadResult.columnConfig.columns.length!==dataProvider.cols.length){/** revisitme Shaishav: Can we make the new condition similar to old condition? Will there\n                       * be extra refreshes because of new condition?\n                       * tstark - leave for refactor\n                  //} else if( !_.isEqual( propertyLoadResult.columnConfig.columns, dataProvider.columnConfig.columns ) ) {\n                       */ // LCS-178290 - Redundant refresh in page load\n// Do column Refresh only in the case we have new columnConfig from server\ncolumnProvider.buildDynamicColumns(propertyLoadResult.columnConfig.columns,true).then(()=>{tableInstance.resetColumns();});}if(util.shouldRequestStartEditPropsLoaded(tableElem)){util.requestStartEdit(tableElem);}});};var _loadProps=_.debounce(function(emptyVMOs){/**\n              * Since debounced functions have a slight chance of being fired off after a maxWait and after the\n              * declViewModelhas been destroyed (and before the debounce 'cancel' function is called), we want to\n              * check for that case here.\n              */if(declViewModel.isDestroyed()){return;}/**\n              * Include 'top' node if it does not have 'props' set yet.\n              */if(!dataProvider.topTreeNode.props){var topNodeUid=dataProvider.topTreeNode.uid;var foundTop=false;for(var i=0;i<emptyVMOs.length;i++){if(emptyVMOs[i].uid===topNodeUid){foundTop=true;break;}}if(!foundTop){emptyVMOs.push(dataProvider.topTreeNode);}}// Return if there are no props to load\nif(emptyVMOs.length===0){return;}var columnInfos=[];_.forEach(dataProvider.cols,function(columnInfo){if(!columnInfo.isTreeNavigation){columnInfos.push(columnInfo);}});_.forEach(emptyVMOs,function(vmo){vmo.isPropLoading=true;});var propertyLoadRequest={parentNode:null,childNodes:emptyVMOs,columnInfos:columnInfos};_loadTreeProperties(propertyLoadRequest);},500,{maxWait:10000,trailing:true,leading:false});var initializeProvider=function(dataProvider,columnProvider,passedState){return columnProvider.initialize(passedState).then(function(dynamicColumns){dataProvider.cols=dataProvider.cols?dataProvider.cols:dynamicColumns;/**\n                  * Dont re-initialize DP if it already exists => Doesn't matter if empty table or table with rows\n                  */if(dataProvider.json&&dataProvider.json.firstPage){/**\n                      * revisitme Shaishav: This code should be deleted as we rely on react to reload data\n                      * tstark - leave for refactor\n                      * Delete firstPage results only on dataProvider reset\n                     // If first page but no data loaded in loadedVMObjects, try viewModelSvc executing the dataprovider\n                     if( dataProvider.json.firstPage.length > 0 && dataProvider.viewModelCollection &&\n                         dataProvider.viewModelCollection.loadedVMObjects && dataProvider.viewModelCollection.loadedVMObjects.length === 0 ) {\n                             viewModelSvc.executeCommand( declViewModel, declGrid.dataProvider, $scope );\n                     }\n                     */ // Do Nothing\nreturn null;}return dataProvider.initialize(dataCtxNode).then(function(){if(!dataProvider.cols||dataProvider.cols.length===0){if(!dataProvider.columnConfig){return Promise.reject(new Error('Column config not loaded'));}return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns,true);}return null;});});};tableCallbacks.completeInitialization=()=>{if(dataProvider.columnConfig){dataProvider.initializationComplete='InProgress';return columnProvider.buildDynamicColumns(dataProvider.columnConfig.columns,true).then(()=>{var gridContextDispatcher=dataCtxNode.gridContextDispatcher;if(declGridObj.reusable){gridContextDispatcher=declGridObj.gridContextDispatcher;}tableInstance=splmTableFactory.createTableObject(element,gridid,dataProvider,viewModelCollection,columnProvider,declViewModel,declGridObj.contentFilter,gridOptions,declGridObj.containerheight,gridContextDispatcher,runActionWithViewModel,tableInstanceCallbacks,declGridObj.tableContext,declGridObj.reusable,declGridObj.showCheckBox);tableInstance.showCheckBox=declGridObj.showCheckBox;tableInstance.resetColumns();tableInstance.viewModelCollection=viewModelCollection;tableInstance.refresh();initializeObserver();tableElem=tableInstance.getTableElement();dataProvider.initializationComplete=true;if(declGridObj.containerHeight){tableInstance.updateContainerHeight(declGridObj.containerHeight);}// Event Interface to rerender the table with data currently on the client\ninstanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.clientRefresh',function(){_.defer(function(){tableInstance.showCheckBox=declGridObj.showCheckBox;if(tableElem&&tableElem._tableInstance){tableElem._tableInstance.showCheckBox=declGridObj.showCheckBox;}util.cleanupComponents(element);tableInstance.refresh();});}));});}};tableCallbacks.updateTableColumns=updatedColumns=>{if(updatedColumns&&updatedColumns.length>0){columnProvider.buildDynamicColumns(updatedColumns,true).then(()=>{if(tableInstance!==null){tableInstance.resetColumns();}});}};tableCallbacks.updateContentRowSelection=()=>{tableInstance&&tableInstance.updateContentRowSelection();};tableCallbacks.selectTableColumn=columnDef=>{if(columnDef){splmTableSelectionHelper.selectColumnCells(tableInstance.getTableElement(),columnDef.field);}};tableCallbacks.updateSortDirection=(currentColumnIndex,newColumnIndex,sortDirection)=>{if(newColumnIndex>-1){tableInstance&&tableInstance.updateSortDirection(currentColumnIndex,newColumnIndex,sortDirection);reloadDataProvider();}};tableCallbacks.updateDynamicRowHeight=dynamicRowHeightStatus=>{tableInstance&&tableInstance.updateDynamicRowHeight(dynamicRowHeightStatus);};tableCallbacks.updatePinColumn=(columnDef,isFreezeAction,defaultColumnPinIndex)=>{if(columnDef&&defaultColumnPinIndex>-1){tableInstance&&tableInstance.updatePinColumn(columnDef,isFreezeAction,defaultColumnPinIndex);}};tableCallbacks.hideColumn=columnDef=>{if(columnDef){tableInstance&&tableInstance.hideColumn(columnDef);}};tableCallbacks.columnFilterApplied=columnFilterInfo=>{// viewModel columnProvider needed because columnFilters with be needed by the viewModel action inputs\n// revisitme - Send event to all application listeners, remove when converted\nconst eventData={isInternalTableEvent:true,gridId:gridid,...columnFilterInfo};eventBus.publish('pltable.columnFilterApplied',eventData);const menuService=util.getTableMenuService(tableElem);menuService.ensureAllTableMenusDismissed();if(columnFilterInfo.filters&&columnFilterInfo.filters.length){columnFilterService.setFilters(columnProvider,dataProvider,columnFilterInfo.filters,columnFilterInfo.column);}else if(columnFilterInfo.column){columnFilterService.removeFilter(columnFilterInfo.column,columnProvider,dataProvider);}else{columnFilterService.removeAllFilters(dataProvider,columnProvider);}dataProvider.isColumnFilterApplied=columnFilterService.isColumnFilterApplied(dataProvider);const columnName=columnFilterInfo.column?columnFilterInfo.column.field:null;tableInstance.updateFilterIcons(columnName);reloadDataProvider();};tableCallbacks.editStateUpdated=()=>{const data={dataSource:dataProvider,state:dataProvider._editingState};tableInstance.updateEditState(data);};tableCallbacks.updateEditState=async props=>{if(props&&props.tableContext){if(props.tableContext.startEdit&&props.tableContext.startEdit.value===true){await dataProvider.startEdit(props.dataCtxNode,props.dataCtxNode.data);if(props.tableContext.startEdit.update){props.tableContext.startEdit.update(false);}if(props.tableContext.isBulkEditing&&props.tableContext.isBulkEditing.update){props.tableContext.isBulkEditing.update(true);}}else if(props.tableContext.cancelEdit&&props.tableContext.cancelEdit.value===true){await dataProvider.cancelEdits(props.dataCtxNode,props.dataCtxNode.data);if(props.tableContext.cancelEdit.update){props.tableContext.cancelEdit.update(false);}if(props.tableContext.isBulkEditing&&props.tableContext.isBulkEditing.update){props.tableContext.isBulkEditing.update(false);}}else if(props.tableContext.saveEdit&&props.tableContext.saveEdit.value===true){await dataProvider.saveEdits(props.dataCtxNode,props.dataCtxNode.data);if(props.tableContext.saveEdit.update){props.tableContext.saveEdit.update(false);}if(props.tableContext.isBulkEditing&&props.tableContext.isBulkEditing.update){props.tableContext.isBulkEditing.update(false);}}}};const initializeObserver=()=>{if(resizeObserverSvc.supportsResizeObserver()){const callback=_.debounce(()=>{eventBus.publish(gridid+'.plTable.resizeCheck');},200,{maxWait:10000,trailing:true,leading:false});resizeObserverSvc.observe(element,callback);}};if(gridOptions.useTree===true){instanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.loadProps',function(eventData){_loadProps(eventData.VMOs);}));instanceEventSubcr.push(eventBus.subscribe('primaryWorkarea.reloadTop',function(event){var clearAllStates=!(event&&event.retainAllStates);if(clearAllStates){awTableStateSvc.clearAllStates(declViewModel,gridid);}/*\n                  * delete firstPage results if any before re-initializing dataProvider\n                  */if(dataProvider.json.firstPage){delete dataProvider.json.firstPage;}dataProvider.initialize(dataCtxNode);}));const toggleTreeNode=function(node){if(!node.loadingStatus){node.loadingStatus=true;tableInstance.updateTreeCellIcon(node);// get the current copy of data\nObject.assign(dataCtxNode.data.data,dataCtxNode.data.getData());if(node.isExpanded===true){tableInstance.setNodeExpansionInProgress(true);node._expandRequested=true;var preExpandVMObjectsLength=dataProvider.viewModelCollection.loadedVMObjects.length;dataProvider.expandObject(dataCtxNode,node).then(function(updatedViewModelCollection){// LCS-180794: If Expand did not return any new objects or\n//if node has previous expansion state and dataProvider.cacheCollapse=true which means it didn't get new objects from server,\n// continue updating the rest of the table\ntableInstance.setNodeExpansionInProgress(false);if(preExpandVMObjectsLength===updatedViewModelCollection.loadedVMObjects.length){delete node.loadingStatus;tableInstance.refresh();}//view model collection is updated so update table with new set of VMOs.\ndataProvider.update(updatedViewModelCollection.loadedVMObjects);}).finally(function(){// Make sure even when errored that the expansion in progress is set to false\ntableInstance.setNodeExpansionInProgress(false);//ensure properties are loaded after expansion\n// If any VMOs need props to be loaded, we will call for the props to be loaded and not\n// render the rows. The row rendering will then occur once they props have been loaded.\ntableInstance.loadMissingProps();delete node.loadingStatus;delete node._expandRequested;tableInstance.updateTreeCellIcon(node);tableElem._tableInstance.focusTreeNodeExpandAfterRender=node;if(util.shouldRequestStartEditTreeExpand(tableElem,node,propertyProvider)){util.requestStartEdit(tableElem);}});awTableStateSvc.saveRowExpanded(declViewModel,gridid,node);}else{dataProvider.collapseObject(dataCtxNode,node).then(function(updatedViewModelCollection){dataProvider.update(updatedViewModelCollection.loadedVMObjects);if(preExpandVMObjectsLength===updatedViewModelCollection.loadedVMObjects.length){tableInstance.refresh();}}).finally(function(){delete node.loadingStatus;tableInstance.updateTreeCellIcon(node);tableElem._tableInstance.focusTreeNodeExpandAfterRender=node;});awTableStateSvc.saveRowCollapsed(declViewModel,gridid,node);}}};instanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.toggleTreeNode',toggleTreeNode));if(declGridObj.reusable){tableInstanceCallbacks.toggleTreeNode=toggleTreeNode;}const doFocusPlaceHolder=function(vmNode){var vmCollection=dataProvider.viewModelCollection;var cursorNdx=vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(vmNode));/**\n                 * Find 'parent' node of the 'placeholder' node in the vmCollection\n                 */var phParentNode=null;var cursorNode=vmCollection.getViewModelObject(cursorNdx);var parentLevelNdx=cursorNode.levelNdx-1;if(parentLevelNdx===-1){phParentNode=dataProvider.topTreeNode;}else{for(var rowNdx=cursorNdx-1;rowNdx>=0;rowNdx--){var currRow=vmCollection.getViewModelObject(rowNdx);if(currRow.levelNdx===parentLevelNdx){phParentNode=currRow;break;}}}if(phParentNode===null){return null;}/**\n                 * Load, using the 'focusAction', the siblings of the 'placeholder' in the context of its immediate\n                 * 'parent'.\n                 * <P>\n                 * Note: We want to use a smaller page size here to minimize the loading.\n                 */var treeLoadInput=awTableSvc.createTreeLoadInput(phParentNode,0,null,vmNode.id,dataProvider.treePageSize,true,null);var loadIDs={t_uid:dataProvider.topTreeNode.uid,o_uid:phParentNode.uid,c_uid:vmNode.uid,uid:null};var actionRequestObj={treeLoadInput:treeLoadInput,loadIDs:loadIDs};/**\n                 * Change 'suffix' text to indicate we are attempting to load more rows.\n                 */vmNode.loadingStatus=true;// get the current copy of data\nObject.assign(dataCtxNode.data.data,dataCtxNode.data.getData());return dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.nextAction,dataProvider.json,dataCtxNode,actionRequestObj).then(function(response){/**\n                     * Locate cursor node in original collection & find/collect all contained 'child' nodes.\n                     */var cursorId=uwUtilSvc.getEvaluatedId(cursorNode);var cursorLevel=cursorNode.levelNdx;var vmCollection=dataProvider.viewModelCollection;var cursorNdxInOrig=vmCollection.findViewModelObjectById(cursorId);var loadedVMObjects=vmCollection.loadedVMObjects;var cursorVMObjects=[loadedVMObjects[cursorNdxInOrig]];for(var l=cursorNdxInOrig+1;l<loadedVMObjects.length;l++){var currNode=loadedVMObjects[l];if(currNode.levelNdx<=cursorLevel){break;}cursorVMObjects.push(currNode);}/**\n                     * Re-order the childNdx values of the sibling nodes relative to initial placeholder as 0;\n                     */var treeLoadResult=response.actionResultObj.responseObj.treeLoadResult;var newVMObjects=treeLoadResult.childNodes;var cursorNdxInNew=0;for(var i=0;i<newVMObjects.length;i++){if(newVMObjects[i].id===cursorId){cursorNdxInNew=i;break;}}for(var j=0;j<newVMObjects.length;j++){newVMObjects[j].childNdx=j-cursorNdxInNew;}/**\n                     * Check if the 'fresh' cursor node is at either end of the 'sibling' list and is now known to be an\n                     * 'incompleteHead' or 'incompleteTail'\n                     * <P>\n                     * If so: Move that status over to the 'original' cursor node.\n                     * <P>\n                     * Note: We are about to replace the 'fresh' node in the set of its siblings just returned and we do\n                     * not want to lose this important information.\n                     */if(cursorNdxInNew===0&&newVMObjects[0].incompleteHead){cursorNode.incompleteHead=true;}var lastNodeNdx=newVMObjects.length-1;if(cursorNdxInNew===lastNodeNdx&&newVMObjects[lastNodeNdx].incompleteTail){cursorNode.incompleteTail=true;}/**\n                     * Make sure the placeholder 'parent' node gets its 'children' set (a shallow clone is good enough).\n                     * <P>\n                     * Replace the 'fresh' cursor node with the 'original' cursor node since it holds important state\n                     * and hierarchy info.\n                     */phParentNode.children=_.clone(newVMObjects);phParentNode.children[cursorNdxInNew]=cursorNode;/**\n                     * Remove the 'fresh' cursor node from the array of its siblings.\n                     * <P>\n                     * Insert the cursor node (and all of its children from the original array) into the array of new\n                     * nodes.\n                     * <P>\n                     * Remove the cursor node (and all of its children) from the original array\n                     * <P>\n                     * Insert the new nodes (updated with the cursor node and all of its children from the original\n                     * array) into the vmCollection array of nodes.\n                     * <P>\n                     * Clear the loading status of the cursor node.\n                     */newVMObjects.splice(cursorNdxInNew,1);// LCS-230184 - In the case where no changes are made to the loadedVMObjects, we must manually refresh\n// so that the table can process the remaining rendered nodes for more focus placeholder, expansion\n// restoration, or prop loading.\nif(newVMObjects.length===0){delete vmNode.loadingStatus;delete vmNode._focusRequested;tableInstance.refresh();return;}var insertNdx=cursorNdxInNew-1;arrayUtils.insert(newVMObjects,insertNdx,cursorVMObjects);loadedVMObjects.splice(cursorNdxInOrig,cursorVMObjects.length);arrayUtils.insert(loadedVMObjects,cursorNdxInOrig-1,newVMObjects);delete vmNode.loadingStatus;delete vmNode._focusRequested;dataProvider.update(loadedVMObjects);/**\n                     * Fire a 'treeNodesLoaded' event, sourced to the uwDataProvider, for all tree-table changes. This\n                     * event includes only the input/result structures for the current load operation. This event is\n                     * used to load additional properties in an async fashion.\n                     */eventBus.publish(dataProvider.name+'.treeNodesLoaded',{treeLoadInput:treeLoadInput,treeLoadResult:treeLoadResult});/**\n                     * Fire a 'modelObjectsUpdated' event, sourced to the uwDataProvider, for all tree-table changes.\n                     * This event includes the complete array of nodes in the collection.\n                     */eventBus.publish(dataProvider.name+'.modelObjectsUpdated',{viewModelObjects:loadedVMObjects,noResults:false});});};tableInstanceCallbacks.doFocusPlaceHolder=doFocusPlaceHolder;}else{instanceEventSubcr.push(eventBus.subscribe(dataProvider.name+'.modelObjectsUpdated',function(event){if(event&&!event.arrangeColumnEvent){tableCallbacks.columnsArranged(event);}}));}tableCallbacks.columnsArranged=columnArrangeData=>{if(columnArrangeData.arrangeType&&columnArrangeData.arrangeType==='saveColumnAndLoadAction'&&columnArrangeData.viewModelObjects){// Just update data provider with vmos changed by columnArrangeService\ntableInstance.resetInfiniteScroll();dataProvider.update(columnArrangeData.viewModelObjects,columnArrangeData.totalFound);// Need to refresh the table since there is no watch anymore on loadedVMObjects\ntableInstance.refresh();}};/**\n          * Subscribe to resetState. Clear all states and set isFocusedLoad to true.\n          */instanceEventSubcr.push(eventBus.subscribe(dataProvider.name+'.resetState',function(){awTableStateSvc.clearAllStates(declViewModel,gridid);dataProvider.isFocusedLoad=true;}));cfgSvc.get('propertyRendererTemplates');initializeProvider(dataProvider,columnProvider,dataCtxNode).then(()=>{var gridContextDispatcher=dataCtxNode.gridContextDispatcher;if(declGridObj.reusable){gridContextDispatcher=declGridObj.gridContextDispatcher;}tableInstance=splmTableFactory.createTableObject(element,gridid,dataProvider,viewModelCollection,columnProvider,declViewModel,declGridObj.contentFilter,gridOptions,declGridObj.containerheight,gridContextDispatcher,runActionWithViewModel,tableInstanceCallbacks,declGridObj.tableContext,declGridObj.reusable,declGridObj.showCheckBox);tableInstance.showCheckBox=declGridObj.showCheckBox;tableElem=tableInstance.getTableElement();initializeObserver();// Following refresh is for cases like object sets. Where first page is already loaded by stylesheet SOA\ntableInstance.viewModelCollection=viewModelCollection;tableInstance.refresh();dataProvider.initializationComplete=true;if(declGridObj.containerHeight){tableInstance.updateContainerHeight(declGridObj.containerHeight);}// Event Interface to rerender the table with data currently on the client\ninstanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.clientRefresh',function(){_.defer(function(){tableInstance.showCheckBox=declGridObj.showCheckBox;if(tableElem&&tableElem._tableInstance){tableElem._tableInstance.showCheckBox=declGridObj.showCheckBox;}util.cleanupComponents(element);tableInstance.refresh();});}));},error=>{dataProvider.initializationComplete=false;logger.trace(error);});}instanceEventSubcr.push(eventBus.subscribe('columnArrange',function(eventData){if(eventData.name===gridid||eventData.columnConfigId&&dataProvider.columnConfig&&eventData.columnConfigId===dataProvider.columnConfig.columnConfigId){if(eventData.columns.length){tableInstance.removeStaleFilters(eventData.columns);}else{columnFilterService.removeAllFilters(dataProvider,columnProvider);}}if(tableInstance.getDynamicRowHeightStatus()){tableInstance.resetDynamicRowHeights();}}));var relatedModifiedEvent=eventBus.subscribe('cdm.relatedModified',function(eventData){tableInstance.relatedModified();});instanceEventSubcr.push(relatedModifiedEvent);// Event Interface to rerender table with reloaded data from the dataprovider\ninstanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.reload',reloadDataProvider));// revisitme - tstark - Need to keep event until all application teams convert away from events\ninstanceEventSubcr.push(eventBus.subscribe('pltable.columnFilterApplied',function(eventData){if(gridid===eventData.gridId&&eventData.isInternalTableEvent!==true){if(eventData.filters&&eventData.filters.length){columnFilterService.setFilters(columnProvider,dataProvider,eventData.filters,eventData.column);}else if(eventData.column){columnFilterService.removeFilter(eventData.column,columnProvider,dataProvider);}else{columnFilterService.removeAllFilters(dataProvider,columnProvider);}dataProvider.isColumnFilterApplied=columnFilterService.isColumnFilterApplied(dataProvider);const columnName=eventData.column?eventData.column.field:null;tableInstance.updateFilterIcons(columnName);reloadDataProvider();}}));tableCallbacks.updateColumnMenuData=function(columnMenuData){_.forEach(dataProvider.cols,function(currentColumn){if(columnMenuData.columnName===currentColumn.field){currentColumn.filter={...currentColumn.filter,...columnMenuData};currentColumn.filter.columnMenuData=columnMenuData;if(currentColumn.filter.showFilters){if(currentColumn.filter.showFilters.dbValue&&currentColumn.filter.showFilters.dbValue!=='false'){currentColumn.filter.showFilterFacets=true;}else{currentColumn.filter.showFilterFacets=false;}}return false;}});};// revisitme - tstark - Need to keep event until all application teams convert away from events\ninstanceEventSubcr.push(eventBus.subscribe(gridid+'.plTable.setFilterDisability',function(eventData){if(gridid===eventData.gridId){tableInstance.setFilterDisability(eventData.isFilterDisabled);}}));/**\n      *  destroy the table\n      */tableCallbacks.destroy=function(){var columns=[];if(dataProvider.columnConfig&&dataProvider.columnConfig.columns){columns=dataProvider.columnConfig.columns;}_.forEach(instanceEventSubcr,function(eventBusSub){eventBus.unsubscribe(eventBusSub);});splmTableFactory.destroyTable(gridid,element,columns);};tableCallbacks.updateVmCollection=viewModelCollection=>{if(tableInstance){tableInstance.viewModelCollection=viewModelCollection;if(util.shouldRequestStartEditPagination(tableElem)){util.requestStartEdit(tableElem);}tableInstance.refresh();}};tableCallbacks.updateDeclGridObject=declGridParam=>{declGridObj=declGridParam;};tableCallbacks.updateMenuContext=menuContext=>{declGridObj.menuContext=menuContext;};tableCallbacks.updateState=newState=>{declViewModel=newState;if(tableInstance){tableInstance.updateInstanceState(newState);}};tableCallbacks.refreshTable=()=>{if(tableInstance){tableInstance.refresh();}};tableCallbacks.updateGridOptionsForTableInstance=props=>{if(tableElem&&tableElem._tableInstance&&props&&props.showCheckBox!==undefined){tableElem._tableInstance.showCheckBox=props.showCheckBox;}};/**\n      * Setup to react to changes in selection within the dataProvider.\n      *\n      * @param {Object} event -\n      * @param {Object} data -\n      */instanceEventSubcr.push(eventBus.subscribe(dataProvider.name+'.selectionChangeEvent',function(event){var selections=event.selectionModel.getSelection();// Set scroll to row in progress\nif(dataProvider.isFocusedLoad===true&&selections.length>0){dataProvider.isFocusedLoad=false;dataProvider.scrollToRow=true;}if(selections.length>0&&selections.length>=_previousSelections.length&&_.isEqual(_previousSelections,selections)===false||dataProvider.scrollToRow===true){dataProvider.scrollToRow=true;eventBus.publish('plTable.scrollToRow',{gridId:gridid,rowUids:selections});}_previousSelections=selections.slice();}));var pageLoadInProgress=false;const getTreeNodePageCallback=function(results){logger.trace('AW simple table: Loaded next tree page data');pageLoadInProgress=false;if(util.shouldRequestStartEditTreePagination(tableElem,propertyProvider)){util.requestStartEdit(tableElem);}dataProvider.update(results.loadedVMObjects,results.totalFound);};// eslint-disable-next-line complexity\nconst loadMorePages=function(eventData){if(tableInstance.viewModelCollection){var lastItemIndex=eventData.lastRenderedItem.index;// get the current copy of data\nObject.assign(dataCtxNode.data.data,dataCtxNode.data.getData());if(lastItemIndex!==0&&lastItemIndex===tableInstance.viewModelCollection.loadedVMObjects.length-1){if(dataProvider.nextAction||dataProvider.action){var lastNode=dataProvider.viewModelCollection.loadedVMObjects[lastItemIndex];if(dataProvider.hasMorePages()&&lastNode.incompleteTail){delete lastNode.incompleteTail;if(eventData.lastRenderedItem.levelNdx>0){pageLoadInProgress=true;dataProvider.getTreeNodePage(dataCtxNode,null,eventData.lastRenderedItem.uid,true,null).then(getTreeNodePageCallback);return;}pageLoadInProgress=true;dataProvider.pageDispatcher({type:'NEXT_PAGE'});return;}logger.trace('AW simple table: Rendering of all rows below completed');}}var firstItemIndex=eventData.firstRenderedItem.index;if(firstItemIndex===0){if(dataProvider.previousAction){var firstNode=dataProvider.viewModelCollection.loadedVMObjects[firstItemIndex];if(dataProvider.hasMorePagesUp()&&firstNode.incompleteHead){delete firstNode.incompleteHead;tableInstance.maintainScrollPosition();if(eventData.firstRenderedItem.levelNdx>0){pageLoadInProgress=true;dataProvider.getTreeNodePage(dataCtxNode,null,eventData.firstRenderedItem.uid,false,null).then(getTreeNodePageCallback);return;}pageLoadInProgress=true;dataProvider.pageDispatcher({type:'PREVIOUS_PAGE'});return;}logger.trace('AW simple table: Rendering of all rows above completed');}}// Check for incomplete head/tail on tree node in rendered range\nif(gridOptions.useTree===true){var incompleteNode=dataProvider.findIncompleteNodeInRange(firstItemIndex,lastItemIndex);if(incompleteNode!==null&&incompleteNode.levelNdx>0){var loadNextPage=incompleteNode.incompleteTail===true;if(loadNextPage===true&&!(dataProvider.nextAction||dataProvider.action)){return;}else if(loadNextPage===false&&!dataProvider.previousAction){return;}delete incompleteNode.incompleteHead;delete incompleteNode.incompleteTail;pageLoadInProgress=true;dataProvider.getTreeNodePage(dataCtxNode,null,incompleteNode.uid,loadNextPage,null).then(getTreeNodePageCallback);return;}}}/** revisitme Radhika: We havesome logic below around pageLoadInProgress. We might need some\n           * tstark - leave for refactor\n               * in the new system. The code needs to be cleaned up and the necessary lines needs to be reused\n              if( dataProvider.viewModelCollection && pageLoadInProgress === false ) {\n                  // Check if next page should be loaded\n                  var lastItemIndex = eventData.lastRenderedItem.index;\n                  if( lastItemIndex !== 0 && lastItemIndex === dataProvider.viewModelCollection.loadedVMObjects.length - 1 ) {\n                      if( dataProvider.nextAction || dataProvider.action ) {\n                          var lastNode = dataProvider.viewModelCollection.loadedVMObjects[ lastItemIndex ];\n                          if( dataProvider.hasMorePages() && lastNode.incompleteTail ) {\n                              delete lastNode.incompleteTail;\n                              if( eventData.lastRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.lastRenderedItem.uid, true, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n                              /**\n                               * REFACTOR: This is how UI Grid checks to see if we actually have more pages to load or not since\n                               * dataProvider.hasMorePages() will always return true, because it sets dataProvider.update(firstPageObjs, firstPageObjs.length + 1)\n                               * in dataProviderFactory and uses these two values for checking for if more pages to load or not.\n                               * Will remove this code in 4.2 when all UIgrid replaced by PL Table\n                              var maxToLoad;\n                              if( dataProvider.action && dataProvider.action.inputData ) {\n                                  var actionInputData = dataProvider.action.inputData;\n                                  if( actionInputData.searchInput ) {\n                                      maxToLoad = actionInputData.searchInput.maxToLoad;\n                                  }\n                              }\n\n                              /**\n                               *\n                               * If we have a firstPage and its length is less than maxToLoad, we dont need to load another page.\n                               * All other cases, handle like normally => Try to get next page of data\n                               *\n                              if( maxToLoad && dataProvider.json.firstPage && dataProvider.json.firstPage.length < maxToLoad ) {\n                                  logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                              } else {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getNextPage( dataCtxNode ).then( function() {\n                                      logger.trace( 'AW simple table: Loaded next page data' );\n                                      pageLoadInProgress = false;\n                                      if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                          util.requestStartEdit( tableElem );\n                                      }\n                                  } );\n                                  return;\n                              }\n                          } else {\n                              logger.trace( 'AW simple table: Rendering of all rows below completed' );\n                          }\n                      }\n                  }\n\n                  // Check if previous page should be loaded as long as next page has not already been requested\n                  var firstItemIndex = eventData.firstRenderedItem.index;\n                  if( firstItemIndex === 0 ) {\n                      if( dataProvider.previousAction ) {\n                          var firstNode = dataProvider.viewModelCollection.loadedVMObjects[ firstItemIndex ];\n                          if( dataProvider.hasMorePagesUp() && firstNode.incompleteHead ) {\n                              delete firstNode.incompleteHead;\n                              eventBus.publish( dataProvider.name + '.plTable.maintainScrollPosition' );\n                              if( eventData.firstRenderedItem.levelNdx > 0 ) {\n                                  pageLoadInProgress = true;\n                                  dataProvider.getTreeNodePage( dataCtxNode, null, eventData.firstRenderedItem.uid, false, null ).then( getTreeNodePageCallback );\n                                  return;\n                              }\n\n                              pageLoadInProgress = true;\n                              dataProvider.getPreviousPage( dataCtxNode ).then( function() {\n                                  logger.trace( 'AW simple table: Loaded previous page data' );\n                                  pageLoadInProgress = false;\n                                  if( util.shouldRequestStartEditPagination( tableElem ) ) {\n                                      util.requestStartEdit( tableElem );\n                                  }\n                              } );\n                              return;\n                          }\n\n                          logger.trace( 'AW simple table: Rendering of all rows above completed' );\n                      }\n                  }\n\n                  // Check for incomplete head/tail on tree node in rendered range\n                  if( gridOptions.useTree === true ) {\n                      var incompleteNode = dataProvider.findIncompleteNodeInRange( firstItemIndex, lastItemIndex );\n                      if( incompleteNode !== null && incompleteNode.levelNdx > 0 ) {\n                          var loadNextPage = incompleteNode.incompleteTail === true;\n                          if( loadNextPage === true && !( dataProvider.nextAction || dataProvider.action ) ) {\n                              return;\n                          } else if( loadNextPage === false && !dataProvider.previousAction ) {\n                              return;\n                          }\n                          delete incompleteNode.incompleteHead;\n                          delete incompleteNode.incompleteTail;\n                          pageLoadInProgress = true;\n                          dataProvider.getTreeNodePage( dataCtxNode, null, incompleteNode.uid, loadNextPage, null ).then( getTreeNodePageCallback );\n                          return;\n                      }\n                  }\n              }\n          */};tableInstanceCallbacks.loadMorePages=loadMorePages;let unsetScrollToRowIndex=function(){tableInstance.unsetScrollToRowIndex();};tableInstanceCallbacks.unsetScrollToRowIndex=unsetScrollToRowIndex;let columnsRearranged=function(eventData){tableInstance.columnsRearranged(eventData);};tableInstanceCallbacks.columnsRearranged=columnsRearranged;let columnsResized=function(eventData){tableInstance.columnsResized(eventData);};tableInstanceCallbacks.columnsResized=columnsResized;return tableCallbacks;};export default{initializeTable};","map":null,"metadata":{},"sourceType":"module"}