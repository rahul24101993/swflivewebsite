{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Fill Down Helper for listen hammer event and manipulate the table element\n *\n * @module js/splmTableFillDownHelper\n *\n * @publishedApolloService\n *\n */import hammer from'hammerjs';import browserUtils from'js/browserUtils';import logger from'js/logger';import eventBus from'js/eventBus';import Const from'js/splmTableConstants';import util from'js/splmTableUtils';/**\n * Instances of this class represent a fill down helper for PL Table\n *\n * @class SPLMTableFillDownHelper\n * @param {Object} tableElem PL Table DOMElement\n */function SPLMTableFillDownHelper(tableElem){var self=this;if(!browserUtils.isMobileOS){document.body.classList.add('nonTouch');}// reference to the entire table visual tree element\ndelete self.tableContentElt;// element ref to the source cellTop\ndelete self.currentSrcCell;// get the bounding rectangle of the source cell\ndelete self.currentSrcCellRectangle;// currently registered event handler\ndelete self.currentPanHandler;delete self.currentPanHandlerElement;self.scrollDelta=0;// currently doing a drag?\nself.isActivelyDragging=false;// the cells within the current drag area; modified as the drag action is done\nself.dragSelectedCells=[];// unhook the drag event hanlder, reset the drag state\nself.removePanEvtHandler=function(){if(self.currentPanHandler){self.currentPanHandler.off('panup pandown panend panstart pancancel',self.handleHammerCellDrag);}delete self.currentPanHandler;self.isActivelyDragging=false;delete self.currentPanHandlerElement;if(self.currentSrcCell){self.currentSrcCell.classList.remove('dragSrc');}};// pan in some direction. compute the drag coords, find the cells within it\n// (includes the source and target cells), and style the cells appropriately\n// to mark the drag area\nself.handlePan=function(hEvt){// get all cells in this column - the attribute name must match the rendering code\nvar getAllColCells=function(){return util.getColumnContentCellElementsByIndex(self.tableContentElt,self.targetColNumber);};var scrollAsNeeded=function(panEvent){// look at table height and offset to determine if we are near the top or bottom?\nvar tableScrollContentRenderer=util.getTableInstance(tableElem).renderer;let currentViewPortBoundingClientRect=self.currentViewportElement.getBoundingClientRect();var boundingTop=currentViewPortBoundingClientRect.top;var boundingBottom=boundingTop+currentViewPortBoundingClientRect.height;if(panEvent.srcEvent.pageY<boundingTop+10){// scroll up logic\nself.scrollDelta=tableScrollContentRenderer.manualScroll(false);logger.debug(scroll,' scroll up');}else if(panEvent.srcEvent.pageY>boundingBottom-10){// scroll down logic\nself.scrollDelta=tableScrollContentRenderer.manualScroll(true);logger.debug(scroll,' scroll down');}};var yDragTop;var yDragBottom;// reset the array of cells in the drag area\nself.dragSelectedCells=[];// which direction is the drag in?\nlet srcCellIndex=self.currentSrcCell.parentElement&&parseInt(self.currentSrcCell.parentElement.getAttribute('aria-rowindex'))-2||0;if(hEvt.srcEvent.clientY+self.scrollDelta>self.currentSrcCellRectangle.top+self.initialScrollDelta+1){// down\nself.dragUp=false;yDragTop=self.currentSrcCellRectangle.top-1+self.initialScrollDelta;yDragBottom=hEvt.srcEvent.clientY+self.scrollDelta;}else{// up - swap for contains calculations\nself.dragUp=true;yDragTop=hEvt.srcEvent.clientY+self.scrollDelta;yDragBottom=self.currentSrcCellRectangle.bottom+self.initialScrollDelta+1;}// check if the data is being virtualized, if so, adjust target area\nvar currentSrcCellProperty=util.getPropertyByCellElement(self.currentSrcCell);if(self.srcUiVal!==currentSrcCellProperty.uiValue){if(self.dragUp){yDragBottom=9999999;}else{yDragTop=0;}}let columnCells=getAllColCells();for(let currentCell of columnCells){let currIndex=parseInt(currentCell.parentElement.getAttribute('aria-rowindex'))-2;// -2 because rowindex for header is 1, first row is 2\nlet indexDelta=currIndex-srcCellIndex;var currentCellTop=self.currentSrcCellRectangle.top+self.initialScrollDelta+(self.currentSrcCellRectangle.height+1)*indexDelta;let currentCellBottom=currentCellTop+self.currentSrcCellRectangle.height;// clear any previous styling\ncurrentCell.classList.remove('dragCellTop');currentCell.classList.remove('dragCell');currentCell.classList.remove('dragCellBottom');var yCell=currentCellTop;// y coord for this cell\nif(self.dragUp===true){yCell=currentCellBottom;}// compute whether or not this cell is in the drag area\nif(yCell<yDragBottom&&yCell>=yDragTop){// if ( hEvt.srcEvent.clientY > currentCellTop && hEvt.srcEvent.clientY < currentCellBottom ) {\n// this element fits inside the selection rectangle\ncurrentCell.classList.add('dragCell');self.dragSelectedCells.push(currentCell);}}// decorate top and bottom cells specially\nif(self.dragSelectedCells.length){self.dragSelectedCells[0].classList.add('dragCellTop');self.dragSelectedCells[self.dragSelectedCells.length-1].classList.add('dragCellBottom');}// attempt to scroll the grid if we are dragging off\nscrollAsNeeded(hEvt);};// the end pan/drag has been encountered - trigger the data processing\n// based on the drag area boundary\nself.handlePanEnd=function(){// eslint-disable-line no-unused-vars\n// check that we have more than just the source cell\nif(self.dragSelectedCells.length>1){var endTargetCell;var direction;if(self.dragUp){endTargetCell=self.dragSelectedCells[0];direction='up';}else{endTargetCell=self.dragSelectedCells[self.dragSelectedCells.length-1];direction='down';}var endTargetProp=util.getPropertyByCellElement(endTargetCell);// iterate the target cells\nfor(var inx=0;inx<self.dragSelectedCells.length;inx++){self.dragSelectedCells[inx].classList.remove('dragCellTop');self.dragSelectedCells[inx].classList.remove('dragCell');self.dragSelectedCells[inx].classList.remove('dragCellBottom');}// for\n// emit this fill-complete event to be handled by the tabled\nvar gridId=util.getTableInstance(tableElem).gridId;let endTarget=endTargetProp.substituteParentUid||endTargetProp.parentUid;if(!endTarget){var rowElement=util.closestElement(endTargetCell,'.'+Const.CLASS_ROW);endTarget=rowElement.vmo.uid;}util.getTableInstance(tableElem).editor.fillDownCompleteHandler({propertyName:self.propertyName,source:self.srcUid,endTarget:endTarget,direction:direction});}// children > 1\nself.scrollDelta=0;self.isActivelyDragging=false;self.tableContentElt.classList.remove('aw-jswidgets-dragfilling');};self.handlePanCancel=function(){self.removePanEvtHandler();};self.handlePanStart=function(hEvt){// starting pan...\nself.dragUp=false;self.isActivelyDragging=true;const tableScrollContentRenderer=util.getTableInstance(tableElem).renderer;self.initialScrollDelta=tableScrollContentRenderer.getScrollTop();self.scrollDelta=self.initialScrollDelta;// the source cell for the fill\nvar srcCell=util.closestElement(hEvt.target,'.'+Const.CLASS_CELL);self.currentSrcCell=srcCell;self.currentSrcCellRectangle=self.currentSrcCell.getBoundingClientRect();self.currentViewportElement=util.closestElement(self.currentSrcCell,'.'+Const.CLASS_VIEWPORT);var property=util.getPropertyByCellElement(self.currentSrcCell);self.srcUid=property.substituteParentUid||property.parentUid;if(!self.srcUid){var rowElement=util.closestElement(self.currentSrcCell,'.'+Const.CLASS_ROW);self.srcUid=rowElement.vmo.uid;}self.srcUiVal=property.uiValue;self.propertyName=property.propertyName;self.tableContentElt=util.closestElement(hEvt.target,'.'+Const.ELEMENT_TABLE);// table content area\nself.currentSrcCell.classList.add('dragSrc');self.tableContentElt.classList.add('aw-jswidgets-dragfilling');self.targetColNumber=self.currentSrcCell.columnDef.index;};// function for handling the Pan/drag related events from hammer.\n// account for all the Hammer event states\nself.handleHammerCellDrag=function(hEvt){if(hEvt.type==='panstart'){self.handlePanStart(hEvt);}else if(hEvt.type==='panend'){// ending pan\nself.handlePanEnd();}else if(hEvt.type==='pancancel'){// cancelling pan\nself.handlePanCancel();}else if(self.isActivelyDragging){// other event - actively dragging, so handle pan\nself.handlePan(hEvt);}};// this is triggered from the drag handle drag action on the directive.\n// Determine if we need to setup the hammer pan/drag listener.\n// Establish the drag start\nself.initialize=function(event){// checking range...\nif(!self.isActivelyDragging){event.preventDefault();if(self.currentPanHandlerElement){if(self.currentPanHandlerElement!==event.target){// remove the old one\nself.removePanEvtHandler();}}if(!self.currentPanHandler){var hmrMgr=hammer(event.target,{touchAction:'pan-y'});// track the element that the hammer is using\nself.currentPanHandlerElement=event.target;var panRecognizer=hmrMgr.get('pan');panRecognizer.set({direction:hammer.DIRECTION_VERTICAL});// set options\nhmrMgr.on('panup pandown panend panstart pancancel',self.handleHammerCellDrag);// panleft panright\nself.currentPanHandler=hmrMgr;}else if(self.currentPanHandlerElement){// existing handler, same element?\nif(self.currentPanHandlerElement!==event.target){logger.warn('different event handler element - shouldnt be here ------------------');}}}};return self;}export default SPLMTableFillDownHelper;","map":null,"metadata":{},"sourceType":"module"}