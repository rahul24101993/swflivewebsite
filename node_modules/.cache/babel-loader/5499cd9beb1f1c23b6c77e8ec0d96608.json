{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Declarative UI data provider service\n * This service performs actions to retrieve data in a paged fashion based solely on a given 'declAction' object.\n *\n * @module js/declDataProviderService\n */import declDataCtxSvc from'js/declarativeDataCtxService';import appCtxSvc from'js/appCtxService';import _ from'lodash';import logger from'js/logger';import Debug from'debug';import declUtils from'js/declUtils';import actionSvc from'js/actionService';import moduleLoader from'js/moduleLoader';import AwPromiseService from'js/awPromiseService';var dataProviderTcLOV='TcLOV';var trace=new Debug('declDataProviderService');/**\n * Use the 'actionService' to execute the given action and resolve the returned 'promise' with the either no object\n * or a reference to the any dependent module's API object.\n * <P>\n * Note: Any dependent module will be loaded before the action is executed.\n * <P>\n * Note: It is assumed that the action will use its 'input' and 'output' properties to move action related data into\n * or out of the dataCtxNode or declViewModel.\n *\n * @param {Object} dataCtxNode - The data context node the action is being performed within.\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n * @param {DeclAction} action - The declarative action to be executed.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n *\n * <pre>\n * {\n *     responseObj: responseObj,\n *     depModuleObj: depModuleObj\n * }\n * </pre>\n */function _executeAction(dataCtxNode,declViewModel,action,depModuleObj){declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel,dataCtxNode,action,null,'_executeAction');return actionSvc.executeAction(declViewModel,action,dataCtxNode,depModuleObj).then(function(responseObj){return{responseObj:responseObj,depModuleObj:depModuleObj};}).catch(function(x){trace('exception',x);logger.error('exception: '+x);});}/**\n *\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *            <P>\n *            If not provided all action options are resolved solely from action's 'inputData' via the given dataCtxNode.\n *            <P>\n *            Note: The properties in this object are guaranteed to be passed to the action being invoked and that\n *            the results of that particular action invocation are returned as the resolution of the promise\n *            returned by this function. Use of the dataCtxNode for 'inputData' binding can result in mixed input vs.\n *            output results when multiple async calls are made to the same action.\n *\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n */function _executeLoadAction(declViewModel,action,dataCtxNode,dataProviderJson,actionRequestObj,depModuleObj){//new in aw4.2\ndeclUtils.assertValidModelDataCtxNodeAndAction2(declViewModel,dataCtxNode,action,null,'_executeLoadAction');var actionFinal=action;if(actionRequestObj){actionFinal=_prepareActionAltInputData(dataCtxNode,declViewModel,action,actionRequestObj,depModuleObj);}return _executeAction(dataCtxNode,declViewModel,actionFinal,depModuleObj).then(function(actionResultObj){// revisitme - somehow in the long SOA case like search, the dataCtxNode.data is not equal to declViewModel\n// anymore which is cause side effect - will investigate later\ndataCtxNode.data.totalFound=declViewModel.totalFound;dataCtxNode.data.searchResults=declViewModel.searchResults;return _postProcessAction(dataCtxNode,dataCtxNode.data,dataProviderJson,actionResultObj);},function(rejectObj){return AwPromiseService.instance.reject(rejectObj);});}/**\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {DeclViewModel} declViewModel - The view model the action is defined within.\n * @param {Object} dataProviderJson - The original JSON definition of the declDataProvider.\n * @param {Object} actionResultObj - The resolved response object from executing the action.\n *\n * @return {Promise} A Promise object resolved with the processed result of the action. The result contains updated\n *         values for all the properties in the given 'dataProviderJson' object.\n */function _postProcessAction(dataCtxNode,declViewModel,dataProviderJson,actionResultObj){var responseObj;if(dataProviderJson&&declUtils.isValidModelAndDataCtxNode(declViewModel,dataCtxNode)){let localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);var dpResult=_.cloneDeep(dataProviderJson);// LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n// Fix cucumber 'Record Utilization Declarative Panel': depModuleObj is needed for all {{function:}}\nvar depModuleObj=actionResultObj&&actionResultObj.depModuleObj?actionResultObj.depModuleObj:null;/**\n         * Check if the dataCtxNode we need has been destroyed (due to DOM manipulation) since the action event\n         * processing was started.\n         */var localDataCtx=declUtils.resolveLocalDataCtx(localContext.data,localContext);/**\n         * Resolve any other data 'from' the declViewModel and/or dataCtxNode\n         */declDataCtxSvc.applyScope(localContext.data,dpResult,declViewModel._internal.functions,localDataCtx,depModuleObj);if(actionResultObj){_.forEach(dpResult,function(fromPath,toPath){/**\n                 * If fromPath has a 'result.' prefix, parse the expression within fromPath to get the correct\n                 * value.\n                 */if(_.isString(fromPath)&&/^action\\.result\\./.test(fromPath)){var fromResultPath=fromPath.split('action.result.')[1];var fromObj=_.get(actionResultObj.responseObj,fromResultPath);_.set(dpResult,toPath,fromObj);}});}/**\n         * Build the response object from the updated (i.e. data bound) properties in the declDataProvider's JSON\n         * definition.\n         */responseObj={actionResultObj:actionResultObj};_.forEach(dpResult,function(value,name){if(name==='action'){return;}/**\n             * Handle special case of a mapping to a different property name (e.g. 'response' to 'result').\n             */if(name==='response'){responseObj.results=value;}else if(/^ctx\\./.test(name)){/**\n                 * If the name starts with ctx. update the appCtxService\n                 */var toCtxName=name.split('ctx.')[1];appCtxSvc.updatePartialCtx(toCtxName,value);}else{responseObj[name]=value;}});/**\n         * Make sure the 'totalFound' is set if we had any data returned.\n         */if(responseObj.results&&_.isUndefined(responseObj.totalFound)){responseObj.totalFound=responseObj.results.length;}}return AwPromiseService.instance.resolve(responseObj);}/**\n * @param {Object} inputData - Input properties from JSON.\n * @param {Object} altInputData - Input properties to use.\n * @param {Object} actionRequestObj - Object from action to use.\n */function _applyActionRequestObject(inputData,altInputData,actionRequestObj){/**\n     * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n     */_.forEach(inputData,function(fromPath,toPath){if(_.isString(fromPath)){if(/^request\\./.test(fromPath)){var fromRequestPath=fromPath.split('request.')[1];var fromObj=_.get(actionRequestObj,fromRequestPath);_.set(altInputData,toPath,fromObj);}}else{_applyActionRequestObject(fromPath,altInputData[toPath],actionRequestObj);}});}// _applyActionRequestObject\n/**\n * Note 1: Multiple async load requests can be made before any given one completes. So we cannot put action-related\n * objects on the dataCtxNode since the dataCtxNode may change before the original dataCtxNode is applied to the action the objects\n * were ment for.\n * <P>\n * To address this, the dataCtxNode will be applied to the 'inputData' of a clone of the action NOW. This clone (and the\n * now static 'inputData' objects) will be passed to the actionService which will use this 'altInputData' as-is\n * without trying to apply the dataCtxNode to it again.\n * <P>\n * Note 2: The post processing of the action results do not have this problem since a new 'outputData' object is\n * created and passed back through the 'promise chain' in a more synchronous fashion. So any output data placed on\n * the dataCtxNode is not there long enough to be overwritten by another action completing before it.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n\n *\n * @returns {DeclAction} Action object to actually use.\n */function _prepareActionAltInputData(dataCtxNode,declViewModel,action,actionRequestObj,depModuleObj){var actionFinal=action;if(action.inputData){/**\n         * Make copied of the 'action' and 'inputData' objects (to keep the originals safe from modification)\n         */actionFinal=_.cloneDeep(action);actionFinal.altInputData=_.cloneDeep(action.inputData);// LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n// The actonRequestObj, which may be a very complex structure, can be applied after applyScope\ndeclDataCtxSvc.applyScope(declViewModel,actionFinal.altInputData,declViewModel._internal.functions,dataCtxNode,depModuleObj);/**\n         * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n         */_applyActionRequestObject(actionFinal.inputData,actionFinal.altInputData,actionRequestObj);}return actionFinal;}// _prepareActionAltInputData\n/**\n * --------------------------------------------------------------------------<BR>\n * Define external API<BR>\n * --------------------------------------------------------------------------<BR>\n */var exports={};/**\n * validate the LOV sections using the function in the lovService\n *\n * @param {array} lovEntries - The 'lovEntries' to update.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @return {Promise} A promise object. validateLOVValueSelections\n */export let validateLOVSelection=function(_ref,dataCtxNode,action,dataProviderJson){let{lovEntries,vmo,viewModelProp}=_ref;//let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n// if( dataProviderJson.dataProviderType && dataProviderJson.dataProviderType === dataProviderTcLOV ) {\n//     declDataCtxSvc.applyScope( declViewModel, dataProviderJson, null, dataCtxNode, null );\n//     var lovConfig = dataProviderJson.lovConfiguration;\n//     var viewModelObj = lovConfig.viewModelObj;\n//     var viewProp = lovConfig.viewProp;\n//     var operationName = lovConfig.operationName;\n//     return lovService.validateLOVValueSelections( lovEntries, viewProp, operationName, viewModelObj );\n// }\nif(action&&viewModelProp){let actionRequestObj={selected:lovEntries,suggestion:viewModelProp.filterString,vmo,vmProp:viewModelProp};return validateSelections(action,dataProviderJson,dataCtxNode,actionRequestObj).then(resp=>{let response;if(resp.actionResultObj&&resp.actionResultObj.responseObj){response=resp.actionResultObj.responseObj;if(!response.valid){return Promise.reject(response);}return Promise.resolve(response);}else if(!resp.valid){resp.cause={partialErrors:true};return Promise.reject(resp);}return resp;});}return Promise.resolve({valid:true});};/**\n * Validate the LOV selections using the function in the dataProvider.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} lovScope - The context in which to evaluate any conditions/bindings.\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object.\n */export let validateSelections=function(action,dataProviderJson,lovScope,actionRequestObj){return exports.executeLoadAction(action,dataProviderJson,lovScope,actionRequestObj);};/**\n * Execute the given action and return results in the async resolution.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's JSON object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the results (IModelObject, ViewModelObjects, etc.) of the given\n *         action.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n */export let executeLoadAction=function(action,dataProviderJson,dataCtxNode,actionRequestObj){// if( !action ) {\n//     logger.error( 'Invalid action specified' );\n// }\nlet declViewModel=declUtils.findViewModel(dataCtxNode,true,appCtxSvc);// add update To latestHere ...\nlet localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);if(!declUtils.isNil(action)){/**\n         * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n         */declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel,dataCtxNode,action,'Load action not executed.','executeLoadAction (a)');// Get Function deps\nvar functionDeps=declUtils.getFunctionDeps(action,declViewModel._internal);if(!_.isEmpty(action.deps)){return moduleLoader.loadDependentModule(action.deps).then(function(depModuleObj){//new in aw4.2\ndeclUtils.assertValidModelDataCtxNodeAndAction2(declViewModel,dataCtxNode,action,'Load action not executed.','executeLoadAction (b)');// Load function.deps\n//\n// Note: Even if the list of 'functionDeps' is empty we need to execute the async load since some\n// code (breadcrumbs) needs the extra digest cycle (or two). This is odd since the same 'empty'\n// check later in this function seems to work ok.\n//\nreturn moduleLoader.loadDependentModules(functionDeps).then(function(depFunctionObj){_.forEach(depFunctionObj,function(depFuncValue,depFuncKey){depModuleObj[depFuncKey]=depFuncValue;});var localScope=declUtils.resolveLocalDataCtx(localContext.data,localContext);return _executeLoadAction(localContext.data,action,localScope,dataProviderJson,actionRequestObj,depModuleObj);});});}if(!_.isEmpty(functionDeps)){// Load function.deps\nreturn moduleLoader.loadDependentModules(functionDeps).then(function(depFunctionObj){var localScope=declUtils.resolveLocalDataCtx(localContext.data,localContext);return _executeLoadAction(localContext.data,action,localScope,dataProviderJson,actionRequestObj,depFunctionObj);});}return _executeLoadAction(localContext.data,action,localContext,dataProviderJson,actionRequestObj,null);}//let localScope = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );\nreturn _postProcessAction(localContext,localContext.data,dataProviderJson,null);};/**\n * Get first page of results\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n *\n */export let getFirstPage=function(action,dataProviderJson,dataCtxNode,actionRequestObj){if(action){return exports.executeLoadAction(action,dataProviderJson,dataCtxNode,actionRequestObj);}/**\n     * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n     */var declViewModel=declUtils.findViewModel(dataCtxNode,true,appCtxSvc);declUtils.assertValidModelAndDataCtxNode(declViewModel,dataCtxNode);/**\n     * Support for binding dataProvider's response to a static list, when action is not provided.\n     */return _postProcessAction(dataCtxNode,declViewModel,dataProviderJson,null);};/**\n * Get next page of results\n *\n * @param {DeclAction} action - The 'declAction' to perform.\n *\n * @param {Object} dataProviderJson - data provider json object\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n */export let getNextPage=function(action,dataProviderJson,dataCtxNode,actionRequestObj){if(action){return exports.executeLoadAction(action,dataProviderJson,dataCtxNode,actionRequestObj);}/**\n     * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n     */var declViewModel=declUtils.findViewModel(dataCtxNode,true,appCtxSvc);declUtils.assertValidModelAndDataCtxNode(declViewModel,dataCtxNode);/**\n     * Support for binding dataProvider's response to a static list, when action is not provided.\n     */return _postProcessAction(dataCtxNode,declViewModel,dataProviderJson,null);};exports={validateLOVSelection,validateSelections,executeLoadAction,getFirstPage,getNextPage};export default exports;","map":null,"metadata":{},"sourceType":"module"}