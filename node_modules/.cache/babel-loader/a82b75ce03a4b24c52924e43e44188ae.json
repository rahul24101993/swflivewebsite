{"ast":null,"code":"/* eslint-disable complexity */ /* eslint-disable max-lines */ // Copyright (c) 2021 Siemens\n/**\n * Data provider factory\n *\n * @module js/dataProviderFactory\n */import AwPromiseService from'js/awPromiseService';import viewModelCollectionFactory from'js/viewModelCollectionFactory';import localeSvc from'js/localeService';import editHandlerSvc from'js/editHandlerService';import uwUtilSvc from'js/uwUtilService';import dataSourceService from'js/dataSourceService';import dataCtxService from'js/declarativeDataCtxService';import declModelRegistrySvc from'js/declModelRegistryService';import editUtilsService from'js/editUtilsService';import appCtxService from'js/appCtxService';import assert from'js/assert';import _ from'lodash';import declUtils from'js/declUtils';import eventBus from'js/eventBus';import logger from'js/logger';import arrayUtils from'js/arrayUtils';import browserUtils from'js/browserUtils';import parsingUtils from'js/parsingUtils';import debugService from'js/debugService';import awTableStateSvc from'js/awTableStateService';import awTableSvc from'js/awTableService';import editHandlerFactory from'js/editHandlerFactory';import declDataProviderSvc from'js/declDataProviderService';import cfgSvc from'js/configurationService';const jsonData=cfgSvc.getCfgCached('lovDataProvider');import Debug from'debug';const trace=new Debug('selection');/**\n * {StringArray} Collection of valid properties in the 'inputData' property of dataProvider's JSON definition.\n */var _modifiablePropertiesViaInputData=['selectionModel','accessMode','topNodeUid','editSupportParamKeys'];/**\n * {Boolean} TRUE if tree node insertion details should be logged.\n */var _debug_logTreeLoadActivity=false;/**\n * Constructs an object that wraps access to a 'viewModelCollection' created by the\n * 'viewModelCollectionFactory'.\n *\n * @class UwDataProvider\n *\n * @param {QueueService} $q - Queue service to use.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {ViewModelCollection} viewModelCollection - The 'viewModelCollection' used to hold all\n *            ViewModelObjects managed by this DataProvider.\n *\n * @param {StringMap} actionMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n */var UwDataProvider=function($q,dataProviderJson,actionObj,dataProviderName,someDataProviderSvc,viewModelCollection,actionMap){var dpSelf=this;// eslint-disable-line consistent-this\n/**\n     * Data that is passed into the data provider constructor from outside of the view model.\n     */var _ctorInputData=dataProviderJson?dataProviderJson.inputData:null;/**\n     *  This private variable would contain the pagination options and non-modifibale from outside.\n     */let paginationOption=null;/**\n     *  The filter string to be used in getFirstPage/getNextPage APi's\n     */let filterStr=null;let propsCallback=null;/**\n     *  selectionModelDispatcher : Dispatcher to update the selection Model on the fly.\n     */let selectionModelDispatcher;/**\n     *\n     */let lovEntryRef=null;/**\n     *  This private variable would contain the reference of the top level referenceElement of list/table/ user defined widget\n     *  using data-provider\n     */let referenceElement=null;/**\n     * {Boolean} TRUE if 'destroy' has been invoked on this instance.\n     */dpSelf._isDestroyed=false;/**\n     * @property {String} noResultsFound - Localized message stating 'No results found'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.noResultsFound=null;/**\n     * @property {String} isLoading - Localized message stating 'loading'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.isLoading=null;/**\n     * @property {Boolean} cacheCollapse - cache collapse infomation to reuse in next expand.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.cacheCollapse=false;/**\n     * @property {Object} someDataProviderSvc - Some API object where 'getFirstPage', 'getNextPage', et al.\n     *           methods are implemented (e.g. 'js/declDataProviderService').\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.someDataProviderSvc=someDataProviderSvc;/**\n     * @property {String} name - name of data provider object\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.name=dataProviderName;/**\n     * @property {ViewModelCollection} viewModelCollection - viewModelCollection which maintains the loaded\n     *           ViewModelObjects and also have APIs to access the information of collection.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.viewModelCollection=viewModelCollection;/**\n     * @property {Number} startIndex - Start/Next index into a virtual list.\n     *           <P>\n     *           Note: This property is accessed by some declViewModel bindings and 'glue' code. While it is\n     *           somewhat analogous to the data in the newer 'cursorObject', it is necessary to keep it exposed\n     *           for support of these earlier uses of it.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.startIndex=0;/**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.action=null;/**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.focusAction=null;/**\n     * @property {DeclDataProviderJson} json - The 'UwDataProvider' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.json=null;/**\n     * @property {Object} policy - The Currently set property policy object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.policy=null;/**\n     * @property {Object} selectionModel - Object which maintains all the selection objects stuff and provides\n     *           APIs to access information.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */ // dpSelf.selectionModel = selectionModelFactory\n//     .buildSelectionModel( dataProviderJson ? dataProviderJson.selectionModelMode : null );\n/**\n     * @property {Boolean} noResults - Flag decides whether to show no results message if there are no values\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.noResults=false;/**\n     * @property {ObjectArray} sortCriteria - Array of ordered sort criteria objects.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.sortCriteria=[];/**\n     * @property {Object} filiterMap - A map (string, list of SearchFilter) containing the list of search\n     *           filters for each search filter field. The key in the map is the property name that represents\n     *           the filter category. It is in the format \"TypeName.PropertyName\". e.g\n     *           WorkspaceObject.object_type\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.filterMap={};/**\n     * @property {ViewModelTreeNode} The ViewModelTReeNode which is the logical (but unseen) 'top' node in any\n     *           hierarchy being managed by this UwDataProvider\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.topTreeNode=null;/**\n     * Selected objects\n     */dpSelf.selectedObjects=[];/**\n     * {Boolean} TRUE if any editHandler associated with this UwDataProvider has been registered.\n     */var _editHandlerRegistered;const updateDataCtxNodeWithProps=function(dataCtxNode){if(propsCallback){dataCtxNode.props=propsCallback();dataCtxNode.getProps=propsCallback;}};// Toggle the display of Cell Decorators.\ndpSelf.toggleDecoratorsEvent=eventBus.subscribe(dpSelf.name+'.toggleCellDecorators',function(eventData){if(eventData){dpSelf.showDecorators=eventData.toggleState;}else{if(dpSelf.showDecorators){dpSelf.showDecorators=false;}else{dpSelf.showDecorators=true;}}});const saveRowExpanded=function(dataCtxNode,node){if(node.isExpanded===true){var declViewModel=declUtils.findViewModel(dataCtxNode);var grids=declViewModel.grids;awTableStateSvc.saveRowExpanded(declViewModel,grids[Object.keys(grids)[0]].gridid,node);}};/**\n     * Fire modelObjects updated event using data provider name space\n     *\n     * @param {Object} dataCtxNode - The 'scope' to use.\n     * @param {Object} eventData - Event data containing data to include in notify.\n     */var _notifyModelObjectsUpdate=function(dataCtxNode,eventData){if(dataCtxNode){dpSelf.syncSelectionModel(dataCtxNode);}eventData=eventData||{};// Set standard data\neventData.viewModelObjects=dpSelf.viewModelCollection.getLoadedViewModelObjects();eventData.noResults=dpSelf.noResults;// Publish event\neventBus.publish(dpSelf.name+'.modelObjectsUpdated',eventData);};dpSelf.notifyModelObjectsUpdate=_notifyModelObjectsUpdate;/**\n     * Insert the given array of ViewModelObjects into the given viewModelCollection starting after the given\n     * 'cursor' ViewModelObject ID.\n     *\n     * @param {ViewModelCollection} vmCollection - The ViewModelCollection to update.\n     * @param {String} cursorId - ID of the object The ViewModelObject in the collection to insert after.\n     * @param {ViewModelObjectArray} vmosToInsert - The ViewModelObjects to insert.\n     * @param {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n     *            (Default: TRUE)\n     */function _insertModelObjects(vmCollection,cursorId,vmosToInsert,addAfter){var cursorNdx=vmCollection.findViewModelObjectById(cursorId);var cursorNode=cursorNdx===-1?null:vmCollection.getViewModelObject(cursorNdx);var loadedVMOs=vmCollection.getLoadedViewModelObjects();if(_debug_logTreeLoadActivity){logger.info('_insertModelObjects: '+'\\n'+//\n'n1stLevelFound : '+vmCollection.totalFound+'\\n'+//\n'n1stLevelLoaded: '+vmCollection.totalObjectsLoaded+'\\n'+//\n'nLoadedOverall : '+loadedVMOs.length+'\\n'+//\n'cursorId       : '+cursorId+'\\n'+//\n'nVMOsToInsert  : '+vmosToInsert.length+'\\n'+//\n'addAfter       : '+addAfter+'\\n'+//\n'cursorNdx      : '+cursorNdx+'\\n'+//\n'cursorNode     : '+cursorNode);}/**\n         * Check if we found where to insert and it is NOT the top level node.\n         * <P>\n         * Note: This function purposefully does not maintain the 'totalObjectsLoaded' for the overall\n         * viewModelCollection since that value only makes sense for the 'top' node.\n         */if(cursorNode&&cursorNode.levelNdx!==-1){var childNdxOffset;if(addAfter){/**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */if(cursorNode.levelNdx===vmosToInsert[0].levelNdx){childNdxOffset=loadedVMOs[cursorNdx].childNdx+1;for(var ndx1=0;ndx1<vmosToInsert.length;ndx1++){vmosToInsert[ndx1].childNdx=childNdxOffset+ndx1;}}/**\n                 * AW-49335 - Jumping to target does not work when page is refreshed...\n                 * <P>\n                 * Check if the 'cursor' node has any children<br>\n                 * If so: We need to account for them before we insert\n                 * <P>\n                 * Note: We look forward until we find a node at the same (or 'above') level.\n                 */var insertNdx=cursorNdx;for(var ndx3=cursorNdx+1;ndx3<loadedVMOs.length;ndx3++){if(loadedVMOs[ndx3].levelNdx<=cursorNode.levelNdx){break;}insertNdx++;}arrayUtils.insert(loadedVMOs,insertNdx,vmosToInsert);}else{/**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */if(cursorNode.levelNdx===vmosToInsert[0].levelNdx){childNdxOffset=loadedVMOs[cursorNdx].childNdx-vmosToInsert.length;for(var ndx2=0;ndx2<vmosToInsert.length;ndx2++){vmosToInsert[ndx2].childNdx=childNdxOffset+ndx2;}}/**\n                 * Insert just before the 'cursor' node.\n                 * <P>\n                 * Note: Even if the 'cursor' node is preceded by any children from an earlier 'sibling' (i.e. a\n                 * node at the same tree level) we do NOT need to account for them before we insert since the\n                 * 'cursor' position defines the correct break in the tree level.\n                 */arrayUtils.insertBefore(loadedVMOs,cursorNdx,vmosToInsert);}}}// _insertModelObjects\n/**\n     * Locate the 'child' in the given 'parent' based on the 'child' node's ID.\n     *\n     * @param {ViewModelTreeNode} parentNode - The 'parent' who's 'children' to search.\n     * @param {String} cursorNodeId - The ID of the 'child' node to find.\n     * @returns {Number} Index to the 'child' node (or -1 if not found)\n     */function _findChildNdx(parentNode,cursorNodeId){var nChild=parentNode.children?parentNode.children.length:0;if(cursorNodeId){for(var ndx=0;ndx<nChild;ndx++){if(parentNode.children[ndx].id===cursorNodeId){return ndx;}}}return-1;}/**\n     * Insert the results into the ViewModelCollection array starting at the current location of the 'cursor'\n     * node.\n     *\n     * @param {TreeLoadInput} treeLoadInput - The original input parameters used to generate the response we are\n     *            processing now.\n     *\n     * @param {Object} responseObj - Object returned from the associated load 'action'\n     *\n     * @param {Object} dataCtxNode - Data context used for selection model sync.\n     *\n     * @param {Object} origCursorObj - The cursorObject of the 'parent' node BEFORE the load operation.\n     *\n     * @return {ViewModelCollection} A reference to the updated ViewModelCollection object.\n     */function _processLoadTreeNodePageResponse(treeLoadInput,responseObj,dataCtxNode,origCursorObj){// eslint-disable-line\nassert(responseObj,'Action did not return a ResponseResult Object');var treeLoadResult=responseObj.treeLoadResult;let vmCollection=dpSelf.viewModelCollection;assert(treeLoadResult,'Action did not return a TreeLoadResult Object');/**\n         * Move the 'parent' and 'viewModelCollection' into handier variables.\n         */var resultParentNode=treeLoadResult.parentNode;let response={totalFound:vmCollection.totalFound,loadedVMObjects:vmCollection.loadedVMObjects};/**\n         * Determine if we are working on the very top node of the tree.\n         */var isParentRoot=resultParentNode&&resultParentNode.levelNdx===-1;/**\n         * Optionally log some useful information\n         */if(_debug_logTreeLoadActivity&&!_.isEmpty(treeLoadResult.childNodes)){logger.info('_processLoadTreeNodePageResponse'+'\\n'+'parentNode: '+resultParentNode+' isParentRoot: '+isParentRoot+'\\n'+'# children returned: '+treeLoadResult.childNodes.length);}/**\n         * AW-47271 - bash_PI1712-2 : Can Not expand Sub Assembly in tree View in a spcific scenario\n         * <P>\n         * Find the original 'parent' node in the vmCollection and see if it is still expanded.\n         * <P>\n         * Note: If we are working on the 'root', skip this check since the 'root' cannot actually be collapsed.\n         */if(!isParentRoot){/**\n             * Check if NOT expanded<BR>\n             * If so: No need to continue. Return current vmCollection unchanged.\n             * <P>\n             * Note: The 'parent' node returned from the async processing can sometimes be a clone made during\n             * processing. It is best to go back to the original to be sure we do not miss the latest state.\n             */var origParentNdx=vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(resultParentNode));if(origParentNdx===-1||!vmCollection.getViewModelObject(origParentNdx).isExpanded){if(_debug_logTreeLoadActivity){logger.info('_processLoadTreeNodePageResponse: Skipping insertion of child nodes into collapsed or missing parent'+'\\n'+'parent: '+resultParentNode+'\\n'+'index: '+origParentNdx);}return{totalFound:vmCollection.getTotalObjectsFound(),loadedVMObjects:vmCollection.getLoadedViewModelObjects()};}}/**\n         * Check if we actually have results to insert.\n         */var newTopNode;var moreAboveFirst;var moreBelowLast;if(treeLoadResult.totalChildCount>0&&!_.isEmpty(treeLoadResult.childNodes)){/**\n             * If this is the 'top' level node we now know IT is NOT empty.\n             */if(isParentRoot){dpSelf.noResults=false;}var expectantParentNode=resultParentNode;/**\n             * Get the effective 'parent' node from the paths (if necessary)\n             */var nRootPaths=_.isEmpty(treeLoadResult.rootPathNodes)?0:treeLoadResult.rootPathNodes.length;var usedPathParent;if(nRootPaths>0){/**\n                 * Get the 'top' node based on the path but do not override the current 'expectantParentNode'\n                 * unless it refers to a different object.\n                 */var resultTopNode=_.last(treeLoadResult.rootPathNodes);if(resultParentNode.uid!==resultTopNode.uid){expectantParentNode=resultTopNode;usedPathParent=true;}}/**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */newTopNode=treeLoadResult.newTopNode;if(newTopNode&&newTopNode.levelNdx===-1){dpSelf.topTreeNode=newTopNode;dpSelf.topTreeNode.children=null;dpSelf.topNodeUid=dpSelf.topTreeNode.uid;if(!usedPathParent){resultParentNode=treeLoadResult.newTopNode;}}/**\n             * Determine if we are inserting before or after the 'start' or 'cursor' node.\n             */var addAfter=declUtils.isNil(treeLoadInput.addAfter)?true:treeLoadInput.addAfter;/**\n             * Check for the trivial case of 1st-time children\n             * <P>\n             * Note: We do a shallow clone to make sure it is not the same array as the result.\n             */var newParent=_.isEmpty(expectantParentNode.children);if(newParent){expectantParentNode.children=_.clone(treeLoadResult.childNodes);}else{/**\n                 * Insert the new 'child' nodes into the 'children' array property of the 'parent' node.\n                 * <P>\n                 * Try to use the 'cursor' node to locate exactly where in the 'parent' to insert the new\n                 * 'child' nodes.\n                 * <P>\n                 * If no 'cursor' then just trust the previous index as a 'best guess' (works in a downward list\n                 * scenario).\n                 * <P>\n                 * Note: We have to do this since some cases where the children were inserted out of order or\n                 * even had duplicates. Relocating the 'cursor' locks it in for at least 'this' thread pass.\n                 */var cursorChildNdx=_findChildNdx(expectantParentNode,treeLoadResult.cursorNodeId);var insertionChildNdx=cursorChildNdx;if(addAfter){/**\n                     * Reset the 'start' info of the 'parent' node (Server bug? we should not have to do this)\n                     */if(origCursorObj){expectantParentNode.cursorObject.startIndex=origCursorObj.startIndex;expectantParentNode.cursorObject.startOccUid=origCursorObj.startOccUid;expectantParentNode.cursorObject.startReached=origCursorObj.startReached;}/**\n                     * First new 'child' node inserted AFTER another cannot be an 'incompleteHead'.\n                     */_.first(treeLoadResult.childNodes).incompleteHead=false;/**\n                     * Insert new 'child' nodes into 'parent' AFTER cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteTail'.\n                     */if(insertionChildNdx===-1){insertionChildNdx=treeLoadResult.startChildNdx;}else{expectantParentNode.children[cursorChildNdx].incompleteTail=false;insertionChildNdx++;}arrayUtils.insert(expectantParentNode.children,insertionChildNdx,treeLoadResult.childNodes);}else{/**\n                     * Reset the 'end' info of the 'parent' node (Server bug? we should not have to do this)\n                     */if(origCursorObj){expectantParentNode.cursorObject.endIndex=origCursorObj.endIndex;expectantParentNode.cursorObject.endOccUid=origCursorObj.endOccUid;expectantParentNode.cursorObject.endReached=origCursorObj.endReached;}/**\n                     * Last new 'child' node inserted BEFORE another cannot be an 'incompleteTail'\n                     */_.last(treeLoadResult.childNodes).incompleteTail=false;/**\n                     * Insert new 'child' nodes into 'parent' BEFORE cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteHead'.\n                     */if(insertionChildNdx===-1){insertionChildNdx=treeLoadResult.startChildNdx;}else{expectantParentNode.children[cursorChildNdx].incompleteHead=false;}arrayUtils.insertBefore(expectantParentNode.children,insertionChildNdx,treeLoadResult.childNodes);}}/**\n             * Fire a 'resetState' event, sourced to this uwDataProvider, for all tree-table 'focused load'\n             * cases.\n             */if(!treeLoadResult.retainTreeExpansionStates){if(isParentRoot&&treeLoadResult.isFocusedLoad){eventBus.publish(dpSelf.name+'.resetState',{});}}/**\n             * Check if we were given a non-trivial path to a root (the new 'child' nodes are to be added to the\n             * bottom of).\n             */if(nRootPaths>1&&newParent){dpSelf.topTreeNode=_.first(treeLoadResult.rootPathNodes);dpSelf.topNodeUid=dpSelf.topTreeNode.uid;if(!treeLoadResult.vmNodesInTreeHierarchyLevels){var newNodes=[];var prevParentNode=treeLoadResult.rootPathNodes[0];for(var ndx=1;ndx<treeLoadResult.rootPathNodes.length;ndx++){var parent=treeLoadResult.rootPathNodes[ndx];newNodes.push(parent);prevParentNode.children=[parent];/**\n                         * If expansion states are cleared after 'resetState' event, tree hierarchy that we are\n                         * creating while building tree using rootPathNodes, those rootPathNodes should be saved in\n                         * expansion state as they are expanded.\n                         * <P>\n                         * This is required for tree refresh scenarios (the level the user is working on should get\n                         * restored after refresh)\n                         */saveRowExpanded(dataCtxNode,parent);prevParentNode=parent;}/**\n                     * Mark the children to be 1 level below the 'expectant' parent\n                     */var nextLevelNdx=_.last(treeLoadResult.rootPathNodes).levelNdx+1;for(var ndx2=0;ndx2<treeLoadResult.childNodes.length;ndx2++){var child=treeLoadResult.childNodes[ndx2];child.levelNdx=nextLevelNdx;child.$$treeLevel=nextLevelNdx;newNodes.push(child);}/**\n                     * Put all the 'parent' path + 'child' nodes as the sole content of the collection\n                     */response.totalFound=treeLoadResult.rootPathNodes.length-1+treeLoadResult.totalChildCount;response.loadedVMObjects=newNodes;}else{var currentlyLoadedRootPathNodeVMO=null;var startLevelIndex=0;var loadedVMOs=vmCollection.getLoadedViewModelObjects();var numberOfLevelsToBeInserted=0;// Check if there is request to merge new ViewModelTreeNodes from TreeLoadResult into existing loaded VMOs.\nif(treeLoadResult.mergeNewNodesInCurrentlyLoadedTree&&loadedVMOs){for(startLevelIndex=treeLoadResult.rootPathNodes.length;startLevelIndex>=1;startLevelIndex--){currentlyLoadedRootPathNodeVMO=loadedVMOs.filter(function(vmo){return treeLoadResult.rootPathNodes[startLevelIndex-1]&&vmo.id===treeLoadResult.rootPathNodes[startLevelIndex-1].id;})[0];/**\n                             * currentlyLoadedRootPathNodeVMO is the parent node which is currently loaded in\n                             * VMO and its also present in response structure.\n                             */if(currentlyLoadedRootPathNodeVMO){numberOfLevelsToBeInserted++;currentlyLoadedRootPathNodeVMO.nextLevelInsert=true;break;}}}/**\n                     * 1)vmNodesInTreeHierarchyLevels is an array of arrays. Each array index represents vmNodes\n                     * at given level (index 0 in array represents level -1 which is not displayed, index 1\n                     * level 0 and so on). Each level will have node where next level nodes need to be inserted.\n                     *\n                     * 2)rootPathNodes contain array of parents with one or more having children under it.\n                     *\n                     * 3)At each level, you will have parent below which next level is supposed to be inserted.\n                     */ // Iterate through all levels\nfor(ndx=startLevelIndex;ndx<treeLoadResult.vmNodesInTreeHierarchyLevels.length;ndx++){var vmNodes=treeLoadResult.vmNodesInTreeHierarchyLevels[ndx];// Get parent node below which next level needs to be inserted.\nvar nextLevelParentNode=vmNodes.filter(function(vmo){return treeLoadResult.rootPathNodes[ndx]&&vmo.id===treeLoadResult.rootPathNodes[ndx].id;})[0];if(nextLevelParentNode){nextLevelParentNode.nextLevelInsert=true;numberOfLevelsToBeInserted++;}}const viewModelObjects=getViewModelCollectionInTreeHierarchyFormat(treeLoadResult,vmCollection,currentlyLoadedRootPathNodeVMO,startLevelIndex,numberOfLevelsToBeInserted,dataCtxNode);response.loadedVMObjects=viewModelObjects;response.totalFound=viewModelObjects.length;}}else if(treeLoadResult.nonRootPathHierarchicalData){/**\n                 * If we are given multiple expanded nodes which are all not necessarily on the \"rootPath\"\n                 */const viewModelObjects=getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult,vmCollection,dataCtxNode);if(viewModelObjects){response.loadedVMObjects=viewModelObjects;response.totalFound=viewModelObjects.length;}}else{/**\n                 * Check if we are processing the unseen 'root' node.<br>\n                 * If so: Just add the results as the only items in the collection.<BR>\n                 * If not: Insert the results in at the correct location.\n                 */if(isParentRoot&&treeLoadResult.startChildNdx===0){response.totalFound=treeLoadResult.totalChildCount;response.loadedVMObjects=_.clone(treeLoadResult.childNodes);}else{if(treeLoadResult.cursorNodeId){_insertModelObjects(vmCollection,treeLoadResult.cursorNodeId,treeLoadResult.childNodes,addAfter);}else{if(treeLoadResult.startChildNdx===0){_insertModelObjects(vmCollection,uwUtilSvc.getEvaluatedId(expectantParentNode),treeLoadResult.childNodes,addAfter);}else{var insertionNode=expectantParentNode.children[treeLoadResult.startChildNdx-1];_insertModelObjects(vmCollection,uwUtilSvc.getEvaluatedId(insertionNode),treeLoadResult.childNodes,addAfter);}}}/**\n                 * Update the totalNumber of known 'child' nodes.\n                 */expectantParentNode.totalChildCount=treeLoadResult.totalChildCount;}/**\n             * Fire a 'modelObjectsUpdated' event, sourced to this uwDataProvider, but only for changes to the\n             * outer-most level. This event includes the entire ViewModelCollection. This event is required to\n             * have the aw-table controller know when to update the information in the GridWrapper.\n             */if(isParentRoot){var nChild=resultParentNode.children?resultParentNode.children.length:0;moreAboveFirst=false;moreBelowLast=false;if(resultParentNode.cursorObject){moreAboveFirst=!resultParentNode.cursorObject.startReached;moreBelowLast=!resultParentNode.cursorObject.endReached;}else{moreBelowLast=resultParentNode.totalChildCount>nChild;}_notifyModelObjectsUpdate(dataCtxNode,{prevPage:moreAboveFirst,nextPage:moreBelowLast});}else{dpSelf.syncSelectionModel(dataCtxNode);}/**\n             * Fire a 'treeNodesLoaded' event, sourced to this uwDataProvider, for all tree-table changes. This\n             * event includes only the input/result structures for the current load operation. This event is\n             * used to load additional properties in an async fashion.\n             */eventBus.publish(dpSelf.name+'.treeNodesLoaded',{treeLoadInput:treeLoadInput,treeLoadResult:treeLoadResult});/**\n             * Check if the response indicates we should make sure the parent is expanded.\n             */if(treeLoadResult.expandParent){eventBus.publish(dpSelf.name+'.expandTreeNode',{parentNode:resultParentNode});}}else if(isParentRoot){/**\n             * If this is the 'top' level node we now know it IS empty.\n             */dpSelf.noResults=true;/**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */newTopNode=treeLoadResult.newTopNode;if(newTopNode&&newTopNode.levelNdx===-1){dpSelf.topTreeNode=newTopNode;dpSelf.topTreeNode.children=null;dpSelf.topNodeUid=dpSelf.topTreeNode.uid;}/**\n             * If empty child nodes are passed to provider, they should be honored and should get updated in UI.\n             */if(treeLoadResult.startChildNdx===0){/**\n                 * This change is when we delete a single row from the tree table\n                 */moreAboveFirst=false;moreBelowLast=false;/**\n                 * Determine if this node is NOT an 'incompleteHead' or 'incompleteTail'\n                 */if(resultParentNode.cursorObject){moreAboveFirst=!resultParentNode.cursorObject.startReached;moreBelowLast=!resultParentNode.cursorObject.endReached;}var emptyChildNodes=!moreAboveFirst&&!moreBelowLast;if(emptyChildNodes){response.totalFound=treeLoadResult.totalChildCount;response.loadedVMObjects=_.clone(treeLoadResult.childNodes);_notifyModelObjectsUpdate(dataCtxNode,{prevPage:moreAboveFirst,nextPage:moreBelowLast});}}}return response;}/**\n     * @param {TreeLoadResult} treeLoadResult - Object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection - VMO array to set\n     * @param {ViewModelObject} currentlyLoadedRootPathNodeVMO - ...\n     * @param {Number} startLevelIndex -\n     * @param {Number} numberOfLevelsToBeInserted -\n     */function getViewModelCollectionInTreeHierarchyFormat(treeLoadResult,vmCollection,currentlyLoadedRootPathNodeVMO,startLevelIndex,numberOfLevelsToBeInserted,dataCtxNode){var finalVMOs=[];var lvlNdx=startLevelIndex;var numberOfLevelsInserted=0;var indx=0;if(currentlyLoadedRootPathNodeVMO){/**\n             * currentlyLoadedRootPathNodeVMO is populated. That means parentNode that has come in\n             * TreeLoadResult is already loaded in vmCollection. In that case , restore existing VMOs, merge new\n             * VMOs that we got in response in currently loaded VMOs.\n             */arrayUtils.insert(finalVMOs,0,vmCollection.getLoadedViewModelObjects());indx=finalVMOs.indexOf(currentlyLoadedRootPathNodeVMO);}else{// Build Final ViewModelTreeNodes array. Add zeroth level , iterate, check for next level insertion point,\n// and add new level there.Keep building and iterating through whole list.\narrayUtils.insert(finalVMOs,0,treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx++]);}while(indx<finalVMOs.length&&numberOfLevelsInserted<numberOfLevelsToBeInserted){var vmo=finalVMOs[indx];if(vmo.nextLevelInsert){vmo.isExpanded=true;for(let vmNodeInTreeHierarchyLevel of treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]){var finalVMOIndex=0;for(let finalVMO of finalVMOs){if(finalVMO&&finalVMO.id===vmNodeInTreeHierarchyLevel.id){finalVMOs.splice(finalVMOIndex,1);}finalVMOIndex++;}}arrayUtils.insert(finalVMOs,indx,treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]);// Next level nodes should be stored as children under current level parent.\nvmo.children=_.clone(treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]);vmo.totalChildCount=vmo.children.length;vmo.isLeaf=false;// Store parent as expanded in state/local storage.\nsaveRowExpanded(dataCtxNode,vmo);delete vmo.nextLevelInsert;lvlNdx++;numberOfLevelsInserted++;}indx++;}// filter out vmo with treeLevel -1 as we don't show topLevel Node.\nfinalVMOs=finalVMOs.filter(function(vmo){return vmo.$$treeLevel!==-1;});return finalVMOs;}/**\n     * @param {TreeLoadResult} treeLoadResult object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection VMO array to set\n     */function getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult,vmCollection,dataCtxNode){let finalVMOs=[];if(treeLoadResult.mergeNewNodesInCurrentlyLoadedTree){finalVMOs=vmCollection.getLoadedViewModelObjects();}for(let index=0;index<treeLoadResult.vmNodesInTreeHierarchyLevels.length;index++){let currentNodes=treeLoadResult.vmNodesInTreeHierarchyLevels[index];for(let node=0;node<currentNodes.length;node++){let vmoIndex=-1;let levelIndex=0;let currentNode=currentNodes[node];finalVMOs.forEach((vmo,index)=>{if(currentNode){if(vmo.id===currentNode.id){vmoIndex=index;}if(vmo.id===currentNode.parentUid){levelIndex=index;}}});if(vmoIndex!==-1){_.assign(finalVMOs[vmoIndex],currentNode);}else{arrayUtils.insert(finalVMOs,levelIndex+node,[currentNode]);}saveRowExpanded(dataCtxNode,currentNode);}}if(!treeLoadResult.mergeNewNodesInCurrentlyLoadedTree){return finalVMOs;}}/**\n     * @param {ViewModelTreeNode} parentNode - (Optional) The 'parent' to use when determining input.\n     *\n     * @param {String} cursorNodeId - (Optional) The ID of the node to insert above/below\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Object} The resolved input object to pass to 'createTreeLoadInput'.\n     */function _determineInput(parentNode,cursorNodeId,addAfter){/**\n         * Determine 'child' index to use as basis for loading.\n         *\n         * <pre>\n         * Handle various cases of 'parent' and/or 'cursorNodeId' validity:\n         * 1) 'parent' and 'cursorNodeId' valid:             Locate the 'cursorNodeId' in the 'parent' and use its index.\n         * 2) 'parent' valid and 'cursorNodeId' not valid:   Use either end of the 'parent' children as the index.\n         * 3) 'parent' NOT valid and the 'cursor' is valid:  Locate the 'parent' of the 'cursor' and use the 'cursor' index.\n         * 4) 'parent' NOT valid and the 'cursor' NOT valid: Fail assertion.\n         * Note: Case 3) is used when dynamically loading the next page of 'children' directly after/before the\n         * 'cursor' node.\n         * </pre>\n         */var startChildNdx=-1;if(parentNode){if(cursorNodeId){startChildNdx=_findChildNdx(parentNode,cursorNodeId);if(startChildNdx!==-1){startChildNdx++;}}else{if(addAfter){var nChild=parentNode.children?parentNode.children.length:0;startChildNdx=nChild;}else{startChildNdx=0;}}}else if(cursorNodeId){var vmCollection=dpSelf.viewModelCollection;var cursorNdx=vmCollection.findViewModelObjectById(cursorNodeId);if(cursorNdx!==-1){var cursorNode=vmCollection.getViewModelObject(cursorNdx);var parentLevelNdx=cursorNode.levelNdx-1;startChildNdx=1;for(var ndx=cursorNdx-1;ndx>=0;ndx--){var currRow=vmCollection.getViewModelObject(ndx);if(currRow.levelNdx===parentLevelNdx){parentNode=currRow;//Locate the 'parent' of the 'cursor' and use the Parent 'cursor' index.\nif(parentNode.cursorObject&&parentNode.cursorObject.endIndex){startChildNdx=parentNode.cursorObject.endIndex+1;}break;}startChildNdx++;}}}assert(parentNode,'Unable to determine \\'parent\\' node');assert(startChildNdx!==-1,'Unable to determine location in \\'parent\\' to insert loaded \\'child\\' nodes');return{parentNode:parentNode,startChildNdx:startChildNdx};}/**\n     * Log a warning that there was an access to this UwDataProvider after it was destroyed.\n     *\n     * @param {String} functionName - Name of the function being accessed.\n     */function _reportAccessToZombieDataProvider(functionName){logger.warn('Attempt to execute a function on a UwDataProvider after it was destroyed...'+'\\n'+//\n'Function was therefore not executed...continuing.'+'\\n'+//\n'UwDataProvider: '+dpSelf.name+'\\n'+//\n'Function: '+functionName);}/**\n     * Override the default implementation to return more helpful information.\n     *\n     * @return {String} Text used to identify the ID of the UsDataProvider (e.g. 'modelId' + an optional\n     *         'name').\n     */dpSelf.toString=function(){if(dpSelf){if(dpSelf.name){return dpSelf._modelId+'  name: '+dpSelf.name;}return dpSelf._internal.modelId+'  name: '+'???';}return'UwDataProvider (destroyed)';};/**\n     * Get all of the loaded objects that are currently selected.\n     *\n     * @return {IModelObjectArray} Array of selected {IModelObject}.\n     */dpSelf.getSelectedObjects=function(){if(dpSelf.selectionModel){var loadedVMO=dpSelf.viewModelCollection.getLoadedViewModelObjects();if(dpSelf.vmCollectionObj&&dpSelf.vmCollectionObj.preferredChoices&&dpSelf.vmCollectionObj.preferredChoices.length>0){loadedVMO=[...loadedVMO,...dpSelf.vmCollectionObj.preferredChoices];}return dpSelf.selectionModel.getSortedSelection(loadedVMO);}return[];};/**\n     * Get the indices of the selected objects.\n     *\n     * @returns {NumberArray} Resolved with the indicies of the selected objects in the ViewModelCollection.\n     */dpSelf.getSelectedIndices=function(){var loadedVMO=dpSelf.viewModelCollection.getLoadedViewModelObjects();return dpSelf.getSelectedObjects().map(function(vmo){return loadedVMO.indexOf(vmo);});};// Define with this 'incorrect' spelling as well.\ndpSelf.getSelectedIndexes=dpSelf.getSelectedIndices;/**\n     * Change the selection range\n     *\n     * @param {Number} start - String index in collection to add/remove/toggle.\n     * @param {Number} end -  Ending index in collection to add/remove/toggle.\n     * @param {Boolean} select - (Optional) TRUE, 'select'...FALSE, 'unselect'...UNDEFINED, 'toggle'.\n     */dpSelf.changeObjectsSelection=function(start,end,select){var loadedVMO=dpSelf.viewModelCollection.getLoadedViewModelObjects();// Going down : Going up\nvar e=start>end?start:end;var s=start>end?end:start;var objects=loadedVMO.slice(s,e+1);if(select===true){if(dpSelf.selectionModel.multiSelectEnabled||objects.length>1){dpSelf.selectionModel.addToSelection(objects);}else{dpSelf.selectionModel.setSelection(objects);}}else if(select===false){dpSelf.selectionModel.removeFromSelection(objects);}else{dpSelf.selectionModel.toggleSelection(objects);}};// activates multi Select mode on selection Model = multiple.\ndpSelf.multiSelectModeEvent=eventBus.subscribe(dpSelf.name+'.multiSelectModeAction',function(eventData){if(eventData&&eventData.multiSelect){dpSelf.enableMultiSelect();}else{dpSelf.disableMultiSelect();}});let _selectionModelDataCtxNode=null;// Event to expose various selection APIs on the selection model.\ndpSelf.selectActionEvent=eventBus.subscribe(dpSelf.name+'.selectAction',function(eventData){if(dpSelf.selectionModel){const oldSelection=dpSelf.selectionModel.getSelection();if(eventData){if(eventData.selectAll===true){dpSelf.selectAll();}if(eventData.selectAll===false){dpSelf.selectNone();}if(eventData.select){dpSelf.selectionModel.addToSelection(eventData.select);}if(eventData.deselect){dpSelf.selectionModel.removeFromSelection(eventData.deselect);}if(eventData.setSelection){dpSelf.selectionModel.setSelection(eventData.setSelection);}}const newSelection=dpSelf.selectionModel.getSelection();dpSelf.syncSelectionModel(_selectionModelDataCtxNode,newSelection,oldSelection);}});/**\n     * Enable MultiSelect\n     */dpSelf.enableMultiSelect=function(){if(dpSelf.selectionModel){dpSelf.selectionModel.setMultiSelectionEnabled(true);}};/**\n     * disable MultiSelect\n     */dpSelf.disableMultiSelect=function(){if(dpSelf.selectionModel){dpSelf.selectionModel.setMultiSelectionEnabled(false);dpSelf.selectNone();}};/**\n     * Select all loaded objects\n     */dpSelf.selectAll=function(){var loadedVMO=dpSelf.viewModelCollection.getLoadedViewModelObjects();dpSelf.selectionModel.addToSelection(loadedVMO);eventBus.publish(dpSelf.name+'.selectAll',{});};/**\n     * Clear selection\n     */dpSelf.selectNone=function(){dpSelf.selectionModel.setSelection([]);eventBus.publish(dpSelf.name+'.selectNone',{});};dpSelf.setSelectionEnabled=function(isSelectionEnabled){dpSelf.selectionModel.setSelectionEnabled(isSelectionEnabled);eventBus.publish(dpSelf.name+'.isSelectionEnabledChanged',{isSelectionEnabled:isSelectionEnabled});};/**\n     * Sync the view with the updated selection model.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {StringArray} newSelection -\n     * @param {StringArray} oldSelection -\n     */dpSelf.syncSelectionModel=function(dataCtxNode,newSelection,oldSelection){// Ensure the selection state is correct\n//zarq9k: Once we sync up the old viewModel and new Collection, this line would not be required.\n// issue reported - https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/56\n// We never worked on it.\nvar loadedVMO=dpSelf.vmCollectionObj.vmCollection.getLoadedViewModelObjects();//var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\nif(dpSelf.vmCollectionObj.preferredChoices&&dpSelf.vmCollectionObj.preferredChoices.length>0){loadedVMO=[...loadedVMO,...dpSelf.vmCollectionObj.preferredChoices];}loadedVMO.map(function(vmo){vmo.selected=dpSelf.selectionModel.isSelected(vmo);});// Put the selected objects on the data provider\n// Makes binding in view models simpler\nvar prevSelectedObjects=dpSelf.selectedObjects;dpSelf.selectedObjects=loadedVMO.filter(function(vmo){return vmo.selected;});var emitEvents=function(){//This check ensures notification is triggered only if there a selection change\nif(!_.isEqual(prevSelectedObjects,dpSelf.selectedObjects)){if(dpSelf.selectionModel&&dpSelf.selectionModel.selectionData){dpSelf.selectionModel.selectionData.update({selected:dpSelf.getSelectedObjects(),source:dpSelf.validSourceTypes,id:dpSelf.selectionModel.name?dpSelf.selectionModel.name:dpSelf.name,_modelId:dpSelf._modelId});trace('Selection Changed for ',dpSelf.selectionModel.name?dpSelf.selectionModel.name:dpSelf.name,dpSelf.selectedObjects);}let eventObj={selectedObjects:dpSelf.getSelectedObjects(),selectedUids:dpSelf.selectionModel.getSelection(),scope:dataCtxNode,selectionModel:dpSelf.selectionModel,selected:dpSelf.getSelectedObjects(),dataProviderName:dpSelf.name,dataProvider:dpSelf};// Always notify through event bus\neventBus.publish(dpSelf.name+'.selectionChangeEvent',eventObj);}};// Handle case where something is selected that is not in data provider\nif(dpSelf.focusAction){var shouldEmitSelectionEvent=true;// Ignore the simple sync to mark objects as selected\nif(newSelection&&oldSelection){var newlySelected=newSelection.filter(function(x){return oldSelection.indexOf(x)===-1;});// If a single new object was selected attempt to focus\nif(newlySelected.length===1){// Try to get object from current list\nvar newlySelectedObject=dpSelf.selectedObjects.filter(function(vmo){return prevSelectedObjects.indexOf(vmo)===-1;})[0];// If not found clear current list and focus\nif(!newlySelectedObject){shouldEmitSelectionEvent=false;// Reset cursor\nif(dpSelf.cursorObject){dpSelf.cursorObject=null;}dpSelf.pageDispatcher({type:'FOCUS_PAGE'});dpSelf.vmCollectionDispatcher({type:'FOCUSING',focusing:true});}else{eventBus.publish(dpSelf.name+'.focusSelection');}}}if(shouldEmitSelectionEvent){emitEvents();}}else{var uidSet=new Set();_.forEach(dpSelf.selectedObjects,function(obj){var uid;if(typeof obj==='object'){uid=obj.uid;}else{uid=obj;}uidSet.add(uid);});//If the selectionModel is shared, there is possibility that the selectionModel can have\n//stale/invalid selection stored.\n//Give precedence to dataprovider selection in case of shared selectionModel\nconst isSharedSelectionModel=_ctorInputData&&_ctorInputData.selectionModel;if(isSharedSelectionModel&&uidSet.size!==dpSelf.selectionModel.getCurrentSelectedCount()){// Default behavior is to remove any object not found from the selection model\ndpSelf.selectionModel.setSelection(dpSelf.selectedObjects);}//Notify selection change in the same render cycle\nemitEvents();}// Check selection state\ndpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);};/**\n     * Detach the selection model from the data provider. Should only be done when re-initializing.\n     */dpSelf.detachSelectionModel=function(){if(dpSelf.syncSelectionEvent){dpSelf.syncSelectionEvent();dpSelf.syncSelectionEvent=null;}};/**\n     * Attach the data provider to its current selection model. Ensures re-initialization of the data provider\n     * will not result in duplicate event listeners / watches.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */ // dpSelf.attachSelectionModel = function( dataCtxNode ) {\n//     // _selectionModelDataCtxNode = dataCtxNode;\n//     // Remove previous watch if it is still setup\n//     // dpSelf.detachSelectionModel();\n//     // dpSelf.selectionModel.syncSelections = function( oldVal, newVal ) {\n//     //     dpSelf.syncSelectionModel( dataCtxNode, newVal, oldVal );\n//     // };\n// };\n/**\n     * Attach the selection model immediately. Will be detached / reattached if data provider is initialized.\n     * However cannot assume data provider is ever initialized.\n     */ //dpSelf.attachSelectionModel( {} );\n/**\n     * Swap selection model with the new selection model provided as input. Detach current selection model and\n     * attach the new one\n     *\n     * @param {Object} newSelectionModel - new selection model which is required to swap\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */dpSelf.swapSelectionModel=function(newSelectionModel,dataCtxNode){// Detach the selection model while initializing\ndpSelf.detachSelectionModel();dpSelf.selectionModel=newSelectionModel;dpSelf.attachSelectionModel(dataCtxNode);};// ======================== Edit Handler Interface ===================================================//\n/**\n     *\n     * @param {*} stateName current state of edit\n     * @param {*} dpSelf data provider instance\n     */var _notifyEditStateChange=function(stateName,dpSelf){dpSelf._editingState=stateName;dpSelf._editing=stateName==='starting';// Add to the appCtx about the editing state\nappCtxService.updateCtx(dpSelf._appCtxEditInProgress,dpSelf._editing);eventBus.publish(dpSelf._eventTopicEditInProgress,dpSelf._editing);};if(!dpSelf._appCtxEditInProgress){dpSelf._appCtxEditInProgress=dpSelf.name+'_editInProgress';dpSelf._eventTopicEditInProgress=dpSelf.name+'.editInProgress';}/**\n     * isDirty implementation of edit-handler interface.\n     * It check if any of the view model property inside view model object is modified.\n     * @returns {*} AwPromiseService.instance with promise true/false        *\n     */dpSelf.isDirty=function(){var viewModelCollection=dpSelf.viewModelCollection.getLoadedViewModelObjects();return editUtilsService._isDirty(viewModelCollection);};/**\n     * Determines if prop edit is enabled for this dataprovider\n     * @param {Object} declViewModel the declarative view model\n     * @returns {*} true if individual prop editing is enabled\n     */dpSelf.isPropEditEnabled=function(declViewModel){if(dpSelf.json&&dpSelf.json.enablePropEdit){// If boolean is used return it directly otherwise evaluate the value as a condition\nif(typeof dpSelf.json.enablePropEdit==='boolean'){return dpSelf.json.enablePropEdit;}const evaluationEnv={data:declViewModel,ctx:appCtxService.ctx,conditions:declViewModel._internal.conditionStates};return declUtils.evaluateCondition(declViewModel,dpSelf.json.enablePropEdit,evaluationEnv);}else if(dpSelf.json&&dpSelf.json.enablePropEdit===false){return false;}// Default is true if enablePropEdit is not defined\nreturn true;};/**\n     * This function implements the start edit function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n     * @return {*} AwPromiseService.instance with promise.\n     */dpSelf.startEdit=function(dataCtxNode,declViewModel,editOptions){var viewModelCollection=dpSelf.viewModelCollection.getLoadedViewModelObjects();var editConfig=dpSelf.json.editConfig;editConfig.sourceModel=dpSelf.name;const saveEditStateChangeCallback=function(){_notifyEditStateChange('saved',dpSelf);};return editUtilsService._startEdit(dataCtxNode,declViewModel,viewModelCollection,editConfig,saveEditStateChangeCallback,editOptions).then(function(){if(!editOptions){_notifyEditStateChange('starting',dpSelf);}});};/**\n     * This is the cancel edits implementation of edit-handler interface.\n     * @param  {*} dataCtxNode data ctx Node.\n     * @param  {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise\n     */dpSelf.cancelEdits=function(dataCtxNode,declViewModel){var viewModelCollection=dpSelf.viewModelCollection.getLoadedViewModelObjects();var editConfig=dpSelf.json.editConfig;return editUtilsService._cancelEdits(dataCtxNode,declViewModel,viewModelCollection,editConfig).then(function(){_notifyEditStateChange('canceling',dpSelf);});};/**\n     * This function implements the save edits function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise.\n     */dpSelf.saveEdits=function(dataCtxNode,declViewModel){var viewModelCollection=dpSelf.viewModelCollection.getLoadedViewModelObjects();var editConfig=dpSelf.json.editConfig;return editUtilsService._saveEdits(dataCtxNode,declViewModel,viewModelCollection,editConfig).then(function(){_notifyEditStateChange('saved',dpSelf);});};/**\n     * @returns {*} boolean true/false\n     */dpSelf.editInProgress=function(){return dpSelf._editing;};dpSelf.setFilterString=filterVal=>{filterStr=filterVal;};dpSelf.getFilterString=()=>{return filterStr;};// ======================== End of Edit Handler Interface ===================================================//\n/**\n     * Initialize and trigger first page of results.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @return {Promise} A promise object resolved with the ViewModelCollection returned by the current\n     *         DataProviderService.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.initialize=function(dataCtxNode){var promise;if(dpSelf.cursorObject){dpSelf.cursorObject=null;}dpSelf.setFilterString(filterStr);/**\n         * If the constructor was told there would be some additional input data passed in from the data ctx\n         * node attempt to get it at this point.\n         * <P>\n         * Note: The input data from the scope can only override specific properties.\n         */if(!_.isEmpty(_ctorInputData)){var declViewModel=declUtils.findViewModel(dataCtxNode);dataCtxService.applyScope(declViewModel,_ctorInputData,null,dataCtxNode);_.forEach(_ctorInputData,function(value,name){if(_modifiablePropertiesViaInputData.indexOf(name)!==-1){dpSelf[name]=value;}});}/** editHandler */if(dpSelf.json.editContext){let reusableEditHandler=editHandlerSvc.getEditHandler(dpSelf.json.editContext);// If editHandler already exists don't create a new one - which overwrites the old one\nif(!reusableEditHandler){editHandlerSvc.setEditHandler(editHandlerFactory.createEditHandler(dataSourceService.createNewDataSource({dataProvider:dpSelf}),dpSelf.editSupportParamKeys),dpSelf.json.editContext);// set this handler active\neditHandlerSvc.setActiveEditHandlerContext(dpSelf.json.editContext);_editHandlerRegistered=true;}}promise=Promise.resolve(dpSelf.resetDataProvider());// Detach the selection model while initializing\n// dpSelf.detachSelectionModel();\n/** revisitme Shaishav: This should be dead code in future because we delegated this responsibility to dataProviderUtils js\n         *  Keeping the code for now to ensure we do not miss any functionality while migrating\n\n        if( dpSelf.accessMode === 'tree' ) {\n            dpSelf.topTreeNode = _determineTopTreeNode( dpSelf.topNodeUid );\n\n            promise = dpSelf.getTreeNodeInitial( dataCtxNode, dpSelf.topTreeNode, null, true,\n                dpSelf.topTreeNode ).then( function( response ) {\n                dpSelf.attachSelectionModel( dataCtxNode );\n\n                return response;\n            } );\n        } else {\n            dpSelf.startIndex = 0;\n\n            var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, false, dataCtxNode.filterStr );\n\n            var actionRequestObj = {\n                listLoadInput: listLoadInput\n            };\n\n            var action = dpSelf.initializeAction ? dpSelf.initializeAction : dpSelf.action;\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugDataProviderInitialize( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj, _ctorInputData );\n            }\n\n            promise = dpSelf.someDataProviderSvc.getFirstPage( action, dpSelf.json, dataCtxNode,\n                actionRequestObj ).then(\n                function( response ) {\n                    eventBus.publish( dpSelf.name + '.resetScroll', {} );\n                    var vmCollection = dpSelf.viewModelCollection;\n\n                    vmCollection.clear();\n                    vmCollection.setTotalObjectsFound( response.totalFound );\n\n                    if( response.totalFound > 0 && response.results ) {\n                        dpSelf.noResults = false;\n\n                        vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                            dpSelf.preSelection );\n\n                        /**\n                         * Determine if the last node in the collection is an 'incompleteTail' because we know\n                         * there are more found than currently loaded.\n                        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                            vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                        }\n                    } else {\n                        dpSelf.noResults = true;\n                        // assigning no result found string if there is no data from rest service\n                        if( dpSelf.json.noResultsFound ) {\n                            var i18nkey = dpSelf.json.noResultsFound;\n                            i18nkey = parsingUtils.geti18nKey( i18nkey );\n                            dpSelf.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                        }\n                    }\n\n                    // dpSelf.attachSelectionModel( dataCtxNode );\n\n                    _notifyModelObjectsUpdate( null, {\n                        firstPage: true\n                    } );\n\n                    return response;\n                },\n                function( err ) {\n                    logger.warn( err );\n                } );\n        }\n        */ // Attach selection model once first page is loaded\npromise.then(function(response){if(dpSelf.selectionModel&&dpSelf.selectionModel.getSelection().length>0){/**\n                 * Fire modelObjects updated event using data provider name space\n                 */eventBus.publish(dpSelf.name+'.focusSelection');}/**\n             * Note: Not all dataCtxNodes are actually AngularJS $scopes. So we have to check if the $scope API\n             * exists before we try to use it.\n             */if(dataCtxNode.$on){dataCtxNode.$on('dataProvider.selectAction',function(event,data){if(data&&data.selectAll){dpSelf.selectAll();}else{dpSelf.selectNone();}});dataCtxNode.$on('dataProvider.multiSelectAction',function(event,data){if(data&&data.multiSelect){dpSelf.enableMultiSelect();}else{dpSelf.disableMultiSelect();}});}return response;});return promise;};// initialize\ndpSelf.setDataUpdater=(pageDispatcher,vmCollectionDispatcher)=>{dpSelf.pageDispatcher=pageDispatcher;dpSelf.vmCollectionDispatcher=vmCollectionDispatcher;};dpSelf.setSelectionModel=_ref=>{let{selectionModel,selectionDispatcher}=_ref;dpSelf.selectionModel=selectionModel;selectionModelDispatcher=selectionDispatcher;};dpSelf.setRootReference=ref=>{referenceElement=ref;};dpSelf.setPropsCallback=getProps=>{propsCallback=getProps;};dpSelf.getRootReference=()=>{return referenceElement;};dpSelf.setLovEntryRef=ref=>{lovEntryRef=ref;};dpSelf.getLovEntryRef=()=>{return lovEntryRef;};dpSelf.setPagination=pageOption=>{if(!paginationOption){paginationOption=pageOption;}};dpSelf.getPagination=()=>{return paginationOption?paginationOption:null;};dpSelf.resetDataProvider=()=>{dpSelf.vmCollectionDispatcher({type:'COLLECTION_RESET'});dpSelf.pageDispatcher({type:'PAGE_RESET'});dpSelf.vmCollectionDispatcher({type:'IN_PROGRESS',fetching:false});// Spare the selection model reset, if it is shared one.\nif(_ctorInputData&&!_ctorInputData.selectionModel||!_ctorInputData){dpSelf.selectNone();}};/**\n     * validate the lovValueSections if it needs to call the \"validateLOVValueSelections\" soa\n     *\n     * @param {array} lovEntry - the lovEntry which is gotten from \"getinitialValues\" SOA and it's the selected\n     *            item\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Promise} A promise object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.validateLOV=function(_ref2,dataCtxNode){let{lovEntries,vmo,viewModelProp}=_ref2;try{let action=dpSelf.validateAction;return dpSelf.someDataProviderSvc.validateLOVSelection({lovEntries,vmo,viewModelProp},dataCtxNode,action,dpSelf.json);}catch(e){//In Table, when user edits LOV manually and clicks outside, widget is destroyed and hence LOV dataprovider as well\n//Due to this, if user clicks outside, dpSelf is coming as NULL and dpSelf.validateAction throws exception\n// Because of this behavior, user is not able to save even valid values.\n//To fix this we have to remove LOV validation outside\nreturn Promise.resolve({valid:true});}};/**\n     * Set the currently loaded view model objects based on the model object (or uid data) in the given array of\n     * 'result' objects.\n     *\n     * @param {ViewModelObjectArray} newVMOs - Array of ViewModelObjects to set.\n     * @param {Number} totalFound - total found\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.update=function(newVMOs,totalFound){if(newVMOs){let updatedVMOs=newVMOs;//create a new reference only if there is an existing VMOs array to trigger update else use the same.\nif(!newVMOs.objects){updatedVMOs=[...newVMOs];}let totalFoundIn=totalFound;if(_.isUndefined(totalFoundIn)){totalFoundIn=updatedVMOs.length;}dpSelf.noResults=totalFoundIn===0;let vmCollection=dpSelf.viewModelCollection;vmCollection.clear();vmCollection.setTotalObjectsFound(totalFoundIn);if(dpSelf.accessMode==='tree'){vmCollection.loadedVMObjects=updatedVMOs;}else{vmCollection.updateModelObjects(updatedVMOs,dpSelf.uidInResponse,dpSelf.preSelection);/**\n                 * Determine if the last node in the collection is an 'incompleteTail' because we know there are\n                 * more found than currently loaded.\n                 */if(!_.isEmpty(vmCollection.loadedVMObjects)&&vmCollection.totalFound>dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()){_.last(vmCollection.loadedVMObjects).incompleteTail=true;}/**\n                 * Maintain selections based on the new VMOs.\n                 */const selectedObjects=dpSelf.getSelectedObjects();dpSelf.selectionModel.setSelection(selectedObjects);_notifyModelObjectsUpdate();}dpSelf.vmCollectionDispatcher({type:'COLLECTION_REPLACE',viewModelObjects:vmCollection.loadedVMObjects,totalFound:vmCollection.loadedVMObjects.length});}};dpSelf.viewModelCollection.update=dpSelf.update;/**\n     * Required. Get item at specified index\n     *\n     * @param {Number} index - index of the list\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Object} object specified at the given index\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getItemAtIndex=function(index,dataCtxNode){if(index>dpSelf.viewModelCollection.getTotalObjectsLoaded()){dpSelf.getNextPage(dataCtxNode);return null;}return dpSelf.viewModelCollection.getViewModelObject(index);};/**\n     * Get ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @return {ViewModelCollection} Reference to the ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getViewModelCollection=function(){return dpSelf.viewModelCollection;};// 20201010 Per tec meeting discussion, dataProvider should never have types, data parser has the role to process data source.\n// /**\n//  * return the same data structure of the list items in the link-with-popup window\n//  * <P>\n//  * Note: Used for aw-link-with-popup.directive<BR>\n//  *\n//  * @memberof module:js/dataProviderFactory~UwDataProvider\n//  *\n//  * @param {Number} index - index of the list\n//  * @param {Object} dataCtxNode - The data context the queryy is occurring within.\n//  * @param {String} dataProviderType - The types of dataProvider: \"static\" \"TcLOV\" \"Action\"\n//  *\n//  * @return {Object} The same data structure of the list items in the link-with-popup window.\n//  */\n// dpSelf.createPopupObject = function( index, dataCtxNode, dataProviderType ) {\n//     if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n//         dpSelf.getNextPage( dataCtxNode );\n//         return null;\n//     }\n//     var listElement = {\n//         listElementDisplayValue: '',\n//         listElementObject: ''\n//     };\n//     var displayValue;\n//     var viewModelObject = dpSelf.getItemAtIndex( index, dataCtxNode );\n//     if( !viewModelObject ) {\n//         return listElement;\n//     }\n//     if( dataProviderType ) {\n//         if( dataProviderType === 'TcLOV' ) {\n//             displayValue = viewModelObject.propDisplayValue;\n//         } else if( dataProviderType === 'Action' ) {\n//             var displayStr;\n//             if( dataCtxNode.displayProperty ) {\n//                 displayStr = _.get( viewModelObject, dataCtxNode.displayProperty );\n//             } else {\n//                 displayStr = _.get( viewModelObject.props, 'object_string' );\n//             }\n//             displayValue = displayStr.uiValue;\n//         } else if( dataProviderType === 'Static' ) {\n//             if( viewModelObject.staticDisplayValue && viewModelObject.staticElementObject ) {\n//                 displayValue = viewModelObject.staticDisplayValue;\n//                 viewModelObject = viewModelObject.staticElementObject;\n//             } else {\n//                 displayValue = viewModelObject;\n//             }\n//         } else {\n//             displayValue = viewModelObject;\n//         }\n//     } else {\n//         displayValue = viewModelObject;\n//     }\n//     listElement.listElementDisplayValue = displayValue;\n//     listElement.listElementObject = viewModelObject;\n//     if( dpSelf.viewModelCollection.getTotalObjectsFound() ) {\n//         var totalFound = 0;\n//     }\n//     if( !viewModelObject && !totalFound ) {\n//         // no result found\n//         listElement.listElementDisplayValue = dataCtxNode.prop.uiValue;\n//         listElement.listElementObject = dataCtxNode.prop.dbValue;\n//     }\n//     if( dataCtxNode.isLoading ) {\n//         // no result found\n//         listElement.listElementDisplayValue = dpSelf.isLoading;\n//         listElement.listElementObject = dpSelf.isLoading;\n//     }\n//     return listElement;\n// }; // createPopupObject\n/**\n     * Required. For infinite scroll behavior, we always return a slightly higher number than the previously\n     * loaded items.\n     *\n     * @return {Number} number of objects loaded.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getLength=function(){return dpSelf.viewModelCollection.getVirtualLength();};/**\n     * Check if there is more data to load\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.hasMorePages=function(){if(dpSelf._isDestroyed){_reportAccessToZombieDataProvider('hasMorePages');return false;}/**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */if(dpSelf.accessMode==='tree'){if(dpSelf.topTreeNode&&dpSelf.topTreeNode.cursorObject){return!dpSelf.topTreeNode.cursorObject.endReached;}return false;}/**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */if(dpSelf.cursorObject){return!dpSelf.cursorObject.endReached;}return dpSelf.viewModelCollection.getTotalObjectsFound()>dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();};/**\n     * Check if there is more data to load before current position.\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.hasMorePagesUp=function(){if(dpSelf._isDestroyed){_reportAccessToZombieDataProvider('hasMorePagesUp');return false;}/**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */if(dpSelf.accessMode==='tree'){if(dpSelf.topTreeNode&&dpSelf.topTreeNode.cursorObject){return!dpSelf.topTreeNode.cursorObject.startReached;}return false;}/**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */if(dpSelf.cursorObject){return!dpSelf.cursorObject.startReached;}return false;};/**\n     * Finds and returns a vmo with an incomplete head/tail in the given range.\n     * @param { Number } startIdx - index of the first node in the range\n     * @param { Number } endIdx - index of the last node in the range\n     *\n     * @return {Object} The node with an incomplete head/tail\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.findIncompleteNodeInRange=function(startIdx,endIdx){for(var i=startIdx;i<=endIdx;i++){var vmNode=dpSelf.viewModelCollection.loadedVMObjects[i];if(vmNode&&(vmNode.incompleteHead===true||vmNode.incompleteTail)){return vmNode;}}return null;};/**\n     * Get previous page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the previous page is loaded and the viewModelCollection is\n     *         updated. Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getPreviousPage=function(dataCtxNode){if(dpSelf._isDestroyed){_reportAccessToZombieDataProvider('getPreviousPage');return $q.reject('Access to destroyed UwDataProvider.');}assert(dpSelf.previousAction,'Invalid action specified');if(dpSelf.accessMode==='tree'){var cursorNode=_.first(dpSelf.topTreeNode.children);if(cursorNode){return dpSelf.getTreeNodePage(dataCtxNode,dpSelf.topTreeNode,cursorNode.id,false,dpSelf.topTreeNode);}return $q.resolve(dpSelf.viewModelCollection);}var listLoadInput=awTableSvc.createListLoadInput(null,0,null,false,true);var actionRequestObj={listLoadInput:listLoadInput};updateDataCtxNodeWithProps(dataCtxNode);return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.previousAction,dpSelf.json,dataCtxNode,actionRequestObj).then(function(response){dpSelf.viewModelCollection.setTotalObjectsFound(response.totalFound);if(response.totalFound>0){dpSelf.viewModelCollection.updateModelObjects(response.results,dpSelf.uidInResponse,dpSelf.preSelection,true);}_notifyModelObjectsUpdate(dataCtxNode,{prevPage:true});return $q.resolve(dpSelf.viewModelCollection);});};/**\n     * Get next page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the next page is loaded and the viewModelCollection is updated.\n     *         Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getNextPage=function(dataCtxNode){// revisit me - temp fix to make dataProvider instance consistent\nconst dpSelf=this;if(dpSelf._isDestroyed){_reportAccessToZombieDataProvider('getNextPage');return $q.reject('Access to destroyed UwDataProvider.');}if(dpSelf.accessMode==='tree'){var cursorNode=_.last(dpSelf.topTreeNode.children);if(cursorNode){return dpSelf.getTreeNodePage(dataCtxNode,dpSelf.topTreeNode,cursorNode.id,true,dpSelf.topTreeNode);}return $q.resolve(dpSelf.viewModelCollection);}var totalFound=dpSelf.viewModelCollection.getTotalObjectsFound();var totalUniqueLoaded=dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();if(totalFound>totalUniqueLoaded||dpSelf.cursorObject&&!dpSelf.cursorObject.endReached){dpSelf.startIndex=totalUniqueLoaded;var listLoadInput=awTableSvc.createListLoadInput(null,dpSelf.startIndex,null,true,true,dataCtxNode.filterStr);var actionRequestObj={listLoadInput:listLoadInput};var action=dpSelf.nextAction?dpSelf.nextAction:dpSelf.action;if(logger.isDeclarativeLogEnabled()){debugService.debugDataProviderNextPage(dpSelf,action,dpSelf.json,dataCtxNode,actionRequestObj);}return dpSelf.someDataProviderSvc.getNextPage(action,dpSelf.json,dataCtxNode,actionRequestObj).then(function(response){var vmCollection=dpSelf.viewModelCollection;vmCollection.setTotalObjectsFound(response.totalFound);if(response.totalFound>0){vmCollection.updateModelObjects(response.results,dpSelf.uidInResponse,dpSelf.preSelection);}_notifyModelObjectsUpdate(dataCtxNode,{nextPage:true});if(!_.isEmpty(vmCollection.loadedVMObjects)&&vmCollection.totalFound>dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()){_.last(vmCollection.loadedVMObjects).incompleteTail=true;}if(dpSelf.accessMode==='lov'){// lov api expects incremental response, not the entire collection\nreturn response;}return vmCollection;});}return $q.resolve(dpSelf.viewModelCollection);};/**\n     * Validate selection\n     *\n     * @param {Object} lovScope - lov context\n     * @param {Array} selected - selected object/s to validate\n     * @param {Boolean} suggestion - does selected contain a suggested value?\n     *\n     * @return {Promise} Promise that is resolved upon completion of validateion.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.validateSelections=function(lovScope,selected,suggestion){var action=dpSelf.validateAction;if(action){var actionRequestObj={selected:selected,suggestion:suggestion};return dpSelf.someDataProviderSvc.validateSelections(action,dpSelf.json,lovScope,actionRequestObj).then(function(resp){if(!resp.valid){resp.cause={partialErrors:true};throw resp;}eventBus.publish(dpSelf.name+'.validSelectionEvent',{selectedObjects:selected});return resp;});}// if validate action is not defined, assume all valid\neventBus.publish(dpSelf.name+'.validSelectionEvent',{selectedObjects:selected});return AwPromiseService.instance.resolve({valid:true});};/**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any new nodes.\n     *\n     * @return {Promise} A promise resolved when the expansion is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.expandObject=function(dataCtxNode,parentNode){var begNdx=-1;if(dpSelf.cacheCollapse){var vmNodes=dpSelf.viewModelCollection.loadedVMObjects;// BMW: can use _, I am lazy now for prototype\nfor(var ndx=0;ndx<vmNodes.length;ndx++){if(vmNodes[ndx].id===parentNode.id){begNdx=ndx+1;break;}}}// BMW: Load __expendState if dpSelf.cacheCollapse == true\nif(begNdx>=0&&parentNode.__expandState&&dpSelf.cacheCollapse){// Apply __expandState.expandedNodes to vmoCollection\nvar vmos=dpSelf.viewModelCollection.loadedVMObjects;vmos.splice.apply(vmos,[begNdx,0].concat(parentNode.__expandState.expandedNodes));dpSelf.viewModelCollection.setTotalObjectsFound(vmos.length);// Load parentNode context back\nparentNode.children=parentNode.__expandState.children;parentNode.startChildNdx=parentNode.__expandState.startChildNdx;parentNode.totalChildCount=parentNode.__expandState.totalChildCount;parentNode.cursorObject=parentNode.__expandState.cursorObject;// Clean up and return\ndelete parentNode.__expandState;return $q.resolve(dpSelf.viewModelCollection);}// BMW: Clean up __expendState if dpSelf.cacheCollapse == false\nif(!dpSelf.cacheCollapse&&parentNode.__expandState){delete parentNode.__expandState;}return dpSelf.getTreeNodePage(dataCtxNode,parentNode,null,true,dpSelf.topTreeNode);};let _initialCacheCollapseState=false;/**\n     *\n     * Function to restore collapse cache to the initial value\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.restoreInitialCacheCollapseState=function(){if(!_initialCacheCollapseState){dpSelf.cacheCollapse=false;dpSelf.resetCollapseCache();}else{dpSelf.cacheCollapse=true;}};/**\n     *\n     * Function to reset collapse cache when needed\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.resetCollapseCache=function(){if(!dpSelf.viewModelCollection||!dpSelf.viewModelCollection.loadedVMObjects){return;}_.forEach(dpSelf.viewModelCollection.loadedVMObjects,function(vmo){if(vmo.__expandState){delete vmo.__expandState;}});};/**\n     * Set valid source types for data provider, this is used for drag and drop usage\n     *\n     * @param {Object} validSourceTypes - valid source types for dataprovider which are set from xrt objectset\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.setValidSourceTypes=function(validSourceTypes){dpSelf.validSourceTypes=validSourceTypes;};/**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any 'child' nodes being removed as\n     *            part of the collapse.\n     * @return {Promise} A promise resolved when the collapse is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.collapseObject=function(dataCtxNode,parentNode){/**\n         * Remove all 'child' nodes of this 'parent' from the 'loadedVMObjects' of the ViewModelCollection and\n         * reset it's internal 'children' array.\n         */var vmNodes=dpSelf.viewModelCollection.loadedVMObjects;var begNdx=-1;var nDelete=0;// BMW Issue #5: add document to this algorithm.\n// - Loop through the whole vmoCollection\n// - When find the parent node, set state to start ( begNdx )\n// - Keep going, when hits node which node.level <= parent.level, stop ( next sibling )\n// - record all as nDelete.\n//\n// So we don't have to clen parentNode.children here...anyway it will be done later\nfor(var ndx=0;ndx<vmNodes.length;ndx++){if(uwUtilSvc.getEvaluatedId(vmNodes[ndx])===uwUtilSvc.getEvaluatedId(parentNode)){begNdx=ndx+1;nDelete=0;}else if(begNdx>=0){if(vmNodes[ndx].levelNdx>parentNode.levelNdx){nDelete++;}else{// BMW Issue #5:\n// parentNode.children = null;\nbreak;}}}if(nDelete>0){var collapsedNodes=vmNodes.splice(begNdx,nDelete);// BMW Issue #7: When any of the node is in loading status, don't cache\nvar collapesdNodesIsLoading=_.reduce(collapsedNodes,function(sum,node){return sum?sum:node.loadingStatus;},false);// BMW: Cache collapse object here\nif(dpSelf.cacheCollapse&&!collapesdNodesIsLoading){parentNode.__expandState={children:parentNode.children,startChildNdx:parentNode.startChildNdx,totalChildCount:parentNode.totalChildCount,// BMW #5: actually cursorObject cache here is not needed since\n// it is anyway leaking in current system when collapse. But for\n// safe we can cache and load it too.\ncursorObject:parentNode.cursorObject,expandedNodes:collapsedNodes};}parentNode.children=null;parentNode.startChildNdx=0;parentNode.totalChildCount=null;}// Re-evaluate selection state, since we have removed children selection state have changed.\ndpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);return $q.resolve(dpSelf.viewModelCollection);};// collapseObject\n/**\n     * Access a page of 'child' nodes of the given 'parent' node and place the results into the\n     * ViewModelColection of this UwDataProvider.\n     * <P>\n     * Note: Paging information stored in the 'parent' node is used to determine which 'child' nodes to get.\n     * This paging information is then updated to be ready for any subsequent call to this API.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @param {Boolean} focusLoadAction - (Optional) TRUE if action is triggered to load selected object in tree\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getTreeNodePage=function(dataCtxNode,parentNode,cursorNodeId,addAfter,rootNode,focusLoadAction){var action=addAfter?dpSelf.nextAction||dpSelf.action:dpSelf.previousAction;assert(action,'Invalid action specified');/**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */var inputData=_determineInput(parentNode,cursorNodeId,addAfter);var treeLoadInput=awTableSvc.createTreeLoadInput(inputData.parentNode,inputData.startChildNdx,null,cursorNodeId,dpSelf.treePageSize,addAfter,rootNode);var actionRequestObj={treeLoadInput:treeLoadInput,loadIDs:{t_uid:dpSelf.topTreeNode.uid,o_uid:treeLoadInput.parentNode.uid}};// focusLoadAction will be true when object present in selection model needs to be loaded in tree.\n// (cross select between PWA and other sources e.g. Search Panel)\nif(focusLoadAction){action=dpSelf.focusAction?dpSelf.focusAction:null;treeLoadInput.focusLoadAction=focusLoadAction;}dataCtxNode.data.treeLoadInput=treeLoadInput;updateDataCtxNodeWithProps(dataCtxNode);var origCursorObj=_.clone(treeLoadInput.parentNode.cursorObject);return dpSelf.someDataProviderSvc.executeLoadAction(action,dpSelf.json,dataCtxNode,actionRequestObj).then(function(responseObj){return _processLoadTreeNodePageResponse(treeLoadInput,responseObj,dataCtxNode,origCursorObj);});};/**\n     * Access the initial page of data.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getTreeNodeInitial=function(dataCtxNode,parentNode,cursorNodeId,addAfter,rootNode){var action=dpSelf.initializeAction;assert(action,'Invalid action specified');/**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */var inputData=_determineInput(parentNode,cursorNodeId,addAfter);var treeLoadInput=awTableSvc.createTreeLoadInput(inputData.parentNode,inputData.startChildNdx,null,cursorNodeId,dpSelf.treePageSize,addAfter,rootNode);var actionRequestObj={treeLoadInput:treeLoadInput};updateDataCtxNodeWithProps(dataCtxNode);dataCtxNode.data.treeLoadInput=treeLoadInput;var origCursorObj=_.clone(treeLoadInput.parentNode.cursorObject);return dpSelf.someDataProviderSvc.executeLoadAction(action,dpSelf.json,dataCtxNode,actionRequestObj).then(function(responseObj){return _processLoadTreeNodePageResponse(treeLoadInput,responseObj,dataCtxNode,origCursorObj);});};/**\n     * Access a page of 'child' nodes of the given 'parent' node (starting at a specific 'child' node) and place\n     * the results into the ViewModelColection of this UwDataProvider.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     * @param {String} startChildId - ID of a node in the 'parent' to start loading at.\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     * @param {Number} pageSize - Maximum number of 'child' nodes to return (including the 'startChild').\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Promise} A promise object resolved with a reference to the updated ViewModelColection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getTreeNode=function(dataCtxNode,parentNode,startChildId,cursorNodeId,pageSize,addAfter){var action=addAfter?dpSelf.nextAction:dpSelf.previousAction;assert(action,'Invalid action specified');/**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */var inputData=_determineInput(parentNode,cursorNodeId,addAfter);var treeLoadInput=awTableSvc.createTreeLoadInput(inputData.parentNode,inputData.startChildNdx,startChildId,cursorNodeId,pageSize,addAfter);var actionRequestObj={treeLoadInput:treeLoadInput};dataCtxNode.data.treeLoadInput=treeLoadInput;updateDataCtxNodeWithProps(dataCtxNode);var origCursorObj=_.clone(parentNode.cursorObject);return dpSelf.someDataProviderSvc.executeLoadAction(action,dpSelf.json,dataCtxNode,actionRequestObj).then(function(responseObj){return _processLoadTreeNodePageResponse(treeLoadInput,responseObj,dataCtxNode,origCursorObj);});};/**\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {PropertyLoadInput} propertyLoadInput - The object containing the PropertyLoadRequest(s) to\n     *            process.\n     *\n     * @return {Promise} The Promise is resolved with a PropertyLoadResult object when the operation is\n     *         complete.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */dpSelf.getProperties=function(dataCtxNode,propertyLoadInput){assert(dpSelf.action,'Invalid action specified');var actionRequestObj={propertyLoadInput:propertyLoadInput};updateDataCtxNodeWithProps(dataCtxNode);return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.action,dpSelf.json,dataCtxNode,actionRequestObj).then(function(response){return response.propertyLoadResult;});};dpSelf.getFilterFacets=function(viewModel,filterFacetInput){var action=dpSelf.filterFacetAction;var dataCtxNode={data:viewModel,filterFacetInput:filterFacetInput};updateDataCtxNodeWithProps(dataCtxNode);if(action){return dpSelf.someDataProviderSvc.executeLoadAction(action,dpSelf.json,dataCtxNode).then(function(response){return response.filterFacetResults;});}return $q.resolve();};/**\n     * Free up all resources held by this object.\n     * <P>\n     * Note: After this function, no API call should be considered valid. This function is intended to be called\n     * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event),\n     * any objects managed by this class may be considered a 'memory leak'.\n     */dpSelf.destroy=function(){dpSelf._isDestroyed=true;declModelRegistrySvc.unregisterModel('UwDataProvider',dpSelf,'name','_modelId');if(dpSelf._appCtxEditInProgress){appCtxService.unRegisterCtx(dpSelf._appCtxEditInProgress);}if(dpSelf.selectionModel){dpSelf.detachSelectionModel();dpSelf.selectionModel=null;}if(dpSelf.viewModelCollection){dpSelf.viewModelCollection.destroy();dpSelf.viewModelCollection=null;}if(dpSelf.someDataProviderSvc&&dpSelf.someDataProviderSvc.destroy){dpSelf.someDataProviderSvc.destroy();dpSelf.someDataProviderSvc=null;}if(dpSelf.json.editContext&&_editHandlerRegistered){editHandlerSvc.removeEditHandler(dpSelf.json.editContext);}const editConfig=dpSelf.json.editConfig;if(editConfig){editUtilsService._removeListeners(editConfig.sourceModel);}dpSelf.cols=null;dpSelf.topTreeNode=null;dpSelf.actionObj=null;dpSelf.json=null;dpSelf.ttState=null;dpSelf.policy=null;dpSelf.validSourceTypes=null;eventBus.unsubscribe(dpSelf.toggleDecoratorsEvent);eventBus.unsubscribe(dpSelf.multiSelectModeEvent);eventBus.unsubscribe(dpSelf.selectActionEvent);dpSelf.toggleDecoratorsEvent=null;dpSelf.multiSelectModeEvent=null;dpSelf.selectActionEvent=null;dpSelf.setRootReference(null);// detach dispatcher\ndpSelf.vmCollectionDispatcher=null;dpSelf.pageDispatcher=null;dpSelf.selectionModel=null;referenceElement=null;selectionModelDispatcher=null;dpSelf=null;};// destroy\n/**\n     * ---------------------------------------------------------------------------<BR>\n     * Property & Function definition complete....Finish initialization. <BR>\n     * ---------------------------------------------------------------------------<BR>\n     */declModelRegistrySvc.registerModel('UwDataProvider',dpSelf,'name','_modelId');/**\n     * Load localized text for when we encounter cases of no results and loading .\n     *\n     * @param localTextBundle\n     */localeSvc.getTextPromise().then(function(localTextBundle){if(dpSelf){if(declUtils.isNil(dpSelf.isLoading)){dpSelf.isLoading=localTextBundle.LOADING_TEXT;}}});if(actionObj){dpSelf.action=actionObj;}_.forEach(actionMap,function(actionDef,actionName){dpSelf[actionName]=actionDef;});if(dataProviderJson){dpSelf.json=dataProviderJson;dpSelf.policy=dataProviderJson.policy;/** tree page size */if(dataProviderJson.treePageSize){dpSelf.treePageSize=dataProviderJson.treePageSize;}/** Row or Cell selection scope ? */if(dataProviderJson.selectionModelScope){dpSelf.selectionModel.scope=dataProviderJson.selectionModelScope;}/**\n         * Only set the default text values if they are not already set in the dataProvider JSON definition.\n         */if(dataProviderJson.noResultsFound){dpSelf.noResultsFound=dataProviderJson.noResultsFound;}if(dataProviderJson.isLoading){dpSelf.isLoading=dataProviderJson.isLoading;}if(dataProviderJson.cacheCollapse){_initialCacheCollapseState=dataProviderJson.cacheCollapse;dpSelf.cacheCollapse=_initialCacheCollapseState;}}/**\n     * Get the editable object from the data provider\n     *\n     * In case of list, it sends the selected object.<BR>\n     * In case of Table, it send the all the loaded objects.\n     *\n     * @return {object} viewModelObject - View model object(s).\n     */dpSelf.getEditableObjects=function(){if(dataProviderJson&&dataProviderJson.editContext){if(dataProviderJson.editContext==='LIST_CELL_CONTEXT'){if(dpSelf.selectionModel&&dpSelf.selectionModel.mode==='single'){return dpSelf.getSelectedObjects();}}else{var vmc=dpSelf.viewModelCollection;return vmc.getLoadedViewModelObjects();}}return null;};/**\n     * Get a list of property names form the dataprovider\n     *\n     * @return {Array} propNames - list of property Names\n     */dpSelf.getPropertyNames=function(){var propNames=[];if(dataProviderJson.editContext==='LIST_CELL_CONTEXT'){if(dpSelf.selectionModel&&dpSelf.selectionModel.mode==='single'){var selectedObject=dpSelf.getSelectedObjects();if(selectedObject!==null){_.forEach(selectedObject,function(viewModelObject){_.forEach(viewModelObject.props,function(props){if(props&&props.type){propNames.push(props.propertyName);}});});}}}else{if(dpSelf.cols){_.forEach(dpSelf.cols,function(col){if(col&&col.typeName&&!col.isTreeNavigation){propNames.push(col.propertyName);}});}}return propNames;};/**\n     * Gets the edit configuration object\n     * @return {Object} The edit configuration object\n     */dpSelf.getEditConfiguration=function(){return dpSelf.json.editConfig;};/**\n     * Get the command override anchors set in viewModel.\n     *\n     * @return {Object} All possible override anchor strings\n     */dpSelf.getCommandOverrides=function(){return{gridMenuCommandsAnchor:dpSelf.json.gridMenuCommandsAnchor,contextMenuCommandsAnchor:dpSelf.json.contextMenuCommandsAnchor,columnMenuCommandsAnchor:dpSelf.json.columnMenuCommandsAnchor};};};// UwDataProvider\n/**\n * ---------------------------------------------------------------------------<BR>\n * Define the public API for the 'dataProviderFactory' Service<BR>\n * ---------------------------------------------------------------------------<BR>\n */var exports={};/**\n * Create a new DeclDataProvider object to manage and access List, LOV, flat-table and tree-table structured\n * ViewModelObjects.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {StringMap} actionsMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n *\n * @return {UwDataProvider} The newly created DeclDataProvider object.\n *\n * @memberof module:js/dataProviderFactory\n */export let createDataProvider=function(dataProviderJson,actionObj,dataProviderName,someDataProviderSvc,actionsMap){var viewModelCollection=viewModelCollectionFactory.createViewModelCollection(dataProviderName);return new UwDataProvider(AwPromiseService.instance,dataProviderJson,actionObj,dataProviderName,someDataProviderSvc,viewModelCollection,actionsMap);};/**\n * Using the given UID, determine which IModelObject should be set as the 'top' node (if any). That object\n * will be set as a new 'top' ViewModelTreeNode on the given dataProvider.\n * <P>\n * Note: The 'top' node is generally hidden from the user and is used only to access 'child' nodes and other\n * properties.\n *\n * @param {String} topNodeUid - (Optional) The ID of the 'top' (if known)\n *\n * @return {ViewModelTreeNode} The new 'top' node.\n */function _determineTopTreeNode(topNodeUid){/**\n     * Create a 'straw' top node to use just in case.\n     */var topTreeNode={nodeId:'top',nodeType:'rootType',displayName:'top',levelNdx:-1,childNdx:0};if(!_.isEmpty(topNodeUid)){topTreeNode.nodeId=topNodeUid;topTreeNode.nodeType='unknown';}return awTableSvc.createViewModelTreeNode(topTreeNode.nodeId,topTreeNode.nodeType,topTreeNode.displayName,topTreeNode.levelNdx,topTreeNode.childNdx,null);}// _determineTopTreeNode\nlet initPreferredChoices=[];export const loadAction=async(dataProvider,dataCtxNode,vmCollection,startIndex,pageObject)=>{// revisitme Subhajit: To keep the backward compatibility.. we need to work on declDataCtxService\ndataProvider.startIndex=startIndex;let pageActionType=pageObject.pageActionType;// tree - for pagination needs improvement\nif(dataProvider.accessMode==='tree'){let results;switch(pageActionType){case'NEXT_PAGE':results=await dataProvider.getNextPage(dataCtxNode);break;case'PREVIOUS_PAGE':results=await dataProvider.getPreviousPage(dataCtxNode);break;case'PAGE_RESET':dataProvider.topTreeNode=_determineTopTreeNode(dataProvider.topNodeUid);results=await dataProvider.getTreeNodeInitial(dataCtxNode,dataProvider.topTreeNode,null,true,dataProvider.topTreeNode);//PAGE_RESET - This means the dataprovider is re-initialized\n//Clear the previous data in vmCollection before updating the new data\ndataProvider.viewModelCollection.clear();break;case'FOCUS_PAGE':var focusLoadAction=true;dataProvider.topTreeNode=_determineTopTreeNode(dataProvider.topNodeUid);results=await dataProvider.getTreeNodePage(dataCtxNode,dataProvider.topTreeNode,null,true,dataProvider.topTreeNode,focusLoadAction);break;}//Verify if the component is still mounted\nif(!dataProvider.vmCollectionDispatcher){return;}// totalFound and hasMoreValuesExist are mutually exclusive keys.\ndataProvider.vmCollectionDispatcher({type:'COLLECTION_UPDATE',viewModelObjects:results.loadedVMObjects,totalFound:results.totalFound,cursorObject:dataProvider.topTreeNode.cursorObject,pageObject:pageObject});dataProvider.vmCollectionDispatcher({type:'IN_PROGRESS',fetching:false});dataProvider.vmCollectionDispatcher({type:'FOCUSING',focusing:false});if(pageActionType==='FOCUS_PAGE'){dataProvider.syncSelectionModel(dataCtxNode);}}else{let action;switch(pageActionType){case'PAGE_RESET':dataProvider.startIndex=0;action=dataProvider.initializeAction?dataProvider.initializeAction:dataProvider.action;break;case'NEXT_PAGE':action=dataProvider.nextAction?dataProvider.nextAction:dataProvider.action;break;case'PREVIOUS_PAGE':action=dataProvider.previousAction?dataProvider.previousAction:dataProvider.action;break;case'FOCUS_PAGE':dataProvider.startIndex=0;dataProvider.vmCollectionDispatcher({type:'COLLECTION_RESET'});action=dataProvider.focusAction?dataProvider.focusAction:null;break;}let listLoadInput=awTableSvc.createListLoadInput(null,dataProvider.startIndex,null,true);let actionRequestObj={listLoadInput};const response=await dataProvider.someDataProviderSvc.executeLoadAction(action,dataProvider.json,dataCtxNode,actionRequestObj);//Verify if the component is still mounted\nif(!dataProvider.vmCollectionDispatcher){return;}let viewModelObjects=vmCollection.createModelObjects(response.results||[]);if(pageActionType==='NEXT_PAGE'){viewModelObjects=vmCollection.getLoadedViewModelObjects().concat(viewModelObjects);}else if(pageActionType==='PREVIOUS_PAGE'){viewModelObjects=viewModelObjects.concat(vmCollection.getLoadedViewModelObjects());}else if(pageActionType==='PAGE_RESET'){// PAGE_RESET - This means the dataprovider is re-initialized\n// retrieve preferred vals if defined\nif(dataProvider.preferredChoicesAction){const preferredChoiceResp=await dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.preferredChoicesAction,dataProvider.json,dataCtxNode);initPreferredChoices=preferredChoiceResp.actionResultObj.responseObj.preferredChoices;}// Clear the previous data in vmCollection before updating the new data\nif(response.hasOwnProperty('lovUsage')){dataProvider.lovUsage=response.lovUsage;}if(response){dataProvider.viewModelCollection.clear();}if(response.totalFound>0&&response.results){dataProvider.noResults=false;}else{dataProvider.noResults=true;// assigning no result found string if there is no data from rest service\nif(dataProvider.json.noResultsFound){var i18nkey=dataProvider.json.noResultsFound;i18nkey=parsingUtils.geti18nKey(i18nkey);dataProvider.noResultsFound=dataCtxNode.data.i18n[i18nkey];}}}// totalFound and hasMoreValuesExist are mutually exclusive keys.\nlet totalFound=response.hasOwnProperty('moreValuesExist')?-1:response.totalFound;let hasMoreValuesExist=response.hasOwnProperty('moreValuesExist')?response.moreValuesExist:null;// set preferred vals if defined\nif(dataProvider.preferredChoicesAction){response.preferredChoices=initPreferredChoices;}dataProvider.vmCollectionDispatcher({type:'COLLECTION_UPDATE',viewModelObjects:viewModelObjects,totalFound,hasMoreValuesExist,cursorObject:dataProvider.cursorObject,pageObject:pageObject,preferredChoices:response.preferredChoices});dataProvider.vmCollectionDispatcher({type:'IN_PROGRESS',fetching:false});dataProvider.notifyModelObjectsUpdate();/**\n         * Determine if the last node in the collection is an 'incompleteTail' because we know\n         * there are more found than currently loaded.\n         */if(!_.isEmpty(vmCollection.loadedVMObjects)&&vmCollection.totalFound>dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded()){_.last(vmCollection.loadedVMObjects).incompleteTail=true;}/**\n         * Determine if the first node in the collection is an 'incompleteHead'\n         */if(!_.isEmpty(vmCollection.loadedVMObjects)&&dataProvider.cursorObject&&dataProvider.cursorObject.startReached===false){_.head(vmCollection.loadedVMObjects).incompleteHead=true;}}if(pageActionType==='FOCUS_PAGE'){//  revisitme Shaishav: In old focus action following variables were getting set.\n//  We might need them when TC tables are supported.\n//  Keeping is commented to not lose track of them\n// if( response.totalFound > 0 && response.results ) {\n//     dpSelf.noResults = false;\n//     vmCollection.updateModelObjects( response.results,\n//         dpSelf.uidInResponse, dpSelf.preSelection );\n// } else {\n//     dpSelf.noResults = true;\n// }\neventBus.publish(dataProvider.name+'.focusSelection');}};/**\n *\n * @param {*} param0\n * @param {*} dataProvider\n * @param {*} dataCtxNode\n */export const validateLovAction=(_ref3,dataProvider,dataCtxNode)=>{let{lovEntries,vmo,viewModelProp}=_ref3;return dataProvider.validateLOV({lovEntries,vmo,viewModelProp},dataCtxNode);};/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {UwDataProvider} The DeclDataProvider from the given arguments (or undefined if not found)\n */export let findDataProvider=function(argsIn){for(var ndx=0;ndx<argsIn.length;ndx++){var arg=argsIn[ndx];if(exports.isDataProvider(arg)){return arg;}}return undefined;};/**\n * Test if the given object 'is-a' UwDataProvider created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a DeclDataProvider.\n */export let isDataProvider=function(objectToTest){return objectToTest instanceof UwDataProvider;};/**\n * Select all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */export let selectAll=function(dataProvider){if(dataProvider){dataProvider.selectAll();}};/**\n * Deselect all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */export let selectNone=function(dataProvider){if(dataProvider){dataProvider.selectNone();}};/**\n * Enable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */export let dataProviderEnableMultiSelect=function(dataProvider){if(dataProvider){dataProvider.enableMultiSelect();}};/**\n * Disable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */export let dataProviderDisableMultiSelect=function(dataProvider){if(dataProvider){dataProvider.disableMultiSelect();}};function loadDebugOption(){var urlAttrs=browserUtils.getUrlAttributes();_debug_logTreeLoadActivity=urlAttrs.logTreeLoadActivity!==undefined;}/**\n * createDynamicDataProvider based on jsonData specified by src\\propertyrender\\lovDataProvider.json\n * @param {int} index - the index to return\n * @return {Object} dataProvider the dataProvider\n */export let createDynamicDataProvider=function(){let index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let dataProviders=[];let _processAction=(jsonData,jsonDataProvider,dpName,actionName,actionMap)=>{var actionRef=jsonDataProvider[actionName];if(actionRef&&jsonData.actions){actionMap[actionName]=jsonData.actions[actionRef];}};if(jsonData.dataProviders){var dataProvidersClone=_.cloneDeep(jsonData.dataProviders);_.forEach(dataProvidersClone,function(jsonDataProvider,dpName){var actionMap={};_processAction(jsonData,jsonDataProvider,dpName,'action',actionMap);// legacy init/getNext action\n_processAction(jsonData,jsonDataProvider,dpName,'initializeAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'nextAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'previousAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'focusAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'expandAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'validateAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'filterFacetAction',actionMap);_processAction(jsonData,jsonDataProvider,dpName,'preferredChoicesAction',actionMap);let dataProviderInstance=createDataProvider(jsonDataProvider,actionMap.action,dpName,declDataProviderSvc,actionMap);dataProviderInstance.dynamicDp=true;dataProviderInstance.debugId=Math.floor(Math.random()*100);dataProviders.push(dataProviderInstance);});}return dataProviders[index];};exports={createDataProvider,createDynamicDataProvider,findDataProvider,isDataProvider,loadAction,selectAll,selectNone,dataProviderEnableMultiSelect,dataProviderDisableMultiSelect,validateLovAction};export default exports;loadDebugOption();","map":null,"metadata":{},"sourceType":"module"}