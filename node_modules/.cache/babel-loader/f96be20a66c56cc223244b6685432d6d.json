{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/atomicDataService\n */\nimport _ from 'lodash';\n/**\n * @param {*} stateObject The stateobject inside atomic data section of viewmodel.\n * @param {*} metaObj The meta object for the same\n * @param {*} rootPath The name of the state object inside atomicdata.\n * @param {*} createField the function to create field objects\n * @returns\n */\n\nexport const createFieldsBasedOnMetaData = function (stateObject, metaObj, rootPath, createField) {\n  let atomicFields = {};\n  const fieldsPath = [];\n  fieldsPath.push(rootPath);\n  parseMetaForFieldsPath(metaObj);\n  validateObjWithMetaObjAndCreateFields(stateObject);\n  let rootField = createField('', rootPath, 'partialField');\n  atomicFields = { ...rootField,\n    ...atomicFields\n  };\n  /**\n   *\n   * @param {*} propName\n   * @param {*} basePath\n   * @returns\n   */\n\n  function parsePath(propName, basePath) {\n    let path;\n\n    if (basePath) {\n      path = Number.isInteger(propName) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n    } else {\n      path = propName;\n    }\n\n    return path;\n  }\n  /**\n   *\n   * @param {*} metaObj\n   * @param {*} rootPath\n   */\n\n\n  function parseMetaForFieldsPath(currentMetaObj) {\n    let basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _.forEach(currentMetaObj, function processMeta(propValue, propName) {\n      if (propName === 'field' || propName === 'type') {\n        return undefined;\n      }\n\n      let path = parsePath(propName, basePath);\n      fieldsPath.push(`${rootPath}.${path}`);\n\n      if (_.isObject(propValue)) {\n        parseMetaForFieldsPath(propValue, path);\n      }\n\n      return undefined;\n    });\n\n    return undefined;\n  }\n  /**\n   *\n   * @param {*} obj\n   * @param {*} metaObj\n   * @param {*} basePath\n   */\n\n\n  function validateObjWithMetaObjAndCreateFields(currStateObj, basePath) {\n    _.forEach(currStateObj, function (propValue, propName) {\n      let path = parsePath(propName, basePath);\n      const metaPathMatcher = path.replace(/\\d+/g, '0'); // This is just to match with schema\n\n      const isFieldObject = _.indexOf(fieldsPath, `${rootPath}.${metaPathMatcher}`) !== -1;\n\n      const fieldType = _.get(metaObj, `${metaPathMatcher}.type`, 'partialField');\n\n      const isLeafLevelFieldObj = isFieldObject && fieldType !== 'partialField';\n\n      if (isFieldObject) {\n        let atomicField = createField(path, rootPath, fieldType);\n\n        if (_.isArray(propValue)) {\n          let fieldsObj = atomicField;\n          atomicField = [...propValue];\n\n          _.assign(atomicField, fieldsObj);\n        } else if (_.isObject(propValue) && !isLeafLevelFieldObj) {\n          _.assign(atomicField, propValue);\n        }\n\n        if (fieldType === 'partialField') {\n          Object.defineProperty(atomicField, 'getValue', {\n            enumerable: false\n          });\n          Object.defineProperty(atomicField, 'value', {\n            enumerable: false\n          });\n          Object.defineProperty(atomicField, 'update', {\n            enumerable: false\n          });\n        }\n\n        _.set(atomicFields, path, atomicField);\n      } else {\n        //workaround to handle 'Categorization.category' as a prop name\n        if (!Number.isInteger(propName) && propName.includes('.')) {\n          path = path.replace('.' + propName, `['${propName}']`);\n        } // If only raw data (read only), then set it without generating any field.\n\n\n        _.set(atomicFields, path, _.get(currStateObj, propName));\n      } // If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.\n      // It would save lot of un-necessary recursions.\n      // If current propValue is of type \"Meta\" and fieldType === 'FieldObject', then only traverse inside.\n      // If the fieldType is of type \"field\" or \"VMP\", no need to traverse the object inside.\n\n      /**\n       *  Two Important cases\n       * 1. Current Object (propValue) is not of type \"Field\" i.e not in meta, this means all down ward objects are also not fields\n       *  Hence, no need to traverse inside it.\n       *\n       * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,\n       * but if the propValue is of type \"field\" but not 'partialField' ( ie. full fledged Field Object), this means it the end of\n       * hierarchy (leaf leavel Field Node), no need to traverse inside it.\n       * no need to go inside.\n       */\n\n\n      if (_.isObject(propValue) && isFieldObject && !isLeafLevelFieldObj) {\n        validateObjWithMetaObjAndCreateFields(propValue, path);\n      }\n    });\n  }\n\n  return atomicFields;\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/atomicDataService.js"],"names":["createFieldsBasedOnMetaData","atomicFields","fieldsPath","parseMetaForFieldsPath","validateObjWithMetaObjAndCreateFields","rootField","createField","path","Number","basePath","propName","_","parsePath","rootPath","metaPathMatcher","isFieldObject","fieldType","isLeafLevelFieldObj","atomicField","fieldsObj","Object","enumerable"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/atomicDataService\n */\nimport _ from 'lodash';\n\n/**\n * @param {*} stateObject The stateobject inside atomic data section of viewmodel.\n * @param {*} metaObj The meta object for the same\n * @param {*} rootPath The name of the state object inside atomicdata.\n * @param {*} createField the function to create field objects\n * @returns\n */\nexport const createFieldsBasedOnMetaData = function( stateObject, metaObj, rootPath, createField ) {\n    let atomicFields = {};\n    const fieldsPath = [];\n    fieldsPath.push( rootPath );\n    parseMetaForFieldsPath( metaObj );\n    validateObjWithMetaObjAndCreateFields( stateObject );\n    let rootField = createField( '', rootPath, 'partialField' );\n    atomicFields = { ...rootField, ...atomicFields };\n\n    /**\n     *\n     * @param {*} propName\n     * @param {*} basePath\n     * @returns\n     */\n    function parsePath( propName, basePath ) {\n        let path;\n        if( basePath ) {\n            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n        } else {\n            path = propName;\n        }\n        return path;\n    }\n\n    /**\n     *\n     * @param {*} metaObj\n     * @param {*} rootPath\n     */\n    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {\n        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {\n            if( propName === 'field' || propName === 'type' ) {\n                return undefined;\n            }\n            let path = parsePath( propName, basePath );\n            fieldsPath.push( `${rootPath}.${path}` );\n            if( _.isObject( propValue ) ) {\n                parseMetaForFieldsPath( propValue, path );\n            }\n            return undefined;\n        } );\n        return undefined;\n    }\n    /**\n     *\n     * @param {*} obj\n     * @param {*} metaObj\n     * @param {*} basePath\n     */\n    function validateObjWithMetaObjAndCreateFields( currStateObj, basePath ) {\n        _.forEach( currStateObj, function( propValue, propName ) {\n            let path = parsePath( propName, basePath );\n            const metaPathMatcher = path.replace( /\\d+/g, '0' ); // This is just to match with schema\n            const isFieldObject = _.indexOf( fieldsPath, `${rootPath}.${metaPathMatcher}` ) !== -1;\n            const fieldType = _.get( metaObj, `${metaPathMatcher}.type`, 'partialField' );\n            const isLeafLevelFieldObj = isFieldObject && fieldType !== 'partialField';\n            if( isFieldObject ) {\n                let atomicField = createField( path, rootPath, fieldType );\n                if( _.isArray( propValue ) ) {\n                    let fieldsObj = atomicField;\n                    atomicField = [ ...propValue ];\n                    _.assign( atomicField, fieldsObj );\n                } else if( _.isObject( propValue ) && !isLeafLevelFieldObj ) {\n                    _.assign( atomicField, propValue );\n                }\n                if( fieldType === 'partialField' ) {\n                    Object.defineProperty( atomicField, 'getValue', { enumerable: false } );\n                    Object.defineProperty( atomicField, 'value', { enumerable: false } );\n                    Object.defineProperty( atomicField, 'update', { enumerable: false } );\n                }\n                _.set( atomicFields, path, atomicField );\n            } else {\n                //workaround to handle 'Categorization.category' as a prop name\n                if( !Number.isInteger( propName ) && propName.includes( '.' ) ) {\n                    path = path.replace( '.' + propName, `['${propName}']` );\n                }\n                // If only raw data (read only), then set it without generating any field.\n                _.set( atomicFields, path, _.get( currStateObj, propName ) );\n            }\n            // If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.\n            // It would save lot of un-necessary recursions.\n            // If current propValue is of type \"Meta\" and fieldType === 'FieldObject', then only traverse inside.\n            // If the fieldType is of type \"field\" or \"VMP\", no need to traverse the object inside.\n            /**\n             *  Two Important cases\n             * 1. Current Object (propValue) is not of type \"Field\" i.e not in meta, this means all down ward objects are also not fields\n             *  Hence, no need to traverse inside it.\n             *\n             * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,\n             * but if the propValue is of type \"field\" but not 'partialField' ( ie. full fledged Field Object), this means it the end of\n             * hierarchy (leaf leavel Field Node), no need to traverse inside it.\n             * no need to go inside.\n             */\n            if( _.isObject( propValue ) && isFieldObject && !isLeafLevelFieldObj ) {\n                validateObjWithMetaObjAndCreateFields( propValue, path );\n            }\n        } );\n    }\n    return atomicFields;\n};\n"]},"metadata":{},"sourceType":"module"}