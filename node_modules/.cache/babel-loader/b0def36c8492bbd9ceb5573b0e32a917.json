{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/conditionParser.service\n */\nimport _ from 'lodash';\n/**\n * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.\n */\n\nconst reCTX = /\\bctx\\b/;\nconst reLead = /^[.[]/;\nconst reLeadDot = /^\\./;\nconst reToStrip = /(\\s*(\\(|\\)|===|!==|>|<|>=|<=|\\|\\||&&|}})\\s*|\\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\\()/;\nconst reCC = /(commandContext\\.[a-zA-Z][.\\w]*)(\\W*|$)/g;\nconst reSV = /ctx\\.(visibleServerCommands\\.[a-zA-Z]\\w*)(\\W*|$)/g;\n/**\n * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\nexport const parseStringCondition = expression => {\n  const ctxParameters = [];\n  let m;\n\n  for (const elem of expression.split(reCTX)) {\n    if (reLead.test(elem)) {\n      m = elem.replace(reLeadDot, ''); // split leading dot if any\n\n      m = m.split(reToStrip)[0]; // split on conditions & functions\n\n      m = m.replace(/\"/g, '\\''); // use single quote to work with lodash toPath\n\n      m = m.replace(/\\[\\s*/g, '[').replace(/\\s*\\]/g, ']'); // remove spaces for left & right brackets to support _.toPath\n\n      m = _.toPath(m);\n\n      for (let ndx = 0; ndx < m.length; ndx++) {\n        if (/(:|^\\d+$)/.test(m[ndx]) && ndx > 0) {\n          m.length = ndx;\n          break;\n        }\n      }\n\n      ctxParameters.push(m.join('.'));\n    }\n  }\n\n  const commandContextParameters = parseRegex(reCC, expression);\n  const visibilityParameters = parseRegex(reSV, expression);\n  return {\n    ctxParameters,\n    additionalParameters: [...commandContextParameters, ...visibilityParameters]\n  };\n};\nexport const parseStringConditionWithAdditionalKeys = (expression, additionalKeys) => {\n  let {\n    ctxParameters,\n    additionalParameters\n  } = parseStringCondition(expression);\n\n  for (let key in additionalKeys) {\n    let additionalKeyRegex = new RegExp('(' + additionalKeys[key] + '\\\\.[a-zA-Z][.\\\\w]*)(\\\\W*|$)', 'g');\n    additionalParameters = additionalParameters.concat(parseRegex(additionalKeyRegex, expression));\n  }\n\n  return {\n    ctxParameters,\n    additionalParameters\n  };\n};\n\nconst parseRegex = (regex, expression) => {\n  const params = [];\n  let m = regex.exec(expression);\n\n  while (m) {\n    params.push(m[1]);\n    m = regex.exec(expression);\n  }\n\n  return params;\n};\n/**\n * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\n\nexport const parseObjectCondition = expression => {\n  return [...Object.keys(expression), ...Object.values(expression)].map(parseExpression).reduce(reduceParams, defaultParams);\n};\n\nconst reduceParams = (_ref, nxt) => {\n  let {\n    ctxParameters,\n    additionalParameters\n  } = _ref;\n  return {\n    ctxParameters: [...ctxParameters, ...nxt.ctxParameters],\n    additionalParameters: [...additionalParameters, ...nxt.additionalParameters]\n  };\n};\n\nconst defaultParams = {\n  ctxParameters: [],\n  additionalParameters: []\n};\nexport const parseObjectConditionWithAdditionalKeys = (expression, additionalKeys) => {\n  return [...Object.keys(expression), ...Object.values(expression)].map(expr => parseExpressionWithAdditionalKeys(expr, additionalKeys)).reduce(reduceParams, defaultParams);\n};\n/**\n * Parse the expression of a declarative condition for any ctx dependencies\n *\n * @param {String} expression Condition expression\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\nconst parseExpression = expression => typeof expression === 'string' ? parseStringCondition(expression) : parseObjectCondition(expression);\n\nconst parseExpressionWithAdditionalKeys = (expression, additionalKeys) => typeof expression === 'string' ? parseStringConditionWithAdditionalKeys(expression, additionalKeys) : parseObjectConditionWithAdditionalKeys(expression, additionalKeys);\n/**\n * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {Condition} condition Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\n\nexport const parseCondition = (condition, additionalKeys) => {\n  if (!condition || !condition.expression) {\n    return {\n      ctxParameters: [],\n      additionalParameters: []\n    };\n  }\n\n  return additionalKeys ? parseExpressionWithAdditionalKeys(condition.expression, additionalKeys) : parseExpression(condition.expression);\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/conditionParser.service.js"],"names":["reCTX","reLead","reLeadDot","reToStrip","reCC","reSV","parseStringCondition","expression","ctxParameters","m","elem","_","ndx","commandContextParameters","parseRegex","visibilityParameters","additionalParameters","parseStringConditionWithAdditionalKeys","additionalKeyRegex","additionalKeys","params","regex","parseObjectCondition","Object","reduceParams","nxt","defaultParams","parseObjectConditionWithAdditionalKeys","expr","parseExpressionWithAdditionalKeys","parseExpression","parseCondition","condition"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/conditionParser.service\n */\nimport _ from 'lodash';\n\n/**\n * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.\n */\n\nconst reCTX = /\\bctx\\b/;\nconst reLead = /^[.[]/;\nconst reLeadDot = /^\\./;\nconst reToStrip = /(\\s*(\\(|\\)|===|!==|>|<|>=|<=|\\|\\||&&|}})\\s*|\\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\\()/;\nconst reCC = /(commandContext\\.[a-zA-Z][.\\w]*)(\\W*|$)/g;\nconst reSV = /ctx\\.(visibleServerCommands\\.[a-zA-Z]\\w*)(\\W*|$)/g;\n\n/**\n * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseStringCondition = ( expression ) => {\n    const ctxParameters = [];\n    let m;\n    for( const elem of expression.split( reCTX ) ) {\n        if( reLead.test( elem ) ) {\n            m = elem.replace( reLeadDot, '' ); // split leading dot if any\n            m = m.split( reToStrip )[ 0 ]; // split on conditions & functions\n            m = m.replace( /\"/g, '\\'' ); // use single quote to work with lodash toPath\n            m = m.replace( /\\[\\s*/g, '[' ).replace( /\\s*\\]/g, ']' ); // remove spaces for left & right brackets to support _.toPath\n            m = _.toPath( m );\n            for( let ndx = 0; ndx < m.length; ndx++ ) {\n                if( /(:|^\\d+$)/.test( m[ ndx ] ) && ndx > 0 ) {\n                    m.length = ndx;\n                    break;\n                }\n            }\n            ctxParameters.push( m.join( '.' ) );\n        }\n    }\n    const commandContextParameters = parseRegex( reCC, expression );\n    const visibilityParameters = parseRegex( reSV, expression );\n    return {\n        ctxParameters,\n        additionalParameters: [ ...commandContextParameters, ...visibilityParameters ]\n    };\n};\n\nexport const parseStringConditionWithAdditionalKeys = ( expression, additionalKeys ) => {\n    let { ctxParameters, additionalParameters } = parseStringCondition( expression );\n    for( let key in additionalKeys ) {\n        let additionalKeyRegex = new RegExp( '(' + additionalKeys[ key ] + '\\\\.[a-zA-Z][.\\\\w]*)(\\\\W*|$)', 'g' );\n        additionalParameters = additionalParameters.concat( parseRegex( additionalKeyRegex, expression ) );\n    }\n    return { ctxParameters, additionalParameters };\n};\n\nconst parseRegex = ( regex, expression ) => {\n    const params = [];\n    let m = regex.exec( expression );\n    while( m ) {\n        params.push( m[ 1 ] );\n        m = regex.exec( expression );\n    }\n    return params;\n};\n\n/**\n * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseObjectCondition = ( expression ) => {\n    return [ ...Object.keys( expression ), ...Object.values( expression ) ]\n        .map( parseExpression )\n        .reduce( reduceParams, defaultParams );\n};\n\nconst reduceParams = ( { ctxParameters, additionalParameters }, nxt ) => {\n    return {\n        ctxParameters: [ ...ctxParameters, ...nxt.ctxParameters ],\n        additionalParameters: [ ...additionalParameters, ...nxt.additionalParameters ]\n    };\n};\n\nconst defaultParams = {\n    ctxParameters: [],\n    additionalParameters: []\n};\n\nexport const parseObjectConditionWithAdditionalKeys = ( expression, additionalKeys ) => {\n    return [ ...Object.keys( expression ), ...Object.values( expression ) ]\n        .map( ( expr ) => parseExpressionWithAdditionalKeys( expr, additionalKeys ) )\n        .reduce( reduceParams, defaultParams );\n};\n\n/**\n * Parse the expression of a declarative condition for any ctx dependencies\n *\n * @param {String} expression Condition expression\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nconst parseExpression = ( expression ) => typeof expression === 'string' ? parseStringCondition( expression ) : parseObjectCondition( expression );\n\nconst parseExpressionWithAdditionalKeys = ( expression, additionalKeys ) => typeof expression === 'string' ? parseStringConditionWithAdditionalKeys( expression, additionalKeys ) :\n    parseObjectConditionWithAdditionalKeys( expression, additionalKeys );\n\n/**\n * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {Condition} condition Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseCondition = ( condition, additionalKeys ) => {\n    if( !condition || !condition.expression ) {\n        return {\n            ctxParameters: [],\n            additionalParameters: []\n        };\n    }\n    return additionalKeys ? parseExpressionWithAdditionalKeys( condition.expression, additionalKeys ) : parseExpression( condition.expression );\n};\n"]},"metadata":{},"sourceType":"module"}