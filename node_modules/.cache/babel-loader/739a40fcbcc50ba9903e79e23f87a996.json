{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module provides cell renderer customization mechanism in PL Table.\n *\n * - Below is the cell renderer pattern:\n *   {\n *       action: function( columnDef, vmo, tableElement ) {\n *           // return DOMStructure\n *       },\n *       condition: function( columnDef, vmo, tableElement ) {\n *           // return true to enable this renderer\n *       }\n *   }\n *\n * - Best practice is to make condition to be unique for your case.\n * - If the requirement is overlapping default behavior, just overlap the condition.\n * - If decoration to cell is needed, just write action, do your work without return\n *   value, but the decoration will only happens before OOTB cell renderer, not after.\n *\n * @module js/splmTableCellRenderer\n *\n */\nimport _ from 'lodash';\nimport uwPropertyService from 'js/uwPropertyService';\nimport splmTableConstants from 'js/splmTableConstants';\nimport splmTableUtils from 'js/splmTableUtils';\nvar exports = {};\nexport let updateCellChangedClass = function (prop, element) {\n  if (element) {\n    if (uwPropertyService.isModified(prop)) {\n      prop.dirty = true;\n      element.classList.add(splmTableConstants.CLASS_CELL_CHANGED);\n    } else {\n      prop.dirty = false;\n      element.classList.remove(splmTableConstants.CLASS_CELL_CHANGED);\n    }\n  }\n};\n/**\n * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n * and the given column (columnInfo )\n * @param {Object} column - Declarative columnInfo object\n * @param {Object} vmo - Declarative view model object (e.g. row)\n * @param {DOMElement} tableElem - Table DOMElement\n * @param {DOMElement} rowElem - Row DOMElement\n * @param {Boolean} dynamicRowHeightEnabled - if dynamic row height is enabled\n * @return {DOMElement} The newly created DOMElement for the property cell content\n */\n\nexport let createElement = function (column, vmo, tableElem, rowElem) {\n  var contentElem = null;\n\n  _.forEach(column.cellRenderers, function (renderer) {\n    if (!renderer.processing && renderer.condition(column, vmo, tableElem, rowElem)) {\n      // NOTE: When ASync rendering happens, this processing mechanism may have issue.\n      // But for now the whole PL Table dosen't support ASync Rendering yet.\n      renderer.processing = true;\n      contentElem = renderer.action(column, vmo, tableElem, rowElem);\n      delete renderer.processing;\n    }\n\n    return !contentElem;\n  }); // Default cell renderer for PLTable\n\n\n  if (!contentElem) {\n    contentElem = document.createElement('div');\n    contentElem.classList.add(splmTableConstants.CLASS_TABLE_CELL_TOP);\n\n    if (vmo.props && vmo.props[column.field] && !vmo.props[column.field].isArray && vmo.props[column.field].uiValue) {\n      contentElem.title = vmo.props[column.field].uiValue;\n    }\n\n    if (tableElem && tableElem._tableInstance.dynamicRowHeightStatus) {\n      contentElem.classList.add(splmTableConstants.CLASS_TABLE_CELL_TOP_DYNAMIC);\n    }\n\n    const textContent = vmo.props && vmo.props[column.field] ? vmo.props[column.field].uiValue : '';\n\n    if (textContent || !vmo.props || Object.keys(vmo.props).length === 0) {\n      var gridCellText = document.createElement('span');\n      gridCellText.classList.add(splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT);\n      gridCellText.textContent = textContent;\n      contentElem.appendChild(gridCellText);\n    }\n  } // isDirty update\n\n\n  if (contentElem && vmo.props && vmo.props[column.field]) {\n    updateCellChangedClass(vmo.props[column.field], contentElem);\n  }\n\n  return contentElem;\n};\nexport let createHeaderElement = function (column, tableElem) {\n  var contentElem = null;\n\n  _.forEach(column.headerRenderers, function (renderer) {\n    if (!renderer.processing && renderer.condition(column, tableElem)) {\n      // NOTE: When ASync rendering happens, this processing mechanism may have issue.\n      // But for now the whole PL Table dosen't support ASync Rendering yet.\n      renderer.processing = true;\n      contentElem = renderer.action(column, tableElem);\n      delete renderer.processing;\n    }\n\n    return !contentElem;\n  });\n\n  return contentElem;\n};\nexport const addDynamicCellHeight = function (vmo, cell) {\n  const dynamicCellText = cell.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC)[0];\n\n  if (dynamicCellText) {\n    dynamicCellText.style.maxHeight = String(vmo.rowHeight) + 'px';\n  }\n};\nexport const updateCell = function (cellElem, rowElem, table, tableEditor) {\n  // If cell is in edit we don't need to update as it is databound and will have latest value\n  if (cellElem.isElementInEdit) {\n    return;\n  }\n\n  var oldCellTop = cellElem.children[0];\n  var newCellTop = createElement(cellElem.columnDef, rowElem.vmo, table, rowElem);\n\n  if (table._tableInstance.dynamicRowHeightStatus === true) {\n    addDynamicCellHeight(rowElem.vmo, newCellTop);\n  } // LCS-145046 - Launch workflow for schedule Task - Item selected does not show open cell command\n  // Move command cell to new cell if present\n  //\n  // LCS-164398 - ACE - adding child item in table mode, shows two show children icon\n  // For the case, which custom cell renderer complies its own command WITH CONDITION, there is\n  // a practice:\n  // 1. Select item which dose not match the CONDITION. In this case, we will compile a native cell\n  //    command for it. It will be dummy since the condition is not match in common case, but the DOM\n  //    structure is there.\n  // 2. After applying something (Add a child in ACE case), the CONDITION in custom cell renderer becomes\n  //    true. Then the custom cell renderer will generate the cell.\n  // 3. So for logic below, in this practice, we should not bring the old command - we should use the command\n  //    In custom cell.\n  // The only 2 cases which is going to have problem is select and hover for now - both of the should be fine\n  // here.\n  //\n  // LCS-166330 Regression caused by Fix for LCS-164398\n  // Be careful that all the DOM data structure are not OOTB JS type - in this case the classList is not array\n  // but DOMTokenList. so we can't use put empty array as default value and assume it has '.contains'.\n  //\n\n\n  var currentCellLastChildClassList = null;\n  var newCellCommandParentElem = null;\n  var oldCellCommandParentElem = null;\n\n  if (cellElem.columnDef.isTreeNavigation === true) {\n    newCellCommandParentElem = newCellTop.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER)[0];\n    oldCellCommandParentElem = oldCellTop.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER)[0];\n  } else {\n    newCellCommandParentElem = newCellTop;\n    oldCellCommandParentElem = oldCellTop;\n  }\n\n  currentCellLastChildClassList = newCellCommandParentElem.lastChild && newCellCommandParentElem.lastChild.classList ? newCellCommandParentElem.lastChild.classList : undefined;\n\n  if (!(currentCellLastChildClassList && currentCellLastChildClassList.contains(splmTableConstants.CLASS_AW_CELL_COMMANDS_CONTAINER)) && oldCellCommandParentElem.lastChild && oldCellCommandParentElem.lastChild.classList && oldCellCommandParentElem.lastChild.classList.contains(splmTableConstants.CLASS_NATIVE_CELL_COMMANDS)) {\n    newCellCommandParentElem.appendChild(oldCellCommandParentElem.lastChild);\n  } // cleanup cell commands and tree commands & expand/collapse icon components if exist\n\n\n  splmTableUtils.cleanupComponents(oldCellTop);\n  cellElem.replaceChild(newCellTop, oldCellTop);\n  tableEditor.updateEditStatusForCell(cellElem);\n};\nexports = {\n  createElement,\n  createHeaderElement,\n  addDynamicCellHeight,\n  updateCell,\n  updateCellChangedClass\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableCellRenderer.js"],"names":["exports","updateCellChangedClass","uwPropertyService","prop","element","splmTableConstants","createElement","contentElem","_","column","renderer","document","vmo","tableElem","textContent","Object","gridCellText","createHeaderElement","addDynamicCellHeight","dynamicCellText","cell","String","updateCell","cellElem","oldCellTop","newCellTop","rowElem","table","currentCellLastChildClassList","newCellCommandParentElem","oldCellCommandParentElem","splmTableUtils","tableEditor"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,iBAAA,MAAA,sBAAA;AACA,OAAA,kBAAA,MAAA,uBAAA;AACA,OAAA,cAAA,MAAA,mBAAA;AAEA,IAAIA,OAAO,GAAX,EAAA;AAEA,OAAO,IAAIC,sBAAsB,GAAG,UAAA,IAAA,EAAA,OAAA,EAA0B;EAC1D,IAAA,OAAA,EAAc;IACV,IAAIC,iBAAiB,CAAjBA,UAAAA,CAAJ,IAAIA,CAAJ,EAA2C;MACvCC,IAAI,CAAJA,KAAAA,GAAAA,IAAAA;MACAC,OAAO,CAAPA,SAAAA,CAAAA,GAAAA,CAAuBC,kBAAkB,CAAzCD,kBAAAA;IAFJ,CAAA,MAGO;MACHD,IAAI,CAAJA,KAAAA,GAAAA,KAAAA;MACAC,OAAO,CAAPA,SAAAA,CAAAA,MAAAA,CAA0BC,kBAAkB,CAA5CD,kBAAAA;IACH;EACJ;AATE,CAAA;AAYP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIE,aAAa,GAAG,UAAA,MAAA,EAAA,GAAA,EAAA,SAAA,EAAA,OAAA,EAA4C;EACnE,IAAIC,WAAW,GAAf,IAAA;;EACAC,CAAC,CAADA,OAAAA,CAAWC,MAAM,CAAjBD,aAAAA,EAAiC,UAAA,QAAA,EAAqB;IAClD,IAAI,CAACE,QAAQ,CAAT,UAAA,IAAwBA,QAAQ,CAARA,SAAAA,CAAAA,MAAAA,EAAAA,GAAAA,EAAAA,SAAAA,EAA5B,OAA4BA,CAA5B,EAAoF;MAChF;MACA;MACAA,QAAQ,CAARA,UAAAA,GAAAA,IAAAA;MACAH,WAAW,GAAGG,QAAQ,CAARA,MAAAA,CAAAA,MAAAA,EAAAA,GAAAA,EAAAA,SAAAA,EAAdH,OAAcG,CAAdH;MACA,OAAOG,QAAQ,CAAf,UAAA;IACH;;IACD,OAAO,CAAP,WAAA;EAV+D,CAEnEF,EAFmE,CAanE;;;EACA,IAAI,CAAJ,WAAA,EAAmB;IACfD,WAAW,GAAGI,QAAQ,CAARA,aAAAA,CAAdJ,KAAcI,CAAdJ;IACAA,WAAW,CAAXA,SAAAA,CAAAA,GAAAA,CAA2BF,kBAAkB,CAA7CE,oBAAAA;;IACA,IAAIK,GAAG,CAAHA,KAAAA,IAAaA,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAA9BG,KAAaA,CAAbA,IAA0C,CAACA,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAjBG,KAAAA,EAA3CA,OAAAA,IAAgFA,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAjBG,KAAAA,EAApF,OAAA,EAAwH;MACpHL,WAAW,CAAXA,KAAAA,GAAoBK,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAjBG,KAAAA,EAApBL,OAAAA;IACH;;IAED,IAAIM,SAAS,IAAIA,SAAS,CAATA,cAAAA,CAAjB,sBAAA,EAAmE;MAC/DN,WAAW,CAAXA,SAAAA,CAAAA,GAAAA,CAA2BF,kBAAkB,CAA7CE,4BAAAA;IACH;;IAED,MAAMO,WAAW,GAAGF,GAAG,CAAHA,KAAAA,IAAaA,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAA9BG,KAAaA,CAAbA,GAAyCA,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAjBG,KAAAA,EAAzCA,OAAAA,GAApB,EAAA;;IACA,IAAIE,WAAW,IAAI,CAACF,GAAG,CAAnBE,KAAAA,IAA6BC,MAAM,CAANA,IAAAA,CAAaH,GAAG,CAAhBG,KAAAA,EAAAA,MAAAA,KAAjC,CAAA,EAAyE;MACrE,IAAIC,YAAY,GAAGL,QAAQ,CAARA,aAAAA,CAAnB,MAAmBA,CAAnB;MACAK,YAAY,CAAZA,SAAAA,CAAAA,GAAAA,CAA4BX,kBAAkB,CAA9CW,4BAAAA;MACAA,YAAY,CAAZA,WAAAA,GAAAA,WAAAA;MAEAT,WAAW,CAAXA,WAAAA,CAAAA,YAAAA;IACH;EAhC8D,CAAA,CAmCnE;;;EACA,IAAIA,WAAW,IAAIK,GAAG,CAAlBL,KAAAA,IAA4BK,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAjD,KAAgCG,CAAhC,EAA4D;IACxDX,sBAAsB,CAAEW,GAAG,CAAHA,KAAAA,CAAWH,MAAM,CAAnB,KAAEG,CAAF,EAAtBX,WAAsB,CAAtBA;EACH;;EAED,OAAA,WAAA;AAxCG,CAAA;AA2CP,OAAO,IAAIgB,mBAAmB,GAAG,UAAA,MAAA,EAAA,SAAA,EAA8B;EAC3D,IAAIV,WAAW,GAAf,IAAA;;EACAC,CAAC,CAADA,OAAAA,CAAWC,MAAM,CAAjBD,eAAAA,EAAmC,UAAA,QAAA,EAAqB;IACpD,IAAI,CAACE,QAAQ,CAAT,UAAA,IAAwBA,QAAQ,CAARA,SAAAA,CAAAA,MAAAA,EAA5B,SAA4BA,CAA5B,EAAsE;MAClE;MACA;MACAA,QAAQ,CAARA,UAAAA,GAAAA,IAAAA;MACAH,WAAW,GAAGG,QAAQ,CAARA,MAAAA,CAAAA,MAAAA,EAAdH,SAAcG,CAAdH;MACA,OAAOG,QAAQ,CAAf,UAAA;IACH;;IACD,OAAO,CAAP,WAAA;EARJF,CAAAA;;EAWA,OAAA,WAAA;AAbG,CAAA;AAgBP,OAAO,MAAMU,oBAAoB,GAAG,UAAA,GAAA,EAAA,IAAA,EAAsB;EACtD,MAAMC,eAAe,GAAGC,IAAI,CAAJA,sBAAAA,CAA6Bf,kBAAkB,CAA/Ce,oCAAAA,EAAxB,CAAwBA,CAAxB;;EACA,IAAA,eAAA,EAAsB;IAClBD,eAAe,CAAfA,KAAAA,CAAAA,SAAAA,GAAkCE,MAAM,CAAET,GAAG,CAAXS,SAAM,CAANA,GAAlCF,IAAAA;EACH;AAJE,CAAA;AAOP,OAAO,MAAMG,UAAU,GAAG,UAAA,QAAA,EAAA,OAAA,EAAA,KAAA,EAAA,WAAA,EAAkD;EACxE;EACA,IAAIC,QAAQ,CAAZ,eAAA,EAA+B;IAC3B;EACH;;EACD,IAAIC,UAAU,GAAGD,QAAQ,CAARA,QAAAA,CAAjB,CAAiBA,CAAjB;EACA,IAAIE,UAAU,GAAGnB,aAAa,CAAEiB,QAAQ,CAAV,SAAA,EAAsBG,OAAO,CAA7B,GAAA,EAAA,KAAA,EAA9B,OAA8B,CAA9B;;EACA,IAAIC,KAAK,CAALA,cAAAA,CAAAA,sBAAAA,KAAJ,IAAA,EAA2D;IACvDT,oBAAoB,CAAEQ,OAAO,CAAT,GAAA,EAApBR,UAAoB,CAApBA;EARoE,CAAA,CAWxE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,IAAIU,6BAA6B,GAAjC,IAAA;EACA,IAAIC,wBAAwB,GAA5B,IAAA;EACA,IAAIC,wBAAwB,GAA5B,IAAA;;EACA,IAAIP,QAAQ,CAARA,SAAAA,CAAAA,gBAAAA,KAAJ,IAAA,EAAmD;IAC/CM,wBAAwB,GAAGJ,UAAU,CAAVA,sBAAAA,CAAmCpB,kBAAkB,CAArDoB,qCAAAA,EAA3BI,CAA2BJ,CAA3BI;IACAC,wBAAwB,GAAGN,UAAU,CAAVA,sBAAAA,CAAmCnB,kBAAkB,CAArDmB,qCAAAA,EAA3BM,CAA2BN,CAA3BM;EAFJ,CAAA,MAGO;IACHD,wBAAwB,GAAxBA,UAAAA;IACAC,wBAAwB,GAAxBA,UAAAA;EACH;;EAEDF,6BAA6B,GAAGC,wBAAwB,CAAxBA,SAAAA,IAAsCA,wBAAwB,CAAxBA,SAAAA,CAAtCA,SAAAA,GAC5BA,wBAAwB,CAAxBA,SAAAA,CAD4BA,SAAAA,GAAhCD,SAAAA;;EAGA,IAAI,EAAGA,6BAA6B,IAAIA,6BAA6B,CAA7BA,QAAAA,CAAwCvB,kBAAkB,CAA9F,gCAAoCuB,CAApC,KACAE,wBAAwB,CADxB,SAAA,IACsCA,wBAAwB,CAAxBA,SAAAA,CADtC,SAAA,IAEAA,wBAAwB,CAAxBA,SAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAuDzB,kBAAkB,CAF7E,0BAEIyB,CAFJ,EAE6G;IACzGD,wBAAwB,CAAxBA,WAAAA,CAAsCC,wBAAwB,CAA9DD,SAAAA;EAhDoE,CAAA,CAmDxE;;;EACAE,cAAc,CAAdA,iBAAAA,CAAAA,UAAAA;EACAR,QAAQ,CAARA,YAAAA,CAAAA,UAAAA,EAAAA,UAAAA;EACAS,WAAW,CAAXA,uBAAAA,CAAAA,QAAAA;AAtDG,CAAA;AAyDPhC,OAAO,GAAG;EAAA,aAAA;EAAA,mBAAA;EAAA,oBAAA;EAAA,UAAA;EAKNC;AALM,CAAVD;AAOA,eAAA,OAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module provides cell renderer customization mechanism in PL Table.\n *\n * - Below is the cell renderer pattern:\n *   {\n *       action: function( columnDef, vmo, tableElement ) {\n *           // return DOMStructure\n *       },\n *       condition: function( columnDef, vmo, tableElement ) {\n *           // return true to enable this renderer\n *       }\n *   }\n *\n * - Best practice is to make condition to be unique for your case.\n * - If the requirement is overlapping default behavior, just overlap the condition.\n * - If decoration to cell is needed, just write action, do your work without return\n *   value, but the decoration will only happens before OOTB cell renderer, not after.\n *\n * @module js/splmTableCellRenderer\n *\n */\nimport _ from 'lodash';\nimport uwPropertyService from 'js/uwPropertyService';\nimport splmTableConstants from 'js/splmTableConstants';\nimport splmTableUtils from 'js/splmTableUtils';\n\nvar exports = {};\n\nexport let updateCellChangedClass = function( prop, element ) {\n    if( element ) {\n        if( uwPropertyService.isModified( prop ) ) {\n            prop.dirty = true;\n            element.classList.add( splmTableConstants.CLASS_CELL_CHANGED );\n        } else {\n            prop.dirty = false;\n            element.classList.remove( splmTableConstants.CLASS_CELL_CHANGED );\n        }\n    }\n};\n\n/**\n * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n * and the given column (columnInfo )\n * @param {Object} column - Declarative columnInfo object\n * @param {Object} vmo - Declarative view model object (e.g. row)\n * @param {DOMElement} tableElem - Table DOMElement\n * @param {DOMElement} rowElem - Row DOMElement\n * @param {Boolean} dynamicRowHeightEnabled - if dynamic row height is enabled\n * @return {DOMElement} The newly created DOMElement for the property cell content\n */\nexport let createElement = function( column, vmo, tableElem, rowElem ) {\n    var contentElem = null;\n    _.forEach( column.cellRenderers, function( renderer ) {\n        if( !renderer.processing && renderer.condition( column, vmo, tableElem, rowElem ) ) {\n            // NOTE: When ASync rendering happens, this processing mechanism may have issue.\n            // But for now the whole PL Table dosen't support ASync Rendering yet.\n            renderer.processing = true;\n            contentElem = renderer.action( column, vmo, tableElem, rowElem );\n            delete renderer.processing;\n        }\n        return !contentElem;\n    } );\n\n    // Default cell renderer for PLTable\n    if( !contentElem ) {\n        contentElem = document.createElement( 'div' );\n        contentElem.classList.add( splmTableConstants.CLASS_TABLE_CELL_TOP );\n        if( vmo.props && vmo.props[ column.field ] && !vmo.props[ column.field ].isArray && vmo.props[ column.field ].uiValue ) {\n            contentElem.title = vmo.props[ column.field ].uiValue;\n        }\n\n        if( tableElem && tableElem._tableInstance.dynamicRowHeightStatus ) {\n            contentElem.classList.add( splmTableConstants.CLASS_TABLE_CELL_TOP_DYNAMIC );\n        }\n\n        const textContent = vmo.props && vmo.props[ column.field ] ? vmo.props[ column.field ].uiValue : '';\n        if( textContent || !vmo.props || Object.keys( vmo.props ).length === 0 ) {\n            var gridCellText = document.createElement( 'span' );\n            gridCellText.classList.add( splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT );\n            gridCellText.textContent = textContent;\n\n            contentElem.appendChild( gridCellText );\n        }\n    }\n\n    // isDirty update\n    if( contentElem && vmo.props && vmo.props[ column.field ] ) {\n        updateCellChangedClass( vmo.props[ column.field ], contentElem );\n    }\n\n    return contentElem;\n};\n\nexport let createHeaderElement = function( column, tableElem ) {\n    var contentElem = null;\n    _.forEach( column.headerRenderers, function( renderer ) {\n        if( !renderer.processing && renderer.condition( column, tableElem ) ) {\n            // NOTE: When ASync rendering happens, this processing mechanism may have issue.\n            // But for now the whole PL Table dosen't support ASync Rendering yet.\n            renderer.processing = true;\n            contentElem = renderer.action( column, tableElem );\n            delete renderer.processing;\n        }\n        return !contentElem;\n    } );\n\n    return contentElem;\n};\n\nexport const addDynamicCellHeight = function( vmo, cell ) {\n    const dynamicCellText = cell.getElementsByClassName( splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC )[ 0 ];\n    if( dynamicCellText ) {\n        dynamicCellText.style.maxHeight = String( vmo.rowHeight ) + 'px';\n    }\n};\n\nexport const updateCell = function( cellElem, rowElem, table, tableEditor ) {\n    // If cell is in edit we don't need to update as it is databound and will have latest value\n    if( cellElem.isElementInEdit ) {\n        return;\n    }\n    var oldCellTop = cellElem.children[ 0 ];\n    var newCellTop = createElement( cellElem.columnDef, rowElem.vmo, table, rowElem );\n    if( table._tableInstance.dynamicRowHeightStatus === true ) {\n        addDynamicCellHeight( rowElem.vmo, newCellTop );\n    }\n\n    // LCS-145046 - Launch workflow for schedule Task - Item selected does not show open cell command\n    // Move command cell to new cell if present\n    //\n    // LCS-164398 - ACE - adding child item in table mode, shows two show children icon\n    // For the case, which custom cell renderer complies its own command WITH CONDITION, there is\n    // a practice:\n    // 1. Select item which dose not match the CONDITION. In this case, we will compile a native cell\n    //    command for it. It will be dummy since the condition is not match in common case, but the DOM\n    //    structure is there.\n    // 2. After applying something (Add a child in ACE case), the CONDITION in custom cell renderer becomes\n    //    true. Then the custom cell renderer will generate the cell.\n    // 3. So for logic below, in this practice, we should not bring the old command - we should use the command\n    //    In custom cell.\n    // The only 2 cases which is going to have problem is select and hover for now - both of the should be fine\n    // here.\n    //\n    // LCS-166330 Regression caused by Fix for LCS-164398\n    // Be careful that all the DOM data structure are not OOTB JS type - in this case the classList is not array\n    // but DOMTokenList. so we can't use put empty array as default value and assume it has '.contains'.\n    //\n    var currentCellLastChildClassList = null;\n    var newCellCommandParentElem = null;\n    var oldCellCommandParentElem = null;\n    if( cellElem.columnDef.isTreeNavigation === true ) {\n        newCellCommandParentElem = newCellTop.getElementsByClassName( splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER )[ 0 ];\n        oldCellCommandParentElem = oldCellTop.getElementsByClassName( splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER )[ 0 ];\n    } else {\n        newCellCommandParentElem = newCellTop;\n        oldCellCommandParentElem = oldCellTop;\n    }\n\n    currentCellLastChildClassList = newCellCommandParentElem.lastChild && newCellCommandParentElem.lastChild.classList ?\n        newCellCommandParentElem.lastChild.classList : undefined;\n\n    if( !( currentCellLastChildClassList && currentCellLastChildClassList.contains( splmTableConstants.CLASS_AW_CELL_COMMANDS_CONTAINER ) ) &&\n        oldCellCommandParentElem.lastChild && oldCellCommandParentElem.lastChild.classList &&\n        oldCellCommandParentElem.lastChild.classList.contains( splmTableConstants.CLASS_NATIVE_CELL_COMMANDS ) ) {\n        newCellCommandParentElem.appendChild( oldCellCommandParentElem.lastChild );\n    }\n\n    // cleanup cell commands and tree commands & expand/collapse icon components if exist\n    splmTableUtils.cleanupComponents( oldCellTop );\n    cellElem.replaceChild( newCellTop, oldCellTop );\n    tableEditor.updateEditStatusForCell( cellElem );\n};\n\nexports = {\n    createElement,\n    createHeaderElement,\n    addDynamicCellHeight,\n    updateCell,\n    updateCellChangedClass\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}