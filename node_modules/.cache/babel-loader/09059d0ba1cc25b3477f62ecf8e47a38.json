{"ast":null,"code":"/* eslint-disable valid-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n *\n * @module js/commandConfigurationService\n */\nimport _, { uniqBy } from 'lodash';\nimport logger from 'js/logger';\nimport 'js/iconService';\nimport ccu from 'js/commandConfigUtils.service';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\nimport { getLocalizedText } from 'js/localeService';\nimport Debug from 'debug';\nimport debugService from 'js/debugService';\nimport conditionService from 'js/conditionService';\nimport htmlUtils from 'js/htmlUtils';\nconst trace = new Debug('command:AwCommandBar'); //TODO: Global state that should not be managed in a service - revisit later\n\nlet dynamicPlacements = [];\nconst handlerCache = {};\n\nconst getHandlersForCommand = (id, commandsViewModel, useCache) => {\n  if (!handlerCache[id] || !useCache) {\n    handlerCache[id] = Object.entries(commandsViewModel.commandHandlers).filter(_ref => {\n      let [, v] = _ref;\n      return v.id === id;\n    });\n  }\n\n  return handlerCache[id];\n};\n\nconst DeclarativeCondition = function (condition, commandsViewModel) {\n  this.id = condition.split('.').slice(-1)[0];\n  this.expression = ccu.getConditionExpression(commandsViewModel, condition);\n};\n\n_c = DeclarativeCondition;\n\nconst getHandlerAction = (handler, commandsViewModel, _ref2) => {\n  let {\n    isRibbon\n  } = _ref2;\n\n  if (isRibbon) {\n    //Ribbon commands use their configured action or open popup with child commands if not configured\n    return commandsViewModel.actions[handler.action || 'openCommandGroup'];\n  }\n\n  if (handler.action) {\n    //Base commands use their configured action\n    return commandsViewModel.actions[handler.action];\n  }\n\n  return null;\n};\n/**\n * Command handler information from commandsViewModel\n *\n * Will be used by AwCommand to setup any necessary hooks and process\n */\n\n\nconst CommandHandler = function (id, handler, commandsViewModel, definition) {\n  // String :: ID of the command handler\n  this.id = id; // DeclarativeCondition :: Active condition for this handler\n\n  this.activeWhen = new DeclarativeCondition(handler.activeWhen.condition, commandsViewModel); // Number :: Priority of the command handler (length of the activeWhen condition)\n\n  this.priority = ccu.getExpressionLength(this.activeWhen.expression, commandsViewModel); // DeclarativeCondition :: Enabled state condition for this handler\n\n  this.enableWhen = handler.enableWhen ? new DeclarativeCondition(handler.enableWhen.condition, commandsViewModel) : null; // DeclarativeCondition :: Selected state condition for this handler\n\n  this.selectWhen = handler.selectWhen ? new DeclarativeCondition(handler.selectWhen.condition, commandsViewModel) : null; // DeclarativeCondition :: Visibility condition for this handler\n\n  this.visibleWhen = handler.visibleWhen ? new DeclarativeCondition(handler.visibleWhen.condition, commandsViewModel) : null;\n  /**\n   * The action that this handler will execute\n   */\n\n  this.action = getHandlerAction(handler, commandsViewModel, definition);\n  /**\n   * Callback function to execute this command handler\n   *\n   * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model\n   * @returns {CommandExecutionResult}\n   */\n\n  this.execute = async (runActionWithViewModel, scope, commandContext) => {\n    scope.commandContext = commandContext || scope.commandContext;\n    return runActionWithViewModel(commandsViewModel, handler.action, scope);\n  };\n};\n/**\n * The raw data from commands view model that will be used to determine the current command state\n */\n\n\n_c2 = CommandHandler;\nexport const CommandOverlay = function (_ref3) {\n  let {\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    showGroupSelected = true,\n    cellDisplay\n  } = _ref3;\n  // String! :: ID of the command\n  this.id = id; // [CommandHandler] :: Handlers for this command\n\n  this.handlers = handlers; // I18nReference :: Title definition of the command\n\n  this.title = title;\n  this.selectedTitle = selectedTitle; // String :: ID of the command icon\n\n  this.icon = icon;\n  this.selectedIcon = selectedIcon;\n  this.decorator = decorator;\n  this.extendedTooltip = extendedTooltip;\n  this.selectedExtendedTooltip = selectedExtendedTooltip;\n  this.description = description;\n  this.selectedDescription = selectedDescription;\n  this.type = type;\n  this.children = children;\n  this.showGroupSelected = showGroupSelected;\n  this.cellDisplay = cellDisplay;\n  this.trace = new Debug(`command:${id}`);\n  this.trace('Overlay created', this);\n};\n/**\n * Get the i18n string configured in the given view model\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String} key Key within the i18n section\n * @param {Object} viewModel View model json\n * @returns {String} The localized text value\n */\n\n_c3 = CommandOverlay;\n\nconst getI18nValue = async (key, viewModel) => {\n  const resource = viewModel.i18n[key] ? viewModel.i18n[key][0] : '';\n  return getLocalizedText(resource, key);\n};\n/**\n * Resolve an i18n reference\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String|Object} i18nRef Reference information\n * @param {Object} viewModel View model json\n * @returns {Object} The string value and a list of any parameters it may have\n */\n\n\nconst resolveI18n = async (i18nRef, viewModel) => {\n  if (typeof i18nRef === 'string') {\n    const reference = getStringBetweenDoubleMustaches(i18nRef);\n    const value = reference.startsWith('i18n.') ? await getI18nValue(reference.slice(5), viewModel) : reference;\n    return {\n      value,\n      parameters: []\n    };\n  }\n\n  if (typeof i18nRef === 'object') {\n    const {\n      value\n    } = await resolveI18n(i18nRef.text, viewModel);\n    return {\n      value,\n      parameters: i18nRef.params || i18nRef.parameters\n    };\n  }\n\n  return null;\n};\n/**\n * Get the type of a command\n *\n * @param {Object} definition Command definition\n * @returns {String} Command type\n */\n\n\nconst getCommandType = definition => {\n  if (definition.isShuttle) {\n    return 'SHUTTLE';\n  }\n\n  if (definition.isRibbon) {\n    return 'RIBBON';\n  }\n\n  if (definition.isGroup) {\n    return 'GROUP';\n  }\n\n  if (definition.isToggle) {\n    return 'TOGGLE';\n  }\n\n  return 'BASE';\n};\n/**\n * Get a command overlay\n *\n * @param {String} id ID of the command\n * @returns {CommandOverlay} Overlay for the command\n */\n\n\nexport const getCommand = async (id, useCache) => {\n  const commandsViewModel = await ccu.getCommandsViewModel();\n  return getCommandInternal(id, commandsViewModel, null, useCache);\n};\n\nconst getDecoratorObject = async (template, commandsViewModel) => {\n  const checkVisbleWhenConditionForConversion = visibleWhen => {\n    if (visibleWhen && visibleWhen.condition) {\n      return visibleWhen.condition;\n    }\n\n    if (visibleWhen === false) {\n      return 'conditions.false';\n    }\n\n    return 'conditions.true';\n  };\n\n  let value = getStringBetweenDoubleMustaches(template.text);\n\n  if (value.startsWith('i18n.')) {\n    return {\n      text: await resolveI18n(template.text, commandsViewModel),\n      visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen), commandsViewModel) : null,\n      class: template.class ? template.class : null\n    };\n  }\n\n  return {\n    text: {\n      value: '{0}',\n      parameters: [template.text]\n    },\n    visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen), commandsViewModel) : null,\n    class: template.class ? template.class : null\n  };\n};\n/**\n * Load the necessary data to create a CommandOverlay and return it\n *\n * @param {String} id ID of the command\n * @param {Object} commandsViewModel Commands view model json\n * @param {Object} placement (Optional) Placement information\n */\n\n\nconst getCommandInternal = async function (id, commandsViewModel) {\n  let placement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let useCache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const definition = commandsViewModel.commands[id];\n\n  if (!definition) {\n    logger.error(`Missing command definition for ${id}`);\n  }\n\n  const type = getCommandType(definition);\n  const handlers = type === 'GROUP' || type === 'SHUTTLE' ? [new CommandHandler('GroupCommandHandler', {\n    activeWhen: {\n      condition: 'conditions.true'\n    },\n    action: 'openCommandGroup'\n  }, commandsViewModel, definition)] : getHandlersForCommand(id, commandsViewModel, useCache).map(_ref4 => {\n    let [handlerId, value] = _ref4;\n    return new CommandHandler(handlerId, value, commandsViewModel, definition);\n  }).sort((a, b) => b.priority - a.priority);\n  const icon = definition.iconId;\n  const selectedIcon = definition.selected ? definition.selected.iconId : null; //TODO: Some stuff (i18n) may need to be resolved here\n\n  const extendedTooltip = definition.extendedTooltip;\n  const selectedExtendedTooltip = definition.selected && definition.selected.extendedTooltip ? definition.selected.extendedTooltip : null;\n  const [title, selectedTitle, description, selectedDescription, decorator] = await Promise.all([resolveI18n(definition.title, commandsViewModel), definition.selected && definition.selected.title ? resolveI18n(definition.selected.title, commandsViewModel) : null, definition.description ? await resolveI18n(definition.description, commandsViewModel) : null, definition.selected && definition.selected.description ? resolveI18n(definition.selected.description, commandsViewModel) : null, definition.template && definition.template.text ? getDecoratorObject(definition.template, commandsViewModel) : null]);\n  const children = type === 'GROUP' || type === 'SHUTTLE' ? await getCommands(id) : [];\n  return new CommandOverlay({\n    showGroupSelected: !placement || placement.showGroupSelected !== false,\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    cellDisplay: placement ? placement.cellDisplay : null\n  });\n};\n/**\n * Sort the placements based on relativeTo and priority. Priority is 0 if not set.\n *\n * @param {[CommandPlacement]} placements - placements\n * @return {[CommandPlacement]} Sorted list of command placements\n */\n\n\nconst sortPlacements = function (placements) {\n  // Assign a priority to any placement that doesn't have one\n  placements.forEach(function (cmd) {\n    cmd.priority = cmd.priority || 0;\n  }); // Split based on whether placement is relative or absolute\n\n  const p = _.partition(placements, function (cmd) {\n    return cmd.relativeTo;\n  }); // Sort the commands with only priority\n\n\n  const priorityCommands = _.sortBy(p[1], 'priority'); // Group the relative commands by the relativeTo property\n\n\n  const allRelativeCmds = _.groupBy(p[0], 'relativeTo');\n\n  const commandsWithRelativeAdded = priorityCommands.reduce((acc, placement) => {\n    // Split into before / after based on negative / positive priority\n    const p2 = _.partition(allRelativeCmds[placement.id] || [], function (cmd) {\n      return cmd.priority > 0;\n    });\n\n    const afterPlacements = _.sortBy(p2[0], 'priority');\n\n    const beforePlacements = _.sortBy(p2[1], 'priority'); //side effect, could be refactored later\n\n\n    delete allRelativeCmds[placement.id];\n    return [...acc, ...beforePlacements, placement, ...afterPlacements];\n  }, []); //Add any placement with relativeTo that is not in this command bar to the end\n\n  return Object.values(allRelativeCmds).reduce((acc, missingRelativeSet) => {\n    logger.debug(`Unable to find relative command ${missingRelativeSet[0].id}. Commands will be placed at end of list.`, missingRelativeSet);\n    return [...acc, ...missingRelativeSet];\n  }, commandsWithRelativeAdded);\n};\n/**\n * Get the commands for the given anchor\n *\n * @param {String} anchor anchor\n * @returns {[CommandOverlay]} Command overlays for the anchor\n */\n\n\nexport const getCommands = async (anchor, useCache) => {\n  const commandsViewModel = await ccu.getCommandsViewModel();\n  const anchors = anchor.split(',');\n  const allPlacements = [...dynamicPlacements, ...Object.values(commandsViewModel.commandPlacements)];\n  const placements = uniqBy(anchors.reduce((fullPlacementList, nextAnchor) => {\n    const newPlacements = allPlacements.filter(placement => !placement.parentGroupId && placement.uiAnchor === nextAnchor && commandsViewModel.commands[placement.id]);\n    return [...fullPlacementList, ...newPlacements];\n  }, []), 'id');\n  let placementsSorted = sortPlacements(placements);\n  const commands = await Promise.all(placementsSorted.map(placement => getCommandInternal(placement.id, commandsViewModel, placement, useCache)));\n\n  if (anchor) {\n    debugService.debugGetCommandsForAnchor(anchor, commands);\n    debugService.reduceData(anchor, commands);\n  }\n\n  return commands;\n};\n/**\n * Add a placement for a command at runtime. All placements\n * must be defined before the AwCommandBar with the matching\n * anchor is rendered\n *\n * @param {[CommandPlacement]} placements Placements to add\n * @returns {Object} Tracking information to all for removal of the placements\n */\n\nexport const addPlacements = placements => {\n  trace('Dynamic placements added', placements);\n  dynamicPlacements = [...dynamicPlacements, ...placements];\n  return {\n    placements,\n    remove: () => {\n      dynamicPlacements = dynamicPlacements.filter(x => !placements.includes(x));\n      trace('Dynamic placements removed', placements);\n    }\n  };\n};\n/**\n * Get the commandContext of a given command bar/group\n *\n * @param {String} grpCmdAnchor - the group id/anchor for a given command group\n * @param {String} commandBarAnchor - the anchor for a given command bar\n * @returns {Object} commandContext for given command group or command bar\n */\n\nexport const getCommandContext = function (grpCmdAnchor, commandBarAnchor) {\n  let commandBarXPath = `//div[contains(@class, 'aw-command-bar') and @anchor='${grpCmdAnchor ? grpCmdAnchor : commandBarAnchor}']`;\n  let commandBar = htmlUtils.getElementByXpath(commandBarXPath, document.body);\n\n  if (commandBar) {\n    const key = Object.keys(commandBar).find(key => {\n      return key.startsWith('__reactFiber$');\n    });\n    const commandBarFiber = commandBar[key];\n\n    if (commandBarFiber.return.memoizedProps.commandContext) {\n      return commandBarFiber.return.memoizedProps.commandContext;\n    } // get parent toolbar which has command context\n\n\n    let toolbarFiber = commandBarFiber.return;\n\n    while (typeof toolbarFiber.type === 'string') {\n      toolbarFiber = toolbarFiber.return;\n    }\n\n    return toolbarFiber.return.memoizedProps.commandContext;\n  }\n\n  return null;\n};\n/**\n * Given the array of handlers for a command get the activeHandler\n *\n * @param {Array<Handler>} handlers - array of command handlers\n * @param {Object} scope - evaluation scope\n * @returns {Handler} the active handler\n */\n\nexport const getActiveCommandHandler = function (handlers, scope) {\n  for (const handler of handlers) {\n    const isActive = Boolean(conditionService.evaluateCondition({}, handler.activeWhen.expression, scope));\n\n    if (isActive) {\n      return handler;\n    }\n  }\n\n  return null;\n};\n/**\n * Check whether a command is enabled and visible\n *\n * @param {Object} activeHandler - active command handler\n * @param {Object} scope - evaluation scope\n * @returns {Boolean} visbleWhen and enableWhen\n */\n\nexport const getCommandAndCheckVisibility = function (activeHandler, scope) {\n  const visibleWhen = activeHandler.visibleWhen ? Boolean(conditionService.evaluateCondition({}, activeHandler.visibleWhen.expression, scope)) : true;\n  const enableWhen = activeHandler.enableWhen ? Boolean(conditionService.evaluateCondition({}, activeHandler.enableWhen.expression, scope)) : true;\n  return visibleWhen && enableWhen;\n};\nexport default {\n  getCommand,\n  getCommands,\n  getCommandContext,\n  getActiveCommandHandler,\n  getCommandAndCheckVisibility\n};\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"DeclarativeCondition\");\n$RefreshReg$(_c2, \"CommandHandler\");\n$RefreshReg$(_c3, \"CommandOverlay\");","map":{"version":3,"names":["_","uniqBy","logger","ccu","getStringBetweenDoubleMustaches","getLocalizedText","Debug","debugService","conditionService","htmlUtils","trace","dynamicPlacements","handlerCache","getHandlersForCommand","id","commandsViewModel","useCache","Object","entries","commandHandlers","filter","v","DeclarativeCondition","condition","split","slice","expression","getConditionExpression","getHandlerAction","handler","isRibbon","actions","action","CommandHandler","definition","activeWhen","priority","getExpressionLength","enableWhen","selectWhen","visibleWhen","execute","runActionWithViewModel","scope","commandContext","CommandOverlay","handlers","title","selectedTitle","icon","selectedIcon","decorator","extendedTooltip","selectedExtendedTooltip","description","selectedDescription","type","children","showGroupSelected","cellDisplay","getI18nValue","key","viewModel","resource","i18n","resolveI18n","i18nRef","reference","value","startsWith","parameters","text","params","getCommandType","isShuttle","isGroup","isToggle","getCommand","getCommandsViewModel","getCommandInternal","getDecoratorObject","template","checkVisbleWhenConditionForConversion","undefined","class","placement","commands","error","map","handlerId","sort","a","b","iconId","selected","Promise","all","getCommands","sortPlacements","placements","forEach","cmd","p","partition","relativeTo","priorityCommands","sortBy","allRelativeCmds","groupBy","commandsWithRelativeAdded","reduce","acc","p2","afterPlacements","beforePlacements","values","missingRelativeSet","debug","anchor","anchors","allPlacements","commandPlacements","fullPlacementList","nextAnchor","newPlacements","parentGroupId","uiAnchor","placementsSorted","debugGetCommandsForAnchor","reduceData","addPlacements","remove","x","includes","getCommandContext","grpCmdAnchor","commandBarAnchor","commandBarXPath","commandBar","getElementByXpath","document","body","keys","find","commandBarFiber","return","memoizedProps","toolbarFiber","getActiveCommandHandler","isActive","Boolean","evaluateCondition","getCommandAndCheckVisibility","activeHandler"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/commandConfigurationService.js"],"sourcesContent":["/* eslint-disable valid-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n *\n * @module js/commandConfigurationService\n */\nimport _, { uniqBy } from 'lodash';\nimport logger from 'js/logger';\nimport 'js/iconService';\nimport ccu from 'js/commandConfigUtils.service';\nimport { getStringBetweenDoubleMustaches } from 'js/parsingUtils';\nimport { getLocalizedText } from 'js/localeService';\nimport Debug from 'debug';\nimport debugService from 'js/debugService';\nimport conditionService from 'js/conditionService';\nimport htmlUtils from 'js/htmlUtils';\nconst trace = new Debug( 'command:AwCommandBar' );\n\n//TODO: Global state that should not be managed in a service - revisit later\nlet dynamicPlacements = [];\nconst handlerCache = {};\nconst getHandlersForCommand = ( id, commandsViewModel, useCache ) => {\n    if( !handlerCache[ id ] || !useCache ) {\n        handlerCache[ id ] = Object.entries( commandsViewModel.commandHandlers )\n            .filter( ( [ , v ] ) => v.id === id );\n    }\n    return handlerCache[ id ];\n};\n\nconst DeclarativeCondition = function( condition, commandsViewModel ) {\n    this.id = condition.split( '.' ).slice( -1 )[ 0 ];\n    this.expression = ccu.getConditionExpression( commandsViewModel, condition );\n};\n\nconst getHandlerAction = ( handler, commandsViewModel, { isRibbon } ) => {\n    if( isRibbon ) {\n        //Ribbon commands use their configured action or open popup with child commands if not configured\n        return commandsViewModel.actions[ handler.action || 'openCommandGroup' ];\n    }\n    if( handler.action ) {\n        //Base commands use their configured action\n        return commandsViewModel.actions[ handler.action ];\n    }\n    return null;\n};\n\n/**\n * Command handler information from commandsViewModel\n *\n * Will be used by AwCommand to setup any necessary hooks and process\n */\nconst CommandHandler = function( id, handler, commandsViewModel, definition ) {\n    // String :: ID of the command handler\n    this.id = id;\n    // DeclarativeCondition :: Active condition for this handler\n    this.activeWhen = new DeclarativeCondition( handler.activeWhen.condition, commandsViewModel );\n    // Number :: Priority of the command handler (length of the activeWhen condition)\n    this.priority = ccu.getExpressionLength( this.activeWhen.expression, commandsViewModel );\n    // DeclarativeCondition :: Enabled state condition for this handler\n    this.enableWhen = handler.enableWhen ? new DeclarativeCondition( handler.enableWhen.condition, commandsViewModel ) : null;\n    // DeclarativeCondition :: Selected state condition for this handler\n    this.selectWhen = handler.selectWhen ? new DeclarativeCondition( handler.selectWhen.condition, commandsViewModel ) : null;\n    // DeclarativeCondition :: Visibility condition for this handler\n    this.visibleWhen = handler.visibleWhen ? new DeclarativeCondition( handler.visibleWhen.condition, commandsViewModel ) : null;\n\n    /**\n     * The action that this handler will execute\n     */\n    this.action = getHandlerAction( handler, commandsViewModel, definition );\n\n    /**\n     * Callback function to execute this command handler\n     *\n     * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model\n     * @returns {CommandExecutionResult}\n     */\n    this.execute = async( runActionWithViewModel, scope, commandContext ) => {\n        scope.commandContext = commandContext || scope.commandContext;\n        return runActionWithViewModel( commandsViewModel, handler.action, scope );\n    };\n};\n\n/**\n * The raw data from commands view model that will be used to determine the current command state\n */\nexport const CommandOverlay = function( {\n    id,\n    handlers,\n    title,\n    selectedTitle,\n    icon,\n    selectedIcon,\n    decorator,\n    extendedTooltip,\n    selectedExtendedTooltip,\n    description,\n    selectedDescription,\n    type,\n    children,\n    showGroupSelected = true,\n    cellDisplay\n} ) {\n    // String! :: ID of the command\n    this.id = id;\n\n    // [CommandHandler] :: Handlers for this command\n    this.handlers = handlers;\n\n    // I18nReference :: Title definition of the command\n    this.title = title;\n    this.selectedTitle = selectedTitle;\n\n    // String :: ID of the command icon\n    this.icon = icon;\n    this.selectedIcon = selectedIcon;\n    this.decorator = decorator;\n    this.extendedTooltip = extendedTooltip;\n    this.selectedExtendedTooltip = selectedExtendedTooltip;\n    this.description = description;\n    this.selectedDescription = selectedDescription;\n    this.type = type;\n\n    this.children = children;\n\n    this.showGroupSelected = showGroupSelected;\n    this.cellDisplay = cellDisplay;\n\n    this.trace = new Debug( `command:${id}` );\n    this.trace( 'Overlay created', this );\n};\n\n/**\n * Get the i18n string configured in the given view model\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String} key Key within the i18n section\n * @param {Object} viewModel View model json\n * @returns {String} The localized text value\n */\nconst getI18nValue = async( key, viewModel ) => {\n    const resource = viewModel.i18n[ key ] ? viewModel.i18n[ key ][ 0 ] : '';\n    return getLocalizedText( resource, key );\n};\n\n/**\n * Resolve an i18n reference\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String|Object} i18nRef Reference information\n * @param {Object} viewModel View model json\n * @returns {Object} The string value and a list of any parameters it may have\n */\nconst resolveI18n = async( i18nRef, viewModel ) => {\n    if( typeof i18nRef === 'string' ) {\n        const reference = getStringBetweenDoubleMustaches( i18nRef );\n        const value = reference.startsWith( 'i18n.' ) ? await getI18nValue( reference.slice( 5 ), viewModel ) : reference;\n        return {\n            value,\n            parameters: []\n        };\n    }\n    if( typeof i18nRef === 'object' ) {\n        const { value } = await resolveI18n( i18nRef.text, viewModel );\n        return {\n            value,\n            parameters: i18nRef.params || i18nRef.parameters\n        };\n    }\n    return null;\n};\n\n/**\n * Get the type of a command\n *\n * @param {Object} definition Command definition\n * @returns {String} Command type\n */\nconst getCommandType = definition => {\n    if( definition.isShuttle ) {\n        return 'SHUTTLE';\n    }\n    if( definition.isRibbon ) {\n        return 'RIBBON';\n    }\n    if( definition.isGroup ) {\n        return 'GROUP';\n    }\n    if( definition.isToggle ) {\n        return 'TOGGLE';\n    }\n    return 'BASE';\n};\n\n/**\n * Get a command overlay\n *\n * @param {String} id ID of the command\n * @returns {CommandOverlay} Overlay for the command\n */\nexport const getCommand = async( id, useCache ) => {\n    const commandsViewModel = await ccu.getCommandsViewModel();\n    return getCommandInternal( id, commandsViewModel, null, useCache );\n};\n\nconst getDecoratorObject = async( template, commandsViewModel ) => {\n    const checkVisbleWhenConditionForConversion = ( visibleWhen ) => {\n        if( visibleWhen && visibleWhen.condition ) {\n            return visibleWhen.condition;\n        }\n        if( visibleWhen === false ) {\n            return 'conditions.false';\n        }\n        return 'conditions.true';\n    };\n\n    let value = getStringBetweenDoubleMustaches( template.text );\n    if( value.startsWith( 'i18n.' ) ) {\n        return {\n            text: await resolveI18n( template.text, commandsViewModel ),\n            visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,\n            class: template.class ? template.class : null\n        };\n    }\n\n    return {\n        text: {\n            value: '{0}',\n            parameters: [ template.text ]\n        },\n        visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,\n        class: template.class ? template.class : null\n    };\n};\n\n/**\n * Load the necessary data to create a CommandOverlay and return it\n *\n * @param {String} id ID of the command\n * @param {Object} commandsViewModel Commands view model json\n * @param {Object} placement (Optional) Placement information\n */\nconst getCommandInternal = async( id, commandsViewModel, placement = null, useCache = true ) => {\n    const definition = commandsViewModel.commands[ id ];\n    if( !definition ) {\n        logger.error( `Missing command definition for ${id}` );\n    }\n    const type = getCommandType( definition );\n\n    const handlers = type === 'GROUP' || type === 'SHUTTLE' ? [ new CommandHandler( 'GroupCommandHandler', {\n        activeWhen: {\n            condition: 'conditions.true'\n        },\n        action: 'openCommandGroup'\n    }, commandsViewModel, definition ) ] : getHandlersForCommand( id, commandsViewModel, useCache )\n        .map( ( [ handlerId, value ] ) => new CommandHandler( handlerId, value, commandsViewModel, definition ) )\n        .sort( ( a, b ) => b.priority - a.priority );\n\n    const icon = definition.iconId;\n    const selectedIcon = definition.selected ? definition.selected.iconId : null;\n\n    //TODO: Some stuff (i18n) may need to be resolved here\n    const extendedTooltip = definition.extendedTooltip;\n    const selectedExtendedTooltip = definition.selected && definition.selected.extendedTooltip ? definition.selected.extendedTooltip : null;\n\n    const [ title, selectedTitle, description, selectedDescription, decorator ] = await Promise.all( [\n        resolveI18n( definition.title, commandsViewModel ),\n        definition.selected && definition.selected.title ? resolveI18n( definition.selected.title, commandsViewModel ) : null,\n        definition.description ? await resolveI18n( definition.description, commandsViewModel ) : null,\n        definition.selected && definition.selected.description ? resolveI18n( definition.selected.description, commandsViewModel ) : null,\n        definition.template && definition.template.text ? getDecoratorObject( definition.template, commandsViewModel ) : null\n    ] );\n\n    const children = type === 'GROUP' || type === 'SHUTTLE' ? await getCommands( id ) : [];\n\n    return new CommandOverlay( {\n        showGroupSelected: !placement || placement.showGroupSelected !== false,\n        id,\n        handlers,\n        title,\n        selectedTitle,\n        icon,\n        selectedIcon,\n        decorator,\n        extendedTooltip,\n        selectedExtendedTooltip,\n        description,\n        selectedDescription,\n        type,\n        children,\n        cellDisplay: placement ? placement.cellDisplay : null\n    } );\n};\n\n/**\n * Sort the placements based on relativeTo and priority. Priority is 0 if not set.\n *\n * @param {[CommandPlacement]} placements - placements\n * @return {[CommandPlacement]} Sorted list of command placements\n */\nconst sortPlacements = function( placements ) {\n    // Assign a priority to any placement that doesn't have one\n    placements.forEach( function( cmd ) {\n        cmd.priority = cmd.priority || 0;\n    } );\n\n    // Split based on whether placement is relative or absolute\n    const p = _.partition( placements, function( cmd ) {\n        return cmd.relativeTo;\n    } );\n    // Sort the commands with only priority\n    const priorityCommands = _.sortBy( p[ 1 ], 'priority' );\n\n    // Group the relative commands by the relativeTo property\n    const allRelativeCmds = _.groupBy( p[ 0 ], 'relativeTo' );\n\n    const commandsWithRelativeAdded = priorityCommands.reduce( ( acc, placement ) => {\n        // Split into before / after based on negative / positive priority\n        const p2 = _.partition( allRelativeCmds[ placement.id ] || [], function( cmd ) {\n            return cmd.priority > 0;\n        } );\n        const afterPlacements = _.sortBy( p2[ 0 ], 'priority' );\n        const beforePlacements = _.sortBy( p2[ 1 ], 'priority' );\n        //side effect, could be refactored later\n        delete allRelativeCmds[ placement.id ];\n        return [ ...acc, ...beforePlacements, placement, ...afterPlacements ];\n    }, [] );\n\n    //Add any placement with relativeTo that is not in this command bar to the end\n    return Object.values( allRelativeCmds ).reduce( ( acc, missingRelativeSet ) => {\n        logger.debug( `Unable to find relative command ${missingRelativeSet[0].id}. Commands will be placed at end of list.`, missingRelativeSet );\n        return [ ...acc, ...missingRelativeSet ];\n    }, commandsWithRelativeAdded );\n};\n\n/**\n * Get the commands for the given anchor\n *\n * @param {String} anchor anchor\n * @returns {[CommandOverlay]} Command overlays for the anchor\n */\nexport const getCommands = async( anchor, useCache ) => {\n    const commandsViewModel = await ccu.getCommandsViewModel();\n    const anchors = anchor.split( ',' );\n    const allPlacements = [ ...dynamicPlacements, ...Object.values( commandsViewModel.commandPlacements ) ];\n    const placements = uniqBy( anchors.reduce( ( fullPlacementList, nextAnchor ) => {\n        const newPlacements = allPlacements\n            .filter( placement => !placement.parentGroupId && placement.uiAnchor === nextAnchor && commandsViewModel.commands[ placement.id ] );\n        return [ ...fullPlacementList, ...newPlacements ];\n    }, [] ), 'id' );\n\n    let placementsSorted = sortPlacements( placements );\n\n\n    const commands = await Promise.all( placementsSorted.map( placement => getCommandInternal( placement.id, commandsViewModel, placement, useCache ) ) );\n    if( anchor ) {\n        debugService.debugGetCommandsForAnchor( anchor, commands );\n        debugService.reduceData( anchor, commands );\n    }\n    return commands;\n};\n\n/**\n * Add a placement for a command at runtime. All placements\n * must be defined before the AwCommandBar with the matching\n * anchor is rendered\n *\n * @param {[CommandPlacement]} placements Placements to add\n * @returns {Object} Tracking information to all for removal of the placements\n */\nexport const addPlacements = ( placements ) => {\n    trace( 'Dynamic placements added', placements );\n    dynamicPlacements = [ ...dynamicPlacements, ...placements ];\n    return {\n        placements,\n        remove: () => {\n            dynamicPlacements = dynamicPlacements.filter( x => !placements.includes( x ) );\n            trace( 'Dynamic placements removed', placements );\n        }\n    };\n};\n\n/**\n * Get the commandContext of a given command bar/group\n *\n * @param {String} grpCmdAnchor - the group id/anchor for a given command group\n * @param {String} commandBarAnchor - the anchor for a given command bar\n * @returns {Object} commandContext for given command group or command bar\n */\nexport const getCommandContext = function( grpCmdAnchor, commandBarAnchor ) {\n    let commandBarXPath = `//div[contains(@class, 'aw-command-bar') and @anchor='${grpCmdAnchor ? grpCmdAnchor : commandBarAnchor}']`;\n    let commandBar = htmlUtils.getElementByXpath( commandBarXPath, document.body );\n    if( commandBar ) {\n        const key = Object.keys( commandBar ).find( key => {\n            return key.startsWith( '__reactFiber$' );\n        } );\n        const commandBarFiber = commandBar[ key ];\n        if( commandBarFiber.return.memoizedProps.commandContext ) {\n            return commandBarFiber.return.memoizedProps.commandContext;\n        }\n        // get parent toolbar which has command context\n        let toolbarFiber = commandBarFiber.return;\n        while( typeof toolbarFiber.type === 'string' ) {\n            toolbarFiber = toolbarFiber.return;\n        }\n        return toolbarFiber.return.memoizedProps.commandContext;\n    }\n    return null;\n};\n\n\n/**\n * Given the array of handlers for a command get the activeHandler\n *\n * @param {Array<Handler>} handlers - array of command handlers\n * @param {Object} scope - evaluation scope\n * @returns {Handler} the active handler\n */\nexport const getActiveCommandHandler = function( handlers, scope ) {\n    for( const handler of handlers ) {\n        const isActive = Boolean( conditionService.evaluateCondition( {}, handler.activeWhen.expression, scope ) );\n        if( isActive ) {\n            return handler;\n        }\n    }\n    return null;\n};\n\n/**\n * Check whether a command is enabled and visible\n *\n * @param {Object} activeHandler - active command handler\n * @param {Object} scope - evaluation scope\n * @returns {Boolean} visbleWhen and enableWhen\n */\nexport const getCommandAndCheckVisibility = function( activeHandler, scope ) {\n    const visibleWhen =  activeHandler.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.visibleWhen.expression, scope ) ) : true;\n    const enableWhen = activeHandler.enableWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.enableWhen.expression, scope ) ) : true;\n    return visibleWhen && enableWhen;\n};\n\nexport default {\n    getCommand,\n    getCommands,\n    getCommandContext,\n    getActiveCommandHandler,\n    getCommandAndCheckVisibility\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}