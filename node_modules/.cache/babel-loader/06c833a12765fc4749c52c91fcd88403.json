{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This service provides data patch operation to sepecific data object.\n *\n * @module js/store\n */\nimport _ from 'lodash';\nimport { parseDataPath } from 'js/declReactUtils';\n/**\n * Get data patch based on dispatch action\n * action could be:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {object} data scope for evaluation\n * @param {object} action dispatch action input\n * @returns {Array} patch array\n */\n\nexport function getPatch(data, action) {\n  let res = {};\n\n  if (action.path === undefined) {\n    const scope = action.scope;\n\n    for (var path in action.value) {\n      const value = action.value[path];\n      path = scope ? `${scope}.${path}` : path;\n\n      if (_.get(data, path) !== value) {\n        res[path] = value;\n      }\n    }\n  } else {\n    const path = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n    const value = action.value;\n\n    if (path) {\n      if (_.get(data, path) !== value) {\n        res[path] = value;\n      }\n    } else if (path === '') {\n      res = data !== value && _.isObject(value) ? value : {};\n    } else {\n      // logically if path is always string this is not needed\n      throw Error('getPatch: Invalid path!');\n    }\n  }\n\n  return res;\n}\n/**\n * Update data by specific path\n * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }\n * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }\n * @returns {object} updated data as mutation result\n */\n\nexport const patchData = (patch, data) => _.reduce(patch, (data, value, path) => value === undefined ? _.unset(data, path) && data || data : _.set(data, path, value), data);\n/**\n * Update data. Only works for immutable framework\n * action could be:\n * {\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {function} updateFn view update function\n * @returns {function} updateFn accepts data and action\n */\n\nexport const createReducer = updateFn => (data, action) => {\n  const patch = getPatch(data, action);\n\n  if (!_.isEmpty(patch)) {\n    return updateFn(patch, data);\n  }\n\n  return data;\n};\n/**\n * reducer for react Reducer hook, return 'immutable' object when value change\n * @param {object} data data object\n * @param {object} action action as { path, value }\n * @returns {function} reducer function used for react hook\n */\n\nexport const reducer = createReducer((patch, data) => ({ ...patchData(patch, data)\n}));\n/**\n * compose key-dispatch function map to one dispatch function\n * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }\n * @returns {object} function pair dispatch and getDispatch\n */\n\nexport const composeDispatch = dispatchFnMap => {\n  const dispatch = action => {\n    const actions = [];\n\n    if (action.scope) {\n      // this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }\n      actions.push(action);\n    } else if (action.path === undefined) {\n      // re-assemble value to data and ctx\n      // TODO: we can be more smart to identify the scope cluster more accurately\n      // for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can\n      // save more performance\n      const values = action.value;\n\n      const patchMap = _.reduce(values, (res, value, dataPath) => {\n        const {\n          scope,\n          path\n        } = parseDataPath(dataPath);\n        res[scope] = res[scope] || {};\n        res[scope][path] = value;\n        return res;\n      }, {});\n\n      _.forEach(patchMap, (value, scope) => actions.push({\n        scope,\n        value\n      }));\n    } else {\n      // re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to\n      const value = action.value;\n      const dataPath = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n      let {\n        scope,\n        path\n      } = parseDataPath(dataPath); // path should be exist in this else branch, need to maintain that intention\n\n      path = path || '';\n      actions.push({\n        scope,\n        path,\n        value\n      });\n    }\n\n    actions.forEach(action => getDispatch(action.scope)({ ...action,\n      scope: undefined\n    }));\n  };\n\n  const getDispatch = (dataPath, updateFn) => {\n    const {\n      scope,\n      path\n    } = parseDataPath(dataPath); // TODO: error out for last branch\n\n    updateFn = updateFn || dispatchFnMap[scope] || (() => null);\n\n    return path ? action => {\n      action.scope = action.scope ? `${path}.${action.scope}` : path;\n      return updateFn(action);\n    } : updateFn;\n  };\n\n  return {\n    dispatch,\n    getDispatch\n  };\n};","map":{"version":3,"names":["_","parseDataPath","getPatch","data","action","res","path","undefined","scope","value","get","isObject","Error","patchData","patch","reduce","unset","set","createReducer","updateFn","isEmpty","reducer","composeDispatch","dispatchFnMap","dispatch","actions","push","values","patchMap","dataPath","forEach","getDispatch"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/store.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n/**\n * This service provides data patch operation to sepecific data object.\n *\n * @module js/store\n */\nimport _ from 'lodash';\nimport {\n    parseDataPath\n} from 'js/declReactUtils';\n\n/**\n * Get data patch based on dispatch action\n * action could be:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {object} data scope for evaluation\n * @param {object} action dispatch action input\n * @returns {Array} patch array\n */\nexport function getPatch( data, action ) {\n    let res = {};\n    if( action.path === undefined ) {\n        const scope = action.scope;\n        for( var path in action.value ) {\n            const value = action.value[ path ];\n            path = scope ? `${scope}.${path}` : path;\n            if( _.get( data, path ) !== value ) {\n                res[ path ] = value;\n            }\n        }\n    } else {\n        const path = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n        const value = action.value;\n        if( path ) {\n            if( _.get( data, path ) !== value ) {\n                res[ path ] = value;\n            }\n        } else if( path === '' ) {\n            res = data !== value && _.isObject( value ) ? value : {};\n        } else {\n            // logically if path is always string this is not needed\n            throw Error( 'getPatch: Invalid path!' );\n        }\n    }\n    return res;\n}\n\n/**\n * Update data by specific path\n * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }\n * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }\n * @returns {object} updated data as mutation result\n */\nexport const patchData = ( patch, data ) => _.reduce( patch,\n    ( data, value, path ) => value === undefined ? _.unset( data, path ) && data || data : _.set( data, path, value ),\n    data\n);\n\n/**\n * Update data. Only works for immutable framework\n * action could be:\n * {\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {function} updateFn view update function\n * @returns {function} updateFn accepts data and action\n */\nexport const createReducer = ( updateFn ) => ( data, action ) => {\n    const patch = getPatch( data, action );\n    if( !_.isEmpty( patch ) ) {\n        return updateFn( patch, data );\n    }\n    return data;\n};\n\n/**\n * reducer for react Reducer hook, return 'immutable' object when value change\n * @param {object} data data object\n * @param {object} action action as { path, value }\n * @returns {function} reducer function used for react hook\n */\nexport const reducer = createReducer( ( patch, data ) => ( { ...patchData( patch, data ) } ) );\n\n/**\n * compose key-dispatch function map to one dispatch function\n * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }\n * @returns {object} function pair dispatch and getDispatch\n */\nexport const composeDispatch = ( dispatchFnMap ) => {\n    const dispatch = action => {\n        const actions = [];\n        if( action.scope ) {\n            // this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }\n            actions.push( action );\n        } else if( action.path === undefined ) {\n            // re-assemble value to data and ctx\n            // TODO: we can be more smart to identify the scope cluster more accurately\n            // for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can\n            // save more performance\n            const values = action.value;\n            const patchMap = _.reduce( values, ( res, value, dataPath ) => {\n                const { scope, path } = parseDataPath( dataPath );\n                res[ scope ] = res[ scope ] || {};\n                res[ scope ][ path ] = value;\n                return res;\n            }, {} );\n            _.forEach( patchMap, ( value, scope ) => actions.push( { scope, value } ) );\n        } else {\n            // re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to\n            const value = action.value;\n            const dataPath = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n            let { scope, path } = parseDataPath( dataPath );\n            // path should be exist in this else branch, need to maintain that intention\n            path = path || '';\n            actions.push( { scope, path, value } );\n        }\n        actions.forEach( action => getDispatch( action.scope )( { ...action, scope: undefined } ) );\n    };\n\n    const getDispatch = ( dataPath, updateFn ) => {\n        const { scope, path } = parseDataPath( dataPath );\n        // TODO: error out for last branch\n        updateFn = updateFn || dispatchFnMap[ scope ] || ( () => null );\n\n        return path ? ( action ) => {\n            action.scope = action.scope ? `${path}.${action.scope}` : path;\n            return updateFn( action );\n        } : updateFn;\n    };\n\n    return { dispatch, getDispatch };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}