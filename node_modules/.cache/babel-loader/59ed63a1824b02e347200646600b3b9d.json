{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch visual indicators\n *\n * @module js/visualIndicatorService\n */\nimport commandsMapSvc from 'js/commandsMapService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nimport { getImageAliasFromId } from 'js/imageRegistry'; //  FIXME this should be loaded async but before the sync API below that uses it is called\n\nvar _indicators;\n\nloadconfiguration(); // eslint-disable-next-line require-jsdoc\n\nasync function loadconfiguration() {\n  await cfgSvc.getCfg('indicators').then(indicators => {\n    _indicators = indicators;\n  });\n} // for Unit tests\n\n\n_indicators = _indicators ? _indicators : {};\nvar exports = {};\n\nlet _isValidPropName = function (indicaotrProp, objPropName) {\n  var isValid = false;\n\n  if (indicaotrProp && indicaotrProp.names && _.isArray(indicaotrProp.names)) {\n    isValid = indicaotrProp.names.some(iPropName => iPropName === objPropName);\n  }\n\n  return isValid;\n};\n\nlet _isValidModelType = function (vmoModelType, modelTypes) {\n  let isValid = false;\n\n  if (vmoModelType && modelTypes && _.isArray(modelTypes)) {\n    isValid = modelTypes.some(modelType => commandsMapSvc.isInstanceOf(modelType, vmoModelType));\n  }\n\n  return isValid;\n};\n\nlet _getIndicatorsFromPreVerdict = function (preVerdictArray, getModelObjCallBack) {\n  let indicatorsArray = [];\n\n  _.forEach(preVerdictArray, preVerdictor => {\n    let refObjs = [];\n    let vmoPropVal = preVerdictor.vmoProp; //get the array of referece object for these indicator\n\n    if (vmoPropVal.dbValue && !_.isArray(vmoPropVal.dbValue)) {\n      let refObjUid = vmoPropVal.dbValue;\n      const refObj = getModelObjCallBack(refObjUid);\n\n      if (refObj) {\n        refObj.uid = refObjUid;\n        refObjs.push(refObj);\n      }\n    } else if (vmoPropVal.dbValues) {\n      vmoPropVal.dbValues.forEach(dbValue => {\n        const refObj = getModelObjCallBack(dbValue);\n\n        if (refObj) {\n          refObj.uid = dbValue;\n          refObjs.push(refObj);\n        }\n      });\n    }\n\n    _.forEach(refObjs, refObj => {\n      let indicatorArray = preVerdictor.indicators;\n      let verdictObjInfo = {};\n      let hasDefaultIndicator = false;\n      let defaultIndicator;\n\n      _.forEach(indicatorArray, indicator => {\n        let verdictObj = evaluatePropBasedCondition(indicator.prop, refObj, indicator.tooltip);\n        hasDefaultIndicator = verdictObj.isDefaultIndicator;\n\n        if (hasDefaultIndicator) {\n          defaultIndicator = indicator;\n        }\n\n        if (verdictObj && verdictObj.hasIndicatorMatchedVal) {\n          //Tooltip is missing some properties from target object\n          if (verdictObj.missingProps.length > 0) {\n            var foundProps = []; //Load the properties from the original object (preVerdicator.vmoProp.parentUid)\n\n            const srcObj = getModelObjCallBack(preVerdictor.vmoProp.parentUid);\n\n            if (srcObj) {\n              //Iterate through the list backward, remove all properties found on this object\n              //(Note there may be some properties not found in the src or target obj)\n              //(If our goal is to end checking here, we can iterate forward and clear the list)\n              for (var propIndx = verdictObj.missingProps.length - 1; propIndx >= 0; propIndx--) {\n                if (srcObj.props[verdictObj.missingProps[propIndx]]) {\n                  //Assemble an object for use later when creating tooltip\n                  var propObj = {\n                    matchingVal: srcObj.props[verdictObj.missingProps[propIndx]].dbValues[0] + '\\n',\n                    tooltip: srcObj.props[verdictObj.missingProps[propIndx]].uiValues[0] + '\\n',\n                    propertyDisplayName: srcObj.props[verdictObj.missingProps[propIndx]].propertyDescriptor.displayName\n                  };\n                  foundProps.unshift(propObj); //Remove this property from the list of missing properties.\n\n                  verdictObj.missingProps.splice(propIndx, 1);\n                }\n              } //Iterate through the list to add to the tooltip the found properties.\n\n\n              for (var idx = 0; idx < foundProps.length; idx++) {\n                verdictObj.matchingVal += foundProps[idx].matchingVal; //If an indicator requires property name to be displayed, we add it first.\n\n                if (indicator.tooltip.showPropDisplayName) {\n                  verdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                }\n\n                verdictObj.tooltip += foundProps[idx].tooltip;\n              }\n            }\n          }\n\n          verdictObj.indicator = indicator;\n          verdictObjInfo = verdictObj;\n        }\n      }); //if hasDefaultIndicator = true it has default indicator\n\n\n      if (hasDefaultIndicator && defaultIndicator && _.isEmpty(verdictObjInfo)) {\n        let targetPropNames = _.get(defaultIndicator, 'tooltip.propNames');\n\n        if (!targetPropNames) {\n          targetPropNames = ['object_string'];\n        }\n\n        let propUiValue = '';\n\n        for (var targetProp in targetPropNames) {\n          var tgtProp = targetPropNames[targetProp];\n          var prop = refObj.props[tgtProp];\n\n          if (prop && prop.dbValue) {\n            propUiValue += prop.uiValue + '\\n';\n          } else if (prop && prop.dbValues && prop.dbValues.length > 0) {\n            propUiValue += prop.uiValues[0] + '\\n';\n          }\n        }\n\n        let indicator = exports.getIndicatorFromParams(defaultIndicator, propUiValue);\n        indicatorsArray.push(indicator);\n      } else if (!_.isEmpty(verdictObjInfo)) {\n        let indicator = exports.getIndicatorFromParams(verdictObjInfo.indicator, verdictObjInfo.tooltip);\n        indicatorsArray.push(indicator);\n      }\n    });\n  });\n\n  return indicatorsArray;\n};\n/**\n * Evaluates prop based condition structure\n *\n * @return {Object} verdictObject containing indicator matching information\n * verdictObj\n    {\n        hasIndicatorMatchedVal   :    If input indicator has matched exact value\n        matchingVal              :    What exact value indicator matched to e.g. \"Approved\"\n        tooltip                  :   \"localized(Approved)\" # based on Display Name\n    }\n */\n\n\nexport let evaluatePropBasedCondition = function (indicatorProp, obj, tooltip) {\n  let verdictObj = {\n    isDefaultIndicator: false,\n    missingProps: []\n  };\n\n  if (indicatorProp.conditions && Object.keys(indicatorProp.conditions).length > 0) {\n    verdictObj.hasIndicatorMatchedVal = expressionParserUtils.evaluateConditions(indicatorProp.conditions, obj);\n\n    if (verdictObj.hasIndicatorMatchedVal) {\n      verdictObj.uid = obj.uid;\n      verdictObj.tooltip = '';\n      verdictObj.matchingVal = '';\n      var tooltipPropNames = tooltip.propNames;\n\n      for (var tooltipProp in tooltipPropNames) {\n        var tooltipPropName = tooltipPropNames[tooltipProp]; // 20200922 - try to validate prop exist by propertyDescriptorsMap, not object itself\n\n        if (obj.modelType && obj.modelType.propertyDescriptorsMap && !obj.modelType.propertyDescriptorsMap.hasOwnProperty(tooltipPropName)) {\n          verdictObj.missingProps.push(tooltipPropName);\n          continue;\n        }\n\n        verdictObj.matchingVal += obj.props[tooltipPropName].dbValues[0] + '\\n';\n\n        if (tooltip.showPropDisplayName) {\n          verdictObj.tooltip += obj.props[tooltipPropName].propertyDescriptor.displayName + ': ';\n        }\n\n        verdictObj.tooltip += obj.props[tooltipPropName].uiValues[0] + '\\n';\n      }\n    }\n  } else if (indicatorProp.conditions && Object.keys(indicatorProp.conditions).length === 0) {\n    //if this has empty condition object, is a default indicator\n    if (indicatorProp.names && _.isArray(indicatorProp.names) && indicatorProp.names.length > 0) {\n      verdictObj.isDefaultIndicator = true;\n      return verdictObj;\n    }\n  } else if (indicatorProp.type) {\n    var evaluatedVerdictObj = evaluatePropBasedCondition(indicatorProp.type.prop, obj, tooltip); //There are missing properties from the tooltip\n\n    if (evaluatedVerdictObj.missingProps.length > 0) {\n      var foundProps = []; //Iterate through the list backward, remove all properties found on this object\n      //(Note there may be some properties not found in the src or target obj)\n      //(If our goal is to end checking here, we can iterate forward and clear the list)\n\n      for (var propIndx = evaluatedVerdictObj.missingProps.length - 1; propIndx >= 0; propIndx--) {\n        if (obj.props[evaluatedVerdictObj.missingProps[propIndx]]) {\n          var propObj = {\n            matchingVal: obj.props[evaluatedVerdictObj.missingProps[propIndx]].dbValues[0] + '\\n',\n            tooltip: obj.props[evaluatedVerdictObj.missingProps[propIndx]].uiValues[0] + '\\n',\n            propertyDisplayName: obj.props[evaluatedVerdictObj.missingProps[propIndx]].propertyDescriptor.displayName\n          };\n          foundProps.unshift(propObj); //Current object found this property, so we can remove it from the list.\n\n          evaluatedVerdictObj.missingProps.splice(propIndx, 1);\n        }\n      } //Iterate through the list to add to the tooltip the found properties.\n\n\n      for (var idx = 0; idx < foundProps.length; idx++) {\n        evaluatedVerdictObj.matchingVal += foundProps[idx].matchingVal;\n\n        if (tooltip.showPropDisplayName) {\n          evaluatedVerdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n        }\n\n        evaluatedVerdictObj.tooltip += foundProps[idx].tooltip;\n      }\n    }\n\n    return evaluatedVerdictObj;\n  }\n\n  return verdictObj;\n};\n/**\n * Returns the list of visual indicators.\n *\n * @param {vmo} vmo - viewModelObject.\n * @param {getModelObjCallBack} getModelObjCallBack - call back.\n * @return {Array} List of visual indicator objects\n */\n\nexport let getVisualIndicators = function (vmo, getModelObjCallBack) {\n  var indicatorsArray = [];\n\n  if (vmo && vmo.props) {\n    let preVerdictArray = []; //Go through all the props from VMO, get indicators for each matched prop\n\n    for (const [propKey, propValue] of Object.entries(vmo.props)) {\n      let preVerdict = {};\n\n      if (!_.isEmpty(propValue.dbValue) || !_.isEmpty(propValue.dbValues)) {\n        preVerdict.name = propKey;\n        preVerdict.vmoProp = propValue;\n        let matchedIndicators = Object.values(_indicators).filter(indicatorJson => indicatorJson && _isValidPropName(indicatorJson.prop, propKey)); //each prop may have multiple indicator\n\n        if (!_.isEmpty(matchedIndicators)) {\n          preVerdict.indicators = matchedIndicators;\n          preVerdictArray.push(preVerdict);\n        }\n      }\n    }\n\n    indicatorsArray = _getIndicatorsFromPreVerdict(preVerdictArray, getModelObjCallBack); //get the indicators which not defined in indicator.prop, eg. CheckOut\n\n    Object.values(_indicators).forEach(indicatorJson => {\n      if (indicatorJson && !indicatorJson.prop) {\n        var modelTypes = indicatorJson.modelTypes;\n        var conditions = indicatorJson.conditions;\n\n        if (_isValidModelType(vmo.modelType, modelTypes)) {\n          let isValid = true;\n\n          if (conditions) {\n            isValid = expressionParserUtils.evaluateConditions(conditions, vmo);\n          }\n\n          if (isValid) {\n            const indicator = exports.generateIndicator(vmo, indicatorJson);\n\n            if (indicator && !_.isEqual(indicator.tooltip, '')) {\n              indicatorsArray.push(indicator);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  return indicatorsArray;\n};\n/**\n * Gets the default indicator for a property\n *\n * @return {Object} Indicator object which is default for a given prop\n */\n\nexport let getDefaultIndicator = function (propName, obj) {\n  var defaultIndicator = null;\n\n  _.forEach(_indicators, function (indicatorJson) {\n    if (indicatorJson) {\n      var prop = indicatorJson.prop;\n\n      if (prop && prop.names && _.isArray(prop.names) && prop.names.length > 0) {\n        // If prop is defined correctly, see if it is valid to default for input propName\n        if (prop.names.indexOf(propName) >= 0 && prop.conditions && _.isEmpty(prop.conditions)) {\n          defaultIndicator = indicatorJson;\n          return false;\n        }\n      }\n    }\n  });\n\n  return defaultIndicator;\n};\n/**\n * Generates indicator object if tooltips are available for given view model object\n *\n * @return {Object} Indicator object which contains tooltip and icon\n */\n\nexport let generateIndicator = function (vmo, indicatorJson) {\n  var indicator;\n\n  if (vmo && indicatorJson && indicatorJson.tooltip) {\n    var indicatorProps = indicatorJson.tooltip.propNames;\n\n    if (_.isArray(indicatorProps)) {\n      var finalTooltip = '';\n\n      for (var indx = 0; indx < indicatorProps.length; indx++) {\n        var tooltip = '';\n        var propValues = [];\n        var indicatorProp = indicatorProps[indx];\n\n        if (indicatorProp && vmo.props.hasOwnProperty(indicatorProp)) {\n          var vmProp = vmo.props[indicatorProp];\n\n          if (vmProp) {\n            propValues = vmProp.displayValues;\n          }\n\n          if (propValues && propValues.length > 0) {\n            for (var i = 0; i < propValues.length; i++) {\n              var propValue = propValues[i];\n\n              if (propValue && propValue !== ' ') {\n                if (tooltip === '' && indicatorJson.tooltip.showPropDisplayName) {\n                  tooltip = vmProp.propertyDisplayName + ': ';\n                }\n\n                if (i !== propValues.length - 1) {\n                  tooltip += propValue + '\\n';\n                } else {\n                  tooltip += propValue;\n                }\n              }\n            }\n\n            if (finalTooltip === '') {\n              finalTooltip = tooltip;\n            } else {\n              finalTooltip = finalTooltip + '\\n' + tooltip;\n            }\n          }\n        }\n      }\n\n      const icon = getImageAliasFromId(`indicator${indicatorJson.iconName}`) ? `indicator${indicatorJson.iconName}` : 'indicatorMissingImage';\n      indicator = {\n        tooltip: finalTooltip,\n        // Sanitize the command icon\n        image: icon\n      };\n    }\n  }\n\n  return indicator;\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {Object} indicator\n */\n\nexport let getIndicatorFromParams = function (indicatorJson, tooltip) {\n  var indicatorFile = null;\n\n  if (indicatorJson !== null) {\n    indicatorFile = indicatorJson.iconName;\n  }\n\n  const icon = getImageAliasFromId(`indicator${indicatorFile}`) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n  return {\n    tooltip: tooltip,\n    // Sanitize the command icon\n    image: icon\n  };\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {indicatorJson} indicatorJson - json\n * @returns {Array} returns a list of visual indicators\n */\n\nexport let getIndicatorFromJSON = function (indicatorJson) {\n  var indicatorsArray = [];\n  var indicatorFile = null;\n  var tooltip = null;\n\n  _.forEach(indicatorJson, function (indicator) {\n    if (indicator) {\n      indicatorFile = indicator.image;\n      tooltip = indicator.tooltip;\n    }\n\n    const icon = getImageAliasFromId(`indicator${indicatorFile}`) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n    var indicatorObj = {\n      image: icon,\n      tooltip: tooltip\n    };\n    indicatorsArray.push(indicatorObj);\n  });\n\n  return indicatorsArray;\n};\n/**\n * API to override generated indicators for testing only.\n *\n * @param {Object} indicatorsOverride\n */\n\nexport let setIndicators = function (indicatorsOverride) {\n  _indicators = indicatorsOverride;\n};\nexports = {\n  getVisualIndicators,\n  getDefaultIndicator,\n  generateIndicator,\n  evaluatePropBasedCondition,\n  getIndicatorFromParams,\n  getIndicatorFromJSON,\n  setIndicators\n};\nexport default exports;","map":{"version":3,"names":["commandsMapSvc","_","expressionParserUtils","cfgSvc","getImageAliasFromId","_indicators","loadconfiguration","getCfg","then","indicators","exports","_isValidPropName","indicaotrProp","objPropName","isValid","names","isArray","some","iPropName","_isValidModelType","vmoModelType","modelTypes","modelType","isInstanceOf","_getIndicatorsFromPreVerdict","preVerdictArray","getModelObjCallBack","indicatorsArray","forEach","preVerdictor","refObjs","vmoPropVal","vmoProp","dbValue","refObjUid","refObj","uid","push","dbValues","indicatorArray","verdictObjInfo","hasDefaultIndicator","defaultIndicator","indicator","verdictObj","evaluatePropBasedCondition","prop","tooltip","isDefaultIndicator","hasIndicatorMatchedVal","missingProps","length","foundProps","srcObj","parentUid","propIndx","props","propObj","matchingVal","uiValues","propertyDisplayName","propertyDescriptor","displayName","unshift","splice","idx","showPropDisplayName","isEmpty","targetPropNames","get","propUiValue","targetProp","tgtProp","uiValue","getIndicatorFromParams","indicatorProp","obj","conditions","Object","keys","evaluateConditions","tooltipPropNames","propNames","tooltipProp","tooltipPropName","propertyDescriptorsMap","hasOwnProperty","type","evaluatedVerdictObj","getVisualIndicators","vmo","propKey","propValue","entries","preVerdict","name","matchedIndicators","values","filter","indicatorJson","generateIndicator","isEqual","getDefaultIndicator","propName","indexOf","indicatorProps","finalTooltip","indx","propValues","vmProp","displayValues","i","icon","iconName","image","indicatorFile","getIndicatorFromJSON","indicatorObj","setIndicators","indicatorsOverride"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/visualIndicatorService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch visual indicators\n *\n * @module js/visualIndicatorService\n */\nimport commandsMapSvc from 'js/commandsMapService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nimport { getImageAliasFromId } from 'js/imageRegistry';\n\n//  FIXME this should be loaded async but before the sync API below that uses it is called\nvar _indicators;\nloadconfiguration();\n\n// eslint-disable-next-line require-jsdoc\nasync function loadconfiguration() {\n    await cfgSvc.getCfg( 'indicators' ).then( indicators => {\n        _indicators = indicators;\n    } );\n}\n// for Unit tests\n_indicators = _indicators ? _indicators : {};\nvar exports = {};\n\n\nlet _isValidPropName = function( indicaotrProp, objPropName ) {\n    var isValid = false;\n    if( indicaotrProp && indicaotrProp.names && _.isArray( indicaotrProp.names ) ) {\n        isValid = indicaotrProp.names.some( iPropName => iPropName === objPropName );\n    }\n    return isValid;\n};\n\nlet _isValidModelType = function( vmoModelType, modelTypes ) {\n    let isValid = false;\n    if( vmoModelType && modelTypes && _.isArray( modelTypes ) ) {\n        isValid = modelTypes.some( modelType => commandsMapSvc.isInstanceOf( modelType, vmoModelType ) );\n    }\n    return isValid;\n};\n\nlet _getIndicatorsFromPreVerdict = function( preVerdictArray, getModelObjCallBack ) {\n    let indicatorsArray = [];\n    _.forEach( preVerdictArray, preVerdictor => {\n        let refObjs = [];\n        let vmoPropVal = preVerdictor.vmoProp;\n        //get the array of referece object for these indicator\n        if( vmoPropVal.dbValue && !_.isArray( vmoPropVal.dbValue ) ) {\n            let refObjUid = vmoPropVal.dbValue;\n            const refObj = getModelObjCallBack( refObjUid );\n            if( refObj ) {\n                refObj.uid = refObjUid;\n                refObjs.push( refObj );\n            }\n        } else if( vmoPropVal.dbValues ) {\n            vmoPropVal.dbValues.forEach( dbValue => {\n                const refObj = getModelObjCallBack( dbValue );\n                if( refObj ) {\n                    refObj.uid = dbValue;\n                    refObjs.push( refObj );\n                }\n            } );\n        }\n\n        _.forEach( refObjs, refObj => {\n            let indicatorArray = preVerdictor.indicators;\n            let verdictObjInfo = {};\n            let hasDefaultIndicator = false;\n            let defaultIndicator;\n            _.forEach( indicatorArray, indicator => {\n                let verdictObj = evaluatePropBasedCondition( indicator.prop, refObj, indicator.tooltip );\n                hasDefaultIndicator = verdictObj.isDefaultIndicator;\n                if( hasDefaultIndicator ) {\n                    defaultIndicator = indicator;\n                }\n                if( verdictObj && verdictObj.hasIndicatorMatchedVal ) {\n                    //Tooltip is missing some properties from target object\n                    if( verdictObj.missingProps.length > 0 ) {\n                        var foundProps = [];\n\n                        //Load the properties from the original object (preVerdicator.vmoProp.parentUid)\n                        const srcObj = getModelObjCallBack( preVerdictor.vmoProp.parentUid );\n                        if( srcObj ) {\n                            //Iterate through the list backward, remove all properties found on this object\n                            //(Note there may be some properties not found in the src or target obj)\n                            //(If our goal is to end checking here, we can iterate forward and clear the list)\n                            for( var propIndx = verdictObj.missingProps.length - 1; propIndx >= 0; propIndx-- ) {\n                                if( srcObj.props[verdictObj.missingProps[propIndx]] ) {\n                                    //Assemble an object for use later when creating tooltip\n                                    var propObj = { matchingVal: srcObj.props[verdictObj.missingProps[propIndx]].dbValues[ 0 ] + '\\n',\n                                        tooltip: srcObj.props[verdictObj.missingProps[propIndx]].uiValues[ 0 ] + '\\n',\n                                        propertyDisplayName: srcObj.props[verdictObj.missingProps[propIndx]].propertyDescriptor.displayName };\n                                    foundProps.unshift( propObj );\n\n                                    //Remove this property from the list of missing properties.\n                                    verdictObj.missingProps.splice( propIndx, 1 );\n                                }\n                            }\n                            //Iterate through the list to add to the tooltip the found properties.\n                            for( var idx = 0; idx < foundProps.length; idx++ ) {\n                                verdictObj.matchingVal += foundProps[idx].matchingVal;\n\n                                //If an indicator requires property name to be displayed, we add it first.\n                                if( indicator.tooltip.showPropDisplayName ) {\n                                    verdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                                }\n\n                                verdictObj.tooltip += foundProps[idx].tooltip;\n                            }\n                        }\n                    }\n\n                    verdictObj.indicator = indicator;\n                    verdictObjInfo = verdictObj;\n                }\n            } );\n\n            //if hasDefaultIndicator = true it has default indicator\n            if( hasDefaultIndicator && defaultIndicator && _.isEmpty( verdictObjInfo ) ) {\n                let targetPropNames = _.get( defaultIndicator, 'tooltip.propNames' );\n                if( !targetPropNames ) {\n                    targetPropNames = [ 'object_string' ];\n                }\n                let propUiValue = '';\n                for( var targetProp in targetPropNames ) {\n                    var tgtProp = targetPropNames[ targetProp ];\n                    var prop = refObj.props[ tgtProp ];\n                    if( prop && prop.dbValue ) {\n                        propUiValue += prop.uiValue + '\\n';\n                    } else if( prop && prop.dbValues && prop.dbValues.length > 0 ) {\n                        propUiValue += prop.uiValues[ 0 ] + '\\n';\n                    }\n                }\n                let indicator = exports.getIndicatorFromParams( defaultIndicator, propUiValue );\n                indicatorsArray.push( indicator );\n            } else if ( !_.isEmpty( verdictObjInfo ) ) {\n                let indicator = exports.getIndicatorFromParams( verdictObjInfo.indicator, verdictObjInfo.tooltip );\n                indicatorsArray.push( indicator );\n            }\n        } );\n    } );\n    return indicatorsArray;\n};\n\n\n/**\n * Evaluates prop based condition structure\n *\n * @return {Object} verdictObject containing indicator matching information\n * verdictObj\n    {\n        hasIndicatorMatchedVal   :    If input indicator has matched exact value\n        matchingVal              :    What exact value indicator matched to e.g. \"Approved\"\n        tooltip                  :   \"localized(Approved)\" # based on Display Name\n    }\n */\nexport let evaluatePropBasedCondition = function( indicatorProp, obj, tooltip ) {\n    let verdictObj = { isDefaultIndicator: false, missingProps: [] };\n    if( indicatorProp.conditions && Object.keys( indicatorProp.conditions ).length > 0 ) {\n        verdictObj.hasIndicatorMatchedVal = expressionParserUtils.evaluateConditions( indicatorProp.conditions, obj );\n        if( verdictObj.hasIndicatorMatchedVal ) {\n            verdictObj.uid = obj.uid;\n            verdictObj.tooltip = '';\n            verdictObj.matchingVal = '';\n            var tooltipPropNames = tooltip.propNames;\n            for( var tooltipProp in tooltipPropNames ) {\n                var tooltipPropName = tooltipPropNames[ tooltipProp ];\n\n                // 20200922 - try to validate prop exist by propertyDescriptorsMap, not object itself\n                if( obj.modelType && obj.modelType.propertyDescriptorsMap && !obj.modelType.propertyDescriptorsMap.hasOwnProperty( tooltipPropName ) ) {\n                    verdictObj.missingProps.push( tooltipPropName );\n                    continue;\n                }\n\n                verdictObj.matchingVal += obj.props[ tooltipPropName ].dbValues[ 0 ] + '\\n';\n\n                if( tooltip.showPropDisplayName ) {\n                    verdictObj.tooltip += obj.props[ tooltipPropName ].propertyDescriptor.displayName + ': ';\n                }\n\n                verdictObj.tooltip += obj.props[ tooltipPropName ].uiValues[ 0 ] + '\\n';\n            }\n        }\n    } else if( indicatorProp.conditions && Object.keys( indicatorProp.conditions ).length === 0 ) {\n        //if this has empty condition object, is a default indicator\n        if( indicatorProp.names && _.isArray( indicatorProp.names ) && indicatorProp.names.length > 0 ) {\n            verdictObj.isDefaultIndicator = true;\n            return verdictObj;\n        }\n    }else if( indicatorProp.type ) {\n        var evaluatedVerdictObj = evaluatePropBasedCondition( indicatorProp.type.prop, obj, tooltip );\n\n        //There are missing properties from the tooltip\n        if( evaluatedVerdictObj.missingProps.length > 0 ) {\n            var foundProps = [];\n            //Iterate through the list backward, remove all properties found on this object\n            //(Note there may be some properties not found in the src or target obj)\n            //(If our goal is to end checking here, we can iterate forward and clear the list)\n            for( var propIndx = evaluatedVerdictObj.missingProps.length - 1; propIndx >= 0; propIndx-- ) {\n                if( obj.props[evaluatedVerdictObj.missingProps[propIndx]] ) {\n                    var propObj = { matchingVal: obj.props[evaluatedVerdictObj.missingProps[propIndx]].dbValues[ 0 ] + '\\n',\n                        tooltip: obj.props[evaluatedVerdictObj.missingProps[propIndx]].uiValues[ 0 ] + '\\n',\n                        propertyDisplayName: obj.props[evaluatedVerdictObj.missingProps[propIndx]].propertyDescriptor.displayName };\n                    foundProps.unshift( propObj );\n\n                    //Current object found this property, so we can remove it from the list.\n                    evaluatedVerdictObj.missingProps.splice( propIndx, 1 );\n                }\n            }\n            //Iterate through the list to add to the tooltip the found properties.\n            for( var idx = 0; idx < foundProps.length; idx++ ) {\n                evaluatedVerdictObj.matchingVal += foundProps[idx].matchingVal;\n\n                if( tooltip.showPropDisplayName ) {\n                    evaluatedVerdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                }\n\n                evaluatedVerdictObj.tooltip += foundProps[idx].tooltip;\n            }\n        }\n\n\n        return evaluatedVerdictObj;\n    }\n    return verdictObj;\n};\n\n\n/**\n * Returns the list of visual indicators.\n *\n * @param {vmo} vmo - viewModelObject.\n * @param {getModelObjCallBack} getModelObjCallBack - call back.\n * @return {Array} List of visual indicator objects\n */\nexport let getVisualIndicators = function( vmo, getModelObjCallBack ) {\n    var indicatorsArray = [];\n    if( vmo && vmo.props ) {\n        let preVerdictArray = [];\n        //Go through all the props from VMO, get indicators for each matched prop\n        for( const [ propKey, propValue ] of Object.entries( vmo.props ) ) {\n            let preVerdict = {};\n            if( !_.isEmpty( propValue.dbValue ) || !_.isEmpty( propValue.dbValues ) ) {\n                preVerdict.name = propKey;\n                preVerdict.vmoProp = propValue;\n                let matchedIndicators = Object.values( _indicators ).filter( indicatorJson => indicatorJson && _isValidPropName( indicatorJson.prop, propKey ) );\n                //each prop may have multiple indicator\n                if( !_.isEmpty( matchedIndicators ) ) {\n                    preVerdict.indicators = matchedIndicators;\n                    preVerdictArray.push( preVerdict );\n                }\n            }\n        }\n        indicatorsArray = _getIndicatorsFromPreVerdict( preVerdictArray, getModelObjCallBack );\n        //get the indicators which not defined in indicator.prop, eg. CheckOut\n        Object.values( _indicators ).forEach( indicatorJson => {\n            if( indicatorJson && !indicatorJson.prop ) {\n                var modelTypes = indicatorJson.modelTypes;\n                var conditions = indicatorJson.conditions;\n                if( _isValidModelType( vmo.modelType, modelTypes ) ) {\n                    let isValid = true;\n                    if( conditions ) {\n                        isValid = expressionParserUtils.evaluateConditions( conditions, vmo );\n                    }\n                    if( isValid ) {\n                        const indicator = exports.generateIndicator( vmo, indicatorJson );\n                        if( indicator && !_.isEqual( indicator.tooltip, '' ) ) {\n                            indicatorsArray.push( indicator );\n                        }\n                    }\n                }\n            }\n        } );\n    }\n    return indicatorsArray;\n};\n\n/**\n * Gets the default indicator for a property\n *\n * @return {Object} Indicator object which is default for a given prop\n */\nexport let getDefaultIndicator = function( propName, obj ) {\n    var defaultIndicator = null;\n    _.forEach( _indicators, function( indicatorJson ) {\n        if( indicatorJson ) {\n            var prop = indicatorJson.prop;\n            if( prop && prop.names && _.isArray( prop.names ) && prop.names.length > 0 ) {\n                // If prop is defined correctly, see if it is valid to default for input propName\n                if( prop.names.indexOf( propName ) >= 0 && prop.conditions && _.isEmpty( prop.conditions ) ) {\n                    defaultIndicator = indicatorJson;\n                    return false;\n                }\n            }\n        }\n    } );\n    return defaultIndicator;\n};\n\n/**\n * Generates indicator object if tooltips are available for given view model object\n *\n * @return {Object} Indicator object which contains tooltip and icon\n */\nexport let generateIndicator = function( vmo, indicatorJson ) {\n    var indicator;\n\n    if( vmo && indicatorJson && indicatorJson.tooltip ) {\n        var indicatorProps = indicatorJson.tooltip.propNames;\n\n        if( _.isArray( indicatorProps ) ) {\n            var finalTooltip = '';\n\n            for( var indx = 0; indx < indicatorProps.length; indx++ ) {\n                var tooltip = '';\n                var propValues = [];\n\n                var indicatorProp = indicatorProps[ indx ];\n\n                if( indicatorProp && vmo.props.hasOwnProperty( indicatorProp ) ) {\n                    var vmProp = vmo.props[ indicatorProp ];\n\n                    if( vmProp ) {\n                        propValues = vmProp.displayValues;\n                    }\n\n                    if( propValues && propValues.length > 0 ) {\n                        for( var i = 0; i < propValues.length; i++ ) {\n                            var propValue = propValues[ i ];\n\n                            if( propValue && propValue !== ' ' ) {\n                                if( tooltip === '' && indicatorJson.tooltip.showPropDisplayName ) {\n                                    tooltip = vmProp.propertyDisplayName + ': ';\n                                }\n\n                                if( i !== propValues.length - 1 ) {\n                                    tooltip += propValue + '\\n';\n                                } else {\n                                    tooltip += propValue;\n                                }\n                            }\n                        }\n\n                        if( finalTooltip === '' ) {\n                            finalTooltip = tooltip;\n                        } else {\n                            finalTooltip = finalTooltip + '\\n' + tooltip;\n                        }\n                    }\n                }\n            }\n\n            const icon = getImageAliasFromId( `indicator${indicatorJson.iconName}` ) ? `indicator${indicatorJson.iconName}` : 'indicatorMissingImage';\n\n            indicator = {\n                tooltip: finalTooltip,\n                // Sanitize the command icon\n                image: icon\n            };\n        }\n    }\n\n    return indicator;\n};\n\n\n/**\n * API to get indicator based on parameters\n *\n * @param {Object} indicator\n */\nexport let getIndicatorFromParams = function( indicatorJson, tooltip ) {\n    var indicatorFile = null;\n    if( indicatorJson !== null ) {\n        indicatorFile = indicatorJson.iconName;\n    }\n\n    const icon = getImageAliasFromId( `indicator${indicatorFile}` ) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n\n    return {\n        tooltip: tooltip,\n        // Sanitize the command icon\n        image: icon\n    };\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {indicatorJson} indicatorJson - json\n * @returns {Array} returns a list of visual indicators\n */\nexport let getIndicatorFromJSON = function( indicatorJson ) {\n    var indicatorsArray = [];\n    var indicatorFile = null;\n    var tooltip = null;\n    _.forEach( indicatorJson, function( indicator ) {\n        if( indicator ) {\n            indicatorFile = indicator.image;\n            tooltip = indicator.tooltip;\n        }\n        const icon = getImageAliasFromId( `indicator${indicatorFile}` ) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n\n        var indicatorObj = {\n            image: icon,\n            tooltip: tooltip\n        };\n        indicatorsArray.push( indicatorObj );\n    } );\n    return indicatorsArray;\n};\n\n/**\n * API to override generated indicators for testing only.\n *\n * @param {Object} indicatorsOverride\n */\nexport let setIndicators = function( indicatorsOverride ) {\n    _indicators = indicatorsOverride;\n};\n\nexports = {\n    getVisualIndicators,\n    getDefaultIndicator,\n    generateIndicator,\n    evaluatePropBasedCondition,\n    getIndicatorFromParams,\n    getIndicatorFromJSON,\n    setIndicators\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}