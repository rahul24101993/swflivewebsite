{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to manage native contributions using a registry object generated at build time. Uses ES6 import to load pieces\n * defined in the registry on demand. Also defines the {@link NgServices.contributionService} which is accessible\n * through injection.\n *\n * @module js/contribution.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cfgSvc2 from 'js/configurationService';\nimport _ from 'lodash';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport { afxDynamicImport } from 'js/moduleLoader';\nvar trace = new Debug('contributionService');\nlet exports = {};\n/**\n * Load the set of contributions that are mapped to the given key string.\n *\n * Each contribution should return a function. The function will be called with the key of the contribution\n * and a promise to resolve with the object. With this method contributions have the ability to get the\n * contribution dynamically instead of returning a static object.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @return {Promise} A promise containing the objects that have been contributed.\n */\n\nexport let loadContributions = function (key) {\n  return cfgSvc2.getCfg('contributions').then(function (contributionProviders) {\n    if (contributionProviders[key]) {\n      // return AwPromiseService.instance.all( modules ).then( values => values );\n      return AwPromiseService.instance(function (resolve) {\n        // Allow module loader to manage the caching / registry\n        trace('Loading contributions', key);\n        afxDynamicImport(contributionProviders[key], function handleLoadedContribution() {\n          trace('Contribution load complete', key); // Create a promise for each contribution function\n\n          var promises = []; // Number of arguments is not known so have parse manually as array\n\n          _.forEach(Array.prototype.slice.call(arguments), function (arg, index) {\n            if (_.isFunction(arg)) {\n              var deferredLp = AwPromiseService.instance.defer();\n              arg(key, deferredLp);\n              promises.push(deferredLp.promise);\n            } else {\n              logger.error(contributionProviders[key][index] + ' did not return a contribution function');\n            }\n          }); // And resolve the main promise once all are resolved\n\n\n          resolve(AwPromiseService.instance.all(promises));\n        });\n      });\n    }\n\n    logger.trace(key + ' not found in contribution registry');\n    return [];\n  });\n};\n/**\n * Support a callback based pattern when angular is not loaded. This should only be used before the angular start.\n *\n * Async contributions are not supported with this pattern, so any contributions that support this method must\n * return the value directly.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @param {Function} callback - A callback to call with the newly loaded contributions\n */\n\nexport let requireBeforeAppInitialize = function (key, callback) {\n  // The following fallback is to support the bootstrap usage.\n  var contributionProviders = cfgSvc2.getCfgCached('contributions');\n\n  if (contributionProviders[key]) {\n    // Allow module loader to manage the caching / registry\n    afxDynamicImport(contributionProviders[key], function () {\n      var result = []; // Number of arguments is not known so have parse manually as array\n\n      _.forEach(Array.prototype.slice.call(arguments), function (arg, index) {\n        if (_.isFunction(arg)) {\n          result.push(arg(key));\n        } else {\n          logger.error(contributionProviders[key][index] + ' did not return a contribution function');\n        }\n      });\n\n      callback(result);\n    });\n  } else {\n    logger.trace(key + ' not found in contribution registry');\n    callback([]);\n  }\n};\nexports = {\n  loadContributions,\n  requireBeforeAppInitialize\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","cfgSvc2","_","Debug","logger","afxDynamicImport","trace","exports","loadContributions","key","getCfg","then","contributionProviders","instance","resolve","handleLoadedContribution","promises","forEach","Array","prototype","slice","call","arguments","arg","index","isFunction","deferredLp","defer","push","promise","error","all","requireBeforeAppInitialize","callback","getCfgCached","result"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/contribution.service.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to manage native contributions using a registry object generated at build time. Uses ES6 import to load pieces\n * defined in the registry on demand. Also defines the {@link NgServices.contributionService} which is accessible\n * through injection.\n *\n * @module js/contribution.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cfgSvc2 from 'js/configurationService';\nimport _ from 'lodash';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport { afxDynamicImport } from 'js/moduleLoader';\n\nvar trace = new Debug( 'contributionService' );\n\nlet exports = {};\n\n/**\n * Load the set of contributions that are mapped to the given key string.\n *\n * Each contribution should return a function. The function will be called with the key of the contribution\n * and a promise to resolve with the object. With this method contributions have the ability to get the\n * contribution dynamically instead of returning a static object.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @return {Promise} A promise containing the objects that have been contributed.\n */\nexport let loadContributions = function( key ) {\n    return cfgSvc2.getCfg( 'contributions' ).then( function( contributionProviders ) {\n        if( contributionProviders[ key ] ) {\n            // return AwPromiseService.instance.all( modules ).then( values => values );\n            return AwPromiseService.instance( function( resolve ) {\n                // Allow module loader to manage the caching / registry\n                trace( 'Loading contributions', key );\n                afxDynamicImport( contributionProviders[ key ], function handleLoadedContribution() {\n                    trace( 'Contribution load complete', key );\n                    // Create a promise for each contribution function\n                    var promises = [];\n                    // Number of arguments is not known so have parse manually as array\n                    _.forEach( Array.prototype.slice.call( arguments ), function( arg, index ) {\n                        if( _.isFunction( arg ) ) {\n                            var deferredLp = AwPromiseService.instance.defer();\n                            arg( key, deferredLp );\n                            promises.push( deferredLp.promise );\n                        } else {\n                            logger.error( contributionProviders[ key ][ index ] +\n                                ' did not return a contribution function' );\n                        }\n                    } );\n\n                    // And resolve the main promise once all are resolved\n                    resolve( AwPromiseService.instance.all( promises ) );\n                } );\n            } );\n        }\n        logger.trace( key + ' not found in contribution registry' );\n        return [];\n    } );\n};\n\n/**\n * Support a callback based pattern when angular is not loaded. This should only be used before the angular start.\n *\n * Async contributions are not supported with this pattern, so any contributions that support this method must\n * return the value directly.\n *\n * @param {String} key - The key that the contribution is mapped to\n * @param {Function} callback - A callback to call with the newly loaded contributions\n */\nexport let requireBeforeAppInitialize = function( key, callback ) {\n    // The following fallback is to support the bootstrap usage.\n    var contributionProviders = cfgSvc2.getCfgCached( 'contributions' );\n    if( contributionProviders[ key ] ) {\n        // Allow module loader to manage the caching / registry\n        afxDynamicImport( contributionProviders[ key ], function() {\n            var result = [];\n            // Number of arguments is not known so have parse manually as array\n            _.forEach( Array.prototype.slice.call( arguments ), function( arg, index ) {\n                if( _.isFunction( arg ) ) {\n                    result.push( arg( key ) );\n                } else {\n                    logger.error( contributionProviders[ key ][ index ] + ' did not return a contribution function' );\n                }\n            } );\n            callback( result );\n        } );\n    } else {\n        logger.trace( key + ' not found in contribution registry' );\n        callback( [] );\n    }\n};\n\nexports = {\n    loadContributions,\n    requireBeforeAppInitialize\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}