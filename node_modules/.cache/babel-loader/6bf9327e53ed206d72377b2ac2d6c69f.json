{"ast":null,"code":"// Copyright (c) 2022 Siemens\n/**\n * @module js/utils\n */import _ from'lodash';import logger from'js/logger';import AwParseService from'js/awParseService';import workspaceUtils from'js/workspaceUtils';/**\n * Polyfill to match dynamic import result back to ES5 supported module\n *\n * @param {Object} obj - function to evaluate after loading the dependencies.\n * @returns {Object} ES5 module object\n */export function interopES6Default(obj){// for case like appCtxSerivce, for unknown reason, it has __esModule but no default\n// In the case we will use module itself\n// LCS-299148 Beyond Angular: Clean up app.getInjector usage\n// NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion\n// it makes that we defined the moduleServiceNameToInject at top level for that practice, not class\n// level.\n// It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice\n// the return is inconsistent for requireJS API:\n// - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }\n// - class without moduleServiceNameToInject => svcClass\n// - non class => it doen't matter since module === module.default\n// webpack and non-webpack mode will be same snce they have the same _interopES6Default\n//\n// Long term solution\n// - stop supporting non-webpack build\n// - see if we can remove this _interopES6Default when use dynamic import\n//\n// Short term solution (aw4.3)\n// - Document this apperance difference for class service\n// - it should be a minor minor case in regular practice\nreturn obj&&obj.__esModule&&obj.default&&!obj.moduleServiceNameToInject?obj.default:obj;}/**\n * Set the \"isToggle\" flag on any commands that have a handler with a \"selectWhen\" condition\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */function updateIsToggleFlag(viewModelJson){if(viewModelJson.commands){const cmdId2handlers={};let handlers=[];for(const handler of Object.values(viewModelJson.commandHandlers)){handlers=cmdId2handlers[handler.id];if(!handlers){handlers=[];cmdId2handlers[handler.id]=handlers;}handlers.push(handler);}for(const cmdId in viewModelJson.commands){const command=viewModelJson.commands[cmdId];// The handlers for the given command\nhandlers=cmdId2handlers[cmdId]||[];// If any handler for this command has selectWhen the command is a toggle command\ncommand.isToggle=!command.isGroup&&!command.isShuttle&&handlers.reduce(function(acc,handler){return acc||handler.hasOwnProperty('selectWhen');},false)||false;}}}/**\n * @param {Object} objValue - destination object\n * @param {Object} srcValue source object\n * @return {Object|undefined} modified destination object\n */function mergeCustomizer(objValue,srcValue){if(_.isArray(objValue)){return objValue.concat(srcValue);}}/**\n * @param {Object} obj1 object 1\n * @param {Object} obj2 object 2\n * @param {Object|null} check - optional checker object\n * @param {Number|null} depth - depth of merge\n * @type {module.exports.merge}\n */const merge=(obj1,obj2,check,depth)=>{if(!depth){depth=1;}if(_.isNull(obj2)){// nothing to merge\n}else if(_.isNull(obj1)){logger.error('Null object to merge!');}else if(_.isArray(obj1)&&_.isArray(obj2)){for(let element of obj2){// If there was a 'identity' test for the elements, we might be able to merge objects in the array.\nif(!obj1.includes(element)){obj1.push(_.cloneDeep(element));}}}else if(_.isObject(obj1)&&_.isObject(obj2)){if(!check){_.mergeWith(obj1,obj2,mergeCustomizer);}else{for(const key in obj2){const field=obj2[key];if(obj1.hasOwnProperty(key)){if(check){check.path.push(key);if(check.uniqueDepth!==undefined&&check.uniqueDepth===depth&&!check.path.includes('i18n')){throw new Error('Name conflict in '+check.file+'.json path='+check.path.join('.')+' for module '+check.moduleName+' (2nd occurrence)!');}}merge(obj1[key],field,check,depth+1);if(check){check.path.pop();}}else{obj1[key]=_.cloneDeep(field);}}}}else if(_.isArray(obj1)||_.isArray(obj2)){throw new Error('Invalid array merge!');}else if(_.isObject(obj1)||_.isObject(obj2)){throw new Error('Invalid object merge!');}};export const processWorkspaces=(solutionDef,workspacesInfo)=>{let workspaceData={};const workspaceArray=solutionDef.workspaces;let filteredWorkspaceContributions=[];if(solutionDef&&solutionDef.workspaces){let filteredWorkspaces=workspacesInfo.filter(function(workspaceInfo){if(/workspace_contribution.*/.test(workspaceInfo.name)){filteredWorkspaceContributions.push(workspaceInfo);return false;}return true;});for(const data of Object.values(filteredWorkspaces)){const workspace=data.contents;if(_.includes(workspaceArray,workspace.workspaceId)||workspace.scope==='Internal'||workspace.includeInSolutions&&workspace.includeInSolutions.includes(solutionDef.solutionId)){workspaceData[workspace.workspaceId]=workspace;}}//now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData\nfor(const data of Object.values(filteredWorkspaceContributions)){const workspace=data.contents;if(workspaceData[workspace.workspaceId]!==undefined){_.mergeWith(workspaceData[workspace.workspaceId],workspace,function customizer(objValue,srcValue){if(_.isArray(objValue)){_.each(srcValue,function(item){if(objValue.indexOf(item)<0){objValue.push(item);}});return objValue;}});}}}return workspaceData;};/**\n * Add all the configurations from the exclusive kits to the workspaces.\n * @param {object} WorkspacesInfo all workspaces\n * @param {Object} allKitsJson - all kits\n * @param {Object} allStatesJson - all states\n */export const processExclusiveKits=(WorkspacesInfo,allKitsJson,allModules2StatesJson)=>{for(var workspaceObject of Object.values(WorkspacesInfo)){workspaceUtils.resolveKitDefinitions(workspaceObject.contents,allKitsJson,allModules2StatesJson);}return;};export const processJsonImports=function(name,importResArray){let config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let lazy=arguments.length>3?arguments[3]:undefined;let res={};let lazyLoadPromises=[];// have to put it here because of clojure\nconst reduceJsonContents=(sum,cur)=>{const[fullStr,moduleName,file]=cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);merge(sum,cur.contents,config.uniqueDepth&&{moduleName,file,path:[],uniqueDepth:config.uniqueDepth});return sum;};if(lazy){for(const imp of importResArray){if(typeof imp.contents.then==='function'){lazyLoadPromises.push(imp.contents.then(contents=>{return{contents:interopES6Default(contents),name:imp.name};}));}else{// require.context in mendix does not support lazy loading\n// For now wrap the response in promise until we fix rollup-plugin-require-context2\nlazyLoadPromises.push(new Promise(resolve=>{const contents=imp.contents;return resolve({contents:interopES6Default(contents),name:imp.name});}));}}}// revisitme - need to consider \"configuration.format === 'array'\" use case later\nif(name==='commandsViewModel'){return Promise.all(lazyLoadPromises).then(importResArray=>{let res=importResArray.reduce(reduceJsonContents,{});updateIsToggleFlag(res);return res;});}else if(name==='secondaryWorkareaTabs'){return Promise.all(lazyLoadPromises).then(importResArray=>{return importResArray.reduce((sum,cur)=>{// old schema support\nif(_.isArray(cur.contents)){sum.tabs.push(...cur.contents);}else{// new schema support\nlet{tabs,...rest}=cur.contents;sum.tabs.push(...Object.values(tabs));merge(sum,rest);}return sum;},{tabs:[]});});}else if(name==='layoutSlots'||name==='navigationURLToken'||name==='syncStrategy'||name==='indicators'||name==='adapters'||name==='headerContributions'||name==='saveHandlers'){return Promise.all(lazyLoadPromises).then(importResArray=>{res=importResArray.reduce(reduceJsonContents,config.format==='array'?[]:{});return res;});}else if(name==='workspace'){return importResArray;}else if(name==='states'){res=importResArray.reduce((sum,cur)=>{if(cur.contents){for(const stateName in cur.contents){const state=cur.contents[stateName];if(state.type==='location'){if(!state.hasOwnProperty('abstract')){state.abstract=true;}if(!state.view){state.view='AwDefaultLocation';}if(!state.parent){state.parent='root';}}else if(state.type==='subLocation'){if(!state.view){state.view='AwDefaultSublocation';}if(!state.hasOwnProperty('reloadOnSearch')){state.reloadOnSearch=false;}if(!state.parent){throw new Error(\"Sublocation state \".concat(stateName,\" does not have parent location\"));}if(!state.hasOwnProperty('url')){throw new Error(\"No url defined for sublocation state \".concat(stateName));}}else if(state.type==='parameter'){if(!state.params){throw new Error(\"Parameter state \".concat(stateName,\" must have parameters\"));}else if(Object.keys(state).length>2){throw new Error(\"Parameter state \".concat(stateName,\" should only have type and params\"));}// Merging states is handled later\n}else{logger.debug(\"No type or unknown type on state \".concat(stateName,\" cannot validate state\"));}if(state.params){for(let param in state.params){if(!state.params[param]){state.params[param]={type:'any'};}}}// Temporary hack to support states that have not set type (ex search)\nif(state.type!=='location'&&!state.parent&&state.controller==='DefaultLocationCtrl'){logger.warn(\"\".concat(stateName,\" is using DefaultLocationCtrl but is not a location\"));state.parent='root';}if(!sum[stateName]){sum[stateName]=state;}else{if(sum[stateName].type==='parameter'||state.type==='parameter'){// If the current state is just parameters merge it into the finalState\nif(state.type==='parameter'){_.assign(sum[stateName].params,state.params);}else{// If the final state is currently just parameters and the new state is not merge into the new state\n_.assign(state.params,sum[stateName].params);sum[stateName]=state;}}else{logger.error(\"State name conflict with state \".concat(stateName));}}}}return sum;},{});return res;}else if(name==='aliasRegistry'){res=importResArray.reduce((sum,cur)=>{if(cur.contents){for(const iconName in cur.contents){const aliases=cur.contents[iconName];let icoName=iconName;if(aliases.length===0){throw new Error(\"No aliases provided for type icons declared for [\".concat(icoName,\"]\"));}// If not a type alias, then strip the size numbers at the end of the filename.\nif(!/^type/.test(icoName)){icoName=icoName.replace(/[0-9]+$/,'');}const token=icoName.substring(0,4);for(const alias of aliases){const aliasToken=token+alias;if(sum[aliasToken]){throw new Error(\"Multiple aliases declared for \".concat(aliasToken,\" [\").concat(icoName,\" & \").concat(sum[aliasToken],\"]\"));}if(aliasToken===iconName){throw new Error(\"Why map the same name to itself? \".concat(alias));}sum[aliasToken]=icoName;}}}return sum;},{});return res;}else if(name==='typeProperties'){res=importResArray.reduce((sum,cur)=>{if(cur.contents&&cur.contents.typeProperties){const typeProperties=cur.contents.typeProperties;for(const key2 in typeProperties){const value=typeProperties[key2];if(!sum[key2]){sum[key2]=value;}else{if(sum[key2].displayProperty&&value.displayProperty&&sum[key2].displayProperty!==value.displayProperty){logger.error(\"TypeProperties displayProperty conflict with type \".concat(key2));}else if(value.displayProperty){sum[key2].displayProperty=value.displayProperty;}if(value.additionalProperties){if(!sum[key2].additionalProperties){sum[key2].additionalProperties=[];}for(const property of value.additionalProperties){const foundProp=_.find(sum[key2].additionalProperties,o=>{return o.name===property.name;});if(!foundProp){sum[key2].additionalProperties.push(property);}}}}}}return sum;},{});return res;}// else\nres=importResArray.reduce(reduceJsonContents,config.format==='array'?[]:{});return res;};export const processI10n=(name,imports)=>{const i18nAllFiles={};const MSG_PREFIX='processL10n: ';let importResArray=imports.reduce((res,m)=>res.concat(_.filter(m.keys(),path=>{let localeCode;// get base name\nlet fileName=path.split('/').reverse()[0].split('.json')[0];if(/_[\\w]{2}_[\\w]{2}$/.test(fileName)){localeCode='i18n_'+fileName.substring(fileName.length-5);}else if(/_[\\w]{2}$/.test(fileName)){localeCode='i18n_'+fileName.substring(fileName.length-2);}else{localeCode='i18n';}return localeCode===name||name!=='i18n'&&localeCode==='i18n';}).map(path=>{if(typeof m(path).then==='function'){return m(path).then(contents=>{return{contents:interopES6Default(contents),name:path};});}// The plugin used in mendix integration does not support lazy m(path) i.e then api is missing\nreturn new Promise(resolve=>{const contents=m(path);return resolve({contents:interopES6Default(contents),name:path});});})),[]);/**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */function backFillFromEnglish(nonEnglish,english){for(const bundleName in english){const bundle=english[bundleName];if(!nonEnglish[bundleName]){nonEnglish[bundleName]=bundle;continue;}for(const key in bundle){const value=bundle[bundleName];if(!nonEnglish[bundleName][key]){nonEnglish[bundleName][key]=value;}}}}return Promise.all(importResArray).then(i18nlanguages=>{for(const cur of i18nlanguages){let[fullStr,moduleName,fileName]=cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);let localeName;if(/_[\\w]{2}_[\\w]{2}$/.test(fileName)){localeName=fileName.substring(fileName.length-5);fileName=fileName.substring(0,fileName.length-6);}else if(/_[\\w]{2}$/.test(fileName)){localeName=fileName.substring(fileName.length-2);fileName=fileName.substring(0,fileName.length-3);}else{localeName='en_US';}if(!i18nAllFiles[localeName]){i18nAllFiles[localeName]={};}if(cur.contents){try{i18nAllFiles[localeName][fileName]=cur.contents;}catch(err){logger.error(\"Unable to parse \".concat(cur.name));throw err;}}}for(const locale in i18nAllFiles){const json=i18nAllFiles[locale];if(locale!=='en_US'){backFillFromEnglish(json,i18nAllFiles.en_US);}}/**\n         * Existing i18n logic: ( for all step below, en_US doesn't have suffix)\n         * - i18n src is defined as:\n         *   adobejsTooltipMessages_zh_CN ->\n         *   {\n         *       \"openInIllustrator\": \"Local test in Chinese\"\n         *   }\n         *\n         * - It will be reassemble as:\n         *   i18n_zh_CN.json ->\n         *   {\n         *       adobejsTooltipMessages: {\n         *           \"openInIllustrator\": \"Local test in Chinese\"\n         *       }\n         *   }\n         *\n         * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',\n         *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'\n         *\n         * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'\n         *\n         * - in the final cfgCache it will looks like:\n         *   {\n         *       actionTemplateDefs,\n         *       ....,\n         *       i18n_zh_CN: {\n         *           adobejsTooltipMessages: {\n         *               \"openInIllustrator\": \"Local test in Chinese\"\n         *           }\n         *       }\n         *   }\n         *\n         * - regarding to installedLocales:\n         *   - it depends on on how man JSON config our customer has in src\n         *   - it depends on war_mySite.json\n         *   We will check it later\n         */let res;for(const locale in i18nAllFiles){const json=i18nAllFiles[locale];if(name.endsWith(locale)){res=json;}}// load english by default\n// revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will\n// see how can we handle that later\nreturn res?res:i18nAllFiles.en_US;});};export const processLoginLocales=(name,imports)=>{const i18nAllFiles={};let importResArray=imports.reduce((res,m)=>res.concat(_.filter(m.keys(),path=>{let localeCode;// get base name\nlet fileName=path.split('/').reverse()[0].split('.json')[0];if(!fileName.startsWith('LoginLocale')){return false;}if(/_[\\w]{2}_[\\w]{2}$/.test(fileName)){localeCode='LoginLocale_'+fileName.substring(fileName.length-5);}else if(/_[\\w]{2}$/.test(fileName)){localeCode='LoginLocale_'+fileName.substring(fileName.length-2);}else{localeCode='LoginLocale';}return localeCode===name||name!=='LoginLocale'&&localeCode==='LoginLocale';}).map(path=>m(path).then(contents=>{return{contents:interopES6Default(contents),name:path};}))),[]);/**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */function backFillFromEnglish(nonEnglish,english){for(const bundleName in english){const bundle=english[bundleName];if(!nonEnglish[bundleName]){nonEnglish[bundleName]=bundle;continue;}for(const key in bundle){const value=bundle[bundleName];if(!nonEnglish[bundleName][key]){nonEnglish[bundleName][key]=value;}}}}return Promise.all(importResArray).then(i18nlanguages=>{for(const cur of i18nlanguages){let[fullStr,moduleName,fileName]=cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);let localeName;if(/_[\\w]{2}_[\\w]{2}$/.test(fileName)){localeName=fileName.substring(fileName.length-5);fileName=fileName.substring(0,fileName.length-6);}else if(/_[\\w]{2}$/.test(fileName)){localeName=fileName.substring(fileName.length-2);fileName=fileName.substring(0,fileName.length-3);}else{localeName='en_US';}if(!i18nAllFiles[localeName]){i18nAllFiles[localeName]={};}if(cur.contents){try{i18nAllFiles[localeName][fileName]=cur.contents;}catch(err){logger.error(\"Unable to parse \".concat(cur.name));throw err;}}}for(const locale in i18nAllFiles){const json=i18nAllFiles[locale];if(locale!=='en_US'){backFillFromEnglish(json,i18nAllFiles.en_US);}if(json.LoginLocale&&json.LoginLocale[locale]){for(const locale2 of Object.keys(i18nAllFiles)){_.set(i18nAllFiles,[locale2,'LoginLocale',locale],json.LoginLocale[locale]);}}}let res;for(const locale in i18nAllFiles){const json=i18nAllFiles[locale];if(name.endsWith(locale)){res=json;}}return res?res:i18nAllFiles.en_US;});};/**\n * parse return value webpack.require.context to module object array\n * @param {Array} imports module structure return by webpack.require.context API\n * @returns {Object} module object array\n */export const parseImports=imports=>imports.reduce((res,m)=>res.concat(m.keys().map(path=>({name:path,contents:interopES6Default(m(path))}))),[]);/**\n * stitch JSON from require.context import\n * @param {String} name module structure return by webpack.require.context API\n * @param {Array} imports module structure return by webpack.require.context API\n * @param {Object} config JSON configuration definition\n * @returns {Object} stitched JSON object\n */export const stitchJSON=function(name,imports){let config=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let lazy=arguments.length>3?arguments[3]:undefined;return processJsonImports(name,parseImports(imports),config,lazy);};/**\n * Try to get field object from expr and field context\n * @param {String} expr field input expression\n * @param {Object} fields fields context\n * @param {String} $index $index context\n * @param {String} path fields context\n * @param {Object} context fields context\n * @returns {Object} field object consumed by universal widget\n */export const getField=(expr,fields,$index,path,context)=>{if(path&&$index){if(/^ctx\\./.test(path)){return AwParseService.instance(path.replace(/^ctx\\./,'').replace(/\\./g,'_'))(fields)[$index]||{fielddata:{}};}// support the use case of atomic data with aw-repeat\nif(path.startsWith('fields.')){return AwParseService.instance(expr)(context);}return AwParseService.instance(path.replace(/\\.props([.[][^.]+\\]?)$/,'$1').replace(/^data\\./,'').replace(/^props\\.|\\.props/,''))(fields)[$index]||{fielddata:{}};}if(/^ctx\\./.test(expr)){return AwParseService.instance(expr.replace(/^ctx\\./,'').replace(/\\./g,'_'))(fields)||{fielddata:{}};}if(!_.isNil($index)){expr=expr.replace('$index',$index.toString());}if(expr.startsWith('fields.')){return AwParseService.instance(expr.replace(/^data\\./,'').replace(/^fields\\./,''))(fields)||{fielddata:{}};}// - put { fielddata: {} } as default value to match with widget design\n// - Supported use case:\n//   - data.myText => myText\n//   - data.myObj.props.object_name => myObj.object_name\nreturn AwParseService.instance(expr.replace(/\\.props([.[][^.]+\\]?)$/,'$1').replace(/^data\\./,'').replace(/^fields\\./,''))(fields)||{fielddata:{}};};/**\n * Replace all instances of a given string within a larger string.\n *\n * @param {String} input - input string to replace content\n * @param {String} toFind - string to locate\n * @param {String} toReplace - string to replace\n * @return {String} modified string\n */export const replaceAll=(input,toFind,toReplace)=>{let output=input;if(output.indexOf(toFind)>-1){output=output.split(toFind).join(toReplace);}return output;};","map":null,"metadata":{},"sourceType":"module"}