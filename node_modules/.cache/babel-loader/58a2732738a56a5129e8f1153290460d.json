{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).\n *\n * @module js/awTableStateService\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport localStrg from 'js/localStorage';\nimport uwUtilSvc from './uwUtilService';\n/**\n * {String} Expansion state of a node when expanded\n */\n\nvar _EXPAND_FULL = 'full';\n/**\n * {String} The primary topic (i.e. key) used to store state information.\n */\n\nvar _LS_TOPIC = 'awTreeTableState';\n/**\n * {String} The current local storage schema version accepted.\n */\n\nvar _LS_TOPIC_VERSION = '1.0.1';\n/**\n * {String} A common location that is included in the declViewModel's path that needs to be removed before reporting\n * the ID of the declViewModel's ID.\n */\n\nvar _VM_DIR_NAME = '/viewmodel/';\n/**\n * {Boolean} TRUE if various activities of this services should be logged.\n */\n\nvar _debug_logTableStateActivity = false;\n/**\n * {Boolean} TRUE if all levels should be expanded (as they become visible).\n */\n\nvar _expandAll = false;\n/**\n * {Object} The keys of this object are the unique 'roots' requesting saves.\n */\n\nvar _pendingSaveStateRequests = {};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node to find the path to all the 'parent' nodes up the levels\n *            currently in the viewModelCollection of the associated dataProvider.\n *\n * @return {StringArray} An array of node IDs that identify the given node (as element [0]) in its hierarchy up to\n *         the 'top' node (as element [length-1]).\n */\n\nvar _buildNodePath = function (declViewModel, gridId, targetNode) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n  /**\n   * Find target\n   */\n\n\n  var vmRows = uwDataProvider.getViewModelCollection().getLoadedViewModelObjects();\n  var targetNdx = -1;\n\n  for (var ndx = 0; ndx < vmRows.length; ndx++) {\n    if (uwUtilSvc.getEvaluatedId(vmRows[ndx]) === uwUtilSvc.getEvaluatedId(targetNode)) {\n      targetNdx = ndx;\n      break;\n    }\n  }\n\n  if (targetNdx < 0) {\n    return [];\n  }\n  /**\n   * Build path by looking 'up' the rows\n   */\n\n\n  var pathIDs = [uwUtilSvc.getEvaluatedId(targetNode)];\n  var currRowNdx = targetNdx;\n  var currNextLevel = targetNode.levelNdx - 1;\n\n  while (currNextLevel > -1) {\n    for (var ndx2 = currRowNdx - 1; ndx2 >= 0; ndx2--) {\n      //\n      var currRow = vmRows[ndx2];\n\n      if (currRow.levelNdx === currNextLevel) {\n        pathIDs.push(uwUtilSvc.getEvaluatedId(currRow));\n        currNextLevel = currRow.levelNdx - 1;\n      }\n    }\n  }\n\n  return pathIDs;\n};\n/**\n * Return the structure object of the given 'target' node (and set with the 'target' 'childNdx') and create any\n * missing 'parent' structure nodes (if necessary).\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to return the object for.\n *\n * @return {Object} The structure object of the given 'target' node (and set with the 'target' 'childNdx').\n */\n\n\nvar _assureStructureNode = function (declViewModel, gridId, ttState, targetNode) {\n  var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n\n  if (!ttState.structure) {\n    ttState.structure = {};\n  }\n  /**\n   * Start at the top and work down based on the 'target' path.\n   */\n\n\n  var currStructureNode = ttState.structure;\n\n  for (var ndx = pathIDs.length - 1; ndx >= 0; ndx--) {\n    var pathID = pathIDs[ndx];\n\n    if (!currStructureNode[pathID]) {\n      currStructureNode[pathID] = {};\n    }\n\n    currStructureNode = currStructureNode[pathID];\n  }\n\n  currStructureNode.childNdx = targetNode.childNdx;\n  return currStructureNode;\n};\n/**\n * Delete the structure object of the given 'target' node.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to delete the state for.\n */\n\n\nvar _removeStructureNode = function (declViewModel, gridId, ttState, targetNode) {\n  if (ttState.structure) {\n    var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n    /**\n     * Start at the top and work down based on the 'target' path.\n     */\n\n\n    var currParentNode = ttState.structure;\n    var parentNodes = {};\n\n    for (var ndx = pathIDs.length - 1; ndx > 0; ndx--) {\n      var pathID = pathIDs[ndx];\n      currParentNode = currParentNode[pathID];\n\n      if (!currParentNode) {\n        break;\n      }\n\n      parentNodes[pathID] = currParentNode;\n    }\n    /**\n     * Starting at the lowest level, delete any structure objects that are not empty.\n     */\n\n\n    if (currParentNode) {\n      currParentNode = ttState.structure;\n      var keys = Object.keys(parentNodes);\n\n      for (var ndx2 = keys.length - 1; ndx2 > 1; ndx2--) {\n        var key = keys[ndx2];\n        currParentNode = parentNodes[key];\n\n        if (Object.keys(currParentNode).length < 2) {\n          var immParent = parentNodes[keys[ndx2 - 1]];\n          delete immParent[key];\n        }\n      }\n    }\n  }\n};\n/**\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {String} nodeId - ID of the node to return the object for,\n *\n * @return {Object} The state object associated with the given node (or NULL if no state exists for it.\n */\n\n\nvar _getNodeState = function (ttState, nodeId) {\n  if (!ttState.nodeStates) {\n    ttState.nodeStates = {};\n    return null;\n  }\n\n  return ttState.nodeStates[nodeId];\n};\n/**\n * @return {Object} The top-level object (loaded from local storage) containing the state information for all tables\n *         currently being tracked.\n */\n\n\nvar _getAllStates = function () {\n  var allStates;\n  var allStatesStr = localStrg.get(_LS_TOPIC);\n\n  if (allStatesStr) {\n    try {\n      allStates = JSON.parse(allStatesStr);\n\n      if (allStates.schemaVersion !== _LS_TOPIC_VERSION) {\n        allStates = null;\n      }\n    } catch (ex) {// Handled below\n    }\n  }\n\n  if (!allStates) {\n    allStates = {\n      schemaVersion: _LS_TOPIC_VERSION\n    };\n  }\n\n  return allStates;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {UwDataProvider} The current dataProvider associated with the given table.\n */\n\n\nvar _getDataProvider = function (declViewModel, gridId) {\n  var declGrid = declViewModel._internal.grids[gridId];\n  assert(declGrid, 'Table definition not found');\n  var uwDataProvider = declViewModel.dataProviders[declGrid.dataProvider];\n  assert(uwDataProvider, 'Table dataProvider is not valid');\n  return uwDataProvider;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {String} The unique ID of the view model object that 'owns' the table's data (i.e. The ID of an assembly)\n *         (or 'nonTreeRoot' if there is no 'topNode' set on the associated dataProvider).\n */\n\n\nvar _getRootId = function (declViewModel, gridId) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n\n  return uwDataProvider.topTreeNode ? uwUtilSvc.getEvaluatedId(uwDataProvider.topTreeNode) : 'nonTreeRoot';\n};\n/**\n * @param {Object} allStates - The top-level object (loaded from local storage) containing the state information for\n *            all tables currently being tracked.\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the state for the given declModel/declGrid.\n */\n\n\nvar _getTreeTableGridState = function (allStates, declViewModel, gridId) {\n  assert(declViewModel, 'Invalid DeclViewModel');\n  assert(declViewModel._internal.panelId, 'Invalid DeclViewModel');\n  assert(gridId, 'Invalid table ID');\n  var declViewModelId = declViewModel._internal.panelId;\n  var vmDirNdx = declViewModelId.indexOf(_VM_DIR_NAME);\n\n  if (vmDirNdx !== -1) {\n    declViewModelId = declViewModelId.substring(vmDirNdx + _VM_DIR_NAME.length);\n  }\n\n  if (!allStates[declViewModelId]) {\n    allStates[declViewModelId] = {};\n  }\n\n  if (!allStates[declViewModelId][gridId]) {\n    allStates[declViewModelId][gridId] = {};\n  }\n\n  return allStates[declViewModelId][gridId];\n};\n/**\n * This save state function is 'debounced' to only save data after updated 'quiets down' for ~2 second.\n *\n * @private\n */\n\n\nvar _pingSaveStateDebounce = _.debounce(function () {\n  /**\n   * Check if we have pending requests<BR>\n   * If so: Process the pending requests.\n   */\n  if (!_.isEmpty(_pendingSaveStateRequests)) {\n    var saveStateRequests = _pendingSaveStateRequests;\n    _pendingSaveStateRequests = {};\n\n    var allStates = _getAllStates();\n\n    _.forEach(saveStateRequests, function (req) {\n      /**\n       * Since a ping can time out *after* a declViewModel has been destroyed, check if the pending request\n       * has a valid declViewModel.\n       */\n      if (!req.declViewModel.isDestroyed()) {\n        var gridState = _getTreeTableGridState(allStates, req.declViewModel, req.gridId);\n\n        var rootId = _getRootId(req.declViewModel, req.gridId);\n\n        gridState[rootId] = req.ttState;\n      }\n    });\n\n    if (_debug_logTableStateActivity) {\n      logger.info('Saving table states');\n    }\n\n    localStrg.publish(_LS_TOPIC, JSON.stringify(allStates));\n  }\n}, 500, {\n  maxWait: 10000,\n  trailing: true,\n  leading: false\n});\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n */\n\n\nvar _saveTreeTableState = function (declViewModel, gridId, ttState) {\n  var rootId = _getRootId(declViewModel, gridId);\n\n  _pendingSaveStateRequests[rootId] = {\n    declViewModel: declViewModel,\n    gridId: gridId,\n    ttState: ttState\n  };\n\n  _pingSaveStateDebounce();\n};\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service Objects<BR>\n * -------------------------------------------------------------------------<BR>\n */\n\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service API<BR>\n * -------------------------------------------------------------------------<BR>\n */\n\n\nvar exports = {};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n */\n\nexport let clearAllStates = function (declViewModel, gridId) {\n  /**\n   * Check if any of the new 'child' nodes are known to be expanded.<BR>\n   * If so: Setup to async expand them later.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n  ttState.nodeStates = {};\n  ttState.structure = {}; // clear from local storage\n\n  _saveTreeTableState(declViewModel, gridId, ttState);\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNodeArray} nodesToTest - The nodes to test expansion status for.\n *\n * @return {Map} An object that maps a tree node ID to a data object with the following properties for each of the\n *         given nodes that are currently expanded:\n *\n * <pre>\n * {\n *     expanded: true,\n *     nodeToExpand: [node from nodesToTest]\n * }\n * </pre>\n */\n\nexport let findExpandedNodes = function (declViewModel, gridId, nodesToTest) {\n  /**\n   * Check if any of the new 'child' nodes are known to be expanded.<BR>\n   * If so: Setup to async expand them later.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n  var expandNodeRequests = {};\n\n  if (!_.isEmpty(ttState.nodeStates)) {\n    _.forEach(nodesToTest, function (testNode) {\n      if (_expandAll) {\n        expandNodeRequests[uwUtilSvc.getEvaluatedId(testNode)] = {\n          expanded: true,\n          nodeToExpand: testNode\n        };\n      } else {\n        var nodeState = ttState.nodeStates[uwUtilSvc.getEvaluatedId(testNode)];\n\n        if (nodeState && nodeState.expansion === _EXPAND_FULL) {\n          expandNodeRequests[uwUtilSvc.getEvaluatedId(testNode)] = {\n            expanded: true,\n            nodeToExpand: testNode\n          };\n        }\n      }\n    });\n  }\n\n  return expandNodeRequests;\n};\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the table state for the given declModel/declGrid.\n */\n\nexport let getTreeTableState = function (declViewModel, gridId) {\n  var uwDataProvider = _getDataProvider(declViewModel, gridId);\n\n  if (!uwDataProvider.ttState) {\n    var allStates = _getAllStates();\n\n    var gridState = _getTreeTableGridState(allStates, declViewModel, gridId);\n\n    var rootId = _getRootId(declViewModel, gridId);\n\n    if (_debug_logTableStateActivity) {\n      logger.info('Reading table states for: ' + rootId);\n    }\n\n    if (!gridState[rootId]) {\n      gridState[rootId] = {\n        structure: {},\n        nodeStates: {}\n      };\n    }\n\n    uwDataProvider.ttState = gridState[rootId]; // <pre>\n    // Possible fix for scroll to problem...investigate later w/ related changes in 'aw.table.controller'.\n    // if( uwDataProvider.ttState ) {\n    //     uwDataProvider.isFocusedLoad = true;\n    // }\n    // </pre>\n  }\n\n  return uwDataProvider.ttState;\n};\n/**\n * @param {Object} ttState - (Optional) An object holding the table state for a given declModel/declGrid.\n * @param {ViewModelTreeNodeArray} nodeToTest - The nodes to test status for.\n *\n * @return {Boolean} TRUE if the given node is currently expanded.\n */\n\nexport let isNodeExpanded = function (ttState, nodeToTest) {\n  if (ttState.nodeStates) {\n    var nodeState = ttState.nodeStates[uwUtilSvc.getEvaluatedId(nodeToTest)];\n    return nodeState && nodeState.expansion === _EXPAND_FULL;\n  }\n\n  return false;\n};\n/**\n * Clear the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just collapsed.\n */\n\nexport let saveRowCollapsed = function (declViewModel, gridId, targetNode) {\n  /**\n   * Forget we are expanding this node.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  _assureStructureNode(declViewModel, gridId, ttState, targetNode);\n\n  var nodeState = _getNodeState(ttState, uwUtilSvc.getEvaluatedId(targetNode));\n\n  if (nodeState && nodeState.expansion) {\n    delete nodeState.expansion;\n\n    if (_.isEmpty(nodeState)) {\n      delete ttState.nodeStates[uwUtilSvc.getEvaluatedId(targetNode)];\n\n      _removeStructureNode(declViewModel, gridId, ttState, targetNode);\n    }\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n/**\n * Update the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just expanded.\n */\n\nexport let saveRowExpanded = function (declViewModel, gridId, targetNode) {\n  /**\n   * Remember we are expanding this node.\n   */\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  _assureStructureNode(declViewModel, gridId, ttState, targetNode);\n\n  var nodeState = _getNodeState(ttState, uwUtilSvc.getEvaluatedId(targetNode));\n\n  if (!nodeState) {\n    ttState.nodeStates[uwUtilSvc.getEvaluatedId(targetNode)] = {\n      expansion: _EXPAND_FULL\n    };\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  } else if (nodeState.expansion !== _EXPAND_FULL) {\n    nodeState.expansion = _EXPAND_FULL;\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n/**\n * Update the persisted current top row in the table. .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node of the currently visible top row of the table.\n */\n\nexport let saveScrollTopRow = function (declViewModel, gridId, targetNode) {\n  var pathIDs = _buildNodePath(declViewModel, gridId, targetNode);\n\n  var ttState = exports.getTreeTableState(declViewModel, gridId);\n\n  if (!ttState.topRowPath || _.difference(ttState.topRowPath, pathIDs).length !== 0) {\n    ttState.topRowPath = pathIDs;\n\n    _saveTreeTableState(declViewModel, gridId, ttState);\n  }\n};\n_debug_logTableStateActivity = browserUtils.getUrlAttributes().logTableStateActivity === '';\nexports = {\n  clearAllStates,\n  findExpandedNodes,\n  getTreeTableState,\n  isNodeExpanded,\n  saveRowCollapsed,\n  saveRowExpanded,\n  saveScrollTopRow\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/propertyrender/src/js/awTableStateService.js"],"names":["_EXPAND_FULL","_LS_TOPIC","_LS_TOPIC_VERSION","_VM_DIR_NAME","_debug_logTableStateActivity","_expandAll","_pendingSaveStateRequests","_buildNodePath","uwDataProvider","_getDataProvider","vmRows","targetNdx","ndx","uwUtilSvc","pathIDs","currRowNdx","currNextLevel","targetNode","ndx2","currRow","_assureStructureNode","ttState","currStructureNode","pathID","_removeStructureNode","currParentNode","parentNodes","keys","Object","key","immParent","_getNodeState","_getAllStates","allStatesStr","localStrg","allStates","JSON","schemaVersion","declGrid","declViewModel","assert","_getRootId","_getTreeTableGridState","declViewModelId","vmDirNdx","_pingSaveStateDebounce","_","saveStateRequests","req","gridState","rootId","logger","maxWait","trailing","leading","_saveTreeTableState","gridId","exports","clearAllStates","findExpandedNodes","expandNodeRequests","expanded","nodeToExpand","testNode","nodeState","getTreeTableState","structure","nodeStates","isNodeExpanded","saveRowCollapsed","saveRowExpanded","expansion","saveScrollTopRow","browserUtils"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAA,MAAA,MAAA,WAAA;AACA,OAAA,CAAA,MAAA,QAAA;AACA,OAAA,YAAA,MAAA,iBAAA;AACA,OAAA,MAAA,MAAA,WAAA;AACA,OAAA,SAAA,MAAA,iBAAA;AACA,OAAA,SAAA,MAAA,iBAAA;AAEA;AACA;AACA;;AACA,IAAIA,YAAY,GAAhB,MAAA;AAEA;AACA;AACA;;AACA,IAAIC,SAAS,GAAb,kBAAA;AAEA;AACA;AACA;;AACA,IAAIC,iBAAiB,GAArB,OAAA;AAEA;AACA;AACA;AACA;;AACA,IAAIC,YAAY,GAAhB,aAAA;AAEA;AACA;AACA;;AACA,IAAIC,4BAA4B,GAAhC,KAAA;AAEA;AACA;AACA;;AACA,IAAIC,UAAU,GAAd,KAAA;AAEA;AACA;AACA;;AACA,IAAIC,yBAAyB,GAA7B,EAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,cAAc,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,UAAA,EAA8C;EAC/D,IAAIC,cAAc,GAAGC,gBAAgB,CAAA,aAAA,EAArC,MAAqC,CAArC;EAEA;AACJ;AACA;;;EACI,IAAIC,MAAM,GAAGF,cAAc,CAAdA,sBAAAA,GAAb,yBAAaA,EAAb;EAEA,IAAIG,SAAS,GAAG,CAAhB,CAAA;;EAEA,KAAK,IAAIC,GAAG,GAAZ,CAAA,EAAkBA,GAAG,GAAGF,MAAM,CAA9B,MAAA,EAAuCE,GAAvC,EAAA,EAA+C;IAC3C,IAAIC,SAAS,CAATA,cAAAA,CAA0BH,MAAM,CAAhCG,GAAgC,CAAhCA,MAA8CA,SAAS,CAATA,cAAAA,CAAlD,UAAkDA,CAAlD,EAA2F;MACvFF,SAAS,GAATA,GAAAA;MACA;IACH;EACJ;;EAED,IAAIA,SAAS,GAAb,CAAA,EAAoB;IAChB,OAAA,EAAA;EACH;EAED;AACJ;AACA;;;EACI,IAAIG,OAAO,GAAG,CAAED,SAAS,CAATA,cAAAA,CAAhB,UAAgBA,CAAF,CAAd;EAEA,IAAIE,UAAU,GAAd,SAAA;EACA,IAAIC,aAAa,GAAGC,UAAU,CAAVA,QAAAA,GAApB,CAAA;;EAEA,OAAOD,aAAa,GAAG,CAAvB,CAAA,EAA4B;IACxB,KAAK,IAAIE,IAAI,GAAGH,UAAU,GAA1B,CAAA,EAAgCG,IAAI,IAApC,CAAA,EAA2CA,IAA3C,EAAA,EAAoD;MAChD;MACA,IAAIC,OAAO,GAAGT,MAAM,CAApB,IAAoB,CAApB;;MAEA,IAAIS,OAAO,CAAPA,QAAAA,KAAJ,aAAA,EAAyC;QACrCL,OAAO,CAAPA,IAAAA,CAAcD,SAAS,CAATA,cAAAA,CAAdC,OAAcD,CAAdC;QACAE,aAAa,GAAGG,OAAO,CAAPA,QAAAA,GAAhBH,CAAAA;MACH;IACJ;EACJ;;EAED,OAAA,OAAA;AAzCJ,CAAA;AA4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAII,oBAAoB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAAA,UAAA,EAAuD;EAC9E,IAAIN,OAAO,GAAGP,cAAc,CAAA,aAAA,EAAA,MAAA,EAA5B,UAA4B,CAA5B;;EAEA,IAAI,CAACc,OAAO,CAAZ,SAAA,EAAyB;IACrBA,OAAO,CAAPA,SAAAA,GAAAA,EAAAA;EACH;EAED;AACJ;AACA;;;EACI,IAAIC,iBAAiB,GAAGD,OAAO,CAA/B,SAAA;;EAEA,KAAK,IAAIT,GAAG,GAAGE,OAAO,CAAPA,MAAAA,GAAf,CAAA,EAAmCF,GAAG,IAAtC,CAAA,EAA6CA,GAA7C,EAAA,EAAqD;IACjD,IAAIW,MAAM,GAAGT,OAAO,CAApB,GAAoB,CAApB;;IAEA,IAAI,CAACQ,iBAAiB,CAAtB,MAAsB,CAAtB,EAAmC;MAC/BA,iBAAiB,CAAjBA,MAAiB,CAAjBA,GAAAA,EAAAA;IACH;;IAEDA,iBAAiB,GAAGA,iBAAiB,CAArCA,MAAqC,CAArCA;EACH;;EAEDA,iBAAiB,CAAjBA,QAAAA,GAA6BL,UAAU,CAAvCK,QAAAA;EAEA,OAAA,iBAAA;AAxBJ,CAAA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIE,oBAAoB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAAA,UAAA,EAAuD;EAC9E,IAAIH,OAAO,CAAX,SAAA,EAAwB;IACpB,IAAIP,OAAO,GAAGP,cAAc,CAAA,aAAA,EAAA,MAAA,EAA5B,UAA4B,CAA5B;IAEA;AACR;AACA;;;IACQ,IAAIkB,cAAc,GAAGJ,OAAO,CAA5B,SAAA;IAEA,IAAIK,WAAW,GAAf,EAAA;;IAEA,KAAK,IAAId,GAAG,GAAGE,OAAO,CAAPA,MAAAA,GAAf,CAAA,EAAmCF,GAAG,GAAtC,CAAA,EAA4CA,GAA5C,EAAA,EAAoD;MAChD,IAAIW,MAAM,GAAGT,OAAO,CAApB,GAAoB,CAApB;MAEAW,cAAc,GAAGA,cAAc,CAA/BA,MAA+B,CAA/BA;;MAEA,IAAI,CAAJ,cAAA,EAAsB;QAClB;MACH;;MAEDC,WAAW,CAAXA,MAAW,CAAXA,GAAAA,cAAAA;IACH;IAED;AACR;AACA;;;IACQ,IAAA,cAAA,EAAqB;MACjBD,cAAc,GAAGJ,OAAO,CAAxBI,SAAAA;MAEA,IAAIE,IAAI,GAAGC,MAAM,CAANA,IAAAA,CAAX,WAAWA,CAAX;;MAEA,KAAK,IAAIV,IAAI,GAAGS,IAAI,CAAJA,MAAAA,GAAhB,CAAA,EAAiCT,IAAI,GAArC,CAAA,EAA2CA,IAA3C,EAAA,EAAoD;QAChD,IAAIW,GAAG,GAAGF,IAAI,CAAd,IAAc,CAAd;QAEAF,cAAc,GAAGC,WAAW,CAA5BD,GAA4B,CAA5BA;;QAEA,IAAIG,MAAM,CAANA,IAAAA,CAAAA,cAAAA,EAAAA,MAAAA,GAAJ,CAAA,EAA+C;UAC3C,IAAIE,SAAS,GAAGJ,WAAW,CAAEC,IAAI,CAAET,IAAI,GAAvC,CAAiC,CAAN,CAA3B;UAEA,OAAOY,SAAS,CAAhB,GAAgB,CAAhB;QACH;MACJ;IACJ;EACJ;AA3CL,CAAA;AA8CA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,aAAa,GAAG,UAAA,OAAA,EAAA,MAAA,EAA4B;EAC5C,IAAI,CAACV,OAAO,CAAZ,UAAA,EAA0B;IACtBA,OAAO,CAAPA,UAAAA,GAAAA,EAAAA;IACA,OAAA,IAAA;EACH;;EAED,OAAOA,OAAO,CAAPA,UAAAA,CAAP,MAAOA,CAAP;AANJ,CAAA;AASA;AACA;AACA;AACA;;;AACA,IAAIW,aAAa,GAAG,YAAW;EAC3B,IAAA,SAAA;EAEA,IAAIC,YAAY,GAAGC,SAAS,CAATA,GAAAA,CAAnB,SAAmBA,CAAnB;;EAEA,IAAA,YAAA,EAAmB;IACf,IAAI;MACAC,SAAS,GAAGC,IAAI,CAAJA,KAAAA,CAAZD,YAAYC,CAAZD;;MAEA,IAAIA,SAAS,CAATA,aAAAA,KAAJ,iBAAA,EAAoD;QAChDA,SAAS,GAATA,IAAAA;MACH;IALL,CAAA,CAME,OAAA,EAAA,EAAa,CACX;IACH;EACJ;;EAED,IAAI,CAAJ,SAAA,EAAiB;IACbA,SAAS,GAAG;MACRE,aAAa,EAAEnC;IADP,CAAZiC;EAGH;;EAED,OAAA,SAAA;AAvBJ,CAAA;AA0BA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI1B,gBAAgB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAkC;EACrD,IAAI6B,QAAQ,GAAGC,aAAa,CAAbA,SAAAA,CAAAA,KAAAA,CAAf,MAAeA,CAAf;EAEAC,MAAM,CAAA,QAAA,EAANA,4BAAM,CAANA;EAEA,IAAIhC,cAAc,GAAG+B,aAAa,CAAbA,aAAAA,CAA6BD,QAAQ,CAA1D,YAAqBC,CAArB;EAEAC,MAAM,CAAA,cAAA,EAANA,iCAAM,CAANA;EAEA,OAAA,cAAA;AATJ,CAAA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,UAAU,GAAG,UAAA,aAAA,EAAA,MAAA,EAAkC;EAC/C,IAAIjC,cAAc,GAAGC,gBAAgB,CAAA,aAAA,EAArC,MAAqC,CAArC;;EAEA,OAAOD,cAAc,CAAdA,WAAAA,GAA6BK,SAAS,CAATA,cAAAA,CAA0BL,cAAc,CAArEA,WAA6BK,CAA7BL,GAAP,aAAA;AAHJ,CAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIkC,sBAAsB,GAAG,UAAA,SAAA,EAAA,aAAA,EAAA,MAAA,EAA6C;EACtEF,MAAM,CAAA,aAAA,EAANA,uBAAM,CAANA;EACAA,MAAM,CAAED,aAAa,CAAbA,SAAAA,CAAF,OAAA,EAANC,uBAAM,CAANA;EACAA,MAAM,CAAA,MAAA,EAANA,kBAAM,CAANA;EAEA,IAAIG,eAAe,GAAGJ,aAAa,CAAbA,SAAAA,CAAtB,OAAA;EAEA,IAAIK,QAAQ,GAAGD,eAAe,CAAfA,OAAAA,CAAf,YAAeA,CAAf;;EAEA,IAAIC,QAAQ,KAAK,CAAjB,CAAA,EAAsB;IAClBD,eAAe,GAAGA,eAAe,CAAfA,SAAAA,CAA2BC,QAAQ,GAAGzC,YAAY,CAApEwC,MAAkBA,CAAlBA;EACH;;EAED,IAAI,CAACR,SAAS,CAAd,eAAc,CAAd,EAAoC;IAChCA,SAAS,CAATA,eAAS,CAATA,GAAAA,EAAAA;EACH;;EAED,IAAI,CAACA,SAAS,CAATA,eAAS,CAATA,CAAL,MAAKA,CAAL,EAA8C;IAC1CA,SAAS,CAATA,eAAS,CAATA,CAAAA,MAAAA,IAAAA,EAAAA;EACH;;EAED,OAAOA,SAAS,CAATA,eAAS,CAATA,CAAP,MAAOA,CAAP;AArBJ,CAAA;AAwBA;AACA;AACA;AACA;AACA;;;AACA,IAAIU,sBAAsB,GAAG,CAAC,CAAD,QAAA,CAAY,YAAW;EAChD;AACJ;AACA;AACA;EACI,IAAI,CAACC,CAAC,CAADA,OAAAA,CAAL,yBAAKA,CAAL,EAA8C;IAC1C,IAAIC,iBAAiB,GAArB,yBAAA;IAEAzC,yBAAyB,GAAzBA,EAAAA;;IAEA,IAAI6B,SAAS,GAAGH,aAAhB,EAAA;;IAEAc,CAAC,CAADA,OAAAA,CAAAA,iBAAAA,EAA8B,UAAA,GAAA,EAAgB;MAC1C;AACZ;AACA;AACA;MACY,IAAI,CAACE,GAAG,CAAHA,aAAAA,CAAL,WAAKA,EAAL,EAAuC;QACnC,IAAIC,SAAS,GAAGP,sBAAsB,CAAA,SAAA,EAAaM,GAAG,CAAhB,aAAA,EAAgCA,GAAG,CAAzE,MAAsC,CAAtC;;QAEA,IAAIE,MAAM,GAAGT,UAAU,CAAEO,GAAG,CAAL,aAAA,EAAqBA,GAAG,CAA/C,MAAuB,CAAvB;;QAEAC,SAAS,CAATA,MAAS,CAATA,GAAsBD,GAAG,CAAzBC,OAAAA;MACH;IAXLH,CAAAA;;IAcA,IAAA,4BAAA,EAAmC;MAC/BK,MAAM,CAANA,IAAAA,CAAAA,qBAAAA;IACH;;IAEDjB,SAAS,CAATA,OAAAA,CAAAA,SAAAA,EAA8BE,IAAI,CAAJA,SAAAA,CAA9BF,SAA8BE,CAA9BF;EACH;AA/BwB,CAAA,EAAA,GAAA,EAgCrB;EACJkB,OAAO,EADH,KAAA;EAEJC,QAAQ,EAFJ,IAAA;EAGJC,OAAO,EAAE;AAHL,CAhCqB,CAA7B;AAsCA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,mBAAmB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAA2C;EACjE,IAAIL,MAAM,GAAGT,UAAU,CAAA,aAAA,EAAvB,MAAuB,CAAvB;;EAEAnC,yBAAyB,CAAzBA,MAAyB,CAAzBA,GAAsC;IAClCiC,aAAa,EADqB,aAAA;IAElCiB,MAAM,EAF4B,MAAA;IAGlCnC,OAAO,EAAEA;EAHyB,CAAtCf;;EAMAuC,sBAAsB;AAT1B,CAAA;AAYA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIY,OAAO,GAAX,EAAA;AAEA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,cAAc,GAAG,UAAA,aAAA,EAAA,MAAA,EAAkC;EAC1D;AACJ;AACA;AACA;EACI,IAAIrC,OAAO,GAAGoC,OAAO,CAAPA,iBAAAA,CAAAA,aAAAA,EAAd,MAAcA,CAAd;EAEApC,OAAO,CAAPA,UAAAA,GAAAA,EAAAA;EACAA,OAAO,CAAPA,SAAAA,GAR0D,EAQ1DA,CAR0D,CAU1D;;EACAkC,mBAAmB,CAAA,aAAA,EAAA,MAAA,EAAnBA,OAAmB,CAAnBA;AAXG,CAAA;AAcP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,iBAAiB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,WAAA,EAA+C;EAC1E;AACJ;AACA;AACA;EACI,IAAItC,OAAO,GAAGoC,OAAO,CAAPA,iBAAAA,CAAAA,aAAAA,EAAd,MAAcA,CAAd;EAEA,IAAIG,kBAAkB,GAAtB,EAAA;;EAEA,IAAI,CAACd,CAAC,CAADA,OAAAA,CAAWzB,OAAO,CAAvB,UAAKyB,CAAL,EAAuC;IACnCA,CAAC,CAADA,OAAAA,CAAAA,WAAAA,EAAwB,UAAA,QAAA,EAAqB;MACzC,IAAA,UAAA,EAAiB;QACbc,kBAAkB,CAAE/C,SAAS,CAATA,cAAAA,CAApB+C,QAAoB/C,CAAF,CAAlB+C,GAA6D;UACzDC,QAAQ,EADiD,IAAA;UAEzDC,YAAY,EAAEC;QAF2C,CAA7DH;MADJ,CAAA,MAKO;QACH,IAAII,SAAS,GAAG3C,OAAO,CAAPA,UAAAA,CAAoBR,SAAS,CAATA,cAAAA,CAApC,QAAoCA,CAApBQ,CAAhB;;QAEA,IAAI2C,SAAS,IAAIA,SAAS,CAATA,SAAAA,KAAjB,YAAA,EAAwD;UACpDJ,kBAAkB,CAAE/C,SAAS,CAATA,cAAAA,CAApB+C,QAAoB/C,CAAF,CAAlB+C,GAA6D;YACzDC,QAAQ,EADiD,IAAA;YAEzDC,YAAY,EAAEC;UAF2C,CAA7DH;QAIH;MACJ;IAfLd,CAAAA;EAiBH;;EAED,OAAA,kBAAA;AA7BG,CAAA;AAgCP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAImB,iBAAiB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAkC;EAC7D,IAAIzD,cAAc,GAAGC,gBAAgB,CAAA,aAAA,EAArC,MAAqC,CAArC;;EAEA,IAAI,CAACD,cAAc,CAAnB,OAAA,EAA8B;IAC1B,IAAI2B,SAAS,GAAGH,aAAhB,EAAA;;IAEA,IAAIiB,SAAS,GAAGP,sBAAsB,CAAA,SAAA,EAAA,aAAA,EAAtC,MAAsC,CAAtC;;IAEA,IAAIQ,MAAM,GAAGT,UAAU,CAAA,aAAA,EAAvB,MAAuB,CAAvB;;IAEA,IAAA,4BAAA,EAAmC;MAC/BU,MAAM,CAANA,IAAAA,CAAa,+BAAbA,MAAAA;IACH;;IAED,IAAI,CAACF,SAAS,CAAd,MAAc,CAAd,EAA2B;MACvBA,SAAS,CAATA,MAAS,CAATA,GAAsB;QAClBiB,SAAS,EADS,EAAA;QAElBC,UAAU,EAAE;MAFM,CAAtBlB;IAIH;;IAEDzC,cAAc,CAAdA,OAAAA,GAAyByC,SAAS,CAlBR,MAkBQ,CAAlCzC,CAlB0B,CAoB1B;IACA;IACA;IACA;IACA;IACA;EACH;;EAED,OAAOA,cAAc,CAArB,OAAA;AA/BG,CAAA;AAkCP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAI4D,cAAc,GAAG,UAAA,OAAA,EAAA,UAAA,EAAgC;EACxD,IAAI/C,OAAO,CAAX,UAAA,EAAyB;IACrB,IAAI2C,SAAS,GAAG3C,OAAO,CAAPA,UAAAA,CAAoBR,SAAS,CAATA,cAAAA,CAApC,UAAoCA,CAApBQ,CAAhB;IAEA,OAAO2C,SAAS,IAAIA,SAAS,CAATA,SAAAA,KAApB,YAAA;EACH;;EAED,OAAA,KAAA;AAPG,CAAA;AAUP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIK,gBAAgB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,UAAA,EAA8C;EACxE;AACJ;AACA;EACI,IAAIhD,OAAO,GAAGoC,OAAO,CAAPA,iBAAAA,CAAAA,aAAAA,EAAd,MAAcA,CAAd;;EAEArC,oBAAoB,CAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAApBA,UAAoB,CAApBA;;EAEA,IAAI4C,SAAS,GAAGjC,aAAa,CAAA,OAAA,EAAWlB,SAAS,CAATA,cAAAA,CAAxC,UAAwCA,CAAX,CAA7B;;EAEA,IAAImD,SAAS,IAAIA,SAAS,CAA1B,SAAA,EAAuC;IACnC,OAAOA,SAAS,CAAhB,SAAA;;IAEA,IAAIlB,CAAC,CAADA,OAAAA,CAAJ,SAAIA,CAAJ,EAA6B;MACzB,OAAOzB,OAAO,CAAPA,UAAAA,CAAoBR,SAAS,CAATA,cAAAA,CAA3B,UAA2BA,CAApBQ,CAAP;;MAEAG,oBAAoB,CAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAApBA,UAAoB,CAApBA;IACH;;IAED+B,mBAAmB,CAAA,aAAA,EAAA,MAAA,EAAnBA,OAAmB,CAAnBA;EACH;AApBE,CAAA;AAuBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIe,eAAe,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,UAAA,EAA8C;EACvE;AACJ;AACA;EACI,IAAIjD,OAAO,GAAGoC,OAAO,CAAPA,iBAAAA,CAAAA,aAAAA,EAAd,MAAcA,CAAd;;EAEArC,oBAAoB,CAAA,aAAA,EAAA,MAAA,EAAA,OAAA,EAApBA,UAAoB,CAApBA;;EAEA,IAAI4C,SAAS,GAAGjC,aAAa,CAAA,OAAA,EAAWlB,SAAS,CAATA,cAAAA,CAAxC,UAAwCA,CAAX,CAA7B;;EAEA,IAAI,CAAJ,SAAA,EAAiB;IACbQ,OAAO,CAAPA,UAAAA,CAAoBR,SAAS,CAATA,cAAAA,CAApBQ,UAAoBR,CAApBQ,IAA+D;MAC3DkD,SAAS,EAAEvE;IADgD,CAA/DqB;;IAIAkC,mBAAmB,CAAA,aAAA,EAAA,MAAA,EAAnBA,OAAmB,CAAnBA;EALJ,CAAA,MAMO,IAAIS,SAAS,CAATA,SAAAA,KAAJ,YAAA,EAA2C;IAC9CA,SAAS,CAATA,SAAAA,GAAAA,YAAAA;;IAEAT,mBAAmB,CAAA,aAAA,EAAA,MAAA,EAAnBA,OAAmB,CAAnBA;EACH;AApBE,CAAA;AAuBP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIiB,gBAAgB,GAAG,UAAA,aAAA,EAAA,MAAA,EAAA,UAAA,EAA8C;EACxE,IAAI1D,OAAO,GAAGP,cAAc,CAAA,aAAA,EAAA,MAAA,EAA5B,UAA4B,CAA5B;;EAEA,IAAIc,OAAO,GAAGoC,OAAO,CAAPA,iBAAAA,CAAAA,aAAAA,EAAd,MAAcA,CAAd;;EAEA,IAAI,CAACpC,OAAO,CAAR,UAAA,IAAuByB,CAAC,CAADA,UAAAA,CAAczB,OAAO,CAArByB,UAAAA,EAAAA,OAAAA,EAAAA,MAAAA,KAA3B,CAAA,EAAsF;IAClFzB,OAAO,CAAPA,UAAAA,GAAAA,OAAAA;;IAEAkC,mBAAmB,CAAA,aAAA,EAAA,MAAA,EAAnBA,OAAmB,CAAnBA;EACH;AATE,CAAA;AAYPnD,4BAA4B,GAAGqE,YAAY,CAAZA,gBAAAA,GAAAA,qBAAAA,KAA/BrE,EAAAA;AAEAqD,OAAO,GAAG;EAAA,cAAA;EAAA,iBAAA;EAAA,iBAAA;EAAA,cAAA;EAAA,gBAAA;EAAA,eAAA;EAONe;AAPM,CAAVf;AASA,eAAA,OAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).\n *\n * @module js/awTableStateService\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport localStrg from 'js/localStorage';\nimport uwUtilSvc from './uwUtilService';\n\n/**\n * {String} Expansion state of a node when expanded\n */\nvar _EXPAND_FULL = 'full';\n\n/**\n * {String} The primary topic (i.e. key) used to store state information.\n */\nvar _LS_TOPIC = 'awTreeTableState';\n\n/**\n * {String} The current local storage schema version accepted.\n */\nvar _LS_TOPIC_VERSION = '1.0.1';\n\n/**\n * {String} A common location that is included in the declViewModel's path that needs to be removed before reporting\n * the ID of the declViewModel's ID.\n */\nvar _VM_DIR_NAME = '/viewmodel/';\n\n/**\n * {Boolean} TRUE if various activities of this services should be logged.\n */\nvar _debug_logTableStateActivity = false;\n\n/**\n * {Boolean} TRUE if all levels should be expanded (as they become visible).\n */\nvar _expandAll = false;\n\n/**\n * {Object} The keys of this object are the unique 'roots' requesting saves.\n */\nvar _pendingSaveStateRequests = {};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node to find the path to all the 'parent' nodes up the levels\n *            currently in the viewModelCollection of the associated dataProvider.\n *\n * @return {StringArray} An array of node IDs that identify the given node (as element [0]) in its hierarchy up to\n *         the 'top' node (as element [length-1]).\n */\nvar _buildNodePath = function( declViewModel, gridId, targetNode ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    /**\n     * Find target\n     */\n    var vmRows = uwDataProvider.getViewModelCollection().getLoadedViewModelObjects();\n\n    var targetNdx = -1;\n\n    for( var ndx = 0; ndx < vmRows.length; ndx++ ) {\n        if( uwUtilSvc.getEvaluatedId( vmRows[ ndx ] ) === uwUtilSvc.getEvaluatedId( targetNode ) ) {\n            targetNdx = ndx;\n            break;\n        }\n    }\n\n    if( targetNdx < 0 ) {\n        return [];\n    }\n\n    /**\n     * Build path by looking 'up' the rows\n     */\n    var pathIDs = [ uwUtilSvc.getEvaluatedId( targetNode ) ];\n\n    var currRowNdx = targetNdx;\n    var currNextLevel = targetNode.levelNdx - 1;\n\n    while( currNextLevel > -1 ) {\n        for( var ndx2 = currRowNdx - 1; ndx2 >= 0; ndx2-- ) {\n            //\n            var currRow = vmRows[ ndx2 ];\n\n            if( currRow.levelNdx === currNextLevel ) {\n                pathIDs.push( uwUtilSvc.getEvaluatedId( currRow ) );\n                currNextLevel = currRow.levelNdx - 1;\n            }\n        }\n    }\n\n    return pathIDs;\n};\n\n/**\n * Return the structure object of the given 'target' node (and set with the 'target' 'childNdx') and create any\n * missing 'parent' structure nodes (if necessary).\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to return the object for.\n *\n * @return {Object} The structure object of the given 'target' node (and set with the 'target' 'childNdx').\n */\nvar _assureStructureNode = function( declViewModel, gridId, ttState, targetNode ) {\n    var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n    if( !ttState.structure ) {\n        ttState.structure = {};\n    }\n\n    /**\n     * Start at the top and work down based on the 'target' path.\n     */\n    var currStructureNode = ttState.structure;\n\n    for( var ndx = pathIDs.length - 1; ndx >= 0; ndx-- ) {\n        var pathID = pathIDs[ ndx ];\n\n        if( !currStructureNode[ pathID ] ) {\n            currStructureNode[ pathID ] = {};\n        }\n\n        currStructureNode = currStructureNode[ pathID ];\n    }\n\n    currStructureNode.childNdx = targetNode.childNdx;\n\n    return currStructureNode;\n};\n\n/**\n * Delete the structure object of the given 'target' node.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {ViewModelTreeNode} targetNode - The node to delete the state for.\n */\nvar _removeStructureNode = function( declViewModel, gridId, ttState, targetNode ) {\n    if( ttState.structure ) {\n        var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n        /**\n         * Start at the top and work down based on the 'target' path.\n         */\n        var currParentNode = ttState.structure;\n\n        var parentNodes = {};\n\n        for( var ndx = pathIDs.length - 1; ndx > 0; ndx-- ) {\n            var pathID = pathIDs[ ndx ];\n\n            currParentNode = currParentNode[ pathID ];\n\n            if( !currParentNode ) {\n                break;\n            }\n\n            parentNodes[ pathID ] = currParentNode;\n        }\n\n        /**\n         * Starting at the lowest level, delete any structure objects that are not empty.\n         */\n        if( currParentNode ) {\n            currParentNode = ttState.structure;\n\n            var keys = Object.keys( parentNodes );\n\n            for( var ndx2 = keys.length - 1; ndx2 > 1; ndx2-- ) {\n                var key = keys[ ndx2 ];\n\n                currParentNode = parentNodes[ key ];\n\n                if( Object.keys( currParentNode ).length < 2 ) {\n                    var immParent = parentNodes[ keys[ ndx2 - 1 ] ];\n\n                    delete immParent[ key ];\n                }\n            }\n        }\n    }\n};\n\n/**\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n * @param {String} nodeId - ID of the node to return the object for,\n *\n * @return {Object} The state object associated with the given node (or NULL if no state exists for it.\n */\nvar _getNodeState = function( ttState, nodeId ) {\n    if( !ttState.nodeStates ) {\n        ttState.nodeStates = {};\n        return null;\n    }\n\n    return ttState.nodeStates[ nodeId ];\n};\n\n/**\n * @return {Object} The top-level object (loaded from local storage) containing the state information for all tables\n *         currently being tracked.\n */\nvar _getAllStates = function() {\n    var allStates;\n\n    var allStatesStr = localStrg.get( _LS_TOPIC );\n\n    if( allStatesStr ) {\n        try {\n            allStates = JSON.parse( allStatesStr );\n\n            if( allStates.schemaVersion !== _LS_TOPIC_VERSION ) {\n                allStates = null;\n            }\n        } catch ( ex ) {\n            // Handled below\n        }\n    }\n\n    if( !allStates ) {\n        allStates = {\n            schemaVersion: _LS_TOPIC_VERSION\n        };\n    }\n\n    return allStates;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {UwDataProvider} The current dataProvider associated with the given table.\n */\nvar _getDataProvider = function( declViewModel, gridId ) {\n    var declGrid = declViewModel._internal.grids[ gridId ];\n\n    assert( declGrid, 'Table definition not found' );\n\n    var uwDataProvider = declViewModel.dataProviders[ declGrid.dataProvider ];\n\n    assert( uwDataProvider, 'Table dataProvider is not valid' );\n\n    return uwDataProvider;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {String} The unique ID of the view model object that 'owns' the table's data (i.e. The ID of an assembly)\n *         (or 'nonTreeRoot' if there is no 'topNode' set on the associated dataProvider).\n */\nvar _getRootId = function( declViewModel, gridId ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    return uwDataProvider.topTreeNode ? uwUtilSvc.getEvaluatedId( uwDataProvider.topTreeNode ) : 'nonTreeRoot';\n};\n\n/**\n * @param {Object} allStates - The top-level object (loaded from local storage) containing the state information for\n *            all tables currently being tracked.\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the state for the given declModel/declGrid.\n */\nvar _getTreeTableGridState = function( allStates, declViewModel, gridId ) {\n    assert( declViewModel, 'Invalid DeclViewModel' );\n    assert( declViewModel._internal.panelId, 'Invalid DeclViewModel' );\n    assert( gridId, 'Invalid table ID' );\n\n    var declViewModelId = declViewModel._internal.panelId;\n\n    var vmDirNdx = declViewModelId.indexOf( _VM_DIR_NAME );\n\n    if( vmDirNdx !== -1 ) {\n        declViewModelId = declViewModelId.substring( vmDirNdx + _VM_DIR_NAME.length );\n    }\n\n    if( !allStates[ declViewModelId ] ) {\n        allStates[ declViewModelId ] = {};\n    }\n\n    if( !allStates[ declViewModelId ][ gridId ] ) {\n        allStates[ declViewModelId ][ gridId ] = {};\n    }\n\n    return allStates[ declViewModelId ][ gridId ];\n};\n\n/**\n * This save state function is 'debounced' to only save data after updated 'quiets down' for ~2 second.\n *\n * @private\n */\nvar _pingSaveStateDebounce = _.debounce( function() {\n    /**\n     * Check if we have pending requests<BR>\n     * If so: Process the pending requests.\n     */\n    if( !_.isEmpty( _pendingSaveStateRequests ) ) {\n        var saveStateRequests = _pendingSaveStateRequests;\n\n        _pendingSaveStateRequests = {};\n\n        var allStates = _getAllStates();\n\n        _.forEach( saveStateRequests, function( req ) {\n            /**\n             * Since a ping can time out *after* a declViewModel has been destroyed, check if the pending request\n             * has a valid declViewModel.\n             */\n            if( !req.declViewModel.isDestroyed() ) {\n                var gridState = _getTreeTableGridState( allStates, req.declViewModel, req.gridId );\n\n                var rootId = _getRootId( req.declViewModel, req.gridId );\n\n                gridState[ rootId ] = req.ttState;\n            }\n        } );\n\n        if( _debug_logTableStateActivity ) {\n            logger.info( 'Saving table states' );\n        }\n\n        localStrg.publish( _LS_TOPIC, JSON.stringify( allStates ) );\n    }\n}, 500, {\n    maxWait: 10000,\n    trailing: true,\n    leading: false\n} );\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {Object} ttState - An object holding the state for the given declModel/declGrid.\n */\nvar _saveTreeTableState = function( declViewModel, gridId, ttState ) {\n    var rootId = _getRootId( declViewModel, gridId );\n\n    _pendingSaveStateRequests[ rootId ] = {\n        declViewModel: declViewModel,\n        gridId: gridId,\n        ttState: ttState\n    };\n\n    _pingSaveStateDebounce();\n};\n\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service Objects<BR>\n * -------------------------------------------------------------------------<BR>\n */\n/**\n * -------------------------------------------------------------------------<BR>\n * Define Service API<BR>\n * -------------------------------------------------------------------------<BR>\n */\nvar exports = {};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n */\nexport let clearAllStates = function( declViewModel, gridId ) {\n    /**\n     * Check if any of the new 'child' nodes are known to be expanded.<BR>\n     * If so: Setup to async expand them later.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    ttState.nodeStates = {};\n    ttState.structure = {};\n\n    // clear from local storage\n    _saveTreeTableState( declViewModel, gridId, ttState );\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNodeArray} nodesToTest - The nodes to test expansion status for.\n *\n * @return {Map} An object that maps a tree node ID to a data object with the following properties for each of the\n *         given nodes that are currently expanded:\n *\n * <pre>\n * {\n *     expanded: true,\n *     nodeToExpand: [node from nodesToTest]\n * }\n * </pre>\n */\nexport let findExpandedNodes = function( declViewModel, gridId, nodesToTest ) {\n    /**\n     * Check if any of the new 'child' nodes are known to be expanded.<BR>\n     * If so: Setup to async expand them later.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    var expandNodeRequests = {};\n\n    if( !_.isEmpty( ttState.nodeStates ) ) {\n        _.forEach( nodesToTest, function( testNode ) {\n            if( _expandAll ) {\n                expandNodeRequests[ uwUtilSvc.getEvaluatedId( testNode ) ] = {\n                    expanded: true,\n                    nodeToExpand: testNode\n                };\n            } else {\n                var nodeState = ttState.nodeStates[ uwUtilSvc.getEvaluatedId( testNode ) ];\n\n                if( nodeState && nodeState.expansion === _EXPAND_FULL ) {\n                    expandNodeRequests[ uwUtilSvc.getEvaluatedId( testNode ) ] = {\n                        expanded: true,\n                        nodeToExpand: testNode\n                    };\n                }\n            }\n        } );\n    }\n\n    return expandNodeRequests;\n};\n\n/**\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n *\n * @return {Object} An object holding the table state for the given declModel/declGrid.\n */\nexport let getTreeTableState = function( declViewModel, gridId ) {\n    var uwDataProvider = _getDataProvider( declViewModel, gridId );\n\n    if( !uwDataProvider.ttState ) {\n        var allStates = _getAllStates();\n\n        var gridState = _getTreeTableGridState( allStates, declViewModel, gridId );\n\n        var rootId = _getRootId( declViewModel, gridId );\n\n        if( _debug_logTableStateActivity ) {\n            logger.info( 'Reading table states for: ' + rootId );\n        }\n\n        if( !gridState[ rootId ] ) {\n            gridState[ rootId ] = {\n                structure: {},\n                nodeStates: {}\n            };\n        }\n\n        uwDataProvider.ttState = gridState[ rootId ];\n\n        // <pre>\n        // Possible fix for scroll to problem...investigate later w/ related changes in 'aw.table.controller'.\n        // if( uwDataProvider.ttState ) {\n        //     uwDataProvider.isFocusedLoad = true;\n        // }\n        // </pre>\n    }\n\n    return uwDataProvider.ttState;\n};\n\n/**\n * @param {Object} ttState - (Optional) An object holding the table state for a given declModel/declGrid.\n * @param {ViewModelTreeNodeArray} nodeToTest - The nodes to test status for.\n *\n * @return {Boolean} TRUE if the given node is currently expanded.\n */\nexport let isNodeExpanded = function( ttState, nodeToTest ) {\n    if( ttState.nodeStates ) {\n        var nodeState = ttState.nodeStates[ uwUtilSvc.getEvaluatedId( nodeToTest ) ];\n\n        return nodeState && nodeState.expansion === _EXPAND_FULL;\n    }\n\n    return false;\n};\n\n/**\n * Clear the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just collapsed.\n */\nexport let saveRowCollapsed = function( declViewModel, gridId, targetNode ) {\n    /**\n     * Forget we are expanding this node.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    _assureStructureNode( declViewModel, gridId, ttState, targetNode );\n\n    var nodeState = _getNodeState( ttState, uwUtilSvc.getEvaluatedId( targetNode ) );\n\n    if( nodeState && nodeState.expansion ) {\n        delete nodeState.expansion;\n\n        if( _.isEmpty( nodeState ) ) {\n            delete ttState.nodeStates[ uwUtilSvc.getEvaluatedId( targetNode ) ];\n\n            _removeStructureNode( declViewModel, gridId, ttState, targetNode );\n        }\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n/**\n * Update the persisted expansion state of the given node .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node just expanded.\n */\nexport let saveRowExpanded = function( declViewModel, gridId, targetNode ) {\n    /**\n     * Remember we are expanding this node.\n     */\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    _assureStructureNode( declViewModel, gridId, ttState, targetNode );\n\n    var nodeState = _getNodeState( ttState, uwUtilSvc.getEvaluatedId( targetNode ) );\n\n    if( !nodeState ) {\n        ttState.nodeStates[ uwUtilSvc.getEvaluatedId( targetNode ) ] = {\n            expansion: _EXPAND_FULL\n        };\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    } else if( nodeState.expansion !== _EXPAND_FULL ) {\n        nodeState.expansion = _EXPAND_FULL;\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n/**\n * Update the persisted current top row in the table. .\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel where the table is defined.\n * @param {String} gridId - The ID of the declGrid used to define the table.\n * @param {ViewModelTreeNode} targetNode - The node of the currently visible top row of the table.\n */\nexport let saveScrollTopRow = function( declViewModel, gridId, targetNode ) {\n    var pathIDs = _buildNodePath( declViewModel, gridId, targetNode );\n\n    var ttState = exports.getTreeTableState( declViewModel, gridId );\n\n    if( !ttState.topRowPath || _.difference( ttState.topRowPath, pathIDs ).length !== 0 ) {\n        ttState.topRowPath = pathIDs;\n\n        _saveTreeTableState( declViewModel, gridId, ttState );\n    }\n};\n\n_debug_logTableStateActivity = browserUtils.getUrlAttributes().logTableStateActivity === '';\n\nexports = {\n    clearAllStates,\n    findExpandedNodes,\n    getTreeTableState,\n    isNodeExpanded,\n    saveRowCollapsed,\n    saveRowExpanded,\n    saveScrollTopRow\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}