{"ast":null,"code":"// Copyright (c) 2022 Siemens\n\n/**\n * @module js/utils\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport AwParseService from 'js/awParseService';\nimport workspaceUtils from 'js/workspaceUtils';\n/**\n * Polyfill to match dynamic import result back to ES5 supported module\n *\n * @param {Object} obj - function to evaluate after loading the dependencies.\n * @returns {Object} ES5 module object\n */\n\nexport function interopES6Default(obj) {\n  // for case like appCtxSerivce, for unknown reason, it has __esModule but no default\n  // In the case we will use module itself\n  // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n  // NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion\n  // it makes that we defined the moduleServiceNameToInject at top level for that practice, not class\n  // level.\n  // It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice\n  // the return is inconsistent for requireJS API:\n  // - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }\n  // - class without moduleServiceNameToInject => svcClass\n  // - non class => it doen't matter since module === module.default\n  // webpack and non-webpack mode will be same snce they have the same _interopES6Default\n  //\n  // Long term solution\n  // - stop supporting non-webpack build\n  // - see if we can remove this _interopES6Default when use dynamic import\n  //\n  // Short term solution (aw4.3)\n  // - Document this apperance difference for class service\n  // - it should be a minor minor case in regular practice\n  return obj && obj.__esModule && obj.default && !obj.moduleServiceNameToInject ? obj.default : obj;\n}\n/**\n * Set the \"isToggle\" flag on any commands that have a handler with a \"selectWhen\" condition\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\nfunction updateIsToggleFlag(viewModelJson) {\n  if (viewModelJson.commands) {\n    const cmdId2handlers = {};\n    let handlers = [];\n\n    for (const handler of Object.values(viewModelJson.commandHandlers)) {\n      handlers = cmdId2handlers[handler.id];\n\n      if (!handlers) {\n        handlers = [];\n        cmdId2handlers[handler.id] = handlers;\n      }\n\n      handlers.push(handler);\n    }\n\n    for (const cmdId in viewModelJson.commands) {\n      const command = viewModelJson.commands[cmdId]; // The handlers for the given command\n\n      handlers = cmdId2handlers[cmdId] || []; // If any handler for this command has selectWhen the command is a toggle command\n\n      command.isToggle = !command.isGroup && !command.isShuttle && handlers.reduce(function (acc, handler) {\n        return acc || handler.hasOwnProperty('selectWhen');\n      }, false) || false;\n    }\n  }\n}\n/**\n * @param {Object} objValue - destination object\n * @param {Object} srcValue source object\n * @return {Object|undefined} modified destination object\n */\n\n\nfunction mergeCustomizer(objValue, srcValue) {\n  if (_.isArray(objValue)) {\n    return objValue.concat(srcValue);\n  }\n}\n/**\n * @param {Object} obj1 object 1\n * @param {Object} obj2 object 2\n * @param {Object|null} check - optional checker object\n * @param {Number|null} depth - depth of merge\n * @type {module.exports.merge}\n */\n\n\nconst merge = (obj1, obj2, check, depth) => {\n  if (!depth) {\n    depth = 1;\n  }\n\n  if (_.isNull(obj2)) {// nothing to merge\n  } else if (_.isNull(obj1)) {\n    logger.error('Null object to merge!');\n  } else if (_.isArray(obj1) && _.isArray(obj2)) {\n    for (let element of obj2) {\n      // If there was a 'identity' test for the elements, we might be able to merge objects in the array.\n      if (!obj1.includes(element)) {\n        obj1.push(_.cloneDeep(element));\n      }\n    }\n  } else if (_.isObject(obj1) && _.isObject(obj2)) {\n    if (!check) {\n      _.mergeWith(obj1, obj2, mergeCustomizer);\n    } else {\n      for (const key in obj2) {\n        const field = obj2[key];\n\n        if (obj1.hasOwnProperty(key)) {\n          if (check) {\n            check.path.push(key);\n\n            if (check.uniqueDepth !== undefined && check.uniqueDepth === depth && !check.path.includes('i18n')) {\n              throw new Error('Name conflict in ' + check.file + '.json path=' + check.path.join('.') + ' for module ' + check.moduleName + ' (2nd occurrence)!');\n            }\n          }\n\n          merge(obj1[key], field, check, depth + 1);\n\n          if (check) {\n            check.path.pop();\n          }\n        } else {\n          obj1[key] = _.cloneDeep(field);\n        }\n      }\n    }\n  } else if (_.isArray(obj1) || _.isArray(obj2)) {\n    throw new Error('Invalid array merge!');\n  } else if (_.isObject(obj1) || _.isObject(obj2)) {\n    throw new Error('Invalid object merge!');\n  }\n};\n\nexport const processWorkspaces = (solutionDef, workspacesInfo) => {\n  let workspaceData = {};\n  const workspaceArray = solutionDef.workspaces;\n  let filteredWorkspaceContributions = [];\n\n  if (solutionDef && solutionDef.workspaces) {\n    let filteredWorkspaces = workspacesInfo.filter(function (workspaceInfo) {\n      if (/workspace_contribution.*/.test(workspaceInfo.name)) {\n        filteredWorkspaceContributions.push(workspaceInfo);\n        return false;\n      }\n\n      return true;\n    });\n\n    for (const data of Object.values(filteredWorkspaces)) {\n      const workspace = data.contents;\n\n      if (_.includes(workspaceArray, workspace.workspaceId) || workspace.scope === 'Internal' || workspace.includeInSolutions && workspace.includeInSolutions.includes(solutionDef.solutionId)) {\n        workspaceData[workspace.workspaceId] = workspace;\n      }\n    } //now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData\n\n\n    for (const data of Object.values(filteredWorkspaceContributions)) {\n      const workspace = data.contents;\n\n      if (workspaceData[workspace.workspaceId] !== undefined) {\n        _.mergeWith(workspaceData[workspace.workspaceId], workspace, function customizer(objValue, srcValue) {\n          if (_.isArray(objValue)) {\n            _.each(srcValue, function (item) {\n              if (objValue.indexOf(item) < 0) {\n                objValue.push(item);\n              }\n            });\n\n            return objValue;\n          }\n        });\n      }\n    }\n  }\n\n  return workspaceData;\n};\n/**\n * Add all the configurations from the exclusive kits to the workspaces.\n * @param {object} WorkspacesInfo all workspaces\n * @param {Object} allKitsJson - all kits\n * @param {Object} allStatesJson - all states\n */\n\nexport const processExclusiveKits = (WorkspacesInfo, allKitsJson, allModules2StatesJson) => {\n  for (var workspaceObject of Object.values(WorkspacesInfo)) {\n    workspaceUtils.resolveKitDefinitions(workspaceObject.contents, allKitsJson, allModules2StatesJson);\n  }\n\n  return;\n};\nexport const processJsonImports = function (name, importResArray) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let lazy = arguments.length > 3 ? arguments[3] : undefined;\n  let res = {};\n  let lazyLoadPromises = []; // have to put it here because of clojure\n\n  const reduceJsonContents = (sum, cur) => {\n    const [fullStr, moduleName, file] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n    merge(sum, cur.contents, config.uniqueDepth && {\n      moduleName,\n      file,\n      path: [],\n      uniqueDepth: config.uniqueDepth\n    });\n    return sum;\n  };\n\n  if (lazy) {\n    for (const imp of importResArray) {\n      if (typeof imp.contents.then === 'function') {\n        lazyLoadPromises.push(imp.contents.then(contents => {\n          return {\n            contents: interopES6Default(contents),\n            name: imp.name\n          };\n        }));\n      } else {\n        // require.context in mendix does not support lazy loading\n        // For now wrap the response in promise until we fix rollup-plugin-require-context2\n        lazyLoadPromises.push(new Promise(resolve => {\n          const contents = imp.contents;\n          return resolve({\n            contents: interopES6Default(contents),\n            name: imp.name\n          });\n        }));\n      }\n    }\n  } // revisitme - need to consider \"configuration.format === 'array'\" use case later\n\n\n  if (name === 'commandsViewModel') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      let res = importResArray.reduce(reduceJsonContents, {});\n      updateIsToggleFlag(res);\n      return res;\n    });\n  } else if (name === 'secondaryWorkareaTabs') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      return importResArray.reduce((sum, cur) => {\n        // old schema support\n        if (_.isArray(cur.contents)) {\n          sum.tabs.push(...cur.contents);\n        } else {\n          // new schema support\n          let {\n            tabs,\n            ...rest\n          } = cur.contents;\n          sum.tabs.push(...Object.values(tabs));\n          merge(sum, rest);\n        }\n\n        return sum;\n      }, {\n        tabs: []\n      });\n    });\n  } else if (name === 'layoutSlots' || name === 'navigationURLToken' || name === 'syncStrategy' || name === 'indicators' || name === 'adapters' || name === 'headerContributions' || name === 'saveHandlers') {\n    return Promise.all(lazyLoadPromises).then(importResArray => {\n      res = importResArray.reduce(reduceJsonContents, config.format === 'array' ? [] : {});\n      return res;\n    });\n  } else if (name === 'workspace') {\n    return importResArray;\n  } else if (name === 'states') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents) {\n        for (const stateName in cur.contents) {\n          const state = cur.contents[stateName];\n\n          if (state.type === 'location') {\n            if (!state.hasOwnProperty('abstract')) {\n              state.abstract = true;\n            }\n\n            if (!state.view) {\n              state.view = 'AwDefaultLocation';\n            }\n\n            if (!state.parent) {\n              state.parent = 'root';\n            }\n          } else if (state.type === 'subLocation') {\n            if (!state.view) {\n              state.view = 'AwDefaultSublocation';\n            }\n\n            if (!state.hasOwnProperty('reloadOnSearch')) {\n              state.reloadOnSearch = false;\n            }\n\n            if (!state.parent) {\n              throw new Error(`Sublocation state ${stateName} does not have parent location`);\n            }\n\n            if (!state.hasOwnProperty('url')) {\n              throw new Error(`No url defined for sublocation state ${stateName}`);\n            }\n          } else if (state.type === 'parameter') {\n            if (!state.params) {\n              throw new Error(`Parameter state ${stateName} must have parameters`);\n            } else if (Object.keys(state).length > 2) {\n              throw new Error(`Parameter state ${stateName} should only have type and params`);\n            } // Merging states is handled later\n\n          } else {\n            logger.debug(`No type or unknown type on state ${stateName} cannot validate state`);\n          }\n\n          if (state.params) {\n            for (let param in state.params) {\n              if (!state.params[param]) {\n                state.params[param] = {\n                  type: 'any'\n                };\n              }\n            }\n          } // Temporary hack to support states that have not set type (ex search)\n\n\n          if (state.type !== 'location' && !state.parent && state.controller === 'DefaultLocationCtrl') {\n            logger.warn(`${stateName} is using DefaultLocationCtrl but is not a location`);\n            state.parent = 'root';\n          }\n\n          if (!sum[stateName]) {\n            sum[stateName] = state;\n          } else {\n            if (sum[stateName].type === 'parameter' || state.type === 'parameter') {\n              // If the current state is just parameters merge it into the finalState\n              if (state.type === 'parameter') {\n                _.assign(sum[stateName].params, state.params);\n              } else {\n                // If the final state is currently just parameters and the new state is not merge into the new state\n                _.assign(state.params, sum[stateName].params);\n\n                sum[stateName] = state;\n              }\n            } else {\n              logger.error(`State name conflict with state ${stateName}`);\n            }\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } else if (name === 'aliasRegistry') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents) {\n        for (const iconName in cur.contents) {\n          const aliases = cur.contents[iconName];\n          let icoName = iconName;\n\n          if (aliases.length === 0) {\n            throw new Error(`No aliases provided for type icons declared for [${icoName}]`);\n          } // If not a type alias, then strip the size numbers at the end of the filename.\n\n\n          if (!/^type/.test(icoName)) {\n            icoName = icoName.replace(/[0-9]+$/, '');\n          }\n\n          const token = icoName.substring(0, 4);\n\n          for (const alias of aliases) {\n            const aliasToken = token + alias;\n\n            if (sum[aliasToken]) {\n              throw new Error(`Multiple aliases declared for ${aliasToken} [${icoName} & ${sum[aliasToken]}]`);\n            }\n\n            if (aliasToken === iconName) {\n              throw new Error(`Why map the same name to itself? ${alias}`);\n            }\n\n            sum[aliasToken] = icoName;\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } else if (name === 'typeProperties') {\n    res = importResArray.reduce((sum, cur) => {\n      if (cur.contents && cur.contents.typeProperties) {\n        const typeProperties = cur.contents.typeProperties;\n\n        for (const key2 in typeProperties) {\n          const value = typeProperties[key2];\n\n          if (!sum[key2]) {\n            sum[key2] = value;\n          } else {\n            if (sum[key2].displayProperty && value.displayProperty && sum[key2].displayProperty !== value.displayProperty) {\n              logger.error(`TypeProperties displayProperty conflict with type ${key2}`);\n            } else if (value.displayProperty) {\n              sum[key2].displayProperty = value.displayProperty;\n            }\n\n            if (value.additionalProperties) {\n              if (!sum[key2].additionalProperties) {\n                sum[key2].additionalProperties = [];\n              }\n\n              for (const property of value.additionalProperties) {\n                const foundProp = _.find(sum[key2].additionalProperties, o => {\n                  return o.name === property.name;\n                });\n\n                if (!foundProp) {\n                  sum[key2].additionalProperties.push(property);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return sum;\n    }, {});\n    return res;\n  } // else\n\n\n  res = importResArray.reduce(reduceJsonContents, config.format === 'array' ? [] : {});\n  return res;\n};\nexport const processI10n = (name, imports) => {\n  const i18nAllFiles = {};\n  const MSG_PREFIX = 'processL10n: ';\n  let importResArray = imports.reduce((res, m) => res.concat(_.filter(m.keys(), path => {\n    let localeCode; // get base name\n\n    let fileName = path.split('/').reverse()[0].split('.json')[0];\n\n    if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'i18n_' + fileName.substring(fileName.length - 5);\n    } else if (/_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'i18n_' + fileName.substring(fileName.length - 2);\n    } else {\n      localeCode = 'i18n';\n    }\n\n    return localeCode === name || name !== 'i18n' && localeCode === 'i18n';\n  }).map(path => {\n    if (typeof m(path).then === 'function') {\n      return m(path).then(contents => {\n        return {\n          contents: interopES6Default(contents),\n          name: path\n        };\n      });\n    } // The plugin used in mendix integration does not support lazy m(path) i.e then api is missing\n\n\n    return new Promise(resolve => {\n      const contents = m(path);\n      return resolve({\n        contents: interopES6Default(contents),\n        name: path\n      });\n    });\n  })), []);\n  /**\n   * Add missing entries in the non-English localization with the English values.\n   *\n   * @param {Object} nonEnglish - non-English localization data\n   * @param {Object} english - English localization data\n   */\n\n  function backFillFromEnglish(nonEnglish, english) {\n    for (const bundleName in english) {\n      const bundle = english[bundleName];\n\n      if (!nonEnglish[bundleName]) {\n        nonEnglish[bundleName] = bundle;\n        continue;\n      }\n\n      for (const key in bundle) {\n        const value = bundle[bundleName];\n\n        if (!nonEnglish[bundleName][key]) {\n          nonEnglish[bundleName][key] = value;\n        }\n      }\n    }\n  }\n\n  return Promise.all(importResArray).then(i18nlanguages => {\n    for (const cur of i18nlanguages) {\n      let [fullStr, moduleName, fileName] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n      let localeName;\n\n      if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 5);\n        fileName = fileName.substring(0, fileName.length - 6);\n      } else if (/_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 2);\n        fileName = fileName.substring(0, fileName.length - 3);\n      } else {\n        localeName = 'en_US';\n      }\n\n      if (!i18nAllFiles[localeName]) {\n        i18nAllFiles[localeName] = {};\n      }\n\n      if (cur.contents) {\n        try {\n          i18nAllFiles[localeName][fileName] = cur.contents;\n        } catch (err) {\n          logger.error(`Unable to parse ${cur.name}`);\n          throw err;\n        }\n      }\n    }\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (locale !== 'en_US') {\n        backFillFromEnglish(json, i18nAllFiles.en_US);\n      }\n    }\n    /**\n     * Existing i18n logic: ( for all step below, en_US doesn't have suffix)\n     * - i18n src is defined as:\n     *   adobejsTooltipMessages_zh_CN ->\n     *   {\n     *       \"openInIllustrator\": \"Local test in Chinese\"\n     *   }\n     *\n     * - It will be reassemble as:\n     *   i18n_zh_CN.json ->\n     *   {\n     *       adobejsTooltipMessages: {\n     *           \"openInIllustrator\": \"Local test in Chinese\"\n     *       }\n     *   }\n     *\n     * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',\n     *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'\n     *\n     * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'\n     *\n     * - in the final cfgCache it will looks like:\n     *   {\n     *       actionTemplateDefs,\n     *       ....,\n     *       i18n_zh_CN: {\n     *           adobejsTooltipMessages: {\n     *               \"openInIllustrator\": \"Local test in Chinese\"\n     *           }\n     *       }\n     *   }\n     *\n     * - regarding to installedLocales:\n     *   - it depends on on how man JSON config our customer has in src\n     *   - it depends on war_mySite.json\n     *   We will check it later\n     */\n\n\n    let res;\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (name.endsWith(locale)) {\n        res = json;\n      }\n    } // load english by default\n    // revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will\n    // see how can we handle that later\n\n\n    return res ? res : i18nAllFiles.en_US;\n  });\n};\nexport const processLoginLocales = (name, imports) => {\n  const i18nAllFiles = {};\n  let importResArray = imports.reduce((res, m) => res.concat(_.filter(m.keys(), path => {\n    let localeCode; // get base name\n\n    let fileName = path.split('/').reverse()[0].split('.json')[0];\n\n    if (!fileName.startsWith('LoginLocale')) {\n      return false;\n    }\n\n    if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'LoginLocale_' + fileName.substring(fileName.length - 5);\n    } else if (/_[\\w]{2}$/.test(fileName)) {\n      localeCode = 'LoginLocale_' + fileName.substring(fileName.length - 2);\n    } else {\n      localeCode = 'LoginLocale';\n    }\n\n    return localeCode === name || name !== 'LoginLocale' && localeCode === 'LoginLocale';\n  }).map(path => m(path).then(contents => {\n    return {\n      contents: interopES6Default(contents),\n      name: path\n    };\n  }))), []);\n  /**\n   * Add missing entries in the non-English localization with the English values.\n   *\n   * @param {Object} nonEnglish - non-English localization data\n   * @param {Object} english - English localization data\n   */\n\n  function backFillFromEnglish(nonEnglish, english) {\n    for (const bundleName in english) {\n      const bundle = english[bundleName];\n\n      if (!nonEnglish[bundleName]) {\n        nonEnglish[bundleName] = bundle;\n        continue;\n      }\n\n      for (const key in bundle) {\n        const value = bundle[bundleName];\n\n        if (!nonEnglish[bundleName][key]) {\n          nonEnglish[bundleName][key] = value;\n        }\n      }\n    }\n  }\n\n  return Promise.all(importResArray).then(i18nlanguages => {\n    for (const cur of i18nlanguages) {\n      let [fullStr, moduleName, fileName] = cur.name.match(/^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/);\n      let localeName;\n\n      if (/_[\\w]{2}_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 5);\n        fileName = fileName.substring(0, fileName.length - 6);\n      } else if (/_[\\w]{2}$/.test(fileName)) {\n        localeName = fileName.substring(fileName.length - 2);\n        fileName = fileName.substring(0, fileName.length - 3);\n      } else {\n        localeName = 'en_US';\n      }\n\n      if (!i18nAllFiles[localeName]) {\n        i18nAllFiles[localeName] = {};\n      }\n\n      if (cur.contents) {\n        try {\n          i18nAllFiles[localeName][fileName] = cur.contents;\n        } catch (err) {\n          logger.error(`Unable to parse ${cur.name}`);\n          throw err;\n        }\n      }\n    }\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (locale !== 'en_US') {\n        backFillFromEnglish(json, i18nAllFiles.en_US);\n      }\n\n      if (json.LoginLocale && json.LoginLocale[locale]) {\n        for (const locale2 of Object.keys(i18nAllFiles)) {\n          _.set(i18nAllFiles, [locale2, 'LoginLocale', locale], json.LoginLocale[locale]);\n        }\n      }\n    }\n\n    let res;\n\n    for (const locale in i18nAllFiles) {\n      const json = i18nAllFiles[locale];\n\n      if (name.endsWith(locale)) {\n        res = json;\n      }\n    }\n\n    return res ? res : i18nAllFiles.en_US;\n  });\n};\n/**\n * parse return value webpack.require.context to module object array\n * @param {Array} imports module structure return by webpack.require.context API\n * @returns {Object} module object array\n */\n\nexport const parseImports = imports => imports.reduce((res, m) => res.concat(m.keys().map(path => ({\n  name: path,\n  contents: interopES6Default(m(path))\n}))), []);\n/**\n * stitch JSON from require.context import\n * @param {String} name module structure return by webpack.require.context API\n * @param {Array} imports module structure return by webpack.require.context API\n * @param {Object} config JSON configuration definition\n * @returns {Object} stitched JSON object\n */\n\nexport const stitchJSON = function (name, imports) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let lazy = arguments.length > 3 ? arguments[3] : undefined;\n  return processJsonImports(name, parseImports(imports), config, lazy);\n};\n/**\n * Try to get field object from expr and field context\n * @param {String} expr field input expression\n * @param {Object} fields fields context\n * @param {String} $index $index context\n * @param {String} path fields context\n * @param {Object} context fields context\n * @returns {Object} field object consumed by universal widget\n */\n\nexport const getField = (expr, fields, $index, path, context) => {\n  if (path && $index) {\n    if (/^ctx\\./.test(path)) {\n      return AwParseService.instance(path.replace(/^ctx\\./, '').replace(/\\./g, '_'))(fields)[$index] || {\n        fielddata: {}\n      };\n    } // support the use case of atomic data with aw-repeat\n\n\n    if (path.startsWith('fields.')) {\n      return AwParseService.instance(expr)(context);\n    }\n\n    return AwParseService.instance(path.replace(/\\.props([.[][^.]+\\]?)$/, '$1').replace(/^data\\./, '').replace(/^props\\.|\\.props/, ''))(fields)[$index] || {\n      fielddata: {}\n    };\n  }\n\n  if (/^ctx\\./.test(expr)) {\n    return AwParseService.instance(expr.replace(/^ctx\\./, '').replace(/\\./g, '_'))(fields) || {\n      fielddata: {}\n    };\n  }\n\n  if (!_.isNil($index)) {\n    expr = expr.replace('$index', $index.toString());\n  }\n\n  if (expr.startsWith('fields.')) {\n    return AwParseService.instance(expr.replace(/^data\\./, '').replace(/^fields\\./, ''))(fields) || {\n      fielddata: {}\n    };\n  } // - put { fielddata: {} } as default value to match with widget design\n  // - Supported use case:\n  //   - data.myText => myText\n  //   - data.myObj.props.object_name => myObj.object_name\n\n\n  return AwParseService.instance(expr.replace(/\\.props([.[][^.]+\\]?)$/, '$1').replace(/^data\\./, '').replace(/^fields\\./, ''))(fields) || {\n    fielddata: {}\n  };\n};\n/**\n * Replace all instances of a given string within a larger string.\n *\n * @param {String} input - input string to replace content\n * @param {String} toFind - string to locate\n * @param {String} toReplace - string to replace\n * @return {String} modified string\n */\n\nexport const replaceAll = (input, toFind, toReplace) => {\n  let output = input;\n\n  if (output.indexOf(toFind) > -1) {\n    output = output.split(toFind).join(toReplace);\n  }\n\n  return output;\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/config/src/js/utils.js"],"names":["obj","viewModelJson","cmdId2handlers","handlers","Object","handler","command","acc","_","objValue","merge","depth","logger","obj1","field","obj2","check","processWorkspaces","workspaceData","workspaceArray","solutionDef","filteredWorkspaceContributions","filteredWorkspaces","workspaceInfo","workspace","data","processExclusiveKits","workspaceUtils","workspaceObject","processJsonImports","config","lazy","res","lazyLoadPromises","reduceJsonContents","cur","path","uniqueDepth","imp","contents","interopES6Default","name","resolve","importResArray","updateIsToggleFlag","sum","rest","tabs","state","stateName","type","aliases","icoName","token","aliasToken","alias","typeProperties","value","key2","foundProp","o","property","processI10n","i18nAllFiles","MSG_PREFIX","m","fileName","localeCode","bundle","english","nonEnglish","i18nlanguages","localeName","json","locale","backFillFromEnglish","processLoginLocales","parseImports","imports","stitchJSON","getField","AwParseService","fielddata","expr","$index","replaceAll","output"],"mappings":"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","sourcesContent":["// Copyright (c) 2022 Siemens\n\n/**\n * @module js/utils\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport AwParseService from 'js/awParseService';\nimport workspaceUtils from 'js/workspaceUtils';\n/**\n * Polyfill to match dynamic import result back to ES5 supported module\n *\n * @param {Object} obj - function to evaluate after loading the dependencies.\n * @returns {Object} ES5 module object\n */\nexport function interopES6Default( obj ) {\n    // for case like appCtxSerivce, for unknown reason, it has __esModule but no default\n    // In the case we will use module itself\n    // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n    // NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion\n    // it makes that we defined the moduleServiceNameToInject at top level for that practice, not class\n    // level.\n    // It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice\n    // the return is inconsistent for requireJS API:\n    // - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }\n    // - class without moduleServiceNameToInject => svcClass\n    // - non class => it doen't matter since module === module.default\n    // webpack and non-webpack mode will be same snce they have the same _interopES6Default\n    //\n    // Long term solution\n    // - stop supporting non-webpack build\n    // - see if we can remove this _interopES6Default when use dynamic import\n    //\n    // Short term solution (aw4.3)\n    // - Document this apperance difference for class service\n    // - it should be a minor minor case in regular practice\n    return obj && obj.__esModule && obj.default && !obj.moduleServiceNameToInject ? obj.default : obj;\n}\n\n/**\n * Set the \"isToggle\" flag on any commands that have a handler with a \"selectWhen\" condition\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nfunction updateIsToggleFlag( viewModelJson ) {\n    if( viewModelJson.commands ) {\n        const cmdId2handlers = {};\n        let handlers = [];\n        for( const handler of Object.values( viewModelJson.commandHandlers ) ) {\n            handlers = cmdId2handlers[ handler.id ];\n            if( !handlers ) {\n                handlers = [];\n                cmdId2handlers[ handler.id ] = handlers;\n            }\n            handlers.push( handler );\n        }\n        for( const cmdId in viewModelJson.commands ) {\n            const command = viewModelJson.commands[ cmdId ];\n            // The handlers for the given command\n            handlers = cmdId2handlers[ cmdId ] || [];\n            // If any handler for this command has selectWhen the command is a toggle command\n            command.isToggle = !command.isGroup && !command.isShuttle && handlers.reduce( function( acc, handler ) {\n                return acc || handler.hasOwnProperty( 'selectWhen' );\n            }, false ) || false;\n        }\n    }\n}\n\n/**\n * @param {Object} objValue - destination object\n * @param {Object} srcValue source object\n * @return {Object|undefined} modified destination object\n */\nfunction mergeCustomizer( objValue, srcValue ) {\n    if( _.isArray( objValue ) ) {\n        return objValue.concat( srcValue );\n    }\n}\n\n/**\n * @param {Object} obj1 object 1\n * @param {Object} obj2 object 2\n * @param {Object|null} check - optional checker object\n * @param {Number|null} depth - depth of merge\n * @type {module.exports.merge}\n */\nconst merge = ( obj1, obj2, check, depth ) => {\n    if( !depth ) { depth = 1; }\n    if( _.isNull( obj2 ) ) {\n        // nothing to merge\n    } else if( _.isNull( obj1 ) ) {\n        logger.error( 'Null object to merge!' );\n    } else if( _.isArray( obj1 ) && _.isArray( obj2 ) ) {\n        for( let element of obj2 ) {\n            // If there was a 'identity' test for the elements, we might be able to merge objects in the array.\n            if( !obj1.includes( element ) ) {\n                obj1.push( _.cloneDeep( element ) );\n            }\n        }\n    } else if( _.isObject( obj1 ) && _.isObject( obj2 ) ) {\n        if( !check ) {\n            _.mergeWith( obj1, obj2, mergeCustomizer );\n        } else {\n            for( const key in obj2 ) {\n                const field = obj2[ key ];\n                if( obj1.hasOwnProperty( key ) ) {\n                    if( check ) {\n                        check.path.push( key );\n                        if( check.uniqueDepth !== undefined &&\n                            check.uniqueDepth === depth &&\n                            !check.path.includes( 'i18n' ) ) {\n                            throw new Error( 'Name conflict in ' + check.file + '.json path=' + check.path.join( '.' ) + ' for module ' + check.moduleName + ' (2nd occurrence)!' );\n                        }\n                    }\n                    merge( obj1[ key ], field, check, depth + 1 );\n                    if( check ) { check.path.pop(); }\n                } else {\n                    obj1[ key ] = _.cloneDeep( field );\n                }\n            }\n        }\n    } else if( _.isArray( obj1 ) || _.isArray( obj2 ) ) {\n        throw new Error( 'Invalid array merge!' );\n    } else if( _.isObject( obj1 ) || _.isObject( obj2 ) ) {\n        throw new Error( 'Invalid object merge!' );\n    }\n};\n\nexport const processWorkspaces = ( solutionDef, workspacesInfo ) => {\n    let workspaceData = {};\n    const workspaceArray = solutionDef.workspaces;\n    let filteredWorkspaceContributions = [];\n    if( solutionDef && solutionDef.workspaces ) {\n        let filteredWorkspaces = workspacesInfo.filter( function( workspaceInfo ) {\n            if( /workspace_contribution.*/.test( workspaceInfo.name ) ) {\n                filteredWorkspaceContributions.push( workspaceInfo );\n                return false;\n            }\n            return true;\n        } );\n        for( const data of Object.values( filteredWorkspaces ) ) {\n            const workspace = data.contents;\n            if( _.includes( workspaceArray, workspace.workspaceId ) || workspace.scope === 'Internal' ||\n                workspace.includeInSolutions && workspace.includeInSolutions.includes( solutionDef.solutionId ) ) {\n                workspaceData[ workspace.workspaceId ] = workspace;\n            }\n        }\n        //now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData\n        for( const data of Object.values( filteredWorkspaceContributions ) ) {\n            const workspace = data.contents;\n            if( workspaceData[ workspace.workspaceId ] !== undefined ) {\n                _.mergeWith( workspaceData[ workspace.workspaceId ], workspace, function customizer( objValue, srcValue ) {\n                    if( _.isArray( objValue ) ) {\n                        _.each( srcValue, function( item ) {\n                            if( objValue.indexOf( item ) < 0 ) {\n                                objValue.push( item );\n                            }\n                        } );\n                        return objValue;\n                    }\n                } );\n            }\n        }\n    }\n    return workspaceData;\n};\n\n/**\n * Add all the configurations from the exclusive kits to the workspaces.\n * @param {object} WorkspacesInfo all workspaces\n * @param {Object} allKitsJson - all kits\n * @param {Object} allStatesJson - all states\n */\nexport const processExclusiveKits = ( WorkspacesInfo, allKitsJson, allModules2StatesJson ) => {\n    for( var workspaceObject of Object.values( WorkspacesInfo ) ) {\n        workspaceUtils.resolveKitDefinitions( workspaceObject.contents, allKitsJson, allModules2StatesJson );\n    }\n    return;\n};\nexport const processJsonImports = ( name, importResArray, config = {}, lazy ) => {\n    let res = {};\n    let lazyLoadPromises = [];\n    // have to put it here because of clojure\n    const reduceJsonContents = ( sum, cur ) => {\n        const [ fullStr, moduleName, file ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n\n        merge( sum, cur.contents, config.uniqueDepth && {\n            moduleName,\n            file,\n            path: [],\n            uniqueDepth: config.uniqueDepth\n        } );\n        return sum;\n    };\n\n    if( lazy ) {\n        for( const imp of importResArray ) {\n            if( typeof imp.contents.then === 'function' ) {\n                lazyLoadPromises.push( imp.contents.then( ( contents ) => {\n                    return { contents: interopES6Default( contents ), name: imp.name };\n                } ) );\n            } else {\n                // require.context in mendix does not support lazy loading\n                // For now wrap the response in promise until we fix rollup-plugin-require-context2\n                lazyLoadPromises.push( new Promise( resolve => {\n                    const contents = imp.contents;\n                    return resolve( { contents: interopES6Default( contents ), name: imp.name } );\n                } ) );\n            }\n        }\n    }\n    // revisitme - need to consider \"configuration.format === 'array'\" use case later\n    if( name === 'commandsViewModel' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            let res = importResArray.reduce( reduceJsonContents, {} );\n            updateIsToggleFlag( res );\n            return res;\n        } );\n    } else if( name === 'secondaryWorkareaTabs' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            return importResArray.reduce( ( sum, cur ) => {\n                // old schema support\n                if( _.isArray( cur.contents ) ) {\n                    sum.tabs.push( ...cur.contents );\n                } else {\n                    // new schema support\n                    let { tabs, ...rest } = cur.contents;\n                    sum.tabs.push( ...Object.values( tabs ) );\n                    merge( sum, rest );\n                }\n                return sum;\n            }, { tabs: [] } );\n        } );\n    } else if( name === 'layoutSlots' ||\n        name === 'navigationURLToken' ||\n        name === 'syncStrategy' ||\n        name === 'indicators' ||\n        name === 'adapters' ||\n        name === 'headerContributions' ||\n        name === 'saveHandlers' ) {\n        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {\n            res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );\n            return res;\n        } );\n    } else if( name === 'workspace' ) {\n        return importResArray;\n    } else if( name === 'states' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents ) {\n                for( const stateName in cur.contents ) {\n                    const state = cur.contents[ stateName ];\n                    if( state.type === 'location' ) {\n                        if( !state.hasOwnProperty( 'abstract' ) ) {\n                            state.abstract = true;\n                        }\n                        if( !state.view ) {\n                            state.view = 'AwDefaultLocation';\n                        }\n                        if( !state.parent ) {\n                            state.parent = 'root';\n                        }\n                    } else if( state.type === 'subLocation' ) {\n                        if( !state.view ) {\n                            state.view = 'AwDefaultSublocation';\n                        }\n                        if( !state.hasOwnProperty( 'reloadOnSearch' ) ) {\n                            state.reloadOnSearch = false;\n                        }\n                        if( !state.parent ) {\n                            throw new Error( `Sublocation state ${stateName} does not have parent location` );\n                        }\n                        if( !state.hasOwnProperty( 'url' ) ) {\n                            throw new Error( `No url defined for sublocation state ${stateName}` );\n                        }\n                    } else if( state.type === 'parameter' ) {\n                        if( !state.params ) {\n                            throw new Error( `Parameter state ${stateName} must have parameters` );\n                        } else if( Object.keys( state ).length > 2 ) {\n                            throw new Error( `Parameter state ${stateName} should only have type and params` );\n                        }\n                        // Merging states is handled later\n                    } else {\n                        logger.debug( `No type or unknown type on state ${stateName} cannot validate state` );\n                    }\n\n                    if( state.params ) {\n                        for( let param in state.params ) {\n                            if( !state.params[ param ] ) {\n                                state.params[ param ] = { type: 'any' };\n                            }\n                        }\n                    }\n                    // Temporary hack to support states that have not set type (ex search)\n                    if( state.type !== 'location' && !state.parent && state.controller === 'DefaultLocationCtrl' ) {\n                        logger.warn( `${stateName} is using DefaultLocationCtrl but is not a location` );\n                        state.parent = 'root';\n                    }\n                    if( !sum[ stateName ] ) {\n                        sum[ stateName ] = state;\n                    } else {\n                        if( sum[ stateName ].type === 'parameter' || state.type === 'parameter' ) {\n                            // If the current state is just parameters merge it into the finalState\n                            if( state.type === 'parameter' ) {\n                                _.assign( sum[ stateName ].params, state.params );\n                            } else {\n                                // If the final state is currently just parameters and the new state is not merge into the new state\n                                _.assign( state.params, sum[ stateName ].params );\n                                sum[ stateName ] = state;\n                            }\n                        } else {\n                            logger.error( `State name conflict with state ${stateName}` );\n                        }\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    } else if( name === 'aliasRegistry' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents ) {\n                for( const iconName in cur.contents ) {\n                    const aliases = cur.contents[ iconName ];\n                    let icoName = iconName;\n                    if( aliases.length === 0 ) {\n                        throw new Error( `No aliases provided for type icons declared for [${icoName}]` );\n                    }\n                    // If not a type alias, then strip the size numbers at the end of the filename.\n                    if( !/^type/.test( icoName ) ) { icoName = icoName.replace( /[0-9]+$/, '' ); }\n                    const token = icoName.substring( 0, 4 );\n                    for( const alias of aliases ) {\n                        const aliasToken = token + alias;\n                        if( sum[ aliasToken ] ) {\n                            throw new Error( `Multiple aliases declared for ${aliasToken} [${icoName} & ${sum[ aliasToken ]}]` );\n                        }\n                        if( aliasToken === iconName ) {\n                            throw new Error( `Why map the same name to itself? ${alias}` );\n                        }\n                        sum[ aliasToken ] = icoName;\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    } else if( name === 'typeProperties' ) {\n        res = importResArray.reduce( ( sum, cur ) => {\n            if( cur.contents && cur.contents.typeProperties ) {\n                const typeProperties = cur.contents.typeProperties;\n                for( const key2 in typeProperties ) {\n                    const value = typeProperties[ key2 ];\n                    if( !sum[ key2 ] ) {\n                        sum[ key2 ] = value;\n                    } else {\n                        if( sum[ key2 ].displayProperty &&\n                            value.displayProperty &&\n                            sum[ key2 ].displayProperty !== value.displayProperty ) {\n                            logger.error( `TypeProperties displayProperty conflict with type ${key2}` );\n                        } else if( value.displayProperty ) {\n                            sum[ key2 ].displayProperty = value.displayProperty;\n                        }\n                        if( value.additionalProperties ) {\n                            if( !sum[ key2 ].additionalProperties ) {\n                                sum[ key2 ].additionalProperties = [];\n                            }\n                            for( const property of value.additionalProperties ) {\n                                const foundProp = _.find( sum[ key2 ].additionalProperties, o => {\n                                    return o.name === property.name;\n                                } );\n                                if( !foundProp ) {\n                                    sum[ key2 ].additionalProperties.push( property );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return sum;\n        }, {} );\n        return res;\n    }\n    // else\n    res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );\n    return res;\n};\n\nexport const processI10n = ( name, imports ) => {\n    const i18nAllFiles = {};\n    const MSG_PREFIX = 'processL10n: ';\n    let importResArray = imports.reduce( ( res, m ) =>\n        res.concat(\n            _.filter( m.keys(), ( path ) => {\n                let localeCode;\n                // get base name\n                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];\n\n                if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'i18n_' + fileName.substring( fileName.length - 5 );\n                } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'i18n_' + fileName.substring( fileName.length - 2 );\n                } else {\n                    localeCode = 'i18n';\n                }\n                return localeCode === name || name !== 'i18n' && localeCode === 'i18n';\n            } ).map( path => {\n                if( typeof m( path ).then === 'function' ) {\n                    return m( path ).then( ( contents ) => {\n                        return { contents: interopES6Default( contents ), name: path };\n                    } );\n                }\n                // The plugin used in mendix integration does not support lazy m(path) i.e then api is missing\n                return new Promise( resolve => {\n                    const contents = m( path );\n                    return resolve( { contents: interopES6Default( contents ), name: path } );\n                } );\n            } ) ), []\n    );\n\n    /**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */\n    function backFillFromEnglish( nonEnglish, english ) {\n        for( const bundleName in english ) {\n            const bundle = english[ bundleName ];\n            if( !nonEnglish[ bundleName ] ) {\n                nonEnglish[ bundleName ] = bundle;\n                continue;\n            }\n            for( const key in bundle ) {\n                const value = bundle[ bundleName ];\n                if( !nonEnglish[ bundleName ][ key ] ) {\n                    nonEnglish[ bundleName ][ key ] = value;\n                }\n            }\n        }\n    }\n\n    return Promise.all( importResArray ).then( ( i18nlanguages ) => {\n        for( const cur of i18nlanguages ) {\n            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n            let localeName;\n            if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 5 );\n                fileName = fileName.substring( 0, fileName.length - 6 );\n            } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 2 );\n                fileName = fileName.substring( 0, fileName.length - 3 );\n            } else {\n                localeName = 'en_US';\n            }\n            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }\n            if( cur.contents ) {\n                try {\n                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;\n                } catch ( err ) {\n                    logger.error( `Unable to parse ${cur.name}` );\n                    throw err;\n                }\n            }\n        }\n\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }\n        }\n\n        /**\n         * Existing i18n logic: ( for all step below, en_US doesn't have suffix)\n         * - i18n src is defined as:\n         *   adobejsTooltipMessages_zh_CN ->\n         *   {\n         *       \"openInIllustrator\": \"Local test in Chinese\"\n         *   }\n         *\n         * - It will be reassemble as:\n         *   i18n_zh_CN.json ->\n         *   {\n         *       adobejsTooltipMessages: {\n         *           \"openInIllustrator\": \"Local test in Chinese\"\n         *       }\n         *   }\n         *\n         * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',\n         *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'\n         *\n         * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'\n         *\n         * - in the final cfgCache it will looks like:\n         *   {\n         *       actionTemplateDefs,\n         *       ....,\n         *       i18n_zh_CN: {\n         *           adobejsTooltipMessages: {\n         *               \"openInIllustrator\": \"Local test in Chinese\"\n         *           }\n         *       }\n         *   }\n         *\n         * - regarding to installedLocales:\n         *   - it depends on on how man JSON config our customer has in src\n         *   - it depends on war_mySite.json\n         *   We will check it later\n         */\n        let res;\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( name.endsWith( locale ) ) {\n                res = json;\n            }\n        }\n\n        // load english by default\n        // revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will\n        // see how can we handle that later\n        return res ? res : i18nAllFiles.en_US;\n    } );\n};\n\nexport const processLoginLocales = ( name, imports ) => {\n    const i18nAllFiles = {};\n    let importResArray = imports.reduce( ( res, m ) =>\n        res.concat(\n            _.filter( m.keys(), ( path ) => {\n                let localeCode;\n                // get base name\n                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];\n\n                if( !fileName.startsWith( 'LoginLocale' ) ) {\n                    return false;\n                }\n\n                if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 5 );\n                } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 2 );\n                } else {\n                    localeCode = 'LoginLocale';\n                }\n                return localeCode === name || name !== 'LoginLocale' && localeCode === 'LoginLocale';\n            } ).map( path => m( path ).then( ( contents ) => {\n                return { contents: interopES6Default( contents ), name: path };\n            } ) ) ), []\n    );\n\n    /**\n     * Add missing entries in the non-English localization with the English values.\n     *\n     * @param {Object} nonEnglish - non-English localization data\n     * @param {Object} english - English localization data\n     */\n    function backFillFromEnglish( nonEnglish, english ) {\n        for( const bundleName in english ) {\n            const bundle = english[ bundleName ];\n            if( !nonEnglish[ bundleName ] ) {\n                nonEnglish[ bundleName ] = bundle;\n                continue;\n            }\n            for( const key in bundle ) {\n                const value = bundle[ bundleName ];\n                if( !nonEnglish[ bundleName ][ key ] ) {\n                    nonEnglish[ bundleName ][ key ] = value;\n                }\n            }\n        }\n    }\n\n    return Promise.all( importResArray ).then( ( i18nlanguages ) => {\n        for( const cur of i18nlanguages ) {\n            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\\\|/]([^\\\\/]*)[\\\\|/]([^\\\\/]*)\\.json$/ );\n            let localeName;\n            if( /_[\\w]{2}_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 5 );\n                fileName = fileName.substring( 0, fileName.length - 6 );\n            } else if( /_[\\w]{2}$/.test( fileName ) ) {\n                localeName = fileName.substring( fileName.length - 2 );\n                fileName = fileName.substring( 0, fileName.length - 3 );\n            } else {\n                localeName = 'en_US';\n            }\n            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }\n            if( cur.contents ) {\n                try {\n                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;\n                } catch ( err ) {\n                    logger.error( `Unable to parse ${cur.name}` );\n                    throw err;\n                }\n            }\n        }\n\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }\n            if( json.LoginLocale && json.LoginLocale[ locale ] ) {\n                for( const locale2 of Object.keys( i18nAllFiles ) ) {\n                    _.set( i18nAllFiles, [ locale2, 'LoginLocale', locale ], json.LoginLocale[ locale ] );\n                }\n            }\n        }\n\n        let res;\n        for( const locale in i18nAllFiles ) {\n            const json = i18nAllFiles[ locale ];\n            if( name.endsWith( locale ) ) {\n                res = json;\n            }\n        }\n\n        return res ? res : i18nAllFiles.en_US;\n    } );\n};\n\n/**\n * parse return value webpack.require.context to module object array\n * @param {Array} imports module structure return by webpack.require.context API\n * @returns {Object} module object array\n */\nexport const parseImports = imports => imports.reduce( ( res, m ) =>\n    res.concat( m.keys().map( path => ( {\n        name: path,\n        contents: interopES6Default( m( path ) )\n    } ) ) ), [] );\n\n/**\n * stitch JSON from require.context import\n * @param {String} name module structure return by webpack.require.context API\n * @param {Array} imports module structure return by webpack.require.context API\n * @param {Object} config JSON configuration definition\n * @returns {Object} stitched JSON object\n */\nexport const stitchJSON = ( name, imports, config = {}, lazy ) =>\n    processJsonImports( name, parseImports( imports ), config, lazy );\n\n/**\n * Try to get field object from expr and field context\n * @param {String} expr field input expression\n * @param {Object} fields fields context\n * @param {String} $index $index context\n * @param {String} path fields context\n * @param {Object} context fields context\n * @returns {Object} field object consumed by universal widget\n */\nexport const getField = ( expr, fields, $index, path, context ) => {\n    if( path && $index ) {\n        if( /^ctx\\./.test( path ) ) {\n            return AwParseService.instance( path.replace( /^ctx\\./, '' ).replace( /\\./g, '_' ) )( fields )[ $index ] || { fielddata: {} };\n        }\n        // support the use case of atomic data with aw-repeat\n        if( path.startsWith( 'fields.' ) ) {\n            return AwParseService.instance( expr )( context );\n        }\n        return AwParseService.instance( path.replace( /\\.props([.[][^.]+\\]?)$/, '$1' ).replace( /^data\\./, '' ).replace( /^props\\.|\\.props/, '' ) )( fields )[ $index ] || { fielddata: {} };\n    }\n    if( /^ctx\\./.test( expr ) ) {\n        return AwParseService.instance( expr.replace( /^ctx\\./, '' ).replace( /\\./g, '_' ) )( fields ) || { fielddata: {} };\n    }\n    if( !_.isNil( $index ) ) {\n        expr = expr.replace( '$index', $index.toString() );\n    }\n\n    if( expr.startsWith( 'fields.' ) ) {\n        return AwParseService.instance( expr.replace( /^data\\./, '' ).replace( /^fields\\./, '' ) )( fields ) || { fielddata: {} };\n    }\n\n    // - put { fielddata: {} } as default value to match with widget design\n    // - Supported use case:\n    //   - data.myText => myText\n    //   - data.myObj.props.object_name => myObj.object_name\n    return AwParseService.instance( expr.replace( /\\.props([.[][^.]+\\]?)$/, '$1' ).replace( /^data\\./, '' ).replace( /^fields\\./, '' ) )( fields ) || { fielddata: {} };\n};\n\n/**\n * Replace all instances of a given string within a larger string.\n *\n * @param {String} input - input string to replace content\n * @param {String} toFind - string to locate\n * @param {String} toReplace - string to replace\n * @return {String} modified string\n */\nexport const replaceAll = ( input, toFind, toReplace ) => {\n    let output = input;\n    if( output.indexOf( toFind ) > -1 ) {\n        output = output.split( toFind ).join( toReplace );\n    }\n    return output;\n};\n"]},"metadata":{},"sourceType":"module"}