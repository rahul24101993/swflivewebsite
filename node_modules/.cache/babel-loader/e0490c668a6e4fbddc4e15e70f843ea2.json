{"ast":null,"code":"/* eslint-disable valid-jsdoc */ // Copyright (c) 2020 Siemens\n/**\n * Defines provider for commands from the View model definition\n *\n * @module js/commandConfigurationService\n */import _,{uniqBy}from'lodash';import logger from'js/logger';import'js/iconService';import ccu from'js/commandConfigUtils.service';import{getStringBetweenDoubleMustaches}from'js/parsingUtils';import{getLocalizedText}from'js/localeService';import Debug from'debug';import debugService from'js/debugService';import conditionService from'js/conditionService';import htmlUtils from'js/htmlUtils';const trace=new Debug('command:AwCommandBar');//TODO: Global state that should not be managed in a service - revisit later\nlet dynamicPlacements=[];const handlerCache={};const getHandlersForCommand=(id,commandsViewModel,useCache)=>{if(!handlerCache[id]||!useCache){handlerCache[id]=Object.entries(commandsViewModel.commandHandlers).filter(_ref=>{let[,v]=_ref;return v.id===id;});}return handlerCache[id];};const DeclarativeCondition=function(condition,commandsViewModel){this.id=condition.split('.').slice(-1)[0];this.expression=ccu.getConditionExpression(commandsViewModel,condition);};const getHandlerAction=(handler,commandsViewModel,_ref2)=>{let{isRibbon}=_ref2;if(isRibbon){//Ribbon commands use their configured action or open popup with child commands if not configured\nreturn commandsViewModel.actions[handler.action||'openCommandGroup'];}if(handler.action){//Base commands use their configured action\nreturn commandsViewModel.actions[handler.action];}return null;};/**\n * Command handler information from commandsViewModel\n *\n * Will be used by AwCommand to setup any necessary hooks and process\n */const CommandHandler=function(id,handler,commandsViewModel,definition){// String :: ID of the command handler\nthis.id=id;// DeclarativeCondition :: Active condition for this handler\nthis.activeWhen=new DeclarativeCondition(handler.activeWhen.condition,commandsViewModel);// Number :: Priority of the command handler (length of the activeWhen condition)\nthis.priority=ccu.getExpressionLength(this.activeWhen.expression,commandsViewModel);// DeclarativeCondition :: Enabled state condition for this handler\nthis.enableWhen=handler.enableWhen?new DeclarativeCondition(handler.enableWhen.condition,commandsViewModel):null;// DeclarativeCondition :: Selected state condition for this handler\nthis.selectWhen=handler.selectWhen?new DeclarativeCondition(handler.selectWhen.condition,commandsViewModel):null;// DeclarativeCondition :: Visibility condition for this handler\nthis.visibleWhen=handler.visibleWhen?new DeclarativeCondition(handler.visibleWhen.condition,commandsViewModel):null;/**\n     * The action that this handler will execute\n     */this.action=getHandlerAction(handler,commandsViewModel,definition);/**\n     * Callback function to execute this command handler\n     *\n     * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model\n     * @returns {CommandExecutionResult}\n     */this.execute=async(runActionWithViewModel,scope,commandContext)=>{scope.commandContext=commandContext||scope.commandContext;return runActionWithViewModel(commandsViewModel,handler.action,scope);};};/**\n * The raw data from commands view model that will be used to determine the current command state\n */export const CommandOverlay=function(_ref3){let{id,handlers,title,selectedTitle,icon,selectedIcon,decorator,extendedTooltip,selectedExtendedTooltip,description,selectedDescription,type,children,showGroupSelected=true,cellDisplay}=_ref3;// String! :: ID of the command\nthis.id=id;// [CommandHandler] :: Handlers for this command\nthis.handlers=handlers;// I18nReference :: Title definition of the command\nthis.title=title;this.selectedTitle=selectedTitle;// String :: ID of the command icon\nthis.icon=icon;this.selectedIcon=selectedIcon;this.decorator=decorator;this.extendedTooltip=extendedTooltip;this.selectedExtendedTooltip=selectedExtendedTooltip;this.description=description;this.selectedDescription=selectedDescription;this.type=type;this.children=children;this.showGroupSelected=showGroupSelected;this.cellDisplay=cellDisplay;this.trace=new Debug(\"command:\".concat(id));this.trace('Overlay created',this);};/**\n * Get the i18n string configured in the given view model\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String} key Key within the i18n section\n * @param {Object} viewModel View model json\n * @returns {String} The localized text value\n */const getI18nValue=async(key,viewModel)=>{const resource=viewModel.i18n[key]?viewModel.i18n[key][0]:'';return getLocalizedText(resource,key);};/**\n * Resolve an i18n reference\n *\n * TODO: Pretty generic, probably already a function somewhere that can be reused\n *\n * @param {String|Object} i18nRef Reference information\n * @param {Object} viewModel View model json\n * @returns {Object} The string value and a list of any parameters it may have\n */const resolveI18n=async(i18nRef,viewModel)=>{if(typeof i18nRef==='string'){const reference=getStringBetweenDoubleMustaches(i18nRef);const value=reference.startsWith('i18n.')?await getI18nValue(reference.slice(5),viewModel):reference;return{value,parameters:[]};}if(typeof i18nRef==='object'){const{value}=await resolveI18n(i18nRef.text,viewModel);return{value,parameters:i18nRef.params||i18nRef.parameters};}return null;};/**\n * Get the type of a command\n *\n * @param {Object} definition Command definition\n * @returns {String} Command type\n */const getCommandType=definition=>{if(definition.isShuttle){return'SHUTTLE';}if(definition.isRibbon){return'RIBBON';}if(definition.isGroup){return'GROUP';}if(definition.isToggle){return'TOGGLE';}return'BASE';};/**\n * Get a command overlay\n *\n * @param {String} id ID of the command\n * @returns {CommandOverlay} Overlay for the command\n */export const getCommand=async(id,useCache)=>{const commandsViewModel=await ccu.getCommandsViewModel();return getCommandInternal(id,commandsViewModel,null,useCache);};const getDecoratorObject=async(template,commandsViewModel)=>{const checkVisbleWhenConditionForConversion=visibleWhen=>{if(visibleWhen&&visibleWhen.condition){return visibleWhen.condition;}if(visibleWhen===false){return'conditions.false';}return'conditions.true';};let value=getStringBetweenDoubleMustaches(template.text);if(value.startsWith('i18n.')){return{text:await resolveI18n(template.text,commandsViewModel),visibleWhen:typeof template.visibleWhen!==undefined?new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen),commandsViewModel):null,class:template.class?template.class:null};}return{text:{value:'{0}',parameters:[template.text]},visibleWhen:typeof template.visibleWhen!==undefined?new DeclarativeCondition(checkVisbleWhenConditionForConversion(template.visibleWhen),commandsViewModel):null,class:template.class?template.class:null};};/**\n * Load the necessary data to create a CommandOverlay and return it\n *\n * @param {String} id ID of the command\n * @param {Object} commandsViewModel Commands view model json\n * @param {Object} placement (Optional) Placement information\n */const getCommandInternal=async function(id,commandsViewModel){let placement=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let useCache=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;const definition=commandsViewModel.commands[id];if(!definition){logger.error(\"Missing command definition for \".concat(id));}const type=getCommandType(definition);const handlers=type==='GROUP'||type==='SHUTTLE'?[new CommandHandler('GroupCommandHandler',{activeWhen:{condition:'conditions.true'},action:'openCommandGroup'},commandsViewModel,definition)]:getHandlersForCommand(id,commandsViewModel,useCache).map(_ref4=>{let[handlerId,value]=_ref4;return new CommandHandler(handlerId,value,commandsViewModel,definition);}).sort((a,b)=>b.priority-a.priority);const icon=definition.iconId;const selectedIcon=definition.selected?definition.selected.iconId:null;//TODO: Some stuff (i18n) may need to be resolved here\nconst extendedTooltip=definition.extendedTooltip;const selectedExtendedTooltip=definition.selected&&definition.selected.extendedTooltip?definition.selected.extendedTooltip:null;const[title,selectedTitle,description,selectedDescription,decorator]=await Promise.all([resolveI18n(definition.title,commandsViewModel),definition.selected&&definition.selected.title?resolveI18n(definition.selected.title,commandsViewModel):null,definition.description?await resolveI18n(definition.description,commandsViewModel):null,definition.selected&&definition.selected.description?resolveI18n(definition.selected.description,commandsViewModel):null,definition.template&&definition.template.text?getDecoratorObject(definition.template,commandsViewModel):null]);const children=type==='GROUP'||type==='SHUTTLE'?await getCommands(id):[];return new CommandOverlay({showGroupSelected:!placement||placement.showGroupSelected!==false,id,handlers,title,selectedTitle,icon,selectedIcon,decorator,extendedTooltip,selectedExtendedTooltip,description,selectedDescription,type,children,cellDisplay:placement?placement.cellDisplay:null});};/**\n * Sort the placements based on relativeTo and priority. Priority is 0 if not set.\n *\n * @param {[CommandPlacement]} placements - placements\n * @return {[CommandPlacement]} Sorted list of command placements\n */const sortPlacements=function(placements){// Assign a priority to any placement that doesn't have one\nplacements.forEach(function(cmd){cmd.priority=cmd.priority||0;});// Split based on whether placement is relative or absolute\nconst p=_.partition(placements,function(cmd){return cmd.relativeTo;});// Sort the commands with only priority\nconst priorityCommands=_.sortBy(p[1],'priority');// Group the relative commands by the relativeTo property\nconst allRelativeCmds=_.groupBy(p[0],'relativeTo');const commandsWithRelativeAdded=priorityCommands.reduce((acc,placement)=>{// Split into before / after based on negative / positive priority\nconst p2=_.partition(allRelativeCmds[placement.id]||[],function(cmd){return cmd.priority>0;});const afterPlacements=_.sortBy(p2[0],'priority');const beforePlacements=_.sortBy(p2[1],'priority');//side effect, could be refactored later\ndelete allRelativeCmds[placement.id];return[...acc,...beforePlacements,placement,...afterPlacements];},[]);//Add any placement with relativeTo that is not in this command bar to the end\nreturn Object.values(allRelativeCmds).reduce((acc,missingRelativeSet)=>{logger.debug(\"Unable to find relative command \".concat(missingRelativeSet[0].id,\". Commands will be placed at end of list.\"),missingRelativeSet);return[...acc,...missingRelativeSet];},commandsWithRelativeAdded);};/**\n * Get the commands for the given anchor\n *\n * @param {String} anchor anchor\n * @returns {[CommandOverlay]} Command overlays for the anchor\n */export const getCommands=async(anchor,useCache)=>{const commandsViewModel=await ccu.getCommandsViewModel();const anchors=anchor.split(',');const allPlacements=[...dynamicPlacements,...Object.values(commandsViewModel.commandPlacements)];const placements=uniqBy(anchors.reduce((fullPlacementList,nextAnchor)=>{const newPlacements=allPlacements.filter(placement=>!placement.parentGroupId&&placement.uiAnchor===nextAnchor&&commandsViewModel.commands[placement.id]);return[...fullPlacementList,...newPlacements];},[]),'id');let placementsSorted=sortPlacements(placements);const commands=await Promise.all(placementsSorted.map(placement=>getCommandInternal(placement.id,commandsViewModel,placement,useCache)));if(anchor){debugService.debugGetCommandsForAnchor(anchor,commands);debugService.reduceData(anchor,commands);}return commands;};/**\n * Add a placement for a command at runtime. All placements\n * must be defined before the AwCommandBar with the matching\n * anchor is rendered\n *\n * @param {[CommandPlacement]} placements Placements to add\n * @returns {Object} Tracking information to all for removal of the placements\n */export const addPlacements=placements=>{trace('Dynamic placements added',placements);dynamicPlacements=[...dynamicPlacements,...placements];return{placements,remove:()=>{dynamicPlacements=dynamicPlacements.filter(x=>!placements.includes(x));trace('Dynamic placements removed',placements);}};};/**\n * Get the commandContext of a given command bar/group\n *\n * @param {String} grpCmdAnchor - the group id/anchor for a given command group\n * @param {String} commandBarAnchor - the anchor for a given command bar\n * @returns {Object} commandContext for given command group or command bar\n */export const getCommandContext=function(grpCmdAnchor,commandBarAnchor){let commandBarXPath=\"//div[contains(@class, 'aw-command-bar') and @anchor='\".concat(grpCmdAnchor?grpCmdAnchor:commandBarAnchor,\"']\");let commandBar=htmlUtils.getElementByXpath(commandBarXPath,document.body);if(commandBar){const key=Object.keys(commandBar).find(key=>{return key.startsWith('__reactFiber$');});const commandBarFiber=commandBar[key];if(commandBarFiber.return.memoizedProps.commandContext){return commandBarFiber.return.memoizedProps.commandContext;}// get parent toolbar which has command context\nlet toolbarFiber=commandBarFiber.return;while(typeof toolbarFiber.type==='string'){toolbarFiber=toolbarFiber.return;}return toolbarFiber.return.memoizedProps.commandContext;}return null;};/**\n * Given the array of handlers for a command get the activeHandler\n *\n * @param {Array<Handler>} handlers - array of command handlers\n * @param {Object} scope - evaluation scope\n * @returns {Handler} the active handler\n */export const getActiveCommandHandler=function(handlers,scope){for(const handler of handlers){const isActive=Boolean(conditionService.evaluateCondition({},handler.activeWhen.expression,scope));if(isActive){return handler;}}return null;};/**\n * Check whether a command is enabled and visible\n *\n * @param {Object} activeHandler - active command handler\n * @param {Object} scope - evaluation scope\n * @returns {Boolean} visbleWhen and enableWhen\n */export const getCommandAndCheckVisibility=function(activeHandler,scope){const visibleWhen=activeHandler.visibleWhen?Boolean(conditionService.evaluateCondition({},activeHandler.visibleWhen.expression,scope)):true;const enableWhen=activeHandler.enableWhen?Boolean(conditionService.evaluateCondition({},activeHandler.enableWhen.expression,scope)):true;return visibleWhen&&enableWhen;};export default{getCommand,getCommands,getCommandContext,getActiveCommandHandler,getCommandAndCheckVisibility};","map":null,"metadata":{},"sourceType":"module"}