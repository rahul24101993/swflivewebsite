{"ast":null,"code":"/* eslint-disable no-await-in-loop */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabRegistryService} which manages tabs.\n *\n * @module js/tabRegistry.service\n */\nimport Debug from 'debug';\nimport AwPromiseService from 'js/awPromiseService';\nimport eventBus from 'js/eventBus';\nimport htmlUtils from 'js/htmlUtils';\nimport wcagSvc from 'js/wcagService';\nconst registry = {};\nconst trace = new Debug('tabRegistryService');\n/**\n * Register a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {List<Object>} tabs List of tabs in tab set (all tabs, not just visible)\n * @param {Object} registryData Callback to change tabs and the tabs that are currently visible\n * @throws Error if tabSetId is already registered\n */\n\nexport function registerTabSet(tabSetId, _ref) {\n  let {\n    changeTab,\n    highlightTab,\n    tabs\n  } = _ref;\n  trace(`Tab set ${tabSetId} registered: ${tabs.map(t => t.tabKey)}`);\n\n  if (registry[tabSetId]) {\n    throw new Error(`Tab set with ID ${tabSetId} is already registered`);\n  }\n\n  registry[tabSetId] = {\n    changeTab,\n    highlightTab,\n    tabs\n  }; // Announce tabset registration\n\n  eventBus.publish(tabSetId + '.tabSetRegistered');\n}\n/**\n * Remove registration of a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n */\n\nexport function unregisterTabSet(tabSetId) {\n  trace(`Tab set ${tabSetId} unregistered`);\n  delete registry[tabSetId]; // Announce tabset un-registration\n\n  eventBus.publish(tabSetId + '.tabSetUnregistered');\n}\n/**\n * Get the list of tabs currently visible in the tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @returns {List<Object>} List of tabs visible in the tab set. Null if tab set is not registered.\n */\n\nexport function getVisibleTabs(tabSetId) {\n  const registration = registry[tabSetId];\n  return registration ? registration.tabs : null;\n}\n/**\n * Change the selected tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to change to\n * @returns {Promise<Void>} Promise resolved when tab transition is complete. Rejected if transition fails or tab is not visible.\n */\n\nexport function changeTab(tabSetId, targetTabId) {\n  const targetTab = (getVisibleTabs(tabSetId) || []).filter(tab => tab.tabKey === targetTabId)[0];\n  const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n\n  return targetTab ? ps.resolve(registry[tabSetId].changeTab(targetTab)) : ps.reject(`${targetTabId} is not available in tab set`);\n}\n/**\n * Highlight tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to be highlighted\n * @returns {Promise<Void>} Promise resolved when tab highlight is complete. Rejected if tab is not visible.\n */\n\nexport function highlightTab(tabSetId, targetTabId) {\n  const targetTab = (getVisibleTabs(tabSetId) || []).filter(tab => tab.tabKey === targetTabId)[0];\n  const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n\n  return targetTab ? ps.resolve(registry[tabSetId].highlightTab(targetTab)) : ps.reject(`${targetTabId} is not available in tab set`);\n}\nconst retryMaxCount = 10;\nconst idleTimeMs = 50;\n/**\n * Delay the execution for a given ms\n *\n * @function delay\n * @param {Number} ms - amount of milliseconds to wait\n * @return {Promise} promise - resolved after x amount of milliseconds\n */\n\nconst delay = function (ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n/**\n * Get the Tab Element based off ID and xPath\n *\n * @function getTabElement\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n * @returns {Element} - the html element to the tab\n */\n\n\nexport const getTabElement = async function (tabId, xPath) {\n  let tabElement = htmlUtils.getElementByXpath(xPath, document.body);\n\n  if (tabElement) {\n    let tabIndex = tabElement.getAttribute('tabindex');\n\n    if (parseInt(tabIndex) > -1) {\n      return tabElement;\n    } // tab is in overflow\n\n\n    const tabContainer = tabElement.closest('.sw-tabContainer');\n\n    if (tabContainer) {\n      const overflowBtn = tabContainer.nextElementSibling;\n\n      if (overflowBtn) {\n        overflowBtn.querySelector('button').click();\n        let retryCounter = 0;\n        let popupTabElement;\n        let loadingElement;\n        setTimeout(function () {\n          retryCounter = retryMaxCount; // After 10 seconds just quit\n        }, 10000);\n\n        while (retryCounter < retryMaxCount) {\n          loadingElement = htmlUtils.getElementByXpath('//div[contains(@class, \\'aw-popup-command-bar\\')]//div[contains(@class, \\'aw-jswidgets-loading\\')]', document.body);\n\n          if (!loadingElement) {\n            popupTabElement = htmlUtils.getElementByXpath(`//li[@tabkey='${tabId}']`, document.body);\n\n            if (popupTabElement) {\n              return popupTabElement;\n            }\n\n            retryCounter++;\n          }\n\n          await delay(idleTimeMs);\n        }\n      }\n    }\n  }\n};\n/**\n * Click on the tab\n *\n * @function clickOnTab\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\n\nexport const clickOnTab = async function (tabId, xPath) {\n  const tabElement = await getTabElement(tabId, xPath);\n\n  if (tabElement) {\n    tabElement.click();\n  }\n};\n/**\n * @function highlightTabBasedOnXPath\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\n\nexport const highlightTabBasedOnXPath = async function (tabId, xPath) {\n  const tabElement = await getTabElement(tabId, xPath);\n\n  if (tabElement) {\n    wcagSvc.afxFocusElement(tabElement);\n  }\n};\nconst exports = {\n  changeTab,\n  highlightTab,\n  getVisibleTabs,\n  registerTabSet,\n  unregisterTabSet,\n  clickOnTab,\n  highlightTabBasedOnXPath\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/tabRegistry.service.js"],"names":["registry","trace","tabs","tabSetId","t","eventBus","registration","targetTab","getVisibleTabs","tab","ps","AwPromiseService","targetTabId","retryMaxCount","idleTimeMs","delay","resolve","setTimeout","getTabElement","tabElement","htmlUtils","document","tabIndex","parseInt","tabContainer","overflowBtn","retryCounter","loadingElement","popupTabElement","tabId","clickOnTab","highlightTabBasedOnXPath","wcagSvc","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-await-in-loop */\n// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabRegistryService} which manages tabs.\n *\n * @module js/tabRegistry.service\n */\nimport Debug from 'debug';\nimport AwPromiseService from 'js/awPromiseService';\nimport eventBus from 'js/eventBus';\nimport htmlUtils from 'js/htmlUtils';\nimport wcagSvc from 'js/wcagService';\n\nconst registry = {};\nconst trace = new Debug( 'tabRegistryService' );\n\n\n/**\n * Register a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {List<Object>} tabs List of tabs in tab set (all tabs, not just visible)\n * @param {Object} registryData Callback to change tabs and the tabs that are currently visible\n * @throws Error if tabSetId is already registered\n */\nexport function registerTabSet( tabSetId, {\n    changeTab,\n    highlightTab,\n    tabs\n} ) {\n    trace( `Tab set ${tabSetId} registered: ${tabs.map( t => t.tabKey )}` );\n    if( registry[ tabSetId ] ) {\n        throw new Error( `Tab set with ID ${tabSetId} is already registered` );\n    }\n    registry[ tabSetId ] = {\n        changeTab,\n        highlightTab,\n        tabs\n    };\n    // Announce tabset registration\n    eventBus.publish( tabSetId + '.tabSetRegistered' );\n}\n\n/**\n * Remove registration of a tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n */\nexport function unregisterTabSet( tabSetId ) {\n    trace( `Tab set ${tabSetId} unregistered` );\n    delete registry[ tabSetId ];\n    // Announce tabset un-registration\n    eventBus.publish( tabSetId + '.tabSetUnregistered' );\n}\n\n/**\n * Get the list of tabs currently visible in the tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @returns {List<Object>} List of tabs visible in the tab set. Null if tab set is not registered.\n */\nexport function getVisibleTabs( tabSetId ) {\n    const registration = registry[ tabSetId ];\n    return registration ? registration.tabs : null;\n}\n\n/**\n * Change the selected tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to change to\n * @returns {Promise<Void>} Promise resolved when tab transition is complete. Rejected if transition fails or tab is not visible.\n */\nexport function changeTab( tabSetId, targetTabId ) {\n    const targetTab = ( getVisibleTabs( tabSetId ) || [] ).filter( tab => tab.tabKey === targetTabId )[0];\n    const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n    return targetTab ? ps.resolve( registry[ tabSetId ].changeTab( targetTab ) ) : ps.reject( `${targetTabId} is not available in tab set` );\n}\n\n/**\n * Highlight tab in the targeted tab set\n *\n * @param {String} tabSetId ID that the tab set has registered with\n * @param {String} targetTabId ID of the tab to be highlighted\n * @returns {Promise<Void>} Promise resolved when tab highlight is complete. Rejected if tab is not visible.\n */\nexport function highlightTab( tabSetId, targetTabId ) {\n    const targetTab = ( getVisibleTabs( tabSetId ) || [] ).filter( tab => tab.tabKey === targetTabId )[0];\n    const ps = AwPromiseService.instance; //inline instead of global because of unit tests\n    return targetTab ? ps.resolve( registry[ tabSetId ].highlightTab( targetTab ) ) : ps.reject( `${targetTabId} is not available in tab set` );\n}\n\nconst retryMaxCount = 10;\n\nconst idleTimeMs = 50;\n\n/**\n * Delay the execution for a given ms\n *\n * @function delay\n * @param {Number} ms - amount of milliseconds to wait\n * @return {Promise} promise - resolved after x amount of milliseconds\n */\nconst delay = function( ms ) {\n    return new Promise( resolve => setTimeout( resolve, ms ) );\n};\n\n/**\n * Get the Tab Element based off ID and xPath\n *\n * @function getTabElement\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n * @returns {Element} - the html element to the tab\n */\nexport const getTabElement = async function( tabId, xPath ) {\n    let tabElement = htmlUtils.getElementByXpath( xPath, document.body );\n    if( tabElement ) {\n        let tabIndex = tabElement.getAttribute( 'tabindex' );\n        if( parseInt( tabIndex ) > -1 ) {\n            return tabElement;\n        }\n        // tab is in overflow\n        const tabContainer = tabElement.closest( '.sw-tabContainer' );\n        if( tabContainer ) {\n            const overflowBtn = tabContainer.nextElementSibling;\n            if( overflowBtn ) {\n                overflowBtn.querySelector( 'button' ).click();\n                let retryCounter = 0;\n                let popupTabElement;\n                let loadingElement;\n\n                setTimeout( function() {\n                    retryCounter = retryMaxCount; // After 10 seconds just quit\n                }, 10000 );\n\n                while( retryCounter < retryMaxCount ) {\n                    loadingElement = htmlUtils.getElementByXpath( '//div[contains(@class, \\'aw-popup-command-bar\\')]//div[contains(@class, \\'aw-jswidgets-loading\\')]', document.body );\n                    if( !loadingElement ) {\n                        popupTabElement = htmlUtils.getElementByXpath( `//li[@tabkey='${tabId}']`, document.body );\n                        if( popupTabElement ) {\n                            return popupTabElement;\n                        }\n                        retryCounter++;\n                    }\n                    await delay( idleTimeMs );\n                }\n            }\n        }\n    }\n};\n\n\n/**\n * Click on the tab\n *\n * @function clickOnTab\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\nexport const clickOnTab = async function( tabId, xPath ) {\n    const tabElement = await getTabElement( tabId, xPath );\n    if( tabElement ) {\n        tabElement.click();\n    }\n};\n\n/**\n * @function highlightTabBasedOnXPath\n * @param {String} tabId - ID of the tab to be highlighted\n * @param {String} xPath - xPath to the tab\n */\nexport const highlightTabBasedOnXPath = async function( tabId, xPath ) {\n    const tabElement = await getTabElement( tabId, xPath );\n    if( tabElement ) {\n        wcagSvc.afxFocusElement( tabElement );\n    }\n};\n\nconst exports = {\n    changeTab,\n    highlightTab,\n    getVisibleTabs,\n    registerTabSet,\n    unregisterTabSet,\n    clickOnTab,\n    highlightTabBasedOnXPath\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}