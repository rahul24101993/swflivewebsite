{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * This module provides core angularJS services abstraction.\n * Link below can we used for test complete accurate functionality:\n * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview\n *\n * For now all the use case in awParseService.test.js are guaranteed to work :)\n *\n * @module js/awParseService\n */import{processExpression,expressionCanSplit,parseNative}from'js/serviceUtils';import{$ParseProvider}from'js/angularjsParseService';const $parse=new $ParseProvider().$get[1]();const getRandomInt=max=>Math.floor(Math.random()*Math.floor(max));/**\n * The API splits the expression and parse it.\n * @param {String} expression - The String expression to parse\n * @param {Array} names - The String Array of Parameters\n * @param {Array} vals - The Array of parameter values.\n * @returns {Object} parsed value\n */const splitAndParse=(expression,names,vals)=>{if(!expressionCanSplit(expression)){return undefined;}const stack=processExpression(expression);let finalExpresions=stack.map((element,index)=>{if(element.expr){try{const response=parseNative(names,vals,null,element.expr);if(response===undefined){//Check unary operator case\nif(index<stack.length-1&&stack[index+1]==='+'||stack[index+1]==='-'){element.response=0;}if(index>0&&stack[index-1]==='+'||stack[index-1]==='-'){element.response=0;}}else{element.response=response;}}catch(e){//Check unary operator case\nif(index<stack.length-1&&stack[index+1]==='+'||stack[index+1]==='-'){element.response=0;}else if(index>0&&stack[index-1]==='+'||stack[index-1]==='-'){element.response=0;}else{element.response=undefined;}}}return element;});let params=[];let values=[];const finalExprs=finalExpresions.map(element=>{if(element.expr){//TODO: generate random number\nconst varName=\"param\".concat(getRandomInt(100000));params.push(varName);values.push(element.response);return varName;}return element;});const evalExpr=finalExprs.join('').trim();return parseNative(params,values,null,evalExpr);};const numberPropRe=/[a-zA-Z]\\.[0-9]/;export default class AwParseService{static instance(expression){if(!expression){return()=>undefined;}const originalParseFunction=function(evaluationCtx){let names=Object.keys(evaluationCtx);let vals=Object.values(evaluationCtx);try{const response=parseNative(names,vals,null,expression);// revisitme - what is this isNaN mean? for now limits it to number only\nif(typeof response==='number'&&isNaN(response)){return splitAndParse(expression,names,vals);}return response;}catch(e){//Split the expression and try to resolve\nreturn splitAndParse(expression,names,vals);}};//if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser\n//Some cases of this have been added in 6.1\nif(expression.match(numberPropRe)){return originalParseFunction;}try{const fn=$parse(expression);return function(evaluationCtx){return fn(evaluationCtx);};}catch(e){return originalParseFunction;}}}","map":null,"metadata":{},"sourceType":"module"}