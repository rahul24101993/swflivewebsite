{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\components\\\\src\\\\js\\\\AwTileCanvasService.js\";\nimport AwTileGroup from 'viewmodel/AwTileGroupViewModel';\nimport domUtils from 'js/domUtils';\nimport eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport tileDragSvc from 'js/tileDragService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst eleRef = domUtils.DOMAPIs;\nexport const awTileCanvasRenderFunction = props => {\n  const {\n    viewModel,\n    ctxMin,\n    actions,\n    i18n,\n    fields,\n    grids,\n    formProp,\n    messages,\n    ...prop\n  } = props;\n  const {\n    data\n  } = viewModel;\n  const {\n    dndHandler\n  } = prop;\n  let callback = getStartTileEditFn(viewModel, prop);\n  let subscriptions = viewModel.data.subscriptions;\n  let subscribedEventsStr = getEventSubscribtionsList(subscriptions);\n\n  if (_.isEmpty(viewModel.data.tileGroups) && !_.isEmpty(prop.tileGroups)) {\n    initialize(prop, viewModel);\n  }\n\n  const unPinTileCallback = () => {\n    if (!_.isEmpty(viewModel.data.tileGroups)) {\n      resetTilesEditFlag(viewModel);\n\n      _.defer(function () {\n        prop.unPinTileCallback && prop.unPinTileCallback(viewModel);\n      });\n    }\n  };\n\n  const tileClickCallback = () => {\n    if (!_.isEmpty(viewModel.data.tileGroups)) {\n      let vmprop = { ...viewModel.getData()\n      };\n      vmprop.isGatewayInEditMode = false;\n      viewModel.dispatch({\n        path: 'data',\n        value: { ...vmprop\n        }\n      });\n\n      _.defer(function () {\n        prop.tileClickCallback && prop.tileClickCallback(viewModel);\n      });\n    }\n  };\n\n  const handleDrag = (event, target, targetVMO) => {\n    if (dndHandler && dndHandler[event.type]) {\n      let fun = dndHandler[event.type];\n      fun(event, {\n        targetElement: target,\n        targetVMO: targetVMO\n      });\n    }\n  };\n\n  const handleDrop = (event, target, targetVMO) => {\n    if (dndHandler && dndHandler[event.type]) {\n      let funDrop = dndHandler[event.type];\n      funDrop(event, {\n        targetElement: target,\n        targetVMO: targetVMO\n      });\n    }\n  };\n\n  const handleDragAndDrop = {\n    drag: handleDrag,\n    drop: handleDrop,\n    draggable: true\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"aw-tile-canvas\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      \"data-locator\": \"tile-canvas\",\n      className: getCanvasClass(viewModel),\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"aw-tile-mainContainer aw-layout-flexColumnContainer\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"aw-tile-tileGroups aw-layout-flexRowContainer\",\n          children: [(prop.tileGroups || []).map((tileGroup, index) => createTileGroup(index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, e => {\n            callback(e);\n            tileGroup.toggleEdit && tileGroup.toggleEdit();\n          })), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"aw-tile-tileGroups\",\n            children: /*#__PURE__*/_jsxDEV(AwTileGroup, {\n              tileGroup: data.dummyTileGroup\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 76,\n              columnNumber: 29\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 65,\n    columnNumber: 9\n  }, this);\n};\n\nconst initialize = (prop, viewModel) => {\n  let data = { ...viewModel.getData()\n  };\n  data.tileGroups = prop.tileGroups || [];\n  viewModel.dispatch({\n    path: 'data',\n    value: { ...data\n    }\n  });\n};\n\nconst getCanvasClass = viewModel => {\n  let canvasClass = ['aw-tile-tileCanvasPanel aw-layout-flexColumn'];\n  canvasClass.push(viewModel.data.isGatewayInEditMode ? 'aw-tile-editMode' : '');\n  return canvasClass.join(' ');\n};\n\nconst createTileGroup = (index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, callback) => {\n  tileGroup.editTileCallback = callback;\n  tileGroup.isGatewayInEditMode = viewModel.data.isGatewayInEditMode; //tileGroup.handleDragAndDrop = handleDragAndDrop;\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: getTileGroupClass(tileGroup),\n    children: /*#__PURE__*/_jsxDEV(AwTileGroup, {\n      tileGroup: tileGroup,\n      handleDragAndDrop: handleDragAndDrop,\n      unPinTileCallback: unPinTileCallback,\n      tileClickCallback: tileClickCallback\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 13\n    }, this)\n  }, index, false, {\n    fileName: _jsxFileName,\n    lineNumber: 102,\n    columnNumber: 9\n  }, this);\n};\n\nconst getTileGroupClass = tileGroup => {\n  let tileGroupClass = ['aw-tile-tileGroup aw-layout-flexRowContainer'];\n  tileGroupClass.push(tileGroup.tiles.length === 0 ? 'aw-tile-emptyTileGroup' : '');\n  return tileGroupClass.join(' ');\n};\n/**\n * Callback Fn triggered from AwTile for tile edit\n * @param {*} viewModel viewModel\n * @returns {*} anonymous function triggered on 'contextmenu'\n */\n\n\nlet _removeHanlder = [];\n\nconst getStartTileEditFn = (viewModel, prop) => {\n  let canvasViewModel = { ...viewModel\n  };\n  return event => {\n    let data = { ...canvasViewModel.getData()\n    };\n    data.isGatewayInEditMode = true;\n    canvasViewModel.dispatch({\n      path: 'data',\n      value: { ...data\n      }\n    });\n    emptyHandler();\n    let handler = handleDocumentClick.bind(null, canvasViewModel, prop);\n    document.addEventListener('click', handler);\n    document.addEventListener('touchstart', handler);\n\n    _removeHanlder.push(() => document.removeEventListener('click', handler));\n\n    _removeHanlder.push(() => document.removeEventListener('touchstart', handler));\n  };\n};\n/**\n *\n * @param {*} viewModel canvasViewModel\n * @param {*} event onClick MouseEvent\n */\n\n\nconst handleDocumentClick = function (viewModel, prop, event) {\n  if (event && event.target && event.target.parentElement) {\n    let isEditingTile = domUtils.DOMAPIs.closest(event.target, '.aw-tile-tileContainer');\n\n    if (!isEditingTile || isEditingTile.length === 0) {\n      stopEditing(viewModel, prop);\n    }\n  }\n};\n\nconst stopEditing = (viewModel, prop) => {\n  resetTilesEditFlag(viewModel);\n  let dirtyTiles = findDirtyTiles(viewModel);\n\n  if (dirtyTiles && dirtyTiles.tiles.length > 0) {\n    eventBus.publish('gateway.updateTile', dirtyTiles);\n    prop.updateTileCallback && prop.updateTileCallback();\n  }\n\n  emptyHandler();\n};\n\nconst emptyHandler = () => {\n  if (_removeHanlder.length > 0) {\n    _removeHanlder.forEach(tile => tile());\n\n    _removeHanlder = [];\n  }\n};\n\nconst resetTilesEditFlag = viewModel => {\n  _.forEach(viewModel.data.tileGroups, tileGroup => {\n    if (tileGroup && tileGroup.tiles) {\n      _.forEach(tileGroup.tiles, tile => {\n        if (tile && tile.editing) {\n          delete tile.editing;\n        }\n      });\n    }\n  });\n\n  let vmprop = { ...viewModel.getData()\n  };\n  vmprop.isGatewayInEditMode = false;\n  viewModel.dispatch({\n    path: 'data',\n    value: { ...vmprop\n    }\n  });\n};\n\nconst findDirtyTiles = viewModel => {\n  var dirtyTiles = {};\n  dirtyTiles.tiles = [];\n  dirtyTiles.groupNames = [];\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup) {\n    if (tileGroup && tileGroup.tiles) {\n      _.forEach(tileGroup.tiles, function (tile) {\n        if (tile && tile.isDirty) {\n          // reset dirty state and return the tile info\n          delete tile.isDirty;\n          delete tile.$$hashKey;\n\n          _.forEach(tile.content, function (content) {\n            if (content) {\n              delete content.$$hashKey;\n            }\n          });\n\n          dirtyTiles.tiles.push(tile);\n          dirtyTiles.groupNames.push(tileGroup.groupName);\n        }\n      });\n    }\n  });\n\n  return dirtyTiles;\n};\n\nconst getEventSubscribtionsList = subscriptions => {\n  let subscribedEventsStr = [];\n\n  if (subscriptions.length !== 0) {\n    subscriptions.map(eventSubscribed => {\n      subscribedEventsStr.push(eventSubscribed.topic);\n    });\n  }\n\n  return subscribedEventsStr;\n};\n/**\n * Create New Tile Group while DnD tiles\n *\n * @param {*} sourceTile sourceTile\n * @param {*} sourceGroupName sourceGroupName\n * @param {*} targetTileGroup targetTileGroup\n */\n\n\nexport const createNewTileGroup = (sourceTile, sourceGroupName, targetTileGroup) => {\n  //TODO: hook viewModel while working on Drag n Drop. May be pass from the DnD service or something\n  let viewModel;\n  var sourceGroup = getTileGroup(viewModel, sourceGroupName);\n  var sourceGroupIndx = viewModel && viewModel.data.tileGroups.indexOf(sourceGroup);\n  var targetGroupIndx = viewModel && viewModel.tileGroups.indexOf(targetTileGroup);\n  var sourceTileIn = retrieveTileInTileGroup(viewModel, sourceTile, sourceGroupIndx);\n  var sourceTileIndx = viewModel && viewModel.data.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n  var baseOrder = 0;\n  var newGroupIncrement = 100;\n\n  if (targetTileGroup && targetTileGroup.tiles.length > 0) {\n    baseOrder = tileDragSvc.getBaseOrder(targetTileGroup.tiles[0].orderNumber);\n  } // remove tile from source group\n\n\n  var srcGroup = viewModel && viewModel.data.tileGroups[sourceGroupIndx];\n  srcGroup.tiles.splice(sourceTileIndx, 1);\n  var srcGroupNull = false; // If we removed the last tile in the group\n\n  if (srcGroup.tiles.length === 0) {\n    srcGroupNull = true;\n  } // create new group using current time\n\n\n  var newGroup = {};\n  newGroup.groupName = 'group' + new Date().getTime(); // add sourceTile to newly created group\n\n  newGroup.tiles = [];\n  newGroup.tiles.push(sourceTileIn);\n  newGroup.tiles.forEach(function (tile, indx) {\n    tile.orderNumber = baseOrder + newGroupIncrement + indx;\n    tile.isDirty = true;\n  }); // update tileGroups array\n\n  if (sourceGroupIndx === targetGroupIndx && srcGroupNull) {\n    viewModel && viewModel.data.tileGroups.splice(targetGroupIndx, 0, newGroup);\n  } else {\n    viewModel && viewModel.data.tileGroups.splice(targetGroupIndx + 1, 0, newGroup);\n  }\n\n  var newGroupIndx = viewModel && viewModel.data.tileGroups.indexOf(newGroup); // update order number for all tiles in each and every tile group\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup, index) {\n    if (index > newGroupIndx && tileGroup.tiles.length > 0) {\n      var grpBaseOrder = tileDragSvc.getBaseOrder(tileGroup.tiles[0].orderNumber);\n      tileGroup.tiles.map(function (tile, indx) {\n        tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n        return tile;\n      });\n    }\n  });\n\n  viewModel && viewModel.dispatch({\n    path: 'data',\n    value: { ...viewModel.data\n    }\n  });\n};\n\nconst getTileGroup = (viewModel, groupName) => {\n  var tileGroupIn;\n\n  _.forEach(viewModel && viewModel.data.tileGroups, function (tileGroup) {\n    if (tileGroup.groupName === groupName) {\n      tileGroupIn = tileGroup;\n      return false;\n    }\n\n    return null;\n  });\n\n  return tileGroupIn;\n};\n\nconst retrieveTileInTileGroup = (viewModel, tile, groupIndex) => {\n  var retrievedTile;\n\n  if (viewModel && viewModel.data.tileGroups[groupIndex] && !_.isEmpty(viewModel && viewModel.data.tileGroups[groupIndex].tiles)) {\n    _.forEach(viewModel.data.tileGroups[groupIndex].tiles, function (tileObj) {\n      if (_.isEqual(tileObj, tile)) {\n        retrievedTile = tileObj;\n        return false;\n      }\n\n      return null;\n    });\n  }\n\n  return retrievedTile;\n};","map":{"version":3,"names":["AwTileGroup","domUtils","eventBus","_","tileDragSvc","eleRef","DOMAPIs","awTileCanvasRenderFunction","props","viewModel","ctxMin","actions","i18n","fields","grids","formProp","messages","prop","data","dndHandler","callback","getStartTileEditFn","subscriptions","subscribedEventsStr","getEventSubscribtionsList","isEmpty","tileGroups","initialize","unPinTileCallback","resetTilesEditFlag","defer","tileClickCallback","vmprop","getData","isGatewayInEditMode","dispatch","path","value","handleDrag","event","target","targetVMO","type","fun","targetElement","handleDrop","funDrop","handleDragAndDrop","drag","drop","draggable","getCanvasClass","map","tileGroup","index","createTileGroup","e","toggleEdit","dummyTileGroup","canvasClass","push","join","editTileCallback","getTileGroupClass","tileGroupClass","tiles","length","_removeHanlder","canvasViewModel","emptyHandler","handler","handleDocumentClick","bind","document","addEventListener","removeEventListener","parentElement","isEditingTile","closest","stopEditing","dirtyTiles","findDirtyTiles","publish","updateTileCallback","forEach","tile","editing","groupNames","isDirty","$$hashKey","content","groupName","eventSubscribed","topic","createNewTileGroup","sourceTile","sourceGroupName","targetTileGroup","sourceGroup","getTileGroup","sourceGroupIndx","indexOf","targetGroupIndx","sourceTileIn","retrieveTileInTileGroup","sourceTileIndx","baseOrder","newGroupIncrement","getBaseOrder","orderNumber","srcGroup","splice","srcGroupNull","newGroup","Date","getTime","indx","newGroupIndx","grpBaseOrder","tileGroupIn","groupIndex","retrievedTile","tileObj","isEqual"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/components/src/js/AwTileCanvasService.js"],"sourcesContent":["import AwTileGroup from 'viewmodel/AwTileGroupViewModel';\nimport domUtils from 'js/domUtils';\nimport eventBus from 'js/eventBus';\nimport _ from 'lodash';\nimport tileDragSvc from 'js/tileDragService';\nconst eleRef = domUtils.DOMAPIs;\n\nexport const awTileCanvasRenderFunction = ( props ) => {\n    const {\n        viewModel,\n        ctxMin,\n        actions,\n        i18n,\n        fields,\n        grids,\n        formProp,\n        messages,\n        ...prop\n    } = props;\n    const { data } = viewModel;\n    const { dndHandler } = prop;\n    let callback = getStartTileEditFn( viewModel, prop );\n    let subscriptions = viewModel.data.subscriptions;\n    let subscribedEventsStr = getEventSubscribtionsList( subscriptions );\n\n    if( _.isEmpty( viewModel.data.tileGroups ) && !_.isEmpty( prop.tileGroups ) ) {\n        initialize( prop, viewModel );\n    }\n\n    const unPinTileCallback = () => {\n        if( !_.isEmpty( viewModel.data.tileGroups ) ) {\n            resetTilesEditFlag( viewModel );\n            _.defer( function() {\n                prop.unPinTileCallback && prop.unPinTileCallback( viewModel );\n            } );\n        }\n    };\n\n    const tileClickCallback = () => {\n        if( !_.isEmpty( viewModel.data.tileGroups ) ) {\n            let vmprop = { ...viewModel.getData() };\n            vmprop.isGatewayInEditMode = false;\n            viewModel.dispatch( { path: 'data', value: { ...vmprop } } );\n            _.defer( function() {\n                prop.tileClickCallback && prop.tileClickCallback( viewModel );\n            } );\n        }\n    };\n\n    const handleDrag = (  event, target, targetVMO  ) => {\n        if( dndHandler && dndHandler[ event.type ] ) {\n            let fun = dndHandler[ event.type ];\n            fun( event, { targetElement: target, targetVMO: targetVMO } );\n        }\n    };\n\n    const handleDrop = (  event, target, targetVMO  ) => {\n        if( dndHandler && dndHandler[ event.type ] ) {\n            let funDrop = dndHandler[ event.type ];\n            funDrop( event, { targetElement: target, targetVMO: targetVMO } );\n        }\n    };\n    const handleDragAndDrop = { drag: handleDrag, drop: handleDrop, draggable: true };\n    return (\n        <div className='aw-tile-canvas'>\n            <div data-locator='tile-canvas' className={getCanvasClass( viewModel )}>\n                <div className='aw-tile-mainContainer aw-layout-flexColumnContainer'>\n                    <div className='aw-tile-tileGroups aw-layout-flexRowContainer'>\n                        {\n                            ( prop.tileGroups || [] ).map( ( tileGroup, index ) =>createTileGroup( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, ( e ) =>{\n                                callback( e );\n                                tileGroup.toggleEdit && tileGroup.toggleEdit();\n                            } ) )\n                        }\n                        <div className='aw-tile-tileGroups'>\n                            <AwTileGroup tileGroup={data.dummyTileGroup}></AwTileGroup>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nconst initialize = ( prop, viewModel ) => {\n    let data = { ...viewModel.getData() };\n    data.tileGroups = prop.tileGroups || [];\n    viewModel.dispatch( { path: 'data', value: { ...data } } );\n};\n\nconst getCanvasClass = ( viewModel ) => {\n    let canvasClass = [ 'aw-tile-tileCanvasPanel aw-layout-flexColumn' ];\n    canvasClass.push( viewModel.data.isGatewayInEditMode ? 'aw-tile-editMode' : '' );\n    return canvasClass.join( ' ' );\n};\n\nconst createTileGroup = ( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, callback ) => {\n    tileGroup.editTileCallback = callback;\n    tileGroup.isGatewayInEditMode = viewModel.data.isGatewayInEditMode;\n    //tileGroup.handleDragAndDrop = handleDragAndDrop;\n    return (\n        <div key={index} className={getTileGroupClass( tileGroup )}>\n            <AwTileGroup tileGroup={tileGroup} handleDragAndDrop={handleDragAndDrop} unPinTileCallback={unPinTileCallback} tileClickCallback={tileClickCallback}></AwTileGroup>\n        </div>\n    );\n};\n\nconst getTileGroupClass = ( tileGroup ) => {\n    let tileGroupClass = [ 'aw-tile-tileGroup aw-layout-flexRowContainer' ];\n    tileGroupClass.push( tileGroup.tiles.length === 0 ? 'aw-tile-emptyTileGroup' : '' );\n    return tileGroupClass.join( ' ' );\n};\n\n/**\n * Callback Fn triggered from AwTile for tile edit\n * @param {*} viewModel viewModel\n * @returns {*} anonymous function triggered on 'contextmenu'\n */\nlet _removeHanlder = [];\nconst getStartTileEditFn = ( viewModel, prop ) => {\n    let canvasViewModel = { ...viewModel };\n    return ( event ) => {\n        let data = { ...canvasViewModel.getData() };\n        data.isGatewayInEditMode = true;\n        canvasViewModel.dispatch( { path: 'data', value: { ...data } } );\n        emptyHandler();\n\n        let handler = handleDocumentClick.bind( null, canvasViewModel, prop );\n\n        document.addEventListener( 'click', handler );\n        document.addEventListener( 'touchstart', handler );\n\n        _removeHanlder.push( () => document.removeEventListener( 'click', handler ) );\n        _removeHanlder.push( () => document.removeEventListener( 'touchstart', handler ) );\n    };\n};\n\n/**\n *\n * @param {*} viewModel canvasViewModel\n * @param {*} event onClick MouseEvent\n */\nconst handleDocumentClick = function( viewModel, prop, event ) {\n    if( event && event.target && event.target.parentElement ) {\n        let isEditingTile = domUtils.DOMAPIs.closest( event.target, '.aw-tile-tileContainer' );\n        if( !isEditingTile || isEditingTile.length === 0 ) {\n            stopEditing( viewModel, prop );\n        }\n    }\n};\n\nconst stopEditing = ( viewModel, prop ) => {\n    resetTilesEditFlag( viewModel );\n\n    let dirtyTiles = findDirtyTiles( viewModel );\n    if( dirtyTiles && dirtyTiles.tiles.length > 0 ) {\n        eventBus.publish( 'gateway.updateTile', dirtyTiles );\n        prop.updateTileCallback && prop.updateTileCallback();\n    }\n\n    emptyHandler();\n};\n\nconst emptyHandler = () => {\n    if( _removeHanlder.length > 0 ) {\n        _removeHanlder.forEach( ( tile ) => tile() );\n        _removeHanlder = [];\n    }\n};\n\nconst resetTilesEditFlag = ( viewModel ) => {\n    _.forEach( viewModel.data.tileGroups, ( tileGroup ) => {\n        if( tileGroup && tileGroup.tiles ) {\n            _.forEach( tileGroup.tiles, ( tile ) => {\n                if( tile && tile.editing ) {\n                    delete tile.editing;\n                }\n            } );\n        }\n    } );\n    let vmprop = { ...viewModel.getData() };\n    vmprop.isGatewayInEditMode = false;\n    viewModel.dispatch( { path: 'data', value: { ...vmprop } } );\n};\n\nconst findDirtyTiles = ( viewModel ) => {\n    var dirtyTiles = {};\n    dirtyTiles.tiles = [];\n    dirtyTiles.groupNames = [];\n\n    _.forEach(  viewModel && viewModel.data.tileGroups, function( tileGroup ) {\n        if( tileGroup && tileGroup.tiles ) {\n            _.forEach( tileGroup.tiles, function( tile ) {\n                if( tile && tile.isDirty ) {\n                    // reset dirty state and return the tile info\n                    delete tile.isDirty;\n                    delete tile.$$hashKey;\n                    _.forEach( tile.content, function( content ) {\n                        if( content ) {\n                            delete content.$$hashKey;\n                        }\n                    } );\n\n                    dirtyTiles.tiles.push( tile );\n                    dirtyTiles.groupNames.push( tileGroup.groupName );\n                }\n            } );\n        }\n    } );\n\n    return dirtyTiles;\n};\n\nconst getEventSubscribtionsList = ( subscriptions ) => {\n    let subscribedEventsStr = [];\n    if( subscriptions.length !== 0 ) {\n        subscriptions.map( ( eventSubscribed ) => {\n            subscribedEventsStr.push( eventSubscribed.topic );\n        } );\n    }\n    return subscribedEventsStr;\n};\n\n/**\n * Create New Tile Group while DnD tiles\n *\n * @param {*} sourceTile sourceTile\n * @param {*} sourceGroupName sourceGroupName\n * @param {*} targetTileGroup targetTileGroup\n */\nexport const createNewTileGroup = ( sourceTile, sourceGroupName, targetTileGroup ) => {\n    //TODO: hook viewModel while working on Drag n Drop. May be pass from the DnD service or something\n    let viewModel;\n\n    var sourceGroup = getTileGroup( viewModel, sourceGroupName );\n    var sourceGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( sourceGroup );\n    var targetGroupIndx = viewModel && viewModel.tileGroups.indexOf( targetTileGroup );\n\n    var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );\n    var sourceTileIndx = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n\n    var baseOrder = 0;\n    var newGroupIncrement = 100;\n    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {\n        baseOrder = tileDragSvc.getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );\n    }\n\n    // remove tile from source group\n    var srcGroup = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ];\n    srcGroup.tiles.splice( sourceTileIndx, 1 );\n\n    var srcGroupNull = false;\n    // If we removed the last tile in the group\n    if( srcGroup.tiles.length === 0 ) {\n        srcGroupNull = true;\n    }\n\n    // create new group using current time\n    var newGroup = {};\n    newGroup.groupName = 'group' + new Date().getTime();\n\n    // add sourceTile to newly created group\n    newGroup.tiles = [];\n    newGroup.tiles.push( sourceTileIn );\n\n    newGroup.tiles.forEach( function( tile, indx ) {\n        tile.orderNumber = baseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n    } );\n\n    // update tileGroups array\n    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {\n        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx, 0, newGroup );\n    } else {\n        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );\n    }\n\n    var newGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( newGroup );\n\n    // update order number for all tiles in each and every tile group\n    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup, index ) {\n        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {\n            var grpBaseOrder = tileDragSvc.getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );\n            tileGroup.tiles.map( function( tile, indx ) {\n                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n                tile.isDirty = true;\n                return tile;\n            } );\n        }\n    } );\n    viewModel &&  viewModel.dispatch( { path: 'data', value: { ...viewModel.data } } );\n};\n\nconst getTileGroup = ( viewModel, groupName ) => {\n    var tileGroupIn;\n\n    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup ) {\n        if( tileGroup.groupName === groupName ) {\n            tileGroupIn = tileGroup;\n            return false;\n        }\n        return null;\n    } );\n\n    return tileGroupIn;\n};\n\nconst retrieveTileInTileGroup = ( viewModel, tile, groupIndex ) => {\n    var retrievedTile;\n\n    if( viewModel && viewModel.data.tileGroups[ groupIndex ] && !_.isEmpty( viewModel && viewModel.data.tileGroups[ groupIndex ].tiles ) ) {\n        _.forEach( viewModel.data.tileGroups[ groupIndex ].tiles, function( tileObj ) {\n            if( _.isEqual( tileObj, tile ) ) {\n                retrievedTile = tileObj;\n                return false;\n            }\n            return null;\n        } );\n    }\n\n    return retrievedTile;\n};\n"],"mappings":";AAAA,OAAOA,WAAP,MAAwB,gCAAxB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,CAAP,MAAc,QAAd;AACA,OAAOC,WAAP,MAAwB,oBAAxB;;AACA,MAAMC,MAAM,GAAGJ,QAAQ,CAACK,OAAxB;AAEA,OAAO,MAAMC,0BAA0B,GAAKC,KAAF,IAAa;EACnD,MAAM;IACFC,SADE;IAEFC,MAFE;IAGFC,OAHE;IAIFC,IAJE;IAKFC,MALE;IAMFC,KANE;IAOFC,QAPE;IAQFC,QARE;IASF,GAAGC;EATD,IAUFT,KAVJ;EAWA,MAAM;IAAEU;EAAF,IAAWT,SAAjB;EACA,MAAM;IAAEU;EAAF,IAAiBF,IAAvB;EACA,IAAIG,QAAQ,GAAGC,kBAAkB,CAAEZ,SAAF,EAAaQ,IAAb,CAAjC;EACA,IAAIK,aAAa,GAAGb,SAAS,CAACS,IAAV,CAAeI,aAAnC;EACA,IAAIC,mBAAmB,GAAGC,yBAAyB,CAAEF,aAAF,CAAnD;;EAEA,IAAInB,CAAC,CAACsB,OAAF,CAAWhB,SAAS,CAACS,IAAV,CAAeQ,UAA1B,KAA0C,CAACvB,CAAC,CAACsB,OAAF,CAAWR,IAAI,CAACS,UAAhB,CAA/C,EAA8E;IAC1EC,UAAU,CAAEV,IAAF,EAAQR,SAAR,CAAV;EACH;;EAED,MAAMmB,iBAAiB,GAAG,MAAM;IAC5B,IAAI,CAACzB,CAAC,CAACsB,OAAF,CAAWhB,SAAS,CAACS,IAAV,CAAeQ,UAA1B,CAAL,EAA8C;MAC1CG,kBAAkB,CAAEpB,SAAF,CAAlB;;MACAN,CAAC,CAAC2B,KAAF,CAAS,YAAW;QAChBb,IAAI,CAACW,iBAAL,IAA0BX,IAAI,CAACW,iBAAL,CAAwBnB,SAAxB,CAA1B;MACH,CAFD;IAGH;EACJ,CAPD;;EASA,MAAMsB,iBAAiB,GAAG,MAAM;IAC5B,IAAI,CAAC5B,CAAC,CAACsB,OAAF,CAAWhB,SAAS,CAACS,IAAV,CAAeQ,UAA1B,CAAL,EAA8C;MAC1C,IAAIM,MAAM,GAAG,EAAE,GAAGvB,SAAS,CAACwB,OAAV;MAAL,CAAb;MACAD,MAAM,CAACE,mBAAP,GAA6B,KAA7B;MACAzB,SAAS,CAAC0B,QAAV,CAAoB;QAAEC,IAAI,EAAE,MAAR;QAAgBC,KAAK,EAAE,EAAE,GAAGL;QAAL;MAAvB,CAApB;;MACA7B,CAAC,CAAC2B,KAAF,CAAS,YAAW;QAChBb,IAAI,CAACc,iBAAL,IAA0Bd,IAAI,CAACc,iBAAL,CAAwBtB,SAAxB,CAA1B;MACH,CAFD;IAGH;EACJ,CATD;;EAWA,MAAM6B,UAAU,GAAG,CAAGC,KAAH,EAAUC,MAAV,EAAkBC,SAAlB,KAAkC;IACjD,IAAItB,UAAU,IAAIA,UAAU,CAAEoB,KAAK,CAACG,IAAR,CAA5B,EAA6C;MACzC,IAAIC,GAAG,GAAGxB,UAAU,CAAEoB,KAAK,CAACG,IAAR,CAApB;MACAC,GAAG,CAAEJ,KAAF,EAAS;QAAEK,aAAa,EAAEJ,MAAjB;QAAyBC,SAAS,EAAEA;MAApC,CAAT,CAAH;IACH;EACJ,CALD;;EAOA,MAAMI,UAAU,GAAG,CAAGN,KAAH,EAAUC,MAAV,EAAkBC,SAAlB,KAAkC;IACjD,IAAItB,UAAU,IAAIA,UAAU,CAAEoB,KAAK,CAACG,IAAR,CAA5B,EAA6C;MACzC,IAAII,OAAO,GAAG3B,UAAU,CAAEoB,KAAK,CAACG,IAAR,CAAxB;MACAI,OAAO,CAAEP,KAAF,EAAS;QAAEK,aAAa,EAAEJ,MAAjB;QAAyBC,SAAS,EAAEA;MAApC,CAAT,CAAP;IACH;EACJ,CALD;;EAMA,MAAMM,iBAAiB,GAAG;IAAEC,IAAI,EAAEV,UAAR;IAAoBW,IAAI,EAAEJ,UAA1B;IAAsCK,SAAS,EAAE;EAAjD,CAA1B;EACA,oBACI;IAAK,SAAS,EAAC,gBAAf;IAAA,uBACI;MAAK,gBAAa,aAAlB;MAAgC,SAAS,EAAEC,cAAc,CAAE1C,SAAF,CAAzD;MAAA,uBACI;QAAK,SAAS,EAAC,qDAAf;QAAA,uBACI;UAAK,SAAS,EAAC,+CAAf;UAAA,WAEQ,CAAEQ,IAAI,CAACS,UAAL,IAAmB,EAArB,EAA0B0B,GAA1B,CAA+B,CAAEC,SAAF,EAAaC,KAAb,KAAuBC,eAAe,CAAED,KAAF,EAAS7C,SAAT,EAAoB4C,SAApB,EAA+BN,iBAA/B,EAAkDnB,iBAAlD,EAAqEG,iBAArE,EAA0FyB,CAAF,IAAQ;YACjKpC,QAAQ,CAAEoC,CAAF,CAAR;YACAH,SAAS,CAACI,UAAV,IAAwBJ,SAAS,CAACI,UAAV,EAAxB;UACH,CAHoE,CAArE,CAFR,eAOI;YAAK,SAAS,EAAC,oBAAf;YAAA,uBACI,QAAC,WAAD;cAAa,SAAS,EAAEvC,IAAI,CAACwC;YAA7B;cAAA;cAAA;cAAA;YAAA;UADJ;YAAA;YAAA;YAAA;UAAA,QAPJ;QAAA;UAAA;UAAA;UAAA;QAAA;MADJ;QAAA;QAAA;QAAA;MAAA;IADJ;MAAA;MAAA;MAAA;IAAA;EADJ;IAAA;IAAA;IAAA;EAAA,QADJ;AAmBH,CA3EM;;AA6EP,MAAM/B,UAAU,GAAG,CAAEV,IAAF,EAAQR,SAAR,KAAuB;EACtC,IAAIS,IAAI,GAAG,EAAE,GAAGT,SAAS,CAACwB,OAAV;EAAL,CAAX;EACAf,IAAI,CAACQ,UAAL,GAAkBT,IAAI,CAACS,UAAL,IAAmB,EAArC;EACAjB,SAAS,CAAC0B,QAAV,CAAoB;IAAEC,IAAI,EAAE,MAAR;IAAgBC,KAAK,EAAE,EAAE,GAAGnB;IAAL;EAAvB,CAApB;AACH,CAJD;;AAMA,MAAMiC,cAAc,GAAK1C,SAAF,IAAiB;EACpC,IAAIkD,WAAW,GAAG,CAAE,8CAAF,CAAlB;EACAA,WAAW,CAACC,IAAZ,CAAkBnD,SAAS,CAACS,IAAV,CAAegB,mBAAf,GAAqC,kBAArC,GAA0D,EAA5E;EACA,OAAOyB,WAAW,CAACE,IAAZ,CAAkB,GAAlB,CAAP;AACH,CAJD;;AAMA,MAAMN,eAAe,GAAG,CAAED,KAAF,EAAS7C,SAAT,EAAoB4C,SAApB,EAA+BN,iBAA/B,EAAkDnB,iBAAlD,EAAqEG,iBAArE,EAAwFX,QAAxF,KAAsG;EAC1HiC,SAAS,CAACS,gBAAV,GAA6B1C,QAA7B;EACAiC,SAAS,CAACnB,mBAAV,GAAgCzB,SAAS,CAACS,IAAV,CAAegB,mBAA/C,CAF0H,CAG1H;;EACA,oBACI;IAAiB,SAAS,EAAE6B,iBAAiB,CAAEV,SAAF,CAA7C;IAAA,uBACI,QAAC,WAAD;MAAa,SAAS,EAAEA,SAAxB;MAAmC,iBAAiB,EAAEN,iBAAtD;MAAyE,iBAAiB,EAAEnB,iBAA5F;MAA+G,iBAAiB,EAAEG;IAAlI;MAAA;MAAA;MAAA;IAAA;EADJ,GAAUuB,KAAV;IAAA;IAAA;IAAA;EAAA,QADJ;AAKH,CATD;;AAWA,MAAMS,iBAAiB,GAAKV,SAAF,IAAiB;EACvC,IAAIW,cAAc,GAAG,CAAE,8CAAF,CAArB;EACAA,cAAc,CAACJ,IAAf,CAAqBP,SAAS,CAACY,KAAV,CAAgBC,MAAhB,KAA2B,CAA3B,GAA+B,wBAA/B,GAA0D,EAA/E;EACA,OAAOF,cAAc,CAACH,IAAf,CAAqB,GAArB,CAAP;AACH,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAIM,cAAc,GAAG,EAArB;;AACA,MAAM9C,kBAAkB,GAAG,CAAEZ,SAAF,EAAaQ,IAAb,KAAuB;EAC9C,IAAImD,eAAe,GAAG,EAAE,GAAG3D;EAAL,CAAtB;EACA,OAAS8B,KAAF,IAAa;IAChB,IAAIrB,IAAI,GAAG,EAAE,GAAGkD,eAAe,CAACnC,OAAhB;IAAL,CAAX;IACAf,IAAI,CAACgB,mBAAL,GAA2B,IAA3B;IACAkC,eAAe,CAACjC,QAAhB,CAA0B;MAAEC,IAAI,EAAE,MAAR;MAAgBC,KAAK,EAAE,EAAE,GAAGnB;MAAL;IAAvB,CAA1B;IACAmD,YAAY;IAEZ,IAAIC,OAAO,GAAGC,mBAAmB,CAACC,IAApB,CAA0B,IAA1B,EAAgCJ,eAAhC,EAAiDnD,IAAjD,CAAd;IAEAwD,QAAQ,CAACC,gBAAT,CAA2B,OAA3B,EAAoCJ,OAApC;IACAG,QAAQ,CAACC,gBAAT,CAA2B,YAA3B,EAAyCJ,OAAzC;;IAEAH,cAAc,CAACP,IAAf,CAAqB,MAAMa,QAAQ,CAACE,mBAAT,CAA8B,OAA9B,EAAuCL,OAAvC,CAA3B;;IACAH,cAAc,CAACP,IAAf,CAAqB,MAAMa,QAAQ,CAACE,mBAAT,CAA8B,YAA9B,EAA4CL,OAA5C,CAA3B;EACH,CAbD;AAcH,CAhBD;AAkBA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,mBAAmB,GAAG,UAAU9D,SAAV,EAAqBQ,IAArB,EAA2BsB,KAA3B,EAAmC;EAC3D,IAAIA,KAAK,IAAIA,KAAK,CAACC,MAAf,IAAyBD,KAAK,CAACC,MAAN,CAAaoC,aAA1C,EAA0D;IACtD,IAAIC,aAAa,GAAG5E,QAAQ,CAACK,OAAT,CAAiBwE,OAAjB,CAA0BvC,KAAK,CAACC,MAAhC,EAAwC,wBAAxC,CAApB;;IACA,IAAI,CAACqC,aAAD,IAAkBA,aAAa,CAACX,MAAd,KAAyB,CAA/C,EAAmD;MAC/Ca,WAAW,CAAEtE,SAAF,EAAaQ,IAAb,CAAX;IACH;EACJ;AACJ,CAPD;;AASA,MAAM8D,WAAW,GAAG,CAAEtE,SAAF,EAAaQ,IAAb,KAAuB;EACvCY,kBAAkB,CAAEpB,SAAF,CAAlB;EAEA,IAAIuE,UAAU,GAAGC,cAAc,CAAExE,SAAF,CAA/B;;EACA,IAAIuE,UAAU,IAAIA,UAAU,CAACf,KAAX,CAAiBC,MAAjB,GAA0B,CAA5C,EAAgD;IAC5ChE,QAAQ,CAACgF,OAAT,CAAkB,oBAAlB,EAAwCF,UAAxC;IACA/D,IAAI,CAACkE,kBAAL,IAA2BlE,IAAI,CAACkE,kBAAL,EAA3B;EACH;;EAEDd,YAAY;AACf,CAVD;;AAYA,MAAMA,YAAY,GAAG,MAAM;EACvB,IAAIF,cAAc,CAACD,MAAf,GAAwB,CAA5B,EAAgC;IAC5BC,cAAc,CAACiB,OAAf,CAA0BC,IAAF,IAAYA,IAAI,EAAxC;;IACAlB,cAAc,GAAG,EAAjB;EACH;AACJ,CALD;;AAOA,MAAMtC,kBAAkB,GAAKpB,SAAF,IAAiB;EACxCN,CAAC,CAACiF,OAAF,CAAW3E,SAAS,CAACS,IAAV,CAAeQ,UAA1B,EAAwC2B,SAAF,IAAiB;IACnD,IAAIA,SAAS,IAAIA,SAAS,CAACY,KAA3B,EAAmC;MAC/B9D,CAAC,CAACiF,OAAF,CAAW/B,SAAS,CAACY,KAArB,EAA8BoB,IAAF,IAAY;QACpC,IAAIA,IAAI,IAAIA,IAAI,CAACC,OAAjB,EAA2B;UACvB,OAAOD,IAAI,CAACC,OAAZ;QACH;MACJ,CAJD;IAKH;EACJ,CARD;;EASA,IAAItD,MAAM,GAAG,EAAE,GAAGvB,SAAS,CAACwB,OAAV;EAAL,CAAb;EACAD,MAAM,CAACE,mBAAP,GAA6B,KAA7B;EACAzB,SAAS,CAAC0B,QAAV,CAAoB;IAAEC,IAAI,EAAE,MAAR;IAAgBC,KAAK,EAAE,EAAE,GAAGL;IAAL;EAAvB,CAApB;AACH,CAbD;;AAeA,MAAMiD,cAAc,GAAKxE,SAAF,IAAiB;EACpC,IAAIuE,UAAU,GAAG,EAAjB;EACAA,UAAU,CAACf,KAAX,GAAmB,EAAnB;EACAe,UAAU,CAACO,UAAX,GAAwB,EAAxB;;EAEApF,CAAC,CAACiF,OAAF,CAAY3E,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAxC,EAAoD,UAAU2B,SAAV,EAAsB;IACtE,IAAIA,SAAS,IAAIA,SAAS,CAACY,KAA3B,EAAmC;MAC/B9D,CAAC,CAACiF,OAAF,CAAW/B,SAAS,CAACY,KAArB,EAA4B,UAAUoB,IAAV,EAAiB;QACzC,IAAIA,IAAI,IAAIA,IAAI,CAACG,OAAjB,EAA2B;UACvB;UACA,OAAOH,IAAI,CAACG,OAAZ;UACA,OAAOH,IAAI,CAACI,SAAZ;;UACAtF,CAAC,CAACiF,OAAF,CAAWC,IAAI,CAACK,OAAhB,EAAyB,UAAUA,OAAV,EAAoB;YACzC,IAAIA,OAAJ,EAAc;cACV,OAAOA,OAAO,CAACD,SAAf;YACH;UACJ,CAJD;;UAMAT,UAAU,CAACf,KAAX,CAAiBL,IAAjB,CAAuByB,IAAvB;UACAL,UAAU,CAACO,UAAX,CAAsB3B,IAAtB,CAA4BP,SAAS,CAACsC,SAAtC;QACH;MACJ,CAdD;IAeH;EACJ,CAlBD;;EAoBA,OAAOX,UAAP;AACH,CA1BD;;AA4BA,MAAMxD,yBAAyB,GAAKF,aAAF,IAAqB;EACnD,IAAIC,mBAAmB,GAAG,EAA1B;;EACA,IAAID,aAAa,CAAC4C,MAAd,KAAyB,CAA7B,EAAiC;IAC7B5C,aAAa,CAAC8B,GAAd,CAAqBwC,eAAF,IAAuB;MACtCrE,mBAAmB,CAACqC,IAApB,CAA0BgC,eAAe,CAACC,KAA1C;IACH,CAFD;EAGH;;EACD,OAAOtE,mBAAP;AACH,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMuE,kBAAkB,GAAG,CAAEC,UAAF,EAAcC,eAAd,EAA+BC,eAA/B,KAAoD;EAClF;EACA,IAAIxF,SAAJ;EAEA,IAAIyF,WAAW,GAAGC,YAAY,CAAE1F,SAAF,EAAauF,eAAb,CAA9B;EACA,IAAII,eAAe,GAAG3F,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA0B2E,OAA1B,CAAmCH,WAAnC,CAAnC;EACA,IAAII,eAAe,GAAG7F,SAAS,IAAIA,SAAS,CAACiB,UAAV,CAAqB2E,OAArB,CAA8BJ,eAA9B,CAAnC;EAEA,IAAIM,YAAY,GAAGC,uBAAuB,CAAE/F,SAAF,EAAasF,UAAb,EAAyBK,eAAzB,CAA1C;EACA,IAAIK,cAAc,GAAGhG,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA2B0E,eAA3B,EAA6CnC,KAA7C,CAAmDoC,OAAnD,CAA4DE,YAA5D,CAAlC;EAEA,IAAIG,SAAS,GAAG,CAAhB;EACA,IAAIC,iBAAiB,GAAG,GAAxB;;EACA,IAAIV,eAAe,IAAIA,eAAe,CAAChC,KAAhB,CAAsBC,MAAtB,GAA+B,CAAtD,EAA0D;IACtDwC,SAAS,GAAGtG,WAAW,CAACwG,YAAZ,CAA0BX,eAAe,CAAChC,KAAhB,CAAuB,CAAvB,EAA2B4C,WAArD,CAAZ;EACH,CAfiF,CAiBlF;;;EACA,IAAIC,QAAQ,GAAGrG,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA2B0E,eAA3B,CAA5B;EACAU,QAAQ,CAAC7C,KAAT,CAAe8C,MAAf,CAAuBN,cAAvB,EAAuC,CAAvC;EAEA,IAAIO,YAAY,GAAG,KAAnB,CArBkF,CAsBlF;;EACA,IAAIF,QAAQ,CAAC7C,KAAT,CAAeC,MAAf,KAA0B,CAA9B,EAAkC;IAC9B8C,YAAY,GAAG,IAAf;EACH,CAzBiF,CA2BlF;;;EACA,IAAIC,QAAQ,GAAG,EAAf;EACAA,QAAQ,CAACtB,SAAT,GAAqB,UAAU,IAAIuB,IAAJ,GAAWC,OAAX,EAA/B,CA7BkF,CA+BlF;;EACAF,QAAQ,CAAChD,KAAT,GAAiB,EAAjB;EACAgD,QAAQ,CAAChD,KAAT,CAAeL,IAAf,CAAqB2C,YAArB;EAEAU,QAAQ,CAAChD,KAAT,CAAemB,OAAf,CAAwB,UAAUC,IAAV,EAAgB+B,IAAhB,EAAuB;IAC3C/B,IAAI,CAACwB,WAAL,GAAmBH,SAAS,GAAGC,iBAAZ,GAAgCS,IAAnD;IACA/B,IAAI,CAACG,OAAL,GAAe,IAAf;EACH,CAHD,EAnCkF,CAwClF;;EACA,IAAIY,eAAe,KAAKE,eAApB,IAAuCU,YAA3C,EAA0D;IACtDvG,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA0BqF,MAA1B,CAAkCT,eAAlC,EAAmD,CAAnD,EAAsDW,QAAtD,CAAb;EACH,CAFD,MAEO;IACHxG,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA0BqF,MAA1B,CAAkCT,eAAe,GAAG,CAApD,EAAuD,CAAvD,EAA0DW,QAA1D,CAAb;EACH;;EAED,IAAII,YAAY,GAAG5G,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA0B2E,OAA1B,CAAmCY,QAAnC,CAAhC,CA/CkF,CAiDlF;;EACA9G,CAAC,CAACiF,OAAF,CAAW3E,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAvC,EAAmD,UAAU2B,SAAV,EAAqBC,KAArB,EAA6B;IAC5E,IAAIA,KAAK,GAAG+D,YAAR,IAAwBhE,SAAS,CAACY,KAAV,CAAgBC,MAAhB,GAAyB,CAArD,EAAyD;MACrD,IAAIoD,YAAY,GAAGlH,WAAW,CAACwG,YAAZ,CAA0BvD,SAAS,CAACY,KAAV,CAAiB,CAAjB,EAAqB4C,WAA/C,CAAnB;MACAxD,SAAS,CAACY,KAAV,CAAgBb,GAAhB,CAAqB,UAAUiC,IAAV,EAAgB+B,IAAhB,EAAuB;QACxC/B,IAAI,CAACwB,WAAL,GAAmBS,YAAY,GAAGX,iBAAf,GAAmCS,IAAtD;QACA/B,IAAI,CAACG,OAAL,GAAe,IAAf;QACA,OAAOH,IAAP;MACH,CAJD;IAKH;EACJ,CATD;;EAUA5E,SAAS,IAAKA,SAAS,CAAC0B,QAAV,CAAoB;IAAEC,IAAI,EAAE,MAAR;IAAgBC,KAAK,EAAE,EAAE,GAAG5B,SAAS,CAACS;IAAf;EAAvB,CAApB,CAAd;AACH,CA7DM;;AA+DP,MAAMiF,YAAY,GAAG,CAAE1F,SAAF,EAAakF,SAAb,KAA4B;EAC7C,IAAI4B,WAAJ;;EAEApH,CAAC,CAACiF,OAAF,CAAW3E,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAvC,EAAmD,UAAU2B,SAAV,EAAsB;IACrE,IAAIA,SAAS,CAACsC,SAAV,KAAwBA,SAA5B,EAAwC;MACpC4B,WAAW,GAAGlE,SAAd;MACA,OAAO,KAAP;IACH;;IACD,OAAO,IAAP;EACH,CAND;;EAQA,OAAOkE,WAAP;AACH,CAZD;;AAcA,MAAMf,uBAAuB,GAAG,CAAE/F,SAAF,EAAa4E,IAAb,EAAmBmC,UAAnB,KAAmC;EAC/D,IAAIC,aAAJ;;EAEA,IAAIhH,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA2B8F,UAA3B,CAAb,IAAwD,CAACrH,CAAC,CAACsB,OAAF,CAAWhB,SAAS,IAAIA,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA2B8F,UAA3B,EAAwCvD,KAAhE,CAA7D,EAAuI;IACnI9D,CAAC,CAACiF,OAAF,CAAW3E,SAAS,CAACS,IAAV,CAAeQ,UAAf,CAA2B8F,UAA3B,EAAwCvD,KAAnD,EAA0D,UAAUyD,OAAV,EAAoB;MAC1E,IAAIvH,CAAC,CAACwH,OAAF,CAAWD,OAAX,EAAoBrC,IAApB,CAAJ,EAAiC;QAC7BoC,aAAa,GAAGC,OAAhB;QACA,OAAO,KAAP;MACH;;MACD,OAAO,IAAP;IACH,CAND;EAOH;;EAED,OAAOD,aAAP;AACH,CAdD"},"metadata":{},"sourceType":"module"}