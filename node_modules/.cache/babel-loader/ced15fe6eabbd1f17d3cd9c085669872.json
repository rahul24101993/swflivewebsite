{"ast":null,"code":"/* eslint-disable complexity */ // Copyright (c) 2020 Siemens\n/**\n * This module provides lov service in native.\n *\n * @module js/lovService\n */import assert from'js/assert';import _ from'lodash';import soaSvc from'soa/kernel/soaService';import clientDataModel from'soa/kernel/clientDataModel';import clientMetaModel from'soa/kernel/clientMetaModel';import appCtxService from'js/appCtxService';import uwPropertyService from'js/uwPropertyService';import dataProviderFactory from'js/dataProviderFactory';import declDataProviderSvc from'js/declDataProviderService';import appCtxSvc from'js/appCtxService';const LOV_TYPES={EXHAUSTIVE_LOV:1,SUGGESTIVE_LOV:2,RANGE_LOV:3};// Services\nimport AwPromiseService from'js/awPromiseService';import{debugUpdateHandlerOnCommand}from'js/debugService';/**\n * LOVEntry object\n *\n * @class LOVEntry\n *\n * @param {Array} lovRowValue - LOV Values.\n * @param {String} lovType - The type of the LOV. e.g. String, Integer etc. This has to be same as the property\n *            type.\n * @param {String} lovValueProp - LOV Value Property.\n * @param {String} lovDescProp - LOV Description Property.\n */var LOVEntry=function(lovRowValue,lovType,lovValueProp,lovDescProp){var self=this;self.lovRowValue=lovRowValue;self.lovType=lovType;self.lovDescProp=lovDescProp;self.lovValueProp=lovValueProp;self.propHasValidValues=true;if(lovRowValue.propInternalValues){self.propInternalValue=lovRowValue.propInternalValues[lovValueProp][0];}else{self.propInternalValue={};}/** property display description */ /**\n     * set flag 'propHasValidValues'\n     *\n     * @param {propHasValidValues} propHasValidValues - flag\n     */self.setPropHasValidValues=function(propHasValidValues){self.propHasValidValues=propHasValidValues;};/**\n     * Concatenate property values array and returns property string\n     *\n     * @param {propValues} propValues - property values array\n     * @return {propVal} concatenated property value string\n     */self.getPropertyString=function(propValues){var propVal='';if(propValues!==null&&propValues.length>0){propVal=propValues[0];for(var i=1;i<propValues.length;i++){if(propValues[i]!==null){propVal+=propVal+';'+propValues[i];}}}return propVal;};/**\n     * Concatenate property display values\n     *\n     * @return {propDisplayValue} concatenated property display values\n     */self.getPropDisplayValues=function(){var propDisplayValue;if(self.lovRowValue&&self.lovRowValue.propDisplayValues&&self.lovRowValue.propDisplayValues[self.lovValueProp]){propDisplayValue=self.getPropertyString(self.lovRowValue.propDisplayValues[self.lovValueProp]);}return propDisplayValue;};/**\n     * Concatenate property display description values\n     *\n     * @return {propDisplayDescription} concatenated property display description values\n     */self.getPropDisplayDescriptions=function(){var propDisplayDescription;if(self.lovRowValue&&self.lovRowValue.propDisplayValues&&self.lovRowValue.propDisplayValues[lovDescProp]){propDisplayDescription=self.getPropertyString(self.lovRowValue.propDisplayValues[lovDescProp]);}return propDisplayDescription;};/** property display value and decription */if(self.lovRowValue.propDisplayValues){self.propDisplayValue=self.getPropDisplayValues();self.propDisplayDescription=self.getPropDisplayDescriptions();}else{self.propDisplayValue={};self.propDisplayDescription={};}/**\n     * Returns true/false whether the lovRowValue has children.\n     *\n     * @return {hasChildren} true/false\n     */self.checkHasChildren=function(){return self.lovRowValue.childRows&&self.lovRowValue.childRows.length>0;};/** checks whether lov has children */self.hasChildren=self.checkHasChildren();/**\n     * Get children lov, used for hierarical lovs\n     *\n     * @return {list} list array which contains child rows\n     */self.getChildren=function(){var lovEntries=[];if(self.checkHasChildren()){for(var lovValue in self.lovRowValue.childRows){if(self.lovRowValue.childRows.hasOwnProperty(lovValue)){lovEntries.push(new LOVEntry(self.lovRowValue.childRows[lovValue],self.lovType,self.lovValueProp,self.lovDescProp));}}}return lovEntries;};};// LOVEntry\n/**\n * LOVDataValidationResult object\n *\n * @constructor\n */var LOVDataValidationResult=function(){var self=this;self.updatedPropValueMap={};self.updatedPropDisplayValueMap={};/**\n     * The parent view model object\n     */self.setViewModelObject=function(vmObj){self.viewModelObj=vmObj;};/**\n     * This structure contains the LOV results from the getInitialLOVValues or getNextLOVValues operations\n     */self.addUpdatedPropertyValue=function(propName,propValues,propDisplayValues){self.updatedPropValueMap[propName]=propValues;self.updatedPropDisplayValueMap[propName]=propDisplayValues;};/**\n     * This structure contains the LOV results from the getInitialLOVValues or getNextLOVValues operations\n     */self.setValid=function(valid){self.valid=valid;};/**\n     * This structure contains the LOV results from the getInitialLOVValues or getNextLOVValues operations\n     */self.setError=function(error){self.error=error;};};// LOVDataValidationResult\n/**\n * @param {ViewModelProperty} viewProp -view model Property\n * @param {filterString} filterString - filter string for lov's\n * @param {String} opName - operation Name\n * @param {ViewModelObject} viewModelObj -view model object\n * @param {Number} maxResults - Maximum no of results.\n * @param {Number} lovPageSize - The count of LOVs to be returned in a single server call.\n * @param {String} sortPropertyName - The property on which to sort LOV results on.\n * @param {String} sortOrder - Sort order.\n * @param {String} owningObjUid - The UID of owning object\n */var createInitialData=function(viewProp,filterString,assert,operationName,viewModelObj,appCtxService,maxResults,lovPageSize,sortPropertyName,sortOrder,owningObjUid){var viewObject=viewModelObj;var contextObject=appCtxService.getCtx('InitialLovDataAdditionalProps');var tablePropObject=appCtxService.getCtx('InitialSaveDataAdditionalProps');assert(viewObject,'LOV property: Missing parent viewObject on viewProp: '+viewProp.name);var initialData={};initialData.propertyName=uwPropertyService.getBasePropertyName(viewProp.propertyName);initialData.filterData={filterString:filterString?filterString:'',maxResults:maxResults?maxResults:2000,numberToReturn:lovPageSize?lovPageSize:25,order:sortOrder?sortOrder:1,sortPropertyName:sortPropertyName?sortPropertyName:''};initialData.lov={uid:'',type:''};let viewPropOwningType;if(viewProp.srcObjectTypeName){let viewPropType=clientMetaModel.getType(viewProp.srcObjectTypeName);viewPropOwningType=viewPropType&&viewPropType.owningType?viewPropType.owningType:viewProp.srcObjectTypeName;}// For Dcp properties, use intermediate object's type, else use the type of the parent object.\nvar objName=viewPropOwningType||viewObject.modelType.owningType||viewObject.modelType.name;operationName=exports.formatOperationName(operationName);var sourceObjectUid=uwPropertyService.getSourceObjectUid(viewProp);var owningObjectUid=owningObjUid||sourceObjectUid;var modelObject=clientDataModel.getObject(owningObjectUid);if(!modelObject){owningObjectUid=clientDataModel.NULL_UID;}initialData.lovInput={owningObject:{uid:owningObjectUid,type:owningObjUid||sourceObjectUid?objName:viewObject.type},operationName:operationName,boName:objName,propertyValues:{}};var modifiedProps=_.union(viewObject.getSaveableDirtyProps(),viewObject.getAutoAssignableProps());if(modifiedProps&&modifiedProps.length>0){for(var prop in modifiedProps){if(modifiedProps.hasOwnProperty(prop)){var modifiedPropName=uwPropertyService.getBasePropertyName(modifiedProps[prop].name);initialData.lovInput.propertyValues[modifiedPropName]=modifiedProps[prop].values;}}}if(tablePropObject){tablePropObject=_.isArray(tablePropObject)?tablePropObject:[tablePropObject];_.forEach(tablePropObject,function(value,key){_.forEach(value,function(nestedValue,nestedKey){delete initialData.lovInput.propertyValues[nestedKey];});});}if(contextObject){for(var addProp in contextObject){initialData.lovInput.propertyValues[addProp]=[contextObject[addProp]];}}return initialData;};/**\n * Implementation of LOV Service (these api's are only compatible with Teamcenter 9)\n *\n * @param {module:scripts/services/notifyService} notifySvc -\n *\n * @param {module:js/dateTimeService} dateTimeSvc - SOA's LOV Access service\n *\n * @param {module:soa/kernel/clientDataModel} clientDataModel - SOA's clientDataModel service\n */let exports;/**\n * Add the 'lovApi' function set object to the given ViewModelProperty\n *\n * @param {ViewModelProperty} viewProp -view model property\n *\n * @param {module:angular~Scope} scope - angular scope for the element\n *\n * @param {ViewModelObject} viewModelObj -view model Object\n *\n * @param {String} owningObjUid - The UID of owning object\n *\n */export let initNativeCellLovApi=function(viewProp,scope,operationName,viewModelObj,owningObjUid){viewProp.lovApi={};//viewProp.isRequired = true;\nviewProp.lovApi.operationName=operationName;viewProp.lovApi.getInitialValues=function(filterStr,deferred,name,maxResults,lovPageSize,sortPropertyName,sortOrder){exports.getInitialValues(filterStr,deferred,viewProp,viewProp.lovApi.operationName,viewModelObj,maxResults,lovPageSize,sortPropertyName,sortOrder,owningObjUid);};viewProp.lovApi.getNextValues=function(deferred){exports.getNextValues(deferred,viewProp);};viewProp.lovApi.validateLOVValueSelections=function(lovEntries){return exports.validateLOVValueSelections(lovEntries,viewProp,viewProp.lovApi.operationName,viewModelObj,owningObjUid);};viewProp.owningObjUid=owningObjUid;};/**\n * This operation is invoked to query the data for a property having an LOV attachment. The results returned\n * from the server also take into consideration any filter string that is in the input. This method calls\n * 'getInitialLOVValues' and returns initial set of lov values. This is only compatible with 'Teamcenter 10'\n *\n * @param {filterString} filterString - The filter text for lov's\n * @param {deferred} deferred - $q object to resolve the 'promise' with a an array of LOVEntry objects.\n * @param {ViewModelProperty} viewProp - Property to aceess LOV values for.\n * @param {String} operationName - The operation being performed e.g. Edit, Create, Revise, Save As etc.\n * @param {ViewModelObject} viewModelObj - The view model object which LOV property is defined on.\n * @param {Number} maxResults - Maximum no of results.\n * @param {Number} lovPageSize - The count of LOVs to be returned in a single server call.\n * @param {String} sortPropertyName - The property on which to sort LOV results on.\n * @param {String} sortOrder - Sort order.\n * @param {String} owningObjUid - The UID of owning object\n */export let getInitialValues=function(filterString,deferred,viewProp,operationName,viewModelObj,maxResults,lovPageSize,sortPropertyName,sortOrder,owningObjUid){var initialData=createInitialData(viewProp,filterString,assert,operationName,viewModelObj,appCtxService,maxResults,lovPageSize,sortPropertyName,sortOrder,owningObjUid);var serviceInput={initialData:initialData};soaSvc.postUnchecked('Core-2013-05-LOV','getInitialLOVValues',serviceInput).then(function(responseData){//Object.assign( viewProp.searchResults, responseData );\n//viewProp.searchResults = responseData; // using for LOV getNextLOVValues SOA call\n//viewProp.lovApi.result = responseData; // using for validateLOVValuesSelections()\nif(_.isArray(responseData.ServiceData.partialErrors)){//getInitialLOV  returns error when message/error has to be displayed\n// if errorlevel >1 its legitimate error else it is message\nfor(const partialError of responseData.ServiceData.partialErrors){if(_.isArray(partialError.errorValues)){for(const errorValue of partialError.errorValues){if(errorValue.level>1){deferred.reject(responseData.ServiceData.partialErrors);}}}}}let lovValues=exports.createLOVEntries(responseData,viewProp.type);deferred.resolve({responseData,lovValues});},function(reason){deferred.reject(reason);});};export let getListLOVValues=function(list){let lovEntries=list;return{lovEntries};};/**\n *\n * @param {*} output\n * @param {*} declViewModel\n */export let processLOVEntries=function(_ref){let{responseData,lovValues={}}=_ref;if(lovValues&&lovValues.hasOwnProperty('moreValuesExist')){let moreValuesExist=lovValues.moreValuesExist;let newop=[...lovValues];delete newop.moreValuesExist;return{lovEntries:newop,moreValuesExist,partialErrors:'',level:'',responseData,lovUsage:lovValues.lovUsage};}return{lovEntries:[],partialErrors:lovValues.cause,level:lovValues.level,moreValuesExist:false,responseData,lovUsage:lovValues.lovUsage};};export let getInitialLOVValues=function(viewModel,dataProviderName){let dataProvider=viewModel.dataProviders?viewModel.dataProviders[dataProviderName]:null;const lovInfo=appCtxSvc.getCtx('aw.lovInfo');let vmo;let viewProp;let filterString;let owningObjUid;let operationName;if(dataProvider&&dataProvider.resolvedLovConfig){const lovConfiguration=dataProvider.resolvedLovConfig;vmo=lovConfiguration.viewModelObj;viewProp=lovConfiguration.viewProp;filterString=lovConfiguration.filterString;owningObjUid=viewProp.owningObjUid;operationName=lovConfiguration.operationName;}else if(lovInfo){vmo=lovInfo.ctxLovPropVMO;viewProp=vmo.props[lovInfo.ctxLovPropName];filterString=viewProp.filterString;owningObjUid=viewProp.owningObjUid;operationName=vmo.operationName;}let deferred=AwPromiseService.instance.defer();getInitialValues(filterString,deferred,viewProp,operationName,vmo,null,null,'','',owningObjUid);return deferred.promise.then(response=>{const responseBehaviorData=response.responseData&&response.responseData.behaviorData;viewProp.lovApi.behaviorData={dependendProps:responseBehaviorData&&responseBehaviorData.dependendProps,style:responseBehaviorData&&responseBehaviorData.style};return response;}).catch(error=>error);};/**\n * This operation is invoked after a call to getInitialLOVValues if the moreValuesExist flag is true in the\n * LOVSearchResults output returned from a call to the getInitialLOVValues operation. The operation will\n * retrieve the next set of LOV values.\n *\n * @param {deferred} deferred - promise object\n * @param {ViewModelProperty} viewProp - Lov object value\n * @return {deferred.promise} promise object\n */export let getNextValues=function(viewModel,dataProviderName){let dataProvider=viewModel.dataProviders?viewModel.dataProviders[dataProviderName]:null;const lovInfo=appCtxSvc.getCtx('aw.lovInfo');let lovDataInfo=viewModel.lovDataInfo;let vmo;let viewProp;if(dataProvider&&dataProvider.resolvedLovConfig){const lovConfiguration=dataProvider.resolvedLovConfig;vmo=lovConfiguration.viewModelObj;viewProp=lovConfiguration.viewProp;}else if(lovDataInfo){vmo=lovInfo.ctxLovPropVMO;viewProp=vmo.props[lovInfo.ctxLovPropName];}let lovEntries=[];if(lovDataInfo&&lovDataInfo.responseData){var serviceInput={};serviceInput.lovData=lovDataInfo.responseData.lovData;return soaSvc.post('Core-2013-05-LOV','getNextLOVValues',serviceInput).then(responseData=>{const lovValues=exports.createLOVEntries(responseData,viewProp.type);return{lovValues,responseData};});}return Promise.resolve(lovEntries);};/**\n * This is a reusable function to create LOV entries from SOA response\n *\n * @param {responseData} SOA response structure from LOV\n * @param {propertyType} Type of Property\n * @return {lovEntries} Array of LOV entry objects\n */export let createLOVEntries=function(responseData,propertyType){var lovEntries=[];var lovValueProp=responseData.behaviorData.columnNames.lovValueProp;var lovDescProp=responseData.behaviorData.columnNames.lovDescrProp;var lovUsage=responseData.behaviorData.lovUsage;for(var lovValue in responseData.lovValues){if(responseData.lovValues.hasOwnProperty(lovValue)){lovEntries.push(new LOVEntry(responseData.lovValues[lovValue],propertyType,lovValueProp,lovDescProp));}}// push the moreValuesExist to the lovEntries. if it is true, then call getNextValues ; else not call getNextValues\nif(responseData.moreValuesExist){lovEntries.moreValuesExist=responseData.moreValuesExist;}else{lovEntries.moreValuesExist=false;}lovEntries.lovUsage='EXHAUSTIVE_LOV';if(lovUsage===LOV_TYPES.SUGGESTIVE_LOV){lovEntries.lovUsage='SUGGESTIVE_LOV';}// This is Workaround hack which will be removed when Fnd0NameValueDynLOV wil be converted to suggestive\n//LCS-681145 - Change Fnd0DynLOVNameValuePairs LOV to suggestive\nif(responseData.lovData&&_.isArray(responseData.lovData.lovs)&&responseData.lovData.lovs.length>0&&responseData.lovData.lovs[0].type==='Fnd0NameValueDynLOV'){lovEntries.lovUsage='SUGGESTIVE_LOV';}return lovEntries;};/**\n * This operation can be invoked after selecting a value from the LOV. Use this operation to do additional\n * validation to be done on server such as validating Range value, getting the dependent properties values in\n * case of interdependent LOV (resetting the dependendent property values), Coordinated LOVs ( populating\n * dependent property values ).\n *\n * @param {LovEntry[]} lovEntries - Array of LOV values selected\n *\n * @param {viewProp} viewProp - The property being modified\n *\n * @return {String} operationName The operation being performed. e.g. Edit, Create, Revise, Save As etc\n *\n * @return {ViewModelObject} viewModelObj The object for which property is being modified\n *\n * @param {String} owningObjUid - The UID of owning object\n */export let validateLOVValueSelections=function(lovEntries,viewProp,operationName,viewModelObj,owningObjUid){var viewObject=viewModelObj;var contextObject=appCtxService.getCtx('InitialLovDataAdditionalProps');var tablePropObject=appCtxService.getCtx('InitialSaveDataAdditionalProps');assert(viewObject,'LOV property: Missing parent viewObject on viewProp: '+viewProp.name);var lovValueProp=null;if(viewProp.lovApi&&viewProp.lovApi.result){lovValueProp=viewProp.lovApi.result.behaviorData.columnNames.lovValueProp;}var propName=uwPropertyService.getBasePropertyName(viewProp.propertyName);let viewPropOwningType;if(viewProp.srcObjectTypeName){let viewPropType=clientMetaModel.getType(viewProp.srcObjectTypeName);viewPropOwningType=viewPropType&&viewPropType.owningType?viewPropType.owningType:viewProp.srcObjectTypeName;}var objName=viewPropOwningType||viewObject.modelType.owningType||viewObject.modelType.name;var serviceInput={};var sourceObjectUid=uwPropertyService.getSourceObjectUid(viewProp);var owningObjectUid=owningObjUid||sourceObjectUid;var modelObject=clientDataModel.getObject(owningObjectUid);if(!modelObject){owningObjectUid=clientDataModel.NULL_UID;}serviceInput.lovInput={owningObject:{uid:owningObjectUid,type:owningObjUid||sourceObjectUid?objName:viewObject.type},operationName:operationName,boName:objName,propertyValues:{}};serviceInput.propName=propName;serviceInput.uidOfSelectedRows=[];serviceInput.lovInput.propertyValues[propName]=[];// First add all the selected LOV entries\nfor(var ii=0;ii<lovEntries.length;ii++){// account for simplified lov format\nif('propInternalValue'in lovEntries[ii]){serviceInput.lovInput.propertyValues[propName].push(String(lovEntries[ii].propInternalValue!==null?lovEntries[ii].propInternalValue:''));}else if(lovValueProp&&lovEntries[ii].lovRowValue){serviceInput.lovInput.propertyValues[propName].push(String(lovEntries[ii].lovRowValue.propInternalValues[lovValueProp][0]));}//append selected row uid to fix dynamic LOV defect LCS-351651\nif(lovEntries[ii].lovRowValue&&!_.isEmpty(lovEntries[ii].lovRowValue.uid)){serviceInput.uidOfSelectedRows.push(String(lovEntries[ii].lovRowValue.uid));}}// Now populate all the other modified properties.\nvar modifiedProps=_.union(viewObject.getSaveableDirtyProps(),viewObject.getAutoAssignableProps());if(modifiedProps&&modifiedProps.length>0){for(var prop in modifiedProps){if(modifiedProps.hasOwnProperty(prop)){var modifiedPropName=uwPropertyService.getBasePropertyName(modifiedProps[prop].name);if(modifiedPropName!==propName){serviceInput.lovInput.propertyValues[modifiedPropName]=modifiedProps[prop].values;}}}}if(tablePropObject){_.forEach(tablePropObject,function(value,key){delete serviceInput.lovInput.propertyValues[key];});}if(contextObject){for(var addProp in contextObject){serviceInput.lovInput.propertyValues[addProp]=[contextObject[addProp]];}}return soaSvc.post('Core-2013-05-LOV','validateLOVValueSelections',serviceInput).then(function(responseData){var validationResult=new LOVDataValidationResult();validationResult.setValid(responseData.propHasValidValues);validationResult.setViewModelObject(viewModelObj);var updatedValues=responseData.updatedPropValues;for(var propName in responseData.dependentPropNames){if(responseData.dependentPropNames.hasOwnProperty(propName)){var prop=responseData.dependentPropNames[propName];if(updatedValues.propInternalValues.hasOwnProperty(prop)){validationResult.addUpdatedPropertyValue(prop,updatedValues.propInternalValues[prop],updatedValues.propDisplayValues[prop]);}}}return validationResult;},function(error){return error;});};/**\n * Converts operation names to camel case.\n *\n * @param {String} operationName The operation being performed. e.g. Edit, Create, Revise, Save As etc.\n *\n * @return {String} operationName The operation formatted into camelCase.\n *\n */export let formatOperationName=function(operationName){if(operationName.toUpperCase()==='EDIT'){operationName='Edit';}else if(operationName.toUpperCase()==='CREATE'){operationName='Create';}else if(operationName.toUpperCase()==='REVISE'){operationName='Revise';}else if(operationName.toUpperCase()==='SAVEAS'){operationName='SaveAs';}return operationName;};exports={getListLOVValues,initNativeCellLovApi,getInitialValues,getNextValues,createLOVEntries,validateLOVValueSelections,formatOperationName,getInitialLOVValues,processLOVEntries};export default exports;","map":null,"metadata":{},"sourceType":"module"}