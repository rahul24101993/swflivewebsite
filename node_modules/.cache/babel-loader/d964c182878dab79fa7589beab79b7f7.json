{"ast":null,"code":"/* eslint-disable complexity */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2021 Siemens\n\n/**\n * Data provider factory\n *\n * @module js/dataProviderFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport viewModelCollectionFactory from 'js/viewModelCollectionFactory';\nimport localeSvc from 'js/localeService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport dataSourceService from 'js/dataSourceService';\nimport dataCtxService from 'js/declarativeDataCtxService';\nimport declModelRegistrySvc from 'js/declModelRegistryService';\nimport editUtilsService from 'js/editUtilsService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport debugService from 'js/debugService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport awTableSvc from 'js/awTableService';\nimport editHandlerFactory from 'js/editHandlerFactory';\nimport declDataProviderSvc from 'js/declDataProviderService';\nimport cfgSvc from 'js/configurationService';\nconst jsonData = cfgSvc.getCfgCached('lovDataProvider');\nimport Debug from 'debug';\nconst trace = new Debug('selection');\n/**\n * {StringArray} Collection of valid properties in the 'inputData' property of dataProvider's JSON definition.\n */\n\nvar _modifiablePropertiesViaInputData = ['selectionModel', 'accessMode', 'topNodeUid', 'editSupportParamKeys'];\n/**\n * {Boolean} TRUE if tree node insertion details should be logged.\n */\n\nvar _debug_logTreeLoadActivity = false;\n/**\n * Constructs an object that wraps access to a 'viewModelCollection' created by the\n * 'viewModelCollectionFactory'.\n *\n * @class UwDataProvider\n *\n * @param {QueueService} $q - Queue service to use.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {ViewModelCollection} viewModelCollection - The 'viewModelCollection' used to hold all\n *            ViewModelObjects managed by this DataProvider.\n *\n * @param {StringMap} actionMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n */\n\nvar UwDataProvider = function ($q, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, viewModelCollection, actionMap) {\n  var dpSelf = this; // eslint-disable-line consistent-this\n\n  /**\n   * Data that is passed into the data provider constructor from outside of the view model.\n   */\n\n  var _ctorInputData = dataProviderJson ? dataProviderJson.inputData : null;\n  /**\n   *  This private variable would contain the pagination options and non-modifibale from outside.\n   */\n\n\n  let paginationOption = null;\n  /**\n   *  The filter string to be used in getFirstPage/getNextPage APi's\n   */\n\n  let filterStr = null;\n  let propsCallback = null;\n  /**\n   *  selectionModelDispatcher : Dispatcher to update the selection Model on the fly.\n   */\n\n  let selectionModelDispatcher;\n  /**\n   *\n   */\n\n  let lovEntryRef = null;\n  /**\n   *  This private variable would contain the reference of the top level referenceElement of list/table/ user defined widget\n   *  using data-provider\n   */\n\n  let referenceElement = null;\n  /**\n   * {Boolean} TRUE if 'destroy' has been invoked on this instance.\n   */\n\n  dpSelf._isDestroyed = false;\n  /**\n   * @property {String} noResultsFound - Localized message stating 'No results found'.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.noResultsFound = null;\n  /**\n   * @property {String} isLoading - Localized message stating 'loading'.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.isLoading = null;\n  /**\n   * @property {Boolean} cacheCollapse - cache collapse infomation to reuse in next expand.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.cacheCollapse = false;\n  /**\n   * @property {Object} someDataProviderSvc - Some API object where 'getFirstPage', 'getNextPage', et al.\n   *           methods are implemented (e.g. 'js/declDataProviderService').\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.someDataProviderSvc = someDataProviderSvc;\n  /**\n   * @property {String} name - name of data provider object\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.name = dataProviderName;\n  /**\n   * @property {ViewModelCollection} viewModelCollection - viewModelCollection which maintains the loaded\n   *           ViewModelObjects and also have APIs to access the information of collection.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.viewModelCollection = viewModelCollection;\n  /**\n   * @property {Number} startIndex - Start/Next index into a virtual list.\n   *           <P>\n   *           Note: This property is accessed by some declViewModel bindings and 'glue' code. While it is\n   *           somewhat analogous to the data in the newer 'cursorObject', it is necessary to keep it exposed\n   *           for support of these earlier uses of it.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.startIndex = 0;\n  /**\n   * @property {DeclAction} action - The 'declAction' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.action = null;\n  /**\n   * @property {DeclAction} action - The 'declAction' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.focusAction = null;\n  /**\n   * @property {DeclDataProviderJson} json - The 'UwDataProvider' JSON object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.json = null;\n  /**\n   * @property {Object} policy - The Currently set property policy object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.policy = null;\n  /**\n   * @property {Object} selectionModel - Object which maintains all the selection objects stuff and provides\n   *           APIs to access information.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n  // dpSelf.selectionModel = selectionModelFactory\n  //     .buildSelectionModel( dataProviderJson ? dataProviderJson.selectionModelMode : null );\n\n  /**\n   * @property {Boolean} noResults - Flag decides whether to show no results message if there are no values\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.noResults = false;\n  /**\n   * @property {ObjectArray} sortCriteria - Array of ordered sort criteria objects.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.sortCriteria = [];\n  /**\n   * @property {Object} filiterMap - A map (string, list of SearchFilter) containing the list of search\n   *           filters for each search filter field. The key in the map is the property name that represents\n   *           the filter category. It is in the format \"TypeName.PropertyName\". e.g\n   *           WorkspaceObject.object_type\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.filterMap = {};\n  /**\n   * @property {ViewModelTreeNode} The ViewModelTReeNode which is the logical (but unseen) 'top' node in any\n   *           hierarchy being managed by this UwDataProvider\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.topTreeNode = null;\n  /**\n   * Selected objects\n   */\n\n  dpSelf.selectedObjects = [];\n  /**\n   * {Boolean} TRUE if any editHandler associated with this UwDataProvider has been registered.\n   */\n\n  var _editHandlerRegistered;\n\n  const updateDataCtxNodeWithProps = function (dataCtxNode) {\n    if (propsCallback) {\n      dataCtxNode.props = propsCallback();\n      dataCtxNode.getProps = propsCallback;\n    }\n  }; // Toggle the display of Cell Decorators.\n\n\n  dpSelf.toggleDecoratorsEvent = eventBus.subscribe(dpSelf.name + '.toggleCellDecorators', function (eventData) {\n    if (eventData) {\n      dpSelf.showDecorators = eventData.toggleState;\n    } else {\n      if (dpSelf.showDecorators) {\n        dpSelf.showDecorators = false;\n      } else {\n        dpSelf.showDecorators = true;\n      }\n    }\n  });\n\n  const saveRowExpanded = function (dataCtxNode, node) {\n    if (node.isExpanded === true) {\n      var declViewModel = declUtils.findViewModel(dataCtxNode);\n      var grids = declViewModel.grids;\n      awTableStateSvc.saveRowExpanded(declViewModel, grids[Object.keys(grids)[0]].gridid, node);\n    }\n  };\n  /**\n   * Fire modelObjects updated event using data provider name space\n   *\n   * @param {Object} dataCtxNode - The 'scope' to use.\n   * @param {Object} eventData - Event data containing data to include in notify.\n   */\n\n\n  var _notifyModelObjectsUpdate = function (dataCtxNode, eventData) {\n    if (dataCtxNode) {\n      dpSelf.syncSelectionModel(dataCtxNode);\n    }\n\n    eventData = eventData || {}; // Set standard data\n\n    eventData.viewModelObjects = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    eventData.noResults = dpSelf.noResults; // Publish event\n\n    eventBus.publish(dpSelf.name + '.modelObjectsUpdated', eventData);\n  };\n\n  dpSelf.notifyModelObjectsUpdate = _notifyModelObjectsUpdate;\n  /**\n   * Insert the given array of ViewModelObjects into the given viewModelCollection starting after the given\n   * 'cursor' ViewModelObject ID.\n   *\n   * @param {ViewModelCollection} vmCollection - The ViewModelCollection to update.\n   * @param {String} cursorId - ID of the object The ViewModelObject in the collection to insert after.\n   * @param {ViewModelObjectArray} vmosToInsert - The ViewModelObjects to insert.\n   * @param {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n   *            (Default: TRUE)\n   */\n\n  function _insertModelObjects(vmCollection, cursorId, vmosToInsert, addAfter) {\n    var cursorNdx = vmCollection.findViewModelObjectById(cursorId);\n    var cursorNode = cursorNdx === -1 ? null : vmCollection.getViewModelObject(cursorNdx);\n    var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n\n    if (_debug_logTreeLoadActivity) {\n      logger.info('_insertModelObjects: ' + '\\n' + //\n      'n1stLevelFound : ' + vmCollection.totalFound + '\\n' + //\n      'n1stLevelLoaded: ' + vmCollection.totalObjectsLoaded + '\\n' + //\n      'nLoadedOverall : ' + loadedVMOs.length + '\\n' + //\n      'cursorId       : ' + cursorId + '\\n' + //\n      'nVMOsToInsert  : ' + vmosToInsert.length + '\\n' + //\n      'addAfter       : ' + addAfter + '\\n' + //\n      'cursorNdx      : ' + cursorNdx + '\\n' + //\n      'cursorNode     : ' + cursorNode);\n    }\n    /**\n     * Check if we found where to insert and it is NOT the top level node.\n     * <P>\n     * Note: This function purposefully does not maintain the 'totalObjectsLoaded' for the overall\n     * viewModelCollection since that value only makes sense for the 'top' node.\n     */\n\n\n    if (cursorNode && cursorNode.levelNdx !== -1) {\n      var childNdxOffset;\n\n      if (addAfter) {\n        /**\n         * Check if the VMOs being inserted are from the same level of the tree.<BR>\n         * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n         * property is helpful when debugging.\n         */\n        if (cursorNode.levelNdx === vmosToInsert[0].levelNdx) {\n          childNdxOffset = loadedVMOs[cursorNdx].childNdx + 1;\n\n          for (var ndx1 = 0; ndx1 < vmosToInsert.length; ndx1++) {\n            vmosToInsert[ndx1].childNdx = childNdxOffset + ndx1;\n          }\n        }\n        /**\n         * AW-49335 - Jumping to target does not work when page is refreshed...\n         * <P>\n         * Check if the 'cursor' node has any children<br>\n         * If so: We need to account for them before we insert\n         * <P>\n         * Note: We look forward until we find a node at the same (or 'above') level.\n         */\n\n\n        var insertNdx = cursorNdx;\n\n        for (var ndx3 = cursorNdx + 1; ndx3 < loadedVMOs.length; ndx3++) {\n          if (loadedVMOs[ndx3].levelNdx <= cursorNode.levelNdx) {\n            break;\n          }\n\n          insertNdx++;\n        }\n\n        arrayUtils.insert(loadedVMOs, insertNdx, vmosToInsert);\n      } else {\n        /**\n         * Check if the VMOs being inserted are from the same level of the tree.<BR>\n         * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n         * property is helpful when debugging.\n         */\n        if (cursorNode.levelNdx === vmosToInsert[0].levelNdx) {\n          childNdxOffset = loadedVMOs[cursorNdx].childNdx - vmosToInsert.length;\n\n          for (var ndx2 = 0; ndx2 < vmosToInsert.length; ndx2++) {\n            vmosToInsert[ndx2].childNdx = childNdxOffset + ndx2;\n          }\n        }\n        /**\n         * Insert just before the 'cursor' node.\n         * <P>\n         * Note: Even if the 'cursor' node is preceded by any children from an earlier 'sibling' (i.e. a\n         * node at the same tree level) we do NOT need to account for them before we insert since the\n         * 'cursor' position defines the correct break in the tree level.\n         */\n\n\n        arrayUtils.insertBefore(loadedVMOs, cursorNdx, vmosToInsert);\n      }\n    }\n  } // _insertModelObjects\n\n  /**\n   * Locate the 'child' in the given 'parent' based on the 'child' node's ID.\n   *\n   * @param {ViewModelTreeNode} parentNode - The 'parent' who's 'children' to search.\n   * @param {String} cursorNodeId - The ID of the 'child' node to find.\n   * @returns {Number} Index to the 'child' node (or -1 if not found)\n   */\n\n\n  function _findChildNdx(parentNode, cursorNodeId) {\n    var nChild = parentNode.children ? parentNode.children.length : 0;\n\n    if (cursorNodeId) {\n      for (var ndx = 0; ndx < nChild; ndx++) {\n        if (parentNode.children[ndx].id === cursorNodeId) {\n          return ndx;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Insert the results into the ViewModelCollection array starting at the current location of the 'cursor'\n   * node.\n   *\n   * @param {TreeLoadInput} treeLoadInput - The original input parameters used to generate the response we are\n   *            processing now.\n   *\n   * @param {Object} responseObj - Object returned from the associated load 'action'\n   *\n   * @param {Object} dataCtxNode - Data context used for selection model sync.\n   *\n   * @param {Object} origCursorObj - The cursorObject of the 'parent' node BEFORE the load operation.\n   *\n   * @return {ViewModelCollection} A reference to the updated ViewModelCollection object.\n   */\n\n\n  function _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj) {\n    // eslint-disable-line\n    assert(responseObj, 'Action did not return a ResponseResult Object');\n    var treeLoadResult = responseObj.treeLoadResult;\n    let vmCollection = dpSelf.viewModelCollection;\n    assert(treeLoadResult, 'Action did not return a TreeLoadResult Object');\n    /**\n     * Move the 'parent' and 'viewModelCollection' into handier variables.\n     */\n\n    var resultParentNode = treeLoadResult.parentNode;\n    let response = {\n      totalFound: vmCollection.totalFound,\n      loadedVMObjects: vmCollection.loadedVMObjects\n    };\n    /**\n     * Determine if we are working on the very top node of the tree.\n     */\n\n    var isParentRoot = resultParentNode && resultParentNode.levelNdx === -1;\n    /**\n     * Optionally log some useful information\n     */\n\n    if (_debug_logTreeLoadActivity && !_.isEmpty(treeLoadResult.childNodes)) {\n      logger.info('_processLoadTreeNodePageResponse' + '\\n' + 'parentNode: ' + resultParentNode + ' isParentRoot: ' + isParentRoot + '\\n' + '# children returned: ' + treeLoadResult.childNodes.length);\n    }\n    /**\n     * AW-47271 - bash_PI1712-2 : Can Not expand Sub Assembly in tree View in a spcific scenario\n     * <P>\n     * Find the original 'parent' node in the vmCollection and see if it is still expanded.\n     * <P>\n     * Note: If we are working on the 'root', skip this check since the 'root' cannot actually be collapsed.\n     */\n\n\n    if (!isParentRoot) {\n      /**\n       * Check if NOT expanded<BR>\n       * If so: No need to continue. Return current vmCollection unchanged.\n       * <P>\n       * Note: The 'parent' node returned from the async processing can sometimes be a clone made during\n       * processing. It is best to go back to the original to be sure we do not miss the latest state.\n       */\n      var origParentNdx = vmCollection.findViewModelObjectById(uwUtilSvc.getEvaluatedId(resultParentNode));\n\n      if (origParentNdx === -1 || !vmCollection.getViewModelObject(origParentNdx).isExpanded) {\n        if (_debug_logTreeLoadActivity) {\n          logger.info('_processLoadTreeNodePageResponse: Skipping insertion of child nodes into collapsed or missing parent' + '\\n' + 'parent: ' + resultParentNode + '\\n' + 'index: ' + origParentNdx);\n        }\n\n        return {\n          totalFound: vmCollection.getTotalObjectsFound(),\n          loadedVMObjects: vmCollection.getLoadedViewModelObjects()\n        };\n      }\n    }\n    /**\n     * Check if we actually have results to insert.\n     */\n\n\n    var newTopNode;\n    var moreAboveFirst;\n    var moreBelowLast;\n\n    if (treeLoadResult.totalChildCount > 0 && !_.isEmpty(treeLoadResult.childNodes)) {\n      /**\n       * If this is the 'top' level node we now know IT is NOT empty.\n       */\n      if (isParentRoot) {\n        dpSelf.noResults = false;\n      }\n\n      var expectantParentNode = resultParentNode;\n      /**\n       * Get the effective 'parent' node from the paths (if necessary)\n       */\n\n      var nRootPaths = _.isEmpty(treeLoadResult.rootPathNodes) ? 0 : treeLoadResult.rootPathNodes.length;\n      var usedPathParent;\n\n      if (nRootPaths > 0) {\n        /**\n         * Get the 'top' node based on the path but do not override the current 'expectantParentNode'\n         * unless it refers to a different object.\n         */\n        var resultTopNode = _.last(treeLoadResult.rootPathNodes);\n\n        if (resultParentNode.uid !== resultTopNode.uid) {\n          expectantParentNode = resultTopNode;\n          usedPathParent = true;\n        }\n      }\n      /**\n       * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n       * <P>\n       * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n       * 'top' children into the ViewModelCollection. Do not do this!\n       */\n\n\n      newTopNode = treeLoadResult.newTopNode;\n\n      if (newTopNode && newTopNode.levelNdx === -1) {\n        dpSelf.topTreeNode = newTopNode;\n        dpSelf.topTreeNode.children = null;\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n        if (!usedPathParent) {\n          resultParentNode = treeLoadResult.newTopNode;\n        }\n      }\n      /**\n       * Determine if we are inserting before or after the 'start' or 'cursor' node.\n       */\n\n\n      var addAfter = declUtils.isNil(treeLoadInput.addAfter) ? true : treeLoadInput.addAfter;\n      /**\n       * Check for the trivial case of 1st-time children\n       * <P>\n       * Note: We do a shallow clone to make sure it is not the same array as the result.\n       */\n\n      var newParent = _.isEmpty(expectantParentNode.children);\n\n      if (newParent) {\n        expectantParentNode.children = _.clone(treeLoadResult.childNodes);\n      } else {\n        /**\n         * Insert the new 'child' nodes into the 'children' array property of the 'parent' node.\n         * <P>\n         * Try to use the 'cursor' node to locate exactly where in the 'parent' to insert the new\n         * 'child' nodes.\n         * <P>\n         * If no 'cursor' then just trust the previous index as a 'best guess' (works in a downward list\n         * scenario).\n         * <P>\n         * Note: We have to do this since some cases where the children were inserted out of order or\n         * even had duplicates. Relocating the 'cursor' locks it in for at least 'this' thread pass.\n         */\n        var cursorChildNdx = _findChildNdx(expectantParentNode, treeLoadResult.cursorNodeId);\n\n        var insertionChildNdx = cursorChildNdx;\n\n        if (addAfter) {\n          /**\n           * Reset the 'start' info of the 'parent' node (Server bug? we should not have to do this)\n           */\n          if (origCursorObj) {\n            expectantParentNode.cursorObject.startIndex = origCursorObj.startIndex;\n            expectantParentNode.cursorObject.startOccUid = origCursorObj.startOccUid;\n            expectantParentNode.cursorObject.startReached = origCursorObj.startReached;\n          }\n          /**\n           * First new 'child' node inserted AFTER another cannot be an 'incompleteHead'.\n           */\n\n\n          _.first(treeLoadResult.childNodes).incompleteHead = false;\n          /**\n           * Insert new 'child' nodes into 'parent' AFTER cursor 'child' node.\n           * <P>\n           * Note: Original cursor 'child' can no longer be an 'incompleteTail'.\n           */\n\n          if (insertionChildNdx === -1) {\n            insertionChildNdx = treeLoadResult.startChildNdx;\n          } else {\n            expectantParentNode.children[cursorChildNdx].incompleteTail = false;\n            insertionChildNdx++;\n          }\n\n          arrayUtils.insert(expectantParentNode.children, insertionChildNdx, treeLoadResult.childNodes);\n        } else {\n          /**\n           * Reset the 'end' info of the 'parent' node (Server bug? we should not have to do this)\n           */\n          if (origCursorObj) {\n            expectantParentNode.cursorObject.endIndex = origCursorObj.endIndex;\n            expectantParentNode.cursorObject.endOccUid = origCursorObj.endOccUid;\n            expectantParentNode.cursorObject.endReached = origCursorObj.endReached;\n          }\n          /**\n           * Last new 'child' node inserted BEFORE another cannot be an 'incompleteTail'\n           */\n\n\n          _.last(treeLoadResult.childNodes).incompleteTail = false;\n          /**\n           * Insert new 'child' nodes into 'parent' BEFORE cursor 'child' node.\n           * <P>\n           * Note: Original cursor 'child' can no longer be an 'incompleteHead'.\n           */\n\n          if (insertionChildNdx === -1) {\n            insertionChildNdx = treeLoadResult.startChildNdx;\n          } else {\n            expectantParentNode.children[cursorChildNdx].incompleteHead = false;\n          }\n\n          arrayUtils.insertBefore(expectantParentNode.children, insertionChildNdx, treeLoadResult.childNodes);\n        }\n      }\n      /**\n       * Fire a 'resetState' event, sourced to this uwDataProvider, for all tree-table 'focused load'\n       * cases.\n       */\n\n\n      if (!treeLoadResult.retainTreeExpansionStates) {\n        if (isParentRoot && treeLoadResult.isFocusedLoad) {\n          eventBus.publish(dpSelf.name + '.resetState', {});\n        }\n      }\n      /**\n       * Check if we were given a non-trivial path to a root (the new 'child' nodes are to be added to the\n       * bottom of).\n       */\n\n\n      if (nRootPaths > 1 && newParent) {\n        dpSelf.topTreeNode = _.first(treeLoadResult.rootPathNodes);\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n        if (!treeLoadResult.vmNodesInTreeHierarchyLevels) {\n          var newNodes = [];\n          var prevParentNode = treeLoadResult.rootPathNodes[0];\n\n          for (var ndx = 1; ndx < treeLoadResult.rootPathNodes.length; ndx++) {\n            var parent = treeLoadResult.rootPathNodes[ndx];\n            newNodes.push(parent);\n            prevParentNode.children = [parent];\n            /**\n             * If expansion states are cleared after 'resetState' event, tree hierarchy that we are\n             * creating while building tree using rootPathNodes, those rootPathNodes should be saved in\n             * expansion state as they are expanded.\n             * <P>\n             * This is required for tree refresh scenarios (the level the user is working on should get\n             * restored after refresh)\n             */\n\n            saveRowExpanded(dataCtxNode, parent);\n            prevParentNode = parent;\n          }\n          /**\n           * Mark the children to be 1 level below the 'expectant' parent\n           */\n\n\n          var nextLevelNdx = _.last(treeLoadResult.rootPathNodes).levelNdx + 1;\n\n          for (var ndx2 = 0; ndx2 < treeLoadResult.childNodes.length; ndx2++) {\n            var child = treeLoadResult.childNodes[ndx2];\n            child.levelNdx = nextLevelNdx;\n            child.$$treeLevel = nextLevelNdx;\n            newNodes.push(child);\n          }\n          /**\n           * Put all the 'parent' path + 'child' nodes as the sole content of the collection\n           */\n\n\n          response.totalFound = treeLoadResult.rootPathNodes.length - 1 + treeLoadResult.totalChildCount;\n          response.loadedVMObjects = newNodes;\n        } else {\n          var currentlyLoadedRootPathNodeVMO = null;\n          var startLevelIndex = 0;\n          var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n          var numberOfLevelsToBeInserted = 0; // Check if there is request to merge new ViewModelTreeNodes from TreeLoadResult into existing loaded VMOs.\n\n          if (treeLoadResult.mergeNewNodesInCurrentlyLoadedTree && loadedVMOs) {\n            for (startLevelIndex = treeLoadResult.rootPathNodes.length; startLevelIndex >= 1; startLevelIndex--) {\n              currentlyLoadedRootPathNodeVMO = loadedVMOs.filter(function (vmo) {\n                return treeLoadResult.rootPathNodes[startLevelIndex - 1] && vmo.id === treeLoadResult.rootPathNodes[startLevelIndex - 1].id;\n              })[0];\n              /**\n               * currentlyLoadedRootPathNodeVMO is the parent node which is currently loaded in\n               * VMO and its also present in response structure.\n               */\n\n              if (currentlyLoadedRootPathNodeVMO) {\n                numberOfLevelsToBeInserted++;\n                currentlyLoadedRootPathNodeVMO.nextLevelInsert = true;\n                break;\n              }\n            }\n          }\n          /**\n           * 1)vmNodesInTreeHierarchyLevels is an array of arrays. Each array index represents vmNodes\n           * at given level (index 0 in array represents level -1 which is not displayed, index 1\n           * level 0 and so on). Each level will have node where next level nodes need to be inserted.\n           *\n           * 2)rootPathNodes contain array of parents with one or more having children under it.\n           *\n           * 3)At each level, you will have parent below which next level is supposed to be inserted.\n           */\n          // Iterate through all levels\n\n\n          for (ndx = startLevelIndex; ndx < treeLoadResult.vmNodesInTreeHierarchyLevels.length; ndx++) {\n            var vmNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ndx]; // Get parent node below which next level needs to be inserted.\n\n            var nextLevelParentNode = vmNodes.filter(function (vmo) {\n              return treeLoadResult.rootPathNodes[ndx] && vmo.id === treeLoadResult.rootPathNodes[ndx].id;\n            })[0];\n\n            if (nextLevelParentNode) {\n              nextLevelParentNode.nextLevelInsert = true;\n              numberOfLevelsToBeInserted++;\n            }\n          }\n\n          const viewModelObjects = getViewModelCollectionInTreeHierarchyFormat(treeLoadResult, vmCollection, currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode);\n          response.loadedVMObjects = viewModelObjects;\n          response.totalFound = viewModelObjects.length;\n        }\n      } else if (treeLoadResult.nonRootPathHierarchicalData) {\n        /**\n         * If we are given multiple expanded nodes which are all not necessarily on the \"rootPath\"\n         */\n        const viewModelObjects = getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult, vmCollection, dataCtxNode);\n\n        if (viewModelObjects) {\n          response.loadedVMObjects = viewModelObjects;\n          response.totalFound = viewModelObjects.length;\n        }\n      } else {\n        /**\n         * Check if we are processing the unseen 'root' node.<br>\n         * If so: Just add the results as the only items in the collection.<BR>\n         * If not: Insert the results in at the correct location.\n         */\n        if (isParentRoot && treeLoadResult.startChildNdx === 0) {\n          response.totalFound = treeLoadResult.totalChildCount;\n          response.loadedVMObjects = _.clone(treeLoadResult.childNodes);\n        } else {\n          if (treeLoadResult.cursorNodeId) {\n            _insertModelObjects(vmCollection, treeLoadResult.cursorNodeId, treeLoadResult.childNodes, addAfter);\n          } else {\n            if (treeLoadResult.startChildNdx === 0) {\n              _insertModelObjects(vmCollection, uwUtilSvc.getEvaluatedId(expectantParentNode), treeLoadResult.childNodes, addAfter);\n            } else {\n              var insertionNode = expectantParentNode.children[treeLoadResult.startChildNdx - 1];\n\n              _insertModelObjects(vmCollection, uwUtilSvc.getEvaluatedId(insertionNode), treeLoadResult.childNodes, addAfter);\n            }\n          }\n        }\n        /**\n         * Update the totalNumber of known 'child' nodes.\n         */\n\n\n        expectantParentNode.totalChildCount = treeLoadResult.totalChildCount;\n      }\n      /**\n       * Fire a 'modelObjectsUpdated' event, sourced to this uwDataProvider, but only for changes to the\n       * outer-most level. This event includes the entire ViewModelCollection. This event is required to\n       * have the aw-table controller know when to update the information in the GridWrapper.\n       */\n\n\n      if (isParentRoot) {\n        var nChild = resultParentNode.children ? resultParentNode.children.length : 0;\n        moreAboveFirst = false;\n        moreBelowLast = false;\n\n        if (resultParentNode.cursorObject) {\n          moreAboveFirst = !resultParentNode.cursorObject.startReached;\n          moreBelowLast = !resultParentNode.cursorObject.endReached;\n        } else {\n          moreBelowLast = resultParentNode.totalChildCount > nChild;\n        }\n\n        _notifyModelObjectsUpdate(dataCtxNode, {\n          prevPage: moreAboveFirst,\n          nextPage: moreBelowLast\n        });\n      } else {\n        dpSelf.syncSelectionModel(dataCtxNode);\n      }\n      /**\n       * Fire a 'treeNodesLoaded' event, sourced to this uwDataProvider, for all tree-table changes. This\n       * event includes only the input/result structures for the current load operation. This event is\n       * used to load additional properties in an async fashion.\n       */\n\n\n      eventBus.publish(dpSelf.name + '.treeNodesLoaded', {\n        treeLoadInput: treeLoadInput,\n        treeLoadResult: treeLoadResult\n      });\n      /**\n       * Check if the response indicates we should make sure the parent is expanded.\n       */\n\n      if (treeLoadResult.expandParent) {\n        eventBus.publish(dpSelf.name + '.expandTreeNode', {\n          parentNode: resultParentNode\n        });\n      }\n    } else if (isParentRoot) {\n      /**\n       * If this is the 'top' level node we now know it IS empty.\n       */\n      dpSelf.noResults = true;\n      /**\n       * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n       * <P>\n       * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n       * 'top' children into the ViewModelCollection. Do not do this!\n       */\n\n      newTopNode = treeLoadResult.newTopNode;\n\n      if (newTopNode && newTopNode.levelNdx === -1) {\n        dpSelf.topTreeNode = newTopNode;\n        dpSelf.topTreeNode.children = null;\n        dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n      }\n      /**\n       * If empty child nodes are passed to provider, they should be honored and should get updated in UI.\n       */\n\n\n      if (treeLoadResult.startChildNdx === 0) {\n        /**\n         * This change is when we delete a single row from the tree table\n         */\n        moreAboveFirst = false;\n        moreBelowLast = false;\n        /**\n         * Determine if this node is NOT an 'incompleteHead' or 'incompleteTail'\n         */\n\n        if (resultParentNode.cursorObject) {\n          moreAboveFirst = !resultParentNode.cursorObject.startReached;\n          moreBelowLast = !resultParentNode.cursorObject.endReached;\n        }\n\n        var emptyChildNodes = !moreAboveFirst && !moreBelowLast;\n\n        if (emptyChildNodes) {\n          response.totalFound = treeLoadResult.totalChildCount;\n          response.loadedVMObjects = _.clone(treeLoadResult.childNodes);\n\n          _notifyModelObjectsUpdate(dataCtxNode, {\n            prevPage: moreAboveFirst,\n            nextPage: moreBelowLast\n          });\n        }\n      }\n    }\n\n    return response;\n  }\n  /**\n   * @param {TreeLoadResult} treeLoadResult - Object containing result/status information.\n   * @param {ViewModelObjectArray} vmCollection - VMO array to set\n   * @param {ViewModelObject} currentlyLoadedRootPathNodeVMO - ...\n   * @param {Number} startLevelIndex -\n   * @param {Number} numberOfLevelsToBeInserted -\n   */\n\n\n  function getViewModelCollectionInTreeHierarchyFormat(treeLoadResult, vmCollection, currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode) {\n    var finalVMOs = [];\n    var lvlNdx = startLevelIndex;\n    var numberOfLevelsInserted = 0;\n    var indx = 0;\n\n    if (currentlyLoadedRootPathNodeVMO) {\n      /**\n       * currentlyLoadedRootPathNodeVMO is populated. That means parentNode that has come in\n       * TreeLoadResult is already loaded in vmCollection. In that case , restore existing VMOs, merge new\n       * VMOs that we got in response in currently loaded VMOs.\n       */\n      arrayUtils.insert(finalVMOs, 0, vmCollection.getLoadedViewModelObjects());\n      indx = finalVMOs.indexOf(currentlyLoadedRootPathNodeVMO);\n    } else {\n      // Build Final ViewModelTreeNodes array. Add zeroth level , iterate, check for next level insertion point,\n      // and add new level there.Keep building and iterating through whole list.\n      arrayUtils.insert(finalVMOs, 0, treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx++]);\n    }\n\n    while (indx < finalVMOs.length && numberOfLevelsInserted < numberOfLevelsToBeInserted) {\n      var vmo = finalVMOs[indx];\n\n      if (vmo.nextLevelInsert) {\n        vmo.isExpanded = true;\n\n        for (let vmNodeInTreeHierarchyLevel of treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]) {\n          var finalVMOIndex = 0;\n\n          for (let finalVMO of finalVMOs) {\n            if (finalVMO && finalVMO.id === vmNodeInTreeHierarchyLevel.id) {\n              finalVMOs.splice(finalVMOIndex, 1);\n            }\n\n            finalVMOIndex++;\n          }\n        }\n\n        arrayUtils.insert(finalVMOs, indx, treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]); // Next level nodes should be stored as children under current level parent.\n\n        vmo.children = _.clone(treeLoadResult.vmNodesInTreeHierarchyLevels[lvlNdx]);\n        vmo.totalChildCount = vmo.children.length;\n        vmo.isLeaf = false; // Store parent as expanded in state/local storage.\n\n        saveRowExpanded(dataCtxNode, vmo);\n        delete vmo.nextLevelInsert;\n        lvlNdx++;\n        numberOfLevelsInserted++;\n      }\n\n      indx++;\n    } // filter out vmo with treeLevel -1 as we don't show topLevel Node.\n\n\n    finalVMOs = finalVMOs.filter(function (vmo) {\n      return vmo.$$treeLevel !== -1;\n    });\n    return finalVMOs;\n  }\n  /**\n   * @param {TreeLoadResult} treeLoadResult object containing result/status information.\n   * @param {ViewModelObjectArray} vmCollection VMO array to set\n   */\n\n\n  function getViewModelCollectionInTreeHierarchyFormatForTopDown(treeLoadResult, vmCollection, dataCtxNode) {\n    let finalVMOs = [];\n\n    if (treeLoadResult.mergeNewNodesInCurrentlyLoadedTree) {\n      finalVMOs = vmCollection.getLoadedViewModelObjects();\n    }\n\n    for (let index = 0; index < treeLoadResult.vmNodesInTreeHierarchyLevels.length; index++) {\n      let currentNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[index];\n\n      for (let node = 0; node < currentNodes.length; node++) {\n        let vmoIndex = -1;\n        let levelIndex = 0;\n        let currentNode = currentNodes[node];\n        finalVMOs.forEach((vmo, index) => {\n          if (currentNode) {\n            if (vmo.id === currentNode.id) {\n              vmoIndex = index;\n            }\n\n            if (vmo.id === currentNode.parentUid) {\n              levelIndex = index;\n            }\n          }\n        });\n\n        if (vmoIndex !== -1) {\n          _.assign(finalVMOs[vmoIndex], currentNode);\n        } else {\n          arrayUtils.insert(finalVMOs, levelIndex + node, [currentNode]);\n        }\n\n        saveRowExpanded(dataCtxNode, currentNode);\n      }\n    }\n\n    if (!treeLoadResult.mergeNewNodesInCurrentlyLoadedTree) {\n      return finalVMOs;\n    }\n  }\n  /**\n   * @param {ViewModelTreeNode} parentNode - (Optional) The 'parent' to use when determining input.\n   *\n   * @param {String} cursorNodeId - (Optional) The ID of the node to insert above/below\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @return {Object} The resolved input object to pass to 'createTreeLoadInput'.\n   */\n\n\n  function _determineInput(parentNode, cursorNodeId, addAfter) {\n    /**\n     * Determine 'child' index to use as basis for loading.\n     *\n     * <pre>\n     * Handle various cases of 'parent' and/or 'cursorNodeId' validity:\n     * 1) 'parent' and 'cursorNodeId' valid:             Locate the 'cursorNodeId' in the 'parent' and use its index.\n     * 2) 'parent' valid and 'cursorNodeId' not valid:   Use either end of the 'parent' children as the index.\n     * 3) 'parent' NOT valid and the 'cursor' is valid:  Locate the 'parent' of the 'cursor' and use the 'cursor' index.\n     * 4) 'parent' NOT valid and the 'cursor' NOT valid: Fail assertion.\n     * Note: Case 3) is used when dynamically loading the next page of 'children' directly after/before the\n     * 'cursor' node.\n     * </pre>\n     */\n    var startChildNdx = -1;\n\n    if (parentNode) {\n      if (cursorNodeId) {\n        startChildNdx = _findChildNdx(parentNode, cursorNodeId);\n\n        if (startChildNdx !== -1) {\n          startChildNdx++;\n        }\n      } else {\n        if (addAfter) {\n          var nChild = parentNode.children ? parentNode.children.length : 0;\n          startChildNdx = nChild;\n        } else {\n          startChildNdx = 0;\n        }\n      }\n    } else if (cursorNodeId) {\n      var vmCollection = dpSelf.viewModelCollection;\n      var cursorNdx = vmCollection.findViewModelObjectById(cursorNodeId);\n\n      if (cursorNdx !== -1) {\n        var cursorNode = vmCollection.getViewModelObject(cursorNdx);\n        var parentLevelNdx = cursorNode.levelNdx - 1;\n        startChildNdx = 1;\n\n        for (var ndx = cursorNdx - 1; ndx >= 0; ndx--) {\n          var currRow = vmCollection.getViewModelObject(ndx);\n\n          if (currRow.levelNdx === parentLevelNdx) {\n            parentNode = currRow; //Locate the 'parent' of the 'cursor' and use the Parent 'cursor' index.\n\n            if (parentNode.cursorObject && parentNode.cursorObject.endIndex) {\n              startChildNdx = parentNode.cursorObject.endIndex + 1;\n            }\n\n            break;\n          }\n\n          startChildNdx++;\n        }\n      }\n    }\n\n    assert(parentNode, 'Unable to determine \\'parent\\' node');\n    assert(startChildNdx !== -1, 'Unable to determine location in \\'parent\\' to insert loaded \\'child\\' nodes');\n    return {\n      parentNode: parentNode,\n      startChildNdx: startChildNdx\n    };\n  }\n  /**\n   * Log a warning that there was an access to this UwDataProvider after it was destroyed.\n   *\n   * @param {String} functionName - Name of the function being accessed.\n   */\n\n\n  function _reportAccessToZombieDataProvider(functionName) {\n    logger.warn('Attempt to execute a function on a UwDataProvider after it was destroyed...' + '\\n' + //\n    'Function was therefore not executed...continuing.' + '\\n' + //\n    'UwDataProvider: ' + dpSelf.name + '\\n' + //\n    'Function: ' + functionName);\n  }\n  /**\n   * Override the default implementation to return more helpful information.\n   *\n   * @return {String} Text used to identify the ID of the UsDataProvider (e.g. 'modelId' + an optional\n   *         'name').\n   */\n\n\n  dpSelf.toString = function () {\n    if (dpSelf) {\n      if (dpSelf.name) {\n        return dpSelf._modelId + '  name: ' + dpSelf.name;\n      }\n\n      return dpSelf._internal.modelId + '  name: ' + '???';\n    }\n\n    return 'UwDataProvider (destroyed)';\n  };\n  /**\n   * Get all of the loaded objects that are currently selected.\n   *\n   * @return {IModelObjectArray} Array of selected {IModelObject}.\n   */\n\n\n  dpSelf.getSelectedObjects = function () {\n    if (dpSelf.selectionModel) {\n      var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n      if (dpSelf.vmCollectionObj && dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0) {\n        loadedVMO = [...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices];\n      }\n\n      return dpSelf.selectionModel.getSortedSelection(loadedVMO);\n    }\n\n    return [];\n  };\n  /**\n   * Get the indices of the selected objects.\n   *\n   * @returns {NumberArray} Resolved with the indicies of the selected objects in the ViewModelCollection.\n   */\n\n\n  dpSelf.getSelectedIndices = function () {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    return dpSelf.getSelectedObjects().map(function (vmo) {\n      return loadedVMO.indexOf(vmo);\n    });\n  }; // Define with this 'incorrect' spelling as well.\n\n\n  dpSelf.getSelectedIndexes = dpSelf.getSelectedIndices;\n  /**\n   * Change the selection range\n   *\n   * @param {Number} start - String index in collection to add/remove/toggle.\n   * @param {Number} end -  Ending index in collection to add/remove/toggle.\n   * @param {Boolean} select - (Optional) TRUE, 'select'...FALSE, 'unselect'...UNDEFINED, 'toggle'.\n   */\n\n  dpSelf.changeObjectsSelection = function (start, end, select) {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects(); // Going down : Going up\n\n    var e = start > end ? start : end;\n    var s = start > end ? end : start;\n    var objects = loadedVMO.slice(s, e + 1);\n\n    if (select === true) {\n      if (dpSelf.selectionModel.multiSelectEnabled || objects.length > 1) {\n        dpSelf.selectionModel.addToSelection(objects);\n      } else {\n        dpSelf.selectionModel.setSelection(objects);\n      }\n    } else if (select === false) {\n      dpSelf.selectionModel.removeFromSelection(objects);\n    } else {\n      dpSelf.selectionModel.toggleSelection(objects);\n    }\n  }; // activates multi Select mode on selection Model = multiple.\n\n\n  dpSelf.multiSelectModeEvent = eventBus.subscribe(dpSelf.name + '.multiSelectModeAction', function (eventData) {\n    if (eventData && eventData.multiSelect) {\n      dpSelf.enableMultiSelect();\n    } else {\n      dpSelf.disableMultiSelect();\n    }\n  });\n  let _selectionModelDataCtxNode = null; // Event to expose various selection APIs on the selection model.\n\n  dpSelf.selectActionEvent = eventBus.subscribe(dpSelf.name + '.selectAction', function (eventData) {\n    if (dpSelf.selectionModel) {\n      const oldSelection = dpSelf.selectionModel.getSelection();\n\n      if (eventData) {\n        if (eventData.selectAll === true) {\n          dpSelf.selectAll();\n        }\n\n        if (eventData.selectAll === false) {\n          dpSelf.selectNone();\n        }\n\n        if (eventData.select) {\n          dpSelf.selectionModel.addToSelection(eventData.select);\n        }\n\n        if (eventData.deselect) {\n          dpSelf.selectionModel.removeFromSelection(eventData.deselect);\n        }\n\n        if (eventData.setSelection) {\n          dpSelf.selectionModel.setSelection(eventData.setSelection);\n        }\n      }\n\n      const newSelection = dpSelf.selectionModel.getSelection();\n      dpSelf.syncSelectionModel(_selectionModelDataCtxNode, newSelection, oldSelection);\n    }\n  });\n  /**\n   * Enable MultiSelect\n   */\n\n  dpSelf.enableMultiSelect = function () {\n    if (dpSelf.selectionModel) {\n      dpSelf.selectionModel.setMultiSelectionEnabled(true);\n    }\n  };\n  /**\n   * disable MultiSelect\n   */\n\n\n  dpSelf.disableMultiSelect = function () {\n    if (dpSelf.selectionModel) {\n      dpSelf.selectionModel.setMultiSelectionEnabled(false);\n      dpSelf.selectNone();\n    }\n  };\n  /**\n   * Select all loaded objects\n   */\n\n\n  dpSelf.selectAll = function () {\n    var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    dpSelf.selectionModel.addToSelection(loadedVMO);\n    eventBus.publish(dpSelf.name + '.selectAll', {});\n  };\n  /**\n   * Clear selection\n   */\n\n\n  dpSelf.selectNone = function () {\n    dpSelf.selectionModel.setSelection([]);\n    eventBus.publish(dpSelf.name + '.selectNone', {});\n  };\n\n  dpSelf.setSelectionEnabled = function (isSelectionEnabled) {\n    dpSelf.selectionModel.setSelectionEnabled(isSelectionEnabled);\n    eventBus.publish(dpSelf.name + '.isSelectionEnabledChanged', {\n      isSelectionEnabled: isSelectionEnabled\n    });\n  };\n  /**\n   * Sync the view with the updated selection model.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {StringArray} newSelection -\n   * @param {StringArray} oldSelection -\n   */\n\n\n  dpSelf.syncSelectionModel = function (dataCtxNode, newSelection, oldSelection) {\n    // Ensure the selection state is correct\n    //zarq9k: Once we sync up the old viewModel and new Collection, this line would not be required.\n    // issue reported - https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/56\n    // We never worked on it.\n    var loadedVMO = dpSelf.vmCollectionObj.vmCollection.getLoadedViewModelObjects(); //var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n    if (dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0) {\n      loadedVMO = [...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices];\n    }\n\n    loadedVMO.map(function (vmo) {\n      vmo.selected = dpSelf.selectionModel.isSelected(vmo);\n    }); // Put the selected objects on the data provider\n    // Makes binding in view models simpler\n\n    var prevSelectedObjects = dpSelf.selectedObjects;\n    dpSelf.selectedObjects = loadedVMO.filter(function (vmo) {\n      return vmo.selected;\n    });\n\n    var emitEvents = function () {\n      //This check ensures notification is triggered only if there a selection change\n      if (!_.isEqual(prevSelectedObjects, dpSelf.selectedObjects)) {\n        if (dpSelf.selectionModel && dpSelf.selectionModel.selectionData) {\n          dpSelf.selectionModel.selectionData.update({\n            selected: dpSelf.getSelectedObjects(),\n            source: dpSelf.validSourceTypes,\n            id: dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name,\n            _modelId: dpSelf._modelId\n          });\n          trace('Selection Changed for ', dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name, dpSelf.selectedObjects);\n        }\n\n        let eventObj = {\n          selectedObjects: dpSelf.getSelectedObjects(),\n          selectedUids: dpSelf.selectionModel.getSelection(),\n          scope: dataCtxNode,\n          selectionModel: dpSelf.selectionModel,\n          selected: dpSelf.getSelectedObjects(),\n          dataProviderName: dpSelf.name,\n          dataProvider: dpSelf\n        }; // Always notify through event bus\n\n        eventBus.publish(dpSelf.name + '.selectionChangeEvent', eventObj);\n      }\n    }; // Handle case where something is selected that is not in data provider\n\n\n    if (dpSelf.focusAction) {\n      var shouldEmitSelectionEvent = true; // Ignore the simple sync to mark objects as selected\n\n      if (newSelection && oldSelection) {\n        var newlySelected = newSelection.filter(function (x) {\n          return oldSelection.indexOf(x) === -1;\n        }); // If a single new object was selected attempt to focus\n\n        if (newlySelected.length === 1) {\n          // Try to get object from current list\n          var newlySelectedObject = dpSelf.selectedObjects.filter(function (vmo) {\n            return prevSelectedObjects.indexOf(vmo) === -1;\n          })[0]; // If not found clear current list and focus\n\n          if (!newlySelectedObject) {\n            shouldEmitSelectionEvent = false; // Reset cursor\n\n            if (dpSelf.cursorObject) {\n              dpSelf.cursorObject = null;\n            }\n\n            dpSelf.pageDispatcher({\n              type: 'FOCUS_PAGE'\n            });\n            dpSelf.vmCollectionDispatcher({\n              type: 'FOCUSING',\n              focusing: true\n            });\n          } else {\n            eventBus.publish(dpSelf.name + '.focusSelection');\n          }\n        }\n      }\n\n      if (shouldEmitSelectionEvent) {\n        emitEvents();\n      }\n    } else {\n      var uidSet = new Set();\n\n      _.forEach(dpSelf.selectedObjects, function (obj) {\n        var uid;\n\n        if (typeof obj === 'object') {\n          uid = obj.uid;\n        } else {\n          uid = obj;\n        }\n\n        uidSet.add(uid);\n      }); //If the selectionModel is shared, there is possibility that the selectionModel can have\n      //stale/invalid selection stored.\n      //Give precedence to dataprovider selection in case of shared selectionModel\n\n\n      const isSharedSelectionModel = _ctorInputData && _ctorInputData.selectionModel;\n\n      if (isSharedSelectionModel && uidSet.size !== dpSelf.selectionModel.getCurrentSelectedCount()) {\n        // Default behavior is to remove any object not found from the selection model\n        dpSelf.selectionModel.setSelection(dpSelf.selectedObjects);\n      } //Notify selection change in the same render cycle\n\n\n      emitEvents();\n    } // Check selection state\n\n\n    dpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);\n  };\n  /**\n   * Detach the selection model from the data provider. Should only be done when re-initializing.\n   */\n\n\n  dpSelf.detachSelectionModel = function () {\n    if (dpSelf.syncSelectionEvent) {\n      dpSelf.syncSelectionEvent();\n      dpSelf.syncSelectionEvent = null;\n    }\n  };\n  /**\n   * Attach the data provider to its current selection model. Ensures re-initialization of the data provider\n   * will not result in duplicate event listeners / watches.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   */\n  // dpSelf.attachSelectionModel = function( dataCtxNode ) {\n  //     // _selectionModelDataCtxNode = dataCtxNode;\n  //     // Remove previous watch if it is still setup\n  //     // dpSelf.detachSelectionModel();\n  //     // dpSelf.selectionModel.syncSelections = function( oldVal, newVal ) {\n  //     //     dpSelf.syncSelectionModel( dataCtxNode, newVal, oldVal );\n  //     // };\n  // };\n\n  /**\n   * Attach the selection model immediately. Will be detached / reattached if data provider is initialized.\n   * However cannot assume data provider is ever initialized.\n   */\n  //dpSelf.attachSelectionModel( {} );\n\n  /**\n   * Swap selection model with the new selection model provided as input. Detach current selection model and\n   * attach the new one\n   *\n   * @param {Object} newSelectionModel - new selection model which is required to swap\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   */\n\n\n  dpSelf.swapSelectionModel = function (newSelectionModel, dataCtxNode) {\n    // Detach the selection model while initializing\n    dpSelf.detachSelectionModel();\n    dpSelf.selectionModel = newSelectionModel;\n    dpSelf.attachSelectionModel(dataCtxNode);\n  }; // ======================== Edit Handler Interface ===================================================//\n\n  /**\n   *\n   * @param {*} stateName current state of edit\n   * @param {*} dpSelf data provider instance\n   */\n\n\n  var _notifyEditStateChange = function (stateName, dpSelf) {\n    dpSelf._editingState = stateName;\n    dpSelf._editing = stateName === 'starting'; // Add to the appCtx about the editing state\n\n    appCtxService.updateCtx(dpSelf._appCtxEditInProgress, dpSelf._editing);\n    eventBus.publish(dpSelf._eventTopicEditInProgress, dpSelf._editing);\n  };\n\n  if (!dpSelf._appCtxEditInProgress) {\n    dpSelf._appCtxEditInProgress = dpSelf.name + '_editInProgress';\n    dpSelf._eventTopicEditInProgress = dpSelf.name + '.editInProgress';\n  }\n  /**\n   * isDirty implementation of edit-handler interface.\n   * It check if any of the view model property inside view model object is modified.\n   * @returns {*} AwPromiseService.instance with promise true/false        *\n   */\n\n\n  dpSelf.isDirty = function () {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    return editUtilsService._isDirty(viewModelCollection);\n  };\n  /**\n   * Determines if prop edit is enabled for this dataprovider\n   * @param {Object} declViewModel the declarative view model\n   * @returns {*} true if individual prop editing is enabled\n   */\n\n\n  dpSelf.isPropEditEnabled = function (declViewModel) {\n    if (dpSelf.json && dpSelf.json.enablePropEdit) {\n      // If boolean is used return it directly otherwise evaluate the value as a condition\n      if (typeof dpSelf.json.enablePropEdit === 'boolean') {\n        return dpSelf.json.enablePropEdit;\n      }\n\n      const evaluationEnv = {\n        data: declViewModel,\n        ctx: appCtxService.ctx,\n        conditions: declViewModel._internal.conditionStates\n      };\n      return declUtils.evaluateCondition(declViewModel, dpSelf.json.enablePropEdit, evaluationEnv);\n    } else if (dpSelf.json && dpSelf.json.enablePropEdit === false) {\n      return false;\n    } // Default is true if enablePropEdit is not defined\n\n\n    return true;\n  };\n  /**\n   * This function implements the start edit function edit handler interface\n   * @param {*} dataCtxNode data ctx Node.\n   * @param {*} declViewModel declarative ViewModel.\n   * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n   * @return {*} AwPromiseService.instance with promise.\n   */\n\n\n  dpSelf.startEdit = function (dataCtxNode, declViewModel, editOptions) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    editConfig.sourceModel = dpSelf.name;\n\n    const saveEditStateChangeCallback = function () {\n      _notifyEditStateChange('saved', dpSelf);\n    };\n\n    return editUtilsService._startEdit(dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback, editOptions).then(function () {\n      if (!editOptions) {\n        _notifyEditStateChange('starting', dpSelf);\n      }\n    });\n  };\n  /**\n   * This is the cancel edits implementation of edit-handler interface.\n   * @param  {*} dataCtxNode data ctx Node.\n   * @param  {*} declViewModel declarative ViewModel.\n   * @return {*} AwPromiseService.instance with promise\n   */\n\n\n  dpSelf.cancelEdits = function (dataCtxNode, declViewModel) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    return editUtilsService._cancelEdits(dataCtxNode, declViewModel, viewModelCollection, editConfig).then(function () {\n      _notifyEditStateChange('canceling', dpSelf);\n    });\n  };\n  /**\n   * This function implements the save edits function edit handler interface\n   * @param {*} dataCtxNode data ctx Node.\n   * @param {*} declViewModel declarative ViewModel.\n   * @return {*} AwPromiseService.instance with promise.\n   */\n\n\n  dpSelf.saveEdits = function (dataCtxNode, declViewModel) {\n    var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n    var editConfig = dpSelf.json.editConfig;\n    return editUtilsService._saveEdits(dataCtxNode, declViewModel, viewModelCollection, editConfig).then(function () {\n      _notifyEditStateChange('saved', dpSelf);\n    });\n  };\n  /**\n   * @returns {*} boolean true/false\n   */\n\n\n  dpSelf.editInProgress = function () {\n    return dpSelf._editing;\n  };\n\n  dpSelf.setFilterString = filterVal => {\n    filterStr = filterVal;\n  };\n\n  dpSelf.getFilterString = () => {\n    return filterStr;\n  }; // ======================== End of Edit Handler Interface ===================================================//\n\n  /**\n   * Initialize and trigger first page of results.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @return {Promise} A promise object resolved with the ViewModelCollection returned by the current\n   *         DataProviderService.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.initialize = function (dataCtxNode) {\n    var promise;\n\n    if (dpSelf.cursorObject) {\n      dpSelf.cursorObject = null;\n    }\n\n    dpSelf.setFilterString(filterStr);\n    /**\n     * If the constructor was told there would be some additional input data passed in from the data ctx\n     * node attempt to get it at this point.\n     * <P>\n     * Note: The input data from the scope can only override specific properties.\n     */\n\n    if (!_.isEmpty(_ctorInputData)) {\n      var declViewModel = declUtils.findViewModel(dataCtxNode);\n      dataCtxService.applyScope(declViewModel, _ctorInputData, null, dataCtxNode);\n\n      _.forEach(_ctorInputData, function (value, name) {\n        if (_modifiablePropertiesViaInputData.indexOf(name) !== -1) {\n          dpSelf[name] = value;\n        }\n      });\n    }\n    /** editHandler */\n\n\n    if (dpSelf.json.editContext) {\n      let reusableEditHandler = editHandlerSvc.getEditHandler(dpSelf.json.editContext); // If editHandler already exists don't create a new one - which overwrites the old one\n\n      if (!reusableEditHandler) {\n        editHandlerSvc.setEditHandler(editHandlerFactory.createEditHandler(dataSourceService.createNewDataSource({\n          dataProvider: dpSelf\n        }), dpSelf.editSupportParamKeys), dpSelf.json.editContext); // set this handler active\n\n        editHandlerSvc.setActiveEditHandlerContext(dpSelf.json.editContext);\n        _editHandlerRegistered = true;\n      }\n    }\n\n    promise = Promise.resolve(dpSelf.resetDataProvider()); // Detach the selection model while initializing\n    // dpSelf.detachSelectionModel();\n\n    /** revisitme Shaishav: This should be dead code in future because we delegated this responsibility to dataProviderUtils js\n     *  Keeping the code for now to ensure we do not miss any functionality while migrating\n     if( dpSelf.accessMode === 'tree' ) {\n        dpSelf.topTreeNode = _determineTopTreeNode( dpSelf.topNodeUid );\n         promise = dpSelf.getTreeNodeInitial( dataCtxNode, dpSelf.topTreeNode, null, true,\n            dpSelf.topTreeNode ).then( function( response ) {\n            dpSelf.attachSelectionModel( dataCtxNode );\n             return response;\n        } );\n    } else {\n        dpSelf.startIndex = 0;\n         var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, false, dataCtxNode.filterStr );\n         var actionRequestObj = {\n            listLoadInput: listLoadInput\n        };\n         var action = dpSelf.initializeAction ? dpSelf.initializeAction : dpSelf.action;\n         if( logger.isDeclarativeLogEnabled() ) {\n            debugService.debugDataProviderInitialize( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj, _ctorInputData );\n        }\n         promise = dpSelf.someDataProviderSvc.getFirstPage( action, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then(\n            function( response ) {\n                eventBus.publish( dpSelf.name + '.resetScroll', {} );\n                var vmCollection = dpSelf.viewModelCollection;\n                 vmCollection.clear();\n                vmCollection.setTotalObjectsFound( response.totalFound );\n                 if( response.totalFound > 0 && response.results ) {\n                    dpSelf.noResults = false;\n                     vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                        dpSelf.preSelection );\n                     /**\n                     * Determine if the last node in the collection is an 'incompleteTail' because we know\n                     * there are more found than currently loaded.\n                    if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                        vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                        _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                    }\n                } else {\n                    dpSelf.noResults = true;\n                    // assigning no result found string if there is no data from rest service\n                    if( dpSelf.json.noResultsFound ) {\n                        var i18nkey = dpSelf.json.noResultsFound;\n                        i18nkey = parsingUtils.geti18nKey( i18nkey );\n                        dpSelf.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                    }\n                }\n                 // dpSelf.attachSelectionModel( dataCtxNode );\n                 _notifyModelObjectsUpdate( null, {\n                    firstPage: true\n                } );\n                 return response;\n            },\n            function( err ) {\n                logger.warn( err );\n            } );\n    }\n    */\n    // Attach selection model once first page is loaded\n\n    promise.then(function (response) {\n      if (dpSelf.selectionModel && dpSelf.selectionModel.getSelection().length > 0) {\n        /**\n         * Fire modelObjects updated event using data provider name space\n         */\n        eventBus.publish(dpSelf.name + '.focusSelection');\n      }\n      /**\n       * Note: Not all dataCtxNodes are actually AngularJS $scopes. So we have to check if the $scope API\n       * exists before we try to use it.\n       */\n\n\n      if (dataCtxNode.$on) {\n        dataCtxNode.$on('dataProvider.selectAction', function (event, data) {\n          if (data && data.selectAll) {\n            dpSelf.selectAll();\n          } else {\n            dpSelf.selectNone();\n          }\n        });\n        dataCtxNode.$on('dataProvider.multiSelectAction', function (event, data) {\n          if (data && data.multiSelect) {\n            dpSelf.enableMultiSelect();\n          } else {\n            dpSelf.disableMultiSelect();\n          }\n        });\n      }\n\n      return response;\n    });\n    return promise;\n  }; // initialize\n\n\n  dpSelf.setDataUpdater = (pageDispatcher, vmCollectionDispatcher) => {\n    dpSelf.pageDispatcher = pageDispatcher;\n    dpSelf.vmCollectionDispatcher = vmCollectionDispatcher;\n  };\n\n  dpSelf.setSelectionModel = _ref => {\n    let {\n      selectionModel,\n      selectionDispatcher\n    } = _ref;\n    dpSelf.selectionModel = selectionModel;\n    selectionModelDispatcher = selectionDispatcher;\n  };\n\n  dpSelf.setRootReference = ref => {\n    referenceElement = ref;\n  };\n\n  dpSelf.setPropsCallback = getProps => {\n    propsCallback = getProps;\n  };\n\n  dpSelf.getRootReference = () => {\n    return referenceElement;\n  };\n\n  dpSelf.setLovEntryRef = ref => {\n    lovEntryRef = ref;\n  };\n\n  dpSelf.getLovEntryRef = () => {\n    return lovEntryRef;\n  };\n\n  dpSelf.setPagination = pageOption => {\n    if (!paginationOption) {\n      paginationOption = pageOption;\n    }\n  };\n\n  dpSelf.getPagination = () => {\n    return paginationOption ? paginationOption : null;\n  };\n\n  dpSelf.resetDataProvider = () => {\n    dpSelf.vmCollectionDispatcher({\n      type: 'COLLECTION_RESET'\n    });\n    dpSelf.pageDispatcher({\n      type: 'PAGE_RESET'\n    });\n    dpSelf.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    }); // Spare the selection model reset, if it is shared one.\n\n    if (_ctorInputData && !_ctorInputData.selectionModel || !_ctorInputData) {\n      dpSelf.selectNone();\n    }\n  };\n  /**\n   * validate the lovValueSections if it needs to call the \"validateLOVValueSelections\" soa\n   *\n   * @param {array} lovEntry - the lovEntry which is gotten from \"getinitialValues\" SOA and it's the selected\n   *            item\n   * @param {Object} dataCtxNode - The angular scope of this data provider\n   * @return {Promise} A promise object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.validateLOV = function (_ref2, dataCtxNode) {\n    let {\n      lovEntries,\n      vmo,\n      viewModelProp\n    } = _ref2;\n\n    try {\n      let action = dpSelf.validateAction;\n      return dpSelf.someDataProviderSvc.validateLOVSelection({\n        lovEntries,\n        vmo,\n        viewModelProp\n      }, dataCtxNode, action, dpSelf.json);\n    } catch (e) {\n      //In Table, when user edits LOV manually and clicks outside, widget is destroyed and hence LOV dataprovider as well\n      //Due to this, if user clicks outside, dpSelf is coming as NULL and dpSelf.validateAction throws exception\n      // Because of this behavior, user is not able to save even valid values.\n      //To fix this we have to remove LOV validation outside\n      return Promise.resolve({\n        valid: true\n      });\n    }\n  };\n  /**\n   * Set the currently loaded view model objects based on the model object (or uid data) in the given array of\n   * 'result' objects.\n   *\n   * @param {ViewModelObjectArray} newVMOs - Array of ViewModelObjects to set.\n   * @param {Number} totalFound - total found\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.update = function (newVMOs, totalFound) {\n    if (newVMOs) {\n      let updatedVMOs = newVMOs; //create a new reference only if there is an existing VMOs array to trigger update else use the same.\n\n      if (!newVMOs.objects) {\n        updatedVMOs = [...newVMOs];\n      }\n\n      let totalFoundIn = totalFound;\n\n      if (_.isUndefined(totalFoundIn)) {\n        totalFoundIn = updatedVMOs.length;\n      }\n\n      dpSelf.noResults = totalFoundIn === 0;\n      let vmCollection = dpSelf.viewModelCollection;\n      vmCollection.clear();\n      vmCollection.setTotalObjectsFound(totalFoundIn);\n\n      if (dpSelf.accessMode === 'tree') {\n        vmCollection.loadedVMObjects = updatedVMOs;\n      } else {\n        vmCollection.updateModelObjects(updatedVMOs, dpSelf.uidInResponse, dpSelf.preSelection);\n        /**\n         * Determine if the last node in the collection is an 'incompleteTail' because we know there are\n         * more found than currently loaded.\n         */\n\n        if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n          _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n        }\n        /**\n         * Maintain selections based on the new VMOs.\n         */\n\n\n        const selectedObjects = dpSelf.getSelectedObjects();\n        dpSelf.selectionModel.setSelection(selectedObjects);\n\n        _notifyModelObjectsUpdate();\n      }\n\n      dpSelf.vmCollectionDispatcher({\n        type: 'COLLECTION_REPLACE',\n        viewModelObjects: vmCollection.loadedVMObjects,\n        totalFound: vmCollection.loadedVMObjects.length\n      });\n    }\n  };\n\n  dpSelf.viewModelCollection.update = dpSelf.update;\n  /**\n   * Required. Get item at specified index\n   *\n   * @param {Number} index - index of the list\n   * @param {Object} dataCtxNode - The angular scope of this data provider\n   * @return {Object} object specified at the given index\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.getItemAtIndex = function (index, dataCtxNode) {\n    if (index > dpSelf.viewModelCollection.getTotalObjectsLoaded()) {\n      dpSelf.getNextPage(dataCtxNode);\n      return null;\n    }\n\n    return dpSelf.viewModelCollection.getViewModelObject(index);\n  };\n  /**\n   * Get ViewModelCollection being managed by this UwDataProvider.\n   *\n   * @return {ViewModelCollection} Reference to the ViewModelCollection being managed by this UwDataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getViewModelCollection = function () {\n    return dpSelf.viewModelCollection;\n  }; // 20201010 Per tec meeting discussion, dataProvider should never have types, data parser has the role to process data source.\n  // /**\n  //  * return the same data structure of the list items in the link-with-popup window\n  //  * <P>\n  //  * Note: Used for aw-link-with-popup.directive<BR>\n  //  *\n  //  * @memberof module:js/dataProviderFactory~UwDataProvider\n  //  *\n  //  * @param {Number} index - index of the list\n  //  * @param {Object} dataCtxNode - The data context the queryy is occurring within.\n  //  * @param {String} dataProviderType - The types of dataProvider: \"static\" \"TcLOV\" \"Action\"\n  //  *\n  //  * @return {Object} The same data structure of the list items in the link-with-popup window.\n  //  */\n  // dpSelf.createPopupObject = function( index, dataCtxNode, dataProviderType ) {\n  //     if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n  //         dpSelf.getNextPage( dataCtxNode );\n  //         return null;\n  //     }\n  //     var listElement = {\n  //         listElementDisplayValue: '',\n  //         listElementObject: ''\n  //     };\n  //     var displayValue;\n  //     var viewModelObject = dpSelf.getItemAtIndex( index, dataCtxNode );\n  //     if( !viewModelObject ) {\n  //         return listElement;\n  //     }\n  //     if( dataProviderType ) {\n  //         if( dataProviderType === 'TcLOV' ) {\n  //             displayValue = viewModelObject.propDisplayValue;\n  //         } else if( dataProviderType === 'Action' ) {\n  //             var displayStr;\n  //             if( dataCtxNode.displayProperty ) {\n  //                 displayStr = _.get( viewModelObject, dataCtxNode.displayProperty );\n  //             } else {\n  //                 displayStr = _.get( viewModelObject.props, 'object_string' );\n  //             }\n  //             displayValue = displayStr.uiValue;\n  //         } else if( dataProviderType === 'Static' ) {\n  //             if( viewModelObject.staticDisplayValue && viewModelObject.staticElementObject ) {\n  //                 displayValue = viewModelObject.staticDisplayValue;\n  //                 viewModelObject = viewModelObject.staticElementObject;\n  //             } else {\n  //                 displayValue = viewModelObject;\n  //             }\n  //         } else {\n  //             displayValue = viewModelObject;\n  //         }\n  //     } else {\n  //         displayValue = viewModelObject;\n  //     }\n  //     listElement.listElementDisplayValue = displayValue;\n  //     listElement.listElementObject = viewModelObject;\n  //     if( dpSelf.viewModelCollection.getTotalObjectsFound() ) {\n  //         var totalFound = 0;\n  //     }\n  //     if( !viewModelObject && !totalFound ) {\n  //         // no result found\n  //         listElement.listElementDisplayValue = dataCtxNode.prop.uiValue;\n  //         listElement.listElementObject = dataCtxNode.prop.dbValue;\n  //     }\n  //     if( dataCtxNode.isLoading ) {\n  //         // no result found\n  //         listElement.listElementDisplayValue = dpSelf.isLoading;\n  //         listElement.listElementObject = dpSelf.isLoading;\n  //     }\n  //     return listElement;\n  // }; // createPopupObject\n\n  /**\n   * Required. For infinite scroll behavior, we always return a slightly higher number than the previously\n   * loaded items.\n   *\n   * @return {Number} number of objects loaded.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getLength = function () {\n    return dpSelf.viewModelCollection.getVirtualLength();\n  };\n  /**\n   * Check if there is more data to load\n   *\n   * @return {Boolean} True if there are more objects to load\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.hasMorePages = function () {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('hasMorePages');\n\n      return false;\n    }\n    /**\n     * Check if acting as a 'tree'<BR>\n     * If so: We can only used the 'top' node cursor.\n     */\n\n\n    if (dpSelf.accessMode === 'tree') {\n      if (dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject) {\n        return !dpSelf.topTreeNode.cursorObject.endReached;\n      }\n\n      return false;\n    }\n    /**\n     * Check if we have a 'cursor' object.<BR>\n     * If so: Use its state for whether there is more data.\n     */\n\n\n    if (dpSelf.cursorObject) {\n      return !dpSelf.cursorObject.endReached;\n    }\n\n    return dpSelf.viewModelCollection.getTotalObjectsFound() > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n  };\n  /**\n   * Check if there is more data to load before current position.\n   *\n   * @return {Boolean} True if there are more objects to load\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.hasMorePagesUp = function () {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('hasMorePagesUp');\n\n      return false;\n    }\n    /**\n     * Check if acting as a 'tree'<BR>\n     * If so: We can only used the 'top' node cursor.\n     */\n\n\n    if (dpSelf.accessMode === 'tree') {\n      if (dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject) {\n        return !dpSelf.topTreeNode.cursorObject.startReached;\n      }\n\n      return false;\n    }\n    /**\n     * Check if we have a 'cursor' object.<BR>\n     * If so: Use its state for whether there is more data.\n     */\n\n\n    if (dpSelf.cursorObject) {\n      return !dpSelf.cursorObject.startReached;\n    }\n\n    return false;\n  };\n  /**\n   * Finds and returns a vmo with an incomplete head/tail in the given range.\n   * @param { Number } startIdx - index of the first node in the range\n   * @param { Number } endIdx - index of the last node in the range\n   *\n   * @return {Object} The node with an incomplete head/tail\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.findIncompleteNodeInRange = function (startIdx, endIdx) {\n    for (var i = startIdx; i <= endIdx; i++) {\n      var vmNode = dpSelf.viewModelCollection.loadedVMObjects[i];\n\n      if (vmNode && (vmNode.incompleteHead === true || vmNode.incompleteTail)) {\n        return vmNode;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get previous page of results\n   *\n   * @param {Object} dataCtxNode - The data context the query is occurring within.\n   *\n   * @return {Promise} A promise resolved when the previous page is loaded and the viewModelCollection is\n   *         updated. Resolved object is a reference to the 'viewModelColection' object associated with this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getPreviousPage = function (dataCtxNode) {\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('getPreviousPage');\n\n      return $q.reject('Access to destroyed UwDataProvider.');\n    }\n\n    assert(dpSelf.previousAction, 'Invalid action specified');\n\n    if (dpSelf.accessMode === 'tree') {\n      var cursorNode = _.first(dpSelf.topTreeNode.children);\n\n      if (cursorNode) {\n        return dpSelf.getTreeNodePage(dataCtxNode, dpSelf.topTreeNode, cursorNode.id, false, dpSelf.topTreeNode);\n      }\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    }\n\n    var listLoadInput = awTableSvc.createListLoadInput(null, 0, null, false, true);\n    var actionRequestObj = {\n      listLoadInput: listLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.previousAction, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n      dpSelf.viewModelCollection.setTotalObjectsFound(response.totalFound);\n\n      if (response.totalFound > 0) {\n        dpSelf.viewModelCollection.updateModelObjects(response.results, dpSelf.uidInResponse, dpSelf.preSelection, true);\n      }\n\n      _notifyModelObjectsUpdate(dataCtxNode, {\n        prevPage: true\n      });\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    });\n  };\n  /**\n   * Get next page of results\n   *\n   * @param {Object} dataCtxNode - The data context the query is occurring within.\n   *\n   * @return {Promise} A promise resolved when the next page is loaded and the viewModelCollection is updated.\n   *         Resolved object is a reference to the 'viewModelColection' object associated with this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getNextPage = function (dataCtxNode) {\n    // revisit me - temp fix to make dataProvider instance consistent\n    const dpSelf = this;\n\n    if (dpSelf._isDestroyed) {\n      _reportAccessToZombieDataProvider('getNextPage');\n\n      return $q.reject('Access to destroyed UwDataProvider.');\n    }\n\n    if (dpSelf.accessMode === 'tree') {\n      var cursorNode = _.last(dpSelf.topTreeNode.children);\n\n      if (cursorNode) {\n        return dpSelf.getTreeNodePage(dataCtxNode, dpSelf.topTreeNode, cursorNode.id, true, dpSelf.topTreeNode);\n      }\n\n      return $q.resolve(dpSelf.viewModelCollection);\n    }\n\n    var totalFound = dpSelf.viewModelCollection.getTotalObjectsFound();\n    var totalUniqueLoaded = dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n\n    if (totalFound > totalUniqueLoaded || dpSelf.cursorObject && !dpSelf.cursorObject.endReached) {\n      dpSelf.startIndex = totalUniqueLoaded;\n      var listLoadInput = awTableSvc.createListLoadInput(null, dpSelf.startIndex, null, true, true, dataCtxNode.filterStr);\n      var actionRequestObj = {\n        listLoadInput: listLoadInput\n      };\n      var action = dpSelf.nextAction ? dpSelf.nextAction : dpSelf.action;\n\n      if (logger.isDeclarativeLogEnabled()) {\n        debugService.debugDataProviderNextPage(dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj);\n      }\n\n      return dpSelf.someDataProviderSvc.getNextPage(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n        var vmCollection = dpSelf.viewModelCollection;\n        vmCollection.setTotalObjectsFound(response.totalFound);\n\n        if (response.totalFound > 0) {\n          vmCollection.updateModelObjects(response.results, dpSelf.uidInResponse, dpSelf.preSelection);\n        }\n\n        _notifyModelObjectsUpdate(dataCtxNode, {\n          nextPage: true\n        });\n\n        if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n          _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n        }\n\n        if (dpSelf.accessMode === 'lov') {\n          // lov api expects incremental response, not the entire collection\n          return response;\n        }\n\n        return vmCollection;\n      });\n    }\n\n    return $q.resolve(dpSelf.viewModelCollection);\n  };\n  /**\n   * Validate selection\n   *\n   * @param {Object} lovScope - lov context\n   * @param {Array} selected - selected object/s to validate\n   * @param {Boolean} suggestion - does selected contain a suggested value?\n   *\n   * @return {Promise} Promise that is resolved upon completion of validateion.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.validateSelections = function (lovScope, selected, suggestion) {\n    var action = dpSelf.validateAction;\n\n    if (action) {\n      var actionRequestObj = {\n        selected: selected,\n        suggestion: suggestion\n      };\n      return dpSelf.someDataProviderSvc.validateSelections(action, dpSelf.json, lovScope, actionRequestObj).then(function (resp) {\n        if (!resp.valid) {\n          resp.cause = {\n            partialErrors: true\n          };\n          throw resp;\n        }\n\n        eventBus.publish(dpSelf.name + '.validSelectionEvent', {\n          selectedObjects: selected\n        });\n        return resp;\n      });\n    } // if validate action is not defined, assume all valid\n\n\n    eventBus.publish(dpSelf.name + '.validSelectionEvent', {\n      selectedObjects: selected\n    });\n    return AwPromiseService.instance.resolve({\n      valid: true\n    });\n  };\n  /**\n   * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n   *\n   * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n   * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any new nodes.\n   *\n   * @return {Promise} A promise resolved when the expansion is complete and the ViewModelCollection is\n   *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.expandObject = function (dataCtxNode, parentNode) {\n    var begNdx = -1;\n\n    if (dpSelf.cacheCollapse) {\n      var vmNodes = dpSelf.viewModelCollection.loadedVMObjects; // BMW: can use _, I am lazy now for prototype\n\n      for (var ndx = 0; ndx < vmNodes.length; ndx++) {\n        if (vmNodes[ndx].id === parentNode.id) {\n          begNdx = ndx + 1;\n          break;\n        }\n      }\n    } // BMW: Load __expendState if dpSelf.cacheCollapse == true\n\n\n    if (begNdx >= 0 && parentNode.__expandState && dpSelf.cacheCollapse) {\n      // Apply __expandState.expandedNodes to vmoCollection\n      var vmos = dpSelf.viewModelCollection.loadedVMObjects;\n      vmos.splice.apply(vmos, [begNdx, 0].concat(parentNode.__expandState.expandedNodes));\n      dpSelf.viewModelCollection.setTotalObjectsFound(vmos.length); // Load parentNode context back\n\n      parentNode.children = parentNode.__expandState.children;\n      parentNode.startChildNdx = parentNode.__expandState.startChildNdx;\n      parentNode.totalChildCount = parentNode.__expandState.totalChildCount;\n      parentNode.cursorObject = parentNode.__expandState.cursorObject; // Clean up and return\n\n      delete parentNode.__expandState;\n      return $q.resolve(dpSelf.viewModelCollection);\n    } // BMW: Clean up __expendState if dpSelf.cacheCollapse == false\n\n\n    if (!dpSelf.cacheCollapse && parentNode.__expandState) {\n      delete parentNode.__expandState;\n    }\n\n    return dpSelf.getTreeNodePage(dataCtxNode, parentNode, null, true, dpSelf.topTreeNode);\n  };\n\n  let _initialCacheCollapseState = false;\n  /**\n   *\n   * Function to restore collapse cache to the initial value\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n  dpSelf.restoreInitialCacheCollapseState = function () {\n    if (!_initialCacheCollapseState) {\n      dpSelf.cacheCollapse = false;\n      dpSelf.resetCollapseCache();\n    } else {\n      dpSelf.cacheCollapse = true;\n    }\n  };\n  /**\n   *\n   * Function to reset collapse cache when needed\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.resetCollapseCache = function () {\n    if (!dpSelf.viewModelCollection || !dpSelf.viewModelCollection.loadedVMObjects) {\n      return;\n    }\n\n    _.forEach(dpSelf.viewModelCollection.loadedVMObjects, function (vmo) {\n      if (vmo.__expandState) {\n        delete vmo.__expandState;\n      }\n    });\n  };\n  /**\n   * Set valid source types for data provider, this is used for drag and drop usage\n   *\n   * @param {Object} validSourceTypes - valid source types for dataprovider which are set from xrt objectset\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.setValidSourceTypes = function (validSourceTypes) {\n    dpSelf.validSourceTypes = validSourceTypes;\n  };\n  /**\n   * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n   *\n   * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n   * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any 'child' nodes being removed as\n   *            part of the collapse.\n   * @return {Promise} A promise resolved when the collapse is complete and the ViewModelCollection is\n   *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n   *         dataProvider.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.collapseObject = function (dataCtxNode, parentNode) {\n    /**\n     * Remove all 'child' nodes of this 'parent' from the 'loadedVMObjects' of the ViewModelCollection and\n     * reset it's internal 'children' array.\n     */\n    var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n    var begNdx = -1;\n    var nDelete = 0; // BMW Issue #5: add document to this algorithm.\n    // - Loop through the whole vmoCollection\n    // - When find the parent node, set state to start ( begNdx )\n    // - Keep going, when hits node which node.level <= parent.level, stop ( next sibling )\n    // - record all as nDelete.\n    //\n    // So we don't have to clen parentNode.children here...anyway it will be done later\n\n    for (var ndx = 0; ndx < vmNodes.length; ndx++) {\n      if (uwUtilSvc.getEvaluatedId(vmNodes[ndx]) === uwUtilSvc.getEvaluatedId(parentNode)) {\n        begNdx = ndx + 1;\n        nDelete = 0;\n      } else if (begNdx >= 0) {\n        if (vmNodes[ndx].levelNdx > parentNode.levelNdx) {\n          nDelete++;\n        } else {\n          // BMW Issue #5:\n          // parentNode.children = null;\n          break;\n        }\n      }\n    }\n\n    if (nDelete > 0) {\n      var collapsedNodes = vmNodes.splice(begNdx, nDelete); // BMW Issue #7: When any of the node is in loading status, don't cache\n\n      var collapesdNodesIsLoading = _.reduce(collapsedNodes, function (sum, node) {\n        return sum ? sum : node.loadingStatus;\n      }, false); // BMW: Cache collapse object here\n\n\n      if (dpSelf.cacheCollapse && !collapesdNodesIsLoading) {\n        parentNode.__expandState = {\n          children: parentNode.children,\n          startChildNdx: parentNode.startChildNdx,\n          totalChildCount: parentNode.totalChildCount,\n          // BMW #5: actually cursorObject cache here is not needed since\n          // it is anyway leaking in current system when collapse. But for\n          // safe we can cache and load it too.\n          cursorObject: parentNode.cursorObject,\n          expandedNodes: collapsedNodes\n        };\n      }\n\n      parentNode.children = null;\n      parentNode.startChildNdx = 0;\n      parentNode.totalChildCount = null;\n    } // Re-evaluate selection state, since we have removed children selection state have changed.\n\n\n    dpSelf.selectionModel.evaluateSelectionStatusSummary(dpSelf);\n    return $q.resolve(dpSelf.viewModelCollection);\n  }; // collapseObject\n\n  /**\n   * Access a page of 'child' nodes of the given 'parent' node and place the results into the\n   * ViewModelColection of this UwDataProvider.\n   * <P>\n   * Note: Paging information stored in the 'parent' node is used to determine which 'child' nodes to get.\n   * This paging information is then updated to be ready for any subsequent call to this API.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   *\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @param {ViewModelTreeNode} rootNode - Root Node opened\n   *\n   * @param {Boolean} focusLoadAction - (Optional) TRUE if action is triggered to load selected object in tree\n   *\n   * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNodePage = function (dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode, focusLoadAction) {\n    var action = addAfter ? dpSelf.nextAction || dpSelf.action : dpSelf.previousAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput,\n      loadIDs: {\n        t_uid: dpSelf.topTreeNode.uid,\n        o_uid: treeLoadInput.parentNode.uid\n      }\n    }; // focusLoadAction will be true when object present in selection model needs to be loaded in tree.\n    // (cross select between PWA and other sources e.g. Search Panel)\n\n    if (focusLoadAction) {\n      action = dpSelf.focusAction ? dpSelf.focusAction : null;\n      treeLoadInput.focusLoadAction = focusLoadAction;\n    }\n\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    var origCursorObj = _.clone(treeLoadInput.parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * Access the initial page of data.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   *\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   *\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   *\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @param {ViewModelTreeNode} rootNode - Root Node opened\n   *\n   * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNodeInitial = function (dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode) {\n    var action = dpSelf.initializeAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n\n    var origCursorObj = _.clone(treeLoadInput.parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * Access a page of 'child' nodes of the given 'parent' node (starting at a specific 'child' node) and place\n   * the results into the ViewModelColection of this UwDataProvider.\n   *\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n   * @param {String} startChildId - ID of a node in the 'parent' to start loading at.\n   * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n   *            ViewModelCollection) to insert any new nodes after.\n   * @param {Number} pageSize - Maximum number of 'child' nodes to return (including the 'startChild').\n   * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n   *            'cursorNodeId' (Default: TRUE)\n   *\n   * @return {Promise} A promise object resolved with a reference to the updated ViewModelColection object.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getTreeNode = function (dataCtxNode, parentNode, startChildId, cursorNodeId, pageSize, addAfter) {\n    var action = addAfter ? dpSelf.nextAction : dpSelf.previousAction;\n    assert(action, 'Invalid action specified');\n    /**\n     * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n     * the given 'parent'.\n     */\n\n    var inputData = _determineInput(parentNode, cursorNodeId, addAfter);\n\n    var treeLoadInput = awTableSvc.createTreeLoadInput(inputData.parentNode, inputData.startChildNdx, startChildId, cursorNodeId, pageSize, addAfter);\n    var actionRequestObj = {\n      treeLoadInput: treeLoadInput\n    };\n    dataCtxNode.data.treeLoadInput = treeLoadInput;\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    var origCursorObj = _.clone(parentNode.cursorObject);\n\n    return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (responseObj) {\n      return _processLoadTreeNodePageResponse(treeLoadInput, responseObj, dataCtxNode, origCursorObj);\n    });\n  };\n  /**\n   * @param {Object} dataCtxNode - The data context the access is occurring within.\n   * @param {PropertyLoadInput} propertyLoadInput - The object containing the PropertyLoadRequest(s) to\n   *            process.\n   *\n   * @return {Promise} The Promise is resolved with a PropertyLoadResult object when the operation is\n   *         complete.\n   *\n   * @memberof module:js/dataProviderFactory~UwDataProvider\n   */\n\n\n  dpSelf.getProperties = function (dataCtxNode, propertyLoadInput) {\n    assert(dpSelf.action, 'Invalid action specified');\n    var actionRequestObj = {\n      propertyLoadInput: propertyLoadInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n    return dpSelf.someDataProviderSvc.executeLoadAction(dpSelf.action, dpSelf.json, dataCtxNode, actionRequestObj).then(function (response) {\n      return response.propertyLoadResult;\n    });\n  };\n\n  dpSelf.getFilterFacets = function (viewModel, filterFacetInput) {\n    var action = dpSelf.filterFacetAction;\n    var dataCtxNode = {\n      data: viewModel,\n      filterFacetInput: filterFacetInput\n    };\n    updateDataCtxNodeWithProps(dataCtxNode);\n\n    if (action) {\n      return dpSelf.someDataProviderSvc.executeLoadAction(action, dpSelf.json, dataCtxNode).then(function (response) {\n        return response.filterFacetResults;\n      });\n    }\n\n    return $q.resolve();\n  };\n  /**\n   * Free up all resources held by this object.\n   * <P>\n   * Note: After this function, no API call should be considered valid. This function is intended to be called\n   * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event),\n   * any objects managed by this class may be considered a 'memory leak'.\n   */\n\n\n  dpSelf.destroy = function () {\n    dpSelf._isDestroyed = true;\n    declModelRegistrySvc.unregisterModel('UwDataProvider', dpSelf, 'name', '_modelId');\n\n    if (dpSelf._appCtxEditInProgress) {\n      appCtxService.unRegisterCtx(dpSelf._appCtxEditInProgress);\n    }\n\n    if (dpSelf.selectionModel) {\n      dpSelf.detachSelectionModel();\n      dpSelf.selectionModel = null;\n    }\n\n    if (dpSelf.viewModelCollection) {\n      dpSelf.viewModelCollection.destroy();\n      dpSelf.viewModelCollection = null;\n    }\n\n    if (dpSelf.someDataProviderSvc && dpSelf.someDataProviderSvc.destroy) {\n      dpSelf.someDataProviderSvc.destroy();\n      dpSelf.someDataProviderSvc = null;\n    }\n\n    if (dpSelf.json.editContext && _editHandlerRegistered) {\n      editHandlerSvc.removeEditHandler(dpSelf.json.editContext);\n    }\n\n    const editConfig = dpSelf.json.editConfig;\n\n    if (editConfig) {\n      editUtilsService._removeListeners(editConfig.sourceModel);\n    }\n\n    dpSelf.cols = null;\n    dpSelf.topTreeNode = null;\n    dpSelf.actionObj = null;\n    dpSelf.json = null;\n    dpSelf.ttState = null;\n    dpSelf.policy = null;\n    dpSelf.validSourceTypes = null;\n    eventBus.unsubscribe(dpSelf.toggleDecoratorsEvent);\n    eventBus.unsubscribe(dpSelf.multiSelectModeEvent);\n    eventBus.unsubscribe(dpSelf.selectActionEvent);\n    dpSelf.toggleDecoratorsEvent = null;\n    dpSelf.multiSelectModeEvent = null;\n    dpSelf.selectActionEvent = null;\n    dpSelf.setRootReference(null); // detach dispatcher\n\n    dpSelf.vmCollectionDispatcher = null;\n    dpSelf.pageDispatcher = null;\n    dpSelf.selectionModel = null;\n    referenceElement = null;\n    selectionModelDispatcher = null;\n    dpSelf = null;\n  }; // destroy\n\n  /**\n   * ---------------------------------------------------------------------------<BR>\n   * Property & Function definition complete....Finish initialization. <BR>\n   * ---------------------------------------------------------------------------<BR>\n   */\n\n\n  declModelRegistrySvc.registerModel('UwDataProvider', dpSelf, 'name', '_modelId');\n  /**\n   * Load localized text for when we encounter cases of no results and loading .\n   *\n   * @param localTextBundle\n   */\n\n  localeSvc.getTextPromise().then(function (localTextBundle) {\n    if (dpSelf) {\n      if (declUtils.isNil(dpSelf.isLoading)) {\n        dpSelf.isLoading = localTextBundle.LOADING_TEXT;\n      }\n    }\n  });\n\n  if (actionObj) {\n    dpSelf.action = actionObj;\n  }\n\n  _.forEach(actionMap, function (actionDef, actionName) {\n    dpSelf[actionName] = actionDef;\n  });\n\n  if (dataProviderJson) {\n    dpSelf.json = dataProviderJson;\n    dpSelf.policy = dataProviderJson.policy;\n    /** tree page size */\n\n    if (dataProviderJson.treePageSize) {\n      dpSelf.treePageSize = dataProviderJson.treePageSize;\n    }\n    /** Row or Cell selection scope ? */\n\n\n    if (dataProviderJson.selectionModelScope) {\n      dpSelf.selectionModel.scope = dataProviderJson.selectionModelScope;\n    }\n    /**\n     * Only set the default text values if they are not already set in the dataProvider JSON definition.\n     */\n\n\n    if (dataProviderJson.noResultsFound) {\n      dpSelf.noResultsFound = dataProviderJson.noResultsFound;\n    }\n\n    if (dataProviderJson.isLoading) {\n      dpSelf.isLoading = dataProviderJson.isLoading;\n    }\n\n    if (dataProviderJson.cacheCollapse) {\n      _initialCacheCollapseState = dataProviderJson.cacheCollapse;\n      dpSelf.cacheCollapse = _initialCacheCollapseState;\n    }\n  }\n  /**\n   * Get the editable object from the data provider\n   *\n   * In case of list, it sends the selected object.<BR>\n   * In case of Table, it send the all the loaded objects.\n   *\n   * @return {object} viewModelObject - View model object(s).\n   */\n\n\n  dpSelf.getEditableObjects = function () {\n    if (dataProviderJson && dataProviderJson.editContext) {\n      if (dataProviderJson.editContext === 'LIST_CELL_CONTEXT') {\n        if (dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single') {\n          return dpSelf.getSelectedObjects();\n        }\n      } else {\n        var vmc = dpSelf.viewModelCollection;\n        return vmc.getLoadedViewModelObjects();\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Get a list of property names form the dataprovider\n   *\n   * @return {Array} propNames - list of property Names\n   */\n\n\n  dpSelf.getPropertyNames = function () {\n    var propNames = [];\n\n    if (dataProviderJson.editContext === 'LIST_CELL_CONTEXT') {\n      if (dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single') {\n        var selectedObject = dpSelf.getSelectedObjects();\n\n        if (selectedObject !== null) {\n          _.forEach(selectedObject, function (viewModelObject) {\n            _.forEach(viewModelObject.props, function (props) {\n              if (props && props.type) {\n                propNames.push(props.propertyName);\n              }\n            });\n          });\n        }\n      }\n    } else {\n      if (dpSelf.cols) {\n        _.forEach(dpSelf.cols, function (col) {\n          if (col && col.typeName && !col.isTreeNavigation) {\n            propNames.push(col.propertyName);\n          }\n        });\n      }\n    }\n\n    return propNames;\n  };\n  /**\n   * Gets the edit configuration object\n   * @return {Object} The edit configuration object\n   */\n\n\n  dpSelf.getEditConfiguration = function () {\n    return dpSelf.json.editConfig;\n  };\n  /**\n   * Get the command override anchors set in viewModel.\n   *\n   * @return {Object} All possible override anchor strings\n   */\n\n\n  dpSelf.getCommandOverrides = function () {\n    return {\n      gridMenuCommandsAnchor: dpSelf.json.gridMenuCommandsAnchor,\n      contextMenuCommandsAnchor: dpSelf.json.contextMenuCommandsAnchor,\n      columnMenuCommandsAnchor: dpSelf.json.columnMenuCommandsAnchor\n    };\n  };\n}; // UwDataProvider\n\n/**\n * ---------------------------------------------------------------------------<BR>\n * Define the public API for the 'dataProviderFactory' Service<BR>\n * ---------------------------------------------------------------------------<BR>\n */\n\n\n_c = UwDataProvider;\nvar exports = {};\n/**\n * Create a new DeclDataProvider object to manage and access List, LOV, flat-table and tree-table structured\n * ViewModelObjects.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {StringMap} actionsMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n *\n * @return {UwDataProvider} The newly created DeclDataProvider object.\n *\n * @memberof module:js/dataProviderFactory\n */\n\nexport let createDataProvider = function (dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, actionsMap) {\n  var viewModelCollection = viewModelCollectionFactory.createViewModelCollection(dataProviderName);\n  return new UwDataProvider(AwPromiseService.instance, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc, viewModelCollection, actionsMap);\n};\n/**\n * Using the given UID, determine which IModelObject should be set as the 'top' node (if any). That object\n * will be set as a new 'top' ViewModelTreeNode on the given dataProvider.\n * <P>\n * Note: The 'top' node is generally hidden from the user and is used only to access 'child' nodes and other\n * properties.\n *\n * @param {String} topNodeUid - (Optional) The ID of the 'top' (if known)\n *\n * @return {ViewModelTreeNode} The new 'top' node.\n */\n\nfunction _determineTopTreeNode(topNodeUid) {\n  /**\n   * Create a 'straw' top node to use just in case.\n   */\n  var topTreeNode = {\n    nodeId: 'top',\n    nodeType: 'rootType',\n    displayName: 'top',\n    levelNdx: -1,\n    childNdx: 0\n  };\n\n  if (!_.isEmpty(topNodeUid)) {\n    topTreeNode.nodeId = topNodeUid;\n    topTreeNode.nodeType = 'unknown';\n  }\n\n  return awTableSvc.createViewModelTreeNode(topTreeNode.nodeId, topTreeNode.nodeType, topTreeNode.displayName, topTreeNode.levelNdx, topTreeNode.childNdx, null);\n} // _determineTopTreeNode\n\n\nlet initPreferredChoices = [];\nexport const loadAction = async (dataProvider, dataCtxNode, vmCollection, startIndex, pageObject) => {\n  // revisitme Subhajit: To keep the backward compatibility.. we need to work on declDataCtxService\n  dataProvider.startIndex = startIndex;\n  let pageActionType = pageObject.pageActionType; // tree - for pagination needs improvement\n\n  if (dataProvider.accessMode === 'tree') {\n    let results;\n\n    switch (pageActionType) {\n      case 'NEXT_PAGE':\n        results = await dataProvider.getNextPage(dataCtxNode);\n        break;\n\n      case 'PREVIOUS_PAGE':\n        results = await dataProvider.getPreviousPage(dataCtxNode);\n        break;\n\n      case 'PAGE_RESET':\n        dataProvider.topTreeNode = _determineTopTreeNode(dataProvider.topNodeUid);\n        results = await dataProvider.getTreeNodeInitial(dataCtxNode, dataProvider.topTreeNode, null, true, dataProvider.topTreeNode); //PAGE_RESET - This means the dataprovider is re-initialized\n        //Clear the previous data in vmCollection before updating the new data\n\n        dataProvider.viewModelCollection.clear();\n        break;\n\n      case 'FOCUS_PAGE':\n        var focusLoadAction = true;\n        dataProvider.topTreeNode = _determineTopTreeNode(dataProvider.topNodeUid);\n        results = await dataProvider.getTreeNodePage(dataCtxNode, dataProvider.topTreeNode, null, true, dataProvider.topTreeNode, focusLoadAction);\n        break;\n    } //Verify if the component is still mounted\n\n\n    if (!dataProvider.vmCollectionDispatcher) {\n      return;\n    } // totalFound and hasMoreValuesExist are mutually exclusive keys.\n\n\n    dataProvider.vmCollectionDispatcher({\n      type: 'COLLECTION_UPDATE',\n      viewModelObjects: results.loadedVMObjects,\n      totalFound: results.totalFound,\n      cursorObject: dataProvider.topTreeNode.cursorObject,\n      pageObject: pageObject\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'FOCUSING',\n      focusing: false\n    });\n\n    if (pageActionType === 'FOCUS_PAGE') {\n      dataProvider.syncSelectionModel(dataCtxNode);\n    }\n  } else {\n    let action;\n\n    switch (pageActionType) {\n      case 'PAGE_RESET':\n        dataProvider.startIndex = 0;\n        action = dataProvider.initializeAction ? dataProvider.initializeAction : dataProvider.action;\n        break;\n\n      case 'NEXT_PAGE':\n        action = dataProvider.nextAction ? dataProvider.nextAction : dataProvider.action;\n        break;\n\n      case 'PREVIOUS_PAGE':\n        action = dataProvider.previousAction ? dataProvider.previousAction : dataProvider.action;\n        break;\n\n      case 'FOCUS_PAGE':\n        dataProvider.startIndex = 0;\n        dataProvider.vmCollectionDispatcher({\n          type: 'COLLECTION_RESET'\n        });\n        action = dataProvider.focusAction ? dataProvider.focusAction : null;\n        break;\n    }\n\n    let listLoadInput = awTableSvc.createListLoadInput(null, dataProvider.startIndex, null, true);\n    let actionRequestObj = {\n      listLoadInput\n    };\n    const response = await dataProvider.someDataProviderSvc.executeLoadAction(action, dataProvider.json, dataCtxNode, actionRequestObj); //Verify if the component is still mounted\n\n    if (!dataProvider.vmCollectionDispatcher) {\n      return;\n    }\n\n    let viewModelObjects = vmCollection.createModelObjects(response.results || []);\n\n    if (pageActionType === 'NEXT_PAGE') {\n      viewModelObjects = vmCollection.getLoadedViewModelObjects().concat(viewModelObjects);\n    } else if (pageActionType === 'PREVIOUS_PAGE') {\n      viewModelObjects = viewModelObjects.concat(vmCollection.getLoadedViewModelObjects());\n    } else if (pageActionType === 'PAGE_RESET') {\n      // PAGE_RESET - This means the dataprovider is re-initialized\n      // retrieve preferred vals if defined\n      if (dataProvider.preferredChoicesAction) {\n        const preferredChoiceResp = await dataProvider.someDataProviderSvc.executeLoadAction(dataProvider.preferredChoicesAction, dataProvider.json, dataCtxNode);\n        initPreferredChoices = preferredChoiceResp.actionResultObj.responseObj.preferredChoices;\n      } // Clear the previous data in vmCollection before updating the new data\n\n\n      if (response.hasOwnProperty('lovUsage')) {\n        dataProvider.lovUsage = response.lovUsage;\n      }\n\n      if (response) {\n        dataProvider.viewModelCollection.clear();\n      }\n\n      if (response.totalFound > 0 && response.results) {\n        dataProvider.noResults = false;\n      } else {\n        dataProvider.noResults = true; // assigning no result found string if there is no data from rest service\n\n        if (dataProvider.json.noResultsFound) {\n          var i18nkey = dataProvider.json.noResultsFound;\n          i18nkey = parsingUtils.geti18nKey(i18nkey);\n          dataProvider.noResultsFound = dataCtxNode.data.i18n[i18nkey];\n        }\n      }\n    } // totalFound and hasMoreValuesExist are mutually exclusive keys.\n\n\n    let totalFound = response.hasOwnProperty('moreValuesExist') ? -1 : response.totalFound;\n    let hasMoreValuesExist = response.hasOwnProperty('moreValuesExist') ? response.moreValuesExist : null; // set preferred vals if defined\n\n    if (dataProvider.preferredChoicesAction) {\n      response.preferredChoices = initPreferredChoices;\n    }\n\n    dataProvider.vmCollectionDispatcher({\n      type: 'COLLECTION_UPDATE',\n      viewModelObjects: viewModelObjects,\n      totalFound,\n      hasMoreValuesExist,\n      cursorObject: dataProvider.cursorObject,\n      pageObject: pageObject,\n      preferredChoices: response.preferredChoices\n    });\n    dataProvider.vmCollectionDispatcher({\n      type: 'IN_PROGRESS',\n      fetching: false\n    });\n    dataProvider.notifyModelObjectsUpdate();\n    /**\n     * Determine if the last node in the collection is an 'incompleteTail' because we know\n     * there are more found than currently loaded.\n     */\n\n    if (!_.isEmpty(vmCollection.loadedVMObjects) && vmCollection.totalFound > dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded()) {\n      _.last(vmCollection.loadedVMObjects).incompleteTail = true;\n    }\n    /**\n     * Determine if the first node in the collection is an 'incompleteHead'\n     */\n\n\n    if (!_.isEmpty(vmCollection.loadedVMObjects) && dataProvider.cursorObject && dataProvider.cursorObject.startReached === false) {\n      _.head(vmCollection.loadedVMObjects).incompleteHead = true;\n    }\n  }\n\n  if (pageActionType === 'FOCUS_PAGE') {\n    //  revisitme Shaishav: In old focus action following variables were getting set.\n    //  We might need them when TC tables are supported.\n    //  Keeping is commented to not lose track of them\n    // if( response.totalFound > 0 && response.results ) {\n    //     dpSelf.noResults = false;\n    //     vmCollection.updateModelObjects( response.results,\n    //         dpSelf.uidInResponse, dpSelf.preSelection );\n    // } else {\n    //     dpSelf.noResults = true;\n    // }\n    eventBus.publish(dataProvider.name + '.focusSelection');\n  }\n};\n/**\n *\n * @param {*} param0\n * @param {*} dataProvider\n * @param {*} dataCtxNode\n */\n\nexport const validateLovAction = (_ref3, dataProvider, dataCtxNode) => {\n  let {\n    lovEntries,\n    vmo,\n    viewModelProp\n  } = _ref3;\n  return dataProvider.validateLOV({\n    lovEntries,\n    vmo,\n    viewModelProp\n  }, dataCtxNode);\n};\n/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {UwDataProvider} The DeclDataProvider from the given arguments (or undefined if not found)\n */\n\nexport let findDataProvider = function (argsIn) {\n  for (var ndx = 0; ndx < argsIn.length; ndx++) {\n    var arg = argsIn[ndx];\n\n    if (exports.isDataProvider(arg)) {\n      return arg;\n    }\n  }\n\n  return undefined;\n};\n/**\n * Test if the given object 'is-a' UwDataProvider created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a DeclDataProvider.\n */\n\nexport let isDataProvider = function (objectToTest) {\n  return objectToTest instanceof UwDataProvider;\n};\n/**\n * Select all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\n\nexport let selectAll = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.selectAll();\n  }\n};\n/**\n * Deselect all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\n\nexport let selectNone = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.selectNone();\n  }\n};\n/**\n * Enable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\n\nexport let dataProviderEnableMultiSelect = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.enableMultiSelect();\n  }\n};\n/**\n * Disable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\n\nexport let dataProviderDisableMultiSelect = function (dataProvider) {\n  if (dataProvider) {\n    dataProvider.disableMultiSelect();\n  }\n};\n\nfunction loadDebugOption() {\n  var urlAttrs = browserUtils.getUrlAttributes();\n  _debug_logTreeLoadActivity = urlAttrs.logTreeLoadActivity !== undefined;\n}\n/**\n * createDynamicDataProvider based on jsonData specified by src\\propertyrender\\lovDataProvider.json\n * @param {int} index - the index to return\n * @return {Object} dataProvider the dataProvider\n */\n\n\nexport let createDynamicDataProvider = function () {\n  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let dataProviders = [];\n\n  let _processAction = (jsonData, jsonDataProvider, dpName, actionName, actionMap) => {\n    var actionRef = jsonDataProvider[actionName];\n\n    if (actionRef && jsonData.actions) {\n      actionMap[actionName] = jsonData.actions[actionRef];\n    }\n  };\n\n  if (jsonData.dataProviders) {\n    var dataProvidersClone = _.cloneDeep(jsonData.dataProviders);\n\n    _.forEach(dataProvidersClone, function (jsonDataProvider, dpName) {\n      var actionMap = {};\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'action', actionMap); // legacy init/getNext action\n\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'initializeAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'nextAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'previousAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'focusAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'expandAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'validateAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'filterFacetAction', actionMap);\n\n      _processAction(jsonData, jsonDataProvider, dpName, 'preferredChoicesAction', actionMap);\n\n      let dataProviderInstance = createDataProvider(jsonDataProvider, actionMap.action, dpName, declDataProviderSvc, actionMap);\n      dataProviderInstance.dynamicDp = true;\n      dataProviderInstance.debugId = Math.floor(Math.random() * 100);\n      dataProviders.push(dataProviderInstance);\n    });\n  }\n\n  return dataProviders[index];\n};\nexports = {\n  createDataProvider,\n  createDynamicDataProvider,\n  findDataProvider,\n  isDataProvider,\n  loadAction,\n  selectAll,\n  selectNone,\n  dataProviderEnableMultiSelect,\n  dataProviderDisableMultiSelect,\n  validateLovAction\n};\nexport default exports;\nloadDebugOption();\n\nvar _c;\n\n$RefreshReg$(_c, \"UwDataProvider\");","map":{"version":3,"names":["AwPromiseService","viewModelCollectionFactory","localeSvc","editHandlerSvc","uwUtilSvc","dataSourceService","dataCtxService","declModelRegistrySvc","editUtilsService","appCtxService","assert","_","declUtils","eventBus","logger","arrayUtils","browserUtils","parsingUtils","debugService","awTableStateSvc","awTableSvc","editHandlerFactory","declDataProviderSvc","cfgSvc","jsonData","getCfgCached","Debug","trace","_modifiablePropertiesViaInputData","_debug_logTreeLoadActivity","UwDataProvider","$q","dataProviderJson","actionObj","dataProviderName","someDataProviderSvc","viewModelCollection","actionMap","dpSelf","_ctorInputData","inputData","paginationOption","filterStr","propsCallback","selectionModelDispatcher","lovEntryRef","referenceElement","_isDestroyed","noResultsFound","isLoading","cacheCollapse","name","startIndex","action","focusAction","json","policy","noResults","sortCriteria","filterMap","topTreeNode","selectedObjects","_editHandlerRegistered","updateDataCtxNodeWithProps","dataCtxNode","props","getProps","toggleDecoratorsEvent","subscribe","eventData","showDecorators","toggleState","saveRowExpanded","node","isExpanded","declViewModel","findViewModel","grids","Object","keys","gridid","_notifyModelObjectsUpdate","syncSelectionModel","viewModelObjects","getLoadedViewModelObjects","publish","notifyModelObjectsUpdate","_insertModelObjects","vmCollection","cursorId","vmosToInsert","addAfter","cursorNdx","findViewModelObjectById","cursorNode","getViewModelObject","loadedVMOs","info","totalFound","totalObjectsLoaded","length","levelNdx","childNdxOffset","childNdx","ndx1","insertNdx","ndx3","insert","ndx2","insertBefore","_findChildNdx","parentNode","cursorNodeId","nChild","children","ndx","id","_processLoadTreeNodePageResponse","treeLoadInput","responseObj","origCursorObj","treeLoadResult","resultParentNode","response","loadedVMObjects","isParentRoot","isEmpty","childNodes","origParentNdx","getEvaluatedId","getTotalObjectsFound","newTopNode","moreAboveFirst","moreBelowLast","totalChildCount","expectantParentNode","nRootPaths","rootPathNodes","usedPathParent","resultTopNode","last","uid","topNodeUid","isNil","newParent","clone","cursorChildNdx","insertionChildNdx","cursorObject","startOccUid","startReached","first","incompleteHead","startChildNdx","incompleteTail","endIndex","endOccUid","endReached","retainTreeExpansionStates","isFocusedLoad","vmNodesInTreeHierarchyLevels","newNodes","prevParentNode","parent","push","nextLevelNdx","child","$$treeLevel","currentlyLoadedRootPathNodeVMO","startLevelIndex","numberOfLevelsToBeInserted","mergeNewNodesInCurrentlyLoadedTree","filter","vmo","nextLevelInsert","vmNodes","nextLevelParentNode","getViewModelCollectionInTreeHierarchyFormat","nonRootPathHierarchicalData","getViewModelCollectionInTreeHierarchyFormatForTopDown","insertionNode","prevPage","nextPage","expandParent","emptyChildNodes","finalVMOs","lvlNdx","numberOfLevelsInserted","indx","indexOf","vmNodeInTreeHierarchyLevel","finalVMOIndex","finalVMO","splice","isLeaf","index","currentNodes","vmoIndex","levelIndex","currentNode","forEach","parentUid","assign","_determineInput","parentLevelNdx","currRow","_reportAccessToZombieDataProvider","functionName","warn","toString","_modelId","_internal","modelId","getSelectedObjects","selectionModel","loadedVMO","vmCollectionObj","preferredChoices","getSortedSelection","getSelectedIndices","map","getSelectedIndexes","changeObjectsSelection","start","end","select","e","s","objects","slice","multiSelectEnabled","addToSelection","setSelection","removeFromSelection","toggleSelection","multiSelectModeEvent","multiSelect","enableMultiSelect","disableMultiSelect","_selectionModelDataCtxNode","selectActionEvent","oldSelection","getSelection","selectAll","selectNone","deselect","newSelection","setMultiSelectionEnabled","setSelectionEnabled","isSelectionEnabled","selected","isSelected","prevSelectedObjects","emitEvents","isEqual","selectionData","update","source","validSourceTypes","eventObj","selectedUids","scope","dataProvider","shouldEmitSelectionEvent","newlySelected","x","newlySelectedObject","pageDispatcher","type","vmCollectionDispatcher","focusing","uidSet","Set","obj","add","isSharedSelectionModel","size","getCurrentSelectedCount","evaluateSelectionStatusSummary","detachSelectionModel","syncSelectionEvent","swapSelectionModel","newSelectionModel","attachSelectionModel","_notifyEditStateChange","stateName","_editingState","_editing","updateCtx","_appCtxEditInProgress","_eventTopicEditInProgress","isDirty","_isDirty","isPropEditEnabled","enablePropEdit","evaluationEnv","data","ctx","conditions","conditionStates","evaluateCondition","startEdit","editOptions","editConfig","sourceModel","saveEditStateChangeCallback","_startEdit","then","cancelEdits","_cancelEdits","saveEdits","_saveEdits","editInProgress","setFilterString","filterVal","getFilterString","initialize","promise","applyScope","value","editContext","reusableEditHandler","getEditHandler","setEditHandler","createEditHandler","createNewDataSource","editSupportParamKeys","setActiveEditHandlerContext","Promise","resolve","resetDataProvider","$on","event","setDataUpdater","setSelectionModel","selectionDispatcher","setRootReference","ref","setPropsCallback","getRootReference","setLovEntryRef","getLovEntryRef","setPagination","pageOption","getPagination","fetching","validateLOV","lovEntries","viewModelProp","validateAction","validateLOVSelection","valid","newVMOs","updatedVMOs","totalFoundIn","isUndefined","clear","setTotalObjectsFound","accessMode","updateModelObjects","uidInResponse","preSelection","getTotalUniqueObjectsLoaded","getItemAtIndex","getTotalObjectsLoaded","getNextPage","getViewModelCollection","getLength","getVirtualLength","hasMorePages","hasMorePagesUp","findIncompleteNodeInRange","startIdx","endIdx","i","vmNode","getPreviousPage","reject","previousAction","getTreeNodePage","listLoadInput","createListLoadInput","actionRequestObj","executeLoadAction","results","totalUniqueLoaded","nextAction","isDeclarativeLogEnabled","debugDataProviderNextPage","validateSelections","lovScope","suggestion","resp","cause","partialErrors","instance","expandObject","begNdx","__expandState","vmos","apply","concat","expandedNodes","_initialCacheCollapseState","restoreInitialCacheCollapseState","resetCollapseCache","setValidSourceTypes","collapseObject","nDelete","collapsedNodes","collapesdNodesIsLoading","reduce","sum","loadingStatus","rootNode","focusLoadAction","createTreeLoadInput","treePageSize","loadIDs","t_uid","o_uid","getTreeNodeInitial","initializeAction","getTreeNode","startChildId","pageSize","getProperties","propertyLoadInput","propertyLoadResult","getFilterFacets","viewModel","filterFacetInput","filterFacetAction","filterFacetResults","destroy","unregisterModel","unRegisterCtx","removeEditHandler","_removeListeners","cols","ttState","unsubscribe","registerModel","getTextPromise","localTextBundle","LOADING_TEXT","actionDef","actionName","selectionModelScope","getEditableObjects","mode","vmc","getPropertyNames","propNames","selectedObject","viewModelObject","propertyName","col","typeName","isTreeNavigation","getEditConfiguration","getCommandOverrides","gridMenuCommandsAnchor","contextMenuCommandsAnchor","columnMenuCommandsAnchor","exports","createDataProvider","actionsMap","createViewModelCollection","_determineTopTreeNode","nodeId","nodeType","displayName","createViewModelTreeNode","initPreferredChoices","loadAction","pageObject","pageActionType","createModelObjects","preferredChoicesAction","preferredChoiceResp","actionResultObj","hasOwnProperty","lovUsage","i18nkey","geti18nKey","i18n","hasMoreValuesExist","moreValuesExist","head","validateLovAction","findDataProvider","argsIn","arg","isDataProvider","undefined","objectToTest","dataProviderEnableMultiSelect","dataProviderDisableMultiSelect","loadDebugOption","urlAttrs","getUrlAttributes","logTreeLoadActivity","createDynamicDataProvider","dataProviders","_processAction","jsonDataProvider","dpName","actionRef","actions","dataProvidersClone","cloneDeep","dataProviderInstance","dynamicDp","debugId","Math","floor","random"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/dataProviderFactory.js"],"sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable max-lines */\n// Copyright (c) 2021 Siemens\n\n/**\n * Data provider factory\n *\n * @module js/dataProviderFactory\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport viewModelCollectionFactory from 'js/viewModelCollectionFactory';\nimport localeSvc from 'js/localeService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport uwUtilSvc from 'js/uwUtilService';\nimport dataSourceService from 'js/dataSourceService';\nimport dataCtxService from 'js/declarativeDataCtxService';\nimport declModelRegistrySvc from 'js/declModelRegistryService';\nimport editUtilsService from 'js/editUtilsService';\nimport appCtxService from 'js/appCtxService';\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport declUtils from 'js/declUtils';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport arrayUtils from 'js/arrayUtils';\nimport browserUtils from 'js/browserUtils';\nimport parsingUtils from 'js/parsingUtils';\nimport debugService from 'js/debugService';\nimport awTableStateSvc from 'js/awTableStateService';\nimport awTableSvc from 'js/awTableService';\nimport editHandlerFactory from 'js/editHandlerFactory';\nimport declDataProviderSvc from 'js/declDataProviderService';\nimport cfgSvc from 'js/configurationService';\nconst jsonData = cfgSvc.getCfgCached( 'lovDataProvider' );\nimport Debug from 'debug';\n\nconst trace = new Debug( 'selection' );\n\n/**\n * {StringArray} Collection of valid properties in the 'inputData' property of dataProvider's JSON definition.\n */\nvar _modifiablePropertiesViaInputData = [ 'selectionModel', 'accessMode', 'topNodeUid', 'editSupportParamKeys' ];\n\n/**\n * {Boolean} TRUE if tree node insertion details should be logged.\n */\nvar _debug_logTreeLoadActivity = false;\n\n/**\n * Constructs an object that wraps access to a 'viewModelCollection' created by the\n * 'viewModelCollectionFactory'.\n *\n * @class UwDataProvider\n *\n * @param {QueueService} $q - Queue service to use.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {ViewModelCollection} viewModelCollection - The 'viewModelCollection' used to hold all\n *            ViewModelObjects managed by this DataProvider.\n *\n * @param {StringMap} actionMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n */\nvar UwDataProvider = function( $q, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n    viewModelCollection, actionMap ) {\n    var dpSelf = this; // eslint-disable-line consistent-this\n\n    /**\n     * Data that is passed into the data provider constructor from outside of the view model.\n     */\n    var _ctorInputData = dataProviderJson ? dataProviderJson.inputData : null;\n\n    /**\n     *  This private variable would contain the pagination options and non-modifibale from outside.\n     */\n    let paginationOption = null;\n    /**\n     *  The filter string to be used in getFirstPage/getNextPage APi's\n     */\n    let filterStr = null;\n\n    let propsCallback = null;\n\n    /**\n     *  selectionModelDispatcher : Dispatcher to update the selection Model on the fly.\n     */\n    let selectionModelDispatcher;\n\n    /**\n     *\n     */\n    let lovEntryRef = null;\n\n    /**\n     *  This private variable would contain the reference of the top level referenceElement of list/table/ user defined widget\n     *  using data-provider\n     */\n    let referenceElement = null;\n    /**\n     * {Boolean} TRUE if 'destroy' has been invoked on this instance.\n     */\n    dpSelf._isDestroyed = false;\n\n    /**\n     * @property {String} noResultsFound - Localized message stating 'No results found'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.noResultsFound = null;\n\n    /**\n     * @property {String} isLoading - Localized message stating 'loading'.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.isLoading = null;\n\n    /**\n     * @property {Boolean} cacheCollapse - cache collapse infomation to reuse in next expand.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.cacheCollapse = false;\n\n    /**\n     * @property {Object} someDataProviderSvc - Some API object where 'getFirstPage', 'getNextPage', et al.\n     *           methods are implemented (e.g. 'js/declDataProviderService').\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.someDataProviderSvc = someDataProviderSvc;\n\n    /**\n     * @property {String} name - name of data provider object\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.name = dataProviderName;\n\n    /**\n     * @property {ViewModelCollection} viewModelCollection - viewModelCollection which maintains the loaded\n     *           ViewModelObjects and also have APIs to access the information of collection.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.viewModelCollection = viewModelCollection;\n\n    /**\n     * @property {Number} startIndex - Start/Next index into a virtual list.\n     *           <P>\n     *           Note: This property is accessed by some declViewModel bindings and 'glue' code. While it is\n     *           somewhat analogous to the data in the newer 'cursorObject', it is necessary to keep it exposed\n     *           for support of these earlier uses of it.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.startIndex = 0;\n\n    /**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.action = null;\n\n    /**\n     * @property {DeclAction} action - The 'declAction' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.focusAction = null;\n\n    /**\n     * @property {DeclDataProviderJson} json - The 'UwDataProvider' JSON object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.json = null;\n\n    /**\n     * @property {Object} policy - The Currently set property policy object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.policy = null;\n\n    /**\n     * @property {Object} selectionModel - Object which maintains all the selection objects stuff and provides\n     *           APIs to access information.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    // dpSelf.selectionModel = selectionModelFactory\n    //     .buildSelectionModel( dataProviderJson ? dataProviderJson.selectionModelMode : null );\n\n    /**\n     * @property {Boolean} noResults - Flag decides whether to show no results message if there are no values\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.noResults = false;\n\n    /**\n     * @property {ObjectArray} sortCriteria - Array of ordered sort criteria objects.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.sortCriteria = [];\n\n    /**\n     * @property {Object} filiterMap - A map (string, list of SearchFilter) containing the list of search\n     *           filters for each search filter field. The key in the map is the property name that represents\n     *           the filter category. It is in the format \"TypeName.PropertyName\". e.g\n     *           WorkspaceObject.object_type\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.filterMap = {};\n\n    /**\n     * @property {ViewModelTreeNode} The ViewModelTReeNode which is the logical (but unseen) 'top' node in any\n     *           hierarchy being managed by this UwDataProvider\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.topTreeNode = null;\n\n    /**\n     * Selected objects\n     */\n    dpSelf.selectedObjects = [];\n\n    /**\n     * {Boolean} TRUE if any editHandler associated with this UwDataProvider has been registered.\n     */\n    var _editHandlerRegistered;\n\n    const updateDataCtxNodeWithProps = function( dataCtxNode ) {\n        if( propsCallback ) {\n            dataCtxNode.props = propsCallback();\n            dataCtxNode.getProps = propsCallback;\n        }\n    };\n\n    // Toggle the display of Cell Decorators.\n    dpSelf.toggleDecoratorsEvent = eventBus.subscribe( dpSelf.name + '.toggleCellDecorators', function(\n        eventData ) {\n        if( eventData ) {\n            dpSelf.showDecorators = eventData.toggleState;\n        } else {\n            if( dpSelf.showDecorators ) {\n                dpSelf.showDecorators = false;\n            } else {\n                dpSelf.showDecorators = true;\n            }\n        }\n    } );\n\n    const saveRowExpanded = function( dataCtxNode, node ) {\n        if( node.isExpanded === true ) {\n            var declViewModel = declUtils.findViewModel( dataCtxNode );\n            var grids = declViewModel.grids;\n            awTableStateSvc.saveRowExpanded( declViewModel, grids[Object.keys( grids )[0]].gridid, node );\n        }\n    };\n\n    /**\n     * Fire modelObjects updated event using data provider name space\n     *\n     * @param {Object} dataCtxNode - The 'scope' to use.\n     * @param {Object} eventData - Event data containing data to include in notify.\n     */\n    var _notifyModelObjectsUpdate = function( dataCtxNode, eventData ) {\n        if( dataCtxNode ) {\n            dpSelf.syncSelectionModel( dataCtxNode );\n        }\n\n        eventData = eventData || {};\n\n        // Set standard data\n        eventData.viewModelObjects = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        eventData.noResults = dpSelf.noResults;\n\n        // Publish event\n        eventBus.publish( dpSelf.name + '.modelObjectsUpdated', eventData );\n    };\n\n    dpSelf.notifyModelObjectsUpdate = _notifyModelObjectsUpdate;\n\n    /**\n     * Insert the given array of ViewModelObjects into the given viewModelCollection starting after the given\n     * 'cursor' ViewModelObject ID.\n     *\n     * @param {ViewModelCollection} vmCollection - The ViewModelCollection to update.\n     * @param {String} cursorId - ID of the object The ViewModelObject in the collection to insert after.\n     * @param {ViewModelObjectArray} vmosToInsert - The ViewModelObjects to insert.\n     * @param {Boolean} addAfter - TRUE if any new children should be added AFTER the optional 'cursorNodeId'\n     *            (Default: TRUE)\n     */\n    function _insertModelObjects( vmCollection, cursorId, vmosToInsert, addAfter ) {\n        var cursorNdx = vmCollection.findViewModelObjectById( cursorId );\n\n        var cursorNode = cursorNdx === -1 ? null : vmCollection.getViewModelObject( cursorNdx );\n\n        var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n\n        if( _debug_logTreeLoadActivity ) {\n            logger.info( '_insertModelObjects: ' + '\\n' + //\n                'n1stLevelFound : ' + vmCollection.totalFound + '\\n' + //\n                'n1stLevelLoaded: ' + vmCollection.totalObjectsLoaded + '\\n' + //\n                'nLoadedOverall : ' + loadedVMOs.length + '\\n' + //\n                'cursorId       : ' + cursorId + '\\n' + //\n                'nVMOsToInsert  : ' + vmosToInsert.length + '\\n' + //\n                'addAfter       : ' + addAfter + '\\n' + //\n                'cursorNdx      : ' + cursorNdx + '\\n' + //\n                'cursorNode     : ' + cursorNode );\n        }\n\n        /**\n         * Check if we found where to insert and it is NOT the top level node.\n         * <P>\n         * Note: This function purposefully does not maintain the 'totalObjectsLoaded' for the overall\n         * viewModelCollection since that value only makes sense for the 'top' node.\n         */\n        if( cursorNode && cursorNode.levelNdx !== -1 ) {\n            var childNdxOffset;\n\n            if( addAfter ) {\n                /**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */\n                if( cursorNode.levelNdx === vmosToInsert[ 0 ].levelNdx ) {\n                    childNdxOffset = loadedVMOs[ cursorNdx ].childNdx + 1;\n\n                    for( var ndx1 = 0; ndx1 < vmosToInsert.length; ndx1++ ) {\n                        vmosToInsert[ ndx1 ].childNdx = childNdxOffset + ndx1;\n                    }\n                }\n\n                /**\n                 * AW-49335 - Jumping to target does not work when page is refreshed...\n                 * <P>\n                 * Check if the 'cursor' node has any children<br>\n                 * If so: We need to account for them before we insert\n                 * <P>\n                 * Note: We look forward until we find a node at the same (or 'above') level.\n                 */\n                var insertNdx = cursorNdx;\n\n                for( var ndx3 = cursorNdx + 1; ndx3 < loadedVMOs.length; ndx3++ ) {\n                    if( loadedVMOs[ ndx3 ].levelNdx <= cursorNode.levelNdx ) {\n                        break;\n                    }\n\n                    insertNdx++;\n                }\n\n                arrayUtils.insert( loadedVMOs, insertNdx, vmosToInsert );\n            } else {\n                /**\n                 * Check if the VMOs being inserted are from the same level of the tree.<BR>\n                 * If so: Adjust the 'childNdx' of the new VMOs to relative to that of the 'cursor' node. This\n                 * property is helpful when debugging.\n                 */\n                if( cursorNode.levelNdx === vmosToInsert[ 0 ].levelNdx ) {\n                    childNdxOffset = loadedVMOs[ cursorNdx ].childNdx - vmosToInsert.length;\n\n                    for( var ndx2 = 0; ndx2 < vmosToInsert.length; ndx2++ ) {\n                        vmosToInsert[ ndx2 ].childNdx = childNdxOffset + ndx2;\n                    }\n                }\n\n                /**\n                 * Insert just before the 'cursor' node.\n                 * <P>\n                 * Note: Even if the 'cursor' node is preceded by any children from an earlier 'sibling' (i.e. a\n                 * node at the same tree level) we do NOT need to account for them before we insert since the\n                 * 'cursor' position defines the correct break in the tree level.\n                 */\n                arrayUtils.insertBefore( loadedVMOs, cursorNdx, vmosToInsert );\n            }\n        }\n    } // _insertModelObjects\n\n    /**\n     * Locate the 'child' in the given 'parent' based on the 'child' node's ID.\n     *\n     * @param {ViewModelTreeNode} parentNode - The 'parent' who's 'children' to search.\n     * @param {String} cursorNodeId - The ID of the 'child' node to find.\n     * @returns {Number} Index to the 'child' node (or -1 if not found)\n     */\n    function _findChildNdx( parentNode, cursorNodeId ) {\n        var nChild = parentNode.children ? parentNode.children.length : 0;\n\n        if( cursorNodeId ) {\n            for( var ndx = 0; ndx < nChild; ndx++ ) {\n                if( parentNode.children[ ndx ].id === cursorNodeId ) {\n                    return ndx;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Insert the results into the ViewModelCollection array starting at the current location of the 'cursor'\n     * node.\n     *\n     * @param {TreeLoadInput} treeLoadInput - The original input parameters used to generate the response we are\n     *            processing now.\n     *\n     * @param {Object} responseObj - Object returned from the associated load 'action'\n     *\n     * @param {Object} dataCtxNode - Data context used for selection model sync.\n     *\n     * @param {Object} origCursorObj - The cursorObject of the 'parent' node BEFORE the load operation.\n     *\n     * @return {ViewModelCollection} A reference to the updated ViewModelCollection object.\n     */\n    function _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode, origCursorObj ) { // eslint-disable-line\n        assert( responseObj, 'Action did not return a ResponseResult Object' );\n\n        var treeLoadResult = responseObj.treeLoadResult;\n        let vmCollection = dpSelf.viewModelCollection;\n\n        assert( treeLoadResult, 'Action did not return a TreeLoadResult Object' );\n\n        /**\n         * Move the 'parent' and 'viewModelCollection' into handier variables.\n         */\n        var resultParentNode = treeLoadResult.parentNode;\n\n        let response = {\n            totalFound: vmCollection.totalFound,\n            loadedVMObjects: vmCollection.loadedVMObjects\n        };\n\n        /**\n         * Determine if we are working on the very top node of the tree.\n         */\n        var isParentRoot = resultParentNode && resultParentNode.levelNdx === -1;\n\n        /**\n         * Optionally log some useful information\n         */\n        if( _debug_logTreeLoadActivity && !_.isEmpty( treeLoadResult.childNodes ) ) {\n            logger.info( '_processLoadTreeNodePageResponse' + '\\n' + 'parentNode: ' + resultParentNode +\n                ' isParentRoot: ' + isParentRoot + '\\n' + '# children returned: ' +\n                treeLoadResult.childNodes.length );\n        }\n\n        /**\n         * AW-47271 - bash_PI1712-2 : Can Not expand Sub Assembly in tree View in a spcific scenario\n         * <P>\n         * Find the original 'parent' node in the vmCollection and see if it is still expanded.\n         * <P>\n         * Note: If we are working on the 'root', skip this check since the 'root' cannot actually be collapsed.\n         */\n        if( !isParentRoot ) {\n            /**\n             * Check if NOT expanded<BR>\n             * If so: No need to continue. Return current vmCollection unchanged.\n             * <P>\n             * Note: The 'parent' node returned from the async processing can sometimes be a clone made during\n             * processing. It is best to go back to the original to be sure we do not miss the latest state.\n             */\n            var origParentNdx = vmCollection.findViewModelObjectById( uwUtilSvc.getEvaluatedId( resultParentNode ) );\n            if( origParentNdx === -1 || !vmCollection.getViewModelObject( origParentNdx ).isExpanded ) {\n                if( _debug_logTreeLoadActivity ) {\n                    logger\n                        .info( '_processLoadTreeNodePageResponse: Skipping insertion of child nodes into collapsed or missing parent' +\n                            '\\n' + 'parent: ' + resultParentNode + '\\n' + 'index: ' + origParentNdx );\n                }\n\n                return {\n                    totalFound: vmCollection.getTotalObjectsFound(),\n                    loadedVMObjects: vmCollection.getLoadedViewModelObjects()\n                };\n            }\n        }\n\n        /**\n         * Check if we actually have results to insert.\n         */\n        var newTopNode;\n        var moreAboveFirst;\n        var moreBelowLast;\n\n        if( treeLoadResult.totalChildCount > 0 && !_.isEmpty( treeLoadResult.childNodes ) ) {\n            /**\n             * If this is the 'top' level node we now know IT is NOT empty.\n             */\n            if( isParentRoot ) {\n                dpSelf.noResults = false;\n            }\n\n            var expectantParentNode = resultParentNode;\n\n            /**\n             * Get the effective 'parent' node from the paths (if necessary)\n             */\n            var nRootPaths = _.isEmpty( treeLoadResult.rootPathNodes ) ? 0 :\n                treeLoadResult.rootPathNodes.length;\n\n            var usedPathParent;\n\n            if( nRootPaths > 0 ) {\n                /**\n                 * Get the 'top' node based on the path but do not override the current 'expectantParentNode'\n                 * unless it refers to a different object.\n                 */\n                var resultTopNode = _.last( treeLoadResult.rootPathNodes );\n\n                if( resultParentNode.uid !== resultTopNode.uid ) {\n                    expectantParentNode = resultTopNode;\n                    usedPathParent = true;\n                }\n            }\n\n            /**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */\n            newTopNode = treeLoadResult.newTopNode;\n\n            if( newTopNode && newTopNode.levelNdx === -1 ) {\n                dpSelf.topTreeNode = newTopNode;\n                dpSelf.topTreeNode.children = null;\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n\n                if( !usedPathParent ) {\n                    resultParentNode = treeLoadResult.newTopNode;\n                }\n            }\n\n            /**\n             * Determine if we are inserting before or after the 'start' or 'cursor' node.\n             */\n            var addAfter = declUtils.isNil( treeLoadInput.addAfter ) ? true : treeLoadInput.addAfter;\n\n            /**\n             * Check for the trivial case of 1st-time children\n             * <P>\n             * Note: We do a shallow clone to make sure it is not the same array as the result.\n             */\n            var newParent = _.isEmpty( expectantParentNode.children );\n\n            if( newParent ) {\n                expectantParentNode.children = _.clone( treeLoadResult.childNodes );\n            } else {\n                /**\n                 * Insert the new 'child' nodes into the 'children' array property of the 'parent' node.\n                 * <P>\n                 * Try to use the 'cursor' node to locate exactly where in the 'parent' to insert the new\n                 * 'child' nodes.\n                 * <P>\n                 * If no 'cursor' then just trust the previous index as a 'best guess' (works in a downward list\n                 * scenario).\n                 * <P>\n                 * Note: We have to do this since some cases where the children were inserted out of order or\n                 * even had duplicates. Relocating the 'cursor' locks it in for at least 'this' thread pass.\n                 */\n                var cursorChildNdx = _findChildNdx( expectantParentNode, treeLoadResult.cursorNodeId );\n                var insertionChildNdx = cursorChildNdx;\n\n                if( addAfter ) {\n                    /**\n                     * Reset the 'start' info of the 'parent' node (Server bug? we should not have to do this)\n                     */\n                    if( origCursorObj ) {\n                        expectantParentNode.cursorObject.startIndex = origCursorObj.startIndex;\n                        expectantParentNode.cursorObject.startOccUid = origCursorObj.startOccUid;\n                        expectantParentNode.cursorObject.startReached = origCursorObj.startReached;\n                    }\n                    /**\n                     * First new 'child' node inserted AFTER another cannot be an 'incompleteHead'.\n                     */\n                    _.first( treeLoadResult.childNodes ).incompleteHead = false;\n\n                    /**\n                     * Insert new 'child' nodes into 'parent' AFTER cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteTail'.\n                     */\n                    if( insertionChildNdx === -1 ) {\n                        insertionChildNdx = treeLoadResult.startChildNdx;\n                    } else {\n                        expectantParentNode.children[ cursorChildNdx ].incompleteTail = false;\n\n                        insertionChildNdx++;\n                    }\n\n                    arrayUtils.insert( expectantParentNode.children, insertionChildNdx,\n                        treeLoadResult.childNodes );\n                } else {\n                    /**\n                     * Reset the 'end' info of the 'parent' node (Server bug? we should not have to do this)\n                     */\n                    if( origCursorObj ) {\n                        expectantParentNode.cursorObject.endIndex = origCursorObj.endIndex;\n                        expectantParentNode.cursorObject.endOccUid = origCursorObj.endOccUid;\n                        expectantParentNode.cursorObject.endReached = origCursorObj.endReached;\n                    }\n                    /**\n                     * Last new 'child' node inserted BEFORE another cannot be an 'incompleteTail'\n                     */\n                    _.last( treeLoadResult.childNodes ).incompleteTail = false;\n\n                    /**\n                     * Insert new 'child' nodes into 'parent' BEFORE cursor 'child' node.\n                     * <P>\n                     * Note: Original cursor 'child' can no longer be an 'incompleteHead'.\n                     */\n                    if( insertionChildNdx === -1 ) {\n                        insertionChildNdx = treeLoadResult.startChildNdx;\n                    } else {\n                        expectantParentNode.children[ cursorChildNdx ].incompleteHead = false;\n                    }\n\n                    arrayUtils.insertBefore( expectantParentNode.children, insertionChildNdx,\n                        treeLoadResult.childNodes );\n                }\n            }\n\n            /**\n             * Fire a 'resetState' event, sourced to this uwDataProvider, for all tree-table 'focused load'\n             * cases.\n             */\n            if( !treeLoadResult.retainTreeExpansionStates ) {\n                if( isParentRoot && treeLoadResult.isFocusedLoad ) {\n                    eventBus.publish( dpSelf.name + '.resetState', {} );\n                }\n            }\n\n            /**\n             * Check if we were given a non-trivial path to a root (the new 'child' nodes are to be added to the\n             * bottom of).\n             */\n            if( nRootPaths > 1 && newParent ) {\n                dpSelf.topTreeNode = _.first( treeLoadResult.rootPathNodes );\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n                if( !treeLoadResult.vmNodesInTreeHierarchyLevels ) {\n                    var newNodes = [];\n\n                    var prevParentNode = treeLoadResult.rootPathNodes[ 0 ];\n\n                    for( var ndx = 1; ndx < treeLoadResult.rootPathNodes.length; ndx++ ) {\n                        var parent = treeLoadResult.rootPathNodes[ ndx ];\n\n                        newNodes.push( parent );\n\n                        prevParentNode.children = [ parent ];\n\n                        /**\n                         * If expansion states are cleared after 'resetState' event, tree hierarchy that we are\n                         * creating while building tree using rootPathNodes, those rootPathNodes should be saved in\n                         * expansion state as they are expanded.\n                         * <P>\n                         * This is required for tree refresh scenarios (the level the user is working on should get\n                         * restored after refresh)\n                         */\n                        saveRowExpanded( dataCtxNode, parent );\n\n                        prevParentNode = parent;\n                    }\n\n                    /**\n                     * Mark the children to be 1 level below the 'expectant' parent\n                     */\n                    var nextLevelNdx = _.last( treeLoadResult.rootPathNodes ).levelNdx + 1;\n\n                    for( var ndx2 = 0; ndx2 < treeLoadResult.childNodes.length; ndx2++ ) {\n                        var child = treeLoadResult.childNodes[ ndx2 ];\n\n                        child.levelNdx = nextLevelNdx;\n                        child.$$treeLevel = nextLevelNdx;\n\n                        newNodes.push( child );\n                    }\n\n                    /**\n                     * Put all the 'parent' path + 'child' nodes as the sole content of the collection\n                     */\n                    response.totalFound = treeLoadResult.rootPathNodes.length - 1 + treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = newNodes;\n                } else {\n                    var currentlyLoadedRootPathNodeVMO = null;\n                    var startLevelIndex = 0;\n                    var loadedVMOs = vmCollection.getLoadedViewModelObjects();\n                    var numberOfLevelsToBeInserted = 0;\n\n                    // Check if there is request to merge new ViewModelTreeNodes from TreeLoadResult into existing loaded VMOs.\n                    if( treeLoadResult.mergeNewNodesInCurrentlyLoadedTree && loadedVMOs ) {\n                        for( startLevelIndex = treeLoadResult.rootPathNodes.length; startLevelIndex >= 1; startLevelIndex-- ) {\n                            currentlyLoadedRootPathNodeVMO = loadedVMOs\n                                .filter( function( vmo ) {\n                                    return treeLoadResult.rootPathNodes[ startLevelIndex - 1 ] && vmo.id === treeLoadResult.rootPathNodes[ startLevelIndex - 1 ].id;\n                                } )[ 0 ];\n\n                            /**\n                             * currentlyLoadedRootPathNodeVMO is the parent node which is currently loaded in\n                             * VMO and its also present in response structure.\n                             */\n                            if( currentlyLoadedRootPathNodeVMO ) {\n                                numberOfLevelsToBeInserted++;\n                                currentlyLoadedRootPathNodeVMO.nextLevelInsert = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    /**\n                     * 1)vmNodesInTreeHierarchyLevels is an array of arrays. Each array index represents vmNodes\n                     * at given level (index 0 in array represents level -1 which is not displayed, index 1\n                     * level 0 and so on). Each level will have node where next level nodes need to be inserted.\n                     *\n                     * 2)rootPathNodes contain array of parents with one or more having children under it.\n                     *\n                     * 3)At each level, you will have parent below which next level is supposed to be inserted.\n                     */\n                    // Iterate through all levels\n                    for( ndx = startLevelIndex; ndx < treeLoadResult.vmNodesInTreeHierarchyLevels.length; ndx++ ) {\n                        var vmNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ ndx ];\n\n                        // Get parent node below which next level needs to be inserted.\n                        var nextLevelParentNode = vmNodes\n                            .filter( function( vmo ) {\n                                return treeLoadResult.rootPathNodes[ ndx ] && vmo.id === treeLoadResult.rootPathNodes[ ndx ].id;\n                            } )[ 0 ];\n\n                        if( nextLevelParentNode ) {\n                            nextLevelParentNode.nextLevelInsert = true;\n                            numberOfLevelsToBeInserted++;\n                        }\n                    }\n\n                    const viewModelObjects = getViewModelCollectionInTreeHierarchyFormat( treeLoadResult, vmCollection,\n                        currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode );\n                    response.loadedVMObjects = viewModelObjects;\n                    response.totalFound = viewModelObjects.length;\n                }\n            } else if( treeLoadResult.nonRootPathHierarchicalData ) {\n                /**\n                 * If we are given multiple expanded nodes which are all not necessarily on the \"rootPath\"\n                 */\n                const viewModelObjects = getViewModelCollectionInTreeHierarchyFormatForTopDown( treeLoadResult, vmCollection, dataCtxNode );\n                if( viewModelObjects ) {\n                    response.loadedVMObjects = viewModelObjects;\n                    response.totalFound = viewModelObjects.length;\n                }\n            } else {\n                /**\n                 * Check if we are processing the unseen 'root' node.<br>\n                 * If so: Just add the results as the only items in the collection.<BR>\n                 * If not: Insert the results in at the correct location.\n                 */\n                if( isParentRoot && treeLoadResult.startChildNdx === 0 ) {\n                    response.totalFound = treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = _.clone( treeLoadResult.childNodes );\n                } else {\n                    if( treeLoadResult.cursorNodeId ) {\n                        _insertModelObjects( vmCollection, treeLoadResult.cursorNodeId,\n                            treeLoadResult.childNodes, addAfter );\n                    } else {\n                        if( treeLoadResult.startChildNdx === 0 ) {\n                            _insertModelObjects( vmCollection, uwUtilSvc.getEvaluatedId( expectantParentNode ),\n                                treeLoadResult.childNodes, addAfter );\n                        } else {\n                            var insertionNode = expectantParentNode.children[ treeLoadResult.startChildNdx - 1 ];\n\n                            _insertModelObjects( vmCollection, uwUtilSvc.getEvaluatedId( insertionNode ), treeLoadResult.childNodes,\n                                addAfter );\n                        }\n                    }\n                }\n\n                /**\n                 * Update the totalNumber of known 'child' nodes.\n                 */\n                expectantParentNode.totalChildCount = treeLoadResult.totalChildCount;\n            }\n\n            /**\n             * Fire a 'modelObjectsUpdated' event, sourced to this uwDataProvider, but only for changes to the\n             * outer-most level. This event includes the entire ViewModelCollection. This event is required to\n             * have the aw-table controller know when to update the information in the GridWrapper.\n             */\n            if( isParentRoot ) {\n                var nChild = resultParentNode.children ? resultParentNode.children.length : 0;\n\n                moreAboveFirst = false;\n                moreBelowLast = false;\n\n                if( resultParentNode.cursorObject ) {\n                    moreAboveFirst = !resultParentNode.cursorObject.startReached;\n                    moreBelowLast = !resultParentNode.cursorObject.endReached;\n                } else {\n                    moreBelowLast = resultParentNode.totalChildCount > nChild;\n                }\n\n                _notifyModelObjectsUpdate( dataCtxNode, {\n                    prevPage: moreAboveFirst,\n                    nextPage: moreBelowLast\n                } );\n            } else {\n                dpSelf.syncSelectionModel( dataCtxNode );\n            }\n\n            /**\n             * Fire a 'treeNodesLoaded' event, sourced to this uwDataProvider, for all tree-table changes. This\n             * event includes only the input/result structures for the current load operation. This event is\n             * used to load additional properties in an async fashion.\n             */\n            eventBus.publish( dpSelf.name + '.treeNodesLoaded', {\n                treeLoadInput: treeLoadInput,\n                treeLoadResult: treeLoadResult\n            } );\n\n            /**\n             * Check if the response indicates we should make sure the parent is expanded.\n             */\n            if( treeLoadResult.expandParent ) {\n                eventBus.publish( dpSelf.name + '.expandTreeNode', {\n                    parentNode: resultParentNode\n                } );\n            }\n        } else if( isParentRoot ) {\n            /**\n             * If this is the 'top' level node we now know it IS empty.\n             */\n            dpSelf.noResults = true;\n\n            /**\n             * Check if the action has passed back a new 'top' (unseen) 'parent' node.\n             * <P>\n             * Note: It is a bad thing to change the 'top' node AFTER we have already been adding the previous\n             * 'top' children into the ViewModelCollection. Do not do this!\n             */\n            newTopNode = treeLoadResult.newTopNode;\n\n            if( newTopNode && newTopNode.levelNdx === -1 ) {\n                dpSelf.topTreeNode = newTopNode;\n                dpSelf.topTreeNode.children = null;\n\n                dpSelf.topNodeUid = dpSelf.topTreeNode.uid;\n            }\n\n            /**\n             * If empty child nodes are passed to provider, they should be honored and should get updated in UI.\n             */\n            if( treeLoadResult.startChildNdx === 0 ) {\n                /**\n                 * This change is when we delete a single row from the tree table\n                 */\n                moreAboveFirst = false;\n                moreBelowLast = false;\n                /**\n                 * Determine if this node is NOT an 'incompleteHead' or 'incompleteTail'\n                 */\n                if( resultParentNode.cursorObject ) {\n                    moreAboveFirst = !resultParentNode.cursorObject.startReached;\n                    moreBelowLast = !resultParentNode.cursorObject.endReached;\n                }\n\n                var emptyChildNodes = !moreAboveFirst && !moreBelowLast;\n\n                if( emptyChildNodes ) {\n                    response.totalFound = treeLoadResult.totalChildCount;\n                    response.loadedVMObjects = _.clone( treeLoadResult.childNodes );\n                    _notifyModelObjectsUpdate( dataCtxNode, {\n                        prevPage: moreAboveFirst,\n                        nextPage: moreBelowLast\n                    } );\n                }\n            }\n        }\n\n        return response;\n    }\n\n    /**\n     * @param {TreeLoadResult} treeLoadResult - Object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection - VMO array to set\n     * @param {ViewModelObject} currentlyLoadedRootPathNodeVMO - ...\n     * @param {Number} startLevelIndex -\n     * @param {Number} numberOfLevelsToBeInserted -\n     */\n    function getViewModelCollectionInTreeHierarchyFormat( treeLoadResult, vmCollection,\n        currentlyLoadedRootPathNodeVMO, startLevelIndex, numberOfLevelsToBeInserted, dataCtxNode ) {\n        var finalVMOs = [];\n        var lvlNdx = startLevelIndex;\n        var numberOfLevelsInserted = 0;\n        var indx = 0;\n\n        if( currentlyLoadedRootPathNodeVMO ) {\n            /**\n             * currentlyLoadedRootPathNodeVMO is populated. That means parentNode that has come in\n             * TreeLoadResult is already loaded in vmCollection. In that case , restore existing VMOs, merge new\n             * VMOs that we got in response in currently loaded VMOs.\n             */\n            arrayUtils.insert( finalVMOs, 0, vmCollection.getLoadedViewModelObjects() );\n            indx = finalVMOs.indexOf( currentlyLoadedRootPathNodeVMO );\n        } else {\n            // Build Final ViewModelTreeNodes array. Add zeroth level , iterate, check for next level insertion point,\n            // and add new level there.Keep building and iterating through whole list.\n            arrayUtils.insert( finalVMOs, 0, treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx++ ] );\n        }\n\n        while( indx < finalVMOs.length && numberOfLevelsInserted < numberOfLevelsToBeInserted ) {\n            var vmo = finalVMOs[ indx ];\n\n            if( vmo.nextLevelInsert ) {\n                vmo.isExpanded = true;\n\n                for( let vmNodeInTreeHierarchyLevel of treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx] ) {\n                    var finalVMOIndex = 0;\n                    for ( let finalVMO of finalVMOs ) {\n                        if ( finalVMO && finalVMO.id === vmNodeInTreeHierarchyLevel.id ) {\n                            finalVMOs.splice( finalVMOIndex, 1 );\n                        }\n                        finalVMOIndex++;\n                    }\n                }\n\n                arrayUtils.insert( finalVMOs, indx, treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx ] );\n\n                // Next level nodes should be stored as children under current level parent.\n                vmo.children = _.clone( treeLoadResult.vmNodesInTreeHierarchyLevels[ lvlNdx ] );\n                vmo.totalChildCount = vmo.children.length;\n                vmo.isLeaf = false;\n\n                // Store parent as expanded in state/local storage.\n                saveRowExpanded( dataCtxNode, vmo );\n                delete vmo.nextLevelInsert;\n                lvlNdx++;\n                numberOfLevelsInserted++;\n            }\n\n            indx++;\n        }\n\n        // filter out vmo with treeLevel -1 as we don't show topLevel Node.\n        finalVMOs = finalVMOs.filter( function( vmo ) {\n            return vmo.$$treeLevel !== -1;\n        } );\n        return finalVMOs;\n    }\n\n    /**\n     * @param {TreeLoadResult} treeLoadResult object containing result/status information.\n     * @param {ViewModelObjectArray} vmCollection VMO array to set\n     */\n    function getViewModelCollectionInTreeHierarchyFormatForTopDown( treeLoadResult, vmCollection, dataCtxNode ) {\n        let finalVMOs = [];\n\n        if( treeLoadResult.mergeNewNodesInCurrentlyLoadedTree ) {\n            finalVMOs = vmCollection.getLoadedViewModelObjects();\n        }\n\n        for( let index = 0; index < treeLoadResult.vmNodesInTreeHierarchyLevels.length; index++ ) {\n            let currentNodes = treeLoadResult.vmNodesInTreeHierarchyLevels[ index ];\n\n            for( let node = 0; node < currentNodes.length; node++ ) {\n                let vmoIndex = -1;\n                let levelIndex = 0;\n                let currentNode = currentNodes[ node ];\n                finalVMOs.forEach( ( vmo, index ) => {\n                    if( currentNode ) {\n                        if( vmo.id === currentNode.id ) {\n                            vmoIndex = index;\n                        }\n                        if( vmo.id === currentNode.parentUid ) {\n                            levelIndex = index;\n                        }\n                    }\n                } );\n\n                if( vmoIndex !== -1 ) {\n                    _.assign( finalVMOs[ vmoIndex ], currentNode );\n                } else {\n                    arrayUtils.insert( finalVMOs, levelIndex + node, [ currentNode ] );\n                }\n\n                saveRowExpanded( dataCtxNode, currentNode );\n            }\n        }\n\n        if( !treeLoadResult.mergeNewNodesInCurrentlyLoadedTree ) {\n            return finalVMOs;\n        }\n    }\n\n    /**\n     * @param {ViewModelTreeNode} parentNode - (Optional) The 'parent' to use when determining input.\n     *\n     * @param {String} cursorNodeId - (Optional) The ID of the node to insert above/below\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Object} The resolved input object to pass to 'createTreeLoadInput'.\n     */\n    function _determineInput( parentNode, cursorNodeId, addAfter ) {\n        /**\n         * Determine 'child' index to use as basis for loading.\n         *\n         * <pre>\n         * Handle various cases of 'parent' and/or 'cursorNodeId' validity:\n         * 1) 'parent' and 'cursorNodeId' valid:             Locate the 'cursorNodeId' in the 'parent' and use its index.\n         * 2) 'parent' valid and 'cursorNodeId' not valid:   Use either end of the 'parent' children as the index.\n         * 3) 'parent' NOT valid and the 'cursor' is valid:  Locate the 'parent' of the 'cursor' and use the 'cursor' index.\n         * 4) 'parent' NOT valid and the 'cursor' NOT valid: Fail assertion.\n         * Note: Case 3) is used when dynamically loading the next page of 'children' directly after/before the\n         * 'cursor' node.\n         * </pre>\n         */\n        var startChildNdx = -1;\n\n        if( parentNode ) {\n            if( cursorNodeId ) {\n                startChildNdx = _findChildNdx( parentNode, cursorNodeId );\n                if( startChildNdx !== -1 ) {\n                    startChildNdx++;\n                }\n            } else {\n                if( addAfter ) {\n                    var nChild = parentNode.children ? parentNode.children.length : 0;\n\n                    startChildNdx = nChild;\n                } else {\n                    startChildNdx = 0;\n                }\n            }\n        } else if( cursorNodeId ) {\n            var vmCollection = dpSelf.viewModelCollection;\n\n            var cursorNdx = vmCollection.findViewModelObjectById( cursorNodeId );\n\n            if( cursorNdx !== -1 ) {\n                var cursorNode = vmCollection.getViewModelObject( cursorNdx );\n\n                var parentLevelNdx = cursorNode.levelNdx - 1;\n\n                startChildNdx = 1;\n\n                for( var ndx = cursorNdx - 1; ndx >= 0; ndx-- ) {\n                    var currRow = vmCollection.getViewModelObject( ndx );\n\n                    if( currRow.levelNdx === parentLevelNdx ) {\n                        parentNode = currRow;\n                        //Locate the 'parent' of the 'cursor' and use the Parent 'cursor' index.\n                        if( parentNode.cursorObject && parentNode.cursorObject.endIndex ) {\n                            startChildNdx = parentNode.cursorObject.endIndex + 1;\n                        }\n                        break;\n                    }\n                    startChildNdx++;\n                }\n            }\n        }\n\n        assert( parentNode, 'Unable to determine \\'parent\\' node' );\n        assert( startChildNdx !== -1, 'Unable to determine location in \\'parent\\' to insert loaded \\'child\\' nodes' );\n\n        return {\n            parentNode: parentNode,\n            startChildNdx: startChildNdx\n        };\n    }\n\n    /**\n     * Log a warning that there was an access to this UwDataProvider after it was destroyed.\n     *\n     * @param {String} functionName - Name of the function being accessed.\n     */\n    function _reportAccessToZombieDataProvider( functionName ) {\n        logger.warn( 'Attempt to execute a function on a UwDataProvider after it was destroyed...' + '\\n' + //\n            'Function was therefore not executed...continuing.' + '\\n' + //\n            'UwDataProvider: ' + dpSelf.name + '\\n' + //\n            'Function: ' + functionName );\n    }\n\n    /**\n     * Override the default implementation to return more helpful information.\n     *\n     * @return {String} Text used to identify the ID of the UsDataProvider (e.g. 'modelId' + an optional\n     *         'name').\n     */\n    dpSelf.toString = function() {\n        if( dpSelf ) {\n            if( dpSelf.name ) {\n                return dpSelf._modelId + '  name: ' + dpSelf.name;\n            }\n\n            return dpSelf._internal.modelId + '  name: ' + '???';\n        }\n\n        return 'UwDataProvider (destroyed)';\n    };\n\n    /**\n     * Get all of the loaded objects that are currently selected.\n     *\n     * @return {IModelObjectArray} Array of selected {IModelObject}.\n     */\n    dpSelf.getSelectedObjects = function() {\n        if( dpSelf.selectionModel ) {\n            var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n            if( dpSelf.vmCollectionObj && dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0  ) {\n                loadedVMO = [ ...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices ];\n            }\n            return dpSelf.selectionModel.getSortedSelection( loadedVMO );\n        }\n        return [];\n    };\n\n    /**\n     * Get the indices of the selected objects.\n     *\n     * @returns {NumberArray} Resolved with the indicies of the selected objects in the ViewModelCollection.\n     */\n    dpSelf.getSelectedIndices = function() {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n\n        return dpSelf.getSelectedObjects().map( function( vmo ) {\n            return loadedVMO.indexOf( vmo );\n        } );\n    };\n\n    // Define with this 'incorrect' spelling as well.\n    dpSelf.getSelectedIndexes = dpSelf.getSelectedIndices;\n\n    /**\n     * Change the selection range\n     *\n     * @param {Number} start - String index in collection to add/remove/toggle.\n     * @param {Number} end -  Ending index in collection to add/remove/toggle.\n     * @param {Boolean} select - (Optional) TRUE, 'select'...FALSE, 'unselect'...UNDEFINED, 'toggle'.\n     */\n    dpSelf.changeObjectsSelection = function( start, end, select ) {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        // Going down : Going up\n        var e = start > end ? start : end;\n        var s = start > end ? end : start;\n\n        var objects = loadedVMO.slice( s, e + 1 );\n        if( select === true ) {\n            if( dpSelf.selectionModel.multiSelectEnabled || objects.length > 1 ) {\n                dpSelf.selectionModel.addToSelection( objects );\n            } else {\n                dpSelf.selectionModel.setSelection( objects );\n            }\n        } else if( select === false ) {\n            dpSelf.selectionModel.removeFromSelection( objects );\n        } else {\n            dpSelf.selectionModel.toggleSelection( objects );\n        }\n    };\n\n    // activates multi Select mode on selection Model = multiple.\n    dpSelf.multiSelectModeEvent = eventBus.subscribe( dpSelf.name + '.multiSelectModeAction', function(\n        eventData ) {\n        if( eventData && eventData.multiSelect ) {\n            dpSelf.enableMultiSelect();\n        } else {\n            dpSelf.disableMultiSelect();\n        }\n    } );\n\n    let _selectionModelDataCtxNode = null;\n\n    // Event to expose various selection APIs on the selection model.\n    dpSelf.selectActionEvent = eventBus.subscribe( dpSelf.name + '.selectAction', function(\n        eventData ) {\n        if( dpSelf.selectionModel ) {\n            const oldSelection = dpSelf.selectionModel.getSelection();\n            if( eventData ) {\n                if( eventData.selectAll === true ) {\n                    dpSelf.selectAll();\n                }\n\n                if( eventData.selectAll === false ) {\n                    dpSelf.selectNone();\n                }\n\n                if( eventData.select ) {\n                    dpSelf.selectionModel.addToSelection( eventData.select );\n                }\n\n                if( eventData.deselect ) {\n                    dpSelf.selectionModel.removeFromSelection( eventData.deselect );\n                }\n\n                if( eventData.setSelection ) {\n                    dpSelf.selectionModel.setSelection( eventData.setSelection );\n                }\n            }\n\n            const newSelection = dpSelf.selectionModel.getSelection();\n            dpSelf.syncSelectionModel( _selectionModelDataCtxNode, newSelection, oldSelection );\n        }\n    } );\n\n    /**\n     * Enable MultiSelect\n     */\n    dpSelf.enableMultiSelect = function() {\n        if( dpSelf.selectionModel ) {\n            dpSelf.selectionModel.setMultiSelectionEnabled( true );\n        }\n    };\n\n    /**\n     * disable MultiSelect\n     */\n    dpSelf.disableMultiSelect = function() {\n        if( dpSelf.selectionModel ) {\n            dpSelf.selectionModel.setMultiSelectionEnabled( false );\n            dpSelf.selectNone();\n        }\n    };\n\n    /**\n     * Select all loaded objects\n     */\n    dpSelf.selectAll = function() {\n        var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        dpSelf.selectionModel.addToSelection( loadedVMO );\n        eventBus.publish( dpSelf.name + '.selectAll', {} );\n    };\n\n    /**\n     * Clear selection\n     */\n    dpSelf.selectNone = function() {\n        dpSelf.selectionModel.setSelection( [] );\n        eventBus.publish( dpSelf.name + '.selectNone', {} );\n    };\n\n    dpSelf.setSelectionEnabled = function( isSelectionEnabled ) {\n        dpSelf.selectionModel.setSelectionEnabled( isSelectionEnabled );\n\n        eventBus.publish( dpSelf.name + '.isSelectionEnabledChanged', {\n            isSelectionEnabled: isSelectionEnabled\n        } );\n    };\n\n    /**\n     * Sync the view with the updated selection model.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {StringArray} newSelection -\n     * @param {StringArray} oldSelection -\n     */\n    dpSelf.syncSelectionModel = function( dataCtxNode, newSelection, oldSelection ) {\n        // Ensure the selection state is correct\n        //zarq9k: Once we sync up the old viewModel and new Collection, this line would not be required.\n        // issue reported - https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/56\n        // We never worked on it.\n        var loadedVMO = dpSelf.vmCollectionObj.vmCollection.getLoadedViewModelObjects();\n        //var loadedVMO = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        if( dpSelf.vmCollectionObj.preferredChoices && dpSelf.vmCollectionObj.preferredChoices.length > 0  ) {\n            loadedVMO = [ ...loadedVMO, ...dpSelf.vmCollectionObj.preferredChoices ];\n        }\n\n        loadedVMO.map( function( vmo ) {\n            vmo.selected = dpSelf.selectionModel.isSelected( vmo );\n        } );\n\n        // Put the selected objects on the data provider\n        // Makes binding in view models simpler\n        var prevSelectedObjects = dpSelf.selectedObjects;\n\n        dpSelf.selectedObjects = loadedVMO.filter( function( vmo ) {\n            return vmo.selected;\n        } );\n\n        var emitEvents = function() {\n            //This check ensures notification is triggered only if there a selection change\n            if( !_.isEqual( prevSelectedObjects, dpSelf.selectedObjects ) ) {\n                if( dpSelf.selectionModel && dpSelf.selectionModel.selectionData ) {\n                    dpSelf.selectionModel.selectionData.update( {\n                        selected: dpSelf.getSelectedObjects(),\n                        source: dpSelf.validSourceTypes,\n                        id: dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name,\n                        _modelId: dpSelf._modelId\n                    } );\n                    trace( 'Selection Changed for ', dpSelf.selectionModel.name ? dpSelf.selectionModel.name : dpSelf.name, dpSelf.selectedObjects );\n                }\n                let eventObj = {\n                    selectedObjects: dpSelf.getSelectedObjects(),\n                    selectedUids: dpSelf.selectionModel.getSelection(),\n                    scope: dataCtxNode,\n                    selectionModel: dpSelf.selectionModel,\n                    selected: dpSelf.getSelectedObjects(),\n                    dataProviderName: dpSelf.name,\n                    dataProvider: dpSelf\n                };\n                // Always notify through event bus\n                eventBus.publish( dpSelf.name + '.selectionChangeEvent', eventObj );\n            }\n        };\n\n        // Handle case where something is selected that is not in data provider\n        if( dpSelf.focusAction ) {\n            var shouldEmitSelectionEvent = true;\n\n            // Ignore the simple sync to mark objects as selected\n            if( newSelection && oldSelection ) {\n                var newlySelected = newSelection.filter( function( x ) {\n                    return oldSelection.indexOf( x ) === -1;\n                } );\n\n                // If a single new object was selected attempt to focus\n                if( newlySelected.length === 1 ) {\n                    // Try to get object from current list\n                    var newlySelectedObject = dpSelf.selectedObjects.filter( function( vmo ) {\n                        return prevSelectedObjects.indexOf( vmo ) === -1;\n                    } )[ 0 ];\n\n                    // If not found clear current list and focus\n                    if( !newlySelectedObject ) {\n                        shouldEmitSelectionEvent = false;\n\n                        // Reset cursor\n                        if( dpSelf.cursorObject ) {\n                            dpSelf.cursorObject = null;\n                        }\n\n                        dpSelf.pageDispatcher( { type: 'FOCUS_PAGE' } );\n                        dpSelf.vmCollectionDispatcher( { type: 'FOCUSING', focusing: true } );\n                    } else {\n                        eventBus.publish( dpSelf.name + '.focusSelection' );\n                    }\n                }\n            }\n\n            if( shouldEmitSelectionEvent ) {\n                emitEvents();\n            }\n        } else {\n            var uidSet = new Set();\n            _.forEach( dpSelf.selectedObjects, function( obj ) {\n                var uid;\n                if( typeof obj === 'object' ) {\n                    uid = obj.uid;\n                } else {\n                    uid = obj;\n                }\n                uidSet.add( uid );\n            } );\n\n            //If the selectionModel is shared, there is possibility that the selectionModel can have\n            //stale/invalid selection stored.\n            //Give precedence to dataprovider selection in case of shared selectionModel\n            const isSharedSelectionModel = _ctorInputData && _ctorInputData.selectionModel;\n            if( isSharedSelectionModel && uidSet.size !== dpSelf.selectionModel.getCurrentSelectedCount() ) {\n                // Default behavior is to remove any object not found from the selection model\n                dpSelf.selectionModel.setSelection( dpSelf.selectedObjects );\n            }\n            //Notify selection change in the same render cycle\n            emitEvents();\n        }\n\n        // Check selection state\n        dpSelf.selectionModel.evaluateSelectionStatusSummary( dpSelf );\n    };\n\n    /**\n     * Detach the selection model from the data provider. Should only be done when re-initializing.\n     */\n    dpSelf.detachSelectionModel = function() {\n        if( dpSelf.syncSelectionEvent ) {\n            dpSelf.syncSelectionEvent();\n            dpSelf.syncSelectionEvent = null;\n        }\n    };\n\n    /**\n     * Attach the data provider to its current selection model. Ensures re-initialization of the data provider\n     * will not result in duplicate event listeners / watches.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */\n    // dpSelf.attachSelectionModel = function( dataCtxNode ) {\n    //     // _selectionModelDataCtxNode = dataCtxNode;\n    //     // Remove previous watch if it is still setup\n    //     // dpSelf.detachSelectionModel();\n\n    //     // dpSelf.selectionModel.syncSelections = function( oldVal, newVal ) {\n    //     //     dpSelf.syncSelectionModel( dataCtxNode, newVal, oldVal );\n    //     // };\n    // };\n\n    /**\n     * Attach the selection model immediately. Will be detached / reattached if data provider is initialized.\n     * However cannot assume data provider is ever initialized.\n     */\n    //dpSelf.attachSelectionModel( {} );\n\n    /**\n     * Swap selection model with the new selection model provided as input. Detach current selection model and\n     * attach the new one\n     *\n     * @param {Object} newSelectionModel - new selection model which is required to swap\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     */\n    dpSelf.swapSelectionModel = function( newSelectionModel, dataCtxNode ) {\n        // Detach the selection model while initializing\n        dpSelf.detachSelectionModel();\n\n        dpSelf.selectionModel = newSelectionModel;\n\n        dpSelf.attachSelectionModel( dataCtxNode );\n    };\n\n    // ======================== Edit Handler Interface ===================================================//\n    /**\n     *\n     * @param {*} stateName current state of edit\n     * @param {*} dpSelf data provider instance\n     */\n    var _notifyEditStateChange = function( stateName, dpSelf ) {\n        dpSelf._editingState = stateName;\n        dpSelf._editing = stateName === 'starting';\n\n        // Add to the appCtx about the editing state\n        appCtxService.updateCtx( dpSelf._appCtxEditInProgress, dpSelf._editing );\n        eventBus.publish( dpSelf._eventTopicEditInProgress, dpSelf._editing );\n    };\n\n    if( !dpSelf._appCtxEditInProgress ) {\n        dpSelf._appCtxEditInProgress = dpSelf.name + '_editInProgress';\n        dpSelf._eventTopicEditInProgress = dpSelf.name + '.editInProgress';\n    }\n\n    /**\n     * isDirty implementation of edit-handler interface.\n     * It check if any of the view model property inside view model object is modified.\n     * @returns {*} AwPromiseService.instance with promise true/false        *\n     */\n    dpSelf.isDirty = function() {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        return editUtilsService._isDirty( viewModelCollection );\n    };\n    /**\n     * Determines if prop edit is enabled for this dataprovider\n     * @param {Object} declViewModel the declarative view model\n     * @returns {*} true if individual prop editing is enabled\n     */\n    dpSelf.isPropEditEnabled = function( declViewModel ) {\n        if( dpSelf.json && dpSelf.json.enablePropEdit ) {\n            // If boolean is used return it directly otherwise evaluate the value as a condition\n            if( typeof dpSelf.json.enablePropEdit === 'boolean' ) {\n                return dpSelf.json.enablePropEdit;\n            }\n\n            const evaluationEnv = {\n                data: declViewModel,\n                ctx: appCtxService.ctx,\n                conditions: declViewModel._internal.conditionStates\n            };\n            return declUtils.evaluateCondition( declViewModel, dpSelf.json.enablePropEdit, evaluationEnv );\n        } else if( dpSelf.json && dpSelf.json.enablePropEdit === false ) {\n            return false;\n        }\n        // Default is true if enablePropEdit is not defined\n        return true;\n    };\n\n    /**\n     * This function implements the start edit function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n     * @return {*} AwPromiseService.instance with promise.\n     */\n    dpSelf.startEdit = function( dataCtxNode, declViewModel, editOptions ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        editConfig.sourceModel = dpSelf.name;\n        const saveEditStateChangeCallback = function() {\n            _notifyEditStateChange( 'saved', dpSelf );\n        };\n        return editUtilsService._startEdit( dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback, editOptions ).then( function() {\n            if( !editOptions ) {\n                _notifyEditStateChange( 'starting', dpSelf );\n            }\n        } );\n    };\n\n    /**\n     * This is the cancel edits implementation of edit-handler interface.\n     * @param  {*} dataCtxNode data ctx Node.\n     * @param  {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise\n     */\n    dpSelf.cancelEdits = function( dataCtxNode, declViewModel ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        return editUtilsService._cancelEdits( dataCtxNode, declViewModel, viewModelCollection, editConfig ).then( function() {\n            _notifyEditStateChange( 'canceling', dpSelf );\n        } );\n    };\n\n    /**\n     * This function implements the save edits function edit handler interface\n     * @param {*} dataCtxNode data ctx Node.\n     * @param {*} declViewModel declarative ViewModel.\n     * @return {*} AwPromiseService.instance with promise.\n     */\n    dpSelf.saveEdits = function( dataCtxNode, declViewModel ) {\n        var viewModelCollection = dpSelf.viewModelCollection.getLoadedViewModelObjects();\n        var editConfig = dpSelf.json.editConfig;\n        return editUtilsService._saveEdits( dataCtxNode, declViewModel, viewModelCollection, editConfig ).then( function() {\n            _notifyEditStateChange( 'saved', dpSelf );\n        } );\n    };\n\n    /**\n     * @returns {*} boolean true/false\n     */\n    dpSelf.editInProgress = function() {\n        return dpSelf._editing;\n    };\n\n    dpSelf.setFilterString = ( filterVal ) => {\n        filterStr = filterVal;\n    };\n\n    dpSelf.getFilterString = () => {\n        return filterStr;\n    };\n\n    // ======================== End of Edit Handler Interface ===================================================//\n\n    /**\n     * Initialize and trigger first page of results.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @return {Promise} A promise object resolved with the ViewModelCollection returned by the current\n     *         DataProviderService.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.initialize = function( dataCtxNode ) {\n        var promise;\n\n        if( dpSelf.cursorObject ) {\n            dpSelf.cursorObject = null;\n        }\n\n        dpSelf.setFilterString( filterStr );\n\n        /**\n         * If the constructor was told there would be some additional input data passed in from the data ctx\n         * node attempt to get it at this point.\n         * <P>\n         * Note: The input data from the scope can only override specific properties.\n         */\n        if( !_.isEmpty( _ctorInputData ) ) {\n            var declViewModel = declUtils.findViewModel( dataCtxNode );\n            dataCtxService.applyScope( declViewModel, _ctorInputData, null, dataCtxNode );\n            _.forEach( _ctorInputData, function( value, name ) {\n                if( _modifiablePropertiesViaInputData.indexOf( name ) !== -1 ) {\n                    dpSelf[ name ] = value;\n                }\n            } );\n        }\n        /** editHandler */\n        if( dpSelf.json.editContext ) {\n            let reusableEditHandler = editHandlerSvc.getEditHandler( dpSelf.json.editContext );\n            // If editHandler already exists don't create a new one - which overwrites the old one\n            if( !reusableEditHandler ) {\n                editHandlerSvc.setEditHandler( editHandlerFactory.createEditHandler( dataSourceService\n                    .createNewDataSource( {\n                        dataProvider: dpSelf\n                    } ), dpSelf.editSupportParamKeys ), dpSelf.json.editContext );\n                // set this handler active\n                editHandlerSvc.setActiveEditHandlerContext( dpSelf.json.editContext );\n\n                _editHandlerRegistered = true;\n            }\n        }\n\n        promise = Promise.resolve( dpSelf.resetDataProvider() );\n\n        // Detach the selection model while initializing\n        // dpSelf.detachSelectionModel();\n\n        /** revisitme Shaishav: This should be dead code in future because we delegated this responsibility to dataProviderUtils js\n         *  Keeping the code for now to ensure we do not miss any functionality while migrating\n\n        if( dpSelf.accessMode === 'tree' ) {\n            dpSelf.topTreeNode = _determineTopTreeNode( dpSelf.topNodeUid );\n\n            promise = dpSelf.getTreeNodeInitial( dataCtxNode, dpSelf.topTreeNode, null, true,\n                dpSelf.topTreeNode ).then( function( response ) {\n                dpSelf.attachSelectionModel( dataCtxNode );\n\n                return response;\n            } );\n        } else {\n            dpSelf.startIndex = 0;\n\n            var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, false, dataCtxNode.filterStr );\n\n            var actionRequestObj = {\n                listLoadInput: listLoadInput\n            };\n\n            var action = dpSelf.initializeAction ? dpSelf.initializeAction : dpSelf.action;\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugDataProviderInitialize( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj, _ctorInputData );\n            }\n\n            promise = dpSelf.someDataProviderSvc.getFirstPage( action, dpSelf.json, dataCtxNode,\n                actionRequestObj ).then(\n                function( response ) {\n                    eventBus.publish( dpSelf.name + '.resetScroll', {} );\n                    var vmCollection = dpSelf.viewModelCollection;\n\n                    vmCollection.clear();\n                    vmCollection.setTotalObjectsFound( response.totalFound );\n\n                    if( response.totalFound > 0 && response.results ) {\n                        dpSelf.noResults = false;\n\n                        vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                            dpSelf.preSelection );\n\n                        /**\n                         * Determine if the last node in the collection is an 'incompleteTail' because we know\n                         * there are more found than currently loaded.\n                        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                            vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                        }\n                    } else {\n                        dpSelf.noResults = true;\n                        // assigning no result found string if there is no data from rest service\n                        if( dpSelf.json.noResultsFound ) {\n                            var i18nkey = dpSelf.json.noResultsFound;\n                            i18nkey = parsingUtils.geti18nKey( i18nkey );\n                            dpSelf.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                        }\n                    }\n\n                    // dpSelf.attachSelectionModel( dataCtxNode );\n\n                    _notifyModelObjectsUpdate( null, {\n                        firstPage: true\n                    } );\n\n                    return response;\n                },\n                function( err ) {\n                    logger.warn( err );\n                } );\n        }\n        */\n\n        // Attach selection model once first page is loaded\n        promise.then( function( response ) {\n            if( dpSelf.selectionModel && dpSelf.selectionModel.getSelection().length > 0 ) {\n                /**\n                 * Fire modelObjects updated event using data provider name space\n                 */\n                eventBus.publish( dpSelf.name + '.focusSelection' );\n            }\n\n            /**\n             * Note: Not all dataCtxNodes are actually AngularJS $scopes. So we have to check if the $scope API\n             * exists before we try to use it.\n             */\n            if( dataCtxNode.$on ) {\n                dataCtxNode.$on( 'dataProvider.selectAction', function( event, data ) {\n                    if( data && data.selectAll ) {\n                        dpSelf.selectAll();\n                    } else {\n                        dpSelf.selectNone();\n                    }\n                } );\n\n                dataCtxNode.$on( 'dataProvider.multiSelectAction', function( event, data ) {\n                    if( data && data.multiSelect ) {\n                        dpSelf.enableMultiSelect();\n                    } else {\n                        dpSelf.disableMultiSelect();\n                    }\n                } );\n            }\n\n            return response;\n        } );\n\n        return promise;\n    }; // initialize\n\n    dpSelf.setDataUpdater = ( pageDispatcher, vmCollectionDispatcher ) => {\n        dpSelf.pageDispatcher = pageDispatcher;\n        dpSelf.vmCollectionDispatcher = vmCollectionDispatcher;\n    };\n\n    dpSelf.setSelectionModel = ( { selectionModel, selectionDispatcher } ) => {\n        dpSelf.selectionModel = selectionModel;\n        selectionModelDispatcher = selectionDispatcher;\n    };\n\n    dpSelf.setRootReference = ( ref ) => {\n        referenceElement = ref;\n    };\n\n    dpSelf.setPropsCallback = ( getProps ) => {\n        propsCallback = getProps;\n    };\n\n    dpSelf.getRootReference = () => {\n        return referenceElement;\n    };\n\n    dpSelf.setLovEntryRef = ( ref ) => {\n        lovEntryRef = ref;\n    };\n\n    dpSelf.getLovEntryRef = () => {\n        return lovEntryRef;\n    };\n\n    dpSelf.setPagination = ( pageOption ) => {\n        if( !paginationOption ) {\n            paginationOption = pageOption;\n        }\n    };\n\n    dpSelf.getPagination = () => {\n        return paginationOption ? paginationOption : null;\n    };\n\n    dpSelf.resetDataProvider = () => {\n        dpSelf.vmCollectionDispatcher( { type: 'COLLECTION_RESET' } );\n        dpSelf.pageDispatcher( { type: 'PAGE_RESET' } );\n        dpSelf.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        // Spare the selection model reset, if it is shared one.\n        if( _ctorInputData && !_ctorInputData.selectionModel || !_ctorInputData ) {\n            dpSelf.selectNone();\n        }\n    };\n\n    /**\n     * validate the lovValueSections if it needs to call the \"validateLOVValueSelections\" soa\n     *\n     * @param {array} lovEntry - the lovEntry which is gotten from \"getinitialValues\" SOA and it's the selected\n     *            item\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Promise} A promise object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.validateLOV = function( { lovEntries, vmo, viewModelProp }, dataCtxNode ) {\n        try {\n            let action = dpSelf.validateAction;\n            return dpSelf.someDataProviderSvc.validateLOVSelection( { lovEntries, vmo, viewModelProp }, dataCtxNode, action, dpSelf.json );\n        } catch ( e ) {\n            //In Table, when user edits LOV manually and clicks outside, widget is destroyed and hence LOV dataprovider as well\n            //Due to this, if user clicks outside, dpSelf is coming as NULL and dpSelf.validateAction throws exception\n            // Because of this behavior, user is not able to save even valid values.\n            //To fix this we have to remove LOV validation outside\n            return Promise.resolve( { valid: true } );\n        }\n    };\n\n    /**\n     * Set the currently loaded view model objects based on the model object (or uid data) in the given array of\n     * 'result' objects.\n     *\n     * @param {ViewModelObjectArray} newVMOs - Array of ViewModelObjects to set.\n     * @param {Number} totalFound - total found\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.update = function( newVMOs, totalFound ) {\n        if( newVMOs ) {\n            let updatedVMOs = newVMOs;\n            //create a new reference only if there is an existing VMOs array to trigger update else use the same.\n            if( !newVMOs.objects ) {\n                updatedVMOs = [ ...newVMOs ];\n            }\n            let totalFoundIn = totalFound;\n\n            if( _.isUndefined( totalFoundIn ) ) {\n                totalFoundIn = updatedVMOs.length;\n            }\n\n            dpSelf.noResults = totalFoundIn === 0;\n\n            let vmCollection = dpSelf.viewModelCollection;\n\n            vmCollection.clear();\n            vmCollection.setTotalObjectsFound( totalFoundIn );\n\n            if( dpSelf.accessMode === 'tree' ) {\n                vmCollection.loadedVMObjects = updatedVMOs;\n            } else {\n                vmCollection.updateModelObjects( updatedVMOs, dpSelf.uidInResponse, dpSelf.preSelection );\n                /**\n                 * Determine if the last node in the collection is an 'incompleteTail' because we know there are\n                 * more found than currently loaded.\n                 */\n                if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                    vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                    _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                }\n\n                /**\n                 * Maintain selections based on the new VMOs.\n                 */\n                const selectedObjects = dpSelf.getSelectedObjects();\n\n                dpSelf.selectionModel.setSelection( selectedObjects );\n                _notifyModelObjectsUpdate();\n            }\n            dpSelf.vmCollectionDispatcher( {\n                type: 'COLLECTION_REPLACE',\n                viewModelObjects: vmCollection.loadedVMObjects,\n                totalFound: vmCollection.loadedVMObjects.length\n            } );\n        }\n    };\n\n    dpSelf.viewModelCollection.update = dpSelf.update;\n\n    /**\n     * Required. Get item at specified index\n     *\n     * @param {Number} index - index of the list\n     * @param {Object} dataCtxNode - The angular scope of this data provider\n     * @return {Object} object specified at the given index\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getItemAtIndex = function( index, dataCtxNode ) {\n        if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n            dpSelf.getNextPage( dataCtxNode );\n            return null;\n        }\n\n        return dpSelf.viewModelCollection.getViewModelObject( index );\n    };\n\n    /**\n     * Get ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @return {ViewModelCollection} Reference to the ViewModelCollection being managed by this UwDataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getViewModelCollection = function() {\n        return dpSelf.viewModelCollection;\n    };\n\n    // 20201010 Per tec meeting discussion, dataProvider should never have types, data parser has the role to process data source.\n    // /**\n    //  * return the same data structure of the list items in the link-with-popup window\n    //  * <P>\n    //  * Note: Used for aw-link-with-popup.directive<BR>\n    //  *\n    //  * @memberof module:js/dataProviderFactory~UwDataProvider\n    //  *\n    //  * @param {Number} index - index of the list\n    //  * @param {Object} dataCtxNode - The data context the queryy is occurring within.\n    //  * @param {String} dataProviderType - The types of dataProvider: \"static\" \"TcLOV\" \"Action\"\n    //  *\n    //  * @return {Object} The same data structure of the list items in the link-with-popup window.\n    //  */\n    // dpSelf.createPopupObject = function( index, dataCtxNode, dataProviderType ) {\n    //     if( index > dpSelf.viewModelCollection.getTotalObjectsLoaded() ) {\n    //         dpSelf.getNextPage( dataCtxNode );\n    //         return null;\n    //     }\n\n    //     var listElement = {\n    //         listElementDisplayValue: '',\n    //         listElementObject: ''\n    //     };\n\n    //     var displayValue;\n    //     var viewModelObject = dpSelf.getItemAtIndex( index, dataCtxNode );\n\n    //     if( !viewModelObject ) {\n    //         return listElement;\n    //     }\n\n    //     if( dataProviderType ) {\n    //         if( dataProviderType === 'TcLOV' ) {\n    //             displayValue = viewModelObject.propDisplayValue;\n    //         } else if( dataProviderType === 'Action' ) {\n    //             var displayStr;\n    //             if( dataCtxNode.displayProperty ) {\n    //                 displayStr = _.get( viewModelObject, dataCtxNode.displayProperty );\n    //             } else {\n    //                 displayStr = _.get( viewModelObject.props, 'object_string' );\n    //             }\n    //             displayValue = displayStr.uiValue;\n    //         } else if( dataProviderType === 'Static' ) {\n    //             if( viewModelObject.staticDisplayValue && viewModelObject.staticElementObject ) {\n    //                 displayValue = viewModelObject.staticDisplayValue;\n    //                 viewModelObject = viewModelObject.staticElementObject;\n    //             } else {\n    //                 displayValue = viewModelObject;\n    //             }\n    //         } else {\n    //             displayValue = viewModelObject;\n    //         }\n    //     } else {\n    //         displayValue = viewModelObject;\n    //     }\n\n    //     listElement.listElementDisplayValue = displayValue;\n    //     listElement.listElementObject = viewModelObject;\n\n    //     if( dpSelf.viewModelCollection.getTotalObjectsFound() ) {\n    //         var totalFound = 0;\n    //     }\n\n    //     if( !viewModelObject && !totalFound ) {\n    //         // no result found\n    //         listElement.listElementDisplayValue = dataCtxNode.prop.uiValue;\n    //         listElement.listElementObject = dataCtxNode.prop.dbValue;\n    //     }\n\n    //     if( dataCtxNode.isLoading ) {\n    //         // no result found\n    //         listElement.listElementDisplayValue = dpSelf.isLoading;\n    //         listElement.listElementObject = dpSelf.isLoading;\n    //     }\n\n    //     return listElement;\n    // }; // createPopupObject\n\n    /**\n     * Required. For infinite scroll behavior, we always return a slightly higher number than the previously\n     * loaded items.\n     *\n     * @return {Number} number of objects loaded.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getLength = function() {\n        return dpSelf.viewModelCollection.getVirtualLength();\n    };\n\n    /**\n     * Check if there is more data to load\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.hasMorePages = function() {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'hasMorePages' );\n            return false;\n        }\n\n        /**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */\n        if( dpSelf.accessMode === 'tree' ) {\n            if( dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject ) {\n                return !dpSelf.topTreeNode.cursorObject.endReached;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */\n        if( dpSelf.cursorObject ) {\n            return !dpSelf.cursorObject.endReached;\n        }\n\n        return dpSelf.viewModelCollection.getTotalObjectsFound() > dpSelf.viewModelCollection\n            .getTotalUniqueObjectsLoaded();\n    };\n\n    /**\n     * Check if there is more data to load before current position.\n     *\n     * @return {Boolean} True if there are more objects to load\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.hasMorePagesUp = function() {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'hasMorePagesUp' );\n            return false;\n        }\n\n        /**\n         * Check if acting as a 'tree'<BR>\n         * If so: We can only used the 'top' node cursor.\n         */\n        if( dpSelf.accessMode === 'tree' ) {\n            if( dpSelf.topTreeNode && dpSelf.topTreeNode.cursorObject ) {\n                return !dpSelf.topTreeNode.cursorObject.startReached;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if we have a 'cursor' object.<BR>\n         * If so: Use its state for whether there is more data.\n         */\n        if( dpSelf.cursorObject ) {\n            return !dpSelf.cursorObject.startReached;\n        }\n\n        return false;\n    };\n\n    /**\n     * Finds and returns a vmo with an incomplete head/tail in the given range.\n     * @param { Number } startIdx - index of the first node in the range\n     * @param { Number } endIdx - index of the last node in the range\n     *\n     * @return {Object} The node with an incomplete head/tail\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.findIncompleteNodeInRange = function( startIdx, endIdx ) {\n        for( var i = startIdx; i <= endIdx; i++ ) {\n            var vmNode = dpSelf.viewModelCollection.loadedVMObjects[ i ];\n            if( vmNode && ( vmNode.incompleteHead === true || vmNode.incompleteTail ) ) {\n                return vmNode;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Get previous page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the previous page is loaded and the viewModelCollection is\n     *         updated. Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getPreviousPage = function( dataCtxNode ) {\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'getPreviousPage' );\n            return $q.reject( 'Access to destroyed UwDataProvider.' );\n        }\n\n        assert( dpSelf.previousAction, 'Invalid action specified' );\n\n        if( dpSelf.accessMode === 'tree' ) {\n            var cursorNode = _.first( dpSelf.topTreeNode.children );\n\n            if( cursorNode ) {\n                return dpSelf.getTreeNodePage( dataCtxNode, dpSelf.topTreeNode, cursorNode.id, false,\n                    dpSelf.topTreeNode );\n            }\n\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        var listLoadInput = awTableSvc.createListLoadInput( null, 0, null, false, true );\n\n        var actionRequestObj = {\n            listLoadInput: listLoadInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        return dpSelf.someDataProviderSvc.executeLoadAction( dpSelf.previousAction, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then(\n            function( response ) {\n                dpSelf.viewModelCollection.setTotalObjectsFound( response.totalFound );\n\n                if( response.totalFound > 0 ) {\n                    dpSelf.viewModelCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                        dpSelf.preSelection, true );\n                }\n\n                _notifyModelObjectsUpdate( dataCtxNode, {\n                    prevPage: true\n                } );\n\n                return $q.resolve( dpSelf.viewModelCollection );\n            } );\n    };\n\n    /**\n     * Get next page of results\n     *\n     * @param {Object} dataCtxNode - The data context the query is occurring within.\n     *\n     * @return {Promise} A promise resolved when the next page is loaded and the viewModelCollection is updated.\n     *         Resolved object is a reference to the 'viewModelColection' object associated with this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getNextPage = function( dataCtxNode ) {\n        // revisit me - temp fix to make dataProvider instance consistent\n        const dpSelf = this;\n\n        if( dpSelf._isDestroyed ) {\n            _reportAccessToZombieDataProvider( 'getNextPage' );\n            return $q.reject( 'Access to destroyed UwDataProvider.' );\n        }\n\n        if( dpSelf.accessMode === 'tree' ) {\n            var cursorNode = _.last( dpSelf.topTreeNode.children );\n\n            if( cursorNode ) {\n                return dpSelf.getTreeNodePage( dataCtxNode, dpSelf.topTreeNode, cursorNode.id, true,\n                    dpSelf.topTreeNode );\n            }\n\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        var totalFound = dpSelf.viewModelCollection.getTotalObjectsFound();\n        var totalUniqueLoaded = dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded();\n\n        if( totalFound > totalUniqueLoaded || dpSelf.cursorObject && !dpSelf.cursorObject.endReached ) {\n            dpSelf.startIndex = totalUniqueLoaded;\n\n            var listLoadInput = awTableSvc.createListLoadInput( null, dpSelf.startIndex, null, true, true, dataCtxNode.filterStr );\n\n            var actionRequestObj = {\n                listLoadInput: listLoadInput\n            };\n\n            var action = dpSelf.nextAction ? dpSelf.nextAction : dpSelf.action;\n\n            if( logger.isDeclarativeLogEnabled() ) {\n                debugService.debugDataProviderNextPage( dpSelf, action, dpSelf.json, dataCtxNode, actionRequestObj );\n            }\n\n            return dpSelf.someDataProviderSvc.getNextPage( action, dpSelf.json, dataCtxNode, actionRequestObj )\n                .then(\n                    function( response ) {\n                        var vmCollection = dpSelf.viewModelCollection;\n\n                        vmCollection.setTotalObjectsFound( response.totalFound );\n\n                        if( response.totalFound > 0 ) {\n                            vmCollection.updateModelObjects( response.results, dpSelf.uidInResponse,\n                                dpSelf.preSelection );\n                        }\n\n                        _notifyModelObjectsUpdate( dataCtxNode, {\n                            nextPage: true\n                        } );\n\n                        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n                            vmCollection.totalFound > dpSelf.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n                            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n                        }\n\n                        if( dpSelf.accessMode === 'lov' ) {\n                            // lov api expects incremental response, not the entire collection\n                            return response;\n                        }\n\n                        return vmCollection;\n                    } );\n        }\n\n        return $q.resolve( dpSelf.viewModelCollection );\n    };\n\n    /**\n     * Validate selection\n     *\n     * @param {Object} lovScope - lov context\n     * @param {Array} selected - selected object/s to validate\n     * @param {Boolean} suggestion - does selected contain a suggested value?\n     *\n     * @return {Promise} Promise that is resolved upon completion of validateion.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.validateSelections = function( lovScope, selected, suggestion ) {\n        var action = dpSelf.validateAction;\n\n        if( action ) {\n            var actionRequestObj = { selected: selected, suggestion: suggestion };\n            return dpSelf.someDataProviderSvc.validateSelections( action, dpSelf.json, lovScope, actionRequestObj ).then( function( resp ) {\n                if( !resp.valid ) {\n                    resp.cause = { partialErrors: true };\n                    throw resp;\n                }\n                eventBus.publish( dpSelf.name + '.validSelectionEvent', {\n                    selectedObjects: selected\n                } );\n                return resp;\n            } );\n        }\n\n        // if validate action is not defined, assume all valid\n        eventBus.publish( dpSelf.name + '.validSelectionEvent', {\n            selectedObjects: selected\n        } );\n        return AwPromiseService.instance.resolve( { valid: true } );\n    };\n\n    /**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any new nodes.\n     *\n     * @return {Promise} A promise resolved when the expansion is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.expandObject = function( dataCtxNode, parentNode ) {\n        var begNdx = -1;\n\n        if( dpSelf.cacheCollapse ) {\n            var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n            // BMW: can use _, I am lazy now for prototype\n            for( var ndx = 0; ndx < vmNodes.length; ndx++ ) {\n                if( vmNodes[ ndx ].id === parentNode.id ) {\n                    begNdx = ndx + 1;\n                    break;\n                }\n            }\n        }\n\n        // BMW: Load __expendState if dpSelf.cacheCollapse == true\n        if( begNdx >= 0 && parentNode.__expandState && dpSelf.cacheCollapse ) {\n            // Apply __expandState.expandedNodes to vmoCollection\n            var vmos = dpSelf.viewModelCollection.loadedVMObjects;\n            vmos.splice.apply( vmos, [ begNdx, 0 ].concat( parentNode.__expandState.expandedNodes ) );\n            dpSelf.viewModelCollection.setTotalObjectsFound( vmos.length );\n\n            // Load parentNode context back\n            parentNode.children = parentNode.__expandState.children;\n            parentNode.startChildNdx = parentNode.__expandState.startChildNdx;\n            parentNode.totalChildCount = parentNode.__expandState.totalChildCount;\n            parentNode.cursorObject = parentNode.__expandState.cursorObject;\n\n            // Clean up and return\n            delete parentNode.__expandState;\n            return $q.resolve( dpSelf.viewModelCollection );\n        }\n\n        // BMW: Clean up __expendState if dpSelf.cacheCollapse == false\n        if( !dpSelf.cacheCollapse && parentNode.__expandState ) {\n            delete parentNode.__expandState;\n        }\n\n        return dpSelf.getTreeNodePage( dataCtxNode, parentNode, null, true, dpSelf.topTreeNode );\n    };\n\n    let _initialCacheCollapseState = false;\n\n    /**\n     *\n     * Function to restore collapse cache to the initial value\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.restoreInitialCacheCollapseState = function() {\n        if( !_initialCacheCollapseState ) {\n            dpSelf.cacheCollapse = false;\n            dpSelf.resetCollapseCache();\n        } else {\n            dpSelf.cacheCollapse = true;\n        }\n    };\n\n    /**\n     *\n     * Function to reset collapse cache when needed\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.resetCollapseCache = function() {\n        if( !dpSelf.viewModelCollection || !dpSelf.viewModelCollection.loadedVMObjects ) {\n            return;\n        }\n        _.forEach( dpSelf.viewModelCollection.loadedVMObjects, function( vmo ) {\n            if( vmo.__expandState ) {\n                delete vmo.__expandState;\n            }\n        } );\n    };\n\n    /**\n     * Set valid source types for data provider, this is used for drag and drop usage\n     *\n     * @param {Object} validSourceTypes - valid source types for dataprovider which are set from xrt objectset\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.setValidSourceTypes = function( validSourceTypes ) {\n        dpSelf.validSourceTypes = validSourceTypes;\n    };\n\n    /**\n     * Note: A \"(dp_name).modelObjectsUpdated\" event will be published on the 'eventBus'.\n     *\n     * @param {Object} dataCtxNode - The data context the expansion is occurring within.\n     * @param {ViewModelTreeNode} parentNode - Node to use as the origin for any 'child' nodes being removed as\n     *            part of the collapse.\n     * @return {Promise} A promise resolved when the collapse is complete and the ViewModelCollection is\n     *         updated. Resolved object is a reference to the 'ViewModelColection' object managed by this\n     *         dataProvider.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.collapseObject = function( dataCtxNode, parentNode ) {\n        /**\n         * Remove all 'child' nodes of this 'parent' from the 'loadedVMObjects' of the ViewModelCollection and\n         * reset it's internal 'children' array.\n         */\n        var vmNodes = dpSelf.viewModelCollection.loadedVMObjects;\n\n        var begNdx = -1;\n        var nDelete = 0;\n\n        // BMW Issue #5: add document to this algorithm.\n        // - Loop through the whole vmoCollection\n        // - When find the parent node, set state to start ( begNdx )\n        // - Keep going, when hits node which node.level <= parent.level, stop ( next sibling )\n        // - record all as nDelete.\n        //\n        // So we don't have to clen parentNode.children here...anyway it will be done later\n        for( var ndx = 0; ndx < vmNodes.length; ndx++ ) {\n            if( uwUtilSvc.getEvaluatedId( vmNodes[ ndx ] ) === uwUtilSvc.getEvaluatedId( parentNode ) ) {\n                begNdx = ndx + 1;\n                nDelete = 0;\n            } else if( begNdx >= 0 ) {\n                if( vmNodes[ ndx ].levelNdx > parentNode.levelNdx ) {\n                    nDelete++;\n                } else {\n                    // BMW Issue #5:\n                    // parentNode.children = null;\n                    break;\n                }\n            }\n        }\n\n        if( nDelete > 0 ) {\n            var collapsedNodes = vmNodes.splice( begNdx, nDelete );\n\n            // BMW Issue #7: When any of the node is in loading status, don't cache\n            var collapesdNodesIsLoading = _.reduce( collapsedNodes, function( sum, node ) {\n                return sum ? sum : node.loadingStatus;\n            }, false );\n\n            // BMW: Cache collapse object here\n            if( dpSelf.cacheCollapse && !collapesdNodesIsLoading ) {\n                parentNode.__expandState = {\n                    children: parentNode.children,\n                    startChildNdx: parentNode.startChildNdx,\n                    totalChildCount: parentNode.totalChildCount,\n                    // BMW #5: actually cursorObject cache here is not needed since\n                    // it is anyway leaking in current system when collapse. But for\n                    // safe we can cache and load it too.\n                    cursorObject: parentNode.cursorObject,\n                    expandedNodes: collapsedNodes\n                };\n            }\n\n            parentNode.children = null;\n            parentNode.startChildNdx = 0;\n            parentNode.totalChildCount = null;\n        }\n\n        // Re-evaluate selection state, since we have removed children selection state have changed.\n        dpSelf.selectionModel.evaluateSelectionStatusSummary( dpSelf );\n\n        return $q.resolve( dpSelf.viewModelCollection );\n    }; // collapseObject\n\n    /**\n     * Access a page of 'child' nodes of the given 'parent' node and place the results into the\n     * ViewModelColection of this UwDataProvider.\n     * <P>\n     * Note: Paging information stored in the 'parent' node is used to determine which 'child' nodes to get.\n     * This paging information is then updated to be ready for any subsequent call to this API.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @param {Boolean} focusLoadAction - (Optional) TRUE if action is triggered to load selected object in tree\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNodePage = function( dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode,\n        focusLoadAction ) {\n        var action = addAfter ? dpSelf.nextAction || dpSelf.action : dpSelf.previousAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput,\n            loadIDs: {\n                t_uid: dpSelf.topTreeNode.uid,\n                o_uid: treeLoadInput.parentNode.uid\n            }\n        };\n\n        // focusLoadAction will be true when object present in selection model needs to be loaded in tree.\n        // (cross select between PWA and other sources e.g. Search Panel)\n        if( focusLoadAction ) {\n            action = dpSelf.focusAction ? dpSelf.focusAction : null;\n            treeLoadInput.focusLoadAction = focusLoadAction;\n        }\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        var origCursorObj = _.clone( treeLoadInput.parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * Access the initial page of data.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     *\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     *\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     *\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @param {ViewModelTreeNode} rootNode - Root Node opened\n     *\n     * @return {Promise} A promise resolved with a reference to the updated ViewModelCollection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNodeInitial = function( dataCtxNode, parentNode, cursorNodeId, addAfter, rootNode ) {\n        var action = dpSelf.initializeAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            null, cursorNodeId, dpSelf.treePageSize, addAfter, rootNode );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput\n        };\n\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n\n        var origCursorObj = _.clone( treeLoadInput.parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * Access a page of 'child' nodes of the given 'parent' node (starting at a specific 'child' node) and place\n     * the results into the ViewModelColection of this UwDataProvider.\n     *\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {ViewModelTreeNode} parentNode - (Optional) Node to use as the 'parent' for any new nodes.\n     * @param {String} startChildId - ID of a node in the 'parent' to start loading at.\n     * @param {String} cursorNodeId - ID of an existing node in the 'parent' (and, presumably a\n     *            ViewModelCollection) to insert any new nodes after.\n     * @param {Number} pageSize - Maximum number of 'child' nodes to return (including the 'startChild').\n     * @param {Boolean} addAfter - (Optional) TRUE if any new children should be added AFTER the optional\n     *            'cursorNodeId' (Default: TRUE)\n     *\n     * @return {Promise} A promise object resolved with a reference to the updated ViewModelColection object.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getTreeNode = function( dataCtxNode, parentNode, startChildId, cursorNodeId, pageSize, addAfter ) {\n        var action = addAfter ? dpSelf.nextAction : dpSelf.previousAction;\n\n        assert( action, 'Invalid action specified' );\n\n        /**\n         * Set the dynamic properties of a 'TreeLoadInput' and start loading the next page of 'child' nodes for\n         * the given 'parent'.\n         */\n        var inputData = _determineInput( parentNode, cursorNodeId, addAfter );\n\n        var treeLoadInput = awTableSvc.createTreeLoadInput( inputData.parentNode, inputData.startChildNdx,\n            startChildId, cursorNodeId, pageSize, addAfter );\n\n        var actionRequestObj = {\n            treeLoadInput: treeLoadInput\n        };\n\n        dataCtxNode.data.treeLoadInput = treeLoadInput;\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        var origCursorObj = _.clone( parentNode.cursorObject );\n\n        return dpSelf.someDataProviderSvc\n            .executeLoadAction( action, dpSelf.json, dataCtxNode, actionRequestObj ).then(\n                function( responseObj ) {\n                    return _processLoadTreeNodePageResponse( treeLoadInput, responseObj, dataCtxNode,\n                        origCursorObj );\n                } );\n    };\n\n    /**\n     * @param {Object} dataCtxNode - The data context the access is occurring within.\n     * @param {PropertyLoadInput} propertyLoadInput - The object containing the PropertyLoadRequest(s) to\n     *            process.\n     *\n     * @return {Promise} The Promise is resolved with a PropertyLoadResult object when the operation is\n     *         complete.\n     *\n     * @memberof module:js/dataProviderFactory~UwDataProvider\n     */\n    dpSelf.getProperties = function( dataCtxNode, propertyLoadInput ) {\n        assert( dpSelf.action, 'Invalid action specified' );\n\n        var actionRequestObj = {\n            propertyLoadInput: propertyLoadInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        return dpSelf.someDataProviderSvc.executeLoadAction( dpSelf.action, dpSelf.json, dataCtxNode,\n            actionRequestObj ).then( function( response ) {\n            return response.propertyLoadResult;\n        } );\n    };\n\n    dpSelf.getFilterFacets = function( viewModel, filterFacetInput ) {\n        var action = dpSelf.filterFacetAction;\n\n        var dataCtxNode = {\n            data: viewModel,\n            filterFacetInput: filterFacetInput\n        };\n        updateDataCtxNodeWithProps( dataCtxNode );\n\n        if( action ) {\n            return dpSelf.someDataProviderSvc.executeLoadAction( action, dpSelf.json, dataCtxNode ).then( function( response ) {\n                return response.filterFacetResults;\n            } );\n        }\n        return $q.resolve();\n    };\n\n    /**\n     * Free up all resources held by this object.\n     * <P>\n     * Note: After this function, no API call should be considered valid. This function is intended to be called\n     * when the $scope of any associated viewModel is also being 'destroyed'. After this call (and a GC event),\n     * any objects managed by this class may be considered a 'memory leak'.\n     */\n    dpSelf.destroy = function() {\n        dpSelf._isDestroyed = true;\n\n        declModelRegistrySvc.unregisterModel( 'UwDataProvider', dpSelf, 'name', '_modelId' );\n\n        if( dpSelf._appCtxEditInProgress ) {\n            appCtxService.unRegisterCtx( dpSelf._appCtxEditInProgress );\n        }\n\n        if( dpSelf.selectionModel ) {\n            dpSelf.detachSelectionModel();\n            dpSelf.selectionModel = null;\n        }\n\n        if( dpSelf.viewModelCollection ) {\n            dpSelf.viewModelCollection.destroy();\n            dpSelf.viewModelCollection = null;\n        }\n\n        if( dpSelf.someDataProviderSvc && dpSelf.someDataProviderSvc.destroy ) {\n            dpSelf.someDataProviderSvc.destroy();\n            dpSelf.someDataProviderSvc = null;\n        }\n\n        if( dpSelf.json.editContext && _editHandlerRegistered ) {\n            editHandlerSvc.removeEditHandler( dpSelf.json.editContext );\n        }\n\n        const editConfig = dpSelf.json.editConfig;\n        if( editConfig ) {\n            editUtilsService._removeListeners( editConfig.sourceModel );\n        }\n\n        dpSelf.cols = null;\n        dpSelf.topTreeNode = null;\n        dpSelf.actionObj = null;\n        dpSelf.json = null;\n\n        dpSelf.ttState = null;\n        dpSelf.policy = null;\n        dpSelf.validSourceTypes = null;\n\n        eventBus.unsubscribe( dpSelf.toggleDecoratorsEvent );\n        eventBus.unsubscribe( dpSelf.multiSelectModeEvent );\n        eventBus.unsubscribe( dpSelf.selectActionEvent );\n        dpSelf.toggleDecoratorsEvent = null;\n        dpSelf.multiSelectModeEvent = null;\n        dpSelf.selectActionEvent = null;\n\n        dpSelf.setRootReference( null );\n\n        // detach dispatcher\n        dpSelf.vmCollectionDispatcher = null;\n        dpSelf.pageDispatcher = null;\n        dpSelf.selectionModel = null;\n        referenceElement = null;\n        selectionModelDispatcher = null;\n        dpSelf = null;\n    }; // destroy\n\n    /**\n     * ---------------------------------------------------------------------------<BR>\n     * Property & Function definition complete....Finish initialization. <BR>\n     * ---------------------------------------------------------------------------<BR>\n     */\n\n    declModelRegistrySvc.registerModel( 'UwDataProvider', dpSelf, 'name', '_modelId' );\n\n    /**\n     * Load localized text for when we encounter cases of no results and loading .\n     *\n     * @param localTextBundle\n     */\n    localeSvc.getTextPromise().then( function( localTextBundle ) {\n        if( dpSelf ) {\n            if( declUtils.isNil( dpSelf.isLoading ) ) {\n                dpSelf.isLoading = localTextBundle.LOADING_TEXT;\n            }\n        }\n    } );\n\n    if( actionObj ) {\n        dpSelf.action = actionObj;\n    }\n\n    _.forEach( actionMap, function( actionDef, actionName ) {\n        dpSelf[ actionName ] = actionDef;\n    } );\n\n    if( dataProviderJson ) {\n        dpSelf.json = dataProviderJson;\n        dpSelf.policy = dataProviderJson.policy;\n\n        /** tree page size */\n        if( dataProviderJson.treePageSize ) {\n            dpSelf.treePageSize = dataProviderJson.treePageSize;\n        }\n\n        /** Row or Cell selection scope ? */\n        if( dataProviderJson.selectionModelScope ) {\n            dpSelf.selectionModel.scope = dataProviderJson.selectionModelScope;\n        }\n\n        /**\n         * Only set the default text values if they are not already set in the dataProvider JSON definition.\n         */\n        if( dataProviderJson.noResultsFound ) {\n            dpSelf.noResultsFound = dataProviderJson.noResultsFound;\n        }\n\n        if( dataProviderJson.isLoading ) {\n            dpSelf.isLoading = dataProviderJson.isLoading;\n        }\n\n        if( dataProviderJson.cacheCollapse ) {\n            _initialCacheCollapseState = dataProviderJson.cacheCollapse;\n            dpSelf.cacheCollapse = _initialCacheCollapseState;\n        }\n    }\n\n    /**\n     * Get the editable object from the data provider\n     *\n     * In case of list, it sends the selected object.<BR>\n     * In case of Table, it send the all the loaded objects.\n     *\n     * @return {object} viewModelObject - View model object(s).\n     */\n    dpSelf.getEditableObjects = function() {\n        if( dataProviderJson && dataProviderJson.editContext ) {\n            if( dataProviderJson.editContext === 'LIST_CELL_CONTEXT' ) {\n                if( dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single' ) {\n                    return dpSelf.getSelectedObjects();\n                }\n            } else {\n                var vmc = dpSelf.viewModelCollection;\n                return vmc.getLoadedViewModelObjects();\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Get a list of property names form the dataprovider\n     *\n     * @return {Array} propNames - list of property Names\n     */\n    dpSelf.getPropertyNames = function() {\n        var propNames = [];\n\n        if( dataProviderJson.editContext === 'LIST_CELL_CONTEXT' ) {\n            if( dpSelf.selectionModel && dpSelf.selectionModel.mode === 'single' ) {\n                var selectedObject = dpSelf.getSelectedObjects();\n                if( selectedObject !== null ) {\n                    _.forEach( selectedObject, function( viewModelObject ) {\n                        _.forEach( viewModelObject.props, function( props ) {\n                            if( props && props.type ) {\n                                propNames.push( props.propertyName );\n                            }\n                        } );\n                    } );\n                }\n            }\n        } else {\n            if( dpSelf.cols ) {\n                _.forEach( dpSelf.cols, function( col ) {\n                    if( col && col.typeName && !col.isTreeNavigation ) {\n                        propNames.push( col.propertyName );\n                    }\n                } );\n            }\n        }\n\n        return propNames;\n    };\n\n    /**\n     * Gets the edit configuration object\n     * @return {Object} The edit configuration object\n     */\n    dpSelf.getEditConfiguration = function() {\n        return dpSelf.json.editConfig;\n    };\n\n    /**\n     * Get the command override anchors set in viewModel.\n     *\n     * @return {Object} All possible override anchor strings\n     */\n    dpSelf.getCommandOverrides = function() {\n        return {\n            gridMenuCommandsAnchor: dpSelf.json.gridMenuCommandsAnchor,\n            contextMenuCommandsAnchor: dpSelf.json.contextMenuCommandsAnchor,\n            columnMenuCommandsAnchor: dpSelf.json.columnMenuCommandsAnchor\n        };\n    };\n}; // UwDataProvider\n\n/**\n * ---------------------------------------------------------------------------<BR>\n * Define the public API for the 'dataProviderFactory' Service<BR>\n * ---------------------------------------------------------------------------<BR>\n */\n\nvar exports = {};\n\n/**\n * Create a new DeclDataProvider object to manage and access List, LOV, flat-table and tree-table structured\n * ViewModelObjects.\n *\n * @param {DeclDataProviderJson} dataProviderJson - The JSON definition of the desired DeclDataProvider object\n *            from the DeclViewModel's JSON.\n *\n * @param {DeclAction} actionObj - The associated DeclAction object from the DeclViewModel's JSON.\n *\n * @param {String} dataProviderName - ID of the DeclDataProvider in the DeclViewModel structure.\n *\n * @param {Object} someDataProviderSvc - Some API object where various APIs (i.e. 'getFirstPage', 'getNextPage',\n *            etc.) methods are implemented (e.g. 'js/declDataProviderService').\n *\n * @param {StringMap} actionsMap - Map of action name to the action object from a declViewModel's JSON\n *            definition.\n *\n * @return {UwDataProvider} The newly created DeclDataProvider object.\n *\n * @memberof module:js/dataProviderFactory\n */\nexport let createDataProvider = function( dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n    actionsMap ) {\n    var viewModelCollection = viewModelCollectionFactory.createViewModelCollection( dataProviderName );\n\n    return new UwDataProvider( AwPromiseService.instance, dataProviderJson, actionObj, dataProviderName, someDataProviderSvc,\n        viewModelCollection, actionsMap );\n};\n\n/**\n * Using the given UID, determine which IModelObject should be set as the 'top' node (if any). That object\n * will be set as a new 'top' ViewModelTreeNode on the given dataProvider.\n * <P>\n * Note: The 'top' node is generally hidden from the user and is used only to access 'child' nodes and other\n * properties.\n *\n * @param {String} topNodeUid - (Optional) The ID of the 'top' (if known)\n *\n * @return {ViewModelTreeNode} The new 'top' node.\n */\nfunction _determineTopTreeNode( topNodeUid ) {\n    /**\n     * Create a 'straw' top node to use just in case.\n     */\n    var topTreeNode = {\n        nodeId: 'top',\n        nodeType: 'rootType',\n        displayName: 'top',\n        levelNdx: -1,\n        childNdx: 0\n    };\n\n    if( !_.isEmpty( topNodeUid ) ) {\n        topTreeNode.nodeId = topNodeUid;\n        topTreeNode.nodeType = 'unknown';\n    }\n\n    return awTableSvc.createViewModelTreeNode( topTreeNode.nodeId, topTreeNode.nodeType,\n        topTreeNode.displayName, topTreeNode.levelNdx, topTreeNode.childNdx, null );\n} // _determineTopTreeNode\n\nlet initPreferredChoices = [];\n\nexport const loadAction = async( dataProvider, dataCtxNode, vmCollection, startIndex, pageObject ) => {\n    // revisitme Subhajit: To keep the backward compatibility.. we need to work on declDataCtxService\n    dataProvider.startIndex = startIndex;\n    let pageActionType = pageObject.pageActionType;\n    // tree - for pagination needs improvement\n    if( dataProvider.accessMode === 'tree' ) {\n        let results;\n        switch ( pageActionType ) {\n            case 'NEXT_PAGE':\n                results = await dataProvider.getNextPage( dataCtxNode );\n                break;\n            case 'PREVIOUS_PAGE':\n                results = await dataProvider.getPreviousPage( dataCtxNode );\n                break;\n            case 'PAGE_RESET':\n                dataProvider.topTreeNode = _determineTopTreeNode( dataProvider.topNodeUid );\n                results = await dataProvider.getTreeNodeInitial( dataCtxNode, dataProvider.topTreeNode, null, true,\n                    dataProvider.topTreeNode );\n                //PAGE_RESET - This means the dataprovider is re-initialized\n                //Clear the previous data in vmCollection before updating the new data\n                dataProvider.viewModelCollection.clear();\n                break;\n            case 'FOCUS_PAGE':\n                var focusLoadAction = true;\n                dataProvider.topTreeNode = _determineTopTreeNode( dataProvider.topNodeUid );\n                results = await dataProvider.getTreeNodePage( dataCtxNode, dataProvider.topTreeNode, null, true,\n                    dataProvider.topTreeNode, focusLoadAction );\n                break;\n        }\n\n        //Verify if the component is still mounted\n        if( !dataProvider.vmCollectionDispatcher ) {\n            return;\n        }\n\n        // totalFound and hasMoreValuesExist are mutually exclusive keys.\n        dataProvider.vmCollectionDispatcher( {\n            type: 'COLLECTION_UPDATE',\n            viewModelObjects: results.loadedVMObjects,\n            totalFound: results.totalFound,\n            cursorObject: dataProvider.topTreeNode.cursorObject,\n            pageObject: pageObject\n        } );\n        dataProvider.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        dataProvider.vmCollectionDispatcher( { type: 'FOCUSING', focusing: false } );\n        if( pageActionType === 'FOCUS_PAGE' ) {\n            dataProvider.syncSelectionModel( dataCtxNode );\n        }\n    } else {\n        let action;\n        switch ( pageActionType ) {\n            case 'PAGE_RESET':\n                dataProvider.startIndex = 0;\n                action = dataProvider.initializeAction ? dataProvider.initializeAction : dataProvider.action;\n                break;\n            case 'NEXT_PAGE':\n                action = dataProvider.nextAction ? dataProvider.nextAction : dataProvider.action;\n                break;\n            case 'PREVIOUS_PAGE':\n                action = dataProvider.previousAction ? dataProvider.previousAction : dataProvider.action;\n                break;\n            case 'FOCUS_PAGE':\n                dataProvider.startIndex = 0;\n                dataProvider.vmCollectionDispatcher( {\n                    type: 'COLLECTION_RESET'\n                } );\n                action = dataProvider.focusAction ? dataProvider.focusAction : null;\n                break;\n        }\n\n        let listLoadInput = awTableSvc.createListLoadInput( null, dataProvider.startIndex, null, true );\n        let actionRequestObj = { listLoadInput };\n\n        const response = await dataProvider.someDataProviderSvc.executeLoadAction( action, dataProvider.json,\n            dataCtxNode, actionRequestObj );\n        //Verify if the component is still mounted\n        if( !dataProvider.vmCollectionDispatcher ) {\n            return;\n        }\n\n        let viewModelObjects = vmCollection.createModelObjects( response.results || [] );\n        if( pageActionType === 'NEXT_PAGE' ) {\n            viewModelObjects = vmCollection.getLoadedViewModelObjects().concat( viewModelObjects );\n        } else if( pageActionType === 'PREVIOUS_PAGE' ) {\n            viewModelObjects = viewModelObjects.concat( vmCollection.getLoadedViewModelObjects() );\n        } else if( pageActionType === 'PAGE_RESET' ) {\n            // PAGE_RESET - This means the dataprovider is re-initialized\n            // retrieve preferred vals if defined\n            if ( dataProvider.preferredChoicesAction ) {\n                const preferredChoiceResp = await dataProvider.someDataProviderSvc.executeLoadAction( dataProvider.preferredChoicesAction, dataProvider.json, dataCtxNode );\n                initPreferredChoices = preferredChoiceResp.actionResultObj.responseObj.preferredChoices;\n            }\n\n            // Clear the previous data in vmCollection before updating the new data\n            if( response.hasOwnProperty( 'lovUsage' ) ) {\n                dataProvider.lovUsage = response.lovUsage;\n            }\n            if( response ) { dataProvider.viewModelCollection.clear(); }\n            if( response.totalFound > 0 && response.results ) {\n                dataProvider.noResults = false;\n            } else {\n                dataProvider.noResults = true;\n                // assigning no result found string if there is no data from rest service\n                if( dataProvider.json.noResultsFound ) {\n                    var i18nkey = dataProvider.json.noResultsFound;\n                    i18nkey = parsingUtils.geti18nKey( i18nkey );\n                    dataProvider.noResultsFound = dataCtxNode.data.i18n[ i18nkey ];\n                }\n            }\n        }\n        // totalFound and hasMoreValuesExist are mutually exclusive keys.\n        let totalFound = response.hasOwnProperty( 'moreValuesExist' ) ? -1 : response.totalFound;\n        let hasMoreValuesExist = response.hasOwnProperty( 'moreValuesExist' ) ? response.moreValuesExist : null;\n\n        // set preferred vals if defined\n        if ( dataProvider.preferredChoicesAction ) {\n            response.preferredChoices = initPreferredChoices;\n        }\n\n        dataProvider.vmCollectionDispatcher( {\n            type: 'COLLECTION_UPDATE',\n            viewModelObjects: viewModelObjects,\n            totalFound,\n            hasMoreValuesExist,\n            cursorObject: dataProvider.cursorObject,\n            pageObject: pageObject,\n            preferredChoices: response.preferredChoices\n        } );\n        dataProvider.vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: false } );\n        dataProvider.notifyModelObjectsUpdate();\n        /**\n         * Determine if the last node in the collection is an 'incompleteTail' because we know\n         * there are more found than currently loaded.\n         */\n        if( !_.isEmpty( vmCollection.loadedVMObjects ) &&\n            vmCollection.totalFound > dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded() ) {\n            _.last( vmCollection.loadedVMObjects ).incompleteTail = true;\n        }\n\n        /**\n         * Determine if the first node in the collection is an 'incompleteHead'\n         */\n        if( !_.isEmpty( vmCollection.loadedVMObjects ) && dataProvider.cursorObject &&\n            dataProvider.cursorObject.startReached === false ) {\n            _.head( vmCollection.loadedVMObjects ).incompleteHead = true;\n        }\n    }\n    if( pageActionType === 'FOCUS_PAGE' ) {\n        //  revisitme Shaishav: In old focus action following variables were getting set.\n        //  We might need them when TC tables are supported.\n        //  Keeping is commented to not lose track of them\n        // if( response.totalFound > 0 && response.results ) {\n        //     dpSelf.noResults = false;\n\n        //     vmCollection.updateModelObjects( response.results,\n        //         dpSelf.uidInResponse, dpSelf.preSelection );\n        // } else {\n        //     dpSelf.noResults = true;\n        // }\n\n        eventBus.publish( dataProvider.name + '.focusSelection' );\n    }\n};\n\n/**\n *\n * @param {*} param0\n * @param {*} dataProvider\n * @param {*} dataCtxNode\n */\nexport const validateLovAction = ( { lovEntries, vmo, viewModelProp }, dataProvider, dataCtxNode ) => {\n    return dataProvider.validateLOV( { lovEntries, vmo, viewModelProp }, dataCtxNode );\n};\n\n/**\n * Extract a parameter of a specific class from the given arguments array.\n * <P>\n * Note: The order or existence of parameters can vary when more-than-one property is specified in the\n * 'inputData' property of a DeclAction JSON. This code seeks out the requested one.\n *\n * @param {ObjectArray} argsIn - Array of argument objects\n *\n * @return {UwDataProvider} The DeclDataProvider from the given arguments (or undefined if not found)\n */\nexport let findDataProvider = function( argsIn ) {\n    for( var ndx = 0; ndx < argsIn.length; ndx++ ) {\n        var arg = argsIn[ ndx ];\n\n        if( exports.isDataProvider( arg ) ) {\n            return arg;\n        }\n    }\n    return undefined;\n};\n\n/**\n * Test if the given object 'is-a' UwDataProvider created by this service.\n *\n * @param {Object} objectToTest - Object to check prototype history of.\n * @return {Boolean} TRUE if the given object is a DeclDataProvider.\n */\nexport let isDataProvider = function( objectToTest ) {\n    return objectToTest instanceof UwDataProvider;\n};\n\n/**\n * Select all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\nexport let selectAll = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.selectAll();\n    }\n};\n\n/**\n * Deselect all loaded objects in the dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\nexport let selectNone = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.selectNone();\n    }\n};\n\n/**\n * Enable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the selectAll command from\n */\nexport let dataProviderEnableMultiSelect = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.enableMultiSelect();\n    }\n};\n\n/**\n * Disable Multi Select Mode for selected dataprovider.\n *\n * @param {Object} dataProvider - dataProvider to call the deSelectAll command from\n */\nexport let dataProviderDisableMultiSelect = function( dataProvider ) {\n    if( dataProvider ) {\n        dataProvider.disableMultiSelect();\n    }\n};\n\nfunction loadDebugOption() {\n    var urlAttrs = browserUtils.getUrlAttributes();\n\n    _debug_logTreeLoadActivity = urlAttrs.logTreeLoadActivity !== undefined;\n}\n\n/**\n * createDynamicDataProvider based on jsonData specified by src\\propertyrender\\lovDataProvider.json\n * @param {int} index - the index to return\n * @return {Object} dataProvider the dataProvider\n */\nexport let createDynamicDataProvider = ( index = 0 ) => {\n    let dataProviders = [];\n    let _processAction = ( jsonData, jsonDataProvider, dpName, actionName, actionMap ) => {\n        var actionRef = jsonDataProvider[ actionName ];\n        if( actionRef && jsonData.actions ) {\n            actionMap[ actionName ] = jsonData.actions[ actionRef ];\n        }\n    };\n    if( jsonData.dataProviders ) {\n        var dataProvidersClone = _.cloneDeep( jsonData.dataProviders );\n        _.forEach( dataProvidersClone, function( jsonDataProvider, dpName ) {\n            var actionMap = {};\n            _processAction( jsonData, jsonDataProvider, dpName, 'action', actionMap ); // legacy init/getNext action\n            _processAction( jsonData, jsonDataProvider, dpName, 'initializeAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'nextAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'previousAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'focusAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'expandAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'validateAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'filterFacetAction', actionMap );\n            _processAction( jsonData, jsonDataProvider, dpName, 'preferredChoicesAction', actionMap );\n\n            let dataProviderInstance = createDataProvider( jsonDataProvider, actionMap.action, dpName, declDataProviderSvc, actionMap );\n            dataProviderInstance.dynamicDp = true;\n            dataProviderInstance.debugId = Math.floor( Math.random() * 100 );\n            dataProviders.push( dataProviderInstance );\n        } );\n    }\n\n    return dataProviders[ index ];\n};\n\nexports = {\n    createDataProvider,\n    createDynamicDataProvider,\n    findDataProvider,\n    isDataProvider,\n    loadAction,\n    selectAll,\n    selectNone,\n    dataProviderEnableMultiSelect,\n    dataProviderDisableMultiSelect,\n    validateLovAction\n};\nexport default exports;\n\nloadDebugOption();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}