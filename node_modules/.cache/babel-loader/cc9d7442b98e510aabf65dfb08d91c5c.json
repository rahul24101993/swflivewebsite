{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /* eslint-disable require-jsdoc */ /* eslint-disable valid-jsdoc */ /**\n * aw Number and Currency Filter Service\n * Formats a number as text.\n * Formats a number as a currency (ie $1,234.56).\n * \n * @module js/awNumberAndCurrencyFilterService\n */const NUMBER_FORMATS={CURRENCY_SYM:'$',DECIMAL_SEP:'.',GROUP_SEP:',',PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:'-',negSuf:'',posPre:'',posSuf:''},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:'-\\u00a4',negSuf:'',posPre:'\\u00a4',posSuf:''}]};const MAX_DIGITS=22;const DECIMAL_SEP='.';const ZERO_CHAR='0';function isString(value){return typeof value==='string';}function isNumber(value){return typeof value==='number';}/**\n * Round the parsed number to the specified number of decimal places\n * This function changed the parsedNumber in-place\n */function roundNumber(parsedNumber,fractionSize,minFrac,maxFrac){var digits=parsedNumber.d;var fractionLen=digits.length-parsedNumber.i;// determine fractionSize if it is not specified; `+fractionSize` converts it to a number\nfractionSize=typeof fractionSize==='undefined'?Math.min(Math.max(minFrac,fractionLen),maxFrac):Number(fractionSize);// The index of the digit to where rounding is to occur\nvar roundAt=fractionSize+parsedNumber.i;var digit=digits[roundAt];if(roundAt>0){// Drop fractional digits beyond `roundAt`\ndigits.splice(Math.max(parsedNumber.i,roundAt));// Set non-fractional digits beyond `roundAt` to 0\nfor(var j=roundAt;j<digits.length;j++){digits[j]=0;}}else{// We rounded to zero so reset the parsedNumber\nfractionLen=Math.max(0,fractionLen);parsedNumber.i=1;digits.length=Math.max(1,roundAt=fractionSize+1);digits[0]=0;for(var i=1;i<roundAt;i++){digits[i]=0;}}if(digit>=5){if(roundAt-1<0){for(var k=0;k>roundAt;k--){digits.unshift(0);parsedNumber.i++;}digits.unshift(1);parsedNumber.i++;}else{digits[roundAt-1]++;}}// Pad out with zeros to get the required fraction length\nfor(;fractionLen<Math.max(0,fractionSize);fractionLen++){digits.push(0);}// Do any carrying, e.g. a digit was rounded up to 10\nvar carry=digits.reduceRight(function(carry,d,i,digits){d+=carry;digits[i]=d%10;return Math.floor(d/10);},0);if(carry){digits.unshift(carry);parsedNumber.i++;}}/**\n * Parse a number (as a string) into three components that can be used\n * for formatting the number.\n *\n * (Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/)\n *\n * @param  {string} numStr The number to parse\n * @return {object} An object describing this number, containing the following keys:\n *  - d : an array of digits containing leading zeros as necessary\n *  - i : the number of the digits in `d` that are to the left of the decimal point\n *  - e : the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n *\n */function parse(numStr){var exponent=0;var digits;var numberOfIntegerDigits;var i;var j;var zeros;// Decimal point?\nif((numberOfIntegerDigits=numStr.indexOf(DECIMAL_SEP))>-1){numStr=numStr.replace(DECIMAL_SEP,'');}// Exponential form?\nif((i=numStr.search(/e/i))>0){// Work out the exponent.\nif(numberOfIntegerDigits<0){numberOfIntegerDigits=i;}numberOfIntegerDigits+=Number(numStr.slice(i+1));numStr=numStr.substring(0,i);}else if(numberOfIntegerDigits<0){// There was no decimal point or exponent so it is an integer.\nnumberOfIntegerDigits=numStr.length;}// Count the number of leading zeros.\nfor(i=0;numStr.charAt(i)===ZERO_CHAR;i++){/* empty */}if(i===(zeros=numStr.length)){// The digits are all zero.\ndigits=[0];numberOfIntegerDigits=1;}else{// Count the number of trailing zeros\nzeros--;while(numStr.charAt(zeros)===ZERO_CHAR){zeros--;}// Trailing zeros are insignificant so ignore them\nnumberOfIntegerDigits-=i;digits=[];// Convert string to array of digits without leading/trailing zeros.\nfor(j=0;i<=zeros;i++,j++){digits[j]=Number(numStr.charAt(i));}}// If the number overflows the maximum allowed digits then use an exponent.\nif(numberOfIntegerDigits>MAX_DIGITS){digits=digits.splice(0,MAX_DIGITS-1);exponent=numberOfIntegerDigits-1;numberOfIntegerDigits=1;}return{d:digits,e:exponent,i:numberOfIntegerDigits};}/**\n * Format a number into a string\n * @param  {number} number       The number to format\n * @param  {{\n *           minFrac, // the minimum number of digits required in the fraction part of the number\n *           maxFrac, // the maximum number of digits required in the fraction part of the number\n *           gSize,   // number of digits in each group of separated digits\n *           lgSize,  // number of digits in the last group of digits before the decimal separator\n *           negPre,  // the string to go in front of a negative number (e.g. `-` or `(`))\n *           posPre,  // the string to go in front of a positive number\n *           negSuf,  // the string to go after a negative number (e.g. `)`)\n *           posSuf   // the string to go after a positive number\n *         }} pattern\n * @param  {string} groupSep The string to separate groups of number (e.g. `,`)\n * @param  {string} decimalSep The string to act as the decimal separator (e.g. `.`)\n * @param  {[type]} fractionSize The size of the fractional part of the number\n * @return {string} The number formatted as a string\n */function formatNumber(number,pattern,groupSep,decimalSep,fractionSize){if(!(isString(number)||isNumber(number))||isNaN(number)){return'';}var isInfinity=!isFinite(number);var isZero=false;var numStr=String(Math.abs(number));var formattedText='';var parsedNumber;if(isInfinity){formattedText='\\u221e';}else{parsedNumber=parse(numStr);roundNumber(parsedNumber,fractionSize,pattern.minFrac,pattern.maxFrac);var digits=parsedNumber.d;var integerLen=parsedNumber.i;var exponent=parsedNumber.e;var decimals=[];isZero=digits.reduce(function(isZero,d){return isZero&&!d;},true);// pad zeros for small numbers\nwhile(integerLen<0){digits.unshift(0);integerLen++;}// extract decimals digits\nif(integerLen>0){decimals=digits.splice(integerLen,digits.length);}else{decimals=digits;digits=[0];}// format the integer digits with grouping separators\nvar groups=[];if(digits.length>=pattern.lgSize){groups.unshift(digits.splice(-pattern.lgSize,digits.length).join(''));}while(digits.length>pattern.gSize){groups.unshift(digits.splice(-pattern.gSize,digits.length).join(''));}if(digits.length){groups.unshift(digits.join(''));}formattedText=groups.join(groupSep);// append the decimal digits\nif(decimals.length){formattedText+=decimalSep+decimals.join('');}if(exponent){formattedText+='e+'+exponent;}}if(number<0&&!isZero){return pattern.negPre+formattedText+pattern.negSuf;}return pattern.posPre+formattedText+pattern.posSuf;}function numberFilter(number,fractionSize){// if null or undefined pass it through\nreturn number===null?number:formatNumber(number,NUMBER_FORMATS.PATTERNS[0],NUMBER_FORMATS.GROUP_SEP,NUMBER_FORMATS.DECIMAL_SEP,fractionSize);}function currencyFilter(amount,currencySymbol,fractionSize){if(typeof currencySymbol==='undefined'){currencySymbol=NUMBER_FORMATS.CURRENCY_SYM;}if(typeof fractionSize==='undefined'){fractionSize=NUMBER_FORMATS.PATTERNS[1].maxFrac;}// If the currency symbol is empty, trim whitespace around the symbol\nvar currencySymbolRe=!currencySymbol?/\\s*\\u00A4\\s*/g:/\\u00A4/g;// if null or undefined pass it through\nreturn amount===null?amount:formatNumber(amount,NUMBER_FORMATS.PATTERNS[1],NUMBER_FORMATS.GROUP_SEP,NUMBER_FORMATS.DECIMAL_SEP,fractionSize).replace(currencySymbolRe,currencySymbol);}export default{numberFilter,currencyFilter};","map":null,"metadata":{},"sourceType":"module"}