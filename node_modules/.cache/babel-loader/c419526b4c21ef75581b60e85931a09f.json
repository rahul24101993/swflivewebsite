{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is responsible to process drag and drop handlers on the declViewModel if drag and\n * drop configuration is defined for that particular view.\n * It is also responsible to attach the drag and drop listners to applicable views and widgets.\n *\n * @module js/declDragAndDropService\n */\nimport cfgSvc from 'js/configurationService';\nimport moduleLoader from 'js/moduleLoader';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport appCtxSvc from 'js/appCtxService';\nimport conditionSvc from 'js/conditionService';\nimport logger from 'js/logger';\nimport domUtils from 'js/domUtils';\nimport awConfiguration from 'js/awConfiguration';\nconst eleRef = domUtils.DOMAPIs;\nlet exports;\nconst PRE_LOADED_DEPS = '_internal.preLoadedDeps';\nconst DRAG_HANDLERS = '_internal.dragHandlers';\nconst DROP_HANDLERS = '_internal.dropHandlers';\nconst DEPS_TO_LOAD = '_internal.depsToLoad';\nconst dndAttr = {\n  dragstart: 'onDrag',\n  dragenter: 'onDragEnter',\n  dragleave: 'onDragLeave',\n  dragover: 'onDragOver',\n  drop: 'onDrop',\n  dragend: 'onDragEnd'\n};\nlet defaultDragHandler = null;\nlet defaultDropHandler = null;\nlet dragDropConfig = null;\nlet viewHandlersMap = new Map();\n\nconst loadConfiguration = () => {\n  /*\n   * Get the drag and drop configuration\n   */\n  dragDropConfig = cfgSvc.getCfgCached('dragAndDrop');\n  let defaultDragAndDropConfig = awConfiguration.get('solutionDef.defaultDragAndDropHandlers');\n\n  if (defaultDragAndDropConfig && defaultDragAndDropConfig !== '{{defaultDragAndDropHandlers}}') {\n    defaultDragHandler = defaultDragAndDropConfig.dragHandler !== '' ? defaultDragAndDropConfig.dragHandler : null;\n    defaultDropHandler = defaultDragAndDropConfig.dropHandler !== '' ? defaultDragAndDropConfig.dropHandler : null;\n  }\n};\n\nconst createDragAndDropHandlersMap = () => {\n  const setViewHandlers = (viewName, handlerDef, handlerkey) => {\n    let key = handlerkey === 'dragActions' ? 'dragHandlers' : 'dropHandlers';\n\n    if (!viewHandlersMap.has(viewName)) {\n      viewHandlersMap.set(viewName, {\n        dragHandlers: [],\n        dropHandlers: []\n      });\n    }\n\n    let def = viewHandlersMap.get(viewName);\n    let obj = {};\n\n    _.forOwn(handlerDef[handlerkey], function (value, hkey) {\n      obj[hkey.toLowerCase()] = value;\n    });\n\n    let viewHandlerDef = {\n      condition: {},\n      handlers: obj\n    };\n\n    if (handlerDef.activeWhen) {\n      viewHandlerDef.condition.activeWhen = handlerDef.activeWhen;\n    }\n\n    def[key].push(viewHandlerDef);\n  };\n\n  const processHandlers = (handlers, handlerkey) => {\n    _.forEach(handlers, (handlerDef, handlerName) => {\n      if (handlerName === defaultDragHandler || handlerName === defaultDropHandler) {\n        return;\n      }\n\n      _.forEach(handlerDef.views, viewName => {\n        setViewHandlers(viewName, handlerDef, handlerkey);\n      });\n    });\n  };\n\n  if (dragDropConfig) {\n    let handlers = dragDropConfig.dragHandlers;\n    processHandlers(handlers, 'dragActions');\n    handlers = dragDropConfig.dropHandlers;\n    processHandlers(handlers, 'dropActions');\n  }\n};\n\nconst getTargetEleAndVMOs = (event, callbackAPIs) => {\n  let target = {};\n  let isSourceEle = event.type === 'dragstart';\n\n  if (callbackAPIs.getTargetElementAndVmo) {\n    target = callbackAPIs.getTargetElementAndVmo(event, isSourceEle);\n  }\n\n  return {\n    targetElement: target.targetElement,\n    targetObjects: target.targetVMO\n  };\n};\n\nconst getAction = (declViewModel, actionName) => {\n  const dragAndDropInput = '{{dragAndDropParams}}';\n\n  let action = _.get(declViewModel, '_internal.actions.' + actionName);\n\n  if (action) {\n    //adding actionId ref to action object for consistency with declViewModel actions\n    action.actionId = actionName;\n\n    if (!action.inputData) {\n      _.set(action, 'inputData', {\n        dndParams: dragAndDropInput\n      });\n    } else {\n      let inputData = { ...action.inputData,\n        dndParams: dragAndDropInput\n      };\n\n      _.set(action, 'inputData', inputData);\n    }\n\n    return action;\n  }\n\n  return null;\n};\n\nconst evaluateActiveWhen = (handlerObj, dragAndDropConfig, declViewModel) => {\n  if (handlerObj.condition) {\n    handlerObj = handlerObj.condition;\n  }\n\n  if (!handlerObj.activeWhen) {\n    return true;\n  }\n\n  if (declViewModel.dataProviders && Object.keys(declViewModel.dataProviders).length === 0) {\n    declViewModel.dataProviders = null;\n  }\n\n  return conditionSvc.evaluateConditionExpression(handlerObj, {\n    data: declViewModel,\n    ctx: appCtxSvc.ctx\n  }, {\n    clauseName: 'activeWhen',\n    conditionList: dragAndDropConfig\n  });\n};\n/*\n * Attaching dragenter, dragover and drop listners at the document level\n * These listners are mainly required for file drag and drop. Whenever a file is dragged from Os to the browser, by\n * default the effectAllowed property that is set by OS(defaults to copy/move depending on the file type) will be set\n * as the dropEffect.\n * So as soon as the file is dragged on browser, the default dropEffect would be enabled(copy/move) and thus drop is enabled\n * if the no events listners for drag and drop are defined for the particular part of the page. Further the default browser behavior\n * to open the dropped file would be performed.\n *\n * These listners basically set the drop effect to false during dragenter and dragover phase, thus preventing drop.\n *\n * Note: A file specific check is not added during dragenter and dragover phase as doing so would lead to undefined dropEffect\n * state(instead of block) for objects that are being dragged on non-droppable drop areas.\n */\n\n\nconst attachDocEventListners = () => {\n  const setDropEffect = event => {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  };\n\n  document.addEventListener('dragover', setDropEffect);\n  document.addEventListener('dragenter', setDropEffect);\n  document.addEventListener('drop', setDropEffect);\n};\n\nconst setDragAndDropHandlersOnVM = (declViewModel, path, activeHandlerActions, actionsDefs) => {\n  const setDnDActionsOnVM = (declViewModel, handlerActions) => {\n    let declVmActions = _.get(declViewModel, '_internal.actions');\n\n    if (!declVmActions) {\n      _.set(declViewModel, '_internal.actions', handlerActions);\n    } else {\n      Object.assign(declVmActions, handlerActions);\n    }\n  };\n\n  const getHandlerActionsAndDepsToLoad = activeHandlerActions => {\n    let depsToLoad = [];\n    let handlerActions = {};\n\n    _.forEach(activeHandlerActions, actionName => {\n      let actionDef = actionsDefs[actionName];\n\n      if (!actionDef) {\n        return;\n      }\n\n      handlerActions[actionName] = actionDef;\n      let found = depsToLoad.some(dep => dep === actionDef.deps);\n\n      if (!found) {\n        depsToLoad.push(actionDef.deps);\n      }\n    });\n\n    return {\n      handlerActions,\n      depsToLoad\n    };\n  }; //Set drag and drop handler references on the declViewModel\n  //These handler references will be used by widgets to setup drag and drop\n\n\n  _.set(declViewModel, path, activeHandlerActions);\n\n  let handlers = getHandlerActionsAndDepsToLoad(activeHandlerActions);\n  setDnDActionsOnVM(declViewModel, handlers.handlerActions);\n  let handlerDeps = _.get(declViewModel, DEPS_TO_LOAD) ? _.get(declViewModel, DEPS_TO_LOAD) : [];\n  handlerDeps = [...new Set([...handlerDeps, ...handlers.depsToLoad])];\n\n  _.set(declViewModel, DEPS_TO_LOAD, handlerDeps);\n};\n\nconst processDnDEvent = (data, event) => {\n  if (data.effectAllowed) {\n    event.dataTransfer.effectAllowed = data.effectAllowed;\n  }\n\n  if (data.dropEffect) {\n    event.dataTransfer.dropEffect = data.dropEffect;\n  }\n\n  if (data.preventDefault) {\n    event.preventDefault();\n  }\n\n  if (data.stopPropagation) {\n    event.stopPropagation();\n  }\n\n  if (!_.isEmpty(data.setDragImage)) {\n    event.dataTransfer.setDragImage(data.setDragImage.dragImage, data.setDragImage.xOffset, data.setDragImage.yOffset);\n  }\n};\n\nexport const areDnDHandelersDefined = function (declViewModel) {\n  let dragProviders = _.get(declViewModel, DRAG_HANDLERS);\n\n  let dropProviders = _.get(declViewModel, DROP_HANDLERS);\n\n  return dragProviders || dropProviders;\n};\n/**\n * Setup drag and drop listners on the element if drag and drophandlers are defined on the declViewModel\n * @param {Element} element: The DOM element on which the drag and drop listeners are to be attached.\n *\n * @param {Object} callbackAPIs:Callback functions used for various reasons of interaction with the\n *            container(element).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @param {Object} dataProvider: The dataProvider associated with the widget(if applicable)\n */\n\nexport const setupDragAndDrop = function (declViewModel, declObj, getProps) {\n  let dragProviders = _.get(declViewModel, DRAG_HANDLERS);\n\n  let dropProviders = _.get(declViewModel, DROP_HANDLERS);\n\n  const processDnDParamsAndGetCtxNode = (declViewModel, event, target, callbackAPIs, dataProvider) => {\n    let dataCtxNode = { ...declObj,\n      props: getProps()\n    };\n    let obj = [];\n\n    if (target.targetVMO && target.targetVMO.length > 0) {\n      obj = target.targetVMO;\n    } else if (declViewModel.vmo) {\n      obj = [declViewModel.vmo];\n    }\n\n    if (!dataCtxNode) {\n      dataCtxNode = {};\n    }\n\n    dataCtxNode.dragAndDropParams = {\n      event: event,\n      targetElement: target.targetElement,\n      targetObjects: obj,\n      declViewModel,\n      callbackAPIs,\n      dataProvider\n    };\n    return dataCtxNode;\n  };\n\n  const executeHandler = (declViewModel, handlerAction, dataCtxNode, event) => {\n    let action = getAction(declViewModel, handlerAction);\n\n    if (!action) {\n      logger.error('Missing action definition for ' + handlerAction);\n      return;\n    }\n\n    let depModuleObj = _.get(declViewModel, PRE_LOADED_DEPS);\n\n    let retData = actionService.performActionSync(declViewModel, action, dataCtxNode, depModuleObj[action.deps]);\n\n    if (retData) {\n      processDnDEvent(retData, event);\n    }\n  };\n\n  const getEventCallbackFn = function (handlerAction, event) {\n    let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callbackAPIs = arguments.length > 3 ? arguments[3] : undefined;\n    let dataProvider = arguments.length > 4 ? arguments[4] : undefined;\n\n    if (target.targetElement && target.targetElement.nodeName.toLowerCase() !== 'aw-include') {\n      event.stopPropagation();\n    } //setting a flag on declVM indicate that a that an element from it is being dragged\n    //This is mainly required to prevent selection of a list cell the list when it is dragged\n\n\n    if (event.type === 'dragstart') {\n      declViewModel._swDragging = true;\n    }\n\n    if ((event.type === 'dragend' || event.type === 'drop') && declViewModel._swDragging) {\n      delete declViewModel._swDragging;\n    }\n\n    let dataCtxNode = processDnDParamsAndGetCtxNode(declViewModel, event, target, callbackAPIs, dataProvider);\n\n    if (handlerAction && handlerAction !== '') {\n      executeHandler(declViewModel, handlerAction, dataCtxNode, event);\n    }\n  };\n\n  let dndHandler = null;\n\n  if (dragProviders || dropProviders) {\n    dndHandler = {};\n\n    const createCallback = (eventType, handlerAction) => {\n      let callBackFn = getEventCallbackFn.bind(null, handlerAction);\n      dndHandler[eventType] = callBackFn;\n    };\n\n    const createEventListener = providers => {\n      Object.keys(providers).forEach(providerName => {\n        createCallback(providerName.toLowerCase(), providers[providerName]);\n      });\n    };\n\n    if (dragProviders) {\n      createEventListener(dragProviders);\n    }\n\n    if (dropProviders) {\n      createEventListener(dropProviders);\n    }\n  }\n\n  declViewModel.dndHandler = dndHandler;\n};\n/**\n * Process the active drag and drop handlers on the declViewModel, if any. Also sets up the drag and drop\n * listners of the view element if active drop handler is found.\n * lement).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @returns {Boolean} Returns whether or not active drop handler is defined for the view.\n */\n\nexport const setupDragAndDropOnView = function (declViewModel) {\n  let activeHandler = null;\n\n  if (!dragDropConfig) {\n    return false;\n  }\n\n  let currentViewName = _.get(declViewModel, '_internal.viewId');\n\n  const isHandlerActiveForView = (viewName, handlerType) => {\n    let handlers = viewHandlersMap.get(viewName);\n\n    if (handlers && handlers[handlerType].length) {\n      return handlers[handlerType].some(handlerObj => {\n        if (evaluateActiveWhen(handlerObj, dragDropConfig, declViewModel)) {\n          activeHandler = handlerObj;\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return false;\n  };\n\n  const attachDefaultHandler = (handlerPath, handlerName, handlerActionKey) => {\n    let handler = _.get(dragDropConfig, handlerName);\n\n    if (handler && handler.views[0] === '*' && evaluateActiveWhen(handler, dragDropConfig, declViewModel)) {\n      setDragAndDropHandlersOnVM(declViewModel, handlerPath, handler[handlerActionKey], dragDropConfig.actions);\n    }\n  };\n\n  let isDragHandlerActive = isHandlerActiveForView(currentViewName, 'dragHandlers');\n\n  if (isDragHandlerActive && activeHandler) {\n    setDragAndDropHandlersOnVM(declViewModel, DRAG_HANDLERS, activeHandler.handlers, dragDropConfig.actions);\n  } else if (!isDragHandlerActive && defaultDragHandler) {\n    attachDefaultHandler(DRAG_HANDLERS, 'dragHandlers.' + defaultDragHandler, 'dragActions');\n  }\n\n  activeHandler = null;\n  let isDropHandlerActive = isHandlerActiveForView(currentViewName, 'dropHandlers');\n\n  if (isDropHandlerActive && activeHandler) {\n    setDragAndDropHandlersOnVM(declViewModel, DROP_HANDLERS, activeHandler.handlers, dragDropConfig.actions);\n  } else if (!isDropHandlerActive && defaultDropHandler) {\n    attachDefaultHandler(DROP_HANDLERS, 'dropHandlers.' + defaultDropHandler, 'dropActions');\n  }\n\n  return true;\n};\nexport const getDragHandler = function (declViewModel) {\n  return _.get(declViewModel, DRAG_HANDLERS);\n};\nexport const getDropHandler = function (declViewModel) {\n  return _.get(declViewModel, DROP_HANDLERS);\n};\nexport const updateDeps = function (declViewModel) {\n  const setPreLoadedDepsOnVM = (declViewModel, deps) => {\n    let loadedDeps = _.get(declViewModel, PRE_LOADED_DEPS);\n\n    if (!loadedDeps) {\n      _.set(declViewModel, PRE_LOADED_DEPS, deps);\n    } else {\n      Object.assign(declViewModel._internal.preLoadedDeps, deps);\n    }\n  };\n\n  const getDeps = async depsToPreLoad => {\n    let dependenciesToPreload = {};\n    let depTobBeLoaded = [];\n    depsToPreLoad.forEach(depToLoad => {\n      if (dependenciesToPreload[depToLoad]) {\n        return;\n      }\n\n      depTobBeLoaded.push(depToLoad);\n    });\n\n    if (depTobBeLoaded.length) {\n      let depModuleObjs = await moduleLoader.loadDependentModules(depTobBeLoaded);\n\n      if (depModuleObjs) {\n        _.forEach(depModuleObjs, (value, key) => {\n          dependenciesToPreload['js/' + key] = value;\n        });\n      }\n    }\n\n    return dependenciesToPreload;\n  };\n\n  let depsToLoad = _.get(declViewModel, DEPS_TO_LOAD);\n\n  if (depsToLoad) {\n    getDeps(depsToLoad).then(deps => {\n      setPreLoadedDepsOnVM(declViewModel, deps);\n    });\n  }\n};\n\nconst highlightView = eventData => {\n  const isViewElement = element => {\n    return element.classList.contains('aw-widgets-droppable');\n  };\n\n  if (!_.isUndefined(eventData) && !_.isUndefined(eventData.targetElement) && isViewElement(eventData.targetElement)) {\n    var isHighlightFlag = eventData.isHighlightFlag;\n    var target = eventData.targetElement;\n\n    if (isHighlightFlag) {\n      target.classList.add('aw-widgets-dropframe');\n      target.classList.add('aw-theme-dropframe');\n    } else {\n      target.classList.remove('aw-theme-dropframe');\n      target.classList.remove('aw-widgets-dropframe');\n    }\n  }\n};\n\nconst callBackAPIsForView = {\n  highlightTarget: highlightView,\n  getTargetElementAndVmo: event => {\n    let target = eleRef.closest(event.target, '.aw-widgets-droppable');\n    return {\n      targetElement: target,\n      targetVMO: null\n    };\n  }\n}; //  fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );\n\nexport const setViewDnd = function (dndHandlers) {\n  var obj = {};\n\n  let callBackForView = event => {\n    let target = eleRef.closest(event.target, '.aw-widgets-droppable');\n\n    if (dndHandlers && dndHandlers[event.type]) {\n      let fun = dndHandlers[event.type];\n      fun(event, {\n        targetElement: target,\n        targetVMO: []\n      }, callBackAPIsForView, null);\n    }\n  };\n\n  Object.keys(dndHandlers).forEach(providerName => {\n    obj[dndAttr[providerName]] = callBackForView;\n  });\n  return obj;\n};\n\nconst initialization = () => {\n  loadConfiguration();\n  createDragAndDropHandlersMap(); //Attach event listner to block the drop effect on the page for files\n  //attachDocEventListners();\n};\n\ninitialization();\nexports = {\n  updateDeps,\n  setupDragAndDropOnView,\n  setupDragAndDrop,\n  getDragHandler,\n  getDropHandler,\n  areDnDHandelersDefined,\n  setDragAndDropHandlersOnVM,\n  initialization,\n  // exporting this method so that this service is testable\n  setViewDnd\n};\nexport default exports;","map":{"version":3,"names":["cfgSvc","moduleLoader","_","actionService","appCtxSvc","conditionSvc","logger","domUtils","awConfiguration","eleRef","DOMAPIs","exports","PRE_LOADED_DEPS","DRAG_HANDLERS","DROP_HANDLERS","DEPS_TO_LOAD","dndAttr","dragstart","dragenter","dragleave","dragover","drop","dragend","defaultDragHandler","defaultDropHandler","dragDropConfig","viewHandlersMap","Map","loadConfiguration","getCfgCached","defaultDragAndDropConfig","get","dragHandler","dropHandler","createDragAndDropHandlersMap","setViewHandlers","viewName","handlerDef","handlerkey","key","has","set","dragHandlers","dropHandlers","def","obj","forOwn","value","hkey","toLowerCase","viewHandlerDef","condition","handlers","activeWhen","push","processHandlers","forEach","handlerName","views","getTargetEleAndVMOs","event","callbackAPIs","target","isSourceEle","type","getTargetElementAndVmo","targetElement","targetObjects","targetVMO","getAction","declViewModel","actionName","dragAndDropInput","action","actionId","inputData","dndParams","evaluateActiveWhen","handlerObj","dragAndDropConfig","dataProviders","Object","keys","length","evaluateConditionExpression","data","ctx","clauseName","conditionList","attachDocEventListners","setDropEffect","stopPropagation","preventDefault","dataTransfer","dropEffect","document","addEventListener","setDragAndDropHandlersOnVM","path","activeHandlerActions","actionsDefs","setDnDActionsOnVM","handlerActions","declVmActions","assign","getHandlerActionsAndDepsToLoad","depsToLoad","actionDef","found","some","dep","deps","handlerDeps","Set","processDnDEvent","effectAllowed","isEmpty","setDragImage","dragImage","xOffset","yOffset","areDnDHandelersDefined","dragProviders","dropProviders","setupDragAndDrop","declObj","getProps","processDnDParamsAndGetCtxNode","dataProvider","dataCtxNode","props","vmo","dragAndDropParams","executeHandler","handlerAction","error","depModuleObj","retData","performActionSync","getEventCallbackFn","nodeName","_swDragging","dndHandler","createCallback","eventType","callBackFn","bind","createEventListener","providers","providerName","setupDragAndDropOnView","activeHandler","currentViewName","isHandlerActiveForView","handlerType","attachDefaultHandler","handlerPath","handlerActionKey","handler","actions","isDragHandlerActive","isDropHandlerActive","getDragHandler","getDropHandler","updateDeps","setPreLoadedDepsOnVM","loadedDeps","_internal","preLoadedDeps","getDeps","depsToPreLoad","dependenciesToPreload","depTobBeLoaded","depToLoad","depModuleObjs","loadDependentModules","then","highlightView","eventData","isViewElement","element","classList","contains","isUndefined","isHighlightFlag","add","remove","callBackAPIsForView","highlightTarget","closest","setViewDnd","dndHandlers","callBackForView","fun","initialization"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/declDragAndDropService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is responsible to process drag and drop handlers on the declViewModel if drag and\n * drop configuration is defined for that particular view.\n * It is also responsible to attach the drag and drop listners to applicable views and widgets.\n *\n * @module js/declDragAndDropService\n */\n\nimport cfgSvc from 'js/configurationService';\nimport moduleLoader from 'js/moduleLoader';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport appCtxSvc from 'js/appCtxService';\nimport conditionSvc from 'js/conditionService';\nimport logger from 'js/logger';\nimport domUtils from 'js/domUtils';\nimport awConfiguration from 'js/awConfiguration';\nconst eleRef = domUtils.DOMAPIs;\n\nlet exports;\n\nconst PRE_LOADED_DEPS = '_internal.preLoadedDeps';\nconst DRAG_HANDLERS = '_internal.dragHandlers';\nconst DROP_HANDLERS = '_internal.dropHandlers';\nconst DEPS_TO_LOAD = '_internal.depsToLoad';\n\nconst dndAttr = {\n    dragstart: 'onDrag',\n    dragenter: 'onDragEnter',\n    dragleave: 'onDragLeave',\n    dragover: 'onDragOver',\n    drop: 'onDrop',\n    dragend: 'onDragEnd'\n};\n\nlet defaultDragHandler = null;\nlet defaultDropHandler = null;\nlet dragDropConfig = null;\nlet viewHandlersMap = new Map();\n\nconst loadConfiguration = () => {\n    /*\n     * Get the drag and drop configuration\n     */\n    dragDropConfig = cfgSvc.getCfgCached( 'dragAndDrop' );\n    let defaultDragAndDropConfig = awConfiguration.get( 'solutionDef.defaultDragAndDropHandlers' );\n    if( defaultDragAndDropConfig && defaultDragAndDropConfig !== '{{defaultDragAndDropHandlers}}' ) {\n        defaultDragHandler = defaultDragAndDropConfig.dragHandler !== '' ? defaultDragAndDropConfig.dragHandler : null;\n        defaultDropHandler = defaultDragAndDropConfig.dropHandler !== '' ? defaultDragAndDropConfig.dropHandler : null;\n    }\n};\n\nconst createDragAndDropHandlersMap = () => {\n    const setViewHandlers = ( viewName, handlerDef, handlerkey ) => {\n        let key = handlerkey === 'dragActions' ? 'dragHandlers' : 'dropHandlers';\n\n        if( !viewHandlersMap.has( viewName ) ) {\n            viewHandlersMap.set( viewName, {\n                dragHandlers: [],\n                dropHandlers: []\n            } );\n        }\n        let def = viewHandlersMap.get( viewName );\n\n        let obj = {};\n\n        _.forOwn( handlerDef[ handlerkey ], function( value, hkey ) {\n            obj[ hkey.toLowerCase() ] = value;\n        } );\n\n        let viewHandlerDef = {\n            condition: {},\n            handlers: obj\n        };\n        if( handlerDef.activeWhen ) {\n            viewHandlerDef.condition.activeWhen = handlerDef.activeWhen;\n        }\n        def[ key ].push( viewHandlerDef );\n    };\n\n    const processHandlers = ( handlers, handlerkey ) => {\n        _.forEach( handlers, ( handlerDef, handlerName ) => {\n            if( handlerName === defaultDragHandler || handlerName === defaultDropHandler ) {\n                return;\n            }\n            _.forEach( handlerDef.views, ( viewName ) => {\n                setViewHandlers( viewName, handlerDef, handlerkey );\n            } );\n        } );\n    };\n    if( dragDropConfig ) {\n        let handlers = dragDropConfig.dragHandlers;\n        processHandlers( handlers, 'dragActions' );\n        handlers = dragDropConfig.dropHandlers;\n        processHandlers( handlers, 'dropActions' );\n    }\n};\n\nconst getTargetEleAndVMOs = ( event, callbackAPIs ) => {\n    let target = {};\n    let isSourceEle = event.type === 'dragstart';\n    if( callbackAPIs.getTargetElementAndVmo ) {\n        target = callbackAPIs.getTargetElementAndVmo( event, isSourceEle );\n    }\n    return {\n        targetElement: target.targetElement,\n        targetObjects: target.targetVMO\n    };\n};\n\nconst getAction = ( declViewModel, actionName ) => {\n    const dragAndDropInput = '{{dragAndDropParams}}';\n    let action = _.get( declViewModel, '_internal.actions.' + actionName );\n\n    if( action ) {\n        //adding actionId ref to action object for consistency with declViewModel actions\n        action.actionId = actionName;\n        if( !action.inputData ) {\n            _.set( action, 'inputData', { dndParams: dragAndDropInput } );\n        } else {\n            let inputData = { ...action.inputData, dndParams: dragAndDropInput };\n            _.set( action, 'inputData', inputData );\n        }\n        return action;\n    }\n    return null;\n};\n\nconst evaluateActiveWhen = ( handlerObj, dragAndDropConfig, declViewModel ) => {\n    if( handlerObj.condition ) {\n        handlerObj = handlerObj.condition;\n    }\n    if( !handlerObj.activeWhen ) {\n        return true;\n    }\n\n    if( declViewModel.dataProviders && Object.keys( declViewModel.dataProviders ).length === 0 ) {\n        declViewModel.dataProviders = null;\n    }\n    return conditionSvc.evaluateConditionExpression( handlerObj, { data: declViewModel, ctx: appCtxSvc.ctx }, { clauseName: 'activeWhen', conditionList: dragAndDropConfig } );\n};\n\n/*\n * Attaching dragenter, dragover and drop listners at the document level\n * These listners are mainly required for file drag and drop. Whenever a file is dragged from Os to the browser, by\n * default the effectAllowed property that is set by OS(defaults to copy/move depending on the file type) will be set\n * as the dropEffect.\n * So as soon as the file is dragged on browser, the default dropEffect would be enabled(copy/move) and thus drop is enabled\n * if the no events listners for drag and drop are defined for the particular part of the page. Further the default browser behavior\n * to open the dropped file would be performed.\n *\n * These listners basically set the drop effect to false during dragenter and dragover phase, thus preventing drop.\n *\n * Note: A file specific check is not added during dragenter and dragover phase as doing so would lead to undefined dropEffect\n * state(instead of block) for objects that are being dragged on non-droppable drop areas.\n */\nconst attachDocEventListners = () => {\n    const setDropEffect = ( event ) => {\n        event.stopPropagation();\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'none';\n    };\n    document.addEventListener( 'dragover', setDropEffect );\n    document.addEventListener( 'dragenter', setDropEffect );\n    document.addEventListener( 'drop', setDropEffect );\n};\n\nconst setDragAndDropHandlersOnVM = ( declViewModel, path, activeHandlerActions, actionsDefs ) => {\n    const setDnDActionsOnVM = ( declViewModel, handlerActions ) => {\n        let declVmActions = _.get( declViewModel, '_internal.actions' );\n        if( !declVmActions ) {\n            _.set( declViewModel, '_internal.actions', handlerActions );\n        } else {\n            Object.assign( declVmActions, handlerActions );\n        }\n    };\n\n    const getHandlerActionsAndDepsToLoad = ( activeHandlerActions ) => {\n        let depsToLoad = [];\n        let handlerActions = {};\n        _.forEach( activeHandlerActions, ( actionName ) => {\n            let actionDef = actionsDefs[ actionName ];\n            if( !actionDef ) {\n                return;\n            }\n            handlerActions[ actionName ] = actionDef;\n            let found = depsToLoad.some( ( dep ) => dep === actionDef.deps );\n            if( !found ) {\n                depsToLoad.push( actionDef.deps );\n            }\n        } );\n        return {\n            handlerActions,\n            depsToLoad\n        };\n    };\n\n    //Set drag and drop handler references on the declViewModel\n    //These handler references will be used by widgets to setup drag and drop\n    _.set( declViewModel, path, activeHandlerActions );\n\n    let handlers = getHandlerActionsAndDepsToLoad( activeHandlerActions );\n\n    setDnDActionsOnVM( declViewModel, handlers.handlerActions );\n\n    let handlerDeps = _.get( declViewModel, DEPS_TO_LOAD ) ? _.get( declViewModel, DEPS_TO_LOAD ) : [];\n    handlerDeps = [ ...new Set( [ ...handlerDeps, ...handlers.depsToLoad ] ) ];\n    _.set( declViewModel, DEPS_TO_LOAD, handlerDeps );\n};\n\nconst processDnDEvent = ( data, event ) => {\n    if( data.effectAllowed ) {\n        event.dataTransfer.effectAllowed = data.effectAllowed;\n    }\n\n    if( data.dropEffect ) {\n        event.dataTransfer.dropEffect = data.dropEffect;\n    }\n\n    if( data.preventDefault ) {\n        event.preventDefault();\n    }\n\n    if( data.stopPropagation ) {\n        event.stopPropagation();\n    }\n\n    if( !_.isEmpty( data.setDragImage ) ) {\n        event.dataTransfer.setDragImage( data.setDragImage.dragImage, data.setDragImage.xOffset, data.setDragImage.yOffset );\n    }\n};\n\nexport const areDnDHandelersDefined = function( declViewModel ) {\n    let dragProviders = _.get( declViewModel, DRAG_HANDLERS );\n    let dropProviders = _.get( declViewModel, DROP_HANDLERS );\n    return dragProviders || dropProviders;\n};\n\n/**\n * Setup drag and drop listners on the element if drag and drophandlers are defined on the declViewModel\n * @param {Element} element: The DOM element on which the drag and drop listeners are to be attached.\n *\n * @param {Object} callbackAPIs:Callback functions used for various reasons of interaction with the\n *            container(element).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @param {Object} dataProvider: The dataProvider associated with the widget(if applicable)\n */\nexport const setupDragAndDrop = function( declViewModel, declObj, getProps ) {\n    let dragProviders = _.get( declViewModel, DRAG_HANDLERS );\n    let dropProviders = _.get( declViewModel, DROP_HANDLERS );\n    const processDnDParamsAndGetCtxNode = ( declViewModel, event, target, callbackAPIs, dataProvider ) => {\n        let dataCtxNode = { ...declObj, props: getProps() };\n        let obj = [];\n        if( target.targetVMO && target.targetVMO.length > 0 ) {\n            obj = target.targetVMO;\n        } else if( declViewModel.vmo ) {\n            obj = [ declViewModel.vmo ];\n        }\n        if( !dataCtxNode ) {\n            dataCtxNode = {};\n        }\n        dataCtxNode.dragAndDropParams = {\n            event: event,\n            targetElement: target.targetElement,\n            targetObjects: obj,\n            declViewModel,\n            callbackAPIs,\n            dataProvider\n        };\n        return dataCtxNode;\n    };\n    const executeHandler = ( declViewModel, handlerAction, dataCtxNode, event ) => {\n        let action = getAction( declViewModel, handlerAction );\n        if( !action ) {\n            logger.error( 'Missing action definition for ' + handlerAction );\n            return;\n        }\n        let depModuleObj = _.get( declViewModel, PRE_LOADED_DEPS );\n        let retData = actionService.performActionSync( declViewModel, action, dataCtxNode, depModuleObj[ action.deps ] );\n        if( retData ) {\n            processDnDEvent( retData, event );\n        }\n    };\n    const getEventCallbackFn = ( handlerAction, event, target = {}, callbackAPIs, dataProvider ) => {\n        if( target.targetElement && target.targetElement.nodeName.toLowerCase() !== 'aw-include' ) {\n            event.stopPropagation();\n        }\n        //setting a flag on declVM indicate that a that an element from it is being dragged\n        //This is mainly required to prevent selection of a list cell the list when it is dragged\n        if( event.type === 'dragstart' ) {\n            declViewModel._swDragging = true;\n        }\n        if( ( event.type === 'dragend' || event.type === 'drop' ) && declViewModel._swDragging ) {\n            delete declViewModel._swDragging;\n        }\n        let dataCtxNode = processDnDParamsAndGetCtxNode( declViewModel, event, target, callbackAPIs, dataProvider );\n        if( handlerAction && handlerAction !== '' ) {\n            executeHandler( declViewModel, handlerAction, dataCtxNode, event );\n        }\n    };\n    let dndHandler = null;\n    if( dragProviders || dropProviders ) {\n        dndHandler = {};\n        const createCallback = ( eventType, handlerAction ) => {\n            let callBackFn = getEventCallbackFn.bind( null, handlerAction );\n            dndHandler[ eventType ] = callBackFn;\n        };\n        const createEventListener = ( providers ) => {\n            Object.keys( providers ).forEach( ( providerName ) => {\n                createCallback( providerName.toLowerCase(), providers[ providerName ] );\n            } );\n        };\n        if( dragProviders ) {\n            createEventListener( dragProviders );\n        }\n        if( dropProviders ) {\n            createEventListener( dropProviders );\n        }\n    }\n    declViewModel.dndHandler = dndHandler;\n};\n\n/**\n * Process the active drag and drop handlers on the declViewModel, if any. Also sets up the drag and drop\n * listners of the view element if active drop handler is found.\n * lement).\n *\n * @param {Object} declViewModel: The declarative viewmodel object of the corresponding to the element\n *\n * @returns {Boolean} Returns whether or not active drop handler is defined for the view.\n */\nexport const setupDragAndDropOnView = function( declViewModel ) {\n    let activeHandler = null;\n    if( !dragDropConfig ) {\n        return false;\n    }\n    let currentViewName = _.get( declViewModel, '_internal.viewId' );\n    const isHandlerActiveForView = ( viewName, handlerType ) => {\n        let handlers = viewHandlersMap.get( viewName );\n        if( handlers && handlers[ handlerType ].length ) {\n            return handlers[ handlerType ].some( ( handlerObj ) => {\n                if( evaluateActiveWhen( handlerObj, dragDropConfig, declViewModel ) ) {\n                    activeHandler = handlerObj;\n                    return true;\n                }\n                return false;\n            } );\n        }\n        return false;\n    };\n    const attachDefaultHandler = ( handlerPath, handlerName, handlerActionKey ) => {\n        let handler = _.get( dragDropConfig, handlerName );\n        if( handler && handler.views[ 0 ] === '*' && evaluateActiveWhen( handler, dragDropConfig, declViewModel ) ) {\n            setDragAndDropHandlersOnVM( declViewModel, handlerPath, handler[ handlerActionKey ], dragDropConfig.actions );\n        }\n    };\n    let isDragHandlerActive = isHandlerActiveForView( currentViewName, 'dragHandlers' );\n    if( isDragHandlerActive && activeHandler ) {\n        setDragAndDropHandlersOnVM( declViewModel, DRAG_HANDLERS, activeHandler.handlers, dragDropConfig.actions );\n    } else if( !isDragHandlerActive && defaultDragHandler ) {\n        attachDefaultHandler( DRAG_HANDLERS, 'dragHandlers.' + defaultDragHandler, 'dragActions' );\n    }\n    activeHandler = null;\n    let isDropHandlerActive = isHandlerActiveForView( currentViewName, 'dropHandlers' );\n    if( isDropHandlerActive && activeHandler ) {\n        setDragAndDropHandlersOnVM( declViewModel, DROP_HANDLERS, activeHandler.handlers, dragDropConfig.actions );\n    } else if( !isDropHandlerActive && defaultDropHandler ) {\n        attachDefaultHandler( DROP_HANDLERS, 'dropHandlers.' + defaultDropHandler, 'dropActions' );\n    }\n    return true;\n};\n\nexport const getDragHandler = function( declViewModel ) {\n    return _.get( declViewModel, DRAG_HANDLERS );\n};\n\nexport const getDropHandler = function( declViewModel ) {\n    return _.get( declViewModel, DROP_HANDLERS );\n};\n\nexport const updateDeps = function( declViewModel ) {\n    const setPreLoadedDepsOnVM = ( declViewModel, deps ) => {\n        let loadedDeps = _.get( declViewModel, PRE_LOADED_DEPS );\n        if( !loadedDeps ) {\n            _.set( declViewModel, PRE_LOADED_DEPS, deps );\n        } else {\n            Object.assign( declViewModel._internal.preLoadedDeps, deps );\n        }\n    };\n\n    const getDeps = async( depsToPreLoad ) => {\n        let dependenciesToPreload = {};\n        let depTobBeLoaded = [];\n\n        depsToPreLoad.forEach( ( depToLoad ) => {\n            if( dependenciesToPreload[ depToLoad ] ) {\n                return;\n            }\n            depTobBeLoaded.push( depToLoad );\n        } );\n\n        if( depTobBeLoaded.length ) {\n            let depModuleObjs = await moduleLoader.loadDependentModules( depTobBeLoaded );\n            if( depModuleObjs ) {\n                _.forEach( depModuleObjs, ( value, key ) => {\n                    dependenciesToPreload[ 'js/' + key ] = value;\n                } );\n            }\n        }\n        return dependenciesToPreload;\n    };\n    let depsToLoad = _.get( declViewModel, DEPS_TO_LOAD );\n    if( depsToLoad ) {\n        getDeps( depsToLoad ).then( ( deps ) => {\n            setPreLoadedDepsOnVM( declViewModel, deps );\n        } );\n    }\n};\n\nconst highlightView = ( eventData ) => {\n    const isViewElement = ( element ) => {\n        return element.classList.contains( 'aw-widgets-droppable' );\n    };\n    if( !_.isUndefined( eventData ) && !_.isUndefined( eventData.targetElement ) && isViewElement( eventData.targetElement ) ) {\n        var isHighlightFlag = eventData.isHighlightFlag;\n        var target = eventData.targetElement;\n        if( isHighlightFlag ) {\n            target.classList.add( 'aw-widgets-dropframe' );\n            target.classList.add( 'aw-theme-dropframe' );\n        } else {\n            target.classList.remove( 'aw-theme-dropframe' );\n            target.classList.remove( 'aw-widgets-dropframe' );\n        }\n    }\n};\n\nconst callBackAPIsForView = {\n    highlightTarget: highlightView,\n    getTargetElementAndVmo: ( event ) => {\n        let target = eleRef.closest( event.target, '.aw-widgets-droppable' );\n        return {\n            targetElement: target,\n            targetVMO: null\n        };\n    }\n};\n\n//  fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );\nexport const setViewDnd = function( dndHandlers ) {\n    var obj = {};\n    let callBackForView = ( event ) => {\n        let target = eleRef.closest( event.target, '.aw-widgets-droppable' );\n        if( dndHandlers && dndHandlers[ event.type ] ) {\n            let fun = dndHandlers[ event.type ];\n            fun( event, { targetElement: target, targetVMO: [] }, callBackAPIsForView, null );\n        }\n    };\n    Object.keys( dndHandlers ).forEach( ( providerName ) => {\n        obj[ dndAttr[ providerName ] ] = callBackForView;\n    } );\n    return obj;\n};\n\nconst initialization = () => {\n    loadConfiguration();\n    createDragAndDropHandlersMap();\n    //Attach event listner to block the drop effect on the page for files\n    //attachDocEventListners();\n};\ninitialization();\n\nexports = {\n    updateDeps,\n    setupDragAndDropOnView,\n    setupDragAndDrop,\n    getDragHandler,\n    getDropHandler,\n    areDnDHandelersDefined,\n    setDragAndDropHandlersOnVM,\n    initialization, // exporting this method so that this service is testable\n    setViewDnd\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}