{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/preferenceService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport soaSvc from 'soa/kernel/soaService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport eventBus from 'js/eventBus';\nimport appCtxSvc from 'js/appCtxService';\nimport messagingService from 'js/messagingService';\nvar exports = {};\n/**\n * @private\n */\n\nvar _prefName2preference = {}; // Preference types: 0 = String, 1 = Logical, 2 = Integer, 3 = Double, 4 = Date\n\n/**\n * TRUE if bulk preferences are loaded\n *\n * @private\n */\n\nvar _areBulkPreferencesLoaded = false;\n/**\n * Stores all the bulk load entries\n *\n * @private\n */\n\nvar _bulkLoadPreferences = [];\n/**\n * Stores listener to appCtx.update\n *\n * @private\n */\n\nvar _onAppCtxUpdateListener = null;\n/**\n * @param {Object} context - context return from appCtx.updatePartialCtx\n */\n\nfunction onCtxPartialUpdateHandler(context) {\n  if (context.name === 'preferences') {\n    exports.setStringValue(context.target, context.value[context.name][context.target]);\n  }\n}\n/**\n * This is the method which conditionally calls the server for the preference values.\n *\n * @param {StringArray} names - Array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise} promise\n * @private\n */\n\n\nfunction getPrefs(names, bulkCache) {\n  names.sort(); // debug help only\n\n  if (bulkCache) {\n    _bulkLoadPreferences = names;\n    return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'getPreferences', {\n      preferenceNames: names,\n      includePreferenceDescriptions: false\n    }, {}).then(function (result) {\n      if (result && result.response) {\n        if (_onAppCtxUpdateListener) {\n          eventBus.unsubscribe(_onAppCtxUpdateListener);\n        }\n\n        var prefCtx = {};\n\n        _.forEach(result.response, function (pref) {\n          // clean up unused stuff...\n          if (pref.definition) {\n            delete pref.definition.category;\n            delete pref.definition.protectionScope;\n            delete pref.definition.isOOTBPreference;\n            delete pref.definition.isEnvEnabled;\n            delete pref.definition.isDisabled;\n            delete pref.definition.description;\n          }\n\n          if (pref.values) {\n            delete pref.values.valueOrigination;\n          } // Remove the preferences from the list which have been fetched successfully\n\n\n          _bulkLoadPreferences.splice(_bulkLoadPreferences.indexOf(pref.definition.name), 1); // store\n\n\n          _prefName2preference[pref.definition.name] = pref;\n\n          if (pref.values.values) {\n            prefCtx[pref.definition.name] = pref.values.values;\n          }\n        });\n\n        appCtxSvc.updateCtx('preferences', prefCtx);\n\n        if (_onAppCtxUpdateListener) {\n          _onAppCtxUpdateListener = eventBus.subscribe('appCtx.update', onCtxPartialUpdateHandler);\n        } // Fill the remaining preferences(returned from server as part of partial errors) with null values into the cache\n\n\n        _.forEach(_bulkLoadPreferences, function (pref) {\n          var defaultPreferenceValJson = {\n            definition: {\n              name: pref\n            },\n            values: {\n              values: [null]\n            }\n          };\n          _prefName2preference[pref] = defaultPreferenceValJson;\n        });\n\n        _areBulkPreferencesLoaded = true; // Empty the list after processing\n\n        _bulkLoadPreferences = [];\n        eventBus.publish('bulkPreferencesLoaded', {});\n      }\n\n      var timeoutPref = _prefName2preference.AWC_Notification_Timeout;\n\n      if (timeoutPref && timeoutPref.definition.name === 'AWC_Notification_Timeout' && timeoutPref.values && timeoutPref.values.values && timeoutPref.values.values.length > 0) {\n        var prefTimeout = timeoutPref.values.values[0];\n\n        if (!isNaN(prefTimeout) && prefTimeout.trim() !== '') {\n          var timeout = 0;\n\n          if (prefTimeout > 0) {\n            timeout = prefTimeout;\n          } // this sets the info to the value from preference and error * 10, which is what used to happen earlier\n\n\n          messagingService.setTimeout('INFO', timeout);\n        }\n      }\n\n      const pollingTimeout = _.get(_prefName2preference, 'AWC_Polling_Timeout.values.values[0]');\n\n      soaSvc.setPollingTimeout(_.toNumber(pollingTimeout));\n      return _prefName2preference;\n    });\n  } // using cached value for preferences\n\n\n  return AwPromiseService.instance.resolve(_prefName2preference);\n}\n/**\n * This is the method calls the server to set the preference values.\n *\n * @param {Object} prefName2Values - map of preference name to preference values\n * @return {Promise} promise\n * @private\n */\n\n\nfunction setPrefs(prefName2Values) {\n  var body = {\n    preferenceInput: []\n  };\n\n  _.forEach(prefName2Values, function (values, name) {\n    var pref = _prefName2preference[name]; // Remove the null entries from values array if any\n\n    _.forEach(values, function (value) {\n      if (value === null) {\n        values.splice(values.indexOf(value), 1);\n      }\n    });\n\n    if (!pref || !_.isEqual(pref.values.values, values)) {\n      body.preferenceInput.push({\n        preferenceName: name,\n        values: values\n      });\n    }\n  });\n\n  if (body.preferenceInput.length === 0) {\n    // using cached value for preferences\n    // no server call required\n    return AwPromiseService.instance.resolve(null);\n  }\n\n  return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'setPreferences2', body, {}).then(function () {\n    // Update the client side cache for the successfully set preference\n    _.forEach(prefName2Values, function (values, name) {\n      var pref = _prefName2preference[name];\n\n      if (pref) {\n        pref.values.values = values;\n      }\n    }); // nothing to return\n\n\n    return null;\n  });\n}\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\n\n\nexport let getStringValue = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      return pref.values.values[0];\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let getStringValues = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      return pref.values.values;\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} names - array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise.<Object>} promise will resolve to the preference string array value\n */\n\nexport let getMultiStringValues = function (names, bulkCache) {\n  return getPrefs(names, bulkCache).then(function (prefName2preference) {\n    var response = {};\n\n    _.forEach(names, function (name) {\n      var pref = prefName2preference[name];\n\n      if (pref) {\n        response[name] = pref.values.values;\n      }\n    });\n\n    return response;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference logical value\n */\n\nexport let getLogicalValue = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      assert(pref.definition.type === 1, 'Querying logical value for a non-string preference');\n      assert(!pref.definition.isArray, 'Querying logical value for array preference');\n      return pref.values.values[0];\n    }\n\n    return null;\n  });\n};\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference logical array value\n */\n\nexport let getLogicalValues = function (name) {\n  return getPrefs([name]).then(function (prefName2preference) {\n    var pref = prefName2preference[name];\n\n    if (pref && pref.values && pref.values.values && pref.values.values.length > 0) {\n      assert(pref.definition.type === 1, 'Querying logical values for a non-string preference');\n      assert(pref.definition.isArray, 'Querying logical values for a non-array preference');\n      return pref.values.values;\n    }\n\n    return null;\n  });\n};\n/**\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let queryAll = function () {\n  return getPrefs(['*']).then(function (prefName2preference) {\n    return prefName2preference;\n  });\n};\n/**\n * This is the method which calls the server to get all preference values that can be modified by the current user\n *\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\n\nexport let getExpandedPrefs = function () {\n  return soaSvc.postUnchecked('Administration-2012-09-PreferenceManagement', 'getPreferences', {\n    preferenceNames: ['*'],\n    includePreferenceDescriptions: true\n  }, {}).then(function (result) {\n    /**\n     * Checks to see if a preference has a user created version of it that should override it.\n     *\n     * @param {String} name - Name to check.\n     * @param {String} origin - Origin of the preference.\n     *\n     * @returns {Booolean} TRUE if a preference has a user created version of it that should override it.\n     */\n    function uniqueUserPref(name, origin) {\n      if (origin === 'User') {\n        return true;\n      }\n\n      for (var i in result.response) {\n        if (result.response[i].definition.name === name && result.response[i].values.valueOrigination !== origin) {\n          return false; // we want the user preference to override the other preference\n        }\n      }\n\n      return true;\n    }\n\n    for (var i = 0; i < result.response.length; i++) {\n      if (!uniqueUserPref(result.response[i].definition.name, result.response[i].values.valueOrigination)) {\n        result.response.splice(i, 1);\n        i--;\n      }\n    }\n\n    return result.response;\n  });\n};\n/**\n * @param {String} name - preference name\n * @param {StringArray} value - preference values\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\n\nexport let setStringValue = function (name, value) {\n  var input = {};\n  input[name] = value;\n  return setPrefs(input);\n};\n/**\n * @param {StringArray} names - array of preference name\n * @param {StringArrayArray} values - array of preference values\n * @return {Promise.<StringArray>} promise will resolve to the preference string value\n */\n\nexport let setStringValues = function (names, values) {\n  var input = {};\n\n  for (var ii = 0; ii < names.length; ii++) {\n    input[names[ii]] = values[ii];\n  }\n\n  return setPrefs(input);\n};\n/**\n * @return {boolean} areBulkPreferencesLoaded\n */\n\nexport let areBulkPreferencesLoaded = function () {\n  return _areBulkPreferencesLoaded;\n};\n/**\n * Get any preferences that are already loaded. Primarily used for when a sync check of a preference is necessary.\n *\n * @return {Object} The currently loaded preferences. Key is name, value is value list.\n */\n\nexport let getLoadedPrefs = function () {\n  var loadedPrefs = {};\n\n  for (var i in _prefName2preference) {\n    // TODO: Could use definition to format pref somehow\n    // For now just make sure everything is an array\n    loadedPrefs[i] = _prefName2preference[i].values.values ? _prefName2preference[i].values.values : [];\n  }\n\n  return loadedPrefs;\n};\n_onAppCtxUpdateListener = eventBus.subscribe('appCtx.update', onCtxPartialUpdateHandler);\nexports = {\n  getStringValue,\n  getStringValues,\n  getMultiStringValues,\n  getLogicalValue,\n  getLogicalValues,\n  queryAll,\n  getExpandedPrefs,\n  setStringValue,\n  setStringValues,\n  areBulkPreferencesLoaded,\n  getLoadedPrefs\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","soaSvc","_","assert","eventBus","appCtxSvc","messagingService","exports","_prefName2preference","_areBulkPreferencesLoaded","_bulkLoadPreferences","_onAppCtxUpdateListener","onCtxPartialUpdateHandler","context","name","setStringValue","target","value","getPrefs","names","bulkCache","sort","postUnchecked","preferenceNames","includePreferenceDescriptions","then","result","response","unsubscribe","prefCtx","forEach","pref","definition","category","protectionScope","isOOTBPreference","isEnvEnabled","isDisabled","description","values","valueOrigination","splice","indexOf","updateCtx","subscribe","defaultPreferenceValJson","publish","timeoutPref","AWC_Notification_Timeout","length","prefTimeout","isNaN","trim","timeout","setTimeout","pollingTimeout","get","setPollingTimeout","toNumber","instance","resolve","setPrefs","prefName2Values","body","preferenceInput","isEqual","push","preferenceName","getStringValue","prefName2preference","getStringValues","getMultiStringValues","getLogicalValue","type","isArray","getLogicalValues","queryAll","getExpandedPrefs","uniqueUserPref","origin","i","input","setStringValues","ii","areBulkPreferencesLoaded","getLoadedPrefs","loadedPrefs"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/preferenceService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/preferenceService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport soaSvc from 'soa/kernel/soaService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport eventBus from 'js/eventBus';\n\nimport appCtxSvc from 'js/appCtxService';\nimport messagingService from 'js/messagingService';\n\nvar exports = {};\n\n/**\n * @private\n */\nvar _prefName2preference = {};\n\n// Preference types: 0 = String, 1 = Logical, 2 = Integer, 3 = Double, 4 = Date\n\n/**\n * TRUE if bulk preferences are loaded\n *\n * @private\n */\nvar _areBulkPreferencesLoaded = false;\n\n/**\n * Stores all the bulk load entries\n *\n * @private\n */\nvar _bulkLoadPreferences = [];\n\n/**\n * Stores listener to appCtx.update\n *\n * @private\n */\nvar _onAppCtxUpdateListener = null;\n\n/**\n * @param {Object} context - context return from appCtx.updatePartialCtx\n */\nfunction onCtxPartialUpdateHandler( context ) {\n    if( context.name === 'preferences' ) {\n        exports.setStringValue( context.target, context.value[ context.name ][ context.target ] );\n    }\n}\n\n/**\n * This is the method which conditionally calls the server for the preference values.\n *\n * @param {StringArray} names - Array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise} promise\n * @private\n */\nfunction getPrefs( names, bulkCache ) {\n    names.sort(); // debug help only\n\n    if( bulkCache ) {\n        _bulkLoadPreferences = names;\n        return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'getPreferences', {\n            preferenceNames: names,\n            includePreferenceDescriptions: false\n        }, {} ).then( function( result ) {\n            if( result && result.response ) {\n                if( _onAppCtxUpdateListener ) {\n                    eventBus.unsubscribe( _onAppCtxUpdateListener );\n                }\n\n                var prefCtx = {};\n\n                _.forEach( result.response, function( pref ) {\n                    // clean up unused stuff...\n                    if( pref.definition ) {\n                        delete pref.definition.category;\n                        delete pref.definition.protectionScope;\n                        delete pref.definition.isOOTBPreference;\n                        delete pref.definition.isEnvEnabled;\n                        delete pref.definition.isDisabled;\n                        delete pref.definition.description;\n                    }\n                    if( pref.values ) {\n                        delete pref.values.valueOrigination;\n                    }\n                    // Remove the preferences from the list which have been fetched successfully\n                    _bulkLoadPreferences.splice( _bulkLoadPreferences.indexOf( pref.definition.name ), 1 );\n                    // store\n                    _prefName2preference[ pref.definition.name ] = pref;\n\n                    if( pref.values.values ) {\n                        prefCtx[ pref.definition.name ] = pref.values.values;\n                    }\n                } );\n\n                appCtxSvc.updateCtx( 'preferences', prefCtx );\n\n                if( _onAppCtxUpdateListener ) {\n                    _onAppCtxUpdateListener = eventBus.subscribe( 'appCtx.update', onCtxPartialUpdateHandler );\n                }\n\n                // Fill the remaining preferences(returned from server as part of partial errors) with null values into the cache\n                _.forEach( _bulkLoadPreferences, function( pref ) {\n                    var defaultPreferenceValJson = {\n                        definition: {\n                            name: pref\n                        },\n                        values: {\n                            values: [ null ]\n                        }\n                    };\n                    _prefName2preference[ pref ] = defaultPreferenceValJson;\n                } );\n\n                _areBulkPreferencesLoaded = true;\n                // Empty the list after processing\n                _bulkLoadPreferences = [];\n                eventBus.publish( 'bulkPreferencesLoaded', {} );\n            }\n\n            var timeoutPref = _prefName2preference.AWC_Notification_Timeout;\n            if( timeoutPref &&\n                timeoutPref.definition.name === 'AWC_Notification_Timeout' &&\n                timeoutPref.values && timeoutPref.values.values && timeoutPref.values.values.length > 0 ) {\n                var prefTimeout = timeoutPref.values.values[ 0 ];\n                if( !isNaN( prefTimeout ) && prefTimeout.trim() !== '' ) {\n                    var timeout = 0;\n                    if( prefTimeout > 0 ) {\n                        timeout = prefTimeout;\n                    }\n                    // this sets the info to the value from preference and error * 10, which is what used to happen earlier\n                    messagingService.setTimeout( 'INFO', timeout );\n                }\n            }\n\n            const pollingTimeout = _.get( _prefName2preference, 'AWC_Polling_Timeout.values.values[0]' );\n            soaSvc.setPollingTimeout( _.toNumber( pollingTimeout ) );\n\n            return _prefName2preference;\n        } );\n    }\n\n    // using cached value for preferences\n    return AwPromiseService.instance.resolve( _prefName2preference );\n}\n\n/**\n * This is the method calls the server to set the preference values.\n *\n * @param {Object} prefName2Values - map of preference name to preference values\n * @return {Promise} promise\n * @private\n */\nfunction setPrefs( prefName2Values ) {\n    var body = {\n        preferenceInput: []\n    };\n\n    _.forEach( prefName2Values, function( values, name ) {\n        var pref = _prefName2preference[ name ];\n        // Remove the null entries from values array if any\n        _.forEach( values, function( value ) {\n            if( value === null ) {\n                values.splice( values.indexOf( value ), 1 );\n            }\n        } );\n        if( !pref || !_.isEqual( pref.values.values, values ) ) {\n            body.preferenceInput.push( {\n                preferenceName: name,\n                values: values\n            } );\n        }\n    } );\n\n    if( body.preferenceInput.length === 0 ) {\n        // using cached value for preferences\n        // no server call required\n        return AwPromiseService.instance.resolve( null );\n    }\n\n    return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'setPreferences2', body, {} ).then(\n        function() {\n            // Update the client side cache for the successfully set preference\n            _.forEach( prefName2Values, function( values, name ) {\n                var pref = _prefName2preference[ name ];\n                if( pref ) {\n                    pref.values.values = values;\n                }\n            } );\n            // nothing to return\n            return null;\n        } );\n}\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\nexport let getStringValue = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            return pref.values.values[ 0 ];\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let getStringValues = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            return pref.values.values;\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} names - array of preference names\n * @param {Boolean} bulkCache - bulk caching call?\n * @return {Promise.<Object>} promise will resolve to the preference string array value\n */\nexport let getMultiStringValues = function( names, bulkCache ) {\n    return getPrefs( names, bulkCache ).then( function( prefName2preference ) {\n        var response = {};\n        _.forEach( names, function( name ) {\n            var pref = prefName2preference[ name ];\n            if( pref ) {\n                response[ name ] = pref.values.values;\n            }\n        } );\n        return response;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<String>} promise will resolve to the preference logical value\n */\nexport let getLogicalValue = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            assert( pref.definition.type === 1, 'Querying logical value for a non-string preference' );\n            assert( !pref.definition.isArray, 'Querying logical value for array preference' );\n            return pref.values.values[ 0 ];\n        }\n        return null;\n    } );\n};\n\n/**\n * @param {String} name - preference name\n * @return {Promise.<StringArray>} promise will resolve to the preference logical array value\n */\nexport let getLogicalValues = function( name ) {\n    return getPrefs( [ name ] ).then( function( prefName2preference ) {\n        var pref = prefName2preference[ name ];\n        if( pref && pref.values && pref.values.values && pref.values.values.length > 0 ) {\n            assert( pref.definition.type === 1, 'Querying logical values for a non-string preference' );\n            assert( pref.definition.isArray, 'Querying logical values for a non-array preference' );\n            return pref.values.values;\n        }\n        return null;\n    } );\n};\n\n/**\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let queryAll = function() {\n    return getPrefs( [ '*' ] ).then( function( prefName2preference ) {\n        return prefName2preference;\n    } );\n};\n\n/**\n * This is the method which calls the server to get all preference values that can be modified by the current user\n *\n * @return {Promise.<StringArray>} promise will resolve to the preference string array value\n */\nexport let getExpandedPrefs = function() {\n    return soaSvc.postUnchecked( 'Administration-2012-09-PreferenceManagement', 'getPreferences', {\n        preferenceNames: [ '*' ],\n        includePreferenceDescriptions: true\n    }, {} )\n        .then(\n            function( result ) {\n                /**\n                 * Checks to see if a preference has a user created version of it that should override it.\n                 *\n                 * @param {String} name - Name to check.\n                 * @param {String} origin - Origin of the preference.\n                 *\n                 * @returns {Booolean} TRUE if a preference has a user created version of it that should override it.\n                 */\n                function uniqueUserPref( name, origin ) {\n                    if( origin === 'User' ) {\n                        return true;\n                    }\n                    for( var i in result.response ) {\n                        if( result.response[ i ].definition.name === name &&\n                            result.response[ i ].values.valueOrigination !== origin ) {\n                            return false; // we want the user preference to override the other preference\n                        }\n                    }\n                    return true;\n                }\n\n                for( var i = 0; i < result.response.length; i++ ) {\n                    if( !uniqueUserPref( result.response[ i ].definition.name,\n                        result.response[ i ].values.valueOrigination ) ) {\n                        result.response.splice( i, 1 );\n                        i--;\n                    }\n                }\n\n                return result.response;\n            } );\n};\n\n/**\n * @param {String} name - preference name\n * @param {StringArray} value - preference values\n * @return {Promise.<String>} promise will resolve to the preference string value\n */\nexport let setStringValue = function( name, value ) {\n    var input = {};\n    input[ name ] = value;\n    return setPrefs( input );\n};\n\n/**\n * @param {StringArray} names - array of preference name\n * @param {StringArrayArray} values - array of preference values\n * @return {Promise.<StringArray>} promise will resolve to the preference string value\n */\nexport let setStringValues = function( names, values ) {\n    var input = {};\n    for( var ii = 0; ii < names.length; ii++ ) {\n        input[ names[ ii ] ] = values[ ii ];\n    }\n    return setPrefs( input );\n};\n\n/**\n * @return {boolean} areBulkPreferencesLoaded\n */\nexport let areBulkPreferencesLoaded = function() {\n    return _areBulkPreferencesLoaded;\n};\n\n/**\n * Get any preferences that are already loaded. Primarily used for when a sync check of a preference is necessary.\n *\n * @return {Object} The currently loaded preferences. Key is name, value is value list.\n */\nexport let getLoadedPrefs = function() {\n    var loadedPrefs = {};\n    for( var i in _prefName2preference ) {\n        // TODO: Could use definition to format pref somehow\n        // For now just make sure everything is an array\n        loadedPrefs[ i ] = _prefName2preference[ i ].values.values ? _prefName2preference[ i ].values.values : [];\n    }\n    return loadedPrefs;\n};\n\n_onAppCtxUpdateListener = eventBus.subscribe( 'appCtx.update', onCtxPartialUpdateHandler );\n\nexports = {\n    getStringValue,\n    getStringValues,\n    getMultiStringValues,\n    getLogicalValue,\n    getLogicalValues,\n    queryAll,\n    getExpandedPrefs,\n    setStringValue,\n    setStringValues,\n    areBulkPreferencesLoaded,\n    getLoadedPrefs\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}