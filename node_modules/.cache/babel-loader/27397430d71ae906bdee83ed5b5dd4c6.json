{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\n/* eslint-disable complexity */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declViewModelService\n *\n * @namespace viewModelService\n */\nimport React, { useState, useMemo, useEffect, createRef, useRef } from 'react';\nimport ReactDOM from 'react-dom';\nimport { reducer } from 'js/store';\nimport { useReducer, useInitHook, useAtomicDataReducer, convertToHtml } from './reactHelper';\nimport { useDerivedState } from 'js/reactAppCtx';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport awDuiLocalizationSvc from 'js/awDuiLocalizationService';\nimport { processViewModel, createDeclViewModel } from 'js/declViewModelProcessingFactory';\nimport { subscribe, unsubscribe, publish } from 'js/eventBus';\nimport viewModelService, { handleRegisteredEvent } from 'js/viewModelService';\nimport conditionService from 'js/conditionService';\nimport { NULLDATE } from 'js/dateTimeService';\nimport _ from 'lodash';\nimport { resolveSubPanelContext, updateI18nTexts } from 'js/viewModelProcessingFactory';\nimport { useDataProviders } from 'js/dataProviderUtils';\nimport { useGrid, useGrids, useGridContext } from 'js/gridProviderUtils';\nimport { usePopups } from 'js/reactPopup';\nimport { useLOVs } from 'js/lovProviderUtils';\nimport { updateValidationSchema, getStateCollection, filterFlatViewModelPropForAtomic, filterFlatViewModelProps } from 'js/propValidationUtils';\nimport { performLOVOperation } from 'js/uwLovDataService';\nimport syncStrategyService from 'js/syncStrategyService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { useSelectionModels } from 'js/declSelectionModelFactory';\nimport { useEditHandlers, removeEditHandler } from 'js/declEditHandlerFactory';\nimport { useMessages } from 'js/messagesProviderUtils';\nimport appCtxSvc from 'js/appCtxService';\nimport editHandlerService from 'js/editHandlerService';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport useVmoStore from './useVmoStore';\nimport debugService from 'js/debugService';\nimport logger from 'js/logger';\nimport { createFieldsBasedOnMetaData } from 'js/atomicDataService';\nimport { createAllFields, isFieldsEqual } from 'js/declFieldService';\nimport splmStatsService from 'js/splmStatsService';\nimport { useCommands } from 'js/commandBarUtils';\nimport AwInterpolateService from 'js/awInterpolateService';\n/**\n * execute lifecycle hook\n * @param {string} hookName hook name as 'onInit', 'onMount' and 'onUnmount'\n * @param {object} viewModel view model instance\n */\n\nconst executeHook = (hookName, viewModel, props, renderOptions) => {\n  if (viewModel.lifecycleHooks && viewModel.lifecycleHooks[hookName]) {\n    if (logger.isDeclarativeLogEnabled()) {\n      debugService.debugLifecyleHooks(hookName, viewModel);\n    }\n\n    if (hookName === 'onMount') {\n      debugService.debug('lifeCycles', viewModel._internal.panelId, 'mount');\n    }\n\n    viewModel.lifecycleHooks[hookName](renderOptions);\n  } // support backward compatibility of XXX.contentLoaded that is equivalent to onMount\n\n\n  if (hookName === 'onMount') {\n    const onEvents = viewModel.onEvent;\n\n    if (onEvents && onEvents.length > 0) {\n      let contentLoadedEvent = onEvents.find(event => {\n        const eventName = event.eventId;\n\n        if (eventName && eventName.includes('.contentLoaded')) {\n          // make sure contentLoaded event is subscribed for this viewmodel\n          // handle legacy use cases too compiler will convert viewModels to PascalCase but legacy viewNames could be in camel case\n          const viewName = viewModel.getViewId();\n          return eventName.split('.contentLoaded')[0].toLowerCase() === viewName.toLowerCase();\n        }\n\n        return false;\n      });\n\n      if (contentLoadedEvent) {\n        publish(contentLoadedEvent.eventId);\n      }\n    } // Backward compatability for command-sub-panel\n\n\n    if (props.isCommandSubPanel === 'true') {\n      publish('awPanel.reveal', {\n        panelId: props.viewId\n      });\n    }\n  }\n};\n/**\n * setup view model instance lifcycle in react\n * @param {object} viewModel view model Instance\n * @param {object} ctx App Ctx object\n * @param {object} prop view model property\n * @param {object} viewData view data\n * @param {boolean} limitEventScope Flag to control whether the even needs to be limited to specific view only\n * @param {object} subscriptions subscriptions\n * @returns {function} function to teardown view model intance\n */\n\n\nconst setupLifeCycle = (vmDef, viewModel, ctx, getProps, renderOptions, limitEventScope, runActionWithViewModel, subscriptions, getFields) => {\n  const props = getProps();\n  subscriptions.current = loadSubscriptions(viewModel.onEvent, viewModel, limitEventScope, getProps, runActionWithViewModel, getFields);\n  let dataCtxNode = {\n    data: viewModel,\n    ctx: ctx,\n    ports: viewModel.ports,\n    props: props,\n    getProps,\n    subPanelContext: props.subPanelContext,\n    getFields\n  }; //Execute onMount LifecycleHook\n\n  executeHook('onInit', viewModel);\n  executeHook('onMount', viewModel, props, renderOptions);\n\n  if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n    syncStrategyService.setupSyncStrategy(dataCtxNode);\n    syncStrategyService.updateVmOnMountUnmount(dataCtxNode, true);\n  } // TODO: can we split this out as teardownLifCycle later??\n\n\n  return () => {\n    const clearContext = () => {\n      cleanupEditHandlers(vmDef._internal.editHandlers, dataCtxNode);\n      unloadSubscriptions(subscriptions.current);\n\n      vmDef._internal.destroy(true);\n\n      dataCtxNode = null;\n      viewModel.actions = null;\n      viewModel.dispatch = null;\n      viewModel = null;\n    }; //onUnmount\n    //Make sure the onUnmount action is complete before destroying the declViewModel\n\n\n    if (viewModel.lifecycleHooks && viewModel.lifecycleHooks.onUnmount) {\n      debugService.debug('lifeCycles', viewModel._internal.panelId, 'unmount');\n      viewModel.lifecycleHooks.onUnmount(renderOptions).then(() => {\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugLifecyleHooks('onUnmount', viewModel);\n        }\n\n        if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n          syncStrategyService.updateVmOnMountUnmount(dataCtxNode, false);\n          syncViewModelCacheService.set('syncViewModelCache.' + viewModel._internal.viewId, null);\n        }\n\n        clearContext();\n      });\n    } else {\n      if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n        syncStrategyService.updateVmOnMountUnmount(dataCtxNode, false);\n        syncViewModelCacheService.set('syncViewModelCache.' + viewModel._internal.viewId, null);\n      }\n\n      clearContext();\n    }\n  };\n};\n/**\n * use i18n hook\n * @param {object} viewModel view model instance\n * @returns {object} i18n string map\n */\n\n\nconst useI18n = _ref => {\n  _s();\n\n  let {\n    i18n,\n    data,\n    dispatch,\n    chartProviders,\n    columnProviders,\n    grids\n  } = _ref;\n  const [i18nData, setI18n] = useState({});\n  const [i18nLoaded, setI18nLoaded] = useState(false);\n  useInitHook(() => {\n    if (i18n && Object.keys(i18n).length > 0) {\n      awDuiLocalizationSvc.populateI18nMap(i18n, null).then(results => {\n        if (results && Object.keys(results).length > 0) {\n          updateI18nTexts(data, {\n            i18n: results\n          }, 0);\n          dispatch({\n            path: 'data',\n            value: { ...data\n            }\n          });\n\n          if (chartProviders) {\n            updateI18nTexts(chartProviders, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'chartProviders',\n              value: { ...chartProviders\n              }\n            });\n          }\n\n          if (columnProviders) {\n            updateI18nTexts(columnProviders, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'columnProviders',\n              value: { ...columnProviders\n              }\n            });\n          }\n\n          if (grids) {\n            updateI18nTexts(grids, {\n              i18n: results\n            }, 0);\n            dispatch({\n              path: 'grids',\n              value: { ...grids\n              }\n            });\n          }\n\n          setI18n(results);\n          setI18nLoaded(true);\n        } else {\n          setI18nLoaded(true);\n        }\n      });\n    }\n  }); // Stu: we should not return this i18nLoaded, the downstream setupLifCycle should not depend on i18n. If it is\n  //      we should remove the dependency\n  // Jesse: it will cause cucumber failure for sure, will do it in next MX\n\n  return [i18nData, i18n && Object.keys(i18n).length > 0 ? i18nLoaded : true];\n}; // eslint-disable-next-line require-jsdoc\n\n\n_s(useI18n, \"IfPeJjNC0FyQE572oasoTGAoR8Q=\", false, function () {\n  return [useInitHook];\n});\n\nconst updateSubPanelContext = (jsonData, dataHook, subPanelContext) => {\n  if (subPanelContext) {\n    let resolvedData = {};\n    resolveSubPanelContext(jsonData, subPanelContext, resolvedData);\n    const [data, updateData] = dataHook;\n\n    _.forEach(resolvedData, function (propValue, propName) {\n      let dataClone = _.cloneDeep(data[propName]);\n\n      if (uwPropertySvc.isViewModelProperty(dataClone)) {\n        uwPropertySvc.setValue(dataClone, Object.values(propValue));\n        updateData({\n          path: propName,\n          value: dataClone\n        });\n      } else {\n        _.merge(dataClone, propValue);\n\n        updateData({\n          path: propName,\n          value: dataClone\n        });\n      }\n    });\n  }\n};\n/**\n * afx form hook\n * @param {object} vmDef view model definition\n * @param {array} dataHook dataHook in data-dispatch pair\n * @param {object} i18n i18n data used by reset\n * @returns {object} fields and form props\n */\n\n\nexport const useAfxForm = (vmDef, viewModel, ctx, dataHook, i18n, declViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema) => {\n  _s2();\n\n  // create field part. If we dont have to toch this by action we are good\n  const {\n    dataProviders,\n    createData\n  } = vmDef;\n  const [touched, setTouched] = useState({});\n  const [errors, setErrors] = useState({});\n  const [isValid, setValid] = useState(true);\n  const [data, updateData] = dataHook;\n  const validRef = useRef(isValid);\n\n  const updateFormValidity = formValidity => {\n    if (validRef.current !== formValidity) {\n      validRef.current = formValidity;\n      setValid(formValidity);\n    }\n  };\n\n  const getFormValidity = React.useCallback(() => validRef.current, [validRef]);\n  const errorsRef = useRef(errors);\n\n  const updateErrors = errorObj => {\n    if (errorObj !== errorsRef.current) {\n      errorsRef.current = errorObj;\n      setErrors({ ...errorObj\n      });\n    }\n  };\n\n  const getErrorsState = React.useCallback(() => errorsRef.current, [errorsRef]);\n  const touchedRef = useRef(touched);\n\n  const updateTouched = function (path) {\n    if (touched && touched[path] !== true) {\n      let newTouched = { ...touchedRef.current,\n        [path]: true\n      };\n      touchedRef.current = newTouched;\n      setTouched(newTouched);\n    }\n  };\n\n  const getTouchedState = React.useCallback(() => touchedRef.current, [touchedRef]);\n  const {\n    atomicData = {},\n    atomicDataRef = {}\n  } = viewModel;\n  const props = getProps ? getProps() : {};\n\n  const getVmProp = (isCtxProp, name) => {\n    const ctxObj = isCtxProp ? ctx : data;\n    return _.get(ctxObj, name);\n  };\n\n  const getVmPropFromList = (propName, index, isCtxProp) => {\n    const ctxObj = isCtxProp ? ctx : data;\n    return _.get(ctxObj, propName)[index];\n  };\n\n  const validateAndUpdateDCPPath = path => {\n    //Identify DCP property and escape using the bracket notation.\n    //For non DCP properties too, if the keys are more than 3, we should update the path\n    const propsKey = 'props.';\n    let propName = path.substring(path.indexOf(propsKey) + 6, path.length);\n\n    if (uwPropertySvc.isDCPProperty(propName) || path.split('.').length > 3) {\n      return path.replace(`.${propName}`, `['${propName}']`);\n    }\n\n    return path;\n  };\n\n  const updateValue = (isCtxProp, name, updatedProp) => {\n    if (updatedProp.isDCP || name.split('.').length > 3) {\n      name = validateAndUpdateDCPPath(name);\n    }\n\n    isCtxProp ? appCtxSvc.updatePartialCtx(name, updatedProp) : updateData({\n      path: name,\n      value: updatedProp\n    });\n  };\n\n  const isFormValid = stateCollection => {\n    let schema = vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n\n    if (schema) {\n      return !hasInvalidProps(stateCollection, schema);\n    }\n\n    return true;\n  };\n\n  const hasInvalidProps = (vmPropCollection, schema) => {\n    let invalidProps = {};\n    let entries = schema && vmPropCollection && Object.entries(vmPropCollection);\n\n    if (!declUtils.isNil(entries) && entries.length > 0) {\n      for (let [key] of entries) {\n        try {\n          schema.validateSyncAt(key, vmPropCollection);\n        } catch (e) {\n          if (e && e.errors) {\n            invalidProps[key] = e.errors;\n            break;\n          }\n        }\n      }\n    }\n\n    return Object.keys(invalidProps).length !== 0;\n  };\n\n  const setFormValidity = stateCollection => {\n    let validity = isFormValid(stateCollection);\n    updateFormValidity(validity);\n  };\n\n  const validateField = (name, viewModelProperty) => {\n    let newErrors = getErrorsState();\n    let schema = null;\n\n    try {\n      schema = viewModelProperty && vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n\n      if (schema) {\n        schema.validateSyncAt(name, viewModelProperty); // No need to update the errors object, if the \"property name\" is not present earlier.\n\n        if (newErrors && newErrors[name]) {\n          delete newErrors[name];\n          updateErrors({ ...newErrors\n          });\n        }\n      }\n    } catch (e) {\n      if (e && e.errors) {\n        newErrors = { ...newErrors,\n          [name]: e.errors\n        };\n        updateErrors(newErrors);\n      }\n    } finally {\n      setFormValidity(getStateCollection(viewModel));\n    }\n  };\n\n  const setLovDataVal = (name, isCtxProp, index) => (_ref2, operation) => {\n    let {\n      lovEntry,\n      dataProvider,\n      checkLovEntries,\n      dateApi\n    } = _ref2;\n\n    if (name.includes('[')) {\n      name = name.replace(/ *\\[[^\\]]*]/, '');\n    }\n\n    let uiProperty;\n\n    if (isCtxProp) {\n      uiProperty = appCtxSvc.getCtx(name);\n    } else if (!_.isNil(index)) {\n      uiProperty = viewModel.getData()[name][index];\n    } else {\n      uiProperty = viewModel.getData()[name];\n    }\n\n    let vmpPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n    return performLOVOperation({\n      uiProperty,\n      vmo: null,\n      lovEntry,\n      dataProvider,\n      createUpdateValue,\n      checkLovEntries,\n      dateApi\n    }, operation).then(_ref3 => {\n      let {\n        newProp,\n        isPropertyUpdateReqd\n      } = _ref3;\n\n      if (newProp && isPropertyUpdateReqd) {\n        updateValue(isCtxProp, vmpPropName, newProp);\n        updateTouched(validateName);\n        validateField(validateName, {\n          [validateName]: newProp\n        });\n      }\n\n      return Promise.resolve(newProp);\n    });\n  };\n\n  const setLovDataValVMO = (vmoName, propName, isCtxProp) => (_ref4, operation) => {\n    let {\n      lovEntry,\n      dataProvider,\n      checkLovEntries,\n      dateApi\n    } = _ref4;\n    let uiProperty = isCtxProp ? appCtxSvc.getCtx(propName) : getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    return performLOVOperation({\n      uiProperty,\n      vmo: getVMO(vmoName),\n      lovEntry,\n      dataProvider,\n      createUpdateValue,\n      checkLovEntries,\n      dateApi\n    }, operation).then(_ref5 => {\n      let {\n        newProp,\n        isPropertyUpdateReqd\n      } = _ref5;\n\n      if (newProp && isPropertyUpdateReqd) {\n        updateValue(isCtxProp, pathName, newProp);\n        updateTouched(propName);\n        validateField(uiProperty.propertyName, getVMOProps(vmoName));\n        return Promise.resolve(newProp);\n      }\n    });\n  };\n\n  const handleChange = (name, isCtxProp, index) => event => {\n    const vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    let vmPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n\n    if (event.persist) {\n      event.persist();\n    }\n\n    let newVMProp = createUpdateValue(vmProp, event);\n    updateValue(isCtxProp, vmPropName, newVMProp);\n    updateTouched(validateName);\n    validateField(validateName, {\n      [validateName]: newVMProp\n    });\n  };\n\n  const setValueForVmo = (vmoName, propName, isCtxProp) => (newVal, additionalProp) => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    let updateVal = { ...vmProp\n    };\n    uwPropertySvc.updateViewModelProp(updateVal, newVal, additionalProp, true);\n    updateValue(isCtxProp, pathName, updateVal);\n    updateTouched(propName);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const setValue = (name, isCtxProp, index) => (newVal, additionalProp) => {\n    const prevVal = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    let vmPropName = _.isNil(index) ? name : name + '[' + index + ']';\n    let validateName = _.isNil(index) ? name : name + '_' + index;\n    let updateVal = { ...prevVal\n    };\n    uwPropertySvc.updateViewModelProp(updateVal, newVal, additionalProp, true);\n    updateValue(isCtxProp, vmPropName, updateVal); // check validity and update Touched\n\n    updateTouched(validateName);\n    validateField(validateName, {\n      [validateName]: updateVal\n    });\n  };\n\n  const handleChangeVMO = (vmoName, propName, isCtxProp) => event => {\n    if (event.persist) {\n      event.persist();\n    }\n\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let pathName = vmoName + '.props.' + propName;\n    updateValue(isCtxProp, pathName, createUpdateValue(vmProp, event));\n    updateTouched(propName);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const moveUp = (prop, index) => {\n    for (var i = 0; i < prop.displayValsModel.length; i++) {\n      if (i === index) {\n        prop.displayValsModel[i].selected = false;\n        prop.lastSelected = prop.displayValsModel[index];\n      }\n    }\n\n    prop.lastSelected = null;\n    var currDbVal = prop.dbValue[index];\n    var currDisplayVal = prop.displayValues[index];\n    var currDisplayValModel = prop.displayValsModel[index];\n    prop.dbValue.splice(index, 1);\n    prop.dbValue.splice(index - 1, 0, currDbVal);\n    prop.displayValues.splice(index, 1);\n    prop.displayValues.splice(index - 1, 0, currDisplayVal);\n    prop.displayValsModel.splice(index, 1);\n    prop.displayValsModel.splice(index - 1, 0, currDisplayValModel);\n    prop.dirty = true;\n  };\n\n  const moveDown = (prop, index) => {\n    index -= 1;\n\n    for (var i = 0; i < prop.displayValsModel.length; i++) {\n      if (i === index) {\n        prop.displayValsModel[i].selected = false;\n        prop.lastSelected = prop.displayValsModel[index];\n      }\n    }\n\n    prop.lastSelected = null;\n    var currDbVal = prop.dbValue[index];\n    var currDisplayVal = prop.displayValues[index];\n    var currDisplayValModel = prop.displayValsModel[index];\n    prop.dbValue.splice(index, 1);\n    prop.dbValue.splice(index + 1, 0, currDbVal);\n    prop.displayValues.splice(index, 1);\n    prop.displayValues.splice(index + 1, 0, currDisplayVal);\n    prop.displayValsModel.splice(index, 1);\n    prop.displayValsModel.splice(index + 1, 0, currDisplayValModel);\n    prop.dirty = true;\n  };\n\n  const remove = (prop, index) => {\n    index -= 2;\n    prop.dbValue.splice(index, 1);\n\n    if (prop.hasLov) {\n      prop.displayValues.splice(index, 1);\n\n      if (prop.isArray) {\n        prop.displayValsModel = prop.displayValsModel || [];\n        prop.displayValsModel.splice(index, 1);\n      }\n    }\n\n    prop.dirty = true;\n  };\n\n  const handleClick = (name, isCtxProp, $index) => event => {\n    let vmProp = _.isNil($index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, $index, isCtxProp);\n    let vmPropName = _.isNil($index) ? name : name + '[' + $index + ']';\n    let validateName = _.isNil($index) ? name : name + '_' + $index;\n    let prop = { ...vmProp\n    };\n\n    if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n      let indexStr = event.currentTarget.attributes.id.value;\n      let index = parseInt(indexStr);\n      let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n      if (!isButtonClicked) {\n        let isAnyValueSelected = false;\n\n        if (prop.displayValsModel) {\n          for (var j = 0; j < prop.displayValsModel.length; j++) {\n            if (prop.displayValsModel[j].selected && prop.displayValsModel[j].isInEditMode) {\n              isAnyValueSelected = true;\n              break;\n            }\n          }\n        }\n\n        if (!isAnyValueSelected) {\n          if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n            prop.autofocus = true;\n            prop.currArrayDbValue = prop.dbValue.slice(0);\n            prop.displayValsModel[index].isInEditMode = true;\n            updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n            updateTouched(validateName);\n            validateField(validateName, {\n              [validateName]: prop\n            });\n          } else {\n            for (var i = 0; i < prop.displayValsModel.length; i++) {\n              if (i === index && !prop.lastSelected) {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              } else if (i === index && prop.lastSelected) {\n                if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                  prop.displayValsModel[i].selected = false;\n                  prop.lastSelected = undefined;\n                } else {\n                  prop.displayValsModel[i].selected = true;\n                  prop.lastSelected = prop.displayValsModel[index];\n                }\n              } else {\n                prop.displayValsModel[i].selected = false;\n              }\n            }\n\n            updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n            updateTouched(validateName);\n            event.stopPropagation();\n          }\n        }\n      } else {\n        let hasActionHappened = false;\n        let titleVal;\n\n        if (event.currentTarget.attributes.title) {\n          titleVal = event.currentTarget.attributes.title.value;\n        }\n\n        if (titleVal && titleVal === 'Move Up' && index > 0) {\n          moveUp(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n          moveDown(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Remove') {\n          remove(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (hasActionHappened) {\n          updateValue(isCtxProp, vmPropName, createUpdateValue(prop, event));\n          updateTouched(validateName);\n          validateField(validateName, {\n            [name]: prop\n          });\n        }\n      }\n    }\n  };\n\n  const handleClickVMO = (vmoName, propName, isCtxProp) => event => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    let prop = { ...vmProp\n    };\n\n    if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n      let indexStr = event.currentTarget.attributes.id.value;\n      let index = parseInt(indexStr);\n      let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n      if (!isButtonClicked) {\n        if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n          prop.autofocus = true;\n          prop.currArrayDbValue = prop.dbValue.slice(0);\n          prop.displayValsModel[index].isInEditMode = true;\n          let pathName = vmoName + '.props.' + propName;\n          updateValue(isCtxProp, pathName, createUpdateValue(prop, event));\n          updateTouched(propName);\n          validateField(vmProp.propertyName, getVMOProps(vmoName));\n        } else {\n          for (var i = 0; i < prop.displayValsModel.length; i++) {\n            if (i === index && !prop.lastSelected) {\n              prop.displayValsModel[i].selected = true;\n              prop.lastSelected = prop.displayValsModel[index];\n            } else if (i === index && prop.lastSelected) {\n              if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                prop.displayValsModel[i].selected = false;\n                prop.lastSelected = undefined;\n              } else {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              }\n            } else {\n              prop.displayValsModel[i].selected = false;\n            }\n          }\n\n          event.stopPropagation();\n        }\n      } else {\n        let hasActionHappened = false;\n        let titleVal = event.currentTarget.attributes.title.value;\n\n        if (titleVal && titleVal === 'Move Up' && index > 0) {\n          moveUp(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n          moveDown(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (titleVal && titleVal === 'Remove') {\n          remove(prop, index);\n          hasActionHappened = true;\n        }\n\n        if (hasActionHappened) {\n          let pathName = vmoName + '.props.' + propName;\n          updateValue(isCtxProp, pathName, createUpdateValue(prop, event));\n          updateTouched(propName);\n          validateField(vmProp.propertyName, getVMOProps(vmoName));\n        }\n      }\n    }\n  };\n\n  const handleBlur = (name, isCtxProp, index) => event => {\n    let vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    name = _.isNil(index) ? name : vmProp.propertyName;\n\n    if (vmProp.isArray && event.isBlurFromInput) {\n      //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n      //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n      updateArray(vmProp, event);\n    }\n\n    uwPropertySvc.updateViewModelProperty(vmProp);\n    validateField(name, {\n      [name]: vmProp\n    });\n  };\n\n  const handleBlurVMO = (vmoName, propName) => event => {\n    let vmProp = getVMPropForVMO(vmoName, propName);\n\n    if (vmProp.isArray && event.isBlurFromInput) {\n      //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n      //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n      updateArray(vmProp, event);\n    }\n\n    uwPropertySvc.updateViewModelProperty(vmProp);\n    validateField(vmProp.propertyName, getVMOProps(vmoName));\n  };\n\n  const isValidArrayValue = (viewModelProperty, valToUpdate) => {\n    var isValid = false;\n\n    if (valToUpdate !== undefined && valToUpdate !== '' && valToUpdate !== null && viewModelProperty.dbValue !== undefined) {\n      if (viewModelProperty.type === 'INTEGERARRAY' || viewModelProperty.type === 'DOUBLEARRAY' || viewModelProperty.type === 'DATEARRAY') {\n        if (isFinite(valToUpdate)) {\n          isValid = true;\n        }\n      } else if (viewModelProperty.type === 'BOOLEANARRAY') {\n        isValid = _.isBoolean(valToUpdate);\n      } else {\n        isValid = true;\n      }\n    }\n\n    return isValid;\n  };\n\n  const updateArray = (prop, event) => {\n    let indexStr;\n    let index;\n    let valToUpdate;\n\n    if (prop.type === 'DATEARRAY') {\n      index = event.index;\n      valToUpdate = new Date(event.target.value);\n    } else {\n      if (prop.type === 'BOOLEANARRAY' && prop.renderingHint === 'radiobutton') {\n        if (event.target.defaultValue === 'true') {\n          valToUpdate = true;\n        } else if (event.target.defaultValue === 'false') {\n          valToUpdate = false;\n        }\n\n        index = event.index;\n      } else if (prop.type === 'BOOLEANARRAY') {\n        valToUpdate = event.target.checked;\n        index = event.index;\n      } else {\n        indexStr = event.currentTarget.attributes.id.value;\n        index = parseInt(indexStr);\n        valToUpdate = event.currentTarget.value;\n      }\n    }\n\n    if (isValidArrayValue(prop, valToUpdate) && (!prop.error || prop.hasServerValidationError)) {\n      if (prop.currArrayDbValue) {\n        prop.currArrayDbValue.splice(index, 1, valToUpdate);\n        prop.dirty = true;\n        prop.dbValue = prop.currArrayDbValue.slice(0);\n      }\n    } else if (prop.dbValue === '' || prop.dbValue === null || prop.dbValue === undefined) {\n      prop.dbValue = prop.currArrayDbValue.slice(0);\n    }\n\n    if (prop.displayValsModel[index] && prop.dbValue.length > 0) {\n      prop.displayValsModel[index].displayValue = prop.dbValue[index];\n      prop.displayValsModel[index].isInEditMode = false;\n      prop.displayValsModel[index].selected = false;\n    }\n\n    prop.lastSelected = undefined;\n  };\n\n  const createNewArrayVal = (newVal, updateVal, event) => {\n    if (updateVal.type === 'DATEARRAY') {\n      if (_.isArray(updateVal.dbValue) && updateVal.dbValue.length > 0) {\n        _.forEach(updateVal.dbValue, function (value) {\n          if (value !== undefined && value !== '') {\n            newVal.push(value);\n          }\n        });\n\n        if (event.target.value) {\n          newVal.push(new Date(event.target.value));\n        }\n      } else if (event.target.value) {\n        newVal.push(new Date(event.target.value));\n      }\n    } else {\n      if (_.isArray(updateVal.dbValue) && updateVal.dbValue.length > 0) {\n        _.forEach(updateVal.dbValue, function (value) {\n          if (value !== undefined && value !== '') {\n            newVal.push(value);\n          }\n        });\n      }\n\n      if (event.target.value && updateVal.type !== 'BOOLEANARRAY') {\n        newVal.push(event.target.value);\n      }\n\n      if (event.target.value && updateVal.type === 'BOOLEANARRAY' && updateVal.renderingHint === 'radiobutton') {\n        newVal.push(event.target.value);\n      }\n\n      if (event.key === 'Enter' && updateVal.type === 'BOOLEANARRAY' && event.target.checked !== undefined && updateVal.renderingHint !== 'radiobutton') {\n        newVal.push(event.target.checked);\n      }\n    }\n  };\n\n  const createUpdateValue = (prevVal, event) => {\n    let updateVal = { ...prevVal\n    };\n\n    if (prevVal.type.toUpperCase() === 'DATEARRAY' && event.target.value === null) {\n      return updateVal;\n    }\n\n    let newVal;\n\n    switch (prevVal.type.toUpperCase()) {\n      case 'DATE':\n        newVal = event.target.value ? Number(new Date(event.target.value)) : NULLDATE;\n        break;\n\n      case 'BOOLEAN':\n        if (event.target.type === 'radio') {\n          newVal = event.target.value === 'true';\n        } else {\n          newVal = event.target.checked;\n        }\n\n        break;\n\n      case 'INTEGER':\n        newVal = event.target.value.replace(/[^\\+|\\-|0-9]/g, '');\n        break;\n\n      case 'DOUBLE':\n        newVal = event.target.value.replace(/[^\\+|\\-|0-9\\.|e]/g, '');\n        break;\n\n      case 'DATETIME':\n        newVal = new Date(event.target.value).toLocaleTimeString();\n        break;\n\n      case 'OBJECT':\n        newVal = Array.isArray(event.target.value) && event.target.value.length > 0 ? event.target.value[0] : '';\n        break;\n\n      case 'OBJECTARRAY':\n        if (!updateVal.hasLov) {\n          newVal = _.clone(prevVal.dbValue);\n\n          _.forEach(event.target.value, function (value) {\n            if (value !== undefined && value !== '') {\n              newVal.push(value);\n            }\n          });\n        } else {\n          newVal = [];\n\n          if (event.updateArray) {\n            updateArray(updateVal, event);\n\n            _.forEach(updateVal.dbValue, function (value) {\n              if (value !== undefined && value !== '') {\n                newVal.push(value);\n              }\n            });\n          } else {\n            createNewArrayVal(newVal, updateVal, event);\n          }\n        }\n\n        break;\n\n      case 'DOUBLEARRAY':\n      case 'DATEARRAY':\n      case 'INTEGERARRAY':\n      case 'STRINGARRAY':\n      case 'CHECKBOXARRAY':\n      case 'BOOLEANARRAY':\n        {\n          newVal = [];\n\n          if (event.updateArray) {\n            updateArray(updateVal, event);\n\n            _.forEach(updateVal.dbValue, function (value) {\n              if (value !== undefined && value !== '') {\n                newVal.push(value);\n              }\n            });\n          } else {\n            createNewArrayVal(newVal, updateVal, event);\n          }\n\n          break;\n        }\n\n      default:\n        newVal = event.target.value;\n    }\n\n    uwPropertySvc.setValue(updateVal, newVal);\n    return updateVal;\n  };\n\n  const getVMO = (vmoName, isCtxProp) => {\n    const lData = isCtxProp ? ctx : viewModel.getData();\n\n    const vmo = _.get(lData, vmoName);\n\n    if (vmo) {\n      return vmo;\n    }\n\n    return undefined;\n  };\n\n  const getAutofocusVMO = vmProp => {\n    if (vmProp) {\n      return vmProp.autofocus;\n    }\n\n    return undefined;\n  };\n\n  const getAutofocus = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.autofocus;\n  };\n\n  const getVMOProps = vmoName => {\n    let vmo = getVMO(vmoName);\n\n    if (vmo && vmo.props) {\n      return vmo.props;\n    }\n\n    return undefined;\n  };\n\n  const getVMPropForVMO = (vmoName, propName) => {\n    let vmo = getVMO(vmoName);\n\n    if (vmo && vmo.props && vmo.props[propName]) {\n      return vmo.props[propName];\n    }\n\n    return undefined;\n  };\n\n  const getValueVMO = vmProp => {\n    if (vmProp && vmProp.type === 'BOOLEAN') {\n      if (vmProp.dbValue === '') {\n        return undefined;\n      }\n\n      if (declUtils.isNil(vmProp.dbValue)) {\n        return null;\n      }\n\n      return String(vmProp.dbValue) === 'true' || String(vmProp.dbValue) === 'TRUE';\n    }\n\n    return vmProp && !_.isUndefined(vmProp && vmProp.dbValue) ? vmProp.dbValue : '';\n  };\n\n  const getValue = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.type === 'BOOLEAN') {\n      if (vmProp.dbValue === '') {\n        return undefined;\n      }\n\n      if (declUtils.isNil(vmProp.dbValue)) {\n        return null;\n      }\n\n      return String(vmProp.dbValue) === 'true' || String(vmProp.dbValue) === 'TRUE';\n    }\n\n    return vmProp && !_.isUndefined(vmProp && vmProp.dbValue) ? vmProp.dbValue : '';\n  };\n\n  const getTouched = name => {\n    let touchedState = getTouchedState();\n    return touchedState[name] ? 'true' : 'false';\n  };\n\n  const getErrorsVMPArray = function (name, index) {\n    let errors = getErrorsState();\n    let isTouched = getTouched(name + '_' + index);\n    return isTouched === 'true' ? errors[name + '_' + index] : undefined;\n  };\n\n  const getErrors = function (name, rootPath, path) {\n    let errors = getErrorsState();\n\n    if (!_.isNil(rootPath)) {\n      let atomicPath = rootPath + '.' + path;\n      atomicPath = atomicPath.replace(/\\./g, '_');\n      atomicPath = atomicPath.replace(/\\[/g, '_');\n      atomicPath = atomicPath.replace(/\\]/g, '');\n      let isTouched = getTouched(atomicPath);\n      return isTouched === 'true' ? errors[atomicPath] : undefined;\n    }\n\n    let isTouched = getTouched(name);\n    return isTouched === 'true' ? errors[name] : undefined;\n  };\n\n  const getAtomicVmProp = function (name, isCtxProp, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let vmProp;\n\n    if (isAtomic && viewProp) {\n      vmProp = viewProp;\n    } else {\n      vmProp = _.isNil(index) ? getVmProp(isCtxProp, name) : getVmPropFromList(name, index, isCtxProp);\n    }\n\n    return vmProp;\n  };\n\n  const getPropertyDisplayName = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : ''; // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n\n    return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n  };\n\n  const getPropertyDisplayNameVMO = vmProp => {\n    const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : ''; // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n\n    return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n  };\n\n  const getPlaceHolder = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    let placeholder = '';\n\n    if (!vmProp) {\n      return placeholder;\n    }\n\n    let propertyType = getPropertyType(name, isCtxProp, index);\n\n    switch (propertyType && propertyType.toUpperCase()) {\n      case 'DATEARRAY':\n      case 'DATE':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n        break;\n\n      default:\n        if (vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else if (vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else {\n          placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n        }\n\n    }\n\n    return placeholder;\n  };\n\n  const getPlaceHolderVMO = vmProp => {\n    let placeholder = '';\n\n    if (!vmProp) {\n      return placeholder;\n    }\n\n    let propertyType = vmProp.type;\n\n    switch (propertyType && propertyType.toUpperCase()) {\n      case 'DATEARRAY':\n      case 'DATETIME':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY HH:mm' : '';\n        break;\n\n      case 'DATE':\n        placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n        break;\n\n      case 'TIME':\n        placeholder = vmProp.isEditable ? 'HH:mm:ss' : '';\n        break;\n\n      default:\n        if (vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else if (vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText) {\n          placeholder = vmProp.propertyRequiredText;\n        } else {\n          placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n        }\n\n    }\n\n    return placeholder;\n  };\n\n  const getUIValue = function (name, isCtxProp, index, isAtomic, viewProp) {\n    let key = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'uiValue';\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp[key];\n  };\n\n  const getUIValueVMO = function (vmProp) {\n    let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'uiValue';\n\n    if (vmProp) {\n      return vmProp[key];\n    }\n\n    return undefined;\n  };\n\n  const getRenderingHint = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.renderingHint;\n  };\n\n  const getRenderingHintVMO = vmProp => {\n    if (vmProp) {\n      return vmProp.renderingHint;\n    }\n\n    return undefined;\n  };\n\n  const getPropertyType = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled) {\n      return 'DATETIME';\n    }\n\n    return vmProp && vmProp.type;\n  };\n\n  const getPropertyTypeVMO = vmProp => {\n    if (vmProp && vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled) {\n      return 'DATETIME';\n    }\n\n    return vmProp && vmProp.type;\n  };\n\n  const getRequired = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.isRequired;\n  };\n\n  const getRequiredVMO = vmProp => {\n    return vmProp && vmProp.isRequired;\n  };\n\n  const getMaxLength = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.maxLength;\n  };\n\n  const getMaxLengthVMO = vmProp => {\n    return vmProp && vmProp.maxLength;\n  };\n\n  const getPropertyRadioTrueText = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioTrueTextVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioFalseText = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n    }\n\n    return undefined;\n  };\n\n  const getPropertyRadioFalseTextVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY')) {\n      return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n    }\n\n    return undefined;\n  };\n\n  const getDisplayValsModel = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' || vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' || vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY')) {\n      return vmProp.displayValsModel;\n    }\n\n    return undefined;\n  };\n\n  const getDisplayValsModelVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' || vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' || vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY')) {\n      return vmProp.displayValsModel;\n    }\n\n    return undefined;\n  };\n\n  const getDateApi = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && (vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME')) {\n      if (vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue) {\n        uwPropertySvc.initializeDateApiValues(vmProp);\n      }\n\n      return vmProp.dateApi;\n    }\n\n    return undefined;\n  };\n\n  const getDateApiVMO = vmProp => {\n    if (vmProp && (vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME')) {\n      if (vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue) {\n        uwPropertySvc.initializeDateApiValues(vmProp);\n      }\n\n      return vmProp.dateApi;\n    }\n\n    return undefined;\n  };\n\n  const getIsLov = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.hasLov;\n  };\n\n  const getIsLovVMO = vmProp => {\n    return vmProp && vmProp.hasLov;\n  };\n\n  const getLovApiVMO = vmProp => {\n    return vmProp && vmProp.lovApi;\n  };\n\n  const getDataProvider = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (!vmProp) {\n      return undefined;\n    } // case dynamic dataProvider\n\n\n    if (_.isFunction(vmProp.dataProvider)) {\n      return vmProp.dataProvider();\n    }\n\n    return vmProp.dataProvider && dataProviders && dataProviders[vmProp.dataProvider] ? dataProviders[vmProp.dataProvider] : null;\n  };\n\n  const getDataProviderVMO = vmProp => {\n    return vmProp && vmProp.dataProvider;\n  };\n\n  const getIsArray = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.isArray;\n  };\n\n  const getIsArrayVMO = vmProp => {\n    return vmProp && vmProp.isArray;\n  };\n\n  const getLovApi = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && vmProp.lovApi) {\n      return vmProp.lovApi;\n    }\n\n    return null;\n  };\n\n  const getEditArrayInlineMode = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.editArrayInlineMode;\n  };\n\n  const getEditArrayInlineModeVMO = vmProp => {\n    return vmProp && vmProp.editArrayInlineMode;\n  };\n\n  const getNumberOfLines = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.numberOfLines;\n  };\n\n  const getNumberOfLinesVMO = vmProp => {\n    return vmProp && vmProp.numberOfLines;\n  }; // compute the label position\n  // the precedence is like this:\n  // 1. class in view (sw-row / sw-column / sw-reverse)\n  // 2. v-m prop.labelPosition\n  // 3. boolean and object use label at end\n  // 4. editable props use label at top\n\n\n  const getLabelPlacement = vmProp => {\n    var labelPlacement = '';\n\n    if (!vmProp) {\n      return labelPlacement;\n    } // get rid of editLayoutSide and consolidate positioning here?\n    // revisitMe ulrey. discuss with Nihar?\n\n\n    switch (vmProp.propertyLabelDisplay) {\n      case 'PROPERTY_LABEL_AT_RIGHT':\n        labelPlacement = 'end';\n        break;\n\n      case 'PROPERTY_LABEL_AT_TOP':\n        labelPlacement = 'top';\n        break;\n\n      case 'PROPERTY_LABEL_AT_SIDE':\n        labelPlacement = 'start';\n        break;\n\n      case 'NO_PROPERTY_LABEL':\n        // revistMe scott: is <aw-widget labeldisplay=\"Headless\"> also supported?\n        labelPlacement = 'none';\n        break;\n\n      default:\n        labelPlacement = 'default';\n    }\n\n    return labelPlacement;\n  };\n\n  const getLabelPlacementFromData = function (propName, vmoName, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 ? arguments[4] : undefined;\n    const vmProp = isAtomic && viewProp ? viewProp : vmoName ? getVMPropForVMO(vmoName, propName) : !declUtils.isNil(index) ? data[propName][index] : data[propName];\n    return getLabelPlacement(vmProp);\n  };\n  /**\n   * Check if prop is dirty\n   * if uncommitted value changes, but is reverted: dirty=false\n   * @param {object} vmProp view model property\n   * @returns {boolean} true if prop is dirty\n   */\n\n\n  const dirtyCheck = vmProp => {\n    // deal with case where null !== emptystring if( vmProp.valueUpdated || vmProp.displayValueUpdated ) {\n    if (_.isNil(vmProp.value) && _.isNil(vmProp.newValue)) {\n      return false;\n    }\n\n    return (vmProp.valueUpdated || vmProp.displayValueUpdated) && !_.isEqual(vmProp.value, vmProp.newValue);\n  };\n  /**\n   * Check if prop is dirty\n   * @param {string} name property namne\n   * @param {boolean} isCtxProp is prop from ctx (optional)\n   * @returns {boolean} true if prop is dirty / undefined if clean\n   */\n\n\n  const isPropDirty = function (name, isCtxProp, index) {\n    let isAtomic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let viewProp = arguments.length > 4 ? arguments[4] : undefined;\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp && dirtyCheck(vmProp)) {\n      return 'true';\n    }\n\n    return undefined;\n  };\n  /**\n   * Check if vmo prop is dirty\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} true if prop is dirty / undefined if clean\n   */\n\n\n  const isPropDirtyVMO = vmProp => {\n    if (vmProp && dirtyCheck(vmProp)) {\n      return 'true';\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets pattern for VMO\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {object} patterns object\n   */\n\n\n  const getPatterns = vmProp => {\n    if (vmProp && vmProp.patterns) {\n      return vmProp.patterns;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets preferred pattern\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {string} preferred patterns value\n   */\n\n\n  const getPreferredPattern = vmProp => {\n    if (vmProp) {\n      return vmProp.preferredPattern;\n    }\n\n    return undefined;\n  };\n\n  const getPreferredPatternVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.preferredPattern;\n    }\n\n    return undefined;\n  };\n\n  const getAutoAssignVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n\n  const getAutoAssignableVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.isAutoAssignable;\n    }\n\n    return undefined;\n  };\n\n  const getPatternAutoAssignFlagsVMO = (propName, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index, isAtomic, viewProp);\n\n    if (vmProp) {\n      return vmProp.patternAutoAssignFlags;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets isAutoAssign boolean value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} isAutoAssign bool value\n   */\n\n\n  const getIsAutoAssign = vmProp => {\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n\n  const getIsAutoAssignVMPArray = (propName, isCtxProp, index) => {\n    const vmProp = getAtomicVmProp(propName, isCtxProp, index);\n\n    if (vmProp) {\n      return vmProp.isAutoAssign;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets isAutoAssignable boolean value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {boolean} isAutoAssignable bool value\n   */\n\n\n  const getIsAutoAssignable = vmProp => {\n    if (vmProp) {\n      return vmProp.isAutoAssignable;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets patternAutoAssignFlags value for the patterns\n   * @param {string} vmoName view-model object name\n   * @param {string} propName property name\n   * @returns {object} PatternAutoAssignFlags object\n   */\n\n\n  const getPatternAutoAssignFlags = vmProp => {\n    if (vmProp) {\n      return vmProp.patternAutoAssignFlags;\n    }\n\n    return undefined;\n  };\n  /**\n   * Gets parent uid\n   * @param {string} vmoName view-model object name\n   * @param {string} vmProp property name\n   * @param {boolean} isCtxProp property name\n   * @returns {string} parent uid\n   */\n\n\n  const getParentUid = (vmoName, vmProp, isCtxProp) => {\n    if (vmProp && (vmProp.patterns || vmProp.patternAutoAssignFlags)) {\n      const vmo = getVMO(vmoName, isCtxProp);\n      return vmo && vmo.uid ? vmo.uid : undefined;\n    }\n\n    return undefined;\n  };\n\n  const handleReset = () => {\n    // revisitme - spond\n    // HINT: In reset case, we need to consider all extra data we put in data store rather than\n    // reset the whole data store to data def\n    updateData({\n      value: { ...data,\n        ...createData({\n          i18n\n        })\n      }\n    });\n    setTouched({});\n    updateErrors({});\n    setFormValidity(getStateCollection(viewModel));\n  };\n\n  const getAction = (name, isCtxProp, index, isAtomic, viewProp) => {\n    const vmProp = getAtomicVmProp(name, isCtxProp, index, isAtomic, viewProp);\n    return vmProp && vmProp.action && viewModel.actions && viewModel.actions[vmProp.action] ? viewModel.actions[vmProp.action] : null;\n  };\n\n  const getActionVMO = vmProp => {\n    return vmProp && vmProp.action && viewModel.actions && viewModel.actions[vmProp.action] ? viewModel.actions[vmProp.action] : null;\n  };\n\n  const constructFieldForNamedPropertyVMO = function (vmoName, propName) {\n    let isCtxProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let vmProp = getVMPropForVMO(vmoName, propName);\n    return {\n      name: propName,\n      onChange: handleChangeVMO(vmoName, propName, isCtxProp),\n      onBlur: handleBlurVMO(vmoName, propName),\n      onClick: handleClickVMO(vmoName, propName, isCtxProp),\n      value: getValueVMO(vmProp),\n      checked: getValueVMO(vmProp),\n      touched: getTouched(propName),\n      label: getPropertyDisplayNameVMO(vmProp),\n      typex: getPropertyTypeVMO(vmProp),\n      error: getErrors(propName),\n      required: getRequiredVMO(vmProp),\n      maxLength: getMaxLengthVMO(vmProp),\n      placeholder: getPlaceHolderVMO(vmProp),\n      disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n      dirty: isPropDirtyVMO(vmProp),\n      'data-locator': getPropertyDisplayNameVMO(vmProp),\n      'aria-label': getPropertyDisplayNameVMO(vmProp),\n      'aria-required': getRequiredVMO(vmProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      setLovVal: setLovDataValVMO(vmoName, propName, isCtxProp),\n      vmo: getVMO(vmoName, isCtxProp),\n      update: setValueForVmo(vmoName, propName, isCtxProp),\n      autoFocus: getAutofocusVMO(vmProp),\n      __vmprop__: () => vmProp,\n      fielddata: {\n        uiValue: getUIValueVMO(vmProp),\n        uiValues: getUIValueVMO(vmProp, 'uiValues'),\n        oldValue: getUIValueVMO(vmProp, 'oldValue'),\n        oldValues: getUIValueVMO(vmProp, 'oldValues'),\n        displayValues: getUIValueVMO(vmProp, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        isEnabled: vmProp && vmProp.isEnabled,\n        isSelectOnly: vmProp && vmProp.isSelectOnly,\n        isEditable: vmProp && vmProp.isEditable,\n        isLocalizable: vmProp && vmProp.isLocalizable,\n        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayNameVMO(vmProp),\n        labelPlacement: getLabelPlacement(vmProp),\n        renderingHint: getRenderingHintVMO(vmProp),\n        propertyRadioTrueText: getPropertyRadioTrueTextVMO(vmProp),\n        propertyRadioFalseText: getPropertyRadioFalseTextVMO(vmProp),\n        radioVertical: vmProp && vmProp.vertical,\n        displayValsModel: getDisplayValsModelVMO(vmProp),\n        numberOfLines: getNumberOfLinesVMO(vmProp),\n        dateApi: getDateApiVMO(vmProp),\n        isArray: getIsArrayVMO(vmProp),\n        hasLov: getIsLovVMO(vmProp),\n        dataProvider: getDataProviderVMO(vmProp),\n        editArrayInlineMode: getEditArrayInlineModeVMO(vmProp),\n        isRichText: vmProp && vmProp.isRichText,\n        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry,\n        patterns: getPatterns(vmProp),\n        preferredPattern: getPreferredPattern(vmProp),\n        lovApi: getLovApiVMO(vmProp),\n        action: getActionVMO(vmProp),\n        destPanelId: vmProp && vmProp.destPanelId,\n        iconName: vmProp && vmProp.iconName,\n        iconSource: vmProp && vmProp.iconSource,\n        tooltip: vmProp && vmProp.tooltip,\n        isAutoAssign: getIsAutoAssign(vmProp),\n        isAutoAssignable: getIsAutoAssignable(vmProp),\n        parentUid: getParentUid(vmoName, vmProp, isCtxProp),\n        propertyName: propName,\n        patternAutoAssignFlags: getPatternAutoAssignFlags(vmProp),\n        hasRevRuleAttached: vmProp && vmProp.hasRevRuleAttached\n      }\n    };\n  };\n\n  const constructFieldForNamedProperty = function (propName) {\n    let isCtxProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const vmProp = getVmProp(isCtxProp, propName);\n    return {\n      name: propName,\n      onChange: handleChange(propName, isCtxProp),\n      onBlur: handleBlur(propName, isCtxProp),\n      onClick: handleClick(propName, isCtxProp),\n      value: getValue(propName, isCtxProp),\n      checked: getValue(propName, isCtxProp),\n      touched: getTouched(propName),\n      label: getPropertyDisplayName(propName, isCtxProp),\n      typex: getPropertyType(propName, isCtxProp),\n      error: getErrors(propName),\n      required: getRequired(propName, isCtxProp),\n      maxLength: getMaxLength(propName, isCtxProp),\n      placeholder: getPlaceHolder(propName, isCtxProp),\n      disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n      dirty: isPropDirty(propName, isCtxProp),\n      'data-locator': getPropertyDisplayName(propName, isCtxProp),\n      'aria-label': getPropertyDisplayName(propName, isCtxProp),\n      'aria-required': getRequired(propName, isCtxProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      setLovVal: setLovDataVal(propName, isCtxProp),\n      update: setValue(propName, isCtxProp),\n      autoFocus: getAutofocus(propName, isCtxProp),\n      __vmprop__: () => vmProp,\n      fielddata: {\n        uiValue: getUIValue(propName, isCtxProp),\n        uiValues: getUIValue(propName, isCtxProp, null, false, null, 'uiValues'),\n        displayValues: getUIValue(propName, isCtxProp, null, false, null, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        isEnabled: vmProp && vmProp.isEnabled,\n        isSelectOnly: vmProp && vmProp.isSelectOnly,\n        isEditable: vmProp && vmProp.isEditable,\n        isLocalizable: vmProp && vmProp.isLocalizable,\n        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayName(propName, isCtxProp),\n        labelPlacement: getLabelPlacementFromData(propName, isCtxProp),\n        renderingHint: getRenderingHint(propName, isCtxProp),\n        propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp),\n        propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp),\n        radioVertical: vmProp && vmProp.vertical,\n        displayValsModel: getDisplayValsModel(propName, isCtxProp),\n        numberOfLines: getNumberOfLines(propName, isCtxProp),\n        dateApi: getDateApi(propName, isCtxProp),\n        isArray: getIsArray(propName, isCtxProp),\n        hasLov: getIsLov(propName, isCtxProp),\n        dataProvider: getDataProvider(propName, isCtxProp),\n        lovApi: getLovApi(propName, isCtxProp),\n        editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp),\n        action: getAction(propName, isCtxProp),\n        iconName: vmProp && vmProp.iconName,\n        iconSource: vmProp && vmProp.iconSource,\n        tooltip: vmProp && vmProp.tooltip,\n        parentUid: undefined,\n        propertyName: propName,\n        patterns: vmProp && vmProp.patterns,\n        preferredPattern: vmProp && vmProp.preferredPattern,\n        isAutoAssign: vmProp && vmProp.isAutoAssign,\n        destPanelId: vmProp && vmProp.destPanelId,\n        isRichText: vmProp && vmProp.isRichText,\n        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n      }\n    };\n  };\n\n  const constructFieldArrayOfNamedProperty = function (vmPropList, propName) {\n    let isCtxProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let vmpFieldArray = [];\n\n    _.forEach(vmPropList, function (value, index) {\n      if (value !== undefined && value !== '') {\n        const vmProp = getVmPropFromList(propName, index, isCtxProp);\n        let obj = {\n          name: vmProp.propertyName,\n          onChange: handleChange(propName, isCtxProp, index),\n          onBlur: handleBlur(propName, isCtxProp, index),\n          onClick: handleClick(propName, isCtxProp, index),\n          value: getValue(propName, isCtxProp, index),\n          checked: getValue(propName, isCtxProp, index),\n          touched: getTouched(vmProp.propertyName),\n          label: getPropertyDisplayName(propName, isCtxProp, index),\n          typex: getPropertyType(propName, isCtxProp, index),\n          error: getErrorsVMPArray(propName, index),\n          required: getRequired(propName, isCtxProp, index),\n          maxLength: getMaxLength(propName, isCtxProp, index),\n          placeholder: getPlaceHolder(propName, isCtxProp, index),\n          disabled: vmProp && (!vmProp.isEnabled || !vmProp.isEditable),\n          dirty: isPropDirty(propName, isCtxProp, index),\n          'data-locator': getPropertyDisplayName(propName, isCtxProp, index),\n          'aria-label': getPropertyDisplayName(propName, isCtxProp, index),\n          'aria-required': getRequired(propName, isCtxProp, index),\n          //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n          setLovVal: setLovDataVal(propName, isCtxProp, index),\n          update: setValue(propName, isCtxProp, index),\n          autoFocus: getAutofocus(propName, isCtxProp, index),\n          __vmprop__: () => vmProp,\n          fielddata: {\n            uiValue: getUIValue(propName, isCtxProp, index),\n            uiValues: getUIValue(propName, isCtxProp, index, false, null, 'uiValues'),\n            displayValues: getUIValue(propName, isCtxProp, index, false, null, 'displayValues'),\n            convertToHtml: value => convertToHtml(value, isCtxProp),\n            isEnabled: vmProp && vmProp.isEnabled,\n            isSelectOnly: vmProp && vmProp.isSelectOnly,\n            isEditable: vmProp && vmProp.isEditable,\n            isLocalizable: vmProp && vmProp.isLocalizable,\n            uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n            propertyDisplayName: getPropertyDisplayName(propName, isCtxProp, index),\n            labelPlacement: getLabelPlacementFromData(propName, isCtxProp, index),\n            renderingHint: getRenderingHint(propName, isCtxProp, index),\n            propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp, index),\n            propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp, index),\n            radioVertical: vmProp && vmProp.vertical,\n            displayValsModel: getDisplayValsModel(propName, isCtxProp, index),\n            numberOfLines: getNumberOfLines(propName, isCtxProp, index),\n            dateApi: getDateApi(propName, isCtxProp, index),\n            isArray: getIsArray(propName, isCtxProp, index),\n            hasLov: getIsLov(propName, isCtxProp, index),\n            dataProvider: getDataProvider(propName, isCtxProp, index),\n            lovApi: getLovApi(propName, isCtxProp, index),\n            editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp, index),\n            action: getAction(propName, isCtxProp, index),\n            iconName: vmProp && vmProp.iconName,\n            iconSource: vmProp && vmProp.iconSource,\n            tooltip: vmProp && vmProp.tooltip,\n            destPanelId: vmProp && vmProp.destPanelId,\n            isRichText: vmProp && vmProp.isRichText,\n            patterns: vmProp && vmProp.patterns,\n            preferredPattern: vmProp && vmProp.preferredPattern,\n            isAutoAssign: getIsAutoAssignVMPArray(propName, isCtxProp, index),\n            parentUid: undefined,\n            propertyName: propName,\n            emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n          }\n        };\n        vmpFieldArray.push(obj);\n      }\n    });\n\n    return vmpFieldArray;\n  };\n  /**\n   *\n   * @param { string } path pathofAtomicData\n   * @param { string } rootPath RootPath\n   * @returns {object} partialObj\n   */\n\n\n  const createPartialField = (path, rootPath) => {\n    return {\n      get value() {\n        return this.getValue();\n      },\n\n      getValue: () => {\n        let rootObject = atomicDataRef[rootPath].getAtomicData();\n        return path === '' ? rootObject : _.get(rootObject, path);\n      },\n      update: value => {\n        let rootObject = atomicDataRef[rootPath].getAtomicData();\n\n        if (path === '') {\n          rootObject = value;\n        } else {\n          _.set(rootObject, path, { ...value\n          });\n        }\n\n        atomicDataRef[rootPath].setAtomicData(_.clone(rootObject));\n        let atomicDataVmpCollection = filterFlatViewModelPropForAtomic(viewModel);\n\n        if (Object.keys(atomicDataVmpCollection).length > 0) {\n          let dataVmpCollection = filterFlatViewModelProps(viewModel.getData());\n          let stateCollection = { ...dataVmpCollection,\n            ...atomicDataVmpCollection\n          };\n          updateValidationSchema(viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection);\n          setFormValidity(stateCollection);\n        }\n      }\n    };\n  };\n  /**\n   *\n   * @param {*} path String\n   * @param {*} rootPath  String\n   * @param {*} fieldType  String\n   * @returns\n   */\n\n\n  const createFieldForAtomicData = (path, rootPath, fieldType) => {\n    if (fieldType === 'partialField') {\n      return createPartialField(path, rootPath);\n    }\n\n    return constructFieldForAtomicProperty(path, rootPath, fieldType);\n  };\n  /**\n   * @param {*} path The path of partial state object with respect to state object\n   * @param {*} rootPath  The root name of the state object\n   * @param {*} fieldType The type of the field defined in meta\n   * @returns { object }-\n   */\n\n\n  const constructFieldForAtomicProperty = (path, rootPath, fieldType) => {\n    let rootObject = viewModel.atomicData[rootPath];\n\n    let stateObj = _.get(rootObject, path);\n\n    const propName = path.split('.')[path.split('.').length - 1];\n    let viewProp = null;\n    const vmo = { ...stateObj,\n      props: {}\n    };\n    let prevFieldsRef = fieldsRef.current;\n\n    let prevFieldObject = _.get(prevFieldsRef, rootPath + '.' + path, null);\n\n    if (fieldType === 'viewModelObject' && stateObj && stateObj.props) {\n      Object.keys(stateObj.props).forEach(propertyName => {\n        viewProp = stateObj.props[propertyName];\n        let prevField = prevFieldObject && prevFieldObject.props && prevFieldObject.props[propertyName];\n        let path1 = `${path}.props.${propertyName}`;\n        let newField = creatAtomicFields(propertyName, rootPath, viewProp, path1, fieldType, stateObj);\n\n        if (isFieldsEqual(prevField, newField)) {\n          vmo.props[propertyName] = prevField;\n        } else {\n          vmo.props[propertyName] = newField;\n        }\n      });\n      return vmo;\n    } else if (fieldType === 'ViewModelProperty') {\n      viewProp = stateObj;\n    } else {\n      viewProp = modelPropertySvc.createViewModelProperty({ ...stateObj,\n        propName,\n        type: fieldType\n      });\n    }\n\n    let newFieldObject = creatAtomicFields(propName, rootPath, viewProp, path, fieldType);\n\n    if (isFieldsEqual(prevFieldObject, newFieldObject)) {\n      return prevFieldObject;\n    }\n\n    return newFieldObject;\n  };\n\n  const creatAtomicFields = function (propName, rootPath, viewProp, path, fieldType) {\n    let vmo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let isCtxProp = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let index = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let isAtomic = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n\n    const updateAtomicData = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      if (event.persist) {\n        event.persist();\n      }\n\n      if (event.additionalProp) {\n        uwPropertySvc.updateViewModelProp(viewProp, null, event.additionalProp, false);\n      }\n\n      viewProp = createUpdateValue(viewProp, event); // This is required to do later instance check.\n      // Mutating the object directly is not a good idea.\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        _.set(rtObj, `${atomicPath}`, { ...viewProp\n        });\n      } else {\n        let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n        let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n        if (val1 === viewProp.dbValue && val2 === viewProp.dbValue) {\n          return;\n        }\n\n        _.set(rtObj, `${atomicPath}.value`, viewProp.dbValue);\n\n        _.set(rtObj, `${atomicPath}.dbValue`, viewProp.dbValue);\n      }\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        let atPath = rootPath + '.' + atomicPath;\n        atPath = atPath.replace(/\\./g, '_');\n        atPath = atPath.replace(/\\[/g, '_');\n        atPath = atPath.replace(/\\]/g, '');\n        validateField(atPath, {\n          [atPath]: viewProp\n        });\n        updateTouched(atPath);\n      }\n\n      atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n    };\n\n    const getValue = () => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      return _.get(rtObj, `${atomicPath}.dbValue`);\n    };\n\n    const handleBlurAtomic = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let vmProp = _.get(rtObj, `${atomicPath}`);\n\n      if (vmProp.isArray && event.isBlurFromInput) {\n        //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n        //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n        updateArray(vmProp, event);\n      }\n\n      uwPropertySvc.updateViewModelProperty(vmProp);\n\n      if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n        let atPath = rootPath + '.' + atomicPath;\n        atPath = atPath.replace(/\\./g, '_');\n        atPath = atPath.replace(/\\[/g, '_');\n        atPath = atPath.replace(/\\]/g, '');\n        validateField(atPath, {\n          [atPath]: vmProp\n        });\n      }\n    };\n\n    const handleClickAtomic = event => {\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let vmProp = _.get(rtObj, `${atomicPath}`);\n\n      let prop = { ...vmProp\n      };\n\n      if (prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value) {\n        let indexStr = event.currentTarget.attributes.id.value;\n        let index = parseInt(indexStr);\n        let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n\n        if (!isButtonClicked) {\n          if (prop.displayValsModel[index].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov) {\n            prop.autofocus = true;\n            prop.currArrayDbValue = prop.dbValue.slice(0);\n            prop.displayValsModel[index].isInEditMode = true;\n            let newProp = createUpdateValue(prop, event);\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              _.set(rtObj, `${atomicPath}`, { ...newProp\n              });\n            } else {\n              let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n              let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n              if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n                return;\n              }\n\n              _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n              _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n            }\n\n            atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              let atPath = rootPath + '.' + atomicPath;\n              atPath = atPath.replace(/\\./g, '_');\n              atPath = atPath.replace(/\\[/g, '_');\n              atPath = atPath.replace(/\\]/g, '');\n              validateField(atPath, {\n                [atPath]: newProp\n              });\n              updateTouched(atPath);\n            }\n          } else {\n            for (var i = 0; i < prop.displayValsModel.length; i++) {\n              if (i === index && !prop.lastSelected) {\n                prop.displayValsModel[i].selected = true;\n                prop.lastSelected = prop.displayValsModel[index];\n              } else if (i === index && prop.lastSelected) {\n                if (prop.lastSelected.displayValue === prop.displayValsModel[index].displayValue) {\n                  prop.displayValsModel[i].selected = false;\n                  prop.lastSelected = undefined;\n                } else {\n                  prop.displayValsModel[i].selected = true;\n                  prop.lastSelected = prop.displayValsModel[index];\n                }\n              } else {\n                prop.displayValsModel[i].selected = false;\n              }\n            }\n\n            event.stopPropagation();\n          }\n        } else {\n          let hasActionHappened = false;\n          let titleVal = event.currentTarget.attributes.title.value;\n\n          if (titleVal && titleVal === 'Move Up' && index > 0) {\n            moveUp(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1) {\n            moveDown(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (titleVal && titleVal === 'Remove') {\n            remove(prop, index);\n            hasActionHappened = true;\n          }\n\n          if (hasActionHappened) {\n            let newProp = createUpdateValue(prop, event);\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              _.set(rtObj, `${atomicPath}`, { ...newProp\n              });\n            } else {\n              let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n              let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n              if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n                return;\n              }\n\n              _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n              _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n            }\n\n            atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n\n            if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n              let atPath = rootPath + '.' + atomicPath;\n              atPath = atPath.replace(/\\./g, '_');\n              atPath = atPath.replace(/\\[/g, '_');\n              atPath = atPath.replace(/\\]/g, '');\n              validateField(atPath, {\n                [atPath]: newProp\n              });\n              updateTouched(atPath);\n            }\n          }\n        }\n      }\n    };\n\n    const setLovDataValAtomic = (propName, isCtxProp, index, isAtomic, viewProp) => (_ref6, operation) => {\n      let {\n        lovEntry,\n        dataProvider,\n        checkLovEntries,\n        dateApi\n      } = _ref6;\n      let rtObj = atomicDataRef[rootPath].getAtomicData();\n      let atomicPath = path;\n\n      if (path.split('.').length > 3) {\n        atomicPath = validateAndUpdateDCPPath(path);\n      }\n\n      let uiProperty = _.get(rtObj, `${atomicPath}`);\n\n      return performLOVOperation({\n        uiProperty,\n        vmo: vmo,\n        lovEntry,\n        dataProvider,\n        createUpdateValue,\n        checkLovEntries,\n        dateApi\n      }, operation).then(_ref7 => {\n        let {\n          newProp,\n          isPropertyUpdateReqd\n        } = _ref7;\n\n        if (newProp && isPropertyUpdateReqd) {\n          if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n            _.set(rtObj, `${atomicPath}`, { ...newProp\n            });\n          } else {\n            let val1 = _.get(rtObj, `${atomicPath}.value`);\n\n            let val2 = _.get(rtObj, `${atomicPath}.value`);\n\n            if (val1 === newProp.dbValue && val2 === newProp.dbValue) {\n              return;\n            }\n\n            _.set(rtObj, `${atomicPath}.value`, newProp.dbValue);\n\n            _.set(rtObj, `${atomicPath}.dbValue`, newProp.dbValue);\n          }\n\n          if (fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject') {\n            let atPath = rootPath + '.' + atomicPath;\n            atPath = atPath.replace(/\\./g, '_');\n            atPath = atPath.replace(/\\[/g, '_');\n            atPath = atPath.replace(/\\]/g, '');\n            validateField(atPath, {\n              [atPath]: newProp\n            });\n            updateTouched(atPath);\n          }\n\n          atomicDataRef[rootPath].setAtomicData(_.clone(rtObj));\n        }\n\n        return newProp;\n      });\n    };\n\n    return {\n      name: propName,\n      onChange: event => {\n        updateAtomicData(event);\n      },\n      value: getValue(),\n      getValue,\n      onBlur: event => handleBlurAtomic(event),\n      // Need to fill in\n      onClick: event => handleClickAtomic(event),\n      // Need to fill in\n      update: (value, additionalProp) => {\n        let event = {\n          target: {\n            type: 'OBJECT',\n            value: value,\n            additionalProp: additionalProp\n          }\n        };\n        updateAtomicData(event);\n      },\n      // Need to fill in\n      checked: getValue(),\n      touched: getTouched(propName),\n      label: getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      typex: getPropertyType(propName, isCtxProp, index, isAtomic, viewProp),\n      error: getErrors(propName, rootPath, path),\n      required: getRequired(propName, isCtxProp, index, isAtomic, viewProp),\n      maxLength: getMaxLength(propName, isCtxProp, index, isAtomic, viewProp),\n      placeholder: getPlaceHolder(propName, isCtxProp, index, isAtomic, viewProp),\n      disabled: viewProp && (!viewProp.isEnabled || !viewProp.isEditable),\n      setLovVal: setLovDataValAtomic(propName, isCtxProp, index, isAtomic, viewProp),\n      dirty: isPropDirty(propName, isCtxProp, index, isAtomic, viewProp),\n      'data-locator': getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      'aria-label': getPropertyDisplayName(propName, isCtxProp, index, isAtomic, viewProp),\n      'aria-required': getRequired(propName, isCtxProp, index, isAtomic, viewProp),\n      //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n      autoFocus: getAutofocus(propName, isCtxProp),\n      vmo: vmo,\n      __vmprop__: () => viewProp,\n      fielddata: {\n        uiValue: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'uiValue'),\n        uiValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'uiValues'),\n        displayValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'displayValues'),\n        convertToHtml: value => convertToHtml(value, isCtxProp),\n        oldValue: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'oldValue'),\n        oldValues: getUIValue(propName, isCtxProp, index, isAtomic, viewProp, 'oldValues'),\n        isEnabled: viewProp && viewProp.isEnabled,\n        isSelectOnly: viewProp && viewProp.isSelectOnly,\n        isEditable: viewProp && viewProp.isEditable,\n        isLocalizable: viewProp && viewProp.isLocalizable,\n        uwAnchor: viewProp && viewProp.uwAnchor ? viewProp.uwAnchor : '',\n        propertyDisplayName: getPropertyDisplayName(propName, isCtxProp, null, isAtomic, viewProp),\n        labelPlacement: getLabelPlacementFromData(propName, isCtxProp, index, isAtomic, viewProp),\n        renderingHint: getRenderingHint(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyRadioTrueText: getPropertyRadioTrueText(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyRadioFalseText: getPropertyRadioFalseText(propName, isCtxProp, index, isAtomic, viewProp),\n        radioVertical: viewProp && viewProp.vertical,\n        displayValsModel: getDisplayValsModel(propName, isCtxProp, index, isAtomic, viewProp),\n        numberOfLines: getNumberOfLines(propName, isCtxProp, index, isAtomic, viewProp),\n        dateApi: getDateApi(propName, isCtxProp, index, isAtomic, viewProp),\n        isArray: getIsArray(propName, isCtxProp, index, isAtomic, viewProp),\n        hasLov: getIsLov(propName, isCtxProp, index, isAtomic, viewProp),\n        dataProvider: getDataProvider(propName, isCtxProp, index, isAtomic, viewProp),\n        lovApi: getLovApi(propName, isCtxProp, index, isAtomic, viewProp),\n        editArrayInlineMode: getEditArrayInlineMode(propName, isCtxProp, index, isAtomic, viewProp),\n        action: getAction(propName, isCtxProp, index, isAtomic, viewProp),\n        iconName: viewProp && viewProp.iconName,\n        iconSource: viewProp && viewProp.iconSource,\n        tooltip: viewProp && viewProp.tooltip,\n        patterns: viewProp && viewProp.patterns,\n        preferredPattern: getPreferredPatternVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        propertyName: propName,\n        parentUid: vmo ? vmo.uid : undefined,\n        isAutoAssign: getAutoAssignVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        isAutoAssignable: getAutoAssignableVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        patternAutoAssignFlags: getPatternAutoAssignFlagsVMO(propName, isCtxProp, index, isAtomic, viewProp),\n        emptyLOVEntry: viewProp && viewProp.emptyLOVEntry,\n        destPanelId: viewProp && viewProp.destPanelId,\n        isRichText: viewProp && viewProp.isRichText,\n        hasRevRuleAttached: viewProp && viewProp.hasRevRuleAttached\n      }\n    };\n  };\n\n  let fields = createAllFields(data, atomicData, declViewModelJson, createFieldForAtomicData, createFieldsBasedOnMetaData, constructFieldForNamedPropertyVMO, constructFieldArrayOfNamedProperty, constructFieldForNamedProperty, ctx, fieldsRef);\n  fieldsRef.current = fields;\n\n  const hasErrors = () => {\n    let formErrors = getErrorsState();\n    let hasError = false;\n\n    if (formErrors) {\n      Object.keys(formErrors || {}).forEach(value => {\n        if (formErrors[value]) {\n          hasError = true;\n        }\n      });\n    }\n\n    return hasError;\n  };\n\n  const handleSubmit = async (event, submitAction) => {\n    event.preventDefault();\n    setFormValidity(getStateCollection(viewModel));\n\n    if (!hasErrors()) {\n      document.activeElement.blur(); // focus out from the form\n\n      await submitAction();\n      handleReset();\n    } else {\n      const focusOnFirstError = () => {\n        let inputElements = event.currentTarget;\n\n        for (let idx = 0; idx < inputElements.length; idx++) {\n          if (inputElements[idx].hasAttribute('error')) {\n            inputElements[idx].focus();\n            break;\n          }\n        }\n      };\n\n      focusOnFirstError();\n    }\n  };\n\n  useInitHook(() => {\n    setFormValidity(getStateCollection(viewModel)); // 20201013 - skip no field case\n    // const keys = Object.keys( fields );\n    //if( keys.length > 0 ) {\n    //let initValues = {};\n    // Object.keys( fields ).forEach( field => {\n    //     initValues[ field ] = fields[ field ] && fields[ field ].value;\n    // } );\n    //setInitialValues( initValues );\n    //}\n  });\n  /**\n   * This function checks the pristine state of the Form.\n   * If the form has been touched, this would return false, otherwise true.\n   * @returns boolean true/false\n   */\n\n  const isFormDirty = () => {\n    let touchedObj = getTouchedState();\n    let isFormDirty = false;\n    let keys = Object.keys(touchedObj);\n\n    for (let i = 0; i < keys.length; i++) {\n      let name = keys[i];\n\n      if (touchedObj[name]) {\n        isFormDirty = true;\n        break;\n      }\n    }\n\n    return isFormDirty;\n  };\n\n  const formProp = {\n    onSubmit: handleSubmit,\n    onReset: handleReset,\n    children: {},\n    id: viewModel._internal.panelId,\n    attributes: {\n      noValidate: true,\n      autoComplete: 'off',\n      valid: getFormValidity(),\n      dirty: isFormDirty()\n    }\n  };\n  return {\n    fields,\n    formProp\n  };\n};\n/**\n * Keeping props inside a Ref. This is to avoid the stale prop issue specially with the actions\n * fired on event subscription.getProps would ensure to give latest prop;\n * @param {*} props React Props Object\n * @return {*} callback function to get the latest prop\n */\n\n_s2(useAfxForm, \"c8youxKBlZDxb+HWbIXAvcZz8iQ=\", false, function () {\n  return [useInitHook];\n});\n\nconst useProps = props => {\n  _s3();\n\n  const propRef = useRef(props);\n  propRef.current = props;\n  return React.useCallback(() => propRef.current, [propRef]);\n};\n/**\n * get view model context based on input\n * @param {object} vmDef view model instance factory\n * @param {object} subPanelContext sub panel context\n * @returns {object} view model context as:\n * {\n *     viewModel: {\n *         data,\n *         dispatch: function( { path: 'ctx.a', value: 3 } ) // way to update viewModel directly\n *     },\n *     actions: {\n *         myAction: executeAction.bind(null, 'myAction', vm)\n *     },\n *     ctx,\n *     fields: {\n *         first_name: {\n *             name: value,\n *             onChange: handleChange(value),\n *             onBlur: handleBlur(value),\n *             value: getValue(value),\n *             checked: getValue(value),\n *             touched: getTouched(value),\n *             propertyDisplayName: getPropertyDisplayName(value),\n *             label:  getPropertyDisplayName(value),\n *             typex: getPropertyType(value),\n *             helperText: getErrors(value),\n *             error: getErrors(value),\n *             required: getRequired(value),\n *             labelPlacement: getLabelPlacement(value),\n *             dirty: isModified(value)\n *         }\n *     },\n *     formSubmit: // Please bind this with form submit button\n * }\n */\n\n/* eslint-disable react-hooks/rules-of-hooks */\n\n\n_s3(useProps, \"Z4ZcnD5XDrf7a5m0u8SmAMrbBDU=\");\n\nexport const useAfxViewModel = (vmDef, prop, renderOptions, ctxImports) => {\n  _s5();\n\n  const declViewModelJson = vmDef._internal.origDeclViewModelJson;\n  const getProps = useProps(prop);\n  let vmpCollRef = useRef(null);\n  let vmpValidationSchema = useRef(null);\n  let fieldsRef = useRef(null);\n  const getFields = React.useCallback(() => fieldsRef.current, [fieldsRef]);\n\n  const setFields = fields => {\n    if (fieldsRef.current !== fields) {\n      fieldsRef.current = fields;\n    }\n  }; // data\n\n\n  const dataHook = useReducer(reducer, null, vmDef.createData); // fieldsdata\n\n  const allAtomicData = useAtomicDataReducer(declViewModelJson); // ctx\n\n  const {\n    ctx,\n    ctxMin,\n    ctxDispatch\n  } = useDerivedState(vmDef, prop, dataHook[0], ctxImports);\n  const ctxHook = [{ ...ctx,\n    ...ctxMin\n  }, ctxDispatch]; // sync strategy ports\n\n  const portsHook = useReducer(reducer, null, vmDef.createPorts); // subPanelContext\n\n  useMemo(() => {\n    updateSubPanelContext(vmDef._internal.origDeclViewModelJson.data, dataHook, prop.subPanelContext);\n  }, [prop.subPanelContext]);\n  let subscriptions = useRef(null);\n  let editHandlerRef = useRef(null); //CommandsViewModel maintains its own lifecycle and has separate subscriptions from parent viewModel\n  //E.g. Container view has some events and container view has commandbar so there are 2 viewmodels\n  // and 2 subscriptions. Lifecycle of command viewModel subscription though is limited to command click\n  // since runActionWithViewModel is not component, we need to declare useRef outside ( under component)\n\n  let subscriptionsForCommands = useRef(null);\n  /**\n   * Run an action with a different view model from the one used by this component\n   *\n   * @param {Object} viewModelJson The unprocessed JSON\n   * @param {String} actionId ID of the action to execute\n   * @param {Object} scope (Optional) Additional properties to include in execution scope\n   */\n\n  const runActionWithViewModel = async function (viewModelJson, actionId) {\n    let scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const trace = new Debug('declViewModelService:actionId'); //get view model ready for executing action\n\n    const commandVmDef = createDeclViewModel(viewModelJson, prop);\n    commandVmDef.data = commandVmDef.data || {};\n    /**\n     * TODO: This takes ~1s for commandsViewModel. Options to fix are:\n     *  1. Cache based on view model ID (so first command click is slow but rest are not)\n     *    - Still results in processing more i18n than necessary\n     *  2. Use lazy getter\n     *    - viewModel.i18n[key] would now be a promise, which would have significant impact\n     */\n\n    commandVmDef.i18n = await awDuiLocalizationSvc.populateI18nMap(viewModelJson.i18n, null);\n    const processedVm = processViewModel(commandVmDef, ctxHook, dataHook);\n    const commandsViewModel = processedVm.viewModel;\n    const subscriptionObject = setupLifeCycle(commandVmDef, commandsViewModel, ctxHook[0], () => prop, null, true, runActionWithViewModel, subscriptionsForCommands, getFields); //Actions being executed can access anything in ctx, even if useSelector hook is not setup\n\n    const executionScope = { ...scope,\n      data: commandsViewModel,\n      ctx: ctxHook[0]\n    };\n    const result = await viewModelService.executeCommand(commandsViewModel, actionId, executionScope); //executeCommand is resolved after first action is complete. We have to wait on all following actions (triggered by events) to complete before resolving\n\n    const resolveWhenCommandsViewModelIsNotActive = new Promise(resolve => {\n      const intervalId = setInterval(() => {\n        if (!commandsViewModel.getToken().isActive()) {\n          clearInterval(intervalId);\n          return resolve();\n        }\n\n        trace('Action is still executing checking again in 50ms', actionId);\n        return null;\n      }, 50);\n    });\n    await resolveWhenCommandsViewModelIsNotActive; //cleanup the view model\n\n    subscriptionObject();\n    return result;\n  }; // view model\n\n\n  const {\n    viewModel,\n    grids\n  } = processViewModel(vmDef, ctxHook, dataHook, portsHook, allAtomicData, getProps, runActionWithViewModel, getFields); // i18n\n\n  const [i18n, i18nLoaded] = useI18n(viewModel);\n  viewModel.i18n = i18n;\n  let stateCollection = getStateCollection(viewModel);\n  updateValidationSchema(viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection); // form\n\n  const {\n    fields,\n    formProp\n  } = useAfxForm(vmDef, viewModel, ctxHook[0], dataHook, i18n, vmDef._internal.origDeclViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema);\n  setFields(fields);\n  let dataCtxNode = {\n    props: prop,\n    data: viewModel,\n    ctx: ctxHook[0],\n    subPanelContext: prop.subPanelContext,\n    ports: viewModel.ports,\n    getProps,\n    getFields,\n    fields\n  }; // selectionModels\n\n  viewModel.selectionModels = useSelectionModels(vmDef._internal.selectionModels, dataCtxNode);\n  useDataProviders(vmDef.dataProviders, getProps, dataCtxNode); // tableContext\n\n  const [gridContextPlaceholder, gridContextDispatcher] = useGridContext(prop);\n  useGrids(vmDef.grids, dataCtxNode, vmDef.dataProviders, gridContextPlaceholder, gridContextDispatcher, viewModel, getProps); // Setup lifecycle\n  // NOTE: it should be setupLifeCycle, but there is a eslint rule to force the function name to be 'useXXX'\n\n  useInitHook(() => setupLifeCycle(vmDef, viewModel, ctxHook[0], getProps, renderOptions, false, runActionWithViewModel, subscriptions, getFields), i18nLoaded);\n  useInitHook(() => declDragAndDropService.updateDeps(viewModel)); // grids\n\n  if (i18nLoaded === true) {\n    for (const gridDefKey in grids) {\n      let gridInstance = grids[gridDefKey];\n      gridInstance.i18nLoaded = i18nLoaded;\n    }\n  }\n\n  useGrid(prop, vmDef.getPanelId(), gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel); //lovs\n\n  useLOVs(fields, prop, viewModel, renderOptions); // initialize popups\n\n  usePopups(viewModel); //messages\n\n  const messages = useMessages(viewModel, fields); // drag and drop\n\n  declDragAndDropService.setupDragAndDrop(viewModel, dataCtxNode, getProps); //update Event subscriptions\n\n  updateSubscriptions(subscriptions.current, viewModel);\n  useCommands(viewModel, prop, renderOptions);\n\n  for (let key in viewModel.declViewModelJson.conditions) {\n    conditionService.registerWatch(viewModel.conditions, viewModel, key, [viewModel.declViewModelJson.conditions[key].expression], vmDef.oldExpressions);\n  }\n\n  vmDef.oldExpressions = viewModel.expressions;\n\n  if (viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate && Array.isArray(viewModel.declViewModelJson.lifecycleHooks.onUpdate)) {\n    var _s4 = $RefreshSig$();\n\n    _s4(_.forEach(viewModel.declViewModelJson.lifecycleHooks.onUpdate, _s4(function (onUpdateDef, i) {\n      _s4();\n\n      let observerObjs = [];\n\n      if (viewModel.declViewModelJson.lifecycleHooks && onUpdateDef) {\n        let obj = onUpdateDef;\n        let evContext = {\n          props: prop,\n          viewModel,\n          fields: getFields()\n        };\n\n        _.forEach(obj.observers, function (observer) {\n          let evaluatedObj = _.get(evContext, observer); //populate observers irrespective of their value\n          //This aids usecases where initial values for observers are null/undefined and are populated eventually\n\n\n          observerObjs.push(evaluatedObj);\n        });\n      }\n\n      useEffect(function () {\n        //don't execute hook if all parameters are undefined\n        if (observerObjs.filter(x => !_.isUndefined(x)).length) {\n          if (logger.isDeclarativeLogEnabled()) {\n            debugService.debugLifecyleHooks('onUpdate', viewModel, observerObjs);\n          }\n\n          debugService.debug('lifeCycles', viewModel._internal.panelId, 'update');\n          viewModel.lifecycleHooks.onUpdate[i](renderOptions);\n        }\n      }, observerObjs);\n    }, \"OD7bBpZva5O2jO+Puf00hKivP7c=\")), \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n  } else {\n    let observerObjs = [];\n\n    if (viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate) {\n      let obj = viewModel.declViewModelJson.lifecycleHooks.onUpdate;\n      let evContext = {\n        props: prop,\n        viewModel,\n        fields: getFields()\n      };\n\n      _.forEach(obj.observers, function (observer) {\n        let evaluatedObj = _.get(evContext, observer); //populate observers irrespective of their value\n        //This aids usecases where initial values for observers are null/undefined and are populated eventually\n\n\n        observerObjs.push(evaluatedObj);\n      });\n    }\n\n    useEffect(function () {\n      //don't execute hook if all parameters are undefined\n      if (observerObjs.filter(x => !_.isUndefined(x)).length) {\n        if (logger.isDeclarativeLogEnabled()) {\n          debugService.debugLifecyleHooks('onUpdate', viewModel, observerObjs);\n        }\n\n        debugService.debug('lifeCycles', viewModel._internal.panelId, 'update');\n        executeHook('onUpdate', viewModel, prop, renderOptions);\n      }\n    }, observerObjs);\n  }\n\n  viewModel.editHandlers = useEditHandlers(vmDef._internal.editHandlers, viewModel, dataCtxNode, editHandlerRef, fields); // Edit handlers\n\n  const editContexts = findEditContexts(viewModel);\n\n  if (editContexts.length > 0) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEditHandlers2(viewModel);\n  } // update Sync path\n\n\n  let path = '';\n\n  if (prop.viewId && prop.viewPath) {\n    let viewPathArray = prop.viewPath.split('/');\n\n    if (prop.viewId === prop.viewPath) {\n      path = prop.viewPath;\n    } else if (prop.viewId === viewPathArray[viewPathArray.length - 1]) {\n      path = prop.viewPath;\n    } else {\n      path = prop.viewPath + '/' + prop.viewId;\n    }\n  } else if (prop.viewId) {\n    path = prop.viewId;\n  }\n\n  return {\n    ctx: ctxMin,\n    ctxDeprecated: ctx,\n    ctxMin,\n    viewModel,\n    actions: viewModel.actions,\n    i18n,\n    fields,\n    grids,\n    formProp,\n    messages,\n    runActionWithViewModel,\n    gridContextPlaceholder,\n    gridContextDispatcher,\n    viewPath: path\n  };\n};\n/**\n * Edit handlers hook\n * @param {Object} viewModel View model\n */\n\n_s5(useAfxViewModel, \"orzwELkpJmJWLFUIcdZfVHUlR8g=\", false, function () {\n  return [useProps, useAtomicDataReducer, useDerivedState, useI18n, useAfxForm, useSelectionModels, useDataProviders, useGridContext, useGrids, useInitHook, useInitHook, useGrid, useLOVs, usePopups, useMessages, useCommands, useEditHandlers, useEditHandlers2];\n});\n\nexport function useEditHandlers2(viewModel) {\n  _s6();\n\n  useEffect(function () {\n    editHandlerService.updateStates2(viewModel);\n  });\n}\n/**\n * Find edit contexts of view model\n * @param {Object} viewModel View model\n * @return {String} Edit contexts\n */\n\n_s6(useEditHandlers2, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\nfunction findEditContexts(viewModel) {\n  let editContexts = [];\n\n  if (viewModel.editHandlers) {\n    for (const editHandlerName in viewModel.editHandlers) {\n      if (!viewModel.editHandlers[editHandlerName].dataSource) {\n        editContexts.push(viewModel.editHandlers[editHandlerName].context);\n      }\n    }\n  }\n\n  if (viewModel.dataProviders) {\n    for (const dataProviderName in viewModel.dataProviders) {\n      const dataProvider = viewModel.dataProviders[dataProviderName];\n\n      if (dataProvider.editContext) {\n        editContexts.push(dataProvider.editContext);\n      }\n    }\n  }\n\n  return editContexts;\n}\n/**\n * load subscriptions\n * @param {JSON} onEventDef onEvent definition\n * @param {ViewModelObject} vm view model object\n * @param {limitEventScope} limitEventScope Limit the event registration for certain view models like commands VM\n * @returns {Array} event subscriptions\n */\n\n\nexport function loadSubscriptions(onEventDef, vm, limitEventScope, getProps, runActionWithViewModel, getFields) {\n  // process event subscription\n  const res = [];\n\n  if (onEventDef) {\n    onEventDef.forEach(eventObj => {\n      // - Construct a call back to process action.\n      // - put vm to the scope of the fn and communicate to subscriber\n      // - update that vm in every render cycle ( which is anti-pattern )\n      if (!_.isEmpty(eventObj)) {\n        const subscriber = eventData => {\n          const viewModel = subscriber.vm;\n\n          if (eventData && eventData.scope) {\n            // Never mutate the existing eventData, it would causes issue when there are multiple subscriptions\n            // and the action associated with the event is async.\n            let newEventData = { ...eventData,\n              scope: { ...eventData.scope\n              }\n            };\n            newEventData.scope.data = viewModel;\n            newEventData.scope.ctx = appCtxSvc.ctx;\n            handleRegisteredEvent(newEventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields);\n          } else {\n            handleRegisteredEvent(eventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields);\n          }\n        };\n\n        subscriber.subDef = subscribe(eventObj.eventId, subscriber);\n        subscriber.vm = vm;\n        res.push(subscriber);\n      }\n    });\n  }\n\n  return res;\n}\n/**\n * Update vm to scope in event subscriptions\n * @param {Array} subscriptions event subscriptions\n * @param {ViewModelObject} vm view model object\n */\n\nexport function updateSubscriptions(subscriptions, vm) {\n  if (subscriptions) {\n    subscriptions.forEach(subscriber => subscriber.vm = vm);\n  }\n}\n/**\n * unload subscriptions from event bus\n * @param {Array} subscriptions event subscriptions\n */\n\nexport function unloadSubscriptions(subscriptions) {\n  subscriptions.forEach(subscriber => unsubscribe(subscriber.subDef) && delete subscriber.vm);\n  subscriptions.splice(0, subscriptions.length);\n}\n/**\n * cleanup edit handlers\n * @param {Array} editHandlers  editHandlers\n * @param {Object} dataCtxNode dataCtxNode\n */\n\nexport function cleanupEditHandlers(editHandlers, dataCtxNode) {\n  if (editHandlers) {\n    for (const key in editHandlers) {\n      if (editHandlers[key] && editHandlers[key].context) {\n        let contextKey = editHandlers[key].context;\n\n        if (contextKey && contextKey.match(/\\{\\{.*}}/g)) {\n          contextKey = AwInterpolateService.instance(contextKey)(dataCtxNode);\n        }\n\n        removeEditHandler(contextKey);\n      }\n    }\n  }\n}\n\nconst getDifferenceBetweenObjects = function (object, base) {\n  function changes(object, base) {\n    return _.transform(object, function (result, value, key) {\n      if (!_.isEqual(value, base[key])) {\n        result[key] = _.isObject(value) && _.isObject(base[key]) ? changes(value, base[key]) : value;\n      }\n    });\n  }\n\n  return changes(object, base);\n};\n\nconst isObject = function (item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n\nconst mergeDeep = function (target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources);\n};\n/**\n * create react component based on view model JSON\n * @param {JSON} declViewModelJson view model definition\n * @param {Function} renderFn the renderFn, default null\n * @param {Object} options the render options\n * @returns {JSX.Element} context for view interpolation\n *\n */\n\n\nexport const createComponent = function (declViewModelJson, renderFn) {\n  var _s7 = $RefreshSig$();\n\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let ctxImports = arguments.length > 3 ? arguments[3] : undefined;\n\n  const Component = prop => {\n    _s7();\n\n    splmStatsService.startComponentRenderTime();\n    const [vmDef] = useState(() => createDeclViewModel(declViewModelJson, prop));\n    const [declViewModel] = useState(() => declViewModelJson);\n    let viewData = null;\n    let elementsMap = useRef(new Map());\n    let ref = prop.domRef;\n\n    if (!ref && options.elementRefList) {\n      viewData = {\n        elementRefList: null\n      };\n      options.elementRefList.map(domElement => {\n        if (!elementsMap.current.has(domElement)) {\n          elementsMap.current.set(domElement, /*#__PURE__*/createRef(null));\n        }\n      });\n      viewData.elementRefList = elementsMap.current; // How to update props ??\n    }\n\n    let {\n      elementRefList,\n      ...restOptionsParams\n    } = { ...options\n    };\n    useVmoStore(prop, vmDef._internal.origDeclViewModelJson.props);\n    const vm = useAfxViewModel(vmDef, prop, { ...viewData,\n      ...restOptionsParams\n    }, ctxImports);\n    let {\n      i18n,\n      data,\n      dispatch\n    } = vm.viewModel;\n    let createData = vmDef.createData; // deserve to put one more useRef since createData and createDeclViewModel is very expensive\n\n    const hmrLastRef = useRef(null);\n    useEffect(function useHmrEffect() {\n      // console.log( 'hmrEffect triggered!' );\n      // Merge new data into current data\n      // TODO: Patch entire view model, maybe don't use hook approach to sync data.\n      if (hmrLastRef.current !== null) {\n        const initialData = createData(i18n);\n        const newData = createDeclViewModel(declViewModelJson, prop).createData(i18n);\n        const diffData = getDifferenceBetweenObjects(newData, initialData);\n        let mergedData = null;\n\n        if (!_.isEmpty(diffData)) {\n          mergedData = mergeDeep(data, diffData);\n          dispatch({\n            path: 'data',\n            value: { ...mergedData\n            }\n          });\n        }\n\n        hmrLastRef.current = declViewModel;\n      }\n    }, [declViewModel]);\n    let props = { ...prop,\n      ...vm\n    };\n    renderFn = renderFn || vmDef.renderFn; // support mixin (renderParams) based on render options\n\n    if (!ref && options.elementRefList) {\n      props.elementRefList = viewData.elementRefList;\n    } // initialize AwExtendedTooltip\n\n\n    if (options && options.isTootip) {\n      let action = vm.actions.extendedTooltipPopup; // justification: hooks are called in the same order each time AwExtendedTooltip renders.\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n\n      useEffect(() => {\n        action.reference.current = prop.reference.current;\n        action.userOptions.current = prop.extendedTooltipOptions;\n      }, [prop.reference.current]);\n    }\n\n    if (options.registerCtx) {\n      // justification: hooks are called in the same order each time that component renders.\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useEffect(() => {\n        let {\n          key,\n          value,\n          path\n        } = options.registerCtx;\n        appCtxSvc.registerCtx(prop.key || key, value || _.get(vm, path));\n      });\n    }\n\n    let component = renderFn(props);\n    component = setDndHandler(vm, props, component); // generic style inheritance\n\n    if (component && component.props && props && props.className) {\n      // don't repeat classes.... use simple string check\n      if (!(component.props.className && component.props.className.includes(props.className))) {\n        if (component.type && component.type.includes && component.type.includes('-')) {\n          component = /*#__PURE__*/React.cloneElement(component, {\n            class: component.props.class + ' ' + props.className\n          });\n        } else {\n          component = /*#__PURE__*/React.cloneElement(component, {\n            className: component.props.className + ' ' + props.className\n          });\n        }\n      }\n    } // inject ref prop by need\n\n\n    if (ref && component) {\n      if (props.domRef) {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          ref,\n          domRef: props.domRef\n        });\n      } else {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          ref\n        });\n      }\n    } // provide a opportunity to override appendToBody behavior through props\n\n\n    if (options.usePortal && prop.enableAppend !== false) {\n      component = /*#__PURE__*/ReactDOM.createPortal(component, prop.parent || document.body);\n    }\n\n    splmStatsService.trackComponent(declViewModelJson._viewModelId);\n    return component || null;\n  }; // Scenario: Verify zero group compile command with popup associated with ZCC (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:7\n  // Scenario: Verify zero shuttle compile command (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:74\n  // Scenario: Verify triangle and popup are not shown when there is only one visible command in the zero group compile command (attempt 2, retried)\n  //     # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:40\n  // Scenario: Verify zero shuttle compile command with/without label (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:143\n  // https://stackoverflow.com/questions/60453845/is-it-safe-to-usememo-for-jsx\n\n\n  _s7(Component, \"RSO2PDv5AsJn8/IR/8BjnzP4xNc=\", false, function () {\n    return [useVmoStore, useAfxViewModel];\n  });\n\n  if (options.useMemo === false) {\n    Component.displayName = declViewModelJson._viewModelId;\n    return Component;\n  }\n\n  Component.displayName = `${declViewModelJson._viewModelId}.memo`;\n  return /*#__PURE__*/React.memo(Component);\n};\n\nconst setDndHandler = function (vm, props, component) {\n  const dndHandlers = vm.viewModel.dndHandler || props.attachdndHandlers;\n\n  if (dndHandlers) {\n    if (component && typeof component.type === 'string') {\n      let dndListener = declDragAndDropService.setViewDnd(dndHandlers);\n      component = /*#__PURE__*/React.cloneElement(component, { ...dndListener,\n        className: component.props.className + ' aw-widgets-droppable'\n      });\n    } else {\n      if (component && component.props && !component.props.onDragEnter && component.type !== 'aw-splm-table') {\n        component = /*#__PURE__*/React.cloneElement(component, {\n          attachdndHandlers: dndHandlers\n        });\n      }\n    }\n  }\n\n  return component;\n};","map":{"version":3,"names":["React","useState","useMemo","useEffect","createRef","useRef","ReactDOM","reducer","useReducer","useInitHook","useAtomicDataReducer","convertToHtml","useDerivedState","modelPropertySvc","uwPropertySvc","awDuiLocalizationSvc","processViewModel","createDeclViewModel","subscribe","unsubscribe","publish","viewModelService","handleRegisteredEvent","conditionService","NULLDATE","_","resolveSubPanelContext","updateI18nTexts","useDataProviders","useGrid","useGrids","useGridContext","usePopups","useLOVs","updateValidationSchema","getStateCollection","filterFlatViewModelPropForAtomic","filterFlatViewModelProps","performLOVOperation","syncStrategyService","syncViewModelCacheService","useSelectionModels","useEditHandlers","removeEditHandler","useMessages","appCtxSvc","editHandlerService","declDragAndDropService","Debug","declUtils","useVmoStore","debugService","logger","createFieldsBasedOnMetaData","createAllFields","isFieldsEqual","splmStatsService","useCommands","AwInterpolateService","executeHook","hookName","viewModel","props","renderOptions","lifecycleHooks","isDeclarativeLogEnabled","debugLifecyleHooks","debug","_internal","panelId","onEvents","onEvent","length","contentLoadedEvent","find","event","eventName","eventId","includes","viewName","getViewId","split","toLowerCase","isCommandSubPanel","viewId","setupLifeCycle","vmDef","ctx","getProps","limitEventScope","runActionWithViewModel","subscriptions","getFields","current","loadSubscriptions","dataCtxNode","data","ports","subPanelContext","isEmpty","setupSyncStrategy","updateVmOnMountUnmount","clearContext","cleanupEditHandlers","editHandlers","unloadSubscriptions","destroy","actions","dispatch","onUnmount","then","set","useI18n","i18n","chartProviders","columnProviders","grids","i18nData","setI18n","i18nLoaded","setI18nLoaded","Object","keys","populateI18nMap","results","path","value","updateSubPanelContext","jsonData","dataHook","resolvedData","updateData","forEach","propValue","propName","dataClone","cloneDeep","isViewModelProperty","setValue","values","merge","useAfxForm","declViewModelJson","fieldsRef","vmpCollRef","vmpValidationSchema","dataProviders","createData","touched","setTouched","errors","setErrors","isValid","setValid","validRef","updateFormValidity","formValidity","getFormValidity","useCallback","errorsRef","updateErrors","errorObj","getErrorsState","touchedRef","updateTouched","newTouched","getTouchedState","atomicData","atomicDataRef","getVmProp","isCtxProp","name","ctxObj","get","getVmPropFromList","index","validateAndUpdateDCPPath","propsKey","substring","indexOf","isDCPProperty","replace","updateValue","updatedProp","isDCP","updatePartialCtx","isFormValid","stateCollection","schema","validationSchema","hasInvalidProps","vmPropCollection","invalidProps","entries","isNil","key","validateSyncAt","e","setFormValidity","validity","validateField","viewModelProperty","newErrors","setLovDataVal","operation","lovEntry","dataProvider","checkLovEntries","dateApi","uiProperty","getCtx","getData","vmpPropName","validateName","vmo","createUpdateValue","newProp","isPropertyUpdateReqd","Promise","resolve","setLovDataValVMO","vmoName","getVMPropForVMO","pathName","getVMO","propertyName","getVMOProps","handleChange","vmProp","vmPropName","persist","newVMProp","setValueForVmo","newVal","additionalProp","updateVal","updateViewModelProp","prevVal","handleChangeVMO","moveUp","prop","i","displayValsModel","selected","lastSelected","currDbVal","dbValue","currDisplayVal","displayValues","currDisplayValModel","splice","dirty","moveDown","remove","hasLov","isArray","handleClick","$index","currentTarget","attributes","id","indexStr","parseInt","isButtonClicked","target","type","isAnyValueSelected","j","isInEditMode","autofocus","currArrayDbValue","slice","displayValue","undefined","stopPropagation","hasActionHappened","titleVal","title","handleClickVMO","handleBlur","isBlurFromInput","updateArray","updateViewModelProperty","handleBlurVMO","isValidArrayValue","valToUpdate","isFinite","isBoolean","Date","renderingHint","defaultValue","checked","error","hasServerValidationError","createNewArrayVal","push","toUpperCase","Number","toLocaleTimeString","Array","clone","lData","getAutofocusVMO","getAutofocus","isAtomic","viewProp","getAtomicVmProp","getValueVMO","String","isUndefined","getValue","getTouched","touchedState","getErrorsVMPArray","isTouched","getErrors","rootPath","atomicPath","getPropertyDisplayName","propDisplayName","propertyDisplayName","text","getPropertyDisplayNameVMO","getPlaceHolder","placeholder","propertyType","getPropertyType","isEditable","isRequired","propertyRequiredText","getPlaceHolderVMO","getUIValue","getUIValueVMO","getRenderingHint","getRenderingHintVMO","isDateEnabled","isTimeEnabled","getPropertyTypeVMO","getRequired","getRequiredVMO","getMaxLength","maxLength","getMaxLengthVMO","getPropertyRadioTrueText","propertyRadioTrueText","getPropertyRadioTrueTextVMO","getPropertyRadioFalseText","propertyRadioFalseText","getPropertyRadioFalseTextVMO","getDisplayValsModel","getDisplayValsModelVMO","getDateApi","dateValue","initializeDateApiValues","getDateApiVMO","getIsLov","getIsLovVMO","getLovApiVMO","lovApi","getDataProvider","isFunction","getDataProviderVMO","getIsArray","getIsArrayVMO","getLovApi","getEditArrayInlineMode","editArrayInlineMode","getEditArrayInlineModeVMO","getNumberOfLines","numberOfLines","getNumberOfLinesVMO","getLabelPlacement","labelPlacement","propertyLabelDisplay","getLabelPlacementFromData","dirtyCheck","newValue","valueUpdated","displayValueUpdated","isEqual","isPropDirty","isPropDirtyVMO","getPatterns","patterns","getPreferredPattern","preferredPattern","getPreferredPatternVMO","getAutoAssignVMO","isAutoAssign","getAutoAssignableVMO","isAutoAssignable","getPatternAutoAssignFlagsVMO","patternAutoAssignFlags","getIsAutoAssign","getIsAutoAssignVMPArray","getIsAutoAssignable","getPatternAutoAssignFlags","getParentUid","uid","handleReset","getAction","action","getActionVMO","constructFieldForNamedPropertyVMO","onChange","onBlur","onClick","label","typex","required","disabled","isEnabled","setLovVal","update","autoFocus","__vmprop__","fielddata","uiValue","uiValues","oldValue","oldValues","isSelectOnly","isLocalizable","uwAnchor","radioVertical","vertical","isRichText","emptyLOVEntry","destPanelId","iconName","iconSource","tooltip","parentUid","hasRevRuleAttached","constructFieldForNamedProperty","constructFieldArrayOfNamedProperty","vmPropList","vmpFieldArray","obj","createPartialField","rootObject","getAtomicData","setAtomicData","atomicDataVmpCollection","dataVmpCollection","createFieldForAtomicData","fieldType","constructFieldForAtomicProperty","stateObj","prevFieldsRef","prevFieldObject","prevField","path1","newField","creatAtomicFields","createViewModelProperty","newFieldObject","updateAtomicData","rtObj","val1","val2","atPath","handleBlurAtomic","handleClickAtomic","setLovDataValAtomic","fields","hasErrors","formErrors","hasError","handleSubmit","submitAction","preventDefault","document","activeElement","blur","focusOnFirstError","inputElements","idx","hasAttribute","focus","isFormDirty","touchedObj","formProp","onSubmit","onReset","children","noValidate","autoComplete","valid","useProps","propRef","useAfxViewModel","ctxImports","origDeclViewModelJson","setFields","allAtomicData","ctxMin","ctxDispatch","ctxHook","portsHook","createPorts","editHandlerRef","subscriptionsForCommands","viewModelJson","actionId","scope","trace","commandVmDef","processedVm","commandsViewModel","subscriptionObject","executionScope","result","executeCommand","resolveWhenCommandsViewModelIsNotActive","intervalId","setInterval","getToken","isActive","clearInterval","selectionModels","gridContextPlaceholder","gridContextDispatcher","updateDeps","gridDefKey","gridInstance","getPanelId","messages","setupDragAndDrop","updateSubscriptions","conditions","registerWatch","expression","oldExpressions","expressions","onUpdate","onUpdateDef","observerObjs","evContext","observers","observer","evaluatedObj","filter","x","editContexts","findEditContexts","useEditHandlers2","viewPath","viewPathArray","ctxDeprecated","updateStates2","editHandlerName","dataSource","context","dataProviderName","editContext","onEventDef","vm","res","eventObj","subscriber","eventData","newEventData","subDef","contextKey","match","instance","getDifferenceBetweenObjects","object","base","changes","transform","isObject","item","mergeDeep","sources","source","shift","assign","createComponent","renderFn","options","Component","startComponentRenderTime","declViewModel","viewData","elementsMap","Map","ref","domRef","elementRefList","map","domElement","has","restOptionsParams","hmrLastRef","useHmrEffect","initialData","newData","diffData","mergedData","isTootip","extendedTooltipPopup","reference","userOptions","extendedTooltipOptions","registerCtx","component","setDndHandler","className","cloneElement","class","usePortal","enableAppend","createPortal","parent","body","trackComponent","_viewModelId","displayName","memo","dndHandlers","dndHandler","attachdndHandlers","dndListener","setViewDnd","onDragEnter"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declViewModelService.js"],"sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declViewModelService\n *\n * @namespace viewModelService\n */\nimport React, { useState, useMemo, useEffect, createRef, useRef } from 'react';\nimport ReactDOM from 'react-dom';\nimport { reducer } from 'js/store';\nimport { useReducer, useInitHook, useAtomicDataReducer, convertToHtml } from './reactHelper';\nimport { useDerivedState } from 'js/reactAppCtx';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport uwPropertySvc from 'js/uwPropertyService';\nimport awDuiLocalizationSvc from 'js/awDuiLocalizationService';\nimport { processViewModel, createDeclViewModel } from 'js/declViewModelProcessingFactory';\nimport { subscribe, unsubscribe, publish } from 'js/eventBus';\nimport viewModelService, { handleRegisteredEvent } from 'js/viewModelService';\nimport conditionService from 'js/conditionService';\nimport { NULLDATE } from 'js/dateTimeService';\nimport _ from 'lodash';\nimport { resolveSubPanelContext, updateI18nTexts } from 'js/viewModelProcessingFactory';\nimport { useDataProviders } from 'js/dataProviderUtils';\nimport { useGrid, useGrids, useGridContext } from 'js/gridProviderUtils';\nimport { usePopups } from 'js/reactPopup';\nimport { useLOVs } from 'js/lovProviderUtils';\nimport { updateValidationSchema, getStateCollection, filterFlatViewModelPropForAtomic, filterFlatViewModelProps } from 'js/propValidationUtils';\nimport { performLOVOperation } from 'js/uwLovDataService';\nimport syncStrategyService from 'js/syncStrategyService';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport { useSelectionModels } from 'js/declSelectionModelFactory';\nimport { useEditHandlers, removeEditHandler } from 'js/declEditHandlerFactory';\nimport { useMessages } from 'js/messagesProviderUtils';\nimport appCtxSvc from 'js/appCtxService';\nimport editHandlerService from 'js/editHandlerService';\nimport declDragAndDropService from 'js/declDragAndDropService';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport useVmoStore from './useVmoStore';\nimport debugService from 'js/debugService';\nimport logger from 'js/logger';\nimport { createFieldsBasedOnMetaData } from 'js/atomicDataService';\nimport { createAllFields, isFieldsEqual } from 'js/declFieldService';\nimport splmStatsService from 'js/splmStatsService';\nimport { useCommands } from 'js/commandBarUtils';\nimport AwInterpolateService from 'js/awInterpolateService';\n/**\n * execute lifecycle hook\n * @param {string} hookName hook name as 'onInit', 'onMount' and 'onUnmount'\n * @param {object} viewModel view model instance\n */\n\nconst executeHook = ( hookName, viewModel, props, renderOptions ) => {\n    if( viewModel.lifecycleHooks && viewModel.lifecycleHooks[ hookName ] ) {\n        if( logger.isDeclarativeLogEnabled() ) {\n            debugService.debugLifecyleHooks( hookName, viewModel );\n        }\n        if( hookName === 'onMount' ) {\n            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'mount' );\n        }\n        viewModel.lifecycleHooks[ hookName ]( renderOptions );\n    }\n    // support backward compatibility of XXX.contentLoaded that is equivalent to onMount\n    if( hookName === 'onMount' ) {\n        const onEvents = viewModel.onEvent;\n        if( onEvents && onEvents.length > 0 ) {\n            let contentLoadedEvent = onEvents.find( ( event ) => {\n                const eventName = event.eventId;\n                if( eventName && eventName.includes( '.contentLoaded' ) ) {\n                    // make sure contentLoaded event is subscribed for this viewmodel\n                    // handle legacy use cases too compiler will convert viewModels to PascalCase but legacy viewNames could be in camel case\n                    const viewName = viewModel.getViewId();\n                    return eventName.split( '.contentLoaded' )[ 0 ].toLowerCase() === viewName.toLowerCase();\n                }\n                return false;\n            } );\n            if( contentLoadedEvent ) {\n                publish( contentLoadedEvent.eventId );\n            }\n        }\n        // Backward compatability for command-sub-panel\n        if( props.isCommandSubPanel === 'true' ) {\n            publish( 'awPanel.reveal', {\n                panelId: props.viewId\n            } );\n        }\n    }\n};\n\n/**\n * setup view model instance lifcycle in react\n * @param {object} viewModel view model Instance\n * @param {object} ctx App Ctx object\n * @param {object} prop view model property\n * @param {object} viewData view data\n * @param {boolean} limitEventScope Flag to control whether the even needs to be limited to specific view only\n * @param {object} subscriptions subscriptions\n * @returns {function} function to teardown view model intance\n */\nconst setupLifeCycle = ( vmDef, viewModel, ctx, getProps, renderOptions, limitEventScope, runActionWithViewModel, subscriptions, getFields ) => {\n    const props = getProps();\n    subscriptions.current = loadSubscriptions( viewModel.onEvent, viewModel, limitEventScope, getProps, runActionWithViewModel, getFields );\n    let dataCtxNode = {\n        data: viewModel,\n        ctx: ctx,\n        ports: viewModel.ports,\n        props: props,\n        getProps,\n        subPanelContext: props.subPanelContext,\n        getFields\n    };\n    //Execute onMount LifecycleHook\n    executeHook( 'onInit', viewModel );\n    executeHook( 'onMount', viewModel, props, renderOptions );\n    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n        syncStrategyService.setupSyncStrategy( dataCtxNode );\n        syncStrategyService.updateVmOnMountUnmount( dataCtxNode, true );\n    }\n    // TODO: can we split this out as teardownLifCycle later??\n    return () => {\n        const clearContext = () => {\n            cleanupEditHandlers( vmDef._internal.editHandlers, dataCtxNode );\n            unloadSubscriptions( subscriptions.current );\n            vmDef._internal.destroy( true );\n            dataCtxNode = null;\n            viewModel.actions = null;\n            viewModel.dispatch = null;\n            viewModel = null;\n        };\n        //onUnmount\n        //Make sure the onUnmount action is complete before destroying the declViewModel\n        if( viewModel.lifecycleHooks && viewModel.lifecycleHooks.onUnmount ) {\n            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'unmount' );\n            viewModel.lifecycleHooks.onUnmount( renderOptions ).then( () => {\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugLifecyleHooks( 'onUnmount', viewModel );\n                }\n                if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n                    syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );\n                    syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );\n                }\n                clearContext();\n            } );\n        } else {\n            if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n                syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );\n                syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );\n            }\n            clearContext();\n        }\n    };\n};\n\n/**\n * use i18n hook\n * @param {object} viewModel view model instance\n * @returns {object} i18n string map\n */\nconst useI18n = ( { i18n, data, dispatch, chartProviders, columnProviders, grids } ) => {\n    const [ i18nData, setI18n ] = useState( {} );\n    const [ i18nLoaded, setI18nLoaded ] = useState( false );\n\n    useInitHook( () => {\n        if( i18n && Object.keys( i18n ).length > 0 ) {\n            awDuiLocalizationSvc.populateI18nMap( i18n, null ).then( results => {\n                if( results && Object.keys( results ).length > 0 ) {\n                    updateI18nTexts( data, { i18n: results }, 0 );\n                    dispatch( { path: 'data', value: { ...data } } );\n                    if( chartProviders ) {\n                        updateI18nTexts( chartProviders, { i18n: results }, 0 );\n                        dispatch( { path: 'chartProviders', value: { ...chartProviders } } );\n                    }\n                    if( columnProviders ) {\n                        updateI18nTexts( columnProviders, { i18n: results }, 0 );\n                        dispatch( { path: 'columnProviders', value: { ...columnProviders } } );\n                    }\n                    if( grids ) {\n                        updateI18nTexts( grids, { i18n: results }, 0 );\n                        dispatch( { path: 'grids', value: { ...grids } } );\n                    }\n                    setI18n( results );\n                    setI18nLoaded( true );\n                } else {\n                    setI18nLoaded( true );\n                }\n            } );\n        }\n    } );\n\n    // Stu: we should not return this i18nLoaded, the downstream setupLifCycle should not depend on i18n. If it is\n    //      we should remove the dependency\n    // Jesse: it will cause cucumber failure for sure, will do it in next MX\n    return [ i18nData, i18n && Object.keys( i18n ).length > 0 ? i18nLoaded : true ];\n};\n\n// eslint-disable-next-line require-jsdoc\nconst updateSubPanelContext = ( jsonData, dataHook, subPanelContext ) => {\n    if( subPanelContext ) {\n        let resolvedData = {};\n        resolveSubPanelContext( jsonData, subPanelContext, resolvedData );\n        const [ data, updateData ] = dataHook;\n        _.forEach( resolvedData, function( propValue, propName ) {\n            let dataClone = _.cloneDeep( data[ propName ] );\n            if( uwPropertySvc.isViewModelProperty( dataClone ) ) {\n                uwPropertySvc.setValue( dataClone, Object.values( propValue ) );\n                updateData( { path: propName, value: dataClone } );\n            } else {\n                _.merge( dataClone, propValue );\n                updateData( { path: propName, value: dataClone } );\n            }\n        } );\n    }\n};\n\n/**\n * afx form hook\n * @param {object} vmDef view model definition\n * @param {array} dataHook dataHook in data-dispatch pair\n * @param {object} i18n i18n data used by reset\n * @returns {object} fields and form props\n */\nexport const useAfxForm = ( vmDef, viewModel, ctx, dataHook, i18n, declViewModelJson, getProps, fieldsRef, vmpCollRef,\n    vmpValidationSchema ) => { // create field part. If we dont have to toch this by action we are good\n    const { dataProviders, createData } = vmDef;\n    const [ touched, setTouched ] = useState( {} );\n    const [ errors, setErrors ] = useState( {} );\n    const [ isValid, setValid ] = useState( true );\n    const [ data, updateData ] = dataHook;\n\n    const validRef = useRef( isValid );\n    const updateFormValidity = ( formValidity ) => {\n        if( validRef.current !== formValidity ) {\n            validRef.current = formValidity;\n            setValid( formValidity );\n        }\n    };\n    const getFormValidity = React.useCallback( () => validRef.current, [ validRef ] );\n\n    const errorsRef = useRef( errors );\n    const updateErrors = ( errorObj ) => {\n        if( errorObj !== errorsRef.current ) {\n            errorsRef.current = errorObj;\n            setErrors( { ...errorObj } );\n        }\n    };\n    const getErrorsState = React.useCallback( () => errorsRef.current, [ errorsRef ] );\n\n    const touchedRef = useRef( touched );\n    const updateTouched = function( path ) {\n        if( touched && touched[ path ] !== true ) {\n            let newTouched = { ...touchedRef.current, [ path ]: true };\n            touchedRef.current = newTouched;\n            setTouched( newTouched );\n        }\n    };\n    const getTouchedState = React.useCallback( () => touchedRef.current, [ touchedRef ] );\n\n    const { atomicData = {}, atomicDataRef = {} } = viewModel;\n    const props = getProps ? getProps() : {};\n\n    const getVmProp = ( isCtxProp, name ) => {\n        const ctxObj = isCtxProp ? ctx : data;\n        return _.get( ctxObj, name );\n    };\n    const getVmPropFromList = ( propName, index, isCtxProp ) => {\n        const ctxObj = isCtxProp ? ctx : data;\n        return _.get( ctxObj, propName )[ index ];\n    };\n\n    const validateAndUpdateDCPPath = ( path ) => {\n        //Identify DCP property and escape using the bracket notation.\n        //For non DCP properties too, if the keys are more than 3, we should update the path\n        const propsKey = 'props.';\n        let propName = path.substring( path.indexOf( propsKey ) + 6, path.length );\n        if( uwPropertySvc.isDCPProperty( propName ) || path.split( '.' ).length > 3 ) {\n            return path.replace( `.${propName}`, `['${propName}']` );\n        }\n        return path;\n    };\n\n    const updateValue = ( isCtxProp, name, updatedProp ) => {\n        if( updatedProp.isDCP || name.split( '.' ).length > 3 ) {\n            name = validateAndUpdateDCPPath( name );\n        }\n        isCtxProp ? appCtxSvc.updatePartialCtx( name, updatedProp ) : updateData( { path: name, value: updatedProp } );\n    };\n\n    const isFormValid = ( stateCollection ) => {\n        let schema = vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n        if( schema ) {\n            return !hasInvalidProps( stateCollection, schema );\n        }\n        return true;\n    };\n\n    const hasInvalidProps = ( vmPropCollection, schema ) => {\n        let invalidProps = {};\n        let entries = schema && vmPropCollection && Object.entries( vmPropCollection );\n        if( !declUtils.isNil( entries ) && entries.length > 0 ) {\n            for( let [ key ] of entries ) {\n                try {\n                    schema.validateSyncAt( key, vmPropCollection );\n                } catch ( e ) {\n                    if( e && e.errors ) {\n                        invalidProps[ key ] = e.errors;\n                        break;\n                    }\n                }\n            }\n        }\n        return Object.keys( invalidProps ).length !== 0;\n    };\n\n    const setFormValidity = ( stateCollection ) => {\n        let validity = isFormValid( stateCollection );\n        updateFormValidity( validity );\n    };\n\n    const validateField = ( name, viewModelProperty ) => {\n        let newErrors = getErrorsState();\n        let schema = null;\n        try {\n            schema = viewModelProperty && vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;\n            if( schema ) {\n                schema.validateSyncAt( name, viewModelProperty );\n                // No need to update the errors object, if the \"property name\" is not present earlier.\n                if( newErrors && newErrors[ name ] ) {\n                    delete newErrors[ name ];\n                    updateErrors( { ...newErrors } );\n                }\n            }\n        } catch ( e ) {\n            if( e && e.errors ) {\n                newErrors = { ...newErrors, [ name ]: e.errors };\n                updateErrors( newErrors );\n            }\n        } finally {\n            setFormValidity( getStateCollection( viewModel ) );\n        }\n    };\n\n    const setLovDataVal = ( name, isCtxProp, index ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n        if( name.includes( '[' ) ) {\n            name = name.replace( / *\\[[^\\]]*]/, '' );\n        }\n        let uiProperty;\n        if( isCtxProp ) {\n            uiProperty = appCtxSvc.getCtx( name );\n        } else if( !_.isNil( index ) ) {\n            uiProperty = viewModel.getData()[ name ][ index ];\n        } else {\n            uiProperty = viewModel.getData()[ name ];\n        }\n        let vmpPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n\n        return performLOVOperation( {\n            uiProperty,\n            vmo: null,\n            lovEntry,\n            dataProvider,\n            createUpdateValue,\n            checkLovEntries,\n            dateApi\n        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n            if( newProp && isPropertyUpdateReqd ) {\n                updateValue( isCtxProp, vmpPropName, newProp );\n                updateTouched( validateName );\n                validateField( validateName, {\n                    [ validateName ]: newProp\n                } );\n            }\n            return Promise.resolve( newProp );\n        } );\n    };\n    const setLovDataValVMO = ( vmoName, propName, isCtxProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n        let uiProperty = isCtxProp ? appCtxSvc.getCtx( propName ) : getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n\n        return performLOVOperation( {\n            uiProperty,\n            vmo: getVMO( vmoName ),\n            lovEntry,\n            dataProvider,\n            createUpdateValue,\n            checkLovEntries,\n            dateApi\n        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n            if( newProp && isPropertyUpdateReqd ) {\n                updateValue( isCtxProp, pathName, newProp );\n                updateTouched( propName );\n                validateField( uiProperty.propertyName, getVMOProps( vmoName ) );\n                return Promise.resolve( newProp );\n            }\n        } );\n    };\n\n    const handleChange = ( name, isCtxProp, index ) => event => {\n        const vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n        if( event.persist ) {\n            event.persist();\n        }\n        let newVMProp = createUpdateValue( vmProp, event );\n        updateValue( isCtxProp, vmPropName, newVMProp );\n        updateTouched( validateName );\n        validateField( validateName, {\n            [ validateName ]: newVMProp\n        } );\n    };\n\n    const setValueForVmo = ( vmoName, propName, isCtxProp ) => ( newVal, additionalProp ) => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n        let updateVal = { ...vmProp };\n        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );\n        updateValue( isCtxProp, pathName, updateVal );\n        updateTouched( propName );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const setValue = ( name, isCtxProp, index ) => ( newVal, additionalProp ) => {\n        const prevVal = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';\n        let validateName = _.isNil( index ) ? name : name + '_' + index;\n        let updateVal = { ...prevVal };\n        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );\n        updateValue( isCtxProp, vmPropName, updateVal );\n        // check validity and update Touched\n        updateTouched( validateName );\n        validateField( validateName, {\n            [ validateName ]: updateVal\n        } );\n    };\n\n    const handleChangeVMO = ( vmoName, propName, isCtxProp ) => event => {\n        if( event.persist ) {\n            event.persist();\n        }\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let pathName = vmoName + '.props.' + propName;\n        updateValue( isCtxProp, pathName, createUpdateValue( vmProp, event ) );\n        updateTouched( propName );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const moveUp = ( prop, index ) => {\n        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n            if( i === index ) {\n                prop.displayValsModel[ i ].selected = false;\n                prop.lastSelected = prop.displayValsModel[ index ];\n            }\n        }\n        prop.lastSelected = null;\n        var currDbVal = prop.dbValue[ index ];\n        var currDisplayVal = prop.displayValues[ index ];\n        var currDisplayValModel = prop.displayValsModel[ index ];\n\n        prop.dbValue.splice( index, 1 );\n        prop.dbValue.splice( index - 1, 0, currDbVal );\n\n        prop.displayValues.splice( index, 1 );\n        prop.displayValues.splice( index - 1, 0, currDisplayVal );\n\n        prop.displayValsModel.splice( index, 1 );\n        prop.displayValsModel.splice( index - 1, 0, currDisplayValModel );\n\n        prop.dirty = true;\n    };\n\n    const moveDown = ( prop, index ) => {\n        index -= 1;\n        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n            if( i === index ) {\n                prop.displayValsModel[ i ].selected = false;\n                prop.lastSelected = prop.displayValsModel[ index ];\n            }\n        }\n        prop.lastSelected = null;\n        var currDbVal = prop.dbValue[ index ];\n        var currDisplayVal = prop.displayValues[ index ];\n        var currDisplayValModel = prop.displayValsModel[ index ];\n        prop.dbValue.splice( index, 1 );\n        prop.dbValue.splice( index + 1, 0, currDbVal );\n\n        prop.displayValues.splice( index, 1 );\n        prop.displayValues.splice( index + 1, 0, currDisplayVal );\n\n        prop.displayValsModel.splice( index, 1 );\n        prop.displayValsModel.splice( index + 1, 0, currDisplayValModel );\n\n        prop.dirty = true;\n    };\n\n    const remove = ( prop, index ) => {\n        index -= 2;\n        prop.dbValue.splice( index, 1 );\n\n        if( prop.hasLov ) {\n            prop.displayValues.splice( index, 1 );\n\n            if( prop.isArray ) {\n                prop.displayValsModel = prop.displayValsModel || [];\n                prop.displayValsModel.splice( index, 1 );\n            }\n        }\n        prop.dirty = true;\n    };\n\n    const handleClick = ( name, isCtxProp, $index ) => event => {\n        let vmProp = _.isNil( $index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, $index, isCtxProp );\n        let vmPropName = _.isNil( $index ) ? name : name + '[' + $index + ']';\n        let validateName = _.isNil( $index ) ? name : name + '_' + $index;\n        let prop = { ...vmProp };\n        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n            let indexStr = event.currentTarget.attributes.id.value;\n            let index = parseInt( indexStr );\n            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n            if( !isButtonClicked ) {\n                let isAnyValueSelected = false;\n                if( prop.displayValsModel ) {\n                    for( var j = 0; j < prop.displayValsModel.length; j++ ) {\n                        if( prop.displayValsModel[ j ].selected && prop.displayValsModel[ j ].isInEditMode ) {\n                            isAnyValueSelected = true;\n                            break;\n                        }\n                    }\n                }\n                if( !isAnyValueSelected ) {\n                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                        prop.autofocus = true;\n                        prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                        prop.displayValsModel[ index ].isInEditMode = true;\n                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                        updateTouched( validateName );\n                        validateField( validateName, {\n                            [ validateName ]: prop\n                        } );\n                    } else {\n                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                            if( i === index && !prop.lastSelected ) {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            } else if( i === index && prop.lastSelected ) {\n                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                    prop.displayValsModel[ i ].selected = false;\n                                    prop.lastSelected = undefined;\n                                } else {\n                                    prop.displayValsModel[ i ].selected = true;\n                                    prop.lastSelected = prop.displayValsModel[ index ];\n                                }\n                            } else {\n                                prop.displayValsModel[ i ].selected = false;\n                            }\n                        }\n                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                        updateTouched( validateName );\n                        event.stopPropagation();\n                    }\n                }\n            } else {\n                let hasActionHappened = false;\n                let titleVal;\n                if( event.currentTarget.attributes.title ) {\n                    titleVal = event.currentTarget.attributes.title.value;\n                }\n                if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                    moveUp( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                    moveDown( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Remove' ) {\n                    remove( prop, index );\n                    hasActionHappened = true;\n                }\n\n                if( hasActionHappened ) {\n                    updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );\n                    updateTouched( validateName );\n                    validateField( validateName, {\n                        [ name ]: prop\n                    } );\n                }\n            }\n        }\n    };\n    const handleClickVMO = ( vmoName, propName, isCtxProp ) => event => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        let prop = { ...vmProp };\n        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n            let indexStr = event.currentTarget.attributes.id.value;\n            let index = parseInt( indexStr );\n            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n            if( !isButtonClicked ) {\n                if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                    prop.autofocus = true;\n                    prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                    prop.displayValsModel[ index ].isInEditMode = true;\n\n                    let pathName = vmoName + '.props.' + propName;\n                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );\n                    updateTouched( propName );\n                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n                } else {\n                    for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                        if( i === index && !prop.lastSelected ) {\n                            prop.displayValsModel[ i ].selected = true;\n                            prop.lastSelected = prop.displayValsModel[ index ];\n                        } else if( i === index && prop.lastSelected ) {\n                            if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                prop.displayValsModel[ i ].selected = false;\n                                prop.lastSelected = undefined;\n                            } else {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            }\n                        } else {\n                            prop.displayValsModel[ i ].selected = false;\n                        }\n                    }\n                    event.stopPropagation();\n                }\n            } else {\n                let hasActionHappened = false;\n                let titleVal = event.currentTarget.attributes.title.value;\n                if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                    moveUp( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                    moveDown( prop, index );\n                    hasActionHappened = true;\n                }\n                if( titleVal && titleVal === 'Remove' ) {\n                    remove( prop, index );\n                    hasActionHappened = true;\n                }\n\n                if( hasActionHappened ) {\n                    let pathName = vmoName + '.props.' + propName;\n                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );\n                    updateTouched( propName );\n                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n                }\n            }\n        }\n    };\n\n    const handleBlur = ( name, isCtxProp, index ) => event => {\n        let vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        name = _.isNil( index ) ? name : vmProp.propertyName;\n        if( vmProp.isArray && event.isBlurFromInput ) {\n            //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n            updateArray( vmProp, event );\n        }\n        uwPropertySvc.updateViewModelProperty( vmProp );\n        validateField( name, {\n            [ name ]: vmProp\n        } );\n    };\n\n    const handleBlurVMO = ( vmoName, propName ) => event => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n\n        if( vmProp.isArray && event.isBlurFromInput ) {\n            //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n            updateArray( vmProp, event );\n        }\n        uwPropertySvc.updateViewModelProperty( vmProp );\n        validateField( vmProp.propertyName, getVMOProps( vmoName ) );\n    };\n\n    const isValidArrayValue = ( viewModelProperty, valToUpdate ) => {\n        var isValid = false;\n\n        if( valToUpdate !== undefined && valToUpdate !== '' && valToUpdate !== null &&\n            viewModelProperty.dbValue !== undefined ) {\n            if( viewModelProperty.type === 'INTEGERARRAY' || viewModelProperty.type === 'DOUBLEARRAY' ||\n                viewModelProperty.type === 'DATEARRAY' ) {\n                if( isFinite( valToUpdate ) ) {\n                    isValid = true;\n                }\n            } else if( viewModelProperty.type === 'BOOLEANARRAY' ) {\n                isValid = _.isBoolean( valToUpdate );\n            } else {\n                isValid = true;\n            }\n        }\n        return isValid;\n    };\n\n    const updateArray = ( prop, event ) => {\n        let indexStr;\n        let index;\n        let valToUpdate;\n        if( prop.type === 'DATEARRAY' ) {\n            index = event.index;\n            valToUpdate = new Date( event.target.value );\n        } else {\n            if( prop.type === 'BOOLEANARRAY' && prop.renderingHint === 'radiobutton' ) {\n                if( event.target.defaultValue === 'true' ) {\n                    valToUpdate = true;\n                } else if( event.target.defaultValue === 'false' ) {\n                    valToUpdate = false;\n                }\n                index = event.index;\n            } else if( prop.type === 'BOOLEANARRAY' ) {\n                valToUpdate = event.target.checked;\n                index = event.index;\n            } else {\n                indexStr = event.currentTarget.attributes.id.value;\n                index = parseInt( indexStr );\n                valToUpdate = event.currentTarget.value;\n            }\n        }\n        if( isValidArrayValue( prop, valToUpdate ) && ( !prop.error || prop.hasServerValidationError ) ) {\n            if( prop.currArrayDbValue ) {\n                prop.currArrayDbValue.splice( index, 1, valToUpdate );\n                prop.dirty = true;\n                prop.dbValue = prop.currArrayDbValue.slice( 0 );\n            }\n        } else if( prop.dbValue === '' || prop.dbValue === null || prop.dbValue === undefined ) {\n            prop.dbValue = prop.currArrayDbValue.slice( 0 );\n        }\n\n        if( prop.displayValsModel[ index ] && prop.dbValue.length > 0 ) {\n            prop.displayValsModel[ index ].displayValue = prop.dbValue[ index ];\n            prop.displayValsModel[ index ].isInEditMode = false;\n            prop.displayValsModel[ index ].selected = false;\n        }\n        prop.lastSelected = undefined;\n    };\n\n    const createNewArrayVal = ( newVal, updateVal, event ) => {\n        if( updateVal.type === 'DATEARRAY' ) {\n            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {\n                _.forEach( updateVal.dbValue, function( value ) {\n                    if( value !== undefined && value !== '' ) {\n                        newVal.push( value );\n                    }\n                } );\n                if( event.target.value ) {\n                    newVal.push( new Date( event.target.value ) );\n                }\n            } else if( event.target.value ) {\n                newVal.push( new Date( event.target.value ) );\n            }\n        } else {\n            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {\n                _.forEach( updateVal.dbValue, function( value ) {\n                    if( value !== undefined && value !== '' ) {\n                        newVal.push( value );\n                    }\n                } );\n            }\n            if( event.target.value && updateVal.type !== 'BOOLEANARRAY' ) {\n                newVal.push( event.target.value );\n            }\n            if( event.target.value && updateVal.type === 'BOOLEANARRAY' && updateVal.renderingHint === 'radiobutton' ) {\n                newVal.push( event.target.value );\n            }\n            if( event.key === 'Enter' && updateVal.type === 'BOOLEANARRAY' && event.target.checked !== undefined && updateVal.renderingHint !== 'radiobutton' ) {\n                newVal.push( event.target.checked );\n            }\n        }\n    };\n\n    const createUpdateValue = ( prevVal, event ) => {\n        let updateVal = { ...prevVal };\n\n        if( prevVal.type.toUpperCase() === 'DATEARRAY' && event.target.value === null ) {\n            return updateVal;\n        }\n\n        let newVal;\n        switch ( prevVal.type.toUpperCase() ) {\n            case 'DATE':\n                newVal = event.target.value ? Number( new Date( event.target.value ) ) : NULLDATE;\n                break;\n            case 'BOOLEAN':\n                if( event.target.type === 'radio' ) {\n                    newVal = event.target.value === 'true';\n                } else {\n                    newVal = event.target.checked;\n                }\n                break;\n            case 'INTEGER':\n                newVal = event.target.value.replace( /[^\\+|\\-|0-9]/g, '' );\n                break;\n            case 'DOUBLE':\n                newVal = event.target.value.replace( /[^\\+|\\-|0-9\\.|e]/g, '' );\n                break;\n            case 'DATETIME':\n                newVal = new Date( event.target.value ).toLocaleTimeString();\n                break;\n            case 'OBJECT':\n                newVal = Array.isArray( event.target.value ) && event.target.value.length > 0 ? event.target.value[ 0 ] : '';\n                break;\n            case 'OBJECTARRAY':\n                if( !updateVal.hasLov ) {\n                    newVal = _.clone( prevVal.dbValue );\n                    _.forEach( event.target.value, function( value ) {\n                        if( value !== undefined && value !== '' ) {\n                            newVal.push( value );\n                        }\n                    } );\n                } else {\n                    newVal = [];\n                    if( event.updateArray ) {\n                        updateArray( updateVal, event );\n                        _.forEach( updateVal.dbValue, function( value ) {\n                            if( value !== undefined && value !== '' ) {\n                                newVal.push( value );\n                            }\n                        } );\n                    } else {\n                        createNewArrayVal( newVal, updateVal, event );\n                    }\n                }\n                break;\n            case 'DOUBLEARRAY':\n            case 'DATEARRAY':\n            case 'INTEGERARRAY':\n            case 'STRINGARRAY':\n            case 'CHECKBOXARRAY':\n            case 'BOOLEANARRAY': {\n                newVal = [];\n                if( event.updateArray ) {\n                    updateArray( updateVal, event );\n                    _.forEach( updateVal.dbValue, function( value ) {\n                        if( value !== undefined && value !== '' ) {\n                            newVal.push( value );\n                        }\n                    } );\n                } else {\n                    createNewArrayVal( newVal, updateVal, event );\n                }\n                break;\n            }\n            default:\n                newVal = event.target.value;\n        }\n        uwPropertySvc.setValue( updateVal, newVal );\n        return updateVal;\n    };\n\n    const getVMO = ( vmoName, isCtxProp ) => {\n        const lData = isCtxProp ? ctx : viewModel.getData();\n        const vmo = _.get( lData, vmoName );\n        if( vmo ) {\n            return vmo;\n        }\n        return undefined;\n    };\n\n    const getAutofocusVMO = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.autofocus;\n        }\n        return undefined;\n    };\n\n    const getAutofocus = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.autofocus;\n    };\n\n    const getVMOProps = ( vmoName ) => {\n        let vmo = getVMO( vmoName );\n        if( vmo && vmo.props ) {\n            return vmo.props;\n        }\n        return undefined;\n    };\n\n    const getVMPropForVMO = ( vmoName, propName ) => {\n        let vmo = getVMO( vmoName );\n        if( vmo && vmo.props && vmo.props[ propName ] ) {\n            return vmo.props[ propName ];\n        }\n        return undefined;\n    };\n\n    const getValueVMO = ( vmProp ) => {\n        if( vmProp && vmProp.type === 'BOOLEAN' ) {\n            if( vmProp.dbValue === '' ) {\n                return undefined;\n            }\n\n            if( declUtils.isNil( vmProp.dbValue ) ) {\n                return null;\n            }\n\n            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';\n        }\n        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';\n    };\n\n    const getValue = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && vmProp.type === 'BOOLEAN' ) {\n            if( vmProp.dbValue === '' ) {\n                return undefined;\n            }\n            if( declUtils.isNil( vmProp.dbValue ) ) {\n                return null;\n            }\n\n            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';\n        }\n        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';\n    };\n\n    const getTouched = name => {\n        let touchedState = getTouchedState();\n        return touchedState[ name ] ? 'true' : 'false';\n    };\n\n    const getErrorsVMPArray = function( name, index ) {\n        let errors = getErrorsState();\n        let isTouched = getTouched( name + '_' + index );\n        return isTouched === 'true' ? errors[ name + '_' + index ] : undefined;\n    };\n\n    const getErrors = function( name, rootPath, path ) {\n        let errors = getErrorsState();\n        if( !_.isNil( rootPath ) ) {\n            let atomicPath = rootPath + '.' + path;\n            atomicPath = atomicPath.replace( /\\./g, '_' );\n            atomicPath = atomicPath.replace( /\\[/g, '_' );\n            atomicPath = atomicPath.replace( /\\]/g, '' );\n            let isTouched = getTouched( atomicPath );\n            return isTouched === 'true' ? errors[ atomicPath ] : undefined;\n        }\n        let isTouched = getTouched( name );\n        return isTouched === 'true' ? errors[ name ] : undefined;\n    };\n\n    const getAtomicVmProp = ( name, isCtxProp, index, isAtomic = false, viewProp = null ) => {\n        let vmProp;\n        if( isAtomic && viewProp ) {\n            vmProp = viewProp;\n        } else {\n            vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );\n        }\n        return vmProp;\n    };\n\n    const getPropertyDisplayName = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';\n        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n    };\n\n    const getPropertyDisplayNameVMO = ( vmProp ) => {\n        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';\n        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value\n        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;\n    };\n\n    const getPlaceHolder = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        let placeholder = '';\n        if( !vmProp ) {\n            return placeholder;\n        }\n        let propertyType = getPropertyType( name, isCtxProp, index );\n        switch ( propertyType && propertyType.toUpperCase() ) {\n            case 'DATEARRAY':\n            case 'DATE':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n                break;\n            default:\n                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else {\n                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n                }\n        }\n        return placeholder;\n    };\n\n    const getPlaceHolderVMO = ( vmProp ) => {\n        let placeholder = '';\n        if( !vmProp ) {\n            return placeholder;\n        }\n        let propertyType = vmProp.type;\n        switch ( propertyType && propertyType.toUpperCase() ) {\n            case 'DATEARRAY':\n            case 'DATETIME':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY HH:mm' : '';\n                break;\n            case 'DATE':\n                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';\n                break;\n            case 'TIME':\n                placeholder = vmProp.isEditable ? 'HH:mm:ss' : '';\n                break;\n            default:\n                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {\n                    placeholder = vmProp.propertyRequiredText;\n                } else {\n                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';\n                }\n        }\n        return placeholder;\n    };\n\n    const getUIValue = ( name, isCtxProp, index, isAtomic, viewProp, key = 'uiValue' ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp[ key ];\n    };\n\n    const getUIValueVMO = ( vmProp, key = 'uiValue' ) => {\n        if( vmProp ) {\n            return vmProp[ key ];\n        }\n        return undefined;\n    };\n\n    const getRenderingHint = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.renderingHint;\n    };\n\n    const getRenderingHintVMO = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.renderingHint;\n        }\n        return undefined;\n    };\n\n    const getPropertyType = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {\n            return 'DATETIME';\n        }\n        return vmProp && vmProp.type;\n    };\n\n    const getPropertyTypeVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {\n            return 'DATETIME';\n        }\n        return vmProp && vmProp.type;\n    };\n\n    const getRequired = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.isRequired;\n    };\n\n    const getRequiredVMO = ( vmProp ) => {\n        return vmProp && vmProp.isRequired;\n    };\n\n    const getMaxLength = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.maxLength;\n    };\n\n    const getMaxLengthVMO = ( vmProp ) => {\n        return vmProp && vmProp.maxLength;\n    };\n\n    const getPropertyRadioTrueText = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioTrueTextVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioFalseText = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n        }\n        return undefined;\n    };\n\n    const getPropertyRadioFalseTextVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {\n            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';\n        }\n        return undefined;\n    };\n\n    const getDisplayValsModel = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||\n                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||\n                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {\n            return vmProp.displayValsModel;\n        }\n        return undefined;\n    };\n\n    const getDisplayValsModelVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||\n                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||\n                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {\n            return vmProp.displayValsModel;\n        }\n        return undefined;\n    };\n\n    const getDateApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {\n            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {\n                uwPropertySvc.initializeDateApiValues( vmProp );\n            }\n            return vmProp.dateApi;\n        }\n        return undefined;\n    };\n\n    const getDateApiVMO = ( vmProp ) => {\n        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {\n            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {\n                uwPropertySvc.initializeDateApiValues( vmProp );\n            }\n            return vmProp.dateApi;\n        }\n        return undefined;\n    };\n\n    const getIsLov = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.hasLov;\n    };\n    const getIsLovVMO = ( vmProp ) => {\n        return vmProp && vmProp.hasLov;\n    };\n\n    const getLovApiVMO = ( vmProp ) => {\n        return vmProp && vmProp.lovApi;\n    };\n\n    const getDataProvider = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( !vmProp ) {\n            return undefined;\n        }\n\n        // case dynamic dataProvider\n        if( _.isFunction( vmProp.dataProvider ) ) {\n            return vmProp.dataProvider();\n        }\n\n        return vmProp.dataProvider && dataProviders && dataProviders[ vmProp.dataProvider ] ? dataProviders[ vmProp.dataProvider ] : null;\n    };\n\n    const getDataProviderVMO = ( vmProp ) => {\n        return vmProp && vmProp.dataProvider;\n    };\n\n    const getIsArray = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.isArray;\n    };\n\n    const getIsArrayVMO = ( vmProp ) => {\n        return vmProp && vmProp.isArray;\n    };\n\n    const getLovApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && vmProp.lovApi ) {\n            return vmProp.lovApi;\n        }\n        return null;\n    };\n\n    const getEditArrayInlineMode = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.editArrayInlineMode;\n    };\n\n    const getEditArrayInlineModeVMO = ( vmProp ) => {\n        return vmProp && vmProp.editArrayInlineMode;\n    };\n\n    const getNumberOfLines = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.numberOfLines;\n    };\n\n    const getNumberOfLinesVMO = ( vmProp ) => {\n        return vmProp && vmProp.numberOfLines;\n    };\n\n    // compute the label position\n    // the precedence is like this:\n    // 1. class in view (sw-row / sw-column / sw-reverse)\n    // 2. v-m prop.labelPosition\n    // 3. boolean and object use label at end\n    // 4. editable props use label at top\n    const getLabelPlacement = ( vmProp ) => {\n        var labelPlacement = '';\n\n        if( !vmProp ) {\n            return labelPlacement;\n        }\n\n        // get rid of editLayoutSide and consolidate positioning here?\n        // revisitMe ulrey. discuss with Nihar?\n        switch ( vmProp.propertyLabelDisplay ) {\n            case 'PROPERTY_LABEL_AT_RIGHT':\n                labelPlacement = 'end';\n                break;\n            case 'PROPERTY_LABEL_AT_TOP':\n                labelPlacement = 'top';\n                break;\n            case 'PROPERTY_LABEL_AT_SIDE':\n                labelPlacement = 'start';\n                break;\n            case 'NO_PROPERTY_LABEL':\n                // revistMe scott: is <aw-widget labeldisplay=\"Headless\"> also supported?\n                labelPlacement = 'none';\n                break;\n            default:\n                labelPlacement = 'default';\n        }\n        return labelPlacement;\n    };\n\n    const getLabelPlacementFromData = ( propName, vmoName, index, isAtomic = false, viewProp ) => {\n        const vmProp = isAtomic && viewProp ? viewProp : vmoName ? getVMPropForVMO( vmoName, propName ) : !declUtils.isNil( index ) ? data[ propName ][ index ] : data[ propName ];\n        return getLabelPlacement( vmProp );\n    };\n\n    /**\n     * Check if prop is dirty\n     * if uncommitted value changes, but is reverted: dirty=false\n     * @param {object} vmProp view model property\n     * @returns {boolean} true if prop is dirty\n     */\n    const dirtyCheck = ( vmProp ) => {\n        // deal with case where null !== emptystring if( vmProp.valueUpdated || vmProp.displayValueUpdated ) {\n        if( _.isNil( vmProp.value ) && _.isNil( vmProp.newValue ) ) {\n            return false;\n        }\n        return ( vmProp.valueUpdated || vmProp.displayValueUpdated ) && !_.isEqual( vmProp.value, vmProp.newValue );\n    };\n\n    /**\n     * Check if prop is dirty\n     * @param {string} name property namne\n     * @param {boolean} isCtxProp is prop from ctx (optional)\n     * @returns {boolean} true if prop is dirty / undefined if clean\n     */\n    const isPropDirty = ( name, isCtxProp, index, isAtomic = false, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp && dirtyCheck( vmProp ) ) {\n            return 'true';\n        }\n        return undefined;\n    };\n\n    /**\n     * Check if vmo prop is dirty\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} true if prop is dirty / undefined if clean\n     */\n    const isPropDirtyVMO = ( vmProp ) => {\n        if( vmProp && dirtyCheck( vmProp ) ) {\n            return 'true';\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets pattern for VMO\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {object} patterns object\n     */\n    const getPatterns = ( vmProp ) => {\n        if( vmProp && vmProp.patterns ) {\n            return vmProp.patterns;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets preferred pattern\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {string} preferred patterns value\n     */\n    const getPreferredPattern = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.preferredPattern;\n        }\n        return undefined;\n    };\n\n    const getPreferredPatternVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.preferredPattern;\n        }\n        return undefined;\n    };\n\n    const getAutoAssignVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    const getAutoAssignableVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.isAutoAssignable;\n        }\n        return undefined;\n    };\n\n    const getPatternAutoAssignFlagsVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );\n        if( vmProp ) {\n            return vmProp.patternAutoAssignFlags;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets isAutoAssign boolean value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} isAutoAssign bool value\n     */\n    const getIsAutoAssign = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    const getIsAutoAssignVMPArray = ( propName, isCtxProp, index ) => {\n        const vmProp = getAtomicVmProp( propName, isCtxProp, index );\n        if( vmProp ) {\n            return vmProp.isAutoAssign;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets isAutoAssignable boolean value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {boolean} isAutoAssignable bool value\n     */\n    const getIsAutoAssignable = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.isAutoAssignable;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets patternAutoAssignFlags value for the patterns\n     * @param {string} vmoName view-model object name\n     * @param {string} propName property name\n     * @returns {object} PatternAutoAssignFlags object\n     */\n    const getPatternAutoAssignFlags = ( vmProp ) => {\n        if( vmProp ) {\n            return vmProp.patternAutoAssignFlags;\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets parent uid\n     * @param {string} vmoName view-model object name\n     * @param {string} vmProp property name\n     * @param {boolean} isCtxProp property name\n     * @returns {string} parent uid\n     */\n    const getParentUid = ( vmoName, vmProp, isCtxProp ) => {\n        if( vmProp && ( vmProp.patterns || vmProp.patternAutoAssignFlags ) ) {\n            const vmo = getVMO( vmoName, isCtxProp );\n            return vmo && vmo.uid ? vmo.uid : undefined;\n        }\n        return undefined;\n    };\n\n    const handleReset = () => {\n        // revisitme - spond\n        // HINT: In reset case, we need to consider all extra data we put in data store rather than\n        // reset the whole data store to data def\n        updateData( { value: { ...data, ...createData( { i18n } ) } } );\n        setTouched( {} );\n        updateErrors( {} );\n        setFormValidity( getStateCollection( viewModel ) );\n    };\n\n    const getAction = ( name, isCtxProp, index, isAtomic, viewProp ) => {\n        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );\n        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;\n    };\n\n    const getActionVMO = ( vmProp ) => {\n        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;\n    };\n\n    const constructFieldForNamedPropertyVMO = ( vmoName, propName, isCtxProp = null ) => {\n        let vmProp = getVMPropForVMO( vmoName, propName );\n        return {\n            name: propName,\n            onChange: handleChangeVMO( vmoName, propName, isCtxProp ),\n            onBlur: handleBlurVMO( vmoName, propName ),\n            onClick: handleClickVMO( vmoName, propName, isCtxProp ),\n            value: getValueVMO( vmProp ),\n            checked: getValueVMO( vmProp ),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayNameVMO( vmProp ),\n            typex: getPropertyTypeVMO( vmProp ),\n            error: getErrors( propName ),\n            required: getRequiredVMO( vmProp ),\n            maxLength: getMaxLengthVMO( vmProp ),\n            placeholder: getPlaceHolderVMO( vmProp ),\n            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n            dirty: isPropDirtyVMO( vmProp ),\n            'data-locator': getPropertyDisplayNameVMO( vmProp ),\n            'aria-label': getPropertyDisplayNameVMO( vmProp ),\n            'aria-required': getRequiredVMO( vmProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            setLovVal: setLovDataValVMO( vmoName, propName, isCtxProp ),\n            vmo: getVMO( vmoName, isCtxProp ),\n            update: setValueForVmo( vmoName, propName, isCtxProp ),\n            autoFocus: getAutofocusVMO( vmProp ),\n            __vmprop__: () => vmProp,\n            fielddata: {\n                uiValue: getUIValueVMO( vmProp ),\n                uiValues: getUIValueVMO( vmProp, 'uiValues' ),\n                oldValue: getUIValueVMO( vmProp, 'oldValue' ),\n                oldValues: getUIValueVMO( vmProp, 'oldValues' ),\n                displayValues: getUIValueVMO( vmProp, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                isEnabled: vmProp && vmProp.isEnabled,\n                isSelectOnly: vmProp && vmProp.isSelectOnly,\n                isEditable: vmProp && vmProp.isEditable,\n                isLocalizable: vmProp && vmProp.isLocalizable,\n                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayNameVMO( vmProp ),\n                labelPlacement: getLabelPlacement( vmProp ),\n                renderingHint: getRenderingHintVMO( vmProp ),\n                propertyRadioTrueText: getPropertyRadioTrueTextVMO( vmProp ),\n                propertyRadioFalseText: getPropertyRadioFalseTextVMO( vmProp ),\n                radioVertical: vmProp && vmProp.vertical,\n                displayValsModel: getDisplayValsModelVMO( vmProp ),\n                numberOfLines: getNumberOfLinesVMO( vmProp ),\n                dateApi: getDateApiVMO( vmProp ),\n                isArray: getIsArrayVMO( vmProp ),\n                hasLov: getIsLovVMO( vmProp ),\n                dataProvider: getDataProviderVMO( vmProp ),\n                editArrayInlineMode: getEditArrayInlineModeVMO( vmProp ),\n                isRichText: vmProp && vmProp.isRichText,\n                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry,\n                patterns: getPatterns( vmProp ),\n                preferredPattern: getPreferredPattern( vmProp ),\n                lovApi: getLovApiVMO( vmProp ),\n                action: getActionVMO( vmProp ),\n                destPanelId: vmProp && vmProp.destPanelId,\n                iconName: vmProp && vmProp.iconName,\n                iconSource: vmProp && vmProp.iconSource,\n                tooltip: vmProp && vmProp.tooltip,\n                isAutoAssign: getIsAutoAssign( vmProp ),\n                isAutoAssignable: getIsAutoAssignable( vmProp ),\n                parentUid: getParentUid( vmoName, vmProp, isCtxProp ),\n                propertyName: propName,\n                patternAutoAssignFlags: getPatternAutoAssignFlags( vmProp ),\n                hasRevRuleAttached: vmProp && vmProp.hasRevRuleAttached\n            }\n        };\n    };\n\n    const constructFieldForNamedProperty = ( propName, isCtxProp = null ) => {\n        const vmProp = getVmProp( isCtxProp, propName );\n        return {\n            name: propName,\n            onChange: handleChange( propName, isCtxProp ),\n            onBlur: handleBlur( propName, isCtxProp ),\n            onClick: handleClick( propName, isCtxProp ),\n            value: getValue( propName, isCtxProp ),\n            checked: getValue( propName, isCtxProp ),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayName( propName, isCtxProp ),\n            typex: getPropertyType( propName, isCtxProp ),\n            error: getErrors( propName ),\n            required: getRequired( propName, isCtxProp ),\n            maxLength: getMaxLength( propName, isCtxProp ),\n            placeholder: getPlaceHolder( propName, isCtxProp ),\n            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n            dirty: isPropDirty( propName, isCtxProp ),\n            'data-locator': getPropertyDisplayName( propName, isCtxProp ),\n            'aria-label': getPropertyDisplayName( propName, isCtxProp ),\n            'aria-required': getRequired( propName, isCtxProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            setLovVal: setLovDataVal( propName, isCtxProp ),\n            update: setValue( propName, isCtxProp ),\n            autoFocus: getAutofocus( propName, isCtxProp ),\n            __vmprop__: () => vmProp,\n            fielddata: {\n                uiValue: getUIValue( propName, isCtxProp ),\n                uiValues: getUIValue( propName, isCtxProp, null, false, null, 'uiValues' ),\n                displayValues: getUIValue( propName, isCtxProp, null, false, null, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                isEnabled: vmProp && vmProp.isEnabled,\n                isSelectOnly: vmProp && vmProp.isSelectOnly,\n                isEditable: vmProp && vmProp.isEditable,\n                isLocalizable: vmProp && vmProp.isLocalizable,\n                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp ),\n                labelPlacement: getLabelPlacementFromData( propName, isCtxProp ),\n                renderingHint: getRenderingHint( propName, isCtxProp ),\n                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp ),\n                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp ),\n                radioVertical: vmProp && vmProp.vertical,\n                displayValsModel: getDisplayValsModel( propName, isCtxProp ),\n                numberOfLines: getNumberOfLines( propName, isCtxProp ),\n                dateApi: getDateApi( propName, isCtxProp ),\n                isArray: getIsArray( propName, isCtxProp ),\n                hasLov: getIsLov( propName, isCtxProp ),\n                dataProvider: getDataProvider( propName, isCtxProp ),\n                lovApi: getLovApi( propName, isCtxProp ),\n                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp ),\n                action: getAction( propName, isCtxProp ),\n                iconName: vmProp && vmProp.iconName,\n                iconSource: vmProp && vmProp.iconSource,\n                tooltip: vmProp && vmProp.tooltip,\n                parentUid: undefined,\n                propertyName: propName,\n                patterns: vmProp && vmProp.patterns,\n                preferredPattern: vmProp && vmProp.preferredPattern,\n                isAutoAssign: vmProp && vmProp.isAutoAssign,\n                destPanelId: vmProp && vmProp.destPanelId,\n                isRichText: vmProp && vmProp.isRichText,\n                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n            }\n        };\n    };\n\n    const constructFieldArrayOfNamedProperty = ( vmPropList, propName, isCtxProp = null ) => {\n        let vmpFieldArray = [];\n        _.forEach( vmPropList, function( value, index ) {\n            if( value !== undefined && value !== '' ) {\n                const vmProp = getVmPropFromList( propName, index, isCtxProp );\n                let obj = {\n                    name: vmProp.propertyName,\n                    onChange: handleChange( propName, isCtxProp, index ),\n                    onBlur: handleBlur( propName, isCtxProp, index ),\n                    onClick: handleClick( propName, isCtxProp, index ),\n                    value: getValue( propName, isCtxProp, index ),\n                    checked: getValue( propName, isCtxProp, index ),\n                    touched: getTouched( vmProp.propertyName ),\n                    label: getPropertyDisplayName( propName, isCtxProp, index ),\n                    typex: getPropertyType( propName, isCtxProp, index ),\n                    error: getErrorsVMPArray( propName, index ),\n                    required: getRequired( propName, isCtxProp, index ),\n                    maxLength: getMaxLength( propName, isCtxProp, index ),\n                    placeholder: getPlaceHolder( propName, isCtxProp, index ),\n                    disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),\n                    dirty: isPropDirty( propName, isCtxProp, index ),\n                    'data-locator': getPropertyDisplayName( propName, isCtxProp, index ),\n                    'aria-label': getPropertyDisplayName( propName, isCtxProp, index ),\n                    'aria-required': getRequired( propName, isCtxProp,\n                        index ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n                    setLovVal: setLovDataVal( propName, isCtxProp, index ),\n                    update: setValue( propName, isCtxProp, index ),\n                    autoFocus: getAutofocus( propName, isCtxProp, index ),\n                    __vmprop__: () => vmProp,\n                    fielddata: {\n                        uiValue: getUIValue( propName, isCtxProp, index ),\n                        uiValues: getUIValue( propName, isCtxProp, index, false, null, 'uiValues' ),\n                        displayValues: getUIValue( propName, isCtxProp, index, false, null, 'displayValues' ),\n                        convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                        isEnabled: vmProp && vmProp.isEnabled,\n                        isSelectOnly: vmProp && vmProp.isSelectOnly,\n                        isEditable: vmProp && vmProp.isEditable,\n                        isLocalizable: vmProp && vmProp.isLocalizable,\n                        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',\n                        propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, index ),\n                        labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index ),\n                        renderingHint: getRenderingHint( propName, isCtxProp, index ),\n                        propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index ),\n                        propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index ),\n                        radioVertical: vmProp && vmProp.vertical,\n                        displayValsModel: getDisplayValsModel( propName, isCtxProp, index ),\n                        numberOfLines: getNumberOfLines( propName, isCtxProp, index ),\n                        dateApi: getDateApi( propName, isCtxProp, index ),\n                        isArray: getIsArray( propName, isCtxProp, index ),\n                        hasLov: getIsLov( propName, isCtxProp, index ),\n                        dataProvider: getDataProvider( propName, isCtxProp, index ),\n                        lovApi: getLovApi( propName, isCtxProp, index ),\n                        editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index ),\n                        action: getAction( propName, isCtxProp, index ),\n                        iconName: vmProp && vmProp.iconName,\n                        iconSource: vmProp && vmProp.iconSource,\n                        tooltip: vmProp && vmProp.tooltip,\n                        destPanelId: vmProp && vmProp.destPanelId,\n                        isRichText: vmProp && vmProp.isRichText,\n                        patterns: vmProp && vmProp.patterns,\n                        preferredPattern: vmProp && vmProp.preferredPattern,\n                        isAutoAssign: getIsAutoAssignVMPArray( propName, isCtxProp, index ),\n                        parentUid: undefined,\n                        propertyName: propName,\n                        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry\n                    }\n                };\n                vmpFieldArray.push( obj );\n            }\n        } );\n        return vmpFieldArray;\n    };\n\n    /**\n     *\n     * @param { string } path pathofAtomicData\n     * @param { string } rootPath RootPath\n     * @returns {object} partialObj\n     */\n    const createPartialField = ( path, rootPath ) => {\n        return {\n            get value() {\n                return this.getValue();\n            },\n            getValue: () => {\n                let rootObject = atomicDataRef[ rootPath ].getAtomicData();\n                return path === '' ? rootObject : _.get( rootObject, path );\n            },\n            update: ( value ) => {\n                let rootObject = atomicDataRef[ rootPath ].getAtomicData();\n                if( path === '' ) {\n                    rootObject = value;\n                } else {\n                    _.set( rootObject, path, { ...value } );\n                }\n                atomicDataRef[ rootPath ].setAtomicData( _.clone( rootObject ) );\n                let atomicDataVmpCollection = filterFlatViewModelPropForAtomic( viewModel );\n                if( Object.keys( atomicDataVmpCollection ).length > 0 ) {\n                    let dataVmpCollection = filterFlatViewModelProps( viewModel.getData() );\n                    let stateCollection = { ...dataVmpCollection, ...atomicDataVmpCollection };\n                    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );\n                    setFormValidity( stateCollection );\n                }\n            }\n        };\n    };\n\n    /**\n     *\n     * @param {*} path String\n     * @param {*} rootPath  String\n     * @param {*} fieldType  String\n     * @returns\n     */\n    const createFieldForAtomicData = ( path, rootPath, fieldType ) => {\n        if( fieldType === 'partialField' ) {\n            return createPartialField( path, rootPath );\n        }\n        return constructFieldForAtomicProperty( path, rootPath, fieldType );\n    };\n    /**\n     * @param {*} path The path of partial state object with respect to state object\n     * @param {*} rootPath  The root name of the state object\n     * @param {*} fieldType The type of the field defined in meta\n     * @returns { object }-\n     */\n    const constructFieldForAtomicProperty = ( path, rootPath, fieldType ) => {\n        let rootObject = viewModel.atomicData[ rootPath ];\n        let stateObj = _.get( rootObject, path );\n        const propName = path.split( '.' )[ path.split( '.' ).length - 1 ];\n        let viewProp = null;\n        const vmo = { ...stateObj, props: {} };\n\n        let prevFieldsRef = fieldsRef.current;\n        let prevFieldObject = _.get( prevFieldsRef, rootPath + '.' + path, null );\n\n        if( fieldType === 'viewModelObject' && stateObj && stateObj.props ) {\n            Object.keys( stateObj.props ).forEach( ( propertyName ) => {\n                viewProp = stateObj.props[ propertyName ];\n                let prevField = prevFieldObject && prevFieldObject.props && prevFieldObject.props[ propertyName ];\n                let path1 = `${path}.props.${propertyName}`;\n                let newField = creatAtomicFields( propertyName, rootPath, viewProp, path1, fieldType, stateObj );\n                if( isFieldsEqual( prevField, newField ) ) {\n                    vmo.props[ propertyName ] = prevField;\n                } else {\n                    vmo.props[ propertyName ] = newField;\n                }\n            } );\n            return vmo;\n        } else if( fieldType === 'ViewModelProperty' ) {\n            viewProp = stateObj;\n        } else {\n            viewProp = modelPropertySvc.createViewModelProperty( { ...stateObj, propName, type: fieldType } );\n        }\n        let newFieldObject = creatAtomicFields( propName, rootPath, viewProp, path, fieldType );\n        if( isFieldsEqual( prevFieldObject, newFieldObject ) ) {\n            return prevFieldObject;\n        }\n        return newFieldObject;\n    };\n\n    const creatAtomicFields = ( propName, rootPath, viewProp, path, fieldType, vmo = null,\n        isCtxProp = false, index = null, isAtomic = true ) => {\n        const updateAtomicData = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            if( event.persist ) {\n                event.persist();\n            }\n            if( event.additionalProp ) {\n                uwPropertySvc.updateViewModelProp( viewProp, null, event.additionalProp, false );\n            }\n            viewProp = createUpdateValue( viewProp, event );\n            // This is required to do later instance check.\n            // Mutating the object directly is not a good idea.\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                _.set( rtObj, `${atomicPath}`, { ...viewProp } );\n            } else {\n                let val1 = _.get( rtObj, `${atomicPath}.value` );\n                let val2 = _.get( rtObj, `${atomicPath}.value` );\n                if( val1 === viewProp.dbValue && val2 === viewProp.dbValue ) {\n                    return;\n                }\n                _.set( rtObj, `${atomicPath}.value`, viewProp.dbValue );\n                _.set( rtObj, `${atomicPath}.dbValue`, viewProp.dbValue );\n            }\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                let atPath = rootPath + '.' + atomicPath;\n                atPath = atPath.replace( /\\./g, '_' );\n                atPath = atPath.replace( /\\[/g, '_' );\n                atPath = atPath.replace( /\\]/g, '' );\n                validateField( atPath, {\n                    [ atPath ]: viewProp\n                } );\n                updateTouched( atPath );\n            }\n            atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n        };\n        const getValue = () => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            return _.get( rtObj, `${atomicPath}.dbValue` );\n        };\n\n        const handleBlurAtomic = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let vmProp = _.get( rtObj, `${atomicPath}` );\n\n            if( vmProp.isArray && event.isBlurFromInput ) {\n                //This method does not fire a dispatch, only accepts a prop to update the input and validate it\n                //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it\n                updateArray( vmProp, event );\n            }\n            uwPropertySvc.updateViewModelProperty( vmProp );\n            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                let atPath = rootPath + '.' + atomicPath;\n                atPath = atPath.replace( /\\./g, '_' );\n                atPath = atPath.replace( /\\[/g, '_' );\n                atPath = atPath.replace( /\\]/g, '' );\n                validateField( atPath, {\n                    [ atPath ]: vmProp\n                } );\n            }\n        };\n\n        const handleClickAtomic = ( event ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let vmProp = _.get( rtObj, `${atomicPath}` );\n            let prop = { ...vmProp };\n            if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {\n                let indexStr = event.currentTarget.attributes.id.value;\n                let index = parseInt( indexStr );\n                let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';\n                if( !isButtonClicked ) {\n                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {\n                        prop.autofocus = true;\n                        prop.currArrayDbValue = prop.dbValue.slice( 0 );\n                        prop.displayValsModel[ index ].isInEditMode = true;\n\n                        let newProp = createUpdateValue( prop, event );\n\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                        } else {\n                            let val1 = _.get( rtObj, `${atomicPath}.value` );\n                            let val2 = _.get( rtObj, `${atomicPath}.value` );\n                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                                return;\n                            }\n                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                        }\n                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            let atPath = rootPath + '.' + atomicPath;\n                            atPath = atPath.replace( /\\./g, '_' );\n                            atPath = atPath.replace( /\\[/g, '_' );\n                            atPath = atPath.replace( /\\]/g, '' );\n                            validateField( atPath, {\n                                [ atPath ]: newProp\n                            } );\n                            updateTouched( atPath );\n                        }\n                    } else {\n                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {\n                            if( i === index && !prop.lastSelected ) {\n                                prop.displayValsModel[ i ].selected = true;\n                                prop.lastSelected = prop.displayValsModel[ index ];\n                            } else if( i === index && prop.lastSelected ) {\n                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {\n                                    prop.displayValsModel[ i ].selected = false;\n                                    prop.lastSelected = undefined;\n                                } else {\n                                    prop.displayValsModel[ i ].selected = true;\n                                    prop.lastSelected = prop.displayValsModel[ index ];\n                                }\n                            } else {\n                                prop.displayValsModel[ i ].selected = false;\n                            }\n                        }\n                        event.stopPropagation();\n                    }\n                } else {\n                    let hasActionHappened = false;\n                    let titleVal = event.currentTarget.attributes.title.value;\n                    if( titleVal && titleVal === 'Move Up' && index > 0 ) {\n                        moveUp( prop, index );\n                        hasActionHappened = true;\n                    }\n                    if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {\n                        moveDown( prop, index );\n                        hasActionHappened = true;\n                    }\n                    if( titleVal && titleVal === 'Remove' ) {\n                        remove( prop, index );\n                        hasActionHappened = true;\n                    }\n\n                    if( hasActionHappened ) {\n                        let newProp = createUpdateValue( prop, event );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                        } else {\n                            let val1 = _.get( rtObj, `${atomicPath}.value` );\n                            let val2 = _.get( rtObj, `${atomicPath}.value` );\n                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                                return;\n                            }\n                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                        }\n                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                            let atPath = rootPath + '.' + atomicPath;\n                            atPath = atPath.replace( /\\./g, '_' );\n                            atPath = atPath.replace( /\\[/g, '_' );\n                            atPath = atPath.replace( /\\]/g, '' );\n                            validateField( atPath, {\n                                [ atPath ]: newProp\n                            } );\n                            updateTouched( atPath );\n                        }\n                    }\n                }\n            }\n        };\n\n        const setLovDataValAtomic = ( propName, isCtxProp, index, isAtomic, viewProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {\n            let rtObj = atomicDataRef[ rootPath ].getAtomicData();\n            let atomicPath = path;\n            if( path.split( '.' ).length > 3 ) {\n                atomicPath = validateAndUpdateDCPPath( path );\n            }\n            let uiProperty = _.get( rtObj, `${atomicPath}` );\n\n            return performLOVOperation( {\n                uiProperty,\n                vmo: vmo,\n                lovEntry,\n                dataProvider,\n                createUpdateValue,\n                checkLovEntries,\n                dateApi\n            }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {\n                if( newProp && isPropertyUpdateReqd ) {\n                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                        _.set( rtObj, `${atomicPath}`, { ...newProp } );\n                    } else {\n                        let val1 = _.get( rtObj, `${atomicPath}.value` );\n                        let val2 = _.get( rtObj, `${atomicPath}.value` );\n                        if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {\n                            return;\n                        }\n                        _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );\n                        _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );\n                    }\n                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {\n                        let atPath = rootPath + '.' + atomicPath;\n                        atPath = atPath.replace( /\\./g, '_' );\n                        atPath = atPath.replace( /\\[/g, '_' );\n                        atPath = atPath.replace( /\\]/g, '' );\n                        validateField( atPath, {\n                            [ atPath ]: newProp\n                        } );\n                        updateTouched( atPath );\n                    }\n                    atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );\n                }\n                return newProp;\n            } );\n        };\n        return {\n            name: propName,\n            onChange: ( event ) => {\n                updateAtomicData( event );\n            },\n            value: getValue(),\n            getValue,\n            onBlur: ( event ) => handleBlurAtomic( event ), // Need to fill in\n            onClick: ( event ) => handleClickAtomic( event ), // Need to fill in\n            update: ( value, additionalProp ) => {\n                let event = {\n                    target: {\n                        type: 'OBJECT',\n                        value: value,\n                        additionalProp : additionalProp\n                    }\n                };\n                updateAtomicData( event );\n            }, // Need to fill in\n            checked: getValue(),\n            touched: getTouched( propName ),\n            label: getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            typex: getPropertyType( propName, isCtxProp, index, isAtomic, viewProp ),\n            error: getErrors( propName, rootPath, path ),\n            required: getRequired( propName, isCtxProp, index, isAtomic, viewProp ),\n            maxLength: getMaxLength( propName, isCtxProp, index, isAtomic, viewProp ),\n            placeholder: getPlaceHolder( propName, isCtxProp, index, isAtomic, viewProp ),\n            disabled: viewProp && ( !viewProp.isEnabled || !viewProp.isEditable ),\n            setLovVal: setLovDataValAtomic( propName, isCtxProp, index, isAtomic, viewProp ),\n            dirty: isPropDirty( propName, isCtxProp, index, isAtomic, viewProp ),\n            'data-locator': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            'aria-label': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),\n            'aria-required': getRequired( propName, isCtxProp, index, isAtomic,\n                viewProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute\n            autoFocus: getAutofocus( propName, isCtxProp ),\n            vmo: vmo,\n            __vmprop__: () => viewProp,\n            fielddata: {\n                uiValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValue' ),\n                uiValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValues' ),\n                displayValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'displayValues' ),\n                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),\n                oldValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValue' ),\n                oldValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValues' ),\n                isEnabled: viewProp && viewProp.isEnabled,\n                isSelectOnly: viewProp && viewProp.isSelectOnly,\n                isEditable: viewProp && viewProp.isEditable,\n                isLocalizable: viewProp && viewProp.isLocalizable,\n                uwAnchor: viewProp && viewProp.uwAnchor ? viewProp.uwAnchor : '',\n                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, null, isAtomic, viewProp ),\n                labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index, isAtomic, viewProp ),\n                renderingHint: getRenderingHint( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index, isAtomic, viewProp ),\n                radioVertical: viewProp && viewProp.vertical,\n                displayValsModel: getDisplayValsModel( propName, isCtxProp, index, isAtomic, viewProp ),\n                numberOfLines: getNumberOfLines( propName, isCtxProp, index, isAtomic, viewProp ),\n                dateApi: getDateApi( propName, isCtxProp, index, isAtomic, viewProp ),\n                isArray: getIsArray( propName, isCtxProp, index, isAtomic, viewProp ),\n                hasLov: getIsLov( propName, isCtxProp, index, isAtomic, viewProp ),\n                dataProvider: getDataProvider( propName, isCtxProp, index, isAtomic, viewProp ),\n                lovApi: getLovApi( propName, isCtxProp, index, isAtomic, viewProp ),\n                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index, isAtomic, viewProp ),\n                action: getAction( propName, isCtxProp, index, isAtomic, viewProp ),\n                iconName: viewProp && viewProp.iconName,\n                iconSource: viewProp && viewProp.iconSource,\n                tooltip: viewProp && viewProp.tooltip,\n                patterns: viewProp && viewProp.patterns,\n                preferredPattern: getPreferredPatternVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                propertyName: propName,\n                parentUid: vmo ? vmo.uid : undefined,\n                isAutoAssign: getAutoAssignVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                isAutoAssignable: getAutoAssignableVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                patternAutoAssignFlags: getPatternAutoAssignFlagsVMO( propName, isCtxProp, index, isAtomic, viewProp ),\n                emptyLOVEntry: viewProp && viewProp.emptyLOVEntry,\n                destPanelId: viewProp && viewProp.destPanelId,\n                isRichText: viewProp && viewProp.isRichText,\n                hasRevRuleAttached: viewProp && viewProp.hasRevRuleAttached\n            }\n\n        };\n    };\n\n    let fields = createAllFields( data,\n        atomicData,\n        declViewModelJson,\n        createFieldForAtomicData,\n        createFieldsBasedOnMetaData,\n        constructFieldForNamedPropertyVMO,\n        constructFieldArrayOfNamedProperty,\n        constructFieldForNamedProperty,\n        ctx, fieldsRef );\n\n    fieldsRef.current = fields;\n\n    const hasErrors = () => {\n        let formErrors = getErrorsState();\n        let hasError = false;\n        if( formErrors ) {\n            Object.keys( formErrors || {} ).forEach( value => {\n                if( formErrors[ value ] ) {\n                    hasError = true;\n                }\n            } );\n        }\n        return hasError;\n    };\n\n    const handleSubmit = async ( event, submitAction ) => {\n        event.preventDefault();\n        setFormValidity( getStateCollection( viewModel ) );\n        if( !hasErrors() ) {\n            document.activeElement.blur(); // focus out from the form\n            await submitAction();\n            handleReset();\n        } else {\n            const focusOnFirstError = () => {\n                let inputElements = event.currentTarget;\n                for( let idx = 0; idx < inputElements.length; idx++ ) {\n                    if( inputElements[ idx ].hasAttribute( 'error' ) ) {\n                        inputElements[ idx ].focus();\n                        break;\n                    }\n                }\n            };\n            focusOnFirstError();\n        }\n    };\n\n    useInitHook( () => {\n        setFormValidity( getStateCollection( viewModel ) );\n        // 20201013 - skip no field case\n        // const keys = Object.keys( fields );\n        //if( keys.length > 0 ) {\n        //let initValues = {};\n        // Object.keys( fields ).forEach( field => {\n        //     initValues[ field ] = fields[ field ] && fields[ field ].value;\n        // } );\n        //setInitialValues( initValues );\n        //}\n    } );\n    /**\n     * This function checks the pristine state of the Form.\n     * If the form has been touched, this would return false, otherwise true.\n     * @returns boolean true/false\n     */\n    const isFormDirty = () => {\n        let touchedObj = getTouchedState();\n        let isFormDirty = false;\n        let keys = Object.keys( touchedObj );\n        for( let i = 0; i < keys.length; i++ ) {\n            let name = keys[ i ];\n            if( touchedObj[ name ] ) {\n                isFormDirty = true;\n                break;\n            }\n        }\n        return isFormDirty;\n    };\n\n    const formProp = {\n        onSubmit: handleSubmit,\n        onReset: handleReset,\n        children: {},\n        id: viewModel._internal.panelId,\n        attributes: {\n            noValidate: true,\n            autoComplete: 'off',\n            valid: getFormValidity(),\n            dirty: isFormDirty()\n        }\n    };\n\n    return {\n        fields,\n        formProp\n    };\n};\n\n/**\n * Keeping props inside a Ref. This is to avoid the stale prop issue specially with the actions\n * fired on event subscription.getProps would ensure to give latest prop;\n * @param {*} props React Props Object\n * @return {*} callback function to get the latest prop\n */\nconst useProps = ( props ) => {\n    const propRef = useRef( props );\n    propRef.current = props;\n    return React.useCallback( () => propRef.current, [ propRef ] );\n};\n\n/**\n * get view model context based on input\n * @param {object} vmDef view model instance factory\n * @param {object} subPanelContext sub panel context\n * @returns {object} view model context as:\n * {\n *     viewModel: {\n *         data,\n *         dispatch: function( { path: 'ctx.a', value: 3 } ) // way to update viewModel directly\n *     },\n *     actions: {\n *         myAction: executeAction.bind(null, 'myAction', vm)\n *     },\n *     ctx,\n *     fields: {\n *         first_name: {\n *             name: value,\n *             onChange: handleChange(value),\n *             onBlur: handleBlur(value),\n *             value: getValue(value),\n *             checked: getValue(value),\n *             touched: getTouched(value),\n *             propertyDisplayName: getPropertyDisplayName(value),\n *             label:  getPropertyDisplayName(value),\n *             typex: getPropertyType(value),\n *             helperText: getErrors(value),\n *             error: getErrors(value),\n *             required: getRequired(value),\n *             labelPlacement: getLabelPlacement(value),\n *             dirty: isModified(value)\n *         }\n *     },\n *     formSubmit: // Please bind this with form submit button\n * }\n */\n/* eslint-disable react-hooks/rules-of-hooks */\n\nexport const useAfxViewModel = ( vmDef, prop, renderOptions, ctxImports ) => {\n    const declViewModelJson = vmDef._internal.origDeclViewModelJson;\n    const getProps = useProps( prop );\n    let vmpCollRef = useRef( null );\n    let vmpValidationSchema = useRef( null );\n\n    let fieldsRef = useRef( null );\n    const getFields = React.useCallback( () => fieldsRef.current, [ fieldsRef ] );\n\n    const setFields = ( fields ) => {\n        if( fieldsRef.current !== fields ) {\n            fieldsRef.current = fields;\n        }\n    };\n\n    // data\n    const dataHook = useReducer( reducer, null, vmDef.createData );\n\n    // fieldsdata\n    const allAtomicData = useAtomicDataReducer( declViewModelJson );\n\n    // ctx\n    const { ctx, ctxMin, ctxDispatch } = useDerivedState( vmDef, prop, dataHook[ 0 ], ctxImports );\n    const ctxHook = [ { ...ctx, ...ctxMin }, ctxDispatch ];\n\n    // sync strategy ports\n    const portsHook = useReducer( reducer, null, vmDef.createPorts );\n\n    // subPanelContext\n    useMemo( () => {\n        updateSubPanelContext( vmDef._internal.origDeclViewModelJson.data, dataHook, prop.subPanelContext );\n    }, [ prop.subPanelContext ] );\n\n    let subscriptions = useRef( null );\n    let editHandlerRef = useRef( null );\n\n    //CommandsViewModel maintains its own lifecycle and has separate subscriptions from parent viewModel\n    //E.g. Container view has some events and container view has commandbar so there are 2 viewmodels\n    // and 2 subscriptions. Lifecycle of command viewModel subscription though is limited to command click\n    // since runActionWithViewModel is not component, we need to declare useRef outside ( under component)\n    let subscriptionsForCommands = useRef( null );\n    /**\n     * Run an action with a different view model from the one used by this component\n     *\n     * @param {Object} viewModelJson The unprocessed JSON\n     * @param {String} actionId ID of the action to execute\n     * @param {Object} scope (Optional) Additional properties to include in execution scope\n     */\n    const runActionWithViewModel = async ( viewModelJson, actionId, scope = {} ) => {\n        const trace = new Debug( 'declViewModelService:actionId' );\n        //get view model ready for executing action\n        const commandVmDef = createDeclViewModel( viewModelJson, prop );\n        commandVmDef.data = commandVmDef.data || {};\n\n        /**\n         * TODO: This takes ~1s for commandsViewModel. Options to fix are:\n         *  1. Cache based on view model ID (so first command click is slow but rest are not)\n         *    - Still results in processing more i18n than necessary\n         *  2. Use lazy getter\n         *    - viewModel.i18n[key] would now be a promise, which would have significant impact\n         */\n        commandVmDef.i18n = await awDuiLocalizationSvc.populateI18nMap( viewModelJson.i18n, null );\n        const processedVm = processViewModel( commandVmDef, ctxHook, dataHook );\n        const commandsViewModel = processedVm.viewModel;\n\n        const subscriptionObject = setupLifeCycle( commandVmDef, commandsViewModel, ctxHook[ 0 ], () => prop, null, true, runActionWithViewModel, subscriptionsForCommands, getFields );\n\n        //Actions being executed can access anything in ctx, even if useSelector hook is not setup\n        const executionScope = {\n            ...scope,\n            data: commandsViewModel,\n            ctx: ctxHook[ 0 ]\n        };\n\n        const result = await viewModelService.executeCommand( commandsViewModel, actionId, executionScope );\n        //executeCommand is resolved after first action is complete. We have to wait on all following actions (triggered by events) to complete before resolving\n        const resolveWhenCommandsViewModelIsNotActive = new Promise( ( resolve ) => {\n            const intervalId = setInterval( () => {\n                if( !commandsViewModel.getToken().isActive() ) {\n                    clearInterval( intervalId );\n                    return resolve();\n                }\n                trace( 'Action is still executing checking again in 50ms', actionId );\n                return null;\n            }, 50 );\n        } );\n        await resolveWhenCommandsViewModelIsNotActive;\n        //cleanup the view model\n        subscriptionObject();\n        return result;\n    };\n\n    // view model\n    const { viewModel, grids } = processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData, getProps, runActionWithViewModel, getFields );\n\n    // i18n\n    const [ i18n, i18nLoaded ] = useI18n( viewModel );\n    viewModel.i18n = i18n;\n\n    let stateCollection = getStateCollection( viewModel );\n    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );\n\n    // form\n    const { fields, formProp } = useAfxForm( vmDef, viewModel, ctxHook[ 0 ], dataHook, i18n, vmDef._internal.origDeclViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema );\n    setFields( fields );\n\n    let dataCtxNode = {\n        props: prop,\n        data: viewModel,\n        ctx: ctxHook[ 0 ],\n        subPanelContext: prop.subPanelContext,\n        ports: viewModel.ports,\n        getProps,\n        getFields,\n        fields\n    };\n\n    // selectionModels\n    viewModel.selectionModels = useSelectionModels( vmDef._internal.selectionModels, dataCtxNode );\n\n    useDataProviders( vmDef.dataProviders, getProps, dataCtxNode );\n\n    // tableContext\n    const [ gridContextPlaceholder, gridContextDispatcher ] = useGridContext( prop );\n    useGrids( vmDef.grids, dataCtxNode, vmDef.dataProviders, gridContextPlaceholder, gridContextDispatcher, viewModel, getProps );\n\n    // Setup lifecycle\n    // NOTE: it should be setupLifeCycle, but there is a eslint rule to force the function name to be 'useXXX'\n    useInitHook( () => setupLifeCycle( vmDef, viewModel, ctxHook[ 0 ], getProps, renderOptions, false, runActionWithViewModel, subscriptions, getFields ), i18nLoaded );\n\n    useInitHook( () => declDragAndDropService.updateDeps( viewModel ) );\n\n    // grids\n    if( i18nLoaded === true ) {\n        for( const gridDefKey in grids ) {\n            let gridInstance = grids[ gridDefKey ];\n            gridInstance.i18nLoaded = i18nLoaded;\n        }\n    }\n\n    useGrid( prop, vmDef.getPanelId(), gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel );\n\n    //lovs\n    useLOVs( fields, prop, viewModel, renderOptions );\n\n    // initialize popups\n    usePopups( viewModel );\n\n    //messages\n\n    const messages = useMessages( viewModel, fields );\n\n    // drag and drop\n    declDragAndDropService.setupDragAndDrop( viewModel, dataCtxNode, getProps );\n\n    //update Event subscriptions\n    updateSubscriptions( subscriptions.current, viewModel );\n\n    useCommands( viewModel, prop, renderOptions );\n\n    for( let key in viewModel.declViewModelJson.conditions ) {\n        conditionService.registerWatch( viewModel.conditions, viewModel, key, [ viewModel.declViewModelJson.conditions[ key ].expression ], vmDef.oldExpressions );\n    }\n    vmDef.oldExpressions = viewModel.expressions;\n\n    if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate && Array.isArray( viewModel.declViewModelJson.lifecycleHooks.onUpdate ) ) {\n        _.forEach( viewModel.declViewModelJson.lifecycleHooks.onUpdate, function( onUpdateDef, i ) {\n            let observerObjs = [];\n            if( viewModel.declViewModelJson.lifecycleHooks && onUpdateDef ) {\n                let obj = onUpdateDef;\n                let evContext = { props: prop, viewModel, fields: getFields() };\n                _.forEach( obj.observers, function( observer ) {\n                    let evaluatedObj = _.get( evContext, observer );\n                    //populate observers irrespective of their value\n                    //This aids usecases where initial values for observers are null/undefined and are populated eventually\n                    observerObjs.push( evaluatedObj );\n                } );\n            }\n\n            useEffect( function() {\n                //don't execute hook if all parameters are undefined\n                if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {\n                    if( logger.isDeclarativeLogEnabled() ) {\n                        debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );\n                    }\n                    debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );\n                    viewModel.lifecycleHooks.onUpdate[ i ]( renderOptions );\n                }\n            }, observerObjs );\n        } );\n    } else {\n        let observerObjs = [];\n        if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate ) {\n            let obj = viewModel.declViewModelJson.lifecycleHooks.onUpdate;\n            let evContext = { props: prop, viewModel, fields: getFields() };\n            _.forEach( obj.observers, function( observer ) {\n                let evaluatedObj = _.get( evContext, observer );\n                //populate observers irrespective of their value\n                //This aids usecases where initial values for observers are null/undefined and are populated eventually\n                observerObjs.push( evaluatedObj );\n            } );\n        }\n\n        useEffect( function() {\n            //don't execute hook if all parameters are undefined\n            if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {\n                if( logger.isDeclarativeLogEnabled() ) {\n                    debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );\n                }\n                debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );\n                executeHook( 'onUpdate', viewModel, prop, renderOptions );\n            }\n        }, observerObjs );\n    }\n\n    viewModel.editHandlers = useEditHandlers( vmDef._internal.editHandlers, viewModel, dataCtxNode, editHandlerRef, fields );\n\n    // Edit handlers\n    const editContexts = findEditContexts( viewModel );\n    if( editContexts.length > 0 ) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEditHandlers2( viewModel );\n    }\n\n    // update Sync path\n    let path = '';\n    if( prop.viewId && prop.viewPath ) {\n        let viewPathArray = prop.viewPath.split( '/' );\n        if( prop.viewId === prop.viewPath ) {\n            path = prop.viewPath;\n        } else if( prop.viewId === viewPathArray[ viewPathArray.length - 1 ] ) {\n            path = prop.viewPath;\n        } else {\n            path = prop.viewPath + '/' + prop.viewId;\n        }\n    } else if( prop.viewId ) {\n        path = prop.viewId;\n    }\n\n    return {\n        ctx: ctxMin,\n        ctxDeprecated: ctx,\n        ctxMin,\n        viewModel,\n        actions: viewModel.actions,\n        i18n,\n        fields,\n        grids,\n        formProp,\n        messages,\n        runActionWithViewModel,\n        gridContextPlaceholder,\n        gridContextDispatcher,\n        viewPath: path\n    };\n};\n\n/**\n * Edit handlers hook\n * @param {Object} viewModel View model\n */\nexport function useEditHandlers2( viewModel ) {\n    useEffect( function() {\n        editHandlerService.updateStates2( viewModel );\n    } );\n}\n\n/**\n * Find edit contexts of view model\n * @param {Object} viewModel View model\n * @return {String} Edit contexts\n */\nfunction findEditContexts( viewModel ) {\n    let editContexts = [];\n    if( viewModel.editHandlers ) {\n        for( const editHandlerName in viewModel.editHandlers ) {\n            if( !viewModel.editHandlers[ editHandlerName ].dataSource ) {\n                editContexts.push( viewModel.editHandlers[ editHandlerName ].context );\n            }\n        }\n    }\n    if( viewModel.dataProviders ) {\n        for( const dataProviderName in viewModel.dataProviders ) {\n            const dataProvider = viewModel.dataProviders[ dataProviderName ];\n            if( dataProvider.editContext ) {\n                editContexts.push( dataProvider.editContext );\n            }\n        }\n    }\n    return editContexts;\n}\n\n/**\n * load subscriptions\n * @param {JSON} onEventDef onEvent definition\n * @param {ViewModelObject} vm view model object\n * @param {limitEventScope} limitEventScope Limit the event registration for certain view models like commands VM\n * @returns {Array} event subscriptions\n */\nexport function loadSubscriptions( onEventDef, vm, limitEventScope, getProps, runActionWithViewModel, getFields ) {\n    // process event subscription\n    const res = [];\n    if( onEventDef ) {\n        onEventDef.forEach( ( eventObj ) => {\n            // - Construct a call back to process action.\n            // - put vm to the scope of the fn and communicate to subscriber\n            // - update that vm in every render cycle ( which is anti-pattern )\n            if( !_.isEmpty( eventObj ) ) {\n                const subscriber = eventData => {\n                    const viewModel = subscriber.vm;\n                    if( eventData && eventData.scope ) {\n                        // Never mutate the existing eventData, it would causes issue when there are multiple subscriptions\n                        // and the action associated with the event is async.\n                        let newEventData = { ...eventData, scope: { ...eventData.scope } };\n                        newEventData.scope.data = viewModel;\n                        newEventData.scope.ctx = appCtxSvc.ctx;\n                        handleRegisteredEvent( newEventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );\n                    } else {\n                        handleRegisteredEvent( eventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );\n                    }\n                };\n                subscriber.subDef = subscribe( eventObj.eventId, subscriber );\n                subscriber.vm = vm;\n                res.push( subscriber );\n            }\n        } );\n    }\n    return res;\n}\n\n/**\n * Update vm to scope in event subscriptions\n * @param {Array} subscriptions event subscriptions\n * @param {ViewModelObject} vm view model object\n */\nexport function updateSubscriptions( subscriptions, vm ) {\n    if( subscriptions ) {\n        subscriptions.forEach( subscriber => subscriber.vm = vm );\n    }\n}\n\n/**\n * unload subscriptions from event bus\n * @param {Array} subscriptions event subscriptions\n */\nexport function unloadSubscriptions( subscriptions ) {\n    subscriptions.forEach( subscriber => unsubscribe( subscriber.subDef ) && delete subscriber.vm );\n    subscriptions.splice( 0, subscriptions.length );\n}\n\n/**\n * cleanup edit handlers\n * @param {Array} editHandlers  editHandlers\n * @param {Object} dataCtxNode dataCtxNode\n */\nexport function cleanupEditHandlers( editHandlers, dataCtxNode ) {\n    if( editHandlers ) {\n        for( const key in editHandlers ) {\n            if( editHandlers[ key ] && editHandlers[ key ].context ) {\n                let contextKey = editHandlers[ key ].context;\n                if( contextKey && contextKey.match( /\\{\\{.*}}/g ) ) {\n                    contextKey = AwInterpolateService.instance( contextKey )( dataCtxNode );\n                }\n                removeEditHandler( contextKey );\n            }\n        }\n    }\n}\n\nconst getDifferenceBetweenObjects = function( object, base ) {\n    function changes( object, base ) {\n        return _.transform( object, function( result, value, key ) {\n            if( !_.isEqual( value, base[ key ] ) ) {\n                result[ key ] = _.isObject( value ) && _.isObject( base[ key ] ) ? changes( value, base[ key ] ) : value;\n            }\n        } );\n    }\n    return changes( object, base );\n};\n\nconst isObject = function( item ) {\n    return item && typeof item === 'object' && !Array.isArray( item );\n};\n\nconst mergeDeep = function( target, ...sources ) {\n    if( !sources.length ) {\n        return target;\n    }\n    const source = sources.shift();\n\n    if( isObject( target ) && isObject( source ) ) {\n        for( const key in source ) {\n            if( isObject( source[ key ] ) ) {\n                if( !target[ key ] ) {\n                    Object.assign( target, {\n                        [ key ]: {}\n                    } );\n                }\n                mergeDeep( target[ key ], source[ key ] );\n            } else {\n                Object.assign( target, {\n                    [ key ]: source[ key ]\n                } );\n            }\n        }\n    }\n\n    return mergeDeep( target, ...sources );\n};\n\n/**\n * create react component based on view model JSON\n * @param {JSON} declViewModelJson view model definition\n * @param {Function} renderFn the renderFn, default null\n * @param {Object} options the render options\n * @returns {JSX.Element} context for view interpolation\n *\n */\nexport const createComponent = ( declViewModelJson, renderFn, options = {}, ctxImports ) => {\n    const Component = prop => {\n        splmStatsService.startComponentRenderTime();\n        const [ vmDef ] = useState( () => createDeclViewModel( declViewModelJson, prop ) );\n        const [ declViewModel ] = useState( () => declViewModelJson );\n        let viewData = null;\n        let elementsMap = useRef( new Map() );\n        let ref = prop.domRef;\n        if( !ref && options.elementRefList ) {\n            viewData = {\n                elementRefList: null\n            };\n            options.elementRefList.map( ( domElement ) => {\n                if( !elementsMap.current.has( domElement ) ) {\n                    elementsMap.current.set( domElement, createRef( null ) );\n                }\n            } );\n            viewData.elementRefList = elementsMap.current;\n            // How to update props ??\n        }\n        let { elementRefList, ...restOptionsParams } = { ...options };\n        useVmoStore( prop, vmDef._internal.origDeclViewModelJson.props );\n        const vm = useAfxViewModel( vmDef, prop, { ...viewData, ...restOptionsParams }, ctxImports );\n\n        let { i18n, data, dispatch } = vm.viewModel;\n        let createData = vmDef.createData;\n\n        // deserve to put one more useRef since createData and createDeclViewModel is very expensive\n        const hmrLastRef = useRef( null );\n        useEffect( function useHmrEffect() {\n            // console.log( 'hmrEffect triggered!' );\n            // Merge new data into current data\n            // TODO: Patch entire view model, maybe don't use hook approach to sync data.\n            if( hmrLastRef.current !== null ) {\n                const initialData = createData( i18n );\n                const newData = createDeclViewModel( declViewModelJson, prop ).createData( i18n );\n                const diffData = getDifferenceBetweenObjects( newData, initialData );\n                let mergedData = null;\n                if( !_.isEmpty( diffData ) ) {\n                    mergedData = mergeDeep( data, diffData );\n                    dispatch( { path: 'data', value: { ...mergedData } } );\n                }\n                hmrLastRef.current = declViewModel;\n            }\n        }, [ declViewModel ] );\n\n        let props = { ...prop, ...vm };\n        renderFn = renderFn || vmDef.renderFn;\n\n        // support mixin (renderParams) based on render options\n        if( !ref && options.elementRefList ) {\n            props.elementRefList = viewData.elementRefList;\n        }\n\n        // initialize AwExtendedTooltip\n        if( options && options.isTootip ) {\n            let action = vm.actions.extendedTooltipPopup;\n            // justification: hooks are called in the same order each time AwExtendedTooltip renders.\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            useEffect( () => {\n                action.reference.current = prop.reference.current;\n                action.userOptions.current = prop.extendedTooltipOptions;\n            }, [ prop.reference.current ] );\n        }\n\n        if( options.registerCtx ) {\n            // justification: hooks are called in the same order each time that component renders.\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            useEffect( () => {\n                let { key, value, path } = options.registerCtx;\n                appCtxSvc.registerCtx( prop.key || key, value || _.get( vm, path ) );\n            } );\n        }\n\n        let component = renderFn( props );\n\n        component = setDndHandler( vm, props, component );\n\n        // generic style inheritance\n        if( component && component.props && props && props.className ) {\n            // don't repeat classes.... use simple string check\n            if( !( component.props.className && component.props.className.includes( props.className ) ) ) {\n                if( component.type && component.type.includes && component.type.includes( '-' ) ) {\n                    component = React.cloneElement( component, { class: component.props.class + ' ' + props.className } );\n                } else {\n                    component = React.cloneElement( component, { className: component.props.className + ' ' + props.className } );\n                }\n            }\n        }\n\n        // inject ref prop by need\n        if( ref && component ) {\n            if( props.domRef ) {\n                component = React.cloneElement( component, { ref, domRef: props.domRef } );\n            } else {\n                component = React.cloneElement( component, { ref } );\n            }\n        }\n\n        // provide a opportunity to override appendToBody behavior through props\n        if( options.usePortal && prop.enableAppend !== false ) {\n            component = ReactDOM.createPortal( component, prop.parent || document.body );\n        }\n\n        splmStatsService.trackComponent( declViewModelJson._viewModelId );\n\n        return component || null;\n    };\n\n    // Scenario: Verify zero group compile command with popup associated with ZCC (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:7\n    // Scenario: Verify zero shuttle compile command (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:74\n    // Scenario: Verify triangle and popup are not shown when there is only one visible command in the zero group compile command (attempt 2, retried)\n    //     # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:40\n    // Scenario: Verify zero shuttle compile command with/without label (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:143\n    // https://stackoverflow.com/questions/60453845/is-it-safe-to-usememo-for-jsx\n    if( options.useMemo === false ) {\n        Component.displayName = declViewModelJson._viewModelId;\n        return Component;\n    }\n\n    Component.displayName = `${declViewModelJson._viewModelId}.memo`;\n    return React.memo( Component );\n};\n\nconst setDndHandler = function( vm, props, component ) {\n    const dndHandlers = vm.viewModel.dndHandler || props.attachdndHandlers;\n    if( dndHandlers ) {\n        if( component && typeof component.type === 'string' ) {\n            let dndListener = declDragAndDropService.setViewDnd( dndHandlers );\n            component = React.cloneElement( component, { ...dndListener, className: component.props.className + ' aw-widgets-droppable' } );\n        } else {\n            if( component && component.props && !component.props.onDragEnter && component.type !== 'aw-splm-table' ) {\n                component = React.cloneElement( component, { attachdndHandlers: dndHandlers } );\n            }\n        }\n    }\n    return component;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}