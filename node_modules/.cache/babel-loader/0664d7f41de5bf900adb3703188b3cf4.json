{"ast":null,"code":"/* eslint-disable max-statements-per-line */\n\n/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * @module js/positionService\n */\nimport _ from 'lodash';\nimport popupUtils from 'js/popupUtils';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport logger from 'js/logger';\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @type {Array}\n * @enum {String}\n */\n\nconst placements = ['top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n/**\n * the predefined arrow size in px\n */\n\nconst arrowSize = 10;\n/**\n *\n * @param {Element} reference - the reference element\n * @param {Element} popup - the popup element\n * @param {String} options - the placement related option\n *\n * @returns {Object} the expected offsets\n */\n\nconst calculateOffsets = function (reference, popup, options) {\n  if (!reference || !popup) {\n    logger.error(`Invalid element for reference or popup: reference - ${reference}, popup - ${popup}`);\n    return;\n  }\n\n  if (!dom.inDOM(reference)) {\n    logger.warn(`Invalid reference element: ${reference}`);\n  }\n\n  let {\n    placement,\n    alternativePlacements,\n    flipBehavior,\n    hasArrow,\n    arrowOptions,\n    minSize,\n    marginBufferSize\n  } = options;\n\n  if (placements.indexOf(placement) === -1) {\n    logger.warn('Error parameter `placement` ', placement, '. Please use a valid option: ' + placements);\n    return undefined;\n  }\n\n  let data = {\n    options,\n    placement,\n    alternativePlacements,\n    flipBehavior,\n    hasArrow,\n    arrowSize,\n    arrowOptions,\n    minSize,\n    marginBufferSize,\n    offsets: {}\n  };\n  data.offsets.boundaries = getBoundaries(options);\n  data.offsets.reference = getReferenceOffsets(reference, options); // apply placementAttribute if has arrow.\n\n  updatePlacementAttribute(popup, data, Boolean(data.hasArrow)); // compute auto placement to support smart position, store placement inside the data object\n\n  let oldPlacement = placement;\n  data.placement = computeAutoPlacement(popup, data); // if placement changed, need to apply placementAttribute again.\n\n  if (oldPlacement !== data.placement) {\n    updatePlacementAttribute(popup, data, Boolean(data.hasArrow));\n  }\n\n  data.offsets.popup = getPopupOffsets(popup, data);\n  const shiftvariation = data.placement.split('-')[1];\n\n  if (shiftvariation) {\n    let shiftOffsets = calculateShiftOffsets(data);\n    data.offsets.popup = { ...data.offsets.popup,\n      ...shiftOffsets[shiftvariation]\n    };\n  } // if defined overlapOnReference\n\n\n  options.overlapOnReference && applyOverlap(data); // final to getArrowOffsets\n\n  data.hasArrow && (data.offsets.arrow = getArrowOffsets(data));\n  return data.offsets;\n};\n\nfunction applyOverlap(data) {\n  let {\n    popup,\n    reference\n  } = data.offsets;\n  const basePlacement = data.placement.split('-')[0];\n  const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n\n  if (isVertical) {\n    let sign = basePlacement === 'top' ? 1 : -1;\n    popup.top += reference.height * sign;\n  }\n}\n\nfunction updatePlacementAttribute(popup, data) {\n  let add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let name = 'x-placement';\n\n  if (add) {\n    let basePlacement = data.placement.split('-')[0];\n    popup.setAttribute(name, basePlacement);\n  } else {\n    popup.removeAttribute(name);\n  }\n}\n\nfunction getPopupSide(popup, side, boundaries) {\n  let value = 0;\n\n  if (_.has(popup, side)) {\n    value = popup[side];\n  } else {\n    const isLeft = side === 'left';\n    const start = isLeft ? 'right' : 'bottom';\n    const measurement = isLeft ? 'width' : 'height';\n    value = boundaries[measurement] - popup[measurement] - popup[start];\n  }\n\n  return value;\n}\n\nfunction calculateShiftOffsets(data) {\n  const {\n    placement,\n    options\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const basePlacement = placement.split('-')[0];\n  const shiftvariation = placement.split('-')[1];\n  let shiftOffsets = null; // if shift shiftvariation is specified, run the modifier\n\n  if (shiftvariation) {\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const padding = isVertical ? 'x' : 'y';\n    let offset = options && options.padding ? options.padding[padding] || 0 : 0;\n    let targetSide = side;\n    let start = reference[side] + offset;\n    let end = reference[side] + reference[measurement] - popup[measurement] - offset;\n    const mainSideFlipped = !_.has(popup, side);\n\n    if (options.advancePositioning && mainSideFlipped) {\n      const popupSideValue = getPopupSide(popup, side, boundaries);\n      targetSide = getOppositePlacement(side);\n      start = popup[targetSide] + (popupSideValue - reference[side]) - offset;\n      end = popup[targetSide] + (popupSideValue + popup[measurement] - reference[side] - reference[measurement]) + offset;\n    } // override top / left or bottom / right based on mainSide flip flag\n    // if mainSide flipped: means popup was positioned by bottom / right due to content growth, hence override these target side\n\n\n    shiftOffsets = {\n      start: {\n        [targetSide]: start\n      },\n      end: {\n        [targetSide]: end\n      }\n    };\n  }\n\n  return shiftOffsets;\n}\n\nfunction getReferenceOffsets(reference, options) {\n  // TODO: viewport case need to take case parent container element\n  let offset = dom.getOffset(reference);\n  let referenceRect = getOuterSizes(reference); // support padding\n\n  if (options && options.padding) {\n    let {\n      x = 0,\n      y = 0\n    } = options.padding;\n    offset.left -= x;\n    offset.top -= y;\n    referenceRect.width += 2 * x;\n    referenceRect.height += 2 * y;\n  }\n\n  const offsets = { ...offset,\n    ...referenceRect\n  };\n  return getClientRect(offsets);\n}\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @param {String} placement - A valid placement\n * @param {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements\n */\n\n\nfunction clockwise(placement) {\n  let counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const index = placements.indexOf(placement);\n  let arr = placements.slice(0, index);\n  let result = placements.slice(index + 1).concat(arr);\n  return !counter ? result : result.reverse();\n}\n\nfunction getBoundaries(options) {\n  const boundary = options.boundary; // align with `dom.getOffset()`, use viewPort as available space\n\n  let offsets = {\n    // top: window.pageYOffset,\n    // left: window.pageXOffset,\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n\n  if (boundary) {\n    offsets = { ...dom.getOffset(boundary),\n      ...getOuterSizes(boundary)\n    };\n  }\n\n  return getClientRect(offsets);\n}\n\nfunction getSearchOrder(placement, flipBehavior, alternativePlacements) {\n  let searchOrder = [placement];\n  let alternatives = [];\n  let leadAlternatives = [];\n  alternativePlacements && (alternatives = alternativePlacements.slice(0));\n\n  if (flipBehavior === 'opposite') {\n    let op = getOppositePlacement(placement);\n    leadAlternatives = placement.split('-')[1] ? [getOppositeAlignment(placement), op, getOppositeAlignment(op)] : [op];\n  } else if (flipBehavior !== 'fixed') {\n    leadAlternatives = clockwise(placement, flipBehavior === 'counterclockwise');\n  }\n\n  return searchOrder.concat(leadAlternatives, alternatives);\n}\n\nfunction getArea(_ref) {\n  let {\n    width,\n    height\n  } = _ref;\n  return width * height;\n}\n\nfunction checkSpace(rect, popper) {\n  let minSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let res = false;\n\n  if (rect && rect.width >= Math.max(popper.width, minSize) && rect.height >= Math.max(popper.height, minSize)) {\n    res = true;\n  }\n\n  return res;\n}\n\nfunction getPlacement(popup, placement, avaliableRects, flipBehavior, data) {\n  let computedPlacement = null;\n  const searchOrder = getSearchOrder(placement, flipBehavior, data.alternativePlacements);\n  const searchRects = searchOrder.reduce((result, item) => {\n    if (avaliableRects[item]) {\n      result[item] = avaliableRects[item];\n      return result;\n    }\n  }, {}); // Get popper node sizes\n  // support dynamic update when parent resize or window resize,\n  // need to get original popup content size, not the current size.\n\n  clearResize(popup, data);\n  const popper = getOuterSizes(popup, data); // find an available space with no resize required\n\n  computedPlacement = searchOrder.find(key => {\n    let rect = searchRects[key];\n\n    if (checkSpace(rect, popper, data.minSize)) {\n      return key;\n    }\n\n    return null;\n  }); // then try to find an available space with resize required\n\n  if (!computedPlacement) {\n    const sortedAreas = Object.keys(searchRects).map(key => ({\n      key,\n      ...searchRects[key],\n      area: getArea(searchRects[key])\n    })).sort((a, b) => b.area - a.area);\n    applyResize(popup, sortedAreas[0], data);\n    computedPlacement = sortedAreas[0].key;\n  }\n\n  return computedPlacement ? computedPlacement : placement;\n}\n\nfunction getDefaultConstraints(container, css) {\n  let result = {};\n  css.forEach(key => {\n    let key2 = `data-${key}`;\n    result[key] = container.getAttribute(key2) || null;\n  });\n  return result;\n}\n\nfunction clearResize(popup, data) {\n  const container = popupUtils.getResizeContainer(popup, data.options.resizeContainer);\n\n  if (!container) {\n    return;\n  } // horner data-max constraints if defined\n\n\n  const css = ['max-width', 'max-height', 'min-width', 'min-height'];\n  dom.setStyles(container, getDefaultConstraints(container, css));\n}\n\nfunction getArrowMargin(placement, data) {\n  let result = {\n    width: 0,\n    height: 0\n  };\n\n  if (data.hasArrow && data.arrowSize) {\n    const basePlacement = placement.split('-')[0];\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const measurement = !isVertical ? 'width' : 'height';\n    result[measurement] = data.arrowSize;\n  }\n\n  return result;\n}\n\nfunction applyResize(popup, area, data) {\n  const marginBufferSize = data.marginBufferSize || 0;\n  const container = popupUtils.getResizeContainer(popup, data.options.resizeContainer);\n\n  if (!container) {\n    return;\n  }\n\n  const styles = dom.getComputedStyle(container);\n  let css = {};\n  const props = ['width', 'height'];\n  const arrowMargin = getArrowMargin(area.key, data);\n  props.forEach(item => {\n    let available = area[item] - arrowMargin[item]; // unless space is highly limited, leave a gap for the drop shadow, etc\n\n    if (item === 'height' && marginBufferSize > 0) {\n      available = Math.max(available - marginBufferSize, 0);\n    }\n\n    let expected = parseInt(styles[item]);\n    let maxItem = 'max-' + item;\n    let minItem = 'min-' + item;\n    let overflowItem = 'overflow-' + (item === 'width' ? 'x' : 'y');\n\n    if (available < expected) {\n      css[maxItem] = available;\n      css[overflowItem] = 'auto';\n\n      if (styles[minItem] && parseInt(styles[minItem]) > available) {\n        css[minItem] = available;\n      }\n    }\n  });\n\n  if (Object.keys(css).length > 0) {\n    dom.setStyles(container, css);\n  }\n}\n\nfunction getArrowOffsets(data) {\n  const {\n    placement,\n    arrowSize,\n    arrowOptions\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const [basePlacement, shiftvariation] = placement.split('-');\n  let overrideOffsets = null;\n  const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n  const side = isVertical ? 'left' : 'top';\n  const measurement = isVertical ? 'width' : 'height'; // should shift based on reference in this narrow case\n\n  if (reference[measurement] < popup[measurement]) {\n    let base = reference[side] - getPopupSide(popup, side, boundaries);\n    overrideOffsets = {\n      [side]: Math.min(Math.max(base + reference[measurement] / 2 - arrowSize, 0), popup[measurement] - arrowSize * 2)\n    };\n  }\n\n  let shiftOffsets = {}; // arrowOptions should be null by default,\n\n  if (arrowOptions && arrowOptions.alignment) {\n    let alignment = arrowOptions.alignment; // based on the popup alignment, arrow should be smart position itself.\n\n    if (alignment === 'auto') {\n      alignment = shiftvariation ? shiftvariation : 'center';\n    }\n\n    shiftOffsets = getArrowShiftOffsets(data); // return directly got audit error: TypeError: Cannot read property 'name' of undefined\n\n    return { ...overrideOffsets,\n      ...shiftOffsets[alignment]\n    };\n  }\n\n  return overrideOffsets;\n}\n\nfunction getArrowShiftOffsets(data) {\n  const {\n    placement,\n    arrowSize,\n    arrowOptions\n  } = data;\n  const {\n    reference,\n    popup,\n    boundaries\n  } = data.offsets;\n  const basePlacement = placement.split('-')[0];\n  const shiftvariation = arrowOptions.alignment;\n  let shiftOffsets = null; // if shift shiftvariation is specified, run the modifier\n\n  if (shiftvariation) {\n    // could be positive / negative\n    let offset = parseInt(arrowOptions.offset) || 0; //  only accept positive values.\n\n    let shift = Math.max(parseInt(arrowOptions.shift) || 0, 0);\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const base = reference[side] - getPopupSide(popup, side, boundaries);\n    const rectifyOffset = Math.min(offset, popup[measurement], reference[measurement]);\n    const padding = rectifyOffset + 2 * arrowSize;\n    const min = Math.min(shift, popup[measurement] - arrowSize, reference[measurement] - arrowSize);\n    const [lowBound, highBound] = [min, positive(shift, Math.max(popup[measurement] - arrowSize * 2 - shift, shift), reference[measurement] + base - arrowSize)];\n    shiftOffsets = {\n      start: {\n        [side]: positive(lowBound, highBound, base + rectifyOffset)\n      },\n      center: {\n        [side]: positive(0, Math.max(popup[measurement], reference[measurement]), // lowBound, highBound,\n        base + reference[measurement] / 2 - arrowSize)\n      },\n      // + offset\n      end: {\n        [side]: positive(lowBound, highBound, base + reference[measurement] - padding)\n      }\n    };\n  }\n\n  return shiftOffsets;\n}\n\nfunction positive(lowBound, highBound) {\n  for (var _len = arguments.length, items = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    items[_key - 2] = arguments[_key];\n  }\n\n  return Math.min(Math.max(lowBound, ...items), highBound);\n}\n\nfunction getPopupOffsets(popup, data) {\n  const {\n    reference,\n    boundaries\n  } = data.offsets;\n  let placement = data.placement;\n  placement = placement.split('-')[0]; // Get popper node sizes\n\n  const popperRect = getOuterSizes(popup, data); // Add position, width and height to our offsets object\n\n  const popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  }; // depending by the popper placement we have to compute its offsets slightly differently\n\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width'; // center aligned offsets\n\n  let center = Math.max(0, reference[mainSide] + (reference[measurement] - popperRect[measurement]) / 2);\n  popperOffsets[mainSide] = center; // support adaptive shift\n\n  if (data.options.adaptiveShift) {\n    let exceed = center + popperRect[measurement] - boundaries[measurement];\n    let adaptive = exceed < 0 ? center : Math.max(0, center - exceed);\n    popperOffsets[mainSide] = adaptive;\n\n    if (data.options.advancePositioning) {\n      // when popup content growing in corner case, we should flip the mainSide in positioning to enable it grows and gets natural size. Ref: LCS-352837\n      if (exceed >= -50) {\n        delete popperOffsets[mainSide];\n        popperOffsets[getOppositePlacement(mainSide)] = exceed < 0 ? -exceed : 0;\n      }\n    }\n  } // support flip\n\n\n  let secondaryOppositeSide = getOppositePlacement(secondarySide);\n\n  if (placement === secondarySide) {\n    if (data.options.advancePositioning) {\n      // for traditional top/left positioning, when popup content growing, it could be overlap on reference element,\n      // to prevent that, we do this improvement to ensure no overlap:\n      // for left placement, calculate top/right for popup\n      // for top placement, calculate left/bottom for popup\n      popperOffsets[secondaryOppositeSide] = Math.max(0, boundaries[secondaryOppositeSide] - reference[secondarySide]);\n    } else {\n      popperOffsets[secondarySide] = Math.max(0, reference[secondarySide] - popperRect[secondaryMeasurement]);\n    }\n  } else {\n    popperOffsets[secondarySide] = Math.max(0, reference[secondaryOppositeSide]);\n  } // center aligned offsets\n\n\n  return popperOffsets;\n}\n/**\n * Get the opposite placement of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\n\n\nfunction getOppositePlacement(placement) {\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n/**\n * Get the opposite alignment of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\n\n\nfunction getOppositeAlignment(placement) {\n  const hash = {\n    start: 'end',\n    end: 'start'\n  };\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @param {Object} offsets - the offsets\n * @returns {Object} ClientRect like output\n */\n\n\nfunction getClientRect(offsets) {\n  return { ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {Element} element - the element\n * @param {Object} data - the data object\n * @returns {Object} object containing width and height properties\n */\n\n\nfunction getOuterSizes(element, data) {\n  let [x, y] = [0, 0];\n\n  if (data && data.hasArrow) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window.getComputedStyle(element);\n    x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  } // offsetHeight only works for block element, using getBoundingClientRect().height to get height for inline element\n\n\n  const boundingRect = element.getBoundingClientRect();\n  return {\n    width: boundingRect.width + y,\n    height: boundingRect.height + x\n  };\n}\n\nfunction computeAutoPlacement(popup, data) {\n  const {\n    reference,\n    boundaries\n  } = data.offsets;\n  let {\n    placement,\n    flipBehavior\n  } = data;\n  const h1 = reference.top - boundaries.top;\n  const h2 = boundaries.bottom - reference.bottom;\n  const h3 = boundaries.height;\n  const w1 = reference.left - boundaries.left;\n  const w2 = boundaries.right - reference.right;\n  const w3 = boundaries.width;\n  const rects = {\n    top: {\n      width: w3,\n      height: h1\n    },\n    'top-start': {\n      width: boundaries.right - reference.left,\n      height: h1\n    },\n    'top-end': {\n      width: reference.right,\n      height: h1\n    },\n    right: {\n      width: w2,\n      height: h3\n    },\n    'right-start': {\n      width: w2,\n      height: boundaries.bottom - reference.top\n    },\n    'right-end': {\n      width: w2,\n      height: reference.bottom\n    },\n    bottom: {\n      width: w3,\n      height: h2\n    },\n    'bottom-start': {\n      width: boundaries.right - reference.left,\n      height: h2\n    },\n    'bottom-end': {\n      width: reference.right,\n      height: h2\n    },\n    left: {\n      width: w1,\n      height: h3\n    },\n    'left-start': {\n      width: w1,\n      height: boundaries.bottom - reference.top\n    },\n    'left-end': {\n      width: w1,\n      height: reference.bottom\n    }\n  };\n  return getPlacement(popup, placement, rects, flipBehavior, data);\n}\n\nfunction getMax(type, boundaries, refRect) {\n  const isHeight = type === 'height';\n  const side = isHeight ? 'bottom' : 'right';\n  const secondarySide = !isHeight ? 'top' : 'left';\n  const measurement = isHeight ? 'height' : 'width';\n  const space = Math.min(boundaries[side] - refRect[side], refRect[secondarySide] - boundaries[secondarySide]);\n  return 2 * space + refRect[measurement];\n}\n\nexport const positionService = {\n  placements,\n  calculateOffsets\n};\nexport default positionService;","map":{"version":3,"names":["_","popupUtils","DOMAPIs","dom","logger","placements","arrowSize","calculateOffsets","reference","popup","options","error","inDOM","warn","placement","alternativePlacements","flipBehavior","hasArrow","arrowOptions","minSize","marginBufferSize","indexOf","undefined","data","offsets","boundaries","getBoundaries","getReferenceOffsets","updatePlacementAttribute","Boolean","oldPlacement","computeAutoPlacement","getPopupOffsets","shiftvariation","split","shiftOffsets","calculateShiftOffsets","overlapOnReference","applyOverlap","arrow","getArrowOffsets","basePlacement","isVertical","sign","top","height","add","name","setAttribute","removeAttribute","getPopupSide","side","value","has","isLeft","start","measurement","padding","offset","targetSide","end","mainSideFlipped","advancePositioning","popupSideValue","getOppositePlacement","getOffset","referenceRect","getOuterSizes","x","y","left","width","getClientRect","clockwise","counter","index","arr","slice","result","concat","reverse","boundary","window","innerWidth","innerHeight","getSearchOrder","searchOrder","alternatives","leadAlternatives","op","getOppositeAlignment","getArea","checkSpace","rect","popper","res","Math","max","getPlacement","avaliableRects","computedPlacement","searchRects","reduce","item","clearResize","find","key","sortedAreas","Object","keys","map","area","sort","a","b","applyResize","getDefaultConstraints","container","css","forEach","key2","getAttribute","getResizeContainer","resizeContainer","setStyles","getArrowMargin","styles","getComputedStyle","props","arrowMargin","available","expected","parseInt","maxItem","minItem","overflowItem","length","overrideOffsets","base","min","alignment","getArrowShiftOffsets","shift","rectifyOffset","lowBound","highBound","positive","center","items","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","secondaryMeasurement","adaptiveShift","exceed","adaptive","secondaryOppositeSide","hash","right","bottom","replace","matched","element","ownerDocument","defaultView","parseFloat","marginTop","marginBottom","marginLeft","marginRight","boundingRect","getBoundingClientRect","h1","h2","h3","w1","w2","w3","rects","getMax","type","refRect","isHeight","space","positionService"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/popup/src/js/positionService.js"],"sourcesContent":["/* eslint-disable max-statements-per-line */\n/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * @module js/positionService\n */\nimport _ from 'lodash';\nimport popupUtils from 'js/popupUtils';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport logger from 'js/logger';\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @type {Array}\n * @enum {String}\n */\nconst placements = [\n    'top-start',\n    'top',\n    'top-end',\n    'right-start',\n    'right',\n    'right-end',\n    'bottom-end',\n    'bottom',\n    'bottom-start',\n    'left-end',\n    'left',\n    'left-start'\n];\n\n/**\n * the predefined arrow size in px\n */\nconst arrowSize = 10;\n/**\n *\n * @param {Element} reference - the reference element\n * @param {Element} popup - the popup element\n * @param {String} options - the placement related option\n *\n * @returns {Object} the expected offsets\n */\nconst calculateOffsets = function( reference, popup, options ) {\n    if( !reference || !popup ) {\n        logger.error( `Invalid element for reference or popup: reference - ${reference}, popup - ${popup}` );\n        return;\n    }\n    if( !dom.inDOM( reference ) ) { logger.warn( `Invalid reference element: ${reference}` ); }\n    let { placement, alternativePlacements, flipBehavior, hasArrow, arrowOptions, minSize, marginBufferSize } = options;\n    if( placements.indexOf( placement ) === -1 ) {\n        logger.warn( 'Error parameter `placement` ', placement, '. Please use a valid option: ' + placements );\n        return undefined;\n    }\n    let data = {\n        options,\n        placement,\n        alternativePlacements,\n        flipBehavior,\n        hasArrow,\n        arrowSize,\n        arrowOptions,\n        minSize,\n        marginBufferSize,\n        offsets: {}\n    };\n\n    data.offsets.boundaries = getBoundaries( options );\n    data.offsets.reference = getReferenceOffsets( reference, options );\n    // apply placementAttribute if has arrow.\n    updatePlacementAttribute( popup, data, Boolean( data.hasArrow ) );\n    // compute auto placement to support smart position, store placement inside the data object\n    let oldPlacement = placement;\n    data.placement = computeAutoPlacement( popup, data );\n    // if placement changed, need to apply placementAttribute again.\n    if( oldPlacement !== data.placement ) { updatePlacementAttribute( popup, data, Boolean( data.hasArrow ) ); }\n    data.offsets.popup = getPopupOffsets( popup, data );\n    const shiftvariation = data.placement.split( '-' )[ 1 ];\n    if( shiftvariation ) {\n        let shiftOffsets = calculateShiftOffsets( data );\n        data.offsets.popup = { ...data.offsets.popup, ...shiftOffsets[ shiftvariation ] };\n    }\n    // if defined overlapOnReference\n    options.overlapOnReference && applyOverlap( data );\n    // final to getArrowOffsets\n    data.hasArrow && ( data.offsets.arrow = getArrowOffsets( data ) );\n    return data.offsets;\n};\n\nfunction applyOverlap( data ) {\n    let { popup, reference } = data.offsets;\n    const basePlacement = data.placement.split( '-' )[ 0 ];\n    const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n    if( isVertical ) {\n        let sign = basePlacement === 'top' ? 1 : -1;\n        popup.top += reference.height * sign;\n    }\n}\n\nfunction updatePlacementAttribute( popup, data, add = true ) {\n    let name = 'x-placement';\n    if( add ) {\n        let basePlacement = data.placement.split( '-' )[ 0 ];\n        popup.setAttribute( name, basePlacement );\n    } else {\n        popup.removeAttribute( name );\n    }\n}\n\nfunction getPopupSide( popup, side, boundaries ) {\n    let value = 0;\n    if( _.has( popup, side ) ) {\n        value = popup[ side ];\n    } else {\n        const isLeft = side === 'left';\n        const start = isLeft ? 'right' : 'bottom';\n        const measurement = isLeft ? 'width' : 'height';\n        value = boundaries[ measurement ] - popup[ measurement ] - popup[ start ];\n    }\n    return value;\n}\n\nfunction calculateShiftOffsets( data ) {\n    const { placement, options } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const basePlacement = placement.split( '-' )[ 0 ];\n    const shiftvariation = placement.split( '-' )[ 1 ];\n    let shiftOffsets = null;\n    // if shift shiftvariation is specified, run the modifier\n    if( shiftvariation ) {\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const padding = isVertical ? 'x' : 'y';\n\n        let offset = options && options.padding ? options.padding[ padding ] || 0 : 0;\n        let targetSide = side;\n        let start = reference[ side ] + offset;\n        let end = reference[ side ] + reference[ measurement ] - popup[ measurement ] - offset;\n\n        const mainSideFlipped = !_.has( popup, side );\n        if( options.advancePositioning && mainSideFlipped ) {\n            const popupSideValue = getPopupSide( popup, side, boundaries );\n            targetSide = getOppositePlacement( side );\n            start = popup[ targetSide ] + ( popupSideValue - reference[ side ] ) - offset;\n            end = popup[ targetSide ] + ( popupSideValue + popup[ measurement ] - reference[ side ] - reference[ measurement ] ) + offset;\n        }\n\n        // override top / left or bottom / right based on mainSide flip flag\n        // if mainSide flipped: means popup was positioned by bottom / right due to content growth, hence override these target side\n        shiftOffsets = {\n            start: {\n                [ targetSide ]: start\n            },\n            end: {\n                [ targetSide ]: end\n            }\n        };\n    }\n    return shiftOffsets;\n}\n\nfunction getReferenceOffsets( reference, options ) {\n    // TODO: viewport case need to take case parent container element\n    let offset = dom.getOffset( reference );\n    let referenceRect = getOuterSizes( reference );\n    // support padding\n    if( options && options.padding ) {\n        let { x = 0, y = 0 } = options.padding;\n        offset.left -= x;\n        offset.top -= y;\n        referenceRect.width += 2 * x;\n        referenceRect.height += 2 * y;\n    }\n    const offsets = {\n        ...offset,\n        ...referenceRect\n    };\n    return getClientRect( offsets );\n}\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @param {String} placement - A valid placement\n * @param {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements\n */\nfunction clockwise( placement, counter = false ) {\n    const index = placements.indexOf( placement );\n    let arr = placements.slice( 0, index );\n    let result = placements.slice( index + 1 ).concat( arr );\n    return !counter ? result : result.reverse();\n}\n\nfunction getBoundaries( options ) {\n    const boundary = options.boundary;\n    // align with `dom.getOffset()`, use viewPort as available space\n    let offsets = {\n        // top: window.pageYOffset,\n        // left: window.pageXOffset,\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight\n    };\n    if( boundary ) {\n        offsets = {\n            ...dom.getOffset( boundary ),\n            ...getOuterSizes( boundary )\n        };\n    }\n    return getClientRect( offsets );\n}\n\nfunction getSearchOrder( placement, flipBehavior, alternativePlacements ) {\n    let searchOrder = [ placement ];\n    let alternatives = [];\n    let leadAlternatives = [];\n    alternativePlacements && ( alternatives = alternativePlacements.slice( 0 ) );\n    if( flipBehavior === 'opposite' ) {\n        let op = getOppositePlacement( placement );\n        leadAlternatives = placement.split( '-' )[ 1 ] ? [ getOppositeAlignment( placement ), op, getOppositeAlignment( op ) ] : [ op ];\n    } else if( flipBehavior !== 'fixed' ) {\n        leadAlternatives = clockwise( placement, flipBehavior === 'counterclockwise' );\n    }\n    return searchOrder.concat( leadAlternatives, alternatives );\n}\n\nfunction getArea( { width, height } ) {\n    return width * height;\n}\n\nfunction checkSpace( rect, popper, minSize = 0 ) {\n    let res = false;\n    if( rect &&\n        rect.width >= Math.max( popper.width, minSize ) &&\n        rect.height >= Math.max( popper.height, minSize )\n    ) {\n        res = true;\n    }\n    return res;\n}\n\nfunction getPlacement( popup, placement, avaliableRects, flipBehavior, data ) {\n    let computedPlacement = null;\n    const searchOrder = getSearchOrder( placement, flipBehavior, data.alternativePlacements );\n    const searchRects = searchOrder.reduce( ( result, item ) => {\n        if( avaliableRects[ item ] ) {\n            result[ item ] = avaliableRects[ item ];\n            return result;\n        }\n    }, {} );\n    // Get popper node sizes\n    // support dynamic update when parent resize or window resize,\n    // need to get original popup content size, not the current size.\n    clearResize( popup, data );\n    const popper = getOuterSizes( popup, data );\n    // find an available space with no resize required\n    computedPlacement = searchOrder.find( ( key ) => {\n        let rect = searchRects[ key ];\n        if( checkSpace( rect, popper, data.minSize ) ) {\n            return key;\n        }\n        return null;\n    } );\n\n    // then try to find an available space with resize required\n    if( !computedPlacement ) {\n        const sortedAreas = Object.keys( searchRects )\n            .map( key => ( {\n                key,\n                ...searchRects[ key ],\n                area: getArea( searchRects[ key ] )\n            } ) )\n            .sort( ( a, b ) => b.area - a.area );\n        applyResize( popup, sortedAreas[ 0 ], data );\n        computedPlacement = sortedAreas[ 0 ].key;\n    }\n    return computedPlacement ? computedPlacement : placement;\n}\n\nfunction getDefaultConstraints( container, css ) {\n    let result = {};\n    css.forEach( ( key )=>{\n        let key2 = `data-${key}`;\n        result[key] = container.getAttribute( key2 ) || null;\n    } );\n    return result;\n}\n\nfunction clearResize( popup, data ) {\n    const container = popupUtils.getResizeContainer( popup, data.options.resizeContainer );\n    if( !container ) { return; }\n    // horner data-max constraints if defined\n    const css = [ 'max-width', 'max-height', 'min-width', 'min-height' ];\n    dom.setStyles( container, getDefaultConstraints( container, css ) );\n}\n\nfunction getArrowMargin( placement, data ) {\n    let result = { width: 0, height: 0 };\n    if( data.hasArrow && data.arrowSize ) {\n        const basePlacement = placement.split( '-' )[ 0 ];\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const measurement = !isVertical ? 'width' : 'height';\n        result[ measurement ] = data.arrowSize;\n    }\n    return result;\n}\n\nfunction applyResize( popup, area, data ) {\n    const marginBufferSize = data.marginBufferSize || 0;\n    const container = popupUtils.getResizeContainer( popup, data.options.resizeContainer );\n    if( !container ) { return; }\n    const styles = dom.getComputedStyle( container );\n    let css = {};\n    const props = [ 'width', 'height' ];\n    const arrowMargin = getArrowMargin( area.key, data );\n    props.forEach( ( item ) => {\n        let available = area[ item ] - arrowMargin[ item ];\n        // unless space is highly limited, leave a gap for the drop shadow, etc\n        if( item === 'height' && marginBufferSize > 0 ) { available = Math.max( available - marginBufferSize, 0 ); }\n        let expected = parseInt( styles[ item ] );\n        let maxItem = 'max-' + item;\n        let minItem = 'min-' + item;\n        let overflowItem = 'overflow-' + ( item === 'width' ? 'x' : 'y' );\n\n        if( available < expected ) {\n            css[ maxItem ] = available;\n            css[ overflowItem ] = 'auto';\n            if( styles[ minItem ] && parseInt( styles[ minItem ] ) > available ) {\n                css[ minItem ] = available;\n            }\n        }\n    } );\n    if( Object.keys( css ).length > 0 ) {\n        dom.setStyles( container, css );\n    }\n}\n\nfunction getArrowOffsets( data ) {\n    const { placement, arrowSize, arrowOptions } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const [ basePlacement, shiftvariation ] = placement.split( '-' );\n    let overrideOffsets = null;\n    const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    // should shift based on reference in this narrow case\n    if( reference[ measurement ] < popup[ measurement ] ) {\n        let base = reference[ side ] - getPopupSide( popup, side, boundaries );\n        overrideOffsets = {\n            [ side ]: Math.min(\n                Math.max( base + reference[ measurement ] / 2 - arrowSize, 0 ),\n                popup[ measurement ] - arrowSize * 2\n            )\n        };\n    }\n    let shiftOffsets = {};\n    // arrowOptions should be null by default,\n    if( arrowOptions && arrowOptions.alignment ) {\n        let alignment = arrowOptions.alignment;\n        // based on the popup alignment, arrow should be smart position itself.\n        if( alignment === 'auto' ) {\n            alignment = shiftvariation ? shiftvariation : 'center';\n        }\n        shiftOffsets = getArrowShiftOffsets( data );\n        // return directly got audit error: TypeError: Cannot read property 'name' of undefined\n        return { ...overrideOffsets, ...shiftOffsets[ alignment ] };\n    }\n    return overrideOffsets;\n}\n\nfunction getArrowShiftOffsets( data ) {\n    const { placement, arrowSize, arrowOptions } = data;\n    const { reference, popup, boundaries } = data.offsets;\n    const basePlacement = placement.split( '-' )[ 0 ];\n    const shiftvariation = arrowOptions.alignment;\n    let shiftOffsets = null;\n    // if shift shiftvariation is specified, run the modifier\n    if( shiftvariation ) {\n        // could be positive / negative\n        let offset = parseInt( arrowOptions.offset ) || 0;\n        //  only accept positive values.\n        let shift = Math.max( parseInt( arrowOptions.shift ) || 0, 0 );\n        const isVertical = [ 'bottom', 'top' ].indexOf( basePlacement ) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const base = reference[ side ] - getPopupSide( popup, side, boundaries );\n        const rectifyOffset = Math.min( offset, popup[ measurement ], reference[ measurement ] );\n        const padding = rectifyOffset + 2 * arrowSize;\n        const min = Math.min( shift, popup[ measurement ] - arrowSize, reference[ measurement ] - arrowSize );\n        const [ lowBound, highBound ] = [ min, positive(\n            shift, Math.max( popup[ measurement ] - arrowSize * 2 - shift, shift ),\n            reference[ measurement ] + base - arrowSize ) ];\n        shiftOffsets = {\n            start: {\n                [ side ]: positive( lowBound, highBound,\n                    base + rectifyOffset )\n            },\n            center: {\n                [ side ]: positive( 0, Math.max( popup[ measurement ], reference[ measurement ] ), // lowBound, highBound,\n                    base + reference[ measurement ] / 2 - arrowSize )\n            }, // + offset\n            end: {\n                [ side ]: positive( lowBound, highBound,\n                    base + reference[ measurement ] - padding )\n            }\n        };\n    }\n    return shiftOffsets;\n}\n\nfunction positive( lowBound, highBound, ...items ) {\n    return Math.min( Math.max( lowBound, ...items ), highBound );\n}\n\nfunction getPopupOffsets( popup, data ) {\n    const { reference, boundaries } = data.offsets;\n    let placement = data.placement;\n    placement = placement.split( '-' )[ 0 ];\n    // Get popper node sizes\n    const popperRect = getOuterSizes( popup, data );\n    // Add position, width and height to our offsets object\n    const popperOffsets = {\n        width: popperRect.width,\n        height: popperRect.height\n    };\n    // depending by the popper placement we have to compute its offsets slightly differently\n    const isHoriz = [ 'right', 'left' ].indexOf( placement ) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    // center aligned offsets\n    let center = Math.max( 0, reference[ mainSide ] + ( reference[ measurement ] - popperRect[ measurement ] ) / 2 );\n    popperOffsets[ mainSide ] = center;\n    // support adaptive shift\n    if( data.options.adaptiveShift ) {\n        let exceed = center + popperRect[ measurement ] - boundaries[ measurement ];\n        let adaptive = exceed < 0 ? center : Math.max( 0, center - exceed );\n        popperOffsets[ mainSide ] = adaptive;\n        if( data.options.advancePositioning ) {\n            // when popup content growing in corner case, we should flip the mainSide in positioning to enable it grows and gets natural size. Ref: LCS-352837\n            if( exceed >= -50 ) {\n                delete popperOffsets[ mainSide ];\n                popperOffsets[ getOppositePlacement( mainSide ) ] = exceed < 0 ? -exceed : 0;\n            }\n        }\n    }\n    // support flip\n    let secondaryOppositeSide = getOppositePlacement( secondarySide );\n    if( placement === secondarySide ) {\n        if( data.options.advancePositioning ) {\n            // for traditional top/left positioning, when popup content growing, it could be overlap on reference element,\n            // to prevent that, we do this improvement to ensure no overlap:\n            // for left placement, calculate top/right for popup\n            // for top placement, calculate left/bottom for popup\n            popperOffsets[ secondaryOppositeSide ] = Math.max( 0,\n                boundaries[ secondaryOppositeSide ] - reference[ secondarySide ] );\n        } else {\n            popperOffsets[ secondarySide ] = Math.max( 0,\n                reference[ secondarySide ] - popperRect[ secondaryMeasurement ] );\n        }\n    } else {\n        popperOffsets[ secondarySide ] = Math.max( 0,\n            reference[ secondaryOppositeSide ] );\n    }\n    // center aligned offsets\n    return popperOffsets;\n}\n/**\n * Get the opposite placement of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement( placement ) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace( /left|right|bottom|top/g, matched => hash[ matched ] );\n}\n/**\n * Get the opposite alignment of the given one\n * @param {String} placement - the placement\n * @returns {String} flipped placement\n */\nfunction getOppositeAlignment( placement ) {\n    const hash = { start: 'end', end: 'start' };\n    return placement.replace( /start|end/g, matched => hash[ matched ] );\n}\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @param {Object} offsets - the offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect( offsets ) {\n    return {\n        ...offsets,\n        right: offsets.left + offsets.width,\n        bottom: offsets.top + offsets.height\n    };\n}\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {Element} element - the element\n * @param {Object} data - the data object\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes( element, data ) {\n    let [ x, y ] = [ 0, 0 ];\n    if( data && data.hasArrow ) {\n        const window = element.ownerDocument.defaultView;\n        const styles = window.getComputedStyle( element );\n        x = parseFloat( styles.marginTop || 0 ) + parseFloat( styles.marginBottom || 0 );\n        y = parseFloat( styles.marginLeft || 0 ) + parseFloat( styles.marginRight || 0 );\n    }\n    // offsetHeight only works for block element, using getBoundingClientRect().height to get height for inline element\n    const boundingRect = element.getBoundingClientRect();\n    return {\n        width: boundingRect.width + y,\n        height: boundingRect.height + x\n    };\n}\n\nfunction computeAutoPlacement( popup, data ) {\n    const { reference, boundaries } = data.offsets;\n    let { placement, flipBehavior } = data;\n    const h1 = reference.top - boundaries.top;\n    const h2 = boundaries.bottom - reference.bottom;\n    const h3 = boundaries.height;\n    const w1 = reference.left - boundaries.left;\n    const w2 = boundaries.right - reference.right;\n    const w3 = boundaries.width;\n    const rects = {\n        top: {\n            width: w3,\n            height: h1\n        },\n        'top-start': {\n            width: boundaries.right - reference.left,\n            height: h1\n        },\n        'top-end': {\n            width: reference.right,\n            height: h1\n        },\n        right: {\n            width: w2,\n            height: h3\n        },\n        'right-start': {\n            width: w2,\n            height: boundaries.bottom - reference.top\n        },\n        'right-end': {\n            width: w2,\n            height: reference.bottom\n        },\n        bottom: {\n            width: w3,\n            height: h2\n        },\n        'bottom-start': {\n            width: boundaries.right - reference.left,\n            height: h2\n        },\n        'bottom-end': {\n            width: reference.right,\n            height: h2\n        },\n        left: {\n            width: w1,\n            height: h3\n        },\n        'left-start': {\n            width: w1,\n            height: boundaries.bottom - reference.top\n        },\n        'left-end': {\n            width: w1,\n            height: reference.bottom\n        }\n    };\n    return getPlacement( popup, placement, rects, flipBehavior, data );\n}\n\nfunction getMax( type, boundaries, refRect ) {\n    const isHeight = type === 'height';\n    const side = isHeight ? 'bottom' : 'right';\n    const secondarySide = !isHeight ? 'top' : 'left';\n    const measurement = isHeight ? 'height' : 'width';\n    const space = Math.min( boundaries[ side ] - refRect[ side ], refRect[ secondarySide ] - boundaries[ secondarySide ] );\n    return 2 * space + refRect[ measurement ];\n}\n\nexport const positionService = {\n    placements,\n    calculateOffsets\n};\n\nexport default positionService;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}