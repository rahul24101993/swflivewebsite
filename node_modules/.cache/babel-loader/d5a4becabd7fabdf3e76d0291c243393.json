{"ast":null,"code":"/* eslint-disable complexity */\n// Copyright (c) 2021 Siemens\nimport _ from 'lodash';\nimport moduleLoader from 'js/moduleLoader';\nimport cfgSvc from 'js/configurationService';\nimport localeService from 'js/localeService';\nimport editHandlerService from 'js/editHandlerService';\nimport appCtxService from 'js/appCtxService';\nimport conditionService from 'js/conditionService';\nimport AwPromiseService from 'js/awPromiseService';\nimport localStorage from 'js/localStorage';\nimport Debug from 'debug';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition } from 'js/conditionParser.service';\nimport { concat, flatten } from 'lodash';\nconst trace = new Debug('selection');\n\nconst loadTabTitle = tab => {\n  if (typeof tab.name !== 'string') {\n    localeService.getLocalizedText(tab.name.source, tab.name.key).then(function (result) {\n      tab.name = result;\n    });\n  }\n};\n\nconst loadSecondaryWorkareaTabs = async () => {\n  return await cfgSvc.getCfg('secondaryWorkareaTabs').then(tabsConfig => {\n    tabsConfig.tabs.forEach(function (tab, idx) {\n      tab.pageId = tab.pageId ? tab.pageId : idx;\n    });\n    tabsConfig.tabs.forEach(loadTabTitle);\n    return tabsConfig;\n  });\n};\n\nexport const initialize = () => {\n  return loadSecondaryWorkareaTabs().then(tabsConfig => {\n    const {\n      ctxParameters,\n      additionalParameters\n    } = getTabsState(tabsConfig);\n    return {\n      tabsConfig,\n      ctxParameters,\n      additionalParameters\n    };\n  });\n};\n\nconst conditionFilter = (tab, tabsConfig, selection, context) => {\n  var conditionExpression = tab.visibleWhen;\n\n  if (tab.visibleWhen && tab.visibleWhen.condition) {\n    var conditionExpressionObj = _.get(tabsConfig, tab.visibleWhen.condition);\n\n    conditionExpression = conditionExpressionObj.expression;\n  }\n\n  tab.displayTab = true;\n\n  if (conditionExpression) {\n    tab.displayTab = conditionService.evaluateCondition({\n      ctx: appCtxService.ctx,\n      selection: selection,\n      context: { ...context,\n        isXrtApplicable: context && context.hasOwnProperty('isXrtApplicable') ? context.isXrtApplicable : !_.isUndefined(appCtxService.ctx.tcSessionData)\n      }\n    }, conditionExpression);\n  }\n\n  return tab.displayTab;\n};\n\nconst isActiveTabStillVisible = (visibleTabs, activeTab) => {\n  return visibleTabs.filter(tab => tab.tabContent ? tab.pageId === activeTab.pageId && _.isEqual(tab.tabContent, activeTab.tabContent) : tab.pageId === activeTab.pageId).length > 0;\n};\n\nconst updateTabsToShow = (tabsToShow, activeTab) => {\n  let index = _.findIndex(tabsToShow, tab => {\n    return tab.pageId === activeTab.pageId || tab.name === activeTab.name;\n  }, 0);\n\n  tabsToShow = _.map(tabsToShow, (tab, idx) => {\n    if (idx === index) {\n      tab.selectedTab = true;\n    } else {\n      tab.selectedTab = undefined;\n    }\n\n    return tab;\n  });\n  return tabsToShow;\n};\n\nconst isContributedTabActive = (swaContributedTabs, activeTab) => {\n  if (activeTab && swaContributedTabs && swaContributedTabs.length > 0) {\n    let ndx = -1;\n\n    if (typeof activeTab === 'object') {\n      ndx = _.findIndex(swaContributedTabs, tab => {\n        return tab.pageId === activeTab.pageId || tab.name === activeTab.name;\n      }, 0);\n    } else if (typeof activeTab === 'string') {\n      ndx = _.findIndex(swaContributedTabs, tab => {\n        return tab.name === activeTab || tab.view === activeTab;\n      }, 0);\n    }\n\n    return ndx > -1;\n  }\n\n  return false;\n};\n\nconst fetchChildTabs = (containerTab, selection, activeTab, swaContributedTabs, context) => {\n  let isContributedTab = isContributedTabActive(swaContributedTabs, activeTab);\n  activeTab = isContributedTab === false ? activeTab : undefined;\n  var deferred = AwPromiseService.instance.defer();\n\n  if (containerTab.deps) {\n    const doAction = depModuleObj => {\n      return depModuleObj[containerTab.method](selection, activeTab, context, isContributedTab);\n    };\n\n    return moduleLoader.loadDependentModule(containerTab.deps).then(doAction);\n  }\n\n  return deferred.Promise;\n};\n\nexport const syncSublocationState = (activeTab, sublocationState) => {\n  let newSublocationState;\n\n  if (sublocationState) {\n    newSublocationState = { ...sublocationState.value\n    };\n  } else {\n    newSublocationState = {};\n  }\n\n  newSublocationState.secondaryActiveTabId = activeTab.tabKey ? activeTab.tabKey : activeTab.view;\n\n  if (sublocationState.secondaryActiveTabId !== newSublocationState.secondaryActiveTabId) {\n    sublocationState.update(newSublocationState);\n  }\n};\nexport const clearSublocationState = sublocationState => {\n  let newSublocationState = { ...sublocationState.value\n  };\n  newSublocationState.secondaryActiveTabId = undefined;\n  sublocationState.update(newSublocationState);\n};\n\nconst processFetchedData = (data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerPriority, updatedTabsToShow, containerTab) => {\n  let tabToActivate = {};\n  let tabsToShow = [];\n  let childTabs = [];\n\n  if (output) {\n    let allVisibleTabs = data.getData().changedAllVisibleTabs;\n    let allVisibleContributedTabs = [];\n\n    if (allVisibleTabs) {\n      allVisibleTabs.map(tab => {\n        let tabClone = { ...tab\n        };\n\n        if (!tabClone.hasChildTabs) {\n          allVisibleContributedTabs.push(tabClone);\n        }\n      });\n\n      if (allVisibleContributedTabs.length === 0) {\n        allVisibleContributedTabs = swaContributedTabs;\n      }\n    } else {\n      allVisibleContributedTabs = swaContributedTabs;\n    }\n\n    childTabs = output.childTabs;\n\n    _.forEach(childTabs, childTab => {\n      childTab.priority = containerPriority;\n    });\n\n    tabsToShow = tabsToShow.concat(childTabs, allVisibleContributedTabs);\n  } else {\n    tabsToShow = updatedTabsToShow ? updatedTabsToShow : swaContributedTabs;\n  } // sort the contributed and container tabs based on priority\n\n\n  tabsToShow.sort(function (t1, t2) {\n    return t1.priority - t2.priority;\n  });\n  let requestedActiveTab = activeTab;\n  activeTab = evalTabObj(tabsToShow, activeTab);\n\n  if (!_.isEmpty(activeTab) && isActiveTabStillVisible(tabsToShow, activeTab)) {\n    tabToActivate = activeTab;\n    tabsToShow = updateTabsToShow(tabsToShow, activeTab);\n  } else if (_.isEmpty(activeTab)) {\n    requestedActiveTab = localStorage.get('lastActiveTab');\n    let activeTab1 = evalTabObj(tabsToShow, requestedActiveTab);\n\n    if (!_.isEmpty(activeTab1) && isActiveTabStillVisible(tabsToShow, activeTab1) && requestedActiveTab !== '') {\n      return fetchTabsData(selectionData, tabsConfig, containerTab, selection, requestedActiveTab, swaContributedTabs, data, context, dispatch, tabsToShow);\n    }\n\n    tabToActivate = tabsToShow[0];\n    tabsToShow = updateTabsToShow(tabsToShow, tabToActivate);\n  } else {\n    tabToActivate = tabsToShow[0];\n    tabsToShow = updateTabsToShow(tabsToShow, tabToActivate);\n  }\n\n  if (tabToActivate) {\n    tabToActivate.tabContent = output ? output.activeTabContent : undefined;\n    tabToActivate.extraInfo = output ? output.extraInfo : null;\n  }\n\n  const tabChangeCallback = (pageId, tabTitle, refresh) => {\n    localStorage.publish('lastActiveTab', pageId);\n    clearSelectionData(selectionData);\n    activateTab(data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority);\n  };\n\n  const activeTabKey = tabToActivate && tabToActivate.tabKey ? tabToActivate.tabKey : tabToActivate ? tabToActivate.view : '';\n  let unExpandedVisibleTabs = data && data.ctx && data.ctx.visibleTabs ? data.ctx.visibleTabs : undefined;\n\n  if (!unExpandedVisibleTabs || unExpandedVisibleTabs.length === 0) {\n    unExpandedVisibleTabs = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.unExpandedVisibleTabs;\n  }\n\n  return {\n    summaryContext: {\n      activeTab: tabToActivate,\n      visibleTabs: tabsToShow,\n      api: tabChangeCallback,\n      selection: selection,\n      allVisibleTabs: updatedTabsToShow,\n      activeTabKey: activeTabKey,\n      childTabs: childTabs,\n      unExpandedVisibleTabs\n    }\n  };\n};\n\nconst fetchTabsData = (selectionData, tabsConfig, containerTab, selection, activeTab, swaContributedTabs, data, context, dispatch, allVisibleTabs) => {\n  return fetchChildTabs(containerTab, selection[0], activeTab, swaContributedTabs, context).then(output => {\n    const currentSelection = data.getData().summaryContext && data.getData().summaryContext.selection ? data.getData().summaryContext.selection : undefined;\n\n    if (!currentSelection || currentSelection && currentSelection.length === 1 && currentSelection[0].uid === selection[0].uid) {\n      return processFetchedData(data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerTab.priority, allVisibleTabs, containerTab);\n    }\n\n    if (currentSelection && currentSelection.length === 1) {\n      return fetchTabsData(selectionData, tabsConfig, containerTab, currentSelection, activeTab, swaContributedTabs, data, context, dispatch);\n    }\n\n    return AwPromiseService.instance.resolve({\n      summaryContext: data.getData().summaryContext\n    });\n  });\n};\n\nconst evalTabObj = (tabsToShow, activeTab) => {\n  if (typeof activeTab !== 'object') {\n    let index = _.findIndex(tabsToShow, tab => {\n      return tab.pageId && tab.pageId === activeTab || tab.tabKey && tab.tabKey === activeTab || tab.name && tab.name === activeTab || tab.view && tab.view === activeTab || tab.id && tab.id === activeTab;\n    }, 0);\n\n    activeTab = tabsToShow[index];\n  }\n\n  return activeTab;\n};\n\nconst isInputSelectionSameAsCurrentSelection = (currentSelection, inputSelection) => {\n  if (!currentSelection && !inputSelection || currentSelection && currentSelection.length === 0 && inputSelection && inputSelection.length === 0) {\n    return true;\n  }\n\n  return currentSelection.length === inputSelection.length && inputSelection.length > 0 && _.isEqual(currentSelection[0].uid, inputSelection[0].uid);\n};\n\nconst areInputPropsAndDataNotPopulatedYet = (props, data) => {\n  return !props || !props.selection || !data || !props.tabsConfig || !props.tabsConfig.tabs;\n};\n\nconst areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs = (currentlyVisibleUnExpandedTabs, inputUnExpandedTabs) => {\n  if (!currentlyVisibleUnExpandedTabs && !inputUnExpandedTabs) {\n    return true;\n  }\n\n  if (!currentlyVisibleUnExpandedTabs || !inputUnExpandedTabs) {\n    return false;\n  }\n\n  if (currentlyVisibleUnExpandedTabs.length !== inputUnExpandedTabs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < currentlyVisibleUnExpandedTabs.length; ++i) {\n    var cachedTabKey = currentlyVisibleUnExpandedTabs[i].tabKey ? currentlyVisibleUnExpandedTabs[i].tabKey : currentlyVisibleUnExpandedTabs[i].name;\n    var receivedTabKey = inputUnExpandedTabs[i].tabKey ? inputUnExpandedTabs[i].tabKey : inputUnExpandedTabs[i].name;\n\n    if (cachedTabKey !== receivedTabKey) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs = (summaryContext, unExpandedVisibleTabs, currentlyActiveTabId) => {\n  return summaryContext && summaryContext.activeTab && !summaryContext.activeTab.api && unExpandedVisibleTabs && unExpandedVisibleTabs.filter(tab => tab.view === currentlyActiveTabId).length === 0;\n};\n\nconst isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab = (tabRequestedToBeActivated, data) => {\n  let currentlyActiveTabKey = data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.tabKey ? data.summaryContext.activeTab.tabKey : data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.view ? data.summaryContext.activeTab.view : '';\n\n  if (tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey) {\n    currentlyActiveTabKey = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.tabKey ? data && data.getData().summaryContext.activeTab.tabKey : data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.view ? data.getData().summaryContext.activeTab.view : '';\n\n    if (tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey) {\n      currentlyActiveTabKey = data && data.summaryContext ? data.summaryContext.activeTabKey : '';\n\n      if (tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey) {\n        currentlyActiveTabKey = data && data.getData().summaryContext ? data.getData().summaryContext.activeTabKey : '';\n\n        if (tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\nexport const getTabToActivateAndVisibleTabs = (data, props, unExpandedVisibleTabs) => {\n  const getTabToActivate = () => {\n    let containerTabs = [];\n    let swaContributedTabs = [];\n\n    if (tabsConfig) {\n      var allVisibleTabs = [];\n      tabsConfig.tabs.map(tab => {\n        let tabClone = { ...tab\n        };\n\n        if (conditionFilter(tabClone, tabsConfig, localSelection, context)) {\n          allVisibleTabs.push(tabClone);\n        }\n      });\n\n      for (const tab of allVisibleTabs) {\n        if (tab.hasChildTabs === true) {\n          containerTabs.push(tab);\n        } else {\n          swaContributedTabs.push(tab);\n        }\n      }\n    }\n\n    if (containerTabs.length > 0 && !skipAfreshChildFetch) {\n      dispatch({\n        path: 'data.changedAllVisibleTabs',\n        value: []\n      });\n      return fetchTabsData(props.selectionData, props.tabsConfig, containerTabs[0], localSelection, tabToActivateNow, swaContributedTabs, data, context, dispatch, allVisibleTabs);\n    }\n\n    if (containerTabs.length > 0) {\n      var output = {\n        childTabs: data.summaryContext ? data.summaryContext.childTabs : [],\n        activeTabContent: _.get(data, 'summaryContext.activeTab.tabContent')\n      };\n\n      if (!output.extraInfo) {\n        output.extraInfo = data.summaryContext && data.summaryContext.activeTab ? data.summaryContext.activeTab.extraInfo : null;\n      }\n\n      if (!output.childTabs || output.childTabs.length === 0) {\n        dispatch({\n          path: 'data.changedAllVisibleTabs',\n          value: unExpandedVisibleTabs\n        });\n        return;\n      }\n\n      return AwPromiseService.instance.resolve(processFetchedData(data, props.selectionData, props.tabsConfig, localSelection, context, dispatch, swaContributedTabs, tabToActivateNow, output, containerTabs[0].priority, allVisibleTabs, containerTabs[0]));\n    }\n\n    return AwPromiseService.instance.resolve(processFetchedData(data, props.selectionData, props.tabsConfig, localSelection, context, dispatch, swaContributedTabs, tabToActivateNow));\n  };\n\n  if (areInputPropsAndDataNotPopulatedYet(props, data)) {\n    return;\n  }\n\n  const {\n    dispatch\n  } = data;\n  const {\n    summaryContext\n  } = data.getData();\n  const {\n    selection,\n    context,\n    tabsConfig\n  } = props;\n  let localSelection = Array.isArray(selection) ? selection : [selection];\n  let allVisibleTabsInternal = [];\n\n  if (tabsConfig) {\n    tabsConfig.tabs.map(tab => {\n      let tabClone = { ...tab\n      };\n\n      if (conditionFilter(tabClone, tabsConfig, localSelection, context)) {\n        allVisibleTabsInternal.push(tabClone);\n      }\n    });\n  }\n\n  let tabRequestedToBeActivated = context && context.pageContext && context.pageContext.sublocationState && context.pageContext.sublocationState.secondaryActiveTabId !== '' ? context.pageContext.sublocationState.secondaryActiveTabId : '';\n\n  if (!tabRequestedToBeActivated) {\n    tabRequestedToBeActivated = '';\n  }\n\n  let currentlyActiveTabId = summaryContext && summaryContext.activeTabKey ? summaryContext.activeTabKey : '';\n  let tabToActivateNow = currentlyActiveTabId;\n\n  if (isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab(tabRequestedToBeActivated, data)) {\n    tabToActivateNow = tabRequestedToBeActivated;\n    localStorage.publish('lastActiveTab', tabToActivateNow);\n  }\n\n  if (summaryContext) {\n    if (!isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab(tabRequestedToBeActivated, data) && isInputSelectionSameAsCurrentSelection(summaryContext.selection, localSelection) && areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs(summaryContext.unExpandedVisibleTabs, allVisibleTabsInternal)) {\n      return;\n    }\n  }\n\n  let skipAfreshChildFetch = false;\n\n  if (summaryContext) {\n    if (isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab(tabRequestedToBeActivated, data)) {\n      tabToActivateNow = tabRequestedToBeActivated;\n    } else if (isInputSelectionSameAsCurrentSelection(summaryContext.selection, localSelection)) {\n      skipAfreshChildFetch = true;\n\n      if (isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs(summaryContext, allVisibleTabsInternal, currentlyActiveTabId)) {\n        skipAfreshChildFetch = false;\n      }\n    }\n  }\n\n  if (tabToActivateNow === '') {\n    tabToActivateNow = localStorage.get('lastActiveTab') ? localStorage.get('lastActiveTab') : tabToActivateNow;\n  }\n\n  let localSummaryContext = { ...data.summaryContext\n  };\n  localSummaryContext.selection = localSelection;\n  localSummaryContext.unExpandedVisibleTabs = allVisibleTabsInternal;\n  localSummaryContext.activeTabKey = tabToActivateNow;\n  dispatch({\n    path: 'data.summaryContext',\n    value: localSummaryContext\n  });\n  let pwaEditContext = context ? context.editContext : '';\n\n  if (!pwaEditContext || pwaEditContext === '') {\n    pwaEditContext = 'TABLE_CONTEXT';\n  }\n\n  let pwaEditHandler = editHandlerService.getEditHandler(pwaEditContext);\n  const isActiveTabIsNonStickyAndNoSelectionChange = !summaryContext || _.get(summaryContext, 'activeTab.api') !== undefined || isInputSelectionSameAsCurrentSelection(summaryContext.selection, localSelection);\n\n  if (!pwaEditHandler || !pwaEditHandler.editInProgress() && isActiveTabIsNonStickyAndNoSelectionChange) {\n    return editHandlerService.leaveConfirmation().then(function () {\n      return getTabToActivate();\n    });\n  }\n\n  return getTabToActivate();\n};\n\nconst activateTab = (data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority) => {\n  const selectedTab = tabsToShow.filter(function (tab) {\n    return tab.pageId === pageId || tab.name === tabTitle;\n  })[0];\n\n  const updateSelectionSummaryContext = output => {\n    let {\n      summaryContext\n    } = processFetchedData(data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, selectedTab, output, containerPriority, tabsToShow);\n    dispatch({\n      path: 'data.summaryContext',\n      value: summaryContext\n    });\n  };\n\n  const handleTabChange = () => {\n    if (selectedTab && selectedTab.api) {\n      if (!selectedTab.tabContent || refresh) {\n        const selectedTabTitle = selectedTab.tabKey ? selectedTab.tabKey : selectedTab.view;\n        dispatch({\n          path: 'data.summaryContext.activeTabKey',\n          value: selectedTabTitle\n        });\n        selectedTab.api(selection[0], selectedTabTitle, null, null, context).then(output => {\n          updateSelectionSummaryContext(output);\n        });\n      }\n    } else {\n      updateSelectionSummaryContext();\n    }\n  };\n\n  let pwaEditContext = context ? context.editContext : '';\n\n  if (!pwaEditContext || pwaEditContext === '') {\n    pwaEditContext = 'TABLE_CONTEXT';\n  }\n\n  let pwaEditHandler = editHandlerService.getEditHandler(pwaEditContext);\n\n  if (!pwaEditHandler || !pwaEditHandler.editInProgress()) {\n    editHandlerService.leaveConfirmation().then(function () {\n      return handleTabChange();\n    });\n  } else {\n    return handleTabChange();\n  }\n};\n\nexport const updateSelection = selection => {\n  return Array.isArray(selection) ? selection : [selection];\n};\nexport const getContext = (vmDef, props, data) => {\n  return [new DerivedStateResult({\n    ctxParameters: [],\n    additionalParameters: [data.summaryContext, props.selection, props.context, props.selectionData],\n    compute: () => {\n      return {\n        activeTab: data.summaryContext ? data.summaryContext.activeTab : undefined,\n        selection: Array.isArray(props.selection) ? props.selection : [props.selection],\n        context: props.context,\n        api: data.summaryContext ? data.summaryContext.api : undefined,\n        selectionData: props.selectionData\n      };\n    }\n  })];\n};\n\nconst clearSelectionData = selectionData => {\n  if (selectionData && selectionData.getValue() && selectionData.getValue().selected && selectionData.getValue().selected.length > 0) {\n    selectionData.update({\n      selected: [],\n      relationInfo: []\n    });\n  }\n};\n\nconst getTabsState = tabsConfig => {\n  if (tabsConfig) {\n    return (tabsConfig.tabs || []).reduce((acc, tab) => {\n      let visibleWhenCondition = {};\n\n      if (tab.visibleWhen && tab.visibleWhen.condition) {\n        visibleWhenCondition = _.get(tabsConfig, tab.visibleWhen.condition);\n      } else {\n        visibleWhenCondition.expression = tab.visibleWhen;\n      }\n\n      const conditionDeps = [parseCondition(visibleWhenCondition, ['selection', 'context'])];\n      return {\n        ctxParameters: _.uniq(concat(flatten(conditionDeps.map(x => x.ctxParameters)), acc.ctxParameters)),\n        additionalParameters: _.uniq(concat(acc.additionalParameters, flatten(conditionDeps.map(x => x.additionalParameters))))\n      };\n    }, {\n      ctxParameters: [],\n      additionalParameters: []\n    });\n  }\n\n  return {\n    ctxParameters: [],\n    additionalParameters: []\n  };\n};\n\nexport const getVisibleTabs = (vmDef, props, data) => {\n  let {\n    context,\n    tabsConfig,\n    selection,\n    additionalParameters,\n    ctxParameters\n  } = props;\n  let localSelection = Array.isArray(selection) ? selection : [selection];\n\n  const getAllVisibleTabs = () => {\n    let allVisibleTabs = [];\n\n    if (tabsConfig) {\n      tabsConfig.tabs.map(tab => {\n        let tabClone = { ...tab\n        };\n\n        if (conditionFilter(tabClone, tabsConfig, localSelection, context)) {\n          allVisibleTabs.push(tabClone);\n        }\n      });\n    }\n\n    if (allVisibleTabs) {\n      return allVisibleTabs;\n    }\n  };\n\n  const scope = {\n    context,\n    selection\n  };\n\n  const getFromProps = path => _.get(scope, path);\n\n  const localAdditionalParameters = additionalParameters.map(getFromProps);\n  return new DerivedStateResult({\n    ctxParameters,\n    additionalParameters: localAdditionalParameters,\n    compute: getAllVisibleTabs\n  });\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pagelevelcomponents/src/js/AwSelectionSummaryService.js"],"names":["trace","loadTabTitle","tab","localeService","loadSecondaryWorkareaTabs","tabsConfig","initialize","additionalParameters","getTabsState","conditionFilter","conditionExpression","conditionExpressionObj","_","ctx","appCtxService","selection","context","isXrtApplicable","isActiveTabStillVisible","visibleTabs","activeTab","updateTabsToShow","index","tabsToShow","idx","isContributedTabActive","swaContributedTabs","ndx","fetchChildTabs","isContributedTab","deferred","AwPromiseService","containerTab","doAction","depModuleObj","moduleLoader","syncSublocationState","newSublocationState","sublocationState","value","clearSublocationState","processFetchedData","tabToActivate","childTabs","allVisibleTabs","data","allVisibleContributedTabs","tabClone","output","childTab","updatedTabsToShow","t1","t2","requestedActiveTab","evalTabObj","localStorage","activeTab1","fetchTabsData","tabChangeCallback","clearSelectionData","activateTab","activeTabKey","unExpandedVisibleTabs","summaryContext","api","currentSelection","isInputSelectionSameAsCurrentSelection","inputSelection","areInputPropsAndDataNotPopulatedYet","props","areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs","currentlyVisibleUnExpandedTabs","inputUnExpandedTabs","i","cachedTabKey","receivedTabKey","isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs","isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab","currentlyActiveTabKey","tabRequestedToBeActivated","getTabToActivateAndVisibleTabs","getTabToActivate","containerTabs","dispatch","path","activeTabContent","localSelection","Array","allVisibleTabsInternal","currentlyActiveTabId","tabToActivateNow","skipAfreshChildFetch","localSummaryContext","pwaEditContext","pwaEditHandler","editHandlerService","isActiveTabIsNonStickyAndNoSelectionChange","selectedTab","updateSelectionSummaryContext","handleTabChange","selectedTabTitle","updateSelection","getContext","ctxParameters","compute","selectionData","selected","relationInfo","visibleWhenCondition","conditionDeps","parseCondition","concat","flatten","x","acc","getVisibleTabs","getAllVisibleTabs","scope","getFromProps","localAdditionalParameters"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2021 Siemens\nimport _ from 'lodash';\nimport moduleLoader from 'js/moduleLoader';\nimport cfgSvc from 'js/configurationService';\nimport localeService from 'js/localeService';\nimport editHandlerService from 'js/editHandlerService';\nimport appCtxService from 'js/appCtxService';\nimport conditionService from 'js/conditionService';\nimport AwPromiseService from 'js/awPromiseService';\nimport localStorage from 'js/localStorage';\nimport Debug from 'debug';\nimport { DerivedStateResult } from 'js/derivedContextService';\nimport { parseCondition } from 'js/conditionParser.service';\nimport { concat, flatten } from 'lodash';\n\nconst trace = new Debug( 'selection' );\n\nconst loadTabTitle = tab => {\n    if( typeof tab.name !== 'string' ) {\n        localeService.getLocalizedText( tab.name.source, tab.name.key ).then( function( result ) {\n            tab.name = result;\n        } );\n    }\n};\n\nconst loadSecondaryWorkareaTabs = async() => {\n    return await cfgSvc.getCfg( 'secondaryWorkareaTabs' ).then( tabsConfig => {\n        tabsConfig.tabs.forEach( function( tab, idx ) {\n            tab.pageId = tab.pageId ? tab.pageId : idx;\n        } );\n        tabsConfig.tabs.forEach( loadTabTitle );\n        return tabsConfig;\n    } );\n};\n\nexport const initialize = () => {\n    return loadSecondaryWorkareaTabs().then( tabsConfig => {\n        const { ctxParameters, additionalParameters } = getTabsState( tabsConfig );\n        return {\n            tabsConfig,\n            ctxParameters,\n            additionalParameters\n        };\n    } );\n};\n\nconst conditionFilter = ( tab, tabsConfig, selection, context ) => {\n    var conditionExpression = tab.visibleWhen;\n    if( tab.visibleWhen && tab.visibleWhen.condition ) {\n        var conditionExpressionObj = _.get( tabsConfig, tab.visibleWhen.condition );\n        conditionExpression = conditionExpressionObj.expression;\n    }\n\n    tab.displayTab = true;\n    if( conditionExpression ) {\n        tab.displayTab = conditionService.evaluateCondition( {\n            ctx: appCtxService.ctx,\n            selection: selection,\n            context: { ...context, isXrtApplicable: context && context.hasOwnProperty( 'isXrtApplicable' ) ? context.isXrtApplicable : !_.isUndefined( appCtxService.ctx.tcSessionData ) }\n        }, conditionExpression );\n    }\n    return tab.displayTab;\n};\n\nconst isActiveTabStillVisible = ( visibleTabs, activeTab ) => {\n    return visibleTabs.filter( tab => tab.tabContent ? tab.pageId === activeTab.pageId && _.isEqual( tab.tabContent, activeTab.tabContent ) : tab.pageId === activeTab.pageId ).length > 0;\n};\n\nconst updateTabsToShow = ( tabsToShow, activeTab ) => {\n    let index = _.findIndex( tabsToShow, ( tab ) => {\n        return tab.pageId === activeTab.pageId || tab.name === activeTab.name;\n    }, 0 );\n    tabsToShow = _.map( tabsToShow, ( tab, idx ) => {\n        if( idx === index ) {\n            tab.selectedTab = true;\n        } else {\n            tab.selectedTab = undefined;\n        }\n        return tab;\n    } );\n    return tabsToShow;\n};\n\nconst isContributedTabActive = ( swaContributedTabs, activeTab ) => {\n    if( activeTab && swaContributedTabs && swaContributedTabs.length > 0 ) {\n        let ndx = -1;\n        if( typeof activeTab === 'object' ) {\n            ndx = _.findIndex( swaContributedTabs, ( tab ) => {\n                return tab.pageId === activeTab.pageId || tab.name === activeTab.name;\n            }, 0 );\n        } else if( typeof activeTab === 'string' ) {\n            ndx = _.findIndex( swaContributedTabs, ( tab ) => {\n                return tab.name === activeTab || tab.view === activeTab;\n            }, 0 );\n        }\n        return ndx > -1;\n    }\n    return false;\n};\n\nconst fetchChildTabs = ( containerTab, selection, activeTab, swaContributedTabs, context ) => {\n    let isContributedTab = isContributedTabActive( swaContributedTabs, activeTab );\n    activeTab = isContributedTab === false ? activeTab : undefined;\n    var deferred = AwPromiseService.instance.defer();\n    if( containerTab.deps ) {\n        const doAction = depModuleObj => {\n            return depModuleObj[ containerTab.method ]( selection, activeTab, context, isContributedTab  );\n        };\n        return moduleLoader.loadDependentModule( containerTab.deps ).then( doAction );\n    }\n    return deferred.Promise;\n};\n\nexport const syncSublocationState = ( activeTab, sublocationState ) => {\n    let newSublocationState;\n    if( sublocationState ) {\n        newSublocationState = { ...sublocationState.value };\n    } else {\n        newSublocationState = {};\n    }\n    newSublocationState.secondaryActiveTabId = activeTab.tabKey ? activeTab.tabKey : activeTab.view;\n    if( sublocationState.secondaryActiveTabId !== newSublocationState.secondaryActiveTabId ) {\n        sublocationState.update( newSublocationState );\n    }\n};\n\nexport const clearSublocationState = ( sublocationState ) => {\n    let newSublocationState = { ...sublocationState.value };\n    newSublocationState.secondaryActiveTabId = undefined;\n    sublocationState.update( newSublocationState );\n};\n\nconst processFetchedData = ( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerPriority, updatedTabsToShow, containerTab ) => {\n    let tabToActivate = {};\n    let tabsToShow = [];\n    let childTabs = [];\n\n    if( output ) {\n        let allVisibleTabs = data.getData().changedAllVisibleTabs;\n        let allVisibleContributedTabs = [];\n        if( allVisibleTabs ) {\n            allVisibleTabs.map( ( tab ) => {\n                let tabClone = { ...tab };\n                if( !tabClone.hasChildTabs ) {\n                    allVisibleContributedTabs.push( tabClone );\n                }\n            } );\n            if( allVisibleContributedTabs.length === 0 ) {\n                allVisibleContributedTabs = swaContributedTabs;\n            }\n        } else {\n            allVisibleContributedTabs = swaContributedTabs;\n        }\n\n        childTabs = output.childTabs;\n        _.forEach( childTabs, ( childTab ) => { childTab.priority = containerPriority; } );\n        tabsToShow = tabsToShow.concat( childTabs, allVisibleContributedTabs );\n    } else {\n        tabsToShow = updatedTabsToShow ? updatedTabsToShow : swaContributedTabs;\n    }\n\n    // sort the contributed and container tabs based on priority\n    tabsToShow.sort( function( t1, t2 ) {\n        return t1.priority - t2.priority;\n    } );\n\n    let requestedActiveTab = activeTab;\n    activeTab = evalTabObj( tabsToShow, activeTab );\n    if( !_.isEmpty( activeTab ) && isActiveTabStillVisible( tabsToShow, activeTab ) ) {\n        tabToActivate = activeTab;\n        tabsToShow = updateTabsToShow( tabsToShow, activeTab );\n    } else if( _.isEmpty( activeTab ) ) {\n        requestedActiveTab = localStorage.get( 'lastActiveTab' );\n        let activeTab1 = evalTabObj( tabsToShow, requestedActiveTab );\n        if( !_.isEmpty( activeTab1 ) && isActiveTabStillVisible( tabsToShow, activeTab1 ) && requestedActiveTab !== '' ) {\n            return fetchTabsData( selectionData, tabsConfig, containerTab, selection, requestedActiveTab, swaContributedTabs, data, context, dispatch, tabsToShow );\n        }\n        tabToActivate = tabsToShow[ 0 ];\n        tabsToShow = updateTabsToShow( tabsToShow, tabToActivate );\n    } else {\n        tabToActivate = tabsToShow[ 0 ];\n        tabsToShow = updateTabsToShow( tabsToShow, tabToActivate );\n    }\n    if( tabToActivate ) {\n        tabToActivate.tabContent = output ? output.activeTabContent : undefined;\n        tabToActivate.extraInfo = output ? output.extraInfo : null;\n    }\n\n    const tabChangeCallback = ( pageId, tabTitle, refresh ) => {\n        localStorage.publish( 'lastActiveTab', pageId );\n        clearSelectionData( selectionData );\n        activateTab( data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority );\n    };\n\n    const activeTabKey = tabToActivate && tabToActivate.tabKey ? tabToActivate.tabKey : tabToActivate ? tabToActivate.view : '';\n\n    let unExpandedVisibleTabs = data && data.ctx && data.ctx.visibleTabs ? data.ctx.visibleTabs : undefined;\n    if( !unExpandedVisibleTabs || unExpandedVisibleTabs.length === 0 ) {\n        unExpandedVisibleTabs = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.unExpandedVisibleTabs;\n    }\n\n    return {\n        summaryContext: {\n            activeTab: tabToActivate,\n            visibleTabs: tabsToShow,\n            api: tabChangeCallback,\n            selection: selection,\n            allVisibleTabs: updatedTabsToShow,\n            activeTabKey: activeTabKey,\n            childTabs: childTabs,\n            unExpandedVisibleTabs\n        }\n    };\n};\n\nconst fetchTabsData = ( selectionData, tabsConfig, containerTab, selection, activeTab, swaContributedTabs, data, context, dispatch, allVisibleTabs ) => {\n    return fetchChildTabs( containerTab, selection[ 0 ], activeTab, swaContributedTabs, context ).then( ( output ) => {\n        const currentSelection = data.getData().summaryContext && data.getData().summaryContext.selection ? data.getData().summaryContext.selection : undefined;\n        if( !currentSelection || currentSelection && currentSelection.length === 1 && currentSelection[ 0 ].uid === selection[ 0 ].uid ) {\n            return processFetchedData( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerTab.priority, allVisibleTabs, containerTab );\n        }\n        if( currentSelection && currentSelection.length === 1 ) {\n            return fetchTabsData( selectionData, tabsConfig, containerTab, currentSelection, activeTab, swaContributedTabs, data, context, dispatch );\n        }\n        return AwPromiseService.instance.resolve( { summaryContext: data.getData().summaryContext } );\n    } );\n};\n\nconst evalTabObj = ( tabsToShow, activeTab ) => {\n    if( typeof activeTab !== 'object' ) {\n        let index = _.findIndex( tabsToShow, ( tab ) => {\n            return tab.pageId && tab.pageId === activeTab || tab.tabKey && tab.tabKey === activeTab || tab.name && tab.name === activeTab\n            || tab.view && tab.view === activeTab || tab.id && tab.id === activeTab;\n        }, 0 );\n        activeTab = tabsToShow[ index ];\n    }\n    return activeTab;\n};\n\nconst isInputSelectionSameAsCurrentSelection = ( currentSelection, inputSelection ) => {\n    if(  !currentSelection && !inputSelection  ||  currentSelection && currentSelection.length === 0 && inputSelection && inputSelection.length === 0  ) {\n        return true;\n    }\n    return currentSelection.length === inputSelection.length && inputSelection.length > 0 && _.isEqual( currentSelection[ 0 ].uid, inputSelection[ 0 ].uid );\n};\n\nconst areInputPropsAndDataNotPopulatedYet = ( props, data ) => {\n    return !props || !props.selection || !data || !props.tabsConfig || !props.tabsConfig.tabs;\n};\n\nconst areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs = ( currentlyVisibleUnExpandedTabs, inputUnExpandedTabs ) => {\n    if( !currentlyVisibleUnExpandedTabs && !inputUnExpandedTabs ) {\n        return true;\n    }\n    if( !currentlyVisibleUnExpandedTabs || !inputUnExpandedTabs ) {\n        return false;\n    }\n    if( currentlyVisibleUnExpandedTabs.length !== inputUnExpandedTabs.length ) {\n        return false;\n    }\n\n    for( var i = 0; i < currentlyVisibleUnExpandedTabs.length; ++i ) {\n        var cachedTabKey = currentlyVisibleUnExpandedTabs[ i ].tabKey ? currentlyVisibleUnExpandedTabs[ i ].tabKey : currentlyVisibleUnExpandedTabs[ i ].name;\n        var receivedTabKey = inputUnExpandedTabs[ i ].tabKey ? inputUnExpandedTabs[ i ].tabKey : inputUnExpandedTabs[ i ].name;\n        if( cachedTabKey !== receivedTabKey ) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs = ( summaryContext, unExpandedVisibleTabs, currentlyActiveTabId ) => {\n    return summaryContext && summaryContext.activeTab && !summaryContext.activeTab.api && unExpandedVisibleTabs && unExpandedVisibleTabs.filter( tab => tab.view === currentlyActiveTabId ).length === 0;\n};\n\nconst isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab = ( tabRequestedToBeActivated, data ) => {\n    let currentlyActiveTabKey = data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.tabKey ? data.summaryContext.activeTab.tabKey : data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.view ? data.summaryContext.activeTab.view : '';\n    if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {\n        currentlyActiveTabKey = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.tabKey ? data && data.getData().summaryContext.activeTab.tabKey : data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.view ? data.getData().summaryContext.activeTab.view : '';\n        if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {\n            currentlyActiveTabKey = data && data.summaryContext ? data.summaryContext.activeTabKey : '';\n            if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {\n                currentlyActiveTabKey = data && data.getData().summaryContext ? data.getData().summaryContext.activeTabKey : '';\n                if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\nexport const getTabToActivateAndVisibleTabs = ( data, props, unExpandedVisibleTabs ) => {\n    const getTabToActivate = () => {\n        let containerTabs = [];\n        let swaContributedTabs = [];\n        if( tabsConfig ) {\n            var allVisibleTabs = [];\n            tabsConfig.tabs.map( ( tab ) => {\n                let tabClone = { ...tab };\n                if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {\n                    allVisibleTabs.push( tabClone );\n                }\n            } );\n\n            for( const tab of allVisibleTabs ) {\n                if( tab.hasChildTabs === true ) {\n                    containerTabs.push( tab );\n                } else {\n                    swaContributedTabs.push( tab );\n                }\n            }\n        }\n\n        if( containerTabs.length > 0 && !skipAfreshChildFetch ) {\n            dispatch( { path: 'data.changedAllVisibleTabs', value: [] } );\n            return fetchTabsData( props.selectionData, props.tabsConfig, containerTabs[ 0 ], localSelection, tabToActivateNow, swaContributedTabs, data, context, dispatch, allVisibleTabs );\n        }\n        if( containerTabs.length > 0 ) {\n            var output = { childTabs: data.summaryContext ? data.summaryContext.childTabs : [], activeTabContent: _.get( data, 'summaryContext.activeTab.tabContent' ) };\n            if( !output.extraInfo ) {\n                output.extraInfo = data.summaryContext && data.summaryContext.activeTab ? data.summaryContext.activeTab.extraInfo : null;\n            }\n            if( !output.childTabs || output.childTabs.length === 0 ) {\n                dispatch( { path: 'data.changedAllVisibleTabs', value: unExpandedVisibleTabs } );\n                return;\n            }\n            return AwPromiseService.instance.resolve( processFetchedData( data, props.selectionData, props.tabsConfig, localSelection, context, dispatch,\n                swaContributedTabs, tabToActivateNow, output, containerTabs[ 0 ].priority, allVisibleTabs, containerTabs[0] ) );\n        }\n        return AwPromiseService.instance.resolve( processFetchedData( data, props.selectionData, props.tabsConfig, localSelection, context, dispatch, swaContributedTabs, tabToActivateNow ) );\n    };\n\n    if( areInputPropsAndDataNotPopulatedYet( props, data ) ) {\n        return;\n    }\n\n    const { dispatch } = data;\n    const { summaryContext } = data.getData();\n    const { selection, context, tabsConfig } = props;\n    let localSelection = Array.isArray( selection ) ? selection : [ selection ];\n\n    let allVisibleTabsInternal = [];\n    if( tabsConfig ) {\n        tabsConfig.tabs.map( ( tab ) => {\n            let tabClone = { ...tab };\n            if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {\n                allVisibleTabsInternal.push( tabClone );\n            }\n        } );\n    }\n\n    let tabRequestedToBeActivated = context && context.pageContext && context.pageContext.sublocationState && context.pageContext.sublocationState.secondaryActiveTabId !== '' ? context.pageContext\n        .sublocationState.secondaryActiveTabId : '';\n\n    if( !tabRequestedToBeActivated ) {\n        tabRequestedToBeActivated = '';\n    }\n\n    let currentlyActiveTabId = summaryContext && summaryContext.activeTabKey ? summaryContext.activeTabKey : '';\n    let tabToActivateNow = currentlyActiveTabId;\n\n    if( isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) ) {\n        tabToActivateNow = tabRequestedToBeActivated;\n        localStorage.publish( 'lastActiveTab', tabToActivateNow );\n    }\n\n    if( summaryContext ) {\n        if( !isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) && isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection ) &&\n            areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs( summaryContext.unExpandedVisibleTabs, allVisibleTabsInternal ) ) {\n            return;\n        }\n    }\n\n    let skipAfreshChildFetch = false;\n\n    if( summaryContext ) {\n        if( isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) ) {\n            tabToActivateNow = tabRequestedToBeActivated;\n        } else if( isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection ) ) {\n            skipAfreshChildFetch = true;\n            if( isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs( summaryContext, allVisibleTabsInternal, currentlyActiveTabId ) ) {\n                skipAfreshChildFetch = false;\n            }\n        }\n    }\n    if( tabToActivateNow === '' ) {\n        tabToActivateNow = localStorage.get( 'lastActiveTab' ) ? localStorage.get( 'lastActiveTab' ) : tabToActivateNow;\n    }\n\n    let localSummaryContext = { ...data.summaryContext };\n    localSummaryContext.selection = localSelection;\n    localSummaryContext.unExpandedVisibleTabs = allVisibleTabsInternal;\n    localSummaryContext.activeTabKey = tabToActivateNow;\n    dispatch( { path: 'data.summaryContext', value: localSummaryContext } );\n\n    let pwaEditContext = context ? context.editContext : '';\n    if( !pwaEditContext || pwaEditContext === '' ) {\n        pwaEditContext = 'TABLE_CONTEXT';\n    }\n    let pwaEditHandler = editHandlerService.getEditHandler( pwaEditContext );\n    const isActiveTabIsNonStickyAndNoSelectionChange = !summaryContext || _.get( summaryContext, 'activeTab.api' ) !== undefined || isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection );\n    if( !pwaEditHandler || !pwaEditHandler.editInProgress() && isActiveTabIsNonStickyAndNoSelectionChange ) {\n        return editHandlerService.leaveConfirmation().then( function() {\n            return getTabToActivate();\n        } );\n    }\n    return getTabToActivate();\n};\n\nconst activateTab = ( data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority ) => {\n    const selectedTab = tabsToShow.filter( function( tab ) {\n        return tab.pageId === pageId || tab.name === tabTitle;\n    } )[ 0 ];\n\n    const updateSelectionSummaryContext = ( output ) => {\n        let { summaryContext } = processFetchedData( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, selectedTab, output, containerPriority, tabsToShow );\n        dispatch( { path: 'data.summaryContext', value: summaryContext } );\n    };\n\n    const handleTabChange = () => {\n        if( selectedTab && selectedTab.api ) {\n            if( !selectedTab.tabContent || refresh ) {\n                const selectedTabTitle = selectedTab.tabKey ? selectedTab.tabKey : selectedTab.view;\n                dispatch( { path: 'data.summaryContext.activeTabKey', value: selectedTabTitle } );\n                selectedTab.api( selection[ 0 ], selectedTabTitle, null, null, context ).then( output => {\n                    updateSelectionSummaryContext( output );\n                } );\n            }\n        } else {\n            updateSelectionSummaryContext();\n        }\n    };\n\n    let pwaEditContext = context ? context.editContext : '';\n    if( !pwaEditContext || pwaEditContext === '' ) {\n        pwaEditContext = 'TABLE_CONTEXT';\n    }\n\n    let pwaEditHandler = editHandlerService.getEditHandler( pwaEditContext );\n\n    if( !pwaEditHandler || !pwaEditHandler.editInProgress() ) {\n        editHandlerService.leaveConfirmation().then( function() {\n            return handleTabChange();\n        } );\n    } else {\n        return handleTabChange();\n    }\n};\n\nexport const updateSelection = ( selection ) => {\n    return Array.isArray( selection ) ? selection : [ selection ];\n};\n\nexport const getContext = ( vmDef, props, data ) => {\n    return [ new DerivedStateResult( {\n        ctxParameters: [],\n        additionalParameters: [ data.summaryContext, props.selection, props.context, props.selectionData ],\n        compute: () => {\n            return {\n                activeTab: data.summaryContext ? data.summaryContext.activeTab : undefined,\n                selection: Array.isArray( props.selection ) ? props.selection : [ props.selection ],\n                context: props.context,\n                api: data.summaryContext ? data.summaryContext.api : undefined,\n                selectionData: props.selectionData\n            };\n        }\n    } ) ];\n};\n\nconst clearSelectionData = ( selectionData ) => {\n    if( selectionData && selectionData.getValue() && selectionData.getValue().selected && selectionData.getValue().selected.length > 0 ) {\n        selectionData.update( { selected: [], relationInfo: [] } );\n    }\n};\n\nconst getTabsState = ( tabsConfig ) => {\n    if( tabsConfig ) {\n        return ( tabsConfig.tabs || [] ).reduce( ( acc, tab ) => {\n            let visibleWhenCondition = {};\n            if( tab.visibleWhen && tab.visibleWhen.condition ) {\n                visibleWhenCondition = _.get( tabsConfig, tab.visibleWhen.condition );\n            } else {\n                visibleWhenCondition.expression = tab.visibleWhen;\n            }\n            const conditionDeps = [ parseCondition( visibleWhenCondition, [ 'selection', 'context' ] ) ];\n            return {\n                ctxParameters: _.uniq( concat( flatten( conditionDeps.map( x => x.ctxParameters ) ), acc.ctxParameters ) ),\n                additionalParameters: _.uniq( concat( acc.additionalParameters, flatten( conditionDeps.map( x => x.additionalParameters ) ) ) )\n            };\n        }, {\n            ctxParameters: [],\n            additionalParameters: []\n        } );\n    }\n    return {\n        ctxParameters: [],\n        additionalParameters: []\n    };\n};\n\nexport const getVisibleTabs = ( vmDef, props, data ) => {\n    let { context, tabsConfig, selection, additionalParameters, ctxParameters } = props;\n    let localSelection = Array.isArray( selection ) ? selection : [ selection ];\n    const getAllVisibleTabs = () => {\n        let allVisibleTabs = [];\n        if( tabsConfig ) {\n            tabsConfig.tabs.map( ( tab ) => {\n                let tabClone = { ...tab };\n                if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {\n                    allVisibleTabs.push( tabClone );\n                }\n            } );\n        }\n        if( allVisibleTabs ) {\n            return allVisibleTabs;\n        }\n    };\n    const scope = {\n        context,\n        selection\n    };\n    const getFromProps = ( path ) => _.get( scope, path );\n    const localAdditionalParameters = additionalParameters.map(\n        getFromProps );\n\n    return new DerivedStateResult( {\n        ctxParameters,\n        additionalParameters: localAdditionalParameters,\n        compute: getAllVisibleTabs\n    } );\n};\n"]},"metadata":{},"sourceType":"module"}