{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module provides cell renderer customization mechanism in PL Table.\n *\n * - Below is the cell renderer pattern:\n *   {\n *       action: function( columnDef, vmo, tableElement ) {\n *           // return DOMStructure\n *       },\n *       condition: function( columnDef, vmo, tableElement ) {\n *           // return true to enable this renderer\n *       }\n *   }\n *\n * - Best practice is to make condition to be unique for your case.\n * - If the requirement is overlapping default behavior, just overlap the condition.\n * - If decoration to cell is needed, just write action, do your work without return\n *   value, but the decoration will only happens before OOTB cell renderer, not after.\n *\n * @module js/splmTableCellRenderer\n *\n */import _ from'lodash';import uwPropertyService from'js/uwPropertyService';import splmTableConstants from'js/splmTableConstants';import splmTableUtils from'js/splmTableUtils';var exports={};export let updateCellChangedClass=function(prop,element){if(element){if(uwPropertyService.isModified(prop)){prop.dirty=true;element.classList.add(splmTableConstants.CLASS_CELL_CHANGED);}else{prop.dirty=false;element.classList.remove(splmTableConstants.CLASS_CELL_CHANGED);}}};/**\n * Creates and returns a DOMElement for the propertyCell of the passed in view model object (vmo) which defines the row\n * and the given column (columnInfo )\n * @param {Object} column - Declarative columnInfo object\n * @param {Object} vmo - Declarative view model object (e.g. row)\n * @param {DOMElement} tableElem - Table DOMElement\n * @param {DOMElement} rowElem - Row DOMElement\n * @param {Boolean} dynamicRowHeightEnabled - if dynamic row height is enabled\n * @return {DOMElement} The newly created DOMElement for the property cell content\n */export let createElement=function(column,vmo,tableElem,rowElem){var contentElem=null;_.forEach(column.cellRenderers,function(renderer){if(!renderer.processing&&renderer.condition(column,vmo,tableElem,rowElem)){// NOTE: When ASync rendering happens, this processing mechanism may have issue.\n// But for now the whole PL Table dosen't support ASync Rendering yet.\nrenderer.processing=true;contentElem=renderer.action(column,vmo,tableElem,rowElem);delete renderer.processing;}return!contentElem;});// Default cell renderer for PLTable\nif(!contentElem){contentElem=document.createElement('div');contentElem.classList.add(splmTableConstants.CLASS_TABLE_CELL_TOP);if(vmo.props&&vmo.props[column.field]&&!vmo.props[column.field].isArray&&vmo.props[column.field].uiValue){contentElem.title=vmo.props[column.field].uiValue;}if(tableElem&&tableElem._tableInstance.dynamicRowHeightStatus){contentElem.classList.add(splmTableConstants.CLASS_TABLE_CELL_TOP_DYNAMIC);}const textContent=vmo.props&&vmo.props[column.field]?vmo.props[column.field].uiValue:'';if(textContent||!vmo.props||Object.keys(vmo.props).length===0){var gridCellText=document.createElement('span');gridCellText.classList.add(splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT);gridCellText.textContent=textContent;contentElem.appendChild(gridCellText);}}// isDirty update\nif(contentElem&&vmo.props&&vmo.props[column.field]){updateCellChangedClass(vmo.props[column.field],contentElem);}return contentElem;};export let createHeaderElement=function(column,tableElem){var contentElem=null;_.forEach(column.headerRenderers,function(renderer){if(!renderer.processing&&renderer.condition(column,tableElem)){// NOTE: When ASync rendering happens, this processing mechanism may have issue.\n// But for now the whole PL Table dosen't support ASync Rendering yet.\nrenderer.processing=true;contentElem=renderer.action(column,tableElem);delete renderer.processing;}return!contentElem;});return contentElem;};export const addDynamicCellHeight=function(vmo,cell){const dynamicCellText=cell.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC)[0];if(dynamicCellText){dynamicCellText.style.maxHeight=String(vmo.rowHeight)+'px';}};export const updateCell=function(cellElem,rowElem,table,tableEditor){// If cell is in edit we don't need to update as it is databound and will have latest value\nif(cellElem.isElementInEdit){return;}var oldCellTop=cellElem.children[0];var newCellTop=createElement(cellElem.columnDef,rowElem.vmo,table,rowElem);if(table._tableInstance.dynamicRowHeightStatus===true){addDynamicCellHeight(rowElem.vmo,newCellTop);}// LCS-145046 - Launch workflow for schedule Task - Item selected does not show open cell command\n// Move command cell to new cell if present\n//\n// LCS-164398 - ACE - adding child item in table mode, shows two show children icon\n// For the case, which custom cell renderer complies its own command WITH CONDITION, there is\n// a practice:\n// 1. Select item which dose not match the CONDITION. In this case, we will compile a native cell\n//    command for it. It will be dummy since the condition is not match in common case, but the DOM\n//    structure is there.\n// 2. After applying something (Add a child in ACE case), the CONDITION in custom cell renderer becomes\n//    true. Then the custom cell renderer will generate the cell.\n// 3. So for logic below, in this practice, we should not bring the old command - we should use the command\n//    In custom cell.\n// The only 2 cases which is going to have problem is select and hover for now - both of the should be fine\n// here.\n//\n// LCS-166330 Regression caused by Fix for LCS-164398\n// Be careful that all the DOM data structure are not OOTB JS type - in this case the classList is not array\n// but DOMTokenList. so we can't use put empty array as default value and assume it has '.contains'.\n//\nvar currentCellLastChildClassList=null;var newCellCommandParentElem=null;var oldCellCommandParentElem=null;if(cellElem.columnDef.isTreeNavigation===true){newCellCommandParentElem=newCellTop.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER)[0];oldCellCommandParentElem=oldCellTop.getElementsByClassName(splmTableConstants.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER)[0];}else{newCellCommandParentElem=newCellTop;oldCellCommandParentElem=oldCellTop;}currentCellLastChildClassList=newCellCommandParentElem.lastChild&&newCellCommandParentElem.lastChild.classList?newCellCommandParentElem.lastChild.classList:undefined;if(!(currentCellLastChildClassList&&currentCellLastChildClassList.contains(splmTableConstants.CLASS_AW_CELL_COMMANDS_CONTAINER))&&oldCellCommandParentElem.lastChild&&oldCellCommandParentElem.lastChild.classList&&oldCellCommandParentElem.lastChild.classList.contains(splmTableConstants.CLASS_NATIVE_CELL_COMMANDS)){newCellCommandParentElem.appendChild(oldCellCommandParentElem.lastChild);}// cleanup cell commands and tree commands & expand/collapse icon components if exist\nsplmTableUtils.cleanupComponents(oldCellTop);cellElem.replaceChild(newCellTop,oldCellTop);tableEditor.updateEditStatusForCell(cellElem);};exports={createElement,createHeaderElement,addDynamicCellHeight,updateCell,updateCellChangedClass};export default exports;","map":null,"metadata":{},"sourceType":"module"}