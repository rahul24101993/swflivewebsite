{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/* eslint-disable valid-jsdoc */ /* eslint-disable require-jsdoc */ /**\n * @module js/popupService\n */import _ from'lodash';import utils from'js/popupUtils';import{DOMAPIs as dom}from'js/domUtils';import positionService from'js/positionService';import appCtxService from'js/appCtxService';const manager=new utils.PopupManager();const MIN_SIZE=50;const BUFFER_SIZE=20;// the default popup options\nconst _defaultOptions={// enable open multiple popups at the same time\n// multiple: false,\n// pre-defined popup configures provided by framework. accept values: modal, balloon, tooltip\n// preset: null,\n// enable close the popup when click outside the popup\nclickOutsideToClose:true,// auto update popup position or close popup when the reference element moves, accept values: 'follow', 'close'\nwhenParentScrolls:'follow',// use outside scroll event to do scroll detection, then based on option whenParentScrolls to close or do follow\n// if set to false, scroll detection will fall back to naive mode: where scroll happens from body to reference.\nuseOutsideScrollEvent:true,// modal mode\n// hasMask: false,\n// has arrow / bubble\n// hasArrow: false,\narrowOptions:{// specify where to align the arrow, relative to reference element,\n// valid value: auto / center / start / end\n// auto: based on the popup alignment, arrow should be smart position itself.\nalignment:'auto',// specify the alignment offset in px, relative to reference element,\n// could be positive / negative\n// special used for start / end case.\noffset:0,// specify the shift offset in px, relative to popup element,\n// must be positive\nshift:5},// the default parent element where the popup element mount to, accept native Element or css selector\n// only valid when enableAppend is true, disable it by set enableAppend = false\nparent:document.body,// set to false when user uses popup in multiple level / nested case\nenableAppend:true,// the reference element which trigger the popup, accept native Element or css selector\n// reference: null,\n// enable popup overlapping on reference element\n// overlapOnReference: false,\n// expect to position popup relative to the reference element\nrelative:true,// Use this option when you want to position popup on the current mouse position. It could be the native targetEvent which triggers to show the popup, or any event with clientX, clientY information\n// targetEvent: null,\n// support add custom styles from application.\n// required for aw-navigate-breadcrumb and aw-search-breadcrumb\n// className: '',\n// popup container size, unit should be included and it could be any. optional\n// height: '',\n// width: '',\n// maxWidth: '',\n// maxHeight: '',\n// minHeight: '',\n// minWidth: '',\n// define the minimal size a popup could be, it's required because:\n// 1, prevent popup too small\n// 2, smart flip side and alignment to support smart position\nminSize:MIN_SIZE,// UX requirement: define the gap/buffer size for drop shadow when the available space is highly limited\nmarginBufferSize:BUFFER_SIZE,// enable popup draggable or not\n// draggable: false,\n// placement options: ['top-start','top','top-end','right-start','right','right-end',\n// 'bottom-end','bottom','bottom-start','left-end','left','left-start']\nplacement:'bottom-start',// smart position behavior, accept values: 'fixed', 'opposite', 'clockwise', 'counterclockwise'\n// define how the position engine to search a available space to place the popup.\nflipBehavior:'opposite',// popup lifeCycle hooks\nhooks:{whenOpened:null,whenUpdated:null,whenClosed:null}// Only available for command popup action case - whether to show a popup independent(not nested) of that command. By default command popup are nested.\n// independent: false\n};/**\n * the default preset options for AFX provided popups,\n * user can override by explicitly configure options\n */const _popupPresets={modal:{options:{relative:false,hasMask:true,innerClassName:'aw-popup-Modal',clickOutsideToClose:false,adaptiveShift:true,draggable:true,handle:'.aw-layout-panelTitle, .panel-header',whenParentScrolls:'close'}},balloon:{options:{ownContainer:true,hasArrow:true,innerClassName:'aw-popup-balloon',clickOutsideToClose:true,adaptiveShift:true,placement:['top','bottom','left','right'],flipBehavior:'opposite',padding:{x:4,y:4},arrowOptions:{// specify where to align the arrow, relative to reference element,\n// valid value: auto / center / start / end\nalignment:'auto',// specify the alignment offset in px, relative to reference element,\n// could be positive / negative\n// special used for start / end case.\noffset:5,// specify the shift offset in px, relative to popup element,\n// must be positive\nshift:15}}},tooltip:{options:{autoFocus:false,showDuration:100,hideDuration:100,ownContainer:true,placement:['top','bottom','right','left'],flipBehavior:'opposite',whenParentScrolls:'close',adaptiveShift:true,// prevent tooltip cut off in corner case\nresizeToClose:true,advancePositioning:true,// prevent overlap or flash when popup content growing\nhasArrow:true,padding:{x:4,y:4},arrowOptions:{alignment:'center'},minSize:5,hasPadding:true,forceCloseOthers:false,innerClassName:'sw-popup-tooltip sw-popup-easein'}}// EXTENDED FUTURE\n};// popup node name,\nconst POPUP_NODE_SELECTOR='div.sw-popup';/**\n * serves as advanced version of hide api\n *\n * close popup by the popupEl or target event. null to force close all popups\n *\n * @param {Object | String} popupEl - the popupEl to close. accept native Element element or css selector\n * @param {String} excludeId - the popupEl to exclude\n * @param {Boolean} force - force to close all popups on current page\n * @returns {Promise} promise with the close result, true or false\n */function close(popupEl){let excludeId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let force=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let elements=[];// if specified and still available on DOM\npopupEl=utils.getElement(utils.extendSelector(popupEl));if(popupEl){elements=_.concat([],popupEl);}// default to force close all popups if no element specified.\nif(!popupEl){elements=dom.getAll(POPUP_NODE_SELECTOR);}let tasks=[];_.forEach(elements,function(elem){if(excludeId&&excludeId===elem.id){return;}const popupRef=manager.get(elem.id);popupRef&&tasks.push(popupRef.hide(force));});return Promise.all(tasks).then(()=>true);}function processExistingPopups(options){let result=true;const{reference}=options;if(options.multiple===true){// prevent create duplicate popup instance for one referenceEl\n// if the referenceEl already has a popup, show again just by bring the popup to foreground,\n// return popupRef or true\nresult=utils.handleOpenedPopup(reference,manager);}else{// if in singleton mode, always force close others\n// process others\n// return true\nif(options.forceCloseOthers!==false){const id=reference?reference.getAttribute(utils.POPUP_ID_ATTRIBUTE):null;close(null,id);result=true;}// process self\n// return null or true\nif(options.toggleMode===true){// if the referenceEl already has a popup, close it and return null to indicate exit\nresult=utils.handleOpenedPopup(reference,manager,true);}}return result;}function deepAssign(){function customize(objValue,srcValue,key){// simple assign by default\nlet result=srcValue;// go deeper for these keys\nif(['arrowOptions','hooks'].indexOf(key)!==-1){result=_.assign({},objValue,srcValue);}return result;}return _.assignWith({},...arguments,customize);//return _.partialRight( _.assignWith, customize )( ...arguments );\n}const getReference=function(reference){let force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// case ref\nif(reference&&_.has(reference,'current')){if(force){return reference.current;}return reference.current||reference;}// case native dom or normal selector\nreturn utils.getElement(reference);};const componentMounted=(options,popupEl)=>{// re-evaluate reference\nconst reference=getReference(options.reference,true);let popupRef=new utils.PanelRef(popupEl,{...options,reference});options.showDeferred.current&&options.showDeferred.current.resolve(popupRef);manager.add(popupRef);popupRef.attach();updatePosition(popupRef);return function componentWillUnMounted(){options.hideDeferred.current&&options.hideDeferred.current.resolve(true);options.showDeferred.current&&options.showDeferred.current.resolve(true);manager.remove(popupRef);popupRef.detach();// clean up resources\noptions.showDeferred.current=null;options.hideDeferred.current=null;popupRef=null;};};function consolidateOptions(options,hide,update){// backup user options\nconst userOptions=deepAssign({},options);// merge presetOptions if any preset defined\nlet presetOptions={};const preset=options.preset;if(preset&&_.has(_popupPresets,preset)){presetOptions=_popupPresets[preset].options;}options=deepAssign({},_defaultOptions,presetOptions,options);options.userOptions=userOptions;options.parent=utils.getElement(options.parent)||document.body;options.reference=getReference(options.reference);options.manager=manager;inflateOptions(options);// apis being passed around(to subview) to control popups, only initial once\nif(!options.api){const getCurrent=()=>manager.get(options.popupReference.current.id);options.api={// hide this popup\n// hide()\nhide,// update options for this popup\n// update({ height: 500 } )\nupdate,// get this popup - return popupRef\n// getCurrent()\ngetCurrent,// update position for this popup\n// updatePosition()\nupdatePosition:()=>updatePosition(getCurrent())};}const beforeOpen=()=>{// re-evaluate reference\noptions.reference=getReference(options.reference,true);return processExistingPopups(options);};const handlePrevents=e=>{e.stopPropagation();};Object.assign(options,{componentMounted,beforeOpen,handlePrevents});return options;}function inflateOptions(options){if(options.multiple===true){options.forceUid=true;options.useCloseContext=true;}if(options.whenParentScrolls==='follow'){options.followParentScroll=true;}else{options.followParentScroll=false;options.closeWhenParentScroll=true;}if(options.toggleMode){options.ignoreReferenceClick=true;}if(options.preset==='modal'){options.relative=false;}if(options.hasMask){options.isModal=true;}// legacy compatible\n// 'isModal' was deprecated, suggest use 'preset' only\nif(options.hasMask&&!_.has(options,'isModal')){options.isModal=true;}//if preset is not included in options but hasArrow is true, user a wants balloon popup\nif(!_.has(options,'preset')&&options.hasArrow&&!options.innerClassName){options.innerClassName='aw-popup-balloon';}if(options.isModal&&!_.has(options,'preset')){options.preset='modal';}// end\n// improve the flexibility to support both single value and array values.\nif(options.placement&&_.isArray(options.placement)){[options.placement,...options.alternativePlacements]=options.placement;}}function setPositionAtMousePosition(popupEl,event){const popup=utils.getContainerElement(popupEl);const resizeContainer=utils.getResizeContainer(popupEl);const height=popup.offsetHeight;const width=popup.offsetWidth;const position=utils.getMousePosition(event);let left=position.x;let top=position.y;// Check if context menu would go outside of visible window, and move up if needed\nlet resizeInfo=null;const maxYNeeded=top+height;if(maxYNeeded>=window.innerHeight){top-=height;// case go out of boundary\nif(top<0){resizeInfo={...resizeInfo,'max-height':position.y};top=0;}}const maxXNeeded=left+width;if(maxXNeeded>=window.innerWidth){left-=width;// case go out of boundary\nif(left<0){resizeInfo={...resizeInfo,'max-width':position.x};left=0;}}if(resizeContainer){// clear resize info case application use cache\ndom.setStyles(resizeContainer,{'max-height':null,'max-width':null});// resize if needed\nresizeInfo&&dom.setStyles(resizeContainer,resizeInfo);}// position itself\ndom.setStyles(popup,{left:left+'px',top:top+'px'});}function setPositionAtPage(popupEl,options){const popup=utils.getContainerElement(popupEl);const height=popup.offsetHeight;const width=popup.offsetWidth;const w=window.innerWidth;const h=window.innerHeight;const{placement,resizeContainer,ignoreLimit}=options;const container=utils.getResizeContainer(popupEl,resizeContainer);container&&!ignoreLimit&&dom.setStyles(container,{'max-width':w*0.6,'max-height':h*0.8});const left=(w-width)/2;let top=(h-height)/2;if(placement==='top'){top=0;}dom.setStyles(popup,{left,top});}// positioning\nfunction updatePosition(popupRef){const options=popupRef.options;const popupEl=popupRef.panelEl;if(options.disableUpdate){return;}// case1: position at the mouse position\nif(options.targetEvent){setPositionAtMousePosition(popupEl,options.targetEvent);// case2: position relative to reference element\n}else if(options.reference&&options.relative){const reference=utils.getElement(options.reference);// referenceEl could be destroyed in detachMode. need to get it again.\n// if ( options.detachMode ) { reference = utils.getElement( utils.extendSelector( options.userOptions.reference ) ); }\nsetPosition(popupEl,reference,options);}else{// case3: position at the page center by default, or top center\nif(options.draggable){options.disableUpdate=true;}setPositionAtPage(popupEl,options);}popupRef.triggerHook('update');}function setPosition(popupEl,referenceEl,options){const containerEl=utils.getContainerElement(popupEl);if(!referenceEl||!containerEl){return;}if(!dom.inDOM(referenceEl)){close(popupEl);return;}if(options&&options.placement){const offset=positionService.calculateOffsets(referenceEl,containerEl,options);const{popup,arrow}=offset;const{top,bottom,left,right}=popup;dom.setStyles(containerEl,{top,bottom,left,right});if(options.hasArrow&&arrow){const arrowEl=utils.getArrowElement(containerEl);arrowEl&&dom.setStyles(arrowEl,arrow,true);}}}const adaptiveOptions=options=>{options=options||{};let result=options;// old fashion\nif(options.declView||options.options){result={...options.options,...options.locals,// apply first level and any overrides\n...options};// rename\nif(options.declView){result.view=options.declView;}// clear the garbage to avoid pollution\ndelete result.options;delete result.locals;delete result.declView;}return result;};/*\n * @alternative use popup action and popup view, ref: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/wikis/popup-design-and-interface\n *\n */function show(options){const globalPopup=appCtxService.getCtx('globalPopup');if(globalPopup){const finalOptions=adaptiveOptions(options);return globalPopup.show(finalOptions);}}/**\n * Schedules an update by popupEl or popupRef. It will run on the next UI update available.\n *\n * @param {Object} popupEl - the popupEl / popupRef to update.\n *\n * @returns {Promise} promise with the updated popupRef\n */function update(popupEl){const popupRef=manager.get(popupEl.id);popupRef&&popupRef.scheduleUpdate();return Promise.resolve(popupRef);}/*\n * @alternative use popup action and popup view, ref: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/wikis/popup-design-and-interface\n *\n */ // support hide as an alias for post compatibility\nconst hide=close;export{show,hide,close,update,consolidateOptions};const popupService={show,hide,close,update,consolidateOptions};export{popupService};export default popupService;","map":null,"metadata":{},"sourceType":"module"}