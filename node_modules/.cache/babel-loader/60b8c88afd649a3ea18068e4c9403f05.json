{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * Link below can we used for test complete accurate functionality:\n * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview\n *\n * For now all the use case in awParseService.test.js are guaranteed to work :)\n *\n * @module js/awParseService\n */\nimport { processExpression, expressionCanSplit, parseNative } from 'js/serviceUtils';\nimport { $ParseProvider } from 'js/angularjsParseService';\nconst $parse = new $ParseProvider().$get[1]();\n\nconst getRandomInt = max => Math.floor(Math.random() * Math.floor(max));\n/**\n * The API splits the expression and parse it.\n * @param {String} expression - The String expression to parse\n * @param {Array} names - The String Array of Parameters\n * @param {Array} vals - The Array of parameter values.\n * @returns {Object} parsed value\n */\n\n\nconst splitAndParse = (expression, names, vals) => {\n  if (!expressionCanSplit(expression)) {\n    return undefined;\n  }\n\n  const stack = processExpression(expression);\n  let finalExpresions = stack.map((element, index) => {\n    if (element.expr) {\n      try {\n        const response = parseNative(names, vals, null, element.expr);\n\n        if (response === undefined) {\n          //Check unary operator case\n          if (index < stack.length - 1 && stack[index + 1] === '+' || stack[index + 1] === '-') {\n            element.response = 0;\n          }\n\n          if (index > 0 && stack[index - 1] === '+' || stack[index - 1] === '-') {\n            element.response = 0;\n          }\n        } else {\n          element.response = response;\n        }\n      } catch (e) {\n        //Check unary operator case\n        if (index < stack.length - 1 && stack[index + 1] === '+' || stack[index + 1] === '-') {\n          element.response = 0;\n        } else if (index > 0 && stack[index - 1] === '+' || stack[index - 1] === '-') {\n          element.response = 0;\n        } else {\n          element.response = undefined;\n        }\n      }\n    }\n\n    return element;\n  });\n  let params = [];\n  let values = [];\n  const finalExprs = finalExpresions.map(element => {\n    if (element.expr) {\n      //TODO: generate random number\n      const varName = `param${getRandomInt(100000)}`;\n      params.push(varName);\n      values.push(element.response);\n      return varName;\n    }\n\n    return element;\n  });\n  const evalExpr = finalExprs.join('').trim();\n  return parseNative(params, values, null, evalExpr);\n};\n\nconst numberPropRe = /[a-zA-Z]\\.[0-9]/;\nexport default class AwParseService {\n  static instance(expression) {\n    if (!expression) {\n      return () => undefined;\n    }\n\n    const originalParseFunction = function (evaluationCtx) {\n      let names = Object.keys(evaluationCtx);\n      let vals = Object.values(evaluationCtx);\n\n      try {\n        const response = parseNative(names, vals, null, expression); // revisitme - what is this isNaN mean? for now limits it to number only\n\n        if (typeof response === 'number' && isNaN(response)) {\n          return splitAndParse(expression, names, vals);\n        }\n\n        return response;\n      } catch (e) {\n        //Split the expression and try to resolve\n        return splitAndParse(expression, names, vals);\n      }\n    }; //if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser\n    //Some cases of this have been added in 6.1\n\n\n    if (expression.match(numberPropRe)) {\n      return originalParseFunction;\n    }\n\n    try {\n      const fn = $parse(expression);\n      return function (evaluationCtx) {\n        return fn(evaluationCtx);\n      };\n    } catch (e) {\n      return originalParseFunction;\n    }\n  }\n\n}","map":{"version":3,"names":["processExpression","expressionCanSplit","parseNative","$ParseProvider","$parse","$get","getRandomInt","max","Math","floor","random","splitAndParse","expression","names","vals","undefined","stack","finalExpresions","map","element","index","expr","response","length","e","params","values","finalExprs","varName","push","evalExpr","join","trim","numberPropRe","AwParseService","instance","originalParseFunction","evaluationCtx","Object","keys","isNaN","match","fn"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/awParseService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * This module provides core angularJS services abstraction.\n * Link below can we used for test complete accurate functionality:\n * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview\n *\n * For now all the use case in awParseService.test.js are guaranteed to work :)\n *\n * @module js/awParseService\n */\n\nimport {\n    processExpression,\n    expressionCanSplit,\n    parseNative\n} from 'js/serviceUtils';\nimport { $ParseProvider } from 'js/angularjsParseService';\n\nconst $parse = new $ParseProvider().$get[1]();\nconst getRandomInt = max => Math.floor( Math.random() * Math.floor( max ) );\n\n/**\n * The API splits the expression and parse it.\n * @param {String} expression - The String expression to parse\n * @param {Array} names - The String Array of Parameters\n * @param {Array} vals - The Array of parameter values.\n * @returns {Object} parsed value\n */\nconst splitAndParse = ( expression, names, vals ) => {\n    if( !expressionCanSplit( expression ) ) {\n        return undefined;\n    }\n    const stack = processExpression( expression );\n    let finalExpresions = stack.map( ( element, index ) => {\n        if( element.expr ) {\n            try {\n                const response = parseNative( names, vals, null, element.expr );\n                if( response === undefined ) {\n                    //Check unary operator case\n                    if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {\n                        element.response = 0;\n                    }\n                    if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {\n                        element.response = 0;\n                    }\n                } else {\n                    element.response = response;\n                }\n            } catch ( e ) {\n                //Check unary operator case\n                if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {\n                    element.response = 0;\n                } else if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {\n                    element.response = 0;\n                } else {\n                    element.response = undefined;\n                }\n            }\n        }\n        return element;\n    } );\n    let params = [];\n    let values = [];\n    const finalExprs = finalExpresions.map( ( element ) => {\n        if( element.expr ) {\n            //TODO: generate random number\n            const varName = `param${getRandomInt( 100000 )}`;\n            params.push( varName );\n            values.push( element.response );\n            return varName;\n        }\n        return element;\n    } );\n    const evalExpr = finalExprs.join( '' ).trim();\n    return parseNative( params, values, null, evalExpr );\n};\n\nconst numberPropRe = /[a-zA-Z]\\.[0-9]/;\nexport default class AwParseService {\n    static instance( expression ) {\n        if( !expression ) {\n            return () => undefined;\n        }\n        const originalParseFunction = function( evaluationCtx ) {\n            let names = Object.keys( evaluationCtx );\n            let vals = Object.values( evaluationCtx );\n            try {\n                const response = parseNative( names, vals, null, expression );\n                // revisitme - what is this isNaN mean? for now limits it to number only\n                if( typeof response === 'number' && isNaN( response ) ) {\n                    return splitAndParse( expression, names, vals );\n                }\n                return response;\n            } catch ( e ) {\n                //Split the expression and try to resolve\n                return splitAndParse( expression, names, vals );\n            }\n        };\n        //if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser\n        //Some cases of this have been added in 6.1\n        if( expression.match( numberPropRe ) ) {\n            return originalParseFunction;\n        }\n        try {\n            const fn = $parse( expression );\n            return function( evaluationCtx ) {\n                return fn( evaluationCtx );\n            };\n        } catch ( e ) {\n            return originalParseFunction;\n        }\n    }\n}\n"],"mappings":"AAAA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SACIA,iBADJ,EAEIC,kBAFJ,EAGIC,WAHJ,QAIO,iBAJP;AAKA,SAASC,cAAT,QAA+B,0BAA/B;AAEA,MAAMC,MAAM,GAAG,IAAID,cAAJ,GAAqBE,IAArB,CAA0B,CAA1B,GAAf;;AACA,MAAMC,YAAY,GAAGC,GAAG,IAAIC,IAAI,CAACC,KAAL,CAAYD,IAAI,CAACE,MAAL,KAAgBF,IAAI,CAACC,KAAL,CAAYF,GAAZ,CAA5B,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,aAAa,GAAG,CAAEC,UAAF,EAAcC,KAAd,EAAqBC,IAArB,KAA+B;EACjD,IAAI,CAACb,kBAAkB,CAAEW,UAAF,CAAvB,EAAwC;IACpC,OAAOG,SAAP;EACH;;EACD,MAAMC,KAAK,GAAGhB,iBAAiB,CAAEY,UAAF,CAA/B;EACA,IAAIK,eAAe,GAAGD,KAAK,CAACE,GAAN,CAAW,CAAEC,OAAF,EAAWC,KAAX,KAAsB;IACnD,IAAID,OAAO,CAACE,IAAZ,EAAmB;MACf,IAAI;QACA,MAAMC,QAAQ,GAAGpB,WAAW,CAAEW,KAAF,EAASC,IAAT,EAAe,IAAf,EAAqBK,OAAO,CAACE,IAA7B,CAA5B;;QACA,IAAIC,QAAQ,KAAKP,SAAjB,EAA6B;UACzB;UACA,IAAIK,KAAK,GAAGJ,KAAK,CAACO,MAAN,GAAe,CAAvB,IAA4BP,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAAnD,IAA0DJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAArF,EAA2F;YACvFD,OAAO,CAACG,QAAR,GAAmB,CAAnB;UACH;;UACD,IAAIF,KAAK,GAAG,CAAR,IAAaJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAApC,IAA2CJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAAtE,EAA4E;YACxED,OAAO,CAACG,QAAR,GAAmB,CAAnB;UACH;QACJ,CARD,MAQO;UACHH,OAAO,CAACG,QAAR,GAAmBA,QAAnB;QACH;MACJ,CAbD,CAaE,OAAQE,CAAR,EAAY;QACV;QACA,IAAIJ,KAAK,GAAGJ,KAAK,CAACO,MAAN,GAAe,CAAvB,IAA4BP,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAAnD,IAA0DJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAArF,EAA2F;UACvFD,OAAO,CAACG,QAAR,GAAmB,CAAnB;QACH,CAFD,MAEO,IAAIF,KAAK,GAAG,CAAR,IAAaJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAApC,IAA2CJ,KAAK,CAAEI,KAAK,GAAG,CAAV,CAAL,KAAuB,GAAtE,EAA4E;UAC/ED,OAAO,CAACG,QAAR,GAAmB,CAAnB;QACH,CAFM,MAEA;UACHH,OAAO,CAACG,QAAR,GAAmBP,SAAnB;QACH;MACJ;IACJ;;IACD,OAAOI,OAAP;EACH,CA3BqB,CAAtB;EA4BA,IAAIM,MAAM,GAAG,EAAb;EACA,IAAIC,MAAM,GAAG,EAAb;EACA,MAAMC,UAAU,GAAGV,eAAe,CAACC,GAAhB,CAAuBC,OAAF,IAAe;IACnD,IAAIA,OAAO,CAACE,IAAZ,EAAmB;MACf;MACA,MAAMO,OAAO,GAAI,QAAOtB,YAAY,CAAE,MAAF,CAAW,EAA/C;MACAmB,MAAM,CAACI,IAAP,CAAaD,OAAb;MACAF,MAAM,CAACG,IAAP,CAAaV,OAAO,CAACG,QAArB;MACA,OAAOM,OAAP;IACH;;IACD,OAAOT,OAAP;EACH,CATkB,CAAnB;EAUA,MAAMW,QAAQ,GAAGH,UAAU,CAACI,IAAX,CAAiB,EAAjB,EAAsBC,IAAtB,EAAjB;EACA,OAAO9B,WAAW,CAAEuB,MAAF,EAAUC,MAAV,EAAkB,IAAlB,EAAwBI,QAAxB,CAAlB;AACH,CA/CD;;AAiDA,MAAMG,YAAY,GAAG,iBAArB;AACA,eAAe,MAAMC,cAAN,CAAqB;EACjB,OAARC,QAAQ,CAAEvB,UAAF,EAAe;IAC1B,IAAI,CAACA,UAAL,EAAkB;MACd,OAAO,MAAMG,SAAb;IACH;;IACD,MAAMqB,qBAAqB,GAAG,UAAUC,aAAV,EAA0B;MACpD,IAAIxB,KAAK,GAAGyB,MAAM,CAACC,IAAP,CAAaF,aAAb,CAAZ;MACA,IAAIvB,IAAI,GAAGwB,MAAM,CAACZ,MAAP,CAAeW,aAAf,CAAX;;MACA,IAAI;QACA,MAAMf,QAAQ,GAAGpB,WAAW,CAAEW,KAAF,EAASC,IAAT,EAAe,IAAf,EAAqBF,UAArB,CAA5B,CADA,CAEA;;QACA,IAAI,OAAOU,QAAP,KAAoB,QAApB,IAAgCkB,KAAK,CAAElB,QAAF,CAAzC,EAAwD;UACpD,OAAOX,aAAa,CAAEC,UAAF,EAAcC,KAAd,EAAqBC,IAArB,CAApB;QACH;;QACD,OAAOQ,QAAP;MACH,CAPD,CAOE,OAAQE,CAAR,EAAY;QACV;QACA,OAAOb,aAAa,CAAEC,UAAF,EAAcC,KAAd,EAAqBC,IAArB,CAApB;MACH;IACJ,CAdD,CAJ0B,CAmB1B;IACA;;;IACA,IAAIF,UAAU,CAAC6B,KAAX,CAAkBR,YAAlB,CAAJ,EAAuC;MACnC,OAAOG,qBAAP;IACH;;IACD,IAAI;MACA,MAAMM,EAAE,GAAGtC,MAAM,CAAEQ,UAAF,CAAjB;MACA,OAAO,UAAUyB,aAAV,EAA0B;QAC7B,OAAOK,EAAE,CAAEL,aAAF,CAAT;MACH,CAFD;IAGH,CALD,CAKE,OAAQb,CAAR,EAAY;MACV,OAAOY,qBAAP;IACH;EACJ;;AAjC+B"},"metadata":{},"sourceType":"module"}