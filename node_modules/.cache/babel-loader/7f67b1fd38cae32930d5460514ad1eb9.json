{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * @module js/editHandlerService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport eventBus from 'js/eventBus';\nvar exports = {}; // Map the context to the edit handler info\n\nvar m_context2EditHandlerInfo = {};\n/** The last edit handler context activated */\n\nvar m_activeEditHandlerContext = {};\n/**\n * Set the current edit handler\n *\n * @param {Object} handler - current edit handler\n * @param {Object} editHandlerContext - context\n */\n\nexport let setEditHandler = function (handler, editHandlerContext) {\n  if (!handler || !editHandlerContext) {\n    return;\n  }\n\n  var info = m_context2EditHandlerInfo[editHandlerContext];\n  appCtxSvc.ctx[editHandlerContext] = handler;\n\n  if (!info || handler !== info.editHandler) {\n    if (!info) {\n      info = {};\n    }\n\n    info.editHandler = handler;\n    info.enable = true;\n    m_context2EditHandlerInfo[editHandlerContext] = info;\n\n    if (handler.hasOwnProperty('hasWrapper')) {\n      handler.addListener(this);\n    }\n\n    eventBus.publish('aw.setEditHandler', {});\n  }\n};\n/**\n * Get the default edit handler\n *\n * @param {String} editHandlerContext - edit handler context\n * @return the default edit handler\n */\n\nexport let getEditHandler = function (editHandlerContext) {\n  var info = m_context2EditHandlerInfo[editHandlerContext];\n\n  if (!info) {\n    return null;\n  }\n\n  return info.editHandler;\n};\n/**\n * Set the edit handler enabled/disabled\n *\n * @param enabled is enabled?\n * @param editHandlerContext is enabled?\n * @returns true if enabled changed, false otherwise\n */\n\nexport let setEditHandlerEnabled = function (enabled, editHandlerContext) {\n  var info = m_context2EditHandlerInfo[editHandlerContext];\n\n  if (info && info.enable !== enabled) {\n    info.enable = enabled;\n    m_context2EditHandlerInfo[editHandlerContext] = info;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Get the current state of the edit handler, enabled/disabled\n *\n * @return True if edit is enabled, False otherwise\n */\n\nexport let isEditEnabled = function (editHandlerContext) {\n  var info = m_context2EditHandlerInfo[editHandlerContext];\n\n  if (!info) {\n    return false;\n  }\n\n  return info.enable;\n};\n/**\n * Remove an edit handler\n *\n * @param editHandlerContext context associated with the edit handler\n */\n\nexport let removeEditHandler = function (editHandlerContext) {\n  appCtxSvc.unRegisterCtx(editHandlerContext);\n  var info = m_context2EditHandlerInfo[editHandlerContext];\n\n  if (info && info.editHandler && info.editHandler.destroy) {\n    info.editHandler.destroy();\n  }\n\n  delete m_context2EditHandlerInfo[editHandlerContext];\n};\n/**\n * Get all of the current edit handlers\n *\n * @return All of the current edit handlers\n */\n\nexport let getAllEditHandlers = function () {\n  var editHandlers = [];\n\n  for (var i in m_context2EditHandlerInfo) {\n    var info = m_context2EditHandlerInfo[i];\n\n    if (info && info.editHandler !== null) {\n      editHandlers.push(info.editHandler);\n    }\n  }\n\n  return editHandlers;\n};\nexport let setActiveEditHandlerContext = function (context) {\n  m_activeEditHandlerContext = context;\n};\nexport let getActiveEditHandler = function () {\n  if (m_context2EditHandlerInfo[m_activeEditHandlerContext] && m_context2EditHandlerInfo[m_activeEditHandlerContext].editHandler) {\n    return m_context2EditHandlerInfo[m_activeEditHandlerContext].editHandler;\n  }\n\n  return null;\n};\nexport let getActiveEditHandlerContext = function () {\n  return m_activeEditHandlerContext;\n};\n/**\n * Check for dirty edits\n *\n * @return {Object} with a boolean flag isDirty, TRUE if there is an activeEditHandler and dirty edits for it\n */\n\nexport let isDirty = function () {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler && activeEditHandler.isNative) {\n    return activeEditHandler.isDirty().then(function (isDirty) {\n      return {\n        isDirty: isDirty\n      };\n    });\n  } else if (activeEditHandler) {\n    return AwPromiseService.instance.when({\n      isDirty: activeEditHandler.isDirty()\n    });\n  }\n\n  return AwPromiseService.instance.when({\n    isDirty: false\n  });\n};\n/**\n * Check for edit in progress\n *\n * @return {Object} with a boolean flag editInProgress, TRUE if there is an activeEditHandler and edit in progress\n */\n\nexport let editInProgress = function () {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler) {\n    return {\n      editInProgress: activeEditHandler.editInProgress()\n    };\n  }\n\n  return {\n    editInProgress: false\n  };\n};\n/**\n * Start edits\n *\n * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n * @return {Promise} A promise object\n */\n\nexport let startEdit = function (editOptions) {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler) {\n    return activeEditHandler.startEdit(editOptions);\n  }\n\n  return AwPromiseService.instance.reject('No active EditHandler');\n};\n/**\n * Save edits\n *\n * @param {String} context - parameter for getting commandHandler (Optional)\n * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n * @return {Promise} A promise object\n */\n\nexport let saveEdits = function (context, isPartialSaveDisabled, isAutoSave) {\n  var activeEditHandler;\n\n  if (context) {\n    activeEditHandler = exports.getEditHandler(context);\n  } else {\n    activeEditHandler = exports.getActiveEditHandler();\n  }\n\n  if (activeEditHandler) {\n    return activeEditHandler.saveEdits(isPartialSaveDisabled, isAutoSave);\n  }\n\n  return AwPromiseService.instance.reject('No active EditHandler');\n};\n/**\n * Perform the actions post Save Edit\n *\n * @param {Boolean} saveSuccess - Whether the save edit was successful or not\n */\n\nexport let saveEditsPostActions = function (saveSuccess) {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler) {\n    activeEditHandler.saveEditsPostActions(saveSuccess);\n  }\n};\n/**\n * Cancel edits\n */\n\nexport let cancelEdits = function () {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler) {\n    activeEditHandler.cancelEdits();\n  }\n};\n/**\n * Leave confirmation. Returns a promise that is resolved when it is ok to leave.\n */\n\nexport let leaveConfirmation = function () {\n  var activeEditHandler = exports.getActiveEditHandler();\n\n  if (activeEditHandler) {\n    return AwPromiseService.instance(function (resolve) {\n      activeEditHandler.leaveConfirmation(resolve);\n    });\n  }\n\n  return AwPromiseService.instance.resolve();\n};\n/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */\n\nexport let updateStates = function (editHandler, context) {\n  if (m_context2EditHandlerInfo && m_context2EditHandlerInfo[context]) {\n    var info = m_context2EditHandlerInfo[context];\n\n    if (info && info.editHandler) {\n      info.editHandler.canEdit = info.editHandler.canStartEdit();\n      editHandler.canEdit = info.editHandler.canStartEdit();\n    }\n  }\n};\n/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */\n\nexport let updateStates2 = function (viewModel) {\n  if (m_context2EditHandlerInfo) {\n    for (var i in m_context2EditHandlerInfo) {\n      var info = m_context2EditHandlerInfo[i];\n\n      if (info && info.editHandler) {\n        const dataSource = info.editHandler.getDataSource();\n        const dataProvider = dataSource.getDataProvider();\n        const declViewModel = dataSource.getDeclViewModel();\n        let isEditHandlerOfViewModel = false;\n\n        if (dataProvider) {\n          for (const dataProviderName in viewModel.dataProviders) {\n            if (dataProvider === viewModel.dataProviders[dataProviderName]) {\n              isEditHandlerOfViewModel = true;\n              break;\n            }\n          }\n        } else if (declViewModel === viewModel) {\n          isEditHandlerOfViewModel = true;\n        }\n\n        if (isEditHandlerOfViewModel) {\n          info.editHandler.canEdit = info.editHandler.canStartEdit();\n        }\n      }\n    }\n  }\n};\nexports = {\n  setEditHandler,\n  getEditHandler,\n  setEditHandlerEnabled,\n  isEditEnabled,\n  removeEditHandler,\n  getAllEditHandlers,\n  setActiveEditHandlerContext,\n  getActiveEditHandler,\n  getActiveEditHandlerContext,\n  isDirty,\n  editInProgress,\n  startEdit,\n  saveEdits,\n  saveEditsPostActions,\n  cancelEdits,\n  leaveConfirmation,\n  updateStates,\n  updateStates2\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","appCtxSvc","eventBus","exports","m_context2EditHandlerInfo","m_activeEditHandlerContext","setEditHandler","handler","editHandlerContext","info","ctx","editHandler","enable","hasOwnProperty","addListener","publish","getEditHandler","setEditHandlerEnabled","enabled","isEditEnabled","removeEditHandler","unRegisterCtx","destroy","getAllEditHandlers","editHandlers","i","push","setActiveEditHandlerContext","context","getActiveEditHandler","getActiveEditHandlerContext","isDirty","activeEditHandler","isNative","then","instance","when","editInProgress","startEdit","editOptions","reject","saveEdits","isPartialSaveDisabled","isAutoSave","saveEditsPostActions","saveSuccess","cancelEdits","leaveConfirmation","resolve","updateStates","canEdit","canStartEdit","updateStates2","viewModel","dataSource","getDataSource","dataProvider","getDataProvider","declViewModel","getDeclViewModel","isEditHandlerOfViewModel","dataProviderName","dataProviders"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/editHandlerService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * @module js/editHandlerService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport eventBus from 'js/eventBus';\n\nvar exports = {};\n\n// Map the context to the edit handler info\nvar m_context2EditHandlerInfo = {};\n\n/** The last edit handler context activated */\nvar m_activeEditHandlerContext = {};\n\n/**\n * Set the current edit handler\n *\n * @param {Object} handler - current edit handler\n * @param {Object} editHandlerContext - context\n */\nexport let setEditHandler = function( handler, editHandlerContext ) {\n    if( !handler || !editHandlerContext ) {\n        return;\n    }\n    var info = m_context2EditHandlerInfo[ editHandlerContext ];\n    appCtxSvc.ctx[ editHandlerContext ] = handler;\n    if( !info || handler !== info.editHandler ) {\n        if( !info ) {\n            info = {};\n        }\n        info.editHandler = handler;\n        info.enable = true;\n        m_context2EditHandlerInfo[ editHandlerContext ] = info;\n        if( handler.hasOwnProperty( 'hasWrapper' ) ) {\n            handler.addListener( this );\n        }\n        eventBus.publish( 'aw.setEditHandler', {} );\n    }\n};\n\n/**\n * Get the default edit handler\n *\n * @param {String} editHandlerContext - edit handler context\n * @return the default edit handler\n */\nexport let getEditHandler = function( editHandlerContext ) {\n    var info = m_context2EditHandlerInfo[ editHandlerContext ];\n    if( !info ) {\n        return null;\n    }\n\n    return info.editHandler;\n};\n\n/**\n * Set the edit handler enabled/disabled\n *\n * @param enabled is enabled?\n * @param editHandlerContext is enabled?\n * @returns true if enabled changed, false otherwise\n */\nexport let setEditHandlerEnabled = function( enabled, editHandlerContext ) {\n    var info = m_context2EditHandlerInfo[ editHandlerContext ];\n    if( info && info.enable !== enabled ) {\n        info.enable = enabled;\n        m_context2EditHandlerInfo[ editHandlerContext ] = info;\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Get the current state of the edit handler, enabled/disabled\n *\n * @return True if edit is enabled, False otherwise\n */\nexport let isEditEnabled = function( editHandlerContext ) {\n    var info = m_context2EditHandlerInfo[ editHandlerContext ];\n    if( !info ) {\n        return false;\n    }\n    return info.enable;\n};\n\n/**\n * Remove an edit handler\n *\n * @param editHandlerContext context associated with the edit handler\n */\nexport let removeEditHandler = function( editHandlerContext ) {\n    appCtxSvc.unRegisterCtx( editHandlerContext );\n    var info = m_context2EditHandlerInfo[ editHandlerContext ];\n    if( info && info.editHandler && info.editHandler.destroy ) {\n        info.editHandler.destroy();\n    }\n    delete m_context2EditHandlerInfo[ editHandlerContext ];\n};\n\n/**\n * Get all of the current edit handlers\n *\n * @return All of the current edit handlers\n */\nexport let getAllEditHandlers = function() {\n    var editHandlers = [];\n    for( var i in m_context2EditHandlerInfo ) {\n        var info = m_context2EditHandlerInfo[ i ];\n        if( info && info.editHandler !== null ) {\n            editHandlers.push( info.editHandler );\n        }\n    }\n    return editHandlers;\n};\n\nexport let setActiveEditHandlerContext = function( context ) {\n    m_activeEditHandlerContext = context;\n};\n\nexport let getActiveEditHandler = function() {\n    if( m_context2EditHandlerInfo[ m_activeEditHandlerContext ] &&\n        m_context2EditHandlerInfo[ m_activeEditHandlerContext ].editHandler ) {\n        return m_context2EditHandlerInfo[ m_activeEditHandlerContext ].editHandler;\n    }\n    return null;\n};\n\nexport let getActiveEditHandlerContext = function() {\n    return m_activeEditHandlerContext;\n};\n\n/**\n * Check for dirty edits\n *\n * @return {Object} with a boolean flag isDirty, TRUE if there is an activeEditHandler and dirty edits for it\n */\nexport let isDirty = function() {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler && activeEditHandler.isNative ) {\n        return activeEditHandler.isDirty().then( function( isDirty ) {\n            return {\n                isDirty: isDirty\n            };\n        } );\n    } else if( activeEditHandler ) {\n        return AwPromiseService.instance.when( {\n            isDirty: activeEditHandler.isDirty()\n        } );\n    }\n    return AwPromiseService.instance.when( {\n        isDirty: false\n    } );\n};\n\n/**\n * Check for edit in progress\n *\n * @return {Object} with a boolean flag editInProgress, TRUE if there is an activeEditHandler and edit in progress\n */\nexport let editInProgress = function() {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler ) {\n        return {\n            editInProgress: activeEditHandler.editInProgress()\n        };\n    }\n    return {\n        editInProgress: false\n    };\n};\n\n/**\n * Start edits\n *\n * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyName, autoSave } (Optional)\n * @return {Promise} A promise object\n */\nexport let startEdit = function( editOptions ) {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler ) {\n        return activeEditHandler.startEdit( editOptions );\n    }\n    return AwPromiseService.instance.reject( 'No active EditHandler' );\n};\n\n/**\n * Save edits\n *\n * @param {String} context - parameter for getting commandHandler (Optional)\n * @param {Boolean} isPartialSaveDisabled - flag to determine if partial save is disabled (Optional)\n * @param {Boolean} isAutoSave - flag to determine if this is an auto save (Optional)\n * @return {Promise} A promise object\n */\nexport let saveEdits = function( context, isPartialSaveDisabled, isAutoSave  ) {\n    var activeEditHandler;\n    if( context ) {\n        activeEditHandler = exports.getEditHandler( context );\n    } else {\n        activeEditHandler = exports.getActiveEditHandler();\n    }\n    if( activeEditHandler ) {\n        return activeEditHandler.saveEdits( isPartialSaveDisabled, isAutoSave );\n    }\n\n    return AwPromiseService.instance.reject( 'No active EditHandler' );\n};\n\n/**\n * Perform the actions post Save Edit\n *\n * @param {Boolean} saveSuccess - Whether the save edit was successful or not\n */\nexport let saveEditsPostActions = function( saveSuccess ) {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler ) {\n        activeEditHandler.saveEditsPostActions( saveSuccess );\n    }\n};\n\n/**\n * Cancel edits\n */\nexport let cancelEdits = function() {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler ) {\n        activeEditHandler.cancelEdits();\n    }\n};\n\n/**\n * Leave confirmation. Returns a promise that is resolved when it is ok to leave.\n */\nexport let leaveConfirmation = function() {\n    var activeEditHandler = exports.getActiveEditHandler();\n    if( activeEditHandler ) {\n        return AwPromiseService.instance( function( resolve ) {\n            activeEditHandler.leaveConfirmation( resolve );\n        } );\n    }\n\n    return AwPromiseService.instance.resolve();\n};\n\n/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */\nexport let updateStates = function( editHandler, context ) {\n    if ( m_context2EditHandlerInfo && m_context2EditHandlerInfo[ context ] ) {\n        var info = m_context2EditHandlerInfo[ context ];\n        if ( info && info.editHandler ) {\n            info.editHandler.canEdit = info.editHandler.canStartEdit();\n            editHandler.canEdit = info.editHandler.canStartEdit();\n        }\n    }\n};\n\n/**\n * Update states\n * @param {Object} viewModel - viewModel the editHandler is associated with\n */\nexport let updateStates2 = function( viewModel ) {\n    if ( m_context2EditHandlerInfo ) {\n        for ( var i in m_context2EditHandlerInfo ) {\n            var info = m_context2EditHandlerInfo[i];\n            if ( info && info.editHandler ) {\n                const dataSource = info.editHandler.getDataSource();\n                const dataProvider = dataSource.getDataProvider();\n                const declViewModel = dataSource.getDeclViewModel();\n\n                let isEditHandlerOfViewModel = false;\n                if ( dataProvider ) {\n                    for( const dataProviderName in viewModel.dataProviders ) {\n                        if ( dataProvider === viewModel.dataProviders[ dataProviderName ] ) {\n                            isEditHandlerOfViewModel = true;\n                            break;\n                        }\n                    }\n                } else if ( declViewModel === viewModel ) {\n                    isEditHandlerOfViewModel = true;\n                }\n\n                if( isEditHandlerOfViewModel ) {\n                    info.editHandler.canEdit = info.editHandler.canStartEdit();\n                }\n            }\n        }\n    }\n};\n\nexports = {\n    setEditHandler,\n    getEditHandler,\n    setEditHandlerEnabled,\n    isEditEnabled,\n    removeEditHandler,\n    getAllEditHandlers,\n    setActiveEditHandlerContext,\n    getActiveEditHandler,\n    getActiveEditHandlerContext,\n    isDirty,\n    editInProgress,\n    startEdit,\n    saveEdits,\n    saveEditsPostActions,\n    cancelEdits,\n    leaveConfirmation,\n    updateStates,\n    updateStates2\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}