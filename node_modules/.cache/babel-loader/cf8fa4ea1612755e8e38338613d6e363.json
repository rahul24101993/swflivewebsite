{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/propertyPolicyService\n */import AwHttpService from'js/awHttpService';import AwPromiseService from'js/awPromiseService';import dateTimeSvc from'js/dateTimeService';import cmm from'soa/kernel/clientMetaModel';import _ from'lodash';import eventBus from'js/eventBus';import logger from'js/logger';import awConfiguration from'js/awConfiguration';import moduleLoader from'js/moduleLoader';/**\n * Angular services\n */var exports={};/**\n * Map of policy id to registered policy.\n *\n * @private\n */export let _policyId2policy={};/**\n * Registration of time stamp for property policies.\n *\n * @private\n */export let _policyId2registrationTimeStamp={};/**\n * Registration counter for property policies.\n *\n * @private\n */export let _policyCount=0;/**\n * Effective property policy for subsequent server calls.\n *\n * @private\n */export let _effectivePolicy={};/**\n * Cache of last SOA service used by getEffectivePolicy()\n *\n * @private\n */export let _soaSvc=null;/**\n * Parent selections.\n *\n * @private\n */export let _parentSelections=[];/**\n * Current selections.\n *\n * @private\n */export let _currentSelections=[];/**\n * List of selected policy Id's.\n *\n * @private\n */export let _selectedPolicyIds=[];/**\n * List of generic policy Id's.\n *\n * @private\n */export let _genericPolicyIds=[];/**\n * boolean to indicate whether the last effective policy was build from selected property policy or not.\n *\n * @private\n */export let _selectedPropertyUsed=false;// /**\n//  * Sort input array by name field of elements.\n//  *\n//  * @param array array to sort\n//  * @private\n//  */\n// function sort( array ) {\n//     if( array ) {\n//         array.sort( function( a, b ) {\n//             return a.name.localeCompare( b.name );\n//         } );\n//     }\n// }\n/**\n * @param {String} typeName - type name\n * @param {String} propName - property name\n * @return {String} defining type name (whether on this type or one of it's parents)\n */function getParentType(typeName,propName){var modelType=cmm.getType(typeName);if(modelType&&modelType.propertyDescriptorsMap.hasOwnProperty(propName)){var parentModelType=cmm.getType(modelType.parentTypeName);if(parentModelType&&parentModelType.propertyDescriptorsMap.hasOwnProperty(propName)){return getParentType(parentModelType.name,propName);}return modelType.name;}return null;}/**\n * Merge modifier into modifier array.\n *\n * @param {Array} modifiers - array of modifiers\n * @param {Object} modifierToMerge - modifier to merge into array\n * @private\n */function mergeModifier(modifiers,modifierToMerge){var modifier=_.find(modifiers,_.matchesProperty('name',modifierToMerge.name));if(!modifier){modifier={name:modifierToMerge.name,Value:modifierToMerge.Value};modifiers.push(modifier);}else if(modifier.Value!==modifierToMerge.Value){logger.error('Modifier conflict!');}}/**\n * Merge property into property array.\n *\n * @param {Array} properties - array of properties\n * @param {Object} propertyToMerge - property to merge into array\n * @private\n */function mergeProperty(properties,propertyToMerge){var property=_.find(properties,_.matchesProperty('name',propertyToMerge.name));if(!property){property={name:propertyToMerge.name};properties.push(property);}if(propertyToMerge.modifiers&&propertyToMerge.modifiers.length>0){if(!property.modifiers){property.modifiers=[];}_.forEach(propertyToMerge.modifiers,function(modifier){mergeModifier(property.modifiers,modifier);});}}/**\n * Merge type into type array.\n *\n * @param {Array} types - array of types\n * @param {Object} typeToMerge - type to merge into array\n * @private\n */function mergeType(types,typeToMerge){var type=_.find(types,_.matchesProperty('name',typeToMerge.name));if(!type){type={name:typeToMerge.name};types.push(type);}if(typeToMerge.properties&&typeToMerge.properties.length>0){if(!type.properties){type.properties=[];}_.forEach(typeToMerge.properties,function(property){mergeProperty(type.properties,property);});}if(typeToMerge.modifiers&&typeToMerge.modifiers.length>0){if(!type.modifiers){type.modifiers=[];}_.forEach(typeToMerge.modifiers,function(modifier){mergeModifier(type.modifiers,modifier);});}}/**\n * Effective property policy for use by Teamcenter SOA server call header.\n *\n * @param {Object} soaSvc - SOA service to avoid cyclic reference\n * @param {boolean} isSelectedProperty - flag indicating the policy type to use.\n * @return {Object} effective property policy\n */export let getEffectivePolicy=function(soaSvc,isSelectedProperty){if(soaSvc){exports._soaSvc=soaSvc;}var policyIdsForEffectPolicy=exports._genericPolicyIds;if(isSelectedProperty){policyIdsForEffectPolicy=exports._selectedPolicyIds;}// we need to check which policy type (selected or generic ) was used to build the effective property policy\nif(!exports._effectivePolicy||isSelectedProperty!==exports._selectedPropertyUsed){var effectivePolicy={useRefCount:false// do we need to set this? ie does the server default to zero anyway?\n};exports._selectedPropertyUsed=isSelectedProperty;_.forEach(policyIdsForEffectPolicy,function(policyId){var policy=exports._policyId2policy[policyId];if(policy.types){if(!effectivePolicy.types){effectivePolicy.types=[];}_.forEach(policy.types,function(type){mergeType(effectivePolicy.types,type);});}if(policy.modifiers&&policy.modifiers.length>0){if(!effectivePolicy.modifiers){effectivePolicy.modifiers=[];}_.forEach(policy.modifiers,function(modifier){mergeModifier(effectivePolicy.modifiers,modifier);});}});//            // Sort the effective policy for debug purposes\n//            sort( effectivePolicy.types );\n//            if( effectivePolicy.types ) {\n//                _.forEach( effectivePolicy.types, function( type ) {\n//                    sort( type.modifiers );\n//                    if( type.properties ) {\n//                        sort( type.properties );\n//                        _.forEach( type.properties, function( property ) {\n//                            sort( property.modifiers );\n//                        } );\n//                    }\n//                } );\n//            }\n//            sort( effectivePolicy.modifiers );\nexports._effectivePolicy=effectivePolicy;}return exports._effectivePolicy;};/**\n * Returns true if at least one selected object is present in the input body.\n *\n * @param {Object} body - input body\n * @param {StringArray} modelObjectUidList - model object uid's\n * @return {Boolean} true if at least one selected object is present in the input body.\n */export let checkForSelectedObject=function(body,modelObjectUidList){var isFound=false;var modelObjectUids=modelObjectUidList;if(!modelObjectUidList){modelObjectUids=[];extractModelObjects(body,modelObjectUids);}if(modelObjectUids.length>0){var totalSelectedModelObject=getSelectedModelObjects();for(var i=0;i<totalSelectedModelObject.length;i++){if(modelObjectUids.indexOf(totalSelectedModelObject[i])>-1){isFound=true;break;}}}return isFound;};/**\n * Returns a list of all the selected model objects. This list includes the parent and the child selections.\n *\n * @private\n * @return {IModelObjectArray} An array of total selected model objects uid's list.\n */function getSelectedModelObjects(){var selectedModelObjects=[];// add current selected objects to the selected objects list .\nfor(var i=0;i<exports._currentSelections.length;i++){if(selectedModelObjects.indexOf(exports._currentSelections[i])===-1){selectedModelObjects.push(exports._currentSelections[i]);}}// add parent selected objects to the selected objects list .\nfor(var ii=0;ii<exports._parentSelections.length;ii++){if(selectedModelObjects.indexOf(exports._parentSelections[ii])===-1){selectedModelObjects.push(exports._parentSelections[ii]);}}return selectedModelObjects;}/**\n * Extracts model object uid's from the body\n *\n * @private\n * @param {Object} body - input body\n * @param {StringArray} uids - Array of {ModelObject} uid's found in body\n */function extractModelObjects(body,uids){_.forEach(body,function(child){if(_.isPlainObject(child)){if(child.hasOwnProperty('uid')&&child.hasOwnProperty('type')){if(child.uid&&child.uid!=='AAAAAAAAAAAAAA'){uids.push(child.uid);}}else{extractModelObjects(child,uids);}}else if(_.isArray(child)){extractModelObjects(child,uids);}});}/**\n * Set's the selected model objects.\n *\n * @param {StringArray} selectedObectuids selected object uid's\n */export let setSelectedObjects=function(selectedObectuids){if(selectedObectuids){exports._currentSelections=selectedObectuids;}else{exports._currentSelections=[];}};/**\n * Add's the selected model object to parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */export let addToParentSelection=function(selectedObectuid){if(!exports._parentSelections){exports._parentSelections=[];}else{exports._parentSelections.push(selectedObectuid);}};/**\n * removes the model object from parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */export let removeFromParentSelection=function(selectedObectuid){// Remove the selected object\nif(exports._parentSelections.lastIndexOf(selectedObectuid)>-1){exports._parentSelections.splice(exports._parentSelections.lastIndexOf(selectedObectuid),1);}};/**\n * Register property policy.\n *\n * @param {Object} policy - property policy\n * @param {String} policyString - property policy string\n * @param {String} policyType - property type\n * @return {String} property policy ID\n */export let register=function(policy,policyString,policyType){var policyFinal=policy;var timeS=Date.now();if(!policyFinal){policyFinal=JSON.parse(policyString);}var nextId=++exports._policyCount;// Create policy id\nvar policyId='policy'+nextId;// Cache policy\nexports._policyId2policy[policyId]=policyFinal;// depending upon the policy type add the policy to generic list\nif(!policyType){exports._genericPolicyIds.push(policyId);}exports._selectedPolicyIds.push(policyId);// Clear cache of effective policy\nexports._effectivePolicy=null;var currentTime=dateTimeSvc.formatTime(timeS);if(logger.isTraceEnabled()){logger.trace('Register Property Policy Id: '+policyId+' TimeStamp: '+currentTime+' Policy data:',policyFinal);}if(policyString){exports._policyId2registrationTimeStamp[policyId]={time:currentTime,policy:policyFinal};}// Return new cached policy id\nreturn policyId;};/**\n * Register property policy.\n *\n * @param {String} policyId - cached property policy ID\n */export let unregister=function(policyId){// Remove the policy id from selected property policy id list\nif(exports._selectedPolicyIds.indexOf(policyId)>-1){exports._selectedPolicyIds.splice(exports._selectedPolicyIds.indexOf(policyId),1);}// Remove the policy id from generic property policy id list\nif(exports._genericPolicyIds.indexOf(policyId)>-1){exports._genericPolicyIds.splice(exports._genericPolicyIds.indexOf(policyId),1);}if(exports._policyId2policy.hasOwnProperty(policyId)){delete exports._policyId2policy[policyId];if(logger.isTraceEnabled()){logger.trace('Unregister Property Policy Id: '+policyId+' TimeStamp: '+dateTimeSvc.formatTime(Date.now()));}delete exports._policyId2registrationTimeStamp[policyId];// Clear cache of effective policy\nexports._effectivePolicy=null;}};/**\n * @param {Object} policy - property policy to validate\n * @param {number} callCount - call count to avoid infinite loop if a type name is invalid & can't be loaded\n */function validatePolicy(policy,callCount){if(policy.types){if(callCount<5&&exports._soaSvc){var typeNames=[];_.forEach(policy.types,function(type){var modelType=cmm.getType(type.name);if(!modelType){typeNames.push(type.name);}else{_.forEach(modelType.typeHierarchyArray,function(name2){if(!cmm.containsType(name2)){typeNames.push(name2);}});}});const sortedTypeNames=typeNames.sort();typeNames=_.uniq(sortedTypeNames,true);if(typeNames){var promise=exports._soaSvc.ensureModelTypesLoaded(typeNames);if(promise){promise.then(function(){return validatePolicy(policy,++callCount);});return;}}}var output=[];_.forEach(policy.types,function(type){var modelType=cmm.getType(type.name);if(modelType){if(type.properties){var parentModelType=cmm.getType(modelType.parentTypeName);_.forEach(type.properties,function(property){if(property){if(!modelType.propertyDescriptorsMap.hasOwnProperty(property.name)){output.push('Invalid property ['+property.name+'] on type ['+type.name+']');}else if(parentModelType&&parentModelType.propertyDescriptorsMap.hasOwnProperty(property.name)){output.push('Wrong type for property ['+property.name+'] on type ['+type.name+'], should be on type ['+getParentType(parentModelType.name,property.name)+']');}else{output.push('Effective property ['+property.name+'] on type ['+type.name+']');}}else{output.push('Empty property on type ['+type.name+']');}});}}else{output.push('Invalid type ['+type.name+']');}if(!type.properties&&!type.modifiers){output.push('Missing properties for type ['+type.name+']');}});if(output.length>0){output.sort();logger.info(output.join('\\n'));}}}/**\n * @param {Array} modelObjects array of model objects\n * @param {Array} propNames array of property names\n */export let validatePropertyRegistration=function(modelObjects,propNames){var policy=exports.getEffectivePolicy();var msg='';_.forEach(modelObjects,function(modelObject){if(modelObject){var modelType=modelObject.modelType;_.forEach(propNames,function(propName){if(modelType.propertyDescriptorsMap.hasOwnProperty(propName)&&policy.types){var found=false;for(var kk=0;kk<policy.types.length&&!found;kk++){var type=policy.types[kk];if(type.properties&&modelType.typeHierarchyArray.indexOf(type.name)>-1){for(var ll=0;ll<type.properties.length&&!found;ll++){var property=type.properties[ll];if(property.name===propName){found=true;}}}}if(!found){msg+='\\n\\tType ['+modelType.displayName+'] PropertyName ['+propName+']';}}});}});if(msg){logger.debug('Property Policy registration is missing for the following:'+msg);}};/**\n * Register a policy which may need to be loaded from a separate json file.\n *\n * @param {Object|String} propertyPolicy - A property policy object or a path to the file containing the policy\n *\n * @return {Promise} A promise that will be resolved with the new policy id\n */export let registerPolicyAsync=function(propertyPolicy){// If it's a string it's a path to a policy file that needs to be loaded\nif(typeof propertyPolicy==='string'){if(propertyPolicy.startsWith('/')){propertyPolicy=propertyPolicy.slice(1);}return moduleLoader.loadDependentModule(propertyPolicy).then(result=>{return exports.register(result);});}// Otherwise it must be the actual policy object\nreturn AwPromiseService.instance.when(exports.register(propertyPolicy));};exports={_policyId2policy,_policyId2registrationTimeStamp,_policyCount,_effectivePolicy,_soaSvc,_parentSelections,_currentSelections,_selectedPolicyIds,_genericPolicyIds,_selectedPropertyUsed,getEffectivePolicy,checkForSelectedObject,setSelectedObjects,addToParentSelection,removeFromParentSelection,register,unregister,validatePropertyRegistration,registerPolicyAsync};export default exports;/**\n * Catch the event for logging all registered policies in the current session and logging the effective policy\n * in the session\n */eventBus.subscribe('cdm.logDiagnostics',function(){var policy=exports.getEffectivePolicy();logger.info('Property Policy Audit Console Logging :');_.forEach(exports._policyId2registrationTimeStamp,function(times,policyId){logger.debug('Registered Property Policy Id \"'+policyId+'\" @ '+times.time+':',times.policy);});logger.debug('Effective Property Policy in session:',policy);validatePolicy(policy,1);},'soa_kernel_propertyPolicyService');","map":null,"metadata":{},"sourceType":"module"}