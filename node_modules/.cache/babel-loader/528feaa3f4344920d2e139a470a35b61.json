{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.async} which provides a set of utilities for handling async methods\n *\n * @module js/async.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwTimeoutService from 'js/awTimeoutService';\nimport Debug from 'debug';\nvar trace = new Debug('async');\n/* eslint-disable-next-line valid-jsdoc*/\n\nlet exports = {};\n/**\n * Get an api capable of executing the given api async\n *\n * @param {Function<List<a>>} methodToExecute Method to call. Input will be a list of a where a is the input to the debounced method\n * @param {Number} debounceTime How long to debounce method calls\n * @param {Lock} lock A \"lock\" with a \"isUnlocked\" function. Allows external control of call on top of debounce\n * @returns {Function<a>} A debounced version of the method that supports individual calls\n */\n\nvar debouncePromise = function (methodToExecute, debounceTime, lock) {\n  /**\n   * Promise tracking any currently active batch.\n   *\n   * Resolved once the method is actually executed.\n   */\n  var deferred = null;\n  /**\n   * The current active timer. If allowed to complete the method will be executed.\n   */\n\n  var debounceTimer = null;\n  /**\n   * Items to pass to the network\n   */\n\n  var items = [];\n  /**\n   * Flag tracking if the service was previously locked\n   */\n\n  var wasLocked = false;\n  /**\n   * Actually execute the action\n   *\n   * @returns {Promise} Promise resolved after execution\n   */\n\n  var doAction = function () {\n    // Clear the reference to current batch - set to null to prevent additions to current batch post timeout\n    var currentDefer = deferred;\n    var currentItems = items;\n    deferred = null;\n    items = []; // Actually do the method\n\n    return methodToExecute(currentItems);\n  };\n  /**\n   * Add a new item to batch\n   *\n   * Returns a promise resolved when the method is actually executed.\n   *\n   * @param {a} item The item to add\n   * @returns {Promise} Promise resolved when action is actually executed\n   */\n\n\n  return function (item) {\n    // If a batch is not already active create a new one\n    if (!deferred) {\n      deferred = AwPromiseService.instance.defer();\n    } // If the timer is running cancel it\n\n\n    if (debounceTimer) {\n      AwTimeoutService.instance.cancel(debounceTimer);\n    } // Add item to batch and start a new timer\n\n\n    items.push(item);\n\n    var timerComplete = function () {\n      if (lock) {\n        if (lock.isUnlocked()) {\n          if (!wasLocked) {\n            trace('Debounce is unlocked doing action', debounceTime); // Debounce after unlock has finished, safe to do action\n\n            doAction();\n          } else {\n            trace('Debounce is unlocked restarting timer', debounceTime);\n            wasLocked = false; // Unlock just happened, restart regular debounce\n\n            debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime);\n          }\n        } else {\n          trace('Debounce is locked', debounceTime);\n          wasLocked = true; // Locked, reset timer and check again after debounce\n\n          debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime);\n        }\n      } else {\n        // No extra lock, just do the action\n        doAction();\n      }\n    };\n\n    trace('New item added resetting timer', debounceTime, item);\n    debounceTimer = AwTimeoutService.instance(timerComplete, debounceTime); // Return the \"shared\" promise\n\n    return deferred.promise;\n  };\n};\n\nexport { debouncePromise };\nexports = {\n  debouncePromise\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/async.service.js"],"names":["trace","exports","debouncePromise","deferred","debounceTimer","items","wasLocked","doAction","currentDefer","currentItems","methodToExecute","AwPromiseService","AwTimeoutService","timerComplete","lock"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAA,gBAAA,MAAA,qBAAA;AACA,OAAA,gBAAA,MAAA,qBAAA;AACA,OAAA,KAAA,MAAA,OAAA;AAEA,IAAIA,KAAK,GAAG,IAAA,KAAA,CAAZ,OAAY,CAAZ;AAEA;;AAEA,IAAIC,OAAO,GAAX,EAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,eAAe,GAAG,UAAA,eAAA,EAAA,YAAA,EAAA,IAAA,EAAgD;EAClE;AACJ;AACA;AACA;AACA;EACI,IAAIC,QAAQ,GAAZ,IAAA;EAEA;AACJ;AACA;;EACI,IAAIC,aAAa,GAAjB,IAAA;EAEA;AACJ;AACA;;EACI,IAAIC,KAAK,GAAT,EAAA;EAEA;AACJ;AACA;;EACI,IAAIC,SAAS,GAAb,KAAA;EAEA;AACJ;AACA;AACA;AACA;;EACI,IAAIC,QAAQ,GAAG,YAAW;IACtB;IACA,IAAIC,YAAY,GAAhB,QAAA;IACA,IAAIC,YAAY,GAAhB,KAAA;IACAN,QAAQ,GAARA,IAAAA;IACAE,KAAK,GALiB,EAKtBA,CALsB,CAMtB;;IACA,OAAOK,eAAe,CAAtB,YAAsB,CAAtB;EAPJ,CAAA;EAUA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,OAAO,UAAA,IAAA,EAAiB;IACpB;IACA,IAAI,CAAJ,QAAA,EAAgB;MACZP,QAAQ,GAAGQ,gBAAgB,CAAhBA,QAAAA,CAAXR,KAAWQ,EAAXR;IAHgB,CAAA,CAKpB;;;IACA,IAAA,aAAA,EAAoB;MAChBS,gBAAgB,CAAhBA,QAAAA,CAAAA,MAAAA,CAAAA,aAAAA;IAPgB,CAAA,CASpB;;;IACAP,KAAK,CAALA,IAAAA,CAAAA,IAAAA;;IACA,IAAIQ,aAAa,GAAG,YAAW;MAC3B,IAAA,IAAA,EAAW;QACP,IAAIC,IAAI,CAAR,UAAIA,EAAJ,EAAwB;UACpB,IAAI,CAAJ,SAAA,EAAiB;YACbd,KAAK,CAAA,mCAAA,EADQ,YACR,CAALA,CADa,CAEb;;YACAO,QAAQ;UAHZ,CAAA,MAIO;YACHP,KAAK,CAAA,uCAAA,EAALA,YAAK,CAALA;YACAM,SAAS,GAFN,KAEHA,CAFG,CAGH;;YACAF,aAAa,GAAGQ,gBAAgB,CAAhBA,QAAAA,CAAAA,aAAAA,EAAhBR,YAAgBQ,CAAhBR;UACH;QAVL,CAAA,MAWO;UACHJ,KAAK,CAAA,oBAAA,EAALA,YAAK,CAALA;UACAM,SAAS,GAFN,IAEHA,CAFG,CAGH;;UACAF,aAAa,GAAGQ,gBAAgB,CAAhBA,QAAAA,CAAAA,aAAAA,EAAhBR,YAAgBQ,CAAhBR;QACH;MAjBL,CAAA,MAkBO;QACH;QACAG,QAAQ;MACX;IAtBL,CAAA;;IAwBAP,KAAK,CAAA,gCAAA,EAAA,YAAA,EAALA,IAAK,CAALA;IACAI,aAAa,GAAGQ,gBAAgB,CAAhBA,QAAAA,CAAAA,aAAAA,EApCI,YAoCJA,CAAhBR,CApCoB,CAqCpB;;IACA,OAAOD,QAAQ,CAAf,OAAA;EAtCJ,CAAA;AA9CJ,CAAA;;AAuFA,SAAA,eAAA;AAEAF,OAAO,GAAG;EACNC;AADM,CAAVD;AAGA,eAAA,OAAA","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link NgServices.async} which provides a set of utilities for handling async methods\n *\n * @module js/async.service\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwTimeoutService from 'js/awTimeoutService';\nimport Debug from 'debug';\n\nvar trace = new Debug( 'async' );\n\n/* eslint-disable-next-line valid-jsdoc*/\n\nlet exports = {};\n\n/**\n * Get an api capable of executing the given api async\n *\n * @param {Function<List<a>>} methodToExecute Method to call. Input will be a list of a where a is the input to the debounced method\n * @param {Number} debounceTime How long to debounce method calls\n * @param {Lock} lock A \"lock\" with a \"isUnlocked\" function. Allows external control of call on top of debounce\n * @returns {Function<a>} A debounced version of the method that supports individual calls\n */\nvar debouncePromise = function( methodToExecute, debounceTime, lock ) {\n    /**\n     * Promise tracking any currently active batch.\n     *\n     * Resolved once the method is actually executed.\n     */\n    var deferred = null;\n\n    /**\n     * The current active timer. If allowed to complete the method will be executed.\n     */\n    var debounceTimer = null;\n\n    /**\n     * Items to pass to the network\n     */\n    var items = [];\n\n    /**\n     * Flag tracking if the service was previously locked\n     */\n    var wasLocked = false;\n\n    /**\n     * Actually execute the action\n     *\n     * @returns {Promise} Promise resolved after execution\n     */\n    var doAction = function() {\n        // Clear the reference to current batch - set to null to prevent additions to current batch post timeout\n        var currentDefer = deferred;\n        var currentItems = items;\n        deferred = null;\n        items = [];\n        // Actually do the method\n        return methodToExecute( currentItems );\n    };\n\n    /**\n     * Add a new item to batch\n     *\n     * Returns a promise resolved when the method is actually executed.\n     *\n     * @param {a} item The item to add\n     * @returns {Promise} Promise resolved when action is actually executed\n     */\n    return function( item ) {\n        // If a batch is not already active create a new one\n        if( !deferred ) {\n            deferred = AwPromiseService.instance.defer();\n        }\n        // If the timer is running cancel it\n        if( debounceTimer ) {\n            AwTimeoutService.instance.cancel( debounceTimer );\n        }\n        // Add item to batch and start a new timer\n        items.push( item );\n        var timerComplete = function() {\n            if( lock ) {\n                if( lock.isUnlocked() ) {\n                    if( !wasLocked ) {\n                        trace( 'Debounce is unlocked doing action', debounceTime );\n                        // Debounce after unlock has finished, safe to do action\n                        doAction();\n                    } else {\n                        trace( 'Debounce is unlocked restarting timer', debounceTime );\n                        wasLocked = false;\n                        // Unlock just happened, restart regular debounce\n                        debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n                    }\n                } else {\n                    trace( 'Debounce is locked', debounceTime );\n                    wasLocked = true;\n                    // Locked, reset timer and check again after debounce\n                    debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n                }\n            } else {\n                // No extra lock, just do the action\n                doAction();\n            }\n        };\n        trace( 'New item added resetting timer', debounceTime, item );\n        debounceTimer = AwTimeoutService.instance( timerComplete, debounceTime );\n        // Return the \"shared\" promise\n        return deferred.promise;\n    };\n};\nexport { debouncePromise as debouncePromise };\n\nexports = {\n    debouncePromise\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}