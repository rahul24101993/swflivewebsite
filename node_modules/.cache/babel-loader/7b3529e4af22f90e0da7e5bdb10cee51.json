{"ast":null,"code":"/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/* global AFX_UTEST */\n\n/**\n * This service is used to manage the sync strategies.\n *\n * @module js/syncStrategyService\n *\n */\nimport _ from 'lodash';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport cfgSvc from 'js/configurationService';\nimport viewModelSvc from 'js/viewModelService';\nimport conditionSvc from 'js/conditionService';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport actionService from 'js/actionService';\n\nlet _syncStrategyMap;\n\nconst _vmPathCache = {};\nvar _strategies = null;\nlet _declViewModel = null;\nvar exports = {};\n/**\n * Create the declartive viewModel from all combined syncStrategy.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */\n\nfunction createViewModel(viewModel) {\n  viewModel._viewModelId = 'syncStrategyViewModel_' + Math.random();\n  viewModel.skipClone = true;\n  return viewModelSvc.populateViewModelPropertiesFromJson(viewModel, null, null, true);\n}\n\nexport const setupSyncStrategy = dataCtxNode => {\n  const id = dataCtxNode.data._internal.modelId;\n  const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n  syncViewModelCacheService.set(path + '.' + id, dataCtxNode);\n};\nexport const loadConfiguration = async function () {\n  await cfgSvc.getCfg('syncStrategy').then(strategies => {\n    _strategies = strategies;\n\n    if (!_strategies && AFX_UTEST) {\n      _strategies = {};\n    }\n\n    _syncStrategyMap = new Map(); // handler relatioin w.r.t to source\n\n    if (!_vmPathCache.handlersRelation) {\n      _vmPathCache.handlersRelation = {};\n    } // target relation with source\n\n\n    if (!_vmPathCache.targetRelationToSource) {\n      _vmPathCache.targetRelationToSource = {};\n    }\n    /*\n        <sourceView>: {\n            \"<port1>\": ['<handler1>', '<handler2>'],\n            \"<port2>\": ['<handler3>', '<handler4>'],\n        }\n    */\n\n\n    for (var key in _strategies.syncStrategyHandlers) {\n      let handler = _strategies.syncStrategyHandlers[key];\n      let syncStrategyId = handler.id;\n      let synConfigObject = _strategies.syncStrategies[syncStrategyId];\n      let sPort = synConfigObject.source.port;\n      let sViewHierarchy = synConfigObject.source.view.split('/');\n      let sView = sViewHierarchy[sViewHierarchy.length - 1];\n\n      if (!_syncStrategyMap.has(sView)) {\n        _syncStrategyMap.set(sView, {\n          ports: {}\n        });\n      }\n\n      if (!_syncStrategyMap.get(sView).ports[sPort]) {\n        _syncStrategyMap.get(sView).ports[sPort] = [];\n      }\n\n      _syncStrategyMap.get(sView).ports[sPort].push(key);\n    }\n  });\n};\n\nconst getDeclViewModel = function () {\n  return createViewModel(_strategies);\n};\n\nconst _fireTargetAction = function (targetViewModel, value, strategyConfig) {\n  if (targetViewModel && targetViewModel.data) {\n    const targetPort = Object.assign({}, targetViewModel.data.getPortById(strategyConfig.target.port)); // if port of target is present, then only fire action\n\n    if (!_.isNil(targetPort) && !_.isEmpty(targetPort)) {\n      // adding input object to targets port\n      targetPort.syncObject = value; // adding ports as a sibling to data in VM.\n\n      const portsData = { ...targetViewModel.ports,\n        [strategyConfig.target.port]: targetPort\n      }; // zarq9k: Cannot do dispatch on unmount process.\n      // Need to re-think on strategy. It is a point fix.\n\n      if (targetViewModel.data && targetViewModel.data.dispatch) {\n        targetViewModel.data.dispatch({\n          path: 'ports',\n          value: portsData\n        });\n        targetViewModel.data.ports = portsData;\n        targetViewModel.ports = targetViewModel.data.ports;\n        return viewModelSvc.executeCommand(targetViewModel.data, targetPort.onChangeAction, targetViewModel);\n      }\n\n      return AwPromiseService.instance.resolve();\n    }\n\n    return AwPromiseService.instance.resolve({\n      errorCode: 'NO_TARGET_PORT_FOUND',\n      errorMessage: `No port is configured for view: ${targetViewModel.data._internal.viewId}`\n    });\n  }\n\n  return AwPromiseService.instance.resolve();\n};\n\nconst _executePreProcessingAction = function (actionName, syncContext, value) {\n  var deferred = AwPromiseService.instance.defer();\n  var action = _strategies.actions[actionName];\n\n  if (action.deps) {\n    /** action ID will be used for better logging */\n    action.actionId = action.method;\n\n    var doAction = function (depModuleObj) {\n      if (_declViewModel.isDestroyed()) {\n        logger.warn('Attempt to execute a command after its DeclViewModel was destroyed...' + '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n        'DeclViewModel: ' + _declViewModel + '\\n' + //\n        'Action       : ' + action);\n        return AwPromiseService.instance.reject();\n      }\n      /**\n       * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n       * event processing was started.\n       */\n\n\n      _declViewModel.value = value;\n      var dataCtxNode = {\n        data: _declViewModel,\n        ctx: appCtxSvc.ctx,\n        syncContext: syncContext\n      };\n      var localDataCtx = declUtils.resolveLocalDataCtx(_declViewModel, dataCtxNode); // _deps will be undefined when try to load viewModelService inside itself\n\n      var _depModuleObj = depModuleObj;\n      return actionService.executeAction(_declViewModel, action, localDataCtx, _depModuleObj, true);\n    };\n\n    return moduleLoader.getDependentModule(action.deps).then(depModuleObj => {\n      return doAction(depModuleObj);\n    });\n  }\n\n  return deferred.Promise;\n};\n\nconst _runAction = function (handler, syncContext, value, targetViewModel, syncStrategyDef) {\n  return _executePreProcessingAction(handler.action, syncContext, value).then(function (response) {\n    // response data is avaiable on response.actionData\n    return _fireTargetAction(targetViewModel, response.actionData, syncStrategyDef);\n  });\n};\n\nconst _executeHandlerAction = function (handler, syncContext, value, targetViewModel, syncStrategyDef) {\n  if (!_declViewModel) {\n    _declViewModel = getDeclViewModel();\n  }\n\n  return _runAction(handler, syncContext, value, targetViewModel, syncStrategyDef);\n};\n\nconst _evaluateActiveWhen = function (strategyObject, syncContext) {\n  return conditionSvc.evaluateConditionExpression(strategyObject, {\n    syncContext: syncContext,\n    ctx: appCtxSvc.ctx\n  }, {\n    clauseName: 'activeWhen',\n    conditionList: _strategies\n  });\n};\n\nconst _requestUpdate = function (viewId, modelId, portName, value) {\n  if (_syncStrategyMap.get(viewId) && _syncStrategyMap.get(viewId).ports[portName]) {\n    var syncExecutePromises = [];\n\n    if (_vmPathCache[viewId]) {\n      const srcObj = _vmPathCache[viewId][modelId];\n\n      var allHandlers = _syncStrategyMap.get(viewId).ports[portName];\n\n      _.forEach(srcObj.handlers, function (handler, name) {\n        if (allHandlers.indexOf(name) > -1 && handler.target) {\n          Object.values(handler.target).forEach(targetViewModel => {\n            const syncStrategyDef = _strategies.syncStrategies[handler.id];\n            const syncContext = {\n              targetViewModel: targetViewModel,\n              sourceViewModel: srcObj.vm\n            }; // evaluate activewhen\n\n            if (_evaluateActiveWhen(handler, syncContext)) {\n              if (handler.action) {\n                var launch = _executeHandlerAction(handler, syncContext, value, targetViewModel, syncStrategyDef);\n\n                syncExecutePromises.push(launch);\n              } else {\n                syncExecutePromises.push(_fireTargetAction(targetViewModel, value, syncStrategyDef));\n              }\n            }\n          });\n        }\n      });\n    }\n\n    if (syncExecutePromises.length) {\n      return AwPromiseService.instance.all(syncExecutePromises);\n    }\n  }\n\n  return AwPromiseService.instance.resolve({\n    errorCode: 'NO_ACTIVE_ACTION_FOUND',\n    errorMessage: `No sync action fired for view: ${viewId} with port: ${portName}`\n  });\n};\n/**\n * triggerSyncStrategy\n * @param {Object} declViewModel decl view model of source\n * @param {String} inputData resolved inputData from actionService\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\n\n\nexport const updatePort = function (declViewModel, inputData) {\n  const viewId = declViewModel._internal.viewId;\n  const modelId = declViewModel._internal.modelId;\n  const portName = inputData.port;\n  const newValue = inputData.syncObject;\n  const vmCacheMap = syncViewModelCacheService.get('syncViewModelCache');\n\n  if (vmCacheMap[viewId] && vmCacheMap[viewId][modelId]) {\n    const sourceVm = vmCacheMap[viewId][modelId];\n\n    if (sourceVm && sourceVm.data && sourceVm.data.getPortById(portName)) {\n      let sourceVmData = sourceVm.data;\n      let sPortObject = Object.assign({}, sourceVmData.getPortById(portName));\n      sPortObject.syncObject = newValue ? newValue : sourceVm.ports[portName].syncObject; // adding ports as a sibling to data in VM.\n\n      const portsData = { ...sourceVm.ports,\n        [portName]: sPortObject\n      };\n      sourceVmData.dispatch({\n        path: 'ports',\n        value: portsData\n      });\n      return _requestUpdate(viewId, modelId, portName, newValue);\n    }\n  }\n\n  return AwPromiseService.instance.resolve({\n    errorCode: 'NO_PORT_FOUND',\n    errorMessage: `No port is configured for view: ${viewId}`\n  });\n};\n/**\n * revisitme: find out the solution for this API to support other use cases\n * @param {*} viewPath viewpath\n * @returns {Array} array of elements\n */\n\nexport const getElementArray = function (viewPath) {\n  var elementString = '';\n  var body = document.body;\n  var elementPathArray = viewPath.split('/');\n\n  if (elementPathArray && elementPathArray.length > 1) {\n    // aw-include[name='commonRoot'] aw-include[name='commonLocation'] aw-include[name='showcaseMain']\"\n    elementPathArray.forEach(function (viewName) {\n      elementString = elementString + 'aw-include[name=\"' + viewName + '\"] ';\n    });\n  } else {\n    // aw-include[view-id='commonRoot']\n    var uniqueViewElement = body.querySelectorAll('aw-include[view-id=\"' + elementPathArray[0] + '\"] ');\n\n    if (uniqueViewElement && uniqueViewElement.length === 1) {\n      return uniqueViewElement;\n    } // aw-include[name='commonRoot']\n\n\n    elementString = 'aw-include[name=\"' + elementPathArray[0] + '\"] ';\n  } // revisitme : currently supporting only viewName use case, figure out impact of following commented line\n  // return body.querySelectorAll( elementString );\n\n\n  return ['dummyelement'];\n};\n\nconst validateViewPath = function (context, viewPath, viewId) {\n  const viewPathArray = viewPath.split('/');\n  let initialCheck = viewPathArray[viewPathArray.length - 1] === viewId;\n\n  if (initialCheck && viewPathArray.length > 1) {\n    let preIndex = -1;\n    let currIndex = 0;\n    let comViewPathArray = context.props.viewPath.split('/');\n\n    for (let i = 0; i < viewPathArray.length; i++) {\n      currIndex = comViewPathArray.indexOf[viewPathArray[i]];\n\n      if (currIndex === -1 && currIndex < preIndex) {\n        initialCheck = false;\n        break;\n      } else {\n        preIndex = currIndex;\n      }\n    }\n  }\n\n  return initialCheck;\n};\n\nconst getViewNameFromPath = function (viewPath) {\n  const viewPathArray = viewPath.split('/');\n  return viewPathArray[viewPathArray.length - 1];\n};\n\nconst _addToCachePaths = function (declViewModel) {\n  const viewId = declViewModel.data._internal.viewId;\n  const modelId = declViewModel.data._internal.modelId;\n  const vmCacheMap = syncViewModelCacheService.get('syncViewModelCache');\n\n  const _cachingAsSource = () => {\n    const allHandlersName = Object.values(_syncStrategyMap.get(viewId).ports).flatMap(h => h);\n    const handlers = allHandlersName.reduce((handlersObj, name) => {\n      const {\n        id,\n        action,\n        activeWhen\n      } = _strategies.syncStrategyHandlers[name];\n\n      if (validateViewPath(declViewModel, _strategies.syncStrategies[id].source.view, viewId)) {\n        const targetObj = _strategies.syncStrategies[id].target;\n        const targetVm = vmCacheMap[getViewNameFromPath(targetObj.view)];\n        handlersObj[name] = {\n          id,\n          action,\n          activeWhen,\n          target: targetVm ? targetVm : {}\n        };\n        _vmPathCache.handlersRelation[name] = {\n          viewId: viewId,\n          modelId: modelId\n        };\n      }\n\n      return handlersObj;\n    }, {}); // handling for multiple entry for same viewId\n\n    if (!_vmPathCache[viewId]) {\n      _vmPathCache[viewId] = {};\n    }\n\n    _vmPathCache[viewId][modelId] = {\n      get vm() {\n        return syncViewModelCacheService.get('syncViewModelCache')[viewId][modelId];\n      },\n\n      handlers: handlers\n    };\n  }; // vm act as source\n\n\n  if (_syncStrategyMap.get(viewId) && (!_vmPathCache[viewId] || !_vmPathCache[viewId][modelId])) {\n    _cachingAsSource();\n  } // vm act as target\n\n\n  const asTarget = Object.entries(_strategies.syncStrategies).reduce((acc, obj) => {\n    if (validateViewPath(declViewModel, obj[1].target.view, viewId)) {\n      acc.push(obj[0]);\n    }\n\n    return acc;\n  }, []);\n\n  const _cachingAsTarget = () => {\n    const targetHandler = Object.entries(_strategies.syncStrategyHandlers).reduce((acc, obj) => {\n      if (asTarget.indexOf(obj[1].id) > -1) {\n        acc[obj[0]] = obj[1];\n      }\n\n      return acc;\n    }, {});\n\n    _.forEach(targetHandler, (obj, key) => {\n      const matchingSrc = _vmPathCache.handlersRelation[key];\n\n      if (matchingSrc && _syncStrategyMap.get(matchingSrc.viewId)) {\n        const view = getViewNameFromPath(_strategies.syncStrategies[obj.id].target.view);\n        const trgVm = vmCacheMap[view];\n        const handlers = _vmPathCache[matchingSrc.viewId][matchingSrc.modelId].handlers;\n        handlers[key].target = trgVm ? trgVm : {};\n\n        if (!_vmPathCache.targetRelationToSource[view]) {\n          _vmPathCache.targetRelationToSource[view] = [];\n        }\n\n        _vmPathCache.targetRelationToSource[view].push({\n          source: {\n            viewId: matchingSrc.viewId,\n            modelId: matchingSrc.modelId\n          },\n          modelId: modelId,\n          handlerId: obj.id,\n          handlerName: key\n        });\n      }\n    });\n  };\n\n  if (asTarget && asTarget.length) {\n    _cachingAsTarget();\n  }\n};\n\nconst _removeFromCachePaths = function (declViewModel) {\n  const viewId = declViewModel.data._internal.viewId; // clear relations\n\n  _.forEach(_vmPathCache.handlersRelation, (obj, key) => {\n    if (obj.viewId === viewId) {\n      delete _vmPathCache.handlersRelation[key];\n    }\n  }); // clear target relation with source\n\n\n  if (_vmPathCache.targetRelationToSource[viewId]) {\n    delete _vmPathCache.targetRelationToSource[viewId];\n  } // clear vm from vmPathCache\n\n\n  if (_vmPathCache[viewId]) {\n    delete _vmPathCache[viewId];\n  }\n};\n\nconst _updateOnMount = function (declVm) {\n  const syncExecutePromises = [];\n  const viewId = declVm.data._internal.viewId;\n  const allRelations = _vmPathCache.targetRelationToSource[viewId];\n  allRelations && allRelations.forEach(relObj => {\n    const strategyDef = _strategies.syncStrategies[relObj.handlerId];\n\n    if (_vmPathCache[relObj.source.viewId]) {\n      const sourceObj = _vmPathCache[relObj.source.viewId][relObj.source.modelId]; // check whether the src is loaded or not\n\n      if (sourceObj) {\n        const handler = _strategies.syncStrategyHandlers[relObj.handlerName];\n        const sourceVm = sourceObj.vm;\n        let srcPortData = sourceVm.ports ? sourceVm.ports[strategyDef.source.port] : null;\n        const syncContext = {\n          targetViewModel: declVm,\n          sourceViewModel: sourceVm\n        }; // evaluate activewhen\n\n        const isActive = _evaluateActiveWhen(handler, syncContext);\n\n        if (isActive && handler.action) {\n          const launch = _executeHandlerAction(handler, syncContext, srcPortData, declVm, strategyDef);\n\n          syncExecutePromises.push(launch);\n        } else if (isActive) {\n          srcPortData = srcPortData ? srcPortData.syncObject : null;\n          syncExecutePromises.push(_fireTargetAction(declVm, srcPortData, strategyDef));\n        }\n      }\n    }\n  });\n\n  if (syncExecutePromises.length) {\n    return AwPromiseService.instance.all(syncExecutePromises);\n  }\n\n  return AwPromiseService.instance.resolve({\n    code: 'NO_OUTSTANDING_REQUEST_PRESENT',\n    message: 'view model mount completed'\n  });\n};\n\nconst _updateOnUnmount = function (declVm) {\n  const syncExecutePromises = [];\n  const viewId = declVm.data._internal.viewId;\n  const modelId = declVm.data._internal.modelId;\n\n  if (_vmPathCache[viewId]) {\n    const allHandlers = Object.values(_vmPathCache[viewId][modelId])[1];\n\n    _.forEach(allHandlers, handler => {\n      const syncStrategyDef = _strategies.syncStrategies[handler.id];\n      syncExecutePromises.push(_fireTargetAction(Object.values(handler.target)[0], '', syncStrategyDef));\n    });\n  }\n\n  if (syncExecutePromises.length) {\n    return AwPromiseService.instance.all(syncExecutePromises);\n  }\n\n  return AwPromiseService.instance.resolve({\n    code: 'NO_OUTSTANDING_REQUEST_PRESENT',\n    message: 'view model unmount completed'\n  });\n};\n/**\n * triggerSyncStrategy\n * @param {Object} declVm decl viewModel of view\n * @param {String} isMount if vm loaded, then true. if vm unloaded, then false\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\n\n\nexport const updateVmOnMountUnmount = function (declVm, isMount) {\n  if (isMount) {\n    // need to add entry to cache as src and trg\n    _addToCachePaths(declVm); // target mounted\n\n\n    return _updateOnMount(declVm);\n  } // if source unmount, reset all the targets.\n\n\n  _updateOnUnmount(declVm); // need to remove entry from cache\n\n\n  return _removeFromCachePaths(declVm);\n};\nloadConfiguration();\nexports = {\n  updatePort,\n  updateVmOnMountUnmount,\n  loadConfiguration,\n  getElementArray,\n  setupSyncStrategy\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/syncStrategyService.js"],"names":["_vmPathCache","_strategies","_declViewModel","exports","viewModel","Math","viewModelSvc","setupSyncStrategy","dataCtxNode","id","path","syncViewModelCacheService","loadConfiguration","strategies","_syncStrategyMap","handler","syncStrategyId","synConfigObject","sPort","sViewHierarchy","sView","ports","getDeclViewModel","createViewModel","_fireTargetAction","targetViewModel","targetPort","Object","strategyConfig","_","portsData","value","AwPromiseService","errorCode","errorMessage","viewId","_executePreProcessingAction","deferred","action","doAction","logger","data","ctx","appCtxSvc","syncContext","localDataCtx","declUtils","_depModuleObj","actionService","depModuleObj","_runAction","response","_executeHandlerAction","_evaluateActiveWhen","clauseName","conditionList","_requestUpdate","syncExecutePromises","srcObj","allHandlers","syncStrategyDef","sourceViewModel","vm","launch","portName","updatePort","declViewModel","modelId","inputData","newValue","vmCacheMap","sourceVm","sourceVmData","sPortObject","getElementArray","elementString","body","document","elementPathArray","viewPath","uniqueViewElement","validateViewPath","viewPathArray","initialCheck","preIndex","currIndex","comViewPathArray","context","i","getViewNameFromPath","_addToCachePaths","_cachingAsSource","allHandlersName","h","handlers","activeWhen","targetObj","targetVm","handlersObj","target","asTarget","obj","acc","_cachingAsTarget","targetHandler","matchingSrc","view","trgVm","source","handlerId","handlerName","key","_removeFromCachePaths","_updateOnMount","declVm","allRelations","relObj","strategyDef","sourceObj","srcPortData","isActive","code","message","_updateOnUnmount","updateVmOnMountUnmount"],"mappings":"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","sourcesContent":["/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/* global AFX_UTEST */\n\n/**\n * This service is used to manage the sync strategies.\n *\n * @module js/syncStrategyService\n *\n */\nimport _ from 'lodash';\nimport AwPromiseService from 'js/awPromiseService';\nimport appCtxSvc from 'js/appCtxService';\nimport cfgSvc from 'js/configurationService';\nimport viewModelSvc from 'js/viewModelService';\nimport conditionSvc from 'js/conditionService';\nimport declUtils from 'js/declUtils';\nimport moduleLoader from 'js/moduleLoader';\nimport logger from 'js/logger';\nimport syncViewModelCacheService from 'js/syncViewModelCacheService';\nimport actionService from 'js/actionService';\n\nlet _syncStrategyMap;\nconst _vmPathCache = {};\nvar _strategies = null;\nlet _declViewModel = null;\nvar exports = {};\n\n/**\n * Create the declartive viewModel from all combined syncStrategy.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */\nfunction createViewModel( viewModel ) {\n    viewModel._viewModelId = 'syncStrategyViewModel_' + Math.random();\n    viewModel.skipClone = true;\n    return viewModelSvc.populateViewModelPropertiesFromJson( viewModel, null, null, true );\n}\n\nexport const setupSyncStrategy = ( dataCtxNode ) => {\n    const id = dataCtxNode.data._internal.modelId;\n    const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;\n    syncViewModelCacheService.set( path + '.' + id, dataCtxNode );\n};\nexport const loadConfiguration = async function() {\n    await cfgSvc.getCfg( 'syncStrategy' ).then( strategies => {\n        _strategies = strategies;\n        if( !_strategies && AFX_UTEST ) {\n            _strategies = {};\n        }\n        _syncStrategyMap = new Map();\n        // handler relatioin w.r.t to source\n        if( !_vmPathCache.handlersRelation ) {\n            _vmPathCache.handlersRelation = {};\n        }\n\n        // target relation with source\n        if( !_vmPathCache.targetRelationToSource ) {\n            _vmPathCache.targetRelationToSource = {};\n        }\n\n        /*\n            <sourceView>: {\n                \"<port1>\": ['<handler1>', '<handler2>'],\n                \"<port2>\": ['<handler3>', '<handler4>'],\n            }\n        */\n        for( var key in _strategies.syncStrategyHandlers ) {\n            let handler = _strategies.syncStrategyHandlers[ key ];\n            let syncStrategyId = handler.id;\n            let synConfigObject = _strategies.syncStrategies[ syncStrategyId ];\n            let sPort = synConfigObject.source.port;\n            let sViewHierarchy = synConfigObject.source.view.split( '/' );\n            let sView = sViewHierarchy[ sViewHierarchy.length - 1 ];\n\n            if( !_syncStrategyMap.has( sView ) ) {\n                _syncStrategyMap.set( sView, { ports: {} } );\n            }\n            if( !_syncStrategyMap.get( sView ).ports[ sPort ] ) {\n                _syncStrategyMap.get( sView ).ports[ sPort ] = [];\n            }\n\n            _syncStrategyMap.get( sView ).ports[ sPort ].push( key );\n        }\n    } );\n};\n\nconst getDeclViewModel = function() {\n    return createViewModel( _strategies );\n};\n\nconst _fireTargetAction = function( targetViewModel, value, strategyConfig ) {\n    if( targetViewModel && targetViewModel.data ) {\n        const targetPort = Object.assign( {}, targetViewModel.data.getPortById( strategyConfig.target.port ) );\n        // if port of target is present, then only fire action\n        if( !_.isNil( targetPort ) && !_.isEmpty( targetPort ) ) {\n            // adding input object to targets port\n            targetPort.syncObject = value;\n            // adding ports as a sibling to data in VM.\n            const portsData = {\n                ...targetViewModel.ports,\n                [ strategyConfig.target.port ]: targetPort\n            };\n            // zarq9k: Cannot do dispatch on unmount process.\n            // Need to re-think on strategy. It is a point fix.\n            if( targetViewModel.data && targetViewModel.data.dispatch ) {\n                targetViewModel.data.dispatch( { path: 'ports', value: portsData } );\n                targetViewModel.data.ports = portsData;\n                targetViewModel.ports = targetViewModel.data.ports;\n                return viewModelSvc.executeCommand( targetViewModel.data, targetPort.onChangeAction, targetViewModel );\n            }\n            return AwPromiseService.instance.resolve();\n        }\n        return AwPromiseService.instance.resolve( { errorCode: 'NO_TARGET_PORT_FOUND', errorMessage: `No port is configured for view: ${targetViewModel.data._internal.viewId}` } );\n    }\n    return AwPromiseService.instance.resolve();\n};\n\nconst _executePreProcessingAction = function( actionName, syncContext, value ) {\n    var deferred = AwPromiseService.instance.defer();\n    var action = _strategies.actions[ actionName ];\n    if( action.deps ) {\n        /** action ID will be used for better logging */\n        action.actionId = action.method;\n\n        var doAction = function( depModuleObj ) {\n            if( _declViewModel.isDestroyed() ) {\n                logger.warn( 'Attempt to execute a command after its DeclViewModel was destroyed...' +\n                    '\\n' + 'Action was therefore not executed...continuing.' + '\\n' + //\n                    'DeclViewModel: ' + _declViewModel + '\\n' + //\n                    'Action       : ' + action );\n                return AwPromiseService.instance.reject();\n            }\n            /**\n             * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n             * event processing was started.\n             */\n            _declViewModel.value = value;\n            var dataCtxNode = {\n                data: _declViewModel,\n                ctx: appCtxSvc.ctx,\n                syncContext: syncContext\n            };\n            var localDataCtx = declUtils.resolveLocalDataCtx( _declViewModel, dataCtxNode );\n\n            // _deps will be undefined when try to load viewModelService inside itself\n            var _depModuleObj = depModuleObj;\n            return actionService.executeAction( _declViewModel, action, localDataCtx, _depModuleObj, true );\n        };\n        return moduleLoader.getDependentModule( action.deps ).then( depModuleObj => {\n            return doAction( depModuleObj );\n        } );\n    }\n    return deferred.Promise;\n};\n\nconst _runAction = function( handler, syncContext, value, targetViewModel, syncStrategyDef ) {\n    return _executePreProcessingAction( handler.action, syncContext, value ).then( function( response ) {\n        // response data is avaiable on response.actionData\n        return _fireTargetAction( targetViewModel, response.actionData, syncStrategyDef );\n    } );\n};\n\nconst _executeHandlerAction = function( handler, syncContext, value, targetViewModel, syncStrategyDef ) {\n    if( !_declViewModel ) {\n        _declViewModel = getDeclViewModel();\n    }\n    return _runAction( handler, syncContext, value, targetViewModel, syncStrategyDef );\n};\n\nconst _evaluateActiveWhen = function( strategyObject, syncContext ) {\n    return conditionSvc.evaluateConditionExpression( strategyObject, { syncContext: syncContext, ctx: appCtxSvc.ctx }, { clauseName: 'activeWhen', conditionList: _strategies } );\n};\n\nconst _requestUpdate = function( viewId, modelId, portName, value ) {\n    if( _syncStrategyMap.get( viewId ) && _syncStrategyMap.get( viewId ).ports[ portName ] ) {\n        var syncExecutePromises = [];\n        if( _vmPathCache[ viewId ] ) {\n            const srcObj = _vmPathCache[ viewId ][ modelId ];\n            var allHandlers = _syncStrategyMap.get( viewId ).ports[ portName ];\n            _.forEach( srcObj.handlers, function( handler, name ) {\n                if( allHandlers.indexOf( name ) > -1 && handler.target ) {\n                    Object.values( handler.target ).forEach( ( targetViewModel ) => {\n                        const syncStrategyDef = _strategies.syncStrategies[ handler.id ];\n                        const syncContext = { targetViewModel: targetViewModel, sourceViewModel: srcObj.vm };\n                        // evaluate activewhen\n                        if( _evaluateActiveWhen( handler, syncContext ) ) {\n                            if( handler.action ) {\n                                var launch = _executeHandlerAction( handler, syncContext, value, targetViewModel, syncStrategyDef );\n                                syncExecutePromises.push( launch );\n                            } else {\n                                syncExecutePromises.push( _fireTargetAction( targetViewModel, value, syncStrategyDef ) );\n                            }\n                        }\n                    } );\n                }\n            } );\n        }\n        if( syncExecutePromises.length ) {\n            return AwPromiseService.instance.all( syncExecutePromises );\n        }\n    }\n    return AwPromiseService.instance.resolve( { errorCode: 'NO_ACTIVE_ACTION_FOUND', errorMessage: `No sync action fired for view: ${viewId} with port: ${portName}` } );\n};\n\n/**\n * triggerSyncStrategy\n * @param {Object} declViewModel decl view model of source\n * @param {String} inputData resolved inputData from actionService\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\nexport const updatePort = function( declViewModel, inputData ) {\n    const viewId = declViewModel._internal.viewId;\n    const modelId = declViewModel._internal.modelId;\n    const portName = inputData.port;\n    const newValue = inputData.syncObject;\n    const vmCacheMap = syncViewModelCacheService.get( 'syncViewModelCache' );\n\n    if( vmCacheMap[ viewId ] && vmCacheMap[ viewId ][ modelId ] ) {\n        const sourceVm = vmCacheMap[ viewId ][ modelId ];\n        if( sourceVm && sourceVm.data && sourceVm.data.getPortById( portName ) ) {\n            let sourceVmData = sourceVm.data;\n            let sPortObject = Object.assign( {}, sourceVmData.getPortById( portName ) );\n            sPortObject.syncObject = newValue ? newValue : sourceVm.ports[ portName ].syncObject;\n            // adding ports as a sibling to data in VM.\n            const portsData = {\n                ...sourceVm.ports,\n                [ portName ]: sPortObject\n            };\n            sourceVmData.dispatch( { path: 'ports', value: portsData } );\n\n            return _requestUpdate( viewId, modelId, portName, newValue );\n        }\n    }\n    return AwPromiseService.instance.resolve( { errorCode: 'NO_PORT_FOUND', errorMessage: `No port is configured for view: ${viewId}` } );\n};\n\n/**\n * revisitme: find out the solution for this API to support other use cases\n * @param {*} viewPath viewpath\n * @returns {Array} array of elements\n */\nexport const getElementArray = function( viewPath ) {\n    var elementString = '';\n    var body = document.body;\n    var elementPathArray = viewPath.split( '/' );\n    if( elementPathArray && elementPathArray.length > 1 ) {\n        // aw-include[name='commonRoot'] aw-include[name='commonLocation'] aw-include[name='showcaseMain']\"\n        elementPathArray.forEach( function( viewName ) {\n            elementString = elementString + 'aw-include[name=\"' + viewName + '\"] ';\n        } );\n    } else {\n        // aw-include[view-id='commonRoot']\n        var uniqueViewElement = body.querySelectorAll( 'aw-include[view-id=\"' + elementPathArray[ 0 ] + '\"] ' );\n        if( uniqueViewElement && uniqueViewElement.length === 1 ) {\n            return uniqueViewElement;\n        }\n        // aw-include[name='commonRoot']\n        elementString = 'aw-include[name=\"' + elementPathArray[ 0 ] + '\"] ';\n    }\n\n    // revisitme : currently supporting only viewName use case, figure out impact of following commented line\n    // return body.querySelectorAll( elementString );\n    return [ 'dummyelement' ];\n};\n\nconst validateViewPath = function( context, viewPath, viewId ) {\n    const viewPathArray = viewPath.split( '/' );\n    let initialCheck = viewPathArray[ viewPathArray.length - 1 ] === viewId;\n    if( initialCheck && viewPathArray.length > 1 ) {\n        let preIndex = -1;\n        let currIndex = 0;\n        let comViewPathArray = context.props.viewPath.split( '/' );\n        for( let i = 0; i < viewPathArray.length; i++ ) {\n            currIndex = comViewPathArray.indexOf[ viewPathArray[ i ] ];\n            if( currIndex === -1 && currIndex < preIndex ) {\n                initialCheck = false;\n                break;\n            } else {\n                preIndex = currIndex;\n            }\n        }\n    }\n    return initialCheck;\n};\n\nconst getViewNameFromPath = function( viewPath ) {\n    const viewPathArray = viewPath.split( '/' );\n    return viewPathArray[ viewPathArray.length - 1 ];\n};\n\nconst _addToCachePaths = function( declViewModel ) {\n    const viewId = declViewModel.data._internal.viewId;\n    const modelId = declViewModel.data._internal.modelId;\n    const vmCacheMap = syncViewModelCacheService.get( 'syncViewModelCache' );\n\n    const _cachingAsSource = () => {\n        const allHandlersName = Object.values( _syncStrategyMap.get( viewId ).ports ).flatMap( h => h );\n\n        const handlers = allHandlersName.reduce( ( handlersObj, name ) => {\n            const { id, action, activeWhen } = _strategies.syncStrategyHandlers[ name ];\n            if( validateViewPath( declViewModel, _strategies.syncStrategies[ id ].source.view, viewId ) ) {\n                const targetObj = _strategies.syncStrategies[ id ].target;\n                const targetVm = vmCacheMap[ getViewNameFromPath( targetObj.view ) ];\n                handlersObj[ name ] = {\n                    id,\n                    action,\n                    activeWhen,\n                    target: targetVm ? targetVm : {}\n                };\n\n                _vmPathCache.handlersRelation[ name ] = {\n                    viewId: viewId,\n                    modelId: modelId\n                };\n            }\n\n            return handlersObj;\n        }, {} );\n\n        // handling for multiple entry for same viewId\n        if( !_vmPathCache[ viewId ] ) {\n            _vmPathCache[ viewId ] = {};\n        }\n        _vmPathCache[ viewId ][ modelId ] = {\n            get vm() {\n                return syncViewModelCacheService.get( 'syncViewModelCache' )[ viewId ][ modelId ];\n            },\n            handlers: handlers\n        };\n    };\n\n    // vm act as source\n    if( _syncStrategyMap.get( viewId ) && ( !_vmPathCache[ viewId ] || !_vmPathCache[ viewId ][ modelId ] ) ) {\n        _cachingAsSource();\n    }\n\n    // vm act as target\n    const asTarget = Object.entries( _strategies.syncStrategies ).reduce( ( acc, obj ) => {\n        if( validateViewPath( declViewModel, obj[ 1 ].target.view, viewId ) ) {\n            acc.push( obj[ 0 ] );\n        }\n        return acc;\n    }, [] );\n\n    const _cachingAsTarget = () => {\n        const targetHandler = Object.entries( _strategies.syncStrategyHandlers ).reduce( ( acc, obj ) => {\n            if( asTarget.indexOf( obj[ 1 ].id ) > -1 ) {\n                acc[ obj[ 0 ] ] = obj[ 1 ];\n            }\n            return acc;\n        }, {} );\n\n        _.forEach( targetHandler, ( obj, key ) => {\n            const matchingSrc = _vmPathCache.handlersRelation[ key ];\n            if( matchingSrc && _syncStrategyMap.get( matchingSrc.viewId ) ) {\n                const view = getViewNameFromPath( _strategies.syncStrategies[ obj.id ].target.view );\n                const trgVm = vmCacheMap[ view ];\n                const handlers = _vmPathCache[ matchingSrc.viewId ][ matchingSrc.modelId ].handlers;\n                handlers[ key ].target = trgVm ? trgVm : {};\n\n                if( !_vmPathCache.targetRelationToSource[ view ] ) {\n                    _vmPathCache.targetRelationToSource[ view ] = [];\n                }\n                _vmPathCache.targetRelationToSource[ view ].push( {\n                    source: {\n                        viewId: matchingSrc.viewId,\n                        modelId: matchingSrc.modelId\n                    },\n                    modelId: modelId,\n                    handlerId: obj.id,\n                    handlerName: key\n                } );\n            }\n        } );\n    };\n\n    if( asTarget && asTarget.length ) {\n        _cachingAsTarget();\n    }\n};\n\nconst _removeFromCachePaths = function( declViewModel ) {\n    const viewId = declViewModel.data._internal.viewId;\n\n    // clear relations\n    _.forEach( _vmPathCache.handlersRelation, ( obj, key ) => {\n        if( obj.viewId === viewId ) {\n            delete _vmPathCache.handlersRelation[ key ];\n        }\n    } );\n\n    // clear target relation with source\n    if( _vmPathCache.targetRelationToSource[ viewId ] ) {\n        delete _vmPathCache.targetRelationToSource[ viewId ];\n    }\n    // clear vm from vmPathCache\n    if( _vmPathCache[ viewId ] ) {\n        delete _vmPathCache[ viewId ];\n    }\n};\n\nconst _updateOnMount = function( declVm ) {\n    const syncExecutePromises = [];\n    const viewId = declVm.data._internal.viewId;\n    const allRelations = _vmPathCache.targetRelationToSource[ viewId ];\n    allRelations && allRelations.forEach( ( relObj ) => {\n        const strategyDef = _strategies.syncStrategies[ relObj.handlerId ];\n        if( _vmPathCache[ relObj.source.viewId ] ) {\n            const sourceObj = _vmPathCache[ relObj.source.viewId ][ relObj.source.modelId ];\n            // check whether the src is loaded or not\n            if( sourceObj ) {\n                const handler = _strategies.syncStrategyHandlers[ relObj.handlerName ];\n                const sourceVm = sourceObj.vm;\n                let srcPortData = sourceVm.ports ? sourceVm.ports[ strategyDef.source.port ] : null;\n                const syncContext = { targetViewModel: declVm, sourceViewModel: sourceVm };\n\n                // evaluate activewhen\n                const isActive = _evaluateActiveWhen( handler, syncContext );\n                if( isActive && handler.action ) {\n                    const launch = _executeHandlerAction( handler, syncContext, srcPortData, declVm, strategyDef );\n                    syncExecutePromises.push( launch );\n                } else if( isActive ) {\n                    srcPortData = srcPortData ? srcPortData.syncObject : null;\n                    syncExecutePromises.push( _fireTargetAction( declVm, srcPortData, strategyDef ) );\n                }\n            }\n        }\n    } );\n\n    if( syncExecutePromises.length ) {\n        return AwPromiseService.instance.all( syncExecutePromises );\n    }\n    return AwPromiseService.instance.resolve( { code: 'NO_OUTSTANDING_REQUEST_PRESENT', message: 'view model mount completed' } );\n};\n\nconst _updateOnUnmount = function( declVm ) {\n    const syncExecutePromises = [];\n\n    const viewId = declVm.data._internal.viewId;\n    const modelId = declVm.data._internal.modelId;\n    if( _vmPathCache[ viewId ] ) {\n        const allHandlers = Object.values( _vmPathCache[ viewId ][ modelId ] )[ 1 ];\n\n        _.forEach( allHandlers, ( handler ) => {\n            const syncStrategyDef = _strategies.syncStrategies[ handler.id ];\n            syncExecutePromises.push( _fireTargetAction( Object.values( handler.target )[ 0 ], '', syncStrategyDef ) );\n        } );\n    }\n\n    if( syncExecutePromises.length ) {\n        return AwPromiseService.instance.all( syncExecutePromises );\n    }\n    return AwPromiseService.instance.resolve( { code: 'NO_OUTSTANDING_REQUEST_PRESENT', message: 'view model unmount completed' } );\n};\n\n/**\n * triggerSyncStrategy\n * @param {Object} declVm decl viewModel of view\n * @param {String} isMount if vm loaded, then true. if vm unloaded, then false\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */\nexport const updateVmOnMountUnmount = function( declVm, isMount ) {\n    if( isMount ) {\n        // need to add entry to cache as src and trg\n        _addToCachePaths( declVm );\n        // target mounted\n        return _updateOnMount( declVm );\n    }\n    // if source unmount, reset all the targets.\n    _updateOnUnmount( declVm );\n    // need to remove entry from cache\n    return _removeFromCachePaths( declVm );\n};\n\nloadConfiguration();\n\nexports = {\n    updatePort,\n    updateVmOnMountUnmount,\n    loadConfiguration,\n    getElementArray,\n    setupSyncStrategy\n};\n\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}