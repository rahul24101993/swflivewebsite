{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * XHR related utilities\n *\n * @module js/splmStatsXhrService\n */import{logger}from'js/splmStatsUtils';import jsService from'js/splmStatsJsService';let _procs=[];let _xhrCounter=0;let _realOpen=null;let _xhrSender=null;let _enabled=false;let _mainProc=null;export const getCount=function(){return _xhrCounter;};export const setMainProc=function(processor){_mainProc=processor;};export const install=function(){if(!_enabled){_realOpen=XMLHttpRequest.prototype.open;XMLHttpRequest.prototype.open=function(method,url,async,user,password){_xhrCounter++;//Try to add as early as possible to avoid pre-finishing pollyfill\n_realOpen.call(this,method,url,async,user,password);this.requestURL=url;};_xhrSender=XMLHttpRequest.prototype.send;XMLHttpRequest.prototype.send=function(data){let xhr=this;_xhrCounter++;// Side Effect fix (helper) - More accurate to have +1 on open and +1 on send and then -2 on receive response\nxhr.addEventListener('readystatechange',function(){if(xhr.readyState===4){_xhrCounter-=2;_procs.forEach(proc=>{try{proc.done();}catch(error){logger.warn(error);}});}},true);/**\n             * Only wrap the function if there is an 'onload' function to wrap (i.e. NOT trying to do a\n             * Socket.IO/WebSocket call which has no such function).\n             */if(jsService.enabled()&&xhr.onload){xhr.onload=jsService.wrapFunction(xhr,xhr.onload,xhr.requestURL);}try{if(_mainProc){_mainProc(xhr,data);}}catch(error){logger.warn(error);}// procs\n_procs.forEach(proc=>{try{proc.start();}catch(error){logger.warn(error);}});_xhrSender.call(xhr,data);};_enabled=true;}};export const uninstall=function(){return true;};export const addProc=function(proc){_procs.push(proc);};export const removeProc=function(proc){_procs=_procs.filter(procObj=>proc!==procObj);};export default{getCount,setMainProc,install,uninstall,addProc,removeProc};","map":null,"metadata":{},"sourceType":"module"}