{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Service to fetch extended type icons Requires typeIconsRegistry.json definition at each module level.\n *\n * @module js/typeIconsRegistryService\n */import cmm from'soa/kernel/clientMetaModel';import cdm from'soa/kernel/clientDataModel';import adapterService from'js/adapterService';import _ from'lodash';import expressionParserUtils from'js/expressionParserUtils';import cfgSvc from'js/configurationService';let exports;let _typeIconsRegistry;/**\n * Returns the custom icon registered against current vmo\n * @param {Object} type --- json type\n * @param {Object} modelType -- ModelType name or array\n * @param { viewmodelObject } obj --- In case of dataparser when modelType and typeHierarchy provided on VMO\n *\n * @return {String} Name of icon to be used against current vmo\n */export let isObjOfAnyTypeNames=function(type,modelType,obj){var isValid=false;if(type.names){for(var i=0;i<type.names.length;i++){let typeName=type.names[i];// If the type is purely a client view model object\nif(type.isClientViewModelObject===true&&modelType===typeName){isValid=true;}else{isValid=cmm.isInstanceOf(typeName,modelType);}if(!isValid&&obj&&obj.typeHierarchy&&obj.typeHierarchy.indexOf(typeName)>-1){isValid=true;}if(isValid){return true;}}}return isValid;};export let getIconForType=function(type,obj){if(type.names&&obj&&obj.modelType&&obj.modelType.name&&obj.props){// If the type configured in json matches with the object which is being evaluated\nvar isValid=exports.isObjOfAnyTypeNames(type,obj.modelType,obj);if(isValid){/* -\n             * If its a valid sub type,( in order)\n             *     1. check if a icon file name has been associated\n             *     2. if a property has been mentioned\n             *     3. If a condition has been mentioned to evaluate the property\n             *     4. If a nested type has been mentioned for a property\n            -*/if(type.iconFileName){return type.iconFileName+'.svg';}else if(type.prop&&type.prop.names){var prop=type.prop;var propNames=prop.names;var conditionVerdict=false;for(var index in propNames){var propName=propNames[index];var vmoPropVal=obj.props[propName];if(vmoPropVal){if(prop.conditions&&prop.iconFileName){conditionVerdict=expressionParserUtils.evaluateConditions(prop.conditions,obj);if(conditionVerdict){break;}}else if(prop.type){// it expects a property to have a OBJECT type of value only\nvar refObjUid=null;if(vmoPropVal.dbValue){refObjUid=vmoPropVal.dbValue;}else if(vmoPropVal.dbValues&&vmoPropVal.dbValues.length>0){refObjUid=vmoPropVal.dbValues[0];}var isType=cmm.isTypeUid(refObjUid);if(isType){var typeObj=cmm.getType(refObjUid);if(typeObj){return cmm.getTypeIconFileName(typeObj);}}else{var refObj=cdm.getObject(refObjUid);if(refObj){//call getCustomIcon to ensure type icon configuration on \"nested\" type is honored\n//if that returns null revert to previous behavior\nreturn exports.getIconForType(prop.type,refObj);}}}}else{// this means property is not loaded in client\n}}if(prop.conditions&&prop.iconFileName){if(conditionVerdict){return prop.iconFileName+'.svg';}}}else{return cmm.getTypeIconFileName(obj.modelType);}}}return null;};/**\n * Returns the custom thumbnail current vmo based on thumbnail configuration\n * @param {Object} type - the registry entry\n * @param {Object} obj - the vmo\n *\n * @return {Object} vmo containing the thumbnail information\n */export let getVmoForThumbnail=function(type,obj){if(type.names&&obj&&obj.modelType){// If the type configured in json matches with the object which is being evaluated\nvar isValid=exports.isObjOfAnyTypeNames(type,obj.modelType,obj);if(isValid){if(type.prop&&type.prop.names){var prop=type.prop;var propNames=prop.names;for(var index in propNames){var propName=propNames[index];var vmoPropVal=obj.props[propName];if(vmoPropVal){if(prop.type){// it expects a property to have a OBJECT type of value only\nvar refObjUid=null;if(vmoPropVal.dbValue){refObjUid=vmoPropVal.dbValue;}else if(vmoPropVal.dbValues&&vmoPropVal.dbValues.length>0){refObjUid=vmoPropVal.dbValues[0];}var isType=cmm.isTypeUid(refObjUid);if(isType){// invalid case\n}else{var refObj=cdm.getObject(refObjUid);if(refObj){return exports.getVmoForThumbnail(prop.type,refObj);}}}}else{// this means property is not loaded in client\n}}}else{return obj;}}}return null;};/**\n * Returns the custom thumbnail registered against current vmo\n *\n * @param {Object} vmo - the vmo to get custom thumbnail for\n *\n * @return {Object} vmo on which thumbnail information is present\n */export let getCustomVmoForThumbnail=function(vmo){var customVmo=null;if(vmo&&vmo.modelType){_.forEach(_typeIconsRegistry,function(typeObj){if(typeObj&&typeObj.thumbnail){customVmo=exports.getVmoForThumbnail(typeObj.thumbnail,vmo);if(customVmo){return false;// break\n}}return undefined;});}return customVmo;};/**\n * Returns the custom icon registered against current vmo\n *\n * @param {Object} vmo - the vmo to check\n *\n * @return {String} Name of icon to be used against current vmo\n */export let getCustomIcon=function(vmo){var finalTypeIconFileName=null;var finalPriority=-1;let adaptedObj=null;let adaptedRequired=vmo.type!==getPropsObjectType(vmo);if(adaptedRequired){adaptedObj=adapterService.getAdaptedObjectsSync([vmo])[0];}let relevantDefinitions=getRelevantDefs(vmo,adaptedObj);if(vmo&&vmo.modelType&&relevantDefinitions.length>0){relevantDefinitions.sort(function(def1,def2){let priority1=def1.priority?def1.priority:1;let priority2=def2.priority?def2.priority:1;return priority1<priority2?1:-1;});_.forEach(relevantDefinitions,function(typeObj){if(typeObj&&typeObj.type){/* If the current priority is greater than priority of any consecutive definitions, don't need to evaluate... */var currPriority=typeObj.priority?typeObj.priority:1;if(finalPriority>currPriority){return;}var currTypeIconName=null;if(adaptedRequired){var adaptedIcon=exports.getIconForType(typeObj.type,adaptedObj);if(adaptedIcon){currTypeIconName=adaptedIcon;currPriority=typeObj.priority?typeObj.priority:currPriority+1;}}if(!currTypeIconName){currTypeIconName=exports.getIconForType(typeObj.type,vmo);}if(currTypeIconName&&currPriority>finalPriority){finalPriority=currPriority;finalTypeIconFileName=currTypeIconName;}}});}return finalTypeIconFileName;};/**\n * Example Case ( List with Summary View, Summary view has 1 objectset table )\n * --------------------------------------------------\n * | Home Folder           |    XRT Objectset Table |\n * |                       |                        |\n * |     SomeItemName123   |        SomeItemName123 |\n * |                       |                        |\n * |                       |                        |\n * --------------------------------------------------\n *\n * Inside of PWA ( List ) the type of \"SomeItemName123\" = ItemRevision\n * Inside of SWA ( Objectset table ) the type of \"SomeItemName123\" = Awp0XRTObjectSet\n *\n * Both items need to be able to utilize the custom icon definition for \"ItemRevision\"\n * Adapting objects is expensive, so check to see if needs to be adapted before doing it anyway.\n * If vmo.props.object_type is equal to vmo.type, adaption is not needed\n * If somewhere along the path is not defined, adaption may be required.\n * If path is present and vmo.type !== vmo.props.object_type, adaption is definitely required.\n * @param {Object} vmo - the vmo to check\n *\n * @returns {String} - undefined or string type of VMO adapted options\n */function getPropsObjectType(vmo){let objectType;if(vmo.props&&vmo.props.object_type){let ot=vmo.props.object_type;if(ot.dbValue){objectType=ot.dbValue;}else if(ot.dbValues&&ot.dbValues.length>0){objectType=ot.dbValues[0];}}if(!objectType&&vmo.modelType&&vmo.modelType.parentTypeName){objectType=vmo.modelType.parentTypeName;}return objectType;}/**\n * Gets the typeHierarchy array from object\n * @param {Object} dataObject - The VMO/Object to get type Hierarchy array from\n *\n * @returns {Array|null} - Returns the typeHierarchyArry or null if non-existent\n */let getTypeHierarchyArray=function(dataObject){if(dataObject){if(dataObject.modelType&&dataObject.modelType.typeHierarchyArray){return dataObject.modelType.typeHierarchyArray;}else if(dataObject.typeHierarchy){return dataObject.typeHierarchy;}else if(dataObject.type){return[dataObject.type];}}return null;};/**\n * Gets the relevant definitions from teh typeIconsRegistry\n *\n * @param {Object} vmo - the view model object\n * @param {Object|null} adaptedObj - The adaptedObject or null\n *\n * @returns {Object[]} - relevant typeIconsRegistry definitions\n */let getRelevantDefs=function(vmo,adaptedObj){const typesToCheck=new Set();const vmoTypeHierarchyArr=getTypeHierarchyArray(vmo);if(vmoTypeHierarchyArr){for(let i=0;i<vmoTypeHierarchyArr.length;i++){typesToCheck.add(vmoTypeHierarchyArr[i]);}}if(adaptedObj){let adaptedTypeHierarchyArr=getTypeHierarchyArray(adaptedObj);if(adaptedTypeHierarchyArr){for(let j=0;j<adaptedTypeHierarchyArr.length;j++){typesToCheck.add(adaptedTypeHierarchyArr[j]);}}}return _typeIconsRegistry.filter(o=>{if(o.type&&o.type.names){// Check if any items in set are valid here, best way is loop through the registry entry names,\n// Since there are generally only one or two items in each, so this will be faster\nfor(let k=0;k<o.type.names.length;k++){if(typesToCheck.has(o.type.names[k])){return true;}}}return false;});};/**\n * Loads the type Icons registry configuration\n */export let loadConfiguration=function(){//  FIXME this should be loaded async but before the sync API below that uses it is called\nconst typeIconsRegistryCfg=cfgSvc.getCfgCached('typeIconsRegistry');_typeIconsRegistry=typeIconsRegistryCfg?typeIconsRegistryCfg:[];};exports={isObjOfAnyTypeNames,getIconForType,getVmoForThumbnail,getCustomVmoForThumbnail,getCustomIcon,loadConfiguration};export default exports;loadConfiguration();","map":null,"metadata":{},"sourceType":"module"}