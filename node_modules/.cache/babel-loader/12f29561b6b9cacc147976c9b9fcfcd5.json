{"ast":null,"code":"/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the popup code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/popupUtils\n */\nimport _ from 'lodash';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport browserUtils from 'js/browserUtils'; // import eventBus from 'js/eventBus';\n// import panelContentService from 'js/panelContentService';\n\nimport { checkResize, resizeDetector } from 'js/resizeDetector';\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport declUtils from 'js/declUtils';\nimport Draggable from 'js/draggable';\nimport keyCode from 'js/keyCode';\nimport wcagSvc from 'js/wcagService';\nimport { FLATPICKR_ID } from 'js/dateTimeService';\nvar exports = {};\nvar TOOLTIP_POPUP_CSS = 'sw-popup-tooltip sw_popup_easein';\n/**\n * The ammount the input box is allowed to move to the left/right before the UI popup (e.g. calendar, LOV ) is collapsed/hidden.\n */\n\nvar _MAX_X = 40;\nvar _MAX_Y = 40;\nvar POPUP_ID_ATTRIBUTE = 'data-popup-id'; // eslint-disable-next-line one-var\n\n/**\n * A reference to a created panel. This reference contains with properties/functions used to control the panel.\n * @param {!Object} panelEl the panelEl to wrap\n * @param {!Object} options the panel options\n * @final @constructor\n */\n\nfunction PanelRef(panelEl, options) {\n  this.id = getId(panelEl, options.forceUid);\n  this.panelEl = panelEl;\n  this.options = options;\n  this.isAttached = false;\n  this._removeListeners = [];\n  this.interceptors = {};\n}\n\n_c3 = PanelRef;\n_c = PanelRef;\n\nPanelRef.prototype.initialize = function () {\n  this.updateBackReference(true);\n  activateLifeCycleHooks(this);\n  addEventListeners(this);\n  processEnablers(this);\n  processMultipleLevel(this);\n};\n\nPanelRef.prototype.clear = function () {\n  this.updateBackReference();\n  removeEventListeners(this);\n};\n\nPanelRef.prototype.attach = function () {\n  this.initialize();\n  this.triggerHook('open'); // onMount && onMount();\n\n  this.isAttached = true;\n};\n\nPanelRef.prototype.detach = function () {\n  this.clear();\n  this.triggerHook('close');\n  this.interceptors = {}; // Remove the DOM reference\n\n  this.panelEl = null;\n  this.isAttached = false;\n};\n\nPanelRef.prototype.updateBackReference = function (isAdd) {\n  if (!this.options.reference) {\n    return;\n  }\n\n  var referenceEl = this.options.reference;\n  var value = isAdd ? this.id : '';\n  referenceEl.setAttribute(POPUP_ID_ATTRIBUTE, value);\n};\n/**\n * Schedules an update. It will run on the next UI update available.\n */\n\n\nPanelRef.prototype.scheduleUpdate = function () {\n  requestAnimationFrame(() => {\n    this.options.api.updatePosition();\n  });\n};\n\nPanelRef.prototype.update = function () {\n  let newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return this.options.api.update(this, newOptions, force);\n};\n\nPanelRef.prototype.canClose = function () {\n  return this.options && !this.options.disableClose;\n};\n\nPanelRef.prototype.hide = function () {\n  let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (force || !force && this.canClose()) {\n    let popupRef = this;\n\n    if (popupRef.parentPopup) {\n      //Update Next ref\n      if (popupRef.nextPopup) {\n        popupRef.parentPopup.nextPopup = popupRef.nextPopup;\n        popupRef.nextPopup.parentPopup = popupRef.parentPopup;\n      } else {\n        popupRef.parentPopup.nextPopup = null;\n      }\n    }\n\n    return this.options.api.hide(this);\n  }\n};\n\nPanelRef.prototype.triggerHook = function (type) {\n  if (['open', 'update', 'close'].indexOf(type) === -1) {\n    return;\n  }\n\n  _.each(this.interceptors[type], item => {\n    item(this);\n  });\n};\n\nexport { PanelRef };\n/**\n * A panel manager to track and manage all panel reference .\n * @final @constructor\n */\n\nfunction PopupManager() {\n  this._previousPopupRef = null;\n  this._popupMaps = {};\n}\n\n_c4 = PopupManager;\n_c2 = PopupManager;\n\nPopupManager.prototype.get = function (id) {\n  if (id && this._popupMaps[id]) {\n    return this._popupMaps[id];\n  }\n\n  return null;\n};\n\nPopupManager.prototype.add = function (panelRef) {\n  if (!panelRef) {\n    return;\n  }\n\n  var id = panelRef.id;\n  let isPanelRefTooltip = panelRef.panelEl && panelRef.panelEl.querySelector('.sw-popup-tooltip.sw-popup-easein') !== null;\n\n  if (!this._popupMaps[id]) {\n    let validPanelRef = null;\n\n    for (const k of Object.keys(this._popupMaps).reverse()) {\n      let validEl = dom.get('.aw-widgets-groupCommandStack', this._popupMaps[k].panelEl); // during keyboard navigation, reference of next and parent popup should not be\n      // maintained if panelRef is an extended tooltip\n      // reference of next and parent popup should not be maintained if panelRef is a tooltip\n\n      if (validEl !== null && !isPanelRefTooltip) {\n        validPanelRef = this._popupMaps[k];\n        break;\n      }\n    }\n\n    if (validPanelRef !== null) {\n      // Maintain reference of next and parent popup\n      validPanelRef.nextPopup = panelRef;\n      panelRef.parentPopup = validPanelRef;\n    }\n\n    this._popupMaps[id] = panelRef;\n  }\n};\n\nPopupManager.prototype.remove = function (panelRef) {\n  if (!panelRef) {\n    return;\n  }\n\n  var id = panelRef.id;\n  this._popupMaps[id] && delete this._popupMaps[id];\n};\n\nObject.defineProperty(PopupManager.prototype, 'previousPopupRef', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return this._previousPopupRef;\n  },\n  set: function (value) {\n    this._previousPopupRef = value;\n  }\n});\nexport { PopupManager };\nexport let handleOpenedPopup = function (referenceEl, manager) {\n  let toggleMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var id = referenceEl ? referenceEl.getAttribute(POPUP_ID_ATTRIBUTE) : null;\n  var popupRef = manager.get(id);\n\n  if (id && toggleMode) {\n    popupRef.hide();\n    return null;\n  } else if (id) {\n    // force bring to foreground by hoist z-index or\n    // force bring to foreground by re-append (safe and easy way)\n    dom.append(popupRef.panelEl);\n    return popupRef;\n  }\n\n  return true;\n};\n\nfunction removeEventListeners(panelRef) {\n  panelRef._removeListeners && panelRef._removeListeners.forEach(function (removeFn) {\n    removeFn();\n  });\n  panelRef._removeListeners = [];\n}\n\nfunction processEnablers(popupRef) {\n  let options = popupRef.options;\n  let {\n    draggable,\n    draggableInitializeDelay = 200\n  } = options;\n\n  if (!draggable) {\n    return;\n  } // contents maybe async loaded, handle maybe not ready(exist) yet.\n\n\n  setTimeout(() => {\n    let popupEl = popupRef.panelEl;\n\n    if (popupEl) {\n      let dragElement = dom.get('.sw-popup-layout', popupEl);\n      let headerElement = dom.get('.aw-layout-panelTitle, .panel-header', popupEl);\n      let handle = undefined;\n\n      if (options.handle) {\n        handle = dom.get(options.handle, popupEl);\n      } else if (headerElement) {\n        handle = headerElement;\n      } else {\n        handle = dragElement;\n      }\n\n      let dragger = new Draggable(dragElement, {\n        handle,\n        limit: document.body,\n        setCursor: true,\n        className: options.draggableClassName || 'sw-popup-draggable',\n        // LCS-337929: expect popup to remain where it was dragged\n        // add flag 'disableUpdate' to prevent auto update position if have been dragged\n        onDragStart: function () {\n          options.disableUpdate = true; // remove right / bottom to ensure element draggable\n\n          options.advancePositioning && dom.setStyles(dragElement, {\n            right: null,\n            bottom: null\n          });\n        }\n      });\n\n      popupRef._removeListeners.push(dragger.destroy.bind(dragger));\n    }\n  }, draggableInitializeDelay);\n} // MultipleLevel popup command bar case:\n// build cascade MultipleLevel popup menus\n// and define the event ignore list between them\n\n\nfunction processMultipleLevel(popupRef) {\n  let {\n    options,\n    panelEl\n  } = popupRef;\n  let {\n    reference,\n    manager,\n    processNested,\n    preset\n  } = options; // exclude tooltip process\n\n  if (preset && preset === 'tooltip') {\n    return;\n  }\n\n  if (processNested === false || !reference || !manager) {\n    return;\n  } // add current popup to ignore click list of all up Level popups\n\n\n  let parentPopup = dom.closest(reference, 'div.sw-popup');\n\n  while (parentPopup && reference && manager) {\n    let ref = manager.get(parentPopup.id);\n    ref.options.ignoreClicksFrom = ref.options.ignoreClicksFrom || [];\n    ref.options.ignoreClicksFrom.push(panelEl); // check upper level recursively\n\n    reference = ref.options.reference;\n    manager = ref.options.manager;\n    parentPopup = dom.closest(reference, 'div.sw-popup');\n  }\n}\n\nfunction autoFocus(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n\n  if (options.autoFocus !== false) {\n    getContainerElement(popupEl).focus();\n  }\n}\n\nconst hookHash = {\n  whenOpened: 'open',\n  whenUpdated: 'update',\n  whenClosed: 'close'\n};\n\nconst getHookKey = key => key.replace(/whenOpened|whenUpdated|whenClosed/g, matched => hookHash[matched]);\n\nfunction activateLifeCycleHooks(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n\n  if (_.isObject(options.hooks)) {\n    var interceptors = popupRef.interceptors; // support hooks in array\n\n    _.each(options.hooks, function (value, key) {\n      const v = [].concat(value || []);\n      const k = getHookKey(key);\n      k && (interceptors[k] = v);\n    });\n  } // TODO\n  // // ensure close any orphan popup in case scope was destroyed\n  // var scope = ngUtils.getElementScope( popupEl );\n  // scope.$on( '$destroy', function () {\n  //     // clear this flag so that this popup could be closed.\n  //     delete options.disableClose;\n  //     popupRef.panelEl && options.api.hide( popupEl );\n  // } );\n\n}\n/**\n *\n * @param {JQLite} popupRef The panel element.\n */\n\n\nfunction addEventListeners(popupRef) {\n  configureAutoFocusAndLoopTabbable(popupRef);\n  configureWatchSizeChange(popupRef);\n  configureEscapeToClose(popupRef);\n  configureClickOutsideToClose(popupRef);\n  configureScrollListener(popupRef);\n  configureResizeListener(popupRef);\n}\n\nfunction configureAutoFocusAndLoopTabbable(popupRef) {\n  const {\n    options,\n    panelEl,\n    interceptors,\n    _removeListeners\n  } = popupRef;\n  const {\n    autoFocus\n  } = options;\n\n  if (autoFocus !== false) {\n    const dialogNode = getContentContainer(panelEl);\n    const {\n      removeHandlers,\n      onClose\n    } = wcagSvc.configureAutoFocus(dialogNode, popupRef);\n\n    _removeListeners.push(...removeHandlers);\n\n    interceptors.close.push(onClose);\n  }\n}\n\nfunction configureWatchSizeChange(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl; // ease the cost, or will cause mouseenter/mouseleave flickering issue in tooltip\n\n  var debouncedUpdatePosition = throttle(options.api.updatePosition);\n  var listener = addWatchHandle(popupEl, function () {\n    debouncedUpdatePosition();\n  }); // Queue remove listeners function\n\n  popupRef._removeListeners.push(listener);\n}\n\nfunction configureEscapeToClose(popupRef) {\n  var options = popupRef.options;\n\n  const handleEscape = event => {\n    if (popupRef && popupRef.options && popupRef.options.customClass !== TOOLTIP_POPUP_CSS) {\n      let key = event.key || event.keyCode;\n\n      if (key === keyCode.ESCAPE && options.closeWhenEsc !== false && declUtils.isNil(popupRef.nextPopup)) {\n        event.stopPropagation();\n        popupRef.hide();\n        wcagSvc.skipToFirstFocusableElement(options.reference);\n      }\n    }\n  }; // Add listeners\n\n\n  document.addEventListener('keyup', handleEscape); // Queue remove listeners function\n\n  popupRef._removeListeners.push(() => {\n    document.removeEventListener('keyup', handleEscape);\n  });\n}\n\nfunction checkIgnore(options, sourceEl) {\n  var set = options.ignoreClicksFrom || [];\n\n  if (options.ignoreClicksFrom) {\n    // force convert to array\n    set = [].concat(set);\n  }\n\n  if (options.ignoreReferenceClick && options.reference) {\n    set.push(options.reference);\n  }\n\n  var found = set.find(item => {\n    let element = getElement(item);\n\n    if (element && (element === sourceEl || element.contains(sourceEl))) {\n      return true;\n    }\n\n    return false;\n  });\n  return Boolean(found);\n}\n\nfunction configureClickOutsideToClose(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var target = options.parent;\n  var reference = options.reference;\n\n  if (options.clickOutsideToClose) {\n    var sourceEl; // Keep track of the element on which the mouse originally went down\n    // so that we can only close the backdrop when the 'click' started on it.\n    // A simple 'click' handler does not work, it sets the target object as the\n    // element the mouse went down on.\n    // var mousedownHandler = function( ev ) {\n    //     sourceEl = ev.target;\n    // };\n    // We check if our original element and the target is the backdrop\n    // because if the original was the backdrop and the target was inside the\n    // panel we don't want to panel to close.\n\n    var clickHandler = function (ev) {\n      if (isTooltipClick(ev) || isNotyClick(ev) || isCalendarClick(ev)) {\n        return;\n      } // We check if the sourceEl of the event is the panel element or one\n      // of it's children. If it is not, then close the panel.\n\n\n      sourceEl = ev.target;\n\n      if (sourceEl !== popupEl && !popupEl.contains(sourceEl) && !isTooltipClick(sourceEl)) {\n        if (!checkIgnore(options, sourceEl)) {\n          options.api.hide(popupRef);\n        }\n      }\n    }; // Add listeners\n\n\n    dom.on(target, 'click,contextmenu', clickHandler, true); // Queue remove listeners function\n\n    popupRef._removeListeners.push(function () {\n      dom.off(target, 'click,contextmenu', clickHandler, true);\n    });\n  }\n}\n\nconst isTooltipClick = event => dom.closest(event.target, '.sw-popup-tooltip');\n\nconst isNotyClick = event => dom.closest(event.target, '#noty_bottom_layout_container');\n\nconst isCalendarClick = event => dom.closest(event.target, FLATPICKR_ID); // function isTooltipClick( sourceEl ) {\n//     let tooltip = dom.closest( sourceEl, '.sw-popup-tooltip' );\n//     return Boolean( tooltip );\n// }\n\n\nfunction configureResizeListener(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var handler = null;\n\n  if (options.resizeToClose) {\n    var debouncedHide = throttle(options.api.hide);\n\n    handler = () => {\n      debouncedHide(popupRef);\n    };\n  } else {\n    var debouncedUpdatePosition = throttle(options.api.updatePosition);\n\n    handler = () => {\n      debouncedUpdatePosition();\n    };\n  } // // Add listeners, use framework's event 'windowResize' instead of native event 'resize'\n  // var scope = ngUtils.getElementScope( popupEl );\n  // var removeListener = scope.$on( 'windowResize', handler );\n  // // Queue remove listeners function\n  // popupRef._removeListeners.push( function () {\n  //     removeListener();\n  // } );\n  // if ( options.listenAreaChanges !== false ) {\n  //     // FUTURE: use reference element's resize event, which needs framework's support.\n  //     var sub = eventBus.subscribe( 'aw-splitter-update', handler );\n  //     popupRef._removeListeners.push( () => { eventBus.unsubscribe( sub ); } );\n  // }\n  // FUTURE: use reference element's resize/move event, which needs framework's support.\n  // Add listeners\n\n\n  window.addEventListener('resize', handler); // Queue remove listeners function\n\n  popupRef._removeListeners.push(() => {\n    window.removeEventListener('resize', handler);\n  });\n}\n/**\n * Firefox and Qt browser have scroll issues: scroll event is firing multiple times even when mouse moves or hover on any element\n * Solution: for these browser, need to remember the last reported scroll position and check it against each new reported scroll position\n *\n * @returns {boolean} result - true for Firefox or Qt browser, false for others\n */\n\n\nfunction checkBrowser() {\n  return browserUtils.isFirefox || browserUtils.isQt;\n}\n\nfunction checkOutsideScrollEvent(event, popupEl) {\n  var path = eventPath(event);\n  return _.indexOf(path, popupEl) === -1;\n}\n\nfunction checkAncestorScrollEvent(event, popupEl, options) {\n  let {\n    reference,\n    useOutsideScrollEvent\n  } = options;\n\n  if (!reference || useOutsideScrollEvent) {\n    return checkOutsideScrollEvent(event, popupEl);\n  }\n\n  let path = composedPath(reference);\n  return _.indexOf(path, event.target) !== -1;\n}\n\nfunction configureScrollListener(popupRef) {\n  var options = popupRef.options;\n  var popupEl = popupRef.panelEl;\n  var onScroll;\n  var target = null;\n  var onScrollWrapper = null;\n\n  if (options.closeWhenParentScroll) {\n    var debouncedHide = throttle(options.api.hide);\n\n    var processScrollEvent = function (event) {\n      debouncedHide(popupRef);\n    };\n\n    var checkScrollPosition = function (target) {\n      var oldY = target.scrollTop;\n      var oldX = target.scrollLeft;\n\n      var wrapper = function (event) {\n        if (event.target !== target) {\n          return;\n        }\n\n        var curY = event.target.scrollTop;\n        var curX = event.target.scrollLeft;\n\n        if (Math.abs(oldX - curX) > _MAX_X || Math.abs(oldY - curY) > _MAX_Y) {\n          oldX = curX;\n          oldY = curY;\n          processScrollEvent(event);\n        }\n      };\n\n      window.removeEventListener('scroll', onScroll, true);\n      target.addEventListener('scroll', wrapper, true);\n      return wrapper;\n    };\n\n    onScroll = function (event) {\n      // skip if scroll happens inside any ancestor node or an input field (like sibling lov case)\n      if (!checkAncestorScrollEvent(event, popupEl, options) || event.target.tagName === 'INPUT') {\n        return;\n      } // Firefox issue: scroll event is firing multiple times even when mouse moves or hover on any element\n      // Solution: need to remember the last reported scroll position and check it against each new reported scroll position\n\n\n      if (checkBrowser()) {\n        target = event.target;\n        onScrollWrapper = checkScrollPosition(target);\n        return;\n      }\n\n      processScrollEvent(event);\n    };\n  } else if (options.followParentScroll) {\n    var debouncedUpdatePosition = throttle(options.api.updatePosition);\n\n    onScroll = function (event) {\n      if (checkAncestorScrollEvent(event, popupEl, options)) {\n        debouncedUpdatePosition();\n      }\n    };\n  }\n\n  if (onScroll) {\n    // Add listeners.\n    window.addEventListener('scroll', onScroll, true); // Queue remove listeners function.\n\n    popupRef._removeListeners.push(function () {\n      window.removeEventListener('scroll', onScroll, true);\n\n      if (checkBrowser() && target) {\n        target.removeEventListener('scroll', onScrollWrapper, true);\n      }\n    });\n  }\n}\n\nexport let getContainerElement = function (popupEl) {\n  return dom.get('.sw-popup-layout', popupEl);\n};\n\nconst getContentContainer = function (popupEl) {\n  // eslint-disable-next-line sonarjs/no-duplicate-string\n  return dom.get('.sw-popup-contentContainer', popupEl);\n};\n\nexport let processOptions = function (popupEl, options) {\n  var container = getContainerElement(popupEl);\n\n  if (!container) {\n    return;\n  }\n\n  if (options.customClass) {\n    let customClasses = options.customClass.split(/\\s+|,/);\n    customClasses.forEach(i => {\n      dom.addClass(container, i);\n    });\n  }\n\n  var sizeCss = {};\n  var needUpdateStyle = false;\n\n  if (options.containerWidth) {\n    sizeCss.width = options.containerWidth;\n    sizeCss['max-width'] = null;\n    needUpdateStyle = true;\n  }\n\n  if (options.containerHeight) {\n    sizeCss.height = options.containerHeight;\n    sizeCss['max-height'] = null;\n    needUpdateStyle = true;\n  }\n\n  needUpdateStyle && dom.setStyles(container, sizeCss);\n};\nexport let getTemplateFromUrl = function (url) {\n  return AwHttpService.instance.get(url, {\n    cache: true\n  }).then(response => response.data).catch(() => AwPromiseService.instance.reject(url + ' type \"url\" not found! please check your resource!'));\n};\nexport let getTemplateFromView = function (viewId, contextScope) {// var subPanelContext = contextScope ? contextScope.subPanelContext : null;\n  // return panelContentService.getPanelContent( viewId )\n  //     .catch( () => AwPromiseService.instance.reject( viewId + ' type \"declView\" not found! please check your resource!' ) )\n  //     .then( ( viewAndViewModelResponse ) => {\n  //         return viewModelService.populateViewModelPropertiesFromJson( viewAndViewModelResponse.viewModel, false, null, null, null, subPanelContext )\n  //             .then( ( declarativeViewModel ) => {\n  //                 viewModelService.setupLifeCycle( contextScope, declarativeViewModel );\n  //                 // align lifecycleHooks\n  //                 contextScope._onMount = () => {\n  //                     let onMountAction = _.get( contextScope, 'data._internal.lifecycleHooks.onMount' );\n  //                     onMountAction && viewModelService.executeCommand( contextScope.data, onMountAction, contextScope );\n  //                 };\n  //                 // Legacy compatible: application are listening this event to retrieve data for that view\n  //                 let modelId = _.get( contextScope, 'data._internal.modelId' ) || '?';\n  //                 eventBus.publish( viewId + '.contentLoaded', { scope: contextScope, _source: modelId } );\n  //                 return AwPromiseService.instance.resolve( viewAndViewModelResponse.view );\n  //             } );\n  //     } );\n};\n\nfunction getId(panelEl, forceUid) {\n  if (!panelEl) {\n    return null;\n  } // force generate uid if\n  // 1, not have a id\n  // 2, multiple mode open\n\n\n  if (forceUid && panelEl.id) {\n    panelEl.id = '';\n  }\n\n  if (!panelEl.id) {\n    dom.uniqueId(panelEl);\n  }\n\n  return panelEl.id;\n}\n/**\n * get the element\n *\n * @param {Element | String} element - can be an Element, or query string\n * @returns {Element} element\n */\n\n\nexport let getElement = function (element) {\n  if (_.isString(element)) {\n    element = dom.get(element);\n  }\n\n  return element;\n}; // ONLY FOR declarative usage due to principle: CSS selectors should not be exposed to view model\n// extend selector by add id sign\n\nexport let extendSelector = function (element) {\n  var reValidSelector = /^(\\.|#|aw)/i;\n\n  if (_.isString(element) && !reValidSelector.test(element)) {\n    element = element + ', #' + element;\n  }\n\n  return element;\n};\nexport let getArrowElement = function (popupEl) {\n  return dom.get('.sw-popup-arrow', popupEl);\n};\n\nfunction addWatchHandle(popupEl, cb) {\n  let containerEl = getContainerElement(popupEl);\n\n  let fn = () => {\n    if (cb && _.isFunction(cb)) {\n      cb();\n    }\n  };\n\n  return resizeDetector(containerEl, fn);\n} // provide opportunity for user to specify the resizeContainer selector\n\n\nexport let getResizeContainer = function (element, containerSelector) {\n  if (containerSelector && dom.match(element, containerSelector)) {\n    return element;\n  }\n\n  let selector = containerSelector || '.aw-base-scrollPanel';\n\n  if (!containerSelector && dom.get('.sw-popup-contentContainer', element)) {\n    selector = '.sw-popup-contentContainer';\n  }\n\n  return dom.get(selector, element);\n};\nexport let getMousePosition = function (event) {\n  let target = {\n    clientX: 0,\n    clientY: 0\n  };\n\n  if (event) {\n    target = event;\n\n    if (_.isUndefined(event.clientX)) {\n      target = event.touches[0];\n    }\n  }\n\n  let {\n    clientX,\n    clientY\n  } = target;\n  return {\n    x: clientX,\n    y: clientY\n  };\n}; // it implements a window frame based throttle function to ease intensively triggered window events.\n// motivation is to improve performance, to ensure callback will only be fired once per frame for intensively triggered window events.\n// references: $mdDialog using a throttle decorator to decorate $$rAF service. popper.js implement it's own window frame based throttle method.\n\nfunction throttle(fn) {\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n  var supportsMicroTasks = isBrowser && window.Promise; // eslint-disable-next-line one-var\n\n  var queuedArgs, alreadyQueued, queueCb, context;\n\n  var microtaskThrottle = function (fn) {\n    alreadyQueued = false;\n    return function throttled() {\n      queuedArgs = arguments;\n      context = this;\n      queueCb = fn;\n\n      if (alreadyQueued) {\n        return;\n      }\n\n      alreadyQueued = true;\n      window.Promise.resolve().then(() => {\n        alreadyQueued = false;\n        queueCb.apply(context, Array.prototype.slice.call(queuedArgs));\n      });\n    };\n  };\n\n  var taskThrottle = function (fn) {\n    var scheduled = false;\n    var task = window.requestAnimationFrame || window.setTimeout;\n    return function throttled() {\n      var queuedArgs = arguments;\n      context = this;\n      queueCb = fn;\n\n      if (!scheduled) {\n        scheduled = true;\n        task(() => {\n          scheduled = false;\n          queueCb.apply(context, Array.prototype.slice.call(queuedArgs));\n        });\n      }\n    };\n  };\n\n  return (supportsMicroTasks ? microtaskThrottle : taskThrottle)(fn);\n}\n\nfunction composedPath(el) {\n  let path = [];\n\n  while (el) {\n    path.push(el);\n\n    if (el.tagName === 'HTML') {\n      path.push(document);\n      path.push(window);\n      return path;\n    }\n\n    el = el.parentElement;\n  }\n\n  return path;\n} // get the event path in dom event bubbling\n\n\nfunction eventPath(event) {\n  var path = event.path || event.composedPath && event.composedPath(); // event.path always has wrong value for Qt browser\n\n  if (!path || browserUtils.isQt) {\n    return composedPath(event.target);\n  }\n\n  return path;\n} // return the first clean node by skip any comment node.\n\n\nexport let cleanNode = nodesArray => {\n  let result = null;\n\n  if (nodesArray && nodesArray.length > 0) {\n    result = _.find(nodesArray, item => {\n      return item.nodeType !== HTMLElement.COMMENT_NODE;\n    });\n  }\n\n  return result;\n}; // verify whether have any plain string content loaded\n\nlet verifyText = node => {\n  return Boolean((node.innerText || '').replace(/\\s|\\r|\\n/g, ''));\n}; // verify whether have any media content loaded\n\n\nlet verifyMedia = node => {\n  return Boolean(dom.get('img, svg', node));\n};\n\nexport let tooltipAdapteStyle = node => {\n  // tooltip expected parent element to have \"display: block\" other than \"display: flex\"\n  dom.removeClass(node, 'aw-layout-flexbox');\n  dom.setStyle(node, 'overflow', 'hidden');\n}; // getLoadingStatus by check transclude / plainHtml contents\n// used for balloon and tooltip\n\nlet getLoadingStatus = (container, adapteStyle) => {\n  let [container_css, transclude_css] = ['.aw-layout-flexColumnContainer', 'aw-include>div.aw-layout-include, div.aw-base-scrollPanel>ng-transclude'];\n  var content = dom.get(container_css, container);\n\n  if (!content) {\n    return false;\n  }\n\n  var transclude = dom.get(transclude_css, content);\n  var transcluded = Boolean(transclude) && Boolean(cleanNode(transclude.childNodes));\n\n  if (transcluded && adapteStyle) {\n    tooltipAdapteStyle(transclude);\n  }\n\n  return verifyText(content) || verifyMedia(content);\n};\n\nexport let runLoadingCheck = function (context, container) {\n  let adapteStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  let loaded = () => getLoadingStatus(container, adapteStyle);\n\n  let apply = function () {\n    let loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    context.loading = loading;\n    context.$apply && context.$apply();\n  };\n\n  return new Promise(resolve => {\n    // defer to next cycle to avoid show loading in cache case\n    setTimeout(() => {\n      let loading = !loaded();\n      apply(loading);\n\n      if (!loading) {\n        resolve();\n        return;\n      }\n\n      let timer = setInterval(() => {\n        if (loaded()) {\n          apply(false);\n        }\n\n        if (!context.loading || !dom.inDOM(container)) {\n          clearInterval(timer);\n          resolve();\n        }\n      }, 50);\n    });\n  });\n};\nconst RESIZE_POLLING_TIMEOUT = 500;\nexport let runResizeCheck = container => {\n  let oldSize = {\n    width: container.offsetWidth,\n    height: container.offsetHeight\n  };\n  let noResizeTimeStart = Date.now();\n  return new Promise(resolve => {\n    let timer = setInterval(() => {\n      if (checkResize(container, oldSize)()) {\n        noResizeTimeStart = Date.now();\n      } else {\n        let noResizeTime = Date.now() - noResizeTimeStart; // size got stable till now, safe to resolve.\n\n        if (noResizeTime > RESIZE_POLLING_TIMEOUT) {\n          clearInterval(timer);\n          resolve();\n        }\n      }\n    }, 50);\n  });\n};\nexport let tooltipProgressCheck = (cb, progress) => {\n  let timer = setInterval(() => {\n    if (!progress.busy) {\n      clearInterval(timer);\n      cb && cb();\n    }\n  }, 50);\n};\nexport let closeExistingTooltip = () => {\n  let nodes = dom.getAll('div.aw-popup-tooltip');\n  let results = dom.getParent(nodes);\n  results && results.length > 0 && dom.remove(results);\n};\n\nlet checkWithinRightSide = node => {\n  return window.innerWidth / 3 - node.getBoundingClientRect().left < 0;\n};\n\nexport let tooltipAdapteOption = (raw, target) => {\n  let result = Object.assign({}, raw); // backward compatible\n\n  if (raw.alignment && !raw.placement) {\n    if (raw.alignment === 'VERTICAL') {\n      result.placement = 'right'; // if target element locate at the right side of the page, then flip the placement\n\n      if (checkWithinRightSide(target)) {\n        result.placement = 'left';\n      }\n    } else if (/^(RIGHT|LEFT)/.test(raw.alignment)) {\n      result.placement = 'right';\n    } else if (/^(TOP|BOTTOM)/.test(raw.alignment)) {\n      result.placement = 'top';\n    }\n  }\n\n  return result;\n};\nexport let processTooltipOptions = (rawOptions, target, popupOpenedCb, popupClosedCb) => {\n  let options = {\n    ownContainer: true,\n    placement: ['top', 'bottom', 'right', 'left'],\n    flipBehavior: 'opposite',\n    whenParentScrolls: 'close',\n    adaptiveShift: true,\n    // prevent tooltip cut off in corner case\n    resizeToClose: true,\n    advancePositioning: true,\n    // prevent overlap or flash when popup content growing\n    hasArrow: true,\n    padding: {\n      x: 4,\n      y: 4\n    },\n    arrowOptions: {\n      alignment: 'center'\n    },\n    reference: target,\n    minSize: 5,\n    forceCloseOthers: false,\n    customClass: 'aw-popup-tooltip aw_popup_easein',\n    hooks: {\n      whenOpened: element => {\n        popupOpenedCb && popupOpenedCb(element);\n      },\n      whenClosed: element => {\n        popupClosedCb && popupClosedCb(element);\n      }\n    }\n  };\n\n  if (_.keys(rawOptions).length > 0) {\n    Object.assign(options, tooltipAdapteOption(rawOptions, target));\n  }\n\n  return options;\n};\nexport let removeNativeTitle = node => {\n  dom.removeAttribute(node, 'title');\n  let results = dom.getAll('[title]', node);\n  results.length > 0 && dom.removeAttribute(results, 'title');\n};\nexports = {\n  POPUP_ID_ATTRIBUTE,\n  PanelRef,\n  PopupManager,\n  handleOpenedPopup,\n  processOptions,\n  getTemplateFromUrl,\n  getTemplateFromView,\n  getElement,\n  checkIgnore,\n  extendSelector,\n  getContainerElement,\n  getArrowElement,\n  getResizeContainer,\n  getMousePosition,\n  cleanNode,\n  runLoadingCheck,\n  runResizeCheck,\n  tooltipProgressCheck,\n  closeExistingTooltip,\n  tooltipAdapteOption,\n  tooltipAdapteStyle,\n  processTooltipOptions,\n  removeNativeTitle,\n  getContentContainer\n};\nexport default exports;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"PanelRef\");\n$RefreshReg$(_c2, \"PopupManager\");\n\nvar _c3, _c4;\n\n$RefreshReg$(_c3, \"PanelRef\");\n$RefreshReg$(_c4, \"PopupManager\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/popup/src/js/popupUtils.js"],"names":["DOMAPIs","exports","TOOLTIP_POPUP_CSS","_MAX_X","_MAX_Y","POPUP_ID_ATTRIBUTE","PanelRef","getId","options","activateLifeCycleHooks","addEventListeners","processEnablers","processMultipleLevel","removeEventListeners","referenceEl","value","isAdd","requestAnimationFrame","newOptions","force","popupRef","_","item","PopupManager","id","panelRef","isPanelRefTooltip","validPanelRef","Object","validEl","dom","enumerable","configurable","get","set","handleOpenedPopup","toggleMode","manager","removeFn","draggableInitializeDelay","setTimeout","popupEl","dragElement","headerElement","handle","dragger","limit","document","setCursor","className","onDragStart","right","bottom","panelEl","preset","processNested","parentPopup","ref","reference","getContainerElement","hookHash","whenOpened","whenUpdated","whenClosed","getHookKey","key","matched","interceptors","v","k","configureAutoFocusAndLoopTabbable","configureWatchSizeChange","configureEscapeToClose","configureClickOutsideToClose","configureScrollListener","configureResizeListener","_removeListeners","autoFocus","dialogNode","getContentContainer","onClose","wcagSvc","debouncedUpdatePosition","throttle","listener","addWatchHandle","handleEscape","event","keyCode","declUtils","found","element","getElement","Boolean","target","clickHandler","isTooltipClick","isNotyClick","isCalendarClick","sourceEl","ev","checkIgnore","handler","debouncedHide","window","browserUtils","path","eventPath","useOutsideScrollEvent","checkOutsideScrollEvent","composedPath","onScrollWrapper","processScrollEvent","checkScrollPosition","oldY","oldX","wrapper","curY","curX","Math","onScroll","checkAncestorScrollEvent","checkBrowser","processOptions","container","customClasses","i","sizeCss","needUpdateStyle","getTemplateFromUrl","cache","response","AwPromiseService","url","getTemplateFromView","forceUid","extendSelector","reValidSelector","getArrowElement","containerEl","fn","cb","resizeDetector","getResizeContainer","containerSelector","selector","getMousePosition","clientX","clientY","x","y","isBrowser","supportsMicroTasks","microtaskThrottle","alreadyQueued","queuedArgs","context","queueCb","Array","taskThrottle","scheduled","task","el","cleanNode","nodesArray","result","HTMLElement","verifyText","node","verifyMedia","tooltipAdapteStyle","getLoadingStatus","content","transclude","transcluded","runLoadingCheck","adapteStyle","loaded","apply","loading","resolve","timer","setInterval","clearInterval","RESIZE_POLLING_TIMEOUT","runResizeCheck","oldSize","width","height","offsetHeight","noResizeTimeStart","Date","checkResize","noResizeTime","tooltipProgressCheck","progress","closeExistingTooltip","nodes","results","checkWithinRightSide","tooltipAdapteOption","raw","processTooltipOptions","ownContainer","placement","flipBehavior","whenParentScrolls","adaptiveShift","resizeToClose","advancePositioning","hasArrow","padding","arrowOptions","alignment","minSize","forceCloseOthers","customClass","hooks","popupOpenedCb","popupClosedCb","removeNativeTitle"],"mappings":"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","sourcesContent":["/* eslint-disable require-jsdoc */\n// Copyright (c) 2020 Siemens\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the popup code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/popupUtils\n */\nimport _ from 'lodash';\nimport { DOMAPIs as dom } from 'js/domUtils';\nimport browserUtils from 'js/browserUtils';\n// import eventBus from 'js/eventBus';\n// import panelContentService from 'js/panelContentService';\nimport { checkResize, resizeDetector } from 'js/resizeDetector';\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport declUtils from 'js/declUtils';\nimport Draggable from 'js/draggable';\nimport keyCode from 'js/keyCode';\nimport wcagSvc from 'js/wcagService';\nimport { FLATPICKR_ID } from 'js/dateTimeService';\n\nvar exports = {};\nvar TOOLTIP_POPUP_CSS = 'sw-popup-tooltip sw_popup_easein';\n\n/**\n * The ammount the input box is allowed to move to the left/right before the UI popup (e.g. calendar, LOV ) is collapsed/hidden.\n */\nvar _MAX_X = 40;\nvar _MAX_Y = 40;\n\nvar POPUP_ID_ATTRIBUTE = 'data-popup-id';\n\n// eslint-disable-next-line one-var\n\n/**\n * A reference to a created panel. This reference contains with properties/functions used to control the panel.\n * @param {!Object} panelEl the panelEl to wrap\n * @param {!Object} options the panel options\n * @final @constructor\n */\nfunction PanelRef( panelEl, options ) {\n    this.id = getId( panelEl, options.forceUid );\n    this.panelEl = panelEl;\n    this.options = options;\n    this.isAttached = false;\n    this._removeListeners = [];\n    this.interceptors = {};\n}\nPanelRef.prototype.initialize = function() {\n    this.updateBackReference( true );\n    activateLifeCycleHooks( this );\n    addEventListeners( this );\n    processEnablers( this );\n    processMultipleLevel( this );\n};\nPanelRef.prototype.clear = function() {\n    this.updateBackReference();\n    removeEventListeners( this );\n};\nPanelRef.prototype.attach = function() {\n    this.initialize();\n    this.triggerHook( 'open' );\n    // onMount && onMount();\n    this.isAttached = true;\n};\nPanelRef.prototype.detach = function() {\n    this.clear();\n    this.triggerHook( 'close' );\n    this.interceptors = {};\n    // Remove the DOM reference\n    this.panelEl = null;\n    this.isAttached = false;\n};\nPanelRef.prototype.updateBackReference = function( isAdd ) {\n    if( !this.options.reference ) { return; }\n    var referenceEl = this.options.reference;\n    var value = isAdd ? this.id : '';\n    referenceEl.setAttribute( POPUP_ID_ATTRIBUTE, value );\n};\n/**\n * Schedules an update. It will run on the next UI update available.\n */\nPanelRef.prototype.scheduleUpdate = function() {\n    requestAnimationFrame( () => {\n        this.options.api.updatePosition();\n    } );\n};\nPanelRef.prototype.update = function( newOptions = null, force = false ) {\n    return this.options.api.update( this, newOptions, force );\n};\nPanelRef.prototype.canClose = function() {\n    return this.options && !this.options.disableClose;\n};\nPanelRef.prototype.hide = function( force = false ) {\n    if( force || !force && this.canClose() ) {\n        let popupRef = this;\n        if( popupRef.parentPopup ) {\n            //Update Next ref\n            if( popupRef.nextPopup ) {\n                popupRef.parentPopup.nextPopup = popupRef.nextPopup;\n                popupRef.nextPopup.parentPopup = popupRef.parentPopup;\n            } else {\n                popupRef.parentPopup.nextPopup = null;\n            }\n        }\n        return this.options.api.hide( this );\n    }\n};\nPanelRef.prototype.triggerHook = function( type ) {\n    if( [ 'open', 'update', 'close' ].indexOf( type ) === -1 ) { return; }\n    _.each( this.interceptors[ type ], ( item ) => { item( this ); } );\n};\nexport { PanelRef as PanelRef };\n\n/**\n * A panel manager to track and manage all panel reference .\n * @final @constructor\n */\nfunction PopupManager() {\n    this._previousPopupRef = null;\n    this._popupMaps = {};\n}\nPopupManager.prototype.get = function( id ) {\n    if( id && this._popupMaps[ id ] ) {\n        return this._popupMaps[ id ];\n    }\n    return null;\n};\nPopupManager.prototype.add = function( panelRef ) {\n    if( !panelRef ) { return; }\n    var id = panelRef.id;\n    let isPanelRefTooltip = panelRef.panelEl && panelRef.panelEl.querySelector( '.sw-popup-tooltip.sw-popup-easein' ) !== null;\n    if( !this._popupMaps[ id ] ) {\n        let validPanelRef = null;\n        for( const k of Object.keys( this._popupMaps ).reverse() ) {\n            let validEl = dom.get( '.aw-widgets-groupCommandStack', this._popupMaps[ k ].panelEl );\n            // during keyboard navigation, reference of next and parent popup should not be\n            // maintained if panelRef is an extended tooltip\n            // reference of next and parent popup should not be maintained if panelRef is a tooltip\n            if( validEl !== null && !isPanelRefTooltip ) {\n                validPanelRef = this._popupMaps[ k ];\n                break;\n            }\n        }\n        if( validPanelRef !== null ) {\n            // Maintain reference of next and parent popup\n            validPanelRef.nextPopup = panelRef;\n            panelRef.parentPopup = validPanelRef;\n        }\n        this._popupMaps[ id ] = panelRef;\n    }\n};\n\nPopupManager.prototype.remove = function( panelRef ) {\n    if( !panelRef ) { return; }\n    var id = panelRef.id;\n    this._popupMaps[ id ] && delete this._popupMaps[ id ];\n};\nObject.defineProperty( PopupManager.prototype, 'previousPopupRef', {\n    enumerable: true,\n    configurable: true,\n    get: function() { return this._previousPopupRef; },\n    set: function( value ) {\n        this._previousPopupRef = value;\n    }\n} );\nexport { PopupManager as PopupManager };\n\nexport let handleOpenedPopup = function( referenceEl, manager, toggleMode = false ) {\n    var id = referenceEl ? referenceEl.getAttribute( POPUP_ID_ATTRIBUTE ) : null;\n    var popupRef = manager.get( id );\n\n    if( id && toggleMode ) {\n        popupRef.hide();\n        return null;\n    } else if( id ) {\n        // force bring to foreground by hoist z-index or\n        // force bring to foreground by re-append (safe and easy way)\n        dom.append( popupRef.panelEl );\n        return popupRef;\n    }\n    return true;\n};\n\nfunction removeEventListeners( panelRef ) {\n    panelRef._removeListeners && panelRef._removeListeners.forEach( function( removeFn ) {\n        removeFn();\n    } );\n    panelRef._removeListeners = [];\n}\n\nfunction processEnablers( popupRef ) {\n    let options = popupRef.options;\n    let { draggable, draggableInitializeDelay = 200 } = options;\n    if( !draggable ) { return; }\n\n    // contents maybe async loaded, handle maybe not ready(exist) yet.\n    setTimeout( ()=>{\n        let popupEl = popupRef.panelEl;\n        if( popupEl ) {\n            let dragElement = dom.get( '.sw-popup-layout', popupEl );\n            let headerElement = dom.get( '.aw-layout-panelTitle, .panel-header', popupEl );\n            let handle = undefined;\n            if( options.handle ) {\n                handle = dom.get( options.handle, popupEl );\n            } else if( headerElement ) {\n                handle = headerElement;\n            } else {\n                handle = dragElement;\n            }\n            let dragger = new Draggable( dragElement, {\n                handle,\n                limit: document.body,\n                setCursor: true,\n                className: options.draggableClassName || 'sw-popup-draggable',\n                // LCS-337929: expect popup to remain where it was dragged\n                // add flag 'disableUpdate' to prevent auto update position if have been dragged\n                onDragStart: function() {\n                    options.disableUpdate = true;\n                    // remove right / bottom to ensure element draggable\n                    options.advancePositioning && dom.setStyles( dragElement, { right: null, bottom: null } );\n                }\n            } );\n            popupRef._removeListeners.push( dragger.destroy.bind( dragger ) );\n        }\n    }, draggableInitializeDelay );\n}\n\n// MultipleLevel popup command bar case:\n// build cascade MultipleLevel popup menus\n// and define the event ignore list between them\nfunction processMultipleLevel( popupRef ) {\n    let { options, panelEl } = popupRef;\n    let { reference, manager, processNested, preset } = options;\n\n    // exclude tooltip process\n    if( preset && preset === 'tooltip' ) { return; }\n    if( processNested === false || !reference || !manager ) { return; }\n\n    // add current popup to ignore click list of all up Level popups\n    let parentPopup = dom.closest( reference, 'div.sw-popup' );\n    while( parentPopup && reference && manager ) {\n        let ref = manager.get( parentPopup.id );\n        ref.options.ignoreClicksFrom = ref.options.ignoreClicksFrom || [];\n        ref.options.ignoreClicksFrom.push( panelEl );\n\n        // check upper level recursively\n        reference = ref.options.reference;\n        manager = ref.options.manager;\n        parentPopup = dom.closest( reference, 'div.sw-popup' );\n    }\n}\n\nfunction autoFocus( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    if( options.autoFocus !== false ) {\n        getContainerElement( popupEl ).focus();\n    }\n}\n\nconst hookHash = { whenOpened: 'open', whenUpdated: 'update', whenClosed: 'close' };\nconst getHookKey = ( key ) => key.replace( /whenOpened|whenUpdated|whenClosed/g, matched => hookHash[ matched ] );\n\nfunction activateLifeCycleHooks( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    if( _.isObject( options.hooks ) ) {\n        var interceptors = popupRef.interceptors;\n        // support hooks in array\n        _.each( options.hooks, function( value, key ) {\n            const v = [].concat( value || [] );\n            const k = getHookKey( key );\n            k && ( interceptors[ k ] = v );\n        } );\n    }\n\n    // TODO\n    // // ensure close any orphan popup in case scope was destroyed\n    // var scope = ngUtils.getElementScope( popupEl );\n    // scope.$on( '$destroy', function () {\n    //     // clear this flag so that this popup could be closed.\n    //     delete options.disableClose;\n    //     popupRef.panelEl && options.api.hide( popupEl );\n    // } );\n}\n/**\n *\n * @param {JQLite} popupRef The panel element.\n */\nfunction addEventListeners( popupRef ) {\n    configureAutoFocusAndLoopTabbable( popupRef );\n    configureWatchSizeChange( popupRef );\n    configureEscapeToClose( popupRef );\n    configureClickOutsideToClose( popupRef );\n    configureScrollListener( popupRef );\n    configureResizeListener( popupRef );\n}\n\nfunction configureAutoFocusAndLoopTabbable( popupRef ) {\n    const { options, panelEl, interceptors, _removeListeners } = popupRef;\n    const { autoFocus } = options;\n\n    if( autoFocus !== false ) {\n        const dialogNode = getContentContainer( panelEl );\n        const { removeHandlers, onClose } = wcagSvc.configureAutoFocus( dialogNode, popupRef );\n        _removeListeners.push( ...removeHandlers );\n        interceptors.close.push( onClose );\n    }\n}\n\nfunction configureWatchSizeChange( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    // ease the cost, or will cause mouseenter/mouseleave flickering issue in tooltip\n    var debouncedUpdatePosition = throttle( options.api.updatePosition );\n    var listener = addWatchHandle( popupEl, function() {\n        debouncedUpdatePosition();\n    } );\n\n    // Queue remove listeners function\n    popupRef._removeListeners.push( listener );\n}\n\nfunction configureEscapeToClose( popupRef ) {\n    var options = popupRef.options;\n    const handleEscape = ( event ) => {\n        if( popupRef && popupRef.options && popupRef.options.customClass !== TOOLTIP_POPUP_CSS ) {\n            let key = event.key || event.keyCode;\n            if( key === keyCode.ESCAPE && options.closeWhenEsc !== false && declUtils.isNil( popupRef.nextPopup ) ) {\n                event.stopPropagation();\n                popupRef.hide();\n                wcagSvc.skipToFirstFocusableElement( options.reference );\n            }\n        }\n    };\n\n    // Add listeners\n    document.addEventListener( 'keyup', handleEscape );\n\n    // Queue remove listeners function\n    popupRef._removeListeners.push( () => {\n        document.removeEventListener( 'keyup', handleEscape );\n    } );\n}\n\nfunction checkIgnore( options, sourceEl ) {\n    var set = options.ignoreClicksFrom || [];\n    if( options.ignoreClicksFrom ) {\n        // force convert to array\n        set = [].concat( set );\n    }\n\n    if( options.ignoreReferenceClick && options.reference ) {\n        set.push( options.reference );\n    }\n\n    var found = set.find( ( item ) => {\n        let element = getElement( item );\n        if( element &&\n            ( element === sourceEl || element.contains( sourceEl ) )\n        ) {\n            return true;\n        }\n        return false;\n    } );\n\n    return Boolean( found );\n}\n\nfunction configureClickOutsideToClose( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var target = options.parent;\n    var reference = options.reference;\n    if( options.clickOutsideToClose ) {\n        var sourceEl;\n\n        // Keep track of the element on which the mouse originally went down\n        // so that we can only close the backdrop when the 'click' started on it.\n        // A simple 'click' handler does not work, it sets the target object as the\n        // element the mouse went down on.\n        // var mousedownHandler = function( ev ) {\n        //     sourceEl = ev.target;\n        // };\n\n        // We check if our original element and the target is the backdrop\n        // because if the original was the backdrop and the target was inside the\n        // panel we don't want to panel to close.\n        var clickHandler = function( ev ) {\n            if( isTooltipClick( ev ) || isNotyClick( ev ) || isCalendarClick( ev ) ) {\n                return;\n            }\n\n            // We check if the sourceEl of the event is the panel element or one\n            // of it's children. If it is not, then close the panel.\n            sourceEl = ev.target;\n            if( sourceEl !== popupEl && !popupEl.contains( sourceEl ) && !isTooltipClick( sourceEl ) ) {\n                if( !checkIgnore( options, sourceEl ) ) {\n                    options.api.hide( popupRef );\n                }\n            }\n        };\n\n        // Add listeners\n        dom.on( target, 'click,contextmenu', clickHandler, true );\n\n        // Queue remove listeners function\n        popupRef._removeListeners.push( function() {\n            dom.off( target, 'click,contextmenu', clickHandler, true );\n        } );\n    }\n}\n\nconst isTooltipClick = ( event ) => dom.closest( event.target, '.sw-popup-tooltip' );\nconst isNotyClick = ( event ) => dom.closest( event.target, '#noty_bottom_layout_container' );\nconst isCalendarClick = ( event ) => dom.closest( event.target, FLATPICKR_ID );\n\n// function isTooltipClick( sourceEl ) {\n//     let tooltip = dom.closest( sourceEl, '.sw-popup-tooltip' );\n//     return Boolean( tooltip );\n// }\n\nfunction configureResizeListener( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var handler = null;\n    if( options.resizeToClose ) {\n        var debouncedHide = throttle( options.api.hide );\n        handler = () => { debouncedHide( popupRef ); };\n    } else {\n        var debouncedUpdatePosition = throttle( options.api.updatePosition );\n        handler = () => { debouncedUpdatePosition(); };\n    }\n\n    // // Add listeners, use framework's event 'windowResize' instead of native event 'resize'\n    // var scope = ngUtils.getElementScope( popupEl );\n    // var removeListener = scope.$on( 'windowResize', handler );\n    // // Queue remove listeners function\n    // popupRef._removeListeners.push( function () {\n    //     removeListener();\n    // } );\n\n    // if ( options.listenAreaChanges !== false ) {\n    //     // FUTURE: use reference element's resize event, which needs framework's support.\n    //     var sub = eventBus.subscribe( 'aw-splitter-update', handler );\n    //     popupRef._removeListeners.push( () => { eventBus.unsubscribe( sub ); } );\n    // }\n    // FUTURE: use reference element's resize/move event, which needs framework's support.\n    // Add listeners\n    window.addEventListener( 'resize', handler );\n    // Queue remove listeners function\n    popupRef._removeListeners.push( () => {\n        window.removeEventListener( 'resize', handler );\n    } );\n}\n\n/**\n * Firefox and Qt browser have scroll issues: scroll event is firing multiple times even when mouse moves or hover on any element\n * Solution: for these browser, need to remember the last reported scroll position and check it against each new reported scroll position\n *\n * @returns {boolean} result - true for Firefox or Qt browser, false for others\n */\nfunction checkBrowser() {\n    return browserUtils.isFirefox || browserUtils.isQt;\n}\n\nfunction checkOutsideScrollEvent( event, popupEl ) {\n    var path = eventPath( event );\n    return _.indexOf( path, popupEl ) === -1;\n}\n\nfunction checkAncestorScrollEvent( event, popupEl, options ) {\n    let { reference, useOutsideScrollEvent } = options;\n    if( !reference || useOutsideScrollEvent ) {\n        return checkOutsideScrollEvent( event, popupEl );\n    }\n    let path = composedPath( reference );\n    return _.indexOf( path, event.target ) !== -1;\n}\n\nfunction configureScrollListener( popupRef ) {\n    var options = popupRef.options;\n    var popupEl = popupRef.panelEl;\n    var onScroll;\n\n    var target = null;\n    var onScrollWrapper = null;\n    if( options.closeWhenParentScroll ) {\n        var debouncedHide = throttle( options.api.hide );\n\n        var processScrollEvent = function( event ) {\n            debouncedHide( popupRef );\n        };\n\n        var checkScrollPosition = function( target ) {\n            var oldY = target.scrollTop;\n            var oldX = target.scrollLeft;\n\n            var wrapper = function( event ) {\n                if( event.target !== target ) { return; }\n                var curY = event.target.scrollTop;\n                var curX = event.target.scrollLeft;\n\n                if( Math.abs( oldX - curX ) > _MAX_X || Math.abs( oldY - curY ) > _MAX_Y ) {\n                    oldX = curX;\n                    oldY = curY;\n                    processScrollEvent( event );\n                }\n            };\n\n            window.removeEventListener( 'scroll', onScroll, true );\n            target.addEventListener( 'scroll', wrapper, true );\n\n            return wrapper;\n        };\n\n        onScroll = function( event ) {\n            // skip if scroll happens inside any ancestor node or an input field (like sibling lov case)\n            if( !checkAncestorScrollEvent( event, popupEl, options ) || event.target.tagName === 'INPUT' ) { return; }\n\n            // Firefox issue: scroll event is firing multiple times even when mouse moves or hover on any element\n            // Solution: need to remember the last reported scroll position and check it against each new reported scroll position\n            if( checkBrowser() ) {\n                target = event.target;\n                onScrollWrapper = checkScrollPosition( target );\n                return;\n            }\n\n            processScrollEvent( event );\n        };\n    } else if( options.followParentScroll ) {\n        var debouncedUpdatePosition = throttle( options.api.updatePosition );\n        onScroll = function( event ) {\n            if( checkAncestorScrollEvent( event, popupEl, options ) ) { debouncedUpdatePosition(); }\n        };\n    }\n\n    if( onScroll ) {\n        // Add listeners.\n        window.addEventListener( 'scroll', onScroll, true );\n\n        // Queue remove listeners function.\n        popupRef._removeListeners.push( function() {\n            window.removeEventListener( 'scroll', onScroll, true );\n            if( checkBrowser() && target ) {\n                target.removeEventListener( 'scroll', onScrollWrapper, true );\n            }\n        } );\n    }\n}\n\nexport let getContainerElement = function( popupEl ) {\n    return dom.get( '.sw-popup-layout', popupEl );\n};\n\nconst getContentContainer = function( popupEl ) {\n    // eslint-disable-next-line sonarjs/no-duplicate-string\n    return dom.get( '.sw-popup-contentContainer', popupEl );\n};\n\nexport let processOptions = function( popupEl, options ) {\n    var container = getContainerElement( popupEl );\n    if( !container ) { return; }\n    if( options.customClass ) {\n        let customClasses = options.customClass.split( /\\s+|,/ );\n        customClasses.forEach( ( i ) => { dom.addClass( container, i ); } );\n    }\n    var sizeCss = {};\n    var needUpdateStyle = false;\n    if( options.containerWidth ) {\n        sizeCss.width = options.containerWidth;\n        sizeCss[ 'max-width' ] = null;\n        needUpdateStyle = true;\n    }\n    if( options.containerHeight ) {\n        sizeCss.height = options.containerHeight;\n        sizeCss[ 'max-height' ] = null;\n        needUpdateStyle = true;\n    }\n\n    needUpdateStyle && dom.setStyles( container, sizeCss );\n};\n\nexport let getTemplateFromUrl = function( url ) {\n    return AwHttpService.instance.get( url, { cache: true } )\n        .then( ( response ) => response.data )\n        .catch( () => AwPromiseService.instance.reject( url + ' type \"url\" not found! please check your resource!' ) );\n};\n\nexport let getTemplateFromView = function( viewId, contextScope ) {\n    // var subPanelContext = contextScope ? contextScope.subPanelContext : null;\n    // return panelContentService.getPanelContent( viewId )\n    //     .catch( () => AwPromiseService.instance.reject( viewId + ' type \"declView\" not found! please check your resource!' ) )\n    //     .then( ( viewAndViewModelResponse ) => {\n    //         return viewModelService.populateViewModelPropertiesFromJson( viewAndViewModelResponse.viewModel, false, null, null, null, subPanelContext )\n    //             .then( ( declarativeViewModel ) => {\n    //                 viewModelService.setupLifeCycle( contextScope, declarativeViewModel );\n    //                 // align lifecycleHooks\n    //                 contextScope._onMount = () => {\n    //                     let onMountAction = _.get( contextScope, 'data._internal.lifecycleHooks.onMount' );\n    //                     onMountAction && viewModelService.executeCommand( contextScope.data, onMountAction, contextScope );\n    //                 };\n    //                 // Legacy compatible: application are listening this event to retrieve data for that view\n    //                 let modelId = _.get( contextScope, 'data._internal.modelId' ) || '?';\n    //                 eventBus.publish( viewId + '.contentLoaded', { scope: contextScope, _source: modelId } );\n\n    //                 return AwPromiseService.instance.resolve( viewAndViewModelResponse.view );\n    //             } );\n    //     } );\n};\n\nfunction getId( panelEl, forceUid ) {\n    if( !panelEl ) { return null; }\n    // force generate uid if\n    // 1, not have a id\n    // 2, multiple mode open\n    if( forceUid && panelEl.id ) { panelEl.id = ''; }\n    if( !panelEl.id ) { dom.uniqueId( panelEl ); }\n    return panelEl.id;\n}\n\n/**\n * get the element\n *\n * @param {Element | String} element - can be an Element, or query string\n * @returns {Element} element\n */\nexport let getElement = function( element ) {\n    if( _.isString( element ) ) {\n        element = dom.get( element );\n    }\n    return element;\n};\n\n// ONLY FOR declarative usage due to principle: CSS selectors should not be exposed to view model\n// extend selector by add id sign\nexport let extendSelector = function( element ) {\n    var reValidSelector = /^(\\.|#|aw)/i;\n    if( _.isString( element ) && !reValidSelector.test( element ) ) {\n        element = element + ', #' + element;\n    }\n    return element;\n};\n\nexport let getArrowElement = function( popupEl ) {\n    return dom.get( '.sw-popup-arrow', popupEl );\n};\n\nfunction addWatchHandle( popupEl, cb ) {\n    let containerEl = getContainerElement( popupEl );\n    let fn = () => {\n        if( cb && _.isFunction( cb ) ) { cb(); }\n    };\n    return resizeDetector( containerEl, fn );\n}\n\n// provide opportunity for user to specify the resizeContainer selector\nexport let getResizeContainer = function( element, containerSelector ) {\n    if( containerSelector && dom.match( element, containerSelector ) ) {\n        return element;\n    }\n    let selector = containerSelector || '.aw-base-scrollPanel';\n    if( !containerSelector && dom.get( '.sw-popup-contentContainer', element ) ) {\n        selector = '.sw-popup-contentContainer';\n    }\n    return dom.get( selector, element );\n};\n\nexport let getMousePosition = function( event ) {\n    let target = { clientX: 0, clientY: 0 };\n    if( event ) {\n        target = event;\n        if( _.isUndefined( event.clientX ) ) { target = event.touches[ 0 ]; }\n    }\n    let { clientX, clientY } = target;\n    return { x: clientX, y: clientY };\n};\n\n// it implements a window frame based throttle function to ease intensively triggered window events.\n// motivation is to improve performance, to ensure callback will only be fired once per frame for intensively triggered window events.\n// references: $mdDialog using a throttle decorator to decorate $$rAF service. popper.js implement it's own window frame based throttle method.\nfunction throttle( fn ) {\n    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n    var supportsMicroTasks = isBrowser && window.Promise;\n    // eslint-disable-next-line one-var\n    var queuedArgs, alreadyQueued, queueCb, context;\n\n    var microtaskThrottle = function( fn ) {\n        alreadyQueued = false;\n        return function throttled() {\n            queuedArgs = arguments;\n            context = this;\n            queueCb = fn;\n            if( alreadyQueued ) {\n                return;\n            }\n            alreadyQueued = true;\n            window.Promise.resolve().then( () => {\n                alreadyQueued = false;\n                queueCb.apply( context, Array.prototype.slice.call( queuedArgs ) );\n            } );\n        };\n    };\n\n    var taskThrottle = function( fn ) {\n        var scheduled = false;\n        var task = window.requestAnimationFrame || window.setTimeout;\n        return function throttled() {\n            var queuedArgs = arguments;\n            context = this;\n            queueCb = fn;\n            if( !scheduled ) {\n                scheduled = true;\n                task( () => {\n                    scheduled = false;\n                    queueCb.apply( context, Array.prototype.slice.call( queuedArgs ) );\n                } );\n            }\n        };\n    };\n\n    return ( supportsMicroTasks ? microtaskThrottle : taskThrottle )( fn );\n}\n\nfunction composedPath( el ) {\n    let path = [];\n    while( el ) {\n        path.push( el );\n        if( el.tagName === 'HTML' ) {\n            path.push( document );\n            path.push( window );\n            return path;\n        }\n        el = el.parentElement;\n    }\n    return path;\n}\n\n// get the event path in dom event bubbling\nfunction eventPath( event ) {\n    var path = event.path || event.composedPath && event.composedPath();\n    // event.path always has wrong value for Qt browser\n    if( !path || browserUtils.isQt ) {\n        return composedPath( event.target );\n    }\n    return path;\n}\n\n// return the first clean node by skip any comment node.\nexport let cleanNode = ( nodesArray ) => {\n    let result = null;\n    if( nodesArray && nodesArray.length > 0 ) {\n        result = _.find( nodesArray, ( item ) => {\n            return item.nodeType !== HTMLElement.COMMENT_NODE;\n        } );\n    }\n    return result;\n};\n\n// verify whether have any plain string content loaded\nlet verifyText = ( node ) => {\n    return Boolean( ( node.innerText || '' ).replace( /\\s|\\r|\\n/g, '' ) );\n};\n\n// verify whether have any media content loaded\nlet verifyMedia = ( node ) => {\n    return Boolean( dom.get( 'img, svg', node ) );\n};\n\nexport let tooltipAdapteStyle = ( node ) => {\n    // tooltip expected parent element to have \"display: block\" other than \"display: flex\"\n    dom.removeClass( node, 'aw-layout-flexbox' );\n    dom.setStyle( node, 'overflow', 'hidden' );\n};\n\n// getLoadingStatus by check transclude / plainHtml contents\n// used for balloon and tooltip\nlet getLoadingStatus = ( container, adapteStyle ) => {\n    let [ container_css, transclude_css ] = [ '.aw-layout-flexColumnContainer',\n        'aw-include>div.aw-layout-include, div.aw-base-scrollPanel>ng-transclude'\n    ];\n    var content = dom.get( container_css, container );\n    if( !content ) { return false; }\n    var transclude = dom.get( transclude_css, content );\n    var transcluded = Boolean( transclude ) && Boolean( cleanNode( transclude.childNodes ) );\n    if( transcluded && adapteStyle ) { tooltipAdapteStyle( transclude ); }\n    return verifyText( content ) || verifyMedia( content );\n};\n\nexport let runLoadingCheck = ( context, container, adapteStyle = false ) => {\n    let loaded = () => getLoadingStatus( container, adapteStyle );\n    let apply = ( loading = false ) => {\n        context.loading = loading;\n        context.$apply && context.$apply();\n    };\n    return new Promise( ( resolve ) => {\n        // defer to next cycle to avoid show loading in cache case\n        setTimeout( () => {\n            let loading = !loaded();\n            apply( loading );\n            if( !loading ) {\n                resolve();\n                return;\n            }\n            let timer = setInterval( () => {\n                if( loaded() ) { apply( false ); }\n                if( !context.loading || !dom.inDOM( container ) ) {\n                    clearInterval( timer );\n                    resolve();\n                }\n            }, 50 );\n        } );\n    } );\n};\n\nconst RESIZE_POLLING_TIMEOUT = 500;\nexport let runResizeCheck = ( container ) => {\n    let oldSize = { width: container.offsetWidth, height: container.offsetHeight };\n    let noResizeTimeStart = Date.now();\n    return new Promise( ( resolve ) => {\n        let timer = setInterval( () => {\n            if( checkResize( container, oldSize )() ) {\n                noResizeTimeStart = Date.now();\n            } else {\n                let noResizeTime = Date.now() - noResizeTimeStart;\n                // size got stable till now, safe to resolve.\n                if( noResizeTime > RESIZE_POLLING_TIMEOUT ) {\n                    clearInterval( timer );\n                    resolve();\n                }\n            }\n        }, 50 );\n    } );\n};\n\nexport let tooltipProgressCheck = ( cb, progress ) => {\n    let timer = setInterval( () => {\n        if( !progress.busy ) {\n            clearInterval( timer );\n            cb && cb();\n        }\n    }, 50 );\n};\n\nexport let closeExistingTooltip = () => {\n    let nodes = dom.getAll( 'div.aw-popup-tooltip' );\n    let results = dom.getParent( nodes );\n    results && results.length > 0 && dom.remove( results );\n};\n\nlet checkWithinRightSide = ( node ) => {\n    return window.innerWidth / 3 - node.getBoundingClientRect().left < 0;\n};\nexport let tooltipAdapteOption = ( raw, target ) => {\n    let result = Object.assign( {}, raw );\n    // backward compatible\n    if( raw.alignment && !raw.placement ) {\n        if( raw.alignment === 'VERTICAL' ) {\n            result.placement = 'right';\n            // if target element locate at the right side of the page, then flip the placement\n            if( checkWithinRightSide( target ) ) { result.placement = 'left'; }\n        } else if( /^(RIGHT|LEFT)/.test( raw.alignment ) ) {\n            result.placement = 'right';\n        } else if( /^(TOP|BOTTOM)/.test( raw.alignment ) ) {\n            result.placement = 'top';\n        }\n    }\n    return result;\n};\n\nexport let processTooltipOptions = ( rawOptions, target, popupOpenedCb, popupClosedCb ) => {\n    let options = {\n        ownContainer: true,\n        placement: [ 'top', 'bottom', 'right', 'left' ],\n        flipBehavior: 'opposite',\n        whenParentScrolls: 'close',\n        adaptiveShift: true, // prevent tooltip cut off in corner case\n        resizeToClose: true,\n        advancePositioning: true, // prevent overlap or flash when popup content growing\n        hasArrow: true,\n        padding: { x: 4, y: 4 },\n        arrowOptions: {\n            alignment: 'center'\n        },\n        reference: target,\n        minSize: 5,\n        forceCloseOthers: false,\n        customClass: 'aw-popup-tooltip aw_popup_easein',\n        hooks: {\n            whenOpened: ( element ) => { popupOpenedCb && popupOpenedCb( element ); },\n            whenClosed: ( element ) => { popupClosedCb && popupClosedCb( element ); }\n        }\n    };\n    if( _.keys( rawOptions ).length > 0 ) { Object.assign( options, tooltipAdapteOption( rawOptions, target ) ); }\n    return options;\n};\n\nexport let removeNativeTitle = ( node ) => {\n    dom.removeAttribute( node, 'title' );\n    let results = dom.getAll( '[title]', node );\n    results.length > 0 && dom.removeAttribute( results, 'title' );\n};\n\nexports = {\n    POPUP_ID_ATTRIBUTE,\n    PanelRef,\n    PopupManager,\n    handleOpenedPopup,\n    processOptions,\n    getTemplateFromUrl,\n    getTemplateFromView,\n    getElement,\n    checkIgnore,\n    extendSelector,\n    getContainerElement,\n    getArrowElement,\n    getResizeContainer,\n    getMousePosition,\n    cleanNode,\n    runLoadingCheck,\n    runResizeCheck,\n    tooltipProgressCheck,\n    closeExistingTooltip,\n    tooltipAdapteOption,\n    tooltipAdapteStyle,\n    processTooltipOptions,\n    removeNativeTitle,\n    getContentContainer\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}