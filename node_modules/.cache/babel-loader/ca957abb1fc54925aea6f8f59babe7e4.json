{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * Defines provider for commands from the View model definition\n * A set of utilities and methods related to processing and modifying the commadns view model\n *\n * @module js/commandConfigUtils.service\n */import configurationService from'js/configurationService';import{getRealExpression}from'js/conditionService';import _,{get,isObject,isString,isArray,mapValues,cloneDeepWith}from'lodash';import logger from'js/logger';import Debug from'debug';const trace=new Debug('command:AwCommandBar');/** Regular Expression for the condition prefix in the expression. */const conditionRE=/\\bconditions\\b\\./;/**\n * Get the conditions with any condition reuse within string expressions expanded\n *\n * @param {Object} viewModelJson View model with conditions to expand\n * @returns {Object} Processed condition expressions\n */const getExpandedConditionExpressions=function(viewModelJson){const stringExpandedConditions=mapValues(viewModelJson.conditions,condition=>{if(isString(condition.expression)){//simple expansion of string conditions\nreturn{...condition,expression:getRealExpression(condition.expression,viewModelJson)};}if(isObject(condition.expression)){//recurse through object and expand any referenced string conditions\nreturn cloneDeepWith(condition,value=>{if(isObject(value)&&value.$source&&conditionRE.test(value.$source)){const refExpression=getRealExpression(value.$source,viewModelJson);return isString(refExpression)?{...value,$source:refExpression,__useSourceParsing:true}:value;}});}return condition;});const tempVm={conditions:stringExpandedConditions};const checkObjectCondition=(condition,shouldRecurse)=>{if(isObject(condition)&&condition.$source&&conditionRE.test(condition.$source)){const eqCheck=get(condition,'$query.$eq');const neCheck=get(condition,'$query.$ne');const refExpression=getRealExpression(condition.$source,tempVm);if(eqCheck===true||neCheck===false){//for true just swap original condition into same place\n//need to restart recursion for new object to ensure and \"conditions.x\" included in it are updated\nconst newValue=cloneDeepWith(refExpression,expandObjectConditions);trace('Expanded object condition',condition,newValue);return newValue;}if(eqCheck===false||neCheck===true){//for false wrap with a $not\nconst newValue={$not:cloneDeepWith(refExpression,expandObjectConditions)};trace('Expanded object condition',condition,newValue);return newValue;}logger.warn('Condition reuse only supports boolean checks',condition);}return shouldRecurse?cloneDeepWith(condition,expandObjectConditions):condition;};const expandObjectConditions=value=>{if(isArray(value)){return value.map(x=>checkObjectCondition(x,true));}const newVal=checkObjectCondition(value);if(newVal!==value){//don't return if not modifying anything, will stop recursion for the current object\nreturn newVal;}};return cloneDeepWith(stringExpandedConditions,expandObjectConditions);};/**\n * Convert every placement that has \"parentGroupID\" into a placement with\n * a dynamically generated anchor based on parent\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */const addChildPlacements=function(viewModelJson){for(const[placementID,placement]of Object.entries(viewModelJson.commandPlacements)){if(placement.parentGroupId){viewModelJson.commandPlacements[\"$$\".concat(placementID).concat(placement.parentGroupId)]={id:placement.id,priority:placement.priority,relativeTo:placement.relativeTo,uiAnchor:placement.parentGroupId};}}};/**\n * Ensure the primary commandsViewModel has all of the expected properties\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */const ensureProps=function(viewModelJson){['actions','commandHandlers','commandPlacements','commands','conditions','messages'].forEach(function(k){viewModelJson[k]=viewModelJson[k]||{};});['onEvent'].forEach(function(k){viewModelJson[k]=viewModelJson[k]||[];});};/**\n * Convert \"true\" and \"false\" shortcuts into actual conditions\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n * @param {Object} commandHandlers Command handlers to modify\n */export const updateShortConditions=function(viewModelJson,commandHandlers){const trueCondition={condition:'conditions.true'};const falseCondition={condition:'conditions.false'};for(const handler of Object.values(commandHandlers)){['activeWhen','visibleWhen','selectWhen','enableWhen'].forEach(function(conditionKey){if(handler[conditionKey]===true||_.get(handler,[conditionKey,'condition'])===true){handler[conditionKey]=trueCondition;}else if(handler[conditionKey]===false||_.get(handler,[conditionKey,'condition'])===false){handler[conditionKey]=falseCondition;}});}viewModelJson.conditions.true={expression:'true'};viewModelJson.conditions.false={expression:'false'};};/**\n * Convert \"title\": \"{{ctx.previousLocationDisplayName }}\" to parameter format\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */const updateShortCommandTitles=function(viewModelJson){for(const command of Object.values(viewModelJson.commands)){if(command.title&&typeof command.title==='string'&&(command.title.startsWith('{{ctx')||command.title.startsWith('{{commandContext'))){command.title={text:'{0}',params:[command.title]};}}};let viewModelJsonCache=null;const setCommandsViewModelCache=newCache=>{viewModelJsonCache=newCache;};/**\n * Get and pre process the commands view model from config service\n * @param {boolean} clearCache true if to clear any commandsViewModelCache\n * @returns {Promise<Object>} promise resolved with the commands view model (plain object)\n */const getCommandsViewModel=async function(){let clearCache=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(viewModelJsonCache&&!clearCache){return viewModelJsonCache;}let viewModelJson=await configurationService.getCfg('commandsViewModel');ensureProps(viewModelJson);const expandedConditions=getExpandedConditionExpressions(viewModelJson);viewModelJson.conditions=expandedConditions;addChildPlacements(viewModelJson);updateShortConditions(viewModelJson,viewModelJson.commandHandlers);updateShortCommandTitles(viewModelJson);setCommandsViewModelCache(viewModelJson);return viewModelJson;};/**\n * Get all matches of a regex in the given string\n *\n * @param {RegExp} re Regex to used\n * @param {String} s String to search\n * @returns {Array<String>} List of all matches\n */const getAllMatches=function(re,s){var result=[];var m=re.exec(s);while(m){result.push(m[1]);m=re.exec(s);}return result;};const conditionsRE=/conditions\\.([a-zA-Z]\\w*)(\\W*|$)/g;/**\n * Get all nested conditions from a condition expression. See unit tests for examples.\n *\n * @param {String|Object} s condition expression\n * @returns {String[]} nested conditions\n */const getConditions=function(s){if(typeof s==='string'){return getAllMatches(conditionsRE,s);}if(typeof s==='object'){return Object.keys(s).map(k=>s[k])//Object.values( s ) if not for IE11\n.reduce((acc,nxt)=>acc.concat(getConditions(nxt)),[]);}return[];};/**\n * Utility to get the actual condition expression from the commands view model\n *\n * @param {Object} commandsViewModel The commands view model\n * @param {String} condition The conditon name (\"conditions.asdf\")\n * @returns {String|Object} The condition expression (string or object)\n */const getConditionExpression=function(commandsViewModel,condition){var conditionName=condition.split('.')[1];var expression=_.get(commandsViewModel,\"_internal.conditions.\".concat(conditionName,\".expression\"),null)||_.get(commandsViewModel,\"conditions.\".concat(conditionName,\".expression\"),null);if(expression===null){//If condition does not exist return \"false\" to avoid console errors (same behavior)\nlogger.error(\"Reference to missing condition \\\"\".concat(conditionName,\"\\\"\"));expression='false';}return expression;};/**\n * Recurses into the object and sub objects and finds real length of the expression by replacing the\n * references to other condition.xyz conditions\n *\n * @param {Object|String} expression expression whose actual length is desired\n * @param {Object} internalViewModel Object holding all expression definitions\n * @returns {Number} the length of the expression\n */const getExpressionLength=function(expression,internalViewModel){var sum=function(a,b){return a+b;};if(typeof expression==='string'){return expression.length;}return _.map(expression,function(value,key){if(key==='__useSourceParsing'){return 0;}var length=String(key).length;if(value&&_.isString(value)){var nestedConditions=getConditions(value);if(nestedConditions.length>0){var nestedConditionLength=nestedConditions.map(function(condName){return getExpressionLength(getConditionExpression(internalViewModel,'conditions.'+condName),internalViewModel);}).reduce(sum);return length+nestedConditionLength;}return length+String(value).length;}if(_.isObject(value)){return length+getExpressionLength(value,internalViewModel);}return length+String(value).length;}).reduce(sum);};const exports={updateShortConditions,getCommandsViewModel,getConditions,getConditionExpression,getExpressionLength};export default exports;","map":null,"metadata":{},"sourceType":"module"}