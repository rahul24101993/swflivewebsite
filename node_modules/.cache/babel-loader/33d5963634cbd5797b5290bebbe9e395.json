{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/filterPanelUtils\n */\nimport appCtxService from 'js/appCtxService';\nimport dateTimeService from 'js/dateTimeService';\nimport messagingService from 'js/messagingService';\nimport localeSvc from 'js/localeService';\nimport $ from 'jquery';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nvar _invalidDateText = '';\nvar _invalidRangeText = '';\nvar _invalidPrefilter = '';\nvar AWC_LIMITED_FILTER_CATEGORIES_ENABLED = 'AWC_Limited_Filter_Categories_Enabled';\nexport let HIERARCHICAL_FACET_SEPARATOR = '/';\nexport let PRESET_CATEGORY = 'WorkspaceObject.object_type';\nexport let DATE_FILTER = 'DateFilter';\nexport let INTERNAL_DATE_FILTER = '_DateFilter_';\nexport let DATE_RANGE_FILTER = 'DateRangeFilter';\nexport let DATE_DRILLDOWN_FILTER = 'DrilldownDateFilter';\nexport let NUMERIC_RANGE_FILTER = 'NumericRangeFilter';\nexport let INTERNAL_NUMERIC_FILTER = '_NumericFilter_';\nexport let INTERNAL_OBJECT_FILTER = '_ObjectFilter_';\nexport let INTERNAL_NUMERIC_RANGE = '_NumericRange_';\nexport let NUMERIC_FILTER = 'NumericFilter';\nexport let NUMERIC_RANGE = 'NumericRange';\nexport let NumericRangeBlankStart = 'NumericRangeBlankStart';\nexport let NumericRangeBlankEnd = 'NumericRangeBlankEnd';\nvar INTERNAL_TO = '_TO_';\nexport let NO_STARTDATE = '*';\nexport let NO_ENDDATE = '2100-12-31';\nexport let NO_STARTRANGE = '';\nexport let NO_ENDRANGE = '';\nexport let BEGINNING_OF_TIME = '0001-01-01T00:00:00';\nexport let ENDING_OF_TIME = '2100-12-31T23:59:59';\nvar START_OF_DAY = '00:00:00';\nvar _presetFilters = true;\nvar _hasTypeFilter = false;\nvar _incontextFlag = false;\nvar customPropValueColorMap = {};\n/**\n * Returns a date object.\n *\n * @function getDate\n * @memberOf filterPanelUtils\n *\n * @param {String}dateString - date string to be converted to date object\n *\n * @return {JsDate} a date object.\n */\n\nexport let getDate = function (dateString) {\n  var dateStr = dateString.substring(0, 10);\n  var date; // change open start/end date to null dates\n\n  if (_.startsWith(dateStr, '0001-01-0') || _.startsWith(dateStr, '2100-12-3')) {\n    date = dateTimeService.getNullDate();\n  } else {\n    var timeStr = dateString.substring(11, dateString.length - 6);\n\n    if (timeStr.indexOf('59') !== -1) {\n      dateStr = dateString.replace(timeStr, START_OF_DAY);\n    } else {\n      dateStr = dateString;\n    }\n\n    date = new Date(dateStr);\n  }\n\n  return date;\n};\n/**\n * Returns a UTC date object.\n *\n * @function convertToUTC\n * @memberOf filterPanelUtils\n *\n * @param {Object}date - date object\n *\n * @return {JsDate} a UTC date object.\n */\n\nfunction convertToUTC(date) {\n  var gmtTime = date.getTime();\n  var offset = date.getTimezoneOffset();\n  var jsDate = new Date(gmtTime + offset * 60 * 1000);\n  return new Date(jsDate.getTime());\n}\n/**\n * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can\n * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the\n * dateTimeService.isNullDate.\n *\n * @function isNullDate\n * @memberOf filterPanelUtils\n *\n * @param {Object} dateToTest - a Date object.\n * @returns {Boolean} - true if it's a null date.\n */\n\n\nexport let isNullDate = function (dateToTest) {\n  if (!dateToTest) {\n    return true;\n  }\n\n  return dateToTest.getFullYear() <= 1;\n};\n/**\n * Validate dates for category date range.\n *\n * @function validateDates\n * @memberOf filterPanelUtils\n *\n * @param {Object}category - category. This object is modified in this function.\n * @param {Object}startDate - startDate\n * @param {Object}origStartDate - origStartDate\n * @param {Object}endDate - endDate\n * @param {Object}origEndDate - origEndDate\n */\n\nexport let validateDates = function (category, startDate, origStartDate, endDate, origEndDate) {\n  category.showSearch = true;\n  var cStartDate = category.daterange.startDate;\n  var eEndDate = category.daterange.endDate;\n\n  if (category.daterange.dateRangeSelected && !cStartDate.valueUpdated && !eEndDate.valueUpdated) {\n    category.showSearch = false;\n    return;\n  } // The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,\n  // which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.\n\n\n  var tmpStartDate = moveDateToStartOfDay(startDate);\n  var tmpEndDate = moveDateToStartOfDay(endDate);\n  var noStartDate = dateTimeService.isNullDate(tmpStartDate);\n  var noEndDate = dateTimeService.isNullDate(tmpEndDate); // if both dates are not set, disable search button\n\n  if (noStartDate && noEndDate) {\n    category.showSearch = false;\n    return;\n  }\n\n  var temp1 = dateTimeService.compare(startDate, endDate); // if start date is later than end date, disable search button\n\n  if (!noStartDate && !noEndDate && startDate !== null && temp1 === 1) {\n    messagingService.showError(_invalidDateText);\n    category.showSearch = false;\n    return;\n  }\n\n  var disable; // check if dates vary from previous search to avoid enabling search\n\n  var tmpOrigEndDate = moveDateToStartOfDay(origEndDate);\n\n  if (noStartDate) {\n    // check if there is no startdate and if end date is same, disable search button\n    disable = category.daterange.startDate === null && dateTimeService.compare(tmpEndDate, tmpOrigEndDate) === 0;\n  } else if (noEndDate) {\n    // check if there is no enddate and  start date is same, disable search button\n    disable = category.daterange.endDate === null && dateTimeService.compare(startDate, category.daterange.startDate.dateApi.dateObject) === 0;\n  } else {\n    // if the dates are same as previous search, disable search button\n    var compare1 = dateTimeService.compare(startDate, origStartDate) === 0;\n    var compare2 = dateTimeService.compare(endDate, tmpOrigEndDate) === 0;\n    disable = compare1 && compare2;\n  }\n\n  category.showSearch = !disable;\n};\n/**\n * get date range filter.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {Object}startDate - startDate\n * @param {Object}endDate - endDate\n *\n * @return {String} a string that represents the date range.\n */\n\nexport let getDateRangeString = function (startDate, endDate) {\n  var noStartDate = isNullDate(startDate);\n  var noEndDate = isNullDate(endDate);\n  var fromDateString = noStartDate ? NO_STARTDATE : dateTimeService.formatUTC(startDate);\n\n  if (noEndDate) {\n    endDate = new Date(NO_ENDDATE);\n  }\n\n  var toDateString = dateTimeService.formatUTC(moveDateToEndOfDay(endDate));\n  return INTERNAL_DATE_FILTER + fromDateString + INTERNAL_TO + toDateString;\n};\n/**\n * get filter of date range.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a filter object of date range for the filter string.\n */\n\nexport let getDateRangeFilter = function (filter) {\n  var searchFilter = {};\n  var sArr = filter.split(INTERNAL_TO);\n  searchFilter.searchFilterType = 'DateFilter';\n  sArr[0] = sArr[0] === NO_STARTDATE ? dateTimeService.NULLDATE : dateTimeService.formatUTC(sArr[0]);\n  searchFilter.startDateValue = sArr[0];\n  searchFilter.endDateValue = sArr[1];\n  return searchFilter;\n};\n/**\n * get a date range filter with display name and category type.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}startDate - startDate\n * @param {String}endDate - endDate\n *\n * @return {Object} a date range filter with display name and category type.\n */\n\nexport let getDateRangeDisplayString = function (startDate, endDate) {\n  var dateRangeFilter = {};\n  var noStartDate = dateTimeService.isNullDate(startDate);\n  var noEndDate = dateTimeService.isNullDate(endDate);\n  var dateRangeString;\n\n  if (noStartDate) {\n    dateRangeString = 'To ' + dateTimeService.formatDate(new Date(endDate)).substring(0, 11);\n  } else if (noEndDate) {\n    dateRangeString = 'From ' + dateTimeService.formatDate(new Date(startDate)).substring(0, 11);\n  } else {\n    dateRangeString = dateTimeService.formatDate(new Date(startDate)).substring(0, 11) + ' - ' + dateTimeService.formatDate(new Date(endDate)).substring(0, 11);\n  }\n\n  dateRangeFilter.displayName = dateRangeString;\n  dateRangeFilter.categoryType = DATE_RANGE_FILTER;\n  return dateRangeFilter;\n};\n/**\n * Simple check to validate the given category numeric range.\n *\n * @function checkIfValidRange\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n *\n * @return {Boolean} true if valid range.\n */\n\nexport let checkIfValidRange = function (category, startRange, endRange) {\n  category.showSearch = true;\n\n  if (startRange !== null && endRange !== null && startRange > endRange) {\n    var errorValue = startRange + '-' + endRange;\n\n    var msg = _invalidRangeText.replace('{0}', errorValue);\n\n    messagingService.showError(msg);\n    category.showSearch = false;\n    return false;\n  }\n\n  return true;\n};\n/**\n * Validate the given category numeric range if the range is selected.\n *\n * @function validateNumericRangeSelected\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {Number}cStartRange - current startRange\n * @param {Number}cEndRange - current endRange\n * @return {Boolean} true if valid range.\n */\n\nexport let validateNumericRangeSelected = function (category, startRange, endRange, cStartRange, cEndRange) {\n  var hasValidated = false;\n  var oStartRange = category.numericrange.filter.startNumericValue;\n  var oEndRange = category.numericrange.filter.endNumericValue;\n  var pStartRange = parseFloat(cStartRange);\n  var pEndRange = parseFloat(cEndRange);\n  var invalidStart = cStartRange === oStartRange || pStartRange === oStartRange || isNaN(pStartRange) && oStartRange === NO_STARTRANGE; // when the start range goes from blank to 0, it's a real change, so the search button should be enabled.\n\n  if (category.numericrange.filter.startEndRange === NumericRangeBlankStart) {\n    invalidStart = isNaN(pStartRange);\n  }\n\n  var invalidEnd = cEndRange === oEndRange || pEndRange === oEndRange || isNaN(pEndRange) && oEndRange === NO_ENDRANGE;\n\n  if (category.numericrange.filter.startEndRange === NumericRangeBlankEnd) {\n    invalidEnd = isNaN(pEndRange);\n  } // when the end range goes from blank to 0, it's a real change, so the search button should be enabled.\n\n\n  if (invalidStart && invalidEnd) {\n    category.showSearch = false;\n    hasValidated = true;\n  }\n\n  return hasValidated;\n};\n/**\n * Validate ranges for category numeric range.\n *\n * @function validateNumericRange\n * @memberOf filterPanelUtils\n *\n * @param {String} category - category\n * @param {String} startRange - startRange\n * @param {String} endRange - endRange\n *\n */\n\nexport let validateNumericRange = function (category, startRange, endRange) {\n  category.showSearch = true; // Validate values to be numbers\n\n  var cStartRange = category.numericrange.startValue.dbValue;\n  var cEndRange = category.numericrange.endValue.dbValue;\n  var oStartRange = null;\n  var oEndRange = null;\n\n  if (category.numericrange.numericRangeSelected && validateNumericRangeSelected(category, startRange, endRange, cStartRange, cEndRange)) {\n    return;\n  }\n\n  var noStartRange = cStartRange === undefined || cStartRange === null || cStartRange === '';\n  var noEndRange = cEndRange === undefined || cEndRange === null || cEndRange === ''; // if both numbers are not set, disable search button\n\n  if (noStartRange && noEndRange) {\n    category.showSearch = false;\n    return;\n  }\n\n  var disable = false;\n\n  if (noStartRange) {\n    disable = endRange === oEndRange || isNaN(endRange);\n  } else if (noEndRange) {\n    // check if there is no endRange and  start number is same, disable search button\n    disable = startRange === oStartRange || isNaN(startRange);\n  } else {\n    disable = !isFinite(startRange) || isNaN(startRange) || !isFinite(endRange) || isNaN(endRange);\n  }\n\n  category.showSearch = !disable;\n};\n/**\n * get numeric range filter string.\n *\n * @function getNumericRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}startRange - startRange\n * @param {String}endRange - endRange\n *\n * @return {String} a numeric range string.\n */\n\nexport let getNumericRangeString = function (startRange, endRange) {\n  var fromValue = startRange && startRange.toString();\n\n  if (fromValue === undefined || fromValue === null || fromValue.length === 0 || isNaN(fromValue)) {\n    fromValue = NO_STARTRANGE;\n  }\n\n  var toValue = endRange && endRange.toString();\n\n  if (toValue === undefined || toValue === null || toValue.length === 0 || isNaN(toValue)) {\n    toValue = NO_ENDRANGE;\n  }\n\n  return INTERNAL_NUMERIC_RANGE + fromValue + INTERNAL_TO + toValue;\n};\n/**\n * get numeric range filter from a filter string.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a numeric range filter.\n */\n\nexport let getNumericRangeFilter = function (filter) {\n  var searchFilter = {};\n  var sArr = filter.split(INTERNAL_TO);\n  searchFilter.searchFilterType = NUMERIC_FILTER;\n  searchFilter.startNumericValue = parseFloat(sArr[0]);\n  searchFilter.endNumericValue = parseFloat(sArr[1]);\n\n  if (isNaN(searchFilter.startNumericValue)) {\n    searchFilter.startEndRange = NumericRangeBlankStart;\n  } else if (isNaN(searchFilter.endNumericValue)) {\n    searchFilter.startEndRange = NumericRangeBlankEnd;\n  } else {\n    searchFilter.startEndRange = NUMERIC_RANGE;\n  }\n\n  return searchFilter;\n};\n/**\n * get a numeric range filter.\n *\n * @function getNumericRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {String}startEndRange - startEndRange\n *\n * @return {Object} a numeric range filter with display name and category type.\n */\n\nexport let getNumericRangeDisplayString = function (startRange, endRange, startEndRange) {\n  var numericRangeFilter = {};\n  var noStartRange = startEndRange === NumericRangeBlankStart || startRange !== 0 && !startRange;\n  var noEndRange = startEndRange === NumericRangeBlankEnd || endRange !== 0 && !endRange;\n  var numericRangeString;\n\n  if (noStartRange) {\n    numericRangeString = 'To ' + endRange.toString();\n  } else if (noEndRange) {\n    numericRangeString = 'From ' + startRange.toString();\n  } else {\n    numericRangeString = startRange.toString() + ' - ' + endRange.toString();\n  }\n\n  numericRangeFilter.displayName = numericRangeString;\n  numericRangeFilter.categoryType = NUMERIC_RANGE_FILTER;\n  return numericRangeFilter;\n};\n/**\n * get a real filter.\n *\n * @function getRealFilterWithNoFilterType\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} the real filter stripped off the identifiers.\n */\n\nexport let getRealFilterWithNoFilterType = function (filter) {\n  var realFilter = filter;\n\n  if (!filter.hasOwnProperty('property')) {\n    realFilter = filter.replace(INTERNAL_NUMERIC_FILTER, '').replace(INTERNAL_OBJECT_FILTER, '');\n  }\n\n  return realFilter;\n};\n/**\n * get filter type from filter value.\n *\n * @function getFilterTypeFromFilterValue\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {String} filter type, if it can be derived.\n */\n\nexport let getFilterTypeFromFilterValue = function (filter) {\n  var filterType;\n\n  if (_.startsWith(filter, INTERNAL_OBJECT_FILTER)) {\n    filterType = 'ObjectFilter';\n  } else if (_.startsWith(filter, INTERNAL_NUMERIC_FILTER)) {\n    filterType = 'NumericFilter';\n  } else {\n    filterType = 'DateFilter';\n  }\n\n  return filterType;\n};\n/**\n * /** Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\n\nfunction moveDateToStartOfDay(date) {\n  if (!dateTimeService.isNullDate(date)) {\n    date.setHours(0, 0, 0);\n    return date;\n  }\n\n  return date;\n}\n/**\n * Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\n\n\nfunction moveDateToEndOfDay(date) {\n  if (!dateTimeService.isNullDate(date)) {\n    date.setHours(23, 59, 59);\n    return date;\n  }\n\n  return date;\n}\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\n\n\nexport let isPresetFilters = function () {\n  return _presetFilters;\n};\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag flag\n */\n\nexport let setPresetFilters = function (flag) {\n  _presetFilters = flag;\n};\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\n\nexport let getHasTypeFilter = function () {\n  return _hasTypeFilter;\n};\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag preset filter flag\n */\n\nexport let setHasTypeFilter = function (flag) {\n  _hasTypeFilter = flag;\n};\n/**\n * Sets incontext flag\n *\n * @param {Object} flag incontext flag\n */\n\nexport let setIncontext = function (flag) {\n  _incontextFlag = flag;\n};\n/**\n * Gets incontext flag\n *\n * @returns {Object} incontext flag\n */\n\nexport let getIncontext = function () {\n  return _incontextFlag;\n};\n/**\n * Save source filter map in appcontext for incontext\n *\n * @param {Object} data data\n */\n\nexport let saveIncontextFilterMap = function (data) {\n  let inContextMap = {};\n\n  if (getHasTypeFilter()) {\n    // Create a filter value for each category value\n    let tmpValues = data.searchFilterMap[PRESET_CATEGORY];\n    inContextMap[PRESET_CATEGORY] = tmpValues;\n  }\n\n  return inContextMap;\n};\n/**\n * Returns category internal name\n * @param {Object} category category\n * @returns {Object} The category internal name\n */\n\nexport let getCategoryInternalName = function (category) {\n  return category.internalName;\n};\n/**\n * Returns current category\n *\n * @param {Object} response the response from the search SOA\n * @returns {Object} The current category\n */\n\nexport let getCurrentCategory = function (response) {\n  return response.groupedObjectsList[0].internalPropertyName;\n};\n/**\n * Returns filter values for a category to be shown in panel\n *\n * @param {Object} category the category to get values for\n *\n * @returns {ObjectArray} The array of filters to show in panel\n */\n\nexport let getPropGroupValues = function (category) {\n  getPreferenceValue();\n  var values = [];\n\n  for (var i = 0; i < category.filterValues.length; i++) {\n    var categoryValue = category.filterValues[i];\n\n    if (categoryValue && (i < 9 || categoryValue.color)) {\n      values.push(getPropGroupValue(category.type, category.drilldown, categoryValue));\n    }\n  }\n\n  return values;\n};\n/**\n * Returns filter values for a category to be shown in panel\n * @param {String} categoryType categoryType\n * @param {Integer} categoryDrillDown category Drill Down\n * @param {String} categoryValue categoryValue\n * @returns {Object} filter value\n */\n\nexport let getPropGroupValue = function (categoryType, categoryDrillDown, categoryValue) {\n  var pos = categoryValue.categoryName.indexOf('.');\n  var propertyName;\n\n  if (pos !== -1) {\n    propertyName = categoryValue.categoryName.slice(pos + 1);\n  } else {\n    propertyName = categoryValue.categoryName;\n  }\n\n  var mapKey = propertyName + '.' + categoryValue.name;\n  var filterValue = {};\n\n  if (categoryValue.color && customPropValueColorMap[mapKey]) {\n    filterValue.propertyGroupID = categoryValue.color;\n    var rgbColorValue = getFilterColorRGBValue(categoryValue.color);\n    filterValue.colorValue = rgbColorValue;\n  } else {\n    filterValue.propertyGroupID = getFilterColorValue(categoryValue.colorIndex);\n    filterValue.colorIndex = categoryValue.colorIndex;\n    filterValue.colorValue = getFilterColorRGBValue('aw-charts-chartColor' + (categoryValue.colorIndex % 9 + 1));\n  }\n\n  if (categoryType === 'DateFilter') {\n    if (categoryValue.colorIndex >= categoryDrillDown) {\n      if (categoryValue.internalName !== '$NONE') {\n        filterValue.startValue = categoryValue.startDateValue;\n        filterValue.endValue = categoryValue.endDateValue;\n      } else {\n        filterValue.startValue = '$NONE';\n      }\n    }\n  } else {\n    filterValue.startValue = categoryValue.internalName;\n    filterValue.endValue = '';\n  }\n\n  return filterValue;\n};\n/**\n * Returns filter RGB values for a category to be shown in viewer\n * @param {STRING} color color\n * @returns {Object} filter Color RGB value\n */\n\nexport let getFilterColorRGBValue = function (color) {\n  var colorBlock = '.aw-ui-filterNameColorBlock';\n  var colorBlockElement = $(colorBlock);\n  var elementExists = colorBlockElement && colorBlockElement.length > 0;\n\n  if (!elementExists) {\n    //in the case of ACE filter panel, the rendering of the panel is delayed\n    colorBlock = '.aw-layout-globalToolbarPanel';\n    colorBlockElement = $(colorBlock);\n    elementExists = colorBlockElement && colorBlockElement.length > 0;\n  }\n\n  if (elementExists) {\n    var p = colorBlockElement[0];\n    var replacedClassName = p.className;\n    p.className = 'aw-ui-filterNameColorBlock ' + color;\n    var style2 = window.getComputedStyle(p, null).getPropertyValue('background-color');\n    p.className = replacedClassName;\n    return style2;\n  }\n\n  return '';\n};\n/**\n * Returns filter values for a category to be shown in panel\n * @param {Integer} index index\n * @returns {Object} filter value\n */\n\nexport let getFilterColorValue = function (index) {\n  return index > -1 ? 'aw-charts-chartColor' + (index % 9 + 1) : '';\n};\n/**\n * Get property name from filter name.\n *\n * @param {String} filterName - The filter name\n * @return {propName} property name\n */\n\nexport let getPropertyFromFilter = function (filterName) {\n  var propName = filterName;\n  var YEAR_SUFFIX = '_0Z0_year';\n  var YEAR_MONTH_SUFFIX = '_0Z0_year_month';\n  var WEEK_SUFFIX = '_0Z0_week';\n  var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';\n\n  if (_.endsWith(filterName, YEAR_MONTH_DAY_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_MONTH_DAY_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, WEEK_SUFFIX) === true) {\n    propName = filterName.replace(WEEK_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, YEAR_MONTH_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_MONTH_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, YEAR_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_SUFFIX, '');\n  }\n\n  return propName;\n};\n/**\n * Get formatted date.\n *\n * @param {String} dateString - input date\n *\n * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range\n *\n * @return {formattedDate} formatted date\n */\n\nexport let getFormattedFilterDate = function (dateString, isDateRangeToDate) {\n  var formattedDate;\n\n  if (dateString === '*') {\n    if (isDateRangeToDate) {\n      formattedDate = ENDING_OF_TIME;\n    } else {\n      formattedDate = BEGINNING_OF_TIME;\n    }\n  } else {\n    try {\n      var date = convertToUTC(new Date(dateString));\n      formattedDate = dateTimeService.formatUTC(date);\n    } catch (e) {\n      logger.error('The specified date is invalid and will be ignored for the search:', dateString);\n      return null;\n    }\n  }\n\n  return formattedDate;\n};\n/**\n * Get formatted numeric range filter.\n *\n * @param {String} filterValue - filterValue\n *\n * @return {formattedNumber} formatted filter\n */\n\nexport let getFormattedFilterNumber = function (filterValue) {\n  var formattedFilter = {};\n  var startToEnd = filterValue.split(' TO ');\n  var startNumber = parseFloat(startToEnd[0]);\n  var endNumber = parseFloat(startToEnd[1]);\n\n  if (isNaN(startNumber) && isNaN(endNumber)) {\n    logger.error('The specified range is invalid and will be ignored for the search:', filterValue);\n    return null;\n  } else if (startToEnd[0] === '*') {\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: 0,\n      endNumericValue: endNumber,\n      startEndRange: NumericRangeBlankStart\n    };\n  } else if (startToEnd[1] === '*') {\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: startNumber,\n      endNumericValue: 0,\n      startEndRange: NumericRangeBlankEnd\n    };\n  } else {\n    if (isNaN(startNumber) || isNaN(endNumber)) {\n      logger.error('The specified range is invalid and will be ignored for the search:', filterValue);\n      return null;\n    }\n\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: startNumber,\n      endNumericValue: endNumber,\n      startEndRange: NUMERIC_RANGE\n    };\n  }\n\n  return formattedFilter;\n};\n/**\n * Get Range Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\n\nexport let getRangeSearchFilter = function (filterType, filterValue) {\n  // range search.\n  var searchFilter;\n  var startToEnd = filterValue.split(' TO ');\n\n  if (filterType === 'NumericFilter') {\n    searchFilter = getFormattedFilterNumber(filterValue);\n  } else if (filterType === 'DateFilter') {\n    var startDate = getFormattedFilterDate(startToEnd[0].trim(), false);\n    var endDate = getFormattedFilterDate(startToEnd[1].trim(), true);\n\n    if (startDate && endDate) {\n      searchFilter = {\n        searchFilterType: filterType,\n        startDateValue: startDate,\n        endDateValue: endDate\n      };\n    }\n  } else {\n    // String type, but string type should not support range search,\n    // so treat the \" TO \" as just part of the filter value\n    searchFilter = {\n      searchFilterType: filterType,\n      stringValue: filterValue\n    };\n  }\n\n  return searchFilter;\n};\n/**\n * Get Single Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\n\nexport let getSingleSearchFilter = function (filterType, filterValue) {\n  // range search.\n  var searchFilter;\n\n  if (filterType === 'NumericFilter') {\n    try {\n      var formattedNumber = parseFloat(filterValue);\n\n      if (isNaN(formattedNumber)) {\n        logger.error('The specified number is invalid and will be ignored for the search:', filterValue);\n      } else {\n        searchFilter = {\n          searchFilterType: filterType,\n          startNumericValue: formattedNumber,\n          endNumericValue: formattedNumber,\n          stringValue: filterValue\n        };\n      }\n    } catch (e) {\n      logger.error('The specified number is invalid and will be ignored for the search:', filterValue);\n    }\n  } else {\n    // Date type is also treated as String, if it's not date range.\n    searchFilter = {\n      searchFilterType: 'StringFilter',\n      stringValue: filterValue\n    };\n  }\n\n  return searchFilter;\n};\n/**\n * Get filter type based on the value type.\n *\n * @param {Integer} valueType - The valueType for this property\n *\n * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)\n */\n\nexport let getFilterType = function (valueType) {\n  var filterType;\n\n  switch (valueType) {\n    case 2:\n      filterType = 'DateFilter';\n      break;\n\n    case 3:\n    case 4:\n    case 5:\n    case 7:\n      filterType = 'NumericFilter';\n      break;\n\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n      // filterType = 'ObjectFilter';\n      // ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.\n      filterType = 'StringFilter';\n      break;\n\n    default:\n      filterType = 'StringFilter';\n      break;\n  }\n\n  return filterType;\n};\n/**\n * Display search prefilter error\n *\n * @param {String} prefilter - The search prefilter\n *\n */\n\nexport let displayPrefilterError = function (prefilter) {\n  var msg = _invalidPrefilter.replace('{0}', prefilter);\n\n  messagingService.showError(msg);\n};\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.\n * This is used to overide filter color in filter panel.\n * Preference value is in formate <propertyname>.<value>:<colorValue>\n */\n\nexport let getPreferenceValue = () => {\n  let values = appCtxService.getCtx('preferences.AWC_CustomPropValueColor');\n\n  if (values && values[0]) {\n    for (var i = 0; i < values.length; i++) {\n      var prefVal = values[i];\n      var pos = prefVal.indexOf(':');\n      var color = prefVal.slice(pos + 1);\n      var property = prefVal.slice(0, pos);\n      customPropValueColorMap[property] = color;\n    }\n  }\n};\n/**\n * get filter color\n *\n * @param propertyName filter name\n *\n * @returns color color code need to be applied for filter\n */\n\nexport let getCustomPropValueColorMap = function (propertyName) {\n  return customPropValueColorMap[propertyName];\n};\n/**\n * set filter color\n *\n * @param propertyName filter name\n *\n * @param color color code need to be applied for filter\n */\n\nexport let setCustomPropValueColorMap = function (propertyName, color) {\n  customPropValueColorMap[propertyName] = color;\n};\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.\n */\n\nexport let applyCustomColor = function (categoryName, categoryValue, filterValue) {\n  var pos = categoryName.indexOf('.');\n  var propertyName;\n\n  if (pos !== -1) {\n    propertyName = categoryName.slice(pos + 1);\n  } else {\n    propertyName = categoryName;\n  }\n\n  var mapKey = propertyName + '.' + categoryValue.stringValue; //Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference\n\n  if (customPropValueColorMap[mapKey]) {\n    if (categoryValue.colorValue) {\n      //This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later\n      filterValue.color = categoryValue.colorValue;\n    } else {\n      //This scenario will be hit in the cases where color value is not being populated by server response\n      filterValue.color = customPropValueColorMap[mapKey];\n    }\n  }\n};\n/**\n * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not\n * @param { Object } category - the current category\n * @returns { Boolean } true/false\n */\n\nexport let checkIfFilterValuesExist = function (category) {\n  if (category.filterValues && category.filterValues.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true\n * @returns { Boolean } true/false\n */\n\nexport let isLimitedCategoriesFeatureEnabled = function () {\n  var preferenceValue = appCtxService.getCtx('preferences.' + AWC_LIMITED_FILTER_CATEGORIES_ENABLED);\n\n  if (preferenceValue && preferenceValue[0].toLowerCase() === 'true') {\n    return true;\n  }\n\n  return false;\n};\n/**\n * ifFilterSelectedForCategory - check if the current category has some filter as selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let ifFilterSelectedForCategory = function (category) {\n  var filterValuesExist = checkIfFilterValuesExist(category);\n\n  if (filterValuesExist) {\n    for (var index = 0; index < category.filterValues.length; index++) {\n      if (category.filterValues[index].selected) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * isClsCategory - check if the current category is a classification type\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let isClsCategory = category => {\n  if (category.filterValues && (category.filterValues.parentnodes && category.filterValues.parentnodes.length > 0 || category.filterValues.childnodes && category.filterValues.childnodes.length > 0)) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let ifFilterSelectedForCls = category => {\n  var filterValuesExist = isClsCategory(category);\n\n  if (filterValuesExist) {\n    for (var index = 0; index < category.filterValues.parentnodes.length; index++) {\n      if (category.filterValues.parentnodes[index].selected) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * getFilterFocus - return whether to set autoFocus for a filter as true or false\n * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info\n * @param { Object } filter current filter\n * @param { Object } categoryInternalName current category internal name\n * @param { Integer } index - current filter index\n * @returns { Boolean } autoFocus value for the filter - true/false\n */\n\nexport const getFilterFocus = (lastSelectedFilterAndCategoryInfo, filter, categoryInternalName, index) => {\n  let lastAction = lastSelectedFilterAndCategoryInfo ? lastSelectedFilterAndCategoryInfo.lastAction : '';\n\n  switch (lastAction) {\n    case 'selectFilter':\n      if (lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName === filter.categoryName && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName === filter.internalName) {\n        return true;\n      }\n\n      return false;\n\n    case 'dateRangeSearch':\n      if (index === 0 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory === categoryInternalName) {\n        return true;\n      }\n\n      return false;\n\n    case 'numericRangeSearch':\n      if (index === 1 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory === categoryInternalName) {\n        return true;\n      }\n\n      return false;\n\n    default:\n      return false;\n  }\n};\nexport let loadConfiguration = function () {\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidDate', true).then(result => _invalidDateText = result);\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidRange', true).then(result => _invalidRangeText = result);\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidPrefilter', true).then(result => _invalidPrefilter = result);\n};\nloadConfiguration();\nexport default {\n  HIERARCHICAL_FACET_SEPARATOR,\n  PRESET_CATEGORY,\n  DATE_FILTER,\n  INTERNAL_DATE_FILTER,\n  DATE_RANGE_FILTER,\n  DATE_DRILLDOWN_FILTER,\n  NUMERIC_RANGE_FILTER,\n  INTERNAL_NUMERIC_FILTER,\n  INTERNAL_OBJECT_FILTER,\n  INTERNAL_NUMERIC_RANGE,\n  NUMERIC_FILTER,\n  NUMERIC_RANGE,\n  NumericRangeBlankStart,\n  NumericRangeBlankEnd,\n  NO_STARTDATE,\n  NO_ENDDATE,\n  NO_STARTRANGE,\n  NO_ENDRANGE,\n  BEGINNING_OF_TIME,\n  ENDING_OF_TIME,\n  getDate,\n  isNullDate,\n  validateDates,\n  getDateRangeString,\n  getDateRangeFilter,\n  getDateRangeDisplayString,\n  checkIfValidRange,\n  validateNumericRangeSelected,\n  validateNumericRange,\n  getNumericRangeString,\n  getNumericRangeFilter,\n  getNumericRangeDisplayString,\n  getRealFilterWithNoFilterType,\n  getFilterTypeFromFilterValue,\n  isPresetFilters,\n  setPresetFilters,\n  getHasTypeFilter,\n  setHasTypeFilter,\n  setIncontext,\n  getIncontext,\n  saveIncontextFilterMap,\n  getCategoryInternalName,\n  getCurrentCategory,\n  getPropGroupValues,\n  getPropGroupValue,\n  getFilterColorRGBValue,\n  getFilterColorValue,\n  getPropertyFromFilter,\n  getFormattedFilterDate,\n  getFormattedFilterNumber,\n  getRangeSearchFilter,\n  getSingleSearchFilter,\n  getFilterType,\n  displayPrefilterError,\n  getPreferenceValue,\n  getCustomPropValueColorMap,\n  setCustomPropValueColorMap,\n  applyCustomColor,\n  checkIfFilterValuesExist,\n  isLimitedCategoriesFeatureEnabled,\n  ifFilterSelectedForCategory,\n  isClsCategory,\n  ifFilterSelectedForCls,\n  getFilterFocus\n};","map":{"version":3,"names":["appCtxService","dateTimeService","messagingService","localeSvc","$","logger","_","_invalidDateText","_invalidRangeText","_invalidPrefilter","AWC_LIMITED_FILTER_CATEGORIES_ENABLED","HIERARCHICAL_FACET_SEPARATOR","PRESET_CATEGORY","DATE_FILTER","INTERNAL_DATE_FILTER","DATE_RANGE_FILTER","DATE_DRILLDOWN_FILTER","NUMERIC_RANGE_FILTER","INTERNAL_NUMERIC_FILTER","INTERNAL_OBJECT_FILTER","INTERNAL_NUMERIC_RANGE","NUMERIC_FILTER","NUMERIC_RANGE","NumericRangeBlankStart","NumericRangeBlankEnd","INTERNAL_TO","NO_STARTDATE","NO_ENDDATE","NO_STARTRANGE","NO_ENDRANGE","BEGINNING_OF_TIME","ENDING_OF_TIME","START_OF_DAY","_presetFilters","_hasTypeFilter","_incontextFlag","customPropValueColorMap","getDate","dateString","dateStr","substring","date","startsWith","getNullDate","timeStr","length","indexOf","replace","Date","convertToUTC","gmtTime","getTime","offset","getTimezoneOffset","jsDate","isNullDate","dateToTest","getFullYear","validateDates","category","startDate","origStartDate","endDate","origEndDate","showSearch","cStartDate","daterange","eEndDate","dateRangeSelected","valueUpdated","tmpStartDate","moveDateToStartOfDay","tmpEndDate","noStartDate","noEndDate","temp1","compare","showError","disable","tmpOrigEndDate","dateApi","dateObject","compare1","compare2","getDateRangeString","fromDateString","formatUTC","toDateString","moveDateToEndOfDay","getDateRangeFilter","filter","searchFilter","sArr","split","searchFilterType","NULLDATE","startDateValue","endDateValue","getDateRangeDisplayString","dateRangeFilter","dateRangeString","formatDate","displayName","categoryType","checkIfValidRange","startRange","endRange","errorValue","msg","validateNumericRangeSelected","cStartRange","cEndRange","hasValidated","oStartRange","numericrange","startNumericValue","oEndRange","endNumericValue","pStartRange","parseFloat","pEndRange","invalidStart","isNaN","startEndRange","invalidEnd","validateNumericRange","startValue","dbValue","endValue","numericRangeSelected","noStartRange","undefined","noEndRange","isFinite","getNumericRangeString","fromValue","toString","toValue","getNumericRangeFilter","getNumericRangeDisplayString","numericRangeFilter","numericRangeString","getRealFilterWithNoFilterType","realFilter","hasOwnProperty","getFilterTypeFromFilterValue","filterType","setHours","isPresetFilters","setPresetFilters","flag","getHasTypeFilter","setHasTypeFilter","setIncontext","getIncontext","saveIncontextFilterMap","data","inContextMap","tmpValues","searchFilterMap","getCategoryInternalName","internalName","getCurrentCategory","response","groupedObjectsList","internalPropertyName","getPropGroupValues","getPreferenceValue","values","i","filterValues","categoryValue","color","push","getPropGroupValue","type","drilldown","categoryDrillDown","pos","categoryName","propertyName","slice","mapKey","name","filterValue","propertyGroupID","rgbColorValue","getFilterColorRGBValue","colorValue","getFilterColorValue","colorIndex","colorBlock","colorBlockElement","elementExists","p","replacedClassName","className","style2","window","getComputedStyle","getPropertyValue","index","getPropertyFromFilter","filterName","propName","YEAR_SUFFIX","YEAR_MONTH_SUFFIX","WEEK_SUFFIX","YEAR_MONTH_DAY_SUFFIX","endsWith","getFormattedFilterDate","isDateRangeToDate","formattedDate","e","error","getFormattedFilterNumber","formattedFilter","startToEnd","startNumber","endNumber","getRangeSearchFilter","trim","stringValue","getSingleSearchFilter","formattedNumber","getFilterType","valueType","displayPrefilterError","prefilter","getCtx","prefVal","property","getCustomPropValueColorMap","setCustomPropValueColorMap","applyCustomColor","checkIfFilterValuesExist","isLimitedCategoriesFeatureEnabled","preferenceValue","toLowerCase","ifFilterSelectedForCategory","filterValuesExist","selected","isClsCategory","parentnodes","childnodes","ifFilterSelectedForCls","getFilterFocus","lastSelectedFilterAndCategoryInfo","categoryInternalName","lastAction","lastSelectedFilter","lastDateRangeSearchCategory","lastNumericRangeSearchCategory","loadConfiguration","getLocalizedTextFromKey","then","result"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/searchcore/src/js/filterPanelUtils.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/filterPanelUtils\n */\nimport appCtxService from 'js/appCtxService';\nimport dateTimeService from 'js/dateTimeService';\nimport messagingService from 'js/messagingService';\nimport localeSvc from 'js/localeService';\nimport $ from 'jquery';\nimport logger from 'js/logger';\nimport _ from 'lodash';\n\nvar _invalidDateText = '';\nvar _invalidRangeText = '';\nvar _invalidPrefilter = '';\nvar AWC_LIMITED_FILTER_CATEGORIES_ENABLED = 'AWC_Limited_Filter_Categories_Enabled';\n\nexport let HIERARCHICAL_FACET_SEPARATOR = '/';\nexport let PRESET_CATEGORY = 'WorkspaceObject.object_type';\nexport let DATE_FILTER = 'DateFilter';\nexport let INTERNAL_DATE_FILTER = '_DateFilter_';\nexport let DATE_RANGE_FILTER = 'DateRangeFilter';\nexport let DATE_DRILLDOWN_FILTER = 'DrilldownDateFilter';\nexport let NUMERIC_RANGE_FILTER = 'NumericRangeFilter';\nexport let INTERNAL_NUMERIC_FILTER = '_NumericFilter_';\nexport let INTERNAL_OBJECT_FILTER = '_ObjectFilter_';\nexport let INTERNAL_NUMERIC_RANGE = '_NumericRange_';\nexport let NUMERIC_FILTER = 'NumericFilter';\nexport let NUMERIC_RANGE = 'NumericRange';\nexport let NumericRangeBlankStart = 'NumericRangeBlankStart';\nexport let NumericRangeBlankEnd = 'NumericRangeBlankEnd';\nvar INTERNAL_TO = '_TO_';\nexport let NO_STARTDATE = '*';\nexport let NO_ENDDATE = '2100-12-31';\nexport let NO_STARTRANGE = '';\nexport let NO_ENDRANGE = '';\nexport let BEGINNING_OF_TIME = '0001-01-01T00:00:00';\nexport let ENDING_OF_TIME = '2100-12-31T23:59:59';\nvar START_OF_DAY = '00:00:00';\nvar _presetFilters = true;\nvar _hasTypeFilter = false;\nvar _incontextFlag = false;\nvar customPropValueColorMap = {};\n\n/**\n * Returns a date object.\n *\n * @function getDate\n * @memberOf filterPanelUtils\n *\n * @param {String}dateString - date string to be converted to date object\n *\n * @return {JsDate} a date object.\n */\nexport let getDate = function( dateString ) {\n    var dateStr = dateString.substring( 0, 10 );\n    var date;\n    // change open start/end date to null dates\n    if( _.startsWith( dateStr, '0001-01-0' ) || _.startsWith( dateStr, '2100-12-3' ) ) {\n        date = dateTimeService.getNullDate();\n    } else {\n        var timeStr = dateString.substring( 11, dateString.length - 6 );\n        if( timeStr.indexOf( '59' ) !== -1 ) {\n            dateStr = dateString.replace( timeStr, START_OF_DAY );\n        } else {\n            dateStr = dateString;\n        }\n        date = new Date( dateStr );\n    }\n\n    return date;\n};\n\n/**\n * Returns a UTC date object.\n *\n * @function convertToUTC\n * @memberOf filterPanelUtils\n *\n * @param {Object}date - date object\n *\n * @return {JsDate} a UTC date object.\n */\nfunction convertToUTC( date ) {\n    var gmtTime = date.getTime();\n    var offset = date.getTimezoneOffset();\n    var jsDate = new Date( gmtTime + offset * 60 * 1000 );\n    return new Date( jsDate.getTime() );\n}\n/**\n * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can\n * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the\n * dateTimeService.isNullDate.\n *\n * @function isNullDate\n * @memberOf filterPanelUtils\n *\n * @param {Object} dateToTest - a Date object.\n * @returns {Boolean} - true if it's a null date.\n */\nexport let isNullDate = function( dateToTest ) {\n    if( !dateToTest ) {\n        return true;\n    }\n    return dateToTest.getFullYear() <= 1;\n};\n\n/**\n * Validate dates for category date range.\n *\n * @function validateDates\n * @memberOf filterPanelUtils\n *\n * @param {Object}category - category. This object is modified in this function.\n * @param {Object}startDate - startDate\n * @param {Object}origStartDate - origStartDate\n * @param {Object}endDate - endDate\n * @param {Object}origEndDate - origEndDate\n */\nexport let validateDates = function( category, startDate, origStartDate, endDate, origEndDate ) {\n    category.showSearch = true;\n\n    var cStartDate = category.daterange.startDate;\n    var eEndDate = category.daterange.endDate;\n    if( category.daterange.dateRangeSelected && !cStartDate.valueUpdated && !eEndDate.valueUpdated ) {\n        category.showSearch = false;\n        return;\n    }\n    // The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,\n    // which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.\n    var tmpStartDate = moveDateToStartOfDay( startDate );\n    var tmpEndDate = moveDateToStartOfDay( endDate );\n    var noStartDate = dateTimeService.isNullDate( tmpStartDate );\n    var noEndDate = dateTimeService.isNullDate( tmpEndDate );\n\n    // if both dates are not set, disable search button\n    if( noStartDate && noEndDate ) {\n        category.showSearch = false;\n        return;\n    }\n    var temp1 = dateTimeService.compare( startDate, endDate );\n    // if start date is later than end date, disable search button\n    if( !noStartDate && !noEndDate && startDate !== null && temp1 === 1 ) {\n        messagingService.showError( _invalidDateText );\n        category.showSearch = false;\n        return;\n    }\n\n    var disable;\n    // check if dates vary from previous search to avoid enabling search\n    var tmpOrigEndDate = moveDateToStartOfDay( origEndDate );\n\n    if( noStartDate ) {\n        // check if there is no startdate and if end date is same, disable search button\n        disable = category.daterange.startDate === null &&\n            dateTimeService.compare( tmpEndDate, tmpOrigEndDate ) === 0;\n    } else if( noEndDate ) {\n        // check if there is no enddate and  start date is same, disable search button\n        disable = category.daterange.endDate === null &&\n            dateTimeService.compare( startDate, category.daterange.startDate.dateApi.dateObject ) === 0;\n    } else {\n        // if the dates are same as previous search, disable search button\n        var compare1 = dateTimeService.compare( startDate, origStartDate ) === 0;\n        var compare2 = dateTimeService.compare( endDate, tmpOrigEndDate ) === 0;\n        disable = compare1 && compare2;\n    }\n    category.showSearch = !disable;\n};\n\n/**\n * get date range filter.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {Object}startDate - startDate\n * @param {Object}endDate - endDate\n *\n * @return {String} a string that represents the date range.\n */\nexport let getDateRangeString = function( startDate, endDate ) {\n    var noStartDate = isNullDate( startDate );\n    var noEndDate = isNullDate( endDate );\n    var fromDateString = noStartDate ? NO_STARTDATE : dateTimeService.formatUTC( startDate );\n    if( noEndDate ) {\n        endDate = new Date( NO_ENDDATE );\n    }\n    var toDateString = dateTimeService.formatUTC( moveDateToEndOfDay( endDate ) );\n    return INTERNAL_DATE_FILTER + fromDateString + INTERNAL_TO + toDateString;\n};\n\n/**\n * get filter of date range.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a filter object of date range for the filter string.\n */\nexport let getDateRangeFilter = function( filter ) {\n    var searchFilter = {};\n    var sArr = filter.split( INTERNAL_TO );\n    searchFilter.searchFilterType = 'DateFilter';\n    sArr[ 0 ] = sArr[ 0 ] === NO_STARTDATE ? dateTimeService.NULLDATE : dateTimeService.formatUTC( sArr[ 0 ] );\n    searchFilter.startDateValue = sArr[ 0 ];\n    searchFilter.endDateValue = sArr[ 1 ];\n    return searchFilter;\n};\n\n/**\n * get a date range filter with display name and category type.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}startDate - startDate\n * @param {String}endDate - endDate\n *\n * @return {Object} a date range filter with display name and category type.\n */\nexport let getDateRangeDisplayString = function( startDate, endDate ) {\n    var dateRangeFilter = {};\n    var noStartDate = dateTimeService.isNullDate( startDate );\n    var noEndDate = dateTimeService.isNullDate( endDate );\n    var dateRangeString;\n    if( noStartDate ) {\n        dateRangeString = 'To ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );\n    } else if( noEndDate ) {\n        dateRangeString = 'From ' +\n            dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 );\n    } else {\n        dateRangeString = dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 ) +\n            ' - ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );\n    }\n    dateRangeFilter.displayName = dateRangeString;\n    dateRangeFilter.categoryType = DATE_RANGE_FILTER;\n    return dateRangeFilter;\n};\n\n/**\n * Simple check to validate the given category numeric range.\n *\n * @function checkIfValidRange\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n *\n * @return {Boolean} true if valid range.\n */\nexport let checkIfValidRange = function( category, startRange, endRange ) {\n    category.showSearch = true;\n\n    if( startRange !== null && endRange !== null && startRange > endRange ) {\n        var errorValue = startRange + '-' + endRange;\n        var msg = _invalidRangeText.replace( '{0}', errorValue );\n        messagingService.showError( msg );\n        category.showSearch = false;\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Validate the given category numeric range if the range is selected.\n *\n * @function validateNumericRangeSelected\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {Number}cStartRange - current startRange\n * @param {Number}cEndRange - current endRange\n * @return {Boolean} true if valid range.\n */\nexport let validateNumericRangeSelected = function( category, startRange, endRange, cStartRange, cEndRange ) {\n    var hasValidated = false;\n\n    var oStartRange = category.numericrange.filter.startNumericValue;\n    var oEndRange = category.numericrange.filter.endNumericValue;\n\n    var pStartRange = parseFloat( cStartRange );\n    var pEndRange = parseFloat( cEndRange );\n\n    var invalidStart = cStartRange === oStartRange || pStartRange === oStartRange ||\n        isNaN( pStartRange ) && oStartRange === NO_STARTRANGE;\n    // when the start range goes from blank to 0, it's a real change, so the search button should be enabled.\n    if( category.numericrange.filter.startEndRange === NumericRangeBlankStart ) {\n        invalidStart = isNaN( pStartRange );\n    }\n    var invalidEnd = cEndRange === oEndRange || pEndRange === oEndRange || isNaN( pEndRange ) && oEndRange === NO_ENDRANGE;\n    if( category.numericrange.filter.startEndRange === NumericRangeBlankEnd ) {\n        invalidEnd = isNaN( pEndRange );\n    }\n    // when the end range goes from blank to 0, it's a real change, so the search button should be enabled.\n    if( invalidStart && invalidEnd ) {\n        category.showSearch = false;\n        hasValidated = true;\n    }\n    return hasValidated;\n};\n/**\n * Validate ranges for category numeric range.\n *\n * @function validateNumericRange\n * @memberOf filterPanelUtils\n *\n * @param {String} category - category\n * @param {String} startRange - startRange\n * @param {String} endRange - endRange\n *\n */\nexport let validateNumericRange = function( category, startRange, endRange ) {\n    category.showSearch = true;\n\n    // Validate values to be numbers\n    var cStartRange = category.numericrange.startValue.dbValue;\n    var cEndRange = category.numericrange.endValue.dbValue;\n    var oStartRange = null;\n    var oEndRange = null;\n\n    if( category.numericrange.numericRangeSelected && validateNumericRangeSelected( category, startRange, endRange, cStartRange, cEndRange ) ) {\n        return;\n    }\n\n    var noStartRange = cStartRange === undefined || cStartRange === null || cStartRange === '';\n    var noEndRange = cEndRange === undefined || cEndRange === null || cEndRange === '';\n\n    // if both numbers are not set, disable search button\n    if( noStartRange && noEndRange ) {\n        category.showSearch = false;\n        return;\n    }\n\n    var disable = false;\n    if( noStartRange ) {\n        disable = endRange === oEndRange || isNaN( endRange );\n    } else if( noEndRange ) {\n        // check if there is no endRange and  start number is same, disable search button\n        disable = startRange === oStartRange || isNaN( startRange );\n    } else {\n        disable = !isFinite( startRange ) || isNaN( startRange ) || !isFinite( endRange ) || isNaN( endRange );\n    }\n    category.showSearch = !disable;\n};\n\n/**\n * get numeric range filter string.\n *\n * @function getNumericRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}startRange - startRange\n * @param {String}endRange - endRange\n *\n * @return {String} a numeric range string.\n */\nexport let getNumericRangeString = function( startRange, endRange ) {\n    var fromValue = startRange && startRange.toString();\n    if( fromValue === undefined || fromValue === null || fromValue.length === 0 || isNaN( fromValue ) ) {\n        fromValue = NO_STARTRANGE;\n    }\n    var toValue = endRange && endRange.toString();\n    if( toValue === undefined || toValue === null || toValue.length === 0 || isNaN( toValue ) ) {\n        toValue = NO_ENDRANGE;\n    }\n    return INTERNAL_NUMERIC_RANGE + fromValue + INTERNAL_TO + toValue;\n};\n\n/**\n * get numeric range filter from a filter string.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a numeric range filter.\n */\nexport let getNumericRangeFilter = function( filter ) {\n    var searchFilter = {};\n    var sArr = filter.split( INTERNAL_TO );\n    searchFilter.searchFilterType = NUMERIC_FILTER;\n    searchFilter.startNumericValue = parseFloat( sArr[ 0 ] );\n    searchFilter.endNumericValue = parseFloat( sArr[ 1 ] );\n    if( isNaN( searchFilter.startNumericValue ) ) {\n        searchFilter.startEndRange = NumericRangeBlankStart;\n    } else if( isNaN( searchFilter.endNumericValue ) ) {\n        searchFilter.startEndRange = NumericRangeBlankEnd;\n    } else {\n        searchFilter.startEndRange = NUMERIC_RANGE;\n    }\n    return searchFilter;\n};\n\n/**\n * get a numeric range filter.\n *\n * @function getNumericRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {String}startEndRange - startEndRange\n *\n * @return {Object} a numeric range filter with display name and category type.\n */\nexport let getNumericRangeDisplayString = function( startRange, endRange, startEndRange ) {\n    var numericRangeFilter = {};\n    var noStartRange = startEndRange === NumericRangeBlankStart || startRange !== 0 && !startRange;\n    var noEndRange = startEndRange === NumericRangeBlankEnd || endRange !== 0 && !endRange;\n\n    var numericRangeString;\n    if( noStartRange ) {\n        numericRangeString = 'To ' + endRange.toString();\n    } else if( noEndRange ) {\n        numericRangeString = 'From ' + startRange.toString();\n    } else {\n        numericRangeString = startRange.toString() + ' - ' + endRange.toString();\n    }\n    numericRangeFilter.displayName = numericRangeString;\n    numericRangeFilter.categoryType = NUMERIC_RANGE_FILTER;\n    return numericRangeFilter;\n};\n\n/**\n * get a real filter.\n *\n * @function getRealFilterWithNoFilterType\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} the real filter stripped off the identifiers.\n */\nexport let getRealFilterWithNoFilterType = function( filter ) {\n    var realFilter = filter;\n    if( !filter.hasOwnProperty( 'property' ) ) {\n        realFilter = filter.replace( INTERNAL_NUMERIC_FILTER, '' ).replace( INTERNAL_OBJECT_FILTER, '' );\n    }\n    return realFilter;\n};\n\n/**\n * get filter type from filter value.\n *\n * @function getFilterTypeFromFilterValue\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {String} filter type, if it can be derived.\n */\nexport let getFilterTypeFromFilterValue = function( filter ) {\n    var filterType;\n    if( _.startsWith( filter, INTERNAL_OBJECT_FILTER ) ) {\n        filterType = 'ObjectFilter';\n    } else if( _.startsWith( filter, INTERNAL_NUMERIC_FILTER ) ) {\n        filterType = 'NumericFilter';\n    } else {\n        filterType = 'DateFilter';\n    }\n    return filterType;\n};\n\n/**\n * /** Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\nfunction moveDateToStartOfDay( date ) {\n    if( !dateTimeService.isNullDate( date ) ) {\n        date.setHours( 0, 0, 0 );\n        return date;\n    }\n    return date;\n}\n\n/**\n * Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\nfunction moveDateToEndOfDay( date ) {\n    if( !dateTimeService.isNullDate( date ) ) {\n        date.setHours( 23, 59, 59 );\n        return date;\n    }\n    return date;\n}\n\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\nexport let isPresetFilters = function() {\n    return _presetFilters;\n};\n\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag flag\n */\nexport let setPresetFilters = function( flag ) {\n    _presetFilters = flag;\n};\n\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\nexport let getHasTypeFilter = function() {\n    return _hasTypeFilter;\n};\n\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag preset filter flag\n */\nexport let setHasTypeFilter = function( flag ) {\n    _hasTypeFilter = flag;\n};\n\n/**\n * Sets incontext flag\n *\n * @param {Object} flag incontext flag\n */\nexport let setIncontext = function( flag ) {\n    _incontextFlag = flag;\n};\n\n/**\n * Gets incontext flag\n *\n * @returns {Object} incontext flag\n */\nexport let getIncontext = function() {\n    return _incontextFlag;\n};\n\n/**\n * Save source filter map in appcontext for incontext\n *\n * @param {Object} data data\n */\nexport let saveIncontextFilterMap = function( data ) {\n    let inContextMap = {};\n    if( getHasTypeFilter() ) {\n        // Create a filter value for each category value\n        let tmpValues = data.searchFilterMap[ PRESET_CATEGORY ];\n        inContextMap[ PRESET_CATEGORY ] = tmpValues;\n    }\n    return inContextMap;\n};\n\n/**\n * Returns category internal name\n * @param {Object} category category\n * @returns {Object} The category internal name\n */\nexport let getCategoryInternalName = function( category ) {\n    return category.internalName;\n};\n\n/**\n * Returns current category\n *\n * @param {Object} response the response from the search SOA\n * @returns {Object} The current category\n */\nexport let getCurrentCategory = function( response ) {\n    return response.groupedObjectsList[ 0 ].internalPropertyName;\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n *\n * @param {Object} category the category to get values for\n *\n * @returns {ObjectArray} The array of filters to show in panel\n */\nexport let getPropGroupValues = function( category ) {\n    getPreferenceValue();\n\n    var values = [];\n    for( var i = 0; i < category.filterValues.length; i++ ) {\n        var categoryValue = category.filterValues[ i ];\n        if( categoryValue && ( i < 9 || categoryValue.color ) ) {\n            values.push( getPropGroupValue( category.type, category.drilldown, categoryValue ) );\n        }\n    }\n\n    return values;\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n * @param {String} categoryType categoryType\n * @param {Integer} categoryDrillDown category Drill Down\n * @param {String} categoryValue categoryValue\n * @returns {Object} filter value\n */\nexport let getPropGroupValue = function( categoryType, categoryDrillDown, categoryValue ) {\n    var pos = categoryValue.categoryName.indexOf( '.' );\n    var propertyName;\n\n    if( pos !== -1 ) {\n        propertyName = categoryValue.categoryName.slice( pos + 1 );\n    } else {\n        propertyName = categoryValue.categoryName;\n    }\n    var mapKey = propertyName + '.' + categoryValue.name;\n\n    var filterValue = {};\n    if( categoryValue.color && customPropValueColorMap[ mapKey ] ) {\n        filterValue.propertyGroupID = categoryValue.color;\n        var rgbColorValue = getFilterColorRGBValue( categoryValue.color );\n        filterValue.colorValue = rgbColorValue;\n    } else {\n        filterValue.propertyGroupID = getFilterColorValue( categoryValue.colorIndex );\n        filterValue.colorIndex = categoryValue.colorIndex;\n        filterValue.colorValue = getFilterColorRGBValue( 'aw-charts-chartColor' + ( categoryValue.colorIndex % 9 + 1 ) );\n    }\n\n    if( categoryType === 'DateFilter' ) {\n        if( categoryValue.colorIndex >= categoryDrillDown ) {\n            if( categoryValue.internalName !== '$NONE' ) {\n                filterValue.startValue = categoryValue.startDateValue;\n                filterValue.endValue = categoryValue.endDateValue;\n            } else {\n                filterValue.startValue = '$NONE';\n            }\n        }\n    } else {\n        filterValue.startValue = categoryValue.internalName;\n        filterValue.endValue = '';\n    }\n\n    return filterValue;\n};\n\n/**\n * Returns filter RGB values for a category to be shown in viewer\n * @param {STRING} color color\n * @returns {Object} filter Color RGB value\n */\nexport let getFilterColorRGBValue = function( color ) {\n    var colorBlock = '.aw-ui-filterNameColorBlock';\n    var colorBlockElement = $( colorBlock );\n    var elementExists = colorBlockElement && colorBlockElement.length > 0;\n    if( !elementExists ) {\n        //in the case of ACE filter panel, the rendering of the panel is delayed\n        colorBlock = '.aw-layout-globalToolbarPanel';\n        colorBlockElement = $( colorBlock );\n        elementExists = colorBlockElement && colorBlockElement.length > 0;\n    }\n    if( elementExists ) {\n        var p = colorBlockElement[ 0 ];\n        var replacedClassName = p.className;\n        p.className = 'aw-ui-filterNameColorBlock ' + color;\n        var style2 = window.getComputedStyle( p, null ).getPropertyValue(\n            'background-color' );\n        p.className = replacedClassName;\n        return style2;\n    }\n    return '';\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n * @param {Integer} index index\n * @returns {Object} filter value\n */\nexport let getFilterColorValue = function( index ) {\n    return index > -1 ? 'aw-charts-chartColor' + ( index % 9 + 1 ) : '';\n};\n\n/**\n * Get property name from filter name.\n *\n * @param {String} filterName - The filter name\n * @return {propName} property name\n */\nexport let getPropertyFromFilter = function( filterName ) {\n    var propName = filterName;\n\n    var YEAR_SUFFIX = '_0Z0_year';\n    var YEAR_MONTH_SUFFIX = '_0Z0_year_month';\n    var WEEK_SUFFIX = '_0Z0_week';\n    var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';\n\n    if( _.endsWith( filterName, YEAR_MONTH_DAY_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_MONTH_DAY_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, WEEK_SUFFIX ) === true ) {\n        propName = filterName.replace( WEEK_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, YEAR_MONTH_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_MONTH_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, YEAR_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_SUFFIX, '' );\n    }\n    return propName;\n};\n\n/**\n * Get formatted date.\n *\n * @param {String} dateString - input date\n *\n * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range\n *\n * @return {formattedDate} formatted date\n */\nexport let getFormattedFilterDate = function( dateString, isDateRangeToDate ) {\n    var formattedDate;\n    if( dateString === '*' ) {\n        if( isDateRangeToDate ) {\n            formattedDate = ENDING_OF_TIME;\n        } else {\n            formattedDate = BEGINNING_OF_TIME;\n        }\n    } else {\n        try {\n            var date = convertToUTC( new Date( dateString ) );\n            formattedDate = dateTimeService.formatUTC( date );\n        } catch ( e ) {\n            logger.error( 'The specified date is invalid and will be ignored for the search:', dateString );\n            return null;\n        }\n    }\n    return formattedDate;\n};\n\n/**\n * Get formatted numeric range filter.\n *\n * @param {String} filterValue - filterValue\n *\n * @return {formattedNumber} formatted filter\n */\nexport let getFormattedFilterNumber = function( filterValue ) {\n    var formattedFilter = {};\n    var startToEnd = filterValue.split( ' TO ' );\n    var startNumber = parseFloat( startToEnd[ 0 ] );\n    var endNumber = parseFloat( startToEnd[ 1 ] );\n    if( isNaN( startNumber ) && isNaN( endNumber ) ) {\n        logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );\n        return null;\n    } else if( startToEnd[ 0 ] === '*' ) {\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: 0,\n            endNumericValue: endNumber,\n            startEndRange: NumericRangeBlankStart\n        };\n    } else if( startToEnd[ 1 ] === '*' ) {\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: startNumber,\n            endNumericValue: 0,\n            startEndRange: NumericRangeBlankEnd\n        };\n    } else {\n        if( isNaN( startNumber ) || isNaN( endNumber ) ) {\n            logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );\n            return null;\n        }\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: startNumber,\n            endNumericValue: endNumber,\n            startEndRange: NUMERIC_RANGE\n        };\n    }\n    return formattedFilter;\n};\n\n/**\n * Get Range Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\nexport let getRangeSearchFilter = function( filterType, filterValue ) {\n    // range search.\n    var searchFilter;\n    var startToEnd = filterValue.split( ' TO ' );\n\n    if( filterType === 'NumericFilter' ) {\n        searchFilter = getFormattedFilterNumber( filterValue );\n    } else if( filterType === 'DateFilter' ) {\n        var startDate = getFormattedFilterDate( startToEnd[ 0 ].trim(), false );\n        var endDate = getFormattedFilterDate( startToEnd[ 1 ].trim(), true );\n        if( startDate && endDate ) {\n            searchFilter = {\n                searchFilterType: filterType,\n                startDateValue: startDate,\n                endDateValue: endDate\n            };\n        }\n    } else {\n        // String type, but string type should not support range search,\n        // so treat the \" TO \" as just part of the filter value\n        searchFilter = {\n            searchFilterType: filterType,\n            stringValue: filterValue\n        };\n    }\n    return searchFilter;\n};\n\n/**\n * Get Single Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\nexport let getSingleSearchFilter = function( filterType, filterValue ) {\n    // range search.\n    var searchFilter;\n\n    if( filterType === 'NumericFilter' ) {\n        try {\n            var formattedNumber = parseFloat( filterValue );\n            if( isNaN( formattedNumber ) ) {\n                logger.error( 'The specified number is invalid and will be ignored for the search:',\n                    filterValue );\n            } else {\n                searchFilter = {\n                    searchFilterType: filterType,\n                    startNumericValue: formattedNumber,\n                    endNumericValue: formattedNumber,\n                    stringValue: filterValue\n                };\n            }\n        } catch ( e ) {\n            logger.error( 'The specified number is invalid and will be ignored for the search:', filterValue );\n        }\n    } else {\n        // Date type is also treated as String, if it's not date range.\n        searchFilter = {\n            searchFilterType: 'StringFilter',\n            stringValue: filterValue\n        };\n    }\n\n    return searchFilter;\n};\n\n/**\n * Get filter type based on the value type.\n *\n * @param {Integer} valueType - The valueType for this property\n *\n * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)\n */\nexport let getFilterType = function( valueType ) {\n    var filterType;\n    switch ( valueType ) {\n        case 2:\n            filterType = 'DateFilter';\n            break;\n        case 3:\n        case 4:\n        case 5:\n        case 7:\n            filterType = 'NumericFilter';\n            break;\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n            // filterType = 'ObjectFilter';\n            // ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.\n            filterType = 'StringFilter';\n            break;\n        default:\n            filterType = 'StringFilter';\n            break;\n    }\n    return filterType;\n};\n\n/**\n * Display search prefilter error\n *\n * @param {String} prefilter - The search prefilter\n *\n */\nexport let displayPrefilterError = function( prefilter ) {\n    var msg = _invalidPrefilter.replace( '{0}', prefilter );\n    messagingService.showError( msg );\n};\n\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.\n * This is used to overide filter color in filter panel.\n * Preference value is in formate <propertyname>.<value>:<colorValue>\n */\nexport let getPreferenceValue = () => {\n    let values = appCtxService.getCtx( 'preferences.AWC_CustomPropValueColor' );\n    if( values && values[ 0 ] ) {\n        for( var i = 0; i < values.length; i++ ) {\n            var prefVal = values[ i ];\n            var pos = prefVal.indexOf( ':' );\n            var color = prefVal.slice( pos + 1 );\n            var property = prefVal.slice( 0, pos );\n            customPropValueColorMap[ property ] = color;\n        }\n    }\n};\n\n/**\n * get filter color\n *\n * @param propertyName filter name\n *\n * @returns color color code need to be applied for filter\n */\nexport let getCustomPropValueColorMap = function( propertyName ) {\n    return customPropValueColorMap[ propertyName ];\n};\n\n/**\n * set filter color\n *\n * @param propertyName filter name\n *\n * @param color color code need to be applied for filter\n */\nexport let setCustomPropValueColorMap = function( propertyName, color ) {\n    customPropValueColorMap[ propertyName ] = color;\n};\n\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.\n */\nexport let applyCustomColor = function( categoryName, categoryValue, filterValue ) {\n    var pos = categoryName.indexOf( '.' );\n    var propertyName;\n\n    if( pos !== -1 ) {\n        propertyName = categoryName.slice( pos + 1 );\n    } else {\n        propertyName = categoryName;\n    }\n    var mapKey = propertyName + '.' + categoryValue.stringValue;\n\n    //Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference\n    if( customPropValueColorMap[ mapKey ] ) {\n        if( categoryValue.colorValue ) {\n            //This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later\n            filterValue.color = categoryValue.colorValue;\n        } else {\n            //This scenario will be hit in the cases where color value is not being populated by server response\n            filterValue.color = customPropValueColorMap[ mapKey ];\n        }\n    }\n};\n\n/**\n * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not\n * @param { Object } category - the current category\n * @returns { Boolean } true/false\n */\n\nexport let checkIfFilterValuesExist = function( category ) {\n    if( category.filterValues && category.filterValues.length > 0 ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true\n * @returns { Boolean } true/false\n */\n\nexport let isLimitedCategoriesFeatureEnabled = function() {\n    var preferenceValue = appCtxService.getCtx( 'preferences.' + AWC_LIMITED_FILTER_CATEGORIES_ENABLED );\n    if( preferenceValue && preferenceValue[ 0 ].toLowerCase() === 'true' ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * ifFilterSelectedForCategory - check if the current category has some filter as selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let ifFilterSelectedForCategory = function( category ) {\n    var filterValuesExist = checkIfFilterValuesExist( category );\n    if( filterValuesExist ) {\n        for( var index = 0; index < category.filterValues.length; index++ ) {\n            if( category.filterValues[ index ].selected ) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * isClsCategory - check if the current category is a classification type\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let isClsCategory = ( category ) => {\n    if( category.filterValues && ( category.filterValues.parentnodes &&\n            category.filterValues.parentnodes.length > 0 || category.filterValues.childnodes && category.filterValues.childnodes.length > 0 ) ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let ifFilterSelectedForCls = ( category ) => {\n    var filterValuesExist = isClsCategory( category );\n    if( filterValuesExist ) {\n        for( var index = 0; index < category.filterValues.parentnodes.length; index++ ) {\n            if( category.filterValues.parentnodes[ index ].selected ) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * getFilterFocus - return whether to set autoFocus for a filter as true or false\n * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info\n * @param { Object } filter current filter\n * @param { Object } categoryInternalName current category internal name\n * @param { Integer } index - current filter index\n * @returns { Boolean } autoFocus value for the filter - true/false\n */\nexport const getFilterFocus = ( lastSelectedFilterAndCategoryInfo, filter, categoryInternalName, index ) => {\n    let lastAction = lastSelectedFilterAndCategoryInfo ? lastSelectedFilterAndCategoryInfo.lastAction : '';\n    switch( lastAction ) {\n        case 'selectFilter':\n            if( lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName === filter.categoryName &&\n                lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName === filter.internalName ) {\n                return true;\n            }\n            return false;\n        case 'dateRangeSearch':\n            if( index === 0 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory === categoryInternalName ) {\n                return true;\n            }\n            return false;\n        case 'numericRangeSearch':\n            if( index === 1 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory === categoryInternalName ) {\n                return true;\n            }\n            return false;\n        default:\n            return false;\n    }\n};\n\nexport let loadConfiguration = function() {\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidDate', true ).then( result => _invalidDateText = result );\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidRange', true ).then( result => _invalidRangeText = result );\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidPrefilter', true ).then( result => _invalidPrefilter = result );\n};\n\nloadConfiguration();\n\nexport default {\n    HIERARCHICAL_FACET_SEPARATOR,\n    PRESET_CATEGORY,\n    DATE_FILTER,\n    INTERNAL_DATE_FILTER,\n    DATE_RANGE_FILTER,\n    DATE_DRILLDOWN_FILTER,\n    NUMERIC_RANGE_FILTER,\n    INTERNAL_NUMERIC_FILTER,\n    INTERNAL_OBJECT_FILTER,\n    INTERNAL_NUMERIC_RANGE,\n    NUMERIC_FILTER,\n    NUMERIC_RANGE,\n    NumericRangeBlankStart,\n    NumericRangeBlankEnd,\n    NO_STARTDATE,\n    NO_ENDDATE,\n    NO_STARTRANGE,\n    NO_ENDRANGE,\n    BEGINNING_OF_TIME,\n    ENDING_OF_TIME,\n    getDate,\n    isNullDate,\n    validateDates,\n    getDateRangeString,\n    getDateRangeFilter,\n    getDateRangeDisplayString,\n    checkIfValidRange,\n    validateNumericRangeSelected,\n    validateNumericRange,\n    getNumericRangeString,\n    getNumericRangeFilter,\n    getNumericRangeDisplayString,\n    getRealFilterWithNoFilterType,\n    getFilterTypeFromFilterValue,\n    isPresetFilters,\n    setPresetFilters,\n    getHasTypeFilter,\n    setHasTypeFilter,\n    setIncontext,\n    getIncontext,\n    saveIncontextFilterMap,\n    getCategoryInternalName,\n    getCurrentCategory,\n    getPropGroupValues,\n    getPropGroupValue,\n    getFilterColorRGBValue,\n    getFilterColorValue,\n    getPropertyFromFilter,\n    getFormattedFilterDate,\n    getFormattedFilterNumber,\n    getRangeSearchFilter,\n    getSingleSearchFilter,\n    getFilterType,\n    displayPrefilterError,\n    getPreferenceValue,\n    getCustomPropValueColorMap,\n    setCustomPropValueColorMap,\n    applyCustomColor,\n    checkIfFilterValuesExist,\n    isLimitedCategoriesFeatureEnabled,\n    ifFilterSelectedForCategory,\n    isClsCategory,\n    ifFilterSelectedForCls,\n    getFilterFocus\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}