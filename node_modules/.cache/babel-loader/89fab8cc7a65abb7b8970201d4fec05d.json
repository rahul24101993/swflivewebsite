{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/actionService\n *\n * @namespace actionService\n */import soaSvc from'soa/kernel/soaService';import declarativeDataCtxSvc from'js/declarativeDataCtxService';import propertyPolicySvc from'soa/kernel/propertyPolicyService';import appCtxSvc from'js/appCtxService';import messagingSvc from'js/messagingService';import conditionSvc from'js/conditionService';import navigationService from'js/navigationService';import adapterSvc from'js/adapterService';import dataMapperSvc from'js/dataMapperService';import cfgSvc from'js/configurationService';import batchActionService from'js/batchActionService';/** revisitme Shaishav\n * Hint: We need to bring following services\nimport wysModeSvc from 'js/wysiwygModeService';\n*/import _ from'lodash';import eventBus from'js/eventBus';import browserUtils from'js/browserUtils';import parsingUtils from'js/parsingUtils';import declUtils from'js/declUtils';import logger from'js/logger';import moduleLoader from'js/moduleLoader';// Services\nimport AwHttpService from'js/awHttpService';import AwPromiseService from'js/awPromiseService';import ClipboardService from'js/clipboardService';import debugService from'js/debugService';/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */var _actionPropsToLog=['actionId','actionType','method','serviceName','deps','actionId'];/**\n * {Boolean} TRUE if 'action' activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current\n * document's URL.\n */var _logActionActivity=browserUtils.getUrlAttributes().logActionActivity!==undefined;/**\n * {Boolean} TRUE if 'action' event activity should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current\n * document's URL.\n */var _logActionEventActivity=browserUtils.getUrlAttributes().logActionEventActivity!==undefined;/**\n * Define public API\n */var exports={};/**\n * Makes SOA call with given action and inputData. return the promise object.\n *\n * @param {Object} action - The 'declAction' object.\n * @param {Object} inputData - The 'inputData' object.\n *\n * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a\n *         problem).\n */var _callSOA=function(action,inputData,propertyPolicyOverride){var promise=null;if(action.actionType==='TcSoaService'){if(action.serviceName){if(action.inputData){promise=soaSvc.postUnchecked(action.serviceName,action.method,inputData,propertyPolicyOverride,null,action.headerState);}else{promise=AwPromiseService.instance.reject('No TcSoaService input data specified');}}else{promise=AwPromiseService.instance.reject('No TcSoaService service specified');}}else{promise=AwPromiseService.instance.reject('Unknown action type: '+action.actionType);}return promise;};var actionInputDataLogging=function(action,inputData){/**\n     * Now that any binding has happened, log the current action (if necessary)\n     */if(_logActionActivity){logger.info('action: '+'\\n'+JSON.stringify(action,_actionPropsToLog,2));if(action.actionType==='RESTService'){logger.info('RESTService.inputData: '+'\\n'+JSON.stringify(inputData,null,2));}else if(action.actionType==='GraphQL'||action.actionType==='JSFunctionAsync'&&action.method==='callGraphQL'){logger.info('GraphQL.inputData: '+'\\n'+JSON.stringify(inputData,null,2));if(action.outputData){logger.info('GraphQL.outputData: '+'\\n'+JSON.stringify(action.outputData,null,2));}}}};var processActionTypeEvent=function(declViewModel,dataCtxNode,action,functionsList,depModuleObj,deferred){setTimeout(function(){if(!declUtils.isValidModelAndDataCtxNode(declViewModel,dataCtxNode)){declUtils.logLifeCycleIssue(declViewModel,action,'Action not processed.','applyExpression');return;}// here needs updated info and eveulation context\nlet localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);/**\n         * Loop for each 'event' type action and publish the ones who's conditions are\n         * currently TRUE.\n         */_.forEach(action.inputData.events,function(event){var conditionValue=true;if(event.condition){conditionValue=conditionSvc.evaluateConditionExpression(event.condition,localContext.data,{evaluationEnv:{...localContext},depModuleObj});}if(conditionValue){if(_logActionEventActivity){logger.info('action: '+'\\n'+JSON.stringify(action,_actionPropsToLog,2)+'\\n'+'ActionEvent: '+event.name);}var eventDataToPublish={};if(event.eventData){eventDataToPublish=_.cloneDeep(event.eventData);declarativeDataCtxSvc.applyScope(localContext.data,eventDataToPublish,functionsList,localContext,depModuleObj);}eventDataToPublish._source=declViewModel._internal.modelId;if(event.excludeLocalDataCtx!==true){eventDataToPublish.scope=localContext;}if(logger.isDeclarativeLogEnabled()){debugService.debugEventPub(action,event,localContext.data,localContext,eventDataToPublish);}eventBus.publish(event.name,eventDataToPublish,true);}});deferred.resolve();},0);};var processActionTypeJsFun=function(inputData,action,deferred,depModuleObj){var params=[];_.forEach(inputData,function(param){params.push(param);});try{const applyFn=depModuleObj[action.method].apply(depModuleObj,params);if(typeof(applyFn===null||applyFn===void 0?void 0:applyFn.then)==='function'){applyFn.then(resolved=>{deferred.resolve(resolved);},err=>{deferred.reject(err);});}else{deferred.resolve(applyFn);}}catch(error){deferred.reject({errorCode:error});}};var getActionInputData=function(action,inputData){if(action.inputData){inputData=_.cloneDeep(action.inputData);}else if(action.navigationParams){if(typeof action.navigationParams==='string'){inputData={navigationParams:action.navigationParams};}else{inputData=_.cloneDeep(action.navigationParams);}}return inputData;};var eveulateActionParameters=function(dataCtxNode,action,inputData){// if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data\n// does not exist. In that case we need to process the dataCtxNode.parameter section to get default value\n// for the parameters We might have some inputdata, which is referring to parameters section. The\n// below code scans the action.inputData for \"{{parameters\" keyword as value in action.inputdata.\n// {action: parameters: { \"param1\": \"{{data.xyz}}\"}, inputdata : { \"key1\":\"{{parameter.param1}}\"}}\n// and replaces them with the default value specified in parameters in action.inputdata :\n// {\"key1\":\"{{data.param1}}\" later we resolve the inputData, this helps us not to use applyScope\n// twice.\nif(!dataCtxNode.parameters&&action.parameters){var keySequence=[];var pattern=/^{{parameters/;_.forEach(action.inputData,function processInputData(value,key){if(value&&_.isObject(value)){keySequence.push(key);_.forEach(value,processInputData);keySequence.pop();}else if(value&&_.isString(value)&&pattern.test(value)){keySequence.push(key);var eventMapKey=keySequence.join('.');var parameterKey=parsingUtils.getStringBetweenDoubleMustaches(value);_.set(inputData,eventMapKey,_.get(action,parameterKey,null));keySequence.pop();}});}};var resolveInputData=function(inputData,declViewModel,action,dataCtxNode,functionsList,depModuleObj,inputError){if(inputData){if(declViewModel.isDestroyed()){declUtils.logLifeCycleIssue(declViewModel,action,'Action results not applied to data context.','_performAction');}else{let localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);try{declarativeDataCtxSvc.applyScope(localContext.data,inputData,functionsList,localContext,depModuleObj);}catch(error){inputError=error;}}}return inputError;};var _processAllDataProvider=function(dataProviderArray,declViewModel,dataCtxNode){var promises=[];_.forEach(dataProviderArray,function(providerObj){var provider=providerObj.dataProvider;/**\n         * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those\n         * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize\n         * the dataProvider and let it decide what to load.\n         */if(provider.json.firstPage){var firstPageObjs=[];_.forEach(provider.json.firstPage,function(uid){var vmos=declViewModel.objects[uid];if(Array.isArray(vmos)){Array.prototype.push.apply(firstPageObjs,vmos);}else if(vmos!==undefined){// LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.\nfirstPageObjs.push(vmos);}});/**\n             * This code evaluates the page size to determine if we need to increment total. This is\n             * necessary for object sets, as we do not know the totalFound.\n             */var maxToLoad;if(provider.action&&provider.action.inputData){var actionInputData=provider.action.inputData;if(actionInputData.searchInput){maxToLoad=actionInputData.searchInput.maxToLoad;}}var totalFound=firstPageObjs.length>0?firstPageObjs.length+1:0;if(maxToLoad){totalFound=firstPageObjs.length===maxToLoad?firstPageObjs.length+1:firstPageObjs.length;}provider.update(firstPageObjs,totalFound);}else{var args=[dataCtxNode,declViewModel];promises.push(provider[providerObj.action].apply(provider,args));}});return AwPromiseService.instance.all(promises);};/**\n * Execute the given 'dataprovider action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n *\n * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.\n */export let performDataProviderAction=function(declViewModel,action,dataCtxNode){var dataProviderArray=[];debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'pre',action,declViewModel);var createDataProviderInput=function(dataProvider,action){return{dataProvider:dataProvider,action:action?action:'initialize'};};if(action.methods&&_.isArray(action.methods)){_.forEach(action.methods,function(method){var dataProvider=declViewModel.dataProviders[method];var dpAction=action.inputData&&action.inputData.action?action.inputData.action:'initialize';if(dataProvider){dataProviderArray.push(createDataProviderInput(dataProvider,dpAction));}});}else if(action.method){if(action.inputData&&action.inputData.action){// Table edit use case\nvar dpAction=action.inputData.action;dataProviderArray.push(createDataProviderInput(declViewModel.dataProviders[action.method],dpAction));}else{// with the new implementation resetDataProvider will re-initialize the dataprovider.\ndeclViewModel.dataProviders[action.method].resetDataProvider();}}else{logger.warn('Missing action method(s) name for action: '+'\\n'+JSON.stringify(action,_actionPropsToLog,2));}if(!_.isEmpty(dataProviderArray)){const{dispatch}=declViewModel;return _processAllDataProvider(dataProviderArray,declViewModel,dataCtxNode).then(()=>{// Rules to use dispatch:\n// - Make sure it is 'immutable change' otherwise it is not getting rerender\n// - Make sure 'immutable change' dosen't change the object type with no indention\n//   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object\ndispatch({path:'dataProviders',value:{...declViewModel.dataProviders}});});}return 0;};var processActionTypePopup=function(declViewModel,action,inputData,dataCtxNode,deferred,depModuleObj){var _dataCtxNode$commandC;let popupAction=declViewModel.actions[action.actionId];let updateOptions=inputData&&inputData.options||{};// override popupAction if defined in commandContext - AwCommandService\n// options could be overridden and customized\nif((_dataCtxNode$commandC=dataCtxNode.commandContext)!==null&&_dataCtxNode$commandC!==void 0&&_dataCtxNode$commandC.popupAction){// case: it's a normal command\npopupAction=dataCtxNode.commandContext.popupAction;}else if(!popupAction.show){// case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.\npopupAction=appCtxSvc.getCtx('globalPopup');}// case customized popup actions - inject popupAction as last params for action.method\n// application manages when / how to invoke show / hide\nif(action.method&&action.deps){let params=[];_.forEach(inputData,function(param){params.push(param);});params.push(popupAction,updateOptions);try{const applyFn=depModuleObj[action.method].apply(depModuleObj,params);if(typeof(applyFn===null||applyFn===void 0?void 0:applyFn.then)==='function'){applyFn.then(resolved=>{deferred.resolve(resolved);},err=>{deferred.reject(err);});}else{deferred.resolve(applyFn);}}catch(error){deferred.reject({errorCode:error});}// default plain popup actions\n}else{// TODO: build params based on inputData, props, viewData\nlet evaluatedOptions=inputData&&inputData.options||null;// only apply dynamic options\n// if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {\n//     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {\n//         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );\n//         return result;\n//     }, {} );\n// }\ntry{popupAction.show(evaluatedOptions).then(function(resolved){deferred.resolve(resolved);},function(err){deferred.reject(err);});}catch(error2){deferred.reject({errorCode:error2});}}};var processActionTypeCopy=function(inputData,promise){/**\n     * This actionType is needed when we are dealing with OS commands like copying to clipboard\n     * which needs to run without any defer mechanism. Since document.execCommand('copy') will\n     * be successful only when it runs through a user click event and not with defer and digest\n     * cycle event. we can use this actionType for other copy command too apart from shareURL\n     * since it calls the same document.execCommand('copy') function after copying it to\n     * awclipboard.\n     */ /**\n     * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.\n     */if(inputData.copyType==='URL'){var adaptedObjects=adapterSvc.getAdaptedObjectsSync(inputData.objectToCopy);ClipboardService.instance.copyUrlToClipboard(adaptedObjects);promise=AwPromiseService.instance.when();}else if(inputData.copyType==='Object'){ClipboardService.instance.copyHyperlinkToClipboard(inputData.objectToCopy);promise=AwPromiseService.instance.when();}return promise;};var processActionTypeNaviagte=function(action,inputData){if(action.navigateTo){if(inputData.navigationParams){inputData=inputData.navigationParams;}return navigationService.navigate(action,inputData);}return AwPromiseService.instance.reject('Missing navigate to in action type: '+action.actionType+' for actionId: '+action.actionId);};var processActionTypeEdit=function(action,declViewModel){var methods=['startEdit','saveEdits','cancelEdits','isDirty'];if(action.method&&methods.indexOf(action.method)!==-1){return declViewModel[action.method].apply(declViewModel);}return AwPromiseService.instance.reject('Not a valid edit action : '+action.method);};var processActionTypeSync=function(action,inputData,declViewModel){if(inputData.port){return import('js/syncStrategyService').then(function(syncStrategyService){return syncStrategyService.updatePort(declViewModel,inputData,exports);});}return AwPromiseService.instance.reject('Missing port to in action type: '+action.actionType+' for actionId: '+action.actionId);};var loadCustomActionDependentModule=function(customAction){var depModuleObj=moduleLoader.getDependentModule(customAction.deps);if(depModuleObj){return AwPromiseService.instance.resolve(depModuleObj);}return moduleLoader.loadDependentModule(customAction.deps).then(function success(depModuleObj){return AwPromiseService.instance.resolve(depModuleObj);},function reject(error){return AwPromiseService.instance.reject(error);});};/**\n * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will\n * be returned.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n * @param {Object} action - The 'declAction' to be executed.\n * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.\n * @param {Object} dataCtxNode - The data context node which holds interpolation values.\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n */var _performAction=function(declViewModel,action,functionsList,dataCtxNode,depModuleObj,propertyPolicyOverride){if(!action){return AwPromiseService.instance.reject('Missing action parameter');}if(!action.actionType){return AwPromiseService.instance.reject('Missing action type for actionId: '+action.actionId);}var inputData=null;var inputError=null;/**\n     * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.\n     * <P>\n     * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the\n     * time the action is queued to be executed and when we get here.\n     */if(action.altInputData){inputData=action.altInputData;}else{inputData=getActionInputData(action,inputData);eveulateActionParameters(dataCtxNode,action,inputData);inputError=resolveInputData(inputData,declViewModel,action,dataCtxNode,functionsList,depModuleObj,inputError);}/**\n     * Now that any binding has happened, log the current action (if necessary)\n     */actionInputDataLogging(action,inputData);/**\n     * Check for an input error\n     */var promise=null;var deferred;if(inputError){promise=AwPromiseService.instance.reject({errorCode:inputError});return promise;}return declarativeDataCtxSvc.applyExpression(inputData).then(function(){debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'pre',action,declViewModel,inputData);if(action.actionType==='dataProvider'){promise=exports.performDataProviderAction(declViewModel,action,dataCtxNode);}else if(action.actionType==='TcSoaService'){promise=_callSOA(action,inputData,propertyPolicyOverride);}else if(action.actionType==='RESTService'){promise=AwHttpService.instance(inputData.request);}else if(action.actionType==='Event'){if(action.inputData){deferred=AwPromiseService.instance.defer();processActionTypeEvent(declViewModel,dataCtxNode,action,functionsList,depModuleObj,deferred);promise=deferred.promise;}}else if(action.actionType==='JSFunction'||action.actionType==='JSFunctionAsync'){deferred=AwPromiseService.instance.defer();promise=deferred.promise;processActionTypeJsFun(inputData,action,deferred,depModuleObj);}else if(action.actionType==='Test'){/**\n                 * This actionType is meant to allow automated testing without the need for a live server to\n                 * load dependent modules. The resolved data for the deferred action is just the same object\n                 * that was given as the 'inputData'.\n                 */deferred=AwPromiseService.instance.defer();promise=deferred.promise;deferred.resolve(inputData);}else if(action.actionType==='popup'){deferred=AwPromiseService.instance.defer();promise=deferred.promise;processActionTypePopup(declViewModel,action,inputData,dataCtxNode,deferred,depModuleObj);}else if(action.actionType==='Copy'){promise=processActionTypeCopy(inputData,promise);}else if(action.actionType==='Navigate'){promise=processActionTypeNaviagte(action,inputData);}else if(action.actionType==='Edit'){promise=processActionTypeEdit(action,declViewModel);}else if(action.actionType==='batchJob'){promise=batchActionService.executeBatchActions(declViewModel,action,dataCtxNode,exports);}else if(action.actionType==='Sync'){return processActionTypeSync(action,inputData,declViewModel);}else{// process custom Action Type\ndeferred=AwPromiseService.instance.defer();promise=deferred.promise;processActionTypeCustom(action,inputData,declViewModel,dataCtxNode,deferred,functionsList,depModuleObj);}// end of custom action\nreturn promise;});};var processActionTypeCustom=function(action,inputData,declViewModel,dataCtxNode,deferred,functionsList,depModuleObj){cfgSvc.getCfg('actionTemplateDefs').then(function(actionTemplateDefs){if(actionTemplateDefs[action.actionType]){var customAction=_.cloneDeep(actionTemplateDefs[action.actionType]);// resolver for inputData defined at successive action template defs that include\n// ctx, data and inputData\nlet localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);var resolver={...localContext,inputData:inputData};// load the dependent modules if deps is specified\nif(customAction.deps){var depModuleObjPromise=loadCustomActionDependentModule(customAction);depModuleObjPromise.then(function(depModuleObj){deferred.resolve(_performAction(declViewModel,customAction,functionsList,resolver,depModuleObj));});}else{deferred.resolve(_performAction(declViewModel,customAction,functionsList,resolver,depModuleObj));}}else{logger.error('error :: action type ->'+action.actionType+' is missing.');deferred.reject('Unknown action type: '+action.actionType);}});};var processDefaultErrorMsg=function(err,action){//var msg = null;\n//var level = 1;\nif(_.isString(err)){/**msg = err;\n        level = 3; */}else if(err&&err.message){/**msg = err.message.replace( /\\n/g, '<br>' );\n        level = err.level ? err.level : 3; */}else{/**msg = 'Unknown error message type for action ' + action.method;\n        level = 3;*/logger.error(err);}/** revisitme Shaishav\n         * Hint: We need to bring wysiwygModeService\n         if( level <= 1 ) {\n             logger.info( msg );\n         } else {\n             wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );\n         }\n    */};var processDefaultErrorTypeObject=function(err,isReported){var errInfo=null;if(err.config&&err.status&&(err.status<200||err.status>299)){/**\n         * Error from Angular's $http service.\n         */errInfo={url:err.config.url,method:err.config.method,status:err.status,statusText:err.statusText};}else if(err.cause&&err.cause.config){/**\n         * Error due to lost network connectivity, server crash etc.\n         */errInfo={url:err.cause.config.url,method:err.cause.config.method,status:err.cause.status,statusText:err.cause.statusText};}if(errInfo!==null){var errMsg='The HTTP \"'+errInfo.method+'\" method to url \"'+errInfo.url+'\" failed';if(_.isString(errInfo.statusText)&&errInfo.statusText.length>0){errMsg=errMsg+' (status = \"'+errInfo.statusText+'\").';}else{errMsg=errMsg+' (status = \"'+errInfo.status+'\").';}isReported=true;logger.error(errMsg);}return isReported;};const parseConditonExp=(expression,evaluationEnv)=>{//This is not acomplete fix, needs to be revisited - LCS-565498\nconst exp=conditionSvc.getRealExpression(expression,evaluationEnv);if(_.isString(exp)){return exp;}//If the condition is object based, return the original expression\nreturn expression;};/**\n * Process the events of the executed action\n *\n * @param {DeclViewModel} declViewModel - The declarative view model\n * @param {DeclAction} action - The declarative action.\n * @param {Object} events - The events of an action object on the View model\n * @param {Object} evaluationEnv - The environment on which to evaluate event conditions\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing\n *            action 'failure'.\n */var _processActionEvents=function(declViewModel,action,events,evaluationEnv,dataCtxNode,depModuleObj,isSuccess){/**\n     * Check if there is no reason to continue.\n     */if(_.isEmpty(events)){return;}//new in afx 3.1.0\nif(declViewModel.isDestroyed()){declUtils.logLifeCycleIssue(declViewModel,action,'Action event(s) not processed.','_processActionEvents');return;}var functionsList=declViewModel._internal.functions;debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'events');_.forEach(events,function(event){/**\n         * Fire event when condition value is true\n         */var conditionValue=true;if(event.condition){const expression=parseConditonExp(event.condition,declViewModel._internal);conditionValue=conditionSvc.evaluateConditionExpression(expression,declViewModel,{evaluationEnv,depModuleObj});}if(conditionValue){if(_logActionEventActivity){if(isSuccess){logger.info('action: '+'\\n'+JSON.stringify(action,_actionPropsToLog,2)+'\\n'+'SuccessEvent: '+event.name);}else{logger.info('action: '+'\\n'+JSON.stringify(action,_actionPropsToLog,2)+'\\n'+'FailureEvent: '+event.name);}}var eventData={};if(event.eventData){eventData=_.cloneDeep(event.eventData);declarativeDataCtxSvc.applyScope(declViewModel,eventData,functionsList,dataCtxNode,depModuleObj);}if(event.excludeLocalDataCtx!==true){eventData.scope=dataCtxNode;}eventData._source=declViewModel._internal.modelId;eventBus.publish(event.name,eventData,true);if(logger.isDeclarativeLogEnabled()){debugService.debugEventPub(action,event,declViewModel,dataCtxNode,eventData);}}});};var processActionFailureEvents=function(events,err,evaluationEnv,declViewModel,action,dataCtxNode,depModuleObj){if(events&&events.failure){var _err$response;if(err.cause&&err.cause.partialErrors){/**\n             * Add the error in the evaluation env for each of the events\n             */_.forEach(events.failure,function(failureEvt){_.forEach(err.cause.partialErrors,function(partialError){if(partialError.errorValues){_.forEach(partialError.errorValues,function(errorValue){if(errorValue.code){evaluationEnv.errorCode=errorValue;if(!evaluationEnv.errorCodes){evaluationEnv.errorCodes=[];}evaluationEnv.errorCodes.push(errorValue);}});}});_processActionEvents(declViewModel,action,[failureEvt],evaluationEnv,dataCtxNode,depModuleObj,false);});// If REST call is failed with error\n}else if(err.status||(_err$response=err.response)!==null&&_err$response!==void 0&&_err$response.status){// Add the error in the evaluation env for each of the events\nevaluationEnv.errorCode=err;_processActionEvents(declViewModel,action,events.failure,evaluationEnv,dataCtxNode,depModuleObj,false);}else{// Process all events in bulk\n_processActionEvents(declViewModel,action,events.failure,evaluationEnv,dataCtxNode,depModuleObj,false);}}};var processPartialError=function(err,actionMessages,evaluationEnv,declViewModel,depModuleObj){let matchingMessages=[];_.forEach(err.cause.partialErrors,function(partialError){if(partialError.errorValues){_.forEach(partialError.errorValues,function(errorValue){if(errorValue.code){_.forEach(actionMessages.failure,function(failureErr){var condValue=true;if(failureErr.condition){evaluationEnv.errorCode=errorValue;const expression=parseConditonExp(failureErr.condition,declViewModel._internal);condValue=conditionSvc.evaluateConditionExpression(expression,declViewModel,{evaluationEnv,depModuleObj});}if(condValue){if(!failureErr.errorCode){failureErr.errorCode=[];}failureErr.errorCode.push(errorValue);if(matchingMessages.indexOf(failureErr)===-1){matchingMessages.push(failureErr);}}});}});}});return matchingMessages;};var processActionHavingCause=function(err,actionMessages,evaluationEnv,declViewModel,depModuleObj){let allMessages=null;let isReported=false;_.forEach(err.cause.messages,function(message){if(message.code){_.forEach(actionMessages.failure,function(failureErr){let conditionResult=false;if(failureErr.condition){// two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123\nevaluationEnv.errorCode=failureErr.condition.indexOf('.code')>-1?message:message.code;const expression=parseConditonExp(failureErr.condition,declViewModel._internal);conditionResult=conditionSvc.evaluateConditionExpression(expression,declViewModel,{evaluationEnv,depModuleObj});}if(conditionResult||failureErr.message&&failureErr.condition===undefined){isReported=true;if(!allMessages){allMessages=_.cloneDeep(declViewModel._internal.messages);}evaluationEnv.errorCode=message.message;messagingSvc.reportNotyMessage(declViewModel,allMessages,failureErr.message,evaluationEnv);}});}});return isReported;};var processActionHavingErrorCode=function(err,actionMessages,evaluationEnv,declViewModel,depModuleObj,dataCtxNode){var isReported=false;var allMessages=null;/**\n     * Notify error raised by a JS function call\n     */_.forEach(actionMessages.failure,function(failureErr){var condValue=true;if(failureErr.condition){var _err$response2;if(err.status||(_err$response2=err.response)!==null&&_err$response2!==void 0&&_err$response2.status){// In case failure is from REST call\nevaluationEnv.errorCode=err;}else{evaluationEnv.errorCode=err.errorCode;}const expression=parseConditonExp(failureErr.condition,declViewModel._internal);condValue=conditionSvc.evaluateConditionExpression(expression,declViewModel,{evaluationEnv,depModuleObj});}if(condValue){isReported=true;if(!allMessages){allMessages=_.cloneDeep(declViewModel._internal.messages);}messagingSvc.reportNotyMessage(declViewModel,allMessages,failureErr.message,dataCtxNode,depModuleObj);}});return isReported;};var processActionFailureMessage=function(actionMessages,err,evaluationEnv,declViewModel,depModuleObj,isReported,dataCtxNode){if(actionMessages&&actionMessages.failure){var _err$response3;if(err.cause&&err.cause.partialErrors){// Notify error message when condition matched\nvar allMessages;if(actionMessages.failure.length>0){var matchingMessages=[];var scopedAllMessages=[];var reportError=function(failureErr,idx){evaluationEnv.errorCode=failureErr.errorCode.reduce((acc,err,index,arr)=>{acc+=err.message+(arr.length-1===index?'':'<br/>');return acc;},'');messagingSvc.reportNotyMessage(declViewModel,scopedAllMessages[idx],failureErr.message,evaluationEnv);failureErr.errorCode=null;};matchingMessages=processPartialError(err,actionMessages,evaluationEnv,declViewModel,depModuleObj);if(!allMessages&&matchingMessages.length>0){allMessages=_.cloneDeep(declViewModel._internal.messages);scopedAllMessages.push(allMessages);isReported=true;}matchingMessages.forEach(function(message,index){reportError(message,index);});}else{/**\n                 * Notify SOA error message when no condition specified\n\n                var errMessage = messagingSvc.getSOAErrorMessage( err ); */isReported=true;/** revisitme Shaishav\n                 * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module\n                 * should not depend on layer 3 modules. We need to correct that.\n                wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );\n                */}}else if(err.cause&&err.cause.messages){isReported=processActionHavingCause(err,actionMessages,evaluationEnv,declViewModel,depModuleObj);}else if(err.errorCode||err.status||(_err$response3=err.response)!==null&&_err$response3!==void 0&&_err$response3.status){isReported=processActionHavingErrorCode(err,actionMessages,evaluationEnv,declViewModel,depModuleObj,dataCtxNode);}}return isReported;};var performOutputDataMapping=function(resolvedAssignments,declViewModel,prop){const{dispatch,updateAtomicData}=declViewModel;let finalObj={};for(prop in resolvedAssignments){// special property\nconst basePath=prop.split('.')[0];if(declViewModel.atomicData&&declViewModel.atomicData[basePath]){_.set(declViewModel.atomicData,prop,resolvedAssignments[prop]);updateAtomicData[basePath](_.cloneDeep(declViewModel.atomicData[basePath]));}else{let key=\"data.\".concat(prop);finalObj[key]=resolvedAssignments[prop];}}if(dispatch&&Object.keys(finalObj).length>0){dispatch({value:finalObj});_.forEach(resolvedAssignments,function(fromPath,toPath){_.set(declViewModel,toPath,fromPath);});}};var loadFuncDependency=function(action,declViewModel,depModuleObj){// load function deps\nvar functionDeps=declUtils.getFunctionDeps(action,declViewModel._internal);// Filter already loaded deps\n_.forEach(depModuleObj,function(funcValue,funcKey){var loaded=_.find(functionDeps,function(funcDep){// LCS-299148 Beyond Angular: Clean up app.getInjector usage\n// funcKey here is module name, fundDep here is js/fileName\n// luckly it is passing today\nreturn funcDep.includes(funcKey);});if(loaded){_.remove(functionDeps,function(funcDep){return funcDep===loaded;});}});return functionDeps;};var getActionPolicyInfo=function(action,declViewModel,functionsList,dataCtxNode,depModuleObj){if(action.policy&&action.actionType==='TcSoaService'){var policy=_.cloneDeep(action.policy);declarativeDataCtxSvc.applyScope(declViewModel,policy,functionsList,dataCtxNode,depModuleObj);if(policy.override===true){return{propertyPolicyOverride:{types:policy.types}};}return{actionPolicyId:propertyPolicySvc.register({types:policy.types},action.method+'_Policy')};}return{};};/**\n * Process the 'Success' part of the executed action\n *\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */var _processSuccess=function(declViewModel,action,dataCtxNode,depModuleObj){var events=action.events;var actionMessages=action.actionMessages;var allMessages;let localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);if(events&&events.success){_processActionEvents(localContext.data,action,events.success,localContext,localContext,depModuleObj,true);}debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'actionMessages');if(actionMessages&&actionMessages.success){_.forEach(actionMessages.success,function(successMessage){if(successMessage){var condValue=true;if(successMessage.condition){const expression=parseConditonExp(successMessage.condition,declViewModel._internal);condValue=conditionSvc.evaluateConditionExpression(expression,localContext.data,{evaluationEnv:{...localContext},depModuleObj});}if(condValue){if(!allMessages){allMessages=_.cloneDeep(declViewModel._internal.messages);}messagingSvc.reportNotyMessage(localContext.data,allMessages,successMessage.message,localContext);}}else{logger.error('Invalid action successMessage:'+successMessage);}});}};/**\n * Process the error and the 'Failure' part of the executed action\n *\n * @param {Object} err - JavaScript Error object\n * @param {Object} declViewModel - The declarative view model\n * @param {Object} action - The action object on the View model\n * @param {Object} dataCtxNode - The data context\n * @param {ModuleObject} depModuleObj - The dependent module object\n */var _processError=function(err,declViewModel,action,dataCtxNode,depModuleObj){var events=action.events;var actionMessages=action.actionMessages;let localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);processActionFailureEvents(events,err,localContext,localContext.data,action,localContext,depModuleObj);var isReported=false;debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'actionMessages');isReported=processActionFailureMessage(actionMessages,err,localContext,localContext.data,depModuleObj,isReported,localContext);if(!isReported&&typeof err==='object'){isReported=processDefaultErrorTypeObject(err,isReported);}/**\n     * Fall back, report error if not raised till this point\n     */if(!isReported){processDefaultErrorMsg(err,action);}};/**\n * @param {DeclViewModel} declViewModel - Model that owns the action.\n * @param {DeclAction} action - Action to 'finish'.\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.\n * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.\n * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.\n */var _finishAction=function(declViewModel,action,dataCtxNode,depModuleObj,actionResponseObj,deferred){var err=null;if(!_.isEmpty(actionResponseObj)){if(!_.isEmpty(actionResponseObj.partialErrors)||!_.isEmpty(actionResponseObj.PartialErrors)){err=soaSvc.createError(actionResponseObj);}if(actionResponseObj.ServiceData&&actionResponseObj.ServiceData.partialErrors){err=soaSvc.createError(actionResponseObj.ServiceData);}}if(err){_processError(err,declViewModel,action,dataCtxNode,depModuleObj);deferred.reject(err);}else{_processSuccess(declViewModel,action,dataCtxNode,depModuleObj);deferred.resolve(actionResponseObj);}};var performOutputDataMappingForBatch=function(resolvedAssignments,declViewModel,action,dataCtxNode,depModuleObj,deferred){var data={actionData:[]};_.forEach(resolvedAssignments,function(fromPath,toPath){_.set(data.actionData,toPath,fromPath);});_finishAction(declViewModel,action,dataCtxNode,depModuleObj,data,deferred);};var resolveActionOutputData=function(action,mapDataOnAction,actionResponseObj,declViewModel,depModuleObj,dataCtxNode){var deferredAssignments={};/**\n     * Loop for each mapping in the 'outputData' spec\n     */var index=0;_.forEach(action.outputData,function(fromPath,toPath){var fromObj;if(mapDataOnAction&&action.outputArg){toPath=action.outputArg[index];}if(_.isBoolean(fromPath)){fromObj=fromPath;}else if(_.isEmpty(fromPath)){/**\n             * To support action as JS function call, assign function return value as the result\n             * when empty value expression specified\n             */fromObj=actionResponseObj;}else if(_.isString(fromPath)&&fromPath.indexOf('result.')===0){/**\n             * If fromPath has a 'result.' prefix, parse the expression within fromPath to get\n             * the correct value.\n             */var fromResultPath=fromPath.split('result.')[1];fromObj=_.get(actionResponseObj,fromResultPath);}else{/**\n             * If fromPath is defined, parse the expression within fromPath to get the correct\n             * value.\n             */let localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);fromObj=declarativeDataCtxSvc.getOutput(declViewModel,actionResponseObj,fromPath,depModuleObj,localContext);}/**\n         * If the toPath starts with ctx. update the appCtxService\n         */if(toPath.indexOf('ctx.')===0){var toCtxName=toPath.split('ctx.')[1];appCtxSvc.updatePartialCtx(toCtxName,fromObj);}else if(_.startsWith(toPath,'ports.')){if(dataCtxNode.ports){_.set(dataCtxNode.ports,toPath.replace('ports.',''),fromObj);}}else{// The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the\n// case in cleaner way\ndeferredAssignments[toPath]=AwPromiseService.instance.when(fromObj);}index+=1;});return deferredAssignments;};/**\n * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.\n * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}\n * @param {DeclAction} action - {DeclAction} being performed\n * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on\n * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the\n * 'deferred' remains untouched.\n */var _isViewModelDestroyed=function(declViewModel,actionResponseObj,action,deferred,methodName){/**\n     * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can\n     * happen, for example, when multiple subscribers are listening to a common event like 'selection' and\n     * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close\n     * (thus destroying the dataCtxNode and the declViewModel associated with it).\n     * <P>\n     * If so: There is nothing more that can be done with the declViewModel and we just want to log a\n     * warning about the life cycle issue and 'resolve' the given 'deferred'.\n     */if(declViewModel.isDestroyed()){/**\n         * If the action is trying to actually do something with the response and the view model is\n         * destroyed log an error\n         */if(actionResponseObj){declUtils.logLifeCycleIssue(declViewModel,action,'Action was therefore not finished.',methodName);}// Otherwise do nothing\ndeferred.resolve();return true;}return false;};/**\n * Perform a SOA action. Support calling SOA service, return the response object.\n *\n * @param {Object} action - The 'declAction' to be executed.\n * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a\n *         problem).\n */export let performSOAAction=function(action){var deferred=AwPromiseService.instance.defer();_callSOA(action,action.inputData).then(function(actionResponseObj){if(!declUtils.isNil(actionResponseObj)){var err=null;if(actionResponseObj.partialErrors||actionResponseObj.PartialErrors){err=soaSvc.createError(actionResponseObj);}if(actionResponseObj.ServiceData&&actionResponseObj.ServiceData.partialErrors){err=soaSvc.createError(actionResponseObj.ServiceData);}if(err){deferred.reject(err);}else if(!_.isEmpty(action.outputData)){deferred.resolve(actionResponseObj);}}},function(err){deferred.reject(err);});return deferred.promise;};/**\n * Perform a action synchronously. Specificly for 'syncFunction' actionType.\n * Returns nothing.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed\n * within.\n *\n * @param {Object} action - The 'declAction' to be executed.\n *\n * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.\n *\n * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be\n *            executed.\n *\n * @returns {Object} The result of the called function.\n */export let performActionSync=function(declViewModel,action,dataCtxNode,depModuleObj){if(!action){logger.error('Missing action definition for actionId '+action.actionId);return null;}if(!action.actionType){logger.error('Missing action type for actionId: '+action.actionId);return null;}if(action.actionType!=='syncFunction'){logger.error('Invalid action type for actionId: '+action.actionId);return null;}var inputData=null;let inputError=null;if(action.inputData){inputData=_.cloneDeep(action.inputData);}if(inputData){if(declViewModel.isDestroyed()){declUtils.logLifeCycleIssue(declViewModel,action,'Action results not applied to data context.','performActionSync');}else{try{// this may require it  latest info update to latest\nlet localContext=declUtils.getLatestContext(dataCtxNode,declViewModel);declarativeDataCtxSvc.applyScope(localContext.data,inputData,null,localContext,depModuleObj);}catch(error){inputError=error;}}}if(inputError){return null;}/**\n     * Collect function parameters from input data\n     */var params=[];_.forEach(inputData,function(param){params.push(param);});try{return depModuleObj[action.method].apply(depModuleObj,params);}catch(err){logger.error('Action '+action.actionId+' cannot be executed\\n'+err);}return null;};/**\n * Execute the given 'action' using the given related parameters\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.\n * @param {DeclAction} action - The DeclAction to execute.\n * @param {Object} dataCtxNode - The data context to use during execution.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in\n *            the execution.\n * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on\n * viewModel/ctx.\n * @param {Object} prop - (Optional) vmprops used for onMount lifecycle\n * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle\n *\n * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.\n */export let executeAction=function(declViewModel,action,dataCtxNode,depModuleObj,mapDataOnAction,prop){// Note: Clipboard Service is not following the correct\n// another approach is we can try to create asyncLoad method\n// for all these case and merge them with current thenable flow\n/** revisitme Shaishav\n     * Hint: Need to find the reason for this line. It is failing to compile in afx-next\n    ClipboardService.instance;\n    */declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel,dataCtxNode,action,null,'executeAction (a)');var deferred=AwPromiseService.instance.defer();var functionsList=declViewModel._internal.functions;var{actionPolicyId,propertyPolicyOverride}=getActionPolicyInfo(action,declViewModel,functionsList,dataCtxNode,depModuleObj);// load function deps\nvar functionDeps=loadFuncDependency(action,declViewModel,depModuleObj);/**\n     * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.\n     * This should probably be made right in the future as part of better performance work.\n     */moduleLoader.loadDependentModules(functionDeps).then(function(functionDependancies){_.forEach(functionDependancies,function(funcDepVal,funcDepKey){depModuleObj[funcDepKey]=funcDepVal;});var promise=_performAction(declViewModel,action,functionsList,dataCtxNode,depModuleObj,propertyPolicyOverride);if(!promise){deferred.resolved();return;}promise.then(function(actionResponseObj){/**\n             * Remove any policies that were registered for this action.\n             */if(actionPolicyId){propertyPolicySvc.unregister(actionPolicyId);}if(_isViewModelDestroyed(declViewModel,actionResponseObj,action,deferred,'executeAction (b)')){return;}/**\n             * Check if we have a response and an output data map to work with.\n             * <P>\n             * If so: Process all the action output definitions and stick them on the dataCtxNode.\n             * <P>\n             * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action\n             * object to handle boolean or number type object responses (D-47571).\n             */if(!declUtils.isNil(actionResponseObj)&&!_.isEmpty(action.outputData)){var deferredAssignments={};/* If dataParsers are defined, then run the actionResponseObj through them before pipelining\n                 * to outPutData.\n                 */if(_.isArray(action.dataParsers)){actionResponseObj=dataMapperSvc.applyDataParseDefinitions(actionResponseObj,declViewModel,action.dataParsers,dataCtxNode,depModuleObj);}deferredAssignments=resolveActionOutputData(action,mapDataOnAction,actionResponseObj,declViewModel,depModuleObj,dataCtxNode);AwPromiseService.instance.all(deferredAssignments).then(function(resolvedAssignments){//new in afx 3.1.0\nif(_isViewModelDestroyed(declViewModel,actionResponseObj,action,deferred,'executeAction (c)')){return;}if(mapDataOnAction){performOutputDataMappingForBatch(resolvedAssignments,declViewModel,action,dataCtxNode,depModuleObj,deferred);}else{performOutputDataMapping(resolvedAssignments,declViewModel,prop);// Update binding when data changed\n_.defer(function(){//new in afx 3.1.0\nif(_isViewModelDestroyed(declViewModel,actionResponseObj,action,deferred,'executeAction (d)')){return;}_finishAction(declViewModel,action,dataCtxNode,depModuleObj,actionResponseObj,deferred);});}debugService.debug('actions',declViewModel._internal.panelId,action.actionId,'post',action,declViewModel,resolvedAssignments);if(logger.isTraceEnabled()){let actionName=action.actionId?action.actionId:action.method;let actionName2=declViewModel._internal.viewId+'::'+actionName;logger.trace('Action: ',actionName2);}});}else{_finishAction(declViewModel,action,dataCtxNode,depModuleObj,actionResponseObj,deferred);if(logger.isTraceEnabled()){let actionName=action.actionId?action.actionId:action.method;let actionName2=declViewModel._internal.viewId+'::'+actionName;logger.trace('Action: ',actionName2);}}},function(err){// Extract error message from response and store it in view model\nvar error=_.cloneDeep(err);_.set(declViewModel,'error',error);if(actionPolicyId){propertyPolicySvc.unregister(actionPolicyId);}_processError(err,declViewModel,action,dataCtxNode,depModuleObj);deferred.reject(err);});});return deferred.promise;};exports={performSOAAction,executeAction,performDataProviderAction,performActionSync};export default exports;","map":null,"metadata":{},"sourceType":"module"}