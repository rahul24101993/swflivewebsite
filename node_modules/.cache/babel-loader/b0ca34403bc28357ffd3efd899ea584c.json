{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Fill Down Helper for listen hammer event and manipulate the table element\n *\n * @module js/splmTableFillDownHelper\n *\n * @publishedApolloService\n *\n */\nimport hammer from 'hammerjs';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n/**\n * Instances of this class represent a fill down helper for PL Table\n *\n * @class SPLMTableFillDownHelper\n * @param {Object} tableElem PL Table DOMElement\n */\n\nfunction SPLMTableFillDownHelper(tableElem) {\n  var self = this;\n\n  if (!browserUtils.isMobileOS) {\n    document.body.classList.add('nonTouch');\n  } // reference to the entire table visual tree element\n\n\n  delete self.tableContentElt; // element ref to the source cellTop\n\n  delete self.currentSrcCell; // get the bounding rectangle of the source cell\n\n  delete self.currentSrcCellRectangle; // currently registered event handler\n\n  delete self.currentPanHandler;\n  delete self.currentPanHandlerElement;\n  self.scrollDelta = 0; // currently doing a drag?\n\n  self.isActivelyDragging = false; // the cells within the current drag area; modified as the drag action is done\n\n  self.dragSelectedCells = []; // unhook the drag event hanlder, reset the drag state\n\n  self.removePanEvtHandler = function () {\n    if (self.currentPanHandler) {\n      self.currentPanHandler.off('panup pandown panend panstart pancancel', self.handleHammerCellDrag);\n    }\n\n    delete self.currentPanHandler;\n    self.isActivelyDragging = false;\n    delete self.currentPanHandlerElement;\n\n    if (self.currentSrcCell) {\n      self.currentSrcCell.classList.remove('dragSrc');\n    }\n  }; // pan in some direction. compute the drag coords, find the cells within it\n  // (includes the source and target cells), and style the cells appropriately\n  // to mark the drag area\n\n\n  self.handlePan = function (hEvt) {\n    // get all cells in this column - the attribute name must match the rendering code\n    var getAllColCells = function () {\n      return util.getColumnContentCellElementsByIndex(self.tableContentElt, self.targetColNumber);\n    };\n\n    var scrollAsNeeded = function (panEvent) {\n      // look at table height and offset to determine if we are near the top or bottom?\n      var tableScrollContentRenderer = util.getTableInstance(tableElem).renderer;\n      let currentViewPortBoundingClientRect = self.currentViewportElement.getBoundingClientRect();\n      var boundingTop = currentViewPortBoundingClientRect.top;\n      var boundingBottom = boundingTop + currentViewPortBoundingClientRect.height;\n\n      if (panEvent.srcEvent.pageY < boundingTop + 10) {\n        // scroll up logic\n        self.scrollDelta = tableScrollContentRenderer.manualScroll(false);\n        logger.debug(scroll, ' scroll up');\n      } else if (panEvent.srcEvent.pageY > boundingBottom - 10) {\n        // scroll down logic\n        self.scrollDelta = tableScrollContentRenderer.manualScroll(true);\n        logger.debug(scroll, ' scroll down');\n      }\n    };\n\n    var yDragTop;\n    var yDragBottom; // reset the array of cells in the drag area\n\n    self.dragSelectedCells = []; // which direction is the drag in?\n\n    let srcCellIndex = self.currentSrcCell.parentElement && parseInt(self.currentSrcCell.parentElement.getAttribute('aria-rowindex')) - 2 || 0;\n\n    if (hEvt.srcEvent.clientY + self.scrollDelta > self.currentSrcCellRectangle.top + self.initialScrollDelta + 1) {\n      // down\n      self.dragUp = false;\n      yDragTop = self.currentSrcCellRectangle.top - 1 + self.initialScrollDelta;\n      yDragBottom = hEvt.srcEvent.clientY + self.scrollDelta;\n    } else {\n      // up - swap for contains calculations\n      self.dragUp = true;\n      yDragTop = hEvt.srcEvent.clientY + self.scrollDelta;\n      yDragBottom = self.currentSrcCellRectangle.bottom + self.initialScrollDelta + 1;\n    } // check if the data is being virtualized, if so, adjust target area\n\n\n    var currentSrcCellProperty = util.getPropertyByCellElement(self.currentSrcCell);\n\n    if (self.srcUiVal !== currentSrcCellProperty.uiValue) {\n      if (self.dragUp) {\n        yDragBottom = 9999999;\n      } else {\n        yDragTop = 0;\n      }\n    }\n\n    let columnCells = getAllColCells();\n\n    for (let currentCell of columnCells) {\n      let currIndex = parseInt(currentCell.parentElement.getAttribute('aria-rowindex')) - 2; // -2 because rowindex for header is 1, first row is 2\n\n      let indexDelta = currIndex - srcCellIndex;\n      var currentCellTop = self.currentSrcCellRectangle.top + self.initialScrollDelta + (self.currentSrcCellRectangle.height + 1) * indexDelta;\n      let currentCellBottom = currentCellTop + self.currentSrcCellRectangle.height; // clear any previous styling\n\n      currentCell.classList.remove('dragCellTop');\n      currentCell.classList.remove('dragCell');\n      currentCell.classList.remove('dragCellBottom');\n      var yCell = currentCellTop; // y coord for this cell\n\n      if (self.dragUp === true) {\n        yCell = currentCellBottom;\n      } // compute whether or not this cell is in the drag area\n\n\n      if (yCell < yDragBottom && yCell >= yDragTop) {\n        // if ( hEvt.srcEvent.clientY > currentCellTop && hEvt.srcEvent.clientY < currentCellBottom ) {\n        // this element fits inside the selection rectangle\n        currentCell.classList.add('dragCell');\n        self.dragSelectedCells.push(currentCell);\n      }\n    } // decorate top and bottom cells specially\n\n\n    if (self.dragSelectedCells.length) {\n      self.dragSelectedCells[0].classList.add('dragCellTop');\n      self.dragSelectedCells[self.dragSelectedCells.length - 1].classList.add('dragCellBottom');\n    } // attempt to scroll the grid if we are dragging off\n\n\n    scrollAsNeeded(hEvt);\n  }; // the end pan/drag has been encountered - trigger the data processing\n  // based on the drag area boundary\n\n\n  self.handlePanEnd = function () {\n    // eslint-disable-line no-unused-vars\n    // check that we have more than just the source cell\n    if (self.dragSelectedCells.length > 1) {\n      var endTargetCell;\n      var direction;\n\n      if (self.dragUp) {\n        endTargetCell = self.dragSelectedCells[0];\n        direction = 'up';\n      } else {\n        endTargetCell = self.dragSelectedCells[self.dragSelectedCells.length - 1];\n        direction = 'down';\n      }\n\n      var endTargetProp = util.getPropertyByCellElement(endTargetCell); // iterate the target cells\n\n      for (var inx = 0; inx < self.dragSelectedCells.length; inx++) {\n        self.dragSelectedCells[inx].classList.remove('dragCellTop');\n        self.dragSelectedCells[inx].classList.remove('dragCell');\n        self.dragSelectedCells[inx].classList.remove('dragCellBottom');\n      } // for\n      // emit this fill-complete event to be handled by the tabled\n\n\n      var gridId = util.getTableInstance(tableElem).gridId;\n      let endTarget = endTargetProp.substituteParentUid || endTargetProp.parentUid;\n\n      if (!endTarget) {\n        var rowElement = util.closestElement(endTargetCell, '.' + Const.CLASS_ROW);\n        endTarget = rowElement.vmo.uid;\n      }\n\n      util.getTableInstance(tableElem).editor.fillDownCompleteHandler({\n        propertyName: self.propertyName,\n        source: self.srcUid,\n        endTarget: endTarget,\n        direction: direction\n      });\n    } // children > 1\n\n\n    self.scrollDelta = 0;\n    self.isActivelyDragging = false;\n    self.tableContentElt.classList.remove('aw-jswidgets-dragfilling');\n  };\n\n  self.handlePanCancel = function () {\n    self.removePanEvtHandler();\n  };\n\n  self.handlePanStart = function (hEvt) {\n    // starting pan...\n    self.dragUp = false;\n    self.isActivelyDragging = true;\n    const tableScrollContentRenderer = util.getTableInstance(tableElem).renderer;\n    self.initialScrollDelta = tableScrollContentRenderer.getScrollTop();\n    self.scrollDelta = self.initialScrollDelta; // the source cell for the fill\n\n    var srcCell = util.closestElement(hEvt.target, '.' + Const.CLASS_CELL);\n    self.currentSrcCell = srcCell;\n    self.currentSrcCellRectangle = self.currentSrcCell.getBoundingClientRect();\n    self.currentViewportElement = util.closestElement(self.currentSrcCell, '.' + Const.CLASS_VIEWPORT);\n    var property = util.getPropertyByCellElement(self.currentSrcCell);\n    self.srcUid = property.substituteParentUid || property.parentUid;\n\n    if (!self.srcUid) {\n      var rowElement = util.closestElement(self.currentSrcCell, '.' + Const.CLASS_ROW);\n      self.srcUid = rowElement.vmo.uid;\n    }\n\n    self.srcUiVal = property.uiValue;\n    self.propertyName = property.propertyName;\n    self.tableContentElt = util.closestElement(hEvt.target, '.' + Const.ELEMENT_TABLE); // table content area\n\n    self.currentSrcCell.classList.add('dragSrc');\n    self.tableContentElt.classList.add('aw-jswidgets-dragfilling');\n    self.targetColNumber = self.currentSrcCell.columnDef.index;\n  }; // function for handling the Pan/drag related events from hammer.\n  // account for all the Hammer event states\n\n\n  self.handleHammerCellDrag = function (hEvt) {\n    if (hEvt.type === 'panstart') {\n      self.handlePanStart(hEvt);\n    } else if (hEvt.type === 'panend') {\n      // ending pan\n      self.handlePanEnd();\n    } else if (hEvt.type === 'pancancel') {\n      // cancelling pan\n      self.handlePanCancel();\n    } else if (self.isActivelyDragging) {\n      // other event - actively dragging, so handle pan\n      self.handlePan(hEvt);\n    }\n  }; // this is triggered from the drag handle drag action on the directive.\n  // Determine if we need to setup the hammer pan/drag listener.\n  // Establish the drag start\n\n\n  self.initialize = function (event) {\n    // checking range...\n    if (!self.isActivelyDragging) {\n      event.preventDefault();\n\n      if (self.currentPanHandlerElement) {\n        if (self.currentPanHandlerElement !== event.target) {\n          // remove the old one\n          self.removePanEvtHandler();\n        }\n      }\n\n      if (!self.currentPanHandler) {\n        var hmrMgr = hammer(event.target, {\n          touchAction: 'pan-y'\n        }); // track the element that the hammer is using\n\n        self.currentPanHandlerElement = event.target;\n        var panRecognizer = hmrMgr.get('pan');\n        panRecognizer.set({\n          direction: hammer.DIRECTION_VERTICAL\n        }); // set options\n\n        hmrMgr.on('panup pandown panend panstart pancancel', self.handleHammerCellDrag); // panleft panright\n\n        self.currentPanHandler = hmrMgr;\n      } else if (self.currentPanHandlerElement) {\n        // existing handler, same element?\n        if (self.currentPanHandlerElement !== event.target) {\n          logger.warn('different event handler element - shouldnt be here ------------------');\n        }\n      }\n    }\n  };\n\n  return self;\n}\n\n_c2 = SPLMTableFillDownHelper;\n_c = SPLMTableFillDownHelper;\nexport default SPLMTableFillDownHelper;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableFillDownHelper\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableFillDownHelper\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableFillDownHelper.js"],"names":["SPLMTableFillDownHelper","self","browserUtils","document","getAllColCells","util","scrollAsNeeded","tableScrollContentRenderer","currentViewPortBoundingClientRect","boundingTop","boundingBottom","panEvent","logger","srcCellIndex","parseInt","hEvt","yDragTop","yDragBottom","currentSrcCellProperty","columnCells","currIndex","currentCell","indexDelta","currentCellTop","currentCellBottom","yCell","endTargetCell","direction","endTargetProp","inx","gridId","endTarget","rowElement","Const","propertyName","source","srcCell","property","event","hmrMgr","hammer","touchAction","panRecognizer","DIRECTION_VERTICAL"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Fill Down Helper for listen hammer event and manipulate the table element\n *\n * @module js/splmTableFillDownHelper\n *\n * @publishedApolloService\n *\n */\nimport hammer from 'hammerjs';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n\n/**\n * Instances of this class represent a fill down helper for PL Table\n *\n * @class SPLMTableFillDownHelper\n * @param {Object} tableElem PL Table DOMElement\n */\nfunction SPLMTableFillDownHelper( tableElem ) {\n    var self = this;\n\n    if( !browserUtils.isMobileOS ) {\n        document.body.classList.add( 'nonTouch' );\n    }\n\n    // reference to the entire table visual tree element\n    delete self.tableContentElt;\n\n    // element ref to the source cellTop\n    delete self.currentSrcCell;\n    // get the bounding rectangle of the source cell\n    delete self.currentSrcCellRectangle;\n\n    // currently registered event handler\n    delete self.currentPanHandler;\n    delete self.currentPanHandlerElement;\n    self.scrollDelta = 0;\n\n    // currently doing a drag?\n    self.isActivelyDragging = false;\n\n    // the cells within the current drag area; modified as the drag action is done\n    self.dragSelectedCells = [];\n\n    // unhook the drag event hanlder, reset the drag state\n    self.removePanEvtHandler = function() {\n        if( self.currentPanHandler ) {\n            self.currentPanHandler.off( 'panup pandown panend panstart pancancel', self.handleHammerCellDrag );\n        }\n        delete self.currentPanHandler;\n        self.isActivelyDragging = false;\n        delete self.currentPanHandlerElement;\n        if( self.currentSrcCell ) {\n            self.currentSrcCell.classList.remove( 'dragSrc' );\n        }\n    };\n\n    // pan in some direction. compute the drag coords, find the cells within it\n    // (includes the source and target cells), and style the cells appropriately\n    // to mark the drag area\n    self.handlePan = function( hEvt ) {\n        // get all cells in this column - the attribute name must match the rendering code\n        var getAllColCells = function() {\n            return util.getColumnContentCellElementsByIndex( self.tableContentElt, self.targetColNumber );\n        };\n\n        var scrollAsNeeded = function( panEvent ) {\n            // look at table height and offset to determine if we are near the top or bottom?\n            var tableScrollContentRenderer = util.getTableInstance( tableElem ).renderer;\n            let currentViewPortBoundingClientRect = self.currentViewportElement.getBoundingClientRect();\n\n            var boundingTop = currentViewPortBoundingClientRect.top;\n            var boundingBottom = boundingTop + currentViewPortBoundingClientRect.height;\n\n            if( panEvent.srcEvent.pageY < boundingTop + 10 ) {\n                // scroll up logic\n                self.scrollDelta = tableScrollContentRenderer.manualScroll( false );\n                logger.debug( scroll, ' scroll up' );\n            } else if( panEvent.srcEvent.pageY > boundingBottom - 10 ) {\n                // scroll down logic\n                self.scrollDelta = tableScrollContentRenderer.manualScroll( true );\n                logger.debug( scroll, ' scroll down' );\n            }\n        };\n\n        var yDragTop;\n        var yDragBottom;\n\n        // reset the array of cells in the drag area\n        self.dragSelectedCells = [];\n\n        // which direction is the drag in?\n        let srcCellIndex = self.currentSrcCell.parentElement && parseInt( self.currentSrcCell.parentElement.getAttribute( 'aria-rowindex' ) ) - 2 || 0;\n\n        if( hEvt.srcEvent.clientY + self.scrollDelta > self.currentSrcCellRectangle.top + self.initialScrollDelta + 1 ) {\n            // down\n            self.dragUp = false;\n            yDragTop = self.currentSrcCellRectangle.top - 1 + self.initialScrollDelta;\n            yDragBottom = hEvt.srcEvent.clientY + self.scrollDelta;\n        } else {\n            // up - swap for contains calculations\n            self.dragUp = true;\n            yDragTop = hEvt.srcEvent.clientY + self.scrollDelta;\n            yDragBottom = self.currentSrcCellRectangle.bottom + self.initialScrollDelta + 1;\n        }\n\n        // check if the data is being virtualized, if so, adjust target area\n        var currentSrcCellProperty = util.getPropertyByCellElement( self.currentSrcCell );\n        if( self.srcUiVal !== currentSrcCellProperty.uiValue ) {\n            if( self.dragUp ) {\n                yDragBottom = 9999999;\n            } else {\n                yDragTop = 0;\n            }\n        }\n\n        let columnCells = getAllColCells();\n\n        for( let currentCell of columnCells ) {\n            let currIndex = parseInt( currentCell.parentElement.getAttribute( 'aria-rowindex' ) ) - 2; // -2 because rowindex for header is 1, first row is 2\n            let indexDelta = currIndex - srcCellIndex;\n            var currentCellTop = self.currentSrcCellRectangle.top + self.initialScrollDelta + ( self.currentSrcCellRectangle.height + 1 ) * indexDelta;\n            let currentCellBottom = currentCellTop + self.currentSrcCellRectangle.height;\n\n            // clear any previous styling\n            currentCell.classList.remove( 'dragCellTop' );\n            currentCell.classList.remove( 'dragCell' );\n            currentCell.classList.remove( 'dragCellBottom' );\n\n            var yCell = currentCellTop; // y coord for this cell\n            if( self.dragUp === true ) {\n                yCell = currentCellBottom;\n            }\n\n            // compute whether or not this cell is in the drag area\n            if( yCell < yDragBottom && yCell >= yDragTop ) {\n                // if ( hEvt.srcEvent.clientY > currentCellTop && hEvt.srcEvent.clientY < currentCellBottom ) {\n                // this element fits inside the selection rectangle\n                currentCell.classList.add( 'dragCell' );\n                self.dragSelectedCells.push( currentCell );\n            }\n        }\n\n        // decorate top and bottom cells specially\n        if( self.dragSelectedCells.length ) {\n            self.dragSelectedCells[ 0 ].classList.add( 'dragCellTop' );\n            self.dragSelectedCells[ self.dragSelectedCells.length - 1 ].classList.add( 'dragCellBottom' );\n        }\n\n        // attempt to scroll the grid if we are dragging off\n        scrollAsNeeded( hEvt );\n    };\n\n    // the end pan/drag has been encountered - trigger the data processing\n    // based on the drag area boundary\n    self.handlePanEnd = function() { // eslint-disable-line no-unused-vars\n        // check that we have more than just the source cell\n        if( self.dragSelectedCells.length > 1 ) {\n            var endTargetCell;\n            var direction;\n            if( self.dragUp ) {\n                endTargetCell = self.dragSelectedCells[ 0 ];\n                direction = 'up';\n            } else {\n                endTargetCell = self.dragSelectedCells[ self.dragSelectedCells.length - 1 ];\n                direction = 'down';\n            }\n            var endTargetProp = util.getPropertyByCellElement( endTargetCell );\n\n            // iterate the target cells\n            for( var inx = 0; inx < self.dragSelectedCells.length; inx++ ) {\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCellTop' );\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCell' );\n                self.dragSelectedCells[ inx ].classList.remove( 'dragCellBottom' );\n            } // for\n\n            // emit this fill-complete event to be handled by the tabled\n            var gridId = util.getTableInstance( tableElem ).gridId;\n            let endTarget = endTargetProp.substituteParentUid || endTargetProp.parentUid;\n            if( !endTarget ) {\n                var rowElement = util.closestElement( endTargetCell, '.' + Const.CLASS_ROW );\n                endTarget = rowElement.vmo.uid;\n            }\n            util.getTableInstance( tableElem ).editor.fillDownCompleteHandler( {\n                propertyName: self.propertyName,\n                source: self.srcUid,\n                endTarget: endTarget,\n                direction: direction\n            } );\n        } // children > 1\n\n        self.scrollDelta = 0;\n        self.isActivelyDragging = false;\n        self.tableContentElt.classList.remove( 'aw-jswidgets-dragfilling' );\n    };\n\n    self.handlePanCancel = function() {\n        self.removePanEvtHandler();\n    };\n\n    self.handlePanStart = function( hEvt ) {\n        // starting pan...\n        self.dragUp = false;\n        self.isActivelyDragging = true;\n        const tableScrollContentRenderer = util.getTableInstance( tableElem ).renderer;\n        self.initialScrollDelta = tableScrollContentRenderer.getScrollTop();\n        self.scrollDelta = self.initialScrollDelta;\n\n        // the source cell for the fill\n        var srcCell = util.closestElement( hEvt.target, '.' + Const.CLASS_CELL );\n        self.currentSrcCell = srcCell;\n        self.currentSrcCellRectangle = self.currentSrcCell.getBoundingClientRect();\n        self.currentViewportElement = util.closestElement( self.currentSrcCell, '.' + Const.CLASS_VIEWPORT );\n\n        var property = util.getPropertyByCellElement( self.currentSrcCell );\n\n        self.srcUid = property.substituteParentUid || property.parentUid;\n        if( !self.srcUid ) {\n            var rowElement = util.closestElement( self.currentSrcCell, '.' + Const.CLASS_ROW );\n            self.srcUid = rowElement.vmo.uid;\n        }\n        self.srcUiVal = property.uiValue;\n        self.propertyName = property.propertyName;\n\n        self.tableContentElt = util.closestElement( hEvt.target, '.' + Const.ELEMENT_TABLE ); // table content area\n\n        self.currentSrcCell.classList.add( 'dragSrc' );\n\n        self.tableContentElt.classList.add( 'aw-jswidgets-dragfilling' );\n\n        self.targetColNumber = self.currentSrcCell.columnDef.index;\n    };\n\n    // function for handling the Pan/drag related events from hammer.\n    // account for all the Hammer event states\n    self.handleHammerCellDrag = function( hEvt ) {\n        if( hEvt.type === 'panstart' ) {\n            self.handlePanStart( hEvt );\n        } else if( hEvt.type === 'panend' ) {\n            // ending pan\n            self.handlePanEnd();\n        } else if( hEvt.type === 'pancancel' ) {\n            // cancelling pan\n            self.handlePanCancel();\n        } else if( self.isActivelyDragging ) {\n            // other event - actively dragging, so handle pan\n            self.handlePan( hEvt );\n        }\n    };\n\n    // this is triggered from the drag handle drag action on the directive.\n    // Determine if we need to setup the hammer pan/drag listener.\n    // Establish the drag start\n    self.initialize = function( event ) {\n        // checking range...\n        if( !self.isActivelyDragging ) {\n            event.preventDefault();\n\n            if( self.currentPanHandlerElement ) {\n                if( self.currentPanHandlerElement !== event.target ) {\n                    // remove the old one\n                    self.removePanEvtHandler();\n                }\n            }\n\n            if( !self.currentPanHandler ) {\n                var hmrMgr = hammer( event.target, {\n                    touchAction: 'pan-y'\n                } );\n\n                // track the element that the hammer is using\n                self.currentPanHandlerElement = event.target;\n\n                var panRecognizer = hmrMgr.get( 'pan' );\n\n                panRecognizer.set( {\n                    direction: hammer.DIRECTION_VERTICAL\n                } ); // set options\n\n                hmrMgr.on( 'panup pandown panend panstart pancancel', self.handleHammerCellDrag ); // panleft panright\n\n                self.currentPanHandler = hmrMgr;\n            } else if( self.currentPanHandlerElement ) {\n                // existing handler, same element?\n                if( self.currentPanHandlerElement !== event.target ) {\n                    logger.warn( 'different event handler element - shouldnt be here ------------------' );\n                }\n            }\n        }\n    };\n\n    return self;\n}\n\nexport default SPLMTableFillDownHelper;\n"]},"metadata":{},"sourceType":"module"}