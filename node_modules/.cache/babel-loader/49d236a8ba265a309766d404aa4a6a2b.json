{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch visual indicators\n *\n * @module js/visualIndicatorService\n */\nimport commandsMapSvc from 'js/commandsMapService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nimport { getImageAliasFromId } from 'js/imageRegistry'; //  FIXME this should be loaded async but before the sync API below that uses it is called\n\nvar _indicators;\n\nloadconfiguration(); // eslint-disable-next-line require-jsdoc\n\nasync function loadconfiguration() {\n  await cfgSvc.getCfg('indicators').then(indicators => {\n    _indicators = indicators;\n  });\n} // for Unit tests\n\n\n_indicators = _indicators ? _indicators : {};\nvar exports = {};\n\nlet _isValidPropName = function (indicaotrProp, objPropName) {\n  var isValid = false;\n\n  if (indicaotrProp && indicaotrProp.names && _.isArray(indicaotrProp.names)) {\n    isValid = indicaotrProp.names.some(iPropName => iPropName === objPropName);\n  }\n\n  return isValid;\n};\n\nlet _isValidModelType = function (vmoModelType, modelTypes) {\n  let isValid = false;\n\n  if (vmoModelType && modelTypes && _.isArray(modelTypes)) {\n    isValid = modelTypes.some(modelType => commandsMapSvc.isInstanceOf(modelType, vmoModelType));\n  }\n\n  return isValid;\n};\n\nlet _getIndicatorsFromPreVerdict = function (preVerdictArray, getModelObjCallBack) {\n  let indicatorsArray = [];\n\n  _.forEach(preVerdictArray, preVerdictor => {\n    let refObjs = [];\n    let vmoPropVal = preVerdictor.vmoProp; //get the array of referece object for these indicator\n\n    if (vmoPropVal.dbValue && !_.isArray(vmoPropVal.dbValue)) {\n      let refObjUid = vmoPropVal.dbValue;\n      const refObj = getModelObjCallBack(refObjUid);\n\n      if (refObj) {\n        refObj.uid = refObjUid;\n        refObjs.push(refObj);\n      }\n    } else if (vmoPropVal.dbValues) {\n      vmoPropVal.dbValues.forEach(dbValue => {\n        const refObj = getModelObjCallBack(dbValue);\n\n        if (refObj) {\n          refObj.uid = dbValue;\n          refObjs.push(refObj);\n        }\n      });\n    }\n\n    _.forEach(refObjs, refObj => {\n      let indicatorArray = preVerdictor.indicators;\n      let verdictObjInfo = {};\n      let hasDefaultIndicator = false;\n      let defaultIndicator;\n\n      _.forEach(indicatorArray, indicator => {\n        let verdictObj = evaluatePropBasedCondition(indicator.prop, refObj, indicator.tooltip);\n        hasDefaultIndicator = verdictObj.isDefaultIndicator;\n\n        if (hasDefaultIndicator) {\n          defaultIndicator = indicator;\n        }\n\n        if (verdictObj && verdictObj.hasIndicatorMatchedVal) {\n          //Tooltip is missing some properties from target object\n          if (verdictObj.missingProps.length > 0) {\n            var foundProps = []; //Load the properties from the original object (preVerdicator.vmoProp.parentUid)\n\n            const srcObj = getModelObjCallBack(preVerdictor.vmoProp.parentUid);\n\n            if (srcObj) {\n              //Iterate through the list backward, remove all properties found on this object\n              //(Note there may be some properties not found in the src or target obj)\n              //(If our goal is to end checking here, we can iterate forward and clear the list)\n              for (var propIndx = verdictObj.missingProps.length - 1; propIndx >= 0; propIndx--) {\n                if (srcObj.props[verdictObj.missingProps[propIndx]]) {\n                  //Assemble an object for use later when creating tooltip\n                  var propObj = {\n                    matchingVal: srcObj.props[verdictObj.missingProps[propIndx]].dbValues[0] + '\\n',\n                    tooltip: srcObj.props[verdictObj.missingProps[propIndx]].uiValues[0] + '\\n',\n                    propertyDisplayName: srcObj.props[verdictObj.missingProps[propIndx]].propertyDescriptor.displayName\n                  };\n                  foundProps.unshift(propObj); //Remove this property from the list of missing properties.\n\n                  verdictObj.missingProps.splice(propIndx, 1);\n                }\n              } //Iterate through the list to add to the tooltip the found properties.\n\n\n              for (var idx = 0; idx < foundProps.length; idx++) {\n                verdictObj.matchingVal += foundProps[idx].matchingVal; //If an indicator requires property name to be displayed, we add it first.\n\n                if (indicator.tooltip.showPropDisplayName) {\n                  verdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                }\n\n                verdictObj.tooltip += foundProps[idx].tooltip;\n              }\n            }\n          }\n\n          verdictObj.indicator = indicator;\n          verdictObjInfo = verdictObj;\n        }\n      }); //if hasDefaultIndicator = true it has default indicator\n\n\n      if (hasDefaultIndicator && defaultIndicator && _.isEmpty(verdictObjInfo)) {\n        let targetPropNames = _.get(defaultIndicator, 'tooltip.propNames');\n\n        if (!targetPropNames) {\n          targetPropNames = ['object_string'];\n        }\n\n        let propUiValue = '';\n\n        for (var targetProp in targetPropNames) {\n          var tgtProp = targetPropNames[targetProp];\n          var prop = refObj.props[tgtProp];\n\n          if (prop && prop.dbValue) {\n            propUiValue += prop.uiValue + '\\n';\n          } else if (prop && prop.dbValues && prop.dbValues.length > 0) {\n            propUiValue += prop.uiValues[0] + '\\n';\n          }\n        }\n\n        let indicator = exports.getIndicatorFromParams(defaultIndicator, propUiValue);\n        indicatorsArray.push(indicator);\n      } else if (!_.isEmpty(verdictObjInfo)) {\n        let indicator = exports.getIndicatorFromParams(verdictObjInfo.indicator, verdictObjInfo.tooltip);\n        indicatorsArray.push(indicator);\n      }\n    });\n  });\n\n  return indicatorsArray;\n};\n/**\n * Evaluates prop based condition structure\n *\n * @return {Object} verdictObject containing indicator matching information\n * verdictObj\n    {\n        hasIndicatorMatchedVal   :    If input indicator has matched exact value\n        matchingVal              :    What exact value indicator matched to e.g. \"Approved\"\n        tooltip                  :   \"localized(Approved)\" # based on Display Name\n    }\n */\n\n\nexport let evaluatePropBasedCondition = function (indicatorProp, obj, tooltip) {\n  let verdictObj = {\n    isDefaultIndicator: false,\n    missingProps: []\n  };\n\n  if (indicatorProp.conditions && Object.keys(indicatorProp.conditions).length > 0) {\n    verdictObj.hasIndicatorMatchedVal = expressionParserUtils.evaluateConditions(indicatorProp.conditions, obj);\n\n    if (verdictObj.hasIndicatorMatchedVal) {\n      verdictObj.uid = obj.uid;\n      verdictObj.tooltip = '';\n      verdictObj.matchingVal = '';\n      var tooltipPropNames = tooltip.propNames;\n\n      for (var tooltipProp in tooltipPropNames) {\n        var tooltipPropName = tooltipPropNames[tooltipProp]; // 20200922 - try to validate prop exist by propertyDescriptorsMap, not object itself\n\n        if (obj.modelType && obj.modelType.propertyDescriptorsMap && !obj.modelType.propertyDescriptorsMap.hasOwnProperty(tooltipPropName)) {\n          verdictObj.missingProps.push(tooltipPropName);\n          continue;\n        }\n\n        verdictObj.matchingVal += obj.props[tooltipPropName].dbValues[0] + '\\n';\n\n        if (tooltip.showPropDisplayName) {\n          verdictObj.tooltip += obj.props[tooltipPropName].propertyDescriptor.displayName + ': ';\n        }\n\n        verdictObj.tooltip += obj.props[tooltipPropName].uiValues[0] + '\\n';\n      }\n    }\n  } else if (indicatorProp.conditions && Object.keys(indicatorProp.conditions).length === 0) {\n    //if this has empty condition object, is a default indicator\n    if (indicatorProp.names && _.isArray(indicatorProp.names) && indicatorProp.names.length > 0) {\n      verdictObj.isDefaultIndicator = true;\n      return verdictObj;\n    }\n  } else if (indicatorProp.type) {\n    var evaluatedVerdictObj = evaluatePropBasedCondition(indicatorProp.type.prop, obj, tooltip); //There are missing properties from the tooltip\n\n    if (evaluatedVerdictObj.missingProps.length > 0) {\n      var foundProps = []; //Iterate through the list backward, remove all properties found on this object\n      //(Note there may be some properties not found in the src or target obj)\n      //(If our goal is to end checking here, we can iterate forward and clear the list)\n\n      for (var propIndx = evaluatedVerdictObj.missingProps.length - 1; propIndx >= 0; propIndx--) {\n        if (obj.props[evaluatedVerdictObj.missingProps[propIndx]]) {\n          var propObj = {\n            matchingVal: obj.props[evaluatedVerdictObj.missingProps[propIndx]].dbValues[0] + '\\n',\n            tooltip: obj.props[evaluatedVerdictObj.missingProps[propIndx]].uiValues[0] + '\\n',\n            propertyDisplayName: obj.props[evaluatedVerdictObj.missingProps[propIndx]].propertyDescriptor.displayName\n          };\n          foundProps.unshift(propObj); //Current object found this property, so we can remove it from the list.\n\n          evaluatedVerdictObj.missingProps.splice(propIndx, 1);\n        }\n      } //Iterate through the list to add to the tooltip the found properties.\n\n\n      for (var idx = 0; idx < foundProps.length; idx++) {\n        evaluatedVerdictObj.matchingVal += foundProps[idx].matchingVal;\n\n        if (tooltip.showPropDisplayName) {\n          evaluatedVerdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n        }\n\n        evaluatedVerdictObj.tooltip += foundProps[idx].tooltip;\n      }\n    }\n\n    return evaluatedVerdictObj;\n  }\n\n  return verdictObj;\n};\n/**\n * Returns the list of visual indicators.\n *\n * @param {vmo} vmo - viewModelObject.\n * @param {getModelObjCallBack} getModelObjCallBack - call back.\n * @return {Array} List of visual indicator objects\n */\n\nexport let getVisualIndicators = function (vmo, getModelObjCallBack) {\n  var indicatorsArray = [];\n\n  if (vmo && vmo.props) {\n    let preVerdictArray = []; //Go through all the props from VMO, get indicators for each matched prop\n\n    for (const [propKey, propValue] of Object.entries(vmo.props)) {\n      let preVerdict = {};\n\n      if (!_.isEmpty(propValue.dbValue) || !_.isEmpty(propValue.dbValues)) {\n        preVerdict.name = propKey;\n        preVerdict.vmoProp = propValue;\n        let matchedIndicators = Object.values(_indicators).filter(indicatorJson => indicatorJson && _isValidPropName(indicatorJson.prop, propKey)); //each prop may have multiple indicator\n\n        if (!_.isEmpty(matchedIndicators)) {\n          preVerdict.indicators = matchedIndicators;\n          preVerdictArray.push(preVerdict);\n        }\n      }\n    }\n\n    indicatorsArray = _getIndicatorsFromPreVerdict(preVerdictArray, getModelObjCallBack); //get the indicators which not defined in indicator.prop, eg. CheckOut\n\n    Object.values(_indicators).forEach(indicatorJson => {\n      if (indicatorJson && !indicatorJson.prop) {\n        var modelTypes = indicatorJson.modelTypes;\n        var conditions = indicatorJson.conditions;\n\n        if (_isValidModelType(vmo.modelType, modelTypes)) {\n          let isValid = true;\n\n          if (conditions) {\n            isValid = expressionParserUtils.evaluateConditions(conditions, vmo);\n          }\n\n          if (isValid) {\n            const indicator = exports.generateIndicator(vmo, indicatorJson);\n\n            if (indicator && !_.isEqual(indicator.tooltip, '')) {\n              indicatorsArray.push(indicator);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  return indicatorsArray;\n};\n/**\n * Gets the default indicator for a property\n *\n * @return {Object} Indicator object which is default for a given prop\n */\n\nexport let getDefaultIndicator = function (propName, obj) {\n  var defaultIndicator = null;\n\n  _.forEach(_indicators, function (indicatorJson) {\n    if (indicatorJson) {\n      var prop = indicatorJson.prop;\n\n      if (prop && prop.names && _.isArray(prop.names) && prop.names.length > 0) {\n        // If prop is defined correctly, see if it is valid to default for input propName\n        if (prop.names.indexOf(propName) >= 0 && prop.conditions && _.isEmpty(prop.conditions)) {\n          defaultIndicator = indicatorJson;\n          return false;\n        }\n      }\n    }\n  });\n\n  return defaultIndicator;\n};\n/**\n * Generates indicator object if tooltips are available for given view model object\n *\n * @return {Object} Indicator object which contains tooltip and icon\n */\n\nexport let generateIndicator = function (vmo, indicatorJson) {\n  var indicator;\n\n  if (vmo && indicatorJson && indicatorJson.tooltip) {\n    var indicatorProps = indicatorJson.tooltip.propNames;\n\n    if (_.isArray(indicatorProps)) {\n      var finalTooltip = '';\n\n      for (var indx = 0; indx < indicatorProps.length; indx++) {\n        var tooltip = '';\n        var propValues = [];\n        var indicatorProp = indicatorProps[indx];\n\n        if (indicatorProp && vmo.props.hasOwnProperty(indicatorProp)) {\n          var vmProp = vmo.props[indicatorProp];\n\n          if (vmProp) {\n            propValues = vmProp.displayValues;\n          }\n\n          if (propValues && propValues.length > 0) {\n            for (var i = 0; i < propValues.length; i++) {\n              var propValue = propValues[i];\n\n              if (propValue && propValue !== ' ') {\n                if (tooltip === '' && indicatorJson.tooltip.showPropDisplayName) {\n                  tooltip = vmProp.propertyDisplayName + ': ';\n                }\n\n                if (i !== propValues.length - 1) {\n                  tooltip += propValue + '\\n';\n                } else {\n                  tooltip += propValue;\n                }\n              }\n            }\n\n            if (finalTooltip === '') {\n              finalTooltip = tooltip;\n            } else {\n              finalTooltip = finalTooltip + '\\n' + tooltip;\n            }\n          }\n        }\n      }\n\n      const icon = getImageAliasFromId(`indicator${indicatorJson.iconName}`) ? `indicator${indicatorJson.iconName}` : 'indicatorMissingImage';\n      indicator = {\n        tooltip: finalTooltip,\n        // Sanitize the command icon\n        image: icon\n      };\n    }\n  }\n\n  return indicator;\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {Object} indicator\n */\n\nexport let getIndicatorFromParams = function (indicatorJson, tooltip) {\n  var indicatorFile = null;\n\n  if (indicatorJson !== null) {\n    indicatorFile = indicatorJson.iconName;\n  }\n\n  const icon = getImageAliasFromId(`indicator${indicatorFile}`) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n  return {\n    tooltip: tooltip,\n    // Sanitize the command icon\n    image: icon\n  };\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {indicatorJson} indicatorJson - json\n * @returns {Array} returns a list of visual indicators\n */\n\nexport let getIndicatorFromJSON = function (indicatorJson) {\n  var indicatorsArray = [];\n  var indicatorFile = null;\n  var tooltip = null;\n\n  _.forEach(indicatorJson, function (indicator) {\n    if (indicator) {\n      indicatorFile = indicator.image;\n      tooltip = indicator.tooltip;\n    }\n\n    const icon = getImageAliasFromId(`indicator${indicatorFile}`) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n    var indicatorObj = {\n      image: icon,\n      tooltip: tooltip\n    };\n    indicatorsArray.push(indicatorObj);\n  });\n\n  return indicatorsArray;\n};\n/**\n * API to override generated indicators for testing only.\n *\n * @param {Object} indicatorsOverride\n */\n\nexport let setIndicators = function (indicatorsOverride) {\n  _indicators = indicatorsOverride;\n};\nexports = {\n  getVisualIndicators,\n  getDefaultIndicator,\n  generateIndicator,\n  evaluatePropBasedCondition,\n  getIndicatorFromParams,\n  getIndicatorFromJSON,\n  setIndicators\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/visualIndicatorService.js"],"names":["loadconfiguration","indicators","_indicators","exports","_isValidPropName","isValid","indicaotrProp","_","iPropName","_isValidModelType","vmoModelType","modelTypes","modelType","commandsMapSvc","_getIndicatorsFromPreVerdict","indicatorsArray","preVerdictor","refObjs","vmoPropVal","refObjUid","refObj","getModelObjCallBack","dbValue","indicatorArray","verdictObjInfo","hasDefaultIndicator","indicator","verdictObj","evaluatePropBasedCondition","defaultIndicator","foundProps","srcObj","propIndx","propObj","matchingVal","tooltip","propertyDisplayName","displayName","idx","targetPropNames","propUiValue","tgtProp","prop","isDefaultIndicator","missingProps","indicatorProp","Object","expressionParserUtils","obj","tooltipPropNames","tooltipPropName","evaluatedVerdictObj","getVisualIndicators","vmo","preVerdictArray","preVerdict","propValue","matchedIndicators","indicatorJson","conditions","getDefaultIndicator","generateIndicator","indicatorProps","finalTooltip","indx","propValues","vmProp","i","icon","getImageAliasFromId","iconName","image","getIndicatorFromParams","indicatorFile","getIndicatorFromJSON","indicatorObj","setIndicators"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch visual indicators\n *\n * @module js/visualIndicatorService\n */\nimport commandsMapSvc from 'js/commandsMapService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nimport { getImageAliasFromId } from 'js/imageRegistry';\n\n//  FIXME this should be loaded async but before the sync API below that uses it is called\nvar _indicators;\nloadconfiguration();\n\n// eslint-disable-next-line require-jsdoc\nasync function loadconfiguration() {\n    await cfgSvc.getCfg( 'indicators' ).then( indicators => {\n        _indicators = indicators;\n    } );\n}\n// for Unit tests\n_indicators = _indicators ? _indicators : {};\nvar exports = {};\n\n\nlet _isValidPropName = function( indicaotrProp, objPropName ) {\n    var isValid = false;\n    if( indicaotrProp && indicaotrProp.names && _.isArray( indicaotrProp.names ) ) {\n        isValid = indicaotrProp.names.some( iPropName => iPropName === objPropName );\n    }\n    return isValid;\n};\n\nlet _isValidModelType = function( vmoModelType, modelTypes ) {\n    let isValid = false;\n    if( vmoModelType && modelTypes && _.isArray( modelTypes ) ) {\n        isValid = modelTypes.some( modelType => commandsMapSvc.isInstanceOf( modelType, vmoModelType ) );\n    }\n    return isValid;\n};\n\nlet _getIndicatorsFromPreVerdict = function( preVerdictArray, getModelObjCallBack ) {\n    let indicatorsArray = [];\n    _.forEach( preVerdictArray, preVerdictor => {\n        let refObjs = [];\n        let vmoPropVal = preVerdictor.vmoProp;\n        //get the array of referece object for these indicator\n        if( vmoPropVal.dbValue && !_.isArray( vmoPropVal.dbValue ) ) {\n            let refObjUid = vmoPropVal.dbValue;\n            const refObj = getModelObjCallBack( refObjUid );\n            if( refObj ) {\n                refObj.uid = refObjUid;\n                refObjs.push( refObj );\n            }\n        } else if( vmoPropVal.dbValues ) {\n            vmoPropVal.dbValues.forEach( dbValue => {\n                const refObj = getModelObjCallBack( dbValue );\n                if( refObj ) {\n                    refObj.uid = dbValue;\n                    refObjs.push( refObj );\n                }\n            } );\n        }\n\n        _.forEach( refObjs, refObj => {\n            let indicatorArray = preVerdictor.indicators;\n            let verdictObjInfo = {};\n            let hasDefaultIndicator = false;\n            let defaultIndicator;\n            _.forEach( indicatorArray, indicator => {\n                let verdictObj = evaluatePropBasedCondition( indicator.prop, refObj, indicator.tooltip );\n                hasDefaultIndicator = verdictObj.isDefaultIndicator;\n                if( hasDefaultIndicator ) {\n                    defaultIndicator = indicator;\n                }\n                if( verdictObj && verdictObj.hasIndicatorMatchedVal ) {\n                    //Tooltip is missing some properties from target object\n                    if( verdictObj.missingProps.length > 0 ) {\n                        var foundProps = [];\n\n                        //Load the properties from the original object (preVerdicator.vmoProp.parentUid)\n                        const srcObj = getModelObjCallBack( preVerdictor.vmoProp.parentUid );\n                        if( srcObj ) {\n                            //Iterate through the list backward, remove all properties found on this object\n                            //(Note there may be some properties not found in the src or target obj)\n                            //(If our goal is to end checking here, we can iterate forward and clear the list)\n                            for( var propIndx = verdictObj.missingProps.length - 1; propIndx >= 0; propIndx-- ) {\n                                if( srcObj.props[verdictObj.missingProps[propIndx]] ) {\n                                    //Assemble an object for use later when creating tooltip\n                                    var propObj = { matchingVal: srcObj.props[verdictObj.missingProps[propIndx]].dbValues[ 0 ] + '\\n',\n                                        tooltip: srcObj.props[verdictObj.missingProps[propIndx]].uiValues[ 0 ] + '\\n',\n                                        propertyDisplayName: srcObj.props[verdictObj.missingProps[propIndx]].propertyDescriptor.displayName };\n                                    foundProps.unshift( propObj );\n\n                                    //Remove this property from the list of missing properties.\n                                    verdictObj.missingProps.splice( propIndx, 1 );\n                                }\n                            }\n                            //Iterate through the list to add to the tooltip the found properties.\n                            for( var idx = 0; idx < foundProps.length; idx++ ) {\n                                verdictObj.matchingVal += foundProps[idx].matchingVal;\n\n                                //If an indicator requires property name to be displayed, we add it first.\n                                if( indicator.tooltip.showPropDisplayName ) {\n                                    verdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                                }\n\n                                verdictObj.tooltip += foundProps[idx].tooltip;\n                            }\n                        }\n                    }\n\n                    verdictObj.indicator = indicator;\n                    verdictObjInfo = verdictObj;\n                }\n            } );\n\n            //if hasDefaultIndicator = true it has default indicator\n            if( hasDefaultIndicator && defaultIndicator && _.isEmpty( verdictObjInfo ) ) {\n                let targetPropNames = _.get( defaultIndicator, 'tooltip.propNames' );\n                if( !targetPropNames ) {\n                    targetPropNames = [ 'object_string' ];\n                }\n                let propUiValue = '';\n                for( var targetProp in targetPropNames ) {\n                    var tgtProp = targetPropNames[ targetProp ];\n                    var prop = refObj.props[ tgtProp ];\n                    if( prop && prop.dbValue ) {\n                        propUiValue += prop.uiValue + '\\n';\n                    } else if( prop && prop.dbValues && prop.dbValues.length > 0 ) {\n                        propUiValue += prop.uiValues[ 0 ] + '\\n';\n                    }\n                }\n                let indicator = exports.getIndicatorFromParams( defaultIndicator, propUiValue );\n                indicatorsArray.push( indicator );\n            } else if ( !_.isEmpty( verdictObjInfo ) ) {\n                let indicator = exports.getIndicatorFromParams( verdictObjInfo.indicator, verdictObjInfo.tooltip );\n                indicatorsArray.push( indicator );\n            }\n        } );\n    } );\n    return indicatorsArray;\n};\n\n\n/**\n * Evaluates prop based condition structure\n *\n * @return {Object} verdictObject containing indicator matching information\n * verdictObj\n    {\n        hasIndicatorMatchedVal   :    If input indicator has matched exact value\n        matchingVal              :    What exact value indicator matched to e.g. \"Approved\"\n        tooltip                  :   \"localized(Approved)\" # based on Display Name\n    }\n */\nexport let evaluatePropBasedCondition = function( indicatorProp, obj, tooltip ) {\n    let verdictObj = { isDefaultIndicator: false, missingProps: [] };\n    if( indicatorProp.conditions && Object.keys( indicatorProp.conditions ).length > 0 ) {\n        verdictObj.hasIndicatorMatchedVal = expressionParserUtils.evaluateConditions( indicatorProp.conditions, obj );\n        if( verdictObj.hasIndicatorMatchedVal ) {\n            verdictObj.uid = obj.uid;\n            verdictObj.tooltip = '';\n            verdictObj.matchingVal = '';\n            var tooltipPropNames = tooltip.propNames;\n            for( var tooltipProp in tooltipPropNames ) {\n                var tooltipPropName = tooltipPropNames[ tooltipProp ];\n\n                // 20200922 - try to validate prop exist by propertyDescriptorsMap, not object itself\n                if( obj.modelType && obj.modelType.propertyDescriptorsMap && !obj.modelType.propertyDescriptorsMap.hasOwnProperty( tooltipPropName ) ) {\n                    verdictObj.missingProps.push( tooltipPropName );\n                    continue;\n                }\n\n                verdictObj.matchingVal += obj.props[ tooltipPropName ].dbValues[ 0 ] + '\\n';\n\n                if( tooltip.showPropDisplayName ) {\n                    verdictObj.tooltip += obj.props[ tooltipPropName ].propertyDescriptor.displayName + ': ';\n                }\n\n                verdictObj.tooltip += obj.props[ tooltipPropName ].uiValues[ 0 ] + '\\n';\n            }\n        }\n    } else if( indicatorProp.conditions && Object.keys( indicatorProp.conditions ).length === 0 ) {\n        //if this has empty condition object, is a default indicator\n        if( indicatorProp.names && _.isArray( indicatorProp.names ) && indicatorProp.names.length > 0 ) {\n            verdictObj.isDefaultIndicator = true;\n            return verdictObj;\n        }\n    }else if( indicatorProp.type ) {\n        var evaluatedVerdictObj = evaluatePropBasedCondition( indicatorProp.type.prop, obj, tooltip );\n\n        //There are missing properties from the tooltip\n        if( evaluatedVerdictObj.missingProps.length > 0 ) {\n            var foundProps = [];\n            //Iterate through the list backward, remove all properties found on this object\n            //(Note there may be some properties not found in the src or target obj)\n            //(If our goal is to end checking here, we can iterate forward and clear the list)\n            for( var propIndx = evaluatedVerdictObj.missingProps.length - 1; propIndx >= 0; propIndx-- ) {\n                if( obj.props[evaluatedVerdictObj.missingProps[propIndx]] ) {\n                    var propObj = { matchingVal: obj.props[evaluatedVerdictObj.missingProps[propIndx]].dbValues[ 0 ] + '\\n',\n                        tooltip: obj.props[evaluatedVerdictObj.missingProps[propIndx]].uiValues[ 0 ] + '\\n',\n                        propertyDisplayName: obj.props[evaluatedVerdictObj.missingProps[propIndx]].propertyDescriptor.displayName };\n                    foundProps.unshift( propObj );\n\n                    //Current object found this property, so we can remove it from the list.\n                    evaluatedVerdictObj.missingProps.splice( propIndx, 1 );\n                }\n            }\n            //Iterate through the list to add to the tooltip the found properties.\n            for( var idx = 0; idx < foundProps.length; idx++ ) {\n                evaluatedVerdictObj.matchingVal += foundProps[idx].matchingVal;\n\n                if( tooltip.showPropDisplayName ) {\n                    evaluatedVerdictObj.tooltip += foundProps[idx].propertyDisplayName + ': ';\n                }\n\n                evaluatedVerdictObj.tooltip += foundProps[idx].tooltip;\n            }\n        }\n\n\n        return evaluatedVerdictObj;\n    }\n    return verdictObj;\n};\n\n\n/**\n * Returns the list of visual indicators.\n *\n * @param {vmo} vmo - viewModelObject.\n * @param {getModelObjCallBack} getModelObjCallBack - call back.\n * @return {Array} List of visual indicator objects\n */\nexport let getVisualIndicators = function( vmo, getModelObjCallBack ) {\n    var indicatorsArray = [];\n    if( vmo && vmo.props ) {\n        let preVerdictArray = [];\n        //Go through all the props from VMO, get indicators for each matched prop\n        for( const [ propKey, propValue ] of Object.entries( vmo.props ) ) {\n            let preVerdict = {};\n            if( !_.isEmpty( propValue.dbValue ) || !_.isEmpty( propValue.dbValues ) ) {\n                preVerdict.name = propKey;\n                preVerdict.vmoProp = propValue;\n                let matchedIndicators = Object.values( _indicators ).filter( indicatorJson => indicatorJson && _isValidPropName( indicatorJson.prop, propKey ) );\n                //each prop may have multiple indicator\n                if( !_.isEmpty( matchedIndicators ) ) {\n                    preVerdict.indicators = matchedIndicators;\n                    preVerdictArray.push( preVerdict );\n                }\n            }\n        }\n        indicatorsArray = _getIndicatorsFromPreVerdict( preVerdictArray, getModelObjCallBack );\n        //get the indicators which not defined in indicator.prop, eg. CheckOut\n        Object.values( _indicators ).forEach( indicatorJson => {\n            if( indicatorJson && !indicatorJson.prop ) {\n                var modelTypes = indicatorJson.modelTypes;\n                var conditions = indicatorJson.conditions;\n                if( _isValidModelType( vmo.modelType, modelTypes ) ) {\n                    let isValid = true;\n                    if( conditions ) {\n                        isValid = expressionParserUtils.evaluateConditions( conditions, vmo );\n                    }\n                    if( isValid ) {\n                        const indicator = exports.generateIndicator( vmo, indicatorJson );\n                        if( indicator && !_.isEqual( indicator.tooltip, '' ) ) {\n                            indicatorsArray.push( indicator );\n                        }\n                    }\n                }\n            }\n        } );\n    }\n    return indicatorsArray;\n};\n\n/**\n * Gets the default indicator for a property\n *\n * @return {Object} Indicator object which is default for a given prop\n */\nexport let getDefaultIndicator = function( propName, obj ) {\n    var defaultIndicator = null;\n    _.forEach( _indicators, function( indicatorJson ) {\n        if( indicatorJson ) {\n            var prop = indicatorJson.prop;\n            if( prop && prop.names && _.isArray( prop.names ) && prop.names.length > 0 ) {\n                // If prop is defined correctly, see if it is valid to default for input propName\n                if( prop.names.indexOf( propName ) >= 0 && prop.conditions && _.isEmpty( prop.conditions ) ) {\n                    defaultIndicator = indicatorJson;\n                    return false;\n                }\n            }\n        }\n    } );\n    return defaultIndicator;\n};\n\n/**\n * Generates indicator object if tooltips are available for given view model object\n *\n * @return {Object} Indicator object which contains tooltip and icon\n */\nexport let generateIndicator = function( vmo, indicatorJson ) {\n    var indicator;\n\n    if( vmo && indicatorJson && indicatorJson.tooltip ) {\n        var indicatorProps = indicatorJson.tooltip.propNames;\n\n        if( _.isArray( indicatorProps ) ) {\n            var finalTooltip = '';\n\n            for( var indx = 0; indx < indicatorProps.length; indx++ ) {\n                var tooltip = '';\n                var propValues = [];\n\n                var indicatorProp = indicatorProps[ indx ];\n\n                if( indicatorProp && vmo.props.hasOwnProperty( indicatorProp ) ) {\n                    var vmProp = vmo.props[ indicatorProp ];\n\n                    if( vmProp ) {\n                        propValues = vmProp.displayValues;\n                    }\n\n                    if( propValues && propValues.length > 0 ) {\n                        for( var i = 0; i < propValues.length; i++ ) {\n                            var propValue = propValues[ i ];\n\n                            if( propValue && propValue !== ' ' ) {\n                                if( tooltip === '' && indicatorJson.tooltip.showPropDisplayName ) {\n                                    tooltip = vmProp.propertyDisplayName + ': ';\n                                }\n\n                                if( i !== propValues.length - 1 ) {\n                                    tooltip += propValue + '\\n';\n                                } else {\n                                    tooltip += propValue;\n                                }\n                            }\n                        }\n\n                        if( finalTooltip === '' ) {\n                            finalTooltip = tooltip;\n                        } else {\n                            finalTooltip = finalTooltip + '\\n' + tooltip;\n                        }\n                    }\n                }\n            }\n\n            const icon = getImageAliasFromId( `indicator${indicatorJson.iconName}` ) ? `indicator${indicatorJson.iconName}` : 'indicatorMissingImage';\n\n            indicator = {\n                tooltip: finalTooltip,\n                // Sanitize the command icon\n                image: icon\n            };\n        }\n    }\n\n    return indicator;\n};\n\n\n/**\n * API to get indicator based on parameters\n *\n * @param {Object} indicator\n */\nexport let getIndicatorFromParams = function( indicatorJson, tooltip ) {\n    var indicatorFile = null;\n    if( indicatorJson !== null ) {\n        indicatorFile = indicatorJson.iconName;\n    }\n\n    const icon = getImageAliasFromId( `indicator${indicatorFile}` ) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n\n    return {\n        tooltip: tooltip,\n        // Sanitize the command icon\n        image: icon\n    };\n};\n/**\n * API to get indicator based on parameters\n *\n * @param {indicatorJson} indicatorJson - json\n * @returns {Array} returns a list of visual indicators\n */\nexport let getIndicatorFromJSON = function( indicatorJson ) {\n    var indicatorsArray = [];\n    var indicatorFile = null;\n    var tooltip = null;\n    _.forEach( indicatorJson, function( indicator ) {\n        if( indicator ) {\n            indicatorFile = indicator.image;\n            tooltip = indicator.tooltip;\n        }\n        const icon = getImageAliasFromId( `indicator${indicatorFile}` ) ? `indicator${indicatorFile}` : 'indicatorMissingImage';\n\n        var indicatorObj = {\n            image: icon,\n            tooltip: tooltip\n        };\n        indicatorsArray.push( indicatorObj );\n    } );\n    return indicatorsArray;\n};\n\n/**\n * API to override generated indicators for testing only.\n *\n * @param {Object} indicatorsOverride\n */\nexport let setIndicators = function( indicatorsOverride ) {\n    _indicators = indicatorsOverride;\n};\n\nexports = {\n    getVisualIndicators,\n    getDefaultIndicator,\n    generateIndicator,\n    evaluatePropBasedCondition,\n    getIndicatorFromParams,\n    getIndicatorFromJSON,\n    setIndicators\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}