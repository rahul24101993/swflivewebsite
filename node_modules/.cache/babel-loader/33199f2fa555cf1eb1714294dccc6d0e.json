{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editUtilsService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport declUtils from 'js/moduleLoader';\nimport uwPropertyService from 'js/uwPropertyService';\nimport viewModelObjectService from 'js/viewModelObjectService';\nvar exports = {};\nlet saveListeners = {};\nexport const _removeListeners = function (sourceModel) {\n  removeSaveListener(sourceModel);\n};\n\nconst addListeners = function (dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback) {\n  _removeListeners(editConfig.sourceModel);\n\n  const saveEditsListener = function (event) {\n    if (event.ctrlKey && (event.key === 's' || event.key === 'S')) {\n      exports._saveEdits(dataCtxNode, declViewModel, viewModelCollection, editConfig);\n\n      saveEditStateChangeCallback();\n      event.preventDefault();\n      removeSaveListener(editConfig.sourceModel);\n    }\n  };\n\n  document.addEventListener('keydown', saveEditsListener);\n  saveListeners[editConfig.sourceModel] = saveEditsListener;\n};\n\nconst removeSaveListener = function (sourceModel) {\n  document.removeEventListener('keydown', saveListeners[sourceModel]);\n};\n/**\n * isDirty implementation of edit-handler interface.\n * @param {*} viewModelCollection collection of view model objects\n * @returns {*} AwPromiseService.instance promise with true/false\n */\n\n\nexport let _isDirty = function (viewModelCollection) {\n  var hasModifiedProperties = false;\n\n  _.forEach(viewModelCollection, function (vmo) {\n    _.forEach(vmo.props, function (vmoProp) {\n      hasModifiedProperties = uwPropertyService.isModified(vmoProp);\n      return !hasModifiedProperties;\n    });\n\n    return !hasModifiedProperties;\n  });\n\n  return AwPromiseService.instance.when(hasModifiedProperties);\n};\n/**\n * saveEdits implementation of edit - handler interface.\n * @param {*} dataCtxNode $scope or the data context node.\n * @param {*} declViewModel Declarative View Model, where edit actions are defined.\n * @param {*} viewModelCollection collection of view-model objects.\n * @param {*} editConfig standard edit configuration defined on dataprovider/declviewmodel\n * @returns {*} AwPromiseService.instance promise\n */\n\nexport let _saveEdits = function (dataCtxNode, declViewModel, viewModelCollection, editConfig) {\n  viewModelCollection = viewModelObjectService.getLoadedAndCachedViewModelObjects(viewModelCollection);\n\n  var getAllModifiedProperties = function () {\n    var modifiedProperties = [];\n\n    _.forEach(viewModelCollection, function (vmo) {\n      _.forOwn(vmo.props, function (vmoProp) {\n        if (uwPropertyService.isModified(vmoProp)) {\n          modifiedProperties.push(vmoProp);\n        }\n      });\n    });\n\n    return modifiedProperties;\n  };\n\n  var getModifiedPropertiesMap = function () {\n    var identifier = editConfig.identifier;\n    var inputs = [];\n    var inputRegistry = {};\n\n    _.forEach(viewModelCollection, function (vmo) {\n      var uid = vmo[identifier];\n\n      _.forOwn(vmo.props, function (prop) {\n        if (uwPropertyService.isModified(prop)) {\n          var propObj = {\n            propertyName: prop.propertyName,\n            dbValues: uwPropertyService.getValueStrings(prop),\n            uiValues: prop.uiValues,\n            srcObjLsd: prop.srcObjLsd\n          };\n          inputRegistry[uid] = inputRegistry[uid] || {\n            identifier: uid,\n            props: []\n          };\n          var inputObj = inputRegistry[uid];\n          inputObj.props.push(propObj);\n        }\n      });\n\n      if (inputRegistry[uid]) {\n        inputs.push(inputRegistry[uid]);\n      }\n    });\n\n    return inputs;\n  };\n\n  return exports._isDirty(viewModelCollection).then(function (hasModifiedProps) {\n    var saveSuccess = function (viewModelCollection) {\n      var modifiedPropsArr = getAllModifiedProperties();\n\n      _.forEach(viewModelCollection, function (vmo) {\n        viewModelObjectService.setEditableStates(vmo, false, true, true);\n      });\n\n      _.forEach(modifiedPropsArr, function (modProp) {\n        uwPropertyService.replaceValuesWithNewValues(modProp);\n        uwPropertyService.resetProperty(modProp);\n      });\n\n      _removeListeners(editConfig.sourceModel);\n\n      return AwPromiseService.instance.resolve();\n    };\n\n    if (hasModifiedProps) {\n      var inputs = getModifiedPropertiesMap();\n      var saveEditAction = editConfig.saveEditAction;\n      var action = declViewModel._internal.actions[saveEditAction];\n\n      if (action) {\n        if (action.actionType === 'RESTService') {\n          var requestData = action.inputData.request;\n          requestData.data = requestData.data || {};\n          requestData.data.saveInputs = inputs;\n        } else {\n          action.inputData = action.inputData || {};\n          action.inputData.saveInputs = inputs;\n        }\n\n        return exports.executeAction(declViewModel, action, dataCtxNode).then(function () {\n          return saveSuccess(viewModelCollection);\n        }, function (error) {\n          return AwPromiseService.instance.reject(error);\n        });\n      }\n    }\n\n    return saveSuccess(viewModelCollection);\n  });\n};\n/**\n * This is the cancel edits implementation of edit-handler interface.\n * @param {*} dataCtxNode data ctx node ($scope)\n * @param {*} declViewModel declarative view model\n * @param {*} viewModelCollection collection of view model objects\n * @param {*} editConfig edit configuration\n * @returns {* } AwPromiseService.instance when operation is completed.\n */\n\nexport let _cancelEdits = function (dataCtxNode, declViewModel, viewModelCollection, editConfig) {\n  viewModelCollection = viewModelObjectService.getLoadedAndCachedViewModelObjects(viewModelCollection);\n\n  _.forEach(viewModelCollection, function (vmo) {\n    viewModelObjectService.clearEditableStates(vmo);\n  });\n\n  _removeListeners(editConfig.sourceModel);\n\n  return AwPromiseService.instance.resolve();\n};\n/**\n * This function merges the start edit action response back into the view model collect.\n * The response from start edit action should be an array of view model objects.\n *\n * @param {* } serverData response from the response\n * @param {* } vmCollection collection of view model objects\n * @param {* } editConfig edit configuration\n * @param {* } [propsToUpdate] - (Optional) If provided, only update these properties from server response\n * @returns {* } Promise when operation is completed.\n */\n\nexport let _mergeStartEditResponse = function (serverData, vmCollection, editConfig, propsToUpdate) {\n  try {\n    var identifier = editConfig.identifier;\n    var identiferToVMOMap = vmCollection.reduce(function (acc, eachObject) {\n      var uid = eachObject[identifier];\n      acc[uid] = eachObject;\n      return acc;\n    }, {});\n\n    if (!editConfig.hasOwnProperty('mergeResponseFunction')) {\n      _.forEach(serverData, function (updatedVMO) {\n        var uid = updatedVMO[identifier];\n        var targetVMO = identiferToVMOMap[uid] || null;\n\n        if (targetVMO) {\n          _.forOwn(updatedVMO.props, function (updatedProperty) {\n            // If this is not one of the props we want to update, continue\n            if (propsToUpdate && propsToUpdate.length > 0 && propsToUpdate.indexOf(updatedProperty.propertyName) === -1) {\n              return true;\n            }\n\n            var targetProperty = targetVMO.props[updatedProperty.propertyName] || null;\n\n            if (targetProperty) {\n              updatedProperty.value = updatedProperty.hasOwnProperty('value') ? updatedProperty.value : targetProperty.value;\n              updatedProperty.displayValues = updatedProperty.hasOwnProperty('displayValues') ? updatedProperty.displayValues : targetProperty.displayValues;\n              updatedProperty.isNull = updatedProperty.hasOwnProperty('isNull') ? updatedProperty.isNull : targetProperty.displayValues;\n              updatedProperty.editable = updatedProperty.hasOwnProperty('editable') ? updatedProperty.editable : targetProperty.editable;\n              updatedProperty.isPropertyModifiable = updatedProperty.hasOwnProperty('isPropertyModifiable') ? updatedProperty.isPropertyModifiable : targetProperty.isPropertyModifiable;\n              updatedProperty.sourceObjectLastSavedDate = updatedProperty.hasOwnProperty('sourceObjectLastSavedDate') ? updatedProperty.sourceObjectLastSavedDate : targetProperty.sourceObjectLastSavedDate;\n              uwPropertyService.copyModelData(targetProperty, updatedProperty);\n            }\n\n            return undefined;\n          });\n        }\n      });\n\n      return AwPromiseService.instance.resolve();\n    }\n\n    var deps = 'js/editMergeService';\n    return exports.loadDependentModule(deps).then(function (depModuleObj) {\n      var args = [serverData, vmCollection, editConfig];\n      return depModuleObj[editConfig.mergeResponseFunction].apply(null, args);\n    });\n  } catch (err) {\n    return AwPromiseService.instance.reject(err);\n  }\n};\n/**\n * This function loads the dependent module.\n * @param {*} deps name of the dependency files.\n * @returns {*} AwPromiseService.instance when module is loaded.\n */\n\nexport let loadDependentModule = function (deps) {\n  var depModuleObj = declUtils.getDependentModule(deps);\n\n  if (depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }\n\n  return declUtils.loadDependentModule(deps).then(function (depModuleObj) {\n    return AwPromiseService.instance.resolve(depModuleObj);\n  }, function (error) {\n    return AwPromiseService.instance.reject(error);\n  });\n};\n/**\n * This function executes any action defined in the view model.\n * @param {*} declViewModel Declarative View Model, where edit action is defined\n * @param {*} action start/save/cancel Edit action\n * @param {*} dataCtxNode $scope/data ctx object\n * @returns {*} AwPromiseService.instance promise\n */\n\nexport let executeAction = function (declViewModel, action, dataCtxNode) {\n  if (action.deps) {\n    return exports.loadDependentModule(action.deps).then(function (depModuleObj) {\n      return actionService.executeAction(declViewModel, action, dataCtxNode, depModuleObj);\n    });\n  }\n\n  return actionService.executeAction(declViewModel, action, dataCtxNode, null);\n};\n/**\n * This function implements the start edit function edit handler interface\n * @param {* } dataCtxNode data ctx Node.\n * @param {* } declViewModel declarative ViewModel.\n * @param {* } vmCollection collection of all view model objects.\n * @param {* } editConfig edit configuration\n * @param {* } saveEditStateChangeCallback callback function on save\n * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n * @returns {* } AwPromiseService.instance when module is loaded.\n */\n\nexport let _startEdit = function (dataCtxNode, declViewModel, vmCollection, editConfig, saveEditStateChangeCallback, editOptions) {\n  try {\n    var identifier = editConfig.identifier;\n\n    var setEditableStates = function () {\n      if (editOptions) {\n        for (let j = 0; j < editOptions.vmos.length; j++) {\n          for (let i = 0; i < editOptions.propertyNames.length; i++) {\n            const prop = editOptions.vmos[j].props[editOptions.propertyNames[i]];\n            uwPropertyService.setEditable(prop, true);\n            uwPropertyService.setEditState(prop, true, true, true);\n          }\n        }\n      } else if (vmCollection) {\n        _.forEach(vmCollection, function (vmo) {\n          viewModelObjectService.setEditableStates(vmo, true, true, true);\n        });\n      }\n    }; // Get viewModelObjects that are not in edit mode\n\n\n    let vmosNotInEdit = [];\n\n    if (editOptions) {\n      vmosNotInEdit = [editOptions.vmos];\n    } else {\n      vmosNotInEdit = viewModelObjectService.getVmosNotInEdit(vmCollection);\n    }\n\n    var inputs = vmosNotInEdit.map(function (eachObject) {\n      var objInput = {};\n      objInput[identifier] = eachObject[identifier];\n      objInput.propertyNames = [];\n\n      if (editOptions) {\n        objInput.propertyNames = editOptions.propertyNames;\n      } else {\n        _.forOwn(eachObject.props, function (prop) {\n          objInput.propertyNames.push(prop.propertyName);\n        });\n      }\n\n      return objInput;\n    });\n    var startEditActionName = editConfig.startEditAction;\n    var startEditAction = declViewModel.getAction(startEditActionName);\n\n    if (startEditAction) {\n      if (startEditAction.actionType === 'RESTService') {\n        var requestData = startEditAction.inputData.request;\n        requestData.data = requestData.data || {};\n        requestData.data.editInputs = inputs;\n      } else {\n        startEditAction.inputData = startEditAction.inputData || {};\n        startEditAction.inputData.editInputs = inputs;\n      }\n\n      return exports.executeAction(declViewModel, startEditAction, dataCtxNode).then(function (responseObj) {\n        responseObj = startEditAction.actionType === 'RESTService' ? responseObj.data : responseObj;\n\n        if (editConfig.hasOwnProperty('startEditResponseKey')) {\n          responseObj = responseObj[editConfig.startEditResponseKey];\n        }\n\n        let propsToUpdate = editOptions ? editOptions.propertyNames : [];\n        return exports._mergeStartEditResponse(responseObj, vmCollection, editConfig, propsToUpdate).then(function () {\n          setEditableStates();\n          addListeners(dataCtxNode, declViewModel, vmCollection, editConfig, saveEditStateChangeCallback);\n          return AwPromiseService.instance.resolve();\n        }, function (error) {\n          return AwPromiseService.instance.reject(error);\n        });\n      });\n    }\n\n    return AwPromiseService.instance.reject('start edit action not defined');\n  } catch (error) {\n    return AwPromiseService.instance.reject(error);\n  }\n};\nexports = {\n  _isDirty,\n  _saveEdits,\n  _cancelEdits,\n  _mergeStartEditResponse,\n  loadDependentModule,\n  executeAction,\n  _startEdit,\n  _removeListeners\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/editUtilsService.js"],"names":["exports","saveListeners","_removeListeners","removeSaveListener","addListeners","editConfig","saveEditsListener","event","saveEditStateChangeCallback","document","_isDirty","hasModifiedProperties","_","vmo","uwPropertyService","AwPromiseService","_saveEdits","viewModelCollection","viewModelObjectService","getAllModifiedProperties","modifiedProperties","getModifiedPropertiesMap","identifier","inputs","inputRegistry","uid","propObj","propertyName","prop","dbValues","uiValues","srcObjLsd","props","inputObj","saveSuccess","modifiedPropsArr","saveEditAction","action","declViewModel","requestData","_cancelEdits","_mergeStartEditResponse","identiferToVMOMap","eachObject","acc","updatedVMO","targetVMO","propsToUpdate","updatedProperty","targetProperty","deps","args","depModuleObj","loadDependentModule","declUtils","executeAction","actionService","_startEdit","setEditableStates","j","editOptions","i","vmosNotInEdit","objInput","startEditActionName","startEditAction","responseObj"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Edit Handler factory\n *\n * @module js/editUtilsService\n */\n\nimport AwPromiseService from 'js/awPromiseService';\nimport _ from 'lodash';\nimport actionService from 'js/actionService';\nimport declUtils from 'js/moduleLoader';\nimport uwPropertyService from 'js/uwPropertyService';\nimport viewModelObjectService from 'js/viewModelObjectService';\n\nvar exports = {};\n\nlet saveListeners = {};\n\nexport const _removeListeners = function( sourceModel ) {\n    removeSaveListener( sourceModel );\n};\n\nconst addListeners = function( dataCtxNode, declViewModel, viewModelCollection, editConfig, saveEditStateChangeCallback ) {\n    _removeListeners( editConfig.sourceModel );\n    const saveEditsListener = function( event ) {\n        if( event.ctrlKey && ( event.key === 's' || event.key === 'S' ) ) {\n            exports._saveEdits( dataCtxNode, declViewModel, viewModelCollection, editConfig );\n            saveEditStateChangeCallback();\n            event.preventDefault();\n            removeSaveListener( editConfig.sourceModel );\n        }\n    };\n    document.addEventListener( 'keydown', saveEditsListener );\n    saveListeners[ editConfig.sourceModel ] = saveEditsListener;\n};\n\nconst removeSaveListener = function( sourceModel ) {\n    document.removeEventListener( 'keydown', saveListeners[ sourceModel ] );\n};\n\n/**\n * isDirty implementation of edit-handler interface.\n * @param {*} viewModelCollection collection of view model objects\n * @returns {*} AwPromiseService.instance promise with true/false\n */\nexport let _isDirty = function( viewModelCollection ) {\n    var hasModifiedProperties = false;\n    _.forEach( viewModelCollection, function( vmo ) {\n        _.forEach( vmo.props, function( vmoProp ) {\n            hasModifiedProperties = uwPropertyService.isModified( vmoProp );\n            return !hasModifiedProperties;\n        } );\n        return !hasModifiedProperties;\n    } );\n    return AwPromiseService.instance.when( hasModifiedProperties );\n};\n/**\n * saveEdits implementation of edit - handler interface.\n * @param {*} dataCtxNode $scope or the data context node.\n * @param {*} declViewModel Declarative View Model, where edit actions are defined.\n * @param {*} viewModelCollection collection of view-model objects.\n * @param {*} editConfig standard edit configuration defined on dataprovider/declviewmodel\n * @returns {*} AwPromiseService.instance promise\n */\nexport let _saveEdits = function( dataCtxNode, declViewModel, viewModelCollection, editConfig ) {\n    viewModelCollection = viewModelObjectService.getLoadedAndCachedViewModelObjects( viewModelCollection );\n    var getAllModifiedProperties = function() {\n        var modifiedProperties = [];\n        _.forEach( viewModelCollection, function( vmo ) {\n            _.forOwn( vmo.props, function( vmoProp ) {\n                if( uwPropertyService.isModified( vmoProp ) ) {\n                    modifiedProperties.push( vmoProp );\n                }\n            } );\n        } );\n        return modifiedProperties;\n    };\n\n    var getModifiedPropertiesMap = function() {\n        var identifier = editConfig.identifier;\n        var inputs = [];\n        var inputRegistry = {};\n        _.forEach( viewModelCollection, function( vmo ) {\n            var uid = vmo[ identifier ];\n            _.forOwn( vmo.props, function( prop ) {\n                if( uwPropertyService.isModified( prop ) ) {\n                    var propObj = {\n                        propertyName: prop.propertyName,\n                        dbValues: uwPropertyService.getValueStrings( prop ),\n                        uiValues: prop.uiValues,\n                        srcObjLsd: prop.srcObjLsd\n                    };\n                    inputRegistry[ uid ] = inputRegistry[ uid ] || { identifier: uid, props: [] };\n                    var inputObj = inputRegistry[ uid ];\n                    inputObj.props.push( propObj );\n                }\n            } );\n            if( inputRegistry[ uid ] ) {\n                inputs.push( inputRegistry[ uid ] );\n            }\n        } );\n        return inputs;\n    };\n    return exports._isDirty( viewModelCollection ).then( function( hasModifiedProps ) {\n        var saveSuccess = function( viewModelCollection ) {\n            var modifiedPropsArr = getAllModifiedProperties();\n            _.forEach( viewModelCollection, function( vmo ) {\n                viewModelObjectService.setEditableStates( vmo, false, true, true );\n            } );\n\n            _.forEach( modifiedPropsArr, function( modProp ) {\n                uwPropertyService.replaceValuesWithNewValues( modProp );\n                uwPropertyService.resetProperty( modProp );\n            } );\n            _removeListeners( editConfig.sourceModel );\n            return AwPromiseService.instance.resolve();\n        };\n\n        if( hasModifiedProps ) {\n            var inputs = getModifiedPropertiesMap();\n            var saveEditAction = editConfig.saveEditAction;\n            var action = declViewModel._internal.actions[ saveEditAction ];\n            if( action ) {\n                if( action.actionType === 'RESTService' ) {\n                    var requestData = action.inputData.request;\n                    requestData.data = requestData.data || {};\n                    requestData.data.saveInputs = inputs;\n                } else {\n                    action.inputData = action.inputData || {};\n                    action.inputData.saveInputs = inputs;\n                }\n                return exports.executeAction( declViewModel, action, dataCtxNode )\n                    .then( function() {\n                        return saveSuccess( viewModelCollection );\n                    }, function( error ) {\n                        return AwPromiseService.instance.reject( error );\n                    } );\n            }\n        }\n        return saveSuccess( viewModelCollection );\n    } );\n};\n\n/**\n * This is the cancel edits implementation of edit-handler interface.\n * @param {*} dataCtxNode data ctx node ($scope)\n * @param {*} declViewModel declarative view model\n * @param {*} viewModelCollection collection of view model objects\n * @param {*} editConfig edit configuration\n * @returns {* } AwPromiseService.instance when operation is completed.\n */\nexport let _cancelEdits = function( dataCtxNode, declViewModel, viewModelCollection, editConfig ) {\n    viewModelCollection = viewModelObjectService.getLoadedAndCachedViewModelObjects( viewModelCollection );\n    _.forEach( viewModelCollection, function( vmo ) {\n        viewModelObjectService.clearEditableStates( vmo );\n    } );\n    _removeListeners( editConfig.sourceModel );\n    return AwPromiseService.instance.resolve();\n};\n\n/**\n * This function merges the start edit action response back into the view model collect.\n * The response from start edit action should be an array of view model objects.\n *\n * @param {* } serverData response from the response\n * @param {* } vmCollection collection of view model objects\n * @param {* } editConfig edit configuration\n * @param {* } [propsToUpdate] - (Optional) If provided, only update these properties from server response\n * @returns {* } Promise when operation is completed.\n */\nexport let _mergeStartEditResponse = function( serverData, vmCollection, editConfig, propsToUpdate ) {\n    try {\n        var identifier = editConfig.identifier;\n        var identiferToVMOMap = vmCollection.reduce( function( acc, eachObject ) {\n            var uid = eachObject[ identifier ];\n            acc[ uid ] = eachObject;\n            return acc;\n        }, {} );\n\n        if( !editConfig.hasOwnProperty( 'mergeResponseFunction' ) ) {\n            _.forEach( serverData, function( updatedVMO ) {\n                var uid = updatedVMO[ identifier ];\n                var targetVMO = identiferToVMOMap[ uid ] || null;\n                if( targetVMO ) {\n                    _.forOwn( updatedVMO.props, function( updatedProperty ) {\n                        // If this is not one of the props we want to update, continue\n                        if( propsToUpdate && propsToUpdate.length > 0 && propsToUpdate.indexOf( updatedProperty.propertyName ) === -1 ) {\n                            return true;\n                        }\n                        var targetProperty = targetVMO.props[ updatedProperty.propertyName ] || null;\n                        if( targetProperty ) {\n                            updatedProperty.value = updatedProperty.hasOwnProperty( 'value' ) ? updatedProperty.value : targetProperty.value;\n                            updatedProperty.displayValues = updatedProperty.hasOwnProperty( 'displayValues' ) ? updatedProperty.displayValues : targetProperty.displayValues;\n                            updatedProperty.isNull = updatedProperty.hasOwnProperty( 'isNull' ) ? updatedProperty.isNull : targetProperty.displayValues;\n                            updatedProperty.editable = updatedProperty.hasOwnProperty( 'editable' ) ? updatedProperty.editable : targetProperty.editable;\n                            updatedProperty.isPropertyModifiable = updatedProperty.hasOwnProperty( 'isPropertyModifiable' ) ? updatedProperty.isPropertyModifiable : targetProperty\n                                .isPropertyModifiable;\n                            updatedProperty.sourceObjectLastSavedDate = updatedProperty.hasOwnProperty( 'sourceObjectLastSavedDate' ) ? updatedProperty.sourceObjectLastSavedDate :\n                                targetProperty.sourceObjectLastSavedDate;\n                            uwPropertyService.copyModelData( targetProperty, updatedProperty );\n                        }\n                        return undefined;\n                    } );\n                }\n            } );\n            return AwPromiseService.instance.resolve();\n        }\n        var deps = 'js/editMergeService';\n        return exports.loadDependentModule( deps ).then( function( depModuleObj ) {\n            var args = [ serverData, vmCollection, editConfig ];\n            return depModuleObj[ editConfig.mergeResponseFunction ].apply( null, args );\n        } );\n    } catch ( err ) {\n        return AwPromiseService.instance.reject( err );\n    }\n};\n\n/**\n * This function loads the dependent module.\n * @param {*} deps name of the dependency files.\n * @returns {*} AwPromiseService.instance when module is loaded.\n */\nexport let loadDependentModule = function( deps ) {\n    var depModuleObj = declUtils.getDependentModule( deps );\n    if( depModuleObj ) {\n        return AwPromiseService.instance.resolve( depModuleObj );\n    }\n    return declUtils.loadDependentModule( deps ).then(\n        function( depModuleObj ) {\n            return AwPromiseService.instance.resolve( depModuleObj );\n        },\n        function( error ) {\n            return AwPromiseService.instance.reject( error );\n        }\n    );\n};\n\n/**\n * This function executes any action defined in the view model.\n * @param {*} declViewModel Declarative View Model, where edit action is defined\n * @param {*} action start/save/cancel Edit action\n * @param {*} dataCtxNode $scope/data ctx object\n * @returns {*} AwPromiseService.instance promise\n */\nexport let executeAction = function( declViewModel, action, dataCtxNode ) {\n    if( action.deps ) {\n        return exports.loadDependentModule( action.deps ).then( function( depModuleObj ) {\n            return actionService.executeAction( declViewModel, action, dataCtxNode, depModuleObj );\n        } );\n    }\n    return actionService.executeAction( declViewModel, action, dataCtxNode, null );\n};\n\n/**\n * This function implements the start edit function edit handler interface\n * @param {* } dataCtxNode data ctx Node.\n * @param {* } declViewModel declarative ViewModel.\n * @param {* } vmCollection collection of all view model objects.\n * @param {* } editConfig edit configuration\n * @param {* } saveEditStateChangeCallback callback function on save\n * @param {Object} editOptions - additional options object to specify specfic prop to edit and autosave mode { vmo, propertyNames, autoSave } (Optional)\n * @returns {* } AwPromiseService.instance when module is loaded.\n */\nexport let _startEdit = function( dataCtxNode, declViewModel, vmCollection, editConfig, saveEditStateChangeCallback, editOptions ) {\n    try {\n        var identifier = editConfig.identifier;\n        var setEditableStates = function() {\n            if( editOptions ) {\n                for( let j = 0; j < editOptions.vmos.length; j++ ) {\n                    for( let i = 0; i < editOptions.propertyNames.length; i++ ) {\n                        const prop = editOptions.vmos[ j ].props[ editOptions.propertyNames[ i ] ];\n                        uwPropertyService.setEditable( prop, true );\n                        uwPropertyService.setEditState( prop, true, true, true );\n                    }\n                }\n            } else if( vmCollection ) {\n                _.forEach( vmCollection, function( vmo ) {\n                    viewModelObjectService.setEditableStates( vmo, true, true, true );\n                } );\n            }\n        };\n\n        // Get viewModelObjects that are not in edit mode\n        let vmosNotInEdit = [];\n        if( editOptions ) {\n            vmosNotInEdit = [ editOptions.vmos ];\n        } else {\n            vmosNotInEdit = viewModelObjectService.getVmosNotInEdit( vmCollection );\n        }\n\n        var inputs = vmosNotInEdit.map( function( eachObject ) {\n            var objInput = {};\n            objInput[ identifier ] = eachObject[ identifier ];\n            objInput.propertyNames = [];\n            if( editOptions ) {\n                objInput.propertyNames = editOptions.propertyNames;\n            } else {\n                _.forOwn( eachObject.props, function( prop ) {\n                    objInput.propertyNames.push( prop.propertyName );\n                } );\n            }\n            return objInput;\n        } );\n\n        var startEditActionName = editConfig.startEditAction;\n        var startEditAction = declViewModel.getAction( startEditActionName );\n\n        if( startEditAction ) {\n            if( startEditAction.actionType === 'RESTService' ) {\n                var requestData = startEditAction.inputData.request;\n                requestData.data = requestData.data || {};\n                requestData.data.editInputs = inputs;\n            } else {\n                startEditAction.inputData = startEditAction.inputData || {};\n                startEditAction.inputData.editInputs = inputs;\n            }\n\n            return exports.executeAction( declViewModel, startEditAction, dataCtxNode ).then( function( responseObj ) {\n                responseObj = startEditAction.actionType === 'RESTService' ? responseObj.data : responseObj;\n                if( editConfig.hasOwnProperty( 'startEditResponseKey' ) ) {\n                    responseObj = responseObj[ editConfig.startEditResponseKey ];\n                }\n                let propsToUpdate = editOptions ? editOptions.propertyNames : [];\n                return exports._mergeStartEditResponse( responseObj, vmCollection, editConfig, propsToUpdate ).then( function() {\n                    setEditableStates();\n                    addListeners( dataCtxNode, declViewModel, vmCollection, editConfig, saveEditStateChangeCallback );\n                    return AwPromiseService.instance.resolve();\n                }, function( error ) {\n                    return AwPromiseService.instance.reject( error );\n                } );\n            } );\n        }\n        return AwPromiseService.instance.reject( 'start edit action not defined' );\n    } catch ( error ) {\n        return AwPromiseService.instance.reject( error );\n    }\n};\n\nexports = {\n    _isDirty,\n    _saveEdits,\n    _cancelEdits,\n    _mergeStartEditResponse,\n    loadDependentModule,\n    executeAction,\n    _startEdit,\n    _removeListeners\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}