{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used for plTable as Column Rearrangement\n *\n * @module js/splmTableColumnRearrangement\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n/**\n * Instances of this class represent a column rearrangement utility for PL Table\n *\n * @class SPLMTableColumnRearrangement\n * @param {DOMElement} tableElem - HTML DOM Element for table\n */\n\nvar SPLMTableColumnRearrangement = function (tableElem) {\n  var _columnRearrangementInProgress = false;\n  var _columnsRearranged = false;\n  var self = this;\n  /**\n   * Switch the column indexes of the column definitions attached to the headers.\n   *\n   * @param {DOMElement} header1 - first header\n   * @param {DOMElement} header2 - second header\n   *\n   * @returns {Boolean} was column index switch successful?\n   */\n\n  var switchColumnDefIndexes = function (header1, header2) {\n    var header1ColumnDefElement = header1.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n    var header2ColumnDefElement = header2.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n\n    if (header1ColumnDefElement && header1ColumnDefElement.columnDef && header2ColumnDefElement && header2ColumnDefElement.columnDef) {\n      var tempColumnIndex = header1ColumnDefElement.columnDef.index;\n      header1ColumnDefElement.columnDef.index = header2ColumnDefElement.columnDef.index;\n      header2ColumnDefElement.columnDef.index = tempColumnIndex;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Rearrange the column headers if the position parameter is outside the bounds of the original header element.\n   *\n   * @param {HTMLElement} element - the header element\n   * @param {Number} positionX - The X position to check for position of drag\n   *\n   * @returns {Boolean} if the columns were rearranged\n   */\n\n\n  var rearrangeColumnHeaders = function (element, positionX) {\n    var elementBoundingBox = element.getBoundingClientRect();\n    var nextSibling = element.nextSibling;\n    var previousSibling = element.previousSibling;\n\n    if (nextSibling && positionX > elementBoundingBox.right + nextSibling.getBoundingClientRect().width / 3 && nextSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE) && switchColumnDefIndexes(nextSibling, element)) {\n      element.parentNode.insertBefore(nextSibling, element);\n      return true;\n    } else if (previousSibling && positionX < elementBoundingBox.left - previousSibling.getBoundingClientRect().width / 2 && previousSibling.classList.contains(Const.CLASS_HEADER_DRAGGABLE) && switchColumnDefIndexes(previousSibling, element)) {\n      element.parentNode.insertBefore(element, previousSibling);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Rearrange the content cells based on the columnDef indexes now.\n   * @param {Number} originalPosition - The original index of the column\n   * @param {Object} columnDef - the column definition\n   */\n\n\n  var rearrangeContent = function (originalPosition, columnDef) {\n    if (originalPosition === columnDef.index) {\n      return;\n    }\n\n    var targetIndex = originalPosition < columnDef.index ? -1 : 1;\n    var targetContentElements = util.getColumnContentCellElementsByIndex(tableElem, columnDef.index + targetIndex);\n    var draggedContentElements = util.getColumnContentCellElementsByIndex(tableElem, columnDef.index);\n\n    for (var i = 0; i < draggedContentElements.length; i++) {\n      var currentContentElement = draggedContentElements[i];\n      var currentTargetContentElement = targetContentElements[i];\n\n      if (originalPosition < columnDef.index) {\n        currentTargetContentElement = currentTargetContentElement.nextSibling;\n      }\n\n      currentContentElement.parentNode.insertBefore(currentContentElement, currentTargetContentElement);\n    }\n  };\n  /**\n   * Attaches the drag header events to the header element paramter.\n   *\n   * @param {DOMElement} element - header element to attach drag events\n   */\n\n\n  var attachDragHeader = function (element) {\n    var nextX = 0;\n    var currentX = 0;\n    var clonedElement;\n    var columnDef;\n    var originalPosition;\n    element.classList.add(Const.CLASS_HEADER_DRAGGABLE);\n    var columnDefElement = element.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n\n    var startDragElement = function (customEvent) {\n      // Clean up menu if exist\n      var menuService = util.getTableMenuService(tableElem);\n      menuService.ensureAllTableMenusDismissed();\n      var event = customEvent ? customEvent.detail : window.event;\n      clonedElement = element.cloneNode(true);\n      clonedElement.classList.add(Const.CLASS_UTILITY_HIDDEN);\n      clonedElement.setAttribute('id', clonedElement.id + 'ClonedHeader'); // Attachment to container because of rendering problems when attached to the row\n\n      var elementContainer = util.closestElement(element, '.' + Const.CLASS_PIN_CONTAINER + ',.' + Const.CLASS_SCROLL_CONTAINER);\n      var scrollLeft = elementContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0].scrollLeft;\n      elementContainer.appendChild(clonedElement);\n      clonedElement.style.left = element.offsetLeft - scrollLeft + 'px';\n      clonedElement.style.top = element.offsetTop + 'px';\n      currentX = event.clientX;\n\n      if (columnDefElement && columnDefElement.columnDef) {\n        columnDef = columnDefElement.columnDef;\n        originalPosition = columnDef.index;\n      }\n    };\n    /**\n     *  Event to run when movement of header is in progress. Moves the element and any headers it moves over.\n     *\n     * @param {DOMEvent} customEvent - event being sent ( wrapped from 'mousemove' )\n     */\n\n\n    var dragElement = function (customEvent) {\n      var event = customEvent ? customEvent.detail : window.event;\n\n      if (!_columnRearrangementInProgress) {\n        element.classList.add('stationaryHeader');\n        clonedElement.classList.add('dragHeader');\n        clonedElement.classList.remove(Const.CLASS_UTILITY_HIDDEN);\n        _columnRearrangementInProgress = true;\n      }\n\n      nextX = currentX - event.clientX;\n      currentX = event.clientX;\n      clonedElement.style.left = clonedElement.offsetLeft - nextX + 'px';\n      _columnsRearranged = rearrangeColumnHeaders(element, event.clientX) || _columnsRearranged;\n    };\n    /**\n     * End the drag movement and replace the original header element visibility.\n     *\n     */\n\n\n    var closeDragElement = function () {\n      element.classList.remove('stationaryHeader');\n      clonedElement.parentNode.removeChild(clonedElement);\n      _columnRearrangementInProgress = false;\n\n      if (_columnsRearranged) {\n        _columnsRearranged = false;\n        var eventData = {\n          name: columnDef.name,\n          originalPosition: originalPosition\n        };\n\n        tableElem._tableInstance.tableInstanceCallbacks.columnsRearranged(eventData);\n\n        rearrangeContent(originalPosition, columnDef);\n      }\n    }; // Column Header = Label + Sort Icon + Splitter\n    // Sort Icon will occupy all spaces by flex-grow\n\n\n    var contentsElement = element.getElementsByClassName(Const.CLASS_CELL_CONTENTS)[0];\n    splmTableDragHandler.enableDragging(contentsElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_START, startDragElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG, dragElement);\n    contentsElement.addEventListener(Const.EVENT_ON_ELEM_DRAG_END, closeDragElement);\n  };\n  /**\n   * Initializes the table with header column rearrangement by dragging.\n   */\n\n\n  self.initialize = function () {\n    var headerCellElements = tableElem.getElementsByClassName(Const.CLASS_HEADER_CELL);\n\n    _.forEach(headerCellElements, function (headerCellElement) {\n      var columnDefinition;\n      var foundElements = headerCellElement.getElementsByClassName(Const.CLASS_COLUMN_DEF);\n\n      if (foundElements.length > 0) {\n        columnDefinition = foundElements[0].columnDef;\n      }\n\n      if (columnDefinition && columnDefinition.enableColumnMoving !== false) {\n        attachDragHeader(headerCellElement);\n      }\n    });\n  };\n\n  self.initialize();\n  return self;\n};\n\n_c2 = SPLMTableColumnRearrangement;\n_c = SPLMTableColumnRearrangement;\nexport default SPLMTableColumnRearrangement;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableColumnRearrangement\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableColumnRearrangement\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableColumnRearrangement.js"],"names":["SPLMTableColumnRearrangement","_columnRearrangementInProgress","_columnsRearranged","self","switchColumnDefIndexes","header1ColumnDefElement","header1","Const","header2ColumnDefElement","header2","tempColumnIndex","rearrangeColumnHeaders","elementBoundingBox","element","nextSibling","previousSibling","positionX","rearrangeContent","originalPosition","columnDef","targetIndex","targetContentElements","util","draggedContentElements","i","currentContentElement","currentTargetContentElement","attachDragHeader","nextX","currentX","columnDefElement","startDragElement","menuService","event","customEvent","window","clonedElement","elementContainer","scrollLeft","dragElement","closeDragElement","eventData","name","tableElem","contentsElement","splmTableDragHandler","headerCellElements","_","foundElements","headerCellElement","columnDefinition"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used for plTable as Column Rearrangement\n *\n * @module js/splmTableColumnRearrangement\n *\n */\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport splmTableDragHandler from 'js/splmTableDragHandler';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\n\n/**\n * Instances of this class represent a column rearrangement utility for PL Table\n *\n * @class SPLMTableColumnRearrangement\n * @param {DOMElement} tableElem - HTML DOM Element for table\n */\nvar SPLMTableColumnRearrangement = function( tableElem ) {\n    var _columnRearrangementInProgress = false;\n    var _columnsRearranged = false;\n\n    var self = this;\n\n    /**\n     * Switch the column indexes of the column definitions attached to the headers.\n     *\n     * @param {DOMElement} header1 - first header\n     * @param {DOMElement} header2 - second header\n     *\n     * @returns {Boolean} was column index switch successful?\n     */\n    var switchColumnDefIndexes = function( header1, header2 ) {\n        var header1ColumnDefElement = header1.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n        var header2ColumnDefElement = header2.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n\n        if( header1ColumnDefElement && header1ColumnDefElement.columnDef && header2ColumnDefElement && header2ColumnDefElement.columnDef ) {\n            var tempColumnIndex = header1ColumnDefElement.columnDef.index;\n            header1ColumnDefElement.columnDef.index = header2ColumnDefElement.columnDef.index;\n            header2ColumnDefElement.columnDef.index = tempColumnIndex;\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Rearrange the column headers if the position parameter is outside the bounds of the original header element.\n     *\n     * @param {HTMLElement} element - the header element\n     * @param {Number} positionX - The X position to check for position of drag\n     *\n     * @returns {Boolean} if the columns were rearranged\n     */\n    var rearrangeColumnHeaders = function( element, positionX ) {\n        var elementBoundingBox = element.getBoundingClientRect();\n        var nextSibling = element.nextSibling;\n        var previousSibling = element.previousSibling;\n\n        if( nextSibling && positionX > elementBoundingBox.right + nextSibling.getBoundingClientRect().width / 3 && nextSibling.classList.contains( Const.CLASS_HEADER_DRAGGABLE ) &&\n            switchColumnDefIndexes( nextSibling, element ) ) {\n            element.parentNode.insertBefore( nextSibling, element );\n            return true;\n        } else if( previousSibling && positionX < elementBoundingBox.left - previousSibling.getBoundingClientRect().width / 2 && previousSibling.classList.contains( Const\n            .CLASS_HEADER_DRAGGABLE ) && switchColumnDefIndexes( previousSibling, element ) ) {\n            element.parentNode.insertBefore( element, previousSibling );\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Rearrange the content cells based on the columnDef indexes now.\n     * @param {Number} originalPosition - The original index of the column\n     * @param {Object} columnDef - the column definition\n     */\n    var rearrangeContent = function( originalPosition, columnDef ) {\n        if( originalPosition === columnDef.index ) {\n            return;\n        }\n        var targetIndex = originalPosition < columnDef.index ? -1 : 1;\n        var targetContentElements = util.getColumnContentCellElementsByIndex( tableElem, columnDef.index + targetIndex );\n        var draggedContentElements = util.getColumnContentCellElementsByIndex( tableElem, columnDef.index );\n\n        for( var i = 0; i < draggedContentElements.length; i++ ) {\n            var currentContentElement = draggedContentElements[ i ];\n            var currentTargetContentElement = targetContentElements[ i ];\n            if( originalPosition < columnDef.index ) {\n                currentTargetContentElement = currentTargetContentElement.nextSibling;\n            }\n            currentContentElement.parentNode.insertBefore( currentContentElement, currentTargetContentElement );\n        }\n    };\n\n    /**\n     * Attaches the drag header events to the header element paramter.\n     *\n     * @param {DOMElement} element - header element to attach drag events\n     */\n    var attachDragHeader = function( element ) {\n        var nextX = 0;\n        var currentX = 0;\n        var clonedElement;\n        var columnDef;\n        var originalPosition;\n        element.classList.add( Const.CLASS_HEADER_DRAGGABLE );\n        var columnDefElement = element.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n\n        var startDragElement = function( customEvent ) {\n            // Clean up menu if exist\n            var menuService = util.getTableMenuService( tableElem );\n            menuService.ensureAllTableMenusDismissed();\n\n            var event = customEvent ? customEvent.detail : window.event;\n\n            clonedElement = element.cloneNode( true );\n            clonedElement.classList.add( Const.CLASS_UTILITY_HIDDEN );\n\n            clonedElement.setAttribute( 'id', clonedElement.id + 'ClonedHeader' );\n            // Attachment to container because of rendering problems when attached to the row\n            var elementContainer = util.closestElement( element, '.' + Const.CLASS_PIN_CONTAINER + ',.' + Const.CLASS_SCROLL_CONTAINER );\n            var scrollLeft = elementContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ].scrollLeft;\n            elementContainer.appendChild( clonedElement );\n\n            clonedElement.style.left = element.offsetLeft - scrollLeft + 'px';\n            clonedElement.style.top = element.offsetTop + 'px';\n\n            currentX = event.clientX;\n\n            if( columnDefElement && columnDefElement.columnDef ) {\n                columnDef = columnDefElement.columnDef;\n                originalPosition = columnDef.index;\n            }\n        };\n\n        /**\n         *  Event to run when movement of header is in progress. Moves the element and any headers it moves over.\n         *\n         * @param {DOMEvent} customEvent - event being sent ( wrapped from 'mousemove' )\n         */\n        var dragElement = function( customEvent ) {\n            var event = customEvent ? customEvent.detail : window.event;\n\n            if( !_columnRearrangementInProgress ) {\n                element.classList.add( 'stationaryHeader' );\n                clonedElement.classList.add( 'dragHeader' );\n                clonedElement.classList.remove( Const.CLASS_UTILITY_HIDDEN );\n                _columnRearrangementInProgress = true;\n            }\n\n            nextX = currentX - event.clientX;\n            currentX = event.clientX;\n\n            clonedElement.style.left = clonedElement.offsetLeft - nextX + 'px';\n\n            _columnsRearranged = rearrangeColumnHeaders( element, event.clientX ) || _columnsRearranged;\n        };\n\n        /**\n         * End the drag movement and replace the original header element visibility.\n         *\n         */\n        var closeDragElement = function() {\n            element.classList.remove( 'stationaryHeader' );\n            clonedElement.parentNode.removeChild( clonedElement );\n            _columnRearrangementInProgress = false;\n\n            if( _columnsRearranged ) {\n                _columnsRearranged = false;\n                var eventData = {\n                    name: columnDef.name,\n                    originalPosition: originalPosition\n                };\n                tableElem._tableInstance.tableInstanceCallbacks.columnsRearranged( eventData );\n                rearrangeContent( originalPosition, columnDef );\n            }\n        };\n\n        // Column Header = Label + Sort Icon + Splitter\n        // Sort Icon will occupy all spaces by flex-grow\n        var contentsElement = element.getElementsByClassName( Const.CLASS_CELL_CONTENTS )[ 0 ];\n        splmTableDragHandler.enableDragging( contentsElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG_START, startDragElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG, dragElement );\n        contentsElement.addEventListener( Const.EVENT_ON_ELEM_DRAG_END, closeDragElement );\n    };\n\n    /**\n     * Initializes the table with header column rearrangement by dragging.\n     */\n    self.initialize = function() {\n        var headerCellElements = tableElem.getElementsByClassName( Const.CLASS_HEADER_CELL );\n\n        _.forEach( headerCellElements, function( headerCellElement ) {\n            var columnDefinition;\n            var foundElements = headerCellElement.getElementsByClassName( Const.CLASS_COLUMN_DEF );\n            if( foundElements.length > 0 ) {\n                columnDefinition = foundElements[ 0 ].columnDef;\n            }\n\n            if( columnDefinition && columnDefinition.enableColumnMoving !== false ) {\n                attachDragHeader( headerCellElement );\n            }\n        } );\n    };\n\n    self.initialize();\n\n    return self;\n};\n\nexport default SPLMTableColumnRearrangement;\n"]},"metadata":{},"sourceType":"module"}