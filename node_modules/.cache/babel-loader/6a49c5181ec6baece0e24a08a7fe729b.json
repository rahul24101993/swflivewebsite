{"ast":null,"code":"/* eslint-disable require-jsdoc */ // Copyright (c) 2020 Siemens\n/* global AFX_UTEST */ /**\n * This service is used to manage the sync strategies.\n *\n * @module js/syncStrategyService\n *\n */import _ from'lodash';import AwPromiseService from'js/awPromiseService';import appCtxSvc from'js/appCtxService';import cfgSvc from'js/configurationService';import viewModelSvc from'js/viewModelService';import conditionSvc from'js/conditionService';import declUtils from'js/declUtils';import moduleLoader from'js/moduleLoader';import logger from'js/logger';import syncViewModelCacheService from'js/syncViewModelCacheService';import actionService from'js/actionService';let _syncStrategyMap;const _vmPathCache={};var _strategies=null;let _declViewModel=null;var exports={};/**\n * Create the declartive viewModel from all combined syncStrategy.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */function createViewModel(viewModel){viewModel._viewModelId='syncStrategyViewModel_'+Math.random();viewModel.skipClone=true;return viewModelSvc.populateViewModelPropertiesFromJson(viewModel,null,null,true);}export const setupSyncStrategy=dataCtxNode=>{const id=dataCtxNode.data._internal.modelId;const path='syncViewModelCache.'+dataCtxNode.data._internal.viewId;syncViewModelCacheService.set(path+'.'+id,dataCtxNode);};export const loadConfiguration=async function(){await cfgSvc.getCfg('syncStrategy').then(strategies=>{_strategies=strategies;if(!_strategies&&AFX_UTEST){_strategies={};}_syncStrategyMap=new Map();// handler relatioin w.r.t to source\nif(!_vmPathCache.handlersRelation){_vmPathCache.handlersRelation={};}// target relation with source\nif(!_vmPathCache.targetRelationToSource){_vmPathCache.targetRelationToSource={};}/*\n            <sourceView>: {\n                \"<port1>\": ['<handler1>', '<handler2>'],\n                \"<port2>\": ['<handler3>', '<handler4>'],\n            }\n        */for(var key in _strategies.syncStrategyHandlers){let handler=_strategies.syncStrategyHandlers[key];let syncStrategyId=handler.id;let synConfigObject=_strategies.syncStrategies[syncStrategyId];let sPort=synConfigObject.source.port;let sViewHierarchy=synConfigObject.source.view.split('/');let sView=sViewHierarchy[sViewHierarchy.length-1];if(!_syncStrategyMap.has(sView)){_syncStrategyMap.set(sView,{ports:{}});}if(!_syncStrategyMap.get(sView).ports[sPort]){_syncStrategyMap.get(sView).ports[sPort]=[];}_syncStrategyMap.get(sView).ports[sPort].push(key);}});};const getDeclViewModel=function(){return createViewModel(_strategies);};const _fireTargetAction=function(targetViewModel,value,strategyConfig){if(targetViewModel&&targetViewModel.data){const targetPort=Object.assign({},targetViewModel.data.getPortById(strategyConfig.target.port));// if port of target is present, then only fire action\nif(!_.isNil(targetPort)&&!_.isEmpty(targetPort)){// adding input object to targets port\ntargetPort.syncObject=value;// adding ports as a sibling to data in VM.\nconst portsData={...targetViewModel.ports,[strategyConfig.target.port]:targetPort};// zarq9k: Cannot do dispatch on unmount process.\n// Need to re-think on strategy. It is a point fix.\nif(targetViewModel.data&&targetViewModel.data.dispatch){targetViewModel.data.dispatch({path:'ports',value:portsData});targetViewModel.data.ports=portsData;targetViewModel.ports=targetViewModel.data.ports;return viewModelSvc.executeCommand(targetViewModel.data,targetPort.onChangeAction,targetViewModel);}return AwPromiseService.instance.resolve();}return AwPromiseService.instance.resolve({errorCode:'NO_TARGET_PORT_FOUND',errorMessage:\"No port is configured for view: \".concat(targetViewModel.data._internal.viewId)});}return AwPromiseService.instance.resolve();};const _executePreProcessingAction=function(actionName,syncContext,value){var deferred=AwPromiseService.instance.defer();var action=_strategies.actions[actionName];if(action.deps){/** action ID will be used for better logging */action.actionId=action.method;var doAction=function(depModuleObj){if(_declViewModel.isDestroyed()){logger.warn('Attempt to execute a command after its DeclViewModel was destroyed...'+'\\n'+'Action was therefore not executed...continuing.'+'\\n'+//\n'DeclViewModel: '+_declViewModel+'\\n'+//\n'Action       : '+action);return AwPromiseService.instance.reject();}/**\n             * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action\n             * event processing was started.\n             */_declViewModel.value=value;var dataCtxNode={data:_declViewModel,ctx:appCtxSvc.ctx,syncContext:syncContext};var localDataCtx=declUtils.resolveLocalDataCtx(_declViewModel,dataCtxNode);// _deps will be undefined when try to load viewModelService inside itself\nvar _depModuleObj=depModuleObj;return actionService.executeAction(_declViewModel,action,localDataCtx,_depModuleObj,true);};return moduleLoader.getDependentModule(action.deps).then(depModuleObj=>{return doAction(depModuleObj);});}return deferred.Promise;};const _runAction=function(handler,syncContext,value,targetViewModel,syncStrategyDef){return _executePreProcessingAction(handler.action,syncContext,value).then(function(response){// response data is avaiable on response.actionData\nreturn _fireTargetAction(targetViewModel,response.actionData,syncStrategyDef);});};const _executeHandlerAction=function(handler,syncContext,value,targetViewModel,syncStrategyDef){if(!_declViewModel){_declViewModel=getDeclViewModel();}return _runAction(handler,syncContext,value,targetViewModel,syncStrategyDef);};const _evaluateActiveWhen=function(strategyObject,syncContext){return conditionSvc.evaluateConditionExpression(strategyObject,{syncContext:syncContext,ctx:appCtxSvc.ctx},{clauseName:'activeWhen',conditionList:_strategies});};const _requestUpdate=function(viewId,modelId,portName,value){if(_syncStrategyMap.get(viewId)&&_syncStrategyMap.get(viewId).ports[portName]){var syncExecutePromises=[];if(_vmPathCache[viewId]){const srcObj=_vmPathCache[viewId][modelId];var allHandlers=_syncStrategyMap.get(viewId).ports[portName];_.forEach(srcObj.handlers,function(handler,name){if(allHandlers.indexOf(name)>-1&&handler.target){Object.values(handler.target).forEach(targetViewModel=>{const syncStrategyDef=_strategies.syncStrategies[handler.id];const syncContext={targetViewModel:targetViewModel,sourceViewModel:srcObj.vm};// evaluate activewhen\nif(_evaluateActiveWhen(handler,syncContext)){if(handler.action){var launch=_executeHandlerAction(handler,syncContext,value,targetViewModel,syncStrategyDef);syncExecutePromises.push(launch);}else{syncExecutePromises.push(_fireTargetAction(targetViewModel,value,syncStrategyDef));}}});}});}if(syncExecutePromises.length){return AwPromiseService.instance.all(syncExecutePromises);}}return AwPromiseService.instance.resolve({errorCode:'NO_ACTIVE_ACTION_FOUND',errorMessage:\"No sync action fired for view: \".concat(viewId,\" with port: \").concat(portName)});};/**\n * triggerSyncStrategy\n * @param {Object} declViewModel decl view model of source\n * @param {String} inputData resolved inputData from actionService\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */export const updatePort=function(declViewModel,inputData){const viewId=declViewModel._internal.viewId;const modelId=declViewModel._internal.modelId;const portName=inputData.port;const newValue=inputData.syncObject;const vmCacheMap=syncViewModelCacheService.get('syncViewModelCache');if(vmCacheMap[viewId]&&vmCacheMap[viewId][modelId]){const sourceVm=vmCacheMap[viewId][modelId];if(sourceVm&&sourceVm.data&&sourceVm.data.getPortById(portName)){let sourceVmData=sourceVm.data;let sPortObject=Object.assign({},sourceVmData.getPortById(portName));sPortObject.syncObject=newValue?newValue:sourceVm.ports[portName].syncObject;// adding ports as a sibling to data in VM.\nconst portsData={...sourceVm.ports,[portName]:sPortObject};sourceVmData.dispatch({path:'ports',value:portsData});return _requestUpdate(viewId,modelId,portName,newValue);}}return AwPromiseService.instance.resolve({errorCode:'NO_PORT_FOUND',errorMessage:\"No port is configured for view: \".concat(viewId)});};/**\n * revisitme: find out the solution for this API to support other use cases\n * @param {*} viewPath viewpath\n * @returns {Array} array of elements\n */export const getElementArray=function(viewPath){var elementString='';var body=document.body;var elementPathArray=viewPath.split('/');if(elementPathArray&&elementPathArray.length>1){// aw-include[name='commonRoot'] aw-include[name='commonLocation'] aw-include[name='showcaseMain']\"\nelementPathArray.forEach(function(viewName){elementString=elementString+'aw-include[name=\"'+viewName+'\"] ';});}else{// aw-include[view-id='commonRoot']\nvar uniqueViewElement=body.querySelectorAll('aw-include[view-id=\"'+elementPathArray[0]+'\"] ');if(uniqueViewElement&&uniqueViewElement.length===1){return uniqueViewElement;}// aw-include[name='commonRoot']\nelementString='aw-include[name=\"'+elementPathArray[0]+'\"] ';}// revisitme : currently supporting only viewName use case, figure out impact of following commented line\n// return body.querySelectorAll( elementString );\nreturn['dummyelement'];};const validateViewPath=function(context,viewPath,viewId){const viewPathArray=viewPath.split('/');let initialCheck=viewPathArray[viewPathArray.length-1]===viewId;if(initialCheck&&viewPathArray.length>1){let preIndex=-1;let currIndex=0;let comViewPathArray=context.props.viewPath.split('/');for(let i=0;i<viewPathArray.length;i++){currIndex=comViewPathArray.indexOf[viewPathArray[i]];if(currIndex===-1&&currIndex<preIndex){initialCheck=false;break;}else{preIndex=currIndex;}}}return initialCheck;};const getViewNameFromPath=function(viewPath){const viewPathArray=viewPath.split('/');return viewPathArray[viewPathArray.length-1];};const _addToCachePaths=function(declViewModel){const viewId=declViewModel.data._internal.viewId;const modelId=declViewModel.data._internal.modelId;const vmCacheMap=syncViewModelCacheService.get('syncViewModelCache');const _cachingAsSource=()=>{const allHandlersName=Object.values(_syncStrategyMap.get(viewId).ports).flatMap(h=>h);const handlers=allHandlersName.reduce((handlersObj,name)=>{const{id,action,activeWhen}=_strategies.syncStrategyHandlers[name];if(validateViewPath(declViewModel,_strategies.syncStrategies[id].source.view,viewId)){const targetObj=_strategies.syncStrategies[id].target;const targetVm=vmCacheMap[getViewNameFromPath(targetObj.view)];handlersObj[name]={id,action,activeWhen,target:targetVm?targetVm:{}};_vmPathCache.handlersRelation[name]={viewId:viewId,modelId:modelId};}return handlersObj;},{});// handling for multiple entry for same viewId\nif(!_vmPathCache[viewId]){_vmPathCache[viewId]={};}_vmPathCache[viewId][modelId]={get vm(){return syncViewModelCacheService.get('syncViewModelCache')[viewId][modelId];},handlers:handlers};};// vm act as source\nif(_syncStrategyMap.get(viewId)&&(!_vmPathCache[viewId]||!_vmPathCache[viewId][modelId])){_cachingAsSource();}// vm act as target\nconst asTarget=Object.entries(_strategies.syncStrategies).reduce((acc,obj)=>{if(validateViewPath(declViewModel,obj[1].target.view,viewId)){acc.push(obj[0]);}return acc;},[]);const _cachingAsTarget=()=>{const targetHandler=Object.entries(_strategies.syncStrategyHandlers).reduce((acc,obj)=>{if(asTarget.indexOf(obj[1].id)>-1){acc[obj[0]]=obj[1];}return acc;},{});_.forEach(targetHandler,(obj,key)=>{const matchingSrc=_vmPathCache.handlersRelation[key];if(matchingSrc&&_syncStrategyMap.get(matchingSrc.viewId)){const view=getViewNameFromPath(_strategies.syncStrategies[obj.id].target.view);const trgVm=vmCacheMap[view];const handlers=_vmPathCache[matchingSrc.viewId][matchingSrc.modelId].handlers;handlers[key].target=trgVm?trgVm:{};if(!_vmPathCache.targetRelationToSource[view]){_vmPathCache.targetRelationToSource[view]=[];}_vmPathCache.targetRelationToSource[view].push({source:{viewId:matchingSrc.viewId,modelId:matchingSrc.modelId},modelId:modelId,handlerId:obj.id,handlerName:key});}});};if(asTarget&&asTarget.length){_cachingAsTarget();}};const _removeFromCachePaths=function(declViewModel){const viewId=declViewModel.data._internal.viewId;// clear relations\n_.forEach(_vmPathCache.handlersRelation,(obj,key)=>{if(obj.viewId===viewId){delete _vmPathCache.handlersRelation[key];}});// clear target relation with source\nif(_vmPathCache.targetRelationToSource[viewId]){delete _vmPathCache.targetRelationToSource[viewId];}// clear vm from vmPathCache\nif(_vmPathCache[viewId]){delete _vmPathCache[viewId];}};const _updateOnMount=function(declVm){const syncExecutePromises=[];const viewId=declVm.data._internal.viewId;const allRelations=_vmPathCache.targetRelationToSource[viewId];allRelations&&allRelations.forEach(relObj=>{const strategyDef=_strategies.syncStrategies[relObj.handlerId];if(_vmPathCache[relObj.source.viewId]){const sourceObj=_vmPathCache[relObj.source.viewId][relObj.source.modelId];// check whether the src is loaded or not\nif(sourceObj){const handler=_strategies.syncStrategyHandlers[relObj.handlerName];const sourceVm=sourceObj.vm;let srcPortData=sourceVm.ports?sourceVm.ports[strategyDef.source.port]:null;const syncContext={targetViewModel:declVm,sourceViewModel:sourceVm};// evaluate activewhen\nconst isActive=_evaluateActiveWhen(handler,syncContext);if(isActive&&handler.action){const launch=_executeHandlerAction(handler,syncContext,srcPortData,declVm,strategyDef);syncExecutePromises.push(launch);}else if(isActive){srcPortData=srcPortData?srcPortData.syncObject:null;syncExecutePromises.push(_fireTargetAction(declVm,srcPortData,strategyDef));}}}});if(syncExecutePromises.length){return AwPromiseService.instance.all(syncExecutePromises);}return AwPromiseService.instance.resolve({code:'NO_OUTSTANDING_REQUEST_PRESENT',message:'view model mount completed'});};const _updateOnUnmount=function(declVm){const syncExecutePromises=[];const viewId=declVm.data._internal.viewId;const modelId=declVm.data._internal.modelId;if(_vmPathCache[viewId]){const allHandlers=Object.values(_vmPathCache[viewId][modelId])[1];_.forEach(allHandlers,handler=>{const syncStrategyDef=_strategies.syncStrategies[handler.id];syncExecutePromises.push(_fireTargetAction(Object.values(handler.target)[0],'',syncStrategyDef));});}if(syncExecutePromises.length){return AwPromiseService.instance.all(syncExecutePromises);}return AwPromiseService.instance.resolve({code:'NO_OUTSTANDING_REQUEST_PRESENT',message:'view model unmount completed'});};/**\n * triggerSyncStrategy\n * @param {Object} declVm decl viewModel of view\n * @param {String} isMount if vm loaded, then true. if vm unloaded, then false\n *\n * @return {Promise} A promise object resolved with the results of the sync action call (or rejected if there is a problem).\n */export const updateVmOnMountUnmount=function(declVm,isMount){if(isMount){// need to add entry to cache as src and trg\n_addToCachePaths(declVm);// target mounted\nreturn _updateOnMount(declVm);}// if source unmount, reset all the targets.\n_updateOnUnmount(declVm);// need to remove entry from cache\nreturn _removeFromCachePaths(declVm);};loadConfiguration();exports={updatePort,updateVmOnMountUnmount,loadConfiguration,getElementArray,setupSyncStrategy};export default exports;","map":null,"metadata":{},"sourceType":"module"}