{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/* eslint-disable sonarjs/no-duplicate-string */ /**\n * @module js/AwServerVisibilityCommandBarService\n */import AwCommandBar from'viewmodel/AwCommandBarViewModel';import AwPopupCommandBar from'viewmodel/AwPopupCommandBarViewModel';import AwStateService from'js/awStateService';import AwToolbar from'viewmodel/AwToolbarViewModel';import DataLoader from'dataloader';import Debug from'debug';import appCtxSvc from'js/appCtxService';import cdm from'soa/kernel/clientDataModel';import dms from'soa/dataManagementService';import{DerivedStateResult}from'js/derivedContextService';import{createComponent}from'js/declViewModelService';import{debounce,forEach,uniq,includes,replace}from'lodash';import{registerDynImportEntry}from'js/moduleLoader';import{jsx as _jsx}from\"react/jsx-runtime\";registerDynImportEntry('js/AwServerVisibilityCommandBarService',()=>import('js/AwServerVisibilityCommandBarService'));const trace=new Debug('command:tcCommandVisibilityService2');/**\n * Get the selection information for SOA input\n *\n * @param {Object[]} selection Currently selected objects\n * @param {Object} parentSelection Parent selection\n * @param {Boolean} istcgql Whether currently in GraphQL sublocation\n * @return {Object[]} Current selection information\n */const getSelectionInfo=function(){let selection=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];let parentSelection=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let istcgql=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(parentSelection&&parentSelection.uid===cdm.NULL_UID){parentSelection=null;}var soaMOs=[];var isTCGQL=istcgql;forEach(selection,function(selectedObj){var mo=cdm.getObject(selectedObj.uid);if(mo){soaMOs.push(mo);}else{if(isTCGQL){soaMOs.push(selectedObj);}}});var selInfo=[];if(soaMOs.length){var primarySelection={contextName:'',parentSelectionIndex:parentSelection?1:-1,selectedObjects:soaMOs};selInfo.push(primarySelection);}if(parentSelection){var pmo=cdm.getObject(parentSelection.uid);if(pmo){selInfo.push({contextName:'',parentSelectionIndex:-1,selectedObjects:[parentSelection]});}}return selInfo;};/**\n * Get the command information for SOA input\n *\n * @param {List<String>} commandIds Specific IDs to include in the call instead of all commands\n * @return {Object[]} Command info\n */const getCommandInfo=function(commandIds){return uniq(commandIds).sort().map(function(commandId){return{commandCollectionId:'',commandId};});};/**\n * Command context parameter for the current XRT page\n */const XRT_PAGE_ID='ActiveXrtPageId';/**\n * Prefix use for any URL parameters included in command context\n */const URL_PARAMETER_PREFIX='UrlParameter_';/**\n * Get the selection information for SOA input\n *\n * @param {Boolean} aw_hosting_enabled Whether currently in hosted mode\n * @param {String} aw_host_type The current host type\n * @param {String[]} commandContextParameters List of URL parameters to include in command context\n * @param {Object} processedState The current state parameters\n * @return {Object[]} The current command context\n */const getCommandContext=function(){let aw_hosting_enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;let aw_host_type=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';let commandContextParameters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];let processedState=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var hostingInfo=[{contextName:'IsHosted',contextValue:aw_hosting_enabled?'true':'false'},{contextName:'HostType',contextValue:aw_host_type}];//uid is always included since many teams have used to avoid writing conditions against what is selected vs the opened object\nvar urlInfo=commandContextParameters.concat(['uid']).map(function(param){if(includes(param,XRT_PAGE_ID)){return{contextName:XRT_PAGE_ID,contextValue:replace(param,XRT_PAGE_ID+':','')};}return{contextName:URL_PARAMETER_PREFIX+param,contextValue:processedState[param]||''};});return hostingInfo.concat(urlInfo);};/**\n * Create a cache map for the dataloader to use\n *\n * Something in the declarative framework breaks the native JS map, so reimplement with the same API\n *\n * @returns {Object} Plain object matching the API of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n */const getCacheMap=()=>{const cache={};return{get:k=>cache[k],set:(k,v)=>cache[k]=v,delete:k=>delete cache[k],clear:()=>{for(const k in cache){delete cache[k];}}};};/**\n * Get the current server visibility for the list of commands\n *\n * @param {[String]} commandIds Command IDs to load server visibility for\n * @param {Object} ctx The current context for loading\n * @returns {[Boolean]} True/false for each command ID\n */export const getCurrentServerVisibility=async(commandIds,ctx)=>{const{sublocation:{clientScopeURI=''},mselected,pselected,istcgql=false,ViewModeContext:{ViewModeContext},aw_hosting_enabled,aw_host_type,commandContextParameters,services:{awCommandVisibilityLoader}}=ctx;//Support for GraphQL based sublocations\nif(istcgql){const isSummaryHidden=ViewModeContext==='TableView'||ViewModeContext==='ListView'||ViewModeContext==='ImageView';const selectObjUids=mselected.map(x=>x.uid).filter(x=>x);const isMultiSelected=mselected.length>1;if(selectObjUids.length>0&&(isSummaryHidden||isMultiSelected)){dms.loadObjects(selectObjUids);}}const stateParameters=AwStateService.instance.params;let pselectedIn=appCtxSvc.getCtx('pselected');const getVisibleCommandsInfo={clientScopeURI,selectionInfo:getSelectionInfo(mselected,pselectedIn,istcgql),commandContextInfo:getCommandContext(aw_hosting_enabled,aw_host_type,commandContextParameters,stateParameters),commandInfo:getCommandInfo(commandIds)};trace('Loading visibility commands with given context information',commandIds,getVisibleCommandsInfo);const visibleCommandsInfo=await awCommandVisibilityLoader.load(getVisibleCommandsInfo);const visibleCommandIds=visibleCommandsInfo.map(x=>x.commandId);return commandIds.map(id=>visibleCommandIds.includes(id));};/**\n * Get a dataloader for command visibility based on the current selection\n *\n * @param {Object} param0 Render context\n * @param {[ViewModelObject]} mselected Selected objects from props\n * @param {ViewModelObject} pselected Parent selection from props\n * @param {Number} visibilityLoaderIdCounter Counter used to force refresh\n * @returns {DataLoader} Loader for command visibility\n */export const getServerVisibilityLoader=(_ref,mselected,pselected,visibilityLoaderIdCounter)=>{let{ctx}=_ref;//note: we could simply do { ...ctx, mselected, pselected } but other cosumers of this loader not refactored yet to use props\nctx.mselected=mselected?mselected:ctx.mselected;ctx.pselected=pselected?pselected:ctx.pselected;trace('Previous visibility loader is stale, creating new loader',ctx,visibilityLoaderIdCounter);return new DataLoader(async commandIds=>getCurrentServerVisibility(commandIds,ctx),{cacheMap:getCacheMap()});};/**\n * Get the derived state configuration for visibility loader\n *\n * @param {Object} vmDef View model\n * @param {Object} prop Current properties\n * @param {Object} data Current view model data\n * @returns {[DerivedStateResult]} Derived state configurations\n */export const getDerivedVisibilityLoader=(vmDef,prop,data)=>{return new DerivedStateResult({ctxParameters:['ViewModeContext.ViewModeContext','services.awCommandVisibilityLoader','aw_host_type','aw_hosting_enabled','commandContextParameters','istcgql','mselected','pselected','sublocation.clientScopeURI'],additionalParameters:[prop.mselected,prop.pselected,data.visibilityLoaderIdCount||0],compute:getServerVisibilityLoader});};/**\n * Counter used to force server visibilty reload. Increment method is debounced to avoid\n * multiple calls when a \"cdm.relatedModified\" is happening at the same time as \"cdm.updated\"\n *\n * @returns {Object} Counter object\n */export const getForcedLoaderCounter=()=>{trace('Initializing visibility loader counter');return{count:0,counter:{increment:debounce(x=>{return x+1;},100,{leading:true,trailing:false})}};};/**\n * Check the event data to determine if a server visibility reload is necessary.\n * Will increment counter only if update is required\n *\n * @param {Object} eventData cdm.relatedModified or cdm.updated event data\n * @param {*} mselected The current selected objects\n * @param {*} count The current count\n * @param {*} counter The current counter\n * @returns {Object} Updated counter\n */export const checkForRefresh=function(eventData){let mselected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];let count=arguments.length>2?arguments[2]:undefined;let counter=arguments.length>3?arguments[3]:undefined;if(!counter){return count;}const mselectedUids=mselected.map(x=>x.uid);const modifiedObjects=eventData.relatedModified||eventData.updatedObjects||[];if(eventData.relatedModified){trace('cdm.relatedModified',eventData.relatedModified);}if(eventData.updatedObjects){trace('cdm.updated',eventData.updatedObjects);}for(const mo of modifiedObjects){if(mselectedUids.includes(mo.uid)){trace('Incrementing counter to force reload of server visibility',mo.uid);return{count:counter.increment(count)};}}return{count};};/**\n * Wrap the given component with Active Workspace specific server visibility logic\n *\n * addServerVisibility :: ( [DataLoader,...props] => JSX ) => ( [Object,Object,...props] => JSX )\n *\n * @param {Component} ChildComponent The component to wrap\n * @param {String} componentId ID of the component (will appear in dev tools)\n * @returns {Component} The wrapper component\n */export const addServerVisibility=(ChildComponent,componentId)=>{const ctxImportObj={serverVisibilityLoader:getDerivedVisibilityLoader};//Generated view model JSON for wrapper component\nconst declViewModelJson={schemaVersion:'1.0.0',actions:{//Refresh action used to force visibility reload without selection change\ncheckForRefresh:{actionType:'JSFunction',method:'checkForRefresh',deps:'js/AwServerVisibilityCommandBarService',inputData:{0:'{{data.eventData}}',1:'{{props.mselected}}',2:'{{data.visibilityLoaderIdCount}}',3:'{{data.visibilityLoaderIdCounter}}'},outputData:{//Increment counter to force recreation of dataloader, causing server visibility reload\nvisibilityLoaderIdCount:'count'}},//Initializes the counter used to \"force\" server visibility reloads\ngetForcedLoaderCounter:{actionType:'JSFunction',method:'getForcedLoaderCounter',deps:'js/AwServerVisibilityCommandBarService',inputData:{},outputData:{visibilityLoaderIdCount:'count',visibilityLoaderIdCounter:'counter'}}},ctx:{//Use derived state to recreate a data loader whenever the relevant data (selection, etc) changes\n//Creation of new data loader triggers reload of server visibility\nserverVisibilityLoader:{parser:{method:'getDerivedVisibilityLoader',deps:'js/AwServerVisibilityCommandBarService'}},mselected:null,pselected:null},onEvent:[{eventId:'cdm.relatedModified',action:'checkForRefresh',cacheEventData:true},{eventId:'cdm.updated',action:'checkForRefresh',cacheEventData:true}],props:{mselected:{type:'object'},pselected:{type:'viewModelObject'}},lifecycleHooks:{onMount:'getForcedLoaderCounter'},_viewModelId:componentId,_uniqueViewModelId:componentId};const render=props=>{const{ctx}=props;return/*#__PURE__*/_jsx(ChildComponent,{...props,visibilityLoader:ctx.serverVisibilityLoader});};return createComponent(declViewModelJson,render,undefined,ctxImportObj);};/**\n * AW specific wrappers of the standard AwCommandBar, AwToolbar, AwPopupCommandBar\n *\n * Instead of a server visibility loader these components will have \"mselected\" and \"pselected\" props. They\n * will use those props to manage server visiiblity. If either one of those props is not provided the values\n * from ctx.mselected and ctx.pselected will be used instead\n */export const AwServerVisibilityPopupCommandBar=addServerVisibility(AwPopupCommandBar,'AwServerVisibilityPopupCommandBarImpl');export const AwServerVisibilityCommandBar=addServerVisibility(AwCommandBar,'AwServerVisibilityCommandBarImpl');export const AwServerVisibilityToolbar=addServerVisibility(AwToolbar,'AwServerVisibilityToolbarImpl');/**\n * Fake render function to support HTML view usage\n *\n * @param {Object} props props\n * @returns {Component} component\n */export const renderCommandBar=props=>{return/*#__PURE__*/_jsx(AwServerVisibilityCommandBar,{...props});};/**\n * Fake render function to support HTML view usage\n *\n * @param {Object} props props\n * @returns {Component} component\n */export const renderToolbar=props=>{return/*#__PURE__*/_jsx(AwServerVisibilityToolbar,{...props});};/**\n * Fake render function to support HTML view usage\n *\n * @param {Object} props props\n * @returns {Component} component\n */export const renderPopupCommandBar=props=>{return/*#__PURE__*/_jsx(AwServerVisibilityPopupCommandBar,{...props});};","map":null,"metadata":{},"sourceType":"module"}