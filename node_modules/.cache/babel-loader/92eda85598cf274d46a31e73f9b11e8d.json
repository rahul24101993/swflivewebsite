{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link wcagService} which provides services for accessibility related functionalities\n *\n * @module js/wcagService\n */\nimport $ from 'jquery';\nimport localeSvc from 'js/localeService';\nimport popupUtils from 'js/popupUtils';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport domUtils from 'js/domUtils';\nlet exports = {};\nlet dom = domUtils.DOMAPIs;\nlet groupCmdParent = null;\nlet focusableCandidates = ['button:not(.disabled), [href]:not(.disabled), input:not(.disabled), select:not(.disabled), textarea:not(.disabled), [tabindex]:not(.disabled)', 'summary:not(.disabled)'];\nconst ENTER_KEY_CODE_VALUE = 'Enter';\nconst SPACE_KEY_CODE_VALUE = 'Space';\nconst MAIN_SELECTOR = 'main.aw-layout-workareaMain';\n/**\n * Helper function to update aria-label on targetelement located by childlocator\n * @param {Object} containerDOMElement - The element which contains landmark element\n * @param {string} childLocator - string identifying landmakr element within containerDOMElement\n * @param {string} messageFile Name of file containing messages\n */\n\nexport let updateArialabel = function (containerDOMElement, childLocator, messageFile) {\n  let targetElement = null;\n\n  if (containerDOMElement === null) {\n    targetElement = $(childLocator).length > 0 ? $(childLocator)[0] : null;\n  } else if ($(containerDOMElement).find(childLocator).length > 0) {\n    targetElement = $(containerDOMElement).find(childLocator)[0];\n  } else if (childLocator.length === 0) {\n    targetElement = containerDOMElement;\n  }\n\n  if (targetElement !== null) {\n    let ariaLabelKey = targetElement.getAttribute('aria-label').substring(5);\n    localeSvc.getLocalizedText(messageFile, ariaLabelKey).then(function (localizedVal) {\n      targetElement.setAttribute('aria-label', localizedVal);\n    });\n  }\n};\n/**\n * This API is a helper function to add aria-label to duplicate 'main' landmarks.\n *\n */\n\nexport let updateArialabelForDuplicateLandmarks = function () {\n  let mainEls = document.querySelectorAll(MAIN_SELECTOR);\n  let cnt = 1; // below check is to ensure we do not have this attribute set in case there is just one\n  // instance of the landmark on a page\n\n  if (mainEls && mainEls.length !== 1) {\n    for (let i = 0; i < mainEls.length; i++) {\n      localeSvc.getLocalizedText('UIElementsMessages', 'mainLabel').then(function (localizedVal) {\n        let ariaLabelledByAttr = document.createAttribute('aria-label');\n        ariaLabelledByAttr.value = localizedVal + cnt;\n        cnt++;\n        mainEls[i].setAttributeNode(ariaLabelledByAttr);\n      });\n    }\n  }\n};\n/**\n * This API is a helper function to add missing button in form to avoid SiteImprove violations.\n *\n */\n\nexport let updateMissingButtonInForm = function (containerDOMElement) {\n  if (containerDOMElement) {\n    let BUTTON_CLASS = 'aw-hide-form-button';\n    let BUTTON_EL = 'button';\n    let formElem = null;\n\n    if (containerDOMElement.tagName && containerDOMElement.tagName === 'FORM') {\n      formElem = containerDOMElement;\n    } else {\n      formElem = containerDOMElement.querySelector('form');\n    } // intent is to check for the presence of dummy hidden disabled button. Not necessary to check the\n    // presence of an already existing functional button within the form since even if one or more\n    // functional buttons exist within the form , it does not cause any functional failures because\n    // the dummy button is disabled and hence not submit-able.\n\n\n    if (!formElem.querySelector(BUTTON_EL + '.' + BUTTON_CLASS)) {\n      let buttonNode = document.createElement(BUTTON_EL);\n      buttonNode.type = 'submit';\n      buttonNode.classList.add(BUTTON_CLASS);\n      buttonNode.disabled = true;\n      buttonNode.setAttribute('aria-hidden', true);\n      formElem.appendChild(buttonNode);\n    }\n  }\n};\n/**\n * This API is a helper function to find all the focusable children of a DOMElement.\n *\n * @param {DOMElement} containerElement the container to look for focusable children\n * @return {NodeList} all the focusable children\n */\n\nexport let findFocusableChildren = function (containerElement) {\n  return containerElement.querySelectorAll(focusableCandidates);\n};\n/**\n * Finds the next focusable child in the containing element if one child is already focused.\n * Otherwise, can send first focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnFirstChildIfNone whether to return first focusable child if no next child found\n * @return {Node} next focusable child, or first focusable child if none found (option)\n */\n\nexport let findNextFocusableChild = function (containerElement, returnFirstChildIfNone) {\n  let nextFocusableChild = null;\n  const focusableElements = findFocusableChildren(containerElement);\n\n  if (focusableElements && focusableElements.length) {\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (focusableElements[i] === document.activeElement) {\n        if (i + 1 < focusableElements.length) {\n          nextFocusableChild = focusableElements[i + 1];\n        }\n\n        break;\n      }\n    }\n\n    if (!nextFocusableChild && returnFirstChildIfNone) {\n      nextFocusableChild = focusableElements[0];\n    }\n  }\n\n  return nextFocusableChild;\n};\n/**\n * Finds the previous focusable child in the containing element if one child is already focused.\n * Otherwise, can send last focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnLastChildIfNone whether to return last focusable child if no previous child found\n * @return {Node} previous focusable child, or last focusable child if none found (option)\n */\n\nexport let findPreviousFocusableChild = function (containerElement, returnLastChildIfNone) {\n  let previousFocusableChild = null;\n  const focusableElements = findFocusableChildren(containerElement);\n\n  if (focusableElements && focusableElements.length) {\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (focusableElements[i] === document.activeElement) {\n        if (i > 0) {\n          previousFocusableChild = focusableElements[i - 1];\n        }\n\n        break;\n      }\n    }\n\n    if (!previousFocusableChild && returnLastChildIfNone) {\n      previousFocusableChild = focusableElements[focusableElements.length - 1];\n    }\n  }\n\n  return previousFocusableChild;\n};\nexport let setParentOfGroupCmds = function (referenceElement) {\n  groupCmdParent = referenceElement;\n};\nexport let getParentOfGroupCmds = function () {\n  return groupCmdParent;\n};\n\nlet isNotyMsgPresentInDOM = function (notyMessageContainer) {\n  return document.body.contains(notyMessageContainer);\n};\n\nlet isNotyMsgNotfocussed = function (focussableElements) {\n  return document.activeElement !== focussableElements[0];\n};\n\nlet renderFocusToNotyMsg = function () {\n  let notyMsgContainerId = 'noty_bottom_layout_container';\n  let notyMessageContainer = document.getElementById(notyMsgContainerId);\n\n  if (isNotyMsgPresentInDOM(notyMessageContainer)) {\n    let focussableElements = findFocusableChildren(notyMessageContainer);\n\n    if (isNotyMsgNotfocussed(focussableElements)) {\n      focussableElements[0].focus();\n    }\n  }\n};\n\nexport let skipToFirstFocusableElement = function (container, checkActiveFocusInContainer, selectedElementCSS) {\n  // If there is already focused element in container, donot skip to focusbale ele\n  let currentFocusedEle = document.activeElement;\n\n  if (container === undefined || container === null || checkActiveFocusInContainer !== false && container.contains(currentFocusedEle)) {\n    return true;\n  }\n\n  let elementLoading = $(container).find('.aw-element-loading, .aw-jswidgets-loading');\n\n  if (elementLoading.length === 0) {\n    // If there is no element in loading state, then only start focus\n    //Try focus on first selected element\n    if (selectedElementCSS && selectedElementCSS.length > 0) {\n      let elementToFocus = $(container).find(selectedElementCSS);\n\n      if (elementToFocus.length > 0) {\n        elementToFocus[0].focus();\n        renderFocusToNotyMsg();\n\n        if (document.activeElement === elementToFocus[0]) {\n          //Focus successful\n          return true;\n        }\n      }\n    }\n\n    let focusable = findFocusableChildren(container);\n\n    if (focusable && focusable.length > 0) {\n      for (let focusableEle of focusable) {\n        if ($(focusableEle).is(':visible')) {\n          focusableEle.focus();\n          renderFocusToNotyMsg();\n          return true;\n        }\n      }\n    } else {\n      //Check if element it self is focusable\n      container.focus();\n      renderFocusToNotyMsg();\n\n      if (document.activeElement === container) {\n        //Focus successful\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nlet trapFocus = panelRef => event => {\n  let {\n    panelEl: element,\n    options\n  } = panelRef; // apply exclude cases- LCS-443560 - Commands in overflow do not process events after SOA completion\n\n  if (popupUtils.checkIgnore(options, event.target)) {\n    return;\n  } // If new focus element is NOT in current popup element, focus on reference and hide\n\n\n  if (!element.contains(event.target)) {\n    // only do this when tab move to the last element\n    if (event.target.id && event.target.id.includes(element.id)) {\n      skipToFirstFocusableElement(panelRef.options.reference, panelRef.options.checkActiveFocusInContainer); // do not hide an element if the api not available, for example noty_msg should not be hidden\n      // once focus reaches the sentinel\n\n      if (panelRef.options.api) {\n        panelRef.options.api.hide(panelRef);\n      }\n    }\n  }\n}; // Bracket the dialog node with two invisible, focusable nodes.\n// While this dialog is open, we use these to make sure that focus never\n// leaves the document even if dialogNode is the first or last node.\n\n\nlet createSentinel = (element, id) => {\n  let preDiv = document.createElement('div');\n  let preNode = element.parentNode.insertBefore(preDiv, element);\n  preNode.tabIndex = 0;\n  preNode.id = `pre-${id}`;\n  let postDiv = document.createElement('div');\n  let postNode = element.parentNode.insertBefore(postDiv, element.nextSibling);\n  postNode.tabIndex = 0;\n  postNode.id = `post-${id}`;\n  return () => {\n    if (element.parentNode) {\n      //check for presence before removing\n      if (_.includes(element.parentNode.childNodes, preNode)) {\n        element.parentNode.removeChild(preNode);\n      }\n\n      if (_.includes(element.parentNode.childNodes, postNode)) {\n        element.parentNode.removeChild(postNode);\n      }\n    }\n  };\n};\n\nlet configureFocusListener = panelRef => {\n  const focusHandler = trapFocus(panelRef);\n  document.addEventListener('focus', focusHandler, true);\n  return () => {\n    document.removeEventListener('focus', focusHandler, true);\n  };\n};\n\nexport let configureAutoFocus = function (dialogNode, popupRef) {\n  const removeHandlers = [];\n  const {\n    reference,\n    selectedElementCSS\n  } = popupRef.options;\n  removeHandlers.push(createSentinel(dialogNode, popupRef.id));\n  removeHandlers.push(configureFocusListener(popupRef)); // honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.\n\n  const onClose = () => {\n    if (reference) {\n      skipToFirstFocusableElement(reference);\n      setParentOfGroupCmds(reference);\n    }\n  };\n\n  focusFirstDescendantWithDelay(dialogNode, selectedElementCSS);\n  return {\n    removeHandlers,\n    onClose\n  };\n};\nexport let focusFirstDescendantWithDelay = function (element, selectedElementCSS) {\n  let timer = setInterval(() => {\n    // if not existed anymore or element is already rendered\n    if (!element) {\n      clearInterval(timer);\n      return;\n    } // still available\n\n\n    if (element.childNodes) {\n      for (var i = 0; i < element.childNodes.length; i++) {\n        var child = element.childNodes[i];\n\n        if (child.tagName && skipToFirstFocusableElement(child, null, selectedElementCSS)) {\n          clearInterval(timer);\n          return true;\n        }\n      }\n    }\n  }, 50); // clean resource when reach max limit\n\n  setTimeout(() => clearInterval(timer), 5000);\n};\n/**\n * Helper function to add 'Skip to Main' functionality in order to support\n * enter/click option on 'Skip to Main' Bypass block\n */\n\nexport let initializeSkipToMain = function () {\n  let mainElement = document.querySelector(MAIN_SELECTOR);\n\n  if (mainElement) {\n    let focusable = findFocusableChildren(mainElement);\n\n    if (focusable && focusable.length > 0) {\n      let firstFocusable = focusable[0];\n      firstFocusable.focus();\n    }\n  } else {\n    logger.error('missing main landmark');\n  }\n};\n/**\n *  Helper function to apply/unapply focus to 'main' landmark when\n *  a page is focussed for the first time using tab click and when\n *  Skip to main link gets focussed\n */\n\nexport let applyFocusOnMain = function () {\n  let skipToMainLinkElem = null;\n  let mainElement = document.querySelector(MAIN_SELECTOR);\n  skipToMainLinkElem = document.querySelector('a.aw-skip-to-main');\n\n  if (skipToMainLinkElem !== null && mainElement !== null) {\n    dom.on(skipToMainLinkElem, 'focus', () => {\n      mainElement.classList.add('aw-apply-focus-to-main');\n    });\n    dom.on(skipToMainLinkElem, 'blur', () => {\n      mainElement.classList.remove('aw-apply-focus-to-main');\n    });\n  }\n};\n/**\n * get key name - supports modern browsers and IE11\n *\n * @param {Object} event keyboard event object ($event)\n * @returns {String} key name\n */\n\nexport let getKeyName = function (event) {\n  // change space key to string literal 'Space'\n  return event.key === ' ' ? SPACE_KEY_CODE_VALUE : event.key;\n};\n/**\n * check if the keyboard event is equivalent to a mouse click\n *\n * @param {Object} event keyboard event object ($event)\n * @param {boolean} ignoreSpacebar - if the element accepts space as a valid key stroke eg: lov\n * @returns {boolean} true if valid synthetic 'click' pressed\n */\n\nlet isValidKeyPress = function (event, ignoreSpacebar) {\n  let keyPressed = getKeyName(event);\n\n  if (ignoreSpacebar) {\n    if (keyPressed === ENTER_KEY_CODE_VALUE) {\n      return true;\n    }\n  } else {\n    // Default space bar press scrolls the page. Preventing that behavior\n    if (keyPressed === SPACE_KEY_CODE_VALUE) {\n      event.preventDefault();\n    } // Check if keyboard event is equivalent to a mouse click\n\n\n    if (keyPressed === ENTER_KEY_CODE_VALUE || keyPressed === SPACE_KEY_CODE_VALUE) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport let handleMoveUpOrDown = (event, container) => {\n  let keyPressed = getKeyName(event);\n\n  if (keyPressed === 'ArrowUp' || keyPressed === 'ArrowDown') {\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      const nextChildUp = findPreviousFocusableChild(container, true);\n      nextChildUp && nextChildUp.focus();\n    } else {\n      event.preventDefault();\n      const nextChildDown = findNextFocusableChild(container, true);\n      nextChildDown && nextChildDown.focus();\n    }\n  }\n}; // When Element is removed from DOM/ mouse clicked, then focus is lost and then\n// on next press of tab, where should be focus starting point- we have to manually manage focus\n// In order to do this, we add 'aw-focus-startpoint' CSS to element that will be focus starting\n// point on next press of tab key press -check solution below\n//https://sarahmhigley.com/writing/focus-navigation-start-point/#assistive-tech-support\n\nexport let updateFocusStartPoint = eletoUpdateFocus => {\n  if (eletoUpdateFocus !== null) {\n    //Remove flying focus from any existing elements\n    $('.aw-focus-startpoint').removeClass('aw-focus-startpoint'); //Update flying focus on\n\n    eletoUpdateFocus.classList.add('aw-focus-startpoint');\n  }\n};\n/**\n * use this function when you want to programatically focus an element\n * and show the focus style normally reserved for keyboard-mode.\n * @param {Object} elementToFocus - dom element about to get focus\n */\n\nexport let afxFocusElement = elementToFocus => {\n  elementToFocus.focus();\n  document.body.classList.add('keyboard');\n};\n/**\n * use this function to check if the user is operating in keyboard-mode.\n * This is determined based on the user's most recent action.\n * returns true if from keyboard. 'false' if from mouse.\n * @returns {boolean} true if it is a keyboard event\n */\n\nexport let areWeInKeyboardMode = () => {\n  if (document.body.classList.contains('keyboard')) {\n    return true;\n  }\n\n  return false;\n};\nexports = {\n  updateArialabel,\n  updateArialabelForDuplicateLandmarks,\n  updateMissingButtonInForm,\n  initializeSkipToMain,\n  findFocusableChildren,\n  findNextFocusableChild,\n  findPreviousFocusableChild,\n  skipToFirstFocusableElement,\n  setParentOfGroupCmds,\n  getParentOfGroupCmds,\n  focusFirstDescendantWithDelay,\n  applyFocusOnMain,\n  isValidKeyPress,\n  configureAutoFocus,\n  getKeyName,\n  handleMoveUpOrDown,\n  updateFocusStartPoint,\n  afxFocusElement,\n  areWeInKeyboardMode\n};\nexport default exports;","map":{"version":3,"names":["$","localeSvc","popupUtils","logger","_","domUtils","exports","dom","DOMAPIs","groupCmdParent","focusableCandidates","ENTER_KEY_CODE_VALUE","SPACE_KEY_CODE_VALUE","MAIN_SELECTOR","updateArialabel","containerDOMElement","childLocator","messageFile","targetElement","length","find","ariaLabelKey","getAttribute","substring","getLocalizedText","then","localizedVal","setAttribute","updateArialabelForDuplicateLandmarks","mainEls","document","querySelectorAll","cnt","i","ariaLabelledByAttr","createAttribute","value","setAttributeNode","updateMissingButtonInForm","BUTTON_CLASS","BUTTON_EL","formElem","tagName","querySelector","buttonNode","createElement","type","classList","add","disabled","appendChild","findFocusableChildren","containerElement","findNextFocusableChild","returnFirstChildIfNone","nextFocusableChild","focusableElements","activeElement","findPreviousFocusableChild","returnLastChildIfNone","previousFocusableChild","setParentOfGroupCmds","referenceElement","getParentOfGroupCmds","isNotyMsgPresentInDOM","notyMessageContainer","body","contains","isNotyMsgNotfocussed","focussableElements","renderFocusToNotyMsg","notyMsgContainerId","getElementById","focus","skipToFirstFocusableElement","container","checkActiveFocusInContainer","selectedElementCSS","currentFocusedEle","undefined","elementLoading","elementToFocus","focusable","focusableEle","is","trapFocus","panelRef","event","panelEl","element","options","checkIgnore","target","id","includes","reference","api","hide","createSentinel","preDiv","preNode","parentNode","insertBefore","tabIndex","postDiv","postNode","nextSibling","childNodes","removeChild","configureFocusListener","focusHandler","addEventListener","removeEventListener","configureAutoFocus","dialogNode","popupRef","removeHandlers","push","onClose","focusFirstDescendantWithDelay","timer","setInterval","clearInterval","child","setTimeout","initializeSkipToMain","mainElement","firstFocusable","error","applyFocusOnMain","skipToMainLinkElem","on","remove","getKeyName","key","isValidKeyPress","ignoreSpacebar","keyPressed","preventDefault","handleMoveUpOrDown","nextChildUp","nextChildDown","updateFocusStartPoint","eletoUpdateFocus","removeClass","afxFocusElement","areWeInKeyboardMode"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uielements/src/js/wcagService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link wcagService} which provides services for accessibility related functionalities\n *\n * @module js/wcagService\n */\nimport $ from 'jquery';\nimport localeSvc from 'js/localeService';\nimport popupUtils from 'js/popupUtils';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nimport domUtils from 'js/domUtils';\n\nlet exports = {};\nlet dom = domUtils.DOMAPIs;\nlet groupCmdParent = null;\nlet focusableCandidates = [ 'button:not(.disabled), [href]:not(.disabled), input:not(.disabled), select:not(.disabled), textarea:not(.disabled), [tabindex]:not(.disabled)', 'summary:not(.disabled)' ];\nconst ENTER_KEY_CODE_VALUE = 'Enter';\nconst SPACE_KEY_CODE_VALUE = 'Space';\nconst MAIN_SELECTOR = 'main.aw-layout-workareaMain';\n\n/**\n * Helper function to update aria-label on targetelement located by childlocator\n * @param {Object} containerDOMElement - The element which contains landmark element\n * @param {string} childLocator - string identifying landmakr element within containerDOMElement\n * @param {string} messageFile Name of file containing messages\n */\nexport let updateArialabel = function( containerDOMElement, childLocator, messageFile ) {\n    let targetElement = null;\n    if( containerDOMElement === null ) {\n        targetElement = $( childLocator ).length > 0 ? $( childLocator )[ 0 ] : null;\n    } else if( $( containerDOMElement ).find( childLocator ).length > 0 ) {\n        targetElement = $( containerDOMElement ).find( childLocator )[ 0 ];\n    } else if( childLocator.length === 0 ) {\n        targetElement = containerDOMElement;\n    }\n    if( targetElement !== null ) {\n        let ariaLabelKey = targetElement.getAttribute( 'aria-label' ).substring( 5 );\n        localeSvc.getLocalizedText( messageFile, ariaLabelKey ).then( function( localizedVal ) {\n            targetElement.setAttribute( 'aria-label', localizedVal );\n        } );\n    }\n};\n\n/**\n * This API is a helper function to add aria-label to duplicate 'main' landmarks.\n *\n */\nexport let updateArialabelForDuplicateLandmarks = function() {\n    let mainEls = document.querySelectorAll( MAIN_SELECTOR );\n    let cnt = 1;\n    // below check is to ensure we do not have this attribute set in case there is just one\n    // instance of the landmark on a page\n    if( mainEls && mainEls.length !== 1 ) {\n        for( let i = 0; i < mainEls.length; i++ ) {\n            localeSvc.getLocalizedText( 'UIElementsMessages', 'mainLabel' ).then( function( localizedVal ) {\n                let ariaLabelledByAttr = document.createAttribute( 'aria-label' );\n                ariaLabelledByAttr.value = localizedVal + cnt;\n                cnt++;\n                mainEls[ i ].setAttributeNode( ariaLabelledByAttr );\n            } );\n        }\n    }\n};\n\n/**\n * This API is a helper function to add missing button in form to avoid SiteImprove violations.\n *\n */\nexport let updateMissingButtonInForm = function( containerDOMElement ) {\n    if( containerDOMElement ) {\n        let BUTTON_CLASS = 'aw-hide-form-button';\n        let BUTTON_EL = 'button';\n        let formElem = null;\n        if( containerDOMElement.tagName && containerDOMElement.tagName === 'FORM' ) {\n            formElem = containerDOMElement;\n        } else {\n            formElem = containerDOMElement.querySelector( 'form' );\n        }\n        // intent is to check for the presence of dummy hidden disabled button. Not necessary to check the\n        // presence of an already existing functional button within the form since even if one or more\n        // functional buttons exist within the form , it does not cause any functional failures because\n        // the dummy button is disabled and hence not submit-able.\n        if( !formElem.querySelector( BUTTON_EL + '.' + BUTTON_CLASS ) ) {\n            let buttonNode = document.createElement( BUTTON_EL );\n            buttonNode.type = 'submit';\n            buttonNode.classList.add( BUTTON_CLASS );\n            buttonNode.disabled = true;\n            buttonNode.setAttribute( 'aria-hidden', true );\n            formElem.appendChild( buttonNode );\n        }\n    }\n};\n\n/**\n * This API is a helper function to find all the focusable children of a DOMElement.\n *\n * @param {DOMElement} containerElement the container to look for focusable children\n * @return {NodeList} all the focusable children\n */\nexport let findFocusableChildren = function( containerElement ) {\n    return containerElement.querySelectorAll( focusableCandidates );\n};\n\n/**\n * Finds the next focusable child in the containing element if one child is already focused.\n * Otherwise, can send first focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnFirstChildIfNone whether to return first focusable child if no next child found\n * @return {Node} next focusable child, or first focusable child if none found (option)\n */\nexport let findNextFocusableChild = function( containerElement, returnFirstChildIfNone ) {\n    let nextFocusableChild = null;\n    const focusableElements = findFocusableChildren( containerElement );\n    if( focusableElements && focusableElements.length ) {\n        for( let i = 0; i < focusableElements.length; i++ ) {\n            if( focusableElements[ i ] === document.activeElement ) {\n                if( i + 1 < focusableElements.length ) {\n                    nextFocusableChild = focusableElements[ i + 1 ];\n                }\n                break;\n            }\n        }\n        if( !nextFocusableChild && returnFirstChildIfNone ) {\n            nextFocusableChild = focusableElements[ 0 ];\n        }\n    }\n    return nextFocusableChild;\n};\n\n/**\n * Finds the previous focusable child in the containing element if one child is already focused.\n * Otherwise, can send last focusable child\n *\n * @param {DOMElement} containerElement Element to seach through for children\n * @param {boolean} returnLastChildIfNone whether to return last focusable child if no previous child found\n * @return {Node} previous focusable child, or last focusable child if none found (option)\n */\nexport let findPreviousFocusableChild = function( containerElement, returnLastChildIfNone ) {\n    let previousFocusableChild = null;\n    const focusableElements = findFocusableChildren( containerElement );\n    if( focusableElements && focusableElements.length ) {\n        for( let i = 0; i < focusableElements.length; i++ ) {\n            if( focusableElements[ i ] === document.activeElement ) {\n                if( i > 0 ) {\n                    previousFocusableChild = focusableElements[ i - 1 ];\n                }\n                break;\n            }\n        }\n        if( !previousFocusableChild && returnLastChildIfNone ) {\n            previousFocusableChild = focusableElements[ focusableElements.length - 1 ];\n        }\n    }\n    return previousFocusableChild;\n};\n\nexport let setParentOfGroupCmds = function( referenceElement ) {\n    groupCmdParent = referenceElement;\n};\n\nexport let getParentOfGroupCmds = function() {\n    return groupCmdParent;\n};\n\nlet isNotyMsgPresentInDOM = function( notyMessageContainer ) {\n    return document.body.contains( notyMessageContainer );\n};\n\nlet isNotyMsgNotfocussed = function( focussableElements ) {\n    return document.activeElement !== focussableElements[ 0 ];\n};\n\nlet renderFocusToNotyMsg = function() {\n    let notyMsgContainerId = 'noty_bottom_layout_container';\n    let notyMessageContainer = document.getElementById( notyMsgContainerId );\n\n    if( isNotyMsgPresentInDOM( notyMessageContainer ) ) {\n        let focussableElements = findFocusableChildren( notyMessageContainer );\n        if( isNotyMsgNotfocussed( focussableElements ) ) {\n            focussableElements[ 0 ].focus();\n        }\n    }\n};\n\nexport let skipToFirstFocusableElement = function( container, checkActiveFocusInContainer, selectedElementCSS ) {\n    // If there is already focused element in container, donot skip to focusbale ele\n    let currentFocusedEle = document.activeElement;\n    if( container === undefined || container === null || checkActiveFocusInContainer !== false && container.contains( currentFocusedEle ) ) {\n        return true;\n    }\n\n    let elementLoading = $( container ).find( '.aw-element-loading, .aw-jswidgets-loading' );\n    if( elementLoading.length === 0 ) {\n        // If there is no element in loading state, then only start focus\n        //Try focus on first selected element\n        if( selectedElementCSS && selectedElementCSS.length > 0 ) {\n            let elementToFocus = $( container ).find( selectedElementCSS );\n            if( elementToFocus.length > 0 ) {\n                elementToFocus[ 0 ].focus();\n                renderFocusToNotyMsg();\n                if( document.activeElement === elementToFocus[ 0 ] ) {\n                    //Focus successful\n                    return true;\n                }\n            }\n        }\n        let focusable = findFocusableChildren( container );\n        if( focusable && focusable.length > 0 ) {\n            for( let focusableEle of focusable ) {\n                if( $( focusableEle ).is( ':visible' ) ) {\n                    focusableEle.focus();\n                    renderFocusToNotyMsg();\n                    return true;\n                }\n            }\n        } else {\n            //Check if element it self is focusable\n            container.focus();\n            renderFocusToNotyMsg();\n            if( document.activeElement === container ) {\n                //Focus successful\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\nlet trapFocus = ( panelRef ) => ( event ) => {\n    let { panelEl: element, options } = panelRef;\n\n    // apply exclude cases- LCS-443560 - Commands in overflow do not process events after SOA completion\n    if( popupUtils.checkIgnore( options, event.target ) ) { return; }\n\n    // If new focus element is NOT in current popup element, focus on reference and hide\n    if( !element.contains( event.target ) ) {\n        // only do this when tab move to the last element\n        if( event.target.id && event.target.id.includes( element.id ) ) {\n            skipToFirstFocusableElement( panelRef.options.reference, panelRef.options.checkActiveFocusInContainer );\n\n            // do not hide an element if the api not available, for example noty_msg should not be hidden\n            // once focus reaches the sentinel\n            if( panelRef.options.api ) {\n                panelRef.options.api.hide( panelRef );\n            }\n        }\n    }\n};\n\n// Bracket the dialog node with two invisible, focusable nodes.\n// While this dialog is open, we use these to make sure that focus never\n// leaves the document even if dialogNode is the first or last node.\nlet createSentinel = ( element, id ) => {\n    let preDiv = document.createElement( 'div' );\n    let preNode = element.parentNode.insertBefore( preDiv, element );\n    preNode.tabIndex = 0;\n    preNode.id = `pre-${id}`;\n\n    let postDiv = document.createElement( 'div' );\n    let postNode = element.parentNode.insertBefore( postDiv, element.nextSibling );\n    postNode.tabIndex = 0;\n    postNode.id = `post-${id}`;\n    return () => {\n        if( element.parentNode ) {\n            //check for presence before removing\n            if( _.includes( element.parentNode.childNodes, preNode ) ) {\n                element.parentNode.removeChild( preNode );\n            }\n            if( _.includes( element.parentNode.childNodes, postNode ) ) {\n                element.parentNode.removeChild( postNode );\n            }\n        }\n    };\n};\n\nlet configureFocusListener = ( panelRef ) => {\n    const focusHandler = trapFocus( panelRef );\n    document.addEventListener( 'focus', focusHandler, true );\n\n    return () => {\n        document.removeEventListener( 'focus', focusHandler, true );\n    };\n};\n\nexport let configureAutoFocus = function( dialogNode, popupRef ) {\n    const removeHandlers = [];\n    const { reference, selectedElementCSS } = popupRef.options;\n\n    removeHandlers.push( createSentinel( dialogNode, popupRef.id ) );\n    removeHandlers.push( configureFocusListener( popupRef ) );\n\n    // honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.\n    const onClose = () => {\n        if( reference ) {\n            skipToFirstFocusableElement( reference );\n            setParentOfGroupCmds( reference );\n        }\n    };\n\n    focusFirstDescendantWithDelay( dialogNode, selectedElementCSS );\n\n    return {\n        removeHandlers,\n        onClose\n    };\n};\n\nexport let focusFirstDescendantWithDelay = function( element, selectedElementCSS ) {\n    let timer = setInterval( () => {\n        // if not existed anymore or element is already rendered\n        if( !element ) {\n            clearInterval( timer );\n            return;\n        }\n        // still available\n        if( element.childNodes ) {\n            for( var i = 0; i < element.childNodes.length; i++ ) {\n                var child = element.childNodes[ i ];\n                if( child.tagName && skipToFirstFocusableElement( child, null, selectedElementCSS ) ) {\n                    clearInterval( timer );\n                    return true;\n                }\n            }\n        }\n    }, 50 );\n    // clean resource when reach max limit\n    setTimeout( () => clearInterval( timer ), 5000 );\n};\n\n/**\n * Helper function to add 'Skip to Main' functionality in order to support\n * enter/click option on 'Skip to Main' Bypass block\n */\nexport let initializeSkipToMain = function() {\n    let mainElement = document.querySelector( MAIN_SELECTOR );\n    if( mainElement ) {\n        let focusable = findFocusableChildren( mainElement );\n        if( focusable && focusable.length > 0 ) {\n            let firstFocusable = focusable[ 0 ];\n            firstFocusable.focus();\n        }\n    } else {\n        logger.error( 'missing main landmark' );\n    }\n};\n\n/**\n *  Helper function to apply/unapply focus to 'main' landmark when\n *  a page is focussed for the first time using tab click and when\n *  Skip to main link gets focussed\n */\nexport let applyFocusOnMain = function() {\n    let skipToMainLinkElem = null;\n    let mainElement = document.querySelector( MAIN_SELECTOR );\n    skipToMainLinkElem = document.querySelector( 'a.aw-skip-to-main' );\n    if( skipToMainLinkElem !== null && mainElement !== null ) {\n        dom.on( skipToMainLinkElem, 'focus', () => {\n            mainElement.classList.add( 'aw-apply-focus-to-main' );\n        } );\n        dom.on( skipToMainLinkElem, 'blur', () => {\n            mainElement.classList.remove( 'aw-apply-focus-to-main' );\n        } );\n    }\n};\n\n/**\n * get key name - supports modern browsers and IE11\n *\n * @param {Object} event keyboard event object ($event)\n * @returns {String} key name\n */\nexport let getKeyName = function( event ) {\n    // change space key to string literal 'Space'\n    return event.key === ' ' ? SPACE_KEY_CODE_VALUE : event.key;\n};\n\n/**\n * check if the keyboard event is equivalent to a mouse click\n *\n * @param {Object} event keyboard event object ($event)\n * @param {boolean} ignoreSpacebar - if the element accepts space as a valid key stroke eg: lov\n * @returns {boolean} true if valid synthetic 'click' pressed\n */\nlet isValidKeyPress = function( event, ignoreSpacebar ) {\n    let keyPressed = getKeyName( event );\n    if( ignoreSpacebar ) {\n        if( keyPressed === ENTER_KEY_CODE_VALUE ) {\n            return true;\n        }\n    } else {\n        // Default space bar press scrolls the page. Preventing that behavior\n        if( keyPressed === SPACE_KEY_CODE_VALUE ) {\n            event.preventDefault();\n        }\n        // Check if keyboard event is equivalent to a mouse click\n        if( keyPressed === ENTER_KEY_CODE_VALUE || keyPressed === SPACE_KEY_CODE_VALUE ) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport let handleMoveUpOrDown = ( event, container ) => {\n    let keyPressed = getKeyName( event );\n    if( keyPressed === 'ArrowUp' || keyPressed === 'ArrowDown' ) {\n        if( event.key === 'ArrowUp' ) {\n            event.preventDefault();\n            const nextChildUp = findPreviousFocusableChild( container, true );\n            nextChildUp && nextChildUp.focus();\n        } else {\n            event.preventDefault();\n            const nextChildDown = findNextFocusableChild( container, true );\n            nextChildDown && nextChildDown.focus();\n        }\n    }\n};\n\n// When Element is removed from DOM/ mouse clicked, then focus is lost and then\n// on next press of tab, where should be focus starting point- we have to manually manage focus\n// In order to do this, we add 'aw-focus-startpoint' CSS to element that will be focus starting\n// point on next press of tab key press -check solution below\n//https://sarahmhigley.com/writing/focus-navigation-start-point/#assistive-tech-support\nexport let updateFocusStartPoint = ( eletoUpdateFocus ) => {\n    if( eletoUpdateFocus !== null ) {\n        //Remove flying focus from any existing elements\n        $( '.aw-focus-startpoint' ).removeClass( 'aw-focus-startpoint' );\n        //Update flying focus on\n        eletoUpdateFocus.classList.add( 'aw-focus-startpoint' );\n    }\n};\n\n/**\n * use this function when you want to programatically focus an element\n * and show the focus style normally reserved for keyboard-mode.\n * @param {Object} elementToFocus - dom element about to get focus\n */\nexport let afxFocusElement = ( elementToFocus ) => {\n    elementToFocus.focus();\n    document.body.classList.add( 'keyboard' );\n};\n\n/**\n * use this function to check if the user is operating in keyboard-mode.\n * This is determined based on the user's most recent action.\n * returns true if from keyboard. 'false' if from mouse.\n * @returns {boolean} true if it is a keyboard event\n */\nexport let areWeInKeyboardMode = () => {\n    if( document.body.classList.contains( 'keyboard' ) ) {\n        return true;\n    }\n    return false;\n};\n\nexports = {\n    updateArialabel,\n    updateArialabelForDuplicateLandmarks,\n    updateMissingButtonInForm,\n    initializeSkipToMain,\n    findFocusableChildren,\n    findNextFocusableChild,\n    findPreviousFocusableChild,\n    skipToFirstFocusableElement,\n    setParentOfGroupCmds,\n    getParentOfGroupCmds,\n    focusFirstDescendantWithDelay,\n    applyFocusOnMain,\n    isValidKeyPress,\n    configureAutoFocus,\n    getKeyName,\n    handleMoveUpOrDown,\n    updateFocusStartPoint,\n    afxFocusElement,\n    areWeInKeyboardMode\n};\n\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}