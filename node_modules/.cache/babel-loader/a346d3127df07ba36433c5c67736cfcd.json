{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/* eslint-disable complexity */\n\n/**\n * @module js/propValidationUtils\n */\nimport * as Yup from 'yup';\nimport _ from 'lodash';\nimport declUtils, { isNil } from 'js/declUtils';\nimport { isViewModelObject } from 'js/viewModelObjectService';\nimport { isViewModelProperty, isArrayOfViewModelProperty } from 'js/uwPropertyService';\nimport { getRealExpression, evaluateCondition } from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport localeSvc from 'js/localeService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport { isMatch } from 'date-fns';\n\nconst mapArrayOfVMPForValidation = (parKey, objectArray) => {\n  let collection = [];\n  objectArray.forEach((value, key) => {\n    collection[parKey + '_' + key] = value;\n  });\n  return collection;\n};\n/**\n *  This method would filter out \"ViewModelProperties\" from data section.\n *  It would only look at first level and try to figure out all the VMP's inside it.\n *  If in a data-structure VMP's are underneath few level, use Atomic data.\n * @param {*} data -\n * @returns {object } -\n */\n\n\nexport const filterFlatViewModelProps = data => {\n  // Below code would filter out the data and extract all the viewModel properties.\n  // It considers all the static and dynamic properties (inside vmo)\n  if (!isNil(data) && !_.isEmpty(data)) {\n    return Object.keys(data).map(key => {\n      let object = data[key];\n\n      if (!_.isEmpty(object)) {\n        // if the VMO is part of an object, then the validation is getting skipped.\n        if (key === 'objects') {\n          let objKey = Object.keys(object)[0];\n          object = object[objKey];\n        }\n\n        if (isViewModelObject(object)) {\n          return object.props;\n        } else if (isViewModelProperty(object)) {\n          return {\n            [key]: object\n          };\n        } else if (_.isArray(object) && isArrayOfViewModelProperty(object)) {\n          return { ...mapArrayOfVMPForValidation(key, object)\n          };\n        }\n      }\n\n      return undefined;\n    }).filter(props => {\n      return props !== null && props !== undefined;\n    }).reduce((acc, current) => {\n      return Object.assign(acc, current);\n    }, {});\n  }\n\n  return {};\n};\n\nconst getAtomicDataPath = function (metaObj, rootPath) {\n  let fieldsPath = [];\n\n  function parsePath(propName, basePath) {\n    let path;\n\n    if (basePath) {\n      path = Number.isInteger(propName) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n    } else {\n      path = propName;\n    }\n\n    return path;\n  }\n\n  function parseMetaForFieldsPath(currentMetaObj) {\n    let basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _.forEach(currentMetaObj, function processMeta(propValue, propName) {\n      if (propName === 'field' || propName === 'type') {\n        return undefined;\n      }\n\n      let path = parsePath(propName, basePath);\n      fieldsPath.push(`${rootPath}.${path}`);\n\n      if (_.isObject(propValue)) {\n        parseMetaForFieldsPath(propValue, path);\n      }\n\n      return undefined;\n    });\n  }\n\n  parseMetaForFieldsPath(metaObj);\n  return fieldsPath;\n};\n\nexport const filterFlatViewModelPropForAtomic = viewModel => {\n  let vmColl = {};\n\n  if (!isNil(viewModel.atomicDataRef) && !_.isEmpty(viewModel.atomicDataRef)) {\n    Object.keys(viewModel.atomicDataRef).forEach(stateName => {\n      let stateObject = viewModel.atomicDataRef[stateName].getAtomicData();\n      let metaObject = viewModel && viewModel.declViewModelJson.data[stateName] && viewModel.declViewModelJson.data[stateName].meta;\n\n      if (metaObject) {\n        let filePath = getAtomicDataPath(metaObject, stateName);\n        let tempStateObject = {\n          [stateName]: stateObject\n        };\n        filePath.forEach((pathkey, index) => {\n          let val = _.get(tempStateObject, pathkey);\n\n          if (!isNil(val) && !_.isEmpty(val)) {\n            if (isViewModelObject(val)) {\n              extractAtomicVMO();\n            } else if (isViewModelProperty(val)) {\n              vmColl[pathkey.replace(/\\./g, '_')] = val;\n            } else if (_.isArray(val) && isArrayOfViewModelProperty(val)) {\n              extractAtomicListVMP();\n            } else if (_.isArray(val)) {\n              extractAtomicListVMo();\n            }\n          }\n\n          function extractAtomicListVMo() {\n            val.forEach((arrpathkey, kindex) => {\n              if (isViewModelObject(val[kindex])) {\n                _.forOwn(val[kindex].props, function (propValue, propName) {\n                  let path = pathkey + '.' + kindex + '.props.' + propName;\n                  vmColl[path.replace(/\\./g, '_')] = propValue;\n                });\n              }\n            });\n          }\n\n          function extractAtomicListVMP() {\n            val.forEach((arrpathkey, kindex) => {\n              let path = pathkey + '.' + kindex;\n              vmColl[path.replace(/\\./g, '_')] = val[kindex];\n            });\n          }\n\n          function extractAtomicVMO() {\n            _.forOwn(val.props, function (propValue, propName) {\n              let path = pathkey + '.props.' + propName;\n              vmColl[path.replace(/\\./g, '_')] = propValue;\n            });\n          }\n        });\n      }\n    });\n  }\n\n  return vmColl;\n};\nexport const getStateCollection = viewModel => {\n  return { ...filterFlatViewModelProps(viewModel.getData()),\n    ...filterFlatViewModelPropForAtomic(viewModel)\n  };\n};\nexport const updateValidationSchema = (viewModel, vmpCollRef, vmpValidationSchema, getProps, vmPropCollection) => {\n  let schemaForValidate = {};\n  let oldVmPropCollection = vmpCollRef.current ? vmpCollRef.current.vmprop : null;\n\n  if (!_.isNil(oldVmPropCollection) && !_.isNil(vmPropCollection)) {\n    let registeredPropNames = Object.keys(oldVmPropCollection);\n    Object.keys(vmPropCollection).forEach(key => {\n      if (!registeredPropNames.includes(key) || oldVmPropCollection[key] && vmPropCollection[key] && oldVmPropCollection[key].isRequired !== vmPropCollection[key].isRequired) {\n        schemaForValidate[key] = vmPropCollection[key];\n      }\n    });\n  } else {\n    schemaForValidate = vmPropCollection;\n  }\n\n  vmpCollRef.current = {\n    vmprop: vmPropCollection,\n    vmModel: viewModel\n  };\n\n  if (!isNil(schemaForValidate) && !_.isEmpty(schemaForValidate)) {\n    const {\n      validationSchemaDef\n    } = getValidationSchema(schemaForValidate, vmpCollRef, getProps);\n    let clubSchema = {};\n    let exitingSchema = vmpValidationSchema.current ? vmpValidationSchema.current.exitingSchema : {};\n    Object.assign(clubSchema, exitingSchema, validationSchemaDef);\n\n    let _validationSchema = Yup.object().shape(clubSchema);\n\n    vmpValidationSchema.current = {\n      exitingSchema: clubSchema,\n      validationSchema: _validationSchema\n    };\n  }\n};\n\nconst isDatetimeValueInvalid = (dateApiObj, dateOrTimeType) => {\n  let timeVal = dateApiObj.timeValue ? dateTimeSvc.getNormalizedTimeValue(dateApiObj.timeValue) : null;\n  let dateVal = dateApiObj.dateValue ? dateApiObj.dateValue.split(' ')[0] : null;\n\n  switch (dateOrTimeType) {\n    case 'DATE':\n      if (dateVal && !isMatch(dateVal, dateTimeSvc.getDateFilterFormat())) {\n        return true;\n      }\n\n      break;\n\n    case 'TIME':\n      if (timeVal && !isMatch(timeVal, dateTimeSvc.getTimeFilterFormat())) {\n        return true;\n      }\n\n      break;\n\n    default:\n      return false;\n  }\n\n  return false;\n};\n\nconst validateDateTime = function () {\n  let dateApiObj = this.options.parent.dateApi;\n\n  if (isDatetimeValueInvalid(dateApiObj, 'DATE')) {\n    return this.createError({\n      message: localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()])\n    });\n  }\n\n  if (isDatetimeValueInvalid(dateApiObj, 'TIME')) {\n    return this.createError({\n      message: localeSvc.getMessage('INVALID_TIME', [dateTimeSvc.getTimeFormatPlaceholder()])\n    });\n  }\n\n  return true;\n};\n\nconst getValidationSchema = function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let vmpCollRef = arguments.length > 1 ? arguments[1] : undefined;\n  let getProps = arguments.length > 2 ? arguments[2] : undefined;\n  let schemaInput = {};\n\n  for (let [key, value] of Object.entries(props)) {\n    if (value) {\n      // build the yup propSchema for checking dbValue\n      let dbValue;\n      let type = value.type || 'none';\n\n      switch (type.toUpperCase()) {\n        case 'DATE':\n          dbValue = Yup.string().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).test('date-validation', 'invalid date', validateDateTime).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()]);\n          });\n          break;\n\n        case 'DATEARRAY':\n          dbValue = Yup.string().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).test('date-array-validation', 'invalid date', validateDateTime).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DATE', [dateTimeSvc.getDateFormatPlaceholder()]);\n          });\n          break;\n\n        case 'INTEGER':\n          dbValue = Yup.number().nullable().min(-2147483648, 'Out of range').max(2147483647, 'Out of range').transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).typeError(obj => {\n            return localeSvc.getMessage('INVALID_INTEGER', [obj.originalValue]);\n          });\n          break;\n\n        case 'INTEGERARRAY':\n          dbValue = Yup.array().of(Yup.number().nullable().min(-2147483648, 'Out of range').max(2147483647, 'Out of range').transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value)).typeError(obj => {\n            return localeSvc.getMessage('INVALID_INTEGER', [obj.originalValue]);\n          });\n          break;\n\n        case 'DOUBLE':\n          dbValue = Yup.number().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DOUBLE', [obj.originalValue]);\n          });\n          break;\n\n        case 'DOUBLEARRAY':\n          dbValue = Yup.array().of(Yup.number().nullable().transform((value, originalValue) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value)).typeError(obj => {\n            return localeSvc.getMessage('INVALID_DOUBLE', [obj.originalValue]);\n          });\n          break;\n\n        case 'BOOLEAN':\n          dbValue = Yup.boolean().nullable();\n          break;\n\n        default:\n          dbValue = Yup.string().nullable();\n      }\n\n      if (value.isRequired || value.isRequired === 'true') {\n        dbValue = dbValue.required(() => {\n          return localeSvc.getMessage('PROP_REQUIRED_ERROR');\n        });\n      }\n\n      if (value.validationCriteria) {\n        for (let criteria in value.validationCriteria) {\n          dbValue = dbValue.test(value.validationCriteria[criteria].condition, value.validationCriteria[criteria].value, function () {\n            let conditionObj = value.validationCriteria[criteria].condition;\n            let viewModel = vmpCollRef.current.vmModel;\n            viewModel.data = viewModel.getData();\n            let evalContext = {\n              viewModel,\n              props: getProps,\n              ctx: appCtxSvc.ctx\n            };\n            let expression = getRealExpression(conditionObj, viewModel.declViewModelJson); // eslint-disable-next-line no-invalid-this\n\n            return evaluateCondition(viewModel, expression, evalContext) ? this.createError({\n              message: viewModel.data[key].validationCriteria[criteria].value,\n              path: key\n            }) : true;\n          });\n        }\n      }\n\n      let valueToTestSchema = dbValue.test('propertyError', 'Error', function () {\n        // eslint-disable-next-line no-invalid-this\n        let context = this;\n        let hasError = declUtils.isNil(context.parent.error) || context.parent.error.trim() === '';\n        return !hasError ? context.createError({\n          message: context.parent.error,\n          path: key\n        }) : true;\n      });\n\n      if (['DATETIME', 'DATEARRAY', 'DATE'].includes(type.toUpperCase())) {\n        schemaInput[key] = Yup.object().shape({\n          uiValue: valueToTestSchema\n        });\n      } else {\n        schemaInput[key] = Yup.object().shape({\n          dbValue: valueToTestSchema\n        });\n      }\n    }\n  }\n\n  return {\n    validationSchemaDef: schemaInput\n  };\n};","map":{"version":3,"names":["Yup","_","declUtils","isNil","isViewModelObject","isViewModelProperty","isArrayOfViewModelProperty","getRealExpression","evaluateCondition","appCtxSvc","localeSvc","dateTimeSvc","isMatch","mapArrayOfVMPForValidation","parKey","objectArray","collection","forEach","value","key","filterFlatViewModelProps","data","isEmpty","Object","keys","map","object","objKey","props","isArray","undefined","filter","reduce","acc","current","assign","getAtomicDataPath","metaObj","rootPath","fieldsPath","parsePath","propName","basePath","path","Number","isInteger","parseMetaForFieldsPath","currentMetaObj","processMeta","propValue","push","isObject","filterFlatViewModelPropForAtomic","viewModel","vmColl","atomicDataRef","stateName","stateObject","getAtomicData","metaObject","declViewModelJson","meta","filePath","tempStateObject","pathkey","index","val","get","extractAtomicVMO","replace","extractAtomicListVMP","extractAtomicListVMo","arrpathkey","kindex","forOwn","getStateCollection","getData","updateValidationSchema","vmpCollRef","vmpValidationSchema","getProps","vmPropCollection","schemaForValidate","oldVmPropCollection","vmprop","registeredPropNames","includes","isRequired","vmModel","validationSchemaDef","getValidationSchema","clubSchema","exitingSchema","_validationSchema","shape","validationSchema","isDatetimeValueInvalid","dateApiObj","dateOrTimeType","timeVal","timeValue","getNormalizedTimeValue","dateVal","dateValue","split","getDateFilterFormat","getTimeFilterFormat","validateDateTime","options","parent","dateApi","createError","message","getMessage","getDateFormatPlaceholder","getTimeFormatPlaceholder","schemaInput","entries","dbValue","type","toUpperCase","string","nullable","transform","originalValue","trim","test","typeError","obj","number","min","max","array","of","boolean","required","validationCriteria","criteria","condition","conditionObj","evalContext","ctx","expression","valueToTestSchema","context","hasError","error","uiValue"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/propValidationUtils.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n/* eslint-disable complexity */\n\n/**\n * @module js/propValidationUtils\n */\nimport * as Yup from 'yup';\nimport _ from 'lodash';\nimport declUtils, { isNil } from 'js/declUtils';\nimport { isViewModelObject } from 'js/viewModelObjectService';\nimport { isViewModelProperty, isArrayOfViewModelProperty } from 'js/uwPropertyService';\nimport { getRealExpression, evaluateCondition } from 'js/conditionService';\nimport appCtxSvc from 'js/appCtxService';\nimport localeSvc from 'js/localeService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport { isMatch } from 'date-fns';\n\nconst mapArrayOfVMPForValidation = ( parKey, objectArray ) => {\n    let collection = [];\n    objectArray.forEach( ( value, key ) => {\n        collection[ parKey + '_' + key ] = value;\n    } );\n    return collection;\n};\n/**\n *  This method would filter out \"ViewModelProperties\" from data section.\n *  It would only look at first level and try to figure out all the VMP's inside it.\n *  If in a data-structure VMP's are underneath few level, use Atomic data.\n * @param {*} data -\n * @returns {object } -\n */\nexport const filterFlatViewModelProps = ( data ) => {\n    // Below code would filter out the data and extract all the viewModel properties.\n    // It considers all the static and dynamic properties (inside vmo)\n    if( !isNil( data ) && !_.isEmpty( data ) ) {\n        return Object.keys( data ).map( ( key ) => {\n            let object = data[ key ];\n\n            if( !_.isEmpty( object ) ) {\n                // if the VMO is part of an object, then the validation is getting skipped.\n                if( key === 'objects' ) {\n                    let objKey = Object.keys( object )[ 0 ];\n                    object = object[ objKey ];\n                }\n                if( isViewModelObject( object ) ) {\n                    return object.props;\n                } else if( isViewModelProperty( object ) ) {\n                    return {\n                        [ key ]: object\n                    };\n                } else if( _.isArray( object ) && isArrayOfViewModelProperty( object ) ) {\n                    return {\n                        ...mapArrayOfVMPForValidation( key, object )\n                    };\n                }\n            }\n            return undefined;\n        } ).filter( ( props ) => {\n            return props !== null && props !== undefined;\n        } ).reduce( ( acc, current ) => {\n            return Object.assign( acc, current );\n        }, {} );\n    }\n    return {};\n};\n\nconst getAtomicDataPath = function( metaObj, rootPath ) {\n    let fieldsPath = [];\n\n    function parsePath( propName, basePath ) {\n        let path;\n        if( basePath ) {\n            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;\n        } else {\n            path = propName;\n        }\n        return path;\n    }\n\n    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {\n        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {\n            if( propName === 'field' || propName === 'type' ) {\n                return undefined;\n            }\n            let path = parsePath( propName, basePath );\n            fieldsPath.push( `${rootPath}.${path}` );\n            if( _.isObject( propValue ) ) {\n                parseMetaForFieldsPath( propValue, path );\n            }\n            return undefined;\n        } );\n    }\n\n    parseMetaForFieldsPath( metaObj );\n\n    return fieldsPath;\n};\n\nexport const filterFlatViewModelPropForAtomic = ( viewModel ) => {\n    let vmColl = {};\n    if( !isNil( viewModel.atomicDataRef ) && !_.isEmpty( viewModel.atomicDataRef ) ) {\n        Object.keys( viewModel.atomicDataRef ).forEach( ( stateName ) => {\n            let stateObject = viewModel.atomicDataRef[ stateName ].getAtomicData();\n            let metaObject = viewModel && viewModel.declViewModelJson.data[ stateName ] &&\n                viewModel.declViewModelJson.data[ stateName ].meta;\n            if( metaObject ) {\n                let filePath = getAtomicDataPath( metaObject, stateName );\n                let tempStateObject = {\n                    [ stateName ]: stateObject\n                };\n                filePath.forEach( ( pathkey, index ) => {\n                    let val = _.get( tempStateObject, pathkey );\n                    if( !isNil( val ) && !_.isEmpty( val ) ) {\n                        if( isViewModelObject( val ) ) {\n                            extractAtomicVMO();\n                        } else if( isViewModelProperty( val ) ) {\n                            vmColl[ pathkey.replace( /\\./g, '_' ) ] = val;\n                        } else if( _.isArray( val ) && isArrayOfViewModelProperty( val ) ) {\n                            extractAtomicListVMP();\n                        } else if( _.isArray( val ) ) {\n                            extractAtomicListVMo();\n                        }\n                    }\n\n                    function extractAtomicListVMo() {\n                        val.forEach( ( arrpathkey, kindex ) => {\n                            if( isViewModelObject( val[ kindex ] ) ) {\n                                _.forOwn( val[ kindex ].props, function( propValue, propName ) {\n                                    let path = pathkey + '.' + kindex + '.props.' + propName;\n                                    vmColl[ path.replace( /\\./g, '_' ) ] = propValue;\n                                } );\n                            }\n                        } );\n                    }\n\n                    function extractAtomicListVMP() {\n                        val.forEach( ( arrpathkey, kindex ) => {\n                            let path = pathkey + '.' + kindex;\n                            vmColl[ path.replace( /\\./g, '_' ) ] = val[ kindex ];\n                        } );\n                    }\n\n                    function extractAtomicVMO() {\n                        _.forOwn( val.props, function( propValue, propName ) {\n                            let path = pathkey + '.props.' + propName;\n                            vmColl[ path.replace( /\\./g, '_' ) ] = propValue;\n                        } );\n                    }\n                } );\n            }\n        } );\n    }\n    return vmColl;\n};\n\nexport const getStateCollection = ( viewModel ) => {\n    return {\n        ...filterFlatViewModelProps( viewModel.getData() ),\n        ...filterFlatViewModelPropForAtomic( viewModel )\n    };\n};\n\nexport const updateValidationSchema = ( viewModel, vmpCollRef, vmpValidationSchema, getProps, vmPropCollection ) => {\n    let schemaForValidate = {};\n    let oldVmPropCollection = vmpCollRef.current ? vmpCollRef.current.vmprop : null;\n    if( !_.isNil( oldVmPropCollection ) && !_.isNil( vmPropCollection ) ) {\n        let registeredPropNames = Object.keys( oldVmPropCollection );\n        Object.keys( vmPropCollection ).forEach( ( key ) => {\n            if( !registeredPropNames.includes( key ) || oldVmPropCollection[ key ] && vmPropCollection[ key ] && oldVmPropCollection[ key ].isRequired !== vmPropCollection[ key ].isRequired ) {\n                schemaForValidate[ key ] = vmPropCollection[ key ];\n            }\n        } );\n    } else {\n        schemaForValidate = vmPropCollection;\n    }\n    vmpCollRef.current = { vmprop: vmPropCollection, vmModel: viewModel };\n    if( !isNil( schemaForValidate ) && !_.isEmpty( schemaForValidate ) ) {\n        const { validationSchemaDef } = getValidationSchema( schemaForValidate, vmpCollRef, getProps );\n        let clubSchema = {};\n        let exitingSchema = vmpValidationSchema.current ? vmpValidationSchema.current.exitingSchema : {};\n        Object.assign( clubSchema, exitingSchema, validationSchemaDef );\n        let _validationSchema = Yup.object().shape( clubSchema );\n        vmpValidationSchema.current = { exitingSchema: clubSchema, validationSchema: _validationSchema };\n    }\n};\n\nconst isDatetimeValueInvalid = ( dateApiObj, dateOrTimeType ) => {\n    let timeVal = dateApiObj.timeValue ? dateTimeSvc.getNormalizedTimeValue( dateApiObj.timeValue ) : null;\n    let dateVal = dateApiObj.dateValue ? dateApiObj.dateValue.split( ' ' )[0] : null;\n    switch( dateOrTimeType ) {\n        case 'DATE':\n            if( dateVal && !isMatch( dateVal, dateTimeSvc.getDateFilterFormat() ) ) {\n                return true;\n            }\n            break;\n        case 'TIME':\n            if( timeVal && !isMatch( timeVal, dateTimeSvc.getTimeFilterFormat() ) ) {\n                return true;\n            }\n            break;\n        default:\n            return false;\n    }\n    return false;\n};\n\nconst validateDateTime = function() {\n    let dateApiObj = this.options.parent.dateApi;\n    if( isDatetimeValueInvalid( dateApiObj, 'DATE' ) ) {\n        return this.createError( { message: localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] ) } );\n    }\n    if( isDatetimeValueInvalid( dateApiObj, 'TIME' ) ) {\n        return this.createError( { message: localeSvc.getMessage( 'INVALID_TIME', [ dateTimeSvc.getTimeFormatPlaceholder() ] ) } );\n    }\n    return true;\n};\n\nconst getValidationSchema = function( props = {}, vmpCollRef, getProps ) {\n    let schemaInput = {};\n    for( let [ key, value ] of Object.entries( props ) ) {\n        if( value ) {\n            // build the yup propSchema for checking dbValue\n            let dbValue;\n            let type = value.type || 'none';\n            switch ( type.toUpperCase() ) {\n                case 'DATE':\n                    dbValue = Yup.string()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .test( 'date-validation', 'invalid date', validateDateTime )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );\n                        } );\n                    break;\n                case 'DATEARRAY':\n                    dbValue = Yup.string()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .test( 'date-array-validation', 'invalid date', validateDateTime )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );\n                        } );\n                    break;\n                case 'INTEGER':\n                    dbValue = Yup.number()\n                        .nullable()\n                        .min( -2147483648, 'Out of range' )\n                        .max( 2147483647, 'Out of range' )\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'INTEGERARRAY':\n                    dbValue = Yup.array().of( Yup.number()\n                        .nullable()\n                        .min( -2147483648, 'Out of range' )\n                        .max( 2147483647, 'Out of range' )\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'DOUBLE':\n                    dbValue = Yup.number()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'DOUBLEARRAY':\n                    dbValue = Yup.array().of( Yup.number()\n                        .nullable()\n                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )\n                        .typeError( ( obj ) => {\n                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );\n                        } );\n                    break;\n                case 'BOOLEAN':\n                    dbValue = Yup.boolean()\n                        .nullable();\n                    break;\n                default:\n                    dbValue = Yup.string()\n                        .nullable();\n            }\n\n            if( value.isRequired || value.isRequired === 'true' ) {\n                dbValue = dbValue.required( () => {\n                    return localeSvc.getMessage( 'PROP_REQUIRED_ERROR' );\n                } );\n            }\n\n            if( value.validationCriteria ) {\n                for( let criteria in value.validationCriteria ) {\n                    dbValue = dbValue.test( value.validationCriteria[ criteria ].condition, value.validationCriteria[ criteria ].value, function() {\n                        let conditionObj = value.validationCriteria[ criteria ].condition;\n                        let viewModel = vmpCollRef.current.vmModel;\n                        viewModel.data = viewModel.getData();\n                        let evalContext = { viewModel, props: getProps, ctx: appCtxSvc.ctx };\n                        let expression = getRealExpression( conditionObj, viewModel.declViewModelJson );\n                        // eslint-disable-next-line no-invalid-this\n                        return evaluateCondition( viewModel, expression, evalContext ) ? this.createError( {\n                            message: viewModel.data[ key ].validationCriteria[ criteria ].value,\n                            path: key\n                        } ) : true;\n                    } );\n                }\n            }\n\n            let valueToTestSchema = dbValue.test( 'propertyError', 'Error', function() {\n                // eslint-disable-next-line no-invalid-this\n                let context = this;\n                let hasError = declUtils.isNil( context.parent.error ) || context.parent.error.trim() === '';\n                return !hasError ? context.createError( {\n                    message: context.parent.error,\n                    path: key\n                } ) : true;\n            } );\n            if( [ 'DATETIME', 'DATEARRAY', 'DATE' ].includes( type.toUpperCase() ) ) {\n                schemaInput[ key ] = Yup.object().shape( { uiValue: valueToTestSchema } );\n            } else {\n                schemaInput[ key ] = Yup.object().shape( { dbValue: valueToTestSchema } );\n            }\n        }\n    }\n\n    return {\n        validationSchemaDef: schemaInput\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}