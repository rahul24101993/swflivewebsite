{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Declarative UI data provider service\n * This service performs actions to retrieve data in a paged fashion based solely on a given 'declAction' object.\n *\n * @module js/declDataProviderService\n */\nimport declDataCtxSvc from 'js/declarativeDataCtxService';\nimport appCtxSvc from 'js/appCtxService';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport actionSvc from 'js/actionService';\nimport moduleLoader from 'js/moduleLoader';\nimport AwPromiseService from 'js/awPromiseService';\nvar dataProviderTcLOV = 'TcLOV';\nvar trace = new Debug('declDataProviderService');\n/**\n * Use the 'actionService' to execute the given action and resolve the returned 'promise' with the either no object\n * or a reference to the any dependent module's API object.\n * <P>\n * Note: Any dependent module will be loaded before the action is executed.\n * <P>\n * Note: It is assumed that the action will use its 'input' and 'output' properties to move action related data into\n * or out of the dataCtxNode or declViewModel.\n *\n * @param {Object} dataCtxNode - The data context node the action is being performed within.\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n * @param {DeclAction} action - The declarative action to be executed.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n *\n * <pre>\n * {\n *     responseObj: responseObj,\n *     depModuleObj: depModuleObj\n * }\n * </pre>\n */\n\nfunction _executeAction(dataCtxNode, declViewModel, action, depModuleObj) {\n  declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, null, '_executeAction');\n  return actionSvc.executeAction(declViewModel, action, dataCtxNode, depModuleObj).then(function (responseObj) {\n    return {\n      responseObj: responseObj,\n      depModuleObj: depModuleObj\n    };\n  }).catch(function (x) {\n    trace('exception', x);\n    logger.error('exception: ' + x);\n  });\n}\n/**\n *\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *            <P>\n *            If not provided all action options are resolved solely from action's 'inputData' via the given dataCtxNode.\n *            <P>\n *            Note: The properties in this object are guaranteed to be passed to the action being invoked and that\n *            the results of that particular action invocation are returned as the resolution of the promise\n *            returned by this function. Use of the dataCtxNode for 'inputData' binding can result in mixed input vs.\n *            output results when multiple async calls are made to the same action.\n *\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n */\n\n\nfunction _executeLoadAction(declViewModel, action, dataCtxNode, dataProviderJson, actionRequestObj, depModuleObj) {\n  //new in aw4.2\n  declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, null, '_executeLoadAction');\n  var actionFinal = action;\n\n  if (actionRequestObj) {\n    actionFinal = _prepareActionAltInputData(dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj);\n  }\n\n  return _executeAction(dataCtxNode, declViewModel, actionFinal, depModuleObj).then(function (actionResultObj) {\n    // revisitme - somehow in the long SOA case like search, the dataCtxNode.data is not equal to declViewModel\n    // anymore which is cause side effect - will investigate later\n    dataCtxNode.data.totalFound = declViewModel.totalFound;\n    dataCtxNode.data.searchResults = declViewModel.searchResults;\n    return _postProcessAction(dataCtxNode, dataCtxNode.data, dataProviderJson, actionResultObj);\n  }, function (rejectObj) {\n    return AwPromiseService.instance.reject(rejectObj);\n  });\n}\n/**\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {DeclViewModel} declViewModel - The view model the action is defined within.\n * @param {Object} dataProviderJson - The original JSON definition of the declDataProvider.\n * @param {Object} actionResultObj - The resolved response object from executing the action.\n *\n * @return {Promise} A Promise object resolved with the processed result of the action. The result contains updated\n *         values for all the properties in the given 'dataProviderJson' object.\n */\n\n\nfunction _postProcessAction(dataCtxNode, declViewModel, dataProviderJson, actionResultObj) {\n  var responseObj;\n\n  if (dataProviderJson && declUtils.isValidModelAndDataCtxNode(declViewModel, dataCtxNode)) {\n    let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n    var dpResult = _.cloneDeep(dataProviderJson); // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n    // Fix cucumber 'Record Utilization Declarative Panel': depModuleObj is needed for all {{function:}}\n\n\n    var depModuleObj = actionResultObj && actionResultObj.depModuleObj ? actionResultObj.depModuleObj : null;\n    /**\n     * Check if the dataCtxNode we need has been destroyed (due to DOM manipulation) since the action event\n     * processing was started.\n     */\n\n    var localDataCtx = declUtils.resolveLocalDataCtx(localContext.data, localContext);\n    /**\n     * Resolve any other data 'from' the declViewModel and/or dataCtxNode\n     */\n\n    declDataCtxSvc.applyScope(localContext.data, dpResult, declViewModel._internal.functions, localDataCtx, depModuleObj);\n\n    if (actionResultObj) {\n      _.forEach(dpResult, function (fromPath, toPath) {\n        /**\n         * If fromPath has a 'result.' prefix, parse the expression within fromPath to get the correct\n         * value.\n         */\n        if (_.isString(fromPath) && /^action\\.result\\./.test(fromPath)) {\n          var fromResultPath = fromPath.split('action.result.')[1];\n\n          var fromObj = _.get(actionResultObj.responseObj, fromResultPath);\n\n          _.set(dpResult, toPath, fromObj);\n        }\n      });\n    }\n    /**\n     * Build the response object from the updated (i.e. data bound) properties in the declDataProvider's JSON\n     * definition.\n     */\n\n\n    responseObj = {\n      actionResultObj: actionResultObj\n    };\n\n    _.forEach(dpResult, function (value, name) {\n      if (name === 'action') {\n        return;\n      }\n      /**\n       * Handle special case of a mapping to a different property name (e.g. 'response' to 'result').\n       */\n\n\n      if (name === 'response') {\n        responseObj.results = value;\n      } else if (/^ctx\\./.test(name)) {\n        /**\n         * If the name starts with ctx. update the appCtxService\n         */\n        var toCtxName = name.split('ctx.')[1];\n        appCtxSvc.updatePartialCtx(toCtxName, value);\n      } else {\n        responseObj[name] = value;\n      }\n    });\n    /**\n     * Make sure the 'totalFound' is set if we had any data returned.\n     */\n\n\n    if (responseObj.results && _.isUndefined(responseObj.totalFound)) {\n      responseObj.totalFound = responseObj.results.length;\n    }\n  }\n\n  return AwPromiseService.instance.resolve(responseObj);\n}\n/**\n * @param {Object} inputData - Input properties from JSON.\n * @param {Object} altInputData - Input properties to use.\n * @param {Object} actionRequestObj - Object from action to use.\n */\n\n\nfunction _applyActionRequestObject(inputData, altInputData, actionRequestObj) {\n  /**\n   * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n   */\n  _.forEach(inputData, function (fromPath, toPath) {\n    if (_.isString(fromPath)) {\n      if (/^request\\./.test(fromPath)) {\n        var fromRequestPath = fromPath.split('request.')[1];\n\n        var fromObj = _.get(actionRequestObj, fromRequestPath);\n\n        _.set(altInputData, toPath, fromObj);\n      }\n    } else {\n      _applyActionRequestObject(fromPath, altInputData[toPath], actionRequestObj);\n    }\n  });\n} // _applyActionRequestObject\n\n/**\n * Note 1: Multiple async load requests can be made before any given one completes. So we cannot put action-related\n * objects on the dataCtxNode since the dataCtxNode may change before the original dataCtxNode is applied to the action the objects\n * were ment for.\n * <P>\n * To address this, the dataCtxNode will be applied to the 'inputData' of a clone of the action NOW. This clone (and the\n * now static 'inputData' objects) will be passed to the actionService which will use this 'altInputData' as-is\n * without trying to apply the dataCtxNode to it again.\n * <P>\n * Note 2: The post processing of the action results do not have this problem since a new 'outputData' object is\n * created and passed back through the 'promise chain' in a more synchronous fashion. So any output data placed on\n * the dataCtxNode is not there long enough to be overwritten by another action completing before it.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n\n *\n * @returns {DeclAction} Action object to actually use.\n */\n\n\nfunction _prepareActionAltInputData(dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj) {\n  var actionFinal = action;\n\n  if (action.inputData) {\n    /**\n     * Make copied of the 'action' and 'inputData' objects (to keep the originals safe from modification)\n     */\n    actionFinal = _.cloneDeep(action);\n    actionFinal.altInputData = _.cloneDeep(action.inputData); // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n    // The actonRequestObj, which may be a very complex structure, can be applied after applyScope\n\n    declDataCtxSvc.applyScope(declViewModel, actionFinal.altInputData, declViewModel._internal.functions, dataCtxNode, depModuleObj);\n    /**\n     * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n     */\n\n    _applyActionRequestObject(actionFinal.inputData, actionFinal.altInputData, actionRequestObj);\n  }\n\n  return actionFinal;\n} // _prepareActionAltInputData\n\n/**\n * --------------------------------------------------------------------------<BR>\n * Define external API<BR>\n * --------------------------------------------------------------------------<BR>\n */\n\n\nvar exports = {};\n/**\n * validate the LOV sections using the function in the lovService\n *\n * @param {array} lovEntries - The 'lovEntries' to update.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @return {Promise} A promise object. validateLOVValueSelections\n */\n\nexport let validateLOVSelection = function (_ref, dataCtxNode, action, dataProviderJson) {\n  let {\n    lovEntries,\n    vmo,\n    viewModelProp\n  } = _ref;\n\n  //let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n  // if( dataProviderJson.dataProviderType && dataProviderJson.dataProviderType === dataProviderTcLOV ) {\n  //     declDataCtxSvc.applyScope( declViewModel, dataProviderJson, null, dataCtxNode, null );\n  //     var lovConfig = dataProviderJson.lovConfiguration;\n  //     var viewModelObj = lovConfig.viewModelObj;\n  //     var viewProp = lovConfig.viewProp;\n  //     var operationName = lovConfig.operationName;\n  //     return lovService.validateLOVValueSelections( lovEntries, viewProp, operationName, viewModelObj );\n  // }\n  if (action && viewModelProp) {\n    let actionRequestObj = {\n      selected: lovEntries,\n      suggestion: viewModelProp.filterString,\n      vmo,\n      vmProp: viewModelProp\n    };\n    return validateSelections(action, dataProviderJson, dataCtxNode, actionRequestObj).then(resp => {\n      let response;\n\n      if (resp.actionResultObj && resp.actionResultObj.responseObj) {\n        response = resp.actionResultObj.responseObj;\n\n        if (!response.valid) {\n          return Promise.reject(response);\n        }\n\n        return Promise.resolve(response);\n      } else if (!resp.valid) {\n        resp.cause = {\n          partialErrors: true\n        };\n        return Promise.reject(resp);\n      }\n\n      return resp;\n    });\n  }\n\n  return Promise.resolve({\n    valid: true\n  });\n};\n/**\n * Validate the LOV selections using the function in the dataProvider.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} lovScope - The context in which to evaluate any conditions/bindings.\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object.\n */\n\nexport let validateSelections = function (action, dataProviderJson, lovScope, actionRequestObj) {\n  return exports.executeLoadAction(action, dataProviderJson, lovScope, actionRequestObj);\n};\n/**\n * Execute the given action and return results in the async resolution.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's JSON object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the results (IModelObject, ViewModelObjects, etc.) of the given\n *         action.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n */\n\nexport let executeLoadAction = function (action, dataProviderJson, dataCtxNode, actionRequestObj) {\n  // if( !action ) {\n  //     logger.error( 'Invalid action specified' );\n  // }\n  let declViewModel = declUtils.findViewModel(dataCtxNode, true, appCtxSvc); // add update To latestHere ...\n\n  let localContext = declUtils.getLatestContext(dataCtxNode, declViewModel);\n\n  if (!declUtils.isNil(action)) {\n    /**\n     * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n     */\n    declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (a)'); // Get Function deps\n\n    var functionDeps = declUtils.getFunctionDeps(action, declViewModel._internal);\n\n    if (!_.isEmpty(action.deps)) {\n      return moduleLoader.loadDependentModule(action.deps).then(function (depModuleObj) {\n        //new in aw4.2\n        declUtils.assertValidModelDataCtxNodeAndAction2(declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (b)'); // Load function.deps\n        //\n        // Note: Even if the list of 'functionDeps' is empty we need to execute the async load since some\n        // code (breadcrumbs) needs the extra digest cycle (or two). This is odd since the same 'empty'\n        // check later in this function seems to work ok.\n        //\n\n        return moduleLoader.loadDependentModules(functionDeps).then(function (depFunctionObj) {\n          _.forEach(depFunctionObj, function (depFuncValue, depFuncKey) {\n            depModuleObj[depFuncKey] = depFuncValue;\n          });\n\n          var localScope = declUtils.resolveLocalDataCtx(localContext.data, localContext);\n          return _executeLoadAction(localContext.data, action, localScope, dataProviderJson, actionRequestObj, depModuleObj);\n        });\n      });\n    }\n\n    if (!_.isEmpty(functionDeps)) {\n      // Load function.deps\n      return moduleLoader.loadDependentModules(functionDeps).then(function (depFunctionObj) {\n        var localScope = declUtils.resolveLocalDataCtx(localContext.data, localContext);\n        return _executeLoadAction(localContext.data, action, localScope, dataProviderJson, actionRequestObj, depFunctionObj);\n      });\n    }\n\n    return _executeLoadAction(localContext.data, action, localContext, dataProviderJson, actionRequestObj, null);\n  } //let localScope = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );\n\n\n  return _postProcessAction(localContext, localContext.data, dataProviderJson, null);\n};\n/**\n * Get first page of results\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n *\n */\n\nexport let getFirstPage = function (action, dataProviderJson, dataCtxNode, actionRequestObj) {\n  if (action) {\n    return exports.executeLoadAction(action, dataProviderJson, dataCtxNode, actionRequestObj);\n  }\n  /**\n   * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n   */\n\n\n  var declViewModel = declUtils.findViewModel(dataCtxNode, true, appCtxSvc);\n  declUtils.assertValidModelAndDataCtxNode(declViewModel, dataCtxNode);\n  /**\n   * Support for binding dataProvider's response to a static list, when action is not provided.\n   */\n\n  return _postProcessAction(dataCtxNode, declViewModel, dataProviderJson, null);\n};\n/**\n * Get next page of results\n *\n * @param {DeclAction} action - The 'declAction' to perform.\n *\n * @param {Object} dataProviderJson - data provider json object\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n */\n\nexport let getNextPage = function (action, dataProviderJson, dataCtxNode, actionRequestObj) {\n  if (action) {\n    return exports.executeLoadAction(action, dataProviderJson, dataCtxNode, actionRequestObj);\n  }\n  /**\n   * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n   */\n\n\n  var declViewModel = declUtils.findViewModel(dataCtxNode, true, appCtxSvc);\n  declUtils.assertValidModelAndDataCtxNode(declViewModel, dataCtxNode);\n  /**\n   * Support for binding dataProvider's response to a static list, when action is not provided.\n   */\n\n  return _postProcessAction(dataCtxNode, declViewModel, dataProviderJson, null);\n};\nexports = {\n  validateLOVSelection,\n  validateSelections,\n  executeLoadAction,\n  getFirstPage,\n  getNextPage\n};\nexport default exports;","map":{"version":3,"names":["declDataCtxSvc","appCtxSvc","_","logger","Debug","declUtils","actionSvc","moduleLoader","AwPromiseService","dataProviderTcLOV","trace","_executeAction","dataCtxNode","declViewModel","action","depModuleObj","assertValidModelDataCtxNodeAndAction2","executeAction","then","responseObj","catch","x","error","_executeLoadAction","dataProviderJson","actionRequestObj","actionFinal","_prepareActionAltInputData","actionResultObj","data","totalFound","searchResults","_postProcessAction","rejectObj","instance","reject","isValidModelAndDataCtxNode","localContext","getLatestContext","dpResult","cloneDeep","localDataCtx","resolveLocalDataCtx","applyScope","_internal","functions","forEach","fromPath","toPath","isString","test","fromResultPath","split","fromObj","get","set","value","name","results","toCtxName","updatePartialCtx","isUndefined","length","resolve","_applyActionRequestObject","inputData","altInputData","fromRequestPath","exports","validateLOVSelection","lovEntries","vmo","viewModelProp","selected","suggestion","filterString","vmProp","validateSelections","resp","response","valid","Promise","cause","partialErrors","lovScope","executeLoadAction","findViewModel","isNil","functionDeps","getFunctionDeps","isEmpty","deps","loadDependentModule","loadDependentModules","depFunctionObj","depFuncValue","depFuncKey","localScope","getFirstPage","assertValidModelAndDataCtxNode","getNextPage"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/declDataProviderService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Declarative UI data provider service\n * This service performs actions to retrieve data in a paged fashion based solely on a given 'declAction' object.\n *\n * @module js/declDataProviderService\n */\nimport declDataCtxSvc from 'js/declarativeDataCtxService';\nimport appCtxSvc from 'js/appCtxService';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nimport declUtils from 'js/declUtils';\nimport actionSvc from 'js/actionService';\nimport moduleLoader from 'js/moduleLoader';\nimport AwPromiseService from 'js/awPromiseService';\n\nvar dataProviderTcLOV = 'TcLOV';\n\nvar trace = new Debug( 'declDataProviderService' );\n\n/**\n * Use the 'actionService' to execute the given action and resolve the returned 'promise' with the either no object\n * or a reference to the any dependent module's API object.\n * <P>\n * Note: Any dependent module will be loaded before the action is executed.\n * <P>\n * Note: It is assumed that the action will use its 'input' and 'output' properties to move action related data into\n * or out of the dataCtxNode or declViewModel.\n *\n * @param {Object} dataCtxNode - The data context node the action is being performed within.\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n * @param {DeclAction} action - The declarative action to be executed.\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n *\n * <pre>\n * {\n *     responseObj: responseObj,\n *     depModuleObj: depModuleObj\n * }\n * </pre>\n */\nfunction _executeAction( dataCtxNode, declViewModel, action, depModuleObj ) {\n    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, '_executeAction' );\n    return actionSvc.executeAction( declViewModel, action, dataCtxNode, depModuleObj ).then( function( responseObj ) {\n        return {\n            responseObj: responseObj,\n            depModuleObj: depModuleObj\n        };\n    } ).catch( function( x ) {\n        trace( 'exception', x );\n        logger.error( 'exception: ' + x );\n    } );\n}\n\n/**\n *\n * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *            <P>\n *            If not provided all action options are resolved solely from action's 'inputData' via the given dataCtxNode.\n *            <P>\n *            Note: The properties in this object are guaranteed to be passed to the action being invoked and that\n *            the results of that particular action invocation are returned as the resolution of the promise\n *            returned by this function. Use of the dataCtxNode for 'inputData' binding can result in mixed input vs.\n *            output results when multiple async calls are made to the same action.\n *\n * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the\n *            execution.\n *\n * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:\n */\nfunction _executeLoadAction( declViewModel, action, dataCtxNode, dataProviderJson, actionRequestObj, depModuleObj ) {\n    //new in aw4.2\n    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, '_executeLoadAction' );\n\n    var actionFinal = action;\n\n    if( actionRequestObj ) {\n        actionFinal = _prepareActionAltInputData( dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj );\n    }\n\n    return _executeAction( dataCtxNode, declViewModel, actionFinal, depModuleObj ).then( function( actionResultObj ) {\n        // revisitme - somehow in the long SOA case like search, the dataCtxNode.data is not equal to declViewModel\n        // anymore which is cause side effect - will investigate later\n        dataCtxNode.data.totalFound = declViewModel.totalFound;\n        dataCtxNode.data.searchResults = declViewModel.searchResults;\n        return _postProcessAction( dataCtxNode, dataCtxNode.data, dataProviderJson, actionResultObj );\n    }, function( rejectObj ) {\n        return AwPromiseService.instance.reject( rejectObj );\n    } );\n}\n\n/**\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n * @param {DeclViewModel} declViewModel - The view model the action is defined within.\n * @param {Object} dataProviderJson - The original JSON definition of the declDataProvider.\n * @param {Object} actionResultObj - The resolved response object from executing the action.\n *\n * @return {Promise} A Promise object resolved with the processed result of the action. The result contains updated\n *         values for all the properties in the given 'dataProviderJson' object.\n */\nfunction _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, actionResultObj ) {\n    var responseObj;\n\n    if( dataProviderJson && declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {\n        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n        var dpResult = _.cloneDeep( dataProviderJson );\n\n        // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n        // Fix cucumber 'Record Utilization Declarative Panel': depModuleObj is needed for all {{function:}}\n        var depModuleObj = actionResultObj && actionResultObj.depModuleObj ? actionResultObj.depModuleObj : null;\n\n        /**\n         * Check if the dataCtxNode we need has been destroyed (due to DOM manipulation) since the action event\n         * processing was started.\n         */\n        var localDataCtx = declUtils.resolveLocalDataCtx( localContext.data, localContext );\n\n        /**\n         * Resolve any other data 'from' the declViewModel and/or dataCtxNode\n         */\n        declDataCtxSvc.applyScope( localContext.data, dpResult, declViewModel._internal.functions, localDataCtx,\n            depModuleObj );\n\n        if( actionResultObj ) {\n            _.forEach( dpResult, function( fromPath, toPath ) {\n                /**\n                 * If fromPath has a 'result.' prefix, parse the expression within fromPath to get the correct\n                 * value.\n                 */\n                if( _.isString( fromPath ) && /^action\\.result\\./.test( fromPath ) ) {\n                    var fromResultPath = fromPath.split( 'action.result.' )[ 1 ];\n\n                    var fromObj = _.get( actionResultObj.responseObj, fromResultPath );\n\n                    _.set( dpResult, toPath, fromObj );\n                }\n            } );\n        }\n\n        /**\n         * Build the response object from the updated (i.e. data bound) properties in the declDataProvider's JSON\n         * definition.\n         */\n        responseObj = {\n            actionResultObj: actionResultObj\n        };\n\n        _.forEach( dpResult, function( value, name ) {\n            if( name === 'action' ) {\n                return;\n            }\n\n            /**\n             * Handle special case of a mapping to a different property name (e.g. 'response' to 'result').\n             */\n            if( name === 'response' ) {\n                responseObj.results = value;\n            } else if( /^ctx\\./.test( name ) ) {\n                /**\n                 * If the name starts with ctx. update the appCtxService\n                 */\n                var toCtxName = name.split( 'ctx.' )[ 1 ];\n                appCtxSvc.updatePartialCtx( toCtxName, value );\n            } else {\n                responseObj[ name ] = value;\n            }\n        } );\n\n        /**\n         * Make sure the 'totalFound' is set if we had any data returned.\n         */\n        if( responseObj.results && _.isUndefined( responseObj.totalFound ) ) {\n            responseObj.totalFound = responseObj.results.length;\n        }\n    }\n\n    return AwPromiseService.instance.resolve( responseObj );\n}\n\n/**\n * @param {Object} inputData - Input properties from JSON.\n * @param {Object} altInputData - Input properties to use.\n * @param {Object} actionRequestObj - Object from action to use.\n */\nfunction _applyActionRequestObject( inputData, altInputData, actionRequestObj ) {\n    /**\n     * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n     */\n    _.forEach( inputData, function( fromPath, toPath ) {\n        if( _.isString( fromPath ) ) {\n            if( /^request\\./.test( fromPath ) ) {\n                var fromRequestPath = fromPath.split( 'request.' )[ 1 ];\n\n                var fromObj = _.get( actionRequestObj, fromRequestPath );\n\n                _.set( altInputData, toPath, fromObj );\n            }\n        } else {\n            _applyActionRequestObject( fromPath, altInputData[ toPath ], actionRequestObj );\n        }\n    } );\n} // _applyActionRequestObject\n\n/**\n * Note 1: Multiple async load requests can be made before any given one completes. So we cannot put action-related\n * objects on the dataCtxNode since the dataCtxNode may change before the original dataCtxNode is applied to the action the objects\n * were ment for.\n * <P>\n * To address this, the dataCtxNode will be applied to the 'inputData' of a clone of the action NOW. This clone (and the\n * now static 'inputData' objects) will be passed to the actionService which will use this 'altInputData' as-is\n * without trying to apply the dataCtxNode to it again.\n * <P>\n * Note 2: The post processing of the action results do not have this problem since a new 'outputData' object is\n * created and passed back through the 'promise chain' in a more synchronous fashion. So any output data placed on\n * the dataCtxNode is not there long enough to be overwritten by another action completing before it.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be\n *            called (action.deps).\n\n *\n * @returns {DeclAction} Action object to actually use.\n */\nfunction _prepareActionAltInputData( dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj ) {\n    var actionFinal = action;\n\n    if( action.inputData ) {\n        /**\n         * Make copied of the 'action' and 'inputData' objects (to keep the originals safe from modification)\n         */\n        actionFinal = _.cloneDeep( action );\n\n        actionFinal.altInputData = _.cloneDeep( action.inputData );\n\n        // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes\n        // The actonRequestObj, which may be a very complex structure, can be applied after applyScope\n        declDataCtxSvc.applyScope( declViewModel, actionFinal.altInputData, declViewModel._internal.functions,\n            dataCtxNode, depModuleObj );\n\n        /**\n         * Put the specific action's request values on the 'atInputData' of the action's inputData clone.\n         */\n        _applyActionRequestObject( actionFinal.inputData, actionFinal.altInputData, actionRequestObj );\n    }\n\n    return actionFinal;\n} // _prepareActionAltInputData\n\n/**\n * --------------------------------------------------------------------------<BR>\n * Define external API<BR>\n * --------------------------------------------------------------------------<BR>\n */\n\nvar exports = {};\n\n/**\n * validate the LOV sections using the function in the lovService\n *\n * @param {array} lovEntries - The 'lovEntries' to update.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @return {Promise} A promise object. validateLOVValueSelections\n */\nexport let validateLOVSelection = function( { lovEntries, vmo, viewModelProp }, dataCtxNode, action, dataProviderJson ) {\n    //let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n    // if( dataProviderJson.dataProviderType && dataProviderJson.dataProviderType === dataProviderTcLOV ) {\n    //     declDataCtxSvc.applyScope( declViewModel, dataProviderJson, null, dataCtxNode, null );\n    //     var lovConfig = dataProviderJson.lovConfiguration;\n    //     var viewModelObj = lovConfig.viewModelObj;\n    //     var viewProp = lovConfig.viewProp;\n    //     var operationName = lovConfig.operationName;\n    //     return lovService.validateLOVValueSelections( lovEntries, viewProp, operationName, viewModelObj );\n    // }\n    if( action && viewModelProp ) {\n        let actionRequestObj = {\n            selected: lovEntries,\n            suggestion: viewModelProp.filterString,\n            vmo,\n            vmProp: viewModelProp\n        };\n        return validateSelections( action, dataProviderJson, dataCtxNode, actionRequestObj ).then( ( resp ) => {\n            let response;\n            if( resp.actionResultObj && resp.actionResultObj.responseObj ) {\n                response = resp.actionResultObj.responseObj;\n                if( !response.valid ) {\n                    return Promise.reject( response );\n                }\n                return Promise.resolve( response );\n            } else if( !resp.valid ) {\n                resp.cause = { partialErrors: true };\n                return Promise.reject( resp );\n            }\n\n            return resp;\n        } );\n    }\n    return Promise.resolve( { valid: true } );\n};\n\n/**\n * Validate the LOV selections using the function in the dataProvider.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n * @param {Object} dataProviderJson - data provider json object\n * @param {Object} lovScope - The context in which to evaluate any conditions/bindings.\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object.\n */\nexport let validateSelections = function( action, dataProviderJson, lovScope, actionRequestObj ) {\n    return exports.executeLoadAction( action, dataProviderJson, lovScope, actionRequestObj );\n};\n\n/**\n * Execute the given action and return results in the async resolution.\n *\n * @param {DeclAction} action - The 'declAction' object to use.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's JSON object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the results (IModelObject, ViewModelObjects, etc.) of the given\n *         action.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n */\nexport let executeLoadAction = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {\n    // if( !action ) {\n    //     logger.error( 'Invalid action specified' );\n    // }\n\n    let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n    // add update To latestHere ...\n    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );\n    if( !declUtils.isNil( action ) ) {\n        /**\n         * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n         */\n        declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (a)' );\n        // Get Function deps\n        var functionDeps = declUtils.getFunctionDeps( action, declViewModel._internal );\n        if( !_.isEmpty( action.deps ) ) {\n            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObj ) {\n                //new in aw4.2\n                declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (b)' );\n\n                // Load function.deps\n                //\n                // Note: Even if the list of 'functionDeps' is empty we need to execute the async load since some\n                // code (breadcrumbs) needs the extra digest cycle (or two). This is odd since the same 'empty'\n                // check later in this function seems to work ok.\n                //\n                return moduleLoader.loadDependentModules( functionDeps ).then( function( depFunctionObj ) {\n                    _.forEach( depFunctionObj, function( depFuncValue, depFuncKey ) {\n                        depModuleObj[ depFuncKey ] = depFuncValue;\n                    } );\n\n                    var localScope = declUtils.resolveLocalDataCtx( localContext.data, localContext );\n\n                    return _executeLoadAction( localContext.data, action, localScope, dataProviderJson, actionRequestObj,\n                        depModuleObj );\n                } );\n            } );\n        }\n\n        if( !_.isEmpty( functionDeps ) ) {\n            // Load function.deps\n            return moduleLoader.loadDependentModules( functionDeps ).then( function( depFunctionObj ) {\n                var localScope = declUtils.resolveLocalDataCtx( localContext.data, localContext );\n\n                return _executeLoadAction( localContext.data, action, localScope, dataProviderJson, actionRequestObj, depFunctionObj );\n            } );\n        }\n        return _executeLoadAction( localContext.data, action, localContext, dataProviderJson, actionRequestObj, null );\n    }\n    //let localScope = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );\n    return _postProcessAction( localContext, localContext.data, dataProviderJson, null );\n};\n\n/**\n * Get first page of results\n *\n * @param {DeclAction} action - The 'declAction' object to use to get the page data.\n *\n * @param {dataProviderJson} dataProviderJson - The data provider's json object.\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n *\n * <pre>\n * If NOT LOV:\n * {Number} totalFound -\n * {Object} results -\n *\n * If LOV:\n * {Object}\n * </pre>\n *\n */\nexport let getFirstPage = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {\n    if( action ) {\n        return exports.executeLoadAction( action, dataProviderJson, dataCtxNode, actionRequestObj );\n    }\n\n    /**\n     * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n     */\n    var declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n\n    declUtils.assertValidModelAndDataCtxNode( declViewModel, dataCtxNode );\n\n\n    /**\n     * Support for binding dataProvider's response to a static list, when action is not provided.\n     */\n    return _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, null );\n};\n\n/**\n * Get next page of results\n *\n * @param {DeclAction} action - The 'declAction' to perform.\n *\n * @param {Object} dataProviderJson - data provider json object\n *\n * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.\n *\n * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options\n *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the\n *            action's 'inputData' (e.g. \"myActionParam1\": \"request.listLoadInput\" where 'listLoadInput' is a\n *            parameter on the 'actionRequestObj' object)\n *\n * @return {Promise} A promise object resolved with the IModelObject results of this operation.\n */\nexport let getNextPage = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {\n    if( action ) {\n        return exports.executeLoadAction( action, dataProviderJson, dataCtxNode, actionRequestObj );\n    }\n\n    /**\n     * Execute the action within the context of the DeclViewModel on the dataCtxNode.\n     */\n    var declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );\n\n    declUtils.assertValidModelAndDataCtxNode( declViewModel, dataCtxNode );\n\n\n    /**\n     * Support for binding dataProvider's response to a static list, when action is not provided.\n     */\n    return _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, null );\n};\n\nexports = {\n    validateLOVSelection,\n    validateSelections,\n    executeLoadAction,\n    getFirstPage,\n    getNextPage\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}