{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the keyboard interactions for PL Table.\n *\n * @module js/splmTableKeyboardService\n */\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport wcagService from 'js/wcagService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n/**\n * Keyboard service to handle keyboard interactions for aw-splm-table\n * @param {HTMLElement} tableElem The table element\n * @param {SPLMTableEditor} tableEditor The table editor\n */\n\nconst SPLMTableKeyboardService = function (tableElem, tableEditor) {\n  let self = this;\n  let _tableElement = tableElem;\n  let _tableEditor = tableEditor;\n\n  let _tableInstance = util.getTableInstance(_tableElement);\n\n  let _trv = new Trv(tableElem);\n\n  const dataIndexNumber = 'data-indexNumber';\n  /**\n   * Prevents default and stops propagation for event\n   * @param {Event} event the event\n   */\n\n  const preventEventDefaults = function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n  /**\n   * Checks if key pressed is an arrow key\n   * @param {String} keyPressed the pressed key to check\n   * @returns {String|null} the direction if arrow key, or null if not\n   */\n\n\n  const checkIfArrowKey = function (keyPressed) {\n    switch (keyPressed) {\n      case 'Up':\n      case 'ArrowUp':\n        return 'UP';\n\n      case 'Down':\n      case 'ArrowDown':\n        return 'DOWN';\n\n      case 'Left':\n      case 'ArrowLeft':\n        return 'LEFT';\n\n      case 'Right':\n      case 'ArrowRight':\n        return 'RIGHT';\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Function for handling onfocus event\n   * @param {Event} event event data\n   */\n\n\n  const onFocusFunction = function (event) {\n    event.target.tabIndex = '0';\n  };\n  /**\n   * Function for handling onblur event\n   * @param {Event} event eventData\n   */\n\n\n  const onBlurFunction = function (event) {\n    event.target.tabIndex = '-1';\n  };\n  /**\n   * Sets focus and blur event listeners to passed element\n   * @param {HTMLElement} element Element to set focus and blur events for\n   */\n\n\n  self.setOnFocusAndBlur = function (element) {\n    element.addEventListener('focus', onFocusFunction);\n    element.addEventListener('blur', onBlurFunction);\n  };\n  /**\n   * Checks if passed element is a header element\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is a header element\n   */\n\n\n  const isHeaderElement = function (element) {\n    return element.classList.contains(Const.CLASS_HEADER_CELL);\n  };\n  /**\n   * Checks if passed element is a cell element\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is a cell element\n   */\n\n\n  const isCellElement = function (element) {\n    return element.classList.contains(Const.CLASS_CELL);\n  };\n  /**\n   * Checks if passed element is the table container\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is table container\n   */\n\n\n  const isTableContainer = function (element) {\n    return element.classList.contains(Const.CLASS_TABLE_CONTAINER);\n  };\n  /**\n   * Checks if passed element is the grid options button\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is grid options button\n   */\n\n\n  const isGridOptionsButton = function (element) {\n    return util.closestElement(element, `.${Const.CLASS_TABLE_MENU_BUTTON}`);\n  };\n\n  const hasFocusableElements = function (element) {\n    return wcagService.findFocusableChildren(element).length > 0;\n  };\n  /**\n   * Focus' the grid options button for table\n   */\n\n\n  const focusGridOptionsButton = function () {\n    const gridMenuButton = _tableElement.querySelector(`.${Const.CLASS_TABLE_MENU_BUTTON} button`);\n\n    gridMenuButton.focus();\n  };\n  /**\n   * Gets the visible column defs for the table\n   * @returns {AwTableColumnInfo[]} Array of visible column defs\n   */\n\n\n  const getColumnDefs = function () {\n    let colDefs;\n\n    if (_tableInstance.gridOptions.transpose) {\n      colDefs = _tableInstance.controller.getColumnDefs();\n    } else {\n      colDefs = _tableInstance.dataProvider.cols;\n      colDefs = colDefs.filter(function (colDef) {\n        return colDef.hiddenFlag !== true;\n      });\n    }\n\n    return colDefs;\n  };\n  /**\n   * Calculates the scrollLeft for when focusing an element in the scroll container when navigating left or right\n   *\n   * @param {HTMLElement} currentElem The currently focused cell\n   * @param {Number} currentRowIdx The current focused element's aria-rowindex\n   * @param {Number} currentColIdx The current focused element aria-colindex\n   * @param {Number} nextColIdx The next column index that will be focused\n   * @returns {Number} Returns the scrollLeft value if a change is needed, or null if no need to set.\n   */\n\n\n  const calculateScrollLeft = function (currentElem, currentRowIdx, currentColIdx, nextColIdx) {\n    const colDefs = getColumnDefs();\n    let currentDef = currentElem.columnDef || currentElem.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n    let defIndex = colDefs.indexOf(currentDef);\n    let scrollLeft = null;\n    let nextDef = colDefs[defIndex + (nextColIdx - currentColIdx)];\n\n    if (currentDef && nextDef && currentDef.pinnedLeft && !nextDef.pinnedLeft) {\n      // set scrollLeft to 0\n      scrollLeft = 0;\n    } else if (currentRowIdx === 1 && nextDef && !nextDef.pinnedLeft) {\n      scrollLeft = nextDef.startPosition;\n    }\n\n    return scrollLeft;\n  };\n\n  const getNewRowAndColumnIndex = (currentElem, direction, colDefs, currentRowIdx, numberOfRows) => {\n    let newIndexes = {\n      newRowIdx: null,\n      newColIdx: null,\n      scrollLeft: null\n    };\n\n    if (!currentElem) {\n      // No current element provided, focus very first header cell\n      newIndexes.newColIdx = 1;\n      newIndexes.newRowIdx = 1;\n      return newIndexes;\n    } else if (isGridOptionsButton(currentElem)) {\n      if (direction === 'LEFT') {\n        newIndexes.newColIdx = colDefs.length;\n        newIndexes.newRowIdx = 1;\n      } else if (direction === 'DOWN') {\n        newIndexes.newRowIdx = 2;\n        newIndexes.newColIdx = colDefs.length;\n        newIndexes.scrollLeft = colDefs[colDefs.length - 1].startPosition;\n      }\n\n      return newIndexes;\n    }\n\n    const currentColIdx = parseInt(currentElem.getAttribute('aria-colindex'));\n\n    switch (direction) {\n      case 'UP':\n        if (currentRowIdx <= 1) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx;\n        newIndexes.newRowIdx = currentRowIdx - 1;\n        break;\n\n      case 'DOWN':\n        // row index starts at 1\n        if (currentRowIdx >= numberOfRows) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx;\n        newIndexes.newRowIdx = currentRowIdx + 1;\n        break;\n\n      case 'LEFT':\n        if (currentColIdx <= 1) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx - 1;\n        newIndexes.newRowIdx = currentRowIdx;\n        break;\n\n      case 'RIGHT':\n        // index for aria-colindex starts at 1\n        if (currentColIdx >= colDefs.length) {\n          if (isHeaderElement(currentElem)) {\n            focusGridOptionsButton();\n          }\n\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx + 1;\n        newIndexes.newRowIdx = currentRowIdx;\n        break;\n\n      default:\n        break;\n    } // Set scrollLeft as needed\n\n\n    if (newIndexes.newColIdx !== currentColIdx) {\n      newIndexes.scrollLeft = calculateScrollLeft(currentElem, currentRowIdx, currentColIdx, newIndexes.newColIdx);\n    }\n\n    return newIndexes;\n  };\n  /**\n   * Handles the cell navigation in table. If no element provided, focuses the first header cell. Otherwise\n   * handles navigation based on current element and direction passed\n   * @param {HTMLElement} currentElem The currently focused element\n   * @param {String} direction The direction to navigate - UP, DOWN, LEFT, or RIGHT\n   */\n\n\n  const handleCellNavigation = (currentElem, direction) => {\n    const colDefs = getColumnDefs();\n    let numberOfRows;\n\n    if (_tableInstance.gridOptions.transpose) {\n      numberOfRows = _tableInstance.dataProvider.cols.length + 1;\n    } else {\n      numberOfRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length + 1;\n    }\n\n    const currentRowIdx = currentElem ? parseInt(currentElem.parentElement.getAttribute('aria-rowindex')) : null;\n    const newIndexes = getNewRowAndColumnIndex(currentElem, direction, colDefs, currentRowIdx, numberOfRows);\n\n    if (!newIndexes) {\n      return;\n    }\n\n    const newRowIdx = newIndexes.newRowIdx;\n    const newColIdx = newIndexes.newColIdx;\n    const scrollLeft = newIndexes.scrollLeft;\n\n    let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n    let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n\n    if (currentRowIdx === 1 && newRowIdx === 2) {\n      // Going from header row to first row, need to set scroll top to 0\n      viewport.scrollTop = 0;\n    }\n\n    if (scrollLeft !== null) {\n      viewport.scrollLeft = scrollLeft;\n    } // Find the correct next element to focus\n\n\n    setTimeout(function () {\n      let queryString = `[aria-rowindex='${newRowIdx}'] [aria-colindex='${newColIdx}']`;\n\n      let element = _tableElement.querySelector(queryString);\n\n      if (element) {\n        element.focus();\n      }\n    }, 100);\n  };\n  /**\n   * Focuses the first or last cell in a given row/header row\n   * @param {HTMLElement} srcElement The source cell\n   * @param {Boolean} focusFirstInRow If user should focus first in row. if false, then last\n   */\n\n\n  const focusFirstOrLastInRow = function (srcElement, focusFirstInRow) {\n    const colDefs = getColumnDefs();\n\n    if (isHeaderElement(srcElement)) {\n      if (focusFirstInRow) {\n        handleCellNavigation();\n      } else {\n        const lastDef = colDefs[colDefs.length - 1];\n        const scrollLeft = lastDef.startPosition;\n\n        if (!lastDef.pinnedLeft) {\n          let container = _trv.getScrollContainerElementFromTable().getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n\n          container.scrollLeft = scrollLeft;\n        }\n\n        setTimeout(function () {\n          let querySelector = `[aria-rowindex='1'] [aria-colindex='${colDefs.length}']`;\n\n          let headerCell = _tableElement.querySelector(querySelector);\n\n          headerCell && headerCell.focus();\n        }, 50);\n      }\n    } else if (isCellElement(srcElement) || util.closestElement(srcElement, `.${Const.CLASS_CELL}`)) {\n      let defToFind;\n      let closestCell = util.closestElement(srcElement, `.${Const.CLASS_CELL}`);\n      const rowIdx = closestCell ? closestCell.parentElement.getAttribute(dataIndexNumber) : srcElement.parentElement.getAttribute(dataIndexNumber);\n\n      if (focusFirstInRow) {\n        defToFind = colDefs[0];\n\n        if (!defToFind.pinnedLeft) {\n          let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n          let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n          viewport.scrollLeft = 0;\n        }\n      } else {\n        defToFind = colDefs[colDefs.length - 1];\n\n        if (!defToFind.pinnedLeft) {\n          let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n          let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n          viewport.scrollLeft = defToFind.startPosition;\n        }\n      }\n\n      setTimeout(function () {\n        let querySelector = `[aria-rowindex='${parseInt(rowIdx) + 2}'] [aria-colindex='${defToFind.index + 1}']`;\n\n        let focusElem = _tableElement.querySelector(querySelector);\n\n        focusElem && focusElem.focus();\n      }, 50);\n    }\n  };\n  /**\n   * Gets the edit context, either from dataProvider.json or declViewModel\n   * @returns {String|null} - The edit context, if any, or null\n   */\n\n\n  const getEditContext = function () {\n    if (_tableInstance.dataProvider.json && _tableInstance.dataProvider.json.editContext) {\n      return _tableInstance.dataProvider.json.editContext;\n    } else if (_tableInstance.declViewModel._internal.editContext) {\n      return _tableInstance.declViewModel._internal.editContext;\n    }\n\n    return null;\n  };\n  /**\n   * Handles selection when using keyboard. Will call the click handler and selection helper to handle the selection event\n   * @param {HTMLElement} keyboardTargetElement The destination element of the keyboard event (cell)\n   * @param {Event} event the event\n   */\n\n\n  const handleKeyboardSelection = function (keyboardTargetElement, event) {\n    let rowVmo = keyboardTargetElement.parentElement && keyboardTargetElement.parentElement.vmo;\n\n    _tableEditor.onClickHandler(event, keyboardTargetElement, rowVmo);\n\n    const selectionHandler = splmTableSelectionHelper.selectionChanged(_tableElement, keyboardTargetElement);\n    selectionHandler(event);\n  };\n  /**\n   * Handles the left/right internal navigation\n   * @param {HTMLElement} cellElement The cell element\n   * @param {String} direction The direction - left or right\n   * @param {Event} event The keyboard event\n   */\n\n\n  const handleLeftOrRightInternalNavigation = (cellElement, direction, event) => {\n    preventEventDefaults(event);\n\n    if (document.activeElement === cellElement && direction === 'RIGHT') {\n      // Navigate inside cell\n      _tableEditor.removeAllCellSelection();\n\n      let focusElem = wcagService.findNextFocusableChild(cellElement, true);\n      focusElem && focusElem.focus();\n    } else if (direction === 'RIGHT') {\n      let nextFocusableElement = wcagService.findNextFocusableChild(cellElement);\n\n      if (nextFocusableElement) {\n        nextFocusableElement.focus();\n      } else {\n        handleCellNavigation(cellElement, direction);\n      }\n    } else {\n      let prevFocusableElement = wcagService.findPreviousFocusableChild(cellElement);\n\n      if (prevFocusableElement) {\n        prevFocusableElement.focus();\n      } else {\n        handleCellNavigation(cellElement, direction);\n      }\n    }\n  };\n\n  self.setupInternalCellNavigation = cellElement => {\n    cellElement.onkeydown = function (event) {\n      const arrowKey = checkIfArrowKey(event.key);\n      let containsFocusableElems = hasFocusableElements(cellElement);\n      const isInternalCellNavigationAllowed = !util.isBulkEditing(_tableElement) && !cellElement.isElementInEdit && containsFocusableElems;\n\n      if (!isInternalCellNavigationAllowed) {\n        return;\n      }\n\n      if (arrowKey === 'LEFT' || arrowKey === 'RIGHT') {\n        delete _tableInstance.focusTreeNodeExpandAfterRender;\n        handleLeftOrRightInternalNavigation(cellElement, arrowKey, event);\n      } else if ((arrowKey === 'DOWN' || arrowKey === 'UP') && document.activeElement !== cellElement) {\n        delete _tableInstance.focusTreeNodeExpandAfterRender;\n        preventEventDefaults(event);\n        handleCellNavigation(cellElement, arrowKey);\n      }\n    };\n  };\n\n  const handleTabKey = (srcElement, event) => {\n    if (isHeaderElement(srcElement) && !event.shiftKey) {\n      preventEventDefaults(event);\n      focusGridOptionsButton();\n    } else if (isGridOptionsButton(srcElement) && event.shiftKey) {\n      preventEventDefaults(event);\n      handleCellNavigation();\n    } else if (isTableContainer(srcElement)) {\n      _tableEditor.removeAllCellSelection();\n    } else if (document.activeElement.closest(Const.CLASS_TABLE_CONTAINER)) {\n      _tableEditor.removeAllCellSelection();\n    }\n  };\n\n  const handleArrowKey = (srcElement, arrowKey, event) => {\n    if (isCellElement(srcElement) && event.shiftKey && (arrowKey === 'DOWN' || arrowKey === 'UP')) {\n      preventEventDefaults(event);\n\n      _tableEditor.removeAllCellSelection(); // Do shift select essentially\n\n\n      const rowIdx = parseInt(srcElement.parentElement.getAttribute(dataIndexNumber));\n\n      const totalRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length;\n\n      if (arrowKey === 'DOWN' && rowIdx < totalRows - 1 || arrowKey === 'UP' && rowIdx > 0) {\n        handleCellNavigation(srcElement, arrowKey);\n        setTimeout(function () {\n          handleKeyboardSelection(document.activeElement, event);\n        }, 100);\n      }\n    } else if (!srcElement.isElementInEdit) {\n      preventEventDefaults(event);\n\n      if (isHeaderElement(srcElement) || isCellElement(srcElement)) {\n        _tableEditor.removeAllCellSelection();\n\n        handleCellNavigation(srcElement, arrowKey);\n      } else if (isGridOptionsButton(srcElement)) {\n        handleCellNavigation(srcElement, arrowKey);\n      } else if (isTableContainer(srcElement)) {\n        _tableEditor.removeAllCellSelection();\n\n        handleCellNavigation();\n      }\n    }\n  };\n\n  const handleEscapeKey = srcElement => {\n    if (util.isCellEditing(_tableElement) && !srcElement.isElementInEdit) {\n      const context = getEditContext();\n      let editHandler = null;\n\n      if (context) {\n        editHandler = editHandlerSvc.getEditHandler(context);\n      }\n\n      if (editHandler) {\n        editHandler.cancelEdits();\n      } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n        const dataCtxNode = {\n          data: _tableInstance.declViewModel,\n          ctx: appCtxService.ctx\n        };\n\n        _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n      } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n        _tableInstance.declViewModel.cancelEdits();\n      }\n    }\n  };\n\n  const handleEnterOrSpaceKey = (srcElement, event) => {\n    if (isCellElement(srcElement) && !srcElement.isElementInEdit) {\n      preventEventDefaults(event); // We have to select the row since this is not a click, it wont trigger the selection change\n\n      handleKeyboardSelection(srcElement, event);\n    }\n  };\n  /**\n   * Sets up the onkeydown listener for table. This will add support for tab, arrows keys, enter/return/space, and escape\n   */\n\n\n  self.setupKeyListener = () => {\n    _tableElement.onkeydown = event => {\n      // check what srcElement, and key code are\n      let srcElement = event.srcElement; // if srcElement is input, then go up to cell level\n\n      if (srcElement.tagName === 'INPUT' || srcElement.tagName === 'TEXTAREA') {\n        srcElement = util.closestElement(srcElement, `.${Const.CLASS_CELL}`) || srcElement;\n      }\n\n      if (util.isBulkEditing(_tableElement)) {\n        if (isTableContainer(srcElement)) {\n          preventEventDefaults(event); // Focus very first edit cell\n\n          let editableGridCell = srcElement.getElementsByClassName('aw-jswidgets-editableGridCell')[0];\n\n          if (editableGridCell) {\n            editableGridCell.parentElement.focus();\n          }\n        }\n\n        return;\n      }\n\n      const keyPressed = event.key;\n      const arrowKey = checkIfArrowKey(keyPressed);\n\n      if (keyPressed === 'Tab') {\n        handleTabKey(srcElement, event);\n      } else if (arrowKey) {\n        handleArrowKey(srcElement, arrowKey, event);\n      } else if (keyPressed === 'Enter' || keyPressed === 'Space' || keyPressed === ' ') {\n        handleEnterOrSpaceKey(srcElement, event);\n      } else if (keyPressed === 'Escape' || keyPressed === 'Esc') {\n        handleEscapeKey(srcElement);\n      } else if (keyPressed === 'Home' && !srcElement.isElementInEdit) {\n        focusFirstOrLastInRow(srcElement, true);\n\n        _tableEditor.removeAllCellSelection();\n      } else if (keyPressed === 'End' && !srcElement.isElementInEdit) {\n        focusFirstOrLastInRow(srcElement, false);\n\n        _tableEditor.removeAllCellSelection();\n      }\n    };\n  };\n};\n\n_c2 = SPLMTableKeyboardService;\n_c = SPLMTableKeyboardService;\nexport default SPLMTableKeyboardService;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableKeyboardService\");\n\nvar _c2;\n\n$RefreshReg$(_c2, \"SPLMTableKeyboardService\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableKeyboardService.js"],"names":["SPLMTableKeyboardService","self","_tableElement","_tableEditor","_tableInstance","util","_trv","dataIndexNumber","preventEventDefaults","event","checkIfArrowKey","onFocusFunction","onBlurFunction","element","isHeaderElement","Const","isCellElement","isTableContainer","isGridOptionsButton","CLASS_TABLE_MENU_BUTTON","hasFocusableElements","wcagService","focusGridOptionsButton","gridMenuButton","getColumnDefs","colDefs","colDef","calculateScrollLeft","currentDef","currentElem","defIndex","scrollLeft","nextDef","nextColIdx","currentRowIdx","getNewRowAndColumnIndex","newIndexes","newRowIdx","newColIdx","direction","currentColIdx","parseInt","handleCellNavigation","numberOfRows","scrollContainer","viewport","setTimeout","queryString","focusFirstOrLastInRow","lastDef","container","querySelector","length","headerCell","CLASS_CELL","closestCell","rowIdx","srcElement","defToFind","focusElem","getEditContext","handleKeyboardSelection","rowVmo","keyboardTargetElement","selectionHandler","splmTableSelectionHelper","handleLeftOrRightInternalNavigation","document","nextFocusableElement","prevFocusableElement","cellElement","arrowKey","containsFocusableElems","isInternalCellNavigationAllowed","handleTabKey","handleArrowKey","totalRows","handleEscapeKey","context","editHandler","editHandlerSvc","dataCtxNode","data","ctx","appCtxService","handleEnterOrSpaceKey","editableGridCell","keyPressed"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the keyboard interactions for PL Table.\n *\n * @module js/splmTableKeyboardService\n */\n\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport wcagService from 'js/wcagService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n\n/**\n * Keyboard service to handle keyboard interactions for aw-splm-table\n * @param {HTMLElement} tableElem The table element\n * @param {SPLMTableEditor} tableEditor The table editor\n */\nconst SPLMTableKeyboardService = function( tableElem, tableEditor ) {\n    let self = this;\n\n    let _tableElement = tableElem;\n    let _tableEditor = tableEditor;\n    let _tableInstance = util.getTableInstance( _tableElement );\n    let _trv = new Trv( tableElem );\n    const dataIndexNumber = 'data-indexNumber';\n\n    /**\n     * Prevents default and stops propagation for event\n     * @param {Event} event the event\n     */\n    const preventEventDefaults = function( event ) {\n        event.preventDefault();\n        event.stopPropagation();\n    };\n\n    /**\n     * Checks if key pressed is an arrow key\n     * @param {String} keyPressed the pressed key to check\n     * @returns {String|null} the direction if arrow key, or null if not\n     */\n    const checkIfArrowKey = function( keyPressed ) {\n        switch ( keyPressed ) {\n            case 'Up':\n            case 'ArrowUp':\n                return 'UP';\n            case 'Down':\n            case 'ArrowDown':\n                return 'DOWN';\n            case 'Left':\n            case 'ArrowLeft':\n                return 'LEFT';\n            case 'Right':\n            case 'ArrowRight':\n                return 'RIGHT';\n            default:\n                return null;\n        }\n    };\n\n    /**\n     * Function for handling onfocus event\n     * @param {Event} event event data\n     */\n    const onFocusFunction = function( event ) {\n        event.target.tabIndex = '0';\n    };\n\n    /**\n     * Function for handling onblur event\n     * @param {Event} event eventData\n     */\n    const onBlurFunction = function( event ) {\n        event.target.tabIndex = '-1';\n    };\n\n    /**\n     * Sets focus and blur event listeners to passed element\n     * @param {HTMLElement} element Element to set focus and blur events for\n     */\n    self.setOnFocusAndBlur = function( element ) {\n        element.addEventListener( 'focus', onFocusFunction );\n        element.addEventListener( 'blur', onBlurFunction );\n    };\n\n    /**\n     * Checks if passed element is a header element\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is a header element\n     */\n    const isHeaderElement = function( element ) {\n        return element.classList.contains( Const.CLASS_HEADER_CELL );\n    };\n\n    /**\n     * Checks if passed element is a cell element\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is a cell element\n     */\n    const isCellElement = function( element ) {\n        return element.classList.contains( Const.CLASS_CELL );\n    };\n\n    /**\n     * Checks if passed element is the table container\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is table container\n     */\n    const isTableContainer = function( element ) {\n        return element.classList.contains( Const.CLASS_TABLE_CONTAINER );\n    };\n\n    /**\n     * Checks if passed element is the grid options button\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is grid options button\n     */\n    const isGridOptionsButton = function( element ) {\n        return util.closestElement( element, `.${Const.CLASS_TABLE_MENU_BUTTON}` );\n    };\n\n    const hasFocusableElements = function( element ) {\n        return wcagService.findFocusableChildren( element ).length > 0;\n    };\n\n    /**\n     * Focus' the grid options button for table\n     */\n    const focusGridOptionsButton = function() {\n        const gridMenuButton = _tableElement.querySelector( `.${Const.CLASS_TABLE_MENU_BUTTON} button` );\n        gridMenuButton.focus();\n    };\n\n    /**\n     * Gets the visible column defs for the table\n     * @returns {AwTableColumnInfo[]} Array of visible column defs\n     */\n    const getColumnDefs = function() {\n        let colDefs;\n        if( _tableInstance.gridOptions.transpose ) {\n            colDefs = _tableInstance.controller.getColumnDefs();\n        } else {\n            colDefs = _tableInstance.dataProvider.cols;\n            colDefs = colDefs.filter( function( colDef ) {\n                return colDef.hiddenFlag !== true;\n            } );\n        }\n        return colDefs;\n    };\n\n    /**\n     * Calculates the scrollLeft for when focusing an element in the scroll container when navigating left or right\n     *\n     * @param {HTMLElement} currentElem The currently focused cell\n     * @param {Number} currentRowIdx The current focused element's aria-rowindex\n     * @param {Number} currentColIdx The current focused element aria-colindex\n     * @param {Number} nextColIdx The next column index that will be focused\n     * @returns {Number} Returns the scrollLeft value if a change is needed, or null if no need to set.\n     */\n    const calculateScrollLeft = function( currentElem, currentRowIdx, currentColIdx, nextColIdx ) {\n        const colDefs = getColumnDefs();\n        let currentDef = currentElem.columnDef || currentElem.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n        let defIndex = colDefs.indexOf( currentDef );\n        let scrollLeft = null;\n\n        let nextDef = colDefs[ defIndex + ( nextColIdx - currentColIdx ) ];\n        if( currentDef && nextDef && currentDef.pinnedLeft && !nextDef.pinnedLeft ) {\n            // set scrollLeft to 0\n            scrollLeft = 0;\n        } else if( currentRowIdx === 1 && nextDef && !nextDef.pinnedLeft ) {\n            scrollLeft = nextDef.startPosition;\n        }\n        return scrollLeft;\n    };\n\n    const getNewRowAndColumnIndex = ( currentElem, direction, colDefs, currentRowIdx, numberOfRows ) => {\n        let newIndexes = {\n            newRowIdx: null,\n            newColIdx: null,\n            scrollLeft: null\n        };\n\n        if( !currentElem ) {\n            // No current element provided, focus very first header cell\n            newIndexes.newColIdx = 1;\n            newIndexes.newRowIdx = 1;\n            return newIndexes;\n        } else if( isGridOptionsButton( currentElem ) ) {\n            if( direction === 'LEFT' ) {\n                newIndexes.newColIdx = colDefs.length;\n                newIndexes.newRowIdx = 1;\n            } else if( direction === 'DOWN' ) {\n                newIndexes.newRowIdx = 2;\n                newIndexes.newColIdx = colDefs.length;\n                newIndexes.scrollLeft = colDefs[ colDefs.length - 1 ].startPosition;\n            }\n            return newIndexes;\n        }\n        const currentColIdx = parseInt( currentElem.getAttribute( 'aria-colindex' ) );\n\n        switch ( direction ) {\n            case 'UP':\n                if( currentRowIdx <= 1 ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx;\n                newIndexes.newRowIdx = currentRowIdx - 1;\n                break;\n            case 'DOWN':\n                // row index starts at 1\n                if( currentRowIdx >= numberOfRows ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx;\n                newIndexes.newRowIdx = currentRowIdx + 1;\n                break;\n            case 'LEFT':\n                if( currentColIdx <= 1 ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx - 1;\n                newIndexes.newRowIdx = currentRowIdx;\n                break;\n            case 'RIGHT':\n                // index for aria-colindex starts at 1\n                if( currentColIdx >= colDefs.length ) {\n                    if( isHeaderElement( currentElem ) ) {\n                        focusGridOptionsButton();\n                    }\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx + 1;\n                newIndexes.newRowIdx = currentRowIdx;\n                break;\n            default:\n                break;\n        }\n        // Set scrollLeft as needed\n        if( newIndexes.newColIdx !== currentColIdx ) {\n            newIndexes.scrollLeft = calculateScrollLeft( currentElem, currentRowIdx, currentColIdx, newIndexes.newColIdx );\n        }\n        return newIndexes;\n    };\n\n    /**\n     * Handles the cell navigation in table. If no element provided, focuses the first header cell. Otherwise\n     * handles navigation based on current element and direction passed\n     * @param {HTMLElement} currentElem The currently focused element\n     * @param {String} direction The direction to navigate - UP, DOWN, LEFT, or RIGHT\n     */\n    const handleCellNavigation = ( currentElem, direction ) => {\n        const colDefs = getColumnDefs();\n        let numberOfRows;\n        if( _tableInstance.gridOptions.transpose ) {\n            numberOfRows = _tableInstance.dataProvider.cols.length + 1;\n        } else {\n            numberOfRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length + 1;\n        }\n\n        const currentRowIdx = currentElem ? parseInt( currentElem.parentElement.getAttribute( 'aria-rowindex' ) ) : null;\n        const newIndexes = getNewRowAndColumnIndex( currentElem, direction, colDefs, currentRowIdx, numberOfRows );\n        if( !newIndexes ) {\n            return;\n        }\n        const newRowIdx = newIndexes.newRowIdx;\n        const newColIdx = newIndexes.newColIdx;\n        const scrollLeft = newIndexes.scrollLeft;\n\n        let scrollContainer = _trv.getScrollContainerElementFromTable();\n        let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n\n        if( currentRowIdx === 1 && newRowIdx === 2 ) {\n            // Going from header row to first row, need to set scroll top to 0\n            viewport.scrollTop = 0;\n        }\n\n        if( scrollLeft !== null ) {\n            viewport.scrollLeft = scrollLeft;\n        }\n        // Find the correct next element to focus\n        setTimeout( function() {\n            let queryString = `[aria-rowindex='${newRowIdx}'] [aria-colindex='${newColIdx}']`;\n            let element = _tableElement.querySelector( queryString );\n            if( element ) {\n                element.focus();\n            }\n        }, 100 );\n    };\n\n    /**\n     * Focuses the first or last cell in a given row/header row\n     * @param {HTMLElement} srcElement The source cell\n     * @param {Boolean} focusFirstInRow If user should focus first in row. if false, then last\n     */\n    const focusFirstOrLastInRow = function( srcElement, focusFirstInRow ) {\n        const colDefs = getColumnDefs();\n        if( isHeaderElement( srcElement ) ) {\n            if( focusFirstInRow ) {\n                handleCellNavigation();\n            } else {\n                const lastDef = colDefs[ colDefs.length - 1 ];\n                const scrollLeft = lastDef.startPosition;\n                if( !lastDef.pinnedLeft ) {\n                    let container = _trv.getScrollContainerElementFromTable().getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    container.scrollLeft = scrollLeft;\n                }\n\n                setTimeout( function() {\n                    let querySelector = `[aria-rowindex='1'] [aria-colindex='${colDefs.length}']`;\n                    let headerCell = _tableElement.querySelector( querySelector );\n                    headerCell && headerCell.focus();\n                }, 50 );\n            }\n        } else if( isCellElement( srcElement ) || util.closestElement( srcElement, `.${Const.CLASS_CELL}` ) ) {\n            let defToFind;\n            let closestCell = util.closestElement( srcElement, `.${Const.CLASS_CELL}` );\n            const rowIdx = closestCell ? closestCell.parentElement.getAttribute( dataIndexNumber ) : srcElement.parentElement.getAttribute( dataIndexNumber );\n            if( focusFirstInRow ) {\n                defToFind = colDefs[ 0 ];\n                if( !defToFind.pinnedLeft ) {\n                    let scrollContainer = _trv.getScrollContainerElementFromTable();\n                    let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    viewport.scrollLeft = 0;\n                }\n            } else {\n                defToFind = colDefs[ colDefs.length - 1 ];\n                if( !defToFind.pinnedLeft ) {\n                    let scrollContainer = _trv.getScrollContainerElementFromTable();\n                    let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    viewport.scrollLeft = defToFind.startPosition;\n                }\n            }\n\n            setTimeout( function() {\n                let querySelector = `[aria-rowindex='${parseInt( rowIdx ) + 2}'] [aria-colindex='${defToFind.index + 1}']`;\n                let focusElem = _tableElement.querySelector( querySelector );\n                focusElem && focusElem.focus();\n            }, 50 );\n        }\n    };\n\n    /**\n     * Gets the edit context, either from dataProvider.json or declViewModel\n     * @returns {String|null} - The edit context, if any, or null\n     */\n    const getEditContext = function() {\n        if( _tableInstance.dataProvider.json && _tableInstance.dataProvider.json.editContext ) {\n            return _tableInstance.dataProvider.json.editContext;\n        } else if( _tableInstance.declViewModel._internal.editContext ) {\n            return _tableInstance.declViewModel._internal.editContext;\n        }\n        return null;\n    };\n\n    /**\n     * Handles selection when using keyboard. Will call the click handler and selection helper to handle the selection event\n     * @param {HTMLElement} keyboardTargetElement The destination element of the keyboard event (cell)\n     * @param {Event} event the event\n     */\n    const handleKeyboardSelection = function( keyboardTargetElement, event ) {\n        let rowVmo = keyboardTargetElement.parentElement && keyboardTargetElement.parentElement.vmo;\n        _tableEditor.onClickHandler( event, keyboardTargetElement, rowVmo );\n        const selectionHandler = splmTableSelectionHelper.selectionChanged( _tableElement, keyboardTargetElement );\n        selectionHandler( event );\n    };\n\n    /**\n     * Handles the left/right internal navigation\n     * @param {HTMLElement} cellElement The cell element\n     * @param {String} direction The direction - left or right\n     * @param {Event} event The keyboard event\n     */\n    const handleLeftOrRightInternalNavigation = ( cellElement, direction, event ) => {\n        preventEventDefaults( event );\n        if( document.activeElement === cellElement && direction === 'RIGHT' ) {\n            // Navigate inside cell\n            _tableEditor.removeAllCellSelection();\n            let focusElem = wcagService.findNextFocusableChild( cellElement, true );\n            focusElem && focusElem.focus();\n        } else if( direction === 'RIGHT' ) {\n            let nextFocusableElement = wcagService.findNextFocusableChild( cellElement );\n            if( nextFocusableElement ) {\n                nextFocusableElement.focus();\n            } else {\n                handleCellNavigation( cellElement, direction );\n            }\n        } else {\n            let prevFocusableElement = wcagService.findPreviousFocusableChild( cellElement );\n            if( prevFocusableElement ) {\n                prevFocusableElement.focus();\n            } else {\n                handleCellNavigation( cellElement, direction );\n            }\n        }\n    };\n\n    self.setupInternalCellNavigation = ( cellElement ) => {\n        cellElement.onkeydown = function( event ) {\n            const arrowKey = checkIfArrowKey( event.key );\n            let containsFocusableElems = hasFocusableElements( cellElement );\n            const isInternalCellNavigationAllowed = !util.isBulkEditing( _tableElement ) && !cellElement.isElementInEdit && containsFocusableElems;\n            if( !isInternalCellNavigationAllowed ) {\n                return;\n            }\n            if( arrowKey === 'LEFT' || arrowKey === 'RIGHT' ) {\n                delete _tableInstance.focusTreeNodeExpandAfterRender;\n                handleLeftOrRightInternalNavigation( cellElement, arrowKey, event );\n            } else if( ( arrowKey === 'DOWN' || arrowKey === 'UP' ) && document.activeElement !== cellElement ) {\n                delete _tableInstance.focusTreeNodeExpandAfterRender;\n                preventEventDefaults( event );\n                handleCellNavigation( cellElement, arrowKey );\n            }\n        };\n    };\n\n    const handleTabKey = ( srcElement, event ) => {\n        if( isHeaderElement( srcElement ) && !event.shiftKey ) {\n            preventEventDefaults( event );\n            focusGridOptionsButton();\n        } else if( isGridOptionsButton( srcElement ) && event.shiftKey ) {\n            preventEventDefaults( event );\n            handleCellNavigation();\n        } else if( isTableContainer( srcElement ) ) {\n            _tableEditor.removeAllCellSelection();\n        } else if( document.activeElement.closest( Const.CLASS_TABLE_CONTAINER ) ) {\n            _tableEditor.removeAllCellSelection();\n        }\n    };\n\n    const handleArrowKey = ( srcElement, arrowKey, event ) => {\n        if( isCellElement( srcElement ) && event.shiftKey && ( arrowKey === 'DOWN' || arrowKey === 'UP' ) ) {\n            preventEventDefaults( event );\n            _tableEditor.removeAllCellSelection();\n            // Do shift select essentially\n            const rowIdx = parseInt( srcElement.parentElement.getAttribute( dataIndexNumber ) );\n            const totalRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length;\n            if( arrowKey === 'DOWN' && rowIdx < totalRows - 1 || arrowKey === 'UP' && rowIdx > 0 ) {\n                handleCellNavigation( srcElement, arrowKey );\n                setTimeout( function() {\n                    handleKeyboardSelection( document.activeElement, event );\n                }, 100 );\n            }\n        } else if( !srcElement.isElementInEdit ) {\n            preventEventDefaults( event );\n            if( isHeaderElement( srcElement ) || isCellElement( srcElement ) ) {\n                _tableEditor.removeAllCellSelection();\n                handleCellNavigation( srcElement, arrowKey );\n            } else if( isGridOptionsButton( srcElement ) ) {\n                handleCellNavigation( srcElement, arrowKey );\n            } else if( isTableContainer( srcElement ) ) {\n                _tableEditor.removeAllCellSelection();\n                handleCellNavigation();\n            }\n        }\n    };\n\n    const handleEscapeKey = ( srcElement ) => {\n        if( util.isCellEditing( _tableElement ) && !srcElement.isElementInEdit ) {\n            const context = getEditContext();\n            let editHandler = null;\n            if( context ) {\n                editHandler = editHandlerSvc.getEditHandler( context );\n            }\n\n            if( editHandler ) {\n                editHandler.cancelEdits();\n            } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                const dataCtxNode = {\n                    data: _tableInstance.declViewModel,\n                    ctx: appCtxService.ctx\n                };\n                _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n            } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                _tableInstance.declViewModel.cancelEdits();\n            }\n        }\n    };\n\n    const handleEnterOrSpaceKey = ( srcElement, event ) => {\n        if( isCellElement( srcElement ) && !srcElement.isElementInEdit ) {\n            preventEventDefaults( event );\n            // We have to select the row since this is not a click, it wont trigger the selection change\n            handleKeyboardSelection( srcElement, event );\n        }\n    };\n\n    /**\n     * Sets up the onkeydown listener for table. This will add support for tab, arrows keys, enter/return/space, and escape\n     */\n    self.setupKeyListener = () => {\n        _tableElement.onkeydown = ( event ) => {\n            // check what srcElement, and key code are\n            let srcElement = event.srcElement;\n\n            // if srcElement is input, then go up to cell level\n            if( srcElement.tagName === 'INPUT' || srcElement.tagName === 'TEXTAREA' ) {\n                srcElement = util.closestElement( srcElement, `.${Const.CLASS_CELL}` ) || srcElement;\n            }\n\n            if( util.isBulkEditing( _tableElement ) ) {\n                if( isTableContainer( srcElement ) ) {\n                    preventEventDefaults( event );\n                    // Focus very first edit cell\n                    let editableGridCell = srcElement.getElementsByClassName( 'aw-jswidgets-editableGridCell' )[ 0 ];\n                    if( editableGridCell ) {\n                        editableGridCell.parentElement.focus();\n                    }\n                }\n                return;\n            }\n\n            const keyPressed = event.key;\n\n            const arrowKey = checkIfArrowKey( keyPressed );\n\n            if( keyPressed === 'Tab' ) {\n                handleTabKey( srcElement, event );\n            } else if( arrowKey ) {\n                handleArrowKey( srcElement, arrowKey, event );\n            } else if( keyPressed === 'Enter' || keyPressed === 'Space' || keyPressed === ' ' ) {\n                handleEnterOrSpaceKey( srcElement, event );\n            } else if( keyPressed === 'Escape' || keyPressed === 'Esc' ) {\n                handleEscapeKey( srcElement );\n            } else if( keyPressed === 'Home' && !srcElement.isElementInEdit ) {\n                focusFirstOrLastInRow( srcElement, true );\n                _tableEditor.removeAllCellSelection();\n            } else if( keyPressed === 'End' && !srcElement.isElementInEdit ) {\n                focusFirstOrLastInRow( srcElement, false );\n                _tableEditor.removeAllCellSelection();\n            }\n        };\n    };\n};\n\nexport default SPLMTableKeyboardService;\n"]},"metadata":{},"sourceType":"module"}