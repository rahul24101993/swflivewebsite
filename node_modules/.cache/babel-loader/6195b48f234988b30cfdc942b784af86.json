{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * This service manages tiles drag and reorder functionality.\n *\n * @module js/tileDragService\n */\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\n/**\n   * Static Strings referencing css classes\n   */\n\nvar TILEMAIN_CSS_CLASS = 'aw-tile-tileMain';\nvar TILE_CONT_CSS_CLASS = 'sw-column.aw-tile-tileContainer';\nvar TILE_DRAGGABLE_CSS_CLASS = 'aw-tile-draggable';\nvar TILEGROUP_CSS_CLASS = 'aw-tile-tileGroup';\nvar PLACEHOLDER_GROUP_CSS_CLASS = 'aw-tile-placeHolderGroupSep';\nvar PLACEHOLDER_TILE_CSS_CLASS = 'aw-tile-placeHolderTile';\nvar DRAGTILE_CSS_CLASS = 'aw-tile-dragTile';\nvar TILE_GROUP_TAGNAME = 'aw-tile-group';\nvar TILE_MAIN_CONTAINER_CSS_CLASS = 'aw-tile-mainContainer';\n/**\n   * <pre>\n   * Greater Than 0 If some basic event activity should be logged.\n   * Greater Than 1 If some more fine-grained event activity should be logged.\n   * </pre>\n   */\n\nvar _debug_logEventActivity = 0;\nvar placeHolderTile;\nlet draggedTileInfo;\nlet droppedTileInfo;\n/**\n   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n   *\n   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n   *            test.\n   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n   */\n\nvar _isValidToDrop = function (event) {\n  return true;\n};\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   * @param {Boolean} isNewGroup - If a new tile group is to be created\n   *\n   * @return {Element} The Element where we need to reorder and insert dragged tile after this.\n   */\n\n\nvar _findDropTargetElement = function (event, isNewGroup) {\n  var dropTarget = {};\n  dropTarget.inPlace = false;\n  let eventSrc = event.currentTarget;\n\n  if (isNewGroup) {\n    var placeholderGroup = $('.' + TILE_MAIN_CONTAINER_CSS_CLASS).find('.' + PLACEHOLDER_GROUP_CSS_CLASS);\n    dropTarget.element = placeholderGroup.prev('.' + TILEGROUP_CSS_CLASS); // For the use case of the previous element not being an actual tile group\n\n    while (dropTarget.element.hasClass('aw-tile-emptyTileGroup')) {\n      dropTarget.element = dropTarget.element.prev('.' + TILEGROUP_CSS_CLASS);\n    } // If the new group is in the 1st tile group location\n\n\n    if (dropTarget.element.length === 0) {\n      dropTarget.element = dropTarget.element.prevObject;\n    }\n\n    dropTarget.element = dropTarget.element[0];\n    return dropTarget;\n  }\n\n  dropTarget.element = $('.aw-tile-mainContainer .aw-tile-placeHolderTile');\n\n  if (dropTarget.element.length === 0) {\n    if (!$(eventSrc).hasClass(TILE_DRAGGABLE_CSS_CLASS)) {\n      // find the closest\n      var parentTileElem = $(eventSrc).closest('.' + TILE_DRAGGABLE_CSS_CLASS); // if its not on the parent level, then try to find it in the children\n\n      if (parentTileElem.length === 0) {\n        parentTileElem = $(eventSrc).find('.' + TILE_DRAGGABLE_CSS_CLASS);\n      }\n\n      if (parentTileElem && parentTileElem.length > 0) {\n        dropTarget.element = parentTileElem[0];\n      }\n    } else {\n      dropTarget.element = eventSrc;\n    }\n  } else {\n    //  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'\n    if (dropTarget.element[0].style.order === '0' && dropTarget.element.next().length !== 0) {\n      dropTarget.element = dropTarget.element.next();\n      dropTarget.inPlace = true;\n    } else {\n      dropTarget.element = dropTarget.element.prev();\n    }\n  }\n\n  return dropTarget;\n};\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   *\n   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order\n   * of dragged tile.\n   */\n\n\nvar _findDragEnterElement = function (event) {\n  var dragEnterElement;\n  let eventSrc = event.target; // find the closest\n\n  let parentTileElem = $(eventSrc).closest('.' + TILE_DRAGGABLE_CSS_CLASS);\n\n  if (parentTileElem && parentTileElem.length > 0) {\n    dragEnterElement = parentTileElem[0];\n  } else if ($(eventSrc).hasClass(TILEGROUP_CSS_CLASS)) {\n    dragEnterElement = $(eventSrc);\n  }\n\n  return dragEnterElement;\n};\n/**\n   * Remove place holder elements from DOM.\n   */\n\n\nvar _removePlaceHolders = function () {\n  $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).remove();\n  $('.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS).remove();\n};\n/**\n   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping\n   *\n   * @return {Element} The Element which represents dummy placeHolder tileGroup\n   */\n\n\nvar _createPlaceHolderTileGroup = function () {\n  // hidden tile to place it where dragging tile will dropped\n  var newTileGroup = $('<div class=\"' + TILEGROUP_CSS_CLASS + '\"></div>');\n  newTileGroup.addClass(PLACEHOLDER_GROUP_CSS_CLASS);\n  return newTileGroup;\n};\n/**\n   * Create dummy placeHolder Tile element to represent the position in the UI before dropping\n   *\n   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element\n   *\n   * @return {Element} The Element which represents dummy placeHolder tile\n   */\n\n\nvar _createPlaceHolderTile = function (sourceTile) {\n  // hidden tile to place it where dragging tile will dropped\n  placeHolderTile = $('<div class=\"' + PLACEHOLDER_TILE_CSS_CLASS + '\"></div>');\n  placeHolderTile.addClass(TILEMAIN_CSS_CLASS);\n\n  if ($(sourceTile).hasClass('aw-tile-doubleSize')) {\n    placeHolderTile.addClass('aw-tile-doubleSize');\n  } else if ($(sourceTile).hasClass('aw-tile-tripleSize')) {\n    placeHolderTile.addClass('aw-tile-tripleSize');\n  } else if ($(sourceTile).hasClass('aw-tile-quadroSize')) {\n    placeHolderTile.addClass('aw-tile-quadroSize');\n  }\n\n  if ($(sourceTile).hasClass('aw-tile-doubleVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-doubleVerticalSize');\n  } else if ($(sourceTile).hasClass('aw-tile-tripleVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-tripleVerticalSize');\n  } else if ($(sourceTile).hasClass('aw-tile-quadroVerticalSize')) {\n    placeHolderTile.addClass('aw-tile-quadroVerticalSize');\n  }\n\n  return placeHolderTile;\n};\n/**\n   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements\n   *\n   * @param {Element} dragTileIn - The DOM element for dragging tile\n   * @param {Element} element - container element for dragging tile\n   */\n\n\nvar _cleanUp = function (dragTileIn, element) {\n  _removePlaceHolders();\n\n  if (dragTileIn) {\n    dragTileIn.removeAttribute('id');\n  } else {\n    let dragTile = document.querySelector('#draggedTile');\n    dragTile.classList.remove(DRAGTILE_CSS_CLASS);\n    dragTile.removeAttribute('id');\n    let tileContElem = dragTile;\n  }\n\n  placeHolderTile = null;\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('Cleaning up');\n  }\n};\n/**\n   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n   * 'target'.\n   *\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Element} targetElement - The target element associate with dragEnter event\n   */\n\n\nvar _processDragEnterInternal = function (event, targetElement, targetObjects) {\n  event.preventDefault(); // place phantom tile instead dragging one\n\n  if (placeHolderTile && targetElement && targetObjects) {\n    // reordering in existing tiles\n    if ($(targetElement).hasClass(TILEMAIN_CSS_CLASS) && $(targetElement).hasClass(TILE_DRAGGABLE_CSS_CLASS)) {\n      _removePlaceHolders();\n\n      var targetCssOrder = targetElement.style.order;\n      var order = parseInt(targetCssOrder, 10);\n      var side;\n      var element = $(targetElement)[0];\n      var mouseX = event.clientX;\n      var elementWidth = element.offsetWidth;\n      var halfElementWidth = elementWidth / 2;\n\n      if (mouseX > halfElementWidth + element.offsetLeft) {\n        side = 'right';\n      } else {\n        side = 'left';\n      } // If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after\n\n\n      if (order === 0 && side === 'left') {\n        placeHolderTile.insertBefore(targetElement);\n        $(placeHolderTile).css('order', 0);\n      } else {\n        placeHolderTile.insertAfter(targetElement);\n        $(placeHolderTile).css('order', order++);\n      }\n\n      _.forEach($(placeHolderTile).nextAll(), function (nextSib) {\n        if (nextSib) {\n          nextSib.style.order = order++;\n        }\n      });\n\n      if (_debug_logEventActivity >= 1) {\n        var tgtTile = targetObjects[0].tile;\n        postLog('processDragEnter - PlaceHolder Tile Inserted: ' + tgtTile.displayName);\n      }\n    } else if ($(targetElement).hasClass(TILEGROUP_CSS_CLASS)) {\n      // vertically or horizontally creating new group\n      _removePlaceHolders();\n\n      var targetGroupElem = $(targetElement);\n\n      var placeHolderTileGroup = _createPlaceHolderTileGroup();\n\n      placeHolderTileGroup.insertBefore(targetGroupElem[0]);\n\n      if (_debug_logEventActivity >= 1) {\n        postLog('processDragEnter - Insert vertical or horizontal placeHolder Group');\n      }\n    }\n\n    droppedTileInfo = {\n      targetTile: targetObjects[0].tile,\n      targetTileGroup: targetObjects[0].tileGroup,\n      viewModel: targetObjects.viewModel\n    };\n  }\n};\n/**\n   * Get base order value from the input parameter's order number\n   * <p>\n   * ex: 212 -> returns 200; 399 -> returns 300\n   *\n   * @param {Number} orderNumber - order number\n   * @returns {Number} base order number if orderNumber is defined, otherwise 0\n   */\n\n\nfunction getBaseOrder(orderNumber) {\n  if (!orderNumber) {\n    return 0;\n  }\n\n  var tensAndOnesDigits = orderNumber % 100;\n  return orderNumber - tensAndOnesDigits;\n}\n/**\n   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n   *\n   * @param {DragEvent} event - The DragEvent to set the DragData on.\n   * @param {Object} dragDataMap - Map of name/value pairs to add.\n   */\n\n\nfunction addDragDataToDragEvent(event, dragDataMap) {\n  if (event.dataTransfer && dragDataMap) {\n    event.dataTransfer.setData('text', JSON.stringify({\n      sourceTile: dragDataMap.sourceTile,\n      sourceGroupName: dragDataMap.sourceTileGroup.groupName\n    }));\n  }\n\n  draggedTileInfo = dragDataMap;\n}\n/**\n   * Update the drag image for the DragEvent based on draggable element.\n   *\n   * @param {DragEvent} event - The DragEvent to set the image on.\n   * @param {DOMElement} draggableElem - element being dragged.\n   */\n\n\nfunction updateDragImage(event, draggableElem) {\n  /**\n     * Internet Explorer doesn't support setDragImage at all.\n     * <P>\n     * See: http://mereskin.github.io/dnd/\n     */\n  if (!browserUtils.isIE && event.dataTransfer) {\n    /**\n       * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n       * should be resolved after moving the list view to a flex display.\n       */\n    event.dataTransfer.setDragImage(draggableElem, 0, 0);\n  }\n}\n/**\n   * Processes drag start event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   * @param {Element} element - The DOM element considered the 'source' of the given drag event.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   */\n\n\nfunction processDragStart(event, element, targetObjects) {\n  let callBackAPIs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let srcElement = event.target;\n  let sourceTile = targetObjects[0].tile;\n  let sourceTileGroup = targetObjects[0].tileGroup;\n  let tileContElem = srcElement.parentElement.parentElement;\n\n  if (sourceTile) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('processDragStart - Source Tile name: ' + sourceTile.displayName + ' && Source Tile Group name: ' + sourceTileGroup.groupName);\n    }\n\n    element.data('dragging', true);\n    var containerId = element.data('containerId');\n\n    if (!containerId) {\n      containerId = Date.now();\n      element.data('containerId', containerId);\n    }\n\n    let width = 0;\n\n    for (let index = 0; index < 3; index++) {\n      if (index < sourceTileGroup.tiles.length) {\n        width += sourceTileGroup.tiles[index].tileSize + 1;\n      } else {\n        break;\n      }\n    } // // Default width for the single width tile\n\n\n    let parentTileMinWidth = 155 * width + 'px';\n    tileContElem.parentElement.style.minWidth = parentTileMinWidth;\n    tileContElem.setAttribute('id', 'draggedTile');\n    tileContElem.classList.add(DRAGTILE_CSS_CLASS);\n\n    if (event.dataTransfer) {\n      event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n\n    updateDragImage(event, tileContElem);\n    addDragDataToDragEvent(event, {\n      sourceTile: sourceTile,\n      sourceTileGroup: sourceTileGroup\n    });\n    placeHolderTile = _createPlaceHolderTile(srcElement);\n  } else {\n    if (_debug_logEventActivity >= 2) {\n      postLog('processDragStart - no tile Info, Set element data \"dragging\" to false');\n    } // No data so there is no reason to let the object be dragged.\n\n\n    element.data('dragging', false);\n    event.preventDefault();\n  }\n}\n/**\n   * Processes drag over event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   */\n\n\nfunction processDragOver(event) {\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = 'move'; // only allow moves\n  }\n}\n/**\n   * Processes drag enter event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.\n   */\n\n\nfunction processDragEnter(event, targetElement, targetObjects) {\n  if (_isValidToDrop(event)) {\n    let targetData = targetObjects[0].tile;\n    let targetTileGroup = targetObjects[0].tileGroup;\n\n    if (targetData) {\n      if (_debug_logEventActivity >= 2) {\n        if (targetData.tiles) {\n          postLog('processDragEnter - Target tileGroup: ' + targetData.groupName);\n        } else if (targetTileGroup && targetData.displayName) {\n          postLog('processDragEnter - Target tile: ' + targetData.displayName + ' && Target Item tileGroup: ' + targetTileGroup.groupName);\n        } else if (targetTileGroup && !targetData.displayName) {\n          postLog('processDragEnter - Target Item tileGroup: ' + targetTileGroup.groupName);\n        }\n      }\n\n      if (!targetData.tiles && (!targetTileGroup || !targetTileGroup.groupName)) {\n        return;\n      }\n\n      if (event.dataTransfer) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n      }\n\n      let debounceProcessDragEnter = _.debounce(_processDragEnterInternal, 100);\n\n      debounceProcessDragEnter(event, targetElement, targetObjects);\n    }\n  }\n}\n/**\n   * Processes drag leave event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   */\n\n\nfunction processDragLeave(event) {\n  event.preventDefault();\n\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = 'move'; // only allow moves\n  }\n}\n/**\n   * Processes drag end event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   */\n\n\nfunction processDragEnd(event, element, targetObjects) {\n  event.preventDefault();\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDragEnd - Processing drag end');\n  }\n\n  let evtElement = event.target.parentElement.parentElement;\n  $(evtElement).removeClass(DRAGTILE_CSS_CLASS);\n  $(evtElement).removeAttr('id');\n  let tileContElem = event.target;\n}\n/**\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   * @param {Object}  targetObjects\n   */\n\n\nfunction processDrop(event, callBackAPIs, element, targetObjects, props) {\n  const propertyToUpdate = props;\n  event.stopPropagation();\n  event.preventDefault();\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDrop - Processing drop');\n  }\n\n  let dragTile = document.querySelector('#draggedTile');\n  var isNewGroup = false;\n  dragTile.classList.remove(DRAGTILE_CSS_CLASS);\n  dragTile.parentElement.style.minWidth = '';\n  let tileContElem = dragTile.firstElementChild.firstElementChild;\n\n  if ($('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).length > 0) {\n    var prevSiblings = $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).prevAll();\n    var nextSiblings = $('.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS).nextAll();\n    var index = 0;\n\n    _.forEachRight(prevSiblings, function (sibling) {\n      if (sibling.id !== 'draggedTile') {\n        sibling.style.order = index;\n        index++;\n      }\n    });\n\n    if (dragTile) {\n      dragTile.style.order = index;\n      index++;\n\n      if (_debug_logEventActivity >= 1) {\n        postLog('processDrop - Set new order style for dragged tile');\n      }\n    }\n\n    _.forEach(nextSiblings, function (sibling) {\n      if (sibling.id !== 'draggedTile') {\n        sibling.style.order = index;\n        index++;\n      }\n    });\n  } else if ($('.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS).length > 0) {\n    isNewGroup = true;\n  }\n\n  let targetElement = _findDropTargetElement(event, isNewGroup);\n\n  if (!targetElement.element) {\n    _cleanUp(dragTile);\n\n    return;\n  }\n\n  let draggingData = event.dataTransfer.getData('text');\n\n  if (_debug_logEventActivity >= 1) {\n    postLog('processDrop - Retrieving drag data');\n  }\n\n  if (draggingData) {\n    var dragDataTile = JSON.parse(draggingData);\n    var targetTile = droppedTileInfo.targetTile;\n    let targetTileGroup = droppedTileInfo.targetTileGroup;\n    let canvasViewModel = droppedTileInfo.viewModel;\n\n    if (!isNewGroup && updateOrder && targetTile !== dragDataTile.sourceTile) {\n      updateOrder(canvasViewModel, dragDataTile.sourceTile, dragDataTile.sourceGroupName, targetTile, targetTileGroup, targetElement.inPlace, propertyToUpdate);\n    } else if (isNewGroup && createNewGroup) {\n      var tileGroupElemData = targetObjects[0].tile;\n      var tileGroupData;\n\n      if (tileGroupElemData) {\n        tileGroupData = tileGroupElemData.tileGroup;\n      }\n\n      createNewGroup(dragDataTile.sourceTile, dragDataTile.sourceGroupName, tileGroupData, propertyToUpdate);\n    }\n\n    if (_debug_logEventActivity >= 1) {\n      postLog('processDrop - Dropping data: ' + draggingData);\n    }\n  }\n\n  _cleanUp(dragTile);\n}\n\nexport const dragStartFn = _ref => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref;\n  let targetObjectsDragStart;\n  event.stopPropagation();\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n\n  if (event.target.nodeName === '#text') {\n    jqElement.data('dragging', false);\n    event.preventDefault();\n  } else {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragstart: ' + event);\n    }\n\n    targetObjectsDragStart = assignViewModelToObject(targetObjects, declViewModel);\n    processDragStart(event, jqElement, targetObjectsDragStart, {});\n  }\n};\nexport const dragEndFn = _ref2 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref2;\n  let targetObjectsDragEnd;\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragend: ' + event);\n    }\n\n    jqElement.data('dragging', false);\n\n    var target = _findDropTargetElement(event);\n\n    if (!target) {\n      return;\n    }\n\n    targetObjectsDragEnd = assignViewModelToObject(targetObjects, declViewModel);\n    processDragEnd(event, jqElement, targetObjectsDragEnd);\n  }\n};\nexport const dragOverFn = _ref3 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref3;\n  event.stopPropagation();\n  event.preventDefault();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragover: ' + event);\n    }\n\n    if (_isValidToDrop(event)) {\n      if (event.dataTransfer && !browserUtils.isQt) {\n        event.dataTransfer.dropEffect = 'move'; // only allow moves\n      }\n\n      event.stopPropagation();\n      event.preventDefault();\n\n      var debounceProcessDragOver = _.debounce(processDragOver, 100);\n\n      debounceProcessDragOver(event);\n    }\n  }\n};\nexport const dragEnterFn = _ref4 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref4;\n  let targetObjectsDragEnter;\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragenter: ' + event);\n    }\n\n    var target = _findDragEnterElement(event);\n\n    if (!target) {\n      return;\n    }\n\n    targetObjectsDragEnter = assignViewModelToObject(targetObjects, declViewModel);\n    targetObjects.viewModel = declViewModel;\n    processDragEnter(event, target, targetObjectsDragEnter);\n  }\n};\nexport const createNewGroup = function (viewModel, sourceTile, sourceGroupName, targetTileGroup) {\n  var sourceGroup = self.getTileGroup(sourceGroupName);\n  var sourceGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, sourceGroup);\n  var targetGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, targetTileGroup);\n  var sourceTileIn = retrieveTileInTileGroup(sourceTile, sourceGroupIndx);\n  var sourceTileIndx = viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n  var baseOrder = 0;\n  var newGroupIncrement = 100;\n\n  if (targetTileGroup && targetTileGroup.tiles.length > 0) {\n    baseOrder = getBaseOrder(targetTileGroup.tiles[0].orderNumber);\n  } // remove tile from source group\n\n\n  var srcGroup = viewModel.tileGroups[sourceGroupIndx];\n  srcGroup.tiles.splice(sourceTileIndx, 1);\n  var srcGroupNull = false; // If we removed the last tile in the group\n\n  if (srcGroup.tiles.length === 0) {\n    srcGroupNull = true;\n  } // create new group using current time\n\n\n  var newGroup = {};\n  newGroup.groupName = 'group' + new Date().getTime(); // add sourceTile to newly created group\n\n  newGroup.tiles = [];\n  newGroup.tiles.push(sourceTileIn);\n  newGroup.tiles.forEach(function (tile, indx) {\n    tile.orderNumber = baseOrder + newGroupIncrement + indx;\n    tile.isDirty = true;\n  }); // update tileGroups array\n\n  if (sourceGroupIndx === targetGroupIndx && srcGroupNull) {\n    viewModel.tileGroups.splice(targetGroupIndx, 0, newGroup);\n  } else {\n    viewModel.tileGroups.splice(targetGroupIndx + 1, 0, newGroup);\n  }\n\n  var newGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, newGroup); // update order number for all tiles in each and every tile group\n\n  _.forEach(viewModel.tileGroups, function (tileGroup, index) {\n    if (index > newGroupIndx && tileGroup.tiles.length > 0) {\n      var grpBaseOrder = getBaseOrder(tileGroup.tiles[0].orderNumber);\n      tileGroup.tiles.map(function (tile, indx) {\n        tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n        return tile;\n      });\n    }\n  });\n};\nexport const updateOrder = function (viewModel, sourceTile, sourceGroupName, targetTile, targetTileGroup, inPlace, propertyToUpdate) {\n  if (targetTile) {\n    var targetTileOrder = targetTile.orderNumber;\n    var targetGroup = getTileGroup(viewModel, targetTileGroup.groupName);\n    var sourceGroup = getTileGroup(viewModel, sourceGroupName);\n    var sourceGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, sourceGroup);\n    var targetGroupIndx = retrieveTileGroupIndex(viewModel.tileGroups, targetGroup);\n    var sourceTileIn = retrieveTileInTileGroup(viewModel, sourceTile, sourceGroupIndx);\n    var sourceTileIndx = viewModel.tileGroups[sourceGroupIndx].tiles.indexOf(sourceTileIn);\n    var targetTileIndx = targetTileGroup.tiles.indexOf(targetTile);\n    var targetBaseOrder = getBaseOrder(targetTileOrder);\n\n    if (sourceGroupIndx === targetGroupIndx) {\n      // same group rearrange\n      reOrderInSameGroup(sourceTileIn, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace);\n    } else {\n      // different group rearrange\n      reOrderInDifferentGroup(viewModel, sourceTileIn, sourceTileIndx, sourceGroupIndx, targetTileIndx, targetGroupIndx, targetBaseOrder, inPlace, propertyToUpdate);\n    }\n  }\n};\nexport const getTileGroup = function (viewModel, groupName) {\n  var tileGroupIn;\n\n  _.forEach(viewModel.tileGroups, function (tileGroup) {\n    if (tileGroup.groupName === groupName) {\n      tileGroupIn = tileGroup;\n      return false;\n    }\n\n    return true;\n  });\n\n  return tileGroupIn;\n};\nexport const retrieveTileInTileGroup = function (viewModel, tile, groupIndex) {\n  var retrievedTile;\n\n  if (viewModel.tileGroups[groupIndex] && !_.isEmpty(viewModel.tileGroups[groupIndex].tiles)) {\n    _.forEach(viewModel.tileGroups[groupIndex].tiles, function (tileObj) {\n      if (_.isEqual(tileObj.displayName, tile.displayName)) {\n        retrievedTile = tileObj;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return retrievedTile;\n};\nexport const reOrderInSameGroup = function (sourceTile, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace) {\n  if (targetTileGroup) {\n    targetTileGroup.tiles.splice(sourceTileIndx, 1);\n    var targetTileIndx = targetTileGroup.tiles.indexOf(targetTile);\n\n    if (inPlace) {\n      targetTileGroup.tiles.splice(targetTileIndx, 0, sourceTile);\n    } else {\n      targetTileGroup.tiles.splice(targetTileIndx + 1, 0, sourceTile);\n    }\n\n    _.forEach(targetTileGroup.tiles, function reorderTiles(tile, index) {\n      if (tile) {\n        tile.orderNumber = targetBaseOrder + index;\n        tile.isDirty = true;\n      }\n    });\n  }\n};\nexport const reOrderInDifferentGroup = function (viewModel, sourceTile, sourceTileIndex, sourceGroupIndex, targetTileIndex, targetGroupIndex, targetBaseOrder, inPlace, propertyToUpdate) {\n  const {\n    dispatch\n  } = viewModel;\n  const propertyName = propertyToUpdate;\n  let updatedTileGroups = { ...viewModel.getData()\n  }.tileGroups;\n  var sourceBaseOrder = getBaseOrder(sourceTile.orderNumber);\n  var srcGroup = updatedTileGroups[sourceGroupIndex];\n  var targetGroupDifferent = updatedTileGroups[targetGroupIndex]; // remove tile from source group\n\n  srcGroup.tiles.splice(sourceTileIndex, 1); // add tile to target group\n\n  if (inPlace) {\n    targetGroupDifferent.tiles.splice(targetTileIndex, 0, sourceTile);\n  } else {\n    targetGroupDifferent.tiles.splice(targetTileIndex + 1, 0, sourceTile);\n  } // modify order in source group\n\n\n  srcGroup.tiles.map(function (tile, idx) {\n    tile.orderNumber = sourceBaseOrder + idx;\n    tile.isDirty = true;\n    return tile;\n  });\n  updatedTileGroups[sourceGroupIndex] = srcGroup; // modify order in target group\n\n  targetGroupDifferent.tiles.map(function (tile, idx) {\n    tile.orderNumber = targetBaseOrder + idx;\n    tile.isDirty = true;\n    return tile;\n  });\n  updatedTileGroups[targetGroupIndex] = targetGroupDifferent;\n  let propertyPath = propertyName ? 'data.' + propertyName : 'data.tileGroups';\n  dispatch({\n    path: propertyPath,\n    value: [...updatedTileGroups]\n  });\n};\nexport const dragLeaveFn = _ref5 => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref5;\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('dragleave: ' + event);\n    }\n\n    var debounceProcessDragLeave = _.debounce(processDragLeave, 100);\n\n    debounceProcessDragLeave(event);\n  }\n};\nexport const dropFn = (props, _ref6) => {\n  let {\n    event,\n    targetObjects,\n    declViewModel\n  } = _ref6;\n  let targetObjectsDrop;\n  let panelElement = document.children[0].querySelector('.aw-tile-tileCanvasPanel.aw-layout-flexColumn ');\n  var jqElement = $(panelElement);\n  event.stopPropagation();\n\n  if (event) {\n    if (_debug_logEventActivity >= 2) {\n      postLog('drop: ' + event);\n    }\n\n    jqElement.data('dragging', false);\n    targetObjectsDrop = assignViewModelToObject(targetObjects, declViewModel);\n    processDrop(event, {}, jqElement, targetObjectsDrop, props);\n  }\n};\nexport const postLog = message => {\n  logger.info(message);\n};\n\nconst retrieveTileGroupIndex = (tileGroups, group) => {\n  if (tileGroups) {\n    return tileGroups.indexOf(group);\n  }\n\n  return -1;\n};\n\nconst assignViewModelToObject = (targetObjects, declViewModel) => {\n  let targetObjectsUpdated = { ...targetObjects\n  };\n  targetObjectsUpdated.viewModel = declViewModel;\n  return targetObjectsUpdated;\n};\n\nexport default {\n  getBaseOrder,\n  addDragDataToDragEvent,\n  updateDragImage,\n  processDragStart,\n  processDragOver,\n  processDragEnter,\n  processDragLeave,\n  processDragEnd,\n  processDrop,\n  dragStartFn,\n  dragEndFn,\n  dragOverFn,\n  dragEnterFn,\n  dragLeaveFn,\n  dropFn,\n  updateOrder,\n  createNewGroup,\n  reOrderInSameGroup,\n  reOrderInDifferentGroup,\n  retrieveTileInTileGroup,\n  getTileGroup,\n  postLog\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/tile/src/js/tileDragService.js"],"names":["TILEMAIN_CSS_CLASS","TILE_CONT_CSS_CLASS","TILE_DRAGGABLE_CSS_CLASS","TILEGROUP_CSS_CLASS","PLACEHOLDER_GROUP_CSS_CLASS","PLACEHOLDER_TILE_CSS_CLASS","DRAGTILE_CSS_CLASS","TILE_GROUP_TAGNAME","TILE_MAIN_CONTAINER_CSS_CLASS","_debug_logEventActivity","_isValidToDrop","_findDropTargetElement","dropTarget","eventSrc","event","placeholderGroup","$","parentTileElem","_findDragEnterElement","dragEnterElement","_removePlaceHolders","_createPlaceHolderTileGroup","newTileGroup","_createPlaceHolderTile","placeHolderTile","_cleanUp","dragTileIn","dragTile","document","tileContElem","postLog","_processDragEnterInternal","targetCssOrder","targetElement","order","parseInt","element","mouseX","elementWidth","halfElementWidth","side","_","nextSib","tgtTile","targetObjects","targetGroupElem","placeHolderTileGroup","droppedTileInfo","targetTile","targetTileGroup","viewModel","tensAndOnesDigits","orderNumber","sourceTile","dragDataMap","sourceGroupName","groupName","draggedTileInfo","browserUtils","callBackAPIs","srcElement","sourceTileGroup","containerId","Date","width","index","parentTileMinWidth","updateDragImage","addDragDataToDragEvent","targetData","debounceProcessDragEnter","evtElement","propertyToUpdate","isNewGroup","prevSiblings","nextSiblings","sibling","draggingData","dragDataTile","JSON","canvasViewModel","updateOrder","tileGroupElemData","tileGroupData","createNewGroup","dragStartFn","declViewModel","panelElement","jqElement","targetObjectsDragStart","assignViewModelToObject","processDragStart","dragEndFn","target","targetObjectsDragEnd","processDragEnd","dragOverFn","debounceProcessDragOver","dragEnterFn","targetObjectsDragEnter","processDragEnter","sourceGroup","self","sourceGroupIndx","retrieveTileGroupIndex","targetGroupIndx","sourceTileIn","retrieveTileInTileGroup","sourceTileIndx","baseOrder","newGroupIncrement","getBaseOrder","srcGroup","srcGroupNull","newGroup","tile","newGroupIndx","tileGroup","grpBaseOrder","targetTileOrder","targetGroup","getTileGroup","targetTileIndx","targetBaseOrder","reOrderInSameGroup","reOrderInDifferentGroup","tileGroupIn","tileObj","retrievedTile","dispatch","propertyName","updatedTileGroups","sourceBaseOrder","targetGroupDifferent","targetTileIndex","propertyPath","path","value","dragLeaveFn","debounceProcessDragLeave","dropFn","targetObjectsDrop","processDrop","message","logger","tileGroups","targetObjectsUpdated"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * This service manages tiles drag and reorder functionality.\n *\n * @module js/tileDragService\n */\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport browserUtils from 'js/browserUtils';\nimport logger from 'js/logger';\n\n/**\n   * Static Strings referencing css classes\n   */\nvar TILEMAIN_CSS_CLASS = 'aw-tile-tileMain';\nvar TILE_CONT_CSS_CLASS = 'sw-column.aw-tile-tileContainer';\nvar TILE_DRAGGABLE_CSS_CLASS = 'aw-tile-draggable';\nvar TILEGROUP_CSS_CLASS = 'aw-tile-tileGroup';\nvar PLACEHOLDER_GROUP_CSS_CLASS = 'aw-tile-placeHolderGroupSep';\nvar PLACEHOLDER_TILE_CSS_CLASS = 'aw-tile-placeHolderTile';\nvar DRAGTILE_CSS_CLASS = 'aw-tile-dragTile';\nvar TILE_GROUP_TAGNAME = 'aw-tile-group';\nvar TILE_MAIN_CONTAINER_CSS_CLASS = 'aw-tile-mainContainer';\n\n/**\n   * <pre>\n   * Greater Than 0 If some basic event activity should be logged.\n   * Greater Than 1 If some more fine-grained event activity should be logged.\n   * </pre>\n   */\nvar _debug_logEventActivity = 0;\n\nvar placeHolderTile;\nlet draggedTileInfo;\nlet droppedTileInfo;\n\n/**\n   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n   *\n   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n   *            test.\n   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n   */\nvar _isValidToDrop = function( event ) {\n    return true;\n};\n\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   * @param {Boolean} isNewGroup - If a new tile group is to be created\n   *\n   * @return {Element} The Element where we need to reorder and insert dragged tile after this.\n   */\nvar _findDropTargetElement = function( event, isNewGroup ) {\n    var dropTarget = {};\n    dropTarget.inPlace = false;\n    let eventSrc = event.currentTarget;\n\n    if( isNewGroup ) {\n        var placeholderGroup = $( '.' + TILE_MAIN_CONTAINER_CSS_CLASS ).find( '.' + PLACEHOLDER_GROUP_CSS_CLASS );\n        dropTarget.element = placeholderGroup.prev( '.' + TILEGROUP_CSS_CLASS );\n\n        // For the use case of the previous element not being an actual tile group\n        while( dropTarget.element.hasClass( 'aw-tile-emptyTileGroup' ) ) {\n            dropTarget.element = dropTarget.element.prev( '.' + TILEGROUP_CSS_CLASS );\n        }\n\n        // If the new group is in the 1st tile group location\n        if( dropTarget.element.length === 0 ) {\n            dropTarget.element = dropTarget.element.prevObject;\n        }\n\n        dropTarget.element = dropTarget.element[ 0 ];\n        return dropTarget;\n    }\n\n    dropTarget.element = $( '.aw-tile-mainContainer .aw-tile-placeHolderTile' );\n\n    if( dropTarget.element.length === 0 ) {\n        if( !$( eventSrc ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {\n            // find the closest\n            var parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );\n            // if its not on the parent level, then try to find it in the children\n            if( parentTileElem.length === 0 ) {\n                parentTileElem = $( eventSrc ).find( '.' + TILE_DRAGGABLE_CSS_CLASS );\n            }\n\n            if( parentTileElem && parentTileElem.length > 0 ) {\n                dropTarget.element = parentTileElem[ 0 ];\n            }\n        } else {\n            dropTarget.element = eventSrc;\n        }\n    } else {\n        //  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'\n        if( dropTarget.element[ 0 ].style.order === '0' && dropTarget.element.next().length !== 0 ) {\n            dropTarget.element = dropTarget.element.next();\n            dropTarget.inPlace = true;\n        } else {\n            dropTarget.element = dropTarget.element.prev();\n        }\n    }\n\n    return dropTarget;\n};\n\n/**\n   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that\n   * represents to create a new group OR placeHolder tile element to find out the reorder position\n   *\n   * @param {DragEvent} event - The event to start the search at.\n   *\n   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order\n   * of dragged tile.\n   */\nvar _findDragEnterElement = function( event ) {\n    var dragEnterElement;\n    let eventSrc = event.target;\n    // find the closest\n    let parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );\n\n    if( parentTileElem && parentTileElem.length > 0 ) {\n        dragEnterElement = parentTileElem[ 0 ];\n    } else if( $( eventSrc ).hasClass( TILEGROUP_CSS_CLASS ) ) {\n        dragEnterElement = $( eventSrc );\n    }\n\n    return dragEnterElement;\n};\n\n/**\n   * Remove place holder elements from DOM.\n   */\nvar _removePlaceHolders = function() {\n    $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).remove();\n    $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).remove();\n};\n\n/**\n   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping\n   *\n   * @return {Element} The Element which represents dummy placeHolder tileGroup\n   */\nvar _createPlaceHolderTileGroup = function() {\n    // hidden tile to place it where dragging tile will dropped\n    var newTileGroup = $( '<div class=\"' + TILEGROUP_CSS_CLASS + '\"></div>' );\n    newTileGroup.addClass( PLACEHOLDER_GROUP_CSS_CLASS );\n    return newTileGroup;\n};\n\n/**\n   * Create dummy placeHolder Tile element to represent the position in the UI before dropping\n   *\n   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element\n   *\n   * @return {Element} The Element which represents dummy placeHolder tile\n   */\nvar _createPlaceHolderTile = function( sourceTile ) {\n    // hidden tile to place it where dragging tile will dropped\n    placeHolderTile = $( '<div class=\"' + PLACEHOLDER_TILE_CSS_CLASS + '\"></div>' );\n    placeHolderTile.addClass( TILEMAIN_CSS_CLASS );\n\n    if( $( sourceTile ).hasClass( 'aw-tile-doubleSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-doubleSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-tripleSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-quadroSize' );\n    }\n\n    if( $( sourceTile ).hasClass( 'aw-tile-doubleVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-doubleVerticalSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-tripleVerticalSize' );\n    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroVerticalSize' ) ) {\n        placeHolderTile.addClass( 'aw-tile-quadroVerticalSize' );\n    }\n\n    return placeHolderTile;\n};\n\n/**\n   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements\n   *\n   * @param {Element} dragTileIn - The DOM element for dragging tile\n   * @param {Element} element - container element for dragging tile\n   */\nvar _cleanUp = function( dragTileIn, element ) {\n    _removePlaceHolders();\n\n    if( dragTileIn ) {\n        dragTileIn.removeAttribute( 'id' );\n    } else {\n        let dragTile = document.querySelector( '#draggedTile' );\n        dragTile.classList.remove( DRAGTILE_CSS_CLASS );\n        dragTile.removeAttribute( 'id' );\n        let tileContElem = dragTile;\n    }\n\n    placeHolderTile = null;\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'Cleaning up' );\n    }\n};\n\n/**\n   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n   * 'target'.\n   *\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Element} targetElement - The target element associate with dragEnter event\n   */\nvar _processDragEnterInternal = function( event, targetElement, targetObjects ) {\n    event.preventDefault();\n    // place phantom tile instead dragging one\n    if( placeHolderTile && targetElement && targetObjects ) {\n        // reordering in existing tiles\n        if( $( targetElement ).hasClass( TILEMAIN_CSS_CLASS ) && $( targetElement ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {\n            _removePlaceHolders();\n\n            var targetCssOrder = targetElement.style.order;\n            var order = parseInt( targetCssOrder, 10 );\n\n            var side;\n            var element = $( targetElement )[ 0 ];\n            var mouseX = event.clientX;\n            var elementWidth = element.offsetWidth;\n            var halfElementWidth = elementWidth / 2;\n            if( mouseX > halfElementWidth + element.offsetLeft ) {\n                side = 'right';\n            } else {\n                side = 'left';\n            }\n\n            // If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after\n            if( order === 0 && side === 'left' ) {\n                placeHolderTile.insertBefore( targetElement );\n                $( placeHolderTile ).css( 'order', 0 );\n            } else {\n                placeHolderTile.insertAfter( targetElement );\n                $( placeHolderTile ).css( 'order', order++ );\n            }\n\n            _.forEach( $( placeHolderTile ).nextAll(), function( nextSib ) {\n                if( nextSib ) {\n                    nextSib.style.order = order++;\n                }\n            } );\n\n            if( _debug_logEventActivity >= 1 ) {\n                var tgtTile = targetObjects[0].tile;\n\n                postLog( 'processDragEnter - PlaceHolder Tile Inserted: ' + tgtTile.displayName );\n            }\n        } else if( $( targetElement ).hasClass( TILEGROUP_CSS_CLASS ) ) { // vertically or horizontally creating new group\n            _removePlaceHolders();\n\n            var targetGroupElem = $( targetElement );\n            var placeHolderTileGroup = _createPlaceHolderTileGroup();\n            placeHolderTileGroup.insertBefore( targetGroupElem[ 0 ] );\n\n            if( _debug_logEventActivity >= 1 ) {\n                postLog( 'processDragEnter - Insert vertical or horizontal placeHolder Group' );\n            }\n        }\n        droppedTileInfo = {\n            targetTile: targetObjects[0].tile,\n            targetTileGroup: targetObjects[0].tileGroup,\n            viewModel: targetObjects.viewModel\n        };\n    }\n};\n\n/**\n   * Get base order value from the input parameter's order number\n   * <p>\n   * ex: 212 -> returns 200; 399 -> returns 300\n   *\n   * @param {Number} orderNumber - order number\n   * @returns {Number} base order number if orderNumber is defined, otherwise 0\n   */\nfunction getBaseOrder( orderNumber ) {\n    if( !orderNumber ) {\n        return 0;\n    }\n    var tensAndOnesDigits = orderNumber % 100;\n    return orderNumber - tensAndOnesDigits;\n}\n\n/**\n   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n   *\n   * @param {DragEvent} event - The DragEvent to set the DragData on.\n   * @param {Object} dragDataMap - Map of name/value pairs to add.\n   */\nfunction addDragDataToDragEvent( event, dragDataMap ) {\n    if( event.dataTransfer && dragDataMap ) {\n        event.dataTransfer.setData( 'text', JSON.stringify( {\n            sourceTile: dragDataMap.sourceTile,\n            sourceGroupName: dragDataMap.sourceTileGroup.groupName\n        } ) );\n    }\n    draggedTileInfo = dragDataMap;\n}\n\n/**\n   * Update the drag image for the DragEvent based on draggable element.\n   *\n   * @param {DragEvent} event - The DragEvent to set the image on.\n   * @param {DOMElement} draggableElem - element being dragged.\n   */\nfunction updateDragImage( event, draggableElem ) {\n    /**\n       * Internet Explorer doesn't support setDragImage at all.\n       * <P>\n       * See: http://mereskin.github.io/dnd/\n       */\n    if( !browserUtils.isIE && event.dataTransfer ) {\n        /**\n           * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n           * should be resolved after moving the list view to a flex display.\n           */\n        event.dataTransfer.setDragImage( draggableElem, 0, 0 );\n    }\n}\n\n/**\n   * Processes drag start event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   * @param {Element} element - The DOM element considered the 'source' of the given drag event.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   */\nfunction processDragStart( event, element, targetObjects, callBackAPIs = {} ) {\n    let srcElement = event.target;\n    let sourceTile = targetObjects[0].tile;\n    let sourceTileGroup = targetObjects[0].tileGroup;\n    let tileContElem = srcElement.parentElement.parentElement;\n\n    if( sourceTile ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'processDragStart - Source Tile name: ' + sourceTile.displayName +\n                 ' && Source Tile Group name: ' + sourceTileGroup.groupName );\n        }\n\n        element.data( 'dragging', true );\n        var containerId = element.data( 'containerId' );\n\n        if( !containerId ) {\n            containerId = Date.now();\n            element.data( 'containerId', containerId );\n        }\n        let width = 0;\n        for( let index = 0; index < 3; index++ ) {\n            if ( index < sourceTileGroup.tiles.length ) {\n                width += sourceTileGroup.tiles[index].tileSize + 1;\n            } else {\n                break;\n            }\n        }\n\n        // // Default width for the single width tile\n        let parentTileMinWidth = 155 * width + 'px';\n        tileContElem.parentElement.style.minWidth = parentTileMinWidth;\n        tileContElem.setAttribute( 'id', 'draggedTile' );\n        tileContElem.classList.add( DRAGTILE_CSS_CLASS );\n\n        if( event.dataTransfer ) {\n            event.dataTransfer.effectAllowed = 'move'; // only allow moves\n        }\n\n        updateDragImage( event, tileContElem );\n        addDragDataToDragEvent( event, {\n            sourceTile: sourceTile,\n            sourceTileGroup: sourceTileGroup\n        } );\n\n        placeHolderTile = _createPlaceHolderTile( srcElement );\n    } else {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'processDragStart - no tile Info, Set element data \"dragging\" to false' );\n        }\n\n        // No data so there is no reason to let the object be dragged.\n        element.data( 'dragging', false );\n        event.preventDefault();\n    }\n}\n\n/**\n   * Processes drag over event\n   *\n   * @param {DragEvent} event - The event to extract the 'source' element from.\n   */\nfunction processDragOver( event ) {\n    if( event.dataTransfer ) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n}\n\n/**\n   * Processes drag enter event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.\n   */\nfunction processDragEnter( event, targetElement, targetObjects ) {\n    if( _isValidToDrop( event ) ) {\n        let targetData = targetObjects[0].tile;\n        let targetTileGroup = targetObjects[0].tileGroup;\n        if( targetData ) {\n            if( _debug_logEventActivity >= 2 ) {\n                if( targetData.tiles ) {\n                    postLog( 'processDragEnter - Target tileGroup: ' + targetData.groupName );\n                } else if( targetTileGroup && targetData.displayName ) {\n                    postLog( 'processDragEnter - Target tile: ' + targetData.displayName +\n                          ' && Target Item tileGroup: ' + targetTileGroup.groupName );\n                } else if( targetTileGroup && !targetData.displayName ) {\n                    postLog( 'processDragEnter - Target Item tileGroup: ' + targetTileGroup.groupName );\n                }\n            }\n\n            if( !targetData.tiles && ( !targetTileGroup || !targetTileGroup.groupName ) ) {\n                return;\n            }\n\n            if( event.dataTransfer ) {\n                event.dataTransfer.effectAllowed = 'move'; // only allow moves\n            }\n\n            let debounceProcessDragEnter = _.debounce( _processDragEnterInternal, 100 );\n            debounceProcessDragEnter( event, targetElement, targetObjects );\n        }\n    }\n}\n\n/**\n   * Processes drag leave event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   */\nfunction processDragLeave( event ) {\n    event.preventDefault();\n\n    if( event.dataTransfer ) {\n        event.dataTransfer.effectAllowed = 'move'; // only allow moves\n    }\n}\n\n/**\n   * Processes drag end event\n   *\n   * @param {DragEvent} event - The event to extract the 'target' element from.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   */\nfunction processDragEnd( event, element, targetObjects ) {\n    event.preventDefault();\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDragEnd - Processing drag end' );\n    }\n\n    let evtElement = event.target.parentElement.parentElement;\n    $( evtElement ).removeClass( DRAGTILE_CSS_CLASS );\n    $( evtElement ).removeAttr( 'id' );\n\n    let tileContElem = event.target;\n}\n\n/**\n   * @param {DragEvent} event - The drag event with the 'target' to process.\n   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.\n   * @param {Element} element - The DOM element considered the 'target' of the given drag event.\n   * @param {Object}  targetObjects\n   */\nfunction processDrop( event, callBackAPIs, element, targetObjects, props ) {\n    const propertyToUpdate = props;\n    event.stopPropagation();\n    event.preventDefault();\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDrop - Processing drop' );\n    }\n\n    let dragTile = document.querySelector( '#draggedTile' );\n    var isNewGroup = false;\n    dragTile.classList.remove( DRAGTILE_CSS_CLASS );\n    dragTile.parentElement.style.minWidth = '';\n    let tileContElem = dragTile.firstElementChild.firstElementChild;\n\n    if( $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).length > 0 ) {\n        var prevSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).prevAll();\n        var nextSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).nextAll();\n        var index = 0;\n\n        _.forEachRight( prevSiblings, function( sibling ) {\n            if( sibling.id !== 'draggedTile' ) {\n                sibling.style.order = index;\n                index++;\n            }\n        } );\n\n        if( dragTile ) {\n            dragTile.style.order = index;\n            index++;\n            if( _debug_logEventActivity >= 1 ) {\n                postLog( 'processDrop - Set new order style for dragged tile' );\n            }\n        }\n\n        _.forEach( nextSiblings, function( sibling ) {\n            if( sibling.id !== 'draggedTile' ) {\n                sibling.style.order = index;\n                index++;\n            }\n        } );\n    } else if( $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).length > 0 ) {\n        isNewGroup = true;\n    }\n\n    let targetElement = _findDropTargetElement( event, isNewGroup );\n    if( !targetElement.element ) {\n        _cleanUp( dragTile );\n        return;\n    }\n\n    let draggingData = event.dataTransfer.getData( 'text' );\n\n    if( _debug_logEventActivity >= 1 ) {\n        postLog( 'processDrop - Retrieving drag data' );\n    }\n\n    if( draggingData ) {\n        var dragDataTile = JSON.parse( draggingData );\n        var targetTile = droppedTileInfo.targetTile;\n        let targetTileGroup = droppedTileInfo.targetTileGroup;\n        let canvasViewModel = droppedTileInfo.viewModel;\n        if( !isNewGroup && updateOrder && targetTile !== dragDataTile.sourceTile ) {\n            updateOrder( canvasViewModel, dragDataTile.sourceTile, dragDataTile.sourceGroupName, targetTile, targetTileGroup, targetElement.inPlace, propertyToUpdate );\n        } else if( isNewGroup && createNewGroup ) {\n            var tileGroupElemData = targetObjects[0].tile;\n            var tileGroupData;\n\n            if( tileGroupElemData ) {\n                tileGroupData = tileGroupElemData.tileGroup;\n            }\n            createNewGroup( dragDataTile.sourceTile, dragDataTile.sourceGroupName, tileGroupData, propertyToUpdate );\n        }\n\n        if( _debug_logEventActivity >= 1 ) {\n            postLog( 'processDrop - Dropping data: ' + draggingData );\n        }\n    }\n\n    _cleanUp( dragTile );\n}\n\nexport const dragStartFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragStart;\n    event.stopPropagation();\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    if( event.target.nodeName === '#text' ) {\n        jqElement.data( 'dragging', false );\n        event.preventDefault();\n    } else {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragstart: ' + event );\n        }\n        targetObjectsDragStart = assignViewModelToObject( targetObjects, declViewModel );\n        processDragStart( event, jqElement, targetObjectsDragStart, {} );\n    }\n};\n\nexport const dragEndFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragEnd;\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragend: ' + event );\n        }\n\n        jqElement.data( 'dragging', false );\n\n        var target = _findDropTargetElement( event );\n        if( !target ) {\n            return;\n        }\n        targetObjectsDragEnd = assignViewModelToObject( targetObjects, declViewModel );\n        processDragEnd( event, jqElement, targetObjectsDragEnd );\n    }\n};\n\nexport const dragOverFn = ( { event, targetObjects, declViewModel } ) => {\n    event.stopPropagation();\n    event.preventDefault();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragover: ' + event );\n        }\n\n        if( _isValidToDrop( event ) ) {\n            if( event.dataTransfer && !browserUtils.isQt ) {\n                event.dataTransfer.dropEffect = 'move'; // only allow moves\n            }\n\n            event.stopPropagation();\n            event.preventDefault();\n            var debounceProcessDragOver = _.debounce( processDragOver, 100 );\n            debounceProcessDragOver( event );\n        }\n    }\n};\n\nexport const dragEnterFn = ( { event, targetObjects, declViewModel } ) => {\n    let targetObjectsDragEnter;\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragenter: ' + event );\n        }\n\n        var target = _findDragEnterElement( event );\n        if( !target ) {\n            return;\n        }\n        targetObjectsDragEnter = assignViewModelToObject( targetObjects, declViewModel );\n        targetObjects.viewModel = declViewModel;\n        processDragEnter( event, target, targetObjectsDragEnter );\n    }\n};\n\nexport const createNewGroup = function( viewModel, sourceTile, sourceGroupName, targetTileGroup ) {\n    var sourceGroup = self.getTileGroup( sourceGroupName );\n    var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );\n    var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetTileGroup );\n\n    var sourceTileIn = retrieveTileInTileGroup( sourceTile, sourceGroupIndx );\n    var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n\n    var baseOrder = 0;\n    var newGroupIncrement = 100;\n    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {\n        baseOrder = getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );\n    }\n\n    // remove tile from source group\n    var srcGroup = viewModel.tileGroups[ sourceGroupIndx ];\n    srcGroup.tiles.splice( sourceTileIndx, 1 );\n\n    var srcGroupNull = false;\n    // If we removed the last tile in the group\n    if( srcGroup.tiles.length === 0 ) {\n        srcGroupNull = true;\n    }\n\n    // create new group using current time\n    var newGroup = {};\n    newGroup.groupName = 'group' + new Date().getTime();\n\n    // add sourceTile to newly created group\n    newGroup.tiles = [];\n    newGroup.tiles.push( sourceTileIn );\n\n    newGroup.tiles.forEach( function( tile, indx ) {\n        tile.orderNumber = baseOrder + newGroupIncrement + indx;\n        tile.isDirty = true;\n    } );\n\n    // update tileGroups array\n    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {\n        viewModel.tileGroups.splice( targetGroupIndx, 0, newGroup );\n    } else {\n        viewModel.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );\n    }\n\n    var newGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, newGroup );\n\n    // update order number for all tiles in each and every tile group\n    _.forEach( viewModel.tileGroups, function( tileGroup, index ) {\n        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {\n            var grpBaseOrder = getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );\n            tileGroup.tiles.map( function( tile, indx ) {\n                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;\n                tile.isDirty = true;\n                return tile;\n            } );\n        }\n    } );\n};\n\nexport const updateOrder = function( viewModel, sourceTile, sourceGroupName, targetTile, targetTileGroup, inPlace, propertyToUpdate ) {\n    if( targetTile ) {\n        var targetTileOrder = targetTile.orderNumber;\n\n        var targetGroup = getTileGroup( viewModel, targetTileGroup.groupName );\n        var sourceGroup = getTileGroup( viewModel, sourceGroupName );\n        var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );\n        var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetGroup );\n\n        var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );\n\n        var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );\n        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );\n        var targetBaseOrder = getBaseOrder( targetTileOrder );\n\n        if( sourceGroupIndx === targetGroupIndx ) { // same group rearrange\n            reOrderInSameGroup( sourceTileIn, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace );\n        } else { // different group rearrange\n            reOrderInDifferentGroup( viewModel, sourceTileIn, sourceTileIndx, sourceGroupIndx, targetTileIndx,\n                targetGroupIndx, targetBaseOrder, inPlace, propertyToUpdate );\n        }\n    }\n};\n\nexport const getTileGroup = function( viewModel, groupName ) {\n    var tileGroupIn;\n    _.forEach( viewModel.tileGroups, function( tileGroup ) {\n        if( tileGroup.groupName === groupName ) {\n            tileGroupIn = tileGroup;\n            return false;\n        }\n        return true;\n    } );\n\n    return tileGroupIn;\n};\n\nexport const retrieveTileInTileGroup = function( viewModel, tile, groupIndex ) {\n    var retrievedTile;\n\n    if( viewModel.tileGroups[ groupIndex ] && !_.isEmpty( viewModel.tileGroups[ groupIndex ].tiles ) ) {\n        _.forEach( viewModel.tileGroups[ groupIndex ].tiles, function( tileObj ) {\n            if( _.isEqual( tileObj.displayName, tile.displayName ) ) {\n                retrievedTile = tileObj;\n                return false;\n            }\n            return true;\n        } );\n    }\n\n    return retrievedTile;\n};\n\nexport const reOrderInSameGroup = function( sourceTile, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace ) {\n    if( targetTileGroup ) {\n        targetTileGroup.tiles.splice( sourceTileIndx, 1 );\n\n        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );\n        if( inPlace ) {\n            targetTileGroup.tiles.splice( targetTileIndx, 0, sourceTile );\n        } else {\n            targetTileGroup.tiles.splice( targetTileIndx + 1, 0, sourceTile );\n        }\n\n        _.forEach( targetTileGroup.tiles, function reorderTiles( tile, index ) {\n            if( tile ) {\n                tile.orderNumber = targetBaseOrder + index;\n                tile.isDirty = true;\n            }\n        } );\n    }\n};\n\nexport const reOrderInDifferentGroup = function( viewModel, sourceTile, sourceTileIndex, sourceGroupIndex, targetTileIndex,\n    targetGroupIndex, targetBaseOrder, inPlace, propertyToUpdate ) {\n    const { dispatch } = viewModel;\n    const propertyName = propertyToUpdate;\n    let updatedTileGroups = { ...viewModel.getData() }.tileGroups;\n    var sourceBaseOrder = getBaseOrder( sourceTile.orderNumber );\n    var srcGroup = updatedTileGroups[ sourceGroupIndex ];\n    var targetGroupDifferent = updatedTileGroups[ targetGroupIndex ];\n    // remove tile from source group\n    srcGroup.tiles.splice( sourceTileIndex, 1 );\n    // add tile to target group\n    if( inPlace ) {\n        targetGroupDifferent.tiles.splice( targetTileIndex, 0, sourceTile );\n    } else {\n        targetGroupDifferent.tiles.splice( targetTileIndex + 1, 0, sourceTile );\n    }\n\n    // modify order in source group\n    srcGroup.tiles.map( function( tile, idx ) {\n        tile.orderNumber = sourceBaseOrder + idx;\n        tile.isDirty = true;\n        return tile;\n    } );\n    updatedTileGroups[ sourceGroupIndex ] = srcGroup;\n    // modify order in target group\n    targetGroupDifferent.tiles.map( function( tile, idx ) {\n        tile.orderNumber = targetBaseOrder + idx;\n        tile.isDirty = true;\n        return tile;\n    } );\n    updatedTileGroups[ targetGroupIndex ] = targetGroupDifferent;\n    let propertyPath = propertyName ? 'data.' + propertyName : 'data.tileGroups';\n    dispatch( { path: propertyPath, value: [ ...updatedTileGroups ] } );\n};\n\nexport const dragLeaveFn = ( { event, targetObjects, declViewModel } ) => {\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'dragleave: ' + event );\n        }\n        var debounceProcessDragLeave = _.debounce( processDragLeave, 100 );\n        debounceProcessDragLeave( event );\n    }\n};\n\nexport const dropFn = ( props, {  event, targetObjects, declViewModel } ) => {\n    let targetObjectsDrop;\n    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );\n    var jqElement = $( panelElement );\n    event.stopPropagation();\n    if( event ) {\n        if( _debug_logEventActivity >= 2 ) {\n            postLog( 'drop: ' + event );\n        }\n\n        jqElement.data( 'dragging', false );\n        targetObjectsDrop = assignViewModelToObject( targetObjects, declViewModel );\n        processDrop( event, {}, jqElement, targetObjectsDrop, props );\n    }\n};\n\nexport const postLog = ( message ) => {\n    logger.info( message );\n};\n\nconst retrieveTileGroupIndex = ( tileGroups, group ) => {\n    if( tileGroups ) {\n        return tileGroups.indexOf( group );\n    }\n    return -1;\n};\n\nconst assignViewModelToObject = ( targetObjects, declViewModel ) => {\n    let targetObjectsUpdated = { ...targetObjects };\n    targetObjectsUpdated.viewModel = declViewModel;\n    return targetObjectsUpdated;\n};\n\nexport default {\n    getBaseOrder,\n    addDragDataToDragEvent,\n    updateDragImage,\n    processDragStart,\n    processDragOver,\n    processDragEnter,\n    processDragLeave,\n    processDragEnd,\n    processDrop,\n    dragStartFn,\n    dragEndFn,\n    dragOverFn,\n    dragEnterFn,\n    dragLeaveFn,\n    dropFn,\n    updateOrder,\n    createNewGroup,\n    reOrderInSameGroup,\n    reOrderInDifferentGroup,\n    retrieveTileInTileGroup,\n    getTileGroup,\n    postLog\n};\n\n"]},"metadata":{},"sourceType":"module"}