{"ast":null,"code":"// Copyright (c) 2022 Siemens\n\n/**\n * A simple and inexpensive HTML Sanitizer which detects and/or eliminates HTML that can cause potential cross-site\n * scripting (XSS) and other UI issues.\n *\n * @module js/sanitizer\n */\nimport _ from 'lodash';\nimport localeSvc from 'js/localeService';\n/**\n * HTML 'anchor' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_ANCHOR_SCRIPT = /href=\"[^\"]*?java[^\"]*?\"/;\n/**\n * HTML 'src=java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_SRC_SCRIPT = /src=java*/;\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_SCRIPT = /style=\"[^\"]*?java[^\"]*?\"/;\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_WEIRD = /style=\"[^\"]*?&[^\"]*?\"/;\n/**\n * HTML '<style on*=' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\n\nvar REGEX_FRAGMENT_STYLE_ATTR = /<style.*(on\\S+)(\\s*)=/;\n/**\n * HTML entity regular expression\n *\n * @private\n */\n\nvar REGEX_HTML_ENTITY = /[a-z]+|#[0-9]+|#x[0-9a-fA-F]+/i;\n/**\n * HTML 'on*' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\n\nvar REGEX_IMG_ATTR = /(\\b)(on\\S+)(\\s*)=/i;\n/**\n * HTML 'base64' regular expression (e.g. 'data:image/jpeg;base64').\n *\n * @private\n */\n\nvar REGEX_BASE64_IMG = /(\\b)(src=\"data:image\\S+)(\\s*)base64/i;\n/**\n * HTML escaped entity regular expression\n *\n * @private\n */\n\nvar REGEX_HTML_ESCAPED_ENTITY = /&[a-z]+;|&#[0-9]+;/i;\n/**\n * {RegEx} Matches external links\n */\n\nvar REGEX_URL_PATTERN = /http(|s):\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+#()[\\]\\-])?|http(|s):\\/\\/([\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+\\*#()[\\]\\-])?/gi; // eslint-disable-line no-useless-escape\n\n/**\n * HTML 'image' regular expression\n *\n * @private\n */\n\nvar REGEX_INVALID_HTML = new RegExp(REGEX_FRAGMENT_ANCHOR_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_SRC_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_STYLE_SCRIPT.source + '|' //\n+ REGEX_FRAGMENT_STYLE_ATTR.source + '|' //\n+ REGEX_FRAGMENT_STYLE_WEIRD.source, 'i');\n/**\n * Global array of HTML black list tags used for sanitization\n *\n * @private\n */\n\nvar TAG_BLACKLIST = ['applet', 'audio', 'body', 'embed', 'fieldset', 'form', 'frame', 'frameset', 'input', 'iframe', 'meta', 'object', 'output', 'param', 'script', 'style', 'textarea', 'video'];\n/**\n * Global reference to invalid HTML locale string\n *\n * @private\n */\n\nvar _invalidHtmlMessage = null;\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\n\nlet exports;\n/**\n * HTML escapes a character. HTML meta characters will be escaped.\n *\n * @private\n *\n * @param {String} unsafe - unsafe HTML String which needs to be escaped.\n *\n * @return {String} Returns escaped and safe HTML String.\n */\n\nfunction _escapeHtml(unsafe) {\n  if (!/['\"<>&]+/.test(unsafe)) {\n    return unsafe;\n  }\n\n  return unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n/**\n * HTML meta characters will be un-escaped. This method should be used only after sanitizing the input.\n *\n * @private\n *\n * @param {String} escapedSafe - escapedSafe HTML String which needs to be un-escaped.\n *\n * @return {String} Returns un-escaped and safe HTML String.\n */\n\n\nfunction _unEscapeHtml(escapedSafe) {\n  // eslint-disable-line no-unused-vars\n  return escapedSafe.replace(/&amp;/ig, '&').replace(/&lt;/ig, '<').replace(/&gt;/ig, '>').replace(/&quot;/ig, '\"').replace(/&#39;/ig, '\\'');\n}\n/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n *\n * @param {Boolean} replaceAnchors - TRUE if any HTTP type external references should be wrapped in an HTML <a\n *            href=\"XXXXX\"></a> (i.e. 'anchors').\n *\n * @param {Boolean} replaceNewLines - TRUE if any newline characters should be replaced by an HTML '<BR>'\n *\n * @return {String} Returns escaped and safe HTML.\n */\n\n\nexport let htmlEscapeAllowEntities = function (value, replaceAnchors, replaceNewLines) {\n  if (_.isString(value) && value.length > 0) {\n    if (!/(['\"<>&]+|(http)+|\\n)/i.test(value)) {\n      return value;\n    }\n\n    var escaped;\n\n    if (!/&+/.test(value)) {\n      escaped = _escapeHtml(value);\n    } else {\n      var splitArray = value.split('&', -1);\n      var nSegment = splitArray.length;\n\n      for (var ndx = 0; ndx < nSegment; ndx++) {\n        var currSegment = splitArray[ndx];\n        /**\n         * The first segment is never part of a valid tag;\n         * <P>\n         * Note that if the input string starts with a tag, we will get an empty segment at the\n         * beginning.\n         */\n\n        if (ndx === 0) {\n          escaped = _escapeHtml(currSegment);\n          continue;\n        }\n\n        var entityEnd = currSegment.indexOf(';');\n\n        if (entityEnd > 0 && REGEX_HTML_ENTITY.test(currSegment.substring(0, entityEnd))) {\n          // Concatenate the entity without escaping.\n          escaped = escaped.concat('&').concat(currSegment.substring(0, entityEnd + 1)); // Concatenate the rest of the segment, escaped.\n\n          escaped = escaped.concat(_escapeHtml(currSegment.substring(entityEnd + 1)));\n        } else {\n          // The segment did not start with an entity reference, so escape the whole segment.\n          escaped = escaped.concat('&amp;').concat(_escapeHtml(currSegment));\n        }\n      }\n    }\n\n    if (replaceAnchors && escaped) {\n      // replaces url text to hyperlinks\n      escaped = escaped.replace(REGEX_URL_PATTERN, '<a href=\"$&\">$&</a>');\n    }\n\n    if (replaceNewLines && escaped) {\n      // replaces new lines to <br> tags\n      escaped = escaped.replace(/\\n/g, '<br/>');\n    }\n\n    return escaped;\n  }\n\n  return '';\n};\n/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list\n * tags.\n *\n * @param {StringArray} values - Array of HTML Strings which needs to be sanitized.\n *\n * @return {StringArray} Returns sanitized HTML string array.\n */\n\nexport let sanitizeHtmlValues = function (values) {\n  if (values && values.length > 0) {\n    for (var ii = values.length - 1; ii >= 0; ii--) {\n      var originalHtml = values[ii];\n      var sanitizedHtml = exports.sanitizeHtmlValue(originalHtml);\n\n      if (sanitizedHtml && originalHtml !== sanitizedHtml) {\n        values[ii] = sanitizedHtml;\n      }\n    }\n  }\n\n  return values;\n};\n/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n *\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */\n\nexport let sanitizeHtmlValue = function (rawValue) {\n  var sanitized = '';\n  var decodedValue = '';\n\n  if (_.isString(rawValue)) {\n    // load _invalidHtmlMessage if it is not loaded\n    if (!_invalidHtmlMessage) {\n      exports.setInvalidHtmlMessage(localeSvc.getLoadedText().INVALID_HTML);\n    }\n    /**\n     * Decode html escaped entity characters before applying sanitization, so that it will also catch\n     * escaped XSS vulnerability attacks.\n     */\n\n\n    if (REGEX_HTML_ESCAPED_ENTITY.test(rawValue)) {\n      decodedValue = _.unescape(rawValue);\n    } else {\n      decodedValue = rawValue;\n    }\n    /**\n     * Break the string into n+1 segments based on any HTML tags\n     * <P>\n     * Loop for each of these segments.\n     */\n\n\n    var splitArray = decodedValue.split('<', -1);\n    var nSplit = splitArray.length;\n\n    for (var ndx = 0; ndx < nSplit; ndx++) {\n      var currSegment = splitArray[ndx];\n      /**\n       * The first segment is never part of a valid tag;\n       * <P>\n       * Note that if the input string starts with a tag, we will get an empty segment at the beginning.\n       */\n\n      if (ndx === 0) {\n        sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));\n        continue;\n      }\n      /**\n       * Determine if the current segment is the start of an attribute-free tag or end-tag in our\n       * whitelist.\n       */\n\n\n      var tagStart = 0; // will be 1 if this turns out to be an end tag.\n\n      var tagEnd = currSegment.indexOf('>');\n      var tag = null;\n      var isValidTag = true;\n      var selfClosingTag = false;\n\n      if (tagEnd > 0) {\n        if (currSegment.charAt(0) === '/') {\n          tagStart = 1;\n        } // for self closing tags ex: '<br />'\n\n\n        if (currSegment.charAt(tagEnd - 1) === '/') {\n          selfClosingTag = true;\n          tagEnd -= 1;\n        }\n\n        tag = currSegment.substring(tagStart, tagEnd);\n        var exist = tag.replace(/\\s(\\w|\\D).*/ig, ''); // for attributes\n\n        if (TAG_BLACKLIST.indexOf(exist.toLowerCase().trim()) !== -1) {\n          isValidTag = false;\n        }\n\n        if (isValidTag) {\n          // concat the tag, not escaping it\n          if (tagStart === 0) {\n            /**\n             * Check for image attribute script <BR>\n             * <img src=\"\" onerror=\"alert('securityIssue_img');\"/>\n             */\n            if (REGEX_BASE64_IMG.test(tag)) {\n              // split tag into attributes, and process individually\n              // to avoid false positives.\n              var attributes = tag.match(/[\\w-]+=\"[^\"]*\"/g);\n\n              for (var i = 0; i < attributes.length; i++) {\n                if (attributes[i].indexOf('src=') < 0 && REGEX_IMG_ATTR.test(attributes[i])) {\n                  return _invalidHtmlMessage;\n                }\n              }\n            } else if (REGEX_IMG_ATTR.test(tag)) {\n              return _invalidHtmlMessage;\n            }\n\n            sanitized = sanitized.concat('<');\n          } else {\n            // we had seen an end-tag\n            sanitized = sanitized.concat('</');\n          }\n\n          if (selfClosingTag) {\n            sanitized = sanitized.concat(tag).concat('/>'); // concat the rest of the segment, escaping it\n\n            sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd + 2)));\n          } else {\n            sanitized = sanitized.concat(tag).concat('>'); // concat the rest of the segment, escaping it\n\n            sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment.substring(tagEnd + 1)));\n          }\n        } else {\n          return _invalidHtmlMessage;\n        }\n      } else {\n        sanitized = sanitized.concat('<');\n        sanitized = sanitized.concat(exports.htmlEscapeAllowEntities(currSegment));\n      }\n    }\n    /**\n     * Check for weird style stuff\n     */\n\n\n    if (REGEX_INVALID_HTML.test(sanitized)) {\n      return _invalidHtmlMessage;\n    }\n  }\n\n  return rawValue;\n};\n/**\n * Set the message that is seen when invalid HTML content is found.\n * <P>\n * Note: This message is normally set based on the value returned by the 'localeService'. This method is marked\n * 'private' and is intended to be used during testing to allow a preditable value to be returned.\n *\n * @private (this method should be used for unit test only)\n *\n * @param {String} message - Localized text to return from 'sanitizeHtmlValue' when some issue is found.\n */\n\nexport let setInvalidHtmlMessage = function (message) {\n  _invalidHtmlMessage = message;\n};\n/**\n * Escape markup which Highcharts will unescape internally\n *\n * Full sanitize is not necessary (and causes issues) because Highcharts internally sets as\n * text on DOM element (does not create element from string)\n *\n * @param {String} x Value to escape\n * @returns {String} Escaped value\n */\n\nexport const escapeMarkup = x => x.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n/**\n * This API sanitizes props to be sent to native html elements to avoid console warnings.\n * It however allows to bypass few custom-attributes if mentioned in argument.\n * Use this if any valid custom attributes to be excluded from being filtered out.\n *\n *\n * @param {Object} props - props coming from component.\n * @param {String} htmlElement - name of htmlElement for which a sanitization is requried\n * @returns {Object} sanitizedProps - Returns valid sanitized props good to use on native html element.\n */\n\nexport const sanitizeHTMLTagProps = (props, htmlElement) => {\n  //placeHolder to allow custom attributes on given html tag.\n  //maintain a list of custom attributes or exception props that are required to bypass sanitization check.\n  //Make sure this list shouldn't contribute to react console warnings.\n  let customAttributes;\n  let excludeAttributes = [];\n\n  switch (htmlElement) {\n    case 'input':\n      customAttributes = ['label', 'data-locator', 'onKeyDown', 'dirty', 'checked'];\n      break;\n\n    case 'span':\n      customAttributes = ['data-locator', 'value'];\n      excludeAttributes = ['aria-label', 'aria-required'];\n      break;\n\n    case 'div':\n    case 'nav':\n    case 'main':\n    case 'textarea':\n    default:\n      customAttributes = ['data-locator'];\n  }\n\n  let sanitizedProps = {};\n  let dummyHtmlElem = document.createElement(htmlElement);\n  let filteredAttribs = Object.keys(props).filter(propName => !excludeAttributes.includes(propName) && (propName in dummyHtmlElem || propName.toLowerCase() in dummyHtmlElem || _.camelCase(propName) in dummyHtmlElem || customAttributes.includes(propName)));\n  filteredAttribs.forEach(key => sanitizedProps[key] = props[key]);\n  return sanitizedProps;\n};\nexports = {\n  htmlEscapeAllowEntities,\n  sanitizeHtmlValues,\n  sanitizeHtmlValue,\n  setInvalidHtmlMessage,\n  escapeMarkup,\n  sanitizeHTMLTagProps\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/sanitizer.js"],"names":["REGEX_FRAGMENT_ANCHOR_SCRIPT","REGEX_FRAGMENT_SRC_SCRIPT","REGEX_FRAGMENT_STYLE_SCRIPT","REGEX_FRAGMENT_STYLE_WEIRD","REGEX_FRAGMENT_STYLE_ATTR","REGEX_HTML_ENTITY","REGEX_IMG_ATTR","REGEX_BASE64_IMG","REGEX_HTML_ESCAPED_ENTITY","REGEX_URL_PATTERN","REGEX_INVALID_HTML","TAG_BLACKLIST","_invalidHtmlMessage","unsafe","escapedSafe","htmlEscapeAllowEntities","_","value","escaped","_escapeHtml","splitArray","nSegment","ndx","currSegment","entityEnd","replaceAnchors","replaceNewLines","sanitizeHtmlValues","values","ii","originalHtml","sanitizedHtml","exports","sanitizeHtmlValue","sanitized","decodedValue","localeSvc","nSplit","tagStart","tagEnd","tag","isValidTag","selfClosingTag","exist","attributes","i","setInvalidHtmlMessage","escapeMarkup","x","sanitizeHTMLTagProps","excludeAttributes","customAttributes","sanitizedProps","dummyHtmlElem","document","filteredAttribs","Object","propName","key","props"],"mappings":"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","sourcesContent":["// Copyright (c) 2022 Siemens\n\n/**\n * A simple and inexpensive HTML Sanitizer which detects and/or eliminates HTML that can cause potential cross-site\n * scripting (XSS) and other UI issues.\n *\n * @module js/sanitizer\n */\nimport _ from 'lodash';\nimport localeSvc from 'js/localeService';\n\n/**\n * HTML 'anchor' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_ANCHOR_SCRIPT = /href=\"[^\"]*?java[^\"]*?\"/;\n\n/**\n * HTML 'src=java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_SRC_SCRIPT = /src=java*/;\n\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_SCRIPT = /style=\"[^\"]*?java[^\"]*?\"/;\n\n/**\n * HTML 'style=\"java' regular expression\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_WEIRD = /style=\"[^\"]*?&[^\"]*?\"/;\n\n/**\n * HTML '<style on*=' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\nvar REGEX_FRAGMENT_STYLE_ATTR = /<style.*(on\\S+)(\\s*)=/;\n\n/**\n * HTML entity regular expression\n *\n * @private\n */\nvar REGEX_HTML_ENTITY = /[a-z]+|#[0-9]+|#x[0-9a-fA-F]+/i;\n\n/**\n * HTML 'on*' regular expression (e.g. 'onload=', 'onerror=', etc.).\n *\n * @private\n */\nvar REGEX_IMG_ATTR = /(\\b)(on\\S+)(\\s*)=/i;\n\n/**\n * HTML 'base64' regular expression (e.g. 'data:image/jpeg;base64').\n *\n * @private\n */\nvar REGEX_BASE64_IMG = /(\\b)(src=\"data:image\\S+)(\\s*)base64/i;\n\n/**\n * HTML escaped entity regular expression\n *\n * @private\n */\nvar REGEX_HTML_ESCAPED_ENTITY = /&[a-z]+;|&#[0-9]+;/i;\n\n/**\n * {RegEx} Matches external links\n */\nvar REGEX_URL_PATTERN =\n    /http(|s):\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+#()[\\]\\-])?|http(|s):\\/\\/([\\w\\-]+)+([\\w.,@?\\^=%&amp;:\\/\\$~+\\*#()[\\]\\-]*[\\w@?\\^=%&amp;\\/~+\\*#()[\\]\\-])?/gi; // eslint-disable-line no-useless-escape\n\n/**\n * HTML 'image' regular expression\n *\n * @private\n */\nvar REGEX_INVALID_HTML = new RegExp( REGEX_FRAGMENT_ANCHOR_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_SRC_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_SCRIPT.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_ATTR.source + '|' //\n    +\n    REGEX_FRAGMENT_STYLE_WEIRD.source, 'i' );\n\n/**\n * Global array of HTML black list tags used for sanitization\n *\n * @private\n */\nvar TAG_BLACKLIST = [ 'applet', 'audio', 'body', 'embed', 'fieldset', 'form', 'frame', 'frameset', 'input',\n    'iframe', 'meta', 'object', 'output', 'param', 'script', 'style', 'textarea', 'video'\n];\n\n/**\n * Global reference to invalid HTML locale string\n *\n * @private\n */\nvar _invalidHtmlMessage = null;\n\n/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */\nlet exports;\n\n/**\n * HTML escapes a character. HTML meta characters will be escaped.\n *\n * @private\n *\n * @param {String} unsafe - unsafe HTML String which needs to be escaped.\n *\n * @return {String} Returns escaped and safe HTML String.\n */\nfunction _escapeHtml( unsafe ) {\n    if( !/['\"<>&]+/.test( unsafe ) ) {\n        return unsafe;\n    }\n\n    return unsafe.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ).replace( /\"/g,\n        '&quot;' ).replace( /'/g, '&#39;' );\n}\n\n/**\n * HTML meta characters will be un-escaped. This method should be used only after sanitizing the input.\n *\n * @private\n *\n * @param {String} escapedSafe - escapedSafe HTML String which needs to be un-escaped.\n *\n * @return {String} Returns un-escaped and safe HTML String.\n */\nfunction _unEscapeHtml( escapedSafe ) { // eslint-disable-line no-unused-vars\n    return escapedSafe.replace( /&amp;/ig, '&' ).replace( /&lt;/ig, '<' ).replace( /&gt;/ig, '>' ).replace(\n        /&quot;/ig, '\"' ).replace( /&#39;/ig, '\\'' );\n}\n\n/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n *\n * @param {Boolean} replaceAnchors - TRUE if any HTTP type external references should be wrapped in an HTML <a\n *            href=\"XXXXX\"></a> (i.e. 'anchors').\n *\n * @param {Boolean} replaceNewLines - TRUE if any newline characters should be replaced by an HTML '<BR>'\n *\n * @return {String} Returns escaped and safe HTML.\n */\nexport let htmlEscapeAllowEntities = function( value, replaceAnchors, replaceNewLines ) {\n    if( _.isString( value ) && value.length > 0 ) {\n        if( !/(['\"<>&]+|(http)+|\\n)/i.test( value ) ) {\n            return value;\n        }\n\n        var escaped;\n\n        if( !/&+/.test( value ) ) {\n            escaped = _escapeHtml( value );\n        } else {\n            var splitArray = value.split( '&', -1 );\n\n            var nSegment = splitArray.length;\n\n            for( var ndx = 0; ndx < nSegment; ndx++ ) {\n                var currSegment = splitArray[ ndx ];\n\n                /**\n                 * The first segment is never part of a valid tag;\n                 * <P>\n                 * Note that if the input string starts with a tag, we will get an empty segment at the\n                 * beginning.\n                 */\n                if( ndx === 0 ) {\n                    escaped = _escapeHtml( currSegment );\n                    continue;\n                }\n\n                var entityEnd = currSegment.indexOf( ';' );\n\n                if( entityEnd > 0 && REGEX_HTML_ENTITY.test( currSegment.substring( 0, entityEnd ) ) ) {\n                    // Concatenate the entity without escaping.\n                    escaped = escaped.concat( '&' ).concat( currSegment.substring( 0, entityEnd + 1 ) );\n\n                    // Concatenate the rest of the segment, escaped.\n                    escaped = escaped.concat( _escapeHtml( currSegment.substring( entityEnd + 1 ) ) );\n                } else {\n                    // The segment did not start with an entity reference, so escape the whole segment.\n                    escaped = escaped.concat( '&amp;' ).concat( _escapeHtml( currSegment ) );\n                }\n            }\n        }\n\n        if( replaceAnchors && escaped ) {\n            // replaces url text to hyperlinks\n            escaped = escaped.replace( REGEX_URL_PATTERN, '<a href=\"$&\">$&</a>' );\n        }\n\n        if( replaceNewLines && escaped ) {\n            // replaces new lines to <br> tags\n            escaped = escaped.replace( /\\n/g, '<br/>' );\n        }\n\n        return escaped;\n    }\n\n    return '';\n};\n\n/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list\n * tags.\n *\n * @param {StringArray} values - Array of HTML Strings which needs to be sanitized.\n *\n * @return {StringArray} Returns sanitized HTML string array.\n */\nexport let sanitizeHtmlValues = function( values ) {\n    if( values && values.length > 0 ) {\n        for( var ii = values.length - 1; ii >= 0; ii-- ) {\n            var originalHtml = values[ ii ];\n            var sanitizedHtml = exports.sanitizeHtmlValue( originalHtml );\n            if( sanitizedHtml && originalHtml !== sanitizedHtml ) {\n                values[ ii ] = sanitizedHtml;\n            }\n        }\n    }\n\n    return values;\n};\n\n/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n *\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */\nexport let sanitizeHtmlValue = function( rawValue ) {\n    var sanitized = '';\n    var decodedValue = '';\n\n    if( _.isString( rawValue ) ) {\n        // load _invalidHtmlMessage if it is not loaded\n        if( !_invalidHtmlMessage ) {\n            exports.setInvalidHtmlMessage( localeSvc.getLoadedText().INVALID_HTML );\n        }\n\n        /**\n         * Decode html escaped entity characters before applying sanitization, so that it will also catch\n         * escaped XSS vulnerability attacks.\n         */\n        if( REGEX_HTML_ESCAPED_ENTITY.test( rawValue ) ) {\n            decodedValue = _.unescape( rawValue );\n        } else {\n            decodedValue = rawValue;\n        }\n\n        /**\n         * Break the string into n+1 segments based on any HTML tags\n         * <P>\n         * Loop for each of these segments.\n         */\n        var splitArray = decodedValue.split( '<', -1 );\n\n        var nSplit = splitArray.length;\n\n        for( var ndx = 0; ndx < nSplit; ndx++ ) {\n            var currSegment = splitArray[ ndx ];\n\n            /**\n             * The first segment is never part of a valid tag;\n             * <P>\n             * Note that if the input string starts with a tag, we will get an empty segment at the beginning.\n             */\n            if( ndx === 0 ) {\n                sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment ) );\n                continue;\n            }\n\n            /**\n             * Determine if the current segment is the start of an attribute-free tag or end-tag in our\n             * whitelist.\n             */\n            var tagStart = 0; // will be 1 if this turns out to be an end tag.\n            var tagEnd = currSegment.indexOf( '>' );\n            var tag = null;\n            var isValidTag = true;\n            var selfClosingTag = false;\n\n            if( tagEnd > 0 ) {\n                if( currSegment.charAt( 0 ) === '/' ) {\n                    tagStart = 1;\n                }\n\n                // for self closing tags ex: '<br />'\n                if( currSegment.charAt( tagEnd - 1 ) === '/' ) {\n                    selfClosingTag = true;\n                    tagEnd -= 1;\n                }\n\n                tag = currSegment.substring( tagStart, tagEnd );\n\n                var exist = tag.replace( /\\s(\\w|\\D).*/ig, '' ); // for attributes\n\n                if( TAG_BLACKLIST.indexOf( exist.toLowerCase().trim() ) !== -1 ) {\n                    isValidTag = false;\n                }\n\n                if( isValidTag ) {\n                    // concat the tag, not escaping it\n                    if( tagStart === 0 ) {\n                        /**\n                         * Check for image attribute script <BR>\n                         * <img src=\"\" onerror=\"alert('securityIssue_img');\"/>\n                         */\n                        if( REGEX_BASE64_IMG.test( tag ) ) {\n                            // split tag into attributes, and process individually\n                            // to avoid false positives.\n                            var attributes = tag.match( /[\\w-]+=\"[^\"]*\"/g );\n\n                            for( var i = 0; i < attributes.length; i++ ) {\n                                if( attributes[ i ].indexOf( 'src=' ) < 0 &&\n                                    REGEX_IMG_ATTR.test( attributes[ i ] ) ) {\n                                    return _invalidHtmlMessage;\n                                }\n                            }\n                        } else if( REGEX_IMG_ATTR.test( tag ) ) {\n                            return _invalidHtmlMessage;\n                        }\n                        sanitized = sanitized.concat( '<' );\n                    } else {\n                        // we had seen an end-tag\n                        sanitized = sanitized.concat( '</' );\n                    }\n\n                    if( selfClosingTag ) {\n                        sanitized = sanitized.concat( tag ).concat( '/>' );\n\n                        // concat the rest of the segment, escaping it\n                        sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment\n                            .substring( tagEnd + 2 ) ) );\n                    } else {\n                        sanitized = sanitized.concat( tag ).concat( '>' );\n\n                        // concat the rest of the segment, escaping it\n                        sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment\n                            .substring( tagEnd + 1 ) ) );\n                    }\n                } else {\n                    return _invalidHtmlMessage;\n                }\n            } else {\n                sanitized = sanitized.concat( '<' );\n                sanitized = sanitized.concat( exports.htmlEscapeAllowEntities( currSegment ) );\n            }\n        }\n\n        /**\n         * Check for weird style stuff\n         */\n        if( REGEX_INVALID_HTML.test( sanitized ) ) {\n            return _invalidHtmlMessage;\n        }\n    }\n\n    return rawValue;\n};\n\n/**\n * Set the message that is seen when invalid HTML content is found.\n * <P>\n * Note: This message is normally set based on the value returned by the 'localeService'. This method is marked\n * 'private' and is intended to be used during testing to allow a preditable value to be returned.\n *\n * @private (this method should be used for unit test only)\n *\n * @param {String} message - Localized text to return from 'sanitizeHtmlValue' when some issue is found.\n */\nexport let setInvalidHtmlMessage = function( message ) {\n    _invalidHtmlMessage = message;\n};\n\n/**\n * Escape markup which Highcharts will unescape internally\n *\n * Full sanitize is not necessary (and causes issues) because Highcharts internally sets as\n * text on DOM element (does not create element from string)\n *\n * @param {String} x Value to escape\n * @returns {String} Escaped value\n */\nexport const escapeMarkup = x => x.replace( /</g, '&lt;' ).replace( />/g, '&gt;' );\n\n/**\n * This API sanitizes props to be sent to native html elements to avoid console warnings.\n * It however allows to bypass few custom-attributes if mentioned in argument.\n * Use this if any valid custom attributes to be excluded from being filtered out.\n *\n *\n * @param {Object} props - props coming from component.\n * @param {String} htmlElement - name of htmlElement for which a sanitization is requried\n * @returns {Object} sanitizedProps - Returns valid sanitized props good to use on native html element.\n */\nexport const sanitizeHTMLTagProps = ( props, htmlElement ) => {\n    //placeHolder to allow custom attributes on given html tag.\n    //maintain a list of custom attributes or exception props that are required to bypass sanitization check.\n    //Make sure this list shouldn't contribute to react console warnings.\n    let customAttributes;\n    let excludeAttributes = [];\n    switch ( htmlElement ) {\n        case 'input':\n            customAttributes = [ 'label', 'data-locator', 'onKeyDown', 'dirty', 'checked' ];\n            break;\n        case 'span':\n            customAttributes = [ 'data-locator', 'value' ];\n            excludeAttributes = [ 'aria-label', 'aria-required' ];\n            break;\n        case 'div':\n        case 'nav':\n        case 'main':\n        case 'textarea':\n        default:\n            customAttributes = [ 'data-locator' ];\n    }\n\n    let sanitizedProps = {};\n    let dummyHtmlElem = document.createElement( htmlElement );\n    let filteredAttribs = Object.keys( props ).filter( ( propName ) =>\n        !excludeAttributes.includes( propName ) && ( propName in dummyHtmlElem || propName.toLowerCase() in dummyHtmlElem ||\n            _.camelCase( propName ) in dummyHtmlElem || customAttributes.includes( propName ) )\n    );\n    filteredAttribs.forEach( ( key ) => sanitizedProps[ key ] = props[ key ] );\n    return sanitizedProps;\n};\nexports = {\n    htmlEscapeAllowEntities,\n    sanitizeHtmlValues,\n    sanitizeHtmlValue,\n    setInvalidHtmlMessage,\n    escapeMarkup,\n    sanitizeHTMLTagProps\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}