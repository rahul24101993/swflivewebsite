{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This file provides helper functions for table selection\n *\n * @module js/splmTableSelectionHelper\n */\nimport awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';\nimport eventBus from 'js/eventBus';\nimport selectionHelper from 'js/selectionHelper';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n/**\n *\n * Handles other select through selection handler\n *\n * @param {Object} rowVmoArray - array of VMOs to select\n * @param {Object} selectionModel - the selection model\n * @param {Object} event - event from the tap/click action\n * @param {Object} dataProvider - declarative dataProvider\n */\n\nconst handleNonContextMenuSelect = function (rowVmoArray, selectionModel, event, dataProvider) {\n  selectionHelper.handleSelectionEvent(rowVmoArray, selectionModel, event, dataProvider.viewModelCollection);\n};\n\nconst selectCell = function (cell, gridOptions, columnDefs, idx, cellRenderer, selectionModel, pinElem, rowElem, table) {\n  cell.classList.add(Const.CLASS_CELL_SELECTED);\n\n  if (gridOptions.transpose === true) {\n    cell.classList.add('ui-grid-columnSelected');\n    return;\n  }\n\n  const isCommandNeeded = columnDefs[idx].isTableCommand || columnDefs[idx].isTreeNavigation;\n\n  if (!isCommandNeeded) {\n    return;\n  }\n\n  let cellTop = cell.children[0];\n\n  if (columnDefs[idx].isTreeNavigation && cell.getElementsByClassName('aw-jswidgets-tableNonEditContainer').length > 0) {\n    cellTop = cell.getElementsByClassName('aw-jswidgets-tableNonEditContainer')[0];\n  }\n\n  cellRenderer.resetHoverCommandElement(); // process OOTB cmd cell\n\n  if (cellTop.lastChild && cellTop.lastChild.classList && cellTop.lastChild.classList.contains(Const.CLASS_NATIVE_CELL_COMMANDS)) {\n    util.destroyElement(cellTop.lastChild);\n  } // process customize cmd cell\n\n\n  if (cellTop.getElementsByClassName(Const.CLASS_AW_CELL_COMMANDS_CONTAINER).length !== 0) {\n    if (selectionModel.multiSelectEnabled) {\n      cellTop.lastChild.style.display = 'none';\n    }\n  } // set checkbox when item is selected\n\n\n  if (pinElem.getElementsByClassName(Const.CLASS_CELL_CHECKBOX_BUTTON).length > 0) {\n    pinElem.getElementsByClassName(Const.CLASS_CELL_CHECKBOX_BUTTON)[0].checked = true;\n  }\n\n  if (rowElem.vmo.props) {\n    if (cellTop.getElementsByClassName(Const.CLASS_AW_CELL_COMMANDS_CONTAINER).length === 0) {\n      if (!selectionModel.multiSelectEnabled && selectionModel.getCurrentSelectedCount() === 1) {\n        const markElem = awSPLMTableCellRendererFactory.createCellCommandElement(columnDefs[idx], rowElem.vmo, table, true);\n        cellTop.appendChild(markElem);\n      }\n    }\n\n    if (cellTop.getElementsByClassName(Const.CLASS_AW_CELL_COMMANDS_CONTAINER).length >= 1) {\n      if (selectionModel.mode === 'multiple' && selectionModel.getCurrentSelectedCount() > 1) {\n        removeCellCommandContainer(cellTop);\n      }\n    }\n  }\n};\n\nconst deselectCell = function (cell, gridOptions, columnDefs, idx, cellRenderer, pinElem, selectionModel) {\n  if (gridOptions.enableColumnSelection && cell.classList.contains(Const.CLASS_COLUMN_SELECTED)) {\n    return;\n  }\n\n  if (cell.classList.contains(Const.CLASS_CELL_SELECTED)) {\n    cell.classList.remove(Const.CLASS_CELL_SELECTED);\n  }\n\n  if (gridOptions.transpose === true) {\n    cell.classList.remove('ui-grid-columSelected');\n    return;\n  }\n\n  if (columnDefs[idx].isTableCommand || columnDefs[idx].isTreeNavigation) {\n    let cellTop = cell.children[0];\n\n    if (columnDefs[idx].isTreeNavigation && cell.getElementsByClassName('aw-jswidgets-tableNonEditContainer').length > 0) {\n      cellTop = cell.getElementsByClassName('aw-jswidgets-tableNonEditContainer')[0];\n    } // Process OOTB cmd cell\n\n\n    if (cellTop.lastChild && cellTop.lastChild.classList && cellTop.lastChild.classList.contains(Const.CLASS_NATIVE_CELL_COMMANDS)) {\n      util.destroyElement(cellTop.lastChild);\n      cellRenderer.destroyHoverCommandElement();\n    } // unset checkbox when item is not selected.\n\n\n    if (pinElem.getElementsByClassName(Const.CLASS_CELL_CHECKBOX_BUTTON).length > 0) {\n      pinElem.getElementsByClassName(Const.CLASS_CELL_CHECKBOX_BUTTON)[0].checked = false;\n    } // Process customize cmd cell\n\n\n    if (cellTop.lastChild && cellTop.lastChild.classList && cellTop.lastChild.classList.contains(Const.CLASS_AW_CELL_COMMANDS)) {\n      if (selectionModel.multiSelectEnabled) {\n        cellTop.lastChild.style.display = 'none';\n      } else {\n        cellTop.lastChild.style.removeProperty('display');\n      }\n    }\n\n    removeCellCommandContainer(cellTop);\n  }\n};\n\nconst removeCellCommandContainer = function (cellTop) {\n  const cellCommandContainer = cellTop.getElementsByClassName(Const.CLASS_AW_CELL_COMMANDS_CONTAINER)[0];\n\n  if (cellCommandContainer && cellCommandContainer.parentElement) {\n    util.cleanupComponents(cellTop);\n\n    if (cellCommandContainer.parentElement) {\n      cellCommandContainer.parentElement.removeChild(cellCommandContainer);\n    }\n\n    util.destroyElement(cellCommandContainer);\n  }\n};\n\nconst updateCellSelectedClass = (rowCells, gridOptions, pinElem, rowElem, table, columnDefs, selectionModel) => {\n  // Add cell selected class to each cell\n  _.forEach(rowCells, function (cell, idx) {\n    const vmo = gridOptions.transpose === true ? cell.columnDef.vmo : rowElem.vmo;\n    const cellRenderer = table._tableInstance.cellRenderer;\n\n    if (vmo && selectionModel.isSelected(vmo)) {\n      selectCell(cell, gridOptions, columnDefs, idx, cellRenderer, selectionModel, pinElem, rowElem, table);\n    } else {\n      deselectCell(cell, gridOptions, columnDefs, idx, cellRenderer, pinElem, selectionModel);\n    }\n  });\n};\n\nconst clearCellHeaderAndColumnSelection = function (tableElem) {\n  let headerCells = tableElem.querySelectorAll(`.${Const.CLASS_COLUMN_DEF}`);\n\n  let selectedHeader = _.find(headerCells, {\n    columnDef: {\n      colSelected: true\n    }\n  });\n\n  if (selectedHeader) {\n    delete selectedHeader.columnDef.colSelected;\n\n    if (tableElem._tableInstance && tableElem._tableInstance.dataProvider && tableElem._tableInstance.dataProvider.gridContextDispatcher) {\n      tableElem._tableInstance.dataProvider.gridContextDispatcher({\n        type: 'UPDATE_VALUES',\n        selectedColumn: null\n      });\n    }\n  }\n\n  let cells = tableElem.querySelectorAll(`.${Const.CLASS_HEADER_CELL_SELECTED}, .${Const.CLASS_COLUMN_SELECTED}`);\n\n  for (let k = 0; k < cells.length; k++) {\n    cells[k].classList.remove(Const.CLASS_HEADER_CELL_SELECTED, Const.CLASS_CELL_SELECTED, Const.CLASS_COLUMN_SELECTED);\n  }\n};\n\nexport const setCellHeaderSelection = function (selection, table) {\n  clearCellHeaderAndColumnSelection(table);\n\n  if (selection && selection.propName) {\n    const columnProp = selection.propName;\n    let headerCells = table.querySelectorAll(`.${Const.CLASS_COLUMN_DEF}`);\n\n    let foundCol = _.find(headerCells, {\n      columnDef: {\n        field: columnProp\n      }\n    });\n\n    if (foundCol && foundCol.parentElement) {\n      // parent element to get the whole header cell\n      foundCol.parentElement.classList.add(Const.CLASS_HEADER_CELL_SELECTED);\n    }\n  }\n};\nexport const selectColumnCells = function (table, columnName) {\n  // First set the header selection\n  setCellHeaderSelection({\n    propName: columnName\n  }, table);\n  let headerCells = table.querySelectorAll(`.${Const.CLASS_COLUMN_DEF}`);\n\n  let selectedHeader = _.find(headerCells, {\n    columnDef: {\n      field: columnName\n    }\n  });\n\n  if (selectedHeader && selectedHeader.columnDef) {\n    selectedHeader.columnDef.colSelected = true;\n  } // Now select all cells in column\n\n\n  const allCells = table.querySelectorAll(`.${Const.CLASS_CELL}`);\n\n  const foundCells = _.filter(allCells, {\n    propName: columnName\n  });\n\n  for (let i = 0; i < foundCells.length; i++) {\n    foundCells[i].classList.add(Const.CLASS_COLUMN_SELECTED, Const.CLASS_CELL_SELECTED);\n  }\n};\nexport const setCellColumnSelection = function (dataProvider, columnDef) {\n  // Clear any selection\n  dataProvider.selectNone();\n  dataProvider.gridContextDispatcher && dataProvider.gridContextDispatcher({\n    type: 'UPDATE_VALUES',\n    selectedColumn: columnDef\n  });\n}; // LCS-145673 - Make 'Show Children' command visible in table rows\n// We need to make the selection code be compatible with:\n// 1. When cellRenderer contains command cell by default\n// 2. When cellRenderer does not contains command cell\n// Code in this method work for both as design above\n\nexport const updateContentRowSelection = function (selectionModel, columnDefs, pinRowElements, scrollRowElements, table) {\n  const cnt = pinRowElements.length;\n  const gridOptions = table._tableInstance.gridOptions;\n\n  if (gridOptions.transpose === true) {\n    const trv = new Trv(table);\n    const headerElements = trv.getHeaderCellElementsFromTable();\n\n    for (let i = 0; i < headerElements.length; i++) {\n      const headerElement = headerElements[i];\n      const columnDefElement = headerElements[i].getElementsByClassName(Const.CLASS_COLUMN_DEF)[0];\n\n      if (columnDefElement && columnDefElement.columnDef.vmo && selectionModel.isSelected(columnDefElement.columnDef.vmo)) {\n        headerElement.classList.add(Const.CLASS_HEADER_CELL_SELECTED);\n      } else {\n        headerElement.classList.remove(Const.CLASS_HEADER_CELL_SELECTED);\n      }\n    }\n  }\n\n  for (let i = 0; i < cnt; i++) {\n    const rowElem = scrollRowElements[i];\n    const pinElem = pinRowElements[i];\n    let rowCells = Array.prototype.slice.call(pinElem.getElementsByClassName(Const.CLASS_CELL));\n    rowCells = rowCells.concat(Array.prototype.slice.call(rowElem.getElementsByClassName(Const.CLASS_CELL)));\n\n    if (!rowElem.vmo) {\n      rowElem.classList.remove(Const.CLASS_ROW_SELECTED);\n      rowElem.classList.remove(Const.CLASS_STATE_SELECTED);\n      rowElem.classList.remove(Const.CLASS_ROW_INACTIVATED);\n      pinElem.classList.remove(Const.CLASS_ROW_SELECTED);\n      pinElem.classList.remove(Const.CLASS_STATE_SELECTED);\n      pinElem.classList.remove(Const.CLASS_ROW_INACTIVATED); // remove cell selected class to each cell\n\n      _.forEach(rowCells, function (cell) {\n        cell.classList.remove(Const.CLASS_CELL_SELECTED);\n      });\n\n      continue;\n    }\n\n    if (selectionModel.isSelected(rowElem.vmo)) {\n      if (!selectionModel.isSelectionModelActivated()) {\n        rowElem.classList.add(Const.CLASS_ROW_INACTIVATED);\n        pinElem.classList.add(Const.CLASS_ROW_INACTIVATED);\n\n        table._tableInstance.editor.removeAllCellSelection();\n      } else if (rowElem.classList.contains(Const.CLASS_ROW_INACTIVATED)) {\n        rowElem.classList.remove(Const.CLASS_ROW_INACTIVATED);\n        pinElem.classList.remove(Const.CLASS_ROW_INACTIVATED);\n      }\n\n      rowElem.classList.add(Const.CLASS_ROW_SELECTED);\n      rowElem.classList.add(Const.CLASS_STATE_SELECTED);\n      rowElem.setAttribute('aria-selected', 'true');\n      pinElem.classList.add(Const.CLASS_ROW_SELECTED);\n      pinElem.classList.add(Const.CLASS_STATE_SELECTED);\n      pinElem.setAttribute('aria-selected', 'true');\n      updateCellSelectedClass(rowCells, gridOptions, pinElem, rowElem, table, columnDefs, selectionModel);\n      continue;\n    }\n\n    if (rowElem.classList.contains(Const.CLASS_ROW_SELECTED) || rowElem.classList.contains(Const.CLASS_STATE_SELECTED)) {\n      rowElem.classList.remove(Const.CLASS_ROW_SELECTED);\n      rowElem.classList.remove(Const.CLASS_STATE_SELECTED);\n      rowElem.classList.remove(Const.CLASS_ROW_INACTIVATED);\n\n      if (rowElem.hasAttribute('aria-selected')) {\n        rowElem.removeAttribute('aria-selected');\n      }\n    }\n\n    if (pinElem.classList.contains(Const.CLASS_ROW_SELECTED) || pinElem.classList.contains(Const.CLASS_STATE_SELECTED)) {\n      pinElem.classList.remove(Const.CLASS_ROW_SELECTED);\n      pinElem.classList.remove(Const.CLASS_STATE_SELECTED);\n      pinElem.classList.remove(Const.CLASS_ROW_INACTIVATED);\n\n      if (pinElem.hasAttribute('aria-selected')) {\n        pinElem.removeAttribute('aria-selected');\n      }\n    }\n\n    updateCellSelectedClass(rowCells, gridOptions, pinElem, rowElem, table, columnDefs, selectionModel);\n  }\n};\n\nconst handleSelect = function (selectedVmo, event, selectionModel, dataProvider, tableElem) {\n  handleNonContextMenuSelect([selectedVmo], selectionModel, event, dataProvider);\n  /**\n   * If we already have row selected, then ctrl + select the same row, we need to update selected row to provide checkmark\n   * Dataprovider watcher evaluates by checking if currently selected has changed. This wont catch for selecting same row in multi\n   * instead of single\n   */\n\n  if (event.ctrlKey) {\n    // event obj basically same as regular selectionChangeEvent\n    let eventObj = {\n      selectedObjects: dataProvider.getSelectedObjects(),\n      selectedUids: selectionModel.getSelection(),\n      selectionModel: selectionModel,\n      selected: dataProvider.getSelectedObjects(),\n      dataProviderName: dataProvider.name,\n      dataProvider: dataProvider\n    }; // Publish event as it doesn't get published with ctrl key\n\n    eventBus.publish(`${dataProvider.name}.selectionChangeEvent`, eventObj);\n  } // This event is used to denote a selection performed by user click on a row.\n\n\n  const gridId = tableElem._tableInstance.gridId;\n  eventBus.publish(gridId + '.gridSelection', {\n    selectedObjects: dataProvider.getSelectedObjects()\n  });\n};\n\nconst getLatestVmo = function (currentVmo, dataProvider) {\n  let id = currentVmo.alternateID || currentVmo.uid;\n  let idx = dataProvider.viewModelCollection.findViewModelObjectById(id);\n  return dataProvider.viewModelCollection.loadedVMObjects[idx];\n};\n/**\n *\n * Callback method when a table row gets selected/clicked\n *\n * @param {DOMElement} tableElem - the table element\n * @param {Event} [keyboardTargetElement] - the destination of keyboard event (Optional)\n * @return {function} selection handler function\n */\n\n\nexport const selectionChanged = function (tableElem, keyboardTargetElement) {\n  return function (event) {\n    const target = keyboardTargetElement || event.target; // Do not trigger selection if clicking on link\n\n    if (target.tagName.toLowerCase() === 'a' && target.href !== '') {\n      return;\n    } // Do not trigger selection if clicking on tree expand/collapse icon\n\n\n    if (util.closestElement(target, `.${Const.CLASS_TREE_ROW_HEADER_BUTTONS}`)) {\n      return;\n    } // Do not trigger selection if clicking on a cell command\n\n\n    if (util.closestElement(target, '.aw-command')) {\n      return;\n    }\n\n    const dataProvider = tableElem._tableInstance.dataProvider; // Get target vmo that was selected\n\n    let selectedRow = util.closestElement(target, '.' + Const.CLASS_ROW);\n    let selectedVmo = selectedRow && selectedRow.vmo && getLatestVmo(selectedRow.vmo, dataProvider);\n    let selectedCell = util.closestElement(target, '.' + Const.CLASS_CELL);\n\n    if (!selectedCell && event.currentTarget.columnDef) {\n      selectedCell = event.currentTarget;\n    }\n\n    const gridOptions = tableElem._tableInstance.gridOptions;\n\n    if (gridOptions.transpose === true) {\n      if (selectedCell && selectedCell.columnDef && selectedCell.columnDef.vmo) {\n        selectedVmo = selectedCell.columnDef.vmo;\n      } else {\n        return;\n      }\n    }\n\n    const selectionModel = dataProvider.selectionModel;\n\n    if (selectionModel && selectedVmo && selectedVmo.props) {\n      // Valid Selections Use Cases:\n      // 1. Selecting vmo that is not selected\n      const vmoNotSelected = !selectedVmo.selected; // 2. Selecting row selection checkbox\n\n      const selectedRowCheckbox = util.closestElement(event.target, '.' + Const.CLASS_CELL_CHECKBOX); // 3. Deselecting vmo with Ctrl key\n\n      const deselectingVmo = selectedVmo.selected && event.ctrlKey; // 4. Selecting already selected vmo when other selections are present and multiselection mode is off\n\n      const selectedLength = dataProvider.getSelectedObjects().length;\n      const keepVmoSelectedButDeselectOthers = selectedVmo.selected && selectedLength > 1 && !selectionModel.multiSelectEnabled;\n\n      if (vmoNotSelected || selectedRowCheckbox || deselectingVmo || keepVmoSelectedButDeselectOthers) {\n        handleSelect(selectedVmo, event, selectionModel, dataProvider, tableElem);\n      } else if (selectionModel.getSelection()[0] === selectedVmo.uid || selectedVmo.alternateID && selectedVmo.alternateID === selectionModel.getSelection()[0]) {\n        dataProvider.selectionModel.setSelectionModelActivated(true);\n        let selectData = dataProvider.selectionModel.selectionData;\n        selectData && selectData.update({ ...selectData.value,\n          selected: dataProvider.getSelectedObjects()\n        });\n      }\n    }\n  };\n};\nexport default {\n  selectionChanged,\n  updateContentRowSelection,\n  setCellHeaderSelection,\n  setCellColumnSelection,\n  selectColumnCells\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableSelectionHelper.js"],"names":["handleNonContextMenuSelect","selectionHelper","dataProvider","selectCell","cell","Const","gridOptions","isCommandNeeded","columnDefs","cellTop","cellRenderer","util","selectionModel","pinElem","rowElem","markElem","awSPLMTableCellRendererFactory","removeCellCommandContainer","deselectCell","cellCommandContainer","updateCellSelectedClass","_","vmo","table","clearCellHeaderAndColumnSelection","headerCells","tableElem","CLASS_COLUMN_DEF","selectedHeader","columnDef","colSelected","type","selectedColumn","cells","CLASS_HEADER_CELL_SELECTED","CLASS_COLUMN_SELECTED","k","setCellHeaderSelection","selection","columnProp","foundCol","field","selectColumnCells","propName","columnName","allCells","CLASS_CELL","foundCells","i","setCellColumnSelection","updateContentRowSelection","cnt","pinRowElements","trv","headerElements","headerElement","columnDefElement","scrollRowElements","rowCells","Array","handleSelect","event","eventObj","selectedObjects","selectedUids","selected","dataProviderName","eventBus","name","gridId","getLatestVmo","id","currentVmo","idx","selectionChanged","target","keyboardTargetElement","CLASS_TREE_ROW_HEADER_BUTTONS","selectedRow","selectedVmo","selectedCell","vmoNotSelected","selectedRowCheckbox","deselectingVmo","selectedLength","keepVmoSelectedButDeselectOthers","selectData"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This file provides helper functions for table selection\n *\n * @module js/splmTableSelectionHelper\n */\nimport awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';\nimport eventBus from 'js/eventBus';\nimport selectionHelper from 'js/selectionHelper';\nimport _ from 'lodash';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n\n/**\n *\n * Handles other select through selection handler\n *\n * @param {Object} rowVmoArray - array of VMOs to select\n * @param {Object} selectionModel - the selection model\n * @param {Object} event - event from the tap/click action\n * @param {Object} dataProvider - declarative dataProvider\n */\nconst handleNonContextMenuSelect = function( rowVmoArray, selectionModel, event, dataProvider ) {\n    selectionHelper.handleSelectionEvent( rowVmoArray, selectionModel, event, dataProvider.viewModelCollection );\n};\n\nconst selectCell = function( cell, gridOptions, columnDefs, idx, cellRenderer, selectionModel, pinElem, rowElem, table ) {\n    cell.classList.add( Const.CLASS_CELL_SELECTED );\n    if( gridOptions.transpose === true ) {\n        cell.classList.add( 'ui-grid-columnSelected' );\n        return;\n    }\n    const isCommandNeeded = columnDefs[ idx ].isTableCommand || columnDefs[ idx ].isTreeNavigation;\n    if( !isCommandNeeded ) {\n        return;\n    }\n\n    let cellTop = cell.children[ 0 ];\n    if( columnDefs[ idx ].isTreeNavigation && cell.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' ).length > 0 ) {\n        cellTop = cell.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' )[ 0 ];\n    }\n    cellRenderer.resetHoverCommandElement();\n    // process OOTB cmd cell\n    if( cellTop.lastChild && cellTop.lastChild.classList && cellTop.lastChild.classList.contains( Const.CLASS_NATIVE_CELL_COMMANDS ) ) {\n        util.destroyElement( cellTop.lastChild );\n    }\n\n    // process customize cmd cell\n    if( cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length !== 0 ) {\n        if( selectionModel.multiSelectEnabled ) {\n            cellTop.lastChild.style.display = 'none';\n        }\n    }\n    // set checkbox when item is selected\n    if( pinElem.getElementsByClassName( Const.CLASS_CELL_CHECKBOX_BUTTON ).length > 0 ) {\n        pinElem.getElementsByClassName( Const.CLASS_CELL_CHECKBOX_BUTTON )[ 0 ].checked = true;\n    }\n\n    if( rowElem.vmo.props ) {\n        if( cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length === 0 ) {\n            if( !selectionModel.multiSelectEnabled && selectionModel.getCurrentSelectedCount() === 1 ) {\n                const markElem = awSPLMTableCellRendererFactory.createCellCommandElement( columnDefs[ idx ], rowElem.vmo, table, true );\n                cellTop.appendChild( markElem );\n            }\n        }\n\n        if( cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length >= 1 ) {\n            if( selectionModel.mode === 'multiple' && selectionModel.getCurrentSelectedCount() > 1 ) {\n                removeCellCommandContainer( cellTop );\n            }\n        }\n    }\n};\n\nconst deselectCell = function( cell, gridOptions, columnDefs, idx, cellRenderer, pinElem, selectionModel ) {\n    if( gridOptions.enableColumnSelection && cell.classList.contains( Const.CLASS_COLUMN_SELECTED ) ) {\n        return;\n    }\n\n    if( cell.classList.contains( Const.CLASS_CELL_SELECTED ) ) {\n        cell.classList.remove( Const.CLASS_CELL_SELECTED );\n    }\n    if( gridOptions.transpose === true ) {\n        cell.classList.remove( 'ui-grid-columSelected' );\n        return;\n    }\n\n    if( columnDefs[ idx ].isTableCommand || columnDefs[ idx ].isTreeNavigation ) {\n        let cellTop = cell.children[ 0 ];\n        if( columnDefs[ idx ].isTreeNavigation && cell.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' ).length > 0 ) {\n            cellTop = cell.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' )[ 0 ];\n        }\n        // Process OOTB cmd cell\n        if( cellTop.lastChild && cellTop.lastChild.classList &&\n            cellTop.lastChild.classList.contains( Const.CLASS_NATIVE_CELL_COMMANDS ) ) {\n            util.destroyElement( cellTop.lastChild );\n            cellRenderer.destroyHoverCommandElement();\n        }\n        // unset checkbox when item is not selected.\n        if( pinElem.getElementsByClassName( Const.CLASS_CELL_CHECKBOX_BUTTON ).length > 0 ) {\n            pinElem.getElementsByClassName( Const.CLASS_CELL_CHECKBOX_BUTTON )[ 0 ].checked = false;\n        }\n\n        // Process customize cmd cell\n        if( cellTop.lastChild && cellTop.lastChild.classList &&\n            cellTop.lastChild.classList.contains( Const.CLASS_AW_CELL_COMMANDS ) ) {\n            if( selectionModel.multiSelectEnabled ) {\n                cellTop.lastChild.style.display = 'none';\n            } else {\n                cellTop.lastChild.style.removeProperty( 'display' );\n            }\n        }\n\n        removeCellCommandContainer( cellTop );\n    }\n};\n\nconst removeCellCommandContainer = function( cellTop ) {\n    const cellCommandContainer = cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER )[ 0 ];\n    if( cellCommandContainer && cellCommandContainer.parentElement ) {\n        util.cleanupComponents( cellTop );\n        if( cellCommandContainer.parentElement ) {\n            cellCommandContainer.parentElement.removeChild( cellCommandContainer );\n        }\n        util.destroyElement( cellCommandContainer );\n    }\n};\n\nconst updateCellSelectedClass = ( rowCells, gridOptions, pinElem, rowElem, table, columnDefs, selectionModel ) => {\n    // Add cell selected class to each cell\n    _.forEach( rowCells, function( cell, idx ) {\n        const vmo = gridOptions.transpose === true ? cell.columnDef.vmo : rowElem.vmo;\n        const cellRenderer = table._tableInstance.cellRenderer;\n        if( vmo && selectionModel.isSelected( vmo ) ) {\n            selectCell( cell, gridOptions, columnDefs, idx, cellRenderer, selectionModel, pinElem, rowElem, table );\n        } else {\n            deselectCell( cell, gridOptions, columnDefs, idx, cellRenderer, pinElem, selectionModel );\n        }\n    } );\n};\n\nconst clearCellHeaderAndColumnSelection = function( tableElem ) {\n    let headerCells = tableElem.querySelectorAll( `.${Const.CLASS_COLUMN_DEF}` );\n    let selectedHeader = _.find( headerCells, { columnDef: { colSelected: true } } );\n    if( selectedHeader ) {\n        delete selectedHeader.columnDef.colSelected;\n        if( tableElem._tableInstance && tableElem._tableInstance.dataProvider && tableElem._tableInstance.dataProvider.gridContextDispatcher ) {\n            tableElem._tableInstance.dataProvider.gridContextDispatcher( {\n                type: 'UPDATE_VALUES',\n                selectedColumn: null\n            } );\n        }\n    }\n    let cells = tableElem.querySelectorAll( `.${Const.CLASS_HEADER_CELL_SELECTED}, .${Const.CLASS_COLUMN_SELECTED}` );\n    for( let k = 0; k < cells.length; k++ ) {\n        cells[ k ].classList.remove( Const.CLASS_HEADER_CELL_SELECTED, Const.CLASS_CELL_SELECTED, Const.CLASS_COLUMN_SELECTED );\n    }\n};\n\nexport const setCellHeaderSelection = function( selection, table ) {\n    clearCellHeaderAndColumnSelection( table );\n\n    if( selection && selection.propName ) {\n        const columnProp = selection.propName;\n        let headerCells = table.querySelectorAll( `.${Const.CLASS_COLUMN_DEF}` );\n        let foundCol = _.find( headerCells, { columnDef: { field: columnProp } } );\n        if( foundCol && foundCol.parentElement ) {\n            // parent element to get the whole header cell\n            foundCol.parentElement.classList.add( Const.CLASS_HEADER_CELL_SELECTED );\n        }\n    }\n};\n\nexport const selectColumnCells = function( table, columnName ) {\n    // First set the header selection\n    setCellHeaderSelection( { propName: columnName }, table );\n\n    let headerCells = table.querySelectorAll( `.${Const.CLASS_COLUMN_DEF}` );\n    let selectedHeader = _.find( headerCells, { columnDef: { field: columnName } } );\n    if( selectedHeader && selectedHeader.columnDef ) {\n        selectedHeader.columnDef.colSelected = true;\n    }\n\n    // Now select all cells in column\n    const allCells = table.querySelectorAll( `.${Const.CLASS_CELL}` );\n    const foundCells = _.filter( allCells, { propName: columnName } );\n    for( let i = 0; i < foundCells.length; i++ ) {\n        foundCells[ i ].classList.add( Const.CLASS_COLUMN_SELECTED, Const.CLASS_CELL_SELECTED );\n    }\n};\n\nexport const setCellColumnSelection = function( dataProvider, columnDef ) {\n    // Clear any selection\n    dataProvider.selectNone();\n    dataProvider.gridContextDispatcher && dataProvider.gridContextDispatcher( {\n        type: 'UPDATE_VALUES',\n        selectedColumn: columnDef\n    } );\n};\n\n// LCS-145673 - Make 'Show Children' command visible in table rows\n// We need to make the selection code be compatible with:\n// 1. When cellRenderer contains command cell by default\n// 2. When cellRenderer does not contains command cell\n// Code in this method work for both as design above\nexport const updateContentRowSelection = function( selectionModel, columnDefs, pinRowElements, scrollRowElements, table ) {\n    const cnt = pinRowElements.length;\n    const gridOptions = table._tableInstance.gridOptions;\n\n    if( gridOptions.transpose === true ) {\n        const trv = new Trv( table );\n        const headerElements = trv.getHeaderCellElementsFromTable();\n        for( let i = 0; i < headerElements.length; i++ ) {\n            const headerElement = headerElements[ i ];\n            const columnDefElement = headerElements[ i ].getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ];\n            if( columnDefElement && columnDefElement.columnDef.vmo && selectionModel.isSelected( columnDefElement.columnDef.vmo ) ) {\n                headerElement.classList.add( Const.CLASS_HEADER_CELL_SELECTED );\n            } else {\n                headerElement.classList.remove( Const.CLASS_HEADER_CELL_SELECTED );\n            }\n        }\n    }\n\n    for( let i = 0; i < cnt; i++ ) {\n        const rowElem = scrollRowElements[ i ];\n        const pinElem = pinRowElements[ i ];\n        let rowCells = Array.prototype.slice.call( pinElem.getElementsByClassName( Const.CLASS_CELL ) );\n        rowCells = rowCells.concat( Array.prototype.slice.call( rowElem.getElementsByClassName( Const.CLASS_CELL ) ) );\n\n        if( !rowElem.vmo ) {\n            rowElem.classList.remove( Const.CLASS_ROW_SELECTED );\n            rowElem.classList.remove( Const.CLASS_STATE_SELECTED );\n            rowElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n            pinElem.classList.remove( Const.CLASS_ROW_SELECTED );\n            pinElem.classList.remove( Const.CLASS_STATE_SELECTED );\n            pinElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n\n            // remove cell selected class to each cell\n            _.forEach( rowCells, function( cell ) {\n                cell.classList.remove( Const.CLASS_CELL_SELECTED );\n            } );\n            continue;\n        }\n\n        if( selectionModel.isSelected( rowElem.vmo ) ) {\n            if( !selectionModel.isSelectionModelActivated() ) {\n                rowElem.classList.add( Const.CLASS_ROW_INACTIVATED );\n                pinElem.classList.add( Const.CLASS_ROW_INACTIVATED );\n                table._tableInstance.editor.removeAllCellSelection();\n            } else if( rowElem.classList.contains( Const.CLASS_ROW_INACTIVATED ) ) {\n                rowElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n                pinElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n            }\n            rowElem.classList.add( Const.CLASS_ROW_SELECTED );\n            rowElem.classList.add( Const.CLASS_STATE_SELECTED );\n            rowElem.setAttribute( 'aria-selected', 'true' );\n            pinElem.classList.add( Const.CLASS_ROW_SELECTED );\n            pinElem.classList.add( Const.CLASS_STATE_SELECTED );\n            pinElem.setAttribute( 'aria-selected', 'true' );\n            updateCellSelectedClass( rowCells, gridOptions,\n                pinElem, rowElem, table, columnDefs, selectionModel );\n            continue;\n        }\n\n        if( rowElem.classList.contains( Const.CLASS_ROW_SELECTED ) || rowElem.classList.contains( Const.CLASS_STATE_SELECTED ) ) {\n            rowElem.classList.remove( Const.CLASS_ROW_SELECTED );\n            rowElem.classList.remove( Const.CLASS_STATE_SELECTED );\n            rowElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n            if( rowElem.hasAttribute( 'aria-selected' ) ) {\n                rowElem.removeAttribute( 'aria-selected' );\n            }\n        }\n\n        if( pinElem.classList.contains( Const.CLASS_ROW_SELECTED ) || pinElem.classList.contains( Const.CLASS_STATE_SELECTED ) ) {\n            pinElem.classList.remove( Const.CLASS_ROW_SELECTED );\n            pinElem.classList.remove( Const.CLASS_STATE_SELECTED );\n            pinElem.classList.remove( Const.CLASS_ROW_INACTIVATED );\n            if( pinElem.hasAttribute( 'aria-selected' ) ) {\n                pinElem.removeAttribute( 'aria-selected' );\n            }\n        }\n        updateCellSelectedClass( rowCells, gridOptions, pinElem, rowElem, table, columnDefs, selectionModel );\n    }\n};\n\nconst handleSelect = function( selectedVmo, event, selectionModel, dataProvider, tableElem ) {\n    handleNonContextMenuSelect( [ selectedVmo ], selectionModel, event, dataProvider );\n    /**\n     * If we already have row selected, then ctrl + select the same row, we need to update selected row to provide checkmark\n     * Dataprovider watcher evaluates by checking if currently selected has changed. This wont catch for selecting same row in multi\n     * instead of single\n     */\n    if( event.ctrlKey ) {\n        // event obj basically same as regular selectionChangeEvent\n        let eventObj = {\n            selectedObjects: dataProvider.getSelectedObjects(),\n            selectedUids: selectionModel.getSelection(),\n            selectionModel: selectionModel,\n            selected: dataProvider.getSelectedObjects(),\n            dataProviderName: dataProvider.name,\n            dataProvider: dataProvider\n        };\n        // Publish event as it doesn't get published with ctrl key\n        eventBus.publish( `${dataProvider.name}.selectionChangeEvent`, eventObj );\n    }\n\n    // This event is used to denote a selection performed by user click on a row.\n    const gridId = tableElem._tableInstance.gridId;\n    eventBus.publish( gridId + '.gridSelection', {\n        selectedObjects: dataProvider.getSelectedObjects()\n    } );\n};\n\nconst getLatestVmo = function( currentVmo, dataProvider ) {\n    let id = currentVmo.alternateID || currentVmo.uid;\n    let idx = dataProvider.viewModelCollection.findViewModelObjectById( id );\n    return dataProvider.viewModelCollection.loadedVMObjects[ idx ];\n};\n\n/**\n *\n * Callback method when a table row gets selected/clicked\n *\n * @param {DOMElement} tableElem - the table element\n * @param {Event} [keyboardTargetElement] - the destination of keyboard event (Optional)\n * @return {function} selection handler function\n */\nexport const selectionChanged = function( tableElem, keyboardTargetElement ) {\n    return function( event ) {\n        const target = keyboardTargetElement || event.target;\n\n        // Do not trigger selection if clicking on link\n        if( target.tagName.toLowerCase() === 'a' && target.href !== '' ) {\n            return;\n        }\n\n        // Do not trigger selection if clicking on tree expand/collapse icon\n        if( util.closestElement( target, `.${Const.CLASS_TREE_ROW_HEADER_BUTTONS}` ) ) {\n            return;\n        }\n\n        // Do not trigger selection if clicking on a cell command\n        if( util.closestElement( target, '.aw-command' ) ) {\n            return;\n        }\n        const dataProvider = tableElem._tableInstance.dataProvider;\n\n        // Get target vmo that was selected\n        let selectedRow = util.closestElement( target, '.' + Const.CLASS_ROW );\n        let selectedVmo = selectedRow && selectedRow.vmo && getLatestVmo( selectedRow.vmo, dataProvider );\n        let selectedCell = util.closestElement( target, '.' + Const.CLASS_CELL );\n        if( !selectedCell && event.currentTarget.columnDef ) {\n            selectedCell = event.currentTarget;\n        }\n        const gridOptions = tableElem._tableInstance.gridOptions;\n        if( gridOptions.transpose === true ) {\n            if( selectedCell && selectedCell.columnDef && selectedCell.columnDef.vmo ) {\n                selectedVmo = selectedCell.columnDef.vmo;\n            } else {\n                return;\n            }\n        }\n\n        const selectionModel = dataProvider.selectionModel;\n        if( selectionModel && selectedVmo && selectedVmo.props ) {\n            // Valid Selections Use Cases:\n            // 1. Selecting vmo that is not selected\n            const vmoNotSelected = !selectedVmo.selected;\n            // 2. Selecting row selection checkbox\n            const selectedRowCheckbox = util.closestElement( event.target, '.' + Const.CLASS_CELL_CHECKBOX );\n            // 3. Deselecting vmo with Ctrl key\n            const deselectingVmo = selectedVmo.selected && event.ctrlKey;\n            // 4. Selecting already selected vmo when other selections are present and multiselection mode is off\n            const selectedLength = dataProvider.getSelectedObjects().length;\n            const keepVmoSelectedButDeselectOthers = selectedVmo.selected && selectedLength > 1 && !selectionModel.multiSelectEnabled;\n\n            if( vmoNotSelected || selectedRowCheckbox || deselectingVmo || keepVmoSelectedButDeselectOthers ) {\n                handleSelect( selectedVmo, event, selectionModel, dataProvider, tableElem );\n            } else if( selectionModel.getSelection()[ 0 ] === selectedVmo.uid || selectedVmo.alternateID && selectedVmo.alternateID === selectionModel.getSelection()[ 0 ] ) {\n                dataProvider.selectionModel.setSelectionModelActivated( true );\n                let selectData = dataProvider.selectionModel.selectionData;\n                selectData && selectData.update( { ...selectData.value, selected: dataProvider.getSelectedObjects() } );\n            }\n        }\n    };\n};\n\nexport default {\n    selectionChanged,\n    updateContentRowSelection,\n    setCellHeaderSelection,\n    setCellColumnSelection,\n    selectColumnCells\n};\n"]},"metadata":{},"sourceType":"module"}