{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\services\\\\src\\\\js\\\\moduleLoader.js\";\n\n/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* global\nafxWeakImport\nAFX_EXTRA_DEPS\n*/\n\n/**\n * mock for dynamic import\n *\n * @module js/moduleLoader\n *\n * @namespace moduleLoader\n */\nimport _ from 'lodash';\nimport loadable from '@loadable/component';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwBaseService from 'js/awBaseService';\nimport { parseImports } from 'js/utils';\nimport { getImageAliasFromId } from 'js/imageRegistry';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet _includedComponentCache = {}; // revisitme - like John said we can do deps: () => callback directly. But approach\n// below is lowest impact solution\n\nconst dynImportRegistration = {\n  'js/browserUtils': async () => await import('js/browserUtils')\n};\n/**\n * register dynamic import entry to dynImportRegistration.\n * mainly used by all JSON loader.\n * has best compatibility to existing declUtils design\n * @param {String} name module name when we use it in JSON\n * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`\n */\n\nexport const registerDynImportEntry = (name, callback) => {\n  dynImportRegistration[name] = callback;\n};\nAFX_EXTRA_DEPS;\nexport const loadDynModule = name => {\n  if (dynImportRegistration[name] !== undefined) {\n    return new Promise(resolve => {\n      dynImportRegistration[name]().then(obj => {\n        const resolved = obj && obj.__esModule && obj.default ? obj.default : obj;\n\n        if (resolved.prototype instanceof AwBaseService) {\n          return resolve(resolved.instance);\n        }\n\n        return resolve(resolved);\n      });\n    });\n  }\n\n  throw Error(`Library ${name} does not exist!`);\n};\nexport const afxDynamicImport = (deps, func) => {\n  let modules = [];\n\n  for (const contri of deps) {\n    modules.push(loadDynModule(contri));\n  }\n\n  return new Promise(resolve => {\n    // LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick\n    // behavior in requirejs.\n    setTimeout(() => {\n      return Promise.all(modules).then(response => {\n        return resolve(func.apply(null, response.map(obj => obj && obj.__esModule && obj.default ? obj.default : obj)));\n      });\n    }, 0);\n  });\n};\n/**\n * Get angular injected module if necessary\n *\n * @param {*} moduleObj - The loaded module\n * @return {Object} Updated dep module\n */\n\nconst getModuleInstance = moduleObj => {\n  if (moduleObj && moduleObj.prototype instanceof AwBaseService) {\n    return moduleObj.instance;\n  }\n\n  return moduleObj;\n};\n/**\n * Get a module synchronously. Returns null if module is not loaded.\n *\n * @param {*} depModuleName -\n *\n * @returns {Object|null} Reference to module API object.\n */\n\n\nexport const getDependentModule = depModuleName => {\n  /** revisitme\n   *  remove me later (loadModule)\n   */\n  return loadDynModule(depModuleName); // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n  // afxWeakImport will be setup either in aw_polyfill or afxImport\n  //return afxWeakImport( depModuleName );\n};\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\n\nexport const loadDependentModule = depModule => {\n  return getDependentModule(depModule);\n  /**\n   * revsitme\n   * afxDynamicImport is not supported yet\n   */\n  // return AwPromiseService.instance( function( resolve, reject ) {\n  //     if( depModule ) {\n  //         afxDynamicImport( [ depModule ], function( depModule2 ) {\n  //             resolve( getModuleInstance( depModule2 ) );\n  //         }, reject );\n  //     } else {\n  //         resolve();\n  //     }\n  // } );\n};\nexport const loadStaticDependentModule = depModule => {\n  if (depModule) {\n    return getModuleInstance(depModule);\n  }\n\n  return undefined;\n};\n/**\n * @param {String[]} depModules - The dependent modules to load.\n * @return {Promise} This promise will be resolved when the given module has been loaded.\n */\n\nexport const loadDependentModules = depModules => {\n  return AwPromiseService.instance(function (resolve, reject) {\n    if (depModules && depModules.length > 0) {\n      afxDynamicImport(depModules, function () {\n        let retModulesMap = {}; // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n        // This interface has bug for the else block, in no case it\n        // will return arg as string which can run injector.get(arg)\n        // who is using this interface will only supports angularJS service\n        // with other limitaton\n        //\n        // They are:\n        // - AFX\n        //   - find function.deps in actionService\n        //     - Example: src\\thinclient\\requirementscommandpanelsjs\\src\\viewmodel\\Arm0ExportToRoundTripWordDocumentViewModel.json\n        //     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc\n        //       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method\n        //       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')\n        //   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)\n        //   - highlighterService -> this is fine which is a blind load\n        // - AW\n        //   - Ase0DualSaveHandler -> this is fine which is a blind load\n        //   - aw-gantt.controller -> this is fine which is a blind load\n        //\n        // - Long term solution\n        //   - Rewrite the interface to retrun array only. Refactor all caller\n        // - Short term solution\n        //   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)\n        //\n        // - How function definition works today\n        //   - Not all function definition supports deps, only function in viewModel ( details see schema )\n        //   - all the function imple should be sync otherwise you will get a unexpected promise object\n        //   - It has different behavior in different place:\n        //     - inputData.data: \"{{function:testFunc}}\"\n        //       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.\n        //       - While loading the deps by this function, it will blindly add key-module pare to depModules,\n        //         For example you will get someActionService['functionSvcName'] = functionService, with all\n        //         method provided by someActionService together...\n        //       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules\n        //         recursively to get the corrct function\n        //         - But if a same function exist in someActionService, it will still take priority...\n        //\n        //     - outputData: \"{{function: testFunc}}\"\n        //       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD\n        //         BE the actual key in deps. For example:\n        //         - You define { functions: { aaa: { functionName: showInfo }}}\n        //         - When use it, we use {{function:showInfo}}, not {{function:aaa}}\n        //       - No matter what you put in deps, it will always go to main dep (action dep)\n        //         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)\n\n        _.forEach(arguments, function (arg, idx) {\n          let moduleName = depModules[idx].replace(/^.*\\//, '');\n\n          if (arg.prototype instanceof AwBaseService) {\n            retModulesMap[moduleName] = arg.instance;\n          } else {\n            retModulesMap[moduleName] = arg;\n          }\n        });\n\n        resolve(retModulesMap);\n      });\n    } else {\n      resolve();\n    }\n  });\n};\n/**\n * Loading the imported JS\n *\n * @param {StringArray} moduleNames - Array of module's to 'import'.\n *\n * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent\n *         modules.\n */\n\nexport const loadImports = moduleNames => {\n  return AwPromiseService.instance(function (resolve, reject) {\n    if (moduleNames && moduleNames.length > 0) {\n      afxDynamicImport(moduleNames, function () {\n        var moduleObjs = [];\n\n        _.forEach(arguments, function (arg) {\n          if (arg) {\n            if (arg.prototype instanceof AwBaseService) {\n              moduleObjs.push(arg.instance);\n            } else {\n              moduleObjs.push(arg);\n            }\n          }\n        });\n\n        resolve(moduleObjs);\n      });\n    } else {\n      resolve();\n    }\n  });\n};\n/**\n * Loading the imported svgs dynamically.\n *\n * @param {String} imageId - String ImageId which can either be complete alias or just imageId.\n * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.\n * @returns Dynamic Image Component\n */\n\nexport const includeImage = (imageId, exactMatch) => {\n  if (imageId) {\n    let DynamicComponent = _includedComponentCache[imageId];\n\n    if (!DynamicComponent) {\n      const imageAlias = exactMatch ? imageId : getImageAliasFromId(imageId);\n      DynamicComponent = loadable(() => {\n        try {\n          return loadDynModule(imageAlias).then(resolved => resolved.SvgComponent);\n        } catch (error) {\n          console.log(error.message);\n          return Promise.resolve(() => null);\n        }\n      }, {\n        fallback: /*#__PURE__*/_jsxDEV(\"svg\", {\n          style: {\n            width: '16px',\n            height: '16px'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 257,\n          columnNumber: 28\n        }, this)\n      });\n      _includedComponentCache[imageId] = DynamicComponent;\n    } // add viewId to facilitate debug\n\n\n    return /*#__PURE__*/_jsxDEV(DynamicComponent, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 16\n    }, this);\n  }\n};\nexport const includeComponent = (componentName, prop) => {\n  if (componentName) {\n    let DynamicComponent = _includedComponentCache[componentName];\n    let viewId = prop.viewId ? prop.viewId : componentName;\n\n    if (!DynamicComponent) {\n      DynamicComponent = loadable(() => {\n        try {\n          return loadDynModule(`viewmodel/${componentName}ViewModel`);\n        } catch (error) {\n          console.log(error.message);\n          return Promise.resolve(() => null);\n        }\n      });\n      _includedComponentCache[componentName] = DynamicComponent;\n    } // add viewId to facilitate debug\n\n\n    return /*#__PURE__*/_jsxDEV(DynamicComponent, {\n      viewId: viewId,\n      ...prop\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 16\n    }, this);\n  }\n};\nwindow.afxDynamicImport = afxDynamicImport; // dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build\n// AFX_CONFIG_ENTRY\n\nregisterDynImportEntry('lodash', () => import('lodash'));\nregisterDynImportEntry('js/configurationService', () => import('js/configurationService'));\nregisterDynImportEntry('js/viewModelService', () => import('js/viewModelService')); // export default for test purpose\n\nexport default {\n  getDependentModule,\n  loadDependentModule,\n  includeComponent,\n  loadStaticDependentModule,\n  loadDependentModules,\n  loadImports,\n  includeImage\n};","map":{"version":3,"names":["_","loadable","AwPromiseService","AwBaseService","parseImports","getImageAliasFromId","_includedComponentCache","dynImportRegistration","registerDynImportEntry","name","callback","AFX_EXTRA_DEPS","loadDynModule","undefined","Promise","resolve","then","obj","resolved","__esModule","default","prototype","instance","Error","afxDynamicImport","deps","func","modules","contri","push","setTimeout","all","response","apply","map","getModuleInstance","moduleObj","getDependentModule","depModuleName","loadDependentModule","depModule","loadStaticDependentModule","loadDependentModules","depModules","reject","length","retModulesMap","forEach","arguments","arg","idx","moduleName","replace","loadImports","moduleNames","moduleObjs","includeImage","imageId","exactMatch","DynamicComponent","imageAlias","SvgComponent","error","console","log","message","fallback","width","height","includeComponent","componentName","prop","viewId","window"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/services/src/js/moduleLoader.js"],"sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/* global\nafxWeakImport\nAFX_EXTRA_DEPS\n*/\n\n/**\n * mock for dynamic import\n *\n * @module js/moduleLoader\n *\n * @namespace moduleLoader\n */\n\nimport _ from 'lodash';\nimport loadable from '@loadable/component';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwBaseService from 'js/awBaseService';\nimport { parseImports } from 'js/utils';\nimport { getImageAliasFromId } from 'js/imageRegistry';\n\nlet _includedComponentCache = {};\n\n// revisitme - like John said we can do deps: () => callback directly. But approach\n// below is lowest impact solution\nconst dynImportRegistration = {\n    'js/browserUtils': async () => await import( 'js/browserUtils' )\n};\n\n/**\n * register dynamic import entry to dynImportRegistration.\n * mainly used by all JSON loader.\n * has best compatibility to existing declUtils design\n * @param {String} name module name when we use it in JSON\n * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`\n */\nexport const registerDynImportEntry = ( name, callback ) => {\n    dynImportRegistration[ name ] = callback;\n};\n\nAFX_EXTRA_DEPS;\n\nexport const loadDynModule = name => {\n    if( dynImportRegistration[ name ] !== undefined ) {\n        return new Promise( resolve => {\n            dynImportRegistration[ name ]().then( obj => {\n                const resolved = obj && obj.__esModule && obj.default ? obj.default : obj;\n                if( resolved.prototype instanceof AwBaseService ) {\n                    return resolve( resolved.instance );\n                }\n                return resolve( resolved );\n            } );\n        } );\n    }\n    throw Error( `Library ${name} does not exist!` );\n};\n\nexport const afxDynamicImport = ( deps, func ) => {\n    let modules = [];\n    for( const contri of deps ) {\n        modules.push( loadDynModule( contri ) );\n    }\n\n    return new Promise( resolve => {\n        // LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick\n        // behavior in requirejs.\n        setTimeout( () => {\n            return Promise.all( modules ).then( response => {\n                return resolve( func.apply( null, response.map( obj => obj && obj.__esModule && obj.default ? obj.default : obj ) ) );\n            } );\n        }, 0 );\n    } );\n};\n\n/**\n * Get angular injected module if necessary\n *\n * @param {*} moduleObj - The loaded module\n * @return {Object} Updated dep module\n */\nconst getModuleInstance = ( moduleObj ) => {\n    if( moduleObj && moduleObj.prototype instanceof AwBaseService ) {\n        return moduleObj.instance;\n    }\n    return moduleObj;\n};\n\n/**\n * Get a module synchronously. Returns null if module is not loaded.\n *\n * @param {*} depModuleName -\n *\n * @returns {Object|null} Reference to module API object.\n */\nexport const getDependentModule = depModuleName => {\n    /** revisitme\n     *  remove me later (loadModule)\n     */\n    return loadDynModule( depModuleName );\n\n    // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n    // afxWeakImport will be setup either in aw_polyfill or afxImport\n    //return afxWeakImport( depModuleName );\n};\n\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\nexport const loadDependentModule = depModule => {\n    return getDependentModule( depModule );\n    /**\n     * revsitme\n     * afxDynamicImport is not supported yet\n     */\n    // return AwPromiseService.instance( function( resolve, reject ) {\n    //     if( depModule ) {\n    //         afxDynamicImport( [ depModule ], function( depModule2 ) {\n    //             resolve( getModuleInstance( depModule2 ) );\n    //         }, reject );\n    //     } else {\n    //         resolve();\n    //     }\n    // } );\n};\n\nexport const loadStaticDependentModule = depModule => {\n    if( depModule ) {\n        return getModuleInstance( depModule );\n    }\n    return undefined;\n};\n\n/**\n * @param {String[]} depModules - The dependent modules to load.\n * @return {Promise} This promise will be resolved when the given module has been loaded.\n */\nexport const loadDependentModules = depModules => {\n    return AwPromiseService.instance( function( resolve, reject ) {\n        if( depModules && depModules.length > 0 ) {\n            afxDynamicImport( depModules, function() {\n                let retModulesMap = {};\n                // LCS-299148 Beyond Angular: Clean up app.getInjector usage\n                // This interface has bug for the else block, in no case it\n                // will return arg as string which can run injector.get(arg)\n                // who is using this interface will only supports angularJS service\n                // with other limitaton\n                //\n                // They are:\n                // - AFX\n                //   - find function.deps in actionService\n                //     - Example: src\\thinclient\\requirementscommandpanelsjs\\src\\viewmodel\\Arm0ExportToRoundTripWordDocumentViewModel.json\n                //     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc\n                //       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method\n                //       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')\n                //   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)\n                //   - highlighterService -> this is fine which is a blind load\n                // - AW\n                //   - Ase0DualSaveHandler -> this is fine which is a blind load\n                //   - aw-gantt.controller -> this is fine which is a blind load\n                //\n                // - Long term solution\n                //   - Rewrite the interface to retrun array only. Refactor all caller\n                // - Short term solution\n                //   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)\n                //\n                // - How function definition works today\n                //   - Not all function definition supports deps, only function in viewModel ( details see schema )\n                //   - all the function imple should be sync otherwise you will get a unexpected promise object\n                //   - It has different behavior in different place:\n                //     - inputData.data: \"{{function:testFunc}}\"\n                //       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.\n                //       - While loading the deps by this function, it will blindly add key-module pare to depModules,\n                //         For example you will get someActionService['functionSvcName'] = functionService, with all\n                //         method provided by someActionService together...\n                //       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules\n                //         recursively to get the corrct function\n                //         - But if a same function exist in someActionService, it will still take priority...\n                //\n                //     - outputData: \"{{function: testFunc}}\"\n                //       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD\n                //         BE the actual key in deps. For example:\n                //         - You define { functions: { aaa: { functionName: showInfo }}}\n                //         - When use it, we use {{function:showInfo}}, not {{function:aaa}}\n                //       - No matter what you put in deps, it will always go to main dep (action dep)\n                //         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)\n                _.forEach( arguments, function( arg, idx ) {\n                    let moduleName = depModules[ idx ].replace( /^.*\\//, '' );\n\n                    if( arg.prototype instanceof AwBaseService ) {\n                        retModulesMap[ moduleName ] = arg.instance;\n                    } else {\n                        retModulesMap[ moduleName ] = arg;\n                    }\n                } );\n                resolve( retModulesMap );\n            } );\n        } else {\n            resolve();\n        }\n    } );\n};\n\n/**\n * Loading the imported JS\n *\n * @param {StringArray} moduleNames - Array of module's to 'import'.\n *\n * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent\n *         modules.\n */\nexport const loadImports = moduleNames => {\n    return AwPromiseService.instance( function( resolve, reject ) {\n        if( moduleNames && moduleNames.length > 0 ) {\n            afxDynamicImport( moduleNames, function() {\n                var moduleObjs = [];\n                _.forEach( arguments, function( arg ) {\n                    if( arg ) {\n                        if( arg.prototype instanceof AwBaseService ) {\n                            moduleObjs.push( arg.instance );\n                        } else {\n                            moduleObjs.push( arg );\n                        }\n                    }\n                } );\n                resolve( moduleObjs );\n            } );\n        } else {\n            resolve();\n        }\n    } );\n};\n\n/**\n * Loading the imported svgs dynamically.\n *\n * @param {String} imageId - String ImageId which can either be complete alias or just imageId.\n * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.\n * @returns Dynamic Image Component\n */\nexport const includeImage = ( imageId, exactMatch ) => {\n    if( imageId ) {\n        let DynamicComponent = _includedComponentCache[ imageId ];\n        if( !DynamicComponent ) {\n            const imageAlias = exactMatch ? imageId : getImageAliasFromId( imageId );\n            DynamicComponent = loadable( () => {\n                try {\n                    return loadDynModule( imageAlias ).then( resolved => resolved.SvgComponent );\n                } catch ( error ) {\n                    console.log( error.message );\n                    return Promise.resolve( () => null );\n                }\n            }, { fallback: <svg style={{ width: '16px', height: '16px' }}></svg> } );\n            _includedComponentCache[ imageId ] = DynamicComponent;\n        }\n        // add viewId to facilitate debug\n        return <DynamicComponent/>;\n    }\n};\n\nexport const includeComponent = ( componentName, prop ) => {\n    if( componentName ) {\n        let DynamicComponent = _includedComponentCache[ componentName ];\n        let viewId = prop.viewId ? prop.viewId : componentName;\n        if( !DynamicComponent ) {\n            DynamicComponent = loadable( () => {\n                try {\n                    return loadDynModule( `viewmodel/${componentName}ViewModel` );\n                } catch ( error ) {\n                    console.log( error.message );\n                    return Promise.resolve( () => null );\n                }\n            } );\n            _includedComponentCache[ componentName ] = DynamicComponent;\n        }\n        // add viewId to facilitate debug\n        return <DynamicComponent viewId={viewId} { ...prop} />;\n    }\n};\n\nwindow.afxDynamicImport = afxDynamicImport;\n\n// dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build\n// AFX_CONFIG_ENTRY\nregisterDynImportEntry('lodash', () => import('lodash'));\nregisterDynImportEntry('js/configurationService', () => import('js/configurationService'));\nregisterDynImportEntry('js/viewModelService', () => import('js/viewModelService'));\n\n// export default for test purpose\nexport default {\n    getDependentModule,\n    loadDependentModule,\n    includeComponent,\n    loadStaticDependentModule,\n    loadDependentModules,\n    loadImports,\n    includeImage\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}