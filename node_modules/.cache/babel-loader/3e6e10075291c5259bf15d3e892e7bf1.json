{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used by <aw-row> and <aw-column> to initialize the flexbox sizing attributes for all rows and\n * columns within the grid system. And to establish elements to implement offsets, align-contents (start, center, end) and justification options.\n *\n * @module js/awRowColumnService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nlet exports = {}; // eslint-disable-line no-invalid-this\n\nexport let constants = {\n  gridSystemSize: 12,\n  standardWidthFactor: 1,\n  standardHeightFactor: 1\n};\n/**\n * Initialize Row or Column - every row or column element calls this method at link time to\n * initialized the flexbox attributes for all siblings. And to add elements to implement offsets\n * align-contents (start, center, end) and justification options.\n *\n * @param {object} scopeElements - The angularJS scope elements used to define the row or\n *            column.\n */\n\nexport let initRowOrColumn = function (scopeElements) {\n  // Get the container element used for the given row or column element\n  var containerElement = scopeElements[0].parentElement;\n  var containerClassName = scopeElements[0].className; // Get all sub-area in this row or column\n\n  var areaList = exports.getAreaList(containerElement);\n\n  if (areaList === null) {\n    return;\n  } // Set parent container element to use flexbox\n\n\n  containerElement.style.display = 'flex';\n\n  if (areaList[0].wrapStyle) {\n    containerElement.style.flexWrap = areaList[0].wrapStyle;\n  }\n\n  containerElement.style.webkitFlexDirection = areaList[0].stackDirection;\n  containerElement.style.flexDirection = areaList[0].stackDirection; // Variables used to captured the index for the first center justify\n  // and (right or bottom) justify elements\n  // Elements to implement the justification will be inserted before these elements\n\n  var centerJustifyIndex = -1;\n  var farJustifyIndex = -1; // Flag to control relative positions of offset elements\n\n  var insertBefore = true; // Get the number of fill areas and the amount of space that is\n  // NOT defined by proportional values needed to fill the grid system\n\n  var fillData = exports.getFillData(areaList);\n  var fillValue = fillData.fillSize;\n  var fillAreaCount = fillData.fillAreaCount;\n  var fillAreaString = ''; // If there are fill areas then all open area will be consumed by them\n  // Any justification options will be ignored\n\n  if (fillAreaCount > 0) {\n    // For multiple fill areas the area is split between them\n    fillAreaString = (fillValue / fillAreaCount).toString();\n    fillValue = 0;\n  } // Process all items in the current row or column:\n  // Set the flexbox size attributes\n  // Capture key justification positions\n  // Add elements needed to implement offsets\n\n\n  _.forEach(areaList, function (area, index) {\n    // Set flexbox size attributes for this element\n    exports.setAreaStyle(area.areaElement, area.sizeType, area.sizeValue, area.color, fillAreaString, area.alignContent, area.when, area.areaType); // Capture the index of the first center and (right or bottom) elements\n\n    var justifyOption = area.justify;\n\n    if (justifyOption === 'center' && centerJustifyIndex < 0) {\n      centerJustifyIndex = index;\n    }\n\n    if ((justifyOption === 'right' || justifyOption === 'bottom') && farJustifyIndex < 0) {\n      farJustifyIndex = index;\n      insertBefore = false;\n    } // If this element has an offset then create the offset element\n\n\n    var offsetValue = area.offsetSizeValue;\n\n    if (offsetValue > 0) {\n      exports.addNewElement(containerClassName, area.offsetSizeType, offsetValue, 'transparent', '', insertBefore, area.areaElement, area.areaType);\n    }\n  }); // End process all items\n  // Add filler elements to handle justification or to fill in undefined space at the end\n\n\n  if (fillValue > 0) {\n    fillAreaString = fillValue.toString();\n\n    if (centerJustifyIndex >= 0) {\n      // Two Element are needed to center - so split the remaining space\n      // Note that this also handles the case of a center AND a (right or bottom) justification\n      fillAreaString = (fillValue / 2).toString(); // Insert an element before the center justify element\n\n      exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[centerJustifyIndex].areaElement, areaList[0].areaType);\n\n      if (farJustifyIndex > 0) {\n        // Also insert a new element before the far justify element\n        exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[farJustifyIndex].areaElement, areaList[0].areaType);\n      } else {\n        // There is no right or bottom justify option - so insert at the end to center\n        exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, false, scopeElements[0], areaList[0].areaType);\n      }\n    } else if (farJustifyIndex >= 0) {\n      // Insert one new element before the far justify element\n      exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[farJustifyIndex].areaElement, areaList[0].areaType);\n    }\n  }\n};\n/**\n * Add New Element\n *\n * Add a new element of a given size before or after a given sibling element.\n *\n * @param {string} className - The class name used for all siblings.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n *            areas\n * @param {boolean} before - when true insert the new element before the sibling, otherwise\n *            insert after\n * @param {object} sibling - existing sibling element to insert before or after Note: pass in\n *            the DOM element not the JQuery/Angular scoping element\n */\n\nexport let addNewElement = function (className, sizeType, sizeValue, color, fillAreaString, before, sibling, areaType) {\n  // Example to get rid of ngModule.element\n\n  /*\n      ngModule.element - it is a $.element, which should be replaced by vallinaJS ( major usage )\n      ngModule.isUndefined - can be vanillaJS\n      ngModule.copy - simple deep copy\n      ngModule.bind - similar like function.bind, not sure why we need this. But should be able to replace.\n      ngModule.noop - similar like null? Anyway we can do equivalent\n      ngModule.forEach - _.forEachngModule.isFunction - _.isFunction\n   */\n  var newElement = document.createElement('div');\n\n  _.forEach(className.split(' '), function (cName) {\n    newElement.classList.add(cName);\n  });\n\n  exports.setAreaStyle(newElement, sizeType, sizeValue, color, fillAreaString, null, null, areaType);\n  sibling.parentNode.insertBefore(newElement, sibling);\n\n  if (!before) {\n    newElement.parentNode.insertBefore(sibling, newElement);\n  }\n};\n/**\n * Set Area Style\n *\n * Set the flexbox size attributes for Fixed and Proportional areas and set the given color.\n *\n * @param {object} areaElement - The row or column to size.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n * @param {string} alignContent - \"start\", \"center\" or \"end\" to flex align Items/ Content\n *            areas\n * @param {string} when - \"xlarge: <value>, large: <value>, medium: <value>, small: <value>, xsmall: <value>\"\n *            12 column responsive grid layout\n */\n\nexport let setAreaStyle = function (areaElement, sizeType, sizeValue, color, fillAreaString, alignContent, when, areaType) {\n  var valueString = sizeValue.toString();\n  var flexString;\n  var areaPercent = '';\n\n  if (sizeType === 'P') {\n    if (sizeValue > 0) {\n      // This is a normal proportional area\n      // note that for IE performance, numeric values should not be used for the flex-basis (3rd value in flexString)\n      flexString = valueString + ' ' + valueString + ' auto';\n\n      if (valueString > 1) {\n        areaPercent = 100 * valueString / 12 + '%';\n      }\n    } else {\n      // This is a fill area - which will also be proportional\n      flexString = fillAreaString + ' ' + fillAreaString + ' auto';\n\n      if (fillAreaString > 1) {\n        areaPercent = 100 * fillAreaString / 12 + '%';\n      }\n    }\n  } else if (sizeType === 'A') {\n    flexString = '0 0 auto';\n  } else {\n    // sizeType = \"F\"\n    // These are areas defined with fixed values\n    flexString = '0 0 ' + sizeValue.toString() + 'em';\n  }\n\n  if (when && sizeType === 'P') {\n    var deviceModeList = when.split(',');\n\n    if (deviceModeList && deviceModeList.length) {\n      deviceModeList.forEach(function (mode) {\n        var deviceMode = mode.split(':')[0].trim();\n        var size = parseInt(mode.split(':')[1]);\n\n        if (deviceMode === 'xlarge') {\n          areaElement.className += ' aw-xlarge-' + size + ' ';\n        } else if (deviceMode === 'large') {\n          areaElement.className += ' aw-large-' + size + ' ';\n        } else if (deviceMode === 'medium') {\n          areaElement.className += ' aw-medium-' + size + ' ';\n        } else if (deviceMode === 'small') {\n          areaElement.className += ' aw-small-' + size + ' ';\n        } else if (deviceMode === 'xsmall') {\n          areaElement.className += ' aw-xsmall-' + size + ' ';\n        } else {\n          areaElement.className += ' aw-default-' + sizeValue + ' ';\n        }\n      });\n    }\n  } else {\n    // apply the flex value inline\n    // Numeric flex-basis should be avoided.\n    // Any change their needs to be carefully tested in IE for performance validation.\n    areaElement.style.flex = flexString;\n\n    if (areaPercent) {\n      areaType === 'column' ? areaElement.style.width = areaPercent : areaElement.style.height = areaPercent;\n    }\n  } // Add the flexbox sizing string and user given color to the current element\n\n\n  areaElement.style.backgroundColor = color;\n  var alignContentValue = '';\n\n  switch (alignContent) {\n    case 'start':\n      alignContentValue = 'flex-start';\n      break;\n\n    case 'center':\n      alignContentValue = 'center';\n      break;\n\n    case 'end':\n      alignContentValue = 'flex-end';\n      break;\n  }\n\n  areaElement.style.alignItems = alignContentValue;\n};\n/**\n * Is Last Child\n *\n * Return true if the given child element is the last child element of the given parent element.\n *\n * @param {object} parent - container element\n * @param {object} child - a child of the container element\n *\n * @return {boolean} - true if child is the last child in parent\n */\n\nexport let isLastChild = function (parent, child) {\n  if (!parent) {\n    return false;\n  }\n\n  var children = parent.children;\n\n  if (!children) {\n    return false;\n  }\n\n  var length = children.length;\n\n  if (length < 1) {\n    return false;\n  }\n\n  if (children[length - 1] !== child) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Get Fill Data\n *\n * For the given row or column, return the number of areas defined with a size of \"fill\" and the\n * amount of space in the grid system that is not defined by proportional width or height or\n * offset values. This is the space to be filled by the \"fill\" areas or by justification\n * options.\n *\n * Note this method also verifies that all items are rows or columns and if not reports a usage\n * error.\n *\n * @param {array} areaList - Array of structures for all areas in a row or column (see\n *            getAreaData)\n *\n * @return {structure} - { fillSize:fillSize, fillAreaCount:fillAreaCount }\n */\n\nexport let getFillData = function (areaList) {\n  // Used to verify that areas are not defined with a mixture of row and column elements\n  var testAreaType = areaList[0].areaType;\n  var typeError = false;\n  var fillSize = exports.constants.gridSystemSize;\n  var fillAreaCount = 0;\n\n  _.forEach(areaList, function (area) {\n    // Subtract proportional widths or heights\n    if (area.sizeType === 'P') {\n      fillSize -= area.sizeValue; // Count Fill Area\n      // Fill areas are identified by having a size of zero\n\n      if (area.sizeValue === 0) {\n        ++fillAreaCount;\n      }\n    } // Subtract proportional offsets\n\n\n    if (area.offsetSizeType === 'P') {\n      fillSize -= area.offsetSizeValue;\n    } // Verify all items are rows or columns (not a mixture)\n\n\n    if (area.areaType !== testAreaType) {\n      typeError = true;\n    }\n  });\n\n  if (typeError) {\n    exports.reportError('area found that is defined with mixed rows and columns');\n  }\n\n  if (fillSize < 0) {\n    fillSize = 0;\n    exports.reportError('row or column found defined with proportional areas that exceed grid system size: ' + exports.constants.gridSystemSize);\n  }\n\n  return {\n    fillSize: fillSize,\n    fillAreaCount: fillAreaCount\n  };\n};\n/**\n * Get Area List\n *\n * For the given container element, return the list of sub-areas (rows or columns) that define\n * the layout for the container.\n *\n * If there are sub-elements then return an array of structures (see getAreaData) If there are\n * no sub-elements then return null.\n *\n * @param {object} containerElement - Element containing the list of row or column elements\n *\n * @return {structure} - see getAreaData\n */\n\nexport let getAreaList = function (containerElement) {\n  if (!containerElement) {\n    return null;\n  }\n\n  var childList = containerElement.children;\n\n  if (!childList) {\n    return null;\n  }\n\n  if (childList.length < 1) {\n    return null;\n  }\n\n  var areaList = [];\n\n  _.forEach(childList, function (subArea) {\n    var subAreaData = exports.getAreaData(subArea);\n\n    if (subAreaData) {\n      areaList.push(subAreaData);\n    }\n  });\n\n  if (areaList.length < 1) {\n    return null;\n  }\n\n  return areaList;\n};\n/**\n * Get Area Data\n *\n * For a given row or column, create and return the data defining the size and options\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { areaElement, areaType, stackDirection, sizeType, sizeValue,\n *         offsetSizeType, offsetSizeValue, justify, color, align-content }\n */\n\nexport let getAreaData = function (areaElement) {\n  // Set the area type based on the elements class name\n  var classList = areaElement.classList;\n  var areaType = 'unknown';\n  var standardSizeFactor;\n  var stackDirection;\n\n  if (classList.contains('aw-layout-row')) {\n    areaType = 'row';\n    stackDirection = 'column'; // flexbox direction\n\n    standardSizeFactor = exports.constants.standardHeightFactor;\n  } else if (classList.contains('aw-layout-column')) {\n    areaType = 'column';\n    stackDirection = 'row'; // flexbox direction\n\n    standardSizeFactor = exports.constants.standardWidthFactor;\n  } else {\n    // Ignore all other elements\n    return null;\n  }\n\n  var userAttributes = exports.getAreaUserAttributes(areaElement);\n  var sizeData = exports.getSizeDataFromAttribute(userAttributes.size, standardSizeFactor);\n  var sizeType = sizeData.sizeType;\n  var sizeValue = sizeData.sizeValue;\n  sizeData = exports.getSizeDataFromAttribute(userAttributes.offset, standardSizeFactor);\n  var offsetSizeType = sizeData.sizeType;\n  var offsetSizeValue = sizeData.sizeValue;\n  return {\n    areaElement: areaElement,\n    // row or column element\n    areaType: areaType,\n    // \"row\", \"column\"\n    stackDirection: stackDirection,\n    // \"row\" means stack horizontally, \"column\" vertically\n    sizeType: sizeType,\n    // \"F\" fixed, \"P\" proportional, \"A\" auto\n    sizeValue: sizeValue,\n    // value for width or height\n    offsetSizeType: offsetSizeType,\n    // \"F\" or \"P\" type of values used for offset\n    offsetSizeValue: offsetSizeValue,\n    // width or height of the desired offset\n    justify: userAttributes.justify,\n    // \"left\", \"right\", \"top\", \"bottom\", \"center\"\n    color: userAttributes.color,\n    alignContent: userAttributes.alignContent,\n    // \"start\", \"center\", \"end\"\n    when: userAttributes.when,\n    // large, medium, small\n    wrapStyle: userAttributes.wrapStyle // nowrap, wrap, wrap-reverse\n\n  }; // Any CSS color string\n};\n/**\n * Get Area User Attributes\n *\n * For the given row or column, return a structure containing either the attribute value as\n * defined by the user or the default attribute value for all possible attributes.\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { size, offset, justify, color, id, alignContent }\n */\n\nexport let getAreaUserAttributes = function (areaElement) {\n  var sizeAttributeName = 'width';\n  var defaultJustifyString = 'left';\n\n  if (areaElement.classList.contains('aw-layout-row')) {\n    sizeAttributeName = 'height';\n    defaultJustifyString = 'top';\n  } // Get original attributes as defined in the element by the user\n\n\n  var sizeString = areaElement.getAttribute(sizeAttributeName);\n  var offsetString = areaElement.getAttribute('offset');\n  var justifyString = areaElement.getAttribute('justify');\n  var colorString = areaElement.getAttribute('color');\n  var idString = areaElement.getAttribute('offset');\n  var alignContent = areaElement.getAttribute('align-content');\n  var when = areaElement.getAttribute('when');\n  var wrapStyle = areaElement.getAttribute('wrap-style'); // Set defaults for attributes that were not defined by the user\n\n  sizeString = sizeString ? sizeString : '1';\n  offsetString = offsetString ? offsetString : '0';\n  justifyString = justifyString ? justifyString : defaultJustifyString;\n  colorString = colorString ? colorString : '';\n  idString = idString ? idString : '';\n  alignContent = alignContent ? alignContent : '';\n  when = when ? when : '';\n  wrapStyle = wrapStyle ? wrapStyle : '';\n  return {\n    size: sizeString,\n    offset: offsetString,\n    justify: justifyString,\n    color: colorString,\n    id: idString,\n    alignContent: alignContent,\n    when: when,\n    wrapStyle: wrapStyle\n  };\n};\n/**\n * Get Size Data From Attribute\n *\n * Given a size attribute string as defined for an <aw-row> or <aw-column> element and used by\n * the width, height, or offset attribute, return the size type and value. Return a structure of\n * the form { sizeType, sizeValue } where: sizeType = \"P\" for proportional values OR \"F\" for\n * fixed values. sizeValue = the integer values times the given standard width or height for\n * fixed values OR the integer value for proportional values\n *\n * @param {string} sizeAttr - The size attribute string as defined by the user\n * @param {number} fixedSizeFactor - Number applied to fixed sized values\n *\n * @return {structure} - { sizeType, sizeValue }\n */\n\nexport let getSizeDataFromAttribute = function (sizeAttr, fixedSizeFactor) {\n  var sizeString = '1'; // Default value\n\n  var sizeType = 'P';\n  var sizeValue = '0';\n\n  if (sizeAttr) {\n    sizeString = sizeAttr;\n    /**\n     * When size attribute is given as percentage, converting it in such a way to calculate\n     * the number based off proportion of 12\n     */\n\n    if (_.endsWith(sizeString, '%')) {\n      var percentNum = _.trimEnd(sizeString, '%');\n\n      sizeString = (percentNum * 12 / 100).toString();\n    }\n  }\n\n  if (sizeString.length < 1) {\n    sizeString = '1';\n  } else if (sizeString === 'fill') {\n    sizeString = '0';\n  } else if (sizeString === 'auto') {\n    sizeString = '0';\n    sizeType = 'A';\n  }\n\n  sizeValue = parseFloat(sizeString, 10);\n\n  if (isNaN(sizeValue)) {\n    exports.reportError('invalid row, column or offset size value (' + sizeAttr + ') - using default of 1');\n    sizeValue = 1;\n  } else if (sizeString[sizeString.length - 1] === 'f') {\n    // Fixed Value\n    sizeType = 'F';\n    sizeValue *= fixedSizeFactor;\n  }\n\n  return {\n    sizeType: sizeType,\n    sizeValue: sizeValue\n  };\n};\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\n\nexport let reportError = function (errorMessage) {\n  logger.warn('awRowColumnService:' + errorMessage);\n};\nexports = {\n  constants,\n  initRowOrColumn,\n  addNewElement,\n  setAreaStyle,\n  isLastChild,\n  getFillData,\n  getAreaList,\n  getAreaData,\n  getAreaUserAttributes,\n  getSizeDataFromAttribute,\n  reportError\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/awRowColumnService.js"],"names":["exports","constants","gridSystemSize","standardWidthFactor","standardHeightFactor","initRowOrColumn","containerElement","scopeElements","containerClassName","areaList","centerJustifyIndex","farJustifyIndex","insertBefore","fillData","fillValue","fillAreaCount","fillAreaString","_","area","justifyOption","offsetValue","addNewElement","newElement","document","className","sibling","setAreaStyle","valueString","sizeValue","areaPercent","sizeType","flexString","when","deviceModeList","deviceMode","mode","size","parseInt","areaElement","areaType","alignContentValue","isLastChild","children","parent","length","getFillData","testAreaType","typeError","fillSize","getAreaList","childList","subAreaData","getAreaData","classList","stackDirection","standardSizeFactor","userAttributes","sizeData","offsetSizeType","offsetSizeValue","justify","color","alignContent","wrapStyle","getAreaUserAttributes","sizeAttributeName","defaultJustifyString","sizeString","offsetString","justifyString","colorString","idString","offset","id","getSizeDataFromAttribute","percentNum","parseFloat","isNaN","reportError","logger"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used by <aw-row> and <aw-column> to initialize the flexbox sizing attributes for all rows and\n * columns within the grid system. And to establish elements to implement offsets, align-contents (start, center, end) and justification options.\n *\n * @module js/awRowColumnService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\n\nlet exports = {}; // eslint-disable-line no-invalid-this\n\nexport let constants = {\n    gridSystemSize: 12,\n    standardWidthFactor: 1,\n    standardHeightFactor: 1\n};\n\n/**\n * Initialize Row or Column - every row or column element calls this method at link time to\n * initialized the flexbox attributes for all siblings. And to add elements to implement offsets\n * align-contents (start, center, end) and justification options.\n *\n * @param {object} scopeElements - The angularJS scope elements used to define the row or\n *            column.\n */\nexport let initRowOrColumn = function( scopeElements ) {\n    // Get the container element used for the given row or column element\n    var containerElement = scopeElements[ 0 ].parentElement;\n    var containerClassName = scopeElements[ 0 ].className;\n\n\n    // Get all sub-area in this row or column\n    var areaList = exports.getAreaList( containerElement );\n    if( areaList === null ) {\n        return;\n    }\n\n    // Set parent container element to use flexbox\n    containerElement.style.display = 'flex';\n    if( areaList[ 0 ].wrapStyle ) {\n        containerElement.style.flexWrap = areaList[ 0 ].wrapStyle;\n    }\n\n    containerElement.style.webkitFlexDirection = areaList[ 0 ].stackDirection;\n    containerElement.style.flexDirection = areaList[ 0 ].stackDirection;\n\n    // Variables used to captured the index for the first center justify\n    // and (right or bottom) justify elements\n    // Elements to implement the justification will be inserted before these elements\n    var centerJustifyIndex = -1;\n    var farJustifyIndex = -1;\n\n    // Flag to control relative positions of offset elements\n    var insertBefore = true;\n\n    // Get the number of fill areas and the amount of space that is\n    // NOT defined by proportional values needed to fill the grid system\n    var fillData = exports.getFillData( areaList );\n    var fillValue = fillData.fillSize;\n    var fillAreaCount = fillData.fillAreaCount;\n    var fillAreaString = '';\n\n    // If there are fill areas then all open area will be consumed by them\n    // Any justification options will be ignored\n    if( fillAreaCount > 0 ) {\n        // For multiple fill areas the area is split between them\n        fillAreaString = ( fillValue / fillAreaCount ).toString();\n        fillValue = 0;\n    }\n\n    // Process all items in the current row or column:\n    // Set the flexbox size attributes\n    // Capture key justification positions\n    // Add elements needed to implement offsets\n    _.forEach( areaList, function( area, index ) {\n        // Set flexbox size attributes for this element\n        exports.setAreaStyle( area.areaElement, area.sizeType, area.sizeValue, area.color,\n            fillAreaString, area.alignContent, area.when, area.areaType );\n\n        // Capture the index of the first center and (right or bottom) elements\n        var justifyOption = area.justify;\n        if( justifyOption === 'center' && centerJustifyIndex < 0 ) {\n            centerJustifyIndex = index;\n        }\n        if( ( justifyOption === 'right' || justifyOption === 'bottom' ) &&\n            farJustifyIndex < 0 ) {\n            farJustifyIndex = index;\n            insertBefore = false;\n        }\n\n        // If this element has an offset then create the offset element\n        var offsetValue = area.offsetSizeValue;\n        if( offsetValue > 0 ) {\n            exports.addNewElement( containerClassName, area.offsetSizeType, offsetValue,\n                'transparent', '', insertBefore, area.areaElement, area.areaType );\n        }\n    } ); // End process all items\n\n    // Add filler elements to handle justification or to fill in undefined space at the end\n    if( fillValue > 0 ) {\n        fillAreaString = fillValue.toString();\n\n        if( centerJustifyIndex >= 0 ) {\n            // Two Element are needed to center - so split the remaining space\n            // Note that this also handles the case of a center AND a (right or bottom) justification\n            fillAreaString = ( fillValue / 2 ).toString();\n\n            // Insert an element before the center justify element\n            exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                true, areaList[ centerJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n\n            if( farJustifyIndex > 0 ) {\n                // Also insert a new element before the far justify element\n                exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                    true, areaList[ farJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n            } else {\n                // There is no right or bottom justify option - so insert at the end to center\n                exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                    false, scopeElements[ 0 ], areaList[ 0 ].areaType );\n            }\n        } else if( farJustifyIndex >= 0 ) {\n            // Insert one new element before the far justify element\n            exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                true, areaList[ farJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n        }\n    }\n};\n\n/**\n * Add New Element\n *\n * Add a new element of a given size before or after a given sibling element.\n *\n * @param {string} className - The class name used for all siblings.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n *            areas\n * @param {boolean} before - when true insert the new element before the sibling, otherwise\n *            insert after\n * @param {object} sibling - existing sibling element to insert before or after Note: pass in\n *            the DOM element not the JQuery/Angular scoping element\n */\nexport let addNewElement = function( className, sizeType, sizeValue, color, fillAreaString, before,\n    sibling, areaType ) {\n    // Example to get rid of ngModule.element\n    /*\n        ngModule.element - it is a $.element, which should be replaced by vallinaJS ( major usage )\n        ngModule.isUndefined - can be vanillaJS\n        ngModule.copy - simple deep copy\n        ngModule.bind - similar like function.bind, not sure why we need this. But should be able to replace.\n        ngModule.noop - similar like null? Anyway we can do equivalent\n        ngModule.forEach - _.forEachngModule.isFunction - _.isFunction\n     */\n    var newElement = document.createElement( 'div' );\n\n    _.forEach( className.split( ' ' ), function( cName ) {\n        newElement.classList.add( cName );\n    } );\n\n    exports.setAreaStyle( newElement, sizeType, sizeValue, color, fillAreaString, null, null, areaType );\n\n    sibling.parentNode.insertBefore( newElement, sibling );\n\n    if( !before ) {\n        newElement.parentNode.insertBefore( sibling, newElement );\n    }\n};\n\n/**\n * Set Area Style\n *\n * Set the flexbox size attributes for Fixed and Proportional areas and set the given color.\n *\n * @param {object} areaElement - The row or column to size.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n * @param {string} alignContent - \"start\", \"center\" or \"end\" to flex align Items/ Content\n *            areas\n * @param {string} when - \"xlarge: <value>, large: <value>, medium: <value>, small: <value>, xsmall: <value>\"\n *            12 column responsive grid layout\n */\nexport let setAreaStyle = function( areaElement, sizeType, sizeValue, color, fillAreaString, alignContent, when, areaType ) {\n    var valueString = sizeValue.toString();\n    var flexString;\n\n    var areaPercent = '';\n\n    if( sizeType === 'P' ) {\n        if( sizeValue > 0 ) {\n            // This is a normal proportional area\n            // note that for IE performance, numeric values should not be used for the flex-basis (3rd value in flexString)\n            flexString = valueString + ' ' + valueString + ' auto';\n            if( valueString > 1 ) {\n                areaPercent = 100 * valueString / 12 + '%';\n            }\n        } else {\n            // This is a fill area - which will also be proportional\n            flexString = fillAreaString + ' ' + fillAreaString + ' auto';\n            if( fillAreaString > 1 ) {\n                areaPercent = 100 * fillAreaString / 12 + '%';\n            }\n        }\n    } else if( sizeType === 'A' ) {\n        flexString = '0 0 auto';\n    } else { // sizeType = \"F\"\n        // These are areas defined with fixed values\n        flexString = '0 0 ' + sizeValue.toString() + 'em';\n    }\n\n    if( when && sizeType === 'P' ) {\n        var deviceModeList = when.split( ',' );\n        if( deviceModeList && deviceModeList.length ) {\n            deviceModeList.forEach( function( mode ) {\n                var deviceMode = mode.split( ':' )[ 0 ].trim();\n                var size = parseInt( mode.split( ':' )[ 1 ] );\n\n                if( deviceMode === 'xlarge' ) {\n                    areaElement.className += ' aw-xlarge-' + size + ' ';\n                } else if( deviceMode === 'large' ) {\n                    areaElement.className += ' aw-large-' + size + ' ';\n                } else if( deviceMode === 'medium' ) {\n                    areaElement.className += ' aw-medium-' + size + ' ';\n                } else if( deviceMode === 'small' ) {\n                    areaElement.className += ' aw-small-' + size + ' ';\n                } else if( deviceMode === 'xsmall' ) {\n                    areaElement.className += ' aw-xsmall-' + size + ' ';\n                } else {\n                    areaElement.className += ' aw-default-' + sizeValue + ' ';\n                }\n            } );\n        }\n    } else {\n        // apply the flex value inline\n        // Numeric flex-basis should be avoided.\n        // Any change their needs to be carefully tested in IE for performance validation.\n        areaElement.style.flex = flexString;\n        if( areaPercent ) {\n            areaType === 'column' ? areaElement.style.width = areaPercent : areaElement.style.height = areaPercent;\n        }\n    }\n\n    // Add the flexbox sizing string and user given color to the current element\n    areaElement.style.backgroundColor = color;\n    var alignContentValue = '';\n    switch ( alignContent ) {\n    case 'start':\n        alignContentValue = 'flex-start';\n        break;\n    case 'center':\n        alignContentValue = 'center';\n        break;\n    case 'end':\n        alignContentValue = 'flex-end';\n        break;\n    }\n    areaElement.style.alignItems = alignContentValue;\n};\n\n/**\n * Is Last Child\n *\n * Return true if the given child element is the last child element of the given parent element.\n *\n * @param {object} parent - container element\n * @param {object} child - a child of the container element\n *\n * @return {boolean} - true if child is the last child in parent\n */\nexport let isLastChild = function( parent, child ) {\n    if( !parent ) {\n        return false;\n    }\n    var children = parent.children;\n    if( !children ) {\n        return false;\n    }\n    var length = children.length;\n    if( length < 1 ) {\n        return false;\n    }\n    if( children[ length - 1 ] !== child ) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Get Fill Data\n *\n * For the given row or column, return the number of areas defined with a size of \"fill\" and the\n * amount of space in the grid system that is not defined by proportional width or height or\n * offset values. This is the space to be filled by the \"fill\" areas or by justification\n * options.\n *\n * Note this method also verifies that all items are rows or columns and if not reports a usage\n * error.\n *\n * @param {array} areaList - Array of structures for all areas in a row or column (see\n *            getAreaData)\n *\n * @return {structure} - { fillSize:fillSize, fillAreaCount:fillAreaCount }\n */\nexport let getFillData = function( areaList ) {\n    // Used to verify that areas are not defined with a mixture of row and column elements\n    var testAreaType = areaList[ 0 ].areaType;\n    var typeError = false;\n\n    var fillSize = exports.constants.gridSystemSize;\n    var fillAreaCount = 0;\n\n    _.forEach( areaList, function( area ) {\n        // Subtract proportional widths or heights\n        if( area.sizeType === 'P' ) {\n            fillSize -= area.sizeValue;\n\n            // Count Fill Area\n            // Fill areas are identified by having a size of zero\n            if( area.sizeValue === 0 ) {\n                ++fillAreaCount;\n            }\n        }\n\n        // Subtract proportional offsets\n        if( area.offsetSizeType === 'P' ) {\n            fillSize -= area.offsetSizeValue;\n        }\n\n        // Verify all items are rows or columns (not a mixture)\n        if( area.areaType !== testAreaType ) {\n            typeError = true;\n        }\n    } );\n\n    if( typeError ) {\n        exports.reportError( 'area found that is defined with mixed rows and columns' );\n    }\n\n    if( fillSize < 0 ) {\n        fillSize = 0;\n        exports.reportError( 'row or column found defined with proportional areas that exceed grid system size: ' + exports.constants.gridSystemSize );\n    }\n\n    return {\n        fillSize: fillSize,\n        fillAreaCount: fillAreaCount\n    };\n};\n\n/**\n * Get Area List\n *\n * For the given container element, return the list of sub-areas (rows or columns) that define\n * the layout for the container.\n *\n * If there are sub-elements then return an array of structures (see getAreaData) If there are\n * no sub-elements then return null.\n *\n * @param {object} containerElement - Element containing the list of row or column elements\n *\n * @return {structure} - see getAreaData\n */\nexport let getAreaList = function( containerElement ) {\n    if( !containerElement ) {\n        return null;\n    }\n    var childList = containerElement.children;\n    if( !childList ) {\n        return null;\n    }\n    if( childList.length < 1 ) {\n        return null;\n    }\n\n    var areaList = [];\n\n    _.forEach( childList, function( subArea ) {\n        var subAreaData = exports.getAreaData( subArea );\n        if( subAreaData ) {\n            areaList.push( subAreaData );\n        }\n    } );\n\n    if( areaList.length < 1 ) {\n        return null;\n    }\n\n    return areaList;\n};\n\n/**\n * Get Area Data\n *\n * For a given row or column, create and return the data defining the size and options\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { areaElement, areaType, stackDirection, sizeType, sizeValue,\n *         offsetSizeType, offsetSizeValue, justify, color, align-content }\n */\nexport let getAreaData = function( areaElement ) {\n    // Set the area type based on the elements class name\n    var classList = areaElement.classList;\n\n    var areaType = 'unknown';\n    var standardSizeFactor;\n    var stackDirection;\n\n    if( classList.contains( 'aw-layout-row' ) ) {\n        areaType = 'row';\n        stackDirection = 'column'; // flexbox direction\n        standardSizeFactor = exports.constants.standardHeightFactor;\n    } else if( classList.contains( 'aw-layout-column' ) ) {\n        areaType = 'column';\n        stackDirection = 'row'; // flexbox direction\n        standardSizeFactor = exports.constants.standardWidthFactor;\n    } else {\n        // Ignore all other elements\n        return null;\n    }\n\n    var userAttributes = exports.getAreaUserAttributes( areaElement );\n\n    var sizeData = exports.getSizeDataFromAttribute( userAttributes.size, standardSizeFactor );\n    var sizeType = sizeData.sizeType;\n    var sizeValue = sizeData.sizeValue;\n\n    sizeData = exports.getSizeDataFromAttribute( userAttributes.offset, standardSizeFactor );\n    var offsetSizeType = sizeData.sizeType;\n    var offsetSizeValue = sizeData.sizeValue;\n\n    return {\n        areaElement: areaElement, // row or column element\n        areaType: areaType, // \"row\", \"column\"\n        stackDirection: stackDirection, // \"row\" means stack horizontally, \"column\" vertically\n        sizeType: sizeType, // \"F\" fixed, \"P\" proportional, \"A\" auto\n        sizeValue: sizeValue, // value for width or height\n        offsetSizeType: offsetSizeType, // \"F\" or \"P\" type of values used for offset\n        offsetSizeValue: offsetSizeValue, // width or height of the desired offset\n        justify: userAttributes.justify, // \"left\", \"right\", \"top\", \"bottom\", \"center\"\n        color: userAttributes.color,\n        alignContent: userAttributes.alignContent, // \"start\", \"center\", \"end\"\n        when: userAttributes.when, // large, medium, small\n        wrapStyle: userAttributes.wrapStyle // nowrap, wrap, wrap-reverse\n    }; // Any CSS color string\n};\n\n/**\n * Get Area User Attributes\n *\n * For the given row or column, return a structure containing either the attribute value as\n * defined by the user or the default attribute value for all possible attributes.\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { size, offset, justify, color, id, alignContent }\n */\nexport let getAreaUserAttributes = function( areaElement ) {\n    var sizeAttributeName = 'width';\n    var defaultJustifyString = 'left';\n    if( areaElement.classList.contains( 'aw-layout-row' ) ) {\n        sizeAttributeName = 'height';\n        defaultJustifyString = 'top';\n    }\n\n    // Get original attributes as defined in the element by the user\n    var sizeString = areaElement.getAttribute( sizeAttributeName );\n    var offsetString = areaElement.getAttribute( 'offset' );\n    var justifyString = areaElement.getAttribute( 'justify' );\n    var colorString = areaElement.getAttribute( 'color' );\n    var idString = areaElement.getAttribute( 'offset' );\n    var alignContent = areaElement.getAttribute( 'align-content' );\n    var when = areaElement.getAttribute( 'when' );\n    var wrapStyle = areaElement.getAttribute( 'wrap-style' );\n\n    // Set defaults for attributes that were not defined by the user\n    sizeString = sizeString ? sizeString : '1';\n    offsetString = offsetString ? offsetString : '0';\n    justifyString = justifyString ? justifyString : defaultJustifyString;\n    colorString = colorString ? colorString : '';\n    idString = idString ? idString : '';\n    alignContent = alignContent ? alignContent : '';\n    when = when ? when : '';\n    wrapStyle = wrapStyle ? wrapStyle : '';\n\n    return {\n        size: sizeString,\n        offset: offsetString,\n        justify: justifyString,\n        color: colorString,\n        id: idString,\n        alignContent: alignContent,\n        when: when,\n        wrapStyle: wrapStyle\n    };\n};\n\n/**\n * Get Size Data From Attribute\n *\n * Given a size attribute string as defined for an <aw-row> or <aw-column> element and used by\n * the width, height, or offset attribute, return the size type and value. Return a structure of\n * the form { sizeType, sizeValue } where: sizeType = \"P\" for proportional values OR \"F\" for\n * fixed values. sizeValue = the integer values times the given standard width or height for\n * fixed values OR the integer value for proportional values\n *\n * @param {string} sizeAttr - The size attribute string as defined by the user\n * @param {number} fixedSizeFactor - Number applied to fixed sized values\n *\n * @return {structure} - { sizeType, sizeValue }\n */\nexport let getSizeDataFromAttribute = function( sizeAttr, fixedSizeFactor ) {\n    var sizeString = '1'; // Default value\n    var sizeType = 'P';\n    var sizeValue = '0';\n\n    if( sizeAttr ) {\n        sizeString = sizeAttr;\n\n        /**\n         * When size attribute is given as percentage, converting it in such a way to calculate\n         * the number based off proportion of 12\n         */\n        if( _.endsWith( sizeString, '%' ) ) {\n            var percentNum = _.trimEnd( sizeString, '%' );\n            sizeString = ( percentNum * 12 / 100 ).toString();\n        }\n    }\n\n    if( sizeString.length < 1 ) {\n        sizeString = '1';\n    } else if( sizeString === 'fill' ) {\n        sizeString = '0';\n    } else if( sizeString === 'auto' ) {\n        sizeString = '0';\n        sizeType = 'A';\n    }\n\n    sizeValue = parseFloat( sizeString, 10 );\n\n    if( isNaN( sizeValue ) ) {\n        exports.reportError( 'invalid row, column or offset size value (' + sizeAttr +\n            ') - using default of 1' );\n        sizeValue = 1;\n    } else if( sizeString[ sizeString.length - 1 ] === 'f' ) { // Fixed Value\n        sizeType = 'F';\n        sizeValue *= fixedSizeFactor;\n    }\n\n    return {\n        sizeType: sizeType,\n        sizeValue: sizeValue\n    };\n};\n\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\nexport let reportError = function( errorMessage ) {\n    logger.warn( 'awRowColumnService:' + errorMessage );\n};\n\nexports = {\n    constants,\n    initRowOrColumn,\n    addNewElement,\n    setAreaStyle,\n    isLastChild,\n    getFillData,\n    getAreaList,\n    getAreaData,\n    getAreaUserAttributes,\n    getSizeDataFromAttribute,\n    reportError\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}