{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * XHR related utilities\n *\n * @module js/splmStatsXhrService\n */\nimport { logger } from 'js/splmStatsUtils';\nimport jsService from 'js/splmStatsJsService';\nlet _procs = [];\nlet _xhrCounter = 0;\nlet _realOpen = null;\nlet _xhrSender = null;\nlet _enabled = false;\nlet _mainProc = null;\nexport const getCount = function () {\n  return _xhrCounter;\n};\nexport const setMainProc = function (processor) {\n  _mainProc = processor;\n};\nexport const install = function () {\n  if (!_enabled) {\n    _realOpen = XMLHttpRequest.prototype.open;\n\n    XMLHttpRequest.prototype.open = function (method, url, async, user, password) {\n      _xhrCounter++; //Try to add as early as possible to avoid pre-finishing pollyfill\n\n      _realOpen.call(this, method, url, async, user, password);\n\n      this.requestURL = url;\n    };\n\n    _xhrSender = XMLHttpRequest.prototype.send;\n\n    XMLHttpRequest.prototype.send = function (data) {\n      let xhr = this;\n      _xhrCounter++; // Side Effect fix (helper) - More accurate to have +1 on open and +1 on send and then -2 on receive response\n\n      xhr.addEventListener('readystatechange', function () {\n        if (xhr.readyState === 4) {\n          _xhrCounter -= 2;\n\n          _procs.forEach(proc => {\n            try {\n              proc.done();\n            } catch (error) {\n              logger.warn(error);\n            }\n          });\n        }\n      }, true);\n      /**\n       * Only wrap the function if there is an 'onload' function to wrap (i.e. NOT trying to do a\n       * Socket.IO/WebSocket call which has no such function).\n       */\n\n      if (jsService.enabled() && xhr.onload) {\n        xhr.onload = jsService.wrapFunction(xhr, xhr.onload, xhr.requestURL);\n      }\n\n      try {\n        if (_mainProc) {\n          _mainProc(xhr, data);\n        }\n      } catch (error) {\n        logger.warn(error);\n      } // procs\n\n\n      _procs.forEach(proc => {\n        try {\n          proc.start();\n        } catch (error) {\n          logger.warn(error);\n        }\n      });\n\n      _xhrSender.call(xhr, data);\n    };\n\n    _enabled = true;\n  }\n};\nexport const uninstall = function () {\n  return true;\n};\nexport const addProc = function (proc) {\n  _procs.push(proc);\n};\nexport const removeProc = function (proc) {\n  _procs = _procs.filter(procObj => proc !== procObj);\n};\nexport default {\n  getCount,\n  setMainProc,\n  install,\n  uninstall,\n  addProc,\n  removeProc\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/plstats/src/js/splmStatsXhrService.js"],"names":["_procs","_xhrCounter","_realOpen","_xhrSender","_enabled","_mainProc","getCount","setMainProc","install","XMLHttpRequest","xhr","proc","logger","jsService","uninstall","addProc","removeProc","procObj"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n\n/**\n * XHR related utilities\n *\n * @module js/splmStatsXhrService\n */\nimport { logger } from 'js/splmStatsUtils';\nimport jsService from 'js/splmStatsJsService';\n\nlet _procs = [];\nlet _xhrCounter = 0;\n\nlet _realOpen = null;\nlet _xhrSender = null;\n\nlet _enabled = false;\n\nlet _mainProc = null;\n\nexport const getCount = function() {\n    return _xhrCounter;\n};\n\nexport const setMainProc = function( processor ) {\n    _mainProc = processor;\n};\n\nexport const install = function() {\n    if( !_enabled ) {\n        _realOpen = XMLHttpRequest.prototype.open;\n        XMLHttpRequest.prototype.open = function( method, url, async, user, password ) {\n            _xhrCounter++; //Try to add as early as possible to avoid pre-finishing pollyfill\n            _realOpen.call( this, method, url, async, user, password );\n            this.requestURL = url;\n        };\n\n        _xhrSender = XMLHttpRequest.prototype.send;\n        XMLHttpRequest.prototype.send = function( data ) {\n            let xhr = this;\n            _xhrCounter++; // Side Effect fix (helper) - More accurate to have +1 on open and +1 on send and then -2 on receive response\n            xhr.addEventListener( 'readystatechange', function() {\n                if( xhr.readyState === 4 ) {\n                    _xhrCounter -= 2;\n\n                    _procs.forEach( proc => {\n                        try {\n                            proc.done();\n                        } catch ( error ) {\n                            logger.warn( error );\n                        }\n                    } );\n                }\n            }, true );\n\n            /**\n             * Only wrap the function if there is an 'onload' function to wrap (i.e. NOT trying to do a\n             * Socket.IO/WebSocket call which has no such function).\n             */\n            if( jsService.enabled() && xhr.onload ) {\n                xhr.onload = jsService.wrapFunction( xhr, xhr.onload, xhr.requestURL );\n            }\n\n            try {\n                if( _mainProc ) {\n                    _mainProc( xhr, data );\n                }\n            } catch ( error ) {\n                logger.warn( error );\n            }\n\n            // procs\n            _procs.forEach( proc => {\n                try {\n                    proc.start();\n                } catch ( error ) {\n                    logger.warn( error );\n                }\n            } );\n\n            _xhrSender.call( xhr, data );\n        };\n        _enabled = true;\n    }\n};\n\nexport const uninstall = function() {\n    return true;\n};\n\nexport const addProc = function( proc ) {\n    _procs.push( proc );\n};\n\nexport const removeProc = function( proc ) {\n    _procs = _procs.filter( procObj => proc !== procObj );\n};\n\nexport default {\n    getCount,\n    setMainProc,\n    install,\n    uninstall,\n    addProc,\n    removeProc\n};\n"]},"metadata":{},"sourceType":"module"}