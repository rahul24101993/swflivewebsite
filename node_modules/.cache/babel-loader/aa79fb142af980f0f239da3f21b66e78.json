{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* global afxDynamicImport afxWeakImport */\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/declUtils\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n/** revisitme Shaishav\n * Hint: We need to integrate with appCtxService\nimport appCtxSvc from 'js/appCtxService';\n*/\n\nimport parsingUtils from 'js/parsingUtils';\nimport browserUtils from 'js/browserUtils';\nimport appCtxSvc from 'js/appCtxService'; // Service\n\nimport AwParseService from 'js/awParseService';\nvar exports = {};\nvar MSG_1 = 'Required DeclViewModel not specified';\nvar MSG_PREFIX_1 = 'Invalid to process with destroyed DeclViewModel: ';\nvar MSG_PREFIX_2 = 'Invalid to process with destroyed DataContextNode: ';\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\n\nvar _actionPropsToLog = ['actionId', 'actionType', 'method', 'serviceName', 'deps', 'steps'];\n/**\n * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's\n * URL.\n */\n\nvar _debug_logLifeCycleIssues = browserUtils.getUrlAttributes().logLifeCycleIssues !== undefined;\n/**\n * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid\n * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema\n * checker).\n */\n\n\nexport let attrHolderPropName = ['dbValue', 'displayName', 'dispValue', 'isArray', 'isEditable', 'isRequired', 'isEnabled', 'displayValue', 'value', 'isModifiable', 'isAutoAssign', 'isAutoAssignable', 'labelPosition', 'requiredText', 'type', 'propName', 'hasLov', 'dataProvider', 'isSelectOnly', 'isRichText', 'referenceTypeName', 'maxLength', 'maxArraySize', 'renderingHint', 'autofocus', 'propertyDisplayName', 'patterns', 'preferredPattern', 'patternAutoAssignFlags', 'condition', 'validationCriteria', 'oldValue', 'oldValues', 'vertical', 'propertyRadioTrueText', 'propertyRadioFalseText', 'numberOfLines', 'iconName'];\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\n\nexport const loadDependentModule = depModule => {\n  return moduleLoader.loadDependentModule(depModule);\n};\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\n\nexport let buildLifeCycleIssueMessage = function (declViewModel, action, consequence, methodName) {\n  var errorMsg = 'Attempted processing after an associated DeclViewModel was destroyed...';\n\n  if (consequence) {\n    errorMsg += '\\n';\n    errorMsg += consequence;\n  }\n\n  if (declViewModel) {\n    errorMsg += '\\n';\n    errorMsg += 'DeclViewModel: ';\n    errorMsg += declViewModel;\n  }\n\n  if (methodName) {\n    errorMsg += '\\n';\n    errorMsg += 'Method: ';\n    errorMsg += methodName;\n  }\n\n  if (action) {\n    errorMsg += '\\n';\n    errorMsg += 'Action:';\n    errorMsg += '\\n';\n    errorMsg += JSON.stringify(action, _actionPropsToLog, 2);\n  }\n\n  return errorMsg;\n};\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\n\nexport let logLifeCycleIssue = function (declViewModel, action, consequence, methodName) {\n  var errorMsg = exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName);\n\n  if (_debug_logLifeCycleIssues) {\n    logger.warn(errorMsg);\n  }\n\n  return errorMsg;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\n\nexport let assertValidModel = function (declViewModel) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n};\n/**\n * Clone scope without copying angular scope's internal properties.\n *\n * @param {Object} scope - Object to clone.\n *\n * @return {Object} an object that holds data from provided Object\n */\n\nexport let cloneData = function (scope) {\n  var object = {};\n\n  _.forOwn(scope, function (value, key) {\n    if (!_.startsWith(key, '$')) {\n      object[key] = value;\n    }\n  });\n\n  return object;\n};\n/**\n * update data for fileData\n *\n * @param {Object} fileData - key string value the location of the file\n * @param {Object} data the view model data object\n */\n\n/** revisitme Shaishav\n * Hint: We need a jquery free solution here\nexport let updateFormData = function( fileData, data ) {\n    if( fileData && fileData.value ) {\n        var form = $( '#fileUploadForm' );\n        data.formData = new FormData( $( form )[ 0 ] );\n        data.formData.append( fileData.key, fileData.value );\n    }\n};\n*/\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\n\nexport let assertValidModelWithOriginalJSON = function (declViewModel) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  assert(declViewModel._internal.origDeclViewModelJson, 'Required DeclViewModel JSON object not specified');\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n */\n\nexport let assertValidModelAndDataCtxNode = function (declViewModel, dataCtxNode) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + ' DeclViewModel=' + declViewModel);\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\n\nexport let isValidModelAndDataCtxNode = function (declViewModel, dataCtxNode) {\n  if (!declViewModel) {\n    if (_debug_logLifeCycleIssues) {\n      logger.warn(MSG_1);\n    }\n\n    return false;\n  }\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    exports.logLifeCycleIssue(declViewModel, null, null, 'isValidModelAndDataCtxNode');\n    return false;\n  }\n\n  if (!declViewModel.isUnmounting && dataCtxNode && dataCtxNode.$$destroyed) {\n    if (_debug_logLifeCycleIssues) {\n      logger.warn(MSG_PREFIX_2 + dataCtxNode.$id + ' DeclViewModel=' + declViewModel);\n    }\n\n    return false;\n  }\n\n  return true;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n * @param {DeclAction} action - The declAction object to test.\n */\n\nexport let assertValidModelDataCtxNodeAndAction = function (declViewModel, dataCtxNode, action) {\n  assert(declViewModel, MSG_1);\n\n  if (declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel + ' actionType: ' + action.actionType + ' method: ' + action.method + ' deps: ' + action.deps);\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + ' DeclViewModel=' + declViewModel + ' actionType: ' + action.actionType + ' method: ' + action.method + ' deps: ' + action.deps);\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @param {DeclAction} action - The declAction object to test.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n */\n\nexport let assertValidModelDataCtxNodeAndAction2 = function (declViewModel, dataCtxNode, action, consequence, methodName) {\n  assert(declViewModel, MSG_1);\n\n  if (declViewModel._internal.isDestroyed) {\n    assert(false, exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName));\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName));\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n */\n\nexport let assertValidModelAndEventData = function (declViewModel, eventData) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  if (eventData && eventData.scope && eventData.scope.$$destroyed) {\n    assert(false, MSG_PREFIX_2 + (eventData.scope ? eventData.scope.$id : '???') + ' DeclViewModel=' + declViewModel);\n  }\n};\n/**\n * Evaluate message with its parameters\n *\n * @param {String} messageString - The message String.\n *\n * @param {String} messageParams - The message parameters.\n *\n * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to\n *            search within.\n *\n * @return {String} Result string after applying passed parameters.\n */\n\nexport let applyMessageParams = function (messageString, messageParams, messageContext) {\n  var placeHolders = messageString.match(/\\{[0-9]*\\}/g);\n  var resultString = messageString;\n\n  if (placeHolders && messageParams) {\n    for (var i in placeHolders) {\n      if (placeHolders.hasOwnProperty(i)) {\n        var placeHolder = placeHolders[i];\n        var index = placeHolder;\n        index = _.trimStart(index, '{');\n        index = _.trimEnd(index, '}');\n        var key = parsingUtils.getStringBetweenDoubleMustaches(messageParams[index]);\n\n        var replacementString = _.get(messageContext, key);\n\n        resultString = resultString.replace(placeHolder, replacementString);\n      }\n    }\n  }\n\n  return resultString;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\n\nexport let isValidModelAndEventData = function (declViewModel, eventData) {\n  if (!declViewModel) {\n    logger.warn(MSG_1);\n    return false;\n  }\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    logger.warn(MSG_PREFIX_1 + declViewModel);\n    return false;\n  }\n\n  if (eventData && eventData.scope && eventData.scope.$$destroyed) {\n    logger.warn(MSG_PREFIX_2 + (eventData.scope ? eventData.scope.$id : '???') + ' DeclViewModel=' + declViewModel);\n    return false;\n  }\n\n  return true;\n};\n/**\n * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was\n * started.\n * <P>\n * If so: Use the dataCtxNode the DeclViewModel was originally created on.\n * <P>\n * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the\n * event was processed.\n *\n * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check\n * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.\n *\n * @returns {Object} The dataCtxNode object to use.\n */\n\nexport let resolveLocalDataCtx = function (declViewModel, dataCtxNode) {\n  if (dataCtxNode.$$destroyed) {\n    return declViewModel._internal.origCtxNode;\n  }\n\n  return dataCtxNode;\n};\n/**\n * Return true if provided value is 'nil' (i.e. not null or undefined).\n *\n * @param {Object} value - The value to test.\n *\n * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).\n */\n\nexport let isNil = function (value) {\n  return value === undefined || value === null;\n};\n/**\n * Return a empty function\n *\n * @returns {null} null\n */\n\nexport const noop = () => null;\n/**\n * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given\n * 'dataCtxNode'.\n *\n * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the\n *            lookup of the 'declViewModel'.\n *\n * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as\n *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.\n *\n * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is\n *            TRUE.\n *\n * @return {DeclViewModel} The 'declViewModel' found.\n */\n\nexport let findViewModel = function (dataCtxNode, setInScope) {\n  /**\n   * Check for the case where the declViewModel is already set on the given node.\n   */\n  if (dataCtxNode.data) {\n    /** revisitme\n    if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {\n        dataCtxNode.ctx = appCtxSvc.ctx;\n    }\n    */\n    return dataCtxNode.data;\n  }\n  /**\n   * Look for the model on a 'parent' node.\n   */\n\n\n  var currCtxNode = dataCtxNode;\n\n  while (currCtxNode && !currCtxNode.data) {\n    currCtxNode = currCtxNode.$parent;\n  }\n\n  if (currCtxNode) {\n    if (setInScope) {\n      dataCtxNode.data = currCtxNode.data;\n      /** revisitme\n      if( appCtxSvc ) {\n          dataCtxNode.ctx = appCtxSvc.ctx;\n      }\n      */\n      //if subPanelContext is available on scope then add it dataCtxNode\n\n      if (currCtxNode.subPanelContext) {\n        dataCtxNode.subPanelContext = currCtxNode.subPanelContext;\n      }\n      /**\n       * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.\n       */\n\n\n      if (dataCtxNode.$on) {\n        dataCtxNode.$on('$destroy', function (data) {\n          data.currentScope.data = null;\n          data.currentScope.ctx = null;\n        });\n      }\n    }\n\n    return currCtxNode.data;\n  }\n\n  return null;\n};\n/**\n * Consolidate the second object's properties into the first one\n *\n * @param {Object} targetObj - The 'target' object to merge to\n * @param {Object} sourceObj - The 'source' object to be merge from\n *\n * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.\n */\n\nexport let consolidateObjects = function (targetObj, sourceObj) {\n  var returnObj = null;\n\n  if (targetObj) {\n    returnObj = targetObj;\n\n    _.forEach(sourceObj, function (n, key) {\n      returnObj[key] = n;\n    });\n  } else if (sourceObj) {\n    returnObj = sourceObj;\n  }\n\n  return returnObj;\n};\n/**\n * Create custom event. Mainly for IE\n *\n * @param {String} eventName - Name of the event\n *\n * @param {Object} eventDetail - Object for event detail\n\n * @param {Object} canBubble -is bubble is up/down\n\n * @param {Object} isCancellable - event can ne canclable or not\n *\n * @return {DOMElement} created DOMElement\n */\n\nexport let createCustomEvent = function (eventName, eventDetail, canBubble, isCancellable) {\n  if (browserUtils.isNonEdgeIE) {\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(eventName, canBubble, isCancellable, eventDetail);\n    return evt;\n  }\n\n  return new CustomEvent(eventName, {\n    detail: eventDetail,\n    bubbles: canBubble\n  });\n};\n/**\n * process output data\n * @param {JSON} outputData output data definition\n * @param {object} result function result\n * @returns {object} data patch as:\n * {\n *     \"ctx.b\": 3,\n *     \"data.c\": 5\n * }\n */\n\nexport const processOutputData = (outputData, result) => {\n  if (outputData) {\n    const value = {};\n\n    for (let vmPath in outputData) {\n      let valPath = outputData[vmPath];\n      let res = undefined;\n\n      if (_.isBoolean(valPath)) {\n        res = valPath;\n      } else {\n        var expression = parsingUtils.getStringBetweenDoubleMustaches(valPath);\n\n        if (_.startsWith(expression, 'json:')) {\n          var jsonStringVariable = expression.replace('json:', '');\n\n          var jsonString = _.get(result, jsonStringVariable);\n\n          res = parsingUtils.parseJsonString(jsonString);\n        } else {\n          res = valPath && valPath.length > 0 ? _.get(result, valPath) : result;\n        }\n      } // TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'\n\n\n      value[/^ctx\\./.test(vmPath) ? vmPath : `data.${vmPath}`] = res;\n    }\n\n    return value;\n  }\n\n  return undefined;\n};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}\n * @param {Object} evaluationEnv - the data environment for expression evaluation\n * evaluation\n *\n * @return {Boolean} the evaluated condition result\n */\n\nexport let evaluateCondition = function (declViewModel, expression, evaluationEnv) {\n  let parse = AwParseService.instance;\n  return parse(expression)(evaluationEnv);\n};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} condition name of condition\n *\n * @return {String} the evaluated condition result\n */\n\nexport let getConditionExpression = function (declViewModel, condition) {\n  var conditionExpression = null;\n\n  if (_.startsWith(condition, 'conditions.')) {\n    var conditionObject = _.get(declViewModel._internal, condition);\n\n    conditionExpression = conditionObject.expression;\n  } else {\n    conditionExpression = condition;\n  }\n\n  return conditionExpression;\n};\n/**\n * Evaluate condition name\n *\n * @param {String} conditionString name of condition\n *\n * @return {String} the evaluated condition result\n */\n\nexport let getConditionName = function (conditionString) {\n  if (_.startsWith(conditionString, 'conditions.')) {\n    var index = conditionString.indexOf('.');\n    return conditionString.substr(index + 1);\n  }\n\n  return null;\n};\n/**\n * Get dirty properties of the view model object\n *\n * @param {Object} vmo - the view model object\n *\n * @return {Array} the dirty properties of the view model object\n */\n\nexport let getAllModifiedValues = function (vmo) {\n  var modifiedProperties = [];\n\n  if (vmo) {\n    modifiedProperties = vmo.getDirtyProps();\n  }\n\n  return modifiedProperties;\n};\n/**\n * Update the properties of the view model property with new values\n *\n * @param {Object} dataObject - view model object.\n * @param {Object} dataProperty - view model object property.\n * @param {Object} dataPropertyValue - view model object property value.\n */\n\nexport let updatePropertyValues = function (dataObject, dataProperty, dataPropertyValue) {\n  dataObject[dataProperty] = dataPropertyValue;\n  return {\n    data: { ...dataObject\n    }\n  };\n};\n/**\n * get type hierarchy from modleObject or view model Object\n *\n * @param {Object} dataObject - view model object.\n *\n *  @return {Array} - hierarchy of model object names\n\n */\n\nexport let getTypeHierarchy = function (dataObject) {\n  return dataObject.typeHierarchy || dataObject.modelType && dataObject.modelType.typeHierarchyArray;\n};\n/**\n *  get functions used in action input/output data\n */\n\nlet getActionDataFunc = function (value, functionsUsedInActions) {\n  if (typeof value === 'string') {\n    var results = value.match(parsingUtils.REGEX_DATABINDING);\n\n    if (results && results.length === 4) {\n      var newVal = results[2];\n\n      if (_.startsWith(newVal, 'function:')) {\n        functionsUsedInActions.push(newVal.replace('function:', ''));\n      }\n    }\n  }\n\n  return functionsUsedInActions;\n};\n/**\n * Get Function dependancies\n *\n * @param {Object} action - The action object\n *\n * @param {Object} viewModel - The view model\n *\n * @return {Array} - The Array contains function dependancies to load.\n */\n\n\nexport let getFunctionDeps = function (action, viewModel) {\n  var depsToLoad = [];\n  var functionsUsedInActions = [];\n  const functions = viewModel.functions; // get functions used in action input data\n\n  if (action && action.inputData) {\n    _.forEach(action.inputData.request, function (value) {\n      getActionDataFunc(value, functionsUsedInActions);\n    });\n  }\n\n  if (action && action.outputData) {\n    _.forEach(action.outputData, function (value) {\n      getActionDataFunc(value, functionsUsedInActions);\n    });\n  }\n\n  if (action && action.dataParsers && action.dataParsers.length) {\n    _.forEach(action.dataParsers, dataParser => {\n      const dataParserDef = viewModel.dataParseDefinitions[dataParser.id];\n      const fnUsedInDataParsers = getFunctionUsageRecursive(dataParserDef);\n\n      _.forEach(fnUsedInDataParsers, fnUsed => getActionDataFunc(fnUsed, functionsUsedInActions));\n    });\n  }\n\n  if (functions) {\n    _.forEach(functions, function (func) {\n      if (func.deps && depsToLoad.includes(func.deps) === false && functionsUsedInActions.includes(func.functionName)) {\n        depsToLoad.push(func.deps);\n      }\n    });\n  }\n\n  return depsToLoad;\n};\n\nconst getFunctionUsageRecursive = object => {\n  let values = [];\n\n  _.each(object, value => {\n    if (_.isString(value) && value.startsWith('{{function:')) {\n      values.push(value);\n    } else if (_.isObject(value)) {\n      values = values.concat(getFunctionUsageRecursive(value));\n    }\n  });\n\n  return values;\n};\n/**\n * Build common proprty Place holder\n *\n *\n * @param {Object} prop - raw property\n *\n * @return {object}  - propAttrHolder will blank if not valid VMP else filled\n */\n\n\nexport let buildPropHolder = prop => {\n  let propAttrHolder = {};\n\n  _.forEach(prop, function (dataPropValue, dataPropName) {\n    if (exports.attrHolderPropName.indexOf(dataPropName) > -1) {\n      propAttrHolder[dataPropName] = dataPropValue;\n    }\n  });\n\n  return propAttrHolder;\n};\nexport let getLatestContext = function (dataCtxNode, declViewModel) {\n  let subPanelContext = null;\n  let ports = null;\n  let conditions = null;\n\n  if (dataCtxNode && dataCtxNode.getProps && _.isFunction(dataCtxNode.getProps)) {\n    let props = dataCtxNode.getProps();\n    dataCtxNode.props = props;\n    subPanelContext = props.subPanelContext;\n  }\n\n  if (dataCtxNode && dataCtxNode.getFields && _.isFunction(dataCtxNode.getFields)) {\n    dataCtxNode.fields = dataCtxNode.getFields();\n  }\n\n  if (declViewModel && declViewModel.getData && _.isFunction(declViewModel.getData)) {\n    let val = declViewModel.getData();\n\n    if (val.hasOwnProperty('data')) {\n      declViewModel.data = val.data;\n    } else {\n      declViewModel.data = val;\n    }\n  }\n\n  if (dataCtxNode && !dataCtxNode.conditions && declViewModel) {\n    conditions = declViewModel.conditions;\n    dataCtxNode.conditions = conditions;\n  }\n\n  if (!dataCtxNode) {\n    dataCtxNode = {};\n  } else {\n    ports = dataCtxNode.ports;\n  }\n\n  return { ...dataCtxNode,\n    data: declViewModel,\n    ctx: { ...dataCtxNode.ctx,\n      ...appCtxSvc.ctx\n    },\n    parameters: dataCtxNode.parameters,\n    subPanelContext: subPanelContext ? subPanelContext : declViewModel.subPanelContext,\n    commandContext: dataCtxNode.commandContext,\n    pasteContext: dataCtxNode.pasteContext,\n    ports: ports ? ports : declViewModel._internal.ports\n  };\n};\nexports = {\n  buildLifeCycleIssueMessage,\n  logLifeCycleIssue,\n  assertValidModel,\n  cloneData,\n\n  /** revisitme\n  updateFormData,\n  */\n  assertValidModelWithOriginalJSON,\n  assertValidModelAndDataCtxNode,\n  isValidModelAndDataCtxNode,\n  assertValidModelDataCtxNodeAndAction,\n  assertValidModelDataCtxNodeAndAction2,\n  assertValidModelAndEventData,\n  isValidModelAndEventData,\n  applyMessageParams,\n  resolveLocalDataCtx,\n  isNil,\n  findViewModel,\n  consolidateObjects,\n  createCustomEvent,\n  evaluateCondition,\n  getConditionExpression,\n  getConditionName,\n  getAllModifiedValues,\n  updatePropertyValues,\n  getFunctionDeps,\n  getTypeHierarchy,\n  processOutputData,\n  noop,\n  loadDependentModule,\n  attrHolderPropName,\n  buildPropHolder,\n  getLatestContext\n};\nexport default exports;","map":{"version":3,"names":["assert","_","logger","moduleLoader","parsingUtils","browserUtils","appCtxSvc","AwParseService","exports","MSG_1","MSG_PREFIX_1","MSG_PREFIX_2","_actionPropsToLog","_debug_logLifeCycleIssues","getUrlAttributes","logLifeCycleIssues","undefined","attrHolderPropName","loadDependentModule","depModule","buildLifeCycleIssueMessage","declViewModel","action","consequence","methodName","errorMsg","JSON","stringify","logLifeCycleIssue","warn","assertValidModel","_internal","isDestroyed","cloneData","scope","object","forOwn","value","key","startsWith","assertValidModelWithOriginalJSON","origDeclViewModelJson","assertValidModelAndDataCtxNode","dataCtxNode","isUnmounting","$$destroyed","$id","isValidModelAndDataCtxNode","assertValidModelDataCtxNodeAndAction","actionType","method","deps","assertValidModelDataCtxNodeAndAction2","assertValidModelAndEventData","eventData","applyMessageParams","messageString","messageParams","messageContext","placeHolders","match","resultString","i","hasOwnProperty","placeHolder","index","trimStart","trimEnd","getStringBetweenDoubleMustaches","replacementString","get","replace","isValidModelAndEventData","resolveLocalDataCtx","origCtxNode","isNil","noop","findViewModel","setInScope","data","currCtxNode","$parent","subPanelContext","$on","currentScope","ctx","consolidateObjects","targetObj","sourceObj","returnObj","forEach","n","createCustomEvent","eventName","eventDetail","canBubble","isCancellable","isNonEdgeIE","evt","document","createEvent","initCustomEvent","CustomEvent","detail","bubbles","processOutputData","outputData","result","vmPath","valPath","res","isBoolean","expression","jsonStringVariable","jsonString","parseJsonString","length","test","evaluateCondition","evaluationEnv","parse","instance","getConditionExpression","condition","conditionExpression","conditionObject","getConditionName","conditionString","indexOf","substr","getAllModifiedValues","vmo","modifiedProperties","getDirtyProps","updatePropertyValues","dataObject","dataProperty","dataPropertyValue","getTypeHierarchy","typeHierarchy","modelType","typeHierarchyArray","getActionDataFunc","functionsUsedInActions","results","REGEX_DATABINDING","newVal","push","getFunctionDeps","viewModel","depsToLoad","functions","inputData","request","dataParsers","dataParser","dataParserDef","dataParseDefinitions","id","fnUsedInDataParsers","getFunctionUsageRecursive","fnUsed","func","includes","functionName","values","each","isString","isObject","concat","buildPropHolder","prop","propAttrHolder","dataPropValue","dataPropName","getLatestContext","ports","conditions","getProps","isFunction","props","getFields","fields","getData","val","parameters","commandContext","pasteContext"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/declUtils.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/* global afxDynamicImport afxWeakImport */\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/declUtils\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n/** revisitme Shaishav\n * Hint: We need to integrate with appCtxService\nimport appCtxSvc from 'js/appCtxService';\n*/\nimport parsingUtils from 'js/parsingUtils';\nimport browserUtils from 'js/browserUtils';\nimport appCtxSvc from 'js/appCtxService';\n\n// Service\nimport AwParseService from 'js/awParseService';\n\nvar exports = {};\n\nvar MSG_1 = 'Required DeclViewModel not specified';\n\nvar MSG_PREFIX_1 = 'Invalid to process with destroyed DeclViewModel: ';\n\nvar MSG_PREFIX_2 = 'Invalid to process with destroyed DataContextNode: ';\n\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\nvar _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'steps' ];\n\n/**\n * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's\n * URL.\n */\nvar _debug_logLifeCycleIssues = browserUtils.getUrlAttributes().logLifeCycleIssues !== undefined;\n\n/**\n * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid\n * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema\n * checker).\n */\nexport let attrHolderPropName = [ 'dbValue', 'displayName', 'dispValue', 'isArray', 'isEditable', 'isRequired', 'isEnabled', 'displayValue', 'value', 'isModifiable', 'isAutoAssign', 'isAutoAssignable',\n    'labelPosition', 'requiredText', 'type', 'propName', 'hasLov', 'dataProvider', 'isSelectOnly', 'isRichText', 'referenceTypeName', 'maxLength', 'maxArraySize', 'renderingHint', 'autofocus',\n    'propertyDisplayName',\n    'patterns', 'preferredPattern', 'patternAutoAssignFlags', 'condition', 'validationCriteria', 'oldValue', 'oldValues', 'vertical', 'propertyRadioTrueText', 'propertyRadioFalseText', 'numberOfLines',\n    'iconName'\n];\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\nexport const loadDependentModule = depModule => {\n    return moduleLoader.loadDependentModule( depModule );\n};\n\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\nexport let buildLifeCycleIssueMessage = function( declViewModel, action, consequence, methodName ) {\n    var errorMsg = 'Attempted processing after an associated DeclViewModel was destroyed...';\n\n    if( consequence ) {\n        errorMsg += '\\n';\n        errorMsg += consequence;\n    }\n\n    if( declViewModel ) {\n        errorMsg += '\\n';\n        errorMsg += 'DeclViewModel: ';\n        errorMsg += declViewModel;\n    }\n\n    if( methodName ) {\n        errorMsg += '\\n';\n        errorMsg += 'Method: ';\n        errorMsg += methodName;\n    }\n\n    if( action ) {\n        errorMsg += '\\n';\n        errorMsg += 'Action:';\n        errorMsg += '\\n';\n        errorMsg += JSON.stringify( action, _actionPropsToLog, 2 );\n    }\n\n    return errorMsg;\n};\n\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\nexport let logLifeCycleIssue = function( declViewModel, action, consequence, methodName ) {\n    var errorMsg = exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName );\n\n    if( _debug_logLifeCycleIssues ) {\n        logger.warn( errorMsg );\n    }\n\n    return errorMsg;\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\nexport let assertValidModel = function( declViewModel ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n};\n\n/**\n * Clone scope without copying angular scope's internal properties.\n *\n * @param {Object} scope - Object to clone.\n *\n * @return {Object} an object that holds data from provided Object\n */\nexport let cloneData = function( scope ) {\n    var object = {};\n    _.forOwn( scope, function( value, key ) {\n        if( !_.startsWith( key, '$' ) ) {\n            object[ key ] = value;\n        }\n    } );\n    return object;\n};\n\n/**\n * update data for fileData\n *\n * @param {Object} fileData - key string value the location of the file\n * @param {Object} data the view model data object\n */\n/** revisitme Shaishav\n * Hint: We need a jquery free solution here\nexport let updateFormData = function( fileData, data ) {\n    if( fileData && fileData.value ) {\n        var form = $( '#fileUploadForm' );\n        data.formData = new FormData( $( form )[ 0 ] );\n        data.formData.append( fileData.key, fileData.value );\n    }\n};\n*/\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\nexport let assertValidModelWithOriginalJSON = function( declViewModel ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    assert( declViewModel._internal.origDeclViewModelJson, 'Required DeclViewModel JSON object not specified' );\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n */\nexport let assertValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\nexport let isValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {\n    if( !declViewModel ) {\n        if( _debug_logLifeCycleIssues ) {\n            logger.warn( MSG_1 );\n        }\n        return false;\n    }\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        exports.logLifeCycleIssue( declViewModel, null, null, 'isValidModelAndDataCtxNode' );\n        return false;\n    }\n\n    if( !declViewModel.isUnmounting && dataCtxNode && dataCtxNode.$$destroyed ) {\n        if( _debug_logLifeCycleIssues ) {\n            logger.warn( MSG_PREFIX_2 + dataCtxNode.$id + ' DeclViewModel=' + declViewModel );\n        }\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n * @param {DeclAction} action - The declAction object to test.\n */\nexport let assertValidModelDataCtxNodeAndAction = function( declViewModel, dataCtxNode, action ) {\n    assert( declViewModel, MSG_1 );\n\n    if( declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel +\n            ' actionType: ' + action.actionType +\n            ' method: ' + action.method +\n            ' deps: ' + action.deps );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +\n            ' DeclViewModel=' + declViewModel +\n            ' actionType: ' + action.actionType +\n            ' method: ' + action.method +\n            ' deps: ' + action.deps );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @param {DeclAction} action - The declAction object to test.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n */\nexport let assertValidModelDataCtxNodeAndAction2 = function( declViewModel, dataCtxNode, action, consequence, methodName ) {\n    assert( declViewModel, MSG_1 );\n\n    if( declViewModel._internal.isDestroyed ) {\n        assert( false, exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +\n            exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n */\nexport let assertValidModelAndEventData = function( declViewModel, eventData ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {\n        assert( false, MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n    }\n};\n\n/**\n * Evaluate message with its parameters\n *\n * @param {String} messageString - The message String.\n *\n * @param {String} messageParams - The message parameters.\n *\n * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to\n *            search within.\n *\n * @return {String} Result string after applying passed parameters.\n */\nexport let applyMessageParams = function( messageString, messageParams, messageContext ) {\n    var placeHolders = messageString.match( /\\{[0-9]*\\}/g );\n\n    var resultString = messageString;\n\n    if( placeHolders && messageParams ) {\n        for( var i in placeHolders ) {\n            if( placeHolders.hasOwnProperty( i ) ) {\n                var placeHolder = placeHolders[ i ];\n\n                var index = placeHolder;\n                index = _.trimStart( index, '{' );\n                index = _.trimEnd( index, '}' );\n\n                var key = parsingUtils.getStringBetweenDoubleMustaches( messageParams[ index ] );\n                var replacementString = _.get( messageContext, key );\n                resultString = resultString.replace( placeHolder, replacementString );\n            }\n        }\n    }\n\n    return resultString;\n};\n\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\nexport let isValidModelAndEventData = function( declViewModel, eventData ) {\n    if( !declViewModel ) {\n        logger.warn( MSG_1 );\n        return false;\n    }\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        logger.warn( MSG_PREFIX_1 + declViewModel );\n        return false;\n    }\n\n    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {\n        logger.warn( MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was\n * started.\n * <P>\n * If so: Use the dataCtxNode the DeclViewModel was originally created on.\n * <P>\n * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the\n * event was processed.\n *\n * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check\n * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.\n *\n * @returns {Object} The dataCtxNode object to use.\n */\nexport let resolveLocalDataCtx = function( declViewModel, dataCtxNode ) {\n    if( dataCtxNode.$$destroyed ) {\n        return declViewModel._internal.origCtxNode;\n    }\n\n    return dataCtxNode;\n};\n\n/**\n * Return true if provided value is 'nil' (i.e. not null or undefined).\n *\n * @param {Object} value - The value to test.\n *\n * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).\n */\nexport let isNil = function( value ) {\n    return value === undefined || value === null;\n};\n\n/**\n * Return a empty function\n *\n * @returns {null} null\n */\nexport const noop = () => null;\n\n/**\n * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given\n * 'dataCtxNode'.\n *\n * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the\n *            lookup of the 'declViewModel'.\n *\n * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as\n *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.\n *\n * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is\n *            TRUE.\n *\n * @return {DeclViewModel} The 'declViewModel' found.\n */\nexport let findViewModel = function( dataCtxNode, setInScope ) {\n    /**\n     * Check for the case where the declViewModel is already set on the given node.\n     */\n    if( dataCtxNode.data ) {\n        /** revisitme\n        if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {\n            dataCtxNode.ctx = appCtxSvc.ctx;\n        }\n        */\n\n        return dataCtxNode.data;\n    }\n\n    /**\n     * Look for the model on a 'parent' node.\n     */\n    var currCtxNode = dataCtxNode;\n\n    while( currCtxNode && !currCtxNode.data ) {\n        currCtxNode = currCtxNode.$parent;\n    }\n\n    if( currCtxNode ) {\n        if( setInScope ) {\n            dataCtxNode.data = currCtxNode.data;\n\n            /** revisitme\n            if( appCtxSvc ) {\n                dataCtxNode.ctx = appCtxSvc.ctx;\n            }\n            */\n\n            //if subPanelContext is available on scope then add it dataCtxNode\n            if( currCtxNode.subPanelContext ) {\n                dataCtxNode.subPanelContext = currCtxNode.subPanelContext;\n            }\n\n            /**\n             * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.\n             */\n            if( dataCtxNode.$on ) {\n                dataCtxNode.$on( '$destroy', function( data ) {\n                    data.currentScope.data = null;\n                    data.currentScope.ctx = null;\n                } );\n            }\n        }\n\n        return currCtxNode.data;\n    }\n\n    return null;\n};\n\n/**\n * Consolidate the second object's properties into the first one\n *\n * @param {Object} targetObj - The 'target' object to merge to\n * @param {Object} sourceObj - The 'source' object to be merge from\n *\n * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.\n */\nexport let consolidateObjects = function( targetObj, sourceObj ) {\n    var returnObj = null;\n\n    if( targetObj ) {\n        returnObj = targetObj;\n\n        _.forEach( sourceObj, function( n, key ) {\n            returnObj[ key ] = n;\n        } );\n    } else if( sourceObj ) {\n        returnObj = sourceObj;\n    }\n\n    return returnObj;\n};\n\n/**\n * Create custom event. Mainly for IE\n *\n * @param {String} eventName - Name of the event\n *\n * @param {Object} eventDetail - Object for event detail\n\n * @param {Object} canBubble -is bubble is up/down\n\n * @param {Object} isCancellable - event can ne canclable or not\n *\n * @return {DOMElement} created DOMElement\n */\nexport let createCustomEvent = function( eventName, eventDetail, canBubble, isCancellable ) {\n    if( browserUtils.isNonEdgeIE ) {\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( eventName, canBubble, isCancellable, eventDetail );\n        return evt;\n    }\n    return new CustomEvent( eventName, {\n        detail: eventDetail,\n        bubbles: canBubble\n    } );\n};\n\n/**\n * process output data\n * @param {JSON} outputData output data definition\n * @param {object} result function result\n * @returns {object} data patch as:\n * {\n *     \"ctx.b\": 3,\n *     \"data.c\": 5\n * }\n */\nexport const processOutputData = ( outputData, result ) => {\n    if( outputData ) {\n        const value = {};\n        for( let vmPath in outputData ) {\n            let valPath = outputData[ vmPath ];\n            let res = undefined;\n            if( _.isBoolean( valPath ) ) {\n                res = valPath;\n            } else {\n                var expression = parsingUtils.getStringBetweenDoubleMustaches( valPath );\n                if( _.startsWith( expression, 'json:' ) ) {\n                    var jsonStringVariable = expression.replace( 'json:', '' );\n                    var jsonString = _.get( result, jsonStringVariable );\n                    res = parsingUtils.parseJsonString( jsonString );\n                } else {\n                    res = valPath && valPath.length > 0 ? _.get( result, valPath ) : result;\n                }\n            }\n            // TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'\n            value[ /^ctx\\./.test( vmPath ) ? vmPath : `data.${vmPath}` ] = res;\n        }\n        return value;\n    }\n    return undefined;\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}\n * @param {Object} evaluationEnv - the data environment for expression evaluation\n * evaluation\n *\n * @return {Boolean} the evaluated condition result\n */\nexport let evaluateCondition = function( declViewModel, expression, evaluationEnv ) {\n    let parse = AwParseService.instance;\n    return parse( expression )( evaluationEnv );\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} condition name of condition\n *\n * @return {String} the evaluated condition result\n */\nexport let getConditionExpression = function( declViewModel, condition ) {\n    var conditionExpression = null;\n\n    if( _.startsWith( condition, 'conditions.' ) ) {\n        var conditionObject = _.get( declViewModel._internal, condition );\n\n        conditionExpression = conditionObject.expression;\n    } else {\n        conditionExpression = condition;\n    }\n\n    return conditionExpression;\n};\n\n/**\n * Evaluate condition name\n *\n * @param {String} conditionString name of condition\n *\n * @return {String} the evaluated condition result\n */\nexport let getConditionName = function( conditionString ) {\n    if( _.startsWith( conditionString, 'conditions.' ) ) {\n        var index = conditionString.indexOf( '.' );\n        return conditionString.substr( index + 1 );\n    }\n    return null;\n};\n\n/**\n * Get dirty properties of the view model object\n *\n * @param {Object} vmo - the view model object\n *\n * @return {Array} the dirty properties of the view model object\n */\nexport let getAllModifiedValues = function( vmo ) {\n    var modifiedProperties = [];\n    if( vmo ) {\n        modifiedProperties = vmo.getDirtyProps();\n    }\n    return modifiedProperties;\n};\n\n/**\n * Update the properties of the view model property with new values\n *\n * @param {Object} dataObject - view model object.\n * @param {Object} dataProperty - view model object property.\n * @param {Object} dataPropertyValue - view model object property value.\n */\nexport let updatePropertyValues = function( dataObject, dataProperty, dataPropertyValue ) {\n    dataObject[ dataProperty ] = dataPropertyValue;\n    return {\n        data:{ ...dataObject }\n    };\n};\n\n/**\n * get type hierarchy from modleObject or view model Object\n *\n * @param {Object} dataObject - view model object.\n *\n *  @return {Array} - hierarchy of model object names\n\n */\nexport let getTypeHierarchy = function( dataObject ) {\n    return dataObject.typeHierarchy || dataObject.modelType && dataObject.modelType.typeHierarchyArray;\n};\n\n/**\n *  get functions used in action input/output data\n */\nlet getActionDataFunc = function( value, functionsUsedInActions ) {\n    if( typeof value === 'string' ) {\n        var results = value.match( parsingUtils.REGEX_DATABINDING );\n        if( results && results.length === 4 ) {\n            var newVal = results[ 2 ];\n            if( _.startsWith( newVal, 'function:' ) ) {\n                functionsUsedInActions.push( newVal.replace( 'function:', '' ) );\n            }\n        }\n    }\n    return functionsUsedInActions;\n};\n\n/**\n * Get Function dependancies\n *\n * @param {Object} action - The action object\n *\n * @param {Object} viewModel - The view model\n *\n * @return {Array} - The Array contains function dependancies to load.\n */\nexport let getFunctionDeps = function( action, viewModel ) {\n    var depsToLoad = [];\n    var functionsUsedInActions = [];\n    const functions = viewModel.functions;\n    // get functions used in action input data\n    if( action && action.inputData ) {\n        _.forEach( action.inputData.request, function( value ) {\n            getActionDataFunc( value, functionsUsedInActions );\n        } );\n    }\n    if( action && action.outputData ) {\n        _.forEach( action.outputData, function( value ) {\n            getActionDataFunc( value, functionsUsedInActions );\n        } );\n    }\n    if( action && action.dataParsers && action.dataParsers.length ) {\n        _.forEach( action.dataParsers, dataParser => {\n            const dataParserDef = viewModel.dataParseDefinitions[ dataParser.id ];\n            const fnUsedInDataParsers = getFunctionUsageRecursive( dataParserDef );\n            _.forEach( fnUsedInDataParsers, fnUsed => getActionDataFunc( fnUsed, functionsUsedInActions ) );\n        } );\n    }\n    if( functions ) {\n        _.forEach( functions, function( func ) {\n            if( func.deps && depsToLoad.includes( func.deps ) === false &&\n                functionsUsedInActions.includes( func.functionName ) ) {\n                depsToLoad.push( func.deps );\n            }\n        } );\n    }\n    return depsToLoad;\n};\n\nconst getFunctionUsageRecursive = ( object ) => {\n    let values = [];\n    _.each( object, ( value ) => {\n        if( _.isString( value ) && value.startsWith( '{{function:' ) ) {\n            values.push( value );\n        } else if( _.isObject( value ) ) {\n            values = values.concat( getFunctionUsageRecursive( value ) );\n        }\n    } );\n    return values;\n};\n\n/**\n * Build common proprty Place holder\n *\n *\n * @param {Object} prop - raw property\n *\n * @return {object}  - propAttrHolder will blank if not valid VMP else filled\n */\n\nexport let buildPropHolder = ( prop ) => {\n    let propAttrHolder = {};\n\n    _.forEach( prop, function( dataPropValue, dataPropName ) {\n        if( exports.attrHolderPropName.indexOf( dataPropName ) > -1 ) {\n            propAttrHolder[ dataPropName ] = dataPropValue;\n        }\n    } );\n\n    return propAttrHolder;\n};\n\nexport let getLatestContext = function( dataCtxNode, declViewModel ) {\n    let subPanelContext = null;\n    let ports = null;\n    let conditions = null;\n\n    if( dataCtxNode && dataCtxNode.getProps && _.isFunction( dataCtxNode.getProps ) ) {\n        let props = dataCtxNode.getProps();\n        dataCtxNode.props = props;\n        subPanelContext = props.subPanelContext;\n    }\n\n    if( dataCtxNode && dataCtxNode.getFields && _.isFunction( dataCtxNode.getFields ) ) {\n        dataCtxNode.fields = dataCtxNode.getFields();\n    }\n\n    if( declViewModel && declViewModel.getData && _.isFunction( declViewModel.getData ) ) {\n        let val = declViewModel.getData();\n        if( val.hasOwnProperty( 'data' ) ) {\n            declViewModel.data = val.data;\n        } else {\n            declViewModel.data = val;\n        }\n    }\n\n    if( dataCtxNode && !dataCtxNode.conditions && declViewModel ) {\n        conditions = declViewModel.conditions;\n        dataCtxNode.conditions = conditions;\n    }\n\n    if( !dataCtxNode ) {\n        dataCtxNode = {};\n    } else {\n        ports = dataCtxNode.ports;\n    }\n\n    return {\n        ...dataCtxNode,\n        data: declViewModel,\n        ctx: { ...dataCtxNode.ctx, ...appCtxSvc.ctx },\n        parameters: dataCtxNode.parameters,\n        subPanelContext: subPanelContext ? subPanelContext : declViewModel.subPanelContext,\n        commandContext: dataCtxNode.commandContext,\n        pasteContext: dataCtxNode.pasteContext,\n        ports: ports ? ports : declViewModel._internal.ports\n    };\n};\n\nexports = {\n    buildLifeCycleIssueMessage,\n    logLifeCycleIssue,\n    assertValidModel,\n    cloneData,\n    /** revisitme\n    updateFormData,\n    */\n    assertValidModelWithOriginalJSON,\n    assertValidModelAndDataCtxNode,\n    isValidModelAndDataCtxNode,\n    assertValidModelDataCtxNodeAndAction,\n    assertValidModelDataCtxNodeAndAction2,\n    assertValidModelAndEventData,\n    isValidModelAndEventData,\n    applyMessageParams,\n    resolveLocalDataCtx,\n    isNil,\n    findViewModel,\n    consolidateObjects,\n    createCustomEvent,\n    evaluateCondition,\n    getConditionExpression,\n    getConditionName,\n    getAllModifiedValues,\n    updatePropertyValues,\n    getFunctionDeps,\n    getTypeHierarchy,\n    processOutputData,\n    noop,\n    loadDependentModule,\n    attrHolderPropName,\n    buildPropHolder,\n    getLatestContext\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}