{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * The methods provided by this module enable access, control and maintenance of a cache of ModelObjects as well as\n * their member PropertyObjects.\n *\n * @module soa/kernel/clientDataModel\n */import cmm from'soa/kernel/clientMetaModel';import dateTimeSvc from'js/dateTimeService';import sanitizer from'js/sanitizer';import _ from'lodash';import eventBus from'js/eventBus';import'js/localeService';/**\n * Marker text within a value used to indicate when a property contains a UTC date/time that needs to be converted\n * to to local time zone and session specfici format.\n *\n * @private\n */var UTC_DATE_TIME_MARKER='{__UTC_DATE_TIME}';/**\n * UID to indicate the identity of an object is 'unknown'.\n */var _NULL_UID='AAAAAAAAAAAAAA';/**\n * A reference to service.\n */ /**\n * A reference to sanitizer.\n */ /**\n * Note: We are holding on to the resolved module now for when we are running NodeJS. However, this variable will be\n * set again when this service is created using AngularJS injection. The reason is that the 'dateTimeService' needs\n * some other AngularJS services injected to do all its work. It will use fallback values when running in NodeJS.\n *\n * @private\n */ /**\n * Object used to implement a UID-to-ModelObject cache map.\n *\n * @private\n */var _uid2modelObject={};/**\n * The array of none flushable object types.\n *\n * @private\n */var _noFlushableTypes=['Awb0ProductContextInfo','Awp0GatewayTileRel','Awp0Tile','Fnd0ClientScope','Fnd0Command','Fnd0CommandCollection','Fnd0ConditionHelper','Fnd0HomeFolder','Fnd0Icon','Fnd0UIConfigCollectionRel','Group','GroupMember','ImanVolume','POM_imc','Role','User','UserSession'];/**\n * UID of the current 'User' ModelObject.\n *\n * @private\n */var _userUID='';/**\n * UID of the current 'Session' ModelObject.\n *\n * @private\n */var _userSessionUID='';/**\n * UID of the current user's 'Group' ModelObject.\n *\n * @private\n */var _groupMemberUID='';/**\n * @param {Object} modelObjectSOA - model object returned from SOA\n */function ModelObject(modelObjectSOA){this.props=modelObjectSOA.props||{};this.type=modelObjectSOA.type;this.uid=modelObjectSOA.uid;// add meta model link\nthis.modelType=cmm.getType(modelObjectSOA.type);_updateProps(this.props,this.modelType);}/**\n * This method is set on (augments) all {ModelObject} instance returned by SOA so that it is available for general\n * application use.\n *\n * @return {String} Text value that represents a common way to identify the function's context object (i.e. The\n *         'object_string' property) or the JSON 'stringify' version of the content object if the specific common\n *         property if not defined.\n */ModelObject.prototype.toString=function(){if(this.props&&this.props.object_string){return this.props.object_string.uiValues[0];}return JSON.stringify(this,null,2);};/**\n * This method is set on (augments) all {PropertyObject} instances returned by SOA so that it is available for\n * general application use.\n *\n * @return {String[]} the name of all property's display value. If this property has multiple values, this method\n *         will return the first display value.\n */ModelObject.prototype.getPropertyNames=function(){return _.keys(this.props);};/**\n * Add reference count for model object.\n */ModelObject.prototype.addReference=function(){if(!this.reference){this.reference=0;}this.reference++;};/**\n * Remove reference count from model object.\n */ModelObject.prototype.removeReference=function(){this.reference--;if(this.reference<1){delete this.reference;}};/**\n * @param {Object} propSOA - property object returned from SOA\n * @param {PropertyDescriptor} propertyDescriptor - property descriptor\n */function Property(propSOA,propertyDescriptor){_conditionSoaPropValue(propSOA,propertyDescriptor,this);this.propertyDescriptor=propertyDescriptor;}/**\n * Apply some common data value transformations on the 'propToUpdate' based on the values in the 'propSOA'.\n *\n * @param {Object} propSOA - Property object returned from SOA\n * @param {PropertyDescriptor} propertyDescriptor - Property descriptor.\n * @param {Object} propToUpdate - Property object to be updated.\n */function _conditionSoaPropValue(propSOA,propertyDescriptor,propToUpdate){propToUpdate.dbValues=propSOA.dbValues||[];propToUpdate.isNulls=propSOA.isNulls;propToUpdate.modifiable=propSOA.modifiable;propToUpdate.uiValues=propSOA.uiValues||[];/**\n     * Assure certain properties are never 'null' or 'undefined'\n     */if(propSOA.isNulls){/**\n         * We want to make sure the 'dbValues' match the SOA supplied definition of 'null'.\n         */for(var ndx=propSOA.isNulls.length-1;ndx>=0;ndx--){if(propSOA.isNulls[ndx]&&propToUpdate.dbValues.length>ndx){propToUpdate.dbValues[ndx]=null;}}}/**\n     * Perform some type specific post processing of the property values.\n     */switch(propertyDescriptor.valueType){case 2:// Date\n/**\n             * Date processing...Reformat UI value based upon DB value.\n             * <P>\n             * Note: This also makes the UI value be for the local time zone instead of the server's time zone.\n             */ // Only set if server gave the client a non-empty UI values array\nif(propSOA.uiValues&&propSOA.uiValues.length>0&&propSOA.uiValues[0]){// Only attempt if we have a DB value...\nif(propSOA.dbValues.length>0){_.forEach(propSOA.dbValues,function(dbValue,dbNdx){var jqDate=new Date(dbValue);if(propertyDescriptor.constantsMap&&propertyDescriptor.constantsMap.timeEnabled==='1'){propToUpdate.uiValues[dbNdx]=dateTimeSvc.formatSessionDateTime(jqDate);}else{propToUpdate.uiValues[dbNdx]=dateTimeSvc.formatSessionDate(jqDate);}});}else{propToUpdate.uiValues[0]='';}}break;case 8:// String\nif(propertyDescriptor.name!=='fnd0SVG'){// Sanitize the String DB values\npropToUpdate.dbValues=sanitizer.sanitizeHtmlValues(propToUpdate.dbValues);// Sanitize the String UI values\npropToUpdate.uiValues=sanitizer.sanitizeHtmlValues(propToUpdate.uiValues);}if(propertyDescriptor.name==='awp0CellProperties'){propToUpdate.dbValues=_convertUTCTimeValues(propToUpdate.dbValues);propToUpdate.uiValues=_convertUTCTimeValues(propToUpdate.uiValues);}break;}}/**\n * This method is set on (augments) all {PropertyObject} instances returned by SOA so that it is available for\n * general application use.\n *\n * @return {String} Gets the property's display value. If this property has multiple values, this method will return\n *         the first display value.\n */Property.prototype.getDisplayValue=function(){if(this.uiValues&&this.uiValues.length>0){return this.uiValues[0];}return'';};/**\n * This method is set on (augments) all {PropertyObject} instances returned by SOA so that it is available for\n * general application use.\n *\n * @return {Boolean} TRUE if ALL the internal values (aka 'dbValues') of the function's context object are to be\n *         considered 'null' or 'unset'.\n *         <P>\n *         If the 'isNulls' array is present, all its values will be used to determine the result. If any are\n *         'false' this function will return 'false' (i.e. property is NOT null).\n *         <P>\n *         If 'isNulls' is not present, we assume the 'dbValues' are NOT null.\n *         <P>\n *         Note: The intrinsic data types (boolean, int, double) can have a value (i.e. 'false' or 'zero') but still\n *         be 'unset'. In this case, the SOA server will send back an optional array of booleans named 'isNulls',\n *         the 'true/false' values in this array indicate while elements in the 'dbValues' array should be\n *         considered 'unset'.\n */Property.prototype.evaluateIsNull=function(){/**\n     * Check if the server told us this context object (property) dbValue was to be considered 'null' or 'unset'.\n     */if(this.isNulls){for(var ndx=0;ndx<this.isNulls.length;ndx++){if(!this.isNulls[ndx]){return false;}}return true;}return false;};/**\n * Replace any occurrences of UTC date/time values with the {@link #UTC_DATE_TIME_MARKER} with the date/time in the\n * local time zone.\n *\n * @private\n *\n * @param {String[]} values - Array of values to consider.\n * @return {String[]} Array if values after replacement of any strings.\n */var _convertUTCTimeValues=function(values){for(var iNdx=0;iNdx<values.length;iNdx++){var value=values[iNdx];var markerNdx=value?value.indexOf(UTC_DATE_TIME_MARKER):-1;if(markerNdx!==-1){var prefix=value.substring(0,markerNdx);var utc=value.substring(markerNdx+UTC_DATE_TIME_MARKER.length);var date=new Date(utc);values[iNdx]=prefix+dateTimeSvc.formatSessionDateTime(date);}}return values;};/**\n * Update properties. This includes adding references to meta model & dealing with date conversions.\n *\n * @param {Object} props - model object properties\n * @param {ModelType} modelType - model type from meta model\n */var _updateProps=function(props,modelType){// Maybe change this to for loop later\n_.forEach(props,function(value,propName){props[propName]=new Property(value,modelType.propertyDescriptorsMap[propName]);});};/**\n * Define the base object used to provide all of this module's external API on.\n *\n * @private\n */var exports={};/**\n * Get the cache.\n *\n * @returns {Object} map of UID to model object\n */export let getCache=function(){return _uid2modelObject;};/**\n * Set the cache\n *\n * @param {Object} cache - map of UID to model object\n */export let setCache=function(cache){_.forOwn(cache,function(value,key){_uid2modelObject[key]=cache[key];});};/**\n * @param {String} uid - UID of ModelObject to test for.\n * @return {boolean} TRUE if client data model contains the given ModelObject\n */export let containsObject=function(uid){return _uid2modelObject.hasOwnProperty(uid);};/**\n * Get model object.\n *\n * @param {String} uid - UID of ModelObject\n * @return {ModelObject} The ModelObject; null if not cached\n */export let getObject=function(uid){if(exports.containsObject(uid)){return _uid2modelObject[uid];}return null;};/**\n * Get model objects.\n *\n * @param {String[]} uids - array of ModelObject UIDs\n * @return {ModelObject} The ModelObject; null if not cached\n */export let getObjects=function(uids){var objects=[];_.forEach(uids,function(uid){objects.push(exports.getObject(uid));});return objects;};/**\n * Remove the ModelObject from the cache that have the given UIDs. Publishes the UIDs to the 'soajs/cdm.deleted'\n * eventBus channel/topic.\n *\n * @param {String[]} deletedUIDs - Array of UIDs to be removed from the cache.\n */export let removeObjects=function(deletedUIDs){var uids=[];_.forEach(deletedUIDs,function(deletedUID){if(exports.containsObject(deletedUID)){delete _uid2modelObject[deletedUID];uids.push(deletedUID);}});if(uids.length>0){eventBus.publish('cdm.deleted',{deletedObjectUids:uids});}};/**\n * @param {ModelObject} userSession - user session\n */var setUserSession=function(userSession){_userSessionUID=userSession.uid;// For refresh scenario, signin isn't call & these 2 fields need to be set.\nif(userSession.props){if(userSession.props.user){_userUID=userSession.props.user.dbValues[0];}if(userSession.props.fnd0groupmember){_groupMemberUID=userSession.props.fnd0groupmember.dbValues[0];}}};/**\n * Add or replace the given ModelObjects to the cache. Publishes the modelObjects to the 'soajs/cdm.modified'\n * eventBus channel/topic.\n *\n * @param {ModelObject[]} modelObjects - Array of 'wire' ModelObject to be added to the cache.\n */export let cacheObjects=function(modelObjects){var newObjects=[];var modifiedObjects=[];_.forEach(modelObjects,function(modelObject){var existing=exports.containsObject(modelObject.uid)&&exports.getObject(modelObject.uid);if(!existing||existing.type!==modelObject.type){modelObject=new ModelObject(modelObject);// Add model object to cache\n_uid2modelObject[modelObject.uid]=modelObject;newObjects.push(modelObject);}else if(!_.isEmpty(modelObject.props)){/**\n             * Special Case: Check if existing is empty\n             */if(_.isEmpty(existing.props)){existing.props=modelObject.props;_updateProps(existing.props,existing.modelType);/**\n                 * Before we add this to the 'modified' list, check if it is already in the 'new' list. We do not\n                 * want to double report these.\n                 */if(newObjects.indexOf(existing)===-1&&modifiedObjects.indexOf(existing)===-1){modifiedObjects.push(existing);}}else{/**\n                 * Foreach of the incoming 'props'\n                 */var propertyDescriptorsMap=existing.modelType.propertyDescriptorsMap;var changedExisting=false;_.forEach(modelObject.props,function(soaPropValue,soaPropName){var propertyDescriptor=propertyDescriptorsMap[soaPropName];var existingProp=existing.props[soaPropName];if(!existingProp){existing.props[soaPropName]=new Property(soaPropValue,propertyDescriptor);changedExisting=true;}else{_conditionSoaPropValue(soaPropValue,propertyDescriptor,soaPropValue);_.forEach(soaPropValue,function(subPropValue,subPropName){var existingSubPropValue=existingProp[subPropName];if(!_.isEqual(subPropValue,existingSubPropValue)){existing.props[soaPropName]=new Property(soaPropValue,propertyDescriptor);changedExisting=true;return false;}});}});if(changedExisting){/**\n                     * Before we add this to the 'modified' list, check if it is already in the 'new' list. We do not\n                     * want to double report these.\n                     */if(newObjects.indexOf(existing)===-1&&modifiedObjects.indexOf(existing)===-1){modifiedObjects.push(existing);}}}}// Set the cache of the UserSession object\nif(modelObject.type==='UserSession'){setUserSession(modelObject);}});if(newObjects.length>0){eventBus.publish('cdm.new',{newObjects:newObjects});}if(modifiedObjects.length>0){eventBus.publish('cdm.modified',{modifiedObjects:modifiedObjects});}};/**\n * @return {ModelObject} The ModelObject of the current user 'Session'.\n */export let getUserSession=function(){return exports.getObject(_userSessionUID);};/**\n * @return {ModelObject} The ModelObject of the current user's 'Group'.\n */export let getGroupMember=function(){return exports.getObject(_groupMemberUID);};/**\n * @return {ModelObject} The ModelObject of the current 'User'.\n */export let getUser=function(){return exports.getObject(_userUID);};/**\n * HTML-escapes a string, but does not double-escape HTML-entities already present in the string.\n *\n * @param {String} value - HTML String which needs to be escaped.\n * @return {String} Returns escaped and safe HTML.\n */export let htmlEscapeAllowEntities=function(value){return sanitizer.htmlEscapeAllowEntities(value);};/**\n * Simple and inexpensive HTML Sanitizer which accepts the subset of TAG_WHITELIST array of HTML white list tags.\n *\n * @param {String[]} values - Array of HTML Strings which needs to be sanitized.\n * @return {String[]} Returns sanitized HTML string array.\n */export let sanitizeHtmlValues=function(values){return sanitizer.sanitizeHtmlValues(values);};/**\n * Simple and inexpensive HTML Sanitizer which detects and/or eliniates HTML that can cause potential cross-site\n * scripting and other UI issues.\n *\n * @param {String} rawValue - HTML String which needs to be sanitized.\n * @return {String} Returns sanitized HTML or Invalid HTML string when there is malicious string.\n */export let sanitizeHtmlValue=function(rawValue){return sanitizer.sanitizeHtmlValue(rawValue);};/**\n * Return an array of all IModelObjects currently in the cache that match the given model type.\n *\n * @param {String} typeName - Name of the model type to search for.\n * @return {ModelObject[]} An array of all IModelObjects currently in the cache that match the given model type.\n */export let getObjectsOfType=function(typeName){var objs=[];_.forEach(_uid2modelObject,function(modelObject){if(modelObject.type&&modelObject.type===typeName){objs.push(modelObject);}});return objs;};/**\n * @param {String} uid - UID to test\n * @return {Boolean} TRUE if the given UID is NOT null and does NOT match the patterns used to indicate 'no object'.\n */export let isValidObjectUid=function(uid){return!_.isEmpty(uid)&&!_.isEqual(uid,_NULL_UID);};/**\n * Determine if the given object is a ModelObject constructed by this service.\n *\n * @param {Object} objectToTest - The object to test.\n *\n * @returns {Boolean} TRUE if input object is an instance of an CDM ModelObject.\n */export let isModelObject=function(objectToTest){return objectToTest instanceof ModelObject;};/**\n * {String} Module constant UID used to indicate the identity of an object is 'unknown'.\n */export let NULL_UID=_NULL_UID;/**\n * ------------------------------------------------<BR>\n * Definition complete...Now do some initialization<BR>\n * ------------------------------------------------<BR>\n */eventBus.subscribe('cdm.cleanCache',function(){// collect the flushable objects, keep the escaped objects in cache\n_.forEach(_uid2modelObject,function(modelObject,uid){if(!modelObject.type){return;}if(cmm.isTypeUid(uid)){// Remove meta data from the cache\ndelete _uid2modelObject[uid];}else if(_noFlushableTypes.indexOf(modelObject.type)===-1&&!modelObject.reference){modelObject.props={};}});},'soa_kernel_clientDataModel');exports={getCache,setCache,containsObject,getObject,getObjects,removeObjects,cacheObjects,getUserSession,getGroupMember,getUser,htmlEscapeAllowEntities,sanitizeHtmlValues,sanitizeHtmlValue,getObjectsOfType,isValidObjectUid,isModelObject,NULL_UID};export default exports;","map":null,"metadata":{},"sourceType":"module"}