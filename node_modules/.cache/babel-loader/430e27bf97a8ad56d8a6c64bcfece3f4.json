{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */\n\n/**\n * Tab Overflow Service to manage tabs.\n */\nlet exports = {};\n/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */\n\nexport let hasOverflowForTabs = (tabContainerElem, tabContainerAlignment, tabElem) => {\n  let propName = tabContainerAlignment === 'HORIZONTAL' ? 'offsetTop' : 'offsetLeft';\n  var tabElement = tabElem;\n\n  if (!tabElement) {\n    let currentTabElems = tabContainerElem ? tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab') : undefined;\n    tabElement = currentTabElems ? currentTabElems[currentTabElems.length - 1] : undefined;\n  } //We just check the element's offsetTop against the container's offset top to determine if there's an overflow\n\n\n  if (!tabContainerElem || !tabElement) {\n    return false;\n  }\n\n  return tabElement[propName] > tabContainerElem[propName];\n};\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\n\nexport let overflowBreakPointCalculatorForTabs = function () {\n  var tabElems;\n  var breakIndex = 0;\n  return function (tabContainerElem, tabContainerAlignment) {\n    if (!tabContainerElem) {\n      return breakIndex;\n    }\n\n    tabElems = tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');\n    breakIndex = tabElems.length;\n\n    for (var i = tabElems.length - 1; i >= 0; i--) {\n      // find the first tab which doesn't have overflow in reverse order\n      if (!hasOverflowForTabs(tabContainerElem, tabContainerAlignment, tabElems[i])) {\n        breakIndex = i + 1;\n        break;\n      }\n    }\n\n    return breakIndex;\n  };\n};\nexport let updateTabIndexOnOverflow = function (tabContainerElement, tabContainerAlignment) {\n  let tabElements = tabContainerElement.querySelectorAll('.sw-tabContainer >.sw-tab');\n\n  for (var i = tabElements.length - 1; i >= 0; i--) {\n    var tabElementAnchor = tabElements[i].querySelector('a:not(.disabled)');\n\n    if (tabElementAnchor) {\n      if (hasOverflowForTabs(tabContainerElement, tabContainerAlignment, tabElements[i])) {\n        tabElementAnchor.setAttribute('tabindex', -1);\n      } else {\n        tabElementAnchor.setAttribute('tabindex', 0);\n      }\n    }\n  }\n};\n/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */\n\nconst isTabsOverflown = function (tabContainerElem, tabElems, tabPadding) {\n  let totalWidth = 0;\n\n  for (var i = 0; i < tabElems.length; i++) {\n    totalWidth += tabElems[i].getClientRects()[0].width + tabPadding;\n  }\n\n  return Math.round(totalWidth) > tabContainerElem.clientWidth;\n};\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\n\n\nexport let calculateBreakIndex = function () {\n  var tabElems;\n  var breakIndex = 0;\n  return function (tabsModelForContainer, tabContainerElem, selectedTabModel) {\n    if (!tabContainerElem) {\n      return breakIndex;\n    }\n\n    tabElems = tabContainerElem.querySelectorAll('.sw-tabContainer>.sw-tab');\n    let arr = [...tabElems];\n    var tabPadding = 16;\n\n    if (selectedTabModel && isTabsOverflown(tabContainerElem, arr, tabPadding)) {\n      let selectedTabObject = arr.find(element => {\n        const anchor = element.getElementsByTagName('a')[0];\n\n        if (anchor) {\n          return anchor.getAttribute('name') === String(selectedTabModel.pageId);\n        }\n\n        return false;\n      });\n      let initialTabPadding = 16;\n      let totalWidth = 0;\n\n      if (selectedTabObject) {\n        totalWidth = selectedTabObject.getClientRects()[0].width + tabPadding + initialTabPadding;\n      }\n\n      for (var i = 0; i < tabsModelForContainer.length; i++) {\n        let currentTabObject = arr.find(element => {\n          const anchor = element.getElementsByTagName('a')[0];\n\n          if (anchor) {\n            return anchor.getAttribute('name') === String(tabsModelForContainer[i].pageId);\n          }\n\n          return false;\n        });\n\n        if (currentTabObject) {\n          totalWidth += currentTabObject.getClientRects()[0].width + tabPadding;\n        }\n\n        if (totalWidth > tabContainerElem.clientWidth) {\n          breakIndex = i;\n          break;\n        }\n      }\n\n      return breakIndex;\n    }\n  };\n};\nexports = {\n  overflowBreakPointCalculatorForTabs,\n  hasOverflowForTabs,\n  updateTabIndexOnOverflow,\n  calculateBreakIndex\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/tabOverflowService.js"],"names":["exports","hasOverflowForTabs","propName","tabContainerAlignment","tabElement","currentTabElems","tabContainerElem","overflowBreakPointCalculatorForTabs","breakIndex","tabElems","i","updateTabIndexOnOverflow","tabElements","tabContainerElement","tabElementAnchor","isTabsOverflown","totalWidth","Math","calculateBreakIndex","arr","tabPadding","selectedTabModel","selectedTabObject","element","anchor","String","initialTabPadding","tabsModelForContainer","currentTabObject"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Defines {@link tabOverflowService} which manages tabs.\n *\n * @module js/tabOverflowService\n */\n\n/**\n * Tab Overflow Service to manage tabs.\n */\nlet exports = {};\n\n/**\n * Checks if overflow occurred on the specified tab on the tab container.\n *\n * The closure function arguments:\n * @param {Element} tabContainerElem the command bar element\n * @param {String} tabContainerAlignment the command bar alignment\n * @param {Element} tabElem the command element to check overflow.\n *                  Optional, if not specified, will check the last command element in command container.\n * @returns {Boolean} A boolean telling whether overflow occurred or not.\n */\nexport let hasOverflowForTabs = ( tabContainerElem, tabContainerAlignment, tabElem ) => {\n    let propName = tabContainerAlignment === 'HORIZONTAL' ? 'offsetTop' : 'offsetLeft';\n    var tabElement = tabElem;\n    if( !tabElement ) {\n        let currentTabElems = tabContainerElem ? tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' ) : undefined;\n        tabElement = currentTabElems ? currentTabElems[ currentTabElems.length - 1 ] : undefined;\n    }\n\n    //We just check the element's offsetTop against the container's offset top to determine if there's an overflow\n    if( !tabContainerElem || !tabElement ) {\n        return false;\n    }\n\n    return tabElement[ propName ] > tabContainerElem[ propName ];\n};\n\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\nexport let overflowBreakPointCalculatorForTabs = function() {\n    var tabElems;\n    var breakIndex = 0;\n\n    return function( tabContainerElem, tabContainerAlignment ) {\n        if( !tabContainerElem ) {\n            return breakIndex;\n        }\n\n        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n\n        breakIndex = tabElems.length;\n        for( var i = tabElems.length - 1; i >= 0; i-- ) {\n            // find the first tab which doesn't have overflow in reverse order\n            if( !hasOverflowForTabs( tabContainerElem, tabContainerAlignment, tabElems[ i ] ) ) {\n                breakIndex = i + 1;\n                break;\n            }\n        }\n\n        return breakIndex;\n    };\n};\n\nexport let updateTabIndexOnOverflow = function( tabContainerElement, tabContainerAlignment ) {\n    let tabElements = tabContainerElement.querySelectorAll( '.sw-tabContainer >.sw-tab' );\n    for( var i = tabElements.length - 1; i >= 0; i-- ) {\n        var tabElementAnchor = tabElements[ i ].querySelector( 'a:not(.disabled)' );\n        if( tabElementAnchor ) {\n            if( hasOverflowForTabs( tabContainerElement, tabContainerAlignment, tabElements[ i ] ) ) {\n                tabElementAnchor.setAttribute( 'tabindex', -1 );\n            } else {\n                tabElementAnchor.setAttribute( 'tabindex', 0 );\n            }\n        }\n    }\n};\n\n/**\n * Evaluate if the total tabs width along with padding is greater than available container client width\n *\n * The closure function arguments:\n * @param {Object} tabContainerElem the reference of the tab container element.\n * @param {Array} tabElems the tab elements.\n * @param {Number} tabPadding the tab padding.\n * @returns {Boolean} true / false depending on width comparison.\n */\nconst isTabsOverflown = function( tabContainerElem, tabElems, tabPadding ) {\n    let totalWidth = 0;\n    for( var i = 0; i < tabElems.length; i++ ) {\n        totalWidth += tabElems[ i ].getClientRects()[ 0 ].width + tabPadding;\n    }\n    return Math.round( totalWidth ) > tabContainerElem.clientWidth;\n};\n\n/**\n * Calculate the tab overflow break point in tabs et. The closure function\n *\n * The closure function arguments:\n * @param {Number} tabContainerElem the reference of the tab container element\n * @param {String} tabContainerAlignment the alignment of tab container\n * @returns {Function} the function to calculate command overflow break point.\n */\nexport let calculateBreakIndex = function() {\n    var tabElems;\n    var breakIndex = 0;\n\n    return function( tabsModelForContainer, tabContainerElem, selectedTabModel ) {\n        if( !tabContainerElem ) {\n            return breakIndex;\n        }\n\n        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n        let arr = [ ...tabElems ];\n        var tabPadding = 16;\n\n        if( selectedTabModel && isTabsOverflown( tabContainerElem, arr, tabPadding ) ) {\n            let selectedTabObject = arr.find( ( element ) => {\n                const anchor = element.getElementsByTagName( 'a' )[ 0 ];\n                if( anchor ) {\n                    return anchor.getAttribute( 'name' ) === String( selectedTabModel.pageId );\n                }\n                return false;\n            } );\n\n            let initialTabPadding = 16;\n            let totalWidth = 0;\n            if( selectedTabObject ) {\n                totalWidth = selectedTabObject.getClientRects()[ 0 ].width + tabPadding + initialTabPadding;\n            }\n\n            for( var i = 0; i < tabsModelForContainer.length; i++ ) {\n                let currentTabObject = arr.find( ( element ) => {\n                    const anchor = element.getElementsByTagName( 'a' )[ 0 ];\n                    if( anchor ) {\n                        return anchor.getAttribute( 'name' ) === String( tabsModelForContainer[ i ].pageId );\n                    }\n                    return false;\n                } );\n                if( currentTabObject ) {\n                    totalWidth += currentTabObject.getClientRects()[ 0 ].width + tabPadding;\n                }\n\n                if( totalWidth > tabContainerElem.clientWidth ) {\n                    breakIndex = i;\n                    break;\n                }\n            }\n\n            return breakIndex;\n        }\n    };\n};\n\nexports = {\n    overflowBreakPointCalculatorForTabs,\n    hasOverflowForTabs,\n    updateTabIndexOnOverflow,\n    calculateBreakIndex\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}