{"ast":null,"code":"import _ from'lodash';import{registerTabSet,unregisterTabSet}from'js/tabRegistry.service';import tabOverflowSvc from'js/tabOverflowService';import resizeObserverSvc from'js/resizeObserver.service';import declUtils from'js/declUtils';import AwTab from'viewmodel/AwTabViewModel';import AwButton from'viewmodel/AwButtonViewModel';import AwTabSetOverflow from'viewmodel/AwTabSetOverflowViewModel';import AwPopup from'viewmodel/AwPopupViewModel';import AwStateService from'js/awStateService';import*as cas from'js/centralAggregationService';import localeService from'js/localeService';import analyticsSvc from'js/analyticsService';import wcagSvc from'js/wcagService';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";let tabObserver=null;let currentSelectedTabName;let moreText='';let lessText='';const initializeObserver=(data,dispatch,tabsetRef)=>{if(resizeObserverSvc.supportsResizeObserver()){const callback=_.debounce(()=>{data.overflowConfig.hideMore=!tabOverflowSvc.hasOverflowForTabs(tabsetRef,'HORIZONTAL');tabOverflowSvc.updateTabIndexOnOverflow(tabsetRef,'HORIZONTAL');dispatch({path:'data',value:{...data}});},200,{maxWait:10000,trailing:true,leading:false});if(tabsetRef!==null&&tabsetRef!==undefined){tabObserver=resizeObserverSvc.observe(tabsetRef,callback);}}};/**\n * Listen to subPanelContext and log user gesture\n *  @param { subPanelContext } selection data from component props\n *  @param { data } viewModel data\n */export const onSelectionDataChange=(subPanelContext,data)=>{logUserGesture(subPanelContext,data);};/**\n * Collect subject data like parent selection\n * @param {object} subPanelContext from component's props\n * @returns {object}\n */const getSubject=subPanelContext=>{let subject={};if(!_.isEmpty(subPanelContext)){let pselected=subPanelContext.pselected?subPanelContext.pselected:'';let selected=subPanelContext.selected?subPanelContext.selected:'';subject={pselected:pselected,selected:selected};}return subject;};/**\n * Collect user gesture and transmit it to Central Aggregation Service\n *  @param { subPanelContext } subPanelContext from component props\n *  @param { data} viewModel data\n */const logUserGesture=(subPanelContext,data)=>{let currentSelectedTabId='';currentSelectedTabId=data.currentSelectedTabId?data.currentSelectedTabId:data.tabsModel.findIndex(tab=>tab.selectedTab);let widgetInfo={currentSelectedTabId:currentSelectedTabId,tabSetId:data.tabSetId,tabsModel:data.tabsModel};cas.notify({widgetInfo:widgetInfo,userGesture:'onTabLoad',subject:getSubject(subPanelContext)});};/**\n * Method to publish analytics to server\n * @param {Number} tabModelId - id of the clicked tab\n * @param {String} tabModelName - name of the clicked tab\n */const publishAnalytics=(tabModelId,tabModelName)=>{let sanEventData={sanAnalyticsType:'Tab',sanCommandId:tabModelId,sanCommandTitle:tabModelName};analyticsSvc.logCommands(sanEventData);};export const onMount=(elementRefList,prop,data)=>{let tabsetRef=elementRefList.get('tabset').current;localeService.getLocalizedTextFromKey('BaseMessages.MORE_LINK_TEXT',true).then(value=>moreText=value);localeService.getLocalizedTextFromKey('BaseMessages.LESS_LINK_TEXT',true).then(value=>lessText=value);initializeObserver(data,data.dispatch,tabsetRef);};//onUnmount\nexport const unRegisterTabSet=tabSetId=>{unregisterTabSet(tabSetId);if(tabObserver){tabObserver();}};const initiateTabSetOverFlow=(overflownTabs,data,dispatch)=>{data.overflowConfig.overflownTabs=overflownTabs?overflownTabs:[];data.overflowConfig.isClicked=true;data.overflowConfig.currentTabIndex=null;data.overflowConfig.replacedTabIndex=null;dispatch({path:'data',value:{...data}});};const updateTabsIndices=(newSelectedTab,data,breakIndex)=>{let newSelNdx=newSelectedTab.tabIndex;let temp;temp=data.tabsModel[breakIndex];data.tabsModel[breakIndex]=newSelectedTab;data.tabsModel[newSelNdx]=temp;return breakIndex;};const isNewSelnFromOverFlowPopup=(index,data)=>{if(index>=data.tabsModel.length-data.overflowConfig.overflownTabs.length){return true;}return false;};const setTabSelection=(data,tabSetOverflowPopup,callback,props)=>{let tabToBeSelected=data.tabsModel.find(tab=>tab.selectedTab);if(!tabToBeSelected&&data.currentSelectedTabId){tabToBeSelected=data.tabsModel.find(tab=>tab.pageId===data.currentSelectedTabId);}if(!tabToBeSelected||!tabToBeSelected.displayTab){data.tabsModel.some(tab=>{if(tab.displayTab){tabToBeSelected=tab;return true;}return false;});}if(tabToBeSelected&&(!tabToBeSelected.selectedTab||!data.manualTabSelection&&tabToBeSelected.selectedTab&&tabToBeSelected.autoSelectTabOnLoad)){data.tabsModel.map((tabModel,index)=>{tabModel.selectedTab=false;tabModel.tabIndex=index;});if(isNewSelnFromOverFlowPopup(tabToBeSelected.tabIndex,data)){updateTabsIndices(tabToBeSelected,data);if(tabSetOverflowPopup.open){tabSetOverflowPopup.hide();}}tabToBeSelected.selectedTab=true;if(callback&&tabToBeSelected.pageId!==data.currentSelectedTabId){data.currentSelectedTabId=tabToBeSelected.pageId;callback(tabToBeSelected.pageId,tabToBeSelected.name,data.tabsModel);}}// Predictive UI: Notify subscribers when user gestures changes on tab selection/load\nif(tabToBeSelected&&tabToBeSelected.name!==currentSelectedTabName&&data.tabsModel.length>0){currentSelectedTabName=tabToBeSelected.name;logUserGesture(props.subPanelContext,data);}};export const awTabContainerRenderFn=props=>{const{actions,viewModel,elementRefList,tabsModel,callback,tabSetId,tabContainerModel}=props;let overflownTabs=[];let{tabSetOverflowPopup}=actions;const{data,dispatch}=viewModel;let tabsetRef=elementRefList.get('tabset').current;const tabsModelForContainer=tabsModel||tabContainerModel;/**\n     * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.\n     *\n     * @method calculateOverflow\n     */const calculateTabSwitching=function(initialTabsModel,currentSelectedTab){var calculateBreakIndex=tabOverflowSvc.calculateBreakIndex();var visibleTabs=data.tabsModel;if(visibleTabs.length<=1){return;}return calculateBreakIndex(initialTabsModel,tabsetRef,currentSelectedTab);};//swicth tabs here based on local state after overflow item click\nlet selectedTabModel=tabsModelForContainer.find(tab=>tab.selectedTab);let selectedTabIndex=tabsModelForContainer.findIndex(tab=>tab.selectedTab);//If we have a selected tab on first render, we need to check if it's in the overflow to make it visible\nlet isInitialOverflowCalculation=data.overflowConfig&&!data.overflowConfig.currentTabIndex&&selectedTabIndex&&!data.manualTabSelection;if(isInitialOverflowCalculation||data.overflowConfig&&data.overflowConfig.currentTabIndex&&selectedTabIndex!==data.overflowConfig.replacedTabIndex||!data.manualTabSelection&&selectedTabIndex&&selectedTabModel&&selectedTabIndex>0&&selectedTabModel.autoSelectTabOnLoad){var breakTabIndex=calculateTabSwitching(tabsModelForContainer,selectedTabModel);if(breakTabIndex){let temp=tabsModelForContainer[breakTabIndex];tabsModelForContainer[breakTabIndex]=tabsModelForContainer[selectedTabIndex];tabsModelForContainer[selectedTabIndex]=temp;}}data.tabsModel=tabsModelForContainer.map(tab=>{if(declUtils.isNil(tab.displayTab)){tab.displayTab=true;}return tab;});/**\n     *  Highlight tab in the targeted tab set\n     *  @param {String} tabName the name of tab to be highlighted\n     */const onHighlightTab=function(targetTab){let elementToHighlight;if(targetTab&&targetTab.displayTab){let tabContainerDomEl=tabsetRef.querySelectorAll('.sw-tabContainer>.sw-tab');let tabElements=[...tabContainerDomEl];let targetTabElement=tabElements.find(element=>element.innerText===targetTab.name);elementToHighlight=targetTabElement.querySelector('a');if(elementToHighlight){wcagSvc.afxFocusElement(elementToHighlight);}}else if(!data.overflowConfig.hideMore){elementToHighlight=tabsetRef.parentNode.querySelector('.sw-tab-overflowButton.sw-jswidget-controlArrow');if(elementToHighlight){wcagSvc.afxFocusElement(elementToHighlight);}}};const onTabSelected=selectedTabModel=>{//before change the tab update the params so we can navigate back to previous tab with old params\nconst previousTabIndex=data.tabsModel.findIndex(tab=>tab.selectedTab);data.tabsModel[previousTabIndex].params=AwStateService.instance.params;data.previousSelectedTabId=data.tabsModel.find(tab=>tab.selectedTab).pageId;data.tabsModel.map(tabModel=>tabModel.selectedTab=false);data.currentSelectedTabId=selectedTabModel.pageId;selectedTabModel.selectedTab=true;data.manualTabSelection=true;data.overflowConfig.currentTabIndex=null;data.overflowConfig.replacedTabIndex=null;var breakIndexFromCalc=calculateTabSwitching(data.tabsModel,selectedTabModel);if(tabSetOverflowPopup.open&&isNewSelnFromOverFlowPopup(selectedTabModel.tabIndex,data)){let breakIndex=updateTabsIndices(selectedTabModel,data,breakIndexFromCalc);tabSetOverflowPopup.hide();data.overflowConfig.currentTabIndex=selectedTabModel.tabIndex;data.overflowConfig.replacedTabIndex=breakIndex;}// Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.\nif(callback&&data.previousSelectedTabId!==data.currentSelectedTabId){callback(selectedTabModel.pageId,selectedTabModel.name,data.tabsModel);}publishAnalytics(selectedTabModel.pageId,selectedTabModel.name);//Update the overflow config object in the current view model too.\n//This is done to cater to the standalone aw-tab-container scenario\ndispatch({path:'data.overflowConfig',value:{...data.overflowConfig}});};/**\n     * Recalculate how many tabs can fit in the tab container before overflow occurs.\n     *\n     * @method calculateOverflow\n     */const calculateOverflow=function(){var overflowBreakPointCalculatorForTabs=tabOverflowSvc.overflowBreakPointCalculatorForTabs();var visibleTabs=data.tabsModel;if(visibleTabs.length<=1){return;}var breakIndex=overflowBreakPointCalculatorForTabs(tabsetRef,'HORIZONTAL');// has tab overflow\nif(breakIndex!==visibleTabs.length){overflownTabs=visibleTabs.slice(breakIndex);initiateTabSetOverFlow(overflownTabs,data,dispatch);tabSetOverflowPopup.show();}};const getButtonClassNames=()=>{return tabSetOverflowPopup.open?'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight':'sw-tab-overflowButton sw-jswidget-controlArrow';};const showMoreButton=()=>{if(!data.overflowConfig.hideMore){return/*#__PURE__*/_jsxs(\"div\",{className:\"sw-tab-overflowContainer\",children:[/*#__PURE__*/_jsx(AwButton,{domRef:tabSetOverflowPopup.reference,className:getButtonClassNames(),tooltip:tabSetOverflowPopup.open?lessText:moreText,\"aria-label\":tabSetOverflowPopup.open?lessText:moreText,iconId:\"miscSmallChevronRight\",action:calculateOverflow}),tabSetOverflowPopup.open&&/*#__PURE__*/_jsx(AwPopup,{...tabSetOverflowPopup.options,children:/*#__PURE__*/_jsx(AwTabSetOverflow,{overflownTabs:data.overflowConfig.overflownTabs,isClicked:data.overflowConfig.isClicked,event:event,onTabSelected:onTabSelected})})]});}};setTabSelection(data,tabSetOverflowPopup,callback,props);if(tabSetId){data.tabSetId=tabSetId;unregisterTabSet(tabSetId);registerTabSet(tabSetId,{changeTab:onTabSelected,tabs:data.tabsModel,highlightTab:onHighlightTab});}return/*#__PURE__*/_jsxs(\"div\",{className:\"sw-row align-items-center flex-shrink\",children:[/*#__PURE__*/_jsx(\"ul\",{role:\"tablist\",className:\"sw-tabContainer\",ref:elementRefList.get('tabset'),children:data.tabsModel&&data.tabsModel.map((tabModel,index)=>{if(tabModel.displayTab){tabModel.tabIndex=index;return/*#__PURE__*/_jsx(AwTab,{tabModel:tabModel,onTabSelected:onTabSelected,onTabClose:props.onTabClose},index);}})}),showMoreButton()]});};","map":null,"metadata":{},"sourceType":"module"}