{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/clientMetaModel\n */\nimport iconMapSvc from 'js/iconMapService';\nimport _ from 'lodash';\n/**\n * Object used to implement a typeName-to-PropertyType cache map.\n */\n\nvar _name2modelType = {};\n/**\n * Reference to the 'iconService' set into this module and used to reuse type file information.\n * <P>\n * Note: We are trying to avoid a cyclic reference since 'iconService' required CMM to do its work.\n */\n\n/**\n * @type {Object} map of property descriptors for reuse; property name to PropertyDescriptor or PropertyDescriptor[]\n */\n\nvar _propertyDescriptors = {};\nlet exports;\n/**\n * Get the resolved filename of the SVG icon.\n *\n * @param {Object} modelType - The Teamcenter ModelObject's 'modelType' object which\n * @return {String} type icon file name\n */\n\nexport let getTypeIconFileName = function (modelType) {\n  for (var ii = 0; ii < modelType.typeHierarchyArray.length; ii++) {\n    var typeName = modelType.typeHierarchyArray[ii];\n    var typeFileName = iconMapSvc.getTypeFileName(typeName);\n\n    if (typeFileName) {\n      return typeFileName;\n    }\n  }\n\n  return iconMapSvc.getTypeFileName('MissingImage');\n};\n/**\n * @param {Object} modelTypeSOA - model type object returned from SOA\n */\n\nvar ModelType = function (modelTypeSOA) {\n  this.abstract = modelTypeSOA.abstract;\n  this.children = modelTypeSOA.children;\n  this.displayName = modelTypeSOA.displayName;\n  this.name = modelTypeSOA.name;\n  this.owningType = modelTypeSOA.owningType;\n  this.parentTypeName = modelTypeSOA.parentTypeName;\n  this.primary = modelTypeSOA.primary ? true : undefined;\n  this.references = modelTypeSOA.references;\n  this.typeHierarchyArray = modelTypeSOA.typeHierarchy ? modelTypeSOA.typeHierarchy.split(',') : null;\n  this.typeUid = modelTypeSOA.typeUid;\n  this.uid = modelTypeSOA.uid;\n  this.constantsMap = {};\n  this.propertyDescriptorsMap = {}; // To support property processing in CDM during model object caching, create a map of the property descriptors.\n\n  if (modelTypeSOA.propertyDescriptors) {\n    for (var jj = modelTypeSOA.propertyDescriptors.length - 1; jj >= 0; jj--) {\n      var propertyDescriptorSOA = modelTypeSOA.propertyDescriptors[jj];\n      var propName = propertyDescriptorSOA.name;\n      var pd = new PropertyDescriptor(propertyDescriptorSOA);\n      var cachedPD = _propertyDescriptors[propName];\n\n      if (cachedPD) {\n        if (_.isArray(cachedPD)) {\n          // is array\n          var foundPD = false;\n\n          _.forEach(cachedPD, function (pd2) {\n            if (_.isEqual(pd, pd2)) {\n              pd = pd2;\n              foundPD = true;\n              return false; // break\n            }\n          });\n\n          if (!foundPD) {\n            // not in array already, add new one\n            cachedPD.push(pd);\n          }\n        } else if (_.isEqual(pd, cachedPD)) {\n          // not array & equal to cached pd\n          pd = cachedPD;\n        } else {\n          // not equal to cached PD, so we create array to track both\n          _propertyDescriptors[propName] = [cachedPD, pd];\n        }\n      } else {\n        // first encounter of this property descriptor, so cache it\n        _propertyDescriptors[propName] = pd;\n      }\n\n      this.propertyDescriptorsMap[propName] = pd;\n    }\n  }\n\n  if (modelTypeSOA.constants) {\n    for (jj = modelTypeSOA.constants.length - 1; jj >= 0; jj--) {\n      var constant = modelTypeSOA.constants[jj];\n      this.constantsMap[constant.name] = constant.value;\n    }\n  }\n\n  if (!this.constantsMap.IconFileName && this.typeHierarchyArray) {\n    this.constantsMap.IconFileName = exports.getTypeIconFileName(this);\n  }\n};\n/**\n * @param {Object} propertyDescriptorSOA - property descriptor object returned from SOA\n */\n\n\n_c3 = ModelType;\n_c = ModelType;\n\nvar PropertyDescriptor = function (propertyDescriptorSOA) {\n  this.anArray = propertyDescriptorSOA.anArray ? true : undefined;\n  this.basedOn = propertyDescriptorSOA.basedOn;\n  this.compoundObjType = propertyDescriptorSOA.compoundObjType;\n  this.displayName = propertyDescriptorSOA.displayName;\n  this.fieldType = propertyDescriptorSOA.fieldType;\n  this.lovCategory = propertyDescriptorSOA.lovCategory;\n  this.maxArraySize = propertyDescriptorSOA.maxArraySize;\n  this.maxLength = propertyDescriptorSOA.maxLength;\n  this.minValue = propertyDescriptorSOA.minValue;\n  this.name = propertyDescriptorSOA.name;\n  this.propertyType = propertyDescriptorSOA.propertyType;\n  this.propertyType2 = propertyDescriptorSOA.propertyType2;\n  this.valueType = propertyDescriptorSOA.valueType;\n  this.constantsMap = {};\n\n  if (propertyDescriptorSOA.constants) {\n    for (var kk = propertyDescriptorSOA.constants.length - 1; kk >= 0; kk--) {\n      var constant = propertyDescriptorSOA.constants[kk];\n      this.constantsMap[constant.name] = constant.value;\n    }\n  }\n};\n/**\n * Does client meta model contain type?\n *\n * @param {String} name - property type name.\n * @return {Boolean} true if model type is contained within the CMM\n */\n\n\n_c4 = PropertyDescriptor;\n_c2 = PropertyDescriptor;\nexport let containsType = function (name) {\n  return _name2modelType.hasOwnProperty(name);\n};\n/**\n * Get model type by type name.\n *\n * @param {String} name - type name (or UID)\n * @return {ModelType|null} model type if contained within CMM\n */\n\nexport let getType = function (name) {\n  if (exports.containsType(name)) {\n    return _name2modelType[name];\n  }\n\n  if (exports.isTypeUid(name)) {\n    return exports.getType(exports.extractTypeNameFromUID(name));\n  }\n\n  return null;\n};\n/**\n * @param {ModelObject} modelObject - ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject represents a 'type' object.\n */\n\nexport let isTypeObject = function (modelObject) {\n  /**\n   * Note: We do not want to cache 'types' in the model object cache.\n   */\n  return exports.isTypeUid(modelObject.uid);\n};\n/**\n * Returns True if this type is child of the give type.\n *\n * @param {String} typeName - name of class\n * @param {ModelType} modelType - view model object's model type.\n * @return {Boolean} true if this type is child of the give type.\n */\n\nexport let isInstanceOf = function (typeName, modelType) {\n  if (typeName && modelType) {\n    if (typeName === modelType.name || modelType.typeHierarchyArray && modelType.typeHierarchyArray.indexOf(typeName) > -1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject UID represents a 'type' object.\n */\n\nexport let isTypeUid = function (uid) {\n  /**\n   * Note: We do not want to cache 'types' in the model object cache.\n   */\n  return uid && /^TYPE::/i.test(uid);\n};\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {String} type name extracted from UID\n */\n\nexport let extractTypeNameFromUID = function (uid) {\n  return uid.split('::')[1];\n};\n/**\n * Cache model types into client meta model.\n *\n * @param {ModelType[]} modelTypes - Array of {ModelType} objects.\n */\n\nexport let cacheTypes = function (modelTypes) {\n  for (var ii = modelTypes.length - 1; ii >= 0; ii--) {\n    var modelType = modelTypes[ii]; // Don't update cache if a model type comes across again\n\n    if (!exports.containsType(modelType.name)) {\n      _name2modelType[modelType.name] = new ModelType(modelType);\n    }\n  }\n};\nexports = {\n  getTypeIconFileName,\n  containsType,\n  getType,\n  isTypeObject,\n  isInstanceOf,\n  isTypeUid,\n  extractTypeNameFromUID,\n  cacheTypes\n};\nexport default exports;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ModelType\");\n$RefreshReg$(_c2, \"PropertyDescriptor\");\n\nvar _c3, _c4;\n\n$RefreshReg$(_c3, \"ModelType\");\n$RefreshReg$(_c4, \"PropertyDescriptor\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/kernel/clientMetaModel.js"],"names":["_name2modelType","_propertyDescriptors","getTypeIconFileName","ii","modelType","typeName","typeFileName","iconMapSvc","ModelType","modelTypeSOA","jj","propertyDescriptorSOA","propName","pd","cachedPD","_","foundPD","constant","exports","PropertyDescriptor","kk","containsType","getType","isTypeObject","modelObject","isInstanceOf","isTypeUid","uid","extractTypeNameFromUID","cacheTypes","modelTypes"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/clientMetaModel\n */\nimport iconMapSvc from 'js/iconMapService';\nimport _ from 'lodash';\n\n/**\n * Object used to implement a typeName-to-PropertyType cache map.\n */\nvar _name2modelType = {};\n\n/**\n * Reference to the 'iconService' set into this module and used to reuse type file information.\n * <P>\n * Note: We are trying to avoid a cyclic reference since 'iconService' required CMM to do its work.\n */\n\n/**\n * @type {Object} map of property descriptors for reuse; property name to PropertyDescriptor or PropertyDescriptor[]\n */\nvar _propertyDescriptors = {};\n\nlet exports;\n\n/**\n * Get the resolved filename of the SVG icon.\n *\n * @param {Object} modelType - The Teamcenter ModelObject's 'modelType' object which\n * @return {String} type icon file name\n */\nexport let getTypeIconFileName = function( modelType ) {\n    for( var ii = 0; ii < modelType.typeHierarchyArray.length; ii++ ) {\n        var typeName = modelType.typeHierarchyArray[ ii ];\n        var typeFileName = iconMapSvc.getTypeFileName( typeName );\n        if( typeFileName ) {\n            return typeFileName;\n        }\n    }\n\n    return iconMapSvc.getTypeFileName( 'MissingImage' );\n};\n\n/**\n * @param {Object} modelTypeSOA - model type object returned from SOA\n */\nvar ModelType = function( modelTypeSOA ) {\n    this.abstract = modelTypeSOA.abstract;\n    this.children = modelTypeSOA.children;\n    this.displayName = modelTypeSOA.displayName;\n    this.name = modelTypeSOA.name;\n    this.owningType = modelTypeSOA.owningType;\n    this.parentTypeName = modelTypeSOA.parentTypeName;\n    this.primary = modelTypeSOA.primary ? true : undefined;\n    this.references = modelTypeSOA.references;\n    this.typeHierarchyArray = modelTypeSOA.typeHierarchy ? modelTypeSOA.typeHierarchy.split( ',' ) : null;\n    this.typeUid = modelTypeSOA.typeUid;\n    this.uid = modelTypeSOA.uid;\n\n    this.constantsMap = {};\n    this.propertyDescriptorsMap = {};\n\n    // To support property processing in CDM during model object caching, create a map of the property descriptors.\n    if( modelTypeSOA.propertyDescriptors ) {\n        for( var jj = modelTypeSOA.propertyDescriptors.length - 1; jj >= 0; jj-- ) {\n            var propertyDescriptorSOA = modelTypeSOA.propertyDescriptors[ jj ];\n            var propName = propertyDescriptorSOA.name;\n            var pd = new PropertyDescriptor( propertyDescriptorSOA );\n\n            var cachedPD = _propertyDescriptors[ propName ];\n            if( cachedPD ) {\n                if( _.isArray( cachedPD ) ) {\n                    // is array\n                    var foundPD = false;\n                    _.forEach( cachedPD, function( pd2 ) {\n                        if( _.isEqual( pd, pd2 ) ) {\n                            pd = pd2;\n                            foundPD = true;\n                            return false; // break\n                        }\n                    } );\n                    if( !foundPD ) {\n                        // not in array already, add new one\n                        cachedPD.push( pd );\n                    }\n                } else if( _.isEqual( pd, cachedPD ) ) {\n                    // not array & equal to cached pd\n                    pd = cachedPD;\n                } else {\n                    // not equal to cached PD, so we create array to track both\n                    _propertyDescriptors[ propName ] = [ cachedPD, pd ];\n                }\n            } else {\n                // first encounter of this property descriptor, so cache it\n                _propertyDescriptors[ propName ] = pd;\n            }\n\n            this.propertyDescriptorsMap[ propName ] = pd;\n        }\n    }\n\n    if( modelTypeSOA.constants ) {\n        for( jj = modelTypeSOA.constants.length - 1; jj >= 0; jj-- ) {\n            var constant = modelTypeSOA.constants[ jj ];\n            this.constantsMap[ constant.name ] = constant.value;\n        }\n    }\n\n    if( !this.constantsMap.IconFileName && this.typeHierarchyArray ) {\n        this.constantsMap.IconFileName = exports.getTypeIconFileName( this );\n    }\n};\n\n/**\n * @param {Object} propertyDescriptorSOA - property descriptor object returned from SOA\n */\nvar PropertyDescriptor = function( propertyDescriptorSOA ) {\n    this.anArray = propertyDescriptorSOA.anArray ? true : undefined;\n    this.basedOn = propertyDescriptorSOA.basedOn;\n    this.compoundObjType = propertyDescriptorSOA.compoundObjType;\n    this.displayName = propertyDescriptorSOA.displayName;\n    this.fieldType = propertyDescriptorSOA.fieldType;\n    this.lovCategory = propertyDescriptorSOA.lovCategory;\n    this.maxArraySize = propertyDescriptorSOA.maxArraySize;\n    this.maxLength = propertyDescriptorSOA.maxLength;\n    this.minValue = propertyDescriptorSOA.minValue;\n    this.name = propertyDescriptorSOA.name;\n    this.propertyType = propertyDescriptorSOA.propertyType;\n    this.propertyType2 = propertyDescriptorSOA.propertyType2;\n    this.valueType = propertyDescriptorSOA.valueType;\n\n    this.constantsMap = {};\n\n    if( propertyDescriptorSOA.constants ) {\n        for( var kk = propertyDescriptorSOA.constants.length - 1; kk >= 0; kk-- ) {\n            var constant = propertyDescriptorSOA.constants[ kk ];\n            this.constantsMap[ constant.name ] = constant.value;\n        }\n    }\n};\n\n/**\n * Does client meta model contain type?\n *\n * @param {String} name - property type name.\n * @return {Boolean} true if model type is contained within the CMM\n */\nexport let containsType = function( name ) {\n    return _name2modelType.hasOwnProperty( name );\n};\n\n/**\n * Get model type by type name.\n *\n * @param {String} name - type name (or UID)\n * @return {ModelType|null} model type if contained within CMM\n */\nexport let getType = function( name ) {\n    if( exports.containsType( name ) ) {\n        return _name2modelType[ name ];\n    }\n    if( exports.isTypeUid( name ) ) {\n        return exports.getType( exports.extractTypeNameFromUID( name ) );\n    }\n    return null;\n};\n\n/**\n * @param {ModelObject} modelObject - ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject represents a 'type' object.\n */\nexport let isTypeObject = function( modelObject ) {\n    /**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */\n    return exports.isTypeUid( modelObject.uid );\n};\n\n/**\n * Returns True if this type is child of the give type.\n *\n * @param {String} typeName - name of class\n * @param {ModelType} modelType - view model object's model type.\n * @return {Boolean} true if this type is child of the give type.\n */\nexport let isInstanceOf = function( typeName, modelType ) {\n    if( typeName && modelType ) {\n        if( typeName === modelType.name ||\n            modelType.typeHierarchyArray && modelType.typeHierarchyArray.indexOf( typeName ) > -1 ) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {Boolean} TRUE if the given ModelObject UID represents a 'type' object.\n */\nexport let isTypeUid = function( uid ) {\n    /**\n     * Note: We do not want to cache 'types' in the model object cache.\n     */\n    return uid && /^TYPE::/i.test( uid );\n};\n\n/**\n * @param {String} uid - UID of a ModelObject to test.\n * @return {String} type name extracted from UID\n */\nexport let extractTypeNameFromUID = function( uid ) {\n    return uid.split( '::' )[ 1 ];\n};\n\n/**\n * Cache model types into client meta model.\n *\n * @param {ModelType[]} modelTypes - Array of {ModelType} objects.\n */\nexport let cacheTypes = function( modelTypes ) {\n    for( var ii = modelTypes.length - 1; ii >= 0; ii-- ) {\n        var modelType = modelTypes[ ii ];\n        // Don't update cache if a model type comes across again\n        if( !exports.containsType( modelType.name ) ) {\n            _name2modelType[ modelType.name ] = new ModelType( modelType );\n        }\n    }\n};\n\nexports = {\n    getTypeIconFileName,\n    containsType,\n    getType,\n    isTypeObject,\n    isInstanceOf,\n    isTypeUid,\n    extractTypeNameFromUID,\n    cacheTypes\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}