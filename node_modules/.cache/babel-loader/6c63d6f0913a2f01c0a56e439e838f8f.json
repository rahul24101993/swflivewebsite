{"ast":null,"code":"/* eslint-disable complexity */ // Copyright (c) 2020 Siemens\n/**\n * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.\n *\n * @module js/declViewModelProcessingFactory\n *\n * @namespace viewModelProcessingFactory\n */import _ from'lodash';import viewModelSvc from'js/viewModelService';import{loadAction,validateLovAction}from'js/dataProviderFactory';import{processGrids}from'js/gridProviderUtils';import syncStrategySvc from'js/syncStrategyService';import{evalDataDefinition,cloneDeepJsonObject}from'js/declReactUtils';import conditionService from'js/conditionService';import modelPropertySvc from'js/modelPropertyService';import{composeDispatch}from'js/store';import declUtils from'js/declUtils';import{shouldCreateViewModelProperty,initViewModel}from'js/viewModelProcessingFactory';import{defineLazyGetter}from'js/functionalUtility.service';import debugService from'js/debugService';import dataProviderService from'js/declDataProviderService';import declDragAndDropService from'js/declDragAndDropService';/**\n * create data instance from data definition\n * @param {JSON} dataDef data section definition\n * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}\n * @param {object} vmDef viewModel template\n * @param {object} subPanelContext subPanelContext\n * @param {object} props props value\n * @returns {object} data object\n */function createData(){let dataDef=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let scope=arguments.length>1?arguments[1]:undefined;let vmDef=arguments.length>2?arguments[2]:undefined;let subPanelContext=arguments.length>3?arguments[3]:undefined;let props=arguments.length>4?arguments[4]:undefined;const filteredDataDef={};// This would filter out the atomic object from the data.\nconst dataKeys=Object.keys(dataDef).filter(keyName=>!_.has(dataDef,\"\".concat(keyName,\".meta\")));dataKeys.forEach(key=>filteredDataDef[key]=dataDef[key]);const data=scope?evalDataDefinition(filteredDataDef,scope):cloneDeepJsonObject(filteredDataDef);/**\n     * Recursively initialize the property values of the given JSON data object with the current value of any bound\n     * appContext properties (bound via {{ctx.*}}).\n     */initViewModel(data,subPanelContext,props);// Assume all root value witout _ is vmo prop\nfor(const prop in data){if(prop==='objects'){data[prop]=vmDef[prop];continue;}if(prop==='uid'){vmDef.vmo=vmDef.attachModelObject(data[prop]);continue;}if(!shouldCreateViewModelProperty(data[prop])){continue;}let propAttrHolder=declUtils.buildPropHolder(data[prop]);/**\n         * Make sure we have a 'propName' set.\n         */if(!data[prop].propName){data[prop].propName=prop;}// If this is not a view model prop, just save the object to the data.\nif(_.isEmpty(propAttrHolder)){data[prop]=vmDef[prop];continue;}if(!prop.startsWith('_')&&typeof data[prop]==='object'){let vmProp=modelPropertySvc.createViewModelProperty(data[prop]);if(!declUtils.isNil(data[prop].uiValue)){vmProp.uiValue=data[prop].uiValue;}if(!declUtils.isNil(data[prop].dbValue)){vmProp.dbValue=data[prop].dbValue;}if(dataDef[prop].dataProvider){// we have an lov, but the api is defined using the dataProvider\nvmProp.dataProvider=dataDef[prop].dataProvider;vmProp.hasLov=true;vmProp.emptyLOVEntry=dataDef[prop].emptyLOVEntry;}data[prop]=vmProp;}}// do init hook her if needed\n// vmDef.executeHook( 'onInit', props, [ data ], ctxHook );\nreturn data;}/**\n * create lifecycle hook based on action map\n * @param {Object} lifecycleHookDefs life cycle hook definition\n * @param {Object} actions action map\n * @returns {object} lifecyclehook callback map\n */function createLifecycleHooks(){let lifecycleHookDefs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];let actions=arguments.length>1?arguments[1]:undefined;let hooksActionsMap={};_.forEach(lifecycleHookDefs,(actionName,hookName)=>{// Map onInit hook to onMount - This would not work when we have have both onInit and onMount\n// defined for a component.onInit would never get a chance to get invoked.\n//hookName = hookName === 'onInit' ? 'onMount' : hookName;\nif(Array.isArray(actionName)){hooksActionsMap[hookName]=[];_.forEach(actionName,function(actionObj){hooksActionsMap[hookName].push(actions[actionObj.action]);});}else{if(!actions[actionName]&&typeof Object){//Is mapped to an object with observer and action.\nhooksActionsMap[hookName]=actions[actionName.action];}else{hooksActionsMap[hookName]=actions[actionName];}}});return hooksActionsMap;}/**\n * create valiation rule based on property definition\n * @param {JSON} props property definitions\n * @param {JSON} conds condition definitions\n * @returns {object} property validation objects\n */ /**\n * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API\n * @param {JSON} declViewModelJson view model definition\n * @param {object} prop componet prop\n * @returns {object} view model factory\n */export function createDeclViewModel(declViewModelJson){let prop=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{viewId,subPanelContext}=prop;declViewModelJson.data=declViewModelJson.data||{};const vmDef=viewModelSvc.populateViewModelPropertiesFromJson(declViewModelJson,null,null,null,null,subPanelContext);if(viewId){vmDef._internal.viewId=viewId;}// put declViewModelJson to vmDef\nvmDef.declViewModelJson=declViewModelJson;// build data creation function\nvmDef.createData=scope=>createData(declViewModelJson.data,scope,vmDef,subPanelContext,prop);// create sync strategy ports\nvmDef.createPorts=()=>{return cloneDeepJsonObject(declViewModelJson.ports);};vmDef.createFieldsData=()=>{let initialState={};for(const prop in declViewModelJson.data){if(declViewModelJson.data[prop]&&declViewModelJson.data[prop].meta){initialState[prop]=declViewModelJson.data[prop].initialValues;}}return initialState;};vmDef.createDataProvider=()=>{return vmDef.dataProviders;};//build LifecycleHooks\nvmDef.createLifecycleHooks=actions=>createLifecycleHooks(declViewModelJson.lifecycleHooks,actions);// bind drag drop handler  with declViewModal\ndeclDragAndDropService.setupDragAndDropOnView(vmDef);return vmDef;}const bindActions=function(viewModel,declViewModelJson,dataCtxNode,getData,getProps,runActionWithViewModel){viewModel.actions=_.mapValues(declViewModelJson.actions,actionDef=>renderOptions=>{let fields=dataCtxNode.getFields();// #49 - Side effect in example 'Notification Messages'\nObject.assign(dataCtxNode.data,getData());getProps&&Object.assign(dataCtxNode,{props:getProps(),getProps});fields&&Object.assign(dataCtxNode,{fields});if(renderOptions){//add the parameter here\n//add the function ref necessary to execute a command action programatically\ndataCtxNode.parameters={...renderOptions,commandActionExecutor:{runActionWithViewModel}};}return viewModelSvc.executeCommand(viewModel,actionDef.actionId,dataCtxNode);});};const bindChartProvider=function(viewModel,vmDef,dataCtxNode){if(viewModel.chartProviders&&!_.isEmpty(viewModel.chartProviders)){_.mapValues(viewModel.chartProviders,function(chartProvider){if(chartProvider.loadDataAction){chartProvider.loadDataActionCallBack=()=>{return dataProviderService.executeLoadAction(vmDef.getAction(chartProvider.loadDataAction),{},dataCtxNode);};}if(chartProvider.selectAction){chartProvider.selectActionCallBack=selectedChartEntity=>{if(!dataCtxNode.parameters){dataCtxNode.parameters={};}dataCtxNode.parameters.selectedChartEntity={...selectedChartEntity};return viewModelSvc.executeCommand(viewModel,vmDef.getAction(chartProvider.selectAction).actionId,dataCtxNode);};}if(chartProvider.unSelectAction){chartProvider.unSelectedActionCallBack=unSelectedChartEntity=>{if(!dataCtxNode.parameters){dataCtxNode.parameters={};}dataCtxNode.parameters.unSelectedChartEntity={...unSelectedChartEntity};return viewModelSvc.executeCommand(viewModel,vmDef.getAction(chartProvider.unSelectAction).actionId,dataCtxNode);};}});}};const bindDataProvider=function(viewModel,dataCtxNode,getData,getProps){_.mapValues(viewModel.dataProviders,dataProvider=>dataProvider.loadAction=async(vmCollection,startIndex,pageObject)=>{Object.assign(dataCtxNode.data,getData());getProps&&Object.assign(dataCtxNode,{props:getProps(),getProps});return loadAction(dataProvider,dataCtxNode,vmCollection,startIndex,pageObject);});};const bindStaticDataProvider=function(viewModel,dataCtxNode){_.mapValues(viewModel.dataProviders,dataProvider=>dataProvider.validateLovAction=async input=>{return validateLovAction(input,dataProvider,dataCtxNode);});};/**\n * process vmDef, ctx and data to create view model instance\n * @param {object} vmDef view model definition\n * @param {Array} ctxHook react ctx hook in data-dispatch pair\n * @param {Array} dataHook  react data hook in dta-dispatch pair\n * @param {Array} portsHook  react data hook in portsHook pair\n * @param {object} allAtomicData  react dataProviders\n * @param {object} getProps getProps\n * @param {object} runActionWithViewModel callback function\n * @param {object} getFields getFields\n * @returns {object} view model instance\n */export function processViewModel(vmDef,ctxHook,dataHook,portsHook){let allAtomicData=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};let getProps=arguments.length>5?arguments[5]:undefined;let runActionWithViewModel=arguments.length>6?arguments[6]:undefined;let getFields=arguments.length>7?arguments[7]:undefined;const[ctx,updateCtx]=ctxHook;const props=getProps?getProps():{};const[data,updateData,getData]=dataHook;const declViewModelJson=vmDef.declViewModelJson;let dispatchers={ctx:updateCtx,data:updateData};debugService.debug('lifeCycles',vmDef._internal.panelId,'init');// fields data\nlet atomicData={};let updateAtomicData={};let atomicDataHook=allAtomicData.atomicDataHook?allAtomicData.atomicDataHook:{};const atomicDataHookKeys=Object.keys(atomicDataHook);_.forEach(atomicDataHookKeys,function(stateName){atomicData[stateName]=atomicDataHook[stateName][0];updateAtomicData[stateName]=allAtomicData.atomicDataRef[stateName].setAtomicData;});// sync strategy port dispatcher\nlet ports;let updatePorts;if(declViewModelJson.ports&&portsHook){[ports,updatePorts]=portsHook;dispatchers.ports=updatePorts;}// dispatch method\nconst{dispatch}=composeDispatch(dispatchers);const viewModel={// store\nctx,data,atomicData,updateAtomicData,atomicDataRef:allAtomicData.atomicDataRef,//subPanelContext\nsubPanelContext:props.subPanelContext,// dispatch\ndispatch,// getData\ngetData,// context for post eval\nconditions:{},expressions:{},oldExpressions:{},i18n:declViewModelJson.i18n,onEvent:declViewModelJson.onEvent,messages:declViewModelJson.messages,ports:ports};// revisitme - data (the section in the VM needs to be directly available on the viewModel)\n// not doing deep copy has side effects. This will be modified depending on the approach\n// that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.\n_.assign(viewModel,vmDef);let dataObj=data;// We need deep copy for data providers.\nif(dataObj&&dataObj.dataProviders){let dataObjDataProviders=dataObj.dataProviders;delete dataObj.dataProviders;for(const dpKey in dataObjDataProviders){if(viewModel.dataProviders&&viewModel.dataProviders[dpKey]){_.assign(viewModel.dataProviders[dpKey],dataObjDataProviders[dpKey]);}}}// Not sure whether other portion of data needs deep copy. So not touching the same.\n_.assign(viewModel,dataObj);_.assign(viewModel,atomicData);let dataCtxNode={props,data:viewModel,ctx,subPanelContext:props.subPanelContext,ports:viewModel.ports,getProps,getFields};// conditions\n//lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it\n//forEach because closure is needed\nObject.entries(declViewModelJson.conditions||{}).forEach(_ref=>{let[key,value]=_ref;defineLazyGetter(viewModel.conditions,key,()=>conditionService.evaluateCondition(viewModel,value.expression,dataCtxNode));defineLazyGetter(viewModel.expressions,key,()=>[conditionService.parseExpression(viewModel,value.expression,dataCtxNode)]);});// bind action\nbindActions(viewModel,declViewModelJson,dataCtxNode,getData,getProps,runActionWithViewModel);// grids\nconst grids=processGrids(vmDef.grids,viewModel,ctxHook[0]);// bind data provider\nbindDataProvider(viewModel,dataCtxNode,getData,getProps);//bind callback for chartsProvider loadActionData\nbindChartProvider(viewModel,vmDef,dataCtxNode);// bind validate action for static dataproviders\nbindStaticDataProvider(viewModel,dataCtxNode);// validation criteria\n//vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );\n// Lifecycle Hooks\nviewModel.lifecycleHooks=createLifecycleHooks(declViewModelJson.lifecycleHooks,viewModel.actions);// sync strategy\nif(viewModel.ports&&!_.isEmpty(viewModel.ports)){syncStrategySvc.setupSyncStrategy(dataCtxNode);}return{viewModel,grids};}","map":null,"metadata":{},"sourceType":"module"}