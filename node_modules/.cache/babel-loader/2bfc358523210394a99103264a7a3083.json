{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n * A set of utilities and methods related to processing and modifying the commadns view model\n *\n * @module js/commandConfigUtils.service\n */\nimport configurationService from 'js/configurationService';\nimport { getRealExpression } from 'js/conditionService';\nimport _, { get, isObject, isString, isArray, mapValues, cloneDeepWith } from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nconst trace = new Debug('command:AwCommandBar');\n/** Regular Expression for the condition prefix in the expression. */\n\nconst conditionRE = /\\bconditions\\b\\./;\n/**\n * Get the conditions with any condition reuse within string expressions expanded\n *\n * @param {Object} viewModelJson View model with conditions to expand\n * @returns {Object} Processed condition expressions\n */\n\nconst getExpandedConditionExpressions = function (viewModelJson) {\n  const stringExpandedConditions = mapValues(viewModelJson.conditions, condition => {\n    if (isString(condition.expression)) {\n      //simple expansion of string conditions\n      return { ...condition,\n        expression: getRealExpression(condition.expression, viewModelJson)\n      };\n    }\n\n    if (isObject(condition.expression)) {\n      //recurse through object and expand any referenced string conditions\n      return cloneDeepWith(condition, value => {\n        if (isObject(value) && value.$source && conditionRE.test(value.$source)) {\n          const refExpression = getRealExpression(value.$source, viewModelJson);\n          return isString(refExpression) ? { ...value,\n            $source: refExpression,\n            __useSourceParsing: true\n          } : value;\n        }\n      });\n    }\n\n    return condition;\n  });\n  const tempVm = {\n    conditions: stringExpandedConditions\n  };\n\n  const checkObjectCondition = (condition, shouldRecurse) => {\n    if (isObject(condition) && condition.$source && conditionRE.test(condition.$source)) {\n      const eqCheck = get(condition, '$query.$eq');\n      const neCheck = get(condition, '$query.$ne');\n      const refExpression = getRealExpression(condition.$source, tempVm);\n\n      if (eqCheck === true || neCheck === false) {\n        //for true just swap original condition into same place\n        //need to restart recursion for new object to ensure and \"conditions.x\" included in it are updated\n        const newValue = cloneDeepWith(refExpression, expandObjectConditions);\n        trace('Expanded object condition', condition, newValue);\n        return newValue;\n      }\n\n      if (eqCheck === false || neCheck === true) {\n        //for false wrap with a $not\n        const newValue = {\n          $not: cloneDeepWith(refExpression, expandObjectConditions)\n        };\n        trace('Expanded object condition', condition, newValue);\n        return newValue;\n      }\n\n      logger.warn('Condition reuse only supports boolean checks', condition);\n    }\n\n    return shouldRecurse ? cloneDeepWith(condition, expandObjectConditions) : condition;\n  };\n\n  const expandObjectConditions = value => {\n    if (isArray(value)) {\n      return value.map(x => checkObjectCondition(x, true));\n    }\n\n    const newVal = checkObjectCondition(value);\n\n    if (newVal !== value) {\n      //don't return if not modifying anything, will stop recursion for the current object\n      return newVal;\n    }\n  };\n\n  return cloneDeepWith(stringExpandedConditions, expandObjectConditions);\n};\n/**\n * Convert every placement that has \"parentGroupID\" into a placement with\n * a dynamically generated anchor based on parent\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\n\nconst addChildPlacements = function (viewModelJson) {\n  for (const [placementID, placement] of Object.entries(viewModelJson.commandPlacements)) {\n    if (placement.parentGroupId) {\n      viewModelJson.commandPlacements[`$$${placementID}${placement.parentGroupId}`] = {\n        id: placement.id,\n        priority: placement.priority,\n        relativeTo: placement.relativeTo,\n        uiAnchor: placement.parentGroupId\n      };\n    }\n  }\n};\n/**\n * Ensure the primary commandsViewModel has all of the expected properties\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\n\nconst ensureProps = function (viewModelJson) {\n  ['actions', 'commandHandlers', 'commandPlacements', 'commands', 'conditions', 'messages'].forEach(function (k) {\n    viewModelJson[k] = viewModelJson[k] || {};\n  });\n  ['onEvent'].forEach(function (k) {\n    viewModelJson[k] = viewModelJson[k] || [];\n  });\n};\n/**\n * Convert \"true\" and \"false\" shortcuts into actual conditions\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n * @param {Object} commandHandlers Command handlers to modify\n */\n\n\nexport const updateShortConditions = function (viewModelJson, commandHandlers) {\n  const trueCondition = {\n    condition: 'conditions.true'\n  };\n  const falseCondition = {\n    condition: 'conditions.false'\n  };\n\n  for (const handler of Object.values(commandHandlers)) {\n    ['activeWhen', 'visibleWhen', 'selectWhen', 'enableWhen'].forEach(function (conditionKey) {\n      if (handler[conditionKey] === true || _.get(handler, [conditionKey, 'condition']) === true) {\n        handler[conditionKey] = trueCondition;\n      } else if (handler[conditionKey] === false || _.get(handler, [conditionKey, 'condition']) === false) {\n        handler[conditionKey] = falseCondition;\n      }\n    });\n  }\n\n  viewModelJson.conditions.true = {\n    expression: 'true'\n  };\n  viewModelJson.conditions.false = {\n    expression: 'false'\n  };\n};\n/**\n * Convert \"title\": \"{{ctx.previousLocationDisplayName }}\" to parameter format\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\n\nconst updateShortCommandTitles = function (viewModelJson) {\n  for (const command of Object.values(viewModelJson.commands)) {\n    if (command.title && typeof command.title === 'string' && (command.title.startsWith('{{ctx') || command.title.startsWith('{{commandContext'))) {\n      command.title = {\n        text: '{0}',\n        params: [command.title]\n      };\n    }\n  }\n};\n\nlet viewModelJsonCache = null;\n\nconst setCommandsViewModelCache = newCache => {\n  viewModelJsonCache = newCache;\n};\n/**\n * Get and pre process the commands view model from config service\n * @param {boolean} clearCache true if to clear any commandsViewModelCache\n * @returns {Promise<Object>} promise resolved with the commands view model (plain object)\n */\n\n\nconst getCommandsViewModel = async function () {\n  let clearCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (viewModelJsonCache && !clearCache) {\n    return viewModelJsonCache;\n  }\n\n  let viewModelJson = await configurationService.getCfg('commandsViewModel');\n  ensureProps(viewModelJson);\n  const expandedConditions = getExpandedConditionExpressions(viewModelJson);\n  viewModelJson.conditions = expandedConditions;\n  addChildPlacements(viewModelJson);\n  updateShortConditions(viewModelJson, viewModelJson.commandHandlers);\n  updateShortCommandTitles(viewModelJson);\n  setCommandsViewModelCache(viewModelJson);\n  return viewModelJson;\n};\n/**\n * Get all matches of a regex in the given string\n *\n * @param {RegExp} re Regex to used\n * @param {String} s String to search\n * @returns {Array<String>} List of all matches\n */\n\n\nconst getAllMatches = function (re, s) {\n  var result = [];\n  var m = re.exec(s);\n\n  while (m) {\n    result.push(m[1]);\n    m = re.exec(s);\n  }\n\n  return result;\n};\n\nconst conditionsRE = /conditions\\.([a-zA-Z]\\w*)(\\W*|$)/g;\n/**\n * Get all nested conditions from a condition expression. See unit tests for examples.\n *\n * @param {String|Object} s condition expression\n * @returns {String[]} nested conditions\n */\n\nconst getConditions = function (s) {\n  if (typeof s === 'string') {\n    return getAllMatches(conditionsRE, s);\n  }\n\n  if (typeof s === 'object') {\n    return Object.keys(s).map(k => s[k]) //Object.values( s ) if not for IE11\n    .reduce((acc, nxt) => acc.concat(getConditions(nxt)), []);\n  }\n\n  return [];\n};\n/**\n * Utility to get the actual condition expression from the commands view model\n *\n * @param {Object} commandsViewModel The commands view model\n * @param {String} condition The conditon name (\"conditions.asdf\")\n * @returns {String|Object} The condition expression (string or object)\n */\n\n\nconst getConditionExpression = function (commandsViewModel, condition) {\n  var conditionName = condition.split('.')[1];\n\n  var expression = _.get(commandsViewModel, `_internal.conditions.${conditionName}.expression`, null) || _.get(commandsViewModel, `conditions.${conditionName}.expression`, null);\n\n  if (expression === null) {\n    //If condition does not exist return \"false\" to avoid console errors (same behavior)\n    logger.error(`Reference to missing condition \"${conditionName}\"`);\n    expression = 'false';\n  }\n\n  return expression;\n};\n/**\n * Recurses into the object and sub objects and finds real length of the expression by replacing the\n * references to other condition.xyz conditions\n *\n * @param {Object|String} expression expression whose actual length is desired\n * @param {Object} internalViewModel Object holding all expression definitions\n * @returns {Number} the length of the expression\n */\n\n\nconst getExpressionLength = function (expression, internalViewModel) {\n  var sum = function (a, b) {\n    return a + b;\n  };\n\n  if (typeof expression === 'string') {\n    return expression.length;\n  }\n\n  return _.map(expression, function (value, key) {\n    if (key === '__useSourceParsing') {\n      return 0;\n    }\n\n    var length = String(key).length;\n\n    if (value && _.isString(value)) {\n      var nestedConditions = getConditions(value);\n\n      if (nestedConditions.length > 0) {\n        var nestedConditionLength = nestedConditions.map(function (condName) {\n          return getExpressionLength(getConditionExpression(internalViewModel, 'conditions.' + condName), internalViewModel);\n        }).reduce(sum);\n        return length + nestedConditionLength;\n      }\n\n      return length + String(value).length;\n    }\n\n    if (_.isObject(value)) {\n      return length + getExpressionLength(value, internalViewModel);\n    }\n\n    return length + String(value).length;\n  }).reduce(sum);\n};\n\nconst exports = {\n  updateShortConditions,\n  getCommandsViewModel,\n  getConditions,\n  getConditionExpression,\n  getExpressionLength\n};\nexport default exports;","map":{"version":3,"names":["configurationService","getRealExpression","_","get","isObject","isString","isArray","mapValues","cloneDeepWith","logger","Debug","trace","conditionRE","getExpandedConditionExpressions","viewModelJson","stringExpandedConditions","conditions","condition","expression","value","$source","test","refExpression","__useSourceParsing","tempVm","checkObjectCondition","shouldRecurse","eqCheck","neCheck","newValue","expandObjectConditions","$not","warn","map","x","newVal","addChildPlacements","placementID","placement","Object","entries","commandPlacements","parentGroupId","id","priority","relativeTo","uiAnchor","ensureProps","forEach","k","updateShortConditions","commandHandlers","trueCondition","falseCondition","handler","values","conditionKey","true","false","updateShortCommandTitles","command","commands","title","startsWith","text","params","viewModelJsonCache","setCommandsViewModelCache","newCache","getCommandsViewModel","clearCache","getCfg","expandedConditions","getAllMatches","re","s","result","m","exec","push","conditionsRE","getConditions","keys","reduce","acc","nxt","concat","getConditionExpression","commandsViewModel","conditionName","split","error","getExpressionLength","internalViewModel","sum","a","b","length","key","String","nestedConditions","nestedConditionLength","condName","exports"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/commandConfigUtils.service.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * Defines provider for commands from the View model definition\n * A set of utilities and methods related to processing and modifying the commadns view model\n *\n * @module js/commandConfigUtils.service\n */\nimport configurationService from 'js/configurationService';\nimport { getRealExpression } from 'js/conditionService';\nimport _, { get, isObject, isString, isArray, mapValues, cloneDeepWith } from 'lodash';\nimport logger from 'js/logger';\nimport Debug from 'debug';\nconst trace = new Debug( 'command:AwCommandBar' );\n\n/** Regular Expression for the condition prefix in the expression. */\nconst conditionRE = /\\bconditions\\b\\./;\n\n/**\n * Get the conditions with any condition reuse within string expressions expanded\n *\n * @param {Object} viewModelJson View model with conditions to expand\n * @returns {Object} Processed condition expressions\n */\nconst getExpandedConditionExpressions = function( viewModelJson ) {\n    const stringExpandedConditions = mapValues( viewModelJson.conditions, condition => {\n        if( isString( condition.expression ) ) {\n            //simple expansion of string conditions\n            return {\n                ...condition,\n                expression: getRealExpression( condition.expression, viewModelJson )\n            };\n        }\n        if( isObject( condition.expression ) ) {\n            //recurse through object and expand any referenced string conditions\n            return cloneDeepWith( condition, ( value ) => {\n                if( isObject( value ) && value.$source && conditionRE.test( value.$source ) ) {\n                    const refExpression = getRealExpression( value.$source, viewModelJson );\n                    return isString( refExpression ) ? {\n                        ...value,\n                        $source: refExpression,\n                        __useSourceParsing: true\n                    } : value;\n                }\n            } );\n        }\n        return condition;\n    } );\n    const tempVm = {\n        conditions: stringExpandedConditions\n    };\n    const checkObjectCondition = ( condition, shouldRecurse ) => {\n        if( isObject( condition ) && condition.$source && conditionRE.test( condition.$source ) ) {\n            const eqCheck = get( condition, '$query.$eq' );\n            const neCheck = get( condition, '$query.$ne' );\n            const refExpression = getRealExpression( condition.$source, tempVm );\n            if( eqCheck === true || neCheck === false ) {\n                //for true just swap original condition into same place\n                //need to restart recursion for new object to ensure and \"conditions.x\" included in it are updated\n                const newValue = cloneDeepWith( refExpression, expandObjectConditions );\n                trace( 'Expanded object condition', condition, newValue );\n                return newValue;\n            }\n            if( eqCheck === false || neCheck === true ) {\n                //for false wrap with a $not\n                const newValue = {\n                    $not: cloneDeepWith( refExpression, expandObjectConditions )\n                };\n                trace( 'Expanded object condition', condition, newValue );\n                return newValue;\n            }\n            logger.warn( 'Condition reuse only supports boolean checks', condition );\n        }\n        return shouldRecurse ? cloneDeepWith( condition, expandObjectConditions ) : condition;\n    };\n    const expandObjectConditions = ( value ) => {\n        if( isArray( value ) ) {\n            return value.map( x => checkObjectCondition( x, true ) );\n        }\n        const newVal = checkObjectCondition( value );\n        if( newVal !== value ) {\n            //don't return if not modifying anything, will stop recursion for the current object\n            return newVal;\n        }\n    };\n    return cloneDeepWith( stringExpandedConditions, expandObjectConditions );\n};\n\n/**\n * Convert every placement that has \"parentGroupID\" into a placement with\n * a dynamically generated anchor based on parent\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst addChildPlacements = function( viewModelJson ) {\n    for( const [ placementID, placement ] of Object.entries( viewModelJson.commandPlacements ) ) {\n        if( placement.parentGroupId ) {\n            viewModelJson.commandPlacements[ `$$${placementID}${placement.parentGroupId}` ] = {\n                id: placement.id,\n                priority: placement.priority,\n                relativeTo: placement.relativeTo,\n                uiAnchor: placement.parentGroupId\n            };\n        }\n    }\n};\n\n/**\n * Ensure the primary commandsViewModel has all of the expected properties\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst ensureProps = function( viewModelJson ) {\n    [ 'actions', 'commandHandlers', 'commandPlacements', 'commands', 'conditions', 'messages' ].forEach( function( k ) {\n        viewModelJson[ k ] = viewModelJson[ k ] || {};\n    } );\n    [ 'onEvent' ].forEach( function( k ) {\n        viewModelJson[ k ] = viewModelJson[ k ] || [];\n    } );\n};\n\n/**\n * Convert \"true\" and \"false\" shortcuts into actual conditions\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n * @param {Object} commandHandlers Command handlers to modify\n */\nexport const updateShortConditions = function( viewModelJson, commandHandlers ) {\n    const trueCondition = {\n        condition: 'conditions.true'\n    };\n    const falseCondition = {\n        condition: 'conditions.false'\n    };\n    for( const handler of Object.values( commandHandlers ) ) {\n        [ 'activeWhen', 'visibleWhen', 'selectWhen', 'enableWhen' ].forEach( function( conditionKey ) {\n            if( handler[ conditionKey ] === true ||\n                _.get( handler, [ conditionKey, 'condition' ] ) === true ) {\n                handler[ conditionKey ] = trueCondition;\n            } else if( handler[ conditionKey ] === false ||\n                _.get( handler, [ conditionKey, 'condition' ] ) === false ) {\n                handler[ conditionKey ] = falseCondition;\n            }\n        } );\n    }\n    viewModelJson.conditions.true = {\n        expression: 'true'\n    };\n    viewModelJson.conditions.false = {\n        expression: 'false'\n    };\n};\n\n/**\n * Convert \"title\": \"{{ctx.previousLocationDisplayName }}\" to parameter format\n *\n * Dirty - modifies input\n *\n * @param {Object} viewModelJson View model json to modify\n */\nconst updateShortCommandTitles = function( viewModelJson ) {\n    for( const command of Object.values( viewModelJson.commands ) ) {\n        if( command.title && typeof command.title === 'string' && ( command.title.startsWith( '{{ctx' ) || command.title.startsWith( '{{commandContext' ) ) ) {\n            command.title = {\n                text: '{0}',\n                params: [ command.title ]\n            };\n        }\n    }\n};\n\nlet viewModelJsonCache = null;\nconst setCommandsViewModelCache = ( newCache ) => {\n    viewModelJsonCache = newCache;\n};\n\n/**\n * Get and pre process the commands view model from config service\n * @param {boolean} clearCache true if to clear any commandsViewModelCache\n * @returns {Promise<Object>} promise resolved with the commands view model (plain object)\n */\nconst getCommandsViewModel = async function( clearCache = false ) {\n    if( viewModelJsonCache && !clearCache ) {\n        return viewModelJsonCache;\n    }\n    let viewModelJson = await configurationService.getCfg( 'commandsViewModel' );\n    ensureProps( viewModelJson );\n    const expandedConditions = getExpandedConditionExpressions( viewModelJson );\n    viewModelJson.conditions = expandedConditions;\n    addChildPlacements( viewModelJson );\n    updateShortConditions( viewModelJson, viewModelJson.commandHandlers );\n    updateShortCommandTitles( viewModelJson );\n    setCommandsViewModelCache( viewModelJson );\n    return viewModelJson;\n};\n\n/**\n * Get all matches of a regex in the given string\n *\n * @param {RegExp} re Regex to used\n * @param {String} s String to search\n * @returns {Array<String>} List of all matches\n */\nconst getAllMatches = function( re, s ) {\n    var result = [];\n    var m = re.exec( s );\n    while( m ) {\n        result.push( m[ 1 ] );\n        m = re.exec( s );\n    }\n    return result;\n};\n\nconst conditionsRE = /conditions\\.([a-zA-Z]\\w*)(\\W*|$)/g;\n\n/**\n * Get all nested conditions from a condition expression. See unit tests for examples.\n *\n * @param {String|Object} s condition expression\n * @returns {String[]} nested conditions\n */\nconst getConditions = function( s ) {\n    if( typeof s === 'string' ) {\n        return getAllMatches( conditionsRE, s );\n    }\n    if( typeof s === 'object' ) {\n        return Object.keys( s ).map( k => s[ k ] ) //Object.values( s ) if not for IE11\n            .reduce( ( acc, nxt ) => acc.concat( getConditions( nxt ) ), [] );\n    }\n    return [];\n};\n\n/**\n * Utility to get the actual condition expression from the commands view model\n *\n * @param {Object} commandsViewModel The commands view model\n * @param {String} condition The conditon name (\"conditions.asdf\")\n * @returns {String|Object} The condition expression (string or object)\n */\nconst getConditionExpression = function( commandsViewModel, condition ) {\n    var conditionName = condition.split( '.' )[ 1 ];\n    var expression = _.get( commandsViewModel, `_internal.conditions.${conditionName}.expression`, null ) ||\n        _.get( commandsViewModel, `conditions.${conditionName}.expression`, null );\n    if( expression === null ) {\n        //If condition does not exist return \"false\" to avoid console errors (same behavior)\n        logger.error( `Reference to missing condition \"${conditionName}\"` );\n        expression = 'false';\n    }\n    return expression;\n};\n\n/**\n * Recurses into the object and sub objects and finds real length of the expression by replacing the\n * references to other condition.xyz conditions\n *\n * @param {Object|String} expression expression whose actual length is desired\n * @param {Object} internalViewModel Object holding all expression definitions\n * @returns {Number} the length of the expression\n */\nconst getExpressionLength = function( expression, internalViewModel ) {\n    var sum = function( a, b ) {\n        return a + b;\n    };\n    if( typeof expression === 'string' ) {\n        return expression.length;\n    }\n    return _.map( expression, function( value, key ) {\n        if( key === '__useSourceParsing' ) {\n            return 0;\n        }\n        var length = String( key ).length;\n        if( value && _.isString( value ) ) {\n            var nestedConditions = getConditions( value );\n            if( nestedConditions.length > 0 ) {\n                var nestedConditionLength = nestedConditions.map( function( condName ) {\n                    return getExpressionLength( getConditionExpression( internalViewModel, 'conditions.' + condName ), internalViewModel );\n                } ).reduce( sum );\n                return length + nestedConditionLength;\n            }\n            return length + String( value ).length;\n        }\n        if( _.isObject( value ) ) {\n            return length + getExpressionLength( value, internalViewModel );\n        }\n        return length + String( value ).length;\n    } ).reduce( sum );\n};\n\nconst exports = {\n    updateShortConditions,\n    getCommandsViewModel,\n    getConditions,\n    getConditionExpression,\n    getExpressionLength\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}