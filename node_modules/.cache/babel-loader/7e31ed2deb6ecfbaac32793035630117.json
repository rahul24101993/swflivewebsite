{"ast":null,"code":"/* eslint-disable complexity */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declFieldService\n *\n * @namespace declFieldService\n */\n//@collapse\nimport _ from 'lodash';\n\nconst checkIsListOfVMP = list => {\n  let isVMPArray = false;\n\n  if (_.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      isVMPArray = isVMPObj(list[i]);\n\n      if (!isVMPArray) {\n        break;\n      }\n    }\n  }\n\n  return isVMPArray;\n};\n\nconst isVMOObj = dataObject => {\n  return dataObject && dataObject.props;\n};\n\nconst isVMPObj = dataObject => {\n  return dataObject && dataObject.hasOwnProperty('dbValue') && dataObject.hasOwnProperty('uiValue');\n};\n\nconst populateFieldsForAtomicData = function (atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData) {\n  Object.keys(atomicData).forEach(atomicDataName => {\n    let prevFields = fieldsRef.current;\n    let prevField = prevFields && prevFields[atomicDataName];\n    let prevStateObj = prevField && prevField.value;\n    let currentStateObject = atomicData[atomicDataName];\n\n    let metaDef = _.get(declViewModelJson, `data.${atomicDataName}.meta`);\n\n    if (prevStateObj === currentStateObject) {\n      fields[atomicDataName] = prevField;\n    } else {\n      fields[atomicDataName] = createFieldsBasedOnMetaData(currentStateObject, metaDef, atomicDataName, createFieldForAtomicData, fieldsRef);\n    }\n  });\n};\n\nconst populateFieldForCtx = function (ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty) {\n  if (ctxFields) {\n    ctxFields.forEach(fieldName => {\n      const prop = _.get(ctx, fieldName); //Revisit me: Ria\n      //a.b.c => a_b_c : to use a prop key\n      //a[b].c not handled. Discuss with Jesse.\n\n\n      const name = fieldName.replace(/\\./g, '_');\n\n      if (prop && prop.props) {\n        fields[name] = {};\n        Object.keys(prop.props).forEach(prop => {\n          let prevField = fieldsRef[name] && fieldsRef[name][prop];\n          let newField = constructFieldForNamedPropertyVMO(fieldName, prop);\n\n          if (isFieldsEqual(prevField, newField)) {\n            fields[name][prop] = prevField;\n          } else {\n            fields[name][prop] = newField;\n          }\n        });\n      } else {\n        let prevField = fieldsRef[name];\n        const ctxField = constructFieldForNamedProperty(fieldName, true);\n\n        if (isFieldsEqual(prevField, ctxField)) {\n          fields[name] = prevField;\n        } else {\n          fields[name] = ctxField;\n        }\n      }\n    });\n  }\n};\n\nconst populateFieldsForXRT = function (dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO) {\n  Object.keys(dataObject).forEach(object => {\n    let obj = dataObject[object];\n\n    if (isVMOObj(obj) && obj.type !== 'Awp0XRTObjectSetRow') {\n      fields[object] = {};\n      Object.keys(obj.props).forEach(propName => {\n        let oldFields = fieldsRef.current;\n        let oldField = oldFields && oldFields[object] && oldFields[object][propName];\n        let newField = constructFieldForNamedPropertyVMO('objects[\\'' + object + '\\']', propName);\n\n        if (oldField && isFieldsEqual(oldField, newField)) {\n          fields[object][propName] = oldField;\n        } else {\n          fields[object][propName] = newField;\n        }\n      });\n    }\n  });\n};\n\nconst validateVMPList = function (newFieldArr, oldFieldArr) {\n  let allEqual = true;\n\n  for (let itr = 0; itr < newFieldArr.length; itr++) {\n    let oldField = oldFieldArr && oldFieldArr[itr];\n    let newField = newFieldArr && newFieldArr[itr];\n    allEqual = oldField && isFieldsEqual(oldField, newField);\n\n    if (!allEqual) {\n      break;\n    }\n  }\n\n  return allEqual;\n};\n\nconst populateFieldsForVMO = function (fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO) {\n  fields[stateName] = {};\n  Object.keys(dataObject.props).forEach(propName => {\n    let oldFields = fieldsRef.current;\n    let oldField = oldFields && oldFields[stateName] && oldFields[stateName][propName];\n    let newField = constructFieldForNamedPropertyVMO(stateName, propName);\n\n    if (oldField && isFieldsEqual(oldField, newField)) {\n      fields[stateName][propName] = oldField;\n    } else {\n      fields[stateName][propName] = newField;\n    }\n  });\n};\n\nconst populateFieldsForVMP = function (fieldsRef, stateName, constructFieldForNamedProperty, fields) {\n  let oldFields = fieldsRef.current;\n  let oldField = oldFields && oldFields[stateName];\n  let newField = constructFieldForNamedProperty(stateName);\n\n  if (oldField && isFieldsEqual(oldField, newField)) {\n    fields[stateName] = oldField;\n  } else {\n    fields[stateName] = newField;\n  }\n};\n\nexport const createAllFields = function (data, atomicData, declViewModelJson, createFieldForAtomicData, createFieldsBasedOnMetaData, constructFieldForNamedPropertyVMO, constructFieldArrayOfNamedProperty, constructFieldForNamedProperty, ctx, fieldsRef) {\n  let fields = {};\n  let stateNames = Object.keys(data);\n\n  for (let index = 0; index < stateNames.length; index++) {\n    let stateName = stateNames[index];\n    let dataObject = data[stateName];\n\n    if (_.isObject(dataObject) && !_.isFunction(dataObject) && !stateName.startsWith('_') && stateName !== 'dataProviders') {\n      if (stateName === 'objects') {\n        populateFieldsForXRT(dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO);\n      } else if (isVMPObj(dataObject)) {\n        populateFieldsForVMP(fieldsRef, stateName, constructFieldForNamedProperty, fields);\n      } else if (isVMOObj(dataObject)) {\n        populateFieldsForVMO(fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO);\n      } else if (Array.isArray(dataObject) && checkIsListOfVMP(dataObject)) {\n        let oldFields = fieldsRef.current;\n        let oldFieldArr = oldFields && oldFields[stateName];\n        let newFieldArr = constructFieldArrayOfNamedProperty(dataObject, stateName);\n\n        if (validateVMPList(newFieldArr, oldFieldArr)) {\n          fields[stateName] = oldFieldArr;\n        } else {\n          fields[stateName] = newFieldArr;\n        }\n      }\n    }\n  }\n\n  populateFieldsForAtomicData(atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData);\n  let ctxFields = declViewModelJson.ctxFields;\n  populateFieldForCtx(ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty);\n  return fields;\n};\n\nconst validateFieldData = function (oldField, newField) {\n  if (oldField && oldField.fielddata && newField.fielddata) {\n    if (oldField.fielddata.propertyName !== newField.fielddata.propertyName) {\n      return false;\n    }\n\n    if (oldField.fielddata.propertyDisplayName !== newField.fielddata.propertyDisplayName) {\n      return false;\n    }\n\n    if (oldField.fielddata.renderingHint !== newField.fielddata.renderingHint) {\n      return false;\n    }\n\n    if (oldField.fielddata.isEnabled !== newField.fielddata.isEnabled) {\n      return false;\n    }\n\n    if (oldField.fielddata.isEditable !== newField.fielddata.isEditable) {\n      return false;\n    }\n\n    if (oldField.fielddata.tooltip !== newField.fielddata.tooltip) {\n      return false;\n    }\n\n    if (oldField.fielddata.uwAnchor !== newField.fielddata.uwAnchor) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nexport const isFieldsEqual = (oldField, newField) => {\n  //TODO: Back command needs refresh -\n  //Scenarios :Export should work when we add properties and go back and export\n  //Export should work when we add properties and go back and export\n  if (newField.name === 'backCommand') {\n    return false;\n  }\n\n  let newProp = newField && newField.__vmprop__ && newField.__vmprop__();\n\n  let oldProp = oldField && oldField.__vmprop__ && oldField.__vmprop__();\n\n  if (newProp !== oldProp) {\n    return false;\n  }\n\n  let newDataProvider = newField.fielddata && newField.fielddata.dataProvider;\n\n  if (newDataProvider) {\n    return false;\n  }\n\n  if (oldField) {\n    if (oldField.checked !== newField.checked) {\n      return false;\n    }\n\n    if (oldField.value !== newField.value) {\n      return false;\n    }\n\n    if (oldField.dirty !== newField.dirty) {\n      return false;\n    }\n\n    if (oldField.fielddata.uiValue !== newField.fielddata.uiValue) {\n      return false;\n    }\n\n    if (oldField.error !== newField.error) {\n      return false;\n    }\n\n    if (oldField.required !== newField.required) {\n      return false;\n    }\n\n    if (oldField.touched !== newField.touched) {\n      return false;\n    }\n\n    if (oldField.disabled !== newField.disabled) {\n      return false;\n    }\n\n    if (oldField.label !== newField.label) {\n      return false;\n    }\n\n    if (oldField.name !== newField.name) {\n      return false;\n    }\n\n    if (oldField.placeholder !== newField.placeholder) {\n      return false;\n    }\n  }\n\n  return validateFieldData(oldField, newField);\n};","map":{"version":3,"names":["_","checkIsListOfVMP","list","isVMPArray","isArray","i","length","isVMPObj","isVMOObj","dataObject","props","hasOwnProperty","populateFieldsForAtomicData","atomicData","fieldsRef","declViewModelJson","fields","createFieldsBasedOnMetaData","createFieldForAtomicData","Object","keys","forEach","atomicDataName","prevFields","current","prevField","prevStateObj","value","currentStateObject","metaDef","get","populateFieldForCtx","ctxFields","ctx","constructFieldForNamedPropertyVMO","constructFieldForNamedProperty","fieldName","prop","name","replace","newField","isFieldsEqual","ctxField","populateFieldsForXRT","object","obj","type","propName","oldFields","oldField","validateVMPList","newFieldArr","oldFieldArr","allEqual","itr","populateFieldsForVMO","stateName","populateFieldsForVMP","createAllFields","data","constructFieldArrayOfNamedProperty","stateNames","index","isObject","isFunction","startsWith","Array","validateFieldData","fielddata","propertyName","propertyDisplayName","renderingHint","isEnabled","isEditable","tooltip","uwAnchor","newProp","__vmprop__","oldProp","newDataProvider","dataProvider","checked","dirty","uiValue","error","required","touched","disabled","label","placeholder"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declFieldService.js"],"sourcesContent":["/* eslint-disable complexity */\n/* eslint-disable no-unused-vars */\n/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n/**\n * This module provides a way for declarative framework to do outgoing calls like SOA or REST.\n *\n * @module js/declFieldService\n *\n * @namespace declFieldService\n */\n//@collapse\n\nimport _ from 'lodash';\n\nconst checkIsListOfVMP = ( list ) => {\n    let isVMPArray = false;\n    if( _.isArray( list ) ) {\n        for( let i = 0; i < list.length; i++ ) {\n            isVMPArray = isVMPObj( list[ i ] );\n            if( !isVMPArray ) {\n                break;\n            }\n        }\n    }\n    return isVMPArray;\n};\n\nconst isVMOObj = ( dataObject ) => {\n    return dataObject && dataObject.props;\n};\n\nconst isVMPObj = ( dataObject ) => {\n    return dataObject && dataObject.hasOwnProperty( 'dbValue' ) && dataObject.hasOwnProperty( 'uiValue' );\n};\n\nconst populateFieldsForAtomicData = function( atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData ) {\n    Object.keys( atomicData ).forEach( atomicDataName => {\n        let prevFields = fieldsRef.current;\n        let prevField = prevFields && prevFields[ atomicDataName ];\n        let prevStateObj = prevField && prevField.value;\n        let currentStateObject = atomicData[ atomicDataName ];\n        let metaDef = _.get( declViewModelJson, `data.${atomicDataName}.meta` );\n        if( prevStateObj === currentStateObject ) {\n            fields[ atomicDataName ] = prevField;\n        } else {\n            fields[ atomicDataName ] = createFieldsBasedOnMetaData( currentStateObject, metaDef, atomicDataName, createFieldForAtomicData, fieldsRef );\n        }\n    } );\n};\n\nconst populateFieldForCtx = function( ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty ) {\n    if( ctxFields ) {\n        ctxFields.forEach( ( fieldName ) => {\n            const prop = _.get( ctx, fieldName );\n            //Revisit me: Ria\n            //a.b.c => a_b_c : to use a prop key\n            //a[b].c not handled. Discuss with Jesse.\n            const name = fieldName.replace( /\\./g, '_' );\n\n            if( prop && prop.props ) {\n                fields[ name ] = {};\n                Object.keys( prop.props ).forEach( prop => {\n                    let prevField = fieldsRef[ name ] && fieldsRef[ name ][ prop ];\n                    let newField = constructFieldForNamedPropertyVMO( fieldName, prop );\n                    if( isFieldsEqual( prevField, newField ) ) {\n                        fields[ name ][ prop ] = prevField;\n                    } else {\n                        fields[ name ][ prop ] = newField;\n                    }\n                } );\n            } else {\n                let prevField = fieldsRef[ name ];\n                const ctxField = constructFieldForNamedProperty( fieldName, true );\n                if( isFieldsEqual( prevField, ctxField ) ) {\n                    fields[ name ] = prevField;\n                } else {\n                    fields[ name ] = ctxField;\n                }\n            }\n        } );\n    }\n};\n\nconst populateFieldsForXRT = function( dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO ) {\n    Object.keys( dataObject ).forEach( object => {\n        let obj = dataObject[ object ];\n        if( isVMOObj( obj ) && obj.type !== 'Awp0XRTObjectSetRow' ) {\n            fields[ object ] = {};\n            Object.keys( obj.props ).forEach( propName => {\n                let oldFields = fieldsRef.current;\n                let oldField = oldFields && oldFields[ object ] && oldFields[ object ][ propName ];\n                let newField = constructFieldForNamedPropertyVMO( 'objects[\\'' + object + '\\']', propName );\n                if( oldField && isFieldsEqual( oldField, newField ) ) {\n                    fields[ object ][ propName ] = oldField;\n                } else {\n                    fields[ object ][ propName ] = newField;\n                }\n            } );\n        }\n    } );\n};\n\nconst validateVMPList = function( newFieldArr, oldFieldArr ) {\n    let allEqual = true;\n    for( let itr = 0; itr < newFieldArr.length; itr++ ) {\n        let oldField = oldFieldArr && oldFieldArr[ itr ];\n        let newField = newFieldArr && newFieldArr[ itr ];\n        allEqual = oldField && isFieldsEqual( oldField, newField );\n        if( !allEqual ) {\n            break;\n        }\n    }\n    return allEqual;\n};\n\nconst populateFieldsForVMO = function( fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO ) {\n    fields[ stateName ] = {};\n    Object.keys( dataObject.props ).forEach( propName => {\n        let oldFields = fieldsRef.current;\n        let oldField = oldFields && oldFields[ stateName ] && oldFields[ stateName ][ propName ];\n        let newField = constructFieldForNamedPropertyVMO( stateName, propName );\n        if( oldField && isFieldsEqual( oldField, newField ) ) {\n            fields[ stateName ][ propName ] = oldField;\n        } else {\n            fields[ stateName ][ propName ] = newField;\n        }\n    } );\n};\n\nconst populateFieldsForVMP = function( fieldsRef, stateName, constructFieldForNamedProperty, fields ) {\n    let oldFields = fieldsRef.current;\n    let oldField = oldFields && oldFields[ stateName ];\n    let newField = constructFieldForNamedProperty( stateName );\n    if( oldField && isFieldsEqual( oldField, newField ) ) {\n        fields[ stateName ] = oldField;\n    } else {\n        fields[ stateName ] = newField;\n    }\n};\n\nexport const createAllFields = function( data,\n    atomicData,\n    declViewModelJson,\n    createFieldForAtomicData,\n    createFieldsBasedOnMetaData,\n    constructFieldForNamedPropertyVMO,\n    constructFieldArrayOfNamedProperty,\n    constructFieldForNamedProperty,\n    ctx, fieldsRef ) {\n    let fields = {};\n\n    let stateNames = Object.keys( data );\n\n    for( let index = 0; index < stateNames.length; index++ ) {\n        let stateName = stateNames[ index ];\n        let dataObject = data[ stateName ];\n        if( _.isObject( dataObject ) && !_.isFunction( dataObject ) && !stateName.startsWith( '_' ) && stateName !== 'dataProviders' ) {\n            if( stateName === 'objects' ) {\n                populateFieldsForXRT( dataObject, fields, fieldsRef, constructFieldForNamedPropertyVMO );\n            } else if( isVMPObj( dataObject ) ) {\n                populateFieldsForVMP( fieldsRef, stateName, constructFieldForNamedProperty, fields );\n            } else if( isVMOObj( dataObject ) ) {\n                populateFieldsForVMO( fields, stateName, dataObject, fieldsRef, constructFieldForNamedPropertyVMO );\n            } else if( Array.isArray( dataObject ) && checkIsListOfVMP( dataObject ) ) {\n                let oldFields = fieldsRef.current;\n                let oldFieldArr = oldFields && oldFields[ stateName ];\n                let newFieldArr = constructFieldArrayOfNamedProperty( dataObject, stateName );\n                if( validateVMPList( newFieldArr, oldFieldArr ) ) {\n                    fields[ stateName ] = oldFieldArr;\n                } else {\n                    fields[ stateName ] = newFieldArr;\n                }\n            }\n        }\n    }\n\n    populateFieldsForAtomicData( atomicData, fieldsRef, declViewModelJson, fields, createFieldsBasedOnMetaData, createFieldForAtomicData );\n\n    let ctxFields = declViewModelJson.ctxFields;\n    populateFieldForCtx( ctxFields, ctx, fields, fieldsRef, constructFieldForNamedPropertyVMO, constructFieldForNamedProperty );\n    return fields;\n};\n\nconst validateFieldData = function( oldField, newField ) {\n    if( oldField && oldField.fielddata && newField.fielddata ) {\n        if( oldField.fielddata.propertyName !== newField.fielddata.propertyName ) {\n            return false;\n        }\n        if( oldField.fielddata.propertyDisplayName !== newField.fielddata.propertyDisplayName ) {\n            return false;\n        }\n        if( oldField.fielddata.renderingHint !== newField.fielddata.renderingHint ) {\n            return false;\n        }\n\n        if( oldField.fielddata.isEnabled !== newField.fielddata.isEnabled ) {\n            return false;\n        }\n\n        if( oldField.fielddata.isEditable !== newField.fielddata.isEditable ) {\n            return false;\n        }\n\n        if( oldField.fielddata.tooltip !== newField.fielddata.tooltip ) {\n            return false;\n        }\n\n        if( oldField.fielddata.uwAnchor !== newField.fielddata.uwAnchor ) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n};\n\nexport const isFieldsEqual = ( oldField, newField ) => {\n    //TODO: Back command needs refresh -\n    //Scenarios :Export should work when we add properties and go back and export\n    //Export should work when we add properties and go back and export\n\n    if( newField.name === 'backCommand' ) {\n        return false;\n    }\n\n    let newProp = newField && newField.__vmprop__ && newField.__vmprop__();\n    let oldProp = oldField && oldField.__vmprop__ && oldField.__vmprop__();\n    if( newProp !== oldProp ) {\n        return false;\n    }\n\n    let newDataProvider = newField.fielddata && newField.fielddata.dataProvider;\n    if( newDataProvider ) {\n        return false;\n    }\n    if( oldField ) {\n        if( oldField.checked !== newField.checked ) {\n            return false;\n        }\n\n        if( oldField.value !== newField.value ) {\n            return false;\n        }\n\n        if( oldField.dirty !== newField.dirty ) {\n            return false;\n        }\n\n        if( oldField.fielddata.uiValue !== newField.fielddata.uiValue ) {\n            return false;\n        }\n\n        if( oldField.error !== newField.error ) {\n            return false;\n        }\n\n        if( oldField.required !== newField.required ) {\n            return false;\n        }\n\n        if( oldField.touched !== newField.touched ) {\n            return false;\n        }\n\n        if( oldField.disabled !== newField.disabled ) {\n            return false;\n        }\n\n        if( oldField.label !== newField.label ) {\n            return false;\n        }\n\n        if( oldField.name !== newField.name ) {\n            return false;\n        }\n\n        if( oldField.placeholder !== newField.placeholder ) {\n            return false;\n        }\n    }\n\n    return validateFieldData( oldField, newField );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}