{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/**\n * Defines the {@link NgServices.leavePlaceService}\n *\n * @module js/leavePlace.service\n */import logger from'js/logger';// => 'afx/src/kernel/src/js/logger'\nimport _ from'lodash';import eventBus from'js/eventBus';// Service\nimport AwStateService from'js/awStateService';import AwPromiseService from'js/awPromiseService';var exports={};/**\n * The currently registered handler.\n *\n * @private\n * @member _registeredAppHandler\n * @memberOf NgServices.leavePlaceService\n */let _registeredAppHandler=null;let _eventSubscriptions=[];export let reset=function(){_registeredAppHandler=null;// unsuscribe _eventSubscriptions if exists\n_eventSubscriptions.forEach(s=>{eventBus.unsubscribe(s);});_eventSubscriptions=[];};/**\n * Initialization function, sets up the transition lifecycle hooks.\n * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation\n * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will\n * trigger navigation to the original target.\n *\n * @private\n * @function initializeRootScope\n * @memberOf NgServices.leavePlaceService\n * @param {Object} $rootScope - $rootScope\n */export let loadConfiguration=function(){reset();let _persistAppHandler=false;/**\n     * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.\n     */AwStateService.instance.transitionHooks.onBefore({},transition=>{if(isLocationChangeStartEvent(transition)){return locationChangeStart(transition);}if(isStateChangeStartEvent(transition)){return stateChangeStart(transition);}});const locationChangeStart=transition=>{const defer=AwPromiseService.instance.defer();if(_registeredAppHandler&&!_persistAppHandler){let fromState=transition.from();let fromParams=transition.params('from');let toState=transition.to();let toParams=transition.params();let options=transition.options();var targetNavDetails={};targetNavDetails.toState=toState;targetNavDetails.toParams=toParams;targetNavDetails.options=options;// Functions to call after the okToLeave promise\n// okToLeaveSuccess must be set, okToLeaveFailure can be null\nlet okToLeaveSuccess;let okToLeaveFailure;okToLeaveSuccess=()=>{// navigate to the target state using the current transition instance\ntransition.router.stateService.go(targetNavDetails.toState,targetNavDetails.toParams,targetNavDetails.options);return true;};okToLeaveFailure=()=>{// Don't clear handler when the promise is rejected\nlogger.trace('Prevented navigation to ',targetNavDetails);return true;};const{targetNavInfo,oldState,newState}=getOkToLeaveInfo(fromState,fromParams,toState,toParams);// Run the okToLeave handler\nreturn _registeredAppHandler.okToLeave(targetNavInfo,oldState,newState).then(options=>{// Clear the handler\nif(options&&options.clearLeaveHandler===false){_persistAppHandler=true;}else{_registeredAppHandler=null;}return okToLeaveSuccess();},okToLeaveFailure);}defer.resolve();_persistAppHandler=false;return defer.promise;};const stateChangeStart=transition=>{const defer=AwPromiseService.instance.defer();if(_registeredAppHandler){let fromState=transition.from();let toState=transition.to();let toParams=transition.params();let options=transition.options();var targetNavDetails={};targetNavDetails.toState=toState;targetNavDetails.fromState=fromState;targetNavDetails.toParams=toParams;targetNavDetails.options=options;// invoke the handler and setup up the promise continuation\nreturn _registeredAppHandler.okToLeave(targetNavDetails).then(()=>{// clear the handler reference that ran to avoid recursion\n_registeredAppHandler=null;// navigate to the target state using the current transition instance\ntransition.router.stateService.go(targetNavDetails.toState,targetNavDetails.toParams,targetNavDetails.options);return true;},err=>{// eslint-disable-line no-unused-vars\nlogger.trace('Prevented navigation to ',targetNavDetails);return true;});}defer.resolve();return defer.promise;};const getOkToLeaveInfo=(fromState,fromParams,toState,toParams)=>{return{targetNavInfo:{},oldState:{params:fromParams,state:{name:fromState.name}},newState:{params:toParams,state:{name:toState.name}}};};};/**\n * Method used by application to create leave handler object from an api object that can perform the okToLeave check\n *\n * @function createAndRegisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} api - The object for the leave handler. Must have a method \"okToLeave\" that is called with a\n *            promise when the user attempts to change location / state.\n */export let createAndRegisterLeaveHandler=function(api){var leaveHandler={api:api};leaveHandler.okToLeave=function(){var deferred=AwPromiseService.instance.defer();this.api.okToLeave(deferred);return deferred.promise;};exports.registerLeaveHandler(leaveHandler);};/**\n * Method used for service consumer to register their handler function. Upon navigation, the \"okToLeave\" function\n * will be invoked. The function must return a promise, and when the handler logic completes the promise should be\n * resolved to allow navigation to continue or rejected to prevent the navigation.\n *\n * @function registerLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler Object function. Must have a \"okToLeave\" property which returns a\n *            promise.\n */export let registerLeaveHandler=function(handler){if(handler&&!handler.okToLeave){logger.error('Leave place handler',handler,'does not have okToLeave property');}else{_registeredAppHandler=handler;}};/**\n * Method used for deregister a given leave handler\n *\n * @function deregisterLeaveHandler\n * @memberOf NgServices.leavePlaceService\n * @param {Object} handler - The leave handler to deregister\n */export let deregisterLeaveHandler=function(handler){if(handler===_registeredAppHandler){_registeredAppHandler=null;}};export let isLocationChangeStartEvent=function(transition){if(_.isUndefined(transition)||_.isEmpty(transition)){return false;}// page refresh case\nif(transition.from().url==='^'&&transition.from().name===''){return false;}//invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params\nif(_.isEqual(transition.from().name,transition.to().name)&&!_.isEqual(transition.params('from'),transition.params('to'))){return true;}return false;};export let isStateChangeStartEvent=function(transition){if(_.isUndefined(transition)||_.isEmpty(transition)){return false;}// page refresh case\nif(transition.from().url==='^'&&transition.from().name===''){return false;}if(!_.isEqual(transition.from().name,transition.to().name)){return true;}return false;};exports={reset,loadConfiguration,createAndRegisterLeaveHandler,registerLeaveHandler,deregisterLeaveHandler,isLocationChangeStartEvent,isStateChangeStartEvent};export default exports;loadConfiguration();","map":null,"metadata":{},"sourceType":"module"}