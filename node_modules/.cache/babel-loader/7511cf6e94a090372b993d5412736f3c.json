{"ast":null,"code":"var _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s8 = $RefreshSig$();\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s4 = $RefreshSig$(); // Copyright (c) 2021 Siemens\n\n/**\n * @module js/dataProviderUtils\n */\n\n\nimport { useReducer, useEffect, useRef, useState } from 'react';\nimport _ from 'lodash';\nimport { useSelectionModel } from 'js/declSelectionModelFactory';\nimport declUtils from 'js/declUtils';\n\nconst pageReducer = (state, action) => {\n  const pageActionType = action.type;\n  let page = state.page || 0;\n\n  switch (pageActionType) {\n    case 'NEXT_PAGE':\n      page++;\n      break;\n\n    case 'PAGE_RESET':\n      page = action.page || 0;\n      break;\n\n    case 'PREVIOUS_PAGE':\n      page--;\n      break;\n\n    case 'FOCUS_PAGE':\n      if (_.has(action, page)) {\n        page = action.page;\n      }\n\n      break;\n\n    default:\n      return state;\n  }\n\n  return { ...state,\n    pageActionType,\n    page\n  };\n};\n\nconst loadVMCollection = (state, action) => {\n  let newState = { ...state\n  };\n  newState.totalFound = action.totalFound && action.totalFound !== '' ? action.totalFound : action.viewModelObjects.length;\n  newState.vmCollection.setViewModelObjects(action.viewModelObjects);\n  newState.cursor.startIndex = newState.vmCollection.loadedVMObjects.length;\n\n  if (action.hasMoreValuesExist !== null) {\n    newState.cursor.endReached = !newState.hasMoreValuesExist;\n  } else {\n    newState.cursor.endReached = newState.totalFound <= newState.cursor.startIndex;\n  }\n\n  newState.focusing = false;\n  newState.dataLoaded = true;\n  return newState;\n};\n\nconst updateVMCollection = (state, action) => {\n  let newState = { ...state\n  };\n  newState.totalFound = action.totalFound && action.totalFound !== '' ? action.totalFound : action.viewModelObjects.length;\n  newState.hasMoreValuesExist = action.hasMoreValuesExist ? action.hasMoreValuesExist : null;\n\n  if (newState.totalFound > 0) {\n    newState.vmCollection.setTotalObjectsFound(action.totalFound);\n\n    if (action.pageObject.pageActionType === 'FOCUS_PAGE' || action.pageObject.pageActionType === 'PREVIOUS_PAGE' || action.pageObject.pageActionType === 'NEXT_PAGE') {\n      newState.vmCollection.setViewModelObjects(action.viewModelObjects);\n    } else {\n      newState.vmCollection.setViewModelObjects(newState.vmCollection.getLoadedViewModelObjects().concat(action.viewModelObjects));\n    }\n  } else if (action.hasMoreValuesExist !== null) {\n    newState.vmCollection.setViewModelObjects(action.viewModelObjects); //This is a NEXT_PAGE case\n  }\n\n  if (action.cursorObject) {\n    newState.cursor = action.cursorObject;\n  } else {\n    newState.cursor.startIndex = newState.vmCollection.loadedVMObjects.length;\n\n    if (action.hasMoreValuesExist !== null) {\n      newState.cursor.endReached = !newState.hasMoreValuesExist;\n    } else {\n      newState.cursor.endReached = newState.totalFound <= newState.cursor.startIndex;\n    }\n  }\n  /**\n    * Determine if the last node in the collection is an 'incompleteTail' because we know\n    * there are more found than currently loaded.\n    */\n\n\n  if (!_.isEmpty(newState.vmCollection.loadedVMObjects) && newState.vmCollection.totalFound > newState.vmCollection.getTotalUniqueObjectsLoaded()) {\n    _.last(newState.vmCollection.loadedVMObjects).incompleteTail = true;\n  }\n\n  newState.focusing = false;\n  newState.dataLoaded = true; // set preferredChoices on state obj\n\n  newState.preferredChoices = action.preferredChoices;\n  return newState;\n};\n\nconst resetVMCollection = state => {\n  let newState = { ...state\n  };\n  newState.cursor.startIndex = 0;\n  delete newState.totalFound;\n  newState.cursor.endReached = false;\n  newState.fetching = false;\n  newState.focusing = false;\n  newState.dataLoaded = false;\n  return newState;\n};\n\nconst vmCollectionReducer = (state, action) => {\n  switch (action.type) {\n    case 'COLLECTION_UPDATE':\n      // revisitme - needs to do concat here to make sure the whole state of vmCollection\n      // is managed here, not dataProvider object\n      return updateVMCollection(state, action);\n\n    case 'COLLECTION_RESET':\n      return resetVMCollection(state);\n\n    case 'IN_PROGRESS':\n      return { ...state,\n        fetching: action.fetching\n      };\n\n    case 'FOCUSING':\n      return { ...state,\n        focusing: action.focusing\n      };\n\n    case 'COLLECTION_REPLACE':\n      return loadVMCollection(state, action);\n\n    default:\n      return state;\n  }\n};\n\nconst usePagingObserver = dataProvider => {\n  _s5();\n\n  _s();\n\n  let rootLevelRef = dataProvider.getRootReference(); // cursor hook\n\n  const [pageObject, pageDispatcher] = useReducer(pageReducer, {\n    // revisitme: move startIndex logic to here\n    page: 0\n  });\n  let containerElement;\n  let bottomAnchorElement;\n  let paginationOption = dataProvider.getPagination();\n\n  if (paginationOption) {\n    let bottomAnchorSelector = paginationOption.bottomAnchorSelector;\n    containerElement = rootLevelRef.current ? rootLevelRef.current : null;\n    bottomAnchorElement = rootLevelRef.current ? rootLevelRef.current.querySelector(bottomAnchorSelector) : null;\n  } // only trigger next page when previous REST call is done\n\n\n  const loadNextPage = () => {\n    if (!dataProvider.vmCollectionObj.fetching) {\n      pageDispatcher({\n        type: 'NEXT_PAGE'\n      });\n    }\n  };\n\n  let observer = useRef(null);\n  useEffect(() => {\n    // intersection observer needs both the container and the anchor element to work properly.\n    if (bottomAnchorElement && containerElement) {\n      const interSectionWatcher = entries => {\n        entries.forEach(en => {\n          if (en.intersectionRatio > 0) {\n            loadNextPage();\n          }\n        });\n      };\n\n      let options = {\n        root: containerElement,\n        rootMargin: '5px',\n        threshold: 1\n      };\n      observer.current = new IntersectionObserver(interSectionWatcher, options);\n      observer.current.observe(bottomAnchorElement);\n    }\n\n    return () => {\n      //zarq9k: need to destroy the observer to prevent leakage.\n      if (observer.current) {\n        observer.current.disconnect();\n      }\n    };\n  }, [containerElement, bottomAnchorElement, rootLevelRef]); // if containerElement has no scroll yet, then we should auto load next page until scroll happened or endReached\n\n  useEffect(() => {\n    if (dataProvider.vmCollectionObj.cursor.endReached) {\n      return undefined;\n    }\n\n    if (containerElement && containerElement.clientHeight > 0 && containerElement.scrollHeight <= containerElement.clientHeight) {\n      loadNextPage();\n    }\n\n    return undefined;\n  }, [pageObject.page]); // , dataProvider.vmCollectionObj\n\n  return {\n    pageObject,\n    pageDispatcher\n  };\n};\n\n_s5(usePagingObserver, \"Y8Lt6RO8lM5sZ4hCiYthr02+lFc=\");\n\n_s(usePagingObserver, \"I8BLwVyWOOSqvtCVR0fCdzuCw70=\");\n\nexport const useDataProvider = (dataProvider, getProps, dataCtxNode) => {\n  _s6();\n\n  _s2();\n\n  const topLevelRef = useRef(null); // attaching a ref to each dataProvider, so that we can pass it to list.\n\n  dataProvider.setRootReference(topLevelRef);\n  const {\n    pageObject,\n    pageDispatcher\n  } = usePagingObserver(dataProvider);\n  const [vmCollectionObj, vmCollectionDispatcher] = useReducer(vmCollectionReducer, {\n    vmCollection: dataProvider.viewModelCollection,\n    totalFound: 0,\n    hasMoreValuesExist: null,\n    fetching: false,\n    dataLoaded: false,\n    preferredChoices: [],\n    cursor: {\n      startIndex: 0,\n      startReached: false,\n      endIndex: 0,\n      endReached: true\n    }\n  });\n\n  if (dataProvider.inputDataExpressions && dataProvider.inputDataExpressions.length > 0) {\n    updateInputDataOnDP(dataProvider, dataCtxNode);\n  }\n\n  dataProvider.setPropsCallback(getProps);\n  let inputSelectionModel = null;\n\n  if (dataProvider.json.inputData && dataProvider.json.inputData.selectionModel) {\n    inputSelectionModel = dataProvider.json.inputData.selectionModel;\n  }\n\n  const dataProviderJson = _.get(dataProvider, 'json');\n\n  const mode = dataProviderJson ? dataProviderJson.selectionModelMode : null;\n  const uwSelectionModel = useSelectionModel(mode, null, inputSelectionModel);\n\n  if (dataProvider.json.inputData && dataProvider.json.inputData.selectionData) {\n    uwSelectionModel.selectionData = dataProvider.json.inputData.selectionData;\n  }\n\n  const validSourceTypes = dataProvider.json.inputData ? dataProvider.json.inputData.validSourceTypes : null;\n\n  if (_.get(dataProvider, 'setValidSourceTypes')) {\n    dataProvider.setValidSourceTypes(validSourceTypes);\n  }\n\n  if (_.get(dataProvider, 'setSelectionModel')) {\n    dataProvider.setSelectionModel({\n      selectionModel: uwSelectionModel\n    });\n  }\n\n  if (_.get(dataProvider, 'setDataUpdater')) {\n    dataProvider.setDataUpdater(pageDispatcher, vmCollectionDispatcher);\n  }\n\n  useEffect(() => {\n    //Adding 'inputSelectionModel' check to limit registration of dp listener only for pwa usecase\n    //This can be removed if more such usecases are encountered\n    if (inputSelectionModel && inputSelectionModel.selectionData) {\n      uwSelectionModel.addRemoveDpListener && uwSelectionModel.addRemoveDpListener('add', dataProvider);\n    }\n\n    return () => {\n      uwSelectionModel.addRemoveDpListener('remove');\n    };\n  }, []);\n  useEffect(() => {\n    const totalFound = dataProvider.viewModelCollection.getTotalObjectsFound();\n    const totalUniqueLoaded = dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded(); // revisitme - use this cursor in loadAction instead of using internal dataProvider.startIndex\n    //if( startIndex.current === 0 || startIndex.current < totalFound.current ) {\n\n    if (!vmCollectionObj.fetching && (!vmCollectionObj.cursor.endReached || vmCollectionObj.focusing === true || totalFound > totalUniqueLoaded)) {\n      vmCollectionDispatcher({\n        type: 'IN_PROGRESS',\n        fetching: true\n      });\n      dataProvider.loadAction(vmCollectionObj.vmCollection, vmCollectionObj.cursor.startIndex, pageObject);\n    }\n  }, [dataProvider, pageObject, pageDispatcher]); //DO not consider current selection until the data is available\n\n  let currentSelection = vmCollectionObj.dataLoaded ? uwSelectionModel.getSelection() : null;\n  useEffect(() => {\n    //sync the selectionModel only if there is data\n    //if there is no data this is a redundant operation\n    if (_.get(dataProvider, 'syncSelectionModel') && vmCollectionObj.dataLoaded) {\n      dataProvider.syncSelectionModel({\n        data: {}\n      }, currentSelection, uwSelectionModel.getLastSelection());\n    }\n  }, [currentSelection, dataProvider]);\n  return {\n    vmCollectionObj\n  };\n};\n\n_s6(useDataProvider, \"kOauQH/4divGr2DbHLcu5cKeWLE=\", false, function () {\n  return [usePagingObserver, useSelectionModel];\n});\n\n_s2(useDataProvider, \"9wN2fGWJOIASPu7G1HDf51y5c6Q=\", false, function () {\n  return [usePagingObserver, useSelectionModel];\n});\n\nconst updateInputDataOnDP = (dataProvider, dataCtxNode) => {\n  let context = declUtils.getLatestContext(dataCtxNode, dataCtxNode.data);\n  dataProvider.inputDataExpressions.map(observer => {\n    dataProvider.json.inputData[Object.keys(observer)[0]] = _.get(context, Object.values(observer)[0]);\n  });\n};\n\nexport const useDataProviders = (dataProviders, getProps, dataCtxNode) => {\n  _s8();\n\n  var _s7 = $RefreshSig$();\n\n  _s4();\n\n  var _s3 = $RefreshSig$(); // Just to make sure the dp name order is same in every render.\n\n\n  const [dataProviderNames] = useState(() => {\n    return !_.isNil(dataProviders) ? Object.keys(dataProviders) : [];\n  }); //dataProviderNames order will never change between render cycles, hence disabling the eslint\n  //https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function\n  // zarq9k: any better solution ?\n\n  _s7(_s3(_s7(dataProviderNames.forEach(_s7(_s3(_s7(dpName => {\n    _s7();\n\n    _s3(); // zarq9k: once we sink up new and old vmCollectionObj, dataProviders[ dpName ].vmCollectionObj would not be required\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n\n    dataProviders[dpName].vmCollectionObj = useDataProvider(dataProviders[dpName], getProps, dataCtxNode).vmCollectionObj;\n  }, \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  }), \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  }), \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  })), \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  }), \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  }), \"nu9PXk7WJrRufYwKU+ypnZZwDdU=\", false, function () {\n    return [useDataProvider];\n  });\n\n  return {};\n};\n\n_s8(useDataProviders, \"gMI6PkyTOPjzC0Izu1PL80h44aY=\");\n\n_s4(useDataProviders, \"rdVHknqRArEQl3un20OJKNL5zKY=\");","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/dataProviderUtils.js"],"names":["pageReducer","pageActionType","action","page","state","_","loadVMCollection","newState","updateVMCollection","resetVMCollection","vmCollectionReducer","fetching","focusing","usePagingObserver","dataProvider","rootLevelRef","useReducer","paginationOption","bottomAnchorSelector","containerElement","bottomAnchorElement","loadNextPage","pageDispatcher","type","observer","useRef","useEffect","interSectionWatcher","entries","en","options","root","rootMargin","threshold","pageObject","useDataProvider","topLevelRef","vmCollection","totalFound","hasMoreValuesExist","dataLoaded","preferredChoices","cursor","startIndex","startReached","endIndex","endReached","updateInputDataOnDP","inputSelectionModel","dataProviderJson","mode","uwSelectionModel","useSelectionModel","validSourceTypes","selectionModel","totalUniqueLoaded","vmCollectionObj","vmCollectionDispatcher","currentSelection","data","context","declUtils","dataCtxNode","Object","useDataProviders","useState","dpName","dataProviders"],"mappings":"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","sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/dataProviderUtils\n */\nimport { useReducer, useEffect, useRef, useState } from 'react';\nimport _ from 'lodash';\nimport { useSelectionModel } from 'js/declSelectionModelFactory';\nimport declUtils from 'js/declUtils';\n\nconst pageReducer = ( state, action ) => {\n    const pageActionType = action.type;\n    let page = state.page || 0;\n\n    switch ( pageActionType ) {\n        case 'NEXT_PAGE':\n            page++;\n            break;\n        case 'PAGE_RESET':\n            page = action.page || 0;\n            break;\n        case 'PREVIOUS_PAGE':\n            page--;\n            break;\n        case 'FOCUS_PAGE':\n            if( _.has( action, page ) ) {\n                page = action.page;\n            }\n            break;\n        default:\n            return state;\n    }\n\n    return { ...state, pageActionType, page };\n};\n\nconst loadVMCollection = ( state, action ) => {\n    let newState = { ...state };\n    newState.totalFound = action.totalFound && action.totalFound !== '' ? action.totalFound : action.viewModelObjects.length;\n    newState.vmCollection.setViewModelObjects( action.viewModelObjects );\n    newState.cursor.startIndex = newState.vmCollection.loadedVMObjects.length;\n    if( action.hasMoreValuesExist !== null ) {\n        newState.cursor.endReached = !newState.hasMoreValuesExist;\n    } else {\n        newState.cursor.endReached = newState.totalFound <= newState.cursor.startIndex;\n    }\n    newState.focusing = false;\n    newState.dataLoaded = true;\n    return newState;\n};\n\nconst updateVMCollection = ( state, action ) => {\n    let newState = { ...state };\n    newState.totalFound = action.totalFound && action.totalFound !== '' ? action.totalFound : action.viewModelObjects.length;\n    newState.hasMoreValuesExist = action.hasMoreValuesExist ? action.hasMoreValuesExist : null;\n    if( newState.totalFound > 0 ) {\n        newState.vmCollection.setTotalObjectsFound( action.totalFound );\n        if( action.pageObject.pageActionType === 'FOCUS_PAGE' || action.pageObject.pageActionType === 'PREVIOUS_PAGE' || action.pageObject.pageActionType === 'NEXT_PAGE' ) {\n            newState.vmCollection.setViewModelObjects( action.viewModelObjects );\n        } else {\n            newState.vmCollection.setViewModelObjects( newState.vmCollection.getLoadedViewModelObjects().concat( action.viewModelObjects ) );\n        }\n    } else if( action.hasMoreValuesExist !== null ) {\n        newState.vmCollection.setViewModelObjects( action.viewModelObjects ); //This is a NEXT_PAGE case\n    }\n    if( action.cursorObject ) {\n        newState.cursor = action.cursorObject;\n    } else {\n        newState.cursor.startIndex = newState.vmCollection.loadedVMObjects.length;\n        if( action.hasMoreValuesExist !== null ) {\n            newState.cursor.endReached = !newState.hasMoreValuesExist;\n        } else {\n            newState.cursor.endReached = newState.totalFound <= newState.cursor.startIndex;\n        }\n    }\n    /**\n      * Determine if the last node in the collection is an 'incompleteTail' because we know\n      * there are more found than currently loaded.\n      */\n    if( !_.isEmpty( newState.vmCollection.loadedVMObjects ) &&\n         newState.vmCollection.totalFound > newState.vmCollection.getTotalUniqueObjectsLoaded() ) {\n        _.last( newState.vmCollection.loadedVMObjects ).incompleteTail = true;\n    }\n    newState.focusing = false;\n    newState.dataLoaded = true;\n\n    // set preferredChoices on state obj\n    newState.preferredChoices = action.preferredChoices;\n\n    return newState;\n};\n\nconst resetVMCollection = ( state ) => {\n    let newState = { ...state };\n    newState.cursor.startIndex = 0;\n    delete newState.totalFound;\n    newState.cursor.endReached = false;\n    newState.fetching = false;\n    newState.focusing = false;\n    newState.dataLoaded = false;\n\n    return newState;\n};\n\nconst vmCollectionReducer = ( state, action ) => {\n    switch ( action.type ) {\n        case 'COLLECTION_UPDATE':\n            // revisitme - needs to do concat here to make sure the whole state of vmCollection\n            // is managed here, not dataProvider object\n            return updateVMCollection( state, action );\n\n        case 'COLLECTION_RESET':\n            return resetVMCollection( state );\n\n        case 'IN_PROGRESS':\n            return { ...state, fetching: action.fetching };\n\n        case 'FOCUSING':\n            return { ...state, focusing: action.focusing };\n        case 'COLLECTION_REPLACE':\n            return loadVMCollection( state, action );\n\n        default:\n            return state;\n    }\n};\n\nconst usePagingObserver = ( dataProvider ) => {\n    let rootLevelRef = dataProvider.getRootReference();\n    // cursor hook\n    const [ pageObject, pageDispatcher ] = useReducer( pageReducer, {\n        // revisitme: move startIndex logic to here\n        page: 0\n    } );\n\n    let containerElement;\n    let bottomAnchorElement;\n    let paginationOption = dataProvider.getPagination();\n\n    if( paginationOption ) {\n        let bottomAnchorSelector = paginationOption.bottomAnchorSelector;\n        containerElement = rootLevelRef.current ? rootLevelRef.current : null;\n        bottomAnchorElement = rootLevelRef.current ? rootLevelRef.current.querySelector( bottomAnchorSelector ) : null;\n    }\n\n    // only trigger next page when previous REST call is done\n    const loadNextPage = () => {\n        if( !dataProvider.vmCollectionObj.fetching ) {\n            pageDispatcher( { type: 'NEXT_PAGE' } );\n        }\n    };\n    let observer = useRef( null );\n    useEffect( () => {\n        // intersection observer needs both the container and the anchor element to work properly.\n        if( bottomAnchorElement && containerElement ) {\n            const interSectionWatcher = ( entries ) => {\n                entries.forEach( en => {\n                    if( en.intersectionRatio > 0 ) {\n                        loadNextPage();\n                    }\n                } );\n            };\n            let options = {\n                root: containerElement,\n                rootMargin: '5px',\n                threshold: 1\n            };\n            observer.current = new IntersectionObserver( interSectionWatcher, options );\n            observer.current.observe( bottomAnchorElement );\n        }\n\n        return () => {\n            //zarq9k: need to destroy the observer to prevent leakage.\n            if( observer.current ) {\n                observer.current.disconnect();\n            }\n        };\n    }, [ containerElement, bottomAnchorElement, rootLevelRef ] );\n\n    // if containerElement has no scroll yet, then we should auto load next page until scroll happened or endReached\n    useEffect( () => {\n        if( dataProvider.vmCollectionObj.cursor.endReached ) {\n            return undefined;\n        }\n\n        if( containerElement && containerElement.clientHeight > 0 && containerElement.scrollHeight <= containerElement.clientHeight ) {\n            loadNextPage();\n        }\n        return undefined;\n    }, [ pageObject.page ] );\n    // , dataProvider.vmCollectionObj\n\n    return {\n        pageObject,\n        pageDispatcher\n    };\n};\n\nexport const useDataProvider = ( dataProvider, getProps, dataCtxNode ) => {\n    const topLevelRef = useRef( null );\n    // attaching a ref to each dataProvider, so that we can pass it to list.\n    dataProvider.setRootReference( topLevelRef );\n    const { pageObject, pageDispatcher } = usePagingObserver( dataProvider );\n    const [ vmCollectionObj, vmCollectionDispatcher ] = useReducer( vmCollectionReducer, {\n        vmCollection: dataProvider.viewModelCollection,\n        totalFound: 0,\n        hasMoreValuesExist: null,\n        fetching: false,\n        dataLoaded: false,\n        preferredChoices: [],\n        cursor: {\n            startIndex: 0,\n            startReached: false,\n            endIndex: 0,\n            endReached: true\n        }\n    } );\n\n    if( dataProvider.inputDataExpressions && dataProvider.inputDataExpressions.length > 0 ) {\n        updateInputDataOnDP( dataProvider, dataCtxNode );\n    }\n\n    dataProvider.setPropsCallback( getProps );\n    let inputSelectionModel = null;\n    if( dataProvider.json.inputData && dataProvider.json.inputData.selectionModel ) {\n        inputSelectionModel = dataProvider.json.inputData.selectionModel;\n    }\n    const dataProviderJson = _.get( dataProvider, 'json' );\n    const mode = dataProviderJson ? dataProviderJson.selectionModelMode : null;\n    const uwSelectionModel = useSelectionModel( mode, null, inputSelectionModel );\n\n    if( dataProvider.json.inputData && dataProvider.json.inputData.selectionData ) {\n        uwSelectionModel.selectionData = dataProvider.json.inputData.selectionData;\n    }\n\n    const validSourceTypes = dataProvider.json.inputData ? dataProvider.json.inputData.validSourceTypes : null;\n    if( _.get( dataProvider, 'setValidSourceTypes' ) ) {\n        dataProvider.setValidSourceTypes( validSourceTypes );\n    }\n    if( _.get( dataProvider, 'setSelectionModel' ) ) {\n        dataProvider.setSelectionModel( { selectionModel: uwSelectionModel } );\n    }\n    if( _.get( dataProvider, 'setDataUpdater' ) ) {\n        dataProvider.setDataUpdater( pageDispatcher, vmCollectionDispatcher );\n    }\n\n    useEffect( () => {\n        //Adding 'inputSelectionModel' check to limit registration of dp listener only for pwa usecase\n        //This can be removed if more such usecases are encountered\n        if( inputSelectionModel && inputSelectionModel.selectionData ) {\n            uwSelectionModel.addRemoveDpListener && uwSelectionModel.addRemoveDpListener( 'add', dataProvider );\n        }\n        return () => {\n            uwSelectionModel.addRemoveDpListener( 'remove' );\n        };\n    }, [] );\n\n    useEffect( () => {\n        const totalFound = dataProvider.viewModelCollection.getTotalObjectsFound();\n        const totalUniqueLoaded = dataProvider.viewModelCollection.getTotalUniqueObjectsLoaded();\n        // revisitme - use this cursor in loadAction instead of using internal dataProvider.startIndex\n        //if( startIndex.current === 0 || startIndex.current < totalFound.current ) {\n        if( !vmCollectionObj.fetching && ( !vmCollectionObj.cursor.endReached || vmCollectionObj.focusing === true || totalFound >\n                 totalUniqueLoaded ) ) {\n            vmCollectionDispatcher( { type: 'IN_PROGRESS', fetching: true } );\n            dataProvider.loadAction( vmCollectionObj.vmCollection, vmCollectionObj.cursor.startIndex, pageObject );\n        }\n    }, [ dataProvider, pageObject, pageDispatcher ] );\n\n    //DO not consider current selection until the data is available\n    let currentSelection = vmCollectionObj.dataLoaded ? uwSelectionModel.getSelection() : null;\n    useEffect( () => {\n        //sync the selectionModel only if there is data\n        //if there is no data this is a redundant operation\n        if( _.get( dataProvider, 'syncSelectionModel' ) && vmCollectionObj.dataLoaded ) {\n            dataProvider.syncSelectionModel( { data: {} }, currentSelection, uwSelectionModel.getLastSelection() );\n        }\n    }, [ currentSelection, dataProvider ] );\n\n    return {\n        vmCollectionObj\n    };\n};\n\nconst updateInputDataOnDP = ( dataProvider, dataCtxNode ) => {\n    let context = declUtils.getLatestContext( dataCtxNode, dataCtxNode.data );\n    dataProvider.inputDataExpressions.map( observer => {\n        dataProvider.json.inputData[ Object.keys( observer )[ 0 ] ] = _.get( context, Object.values( observer )[ 0 ] );\n    } );\n};\n\nexport const useDataProviders = ( dataProviders, getProps, dataCtxNode ) => {\n    // Just to make sure the dp name order is same in every render.\n    const [ dataProviderNames ] = useState( () => {\n        return !_.isNil( dataProviders ) ? Object.keys( dataProviders ) : [];\n    } );\n    //dataProviderNames order will never change between render cycles, hence disabling the eslint\n    //https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function\n    // zarq9k: any better solution ?\n    dataProviderNames.forEach( ( dpName ) => {\n        // zarq9k: once we sink up new and old vmCollectionObj, dataProviders[ dpName ].vmCollectionObj would not be required\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        dataProviders[ dpName ].vmCollectionObj = useDataProvider( dataProviders[ dpName ], getProps, dataCtxNode ).vmCollectionObj;\n    } );\n    return {};\n};\n"]},"metadata":{},"sourceType":"module"}