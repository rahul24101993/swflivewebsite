{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* global afxDynamicImport afxWeakImport */\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/declUtils\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n/** revisitme Shaishav\n * Hint: We need to integrate with appCtxService\nimport appCtxSvc from 'js/appCtxService';\n*/\n\nimport parsingUtils from 'js/parsingUtils';\nimport browserUtils from 'js/browserUtils';\nimport appCtxSvc from 'js/appCtxService'; // Service\n\nimport AwParseService from 'js/awParseService';\nvar exports = {};\nvar MSG_1 = 'Required DeclViewModel not specified';\nvar MSG_PREFIX_1 = 'Invalid to process with destroyed DeclViewModel: ';\nvar MSG_PREFIX_2 = 'Invalid to process with destroyed DataContextNode: ';\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\n\nvar _actionPropsToLog = ['actionId', 'actionType', 'method', 'serviceName', 'deps', 'steps'];\n/**\n * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's\n * URL.\n */\n\nvar _debug_logLifeCycleIssues = browserUtils.getUrlAttributes().logLifeCycleIssues !== undefined;\n/**\n * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid\n * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema\n * checker).\n */\n\n\nexport let attrHolderPropName = ['dbValue', 'displayName', 'dispValue', 'isArray', 'isEditable', 'isRequired', 'isEnabled', 'displayValue', 'value', 'isModifiable', 'isAutoAssign', 'isAutoAssignable', 'labelPosition', 'requiredText', 'type', 'propName', 'hasLov', 'dataProvider', 'isSelectOnly', 'isRichText', 'referenceTypeName', 'maxLength', 'maxArraySize', 'renderingHint', 'autofocus', 'propertyDisplayName', 'patterns', 'preferredPattern', 'patternAutoAssignFlags', 'condition', 'validationCriteria', 'oldValue', 'oldValues', 'vertical', 'propertyRadioTrueText', 'propertyRadioFalseText', 'numberOfLines', 'iconName'];\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\n\nexport const loadDependentModule = depModule => {\n  return moduleLoader.loadDependentModule(depModule);\n};\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\n\nexport let buildLifeCycleIssueMessage = function (declViewModel, action, consequence, methodName) {\n  var errorMsg = 'Attempted processing after an associated DeclViewModel was destroyed...';\n\n  if (consequence) {\n    errorMsg += '\\n';\n    errorMsg += consequence;\n  }\n\n  if (declViewModel) {\n    errorMsg += '\\n';\n    errorMsg += 'DeclViewModel: ';\n    errorMsg += declViewModel;\n  }\n\n  if (methodName) {\n    errorMsg += '\\n';\n    errorMsg += 'Method: ';\n    errorMsg += methodName;\n  }\n\n  if (action) {\n    errorMsg += '\\n';\n    errorMsg += 'Action:';\n    errorMsg += '\\n';\n    errorMsg += JSON.stringify(action, _actionPropsToLog, 2);\n  }\n\n  return errorMsg;\n};\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\n\nexport let logLifeCycleIssue = function (declViewModel, action, consequence, methodName) {\n  var errorMsg = exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName);\n\n  if (_debug_logLifeCycleIssues) {\n    logger.warn(errorMsg);\n  }\n\n  return errorMsg;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\n\nexport let assertValidModel = function (declViewModel) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n};\n/**\n * Clone scope without copying angular scope's internal properties.\n *\n * @param {Object} scope - Object to clone.\n *\n * @return {Object} an object that holds data from provided Object\n */\n\nexport let cloneData = function (scope) {\n  var object = {};\n\n  _.forOwn(scope, function (value, key) {\n    if (!_.startsWith(key, '$')) {\n      object[key] = value;\n    }\n  });\n\n  return object;\n};\n/**\n * update data for fileData\n *\n * @param {Object} fileData - key string value the location of the file\n * @param {Object} data the view model data object\n */\n\n/** revisitme Shaishav\n * Hint: We need a jquery free solution here\nexport let updateFormData = function( fileData, data ) {\n    if( fileData && fileData.value ) {\n        var form = $( '#fileUploadForm' );\n        data.formData = new FormData( $( form )[ 0 ] );\n        data.formData.append( fileData.key, fileData.value );\n    }\n};\n*/\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\n\nexport let assertValidModelWithOriginalJSON = function (declViewModel) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  assert(declViewModel._internal.origDeclViewModelJson, 'Required DeclViewModel JSON object not specified');\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n */\n\nexport let assertValidModelAndDataCtxNode = function (declViewModel, dataCtxNode) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + ' DeclViewModel=' + declViewModel);\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\n\nexport let isValidModelAndDataCtxNode = function (declViewModel, dataCtxNode) {\n  if (!declViewModel) {\n    if (_debug_logLifeCycleIssues) {\n      logger.warn(MSG_1);\n    }\n\n    return false;\n  }\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    exports.logLifeCycleIssue(declViewModel, null, null, 'isValidModelAndDataCtxNode');\n    return false;\n  }\n\n  if (!declViewModel.isUnmounting && dataCtxNode && dataCtxNode.$$destroyed) {\n    if (_debug_logLifeCycleIssues) {\n      logger.warn(MSG_PREFIX_2 + dataCtxNode.$id + ' DeclViewModel=' + declViewModel);\n    }\n\n    return false;\n  }\n\n  return true;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n * @param {DeclAction} action - The declAction object to test.\n */\n\nexport let assertValidModelDataCtxNodeAndAction = function (declViewModel, dataCtxNode, action) {\n  assert(declViewModel, MSG_1);\n\n  if (declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel + ' actionType: ' + action.actionType + ' method: ' + action.method + ' deps: ' + action.deps);\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + ' DeclViewModel=' + declViewModel + ' actionType: ' + action.actionType + ' method: ' + action.method + ' deps: ' + action.deps);\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @param {DeclAction} action - The declAction object to test.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n */\n\nexport let assertValidModelDataCtxNodeAndAction2 = function (declViewModel, dataCtxNode, action, consequence, methodName) {\n  assert(declViewModel, MSG_1);\n\n  if (declViewModel._internal.isDestroyed) {\n    assert(false, exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName));\n  }\n\n  if (!declViewModel.isUnmounting && (!dataCtxNode || dataCtxNode.$$destroyed)) {\n    assert(false, MSG_PREFIX_2 + (dataCtxNode ? dataCtxNode.$id : '???') + exports.buildLifeCycleIssueMessage(declViewModel, action, consequence, methodName));\n  }\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n */\n\nexport let assertValidModelAndEventData = function (declViewModel, eventData) {\n  assert(declViewModel, MSG_1);\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    assert(false, MSG_PREFIX_1 + declViewModel);\n  }\n\n  if (eventData && eventData.scope && eventData.scope.$$destroyed) {\n    assert(false, MSG_PREFIX_2 + (eventData.scope ? eventData.scope.$id : '???') + ' DeclViewModel=' + declViewModel);\n  }\n};\n/**\n * Evaluate message with its parameters\n *\n * @param {String} messageString - The message String.\n *\n * @param {String} messageParams - The message parameters.\n *\n * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to\n *            search within.\n *\n * @return {String} Result string after applying passed parameters.\n */\n\nexport let applyMessageParams = function (messageString, messageParams, messageContext) {\n  var placeHolders = messageString.match(/\\{[0-9]*\\}/g);\n  var resultString = messageString;\n\n  if (placeHolders && messageParams) {\n    for (var i in placeHolders) {\n      if (placeHolders.hasOwnProperty(i)) {\n        var placeHolder = placeHolders[i];\n        var index = placeHolder;\n        index = _.trimStart(index, '{');\n        index = _.trimEnd(index, '}');\n        var key = parsingUtils.getStringBetweenDoubleMustaches(messageParams[index]);\n\n        var replacementString = _.get(messageContext, key);\n\n        resultString = resultString.replace(placeHolder, replacementString);\n      }\n    }\n  }\n\n  return resultString;\n};\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\n\nexport let isValidModelAndEventData = function (declViewModel, eventData) {\n  if (!declViewModel) {\n    logger.warn(MSG_1);\n    return false;\n  }\n\n  if (!declViewModel._internal || declViewModel._internal.isDestroyed) {\n    logger.warn(MSG_PREFIX_1 + declViewModel);\n    return false;\n  }\n\n  if (eventData && eventData.scope && eventData.scope.$$destroyed) {\n    logger.warn(MSG_PREFIX_2 + (eventData.scope ? eventData.scope.$id : '???') + ' DeclViewModel=' + declViewModel);\n    return false;\n  }\n\n  return true;\n};\n/**\n * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was\n * started.\n * <P>\n * If so: Use the dataCtxNode the DeclViewModel was originally created on.\n * <P>\n * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the\n * event was processed.\n *\n * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check\n * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.\n *\n * @returns {Object} The dataCtxNode object to use.\n */\n\nexport let resolveLocalDataCtx = function (declViewModel, dataCtxNode) {\n  if (dataCtxNode.$$destroyed) {\n    return declViewModel._internal.origCtxNode;\n  }\n\n  return dataCtxNode;\n};\n/**\n * Return true if provided value is 'nil' (i.e. not null or undefined).\n *\n * @param {Object} value - The value to test.\n *\n * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).\n */\n\nexport let isNil = function (value) {\n  return value === undefined || value === null;\n};\n/**\n * Return a empty function\n *\n * @returns {null} null\n */\n\nexport const noop = () => null;\n/**\n * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given\n * 'dataCtxNode'.\n *\n * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the\n *            lookup of the 'declViewModel'.\n *\n * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as\n *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.\n *\n * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is\n *            TRUE.\n *\n * @return {DeclViewModel} The 'declViewModel' found.\n */\n\nexport let findViewModel = function (dataCtxNode, setInScope) {\n  /**\n   * Check for the case where the declViewModel is already set on the given node.\n   */\n  if (dataCtxNode.data) {\n    /** revisitme\n    if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {\n        dataCtxNode.ctx = appCtxSvc.ctx;\n    }\n    */\n    return dataCtxNode.data;\n  }\n  /**\n   * Look for the model on a 'parent' node.\n   */\n\n\n  var currCtxNode = dataCtxNode;\n\n  while (currCtxNode && !currCtxNode.data) {\n    currCtxNode = currCtxNode.$parent;\n  }\n\n  if (currCtxNode) {\n    if (setInScope) {\n      dataCtxNode.data = currCtxNode.data;\n      /** revisitme\n      if( appCtxSvc ) {\n          dataCtxNode.ctx = appCtxSvc.ctx;\n      }\n      */\n      //if subPanelContext is available on scope then add it dataCtxNode\n\n      if (currCtxNode.subPanelContext) {\n        dataCtxNode.subPanelContext = currCtxNode.subPanelContext;\n      }\n      /**\n       * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.\n       */\n\n\n      if (dataCtxNode.$on) {\n        dataCtxNode.$on('$destroy', function (data) {\n          data.currentScope.data = null;\n          data.currentScope.ctx = null;\n        });\n      }\n    }\n\n    return currCtxNode.data;\n  }\n\n  return null;\n};\n/**\n * Consolidate the second object's properties into the first one\n *\n * @param {Object} targetObj - The 'target' object to merge to\n * @param {Object} sourceObj - The 'source' object to be merge from\n *\n * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.\n */\n\nexport let consolidateObjects = function (targetObj, sourceObj) {\n  var returnObj = null;\n\n  if (targetObj) {\n    returnObj = targetObj;\n\n    _.forEach(sourceObj, function (n, key) {\n      returnObj[key] = n;\n    });\n  } else if (sourceObj) {\n    returnObj = sourceObj;\n  }\n\n  return returnObj;\n};\n/**\n * Create custom event. Mainly for IE\n *\n * @param {String} eventName - Name of the event\n *\n * @param {Object} eventDetail - Object for event detail\n\n * @param {Object} canBubble -is bubble is up/down\n\n * @param {Object} isCancellable - event can ne canclable or not\n *\n * @return {DOMElement} created DOMElement\n */\n\nexport let createCustomEvent = function (eventName, eventDetail, canBubble, isCancellable) {\n  if (browserUtils.isNonEdgeIE) {\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(eventName, canBubble, isCancellable, eventDetail);\n    return evt;\n  }\n\n  return new CustomEvent(eventName, {\n    detail: eventDetail,\n    bubbles: canBubble\n  });\n};\n/**\n * process output data\n * @param {JSON} outputData output data definition\n * @param {object} result function result\n * @returns {object} data patch as:\n * {\n *     \"ctx.b\": 3,\n *     \"data.c\": 5\n * }\n */\n\nexport const processOutputData = (outputData, result) => {\n  if (outputData) {\n    const value = {};\n\n    for (let vmPath in outputData) {\n      let valPath = outputData[vmPath];\n      let res = undefined;\n\n      if (_.isBoolean(valPath)) {\n        res = valPath;\n      } else {\n        var expression = parsingUtils.getStringBetweenDoubleMustaches(valPath);\n\n        if (_.startsWith(expression, 'json:')) {\n          var jsonStringVariable = expression.replace('json:', '');\n\n          var jsonString = _.get(result, jsonStringVariable);\n\n          res = parsingUtils.parseJsonString(jsonString);\n        } else {\n          res = valPath && valPath.length > 0 ? _.get(result, valPath) : result;\n        }\n      } // TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'\n\n\n      value[/^ctx\\./.test(vmPath) ? vmPath : `data.${vmPath}`] = res;\n    }\n\n    return value;\n  }\n\n  return undefined;\n};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}\n * @param {Object} evaluationEnv - the data environment for expression evaluation\n * evaluation\n *\n * @return {Boolean} the evaluated condition result\n */\n\nexport let evaluateCondition = function (declViewModel, expression, evaluationEnv) {\n  let parse = AwParseService.instance;\n  return parse(expression)(evaluationEnv);\n};\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} condition name of condition\n *\n * @return {String} the evaluated condition result\n */\n\nexport let getConditionExpression = function (declViewModel, condition) {\n  var conditionExpression = null;\n\n  if (_.startsWith(condition, 'conditions.')) {\n    var conditionObject = _.get(declViewModel._internal, condition);\n\n    conditionExpression = conditionObject.expression;\n  } else {\n    conditionExpression = condition;\n  }\n\n  return conditionExpression;\n};\n/**\n * Evaluate condition name\n *\n * @param {String} conditionString name of condition\n *\n * @return {String} the evaluated condition result\n */\n\nexport let getConditionName = function (conditionString) {\n  if (_.startsWith(conditionString, 'conditions.')) {\n    var index = conditionString.indexOf('.');\n    return conditionString.substr(index + 1);\n  }\n\n  return null;\n};\n/**\n * Get dirty properties of the view model object\n *\n * @param {Object} vmo - the view model object\n *\n * @return {Array} the dirty properties of the view model object\n */\n\nexport let getAllModifiedValues = function (vmo) {\n  var modifiedProperties = [];\n\n  if (vmo) {\n    modifiedProperties = vmo.getDirtyProps();\n  }\n\n  return modifiedProperties;\n};\n/**\n * Update the properties of the view model property with new values\n *\n * @param {Object} dataObject - view model object.\n * @param {Object} dataProperty - view model object property.\n * @param {Object} dataPropertyValue - view model object property value.\n */\n\nexport let updatePropertyValues = function (dataObject, dataProperty, dataPropertyValue) {\n  dataObject[dataProperty] = dataPropertyValue;\n  return {\n    data: { ...dataObject\n    }\n  };\n};\n/**\n * get type hierarchy from modleObject or view model Object\n *\n * @param {Object} dataObject - view model object.\n *\n *  @return {Array} - hierarchy of model object names\n\n */\n\nexport let getTypeHierarchy = function (dataObject) {\n  return dataObject.typeHierarchy || dataObject.modelType && dataObject.modelType.typeHierarchyArray;\n};\n/**\n *  get functions used in action input/output data\n */\n\nlet getActionDataFunc = function (value, functionsUsedInActions) {\n  if (typeof value === 'string') {\n    var results = value.match(parsingUtils.REGEX_DATABINDING);\n\n    if (results && results.length === 4) {\n      var newVal = results[2];\n\n      if (_.startsWith(newVal, 'function:')) {\n        functionsUsedInActions.push(newVal.replace('function:', ''));\n      }\n    }\n  }\n\n  return functionsUsedInActions;\n};\n/**\n * Get Function dependancies\n *\n * @param {Object} action - The action object\n *\n * @param {Object} viewModel - The view model\n *\n * @return {Array} - The Array contains function dependancies to load.\n */\n\n\nexport let getFunctionDeps = function (action, viewModel) {\n  var depsToLoad = [];\n  var functionsUsedInActions = [];\n  const functions = viewModel.functions; // get functions used in action input data\n\n  if (action && action.inputData) {\n    _.forEach(action.inputData.request, function (value) {\n      getActionDataFunc(value, functionsUsedInActions);\n    });\n  }\n\n  if (action && action.outputData) {\n    _.forEach(action.outputData, function (value) {\n      getActionDataFunc(value, functionsUsedInActions);\n    });\n  }\n\n  if (action && action.dataParsers && action.dataParsers.length) {\n    _.forEach(action.dataParsers, dataParser => {\n      const dataParserDef = viewModel.dataParseDefinitions[dataParser.id];\n      const fnUsedInDataParsers = getFunctionUsageRecursive(dataParserDef);\n\n      _.forEach(fnUsedInDataParsers, fnUsed => getActionDataFunc(fnUsed, functionsUsedInActions));\n    });\n  }\n\n  if (functions) {\n    _.forEach(functions, function (func) {\n      if (func.deps && depsToLoad.includes(func.deps) === false && functionsUsedInActions.includes(func.functionName)) {\n        depsToLoad.push(func.deps);\n      }\n    });\n  }\n\n  return depsToLoad;\n};\n\nconst getFunctionUsageRecursive = object => {\n  let values = [];\n\n  _.each(object, value => {\n    if (_.isString(value) && value.startsWith('{{function:')) {\n      values.push(value);\n    } else if (_.isObject(value)) {\n      values = values.concat(getFunctionUsageRecursive(value));\n    }\n  });\n\n  return values;\n};\n/**\n * Build common proprty Place holder\n *\n *\n * @param {Object} prop - raw property\n *\n * @return {object}  - propAttrHolder will blank if not valid VMP else filled\n */\n\n\nexport let buildPropHolder = prop => {\n  let propAttrHolder = {};\n\n  _.forEach(prop, function (dataPropValue, dataPropName) {\n    if (exports.attrHolderPropName.indexOf(dataPropName) > -1) {\n      propAttrHolder[dataPropName] = dataPropValue;\n    }\n  });\n\n  return propAttrHolder;\n};\nexport let getLatestContext = function (dataCtxNode, declViewModel) {\n  let subPanelContext = null;\n  let ports = null;\n  let conditions = null;\n\n  if (dataCtxNode && dataCtxNode.getProps && _.isFunction(dataCtxNode.getProps)) {\n    let props = dataCtxNode.getProps();\n    dataCtxNode.props = props;\n    subPanelContext = props.subPanelContext;\n  }\n\n  if (dataCtxNode && dataCtxNode.getFields && _.isFunction(dataCtxNode.getFields)) {\n    dataCtxNode.fields = dataCtxNode.getFields();\n  }\n\n  if (declViewModel && declViewModel.getData && _.isFunction(declViewModel.getData)) {\n    let val = declViewModel.getData();\n\n    if (val.hasOwnProperty('data')) {\n      declViewModel.data = val.data;\n    } else {\n      declViewModel.data = val;\n    }\n  }\n\n  if (dataCtxNode && !dataCtxNode.conditions && declViewModel) {\n    conditions = declViewModel.conditions;\n    dataCtxNode.conditions = conditions;\n  }\n\n  if (!dataCtxNode) {\n    dataCtxNode = {};\n  } else {\n    ports = dataCtxNode.ports;\n  }\n\n  return { ...dataCtxNode,\n    data: declViewModel,\n    ctx: { ...dataCtxNode.ctx,\n      ...appCtxSvc.ctx\n    },\n    parameters: dataCtxNode.parameters,\n    subPanelContext: subPanelContext ? subPanelContext : declViewModel.subPanelContext,\n    commandContext: dataCtxNode.commandContext,\n    pasteContext: dataCtxNode.pasteContext,\n    ports: ports ? ports : declViewModel._internal.ports\n  };\n};\nexports = {\n  buildLifeCycleIssueMessage,\n  logLifeCycleIssue,\n  assertValidModel,\n  cloneData,\n\n  /** revisitme\n  updateFormData,\n  */\n  assertValidModelWithOriginalJSON,\n  assertValidModelAndDataCtxNode,\n  isValidModelAndDataCtxNode,\n  assertValidModelDataCtxNodeAndAction,\n  assertValidModelDataCtxNodeAndAction2,\n  assertValidModelAndEventData,\n  isValidModelAndEventData,\n  applyMessageParams,\n  resolveLocalDataCtx,\n  isNil,\n  findViewModel,\n  consolidateObjects,\n  createCustomEvent,\n  evaluateCondition,\n  getConditionExpression,\n  getConditionName,\n  getAllModifiedValues,\n  updatePropertyValues,\n  getFunctionDeps,\n  getTypeHierarchy,\n  processOutputData,\n  noop,\n  loadDependentModule,\n  attrHolderPropName,\n  buildPropHolder,\n  getLatestContext\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/declUtils.js"],"names":["exports","MSG_1","MSG_PREFIX_1","MSG_PREFIX_2","_actionPropsToLog","_debug_logLifeCycleIssues","browserUtils","attrHolderPropName","loadDependentModule","depModule","moduleLoader","buildLifeCycleIssueMessage","errorMsg","JSON","logLifeCycleIssue","logger","assertValidModel","assert","declViewModel","cloneData","object","_","assertValidModelWithOriginalJSON","assertValidModelAndDataCtxNode","dataCtxNode","isValidModelAndDataCtxNode","assertValidModelDataCtxNodeAndAction","action","assertValidModelDataCtxNodeAndAction2","assertValidModelAndEventData","eventData","applyMessageParams","placeHolders","messageString","resultString","placeHolder","index","key","parsingUtils","messageParams","replacementString","isValidModelAndEventData","resolveLocalDataCtx","isNil","value","noop","findViewModel","currCtxNode","data","consolidateObjects","returnObj","createCustomEvent","evt","document","detail","bubbles","canBubble","processOutputData","valPath","outputData","res","expression","jsonStringVariable","jsonString","vmPath","evaluateCondition","parse","AwParseService","getConditionExpression","conditionExpression","conditionObject","getConditionName","conditionString","getAllModifiedValues","modifiedProperties","vmo","updatePropertyValues","dataObject","getTypeHierarchy","getActionDataFunc","results","newVal","functionsUsedInActions","getFunctionDeps","depsToLoad","functions","viewModel","dataParser","dataParserDef","fnUsedInDataParsers","getFunctionUsageRecursive","fnUsed","func","values","buildPropHolder","prop","propAttrHolder","getLatestContext","subPanelContext","ports","conditions","props","val","ctx","appCtxSvc","parameters","commandContext","pasteContext"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/* global afxDynamicImport afxWeakImport */\n\n/**\n * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.\n * <P>\n * Note: This modules does not create an injectable service.\n *\n * @module js/declUtils\n */\nimport assert from 'js/assert';\nimport _ from 'lodash';\nimport logger from 'js/logger';\nimport moduleLoader from 'js/moduleLoader';\n/** revisitme Shaishav\n * Hint: We need to integrate with appCtxService\nimport appCtxSvc from 'js/appCtxService';\n*/\nimport parsingUtils from 'js/parsingUtils';\nimport browserUtils from 'js/browserUtils';\nimport appCtxSvc from 'js/appCtxService';\n\n// Service\nimport AwParseService from 'js/awParseService';\n\nvar exports = {};\n\nvar MSG_1 = 'Required DeclViewModel not specified';\n\nvar MSG_PREFIX_1 = 'Invalid to process with destroyed DeclViewModel: ';\n\nvar MSG_PREFIX_2 = 'Invalid to process with destroyed DataContextNode: ';\n\n/**\n * {StringAray} Props to include when logging the properties of a dseclAction.\n */\nvar _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'steps' ];\n\n/**\n * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.\n * <P>\n * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's\n * URL.\n */\nvar _debug_logLifeCycleIssues = browserUtils.getUrlAttributes().logLifeCycleIssues !== undefined;\n\n/**\n * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid\n * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema\n * checker).\n */\nexport let attrHolderPropName = [ 'dbValue', 'displayName', 'dispValue', 'isArray', 'isEditable', 'isRequired', 'isEnabled', 'displayValue', 'value', 'isModifiable', 'isAutoAssign', 'isAutoAssignable',\n    'labelPosition', 'requiredText', 'type', 'propName', 'hasLov', 'dataProvider', 'isSelectOnly', 'isRichText', 'referenceTypeName', 'maxLength', 'maxArraySize', 'renderingHint', 'autofocus',\n    'propertyDisplayName',\n    'patterns', 'preferredPattern', 'patternAutoAssignFlags', 'condition', 'validationCriteria', 'oldValue', 'oldValues', 'vertical', 'propertyRadioTrueText', 'propertyRadioFalseText', 'numberOfLines',\n    'iconName'\n];\n/**\n * @param {String} depModule - The dependent module to load.\n *\n * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has\n * been loaded.\n */\nexport const loadDependentModule = depModule => {\n    return moduleLoader.loadDependentModule( depModule );\n};\n\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\nexport let buildLifeCycleIssueMessage = function( declViewModel, action, consequence, methodName ) {\n    var errorMsg = 'Attempted processing after an associated DeclViewModel was destroyed...';\n\n    if( consequence ) {\n        errorMsg += '\\n';\n        errorMsg += consequence;\n    }\n\n    if( declViewModel ) {\n        errorMsg += '\\n';\n        errorMsg += 'DeclViewModel: ';\n        errorMsg += declViewModel;\n    }\n\n    if( methodName ) {\n        errorMsg += '\\n';\n        errorMsg += 'Method: ';\n        errorMsg += methodName;\n    }\n\n    if( action ) {\n        errorMsg += '\\n';\n        errorMsg += 'Action:';\n        errorMsg += '\\n';\n        errorMsg += JSON.stringify( action, _actionPropsToLog, 2 );\n    }\n\n    return errorMsg;\n};\n\n/**\n * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.\n *\n * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life\n * cycle issue.\n *\n * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n *\n * @returns {String} Formatted message\n */\nexport let logLifeCycleIssue = function( declViewModel, action, consequence, methodName ) {\n    var errorMsg = exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName );\n\n    if( _debug_logLifeCycleIssues ) {\n        logger.warn( errorMsg );\n    }\n\n    return errorMsg;\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\nexport let assertValidModel = function( declViewModel ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n};\n\n/**\n * Clone scope without copying angular scope's internal properties.\n *\n * @param {Object} scope - Object to clone.\n *\n * @return {Object} an object that holds data from provided Object\n */\nexport let cloneData = function( scope ) {\n    var object = {};\n    _.forOwn( scope, function( value, key ) {\n        if( !_.startsWith( key, '$' ) ) {\n            object[ key ] = value;\n        }\n    } );\n    return object;\n};\n\n/**\n * update data for fileData\n *\n * @param {Object} fileData - key string value the location of the file\n * @param {Object} data the view model data object\n */\n/** revisitme Shaishav\n * Hint: We need a jquery free solution here\nexport let updateFormData = function( fileData, data ) {\n    if( fileData && fileData.value ) {\n        var form = $( '#fileUploadForm' );\n        data.formData = new FormData( $( form )[ 0 ] );\n        data.formData.append( fileData.key, fileData.value );\n    }\n};\n*/\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n */\nexport let assertValidModelWithOriginalJSON = function( declViewModel ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    assert( declViewModel._internal.origDeclViewModelJson, 'Required DeclViewModel JSON object not specified' );\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n */\nexport let assertValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\nexport let isValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {\n    if( !declViewModel ) {\n        if( _debug_logLifeCycleIssues ) {\n            logger.warn( MSG_1 );\n        }\n        return false;\n    }\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        exports.logLifeCycleIssue( declViewModel, null, null, 'isValidModelAndDataCtxNode' );\n        return false;\n    }\n\n    if( !declViewModel.isUnmounting && dataCtxNode && dataCtxNode.$$destroyed ) {\n        if( _debug_logLifeCycleIssues ) {\n            logger.warn( MSG_PREFIX_2 + dataCtxNode.$id + ' DeclViewModel=' + declViewModel );\n        }\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} dataCtxNode - The context object to test.\n * @param {DeclAction} action - The declAction object to test.\n */\nexport let assertValidModelDataCtxNodeAndAction = function( declViewModel, dataCtxNode, action ) {\n    assert( declViewModel, MSG_1 );\n\n    if( declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel +\n            ' actionType: ' + action.actionType +\n            ' method: ' + action.method +\n            ' deps: ' + action.deps );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +\n            ' DeclViewModel=' + declViewModel +\n            ' actionType: ' + action.actionType +\n            ' method: ' + action.method +\n            ' deps: ' + action.deps );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} dataCtxNode - The context object to test.\n *\n * @param {DeclAction} action - The declAction object to test.\n *\n * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}\n * has been destroyed.\n *\n * @param {String} methodName - Name of the method where the issues was found.\n */\nexport let assertValidModelDataCtxNodeAndAction2 = function( declViewModel, dataCtxNode, action, consequence, methodName ) {\n    assert( declViewModel, MSG_1 );\n\n    if( declViewModel._internal.isDestroyed ) {\n        assert( false, exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );\n    }\n\n    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {\n        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +\n            exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );\n    }\n};\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * an 'assert' failure will be thrown.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n */\nexport let assertValidModelAndEventData = function( declViewModel, eventData ) {\n    assert( declViewModel, MSG_1 );\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        assert( false, MSG_PREFIX_1 + declViewModel );\n    }\n\n    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {\n        assert( false, MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n    }\n};\n\n/**\n * Evaluate message with its parameters\n *\n * @param {String} messageString - The message String.\n *\n * @param {String} messageParams - The message parameters.\n *\n * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to\n *            search within.\n *\n * @return {String} Result string after applying passed parameters.\n */\nexport let applyMessageParams = function( messageString, messageParams, messageContext ) {\n    var placeHolders = messageString.match( /\\{[0-9]*\\}/g );\n\n    var resultString = messageString;\n\n    if( placeHolders && messageParams ) {\n        for( var i in placeHolders ) {\n            if( placeHolders.hasOwnProperty( i ) ) {\n                var placeHolder = placeHolders[ i ];\n\n                var index = placeHolder;\n                index = _.trimStart( index, '{' );\n                index = _.trimEnd( index, '}' );\n\n                var key = parsingUtils.getStringBetweenDoubleMustaches( messageParams[ index ] );\n                var replacementString = _.get( messageContext, key );\n                resultString = resultString.replace( placeHolder, replacementString );\n            }\n        }\n    }\n\n    return resultString;\n};\n\n\n/**\n * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,\n * a 'warning' will be logged and this function will return FALSE.\n *\n * @param {DeclViewModel} declViewModel - The DeclViewModel to test.\n *\n * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for\n *            validity.\n *\n * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid\n * properties set. TRUE otherwise.\n */\nexport let isValidModelAndEventData = function( declViewModel, eventData ) {\n    if( !declViewModel ) {\n        logger.warn( MSG_1 );\n        return false;\n    }\n\n    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {\n        logger.warn( MSG_PREFIX_1 + declViewModel );\n        return false;\n    }\n\n    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {\n        logger.warn( MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was\n * started.\n * <P>\n * If so: Use the dataCtxNode the DeclViewModel was originally created on.\n * <P>\n * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the\n * event was processed.\n *\n * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check\n * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.\n *\n * @returns {Object} The dataCtxNode object to use.\n */\nexport let resolveLocalDataCtx = function( declViewModel, dataCtxNode ) {\n    if( dataCtxNode.$$destroyed ) {\n        return declViewModel._internal.origCtxNode;\n    }\n\n    return dataCtxNode;\n};\n\n/**\n * Return true if provided value is 'nil' (i.e. not null or undefined).\n *\n * @param {Object} value - The value to test.\n *\n * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).\n */\nexport let isNil = function( value ) {\n    return value === undefined || value === null;\n};\n\n/**\n * Return a empty function\n *\n * @returns {null} null\n */\nexport const noop = () => null;\n\n/**\n * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given\n * 'dataCtxNode'.\n *\n * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the\n *            lookup of the 'declViewModel'.\n *\n * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as\n *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.\n *\n * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is\n *            TRUE.\n *\n * @return {DeclViewModel} The 'declViewModel' found.\n */\nexport let findViewModel = function( dataCtxNode, setInScope ) {\n    /**\n     * Check for the case where the declViewModel is already set on the given node.\n     */\n    if( dataCtxNode.data ) {\n        /** revisitme\n        if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {\n            dataCtxNode.ctx = appCtxSvc.ctx;\n        }\n        */\n\n        return dataCtxNode.data;\n    }\n\n    /**\n     * Look for the model on a 'parent' node.\n     */\n    var currCtxNode = dataCtxNode;\n\n    while( currCtxNode && !currCtxNode.data ) {\n        currCtxNode = currCtxNode.$parent;\n    }\n\n    if( currCtxNode ) {\n        if( setInScope ) {\n            dataCtxNode.data = currCtxNode.data;\n\n            /** revisitme\n            if( appCtxSvc ) {\n                dataCtxNode.ctx = appCtxSvc.ctx;\n            }\n            */\n\n            //if subPanelContext is available on scope then add it dataCtxNode\n            if( currCtxNode.subPanelContext ) {\n                dataCtxNode.subPanelContext = currCtxNode.subPanelContext;\n            }\n\n            /**\n             * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.\n             */\n            if( dataCtxNode.$on ) {\n                dataCtxNode.$on( '$destroy', function( data ) {\n                    data.currentScope.data = null;\n                    data.currentScope.ctx = null;\n                } );\n            }\n        }\n\n        return currCtxNode.data;\n    }\n\n    return null;\n};\n\n/**\n * Consolidate the second object's properties into the first one\n *\n * @param {Object} targetObj - The 'target' object to merge to\n * @param {Object} sourceObj - The 'source' object to be merge from\n *\n * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.\n */\nexport let consolidateObjects = function( targetObj, sourceObj ) {\n    var returnObj = null;\n\n    if( targetObj ) {\n        returnObj = targetObj;\n\n        _.forEach( sourceObj, function( n, key ) {\n            returnObj[ key ] = n;\n        } );\n    } else if( sourceObj ) {\n        returnObj = sourceObj;\n    }\n\n    return returnObj;\n};\n\n/**\n * Create custom event. Mainly for IE\n *\n * @param {String} eventName - Name of the event\n *\n * @param {Object} eventDetail - Object for event detail\n\n * @param {Object} canBubble -is bubble is up/down\n\n * @param {Object} isCancellable - event can ne canclable or not\n *\n * @return {DOMElement} created DOMElement\n */\nexport let createCustomEvent = function( eventName, eventDetail, canBubble, isCancellable ) {\n    if( browserUtils.isNonEdgeIE ) {\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( eventName, canBubble, isCancellable, eventDetail );\n        return evt;\n    }\n    return new CustomEvent( eventName, {\n        detail: eventDetail,\n        bubbles: canBubble\n    } );\n};\n\n/**\n * process output data\n * @param {JSON} outputData output data definition\n * @param {object} result function result\n * @returns {object} data patch as:\n * {\n *     \"ctx.b\": 3,\n *     \"data.c\": 5\n * }\n */\nexport const processOutputData = ( outputData, result ) => {\n    if( outputData ) {\n        const value = {};\n        for( let vmPath in outputData ) {\n            let valPath = outputData[ vmPath ];\n            let res = undefined;\n            if( _.isBoolean( valPath ) ) {\n                res = valPath;\n            } else {\n                var expression = parsingUtils.getStringBetweenDoubleMustaches( valPath );\n                if( _.startsWith( expression, 'json:' ) ) {\n                    var jsonStringVariable = expression.replace( 'json:', '' );\n                    var jsonString = _.get( result, jsonStringVariable );\n                    res = parsingUtils.parseJsonString( jsonString );\n                } else {\n                    res = valPath && valPath.length > 0 ? _.get( result, valPath ) : result;\n                }\n            }\n            // TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'\n            value[ /^ctx\\./.test( vmPath ) ? vmPath : `data.${vmPath}` ] = res;\n        }\n        return value;\n    }\n    return undefined;\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}\n * @param {Object} evaluationEnv - the data environment for expression evaluation\n * evaluation\n *\n * @return {Boolean} the evaluated condition result\n */\nexport let evaluateCondition = function( declViewModel, expression, evaluationEnv ) {\n    let parse = AwParseService.instance;\n    return parse( expression )( evaluationEnv );\n};\n\n/**\n * Evaluate condition expression\n *\n * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.\n * @param {String} condition name of condition\n *\n * @return {String} the evaluated condition result\n */\nexport let getConditionExpression = function( declViewModel, condition ) {\n    var conditionExpression = null;\n\n    if( _.startsWith( condition, 'conditions.' ) ) {\n        var conditionObject = _.get( declViewModel._internal, condition );\n\n        conditionExpression = conditionObject.expression;\n    } else {\n        conditionExpression = condition;\n    }\n\n    return conditionExpression;\n};\n\n/**\n * Evaluate condition name\n *\n * @param {String} conditionString name of condition\n *\n * @return {String} the evaluated condition result\n */\nexport let getConditionName = function( conditionString ) {\n    if( _.startsWith( conditionString, 'conditions.' ) ) {\n        var index = conditionString.indexOf( '.' );\n        return conditionString.substr( index + 1 );\n    }\n    return null;\n};\n\n/**\n * Get dirty properties of the view model object\n *\n * @param {Object} vmo - the view model object\n *\n * @return {Array} the dirty properties of the view model object\n */\nexport let getAllModifiedValues = function( vmo ) {\n    var modifiedProperties = [];\n    if( vmo ) {\n        modifiedProperties = vmo.getDirtyProps();\n    }\n    return modifiedProperties;\n};\n\n/**\n * Update the properties of the view model property with new values\n *\n * @param {Object} dataObject - view model object.\n * @param {Object} dataProperty - view model object property.\n * @param {Object} dataPropertyValue - view model object property value.\n */\nexport let updatePropertyValues = function( dataObject, dataProperty, dataPropertyValue ) {\n    dataObject[ dataProperty ] = dataPropertyValue;\n    return {\n        data:{ ...dataObject }\n    };\n};\n\n/**\n * get type hierarchy from modleObject or view model Object\n *\n * @param {Object} dataObject - view model object.\n *\n *  @return {Array} - hierarchy of model object names\n\n */\nexport let getTypeHierarchy = function( dataObject ) {\n    return dataObject.typeHierarchy || dataObject.modelType && dataObject.modelType.typeHierarchyArray;\n};\n\n/**\n *  get functions used in action input/output data\n */\nlet getActionDataFunc = function( value, functionsUsedInActions ) {\n    if( typeof value === 'string' ) {\n        var results = value.match( parsingUtils.REGEX_DATABINDING );\n        if( results && results.length === 4 ) {\n            var newVal = results[ 2 ];\n            if( _.startsWith( newVal, 'function:' ) ) {\n                functionsUsedInActions.push( newVal.replace( 'function:', '' ) );\n            }\n        }\n    }\n    return functionsUsedInActions;\n};\n\n/**\n * Get Function dependancies\n *\n * @param {Object} action - The action object\n *\n * @param {Object} viewModel - The view model\n *\n * @return {Array} - The Array contains function dependancies to load.\n */\nexport let getFunctionDeps = function( action, viewModel ) {\n    var depsToLoad = [];\n    var functionsUsedInActions = [];\n    const functions = viewModel.functions;\n    // get functions used in action input data\n    if( action && action.inputData ) {\n        _.forEach( action.inputData.request, function( value ) {\n            getActionDataFunc( value, functionsUsedInActions );\n        } );\n    }\n    if( action && action.outputData ) {\n        _.forEach( action.outputData, function( value ) {\n            getActionDataFunc( value, functionsUsedInActions );\n        } );\n    }\n    if( action && action.dataParsers && action.dataParsers.length ) {\n        _.forEach( action.dataParsers, dataParser => {\n            const dataParserDef = viewModel.dataParseDefinitions[ dataParser.id ];\n            const fnUsedInDataParsers = getFunctionUsageRecursive( dataParserDef );\n            _.forEach( fnUsedInDataParsers, fnUsed => getActionDataFunc( fnUsed, functionsUsedInActions ) );\n        } );\n    }\n    if( functions ) {\n        _.forEach( functions, function( func ) {\n            if( func.deps && depsToLoad.includes( func.deps ) === false &&\n                functionsUsedInActions.includes( func.functionName ) ) {\n                depsToLoad.push( func.deps );\n            }\n        } );\n    }\n    return depsToLoad;\n};\n\nconst getFunctionUsageRecursive = ( object ) => {\n    let values = [];\n    _.each( object, ( value ) => {\n        if( _.isString( value ) && value.startsWith( '{{function:' ) ) {\n            values.push( value );\n        } else if( _.isObject( value ) ) {\n            values = values.concat( getFunctionUsageRecursive( value ) );\n        }\n    } );\n    return values;\n};\n\n/**\n * Build common proprty Place holder\n *\n *\n * @param {Object} prop - raw property\n *\n * @return {object}  - propAttrHolder will blank if not valid VMP else filled\n */\n\nexport let buildPropHolder = ( prop ) => {\n    let propAttrHolder = {};\n\n    _.forEach( prop, function( dataPropValue, dataPropName ) {\n        if( exports.attrHolderPropName.indexOf( dataPropName ) > -1 ) {\n            propAttrHolder[ dataPropName ] = dataPropValue;\n        }\n    } );\n\n    return propAttrHolder;\n};\n\nexport let getLatestContext = function( dataCtxNode, declViewModel ) {\n    let subPanelContext = null;\n    let ports = null;\n    let conditions = null;\n\n    if( dataCtxNode && dataCtxNode.getProps && _.isFunction( dataCtxNode.getProps ) ) {\n        let props = dataCtxNode.getProps();\n        dataCtxNode.props = props;\n        subPanelContext = props.subPanelContext;\n    }\n\n    if( dataCtxNode && dataCtxNode.getFields && _.isFunction( dataCtxNode.getFields ) ) {\n        dataCtxNode.fields = dataCtxNode.getFields();\n    }\n\n    if( declViewModel && declViewModel.getData && _.isFunction( declViewModel.getData ) ) {\n        let val = declViewModel.getData();\n        if( val.hasOwnProperty( 'data' ) ) {\n            declViewModel.data = val.data;\n        } else {\n            declViewModel.data = val;\n        }\n    }\n\n    if( dataCtxNode && !dataCtxNode.conditions && declViewModel ) {\n        conditions = declViewModel.conditions;\n        dataCtxNode.conditions = conditions;\n    }\n\n    if( !dataCtxNode ) {\n        dataCtxNode = {};\n    } else {\n        ports = dataCtxNode.ports;\n    }\n\n    return {\n        ...dataCtxNode,\n        data: declViewModel,\n        ctx: { ...dataCtxNode.ctx, ...appCtxSvc.ctx },\n        parameters: dataCtxNode.parameters,\n        subPanelContext: subPanelContext ? subPanelContext : declViewModel.subPanelContext,\n        commandContext: dataCtxNode.commandContext,\n        pasteContext: dataCtxNode.pasteContext,\n        ports: ports ? ports : declViewModel._internal.ports\n    };\n};\n\nexports = {\n    buildLifeCycleIssueMessage,\n    logLifeCycleIssue,\n    assertValidModel,\n    cloneData,\n    /** revisitme\n    updateFormData,\n    */\n    assertValidModelWithOriginalJSON,\n    assertValidModelAndDataCtxNode,\n    isValidModelAndDataCtxNode,\n    assertValidModelDataCtxNodeAndAction,\n    assertValidModelDataCtxNodeAndAction2,\n    assertValidModelAndEventData,\n    isValidModelAndEventData,\n    applyMessageParams,\n    resolveLocalDataCtx,\n    isNil,\n    findViewModel,\n    consolidateObjects,\n    createCustomEvent,\n    evaluateCondition,\n    getConditionExpression,\n    getConditionName,\n    getAllModifiedValues,\n    updatePropertyValues,\n    getFunctionDeps,\n    getTypeHierarchy,\n    processOutputData,\n    noop,\n    loadDependentModule,\n    attrHolderPropName,\n    buildPropHolder,\n    getLatestContext\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}