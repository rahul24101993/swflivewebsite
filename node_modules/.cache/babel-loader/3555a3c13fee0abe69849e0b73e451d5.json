{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/filterPanelUtils\n */\nimport appCtxService from 'js/appCtxService';\nimport dateTimeService from 'js/dateTimeService';\nimport messagingService from 'js/messagingService';\nimport localeSvc from 'js/localeService';\nimport $ from 'jquery';\nimport logger from 'js/logger';\nimport _ from 'lodash';\nvar _invalidDateText = '';\nvar _invalidRangeText = '';\nvar _invalidPrefilter = '';\nvar AWC_LIMITED_FILTER_CATEGORIES_ENABLED = 'AWC_Limited_Filter_Categories_Enabled';\nexport let HIERARCHICAL_FACET_SEPARATOR = '/';\nexport let PRESET_CATEGORY = 'WorkspaceObject.object_type';\nexport let DATE_FILTER = 'DateFilter';\nexport let INTERNAL_DATE_FILTER = '_DateFilter_';\nexport let DATE_RANGE_FILTER = 'DateRangeFilter';\nexport let DATE_DRILLDOWN_FILTER = 'DrilldownDateFilter';\nexport let NUMERIC_RANGE_FILTER = 'NumericRangeFilter';\nexport let INTERNAL_NUMERIC_FILTER = '_NumericFilter_';\nexport let INTERNAL_OBJECT_FILTER = '_ObjectFilter_';\nexport let INTERNAL_NUMERIC_RANGE = '_NumericRange_';\nexport let NUMERIC_FILTER = 'NumericFilter';\nexport let NUMERIC_RANGE = 'NumericRange';\nexport let NumericRangeBlankStart = 'NumericRangeBlankStart';\nexport let NumericRangeBlankEnd = 'NumericRangeBlankEnd';\nvar INTERNAL_TO = '_TO_';\nexport let NO_STARTDATE = '*';\nexport let NO_ENDDATE = '2100-12-31';\nexport let NO_STARTRANGE = '';\nexport let NO_ENDRANGE = '';\nexport let BEGINNING_OF_TIME = '0001-01-01T00:00:00';\nexport let ENDING_OF_TIME = '2100-12-31T23:59:59';\nvar START_OF_DAY = '00:00:00';\nvar _presetFilters = true;\nvar _hasTypeFilter = false;\nvar _incontextFlag = false;\nvar customPropValueColorMap = {};\n/**\n * Returns a date object.\n *\n * @function getDate\n * @memberOf filterPanelUtils\n *\n * @param {String}dateString - date string to be converted to date object\n *\n * @return {JsDate} a date object.\n */\n\nexport let getDate = function (dateString) {\n  var dateStr = dateString.substring(0, 10);\n  var date; // change open start/end date to null dates\n\n  if (_.startsWith(dateStr, '0001-01-0') || _.startsWith(dateStr, '2100-12-3')) {\n    date = dateTimeService.getNullDate();\n  } else {\n    var timeStr = dateString.substring(11, dateString.length - 6);\n\n    if (timeStr.indexOf('59') !== -1) {\n      dateStr = dateString.replace(timeStr, START_OF_DAY);\n    } else {\n      dateStr = dateString;\n    }\n\n    date = new Date(dateStr);\n  }\n\n  return date;\n};\n/**\n * Returns a UTC date object.\n *\n * @function convertToUTC\n * @memberOf filterPanelUtils\n *\n * @param {Object}date - date object\n *\n * @return {JsDate} a UTC date object.\n */\n\nfunction convertToUTC(date) {\n  var gmtTime = date.getTime();\n  var offset = date.getTimezoneOffset();\n  var jsDate = new Date(gmtTime + offset * 60 * 1000);\n  return new Date(jsDate.getTime());\n}\n/**\n * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can\n * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the\n * dateTimeService.isNullDate.\n *\n * @function isNullDate\n * @memberOf filterPanelUtils\n *\n * @param {Object} dateToTest - a Date object.\n * @returns {Boolean} - true if it's a null date.\n */\n\n\nexport let isNullDate = function (dateToTest) {\n  if (!dateToTest) {\n    return true;\n  }\n\n  return dateToTest.getFullYear() <= 1;\n};\n/**\n * Validate dates for category date range.\n *\n * @function validateDates\n * @memberOf filterPanelUtils\n *\n * @param {Object}category - category. This object is modified in this function.\n * @param {Object}startDate - startDate\n * @param {Object}origStartDate - origStartDate\n * @param {Object}endDate - endDate\n * @param {Object}origEndDate - origEndDate\n */\n\nexport let validateDates = function (category, startDate, origStartDate, endDate, origEndDate) {\n  category.showSearch = true;\n  var cStartDate = category.daterange.startDate;\n  var eEndDate = category.daterange.endDate;\n\n  if (category.daterange.dateRangeSelected && !cStartDate.valueUpdated && !eEndDate.valueUpdated) {\n    category.showSearch = false;\n    return;\n  } // The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,\n  // which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.\n\n\n  var tmpStartDate = moveDateToStartOfDay(startDate);\n  var tmpEndDate = moveDateToStartOfDay(endDate);\n  var noStartDate = dateTimeService.isNullDate(tmpStartDate);\n  var noEndDate = dateTimeService.isNullDate(tmpEndDate); // if both dates are not set, disable search button\n\n  if (noStartDate && noEndDate) {\n    category.showSearch = false;\n    return;\n  }\n\n  var temp1 = dateTimeService.compare(startDate, endDate); // if start date is later than end date, disable search button\n\n  if (!noStartDate && !noEndDate && startDate !== null && temp1 === 1) {\n    messagingService.showError(_invalidDateText);\n    category.showSearch = false;\n    return;\n  }\n\n  var disable; // check if dates vary from previous search to avoid enabling search\n\n  var tmpOrigEndDate = moveDateToStartOfDay(origEndDate);\n\n  if (noStartDate) {\n    // check if there is no startdate and if end date is same, disable search button\n    disable = category.daterange.startDate === null && dateTimeService.compare(tmpEndDate, tmpOrigEndDate) === 0;\n  } else if (noEndDate) {\n    // check if there is no enddate and  start date is same, disable search button\n    disable = category.daterange.endDate === null && dateTimeService.compare(startDate, category.daterange.startDate.dateApi.dateObject) === 0;\n  } else {\n    // if the dates are same as previous search, disable search button\n    var compare1 = dateTimeService.compare(startDate, origStartDate) === 0;\n    var compare2 = dateTimeService.compare(endDate, tmpOrigEndDate) === 0;\n    disable = compare1 && compare2;\n  }\n\n  category.showSearch = !disable;\n};\n/**\n * get date range filter.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {Object}startDate - startDate\n * @param {Object}endDate - endDate\n *\n * @return {String} a string that represents the date range.\n */\n\nexport let getDateRangeString = function (startDate, endDate) {\n  var noStartDate = isNullDate(startDate);\n  var noEndDate = isNullDate(endDate);\n  var fromDateString = noStartDate ? NO_STARTDATE : dateTimeService.formatUTC(startDate);\n\n  if (noEndDate) {\n    endDate = new Date(NO_ENDDATE);\n  }\n\n  var toDateString = dateTimeService.formatUTC(moveDateToEndOfDay(endDate));\n  return INTERNAL_DATE_FILTER + fromDateString + INTERNAL_TO + toDateString;\n};\n/**\n * get filter of date range.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a filter object of date range for the filter string.\n */\n\nexport let getDateRangeFilter = function (filter) {\n  var searchFilter = {};\n  var sArr = filter.split(INTERNAL_TO);\n  searchFilter.searchFilterType = 'DateFilter';\n  sArr[0] = sArr[0] === NO_STARTDATE ? dateTimeService.NULLDATE : dateTimeService.formatUTC(sArr[0]);\n  searchFilter.startDateValue = sArr[0];\n  searchFilter.endDateValue = sArr[1];\n  return searchFilter;\n};\n/**\n * get a date range filter with display name and category type.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}startDate - startDate\n * @param {String}endDate - endDate\n *\n * @return {Object} a date range filter with display name and category type.\n */\n\nexport let getDateRangeDisplayString = function (startDate, endDate) {\n  var dateRangeFilter = {};\n  var noStartDate = dateTimeService.isNullDate(startDate);\n  var noEndDate = dateTimeService.isNullDate(endDate);\n  var dateRangeString;\n\n  if (noStartDate) {\n    dateRangeString = 'To ' + dateTimeService.formatDate(new Date(endDate)).substring(0, 11);\n  } else if (noEndDate) {\n    dateRangeString = 'From ' + dateTimeService.formatDate(new Date(startDate)).substring(0, 11);\n  } else {\n    dateRangeString = dateTimeService.formatDate(new Date(startDate)).substring(0, 11) + ' - ' + dateTimeService.formatDate(new Date(endDate)).substring(0, 11);\n  }\n\n  dateRangeFilter.displayName = dateRangeString;\n  dateRangeFilter.categoryType = DATE_RANGE_FILTER;\n  return dateRangeFilter;\n};\n/**\n * Simple check to validate the given category numeric range.\n *\n * @function checkIfValidRange\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n *\n * @return {Boolean} true if valid range.\n */\n\nexport let checkIfValidRange = function (category, startRange, endRange) {\n  category.showSearch = true;\n\n  if (startRange !== null && endRange !== null && startRange > endRange) {\n    var errorValue = startRange + '-' + endRange;\n\n    var msg = _invalidRangeText.replace('{0}', errorValue);\n\n    messagingService.showError(msg);\n    category.showSearch = false;\n    return false;\n  }\n\n  return true;\n};\n/**\n * Validate the given category numeric range if the range is selected.\n *\n * @function validateNumericRangeSelected\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {Number}cStartRange - current startRange\n * @param {Number}cEndRange - current endRange\n * @return {Boolean} true if valid range.\n */\n\nexport let validateNumericRangeSelected = function (category, startRange, endRange, cStartRange, cEndRange) {\n  var hasValidated = false;\n  var oStartRange = category.numericrange.filter.startNumericValue;\n  var oEndRange = category.numericrange.filter.endNumericValue;\n  var pStartRange = parseFloat(cStartRange);\n  var pEndRange = parseFloat(cEndRange);\n  var invalidStart = cStartRange === oStartRange || pStartRange === oStartRange || isNaN(pStartRange) && oStartRange === NO_STARTRANGE; // when the start range goes from blank to 0, it's a real change, so the search button should be enabled.\n\n  if (category.numericrange.filter.startEndRange === NumericRangeBlankStart) {\n    invalidStart = isNaN(pStartRange);\n  }\n\n  var invalidEnd = cEndRange === oEndRange || pEndRange === oEndRange || isNaN(pEndRange) && oEndRange === NO_ENDRANGE;\n\n  if (category.numericrange.filter.startEndRange === NumericRangeBlankEnd) {\n    invalidEnd = isNaN(pEndRange);\n  } // when the end range goes from blank to 0, it's a real change, so the search button should be enabled.\n\n\n  if (invalidStart && invalidEnd) {\n    category.showSearch = false;\n    hasValidated = true;\n  }\n\n  return hasValidated;\n};\n/**\n * Validate ranges for category numeric range.\n *\n * @function validateNumericRange\n * @memberOf filterPanelUtils\n *\n * @param {String} category - category\n * @param {String} startRange - startRange\n * @param {String} endRange - endRange\n *\n */\n\nexport let validateNumericRange = function (category, startRange, endRange) {\n  category.showSearch = true; // Validate values to be numbers\n\n  var cStartRange = category.numericrange.startValue.dbValue;\n  var cEndRange = category.numericrange.endValue.dbValue;\n  var oStartRange = null;\n  var oEndRange = null;\n\n  if (category.numericrange.numericRangeSelected && validateNumericRangeSelected(category, startRange, endRange, cStartRange, cEndRange)) {\n    return;\n  }\n\n  var noStartRange = cStartRange === undefined || cStartRange === null || cStartRange === '';\n  var noEndRange = cEndRange === undefined || cEndRange === null || cEndRange === ''; // if both numbers are not set, disable search button\n\n  if (noStartRange && noEndRange) {\n    category.showSearch = false;\n    return;\n  }\n\n  var disable = false;\n\n  if (noStartRange) {\n    disable = endRange === oEndRange || isNaN(endRange);\n  } else if (noEndRange) {\n    // check if there is no endRange and  start number is same, disable search button\n    disable = startRange === oStartRange || isNaN(startRange);\n  } else {\n    disable = !isFinite(startRange) || isNaN(startRange) || !isFinite(endRange) || isNaN(endRange);\n  }\n\n  category.showSearch = !disable;\n};\n/**\n * get numeric range filter string.\n *\n * @function getNumericRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}startRange - startRange\n * @param {String}endRange - endRange\n *\n * @return {String} a numeric range string.\n */\n\nexport let getNumericRangeString = function (startRange, endRange) {\n  var fromValue = startRange && startRange.toString();\n\n  if (fromValue === undefined || fromValue === null || fromValue.length === 0 || isNaN(fromValue)) {\n    fromValue = NO_STARTRANGE;\n  }\n\n  var toValue = endRange && endRange.toString();\n\n  if (toValue === undefined || toValue === null || toValue.length === 0 || isNaN(toValue)) {\n    toValue = NO_ENDRANGE;\n  }\n\n  return INTERNAL_NUMERIC_RANGE + fromValue + INTERNAL_TO + toValue;\n};\n/**\n * get numeric range filter from a filter string.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a numeric range filter.\n */\n\nexport let getNumericRangeFilter = function (filter) {\n  var searchFilter = {};\n  var sArr = filter.split(INTERNAL_TO);\n  searchFilter.searchFilterType = NUMERIC_FILTER;\n  searchFilter.startNumericValue = parseFloat(sArr[0]);\n  searchFilter.endNumericValue = parseFloat(sArr[1]);\n\n  if (isNaN(searchFilter.startNumericValue)) {\n    searchFilter.startEndRange = NumericRangeBlankStart;\n  } else if (isNaN(searchFilter.endNumericValue)) {\n    searchFilter.startEndRange = NumericRangeBlankEnd;\n  } else {\n    searchFilter.startEndRange = NUMERIC_RANGE;\n  }\n\n  return searchFilter;\n};\n/**\n * get a numeric range filter.\n *\n * @function getNumericRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {String}startEndRange - startEndRange\n *\n * @return {Object} a numeric range filter with display name and category type.\n */\n\nexport let getNumericRangeDisplayString = function (startRange, endRange, startEndRange) {\n  var numericRangeFilter = {};\n  var noStartRange = startEndRange === NumericRangeBlankStart || startRange !== 0 && !startRange;\n  var noEndRange = startEndRange === NumericRangeBlankEnd || endRange !== 0 && !endRange;\n  var numericRangeString;\n\n  if (noStartRange) {\n    numericRangeString = 'To ' + endRange.toString();\n  } else if (noEndRange) {\n    numericRangeString = 'From ' + startRange.toString();\n  } else {\n    numericRangeString = startRange.toString() + ' - ' + endRange.toString();\n  }\n\n  numericRangeFilter.displayName = numericRangeString;\n  numericRangeFilter.categoryType = NUMERIC_RANGE_FILTER;\n  return numericRangeFilter;\n};\n/**\n * get a real filter.\n *\n * @function getRealFilterWithNoFilterType\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} the real filter stripped off the identifiers.\n */\n\nexport let getRealFilterWithNoFilterType = function (filter) {\n  var realFilter = filter;\n\n  if (!filter.hasOwnProperty('property')) {\n    realFilter = filter.replace(INTERNAL_NUMERIC_FILTER, '').replace(INTERNAL_OBJECT_FILTER, '');\n  }\n\n  return realFilter;\n};\n/**\n * get filter type from filter value.\n *\n * @function getFilterTypeFromFilterValue\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {String} filter type, if it can be derived.\n */\n\nexport let getFilterTypeFromFilterValue = function (filter) {\n  var filterType;\n\n  if (_.startsWith(filter, INTERNAL_OBJECT_FILTER)) {\n    filterType = 'ObjectFilter';\n  } else if (_.startsWith(filter, INTERNAL_NUMERIC_FILTER)) {\n    filterType = 'NumericFilter';\n  } else {\n    filterType = 'DateFilter';\n  }\n\n  return filterType;\n};\n/**\n * /** Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\n\nfunction moveDateToStartOfDay(date) {\n  if (!dateTimeService.isNullDate(date)) {\n    date.setHours(0, 0, 0);\n    return date;\n  }\n\n  return date;\n}\n/**\n * Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\n\n\nfunction moveDateToEndOfDay(date) {\n  if (!dateTimeService.isNullDate(date)) {\n    date.setHours(23, 59, 59);\n    return date;\n  }\n\n  return date;\n}\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\n\n\nexport let isPresetFilters = function () {\n  return _presetFilters;\n};\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag flag\n */\n\nexport let setPresetFilters = function (flag) {\n  _presetFilters = flag;\n};\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\n\nexport let getHasTypeFilter = function () {\n  return _hasTypeFilter;\n};\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag preset filter flag\n */\n\nexport let setHasTypeFilter = function (flag) {\n  _hasTypeFilter = flag;\n};\n/**\n * Sets incontext flag\n *\n * @param {Object} flag incontext flag\n */\n\nexport let setIncontext = function (flag) {\n  _incontextFlag = flag;\n};\n/**\n * Gets incontext flag\n *\n * @returns {Object} incontext flag\n */\n\nexport let getIncontext = function () {\n  return _incontextFlag;\n};\n/**\n * Save source filter map in appcontext for incontext\n *\n * @param {Object} data data\n */\n\nexport let saveIncontextFilterMap = function (data) {\n  let inContextMap = {};\n\n  if (getHasTypeFilter()) {\n    // Create a filter value for each category value\n    let tmpValues = data.searchFilterMap[PRESET_CATEGORY];\n    inContextMap[PRESET_CATEGORY] = tmpValues;\n  }\n\n  return inContextMap;\n};\n/**\n * Returns category internal name\n * @param {Object} category category\n * @returns {Object} The category internal name\n */\n\nexport let getCategoryInternalName = function (category) {\n  return category.internalName;\n};\n/**\n * Returns current category\n *\n * @param {Object} response the response from the search SOA\n * @returns {Object} The current category\n */\n\nexport let getCurrentCategory = function (response) {\n  return response.groupedObjectsList[0].internalPropertyName;\n};\n/**\n * Returns filter values for a category to be shown in panel\n *\n * @param {Object} category the category to get values for\n *\n * @returns {ObjectArray} The array of filters to show in panel\n */\n\nexport let getPropGroupValues = function (category) {\n  getPreferenceValue();\n  var values = [];\n\n  for (var i = 0; i < category.filterValues.length; i++) {\n    var categoryValue = category.filterValues[i];\n\n    if (categoryValue && (i < 9 || categoryValue.color)) {\n      values.push(getPropGroupValue(category.type, category.drilldown, categoryValue));\n    }\n  }\n\n  return values;\n};\n/**\n * Returns filter values for a category to be shown in panel\n * @param {String} categoryType categoryType\n * @param {Integer} categoryDrillDown category Drill Down\n * @param {String} categoryValue categoryValue\n * @returns {Object} filter value\n */\n\nexport let getPropGroupValue = function (categoryType, categoryDrillDown, categoryValue) {\n  var pos = categoryValue.categoryName.indexOf('.');\n  var propertyName;\n\n  if (pos !== -1) {\n    propertyName = categoryValue.categoryName.slice(pos + 1);\n  } else {\n    propertyName = categoryValue.categoryName;\n  }\n\n  var mapKey = propertyName + '.' + categoryValue.name;\n  var filterValue = {};\n\n  if (categoryValue.color && customPropValueColorMap[mapKey]) {\n    filterValue.propertyGroupID = categoryValue.color;\n    var rgbColorValue = getFilterColorRGBValue(categoryValue.color);\n    filterValue.colorValue = rgbColorValue;\n  } else {\n    filterValue.propertyGroupID = getFilterColorValue(categoryValue.colorIndex);\n    filterValue.colorIndex = categoryValue.colorIndex;\n    filterValue.colorValue = getFilterColorRGBValue('aw-charts-chartColor' + (categoryValue.colorIndex % 9 + 1));\n  }\n\n  if (categoryType === 'DateFilter') {\n    if (categoryValue.colorIndex >= categoryDrillDown) {\n      if (categoryValue.internalName !== '$NONE') {\n        filterValue.startValue = categoryValue.startDateValue;\n        filterValue.endValue = categoryValue.endDateValue;\n      } else {\n        filterValue.startValue = '$NONE';\n      }\n    }\n  } else {\n    filterValue.startValue = categoryValue.internalName;\n    filterValue.endValue = '';\n  }\n\n  return filterValue;\n};\n/**\n * Returns filter RGB values for a category to be shown in viewer\n * @param {STRING} color color\n * @returns {Object} filter Color RGB value\n */\n\nexport let getFilterColorRGBValue = function (color) {\n  var colorBlock = '.aw-ui-filterNameColorBlock';\n  var colorBlockElement = $(colorBlock);\n  var elementExists = colorBlockElement && colorBlockElement.length > 0;\n\n  if (!elementExists) {\n    //in the case of ACE filter panel, the rendering of the panel is delayed\n    colorBlock = '.aw-layout-globalToolbarPanel';\n    colorBlockElement = $(colorBlock);\n    elementExists = colorBlockElement && colorBlockElement.length > 0;\n  }\n\n  if (elementExists) {\n    var p = colorBlockElement[0];\n    var replacedClassName = p.className;\n    p.className = 'aw-ui-filterNameColorBlock ' + color;\n    var style2 = window.getComputedStyle(p, null).getPropertyValue('background-color');\n    p.className = replacedClassName;\n    return style2;\n  }\n\n  return '';\n};\n/**\n * Returns filter values for a category to be shown in panel\n * @param {Integer} index index\n * @returns {Object} filter value\n */\n\nexport let getFilterColorValue = function (index) {\n  return index > -1 ? 'aw-charts-chartColor' + (index % 9 + 1) : '';\n};\n/**\n * Get property name from filter name.\n *\n * @param {String} filterName - The filter name\n * @return {propName} property name\n */\n\nexport let getPropertyFromFilter = function (filterName) {\n  var propName = filterName;\n  var YEAR_SUFFIX = '_0Z0_year';\n  var YEAR_MONTH_SUFFIX = '_0Z0_year_month';\n  var WEEK_SUFFIX = '_0Z0_week';\n  var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';\n\n  if (_.endsWith(filterName, YEAR_MONTH_DAY_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_MONTH_DAY_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, WEEK_SUFFIX) === true) {\n    propName = filterName.replace(WEEK_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, YEAR_MONTH_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_MONTH_SUFFIX, '');\n  }\n\n  if (_.endsWith(filterName, YEAR_SUFFIX) === true) {\n    propName = filterName.replace(YEAR_SUFFIX, '');\n  }\n\n  return propName;\n};\n/**\n * Get formatted date.\n *\n * @param {String} dateString - input date\n *\n * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range\n *\n * @return {formattedDate} formatted date\n */\n\nexport let getFormattedFilterDate = function (dateString, isDateRangeToDate) {\n  var formattedDate;\n\n  if (dateString === '*') {\n    if (isDateRangeToDate) {\n      formattedDate = ENDING_OF_TIME;\n    } else {\n      formattedDate = BEGINNING_OF_TIME;\n    }\n  } else {\n    try {\n      var date = convertToUTC(new Date(dateString));\n      formattedDate = dateTimeService.formatUTC(date);\n    } catch (e) {\n      logger.error('The specified date is invalid and will be ignored for the search:', dateString);\n      return null;\n    }\n  }\n\n  return formattedDate;\n};\n/**\n * Get formatted numeric range filter.\n *\n * @param {String} filterValue - filterValue\n *\n * @return {formattedNumber} formatted filter\n */\n\nexport let getFormattedFilterNumber = function (filterValue) {\n  var formattedFilter = {};\n  var startToEnd = filterValue.split(' TO ');\n  var startNumber = parseFloat(startToEnd[0]);\n  var endNumber = parseFloat(startToEnd[1]);\n\n  if (isNaN(startNumber) && isNaN(endNumber)) {\n    logger.error('The specified range is invalid and will be ignored for the search:', filterValue);\n    return null;\n  } else if (startToEnd[0] === '*') {\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: 0,\n      endNumericValue: endNumber,\n      startEndRange: NumericRangeBlankStart\n    };\n  } else if (startToEnd[1] === '*') {\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: startNumber,\n      endNumericValue: 0,\n      startEndRange: NumericRangeBlankEnd\n    };\n  } else {\n    if (isNaN(startNumber) || isNaN(endNumber)) {\n      logger.error('The specified range is invalid and will be ignored for the search:', filterValue);\n      return null;\n    }\n\n    formattedFilter = {\n      searchFilterType: 'NumericFilter',\n      startNumericValue: startNumber,\n      endNumericValue: endNumber,\n      startEndRange: NUMERIC_RANGE\n    };\n  }\n\n  return formattedFilter;\n};\n/**\n * Get Range Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\n\nexport let getRangeSearchFilter = function (filterType, filterValue) {\n  // range search.\n  var searchFilter;\n  var startToEnd = filterValue.split(' TO ');\n\n  if (filterType === 'NumericFilter') {\n    searchFilter = getFormattedFilterNumber(filterValue);\n  } else if (filterType === 'DateFilter') {\n    var startDate = getFormattedFilterDate(startToEnd[0].trim(), false);\n    var endDate = getFormattedFilterDate(startToEnd[1].trim(), true);\n\n    if (startDate && endDate) {\n      searchFilter = {\n        searchFilterType: filterType,\n        startDateValue: startDate,\n        endDateValue: endDate\n      };\n    }\n  } else {\n    // String type, but string type should not support range search,\n    // so treat the \" TO \" as just part of the filter value\n    searchFilter = {\n      searchFilterType: filterType,\n      stringValue: filterValue\n    };\n  }\n\n  return searchFilter;\n};\n/**\n * Get Single Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\n\nexport let getSingleSearchFilter = function (filterType, filterValue) {\n  // range search.\n  var searchFilter;\n\n  if (filterType === 'NumericFilter') {\n    try {\n      var formattedNumber = parseFloat(filterValue);\n\n      if (isNaN(formattedNumber)) {\n        logger.error('The specified number is invalid and will be ignored for the search:', filterValue);\n      } else {\n        searchFilter = {\n          searchFilterType: filterType,\n          startNumericValue: formattedNumber,\n          endNumericValue: formattedNumber,\n          stringValue: filterValue\n        };\n      }\n    } catch (e) {\n      logger.error('The specified number is invalid and will be ignored for the search:', filterValue);\n    }\n  } else {\n    // Date type is also treated as String, if it's not date range.\n    searchFilter = {\n      searchFilterType: 'StringFilter',\n      stringValue: filterValue\n    };\n  }\n\n  return searchFilter;\n};\n/**\n * Get filter type based on the value type.\n *\n * @param {Integer} valueType - The valueType for this property\n *\n * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)\n */\n\nexport let getFilterType = function (valueType) {\n  var filterType;\n\n  switch (valueType) {\n    case 2:\n      filterType = 'DateFilter';\n      break;\n\n    case 3:\n    case 4:\n    case 5:\n    case 7:\n      filterType = 'NumericFilter';\n      break;\n\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n      // filterType = 'ObjectFilter';\n      // ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.\n      filterType = 'StringFilter';\n      break;\n\n    default:\n      filterType = 'StringFilter';\n      break;\n  }\n\n  return filterType;\n};\n/**\n * Display search prefilter error\n *\n * @param {String} prefilter - The search prefilter\n *\n */\n\nexport let displayPrefilterError = function (prefilter) {\n  var msg = _invalidPrefilter.replace('{0}', prefilter);\n\n  messagingService.showError(msg);\n};\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.\n * This is used to overide filter color in filter panel.\n * Preference value is in formate <propertyname>.<value>:<colorValue>\n */\n\nexport let getPreferenceValue = () => {\n  let values = appCtxService.getCtx('preferences.AWC_CustomPropValueColor');\n\n  if (values && values[0]) {\n    for (var i = 0; i < values.length; i++) {\n      var prefVal = values[i];\n      var pos = prefVal.indexOf(':');\n      var color = prefVal.slice(pos + 1);\n      var property = prefVal.slice(0, pos);\n      customPropValueColorMap[property] = color;\n    }\n  }\n};\n/**\n * get filter color\n *\n * @param propertyName filter name\n *\n * @returns color color code need to be applied for filter\n */\n\nexport let getCustomPropValueColorMap = function (propertyName) {\n  return customPropValueColorMap[propertyName];\n};\n/**\n * set filter color\n *\n * @param propertyName filter name\n *\n * @param color color code need to be applied for filter\n */\n\nexport let setCustomPropValueColorMap = function (propertyName, color) {\n  customPropValueColorMap[propertyName] = color;\n};\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.\n */\n\nexport let applyCustomColor = function (categoryName, categoryValue, filterValue) {\n  var pos = categoryName.indexOf('.');\n  var propertyName;\n\n  if (pos !== -1) {\n    propertyName = categoryName.slice(pos + 1);\n  } else {\n    propertyName = categoryName;\n  }\n\n  var mapKey = propertyName + '.' + categoryValue.stringValue; //Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference\n\n  if (customPropValueColorMap[mapKey]) {\n    if (categoryValue.colorValue) {\n      //This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later\n      filterValue.color = categoryValue.colorValue;\n    } else {\n      //This scenario will be hit in the cases where color value is not being populated by server response\n      filterValue.color = customPropValueColorMap[mapKey];\n    }\n  }\n};\n/**\n * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not\n * @param { Object } category - the current category\n * @returns { Boolean } true/false\n */\n\nexport let checkIfFilterValuesExist = function (category) {\n  if (category.filterValues && category.filterValues.length > 0) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true\n * @returns { Boolean } true/false\n */\n\nexport let isLimitedCategoriesFeatureEnabled = function () {\n  var preferenceValue = appCtxService.getCtx('preferences.' + AWC_LIMITED_FILTER_CATEGORIES_ENABLED);\n\n  if (preferenceValue && preferenceValue[0].toLowerCase() === 'true') {\n    return true;\n  }\n\n  return false;\n};\n/**\n * ifFilterSelectedForCategory - check if the current category has some filter as selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let ifFilterSelectedForCategory = function (category) {\n  var filterValuesExist = checkIfFilterValuesExist(category);\n\n  if (filterValuesExist) {\n    for (var index = 0; index < category.filterValues.length; index++) {\n      if (category.filterValues[index].selected) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * isClsCategory - check if the current category is a classification type\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let isClsCategory = category => {\n  if (category.filterValues && (category.filterValues.parentnodes && category.filterValues.parentnodes.length > 0 || category.filterValues.childnodes && category.filterValues.childnodes.length > 0)) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\n\nexport let ifFilterSelectedForCls = category => {\n  var filterValuesExist = isClsCategory(category);\n\n  if (filterValuesExist) {\n    for (var index = 0; index < category.filterValues.parentnodes.length; index++) {\n      if (category.filterValues.parentnodes[index].selected) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * getFilterFocus - return whether to set autoFocus for a filter as true or false\n * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info\n * @param { Object } filter current filter\n * @param { Object } categoryInternalName current category internal name\n * @param { Integer } index - current filter index\n * @returns { Boolean } autoFocus value for the filter - true/false\n */\n\nexport const getFilterFocus = (lastSelectedFilterAndCategoryInfo, filter, categoryInternalName, index) => {\n  let lastAction = lastSelectedFilterAndCategoryInfo ? lastSelectedFilterAndCategoryInfo.lastAction : '';\n\n  switch (lastAction) {\n    case 'selectFilter':\n      if (lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName === filter.categoryName && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName === filter.internalName) {\n        return true;\n      }\n\n      return false;\n\n    case 'dateRangeSearch':\n      if (index === 0 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory === categoryInternalName) {\n        return true;\n      }\n\n      return false;\n\n    case 'numericRangeSearch':\n      if (index === 1 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory === categoryInternalName) {\n        return true;\n      }\n\n      return false;\n\n    default:\n      return false;\n  }\n};\nexport let loadConfiguration = function () {\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidDate', true).then(result => _invalidDateText = result);\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidRange', true).then(result => _invalidRangeText = result);\n  localeSvc.getLocalizedTextFromKey('UIMessages.invalidPrefilter', true).then(result => _invalidPrefilter = result);\n};\nloadConfiguration();\nexport default {\n  HIERARCHICAL_FACET_SEPARATOR,\n  PRESET_CATEGORY,\n  DATE_FILTER,\n  INTERNAL_DATE_FILTER,\n  DATE_RANGE_FILTER,\n  DATE_DRILLDOWN_FILTER,\n  NUMERIC_RANGE_FILTER,\n  INTERNAL_NUMERIC_FILTER,\n  INTERNAL_OBJECT_FILTER,\n  INTERNAL_NUMERIC_RANGE,\n  NUMERIC_FILTER,\n  NUMERIC_RANGE,\n  NumericRangeBlankStart,\n  NumericRangeBlankEnd,\n  NO_STARTDATE,\n  NO_ENDDATE,\n  NO_STARTRANGE,\n  NO_ENDRANGE,\n  BEGINNING_OF_TIME,\n  ENDING_OF_TIME,\n  getDate,\n  isNullDate,\n  validateDates,\n  getDateRangeString,\n  getDateRangeFilter,\n  getDateRangeDisplayString,\n  checkIfValidRange,\n  validateNumericRangeSelected,\n  validateNumericRange,\n  getNumericRangeString,\n  getNumericRangeFilter,\n  getNumericRangeDisplayString,\n  getRealFilterWithNoFilterType,\n  getFilterTypeFromFilterValue,\n  isPresetFilters,\n  setPresetFilters,\n  getHasTypeFilter,\n  setHasTypeFilter,\n  setIncontext,\n  getIncontext,\n  saveIncontextFilterMap,\n  getCategoryInternalName,\n  getCurrentCategory,\n  getPropGroupValues,\n  getPropGroupValue,\n  getFilterColorRGBValue,\n  getFilterColorValue,\n  getPropertyFromFilter,\n  getFormattedFilterDate,\n  getFormattedFilterNumber,\n  getRangeSearchFilter,\n  getSingleSearchFilter,\n  getFilterType,\n  displayPrefilterError,\n  getPreferenceValue,\n  getCustomPropValueColorMap,\n  setCustomPropValueColorMap,\n  applyCustomColor,\n  checkIfFilterValuesExist,\n  isLimitedCategoriesFeatureEnabled,\n  ifFilterSelectedForCategory,\n  isClsCategory,\n  ifFilterSelectedForCls,\n  getFilterFocus\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/searchcore/src/js/filterPanelUtils.js"],"names":["_invalidDateText","_invalidRangeText","_invalidPrefilter","AWC_LIMITED_FILTER_CATEGORIES_ENABLED","HIERARCHICAL_FACET_SEPARATOR","PRESET_CATEGORY","DATE_FILTER","INTERNAL_DATE_FILTER","DATE_RANGE_FILTER","DATE_DRILLDOWN_FILTER","NUMERIC_RANGE_FILTER","INTERNAL_NUMERIC_FILTER","INTERNAL_OBJECT_FILTER","INTERNAL_NUMERIC_RANGE","NUMERIC_FILTER","NUMERIC_RANGE","NumericRangeBlankStart","NumericRangeBlankEnd","INTERNAL_TO","NO_STARTDATE","NO_ENDDATE","NO_STARTRANGE","NO_ENDRANGE","BEGINNING_OF_TIME","ENDING_OF_TIME","START_OF_DAY","_presetFilters","_hasTypeFilter","_incontextFlag","customPropValueColorMap","getDate","dateStr","dateString","_","date","dateTimeService","timeStr","gmtTime","offset","jsDate","isNullDate","dateToTest","validateDates","category","cStartDate","eEndDate","tmpStartDate","moveDateToStartOfDay","tmpEndDate","noStartDate","noEndDate","temp1","startDate","messagingService","tmpOrigEndDate","disable","compare1","compare2","getDateRangeString","fromDateString","endDate","toDateString","moveDateToEndOfDay","getDateRangeFilter","searchFilter","sArr","filter","getDateRangeDisplayString","dateRangeFilter","dateRangeString","checkIfValidRange","startRange","endRange","errorValue","msg","validateNumericRangeSelected","hasValidated","oStartRange","oEndRange","pStartRange","parseFloat","pEndRange","invalidStart","cStartRange","isNaN","invalidEnd","cEndRange","validateNumericRange","noStartRange","noEndRange","isFinite","getNumericRangeString","fromValue","toValue","getNumericRangeFilter","getNumericRangeDisplayString","numericRangeFilter","startEndRange","numericRangeString","getRealFilterWithNoFilterType","realFilter","getFilterTypeFromFilterValue","filterType","isPresetFilters","setPresetFilters","getHasTypeFilter","setHasTypeFilter","setIncontext","getIncontext","saveIncontextFilterMap","inContextMap","tmpValues","data","getCategoryInternalName","getCurrentCategory","response","getPropGroupValues","getPreferenceValue","values","i","categoryValue","getPropGroupValue","pos","propertyName","mapKey","filterValue","rgbColorValue","getFilterColorRGBValue","getFilterColorValue","categoryType","colorBlock","colorBlockElement","$","elementExists","p","replacedClassName","style2","window","index","getPropertyFromFilter","propName","YEAR_SUFFIX","YEAR_MONTH_SUFFIX","WEEK_SUFFIX","YEAR_MONTH_DAY_SUFFIX","filterName","getFormattedFilterDate","formattedDate","convertToUTC","logger","getFormattedFilterNumber","formattedFilter","startToEnd","startNumber","endNumber","searchFilterType","startNumericValue","endNumericValue","getRangeSearchFilter","startDateValue","endDateValue","stringValue","getSingleSearchFilter","formattedNumber","getFilterType","displayPrefilterError","appCtxService","prefVal","color","property","getCustomPropValueColorMap","setCustomPropValueColorMap","applyCustomColor","categoryName","checkIfFilterValuesExist","isLimitedCategoriesFeatureEnabled","preferenceValue","ifFilterSelectedForCategory","filterValuesExist","isClsCategory","ifFilterSelectedForCls","getFilterFocus","lastAction","lastSelectedFilterAndCategoryInfo","loadConfiguration","localeSvc","result"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: This module does not return an API object. The API is only available when the service defined this module is\n * injected by AngularJS.\n *\n * @module js/filterPanelUtils\n */\nimport appCtxService from 'js/appCtxService';\nimport dateTimeService from 'js/dateTimeService';\nimport messagingService from 'js/messagingService';\nimport localeSvc from 'js/localeService';\nimport $ from 'jquery';\nimport logger from 'js/logger';\nimport _ from 'lodash';\n\nvar _invalidDateText = '';\nvar _invalidRangeText = '';\nvar _invalidPrefilter = '';\nvar AWC_LIMITED_FILTER_CATEGORIES_ENABLED = 'AWC_Limited_Filter_Categories_Enabled';\n\nexport let HIERARCHICAL_FACET_SEPARATOR = '/';\nexport let PRESET_CATEGORY = 'WorkspaceObject.object_type';\nexport let DATE_FILTER = 'DateFilter';\nexport let INTERNAL_DATE_FILTER = '_DateFilter_';\nexport let DATE_RANGE_FILTER = 'DateRangeFilter';\nexport let DATE_DRILLDOWN_FILTER = 'DrilldownDateFilter';\nexport let NUMERIC_RANGE_FILTER = 'NumericRangeFilter';\nexport let INTERNAL_NUMERIC_FILTER = '_NumericFilter_';\nexport let INTERNAL_OBJECT_FILTER = '_ObjectFilter_';\nexport let INTERNAL_NUMERIC_RANGE = '_NumericRange_';\nexport let NUMERIC_FILTER = 'NumericFilter';\nexport let NUMERIC_RANGE = 'NumericRange';\nexport let NumericRangeBlankStart = 'NumericRangeBlankStart';\nexport let NumericRangeBlankEnd = 'NumericRangeBlankEnd';\nvar INTERNAL_TO = '_TO_';\nexport let NO_STARTDATE = '*';\nexport let NO_ENDDATE = '2100-12-31';\nexport let NO_STARTRANGE = '';\nexport let NO_ENDRANGE = '';\nexport let BEGINNING_OF_TIME = '0001-01-01T00:00:00';\nexport let ENDING_OF_TIME = '2100-12-31T23:59:59';\nvar START_OF_DAY = '00:00:00';\nvar _presetFilters = true;\nvar _hasTypeFilter = false;\nvar _incontextFlag = false;\nvar customPropValueColorMap = {};\n\n/**\n * Returns a date object.\n *\n * @function getDate\n * @memberOf filterPanelUtils\n *\n * @param {String}dateString - date string to be converted to date object\n *\n * @return {JsDate} a date object.\n */\nexport let getDate = function( dateString ) {\n    var dateStr = dateString.substring( 0, 10 );\n    var date;\n    // change open start/end date to null dates\n    if( _.startsWith( dateStr, '0001-01-0' ) || _.startsWith( dateStr, '2100-12-3' ) ) {\n        date = dateTimeService.getNullDate();\n    } else {\n        var timeStr = dateString.substring( 11, dateString.length - 6 );\n        if( timeStr.indexOf( '59' ) !== -1 ) {\n            dateStr = dateString.replace( timeStr, START_OF_DAY );\n        } else {\n            dateStr = dateString;\n        }\n        date = new Date( dateStr );\n    }\n\n    return date;\n};\n\n/**\n * Returns a UTC date object.\n *\n * @function convertToUTC\n * @memberOf filterPanelUtils\n *\n * @param {Object}date - date object\n *\n * @return {JsDate} a UTC date object.\n */\nfunction convertToUTC( date ) {\n    var gmtTime = date.getTime();\n    var offset = date.getTimezoneOffset();\n    var jsDate = new Date( gmtTime + offset * 60 * 1000 );\n    return new Date( jsDate.getTime() );\n}\n/**\n * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can\n * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the\n * dateTimeService.isNullDate.\n *\n * @function isNullDate\n * @memberOf filterPanelUtils\n *\n * @param {Object} dateToTest - a Date object.\n * @returns {Boolean} - true if it's a null date.\n */\nexport let isNullDate = function( dateToTest ) {\n    if( !dateToTest ) {\n        return true;\n    }\n    return dateToTest.getFullYear() <= 1;\n};\n\n/**\n * Validate dates for category date range.\n *\n * @function validateDates\n * @memberOf filterPanelUtils\n *\n * @param {Object}category - category. This object is modified in this function.\n * @param {Object}startDate - startDate\n * @param {Object}origStartDate - origStartDate\n * @param {Object}endDate - endDate\n * @param {Object}origEndDate - origEndDate\n */\nexport let validateDates = function( category, startDate, origStartDate, endDate, origEndDate ) {\n    category.showSearch = true;\n\n    var cStartDate = category.daterange.startDate;\n    var eEndDate = category.daterange.endDate;\n    if( category.daterange.dateRangeSelected && !cStartDate.valueUpdated && !eEndDate.valueUpdated ) {\n        category.showSearch = false;\n        return;\n    }\n    // The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,\n    // which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.\n    var tmpStartDate = moveDateToStartOfDay( startDate );\n    var tmpEndDate = moveDateToStartOfDay( endDate );\n    var noStartDate = dateTimeService.isNullDate( tmpStartDate );\n    var noEndDate = dateTimeService.isNullDate( tmpEndDate );\n\n    // if both dates are not set, disable search button\n    if( noStartDate && noEndDate ) {\n        category.showSearch = false;\n        return;\n    }\n    var temp1 = dateTimeService.compare( startDate, endDate );\n    // if start date is later than end date, disable search button\n    if( !noStartDate && !noEndDate && startDate !== null && temp1 === 1 ) {\n        messagingService.showError( _invalidDateText );\n        category.showSearch = false;\n        return;\n    }\n\n    var disable;\n    // check if dates vary from previous search to avoid enabling search\n    var tmpOrigEndDate = moveDateToStartOfDay( origEndDate );\n\n    if( noStartDate ) {\n        // check if there is no startdate and if end date is same, disable search button\n        disable = category.daterange.startDate === null &&\n            dateTimeService.compare( tmpEndDate, tmpOrigEndDate ) === 0;\n    } else if( noEndDate ) {\n        // check if there is no enddate and  start date is same, disable search button\n        disable = category.daterange.endDate === null &&\n            dateTimeService.compare( startDate, category.daterange.startDate.dateApi.dateObject ) === 0;\n    } else {\n        // if the dates are same as previous search, disable search button\n        var compare1 = dateTimeService.compare( startDate, origStartDate ) === 0;\n        var compare2 = dateTimeService.compare( endDate, tmpOrigEndDate ) === 0;\n        disable = compare1 && compare2;\n    }\n    category.showSearch = !disable;\n};\n\n/**\n * get date range filter.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {Object}startDate - startDate\n * @param {Object}endDate - endDate\n *\n * @return {String} a string that represents the date range.\n */\nexport let getDateRangeString = function( startDate, endDate ) {\n    var noStartDate = isNullDate( startDate );\n    var noEndDate = isNullDate( endDate );\n    var fromDateString = noStartDate ? NO_STARTDATE : dateTimeService.formatUTC( startDate );\n    if( noEndDate ) {\n        endDate = new Date( NO_ENDDATE );\n    }\n    var toDateString = dateTimeService.formatUTC( moveDateToEndOfDay( endDate ) );\n    return INTERNAL_DATE_FILTER + fromDateString + INTERNAL_TO + toDateString;\n};\n\n/**\n * get filter of date range.\n *\n * @function getDateRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a filter object of date range for the filter string.\n */\nexport let getDateRangeFilter = function( filter ) {\n    var searchFilter = {};\n    var sArr = filter.split( INTERNAL_TO );\n    searchFilter.searchFilterType = 'DateFilter';\n    sArr[ 0 ] = sArr[ 0 ] === NO_STARTDATE ? dateTimeService.NULLDATE : dateTimeService.formatUTC( sArr[ 0 ] );\n    searchFilter.startDateValue = sArr[ 0 ];\n    searchFilter.endDateValue = sArr[ 1 ];\n    return searchFilter;\n};\n\n/**\n * get a date range filter with display name and category type.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}startDate - startDate\n * @param {String}endDate - endDate\n *\n * @return {Object} a date range filter with display name and category type.\n */\nexport let getDateRangeDisplayString = function( startDate, endDate ) {\n    var dateRangeFilter = {};\n    var noStartDate = dateTimeService.isNullDate( startDate );\n    var noEndDate = dateTimeService.isNullDate( endDate );\n    var dateRangeString;\n    if( noStartDate ) {\n        dateRangeString = 'To ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );\n    } else if( noEndDate ) {\n        dateRangeString = 'From ' +\n            dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 );\n    } else {\n        dateRangeString = dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 ) +\n            ' - ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );\n    }\n    dateRangeFilter.displayName = dateRangeString;\n    dateRangeFilter.categoryType = DATE_RANGE_FILTER;\n    return dateRangeFilter;\n};\n\n/**\n * Simple check to validate the given category numeric range.\n *\n * @function checkIfValidRange\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n *\n * @return {Boolean} true if valid range.\n */\nexport let checkIfValidRange = function( category, startRange, endRange ) {\n    category.showSearch = true;\n\n    if( startRange !== null && endRange !== null && startRange > endRange ) {\n        var errorValue = startRange + '-' + endRange;\n        var msg = _invalidRangeText.replace( '{0}', errorValue );\n        messagingService.showError( msg );\n        category.showSearch = false;\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Validate the given category numeric range if the range is selected.\n *\n * @function validateNumericRangeSelected\n * @memberOf filterPanelUtils\n *\n * @param {String}category - category\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {Number}cStartRange - current startRange\n * @param {Number}cEndRange - current endRange\n * @return {Boolean} true if valid range.\n */\nexport let validateNumericRangeSelected = function( category, startRange, endRange, cStartRange, cEndRange ) {\n    var hasValidated = false;\n\n    var oStartRange = category.numericrange.filter.startNumericValue;\n    var oEndRange = category.numericrange.filter.endNumericValue;\n\n    var pStartRange = parseFloat( cStartRange );\n    var pEndRange = parseFloat( cEndRange );\n\n    var invalidStart = cStartRange === oStartRange || pStartRange === oStartRange ||\n        isNaN( pStartRange ) && oStartRange === NO_STARTRANGE;\n    // when the start range goes from blank to 0, it's a real change, so the search button should be enabled.\n    if( category.numericrange.filter.startEndRange === NumericRangeBlankStart ) {\n        invalidStart = isNaN( pStartRange );\n    }\n    var invalidEnd = cEndRange === oEndRange || pEndRange === oEndRange || isNaN( pEndRange ) && oEndRange === NO_ENDRANGE;\n    if( category.numericrange.filter.startEndRange === NumericRangeBlankEnd ) {\n        invalidEnd = isNaN( pEndRange );\n    }\n    // when the end range goes from blank to 0, it's a real change, so the search button should be enabled.\n    if( invalidStart && invalidEnd ) {\n        category.showSearch = false;\n        hasValidated = true;\n    }\n    return hasValidated;\n};\n/**\n * Validate ranges for category numeric range.\n *\n * @function validateNumericRange\n * @memberOf filterPanelUtils\n *\n * @param {String} category - category\n * @param {String} startRange - startRange\n * @param {String} endRange - endRange\n *\n */\nexport let validateNumericRange = function( category, startRange, endRange ) {\n    category.showSearch = true;\n\n    // Validate values to be numbers\n    var cStartRange = category.numericrange.startValue.dbValue;\n    var cEndRange = category.numericrange.endValue.dbValue;\n    var oStartRange = null;\n    var oEndRange = null;\n\n    if( category.numericrange.numericRangeSelected && validateNumericRangeSelected( category, startRange, endRange, cStartRange, cEndRange ) ) {\n        return;\n    }\n\n    var noStartRange = cStartRange === undefined || cStartRange === null || cStartRange === '';\n    var noEndRange = cEndRange === undefined || cEndRange === null || cEndRange === '';\n\n    // if both numbers are not set, disable search button\n    if( noStartRange && noEndRange ) {\n        category.showSearch = false;\n        return;\n    }\n\n    var disable = false;\n    if( noStartRange ) {\n        disable = endRange === oEndRange || isNaN( endRange );\n    } else if( noEndRange ) {\n        // check if there is no endRange and  start number is same, disable search button\n        disable = startRange === oStartRange || isNaN( startRange );\n    } else {\n        disable = !isFinite( startRange ) || isNaN( startRange ) || !isFinite( endRange ) || isNaN( endRange );\n    }\n    category.showSearch = !disable;\n};\n\n/**\n * get numeric range filter string.\n *\n * @function getNumericRangeString\n * @memberOf filterPanelUtils\n *\n * @param {String}startRange - startRange\n * @param {String}endRange - endRange\n *\n * @return {String} a numeric range string.\n */\nexport let getNumericRangeString = function( startRange, endRange ) {\n    var fromValue = startRange && startRange.toString();\n    if( fromValue === undefined || fromValue === null || fromValue.length === 0 || isNaN( fromValue ) ) {\n        fromValue = NO_STARTRANGE;\n    }\n    var toValue = endRange && endRange.toString();\n    if( toValue === undefined || toValue === null || toValue.length === 0 || isNaN( toValue ) ) {\n        toValue = NO_ENDRANGE;\n    }\n    return INTERNAL_NUMERIC_RANGE + fromValue + INTERNAL_TO + toValue;\n};\n\n/**\n * get numeric range filter from a filter string.\n *\n * @function getDateRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} a numeric range filter.\n */\nexport let getNumericRangeFilter = function( filter ) {\n    var searchFilter = {};\n    var sArr = filter.split( INTERNAL_TO );\n    searchFilter.searchFilterType = NUMERIC_FILTER;\n    searchFilter.startNumericValue = parseFloat( sArr[ 0 ] );\n    searchFilter.endNumericValue = parseFloat( sArr[ 1 ] );\n    if( isNaN( searchFilter.startNumericValue ) ) {\n        searchFilter.startEndRange = NumericRangeBlankStart;\n    } else if( isNaN( searchFilter.endNumericValue ) ) {\n        searchFilter.startEndRange = NumericRangeBlankEnd;\n    } else {\n        searchFilter.startEndRange = NUMERIC_RANGE;\n    }\n    return searchFilter;\n};\n\n/**\n * get a numeric range filter.\n *\n * @function getNumericRangeDisplayString\n * @memberOf filterPanelUtils\n *\n * @param {Number}startRange - startRange\n * @param {Number}endRange - endRange\n * @param {String}startEndRange - startEndRange\n *\n * @return {Object} a numeric range filter with display name and category type.\n */\nexport let getNumericRangeDisplayString = function( startRange, endRange, startEndRange ) {\n    var numericRangeFilter = {};\n    var noStartRange = startEndRange === NumericRangeBlankStart || startRange !== 0 && !startRange;\n    var noEndRange = startEndRange === NumericRangeBlankEnd || endRange !== 0 && !endRange;\n\n    var numericRangeString;\n    if( noStartRange ) {\n        numericRangeString = 'To ' + endRange.toString();\n    } else if( noEndRange ) {\n        numericRangeString = 'From ' + startRange.toString();\n    } else {\n        numericRangeString = startRange.toString() + ' - ' + endRange.toString();\n    }\n    numericRangeFilter.displayName = numericRangeString;\n    numericRangeFilter.categoryType = NUMERIC_RANGE_FILTER;\n    return numericRangeFilter;\n};\n\n/**\n * get a real filter.\n *\n * @function getRealFilterWithNoFilterType\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {Object} the real filter stripped off the identifiers.\n */\nexport let getRealFilterWithNoFilterType = function( filter ) {\n    var realFilter = filter;\n    if( !filter.hasOwnProperty( 'property' ) ) {\n        realFilter = filter.replace( INTERNAL_NUMERIC_FILTER, '' ).replace( INTERNAL_OBJECT_FILTER, '' );\n    }\n    return realFilter;\n};\n\n/**\n * get filter type from filter value.\n *\n * @function getFilterTypeFromFilterValue\n * @memberOf filterPanelUtils\n *\n * @param {String}filter - filter\n *\n * @return {String} filter type, if it can be derived.\n */\nexport let getFilterTypeFromFilterValue = function( filter ) {\n    var filterType;\n    if( _.startsWith( filter, INTERNAL_OBJECT_FILTER ) ) {\n        filterType = 'ObjectFilter';\n    } else if( _.startsWith( filter, INTERNAL_NUMERIC_FILTER ) ) {\n        filterType = 'NumericFilter';\n    } else {\n        filterType = 'DateFilter';\n    }\n    return filterType;\n};\n\n/**\n * /** Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\nfunction moveDateToStartOfDay( date ) {\n    if( !dateTimeService.isNullDate( date ) ) {\n        date.setHours( 0, 0, 0 );\n        return date;\n    }\n    return date;\n}\n\n/**\n * Return date to start of the day\n *\n * @param {Date} date a given date\n * @return {Date} date\n */\nfunction moveDateToEndOfDay( date ) {\n    if( !dateTimeService.isNullDate( date ) ) {\n        date.setHours( 23, 59, 59 );\n        return date;\n    }\n    return date;\n}\n\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\nexport let isPresetFilters = function() {\n    return _presetFilters;\n};\n\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag flag\n */\nexport let setPresetFilters = function( flag ) {\n    _presetFilters = flag;\n};\n\n/**\n * Returns true if preset filters are hidden\n *\n * @returns {Object} preset filter flag\n */\nexport let getHasTypeFilter = function() {\n    return _hasTypeFilter;\n};\n\n/**\n * Sets preset filters flag\n *\n * @param {Object} flag preset filter flag\n */\nexport let setHasTypeFilter = function( flag ) {\n    _hasTypeFilter = flag;\n};\n\n/**\n * Sets incontext flag\n *\n * @param {Object} flag incontext flag\n */\nexport let setIncontext = function( flag ) {\n    _incontextFlag = flag;\n};\n\n/**\n * Gets incontext flag\n *\n * @returns {Object} incontext flag\n */\nexport let getIncontext = function() {\n    return _incontextFlag;\n};\n\n/**\n * Save source filter map in appcontext for incontext\n *\n * @param {Object} data data\n */\nexport let saveIncontextFilterMap = function( data ) {\n    let inContextMap = {};\n    if( getHasTypeFilter() ) {\n        // Create a filter value for each category value\n        let tmpValues = data.searchFilterMap[ PRESET_CATEGORY ];\n        inContextMap[ PRESET_CATEGORY ] = tmpValues;\n    }\n    return inContextMap;\n};\n\n/**\n * Returns category internal name\n * @param {Object} category category\n * @returns {Object} The category internal name\n */\nexport let getCategoryInternalName = function( category ) {\n    return category.internalName;\n};\n\n/**\n * Returns current category\n *\n * @param {Object} response the response from the search SOA\n * @returns {Object} The current category\n */\nexport let getCurrentCategory = function( response ) {\n    return response.groupedObjectsList[ 0 ].internalPropertyName;\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n *\n * @param {Object} category the category to get values for\n *\n * @returns {ObjectArray} The array of filters to show in panel\n */\nexport let getPropGroupValues = function( category ) {\n    getPreferenceValue();\n\n    var values = [];\n    for( var i = 0; i < category.filterValues.length; i++ ) {\n        var categoryValue = category.filterValues[ i ];\n        if( categoryValue && ( i < 9 || categoryValue.color ) ) {\n            values.push( getPropGroupValue( category.type, category.drilldown, categoryValue ) );\n        }\n    }\n\n    return values;\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n * @param {String} categoryType categoryType\n * @param {Integer} categoryDrillDown category Drill Down\n * @param {String} categoryValue categoryValue\n * @returns {Object} filter value\n */\nexport let getPropGroupValue = function( categoryType, categoryDrillDown, categoryValue ) {\n    var pos = categoryValue.categoryName.indexOf( '.' );\n    var propertyName;\n\n    if( pos !== -1 ) {\n        propertyName = categoryValue.categoryName.slice( pos + 1 );\n    } else {\n        propertyName = categoryValue.categoryName;\n    }\n    var mapKey = propertyName + '.' + categoryValue.name;\n\n    var filterValue = {};\n    if( categoryValue.color && customPropValueColorMap[ mapKey ] ) {\n        filterValue.propertyGroupID = categoryValue.color;\n        var rgbColorValue = getFilterColorRGBValue( categoryValue.color );\n        filterValue.colorValue = rgbColorValue;\n    } else {\n        filterValue.propertyGroupID = getFilterColorValue( categoryValue.colorIndex );\n        filterValue.colorIndex = categoryValue.colorIndex;\n        filterValue.colorValue = getFilterColorRGBValue( 'aw-charts-chartColor' + ( categoryValue.colorIndex % 9 + 1 ) );\n    }\n\n    if( categoryType === 'DateFilter' ) {\n        if( categoryValue.colorIndex >= categoryDrillDown ) {\n            if( categoryValue.internalName !== '$NONE' ) {\n                filterValue.startValue = categoryValue.startDateValue;\n                filterValue.endValue = categoryValue.endDateValue;\n            } else {\n                filterValue.startValue = '$NONE';\n            }\n        }\n    } else {\n        filterValue.startValue = categoryValue.internalName;\n        filterValue.endValue = '';\n    }\n\n    return filterValue;\n};\n\n/**\n * Returns filter RGB values for a category to be shown in viewer\n * @param {STRING} color color\n * @returns {Object} filter Color RGB value\n */\nexport let getFilterColorRGBValue = function( color ) {\n    var colorBlock = '.aw-ui-filterNameColorBlock';\n    var colorBlockElement = $( colorBlock );\n    var elementExists = colorBlockElement && colorBlockElement.length > 0;\n    if( !elementExists ) {\n        //in the case of ACE filter panel, the rendering of the panel is delayed\n        colorBlock = '.aw-layout-globalToolbarPanel';\n        colorBlockElement = $( colorBlock );\n        elementExists = colorBlockElement && colorBlockElement.length > 0;\n    }\n    if( elementExists ) {\n        var p = colorBlockElement[ 0 ];\n        var replacedClassName = p.className;\n        p.className = 'aw-ui-filterNameColorBlock ' + color;\n        var style2 = window.getComputedStyle( p, null ).getPropertyValue(\n            'background-color' );\n        p.className = replacedClassName;\n        return style2;\n    }\n    return '';\n};\n\n/**\n * Returns filter values for a category to be shown in panel\n * @param {Integer} index index\n * @returns {Object} filter value\n */\nexport let getFilterColorValue = function( index ) {\n    return index > -1 ? 'aw-charts-chartColor' + ( index % 9 + 1 ) : '';\n};\n\n/**\n * Get property name from filter name.\n *\n * @param {String} filterName - The filter name\n * @return {propName} property name\n */\nexport let getPropertyFromFilter = function( filterName ) {\n    var propName = filterName;\n\n    var YEAR_SUFFIX = '_0Z0_year';\n    var YEAR_MONTH_SUFFIX = '_0Z0_year_month';\n    var WEEK_SUFFIX = '_0Z0_week';\n    var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';\n\n    if( _.endsWith( filterName, YEAR_MONTH_DAY_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_MONTH_DAY_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, WEEK_SUFFIX ) === true ) {\n        propName = filterName.replace( WEEK_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, YEAR_MONTH_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_MONTH_SUFFIX, '' );\n    }\n    if( _.endsWith( filterName, YEAR_SUFFIX ) === true ) {\n        propName = filterName.replace( YEAR_SUFFIX, '' );\n    }\n    return propName;\n};\n\n/**\n * Get formatted date.\n *\n * @param {String} dateString - input date\n *\n * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range\n *\n * @return {formattedDate} formatted date\n */\nexport let getFormattedFilterDate = function( dateString, isDateRangeToDate ) {\n    var formattedDate;\n    if( dateString === '*' ) {\n        if( isDateRangeToDate ) {\n            formattedDate = ENDING_OF_TIME;\n        } else {\n            formattedDate = BEGINNING_OF_TIME;\n        }\n    } else {\n        try {\n            var date = convertToUTC( new Date( dateString ) );\n            formattedDate = dateTimeService.formatUTC( date );\n        } catch ( e ) {\n            logger.error( 'The specified date is invalid and will be ignored for the search:', dateString );\n            return null;\n        }\n    }\n    return formattedDate;\n};\n\n/**\n * Get formatted numeric range filter.\n *\n * @param {String} filterValue - filterValue\n *\n * @return {formattedNumber} formatted filter\n */\nexport let getFormattedFilterNumber = function( filterValue ) {\n    var formattedFilter = {};\n    var startToEnd = filterValue.split( ' TO ' );\n    var startNumber = parseFloat( startToEnd[ 0 ] );\n    var endNumber = parseFloat( startToEnd[ 1 ] );\n    if( isNaN( startNumber ) && isNaN( endNumber ) ) {\n        logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );\n        return null;\n    } else if( startToEnd[ 0 ] === '*' ) {\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: 0,\n            endNumericValue: endNumber,\n            startEndRange: NumericRangeBlankStart\n        };\n    } else if( startToEnd[ 1 ] === '*' ) {\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: startNumber,\n            endNumericValue: 0,\n            startEndRange: NumericRangeBlankEnd\n        };\n    } else {\n        if( isNaN( startNumber ) || isNaN( endNumber ) ) {\n            logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );\n            return null;\n        }\n        formattedFilter = {\n            searchFilterType: 'NumericFilter',\n            startNumericValue: startNumber,\n            endNumericValue: endNumber,\n            startEndRange: NUMERIC_RANGE\n        };\n    }\n    return formattedFilter;\n};\n\n/**\n * Get Range Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\nexport let getRangeSearchFilter = function( filterType, filterValue ) {\n    // range search.\n    var searchFilter;\n    var startToEnd = filterValue.split( ' TO ' );\n\n    if( filterType === 'NumericFilter' ) {\n        searchFilter = getFormattedFilterNumber( filterValue );\n    } else if( filterType === 'DateFilter' ) {\n        var startDate = getFormattedFilterDate( startToEnd[ 0 ].trim(), false );\n        var endDate = getFormattedFilterDate( startToEnd[ 1 ].trim(), true );\n        if( startDate && endDate ) {\n            searchFilter = {\n                searchFilterType: filterType,\n                startDateValue: startDate,\n                endDateValue: endDate\n            };\n        }\n    } else {\n        // String type, but string type should not support range search,\n        // so treat the \" TO \" as just part of the filter value\n        searchFilter = {\n            searchFilterType: filterType,\n            stringValue: filterValue\n        };\n    }\n    return searchFilter;\n};\n\n/**\n * Get Single Filter.\n *\n * @param {String} filterType - filter type\n *\n * @param {String} filterValue - filter value\n *\n * @return {searchFilter} Search Filter\n */\nexport let getSingleSearchFilter = function( filterType, filterValue ) {\n    // range search.\n    var searchFilter;\n\n    if( filterType === 'NumericFilter' ) {\n        try {\n            var formattedNumber = parseFloat( filterValue );\n            if( isNaN( formattedNumber ) ) {\n                logger.error( 'The specified number is invalid and will be ignored for the search:',\n                    filterValue );\n            } else {\n                searchFilter = {\n                    searchFilterType: filterType,\n                    startNumericValue: formattedNumber,\n                    endNumericValue: formattedNumber,\n                    stringValue: filterValue\n                };\n            }\n        } catch ( e ) {\n            logger.error( 'The specified number is invalid and will be ignored for the search:', filterValue );\n        }\n    } else {\n        // Date type is also treated as String, if it's not date range.\n        searchFilter = {\n            searchFilterType: 'StringFilter',\n            stringValue: filterValue\n        };\n    }\n\n    return searchFilter;\n};\n\n/**\n * Get filter type based on the value type.\n *\n * @param {Integer} valueType - The valueType for this property\n *\n * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)\n */\nexport let getFilterType = function( valueType ) {\n    var filterType;\n    switch ( valueType ) {\n        case 2:\n            filterType = 'DateFilter';\n            break;\n        case 3:\n        case 4:\n        case 5:\n        case 7:\n            filterType = 'NumericFilter';\n            break;\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n            // filterType = 'ObjectFilter';\n            // ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.\n            filterType = 'StringFilter';\n            break;\n        default:\n            filterType = 'StringFilter';\n            break;\n    }\n    return filterType;\n};\n\n/**\n * Display search prefilter error\n *\n * @param {String} prefilter - The search prefilter\n *\n */\nexport let displayPrefilterError = function( prefilter ) {\n    var msg = _invalidPrefilter.replace( '{0}', prefilter );\n    messagingService.showError( msg );\n};\n\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.\n * This is used to overide filter color in filter panel.\n * Preference value is in formate <propertyname>.<value>:<colorValue>\n */\nexport let getPreferenceValue = () => {\n    let values = appCtxService.getCtx( 'preferences.AWC_CustomPropValueColor' );\n    if( values && values[ 0 ] ) {\n        for( var i = 0; i < values.length; i++ ) {\n            var prefVal = values[ i ];\n            var pos = prefVal.indexOf( ':' );\n            var color = prefVal.slice( pos + 1 );\n            var property = prefVal.slice( 0, pos );\n            customPropValueColorMap[ property ] = color;\n        }\n    }\n};\n\n/**\n * get filter color\n *\n * @param propertyName filter name\n *\n * @returns color color code need to be applied for filter\n */\nexport let getCustomPropValueColorMap = function( propertyName ) {\n    return customPropValueColorMap[ propertyName ];\n};\n\n/**\n * set filter color\n *\n * @param propertyName filter name\n *\n * @param color color code need to be applied for filter\n */\nexport let setCustomPropValueColorMap = function( propertyName, color ) {\n    customPropValueColorMap[ propertyName ] = color;\n};\n\n/**\n * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.\n */\nexport let applyCustomColor = function( categoryName, categoryValue, filterValue ) {\n    var pos = categoryName.indexOf( '.' );\n    var propertyName;\n\n    if( pos !== -1 ) {\n        propertyName = categoryName.slice( pos + 1 );\n    } else {\n        propertyName = categoryName;\n    }\n    var mapKey = propertyName + '.' + categoryValue.stringValue;\n\n    //Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference\n    if( customPropValueColorMap[ mapKey ] ) {\n        if( categoryValue.colorValue ) {\n            //This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later\n            filterValue.color = categoryValue.colorValue;\n        } else {\n            //This scenario will be hit in the cases where color value is not being populated by server response\n            filterValue.color = customPropValueColorMap[ mapKey ];\n        }\n    }\n};\n\n/**\n * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not\n * @param { Object } category - the current category\n * @returns { Boolean } true/false\n */\n\nexport let checkIfFilterValuesExist = function( category ) {\n    if( category.filterValues && category.filterValues.length > 0 ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true\n * @returns { Boolean } true/false\n */\n\nexport let isLimitedCategoriesFeatureEnabled = function() {\n    var preferenceValue = appCtxService.getCtx( 'preferences.' + AWC_LIMITED_FILTER_CATEGORIES_ENABLED );\n    if( preferenceValue && preferenceValue[ 0 ].toLowerCase() === 'true' ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * ifFilterSelectedForCategory - check if the current category has some filter as selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let ifFilterSelectedForCategory = function( category ) {\n    var filterValuesExist = checkIfFilterValuesExist( category );\n    if( filterValuesExist ) {\n        for( var index = 0; index < category.filterValues.length; index++ ) {\n            if( category.filterValues[ index ].selected ) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * isClsCategory - check if the current category is a classification type\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let isClsCategory = ( category ) => {\n    if( category.filterValues && ( category.filterValues.parentnodes &&\n            category.filterValues.parentnodes.length > 0 || category.filterValues.childnodes && category.filterValues.childnodes.length > 0 ) ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected\n * @param { Object } category the current category\n * @returns { Boolean } true/false\n */\nexport let ifFilterSelectedForCls = ( category ) => {\n    var filterValuesExist = isClsCategory( category );\n    if( filterValuesExist ) {\n        for( var index = 0; index < category.filterValues.parentnodes.length; index++ ) {\n            if( category.filterValues.parentnodes[ index ].selected ) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * getFilterFocus - return whether to set autoFocus for a filter as true or false\n * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info\n * @param { Object } filter current filter\n * @param { Object } categoryInternalName current category internal name\n * @param { Integer } index - current filter index\n * @returns { Boolean } autoFocus value for the filter - true/false\n */\nexport const getFilterFocus = ( lastSelectedFilterAndCategoryInfo, filter, categoryInternalName, index ) => {\n    let lastAction = lastSelectedFilterAndCategoryInfo ? lastSelectedFilterAndCategoryInfo.lastAction : '';\n    switch( lastAction ) {\n        case 'selectFilter':\n            if( lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName === filter.categoryName &&\n                lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName === filter.internalName ) {\n                return true;\n            }\n            return false;\n        case 'dateRangeSearch':\n            if( index === 0 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory === categoryInternalName ) {\n                return true;\n            }\n            return false;\n        case 'numericRangeSearch':\n            if( index === 1 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory === categoryInternalName ) {\n                return true;\n            }\n            return false;\n        default:\n            return false;\n    }\n};\n\nexport let loadConfiguration = function() {\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidDate', true ).then( result => _invalidDateText = result );\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidRange', true ).then( result => _invalidRangeText = result );\n    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidPrefilter', true ).then( result => _invalidPrefilter = result );\n};\n\nloadConfiguration();\n\nexport default {\n    HIERARCHICAL_FACET_SEPARATOR,\n    PRESET_CATEGORY,\n    DATE_FILTER,\n    INTERNAL_DATE_FILTER,\n    DATE_RANGE_FILTER,\n    DATE_DRILLDOWN_FILTER,\n    NUMERIC_RANGE_FILTER,\n    INTERNAL_NUMERIC_FILTER,\n    INTERNAL_OBJECT_FILTER,\n    INTERNAL_NUMERIC_RANGE,\n    NUMERIC_FILTER,\n    NUMERIC_RANGE,\n    NumericRangeBlankStart,\n    NumericRangeBlankEnd,\n    NO_STARTDATE,\n    NO_ENDDATE,\n    NO_STARTRANGE,\n    NO_ENDRANGE,\n    BEGINNING_OF_TIME,\n    ENDING_OF_TIME,\n    getDate,\n    isNullDate,\n    validateDates,\n    getDateRangeString,\n    getDateRangeFilter,\n    getDateRangeDisplayString,\n    checkIfValidRange,\n    validateNumericRangeSelected,\n    validateNumericRange,\n    getNumericRangeString,\n    getNumericRangeFilter,\n    getNumericRangeDisplayString,\n    getRealFilterWithNoFilterType,\n    getFilterTypeFromFilterValue,\n    isPresetFilters,\n    setPresetFilters,\n    getHasTypeFilter,\n    setHasTypeFilter,\n    setIncontext,\n    getIncontext,\n    saveIncontextFilterMap,\n    getCategoryInternalName,\n    getCurrentCategory,\n    getPropGroupValues,\n    getPropGroupValue,\n    getFilterColorRGBValue,\n    getFilterColorValue,\n    getPropertyFromFilter,\n    getFormattedFilterDate,\n    getFormattedFilterNumber,\n    getRangeSearchFilter,\n    getSingleSearchFilter,\n    getFilterType,\n    displayPrefilterError,\n    getPreferenceValue,\n    getCustomPropValueColorMap,\n    setCustomPropValueColorMap,\n    applyCustomColor,\n    checkIfFilterValuesExist,\n    isLimitedCategoriesFeatureEnabled,\n    ifFilterSelectedForCategory,\n    isClsCategory,\n    ifFilterSelectedForCls,\n    getFilterFocus\n};\n"]},"metadata":{},"sourceType":"module"}