{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * @module js/tcCommandVisibilityService2\n */\nimport appCtxService from 'js/appCtxService';\nimport DataLoader from 'dataloader';\nimport { postUnchecked, getPendingRequestsCount } from 'soa/kernel/soaService';\nimport Debug from 'debug';\nimport async from 'js/async.service';\n/**\n * How long to wait after the last \"request\" to load visibility before actually making the SOA call.\n * Because command bars will not render if server visibility is not ready this is also the minimum\n * delay before a command bar will appear.\n *\n * Will probably be reworked in the future\n */\n\nconst commandBatchLoadTime = 100;\nconst trace = new Debug('command:tcCommandVisibilityService2');\n/**\n  * Unlock detection function\n  *\n  * @returns {Boolean} If the service is unlocked\n  */\n\nvar unlockFunction = function () {\n  if (getPendingRequestsCount() !== 0) {\n    trace('Visibility service is locked - SOA is active');\n    return false;\n  }\n\n  return true;\n};\n/**\n * Get a dataloader that batches up calls to the getVisibleCommands SOA\n * @returns {DataLoader} Server visibility dataloader\n */\n\n\nexport const getServerVisibilityLoader = () => {\n  return new DataLoader(async getVisibleCommandsInfo => {\n    const input = {\n      getVisibleCommandsInfo\n    };\n    trace('Making batched SOA call to load visibility', input);\n    const response = await postUnchecked('Internal-AWS2-2016-03-UiConfig', 'getVisibleCommands', input, {}); //New SOA is needed to fully support this use case. SOA accepts multiple sets of info as input but only returns a single list of visible commands\n\n    return getVisibleCommandsInfo.map(() => response.visibleCommandsInfo);\n  }, {\n    //Only batching of requests done at this level. Caching managed at lower levels (ex sublocation)\n    cache: false,\n    batchScheduleFn: callback => {\n      return async.debouncePromise(callback, commandBatchLoadTime, {\n        isUnlocked: unlockFunction\n      })();\n    }\n  });\n};\n/**\n * Startup function to create a shared dataloader and add to ctx\n */\n\nexport const addServerVisibilityLoaderToCtx = () => {\n  trace('Adding shared visibility loader to ctx');\n  appCtxService.registerPartialCtx('services.awCommandVisibilityLoader', getServerVisibilityLoader());\n};\nexport default {\n  addServerVisibilityLoaderToCtx,\n  getServerVisibilityLoader\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/tcCommandVisibilityService2.js"],"names":["commandBatchLoadTime","trace","unlockFunction","getPendingRequestsCount","getServerVisibilityLoader","input","getVisibleCommandsInfo","response","postUnchecked","cache","batchScheduleFn","callback","isUnlocked","addServerVisibilityLoaderToCtx","appCtxService"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA,OAAA,aAAA,MAAA,kBAAA;AACA,OAAA,UAAA,MAAA,YAAA;AACA,SAAA,aAAA,EAAA,uBAAA,QAAA,uBAAA;AACA,OAAA,KAAA,MAAA,OAAA;AACA,OAAA,KAAA,MAAA,kBAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,oBAAoB,GAA1B,GAAA;AAEA,MAAMC,KAAK,GAAG,IAAA,KAAA,CAAd,qCAAc,CAAd;AAEA;AACA;AACA;AACA;AACA;;AACC,IAAIC,cAAc,GAAG,YAAW;EAC7B,IAAIC,uBAAuB,OAA3B,CAAA,EAAsC;IAClCF,KAAK,CAALA,8CAAK,CAALA;IACA,OAAA,KAAA;EACH;;EACD,OAAA,IAAA;AALH,CAAA;AAQD;AACA;AACA;AACA;;;AACA,OAAO,MAAMG,yBAAyB,GAAG,MAAM;EAC3C,OAAO,IAAA,UAAA,CAAgB,MAAA,sBAAA,IAAgC;IACnD,MAAMC,KAAK,GAAG;MACVC;IADU,CAAd;IAGAL,KAAK,CAAA,4CAAA,EAALA,KAAK,CAALA;IACA,MAAMM,QAAQ,GAAG,MAAMC,aAAa,CAAA,gCAAA,EAAA,oBAAA,EAAA,KAAA,EALe,EAKf,CAApC,CALmD,CAMnD;;IACA,OAAOF,sBAAsB,CAAtBA,GAAAA,CAA4B,MAAMC,QAAQ,CAAjD,mBAAOD,CAAP;EAPG,CAAA,EAQJ;IACC;IACAG,KAAK,EAFN,KAAA;IAGCC,eAAe,EAAIC,QAAF,IAAiB;MAC9B,OAAO,KAAK,CAAL,eAAA,CAAA,QAAA,EAAA,oBAAA,EAAuD;QAAEC,UAAU,EAAEV;MAAd,CAAvD,GAAP;IACH;EALF,CARI,CAAP;AADG,CAAA;AAkBP;AACA;AACA;;AACA,OAAO,MAAMW,8BAA8B,GAAG,MAAM;EAChDZ,KAAK,CAALA,wCAAK,CAALA;EACAa,aAAa,CAAbA,kBAAAA,CAAAA,oCAAAA,EAAwEV,yBAAxEU,EAAAA;AAFG,CAAA;AAKP,eAAe;EAAA,8BAAA;EAEXV;AAFW,CAAf","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * @module js/tcCommandVisibilityService2\n */\nimport appCtxService from 'js/appCtxService';\nimport DataLoader from 'dataloader';\nimport { postUnchecked, getPendingRequestsCount  } from 'soa/kernel/soaService';\nimport Debug from 'debug';\nimport async from 'js/async.service';\n\n/**\n * How long to wait after the last \"request\" to load visibility before actually making the SOA call.\n * Because command bars will not render if server visibility is not ready this is also the minimum\n * delay before a command bar will appear.\n *\n * Will probably be reworked in the future\n */\nconst commandBatchLoadTime = 100;\n\nconst trace = new Debug( 'command:tcCommandVisibilityService2' );\n\n/**\n  * Unlock detection function\n  *\n  * @returns {Boolean} If the service is unlocked\n  */\n var unlockFunction = function() {\n    if( getPendingRequestsCount() !== 0 ) {\n        trace( 'Visibility service is locked - SOA is active' );\n        return false;\n    }\n    return true;\n};\n\n/**\n * Get a dataloader that batches up calls to the getVisibleCommands SOA\n * @returns {DataLoader} Server visibility dataloader\n */\nexport const getServerVisibilityLoader = () => {\n    return new DataLoader( async getVisibleCommandsInfo => {\n        const input = {\n            getVisibleCommandsInfo\n        };\n        trace( 'Making batched SOA call to load visibility', input );\n        const response = await postUnchecked( 'Internal-AWS2-2016-03-UiConfig', 'getVisibleCommands', input, {} );\n        //New SOA is needed to fully support this use case. SOA accepts multiple sets of info as input but only returns a single list of visible commands\n        return getVisibleCommandsInfo.map( () => response.visibleCommandsInfo );\n    }, {\n        //Only batching of requests done at this level. Caching managed at lower levels (ex sublocation)\n        cache: false,\n        batchScheduleFn: ( callback ) =>  {\n            return async.debouncePromise( callback, commandBatchLoadTime, { isUnlocked: unlockFunction } )();\n        }\n    } );\n};\n\n/**\n * Startup function to create a shared dataloader and add to ctx\n */\nexport const addServerVisibilityLoaderToCtx = () => {\n    trace( 'Adding shared visibility loader to ctx' );\n    appCtxService.registerPartialCtx( 'services.awCommandVisibilityLoader', getServerVisibilityLoader() );\n};\n\nexport default {\n    addServerVisibilityLoaderToCtx,\n    getServerVisibilityLoader\n};\n"]},"metadata":{},"sourceType":"module"}