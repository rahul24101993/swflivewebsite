{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/* eslint-env es6 */\n\n/**\n * This service provides data patch operation to sepecific data object.\n *\n * @module js/store\n */\nimport _ from 'lodash';\nimport { parseDataPath } from 'js/declReactUtils';\n/**\n * Get data patch based on dispatch action\n * action could be:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {object} data scope for evaluation\n * @param {object} action dispatch action input\n * @returns {Array} patch array\n */\n\nexport function getPatch(data, action) {\n  let res = {};\n\n  if (action.path === undefined) {\n    const scope = action.scope;\n\n    for (var path in action.value) {\n      const value = action.value[path];\n      path = scope ? `${scope}.${path}` : path;\n\n      if (_.get(data, path) !== value) {\n        res[path] = value;\n      }\n    }\n  } else {\n    const path = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n    const value = action.value;\n\n    if (path) {\n      if (_.get(data, path) !== value) {\n        res[path] = value;\n      }\n    } else if (path === '') {\n      res = data !== value && _.isObject(value) ? value : {};\n    } else {\n      // logically if path is always string this is not needed\n      throw Error('getPatch: Invalid path!');\n    }\n  }\n\n  return res;\n}\n/**\n * Update data by specific path\n * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }\n * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }\n * @returns {object} updated data as mutation result\n */\n\nexport const patchData = (patch, data) => _.reduce(patch, (data, value, path) => value === undefined ? _.unset(data, path) && data || data : _.set(data, path, value), data);\n/**\n * Update data. Only works for immutable framework\n * action could be:\n * {\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {function} updateFn view update function\n * @returns {function} updateFn accepts data and action\n */\n\nexport const createReducer = updateFn => (data, action) => {\n  const patch = getPatch(data, action);\n\n  if (!_.isEmpty(patch)) {\n    return updateFn(patch, data);\n  }\n\n  return data;\n};\n/**\n * reducer for react Reducer hook, return 'immutable' object when value change\n * @param {object} data data object\n * @param {object} action action as { path, value }\n * @returns {function} reducer function used for react hook\n */\n\nexport const reducer = createReducer((patch, data) => ({ ...patchData(patch, data)\n}));\n/**\n * compose key-dispatch function map to one dispatch function\n * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }\n * @returns {object} function pair dispatch and getDispatch\n */\n\nexport const composeDispatch = dispatchFnMap => {\n  const dispatch = action => {\n    const actions = [];\n\n    if (action.scope) {\n      // this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }\n      actions.push(action);\n    } else if (action.path === undefined) {\n      // re-assemble value to data and ctx\n      // TODO: we can be more smart to identify the scope cluster more accurately\n      // for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can\n      // save more performance\n      const values = action.value;\n\n      const patchMap = _.reduce(values, (res, value, dataPath) => {\n        const {\n          scope,\n          path\n        } = parseDataPath(dataPath);\n        res[scope] = res[scope] || {};\n        res[scope][path] = value;\n        return res;\n      }, {});\n\n      _.forEach(patchMap, (value, scope) => actions.push({\n        scope,\n        value\n      }));\n    } else {\n      // re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to\n      const value = action.value;\n      const dataPath = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n      let {\n        scope,\n        path\n      } = parseDataPath(dataPath); // path should be exist in this else branch, need to maintain that intention\n\n      path = path || '';\n      actions.push({\n        scope,\n        path,\n        value\n      });\n    }\n\n    actions.forEach(action => getDispatch(action.scope)({ ...action,\n      scope: undefined\n    }));\n  };\n\n  const getDispatch = (dataPath, updateFn) => {\n    const {\n      scope,\n      path\n    } = parseDataPath(dataPath); // TODO: error out for last branch\n\n    updateFn = updateFn || dispatchFnMap[scope] || (() => null);\n\n    return path ? action => {\n      action.scope = action.scope ? `${path}.${action.scope}` : path;\n      return updateFn(action);\n    } : updateFn;\n  };\n\n  return {\n    dispatch,\n    getDispatch\n  };\n};","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/store.js"],"names":["res","action","scope","value","path","_","data","Error","patchData","createReducer","updateFn","patch","getPatch","reducer","composeDispatch","dispatchFnMap","dispatch","actions","values","patchMap","parseDataPath","dataPath","undefined","getDispatch"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n/* eslint-env es6 */\n/**\n * This service provides data patch operation to sepecific data object.\n *\n * @module js/store\n */\nimport _ from 'lodash';\nimport {\n    parseDataPath\n} from 'js/declReactUtils';\n\n/**\n * Get data patch based on dispatch action\n * action could be:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     scope: 'ctx.occMgmtCtx',\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {object} data scope for evaluation\n * @param {object} action dispatch action input\n * @returns {Array} patch array\n */\nexport function getPatch( data, action ) {\n    let res = {};\n    if( action.path === undefined ) {\n        const scope = action.scope;\n        for( var path in action.value ) {\n            const value = action.value[ path ];\n            path = scope ? `${scope}.${path}` : path;\n            if( _.get( data, path ) !== value ) {\n                res[ path ] = value;\n            }\n        }\n    } else {\n        const path = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n        const value = action.value;\n        if( path ) {\n            if( _.get( data, path ) !== value ) {\n                res[ path ] = value;\n            }\n        } else if( path === '' ) {\n            res = data !== value && _.isObject( value ) ? value : {};\n        } else {\n            // logically if path is always string this is not needed\n            throw Error( 'getPatch: Invalid path!' );\n        }\n    }\n    return res;\n}\n\n/**\n * Update data by specific path\n * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }\n * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }\n * @returns {object} updated data as mutation result\n */\nexport const patchData = ( patch, data ) => _.reduce( patch,\n    ( data, value, path ) => value === undefined ? _.unset( data, path ) && data || data : _.set( data, path, value ),\n    data\n);\n\n/**\n * Update data. Only works for immutable framework\n * action could be:\n * {\n *     path: 'prop.uiValue',\n *     value: 'myValue'\n * }\n * or:\n * {\n *     value: {\n *         'prop.uiValue': 'my name',\n *         'prop.dbValue': 'my_name'\n *     }\n * }\n * @param {function} updateFn view update function\n * @returns {function} updateFn accepts data and action\n */\nexport const createReducer = ( updateFn ) => ( data, action ) => {\n    const patch = getPatch( data, action );\n    if( !_.isEmpty( patch ) ) {\n        return updateFn( patch, data );\n    }\n    return data;\n};\n\n/**\n * reducer for react Reducer hook, return 'immutable' object when value change\n * @param {object} data data object\n * @param {object} action action as { path, value }\n * @returns {function} reducer function used for react hook\n */\nexport const reducer = createReducer( ( patch, data ) => ( { ...patchData( patch, data ) } ) );\n\n/**\n * compose key-dispatch function map to one dispatch function\n * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }\n * @returns {object} function pair dispatch and getDispatch\n */\nexport const composeDispatch = ( dispatchFnMap ) => {\n    const dispatch = action => {\n        const actions = [];\n        if( action.scope ) {\n            // this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }\n            actions.push( action );\n        } else if( action.path === undefined ) {\n            // re-assemble value to data and ctx\n            // TODO: we can be more smart to identify the scope cluster more accurately\n            // for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can\n            // save more performance\n            const values = action.value;\n            const patchMap = _.reduce( values, ( res, value, dataPath ) => {\n                const { scope, path } = parseDataPath( dataPath );\n                res[ scope ] = res[ scope ] || {};\n                res[ scope ][ path ] = value;\n                return res;\n            }, {} );\n            _.forEach( patchMap, ( value, scope ) => actions.push( { scope, value } ) );\n        } else {\n            // re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to\n            const value = action.value;\n            const dataPath = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;\n            let { scope, path } = parseDataPath( dataPath );\n            // path should be exist in this else branch, need to maintain that intention\n            path = path || '';\n            actions.push( { scope, path, value } );\n        }\n        actions.forEach( action => getDispatch( action.scope )( { ...action, scope: undefined } ) );\n    };\n\n    const getDispatch = ( dataPath, updateFn ) => {\n        const { scope, path } = parseDataPath( dataPath );\n        // TODO: error out for last branch\n        updateFn = updateFn || dispatchFnMap[ scope ] || ( () => null );\n\n        return path ? ( action ) => {\n            action.scope = action.scope ? `${path}.${action.scope}` : path;\n            return updateFn( action );\n        } : updateFn;\n    };\n\n    return { dispatch, getDispatch };\n};\n"]},"metadata":{},"sourceType":"module"}