{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to parse the mongo-db like expression.\n *\n * @module js/adapterParserService\n *\n * @namespace adapterParserService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport _ from 'lodash';\nimport assert from 'js/assert';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport moduleLoader from 'js/moduleLoader';\n\nvar _adapterConfigObject;\n\nvar exports = {};\nvar OP_ARRAY = ['$and', '$or'];\nvar _conditionQuickEval = {};\n/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n */\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n *\n * @returns {ObjectArray} objects adapted from source using adapter configuration.\n */\n\nexport let getAdaptedObjectsSync = function (sourceObjects, adapterConfigObject) {\n  var adaptedObjects = [];\n  adaptedObjects = adaptedObjects.concat(sourceObjects);\n  assert(adapterConfigObject, 'The Adapter Config service is not loaded');\n  _adapterConfigObject = adapterConfigObject;\n\n  if (!_.isEmpty(_adapterConfigObject)) {\n    var adoptees = [];\n\n    _.forEach(sourceObjects, function (sourceObject) {\n      var verdictObj = exports.applyConditions(sourceObject);\n\n      if (verdictObj && verdictObj.verdict) {\n        var targetProp = _adapterConfigObject[verdictObj.index].target;\n\n        if (targetProp.prop) {\n          var propObjs = sourceObject.props[targetProp.prop];\n          propObjs = _.isArray(propObjs) ? propObjs : [propObjs];\n\n          _.forEach(propObjs, function (prop) {\n            if (prop && prop.dbValues) {\n              _.forEach(prop.dbValues, function (dbValue) {\n                var modelObject = cdm.getObject(dbValue);\n\n                if (modelObject) {\n                  adoptees.push(modelObject);\n                } else {\n                  adoptees.push(sourceObject);\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n\n    if (adoptees && adoptees.length > 0) {\n      adaptedObjects = adoptees;\n    }\n  }\n\n  return adaptedObjects;\n};\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n * @param {Boolean} isFullyAdapted - if object should be recursively adapted\n *\n * @return {Promise} Resolved with an array of adapted objects containing the results of the operation.\n */\n\nexport let getAdaptedObjects = function (sourceObjects, adapterConfigObject, isFullyAdapted) {\n  assert(adapterConfigObject, 'The Adapter Config service is not loaded');\n  _adapterConfigObject = adapterConfigObject;\n\n  if (!_.isEmpty(_adapterConfigObject)) {\n    var promises = [];\n    var adoptees = [];\n\n    _.forEach(sourceObjects, function (sourceObject) {\n      promises.push(_getAdaptedObjectSource(sourceObject, isFullyAdapted));\n    });\n\n    return AwPromiseService.instance.all(promises).then(function (results) {\n      _.forEach(results, function (result) {\n        adoptees = adoptees.concat(result);\n      });\n\n      return adoptees;\n    });\n  }\n\n  return AwPromiseService.instance.resolve(sourceObjects);\n};\n/**\n * This is to set the adapter config object\n *\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n */\n\nexport let setConfiguration = function (adapterConfigObject) {\n  _adapterConfigObject = adapterConfigObject;\n};\n/**\n * This method apply and evaluate the conditions on the source object and returns boolean value accordingly.\n *\n * @param {Object} sourceObject - source object\n * @param {Object} configObject - solution config object in case this function is called from a different context\n * @returns {Object} verdict object\n */\n\nexport let applyConditions = function (sourceObject, configObject) {\n  var index = 0;\n  var verdict = false;\n\n  if (!_.isUndefined(configObject)) {\n    _adapterConfigObject = configObject;\n  }\n\n  while (index < _adapterConfigObject.length) {\n    var adaptrObjConf = _adapterConfigObject[index];\n    var adaptrObjConfConds = adaptrObjConf.conditions;\n\n    if (adaptrObjConfConds) {\n      var condKeys = _.keys(adaptrObjConfConds)[0];\n\n      if (_.indexOf(OP_ARRAY, condKeys) >= 0) {\n        verdict = _traverseQueryTree(adaptrObjConfConds, sourceObject)[0];\n      } else {\n        verdict = _evaluateLeafNodes(adaptrObjConfConds, sourceObject);\n      }\n    }\n\n    if (verdict) {\n      break;\n    }\n\n    index++;\n  }\n\n  var verdictObj = {};\n  verdictObj.index = index;\n  verdictObj.verdict = verdict;\n  return verdictObj;\n};\n/**\n * @param {Object} sourceObject - source object\n * @param {Object} verdictObj - verdict object\n *\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\n\nvar _getAdoptees = function (sourceObject, verdictObj) {\n  var deferred = AwPromiseService.instance.defer();\n  var allAdoptees = [];\n\n  if (verdictObj.verdict) {\n    var targetProp = _adapterConfigObject[verdictObj.index].target;\n\n    if (targetProp.prop) {\n      var adaptedObjs = sourceObject.props[targetProp.prop];\n\n      if (adaptedObjs instanceof Array && adaptedObjs.length > 0) {\n        allAdoptees = allAdoptees.concat(adaptedObjs);\n      } else if (adaptedObjs) {\n        allAdoptees.push(adaptedObjs);\n      }\n    }\n\n    if ((targetProp.method || targetProp.methodAsync) && targetProp.deps) {\n      moduleLoader.loadDependentModule(targetProp.deps).then(function (depModuleObj) {\n        // _deps will be undefined when try to load adapterService inside itself\n        var _depModuleObj = depModuleObj;\n\n        if (!depModuleObj && targetProp.deps === 'js/adapterService') {\n          _depModuleObj = exports;\n        }\n\n        if (targetProp.method) {\n          var ret = _depModuleObj[targetProp.method].apply(_depModuleObj, [allAdoptees]);\n\n          deferred.resolve(ret);\n        } else {\n          var retPromise = _depModuleObj[targetProp.methodAsync].apply(_depModuleObj, [allAdoptees]);\n\n          retPromise.then(function (response) {\n            deferred.resolve(response);\n          }, function (error) {\n            deferred.reject(error);\n          });\n        }\n      });\n    } else {\n      deferred.resolve(allAdoptees);\n    }\n  } else {\n    allAdoptees.push(sourceObject);\n    deferred.resolve(allAdoptees);\n  }\n\n  return deferred.promise;\n};\n/**\n * private object, not exposed out of service This is placeholder of two functions\n */\n\n\nvar _logicalOperator = {};\n/**\n * This takes array of boolean values and evaluate it in AND mode.\n *\n * @param {Object} values - values\n * @return {boolean} verdict\n */\n\n_logicalOperator.$and = function (values) {\n  assert(values instanceof Array, 'Values is not an array');\n  var verdict = true;\n\n  _.forEach(values, function (val) {\n    if (!val) {\n      verdict = false;\n      return false; // to break the loop, not return value\n    }\n  });\n\n  return verdict;\n};\n/**\n * This takes array of boolean values and evaluate it in OR mode\n *\n * @param {Object} values - values\n * @return {Boolean} verdict\n */\n\n\n_logicalOperator.$or = function (values) {\n  assert(values instanceof Array, 'Values is not an array');\n  var verdict = false;\n\n  _.forEach(values, function (val) {\n    if (val) {\n      verdict = true;\n      return false; // to break the loop, not return value\n    }\n  });\n\n  return verdict;\n};\n/**\n *\n * This method traverses the adapter condition file recursively to evaluate it against the source object\n *\n * @param {Object} rootObj - root object\n * @param {Object} sourceObject - source object\n * @return {Array} values\n */\n\n\nvar _traverseQueryTree = function (rootObj, sourceObject) {\n  var values = [];\n\n  _.forEach(rootObj, function (childObj, logicalOps) {\n    if (_.indexOf(OP_ARRAY, logicalOps) >= 0) {\n      assert(childObj instanceof Array, 'The value of and/or logical operators should be in Array');\n      values.push(_logicalOperator[logicalOps](_traverseQueryTree(childObj, sourceObject)));\n    } else if (_.intersection(OP_ARRAY, _.keys(childObj)).length > 0) {\n      values = values.concat(_traverseQueryTree(childObj, sourceObject));\n    } else {\n      var val = _evaluateLeafNodes(childObj, sourceObject);\n\n      if (!_.isUndefined(val)) {\n        values.push(val);\n      }\n    }\n  });\n\n  return values;\n};\n/**\n * @param {Object} leafNode - leaf node\n * @param {Object} sourceObject - source object\n * @return {Boolean|null} TRUE if conditions are valid\n */\n\n\nvar _evaluateLeafNodes = function (leafNode, sourceObject) {\n  var propKey = _.keys(leafNode)[0];\n\n  assert(_.indexOf(OP_ARRAY, propKey) < 0, 'These are not the leaf level nodes to evaluate');\n\n  if (_.indexOf(OP_ARRAY, propKey) < 0) {\n    var propRealValue = _.get(sourceObject, propKey);\n\n    var condition = _.get(leafNode, propKey);\n\n    var condKey = _.keys(condition)[0];\n\n    var condVal = _.get(condition, condKey);\n\n    var compareToKey = propKey + '@' + condKey; // modelType.typeHierarchy@$in\n\n    var compareTo = {};\n    compareTo[compareToKey] = condVal;\n\n    if (!_conditionQuickEval[compareToKey]) {\n      _conditionQuickEval[compareToKey] = expressionParserUtils.getEvaluationFn(condKey, propKey, compareTo);\n    }\n\n    return _conditionQuickEval[compareToKey](condVal, propRealValue);\n  }\n\n  return null;\n};\n/**\n * Retrieves the adapted object recursively.\n *\n * @param {*} sourceObject - source object\n * @param {*} isFullyAdapted - if object should be recursively adapted\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\n\n\nvar _getAdaptedObjectSource = function (sourceObject, isFullyAdapted) {\n  var deferred = AwPromiseService.instance.defer();\n  var adaptedReturnObjects = [];\n  var verdictObject = exports.applyConditions(sourceObject);\n\n  if (verdictObject.verdict) {\n    var adaptedObjectPromise = _getAdoptees(sourceObject, verdictObject);\n\n    adaptedObjectPromise.then(function (adaptedObjects) {\n      if (isFullyAdapted) {\n        var deferredPromises = [];\n\n        _.forEach(adaptedObjects, function (adaptedObject) {\n          deferredPromises.push(_getAdaptedObjectSource(adaptedObject, isFullyAdapted));\n        });\n\n        AwPromiseService.instance.all(deferredPromises).then(function (results) {\n          _.forEach(results, function (result) {\n            adaptedReturnObjects = adaptedReturnObjects.concat(result);\n          });\n\n          deferred.resolve(adaptedReturnObjects);\n        });\n      } else {\n        deferred.resolve(adaptedObjects);\n      }\n    });\n  } else {\n    adaptedReturnObjects.push(sourceObject);\n    deferred.resolve(adaptedReturnObjects);\n  }\n\n  return deferred.promise;\n};\n\nexports = {\n  getAdaptedObjectsSync,\n  getAdaptedObjects,\n  setConfiguration,\n  applyConditions\n};\nexport default exports;","map":{"version":3,"names":["AwPromiseService","cdm","_","assert","expressionParserUtils","moduleLoader","_adapterConfigObject","exports","OP_ARRAY","_conditionQuickEval","getAdaptedObjectsSync","sourceObjects","adapterConfigObject","adaptedObjects","concat","isEmpty","adoptees","forEach","sourceObject","verdictObj","applyConditions","verdict","targetProp","index","target","prop","propObjs","props","isArray","dbValues","dbValue","modelObject","getObject","push","length","getAdaptedObjects","isFullyAdapted","promises","_getAdaptedObjectSource","instance","all","then","results","result","resolve","setConfiguration","configObject","isUndefined","adaptrObjConf","adaptrObjConfConds","conditions","condKeys","keys","indexOf","_traverseQueryTree","_evaluateLeafNodes","_getAdoptees","deferred","defer","allAdoptees","adaptedObjs","Array","method","methodAsync","deps","loadDependentModule","depModuleObj","_depModuleObj","ret","apply","retPromise","response","error","reject","promise","_logicalOperator","$and","values","val","$or","rootObj","childObj","logicalOps","intersection","leafNode","propKey","propRealValue","get","condition","condKey","condVal","compareToKey","compareTo","getEvaluationFn","adaptedReturnObjects","verdictObject","adaptedObjectPromise","deferredPromises","adaptedObject"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/adapterParserService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used to parse the mongo-db like expression.\n *\n * @module js/adapterParserService\n *\n * @namespace adapterParserService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport _ from 'lodash';\nimport assert from 'js/assert';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport moduleLoader from 'js/moduleLoader';\n\nvar _adapterConfigObject;\n\nvar exports = {};\n\nvar OP_ARRAY = [ '$and', '$or' ];\n\nvar _conditionQuickEval = {};\n\n/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n */\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n *\n * @returns {ObjectArray} objects adapted from source using adapter configuration.\n */\nexport let getAdaptedObjectsSync = function( sourceObjects, adapterConfigObject ) {\n    var adaptedObjects = [];\n    adaptedObjects = adaptedObjects.concat( sourceObjects );\n\n    assert( adapterConfigObject, 'The Adapter Config service is not loaded' );\n    _adapterConfigObject = adapterConfigObject;\n\n    if( !_.isEmpty( _adapterConfigObject ) ) {\n        var adoptees = [];\n        _.forEach( sourceObjects, function( sourceObject ) {\n            var verdictObj = exports.applyConditions( sourceObject );\n            if( verdictObj && verdictObj.verdict ) {\n                var targetProp = _adapterConfigObject[ verdictObj.index ].target;\n                if( targetProp.prop ) {\n                    var propObjs = sourceObject.props[ targetProp.prop ];\n                    propObjs = _.isArray( propObjs ) ? propObjs : [ propObjs ];\n                    _.forEach( propObjs, function( prop ) {\n                        if( prop && prop.dbValues ) {\n                            _.forEach( prop.dbValues, function( dbValue ) {\n                                var modelObject = cdm.getObject( dbValue );\n                                if( modelObject ) {\n                                    adoptees.push( modelObject );\n                                } else {\n                                    adoptees.push( sourceObject );\n                                }\n                            } );\n                        }\n                    } );\n                }\n            }\n        } );\n\n        if( adoptees && adoptees.length > 0 ) {\n            adaptedObjects = adoptees;\n        }\n    }\n\n    return adaptedObjects;\n};\n\n/**\n * This method returns the adapted objects based on a given object. This takes an array of source objects on which\n * the conditions will be applied. If any of the source object satisfies the condition, it takes the target object\n * corresponding to the sourceobject and returns it.\n *\n * @param {Array} sourceObjects - source objects\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n * @param {Boolean} isFullyAdapted - if object should be recursively adapted\n *\n * @return {Promise} Resolved with an array of adapted objects containing the results of the operation.\n */\nexport let getAdaptedObjects = function( sourceObjects, adapterConfigObject, isFullyAdapted ) {\n    assert( adapterConfigObject, 'The Adapter Config service is not loaded' );\n    _adapterConfigObject = adapterConfigObject;\n\n    if( !_.isEmpty( _adapterConfigObject ) ) {\n        var promises = [];\n        var adoptees = [];\n        _.forEach( sourceObjects, function( sourceObject ) {\n            promises.push( _getAdaptedObjectSource( sourceObject, isFullyAdapted ) );\n        } );\n\n        return AwPromiseService.instance.all( promises ).then( function( results ) {\n            _.forEach( results, function( result ) {\n                adoptees = adoptees.concat( result );\n            } );\n            return adoptees;\n        } );\n    }\n    return AwPromiseService.instance.resolve( sourceObjects );\n};\n\n/**\n * This is to set the adapter config object\n *\n * @param {Array} adapterConfigObject - Configuration to base adapting operation on.\n */\nexport let setConfiguration = function( adapterConfigObject ) {\n    _adapterConfigObject = adapterConfigObject;\n};\n\n/**\n * This method apply and evaluate the conditions on the source object and returns boolean value accordingly.\n *\n * @param {Object} sourceObject - source object\n * @param {Object} configObject - solution config object in case this function is called from a different context\n * @returns {Object} verdict object\n */\nexport let applyConditions = function( sourceObject, configObject ) {\n    var index = 0;\n    var verdict = false;\n    if( !_.isUndefined( configObject ) ) {\n        _adapterConfigObject = configObject;\n    }\n    while( index < _adapterConfigObject.length ) {\n        var adaptrObjConf = _adapterConfigObject[ index ];\n        var adaptrObjConfConds = adaptrObjConf.conditions;\n        if( adaptrObjConfConds ) {\n            var condKeys = _.keys( adaptrObjConfConds )[ 0 ];\n            if( _.indexOf( OP_ARRAY, condKeys ) >= 0 ) {\n                verdict = _traverseQueryTree( adaptrObjConfConds, sourceObject )[ 0 ];\n            } else {\n                verdict = _evaluateLeafNodes( adaptrObjConfConds, sourceObject );\n            }\n        }\n        if( verdict ) {\n            break;\n        }\n        index++;\n    }\n\n    var verdictObj = {};\n    verdictObj.index = index;\n    verdictObj.verdict = verdict;\n\n    return verdictObj;\n};\n\n/**\n * @param {Object} sourceObject - source object\n * @param {Object} verdictObj - verdict object\n *\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\nvar _getAdoptees = function( sourceObject, verdictObj ) {\n    var deferred = AwPromiseService.instance.defer();\n    var allAdoptees = [];\n\n    if( verdictObj.verdict ) {\n        var targetProp = _adapterConfigObject[ verdictObj.index ].target;\n        if( targetProp.prop ) {\n            var adaptedObjs = sourceObject.props[ targetProp.prop ];\n            if( adaptedObjs instanceof Array && adaptedObjs.length > 0 ) {\n                allAdoptees = allAdoptees.concat( adaptedObjs );\n            } else if( adaptedObjs ) {\n                allAdoptees.push( adaptedObjs );\n            }\n        }\n\n        if( ( targetProp.method || targetProp.methodAsync ) && targetProp.deps ) {\n            moduleLoader.loadDependentModule( targetProp.deps ).then(\n                function( depModuleObj ) {\n                    // _deps will be undefined when try to load adapterService inside itself\n                    var _depModuleObj = depModuleObj;\n                    if( !depModuleObj && targetProp.deps === 'js/adapterService' ) {\n                        _depModuleObj = exports;\n                    }\n\n                    if( targetProp.method ) {\n                        var ret = _depModuleObj[ targetProp.method ].apply( _depModuleObj, [ allAdoptees ] );\n                        deferred.resolve( ret );\n                    } else {\n                        var retPromise = _depModuleObj[ targetProp.methodAsync ].apply( _depModuleObj, [ allAdoptees ] );\n                        retPromise.then( function( response ) {\n                            deferred.resolve( response );\n                        }, function( error ) {\n                            deferred.reject( error );\n                        } );\n                    }\n                } );\n        } else {\n            deferred.resolve( allAdoptees );\n        }\n    } else {\n        allAdoptees.push( sourceObject );\n        deferred.resolve( allAdoptees );\n    }\n\n    return deferred.promise;\n};\n\n/**\n * private object, not exposed out of service This is placeholder of two functions\n */\nvar _logicalOperator = {};\n\n/**\n * This takes array of boolean values and evaluate it in AND mode.\n *\n * @param {Object} values - values\n * @return {boolean} verdict\n */\n_logicalOperator.$and = function( values ) {\n    assert( values instanceof Array, 'Values is not an array' );\n    var verdict = true;\n    _.forEach( values, function( val ) {\n        if( !val ) {\n            verdict = false;\n            return false; // to break the loop, not return value\n        }\n    } );\n    return verdict;\n};\n\n/**\n * This takes array of boolean values and evaluate it in OR mode\n *\n * @param {Object} values - values\n * @return {Boolean} verdict\n */\n_logicalOperator.$or = function( values ) {\n    assert( values instanceof Array, 'Values is not an array' );\n    var verdict = false;\n    _.forEach( values, function( val ) {\n        if( val ) {\n            verdict = true;\n            return false; // to break the loop, not return value\n        }\n    } );\n    return verdict;\n};\n\n/**\n *\n * This method traverses the adapter condition file recursively to evaluate it against the source object\n *\n * @param {Object} rootObj - root object\n * @param {Object} sourceObject - source object\n * @return {Array} values\n */\nvar _traverseQueryTree = function( rootObj, sourceObject ) {\n    var values = [];\n    _.forEach( rootObj, function( childObj, logicalOps ) {\n        if( _.indexOf( OP_ARRAY, logicalOps ) >= 0 ) {\n            assert( childObj instanceof Array, 'The value of and/or logical operators should be in Array' );\n            values.push( _logicalOperator[ logicalOps ]( _traverseQueryTree( childObj, sourceObject ) ) );\n        } else if( _.intersection( OP_ARRAY, _.keys( childObj ) ).length > 0 ) {\n            values = values.concat( _traverseQueryTree( childObj, sourceObject ) );\n        } else {\n            var val = _evaluateLeafNodes( childObj, sourceObject );\n            if( !_.isUndefined( val ) ) {\n                values.push( val );\n            }\n        }\n    } );\n    return values;\n};\n\n/**\n * @param {Object} leafNode - leaf node\n * @param {Object} sourceObject - source object\n * @return {Boolean|null} TRUE if conditions are valid\n */\nvar _evaluateLeafNodes = function( leafNode, sourceObject ) {\n    var propKey = _.keys( leafNode )[ 0 ];\n    assert( _.indexOf( OP_ARRAY, propKey ) < 0, 'These are not the leaf level nodes to evaluate' );\n    if( _.indexOf( OP_ARRAY, propKey ) < 0 ) {\n        var propRealValue = _.get( sourceObject, propKey );\n        var condition = _.get( leafNode, propKey );\n        var condKey = _.keys( condition )[ 0 ];\n        var condVal = _.get( condition, condKey );\n        var compareToKey = propKey + '@' + condKey; // modelType.typeHierarchy@$in\n        var compareTo = {};\n        compareTo[ compareToKey ] = condVal;\n        if( !_conditionQuickEval[ compareToKey ] ) {\n            _conditionQuickEval[ compareToKey ] = expressionParserUtils.getEvaluationFn( condKey, propKey, compareTo );\n        }\n        return _conditionQuickEval[ compareToKey ]( condVal, propRealValue );\n    }\n    return null;\n};\n\n/**\n * Retrieves the adapted object recursively.\n *\n * @param {*} sourceObject - source object\n * @param {*} isFullyAdapted - if object should be recursively adapted\n * @return {Promise} Resolved with an array of adoptees containing the results of the operation.\n */\nvar _getAdaptedObjectSource = function( sourceObject, isFullyAdapted ) {\n    var deferred = AwPromiseService.instance.defer();\n    var adaptedReturnObjects = [];\n    var verdictObject = exports.applyConditions( sourceObject );\n\n    if( verdictObject.verdict ) {\n        var adaptedObjectPromise = _getAdoptees( sourceObject, verdictObject );\n\n        adaptedObjectPromise.then( function( adaptedObjects ) {\n            if( isFullyAdapted ) {\n                var deferredPromises = [];\n\n                _.forEach( adaptedObjects, function( adaptedObject ) {\n                    deferredPromises.push( _getAdaptedObjectSource( adaptedObject, isFullyAdapted ) );\n                } );\n\n                AwPromiseService.instance.all( deferredPromises ).then( function( results ) {\n                    _.forEach( results, function( result ) {\n                        adaptedReturnObjects = adaptedReturnObjects.concat( result );\n                    } );\n\n                    deferred.resolve( adaptedReturnObjects );\n                } );\n            } else {\n                deferred.resolve( adaptedObjects );\n            }\n        } );\n    } else {\n        adaptedReturnObjects.push( sourceObject );\n        deferred.resolve( adaptedReturnObjects );\n    }\n\n    return deferred.promise;\n};\n\nexports = {\n    getAdaptedObjectsSync,\n    getAdaptedObjects,\n    setConfiguration,\n    applyConditions\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}