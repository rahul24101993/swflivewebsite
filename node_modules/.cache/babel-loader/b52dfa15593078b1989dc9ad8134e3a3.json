{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch extended type icons Requires typeIconsRegistry.json definition at each module level.\n *\n * @module js/typeIconsRegistryService\n */\nimport cmm from 'soa/kernel/clientMetaModel';\nimport cdm from 'soa/kernel/clientDataModel';\nimport adapterService from 'js/adapterService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\nlet exports;\n\nlet _typeIconsRegistry;\n/**\n * Returns the custom icon registered against current vmo\n * @param {Object} type --- json type\n * @param {Object} modelType -- ModelType name or array\n * @param { viewmodelObject } obj --- In case of dataparser when modelType and typeHierarchy provided on VMO\n *\n * @return {String} Name of icon to be used against current vmo\n */\n\n\nexport let isObjOfAnyTypeNames = function (type, modelType, obj) {\n  var isValid = false;\n\n  if (type.names) {\n    for (var i = 0; i < type.names.length; i++) {\n      let typeName = type.names[i]; // If the type is purely a client view model object\n\n      if (type.isClientViewModelObject === true && modelType === typeName) {\n        isValid = true;\n      } else {\n        isValid = cmm.isInstanceOf(typeName, modelType);\n      }\n\n      if (!isValid && obj && obj.typeHierarchy && obj.typeHierarchy.indexOf(typeName) > -1) {\n        isValid = true;\n      }\n\n      if (isValid) {\n        return true;\n      }\n    }\n  }\n\n  return isValid;\n};\nexport let getIconForType = function (type, obj) {\n  if (type.names && obj && obj.modelType && obj.modelType.name && obj.props) {\n    // If the type configured in json matches with the object which is being evaluated\n    var isValid = exports.isObjOfAnyTypeNames(type, obj.modelType, obj);\n\n    if (isValid) {\n      /* -\n       * If its a valid sub type,( in order)\n       *     1. check if a icon file name has been associated\n       *     2. if a property has been mentioned\n       *     3. If a condition has been mentioned to evaluate the property\n       *     4. If a nested type has been mentioned for a property\n      -*/\n      if (type.iconFileName) {\n        return type.iconFileName + '.svg';\n      } else if (type.prop && type.prop.names) {\n        var prop = type.prop;\n        var propNames = prop.names;\n        var conditionVerdict = false;\n\n        for (var index in propNames) {\n          var propName = propNames[index];\n          var vmoPropVal = obj.props[propName];\n\n          if (vmoPropVal) {\n            if (prop.conditions && prop.iconFileName) {\n              conditionVerdict = expressionParserUtils.evaluateConditions(prop.conditions, obj);\n\n              if (conditionVerdict) {\n                break;\n              }\n            } else if (prop.type) {\n              // it expects a property to have a OBJECT type of value only\n              var refObjUid = null;\n\n              if (vmoPropVal.dbValue) {\n                refObjUid = vmoPropVal.dbValue;\n              } else if (vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0) {\n                refObjUid = vmoPropVal.dbValues[0];\n              }\n\n              var isType = cmm.isTypeUid(refObjUid);\n\n              if (isType) {\n                var typeObj = cmm.getType(refObjUid);\n\n                if (typeObj) {\n                  return cmm.getTypeIconFileName(typeObj);\n                }\n              } else {\n                var refObj = cdm.getObject(refObjUid);\n\n                if (refObj) {\n                  //call getCustomIcon to ensure type icon configuration on \"nested\" type is honored\n                  //if that returns null revert to previous behavior\n                  return exports.getIconForType(prop.type, refObj);\n                }\n              }\n            }\n          } else {// this means property is not loaded in client\n          }\n        }\n\n        if (prop.conditions && prop.iconFileName) {\n          if (conditionVerdict) {\n            return prop.iconFileName + '.svg';\n          }\n        }\n      } else {\n        return cmm.getTypeIconFileName(obj.modelType);\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the custom thumbnail current vmo based on thumbnail configuration\n * @param {Object} type - the registry entry\n * @param {Object} obj - the vmo\n *\n * @return {Object} vmo containing the thumbnail information\n */\n\nexport let getVmoForThumbnail = function (type, obj) {\n  if (type.names && obj && obj.modelType) {\n    // If the type configured in json matches with the object which is being evaluated\n    var isValid = exports.isObjOfAnyTypeNames(type, obj.modelType, obj);\n\n    if (isValid) {\n      if (type.prop && type.prop.names) {\n        var prop = type.prop;\n        var propNames = prop.names;\n\n        for (var index in propNames) {\n          var propName = propNames[index];\n          var vmoPropVal = obj.props[propName];\n\n          if (vmoPropVal) {\n            if (prop.type) {\n              // it expects a property to have a OBJECT type of value only\n              var refObjUid = null;\n\n              if (vmoPropVal.dbValue) {\n                refObjUid = vmoPropVal.dbValue;\n              } else if (vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0) {\n                refObjUid = vmoPropVal.dbValues[0];\n              }\n\n              var isType = cmm.isTypeUid(refObjUid);\n\n              if (isType) {// invalid case\n              } else {\n                var refObj = cdm.getObject(refObjUid);\n\n                if (refObj) {\n                  return exports.getVmoForThumbnail(prop.type, refObj);\n                }\n              }\n            }\n          } else {// this means property is not loaded in client\n          }\n        }\n      } else {\n        return obj;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the custom thumbnail registered against current vmo\n *\n * @param {Object} vmo - the vmo to get custom thumbnail for\n *\n * @return {Object} vmo on which thumbnail information is present\n */\n\nexport let getCustomVmoForThumbnail = function (vmo) {\n  var customVmo = null;\n\n  if (vmo && vmo.modelType) {\n    _.forEach(_typeIconsRegistry, function (typeObj) {\n      if (typeObj && typeObj.thumbnail) {\n        customVmo = exports.getVmoForThumbnail(typeObj.thumbnail, vmo);\n\n        if (customVmo) {\n          return false; // break\n        }\n      }\n\n      return undefined;\n    });\n  }\n\n  return customVmo;\n};\n/**\n * Returns the custom icon registered against current vmo\n *\n * @param {Object} vmo - the vmo to check\n *\n * @return {String} Name of icon to be used against current vmo\n */\n\nexport let getCustomIcon = function (vmo) {\n  var finalTypeIconFileName = null;\n  var finalPriority = -1;\n  let adaptedObj = null;\n  let adaptedRequired = vmo.type !== getPropsObjectType(vmo);\n\n  if (adaptedRequired) {\n    adaptedObj = adapterService.getAdaptedObjectsSync([vmo])[0];\n  }\n\n  let relevantDefinitions = getRelevantDefs(vmo, adaptedObj);\n\n  if (vmo && vmo.modelType && relevantDefinitions.length > 0) {\n    relevantDefinitions.sort(function (def1, def2) {\n      let priority1 = def1.priority ? def1.priority : 1;\n      let priority2 = def2.priority ? def2.priority : 1;\n      return priority1 < priority2 ? 1 : -1;\n    });\n\n    _.forEach(relevantDefinitions, function (typeObj) {\n      if (typeObj && typeObj.type) {\n        /* If the current priority is greater than priority of any consecutive definitions, don't need to evaluate... */\n        var currPriority = typeObj.priority ? typeObj.priority : 1;\n\n        if (finalPriority > currPriority) {\n          return;\n        }\n\n        var currTypeIconName = null;\n\n        if (adaptedRequired) {\n          var adaptedIcon = exports.getIconForType(typeObj.type, adaptedObj);\n\n          if (adaptedIcon) {\n            currTypeIconName = adaptedIcon;\n            currPriority = typeObj.priority ? typeObj.priority : currPriority + 1;\n          }\n        }\n\n        if (!currTypeIconName) {\n          currTypeIconName = exports.getIconForType(typeObj.type, vmo);\n        }\n\n        if (currTypeIconName && currPriority > finalPriority) {\n          finalPriority = currPriority;\n          finalTypeIconFileName = currTypeIconName;\n        }\n      }\n    });\n  }\n\n  return finalTypeIconFileName;\n};\n/**\n * Example Case ( List with Summary View, Summary view has 1 objectset table )\n * --------------------------------------------------\n * | Home Folder           |    XRT Objectset Table |\n * |                       |                        |\n * |     SomeItemName123   |        SomeItemName123 |\n * |                       |                        |\n * |                       |                        |\n * --------------------------------------------------\n *\n * Inside of PWA ( List ) the type of \"SomeItemName123\" = ItemRevision\n * Inside of SWA ( Objectset table ) the type of \"SomeItemName123\" = Awp0XRTObjectSet\n *\n * Both items need to be able to utilize the custom icon definition for \"ItemRevision\"\n * Adapting objects is expensive, so check to see if needs to be adapted before doing it anyway.\n * If vmo.props.object_type is equal to vmo.type, adaption is not needed\n * If somewhere along the path is not defined, adaption may be required.\n * If path is present and vmo.type !== vmo.props.object_type, adaption is definitely required.\n * @param {Object} vmo - the vmo to check\n *\n * @returns {String} - undefined or string type of VMO adapted options\n */\n\nfunction getPropsObjectType(vmo) {\n  let objectType;\n\n  if (vmo.props && vmo.props.object_type) {\n    let ot = vmo.props.object_type;\n\n    if (ot.dbValue) {\n      objectType = ot.dbValue;\n    } else if (ot.dbValues && ot.dbValues.length > 0) {\n      objectType = ot.dbValues[0];\n    }\n  }\n\n  if (!objectType && vmo.modelType && vmo.modelType.parentTypeName) {\n    objectType = vmo.modelType.parentTypeName;\n  }\n\n  return objectType;\n}\n/**\n * Gets the typeHierarchy array from object\n * @param {Object} dataObject - The VMO/Object to get type Hierarchy array from\n *\n * @returns {Array|null} - Returns the typeHierarchyArry or null if non-existent\n */\n\n\nlet getTypeHierarchyArray = function (dataObject) {\n  if (dataObject) {\n    if (dataObject.modelType && dataObject.modelType.typeHierarchyArray) {\n      return dataObject.modelType.typeHierarchyArray;\n    } else if (dataObject.typeHierarchy) {\n      return dataObject.typeHierarchy;\n    } else if (dataObject.type) {\n      return [dataObject.type];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets the relevant definitions from teh typeIconsRegistry\n *\n * @param {Object} vmo - the view model object\n * @param {Object|null} adaptedObj - The adaptedObject or null\n *\n * @returns {Object[]} - relevant typeIconsRegistry definitions\n */\n\n\nlet getRelevantDefs = function (vmo, adaptedObj) {\n  const typesToCheck = new Set();\n  const vmoTypeHierarchyArr = getTypeHierarchyArray(vmo);\n\n  if (vmoTypeHierarchyArr) {\n    for (let i = 0; i < vmoTypeHierarchyArr.length; i++) {\n      typesToCheck.add(vmoTypeHierarchyArr[i]);\n    }\n  }\n\n  if (adaptedObj) {\n    let adaptedTypeHierarchyArr = getTypeHierarchyArray(adaptedObj);\n\n    if (adaptedTypeHierarchyArr) {\n      for (let j = 0; j < adaptedTypeHierarchyArr.length; j++) {\n        typesToCheck.add(adaptedTypeHierarchyArr[j]);\n      }\n    }\n  }\n\n  return _typeIconsRegistry.filter(o => {\n    if (o.type && o.type.names) {\n      // Check if any items in set are valid here, best way is loop through the registry entry names,\n      // Since there are generally only one or two items in each, so this will be faster\n      for (let k = 0; k < o.type.names.length; k++) {\n        if (typesToCheck.has(o.type.names[k])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  });\n};\n/**\n * Loads the type Icons registry configuration\n */\n\n\nexport let loadConfiguration = function () {\n  //  FIXME this should be loaded async but before the sync API below that uses it is called\n  const typeIconsRegistryCfg = cfgSvc.getCfgCached('typeIconsRegistry');\n  _typeIconsRegistry = typeIconsRegistryCfg ? typeIconsRegistryCfg : [];\n};\nexports = {\n  isObjOfAnyTypeNames,\n  getIconForType,\n  getVmoForThumbnail,\n  getCustomVmoForThumbnail,\n  getCustomIcon,\n  loadConfiguration\n};\nexport default exports;\nloadConfiguration();","map":{"version":3,"names":["cmm","cdm","adapterService","_","expressionParserUtils","cfgSvc","exports","_typeIconsRegistry","isObjOfAnyTypeNames","type","modelType","obj","isValid","names","i","length","typeName","isClientViewModelObject","isInstanceOf","typeHierarchy","indexOf","getIconForType","name","props","iconFileName","prop","propNames","conditionVerdict","index","propName","vmoPropVal","conditions","evaluateConditions","refObjUid","dbValue","dbValues","isType","isTypeUid","typeObj","getType","getTypeIconFileName","refObj","getObject","getVmoForThumbnail","getCustomVmoForThumbnail","vmo","customVmo","forEach","thumbnail","undefined","getCustomIcon","finalTypeIconFileName","finalPriority","adaptedObj","adaptedRequired","getPropsObjectType","getAdaptedObjectsSync","relevantDefinitions","getRelevantDefs","sort","def1","def2","priority1","priority","priority2","currPriority","currTypeIconName","adaptedIcon","objectType","object_type","ot","parentTypeName","getTypeHierarchyArray","dataObject","typeHierarchyArray","typesToCheck","Set","vmoTypeHierarchyArr","add","adaptedTypeHierarchyArr","j","filter","o","k","has","loadConfiguration","typeIconsRegistryCfg","getCfgCached"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declarativeui/src/js/typeIconsRegistryService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Service to fetch extended type icons Requires typeIconsRegistry.json definition at each module level.\n *\n * @module js/typeIconsRegistryService\n */\nimport cmm from 'soa/kernel/clientMetaModel';\nimport cdm from 'soa/kernel/clientDataModel';\nimport adapterService from 'js/adapterService';\nimport _ from 'lodash';\nimport expressionParserUtils from 'js/expressionParserUtils';\nimport cfgSvc from 'js/configurationService';\n\nlet exports;\n\nlet _typeIconsRegistry;\n\n/**\n * Returns the custom icon registered against current vmo\n * @param {Object} type --- json type\n * @param {Object} modelType -- ModelType name or array\n * @param { viewmodelObject } obj --- In case of dataparser when modelType and typeHierarchy provided on VMO\n *\n * @return {String} Name of icon to be used against current vmo\n */\nexport let isObjOfAnyTypeNames = function( type, modelType, obj ) {\n    var isValid = false;\n    if( type.names ) {\n        for( var i = 0; i < type.names.length; i++ ) {\n            let typeName = type.names[ i ];\n            // If the type is purely a client view model object\n            if( type.isClientViewModelObject === true && modelType === typeName ) {\n                isValid = true;\n            } else {\n                isValid = cmm.isInstanceOf( typeName, modelType );\n            }\n            if( !isValid && obj && obj.typeHierarchy && obj.typeHierarchy.indexOf( typeName ) > -1 ) {\n                isValid = true;\n            }\n            if( isValid ) {\n                return true;\n            }\n        }\n    }\n\n    return isValid;\n};\n\nexport let getIconForType = function( type, obj ) {\n    if( type.names && obj && obj.modelType && obj.modelType.name && obj.props ) {\n        // If the type configured in json matches with the object which is being evaluated\n        var isValid = exports.isObjOfAnyTypeNames( type, obj.modelType, obj );\n        if( isValid ) {\n            /* -\n             * If its a valid sub type,( in order)\n             *     1. check if a icon file name has been associated\n             *     2. if a property has been mentioned\n             *     3. If a condition has been mentioned to evaluate the property\n             *     4. If a nested type has been mentioned for a property\n            -*/\n            if( type.iconFileName ) {\n                return type.iconFileName + '.svg';\n            } else if( type.prop && type.prop.names ) {\n                var prop = type.prop;\n                var propNames = prop.names;\n                var conditionVerdict = false;\n                for( var index in propNames ) {\n                    var propName = propNames[ index ];\n                    var vmoPropVal = obj.props[ propName ];\n                    if( vmoPropVal ) {\n                        if( prop.conditions && prop.iconFileName ) {\n                            conditionVerdict = expressionParserUtils.evaluateConditions( prop.conditions,\n                                obj );\n                            if( conditionVerdict ) {\n                                break;\n                            }\n                        } else if( prop.type ) {\n                            // it expects a property to have a OBJECT type of value only\n                            var refObjUid = null;\n                            if( vmoPropVal.dbValue ) {\n                                refObjUid = vmoPropVal.dbValue;\n                            } else if( vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0 ) {\n                                refObjUid = vmoPropVal.dbValues[ 0 ];\n                            }\n\n                            var isType = cmm.isTypeUid( refObjUid );\n                            if( isType ) {\n                                var typeObj = cmm.getType( refObjUid );\n                                if( typeObj ) {\n                                    return cmm.getTypeIconFileName( typeObj );\n                                }\n                            } else {\n                                var refObj = cdm.getObject( refObjUid );\n                                if( refObj ) {\n                                    //call getCustomIcon to ensure type icon configuration on \"nested\" type is honored\n                                    //if that returns null revert to previous behavior\n                                    return exports.getIconForType( prop.type, refObj );\n                                }\n                            }\n                        }\n                    } else {\n                        // this means property is not loaded in client\n                    }\n                }\n                if( prop.conditions && prop.iconFileName ) {\n                    if( conditionVerdict ) {\n                        return prop.iconFileName + '.svg';\n                    }\n                }\n            } else {\n                return cmm.getTypeIconFileName( obj.modelType );\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Returns the custom thumbnail current vmo based on thumbnail configuration\n * @param {Object} type - the registry entry\n * @param {Object} obj - the vmo\n *\n * @return {Object} vmo containing the thumbnail information\n */\nexport let getVmoForThumbnail = function( type, obj ) {\n    if( type.names && obj && obj.modelType ) {\n        // If the type configured in json matches with the object which is being evaluated\n        var isValid = exports.isObjOfAnyTypeNames( type, obj.modelType, obj );\n\n        if( isValid ) {\n            if( type.prop && type.prop.names ) {\n                var prop = type.prop;\n                var propNames = prop.names;\n                for( var index in propNames ) {\n                    var propName = propNames[ index ];\n                    var vmoPropVal = obj.props[ propName ];\n                    if( vmoPropVal ) {\n                        if( prop.type ) {\n                            // it expects a property to have a OBJECT type of value only\n                            var refObjUid = null;\n                            if( vmoPropVal.dbValue ) {\n                                refObjUid = vmoPropVal.dbValue;\n                            } else if( vmoPropVal.dbValues && vmoPropVal.dbValues.length > 0 ) {\n                                refObjUid = vmoPropVal.dbValues[ 0 ];\n                            }\n\n                            var isType = cmm.isTypeUid( refObjUid );\n                            if( isType ) {\n                                // invalid case\n                            } else {\n                                var refObj = cdm.getObject( refObjUid );\n                                if( refObj ) {\n                                    return exports.getVmoForThumbnail( prop.type, refObj );\n                                }\n                            }\n                        }\n                    } else {\n                        // this means property is not loaded in client\n                    }\n                }\n            } else {\n                return obj;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Returns the custom thumbnail registered against current vmo\n *\n * @param {Object} vmo - the vmo to get custom thumbnail for\n *\n * @return {Object} vmo on which thumbnail information is present\n */\nexport let getCustomVmoForThumbnail = function( vmo ) {\n    var customVmo = null;\n    if( vmo && vmo.modelType ) {\n        _.forEach( _typeIconsRegistry, function( typeObj ) {\n            if( typeObj && typeObj.thumbnail ) {\n                customVmo = exports.getVmoForThumbnail( typeObj.thumbnail, vmo );\n                if( customVmo ) {\n                    return false; // break\n                }\n            }\n            return undefined;\n        } );\n    }\n    return customVmo;\n};\n\n/**\n * Returns the custom icon registered against current vmo\n *\n * @param {Object} vmo - the vmo to check\n *\n * @return {String} Name of icon to be used against current vmo\n */\nexport let getCustomIcon = function( vmo ) {\n    var finalTypeIconFileName = null;\n    var finalPriority = -1;\n    let adaptedObj = null;\n    let adaptedRequired = vmo.type !== getPropsObjectType( vmo );\n\n    if( adaptedRequired ) {\n        adaptedObj = adapterService.getAdaptedObjectsSync( [ vmo ] )[ 0 ];\n    }\n\n    let relevantDefinitions = getRelevantDefs( vmo, adaptedObj );\n    if( vmo && vmo.modelType && relevantDefinitions.length > 0 ) {\n        relevantDefinitions.sort( function( def1, def2 ) {\n            let priority1 = def1.priority ? def1.priority : 1;\n            let priority2 = def2.priority ? def2.priority : 1;\n\n            return priority1 < priority2 ? 1 : -1;\n        } );\n        _.forEach( relevantDefinitions, function( typeObj ) {\n            if( typeObj && typeObj.type ) {\n                /* If the current priority is greater than priority of any consecutive definitions, don't need to evaluate... */\n                var currPriority = typeObj.priority ? typeObj.priority : 1;\n                if( finalPriority > currPriority ) {\n                    return;\n                }\n                var currTypeIconName = null;\n                if( adaptedRequired ) {\n                    var adaptedIcon = exports.getIconForType( typeObj.type, adaptedObj );\n                    if( adaptedIcon ) {\n                        currTypeIconName = adaptedIcon;\n                        currPriority = typeObj.priority ? typeObj.priority : currPriority + 1;\n                    }\n                }\n\n                if( !currTypeIconName ) {\n                    currTypeIconName = exports.getIconForType( typeObj.type, vmo );\n                }\n\n                if( currTypeIconName && currPriority > finalPriority ) {\n                    finalPriority = currPriority;\n                    finalTypeIconFileName = currTypeIconName;\n                }\n            }\n        } );\n    }\n    return finalTypeIconFileName;\n};\n\n/**\n * Example Case ( List with Summary View, Summary view has 1 objectset table )\n * --------------------------------------------------\n * | Home Folder           |    XRT Objectset Table |\n * |                       |                        |\n * |     SomeItemName123   |        SomeItemName123 |\n * |                       |                        |\n * |                       |                        |\n * --------------------------------------------------\n *\n * Inside of PWA ( List ) the type of \"SomeItemName123\" = ItemRevision\n * Inside of SWA ( Objectset table ) the type of \"SomeItemName123\" = Awp0XRTObjectSet\n *\n * Both items need to be able to utilize the custom icon definition for \"ItemRevision\"\n * Adapting objects is expensive, so check to see if needs to be adapted before doing it anyway.\n * If vmo.props.object_type is equal to vmo.type, adaption is not needed\n * If somewhere along the path is not defined, adaption may be required.\n * If path is present and vmo.type !== vmo.props.object_type, adaption is definitely required.\n * @param {Object} vmo - the vmo to check\n *\n * @returns {String} - undefined or string type of VMO adapted options\n */\nfunction getPropsObjectType( vmo ) {\n    let objectType;\n    if( vmo.props && vmo.props.object_type ) {\n        let ot = vmo.props.object_type;\n        if( ot.dbValue ) {\n            objectType = ot.dbValue;\n        } else if( ot.dbValues && ot.dbValues.length > 0 ) {\n            objectType = ot.dbValues[ 0 ];\n        }\n    }\n    if( !objectType && vmo.modelType && vmo.modelType.parentTypeName ) {\n        objectType = vmo.modelType.parentTypeName;\n    }\n    return objectType;\n}\n\n/**\n * Gets the typeHierarchy array from object\n * @param {Object} dataObject - The VMO/Object to get type Hierarchy array from\n *\n * @returns {Array|null} - Returns the typeHierarchyArry or null if non-existent\n */\nlet getTypeHierarchyArray = function( dataObject ) {\n    if( dataObject ) {\n        if( dataObject.modelType && dataObject.modelType.typeHierarchyArray ) {\n            return dataObject.modelType.typeHierarchyArray;\n        } else if( dataObject.typeHierarchy ) {\n            return dataObject.typeHierarchy;\n        } else if( dataObject.type ) {\n            return [ dataObject.type ];\n        }\n    }\n    return null;\n};\n\n/**\n * Gets the relevant definitions from teh typeIconsRegistry\n *\n * @param {Object} vmo - the view model object\n * @param {Object|null} adaptedObj - The adaptedObject or null\n *\n * @returns {Object[]} - relevant typeIconsRegistry definitions\n */\nlet getRelevantDefs = function( vmo, adaptedObj ) {\n    const typesToCheck = new Set();\n    const vmoTypeHierarchyArr = getTypeHierarchyArray( vmo );\n\n    if( vmoTypeHierarchyArr ) {\n        for( let i = 0; i < vmoTypeHierarchyArr.length; i++ ) {\n            typesToCheck.add( vmoTypeHierarchyArr[ i ] );\n        }\n    }\n\n    if( adaptedObj ) {\n        let adaptedTypeHierarchyArr = getTypeHierarchyArray( adaptedObj );\n        if( adaptedTypeHierarchyArr ) {\n            for( let j = 0; j < adaptedTypeHierarchyArr.length; j++ ) {\n                typesToCheck.add( adaptedTypeHierarchyArr[ j ] );\n            }\n        }\n    }\n\n    return _typeIconsRegistry.filter( ( o ) => {\n        if( o.type && o.type.names ) {\n            // Check if any items in set are valid here, best way is loop through the registry entry names,\n            // Since there are generally only one or two items in each, so this will be faster\n            for( let k = 0; k < o.type.names.length; k++ ) {\n                if( typesToCheck.has( o.type.names[ k ] ) ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    } );\n};\n\n/**\n * Loads the type Icons registry configuration\n */\nexport let loadConfiguration = function() {\n    //  FIXME this should be loaded async but before the sync API below that uses it is called\n    const typeIconsRegistryCfg = cfgSvc.getCfgCached( 'typeIconsRegistry' );\n    _typeIconsRegistry = typeIconsRegistryCfg ? typeIconsRegistryCfg : [];\n};\n\nexports = {\n    isObjOfAnyTypeNames,\n    getIconForType,\n    getVmoForThumbnail,\n    getCustomVmoForThumbnail,\n    getCustomIcon,\n    loadConfiguration\n};\nexport default exports;\n\nloadConfiguration();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}