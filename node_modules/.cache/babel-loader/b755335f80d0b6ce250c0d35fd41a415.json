{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * @module js/atomicDataService\n */import _ from'lodash';/**\n * @param {*} stateObject The stateobject inside atomic data section of viewmodel.\n * @param {*} metaObj The meta object for the same\n * @param {*} rootPath The name of the state object inside atomicdata.\n * @param {*} createField the function to create field objects\n * @returns\n */export const createFieldsBasedOnMetaData=function(stateObject,metaObj,rootPath,createField){let atomicFields={};const fieldsPath=[];fieldsPath.push(rootPath);parseMetaForFieldsPath(metaObj);validateObjWithMetaObjAndCreateFields(stateObject);let rootField=createField('',rootPath,'partialField');atomicFields={...rootField,...atomicFields};/**\n     *\n     * @param {*} propName\n     * @param {*} basePath\n     * @returns\n     */function parsePath(propName,basePath){let path;if(basePath){path=Number.isInteger(propName)?\"\".concat(basePath,\"[\").concat(propName,\"]\"):\"\".concat(basePath,\".\").concat(propName);}else{path=propName;}return path;}/**\n     *\n     * @param {*} metaObj\n     * @param {*} rootPath\n     */function parseMetaForFieldsPath(currentMetaObj){let basePath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;_.forEach(currentMetaObj,function processMeta(propValue,propName){if(propName==='field'||propName==='type'){return undefined;}let path=parsePath(propName,basePath);fieldsPath.push(\"\".concat(rootPath,\".\").concat(path));if(_.isObject(propValue)){parseMetaForFieldsPath(propValue,path);}return undefined;});return undefined;}/**\n     *\n     * @param {*} obj\n     * @param {*} metaObj\n     * @param {*} basePath\n     */function validateObjWithMetaObjAndCreateFields(currStateObj,basePath){_.forEach(currStateObj,function(propValue,propName){let path=parsePath(propName,basePath);const metaPathMatcher=path.replace(/\\d+/g,'0');// This is just to match with schema\nconst isFieldObject=_.indexOf(fieldsPath,\"\".concat(rootPath,\".\").concat(metaPathMatcher))!==-1;const fieldType=_.get(metaObj,\"\".concat(metaPathMatcher,\".type\"),'partialField');const isLeafLevelFieldObj=isFieldObject&&fieldType!=='partialField';if(isFieldObject){let atomicField=createField(path,rootPath,fieldType);if(_.isArray(propValue)){let fieldsObj=atomicField;atomicField=[...propValue];_.assign(atomicField,fieldsObj);}else if(_.isObject(propValue)&&!isLeafLevelFieldObj){_.assign(atomicField,propValue);}if(fieldType==='partialField'){Object.defineProperty(atomicField,'getValue',{enumerable:false});Object.defineProperty(atomicField,'value',{enumerable:false});Object.defineProperty(atomicField,'update',{enumerable:false});}_.set(atomicFields,path,atomicField);}else{//workaround to handle 'Categorization.category' as a prop name\nif(!Number.isInteger(propName)&&propName.includes('.')){path=path.replace('.'+propName,\"['\".concat(propName,\"']\"));}// If only raw data (read only), then set it without generating any field.\n_.set(atomicFields,path,_.get(currStateObj,propName));}// If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.\n// It would save lot of un-necessary recursions.\n// If current propValue is of type \"Meta\" and fieldType === 'FieldObject', then only traverse inside.\n// If the fieldType is of type \"field\" or \"VMP\", no need to traverse the object inside.\n/**\n             *  Two Important cases\n             * 1. Current Object (propValue) is not of type \"Field\" i.e not in meta, this means all down ward objects are also not fields\n             *  Hence, no need to traverse inside it.\n             *\n             * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,\n             * but if the propValue is of type \"field\" but not 'partialField' ( ie. full fledged Field Object), this means it the end of\n             * hierarchy (leaf leavel Field Node), no need to traverse inside it.\n             * no need to go inside.\n             */if(_.isObject(propValue)&&isFieldObject&&!isLeafLevelFieldObj){validateObjWithMetaObjAndCreateFields(propValue,path);}});}return atomicFields;};","map":null,"metadata":{},"sourceType":"module"}