{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */import{evalExpression}from'js/serviceUtils';import{render,unmountComponentAtNode}from'react-dom';/**\n * fastest way to copy a pure JSON object, use on your own risk\n * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript\n *\n * @param {Object} obj Current DOM Element\n * @returns {Object} new cloned object\n */import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";export function cloneDeepJsonObject(obj){return obj?JSON.parse(JSON.stringify(obj)):obj;}/**\n * parse data path to scope + subPatoh\n * @param {string} pathStr path string like 'ctx.a.b'\n * @returns {object} path structure like:\n * {\n *     scope: 'ctx'\n *     path: 'a.b'\n * }\n */export function parseDataPath(pathStr){const match=pathStr.match(/[.[]/);if(match){return{scope:pathStr.substr(0,match.index),path:pathStr.substr(match[0]==='['?match.index:match.index+1)};}return{scope:pathStr};}/**\n * evaluate string as Javascript expression\n * @param {string} expr string as expression\n * @param {Object} scope parameters as name value pair\n * @param {boolean} ignoreError if true the error is not thrown\n * @param {boolean} applyObject object will apply to the expr as this\n * @return {*} evaluation result\n */export function evalInScope(expr,scope,ignoreError,applyObject){const params=scope?Object.keys(scope):[];const values=scope?Object.values(scope):[];return evalExpression(expr,params,values,ignoreError,applyObject);}/**\n * get value from scope\n * @param {object} data scope for evaluation\n * @param {string} path string as path/expression\n * @returns {*} result\n */export function getValue(data,path){return evalInScope(path,data,true);}/**\n * parse expr {{aa.bb}} to get aa.bb\n * @param {string} str input string\n * @returns {string} the expression inside {{}}\n */export function parseExpr(str){let match=str.match(/^{{(.*)}}$/);return match?match[1]:undefined;}/**\n * Evaluate from data definition like:\n * {\n *    attr1: {{data.curVal}}\n * }\n * @param {JSON} input data definition\n * @param {JSON} scope scope for evaluation\n * @param {number} level used for recursive call internally\n * @returns {JSON} evaluated input object\n */export function evalDataDefinition(input,scope){let level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;// Make the method to be immutable at top level\nlet obj=level>0?input:cloneDeepJsonObject(input);for(let key in obj){let value=obj[key];if(typeof value==='string'){let template=parseExpr(value);if(template){obj[key]=getValue(scope,template);}}else{evalDataDefinition(obj[key],scope,level+1);}}return obj;}/**\n * parse i18n definition. Given:\n * {\n *     myData: {\n *         value1: \"a\",\n *         value2: \"{{i18n.myVal}}\"\n *     }\n * }\n * returns:\n * {\n *     \"myData.value2\": \"{{i18n.myVal}}\"\n * }\n * NODE: No usage for now, keep it here for reference\n * @param {JSON} dataDef data definition\n * @param {Array} stack JSON path stack\n * @returns {JSON} i18n defintions in path-expr pair\n */function getExprsFromDataDef(dataDef){let stack=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];const res={};for(let key in dataDef){stack.push(key);let value=dataDef[key];if(typeof value==='string'){let template=parseExpr(value);if(/^i18n\\./.test(template)){res[stack.join('.')]=value;}}else{Object.assign(res,getExprsFromDataDef(value,stack));}stack.pop();}return res;}/**\n * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.\n * @param {object} component React component.\n * @param {DOMElement} renderedElement The container element on which the component will be rendered.\n * @param {Function} callback callback function that will be executed by render method. This is optional.\n */export function renderComponent(component,renderedElement,callback){if(component&&renderedElement){render(/*#__PURE__*/_jsx(_Fragment,{children:component}),renderedElement,callback);}}/**\n * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.\n * These elements will then be unmounted if they have a react element mounted.\n * @param {HTMLElement} baseElement The base element to use\n * @param {String} [selector] CSS selector used to search for nodes from the base element\n */export function unmountComponents(baseElement,selector){// get the container elements that could potentially have a component\nlet components;if(!selector){components=[baseElement];}else{components=baseElement.querySelectorAll(selector);}for(let i=0;i<components.length;i++){unmountComponentAtNode(components[i]);}}","map":null,"metadata":{},"sourceType":"module"}