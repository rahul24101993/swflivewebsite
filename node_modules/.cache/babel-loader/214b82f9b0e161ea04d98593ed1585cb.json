{"ast":null,"code":"// Copyright (c) 2020 Siemens\n/* eslint-env es6 */ /**\n * @module js/reactAppCtx\n */import React,{useMemo}from'react';import lodashFpSet from'lodash/fp/set';import{get,set,orderBy,isArray,uniq}from'lodash';import{init}from'js/appCtxService';import{DerivedStateResult}from'js/derivedContextService';import{createStore}from'redux';import{useSelector,Provider as ReduxProvider,useDispatch}from'react-redux';import{jsx as _jsx}from\"react/jsx-runtime\";export const _dispatchCtx=function(){let ctx=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let action=arguments.length>1?arguments[1]:undefined;const{path,value}=action;if(path){return lodashFpSet(path,value,ctx);}return ctx;};// create store - will be decided by 1st param of the dispatchFn\nconst store=createStore(_dispatchCtx,window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__());/**\n * Hook to pull a value from from the global ctx store\n *\n * @param {String|Array} path The path to the property\n * @returns {Any} The current value in ctx\n */export const useCtx=path=>useSelector(ctx=>{return{path,value:get(ctx,path)};},(l,r)=>l.value===r.value);const getDerivedState=(ctxCompute,_ref)=>{let{vmDef,prop,data}=_ref;const derivedStateResult=ctxCompute(vmDef,prop,data);const derivedStates=isArray(derivedStateResult)?derivedStateResult:[derivedStateResult];for(const s of derivedStates){if(!(s instanceof DerivedStateResult)){throw new Error('Results from the derived state calculation must be a DerivedStateResult. See https://gitlab.industrysoftware.automation.siemens.com/Apollo/afx/-/wikis/Derived-State');}}return derivedStateResult;};// These methods will call hooks in the same order even though they use loops and callbacks\n/* eslint-disable react-hooks/rules-of-hooks */ /**\n * Custom hook to get the ctxCompute result and use it to run other hooks\n *\n * @param {Object} derivedStateResult Function that returns DerivedStateResult\n * @param {Object} ctxMin Context available to ctxCompute\n * @returns {Any} The computed result\n */const useDerivedStateCompute=(derivedStateResult,ctxMin)=>{//Return the latest result of the memoized compute function\nconst processDerivedState=_ref2=>{let{additionalParameters,ctxParameters,compute}=_ref2;return useMemo(()=>compute({ctx:ctxMin// eslint-disable-next-line react-hooks/exhaustive-deps\n},...additionalParameters),[...additionalParameters,...ctxParameters.map(x=>get(ctxMin,x))]);};return isArray(derivedStateResult)?derivedStateResult.map(processDerivedState):processDerivedState(derivedStateResult);};const setupCtxFromDerivedStates=function(derivedStates){let entries=Object.entries(derivedStates);let derivedStatesCollection=entries.reduce((acc,_ref3)=>{let[ctxName,derivedStates]=_ref3;let value=isArray(derivedStates)?derivedStates:[derivedStates];acc.push(...value);return acc;},[]);let allctx=orderBy(uniq(derivedStatesCollection.reduce((acc2,nxt)=>{return[...acc2,...nxt.ctxParameters];},[])),['length'],['desc']);//allctx = uniq( allctx );\nreturn allctx.map(useCtx).reduce((ctx,nxt)=>{//for some objects (such as array) set can have side effects, so avoid if values match\nif(nxt.value){if(get(ctx,nxt.path)!==nxt.value){set(ctx,nxt.path,nxt.value);}}else{set(ctx,nxt.path,nxt.value);}return ctx;},{});};/**\n * Custom hook that will process the \"ctx\" configuration into the final object\n *\n * @param {Object} vmDef View model definition\n * @param {Object} prop Component properties\n * @param {Object} data View model data\n * @param {Object} ctxImports Imported function map\n * @returns {Object} Processed ctx, global ctx, and dispatch\n */export const useDerivedState=(vmDef,prop,data,ctxImports)=>{const ctxDefs=vmDef.declViewModelJson.ctx||{};let directCtx={};let derivedStates={};Object.entries(ctxDefs).forEach(_ref4=>{let[ctxName,ctxCompute]=_ref4;ctxCompute=ctxCompute?ctxImports[ctxName]:null;if(ctxCompute){set(derivedStates,ctxName,getDerivedState(ctxCompute,{vmDef,prop,data}));}else{set(directCtx,ctxName,useCtx(ctxName).value);}},{});const computeFnDeps=setupCtxFromDerivedStates(derivedStates);//let entries = Object.entries( derivedStates );\nconst ctxMinDS=Object.entries(derivedStates).reduce((acc,_ref5)=>{let[ctxName,derivedStates]=_ref5;const latestResult=useDerivedStateCompute(derivedStates,computeFnDeps);if(latestResult){if(get(acc,ctxName)!==latestResult){set(acc,ctxName,latestResult);}}else{set(acc,ctxName,latestResult);}return acc;},{});const ctxMin=Object.assign({},directCtx,ctxMinDS);return{//Everything in ctx. Need to be replaced by ctxMin\nctx:store.getState(),//The derived ctx which only contains things this specific component needs\nctxMin,//Dispatch to update ctx\nctxDispatch:useDispatch};};/* eslint-enable react-hooks/rules-of-hooks */ /**\n * Application Context Component\n * @param {object} props properties\n * @returns {function} react component\n */export const AppCtxComponent=_ref6=>{let{children}=_ref6;// NOTE: useMemo might not be safe here, if we see any side effect we\n// will change it later\nuseMemo(()=>init({fetch:path=>path?get(store.getState(),path):store.getState(),dispatch:_ref7=>{let{path,value}=_ref7;return store.dispatch({type:path,path,value});}}),[]);return/*#__PURE__*/_jsx(ReduxProvider,{store:store,children:children});};","map":null,"metadata":{},"sourceType":"module"}