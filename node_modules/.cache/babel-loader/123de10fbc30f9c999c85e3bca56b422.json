{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/propertyPolicyService\n */\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport awConfiguration from 'js/awConfiguration';\nimport moduleLoader from 'js/moduleLoader';\n/**\n * Angular services\n */\n\nvar exports = {};\n/**\n * Map of policy id to registered policy.\n *\n * @private\n */\n\nexport let _policyId2policy = {};\n/**\n * Registration of time stamp for property policies.\n *\n * @private\n */\n\nexport let _policyId2registrationTimeStamp = {};\n/**\n * Registration counter for property policies.\n *\n * @private\n */\n\nexport let _policyCount = 0;\n/**\n * Effective property policy for subsequent server calls.\n *\n * @private\n */\n\nexport let _effectivePolicy = {};\n/**\n * Cache of last SOA service used by getEffectivePolicy()\n *\n * @private\n */\n\nexport let _soaSvc = null;\n/**\n * Parent selections.\n *\n * @private\n */\n\nexport let _parentSelections = [];\n/**\n * Current selections.\n *\n * @private\n */\n\nexport let _currentSelections = [];\n/**\n * List of selected policy Id's.\n *\n * @private\n */\n\nexport let _selectedPolicyIds = [];\n/**\n * List of generic policy Id's.\n *\n * @private\n */\n\nexport let _genericPolicyIds = [];\n/**\n * boolean to indicate whether the last effective policy was build from selected property policy or not.\n *\n * @private\n */\n\nexport let _selectedPropertyUsed = false; // /**\n//  * Sort input array by name field of elements.\n//  *\n//  * @param array array to sort\n//  * @private\n//  */\n// function sort( array ) {\n//     if( array ) {\n//         array.sort( function( a, b ) {\n//             return a.name.localeCompare( b.name );\n//         } );\n//     }\n// }\n\n/**\n * @param {String} typeName - type name\n * @param {String} propName - property name\n * @return {String} defining type name (whether on this type or one of it's parents)\n */\n\nfunction getParentType(typeName, propName) {\n  var modelType = cmm.getType(typeName);\n\n  if (modelType && modelType.propertyDescriptorsMap.hasOwnProperty(propName)) {\n    var parentModelType = cmm.getType(modelType.parentTypeName);\n\n    if (parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty(propName)) {\n      return getParentType(parentModelType.name, propName);\n    }\n\n    return modelType.name;\n  }\n\n  return null;\n}\n/**\n * Merge modifier into modifier array.\n *\n * @param {Array} modifiers - array of modifiers\n * @param {Object} modifierToMerge - modifier to merge into array\n * @private\n */\n\n\nfunction mergeModifier(modifiers, modifierToMerge) {\n  var modifier = _.find(modifiers, _.matchesProperty('name', modifierToMerge.name));\n\n  if (!modifier) {\n    modifier = {\n      name: modifierToMerge.name,\n      Value: modifierToMerge.Value\n    };\n    modifiers.push(modifier);\n  } else if (modifier.Value !== modifierToMerge.Value) {\n    logger.error('Modifier conflict!');\n  }\n}\n/**\n * Merge property into property array.\n *\n * @param {Array} properties - array of properties\n * @param {Object} propertyToMerge - property to merge into array\n * @private\n */\n\n\nfunction mergeProperty(properties, propertyToMerge) {\n  var property = _.find(properties, _.matchesProperty('name', propertyToMerge.name));\n\n  if (!property) {\n    property = {\n      name: propertyToMerge.name\n    };\n    properties.push(property);\n  }\n\n  if (propertyToMerge.modifiers && propertyToMerge.modifiers.length > 0) {\n    if (!property.modifiers) {\n      property.modifiers = [];\n    }\n\n    _.forEach(propertyToMerge.modifiers, function (modifier) {\n      mergeModifier(property.modifiers, modifier);\n    });\n  }\n}\n/**\n * Merge type into type array.\n *\n * @param {Array} types - array of types\n * @param {Object} typeToMerge - type to merge into array\n * @private\n */\n\n\nfunction mergeType(types, typeToMerge) {\n  var type = _.find(types, _.matchesProperty('name', typeToMerge.name));\n\n  if (!type) {\n    type = {\n      name: typeToMerge.name\n    };\n    types.push(type);\n  }\n\n  if (typeToMerge.properties && typeToMerge.properties.length > 0) {\n    if (!type.properties) {\n      type.properties = [];\n    }\n\n    _.forEach(typeToMerge.properties, function (property) {\n      mergeProperty(type.properties, property);\n    });\n  }\n\n  if (typeToMerge.modifiers && typeToMerge.modifiers.length > 0) {\n    if (!type.modifiers) {\n      type.modifiers = [];\n    }\n\n    _.forEach(typeToMerge.modifiers, function (modifier) {\n      mergeModifier(type.modifiers, modifier);\n    });\n  }\n}\n/**\n * Effective property policy for use by Teamcenter SOA server call header.\n *\n * @param {Object} soaSvc - SOA service to avoid cyclic reference\n * @param {boolean} isSelectedProperty - flag indicating the policy type to use.\n * @return {Object} effective property policy\n */\n\n\nexport let getEffectivePolicy = function (soaSvc, isSelectedProperty) {\n  if (soaSvc) {\n    exports._soaSvc = soaSvc;\n  }\n\n  var policyIdsForEffectPolicy = exports._genericPolicyIds;\n\n  if (isSelectedProperty) {\n    policyIdsForEffectPolicy = exports._selectedPolicyIds;\n  } // we need to check which policy type (selected or generic ) was used to build the effective property policy\n\n\n  if (!exports._effectivePolicy || isSelectedProperty !== exports._selectedPropertyUsed) {\n    var effectivePolicy = {\n      useRefCount: false // do we need to set this? ie does the server default to zero anyway?\n\n    };\n    exports._selectedPropertyUsed = isSelectedProperty;\n\n    _.forEach(policyIdsForEffectPolicy, function (policyId) {\n      var policy = exports._policyId2policy[policyId];\n\n      if (policy.types) {\n        if (!effectivePolicy.types) {\n          effectivePolicy.types = [];\n        }\n\n        _.forEach(policy.types, function (type) {\n          mergeType(effectivePolicy.types, type);\n        });\n      }\n\n      if (policy.modifiers && policy.modifiers.length > 0) {\n        if (!effectivePolicy.modifiers) {\n          effectivePolicy.modifiers = [];\n        }\n\n        _.forEach(policy.modifiers, function (modifier) {\n          mergeModifier(effectivePolicy.modifiers, modifier);\n        });\n      }\n    }); //            // Sort the effective policy for debug purposes\n    //            sort( effectivePolicy.types );\n    //            if( effectivePolicy.types ) {\n    //                _.forEach( effectivePolicy.types, function( type ) {\n    //                    sort( type.modifiers );\n    //                    if( type.properties ) {\n    //                        sort( type.properties );\n    //                        _.forEach( type.properties, function( property ) {\n    //                            sort( property.modifiers );\n    //                        } );\n    //                    }\n    //                } );\n    //            }\n    //            sort( effectivePolicy.modifiers );\n\n\n    exports._effectivePolicy = effectivePolicy;\n  }\n\n  return exports._effectivePolicy;\n};\n/**\n * Returns true if at least one selected object is present in the input body.\n *\n * @param {Object} body - input body\n * @param {StringArray} modelObjectUidList - model object uid's\n * @return {Boolean} true if at least one selected object is present in the input body.\n */\n\nexport let checkForSelectedObject = function (body, modelObjectUidList) {\n  var isFound = false;\n  var modelObjectUids = modelObjectUidList;\n\n  if (!modelObjectUidList) {\n    modelObjectUids = [];\n    extractModelObjects(body, modelObjectUids);\n  }\n\n  if (modelObjectUids.length > 0) {\n    var totalSelectedModelObject = getSelectedModelObjects();\n\n    for (var i = 0; i < totalSelectedModelObject.length; i++) {\n      if (modelObjectUids.indexOf(totalSelectedModelObject[i]) > -1) {\n        isFound = true;\n        break;\n      }\n    }\n  }\n\n  return isFound;\n};\n/**\n * Returns a list of all the selected model objects. This list includes the parent and the child selections.\n *\n * @private\n * @return {IModelObjectArray} An array of total selected model objects uid's list.\n */\n\nfunction getSelectedModelObjects() {\n  var selectedModelObjects = []; // add current selected objects to the selected objects list .\n\n  for (var i = 0; i < exports._currentSelections.length; i++) {\n    if (selectedModelObjects.indexOf(exports._currentSelections[i]) === -1) {\n      selectedModelObjects.push(exports._currentSelections[i]);\n    }\n  } // add parent selected objects to the selected objects list .\n\n\n  for (var ii = 0; ii < exports._parentSelections.length; ii++) {\n    if (selectedModelObjects.indexOf(exports._parentSelections[ii]) === -1) {\n      selectedModelObjects.push(exports._parentSelections[ii]);\n    }\n  }\n\n  return selectedModelObjects;\n}\n/**\n * Extracts model object uid's from the body\n *\n * @private\n * @param {Object} body - input body\n * @param {StringArray} uids - Array of {ModelObject} uid's found in body\n */\n\n\nfunction extractModelObjects(body, uids) {\n  _.forEach(body, function (child) {\n    if (_.isPlainObject(child)) {\n      if (child.hasOwnProperty('uid') && child.hasOwnProperty('type')) {\n        if (child.uid && child.uid !== 'AAAAAAAAAAAAAA') {\n          uids.push(child.uid);\n        }\n      } else {\n        extractModelObjects(child, uids);\n      }\n    } else if (_.isArray(child)) {\n      extractModelObjects(child, uids);\n    }\n  });\n}\n/**\n * Set's the selected model objects.\n *\n * @param {StringArray} selectedObectuids selected object uid's\n */\n\n\nexport let setSelectedObjects = function (selectedObectuids) {\n  if (selectedObectuids) {\n    exports._currentSelections = selectedObectuids;\n  } else {\n    exports._currentSelections = [];\n  }\n};\n/**\n * Add's the selected model object to parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\n\nexport let addToParentSelection = function (selectedObectuid) {\n  if (!exports._parentSelections) {\n    exports._parentSelections = [];\n  } else {\n    exports._parentSelections.push(selectedObectuid);\n  }\n};\n/**\n * removes the model object from parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\n\nexport let removeFromParentSelection = function (selectedObectuid) {\n  // Remove the selected object\n  if (exports._parentSelections.lastIndexOf(selectedObectuid) > -1) {\n    exports._parentSelections.splice(exports._parentSelections.lastIndexOf(selectedObectuid), 1);\n  }\n};\n/**\n * Register property policy.\n *\n * @param {Object} policy - property policy\n * @param {String} policyString - property policy string\n * @param {String} policyType - property type\n * @return {String} property policy ID\n */\n\nexport let register = function (policy, policyString, policyType) {\n  var policyFinal = policy;\n  var timeS = Date.now();\n\n  if (!policyFinal) {\n    policyFinal = JSON.parse(policyString);\n  }\n\n  var nextId = ++exports._policyCount; // Create policy id\n\n  var policyId = 'policy' + nextId; // Cache policy\n\n  exports._policyId2policy[policyId] = policyFinal; // depending upon the policy type add the policy to generic list\n\n  if (!policyType) {\n    exports._genericPolicyIds.push(policyId);\n  }\n\n  exports._selectedPolicyIds.push(policyId); // Clear cache of effective policy\n\n\n  exports._effectivePolicy = null;\n  var currentTime = dateTimeSvc.formatTime(timeS);\n\n  if (logger.isTraceEnabled()) {\n    logger.trace('Register Property Policy Id: ' + policyId + ' TimeStamp: ' + currentTime + ' Policy data:', policyFinal);\n  }\n\n  if (policyString) {\n    exports._policyId2registrationTimeStamp[policyId] = {\n      time: currentTime,\n      policy: policyFinal\n    };\n  } // Return new cached policy id\n\n\n  return policyId;\n};\n/**\n * Register property policy.\n *\n * @param {String} policyId - cached property policy ID\n */\n\nexport let unregister = function (policyId) {\n  // Remove the policy id from selected property policy id list\n  if (exports._selectedPolicyIds.indexOf(policyId) > -1) {\n    exports._selectedPolicyIds.splice(exports._selectedPolicyIds.indexOf(policyId), 1);\n  } // Remove the policy id from generic property policy id list\n\n\n  if (exports._genericPolicyIds.indexOf(policyId) > -1) {\n    exports._genericPolicyIds.splice(exports._genericPolicyIds.indexOf(policyId), 1);\n  }\n\n  if (exports._policyId2policy.hasOwnProperty(policyId)) {\n    delete exports._policyId2policy[policyId];\n\n    if (logger.isTraceEnabled()) {\n      logger.trace('Unregister Property Policy Id: ' + policyId + ' TimeStamp: ' + dateTimeSvc.formatTime(Date.now()));\n    }\n\n    delete exports._policyId2registrationTimeStamp[policyId]; // Clear cache of effective policy\n\n    exports._effectivePolicy = null;\n  }\n};\n/**\n * @param {Object} policy - property policy to validate\n * @param {number} callCount - call count to avoid infinite loop if a type name is invalid & can't be loaded\n */\n\nfunction validatePolicy(policy, callCount) {\n  if (policy.types) {\n    if (callCount < 5 && exports._soaSvc) {\n      var typeNames = [];\n\n      _.forEach(policy.types, function (type) {\n        var modelType = cmm.getType(type.name);\n\n        if (!modelType) {\n          typeNames.push(type.name);\n        } else {\n          _.forEach(modelType.typeHierarchyArray, function (name2) {\n            if (!cmm.containsType(name2)) {\n              typeNames.push(name2);\n            }\n          });\n        }\n      });\n\n      const sortedTypeNames = typeNames.sort();\n      typeNames = _.uniq(sortedTypeNames, true);\n\n      if (typeNames) {\n        var promise = exports._soaSvc.ensureModelTypesLoaded(typeNames);\n\n        if (promise) {\n          promise.then(function () {\n            return validatePolicy(policy, ++callCount);\n          });\n          return;\n        }\n      }\n    }\n\n    var output = [];\n\n    _.forEach(policy.types, function (type) {\n      var modelType = cmm.getType(type.name);\n\n      if (modelType) {\n        if (type.properties) {\n          var parentModelType = cmm.getType(modelType.parentTypeName);\n\n          _.forEach(type.properties, function (property) {\n            if (property) {\n              if (!modelType.propertyDescriptorsMap.hasOwnProperty(property.name)) {\n                output.push('Invalid property [' + property.name + '] on type [' + type.name + ']');\n              } else if (parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty(property.name)) {\n                output.push('Wrong type for property [' + property.name + '] on type [' + type.name + '], should be on type [' + getParentType(parentModelType.name, property.name) + ']');\n              } else {\n                output.push('Effective property [' + property.name + '] on type [' + type.name + ']');\n              }\n            } else {\n              output.push('Empty property on type [' + type.name + ']');\n            }\n          });\n        }\n      } else {\n        output.push('Invalid type [' + type.name + ']');\n      }\n\n      if (!type.properties && !type.modifiers) {\n        output.push('Missing properties for type [' + type.name + ']');\n      }\n    });\n\n    if (output.length > 0) {\n      output.sort();\n      logger.info(output.join('\\n'));\n    }\n  }\n}\n/**\n * @param {Array} modelObjects array of model objects\n * @param {Array} propNames array of property names\n */\n\n\nexport let validatePropertyRegistration = function (modelObjects, propNames) {\n  var policy = exports.getEffectivePolicy();\n  var msg = '';\n\n  _.forEach(modelObjects, function (modelObject) {\n    if (modelObject) {\n      var modelType = modelObject.modelType;\n\n      _.forEach(propNames, function (propName) {\n        if (modelType.propertyDescriptorsMap.hasOwnProperty(propName) && policy.types) {\n          var found = false;\n\n          for (var kk = 0; kk < policy.types.length && !found; kk++) {\n            var type = policy.types[kk];\n\n            if (type.properties && modelType.typeHierarchyArray.indexOf(type.name) > -1) {\n              for (var ll = 0; ll < type.properties.length && !found; ll++) {\n                var property = type.properties[ll];\n\n                if (property.name === propName) {\n                  found = true;\n                }\n              }\n            }\n          }\n\n          if (!found) {\n            msg += '\\n\\tType [' + modelType.displayName + '] PropertyName [' + propName + ']';\n          }\n        }\n      });\n    }\n  });\n\n  if (msg) {\n    logger.debug('Property Policy registration is missing for the following:' + msg);\n  }\n};\n/**\n * Register a policy which may need to be loaded from a separate json file.\n *\n * @param {Object|String} propertyPolicy - A property policy object or a path to the file containing the policy\n *\n * @return {Promise} A promise that will be resolved with the new policy id\n */\n\nexport let registerPolicyAsync = function (propertyPolicy) {\n  // If it's a string it's a path to a policy file that needs to be loaded\n  if (typeof propertyPolicy === 'string') {\n    if (propertyPolicy.startsWith('/')) {\n      propertyPolicy = propertyPolicy.slice(1);\n    }\n\n    return moduleLoader.loadDependentModule(propertyPolicy).then(result => {\n      return exports.register(result);\n    });\n  } // Otherwise it must be the actual policy object\n\n\n  return AwPromiseService.instance.when(exports.register(propertyPolicy));\n};\nexports = {\n  _policyId2policy,\n  _policyId2registrationTimeStamp,\n  _policyCount,\n  _effectivePolicy,\n  _soaSvc,\n  _parentSelections,\n  _currentSelections,\n  _selectedPolicyIds,\n  _genericPolicyIds,\n  _selectedPropertyUsed,\n  getEffectivePolicy,\n  checkForSelectedObject,\n  setSelectedObjects,\n  addToParentSelection,\n  removeFromParentSelection,\n  register,\n  unregister,\n  validatePropertyRegistration,\n  registerPolicyAsync\n};\nexport default exports;\n/**\n * Catch the event for logging all registered policies in the current session and logging the effective policy\n * in the session\n */\n\neventBus.subscribe('cdm.logDiagnostics', function () {\n  var policy = exports.getEffectivePolicy();\n  logger.info('Property Policy Audit Console Logging :');\n\n  _.forEach(exports._policyId2registrationTimeStamp, function (times, policyId) {\n    logger.debug('Registered Property Policy Id \"' + policyId + '\" @ ' + times.time + ':', times.policy);\n  });\n\n  logger.debug('Effective Property Policy in session:', policy);\n  validatePolicy(policy, 1);\n}, 'soa_kernel_propertyPolicyService');","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/kernel/propertyPolicyService.js"],"names":["exports","_policyId2policy","_policyId2registrationTimeStamp","_policyCount","_effectivePolicy","_soaSvc","_parentSelections","_currentSelections","_selectedPolicyIds","_genericPolicyIds","_selectedPropertyUsed","modelType","cmm","parentModelType","getParentType","modifier","_","modifierToMerge","name","Value","modifiers","logger","property","propertyToMerge","properties","mergeModifier","type","typeToMerge","types","mergeProperty","getEffectivePolicy","policyIdsForEffectPolicy","isSelectedProperty","effectivePolicy","useRefCount","policy","mergeType","checkForSelectedObject","isFound","modelObjectUids","extractModelObjects","totalSelectedModelObject","getSelectedModelObjects","i","selectedModelObjects","ii","child","uids","setSelectedObjects","addToParentSelection","removeFromParentSelection","register","policyFinal","timeS","Date","JSON","nextId","policyId","currentTime","dateTimeSvc","time","unregister","callCount","typeNames","sortedTypeNames","promise","validatePolicy","output","validatePropertyRegistration","msg","modelObject","found","kk","ll","registerPolicyAsync","propertyPolicy","result","AwPromiseService","eventBus","times"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/propertyPolicyService\n */\nimport AwHttpService from 'js/awHttpService';\nimport AwPromiseService from 'js/awPromiseService';\nimport dateTimeSvc from 'js/dateTimeService';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport logger from 'js/logger';\nimport awConfiguration from 'js/awConfiguration';\nimport moduleLoader from 'js/moduleLoader';\n/**\n * Angular services\n */\n\nvar exports = {};\n\n/**\n * Map of policy id to registered policy.\n *\n * @private\n */\nexport let _policyId2policy = {};\n\n/**\n * Registration of time stamp for property policies.\n *\n * @private\n */\nexport let _policyId2registrationTimeStamp = {};\n\n/**\n * Registration counter for property policies.\n *\n * @private\n */\nexport let _policyCount = 0;\n\n/**\n * Effective property policy for subsequent server calls.\n *\n * @private\n */\nexport let _effectivePolicy = {};\n\n/**\n * Cache of last SOA service used by getEffectivePolicy()\n *\n * @private\n */\nexport let _soaSvc = null;\n\n/**\n * Parent selections.\n *\n * @private\n */\nexport let _parentSelections = [];\n\n/**\n * Current selections.\n *\n * @private\n */\nexport let _currentSelections = [];\n\n/**\n * List of selected policy Id's.\n *\n * @private\n */\nexport let _selectedPolicyIds = [];\n\n/**\n * List of generic policy Id's.\n *\n * @private\n */\nexport let _genericPolicyIds = [];\n\n/**\n * boolean to indicate whether the last effective policy was build from selected property policy or not.\n *\n * @private\n */\nexport let _selectedPropertyUsed = false;\n// /**\n//  * Sort input array by name field of elements.\n//  *\n//  * @param array array to sort\n//  * @private\n//  */\n// function sort( array ) {\n//     if( array ) {\n//         array.sort( function( a, b ) {\n//             return a.name.localeCompare( b.name );\n//         } );\n//     }\n// }\n\n/**\n * @param {String} typeName - type name\n * @param {String} propName - property name\n * @return {String} defining type name (whether on this type or one of it's parents)\n */\nfunction getParentType( typeName, propName ) {\n    var modelType = cmm.getType( typeName );\n    if( modelType && modelType.propertyDescriptorsMap.hasOwnProperty( propName ) ) {\n        var parentModelType = cmm.getType( modelType.parentTypeName );\n        if( parentModelType && parentModelType.propertyDescriptorsMap.hasOwnProperty( propName ) ) {\n            return getParentType( parentModelType.name, propName );\n        }\n        return modelType.name;\n    }\n    return null;\n}\n\n/**\n * Merge modifier into modifier array.\n *\n * @param {Array} modifiers - array of modifiers\n * @param {Object} modifierToMerge - modifier to merge into array\n * @private\n */\nfunction mergeModifier( modifiers, modifierToMerge ) {\n    var modifier = _.find( modifiers, _.matchesProperty( 'name', modifierToMerge.name ) );\n    if( !modifier ) {\n        modifier = {\n            name: modifierToMerge.name,\n            Value: modifierToMerge.Value\n        };\n        modifiers.push( modifier );\n    } else if( modifier.Value !== modifierToMerge.Value ) {\n        logger.error( 'Modifier conflict!' );\n    }\n}\n\n/**\n * Merge property into property array.\n *\n * @param {Array} properties - array of properties\n * @param {Object} propertyToMerge - property to merge into array\n * @private\n */\nfunction mergeProperty( properties, propertyToMerge ) {\n    var property = _.find( properties, _.matchesProperty( 'name', propertyToMerge.name ) );\n    if( !property ) {\n        property = {\n            name: propertyToMerge.name\n        };\n        properties.push( property );\n    }\n    if( propertyToMerge.modifiers && propertyToMerge.modifiers.length > 0 ) {\n        if( !property.modifiers ) {\n            property.modifiers = [];\n        }\n        _.forEach( propertyToMerge.modifiers, function( modifier ) {\n            mergeModifier( property.modifiers, modifier );\n        } );\n    }\n}\n\n/**\n * Merge type into type array.\n *\n * @param {Array} types - array of types\n * @param {Object} typeToMerge - type to merge into array\n * @private\n */\nfunction mergeType( types, typeToMerge ) {\n    var type = _.find( types, _.matchesProperty( 'name', typeToMerge.name ) );\n    if( !type ) {\n        type = {\n            name: typeToMerge.name\n        };\n        types.push( type );\n    }\n    if( typeToMerge.properties && typeToMerge.properties.length > 0 ) {\n        if( !type.properties ) {\n            type.properties = [];\n        }\n        _.forEach( typeToMerge.properties, function( property ) {\n            mergeProperty( type.properties, property );\n        } );\n    }\n    if( typeToMerge.modifiers && typeToMerge.modifiers.length > 0 ) {\n        if( !type.modifiers ) {\n            type.modifiers = [];\n        }\n        _.forEach( typeToMerge.modifiers, function( modifier ) {\n            mergeModifier( type.modifiers, modifier );\n        } );\n    }\n}\n\n/**\n * Effective property policy for use by Teamcenter SOA server call header.\n *\n * @param {Object} soaSvc - SOA service to avoid cyclic reference\n * @param {boolean} isSelectedProperty - flag indicating the policy type to use.\n * @return {Object} effective property policy\n */\nexport let getEffectivePolicy = function( soaSvc, isSelectedProperty ) {\n    if( soaSvc ) {\n        exports._soaSvc = soaSvc;\n    }\n\n    var policyIdsForEffectPolicy = exports._genericPolicyIds;\n    if( isSelectedProperty ) {\n        policyIdsForEffectPolicy = exports._selectedPolicyIds;\n    }\n    // we need to check which policy type (selected or generic ) was used to build the effective property policy\n    if( !exports._effectivePolicy || isSelectedProperty !== exports._selectedPropertyUsed ) {\n        var effectivePolicy = {\n            useRefCount: false\n            // do we need to set this? ie does the server default to zero anyway?\n        };\n        exports._selectedPropertyUsed = isSelectedProperty;\n        _.forEach( policyIdsForEffectPolicy, function( policyId ) {\n            var policy = exports._policyId2policy[ policyId ];\n            if( policy.types ) {\n                if( !effectivePolicy.types ) {\n                    effectivePolicy.types = [];\n                }\n                _.forEach( policy.types, function( type ) {\n                    mergeType( effectivePolicy.types, type );\n                } );\n            }\n\n            if( policy.modifiers && policy.modifiers.length > 0 ) {\n                if( !effectivePolicy.modifiers ) {\n                    effectivePolicy.modifiers = [];\n                }\n                _.forEach( policy.modifiers, function( modifier ) {\n                    mergeModifier( effectivePolicy.modifiers, modifier );\n                } );\n            }\n        } );\n\n        //            // Sort the effective policy for debug purposes\n        //            sort( effectivePolicy.types );\n        //            if( effectivePolicy.types ) {\n        //                _.forEach( effectivePolicy.types, function( type ) {\n        //                    sort( type.modifiers );\n        //                    if( type.properties ) {\n        //                        sort( type.properties );\n        //                        _.forEach( type.properties, function( property ) {\n        //                            sort( property.modifiers );\n        //                        } );\n        //                    }\n        //                } );\n        //            }\n        //            sort( effectivePolicy.modifiers );\n\n        exports._effectivePolicy = effectivePolicy;\n    }\n    return exports._effectivePolicy;\n};\n\n/**\n * Returns true if at least one selected object is present in the input body.\n *\n * @param {Object} body - input body\n * @param {StringArray} modelObjectUidList - model object uid's\n * @return {Boolean} true if at least one selected object is present in the input body.\n */\nexport let checkForSelectedObject = function( body, modelObjectUidList ) {\n    var isFound = false;\n    var modelObjectUids = modelObjectUidList;\n    if( !modelObjectUidList ) {\n        modelObjectUids = [];\n        extractModelObjects( body, modelObjectUids );\n    }\n    if( modelObjectUids.length > 0 ) {\n        var totalSelectedModelObject = getSelectedModelObjects();\n        for( var i = 0; i < totalSelectedModelObject.length; i++ ) {\n            if( modelObjectUids.indexOf( totalSelectedModelObject[ i ] ) > -1 ) {\n                isFound = true;\n                break;\n            }\n        }\n    }\n    return isFound;\n};\n\n/**\n * Returns a list of all the selected model objects. This list includes the parent and the child selections.\n *\n * @private\n * @return {IModelObjectArray} An array of total selected model objects uid's list.\n */\nfunction getSelectedModelObjects() {\n    var selectedModelObjects = [];\n\n    // add current selected objects to the selected objects list .\n    for( var i = 0; i < exports._currentSelections.length; i++ ) {\n        if( selectedModelObjects.indexOf( exports._currentSelections[ i ] ) === -1 ) {\n            selectedModelObjects.push( exports._currentSelections[ i ] );\n        }\n    }\n\n    // add parent selected objects to the selected objects list .\n    for( var ii = 0; ii < exports._parentSelections.length; ii++ ) {\n        if( selectedModelObjects.indexOf( exports._parentSelections[ ii ] ) === -1 ) {\n            selectedModelObjects.push( exports._parentSelections[ ii ] );\n        }\n    }\n\n    return selectedModelObjects;\n}\n\n/**\n * Extracts model object uid's from the body\n *\n * @private\n * @param {Object} body - input body\n * @param {StringArray} uids - Array of {ModelObject} uid's found in body\n */\nfunction extractModelObjects( body, uids ) {\n    _.forEach( body, function( child ) {\n        if( _.isPlainObject( child ) ) {\n            if( child.hasOwnProperty( 'uid' ) && child.hasOwnProperty( 'type' ) ) {\n                if( child.uid && child.uid !== 'AAAAAAAAAAAAAA' ) {\n                    uids.push( child.uid );\n                }\n            } else {\n                extractModelObjects( child, uids );\n            }\n        } else if( _.isArray( child ) ) {\n            extractModelObjects( child, uids );\n        }\n    } );\n}\n\n/**\n * Set's the selected model objects.\n *\n * @param {StringArray} selectedObectuids selected object uid's\n */\nexport let setSelectedObjects = function( selectedObectuids ) {\n    if( selectedObectuids ) {\n        exports._currentSelections = selectedObectuids;\n    } else {\n        exports._currentSelections = [];\n    }\n};\n\n/**\n * Add's the selected model object to parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\nexport let addToParentSelection = function( selectedObectuid ) {\n    if( !exports._parentSelections ) {\n        exports._parentSelections = [];\n    } else {\n        exports._parentSelections.push( selectedObectuid );\n    }\n};\n\n/**\n * removes the model object from parent selection.\n *\n * @param {String} selectedObectuid selected object uid's\n */\nexport let removeFromParentSelection = function( selectedObectuid ) {\n    // Remove the selected object\n    if( exports._parentSelections.lastIndexOf( selectedObectuid ) > -1 ) {\n        exports._parentSelections.splice( exports._parentSelections.lastIndexOf( selectedObectuid ), 1 );\n    }\n};\n\n/**\n * Register property policy.\n *\n * @param {Object} policy - property policy\n * @param {String} policyString - property policy string\n * @param {String} policyType - property type\n * @return {String} property policy ID\n */\nexport let register = function( policy, policyString, policyType ) {\n    var policyFinal = policy;\n\n    var timeS = Date.now();\n\n    if( !policyFinal ) {\n        policyFinal = JSON.parse( policyString );\n    }\n\n    var nextId = ++exports._policyCount;\n\n    // Create policy id\n    var policyId = 'policy' + nextId;\n\n    // Cache policy\n    exports._policyId2policy[ policyId ] = policyFinal;\n\n    // depending upon the policy type add the policy to generic list\n    if( !policyType ) {\n        exports._genericPolicyIds.push( policyId );\n    }\n\n    exports._selectedPolicyIds.push( policyId );\n\n    // Clear cache of effective policy\n    exports._effectivePolicy = null;\n\n    var currentTime = dateTimeSvc.formatTime( timeS );\n\n    if( logger.isTraceEnabled() ) {\n        logger.trace( 'Register Property Policy Id: ' + policyId + ' TimeStamp: ' + currentTime + ' Policy data:',\n            policyFinal );\n    }\n\n    if( policyString ) {\n        exports._policyId2registrationTimeStamp[ policyId ] = {\n            time: currentTime,\n            policy: policyFinal\n        };\n    }\n\n    // Return new cached policy id\n    return policyId;\n};\n\n/**\n * Register property policy.\n *\n * @param {String} policyId - cached property policy ID\n */\nexport let unregister = function( policyId ) {\n    // Remove the policy id from selected property policy id list\n    if( exports._selectedPolicyIds.indexOf( policyId ) > -1 ) {\n        exports._selectedPolicyIds.splice( exports._selectedPolicyIds.indexOf( policyId ), 1 );\n    }\n    // Remove the policy id from generic property policy id list\n    if( exports._genericPolicyIds.indexOf( policyId ) > -1 ) {\n        exports._genericPolicyIds.splice( exports._genericPolicyIds.indexOf( policyId ), 1 );\n    }\n\n    if( exports._policyId2policy.hasOwnProperty( policyId ) ) {\n        delete exports._policyId2policy[ policyId ];\n\n        if( logger.isTraceEnabled() ) {\n            logger.trace( 'Unregister Property Policy Id: ' + policyId + ' TimeStamp: ' +\n                dateTimeSvc.formatTime( Date.now() ) );\n        }\n\n        delete exports._policyId2registrationTimeStamp[ policyId ];\n        // Clear cache of effective policy\n        exports._effectivePolicy = null;\n    }\n};\n\n/**\n * @param {Object} policy - property policy to validate\n * @param {number} callCount - call count to avoid infinite loop if a type name is invalid & can't be loaded\n */\nfunction validatePolicy( policy, callCount ) {\n    if( policy.types ) {\n        if( callCount < 5 && exports._soaSvc ) {\n            var typeNames = [];\n            _.forEach( policy.types, function( type ) {\n                var modelType = cmm.getType( type.name );\n                if( !modelType ) {\n                    typeNames.push( type.name );\n                } else {\n                    _.forEach( modelType.typeHierarchyArray, function( name2 ) {\n                        if( !cmm.containsType( name2 ) ) {\n                            typeNames.push( name2 );\n                        }\n                    } );\n                }\n            } );\n            const sortedTypeNames = typeNames.sort();\n            typeNames = _.uniq( sortedTypeNames, true );\n            if( typeNames ) {\n                var promise = exports._soaSvc.ensureModelTypesLoaded( typeNames );\n                if( promise ) {\n                    promise.then( function() {\n                        return validatePolicy( policy, ++callCount );\n                    } );\n                    return;\n                }\n            }\n        }\n\n        var output = [];\n        _.forEach( policy.types, function( type ) {\n            var modelType = cmm.getType( type.name );\n            if( modelType ) {\n                if( type.properties ) {\n                    var parentModelType = cmm.getType( modelType.parentTypeName );\n                    _.forEach( type.properties, function( property ) {\n                        if( property ) {\n                            if( !modelType.propertyDescriptorsMap.hasOwnProperty( property.name ) ) {\n                                output.push( 'Invalid property [' + property.name + '] on type [' +\n                                    type.name + ']' );\n                            } else if( parentModelType &&\n                                parentModelType.propertyDescriptorsMap.hasOwnProperty( property.name ) ) {\n                                output.push( 'Wrong type for property [' + property.name + '] on type [' +\n                                    type.name + '], should be on type [' +\n                                    getParentType( parentModelType.name, property.name ) + ']' );\n                            } else {\n                                output.push( 'Effective property [' + property.name + '] on type [' +\n                                    type.name + ']' );\n                            }\n                        } else {\n                            output.push( 'Empty property on type [' + type.name + ']' );\n                        }\n                    } );\n                }\n            } else {\n                output.push( 'Invalid type [' + type.name + ']' );\n            }\n            if( !type.properties && !type.modifiers ) {\n                output.push( 'Missing properties for type [' + type.name + ']' );\n            }\n        } );\n\n        if( output.length > 0 ) {\n            output.sort();\n            logger.info( output.join( '\\n' ) );\n        }\n    }\n}\n\n/**\n * @param {Array} modelObjects array of model objects\n * @param {Array} propNames array of property names\n */\nexport let validatePropertyRegistration = function( modelObjects, propNames ) {\n    var policy = exports.getEffectivePolicy();\n    var msg = '';\n    _.forEach( modelObjects, function( modelObject ) {\n        if( modelObject ) {\n            var modelType = modelObject.modelType;\n            _.forEach( propNames, function( propName ) {\n                if( modelType.propertyDescriptorsMap.hasOwnProperty( propName ) && policy.types ) {\n                    var found = false;\n                    for( var kk = 0; kk < policy.types.length && !found; kk++ ) {\n                        var type = policy.types[ kk ];\n                        if( type.properties && modelType.typeHierarchyArray.indexOf( type.name ) > -1 ) {\n                            for( var ll = 0; ll < type.properties.length && !found; ll++ ) {\n                                var property = type.properties[ ll ];\n                                if( property.name === propName ) {\n                                    found = true;\n                                }\n                            }\n                        }\n                    }\n                    if( !found ) {\n                        msg += '\\n\\tType [' + modelType.displayName + '] PropertyName [' + propName + ']';\n                    }\n                }\n            } );\n        }\n    } );\n\n    if( msg ) {\n        logger.debug( 'Property Policy registration is missing for the following:' + msg );\n    }\n};\n\n/**\n * Register a policy which may need to be loaded from a separate json file.\n *\n * @param {Object|String} propertyPolicy - A property policy object or a path to the file containing the policy\n *\n * @return {Promise} A promise that will be resolved with the new policy id\n */\nexport let registerPolicyAsync = function( propertyPolicy ) {\n    // If it's a string it's a path to a policy file that needs to be loaded\n    if( typeof propertyPolicy === 'string' ) {\n        if( propertyPolicy.startsWith( '/' ) ) {\n            propertyPolicy = propertyPolicy.slice( 1 );\n        }\n        return moduleLoader.loadDependentModule( propertyPolicy ).then( ( result ) => {\n            return exports.register( result );\n        } );\n    }\n    // Otherwise it must be the actual policy object\n    return AwPromiseService.instance.when( exports.register( propertyPolicy ) );\n};\n\nexports = {\n    _policyId2policy,\n    _policyId2registrationTimeStamp,\n    _policyCount,\n    _effectivePolicy,\n    _soaSvc,\n    _parentSelections,\n    _currentSelections,\n    _selectedPolicyIds,\n    _genericPolicyIds,\n    _selectedPropertyUsed,\n    getEffectivePolicy,\n    checkForSelectedObject,\n    setSelectedObjects,\n    addToParentSelection,\n    removeFromParentSelection,\n    register,\n    unregister,\n    validatePropertyRegistration,\n    registerPolicyAsync\n};\nexport default exports;\n\n/**\n * Catch the event for logging all registered policies in the current session and logging the effective policy\n * in the session\n */\neventBus.subscribe( 'cdm.logDiagnostics', function() {\n    var policy = exports.getEffectivePolicy();\n    logger.info( 'Property Policy Audit Console Logging :' );\n\n    _.forEach( exports._policyId2registrationTimeStamp, function( times, policyId ) {\n        logger.debug( 'Registered Property Policy Id \"' + policyId + '\" @ ' + times.time + ':', times.policy );\n    } );\n\n    logger.debug( 'Effective Property Policy in session:', policy );\n\n    validatePolicy( policy, 1 );\n}, 'soa_kernel_propertyPolicyService' );\n"]},"metadata":{},"sourceType":"module"}