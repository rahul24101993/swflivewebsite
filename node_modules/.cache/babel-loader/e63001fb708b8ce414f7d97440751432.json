{"ast":null,"code":"/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service manages the 'source' object information placed into 'localStorage' during drag-n-drop operations.\n *\n * @module js/dragAndDropService\n */\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport dms from 'soa/dataManagementService';\nimport soaSvc from 'soa/kernel/soaService';\nimport cfgSvc from 'js/configurationService';\nimport messagingSvc from 'js/messagingService';\nimport localeService from 'js/localeService';\nimport appCtxSvc from 'js/appCtxService';\nimport adapterSvc from 'js/adapterService';\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport declUtils from 'js/declUtils';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport dragAndDropUtils from 'js/dragAndDropUtils'; // Service\n\nimport AwBaseService from 'js/awBaseService';\nimport AwStateService from 'js/awStateService';\nimport pasteService from 'js/pasteService';\nimport AwPromiseService from 'js/awPromiseService';\nimport htmlUtils from 'js/htmlUtils'; // Class for load handler\n// This file is too complex to convert it to a complete class\n\nclass DragAndDropService extends AwBaseService {\n  static reset() {\n    AwBaseService.reset();\n    delete this._defaultPasteHandler;\n    delete this._pasteFileHandler;\n  }\n\n  constructor() {\n    super(); // The following check is to support Karma testing which invokes this multiple times.\n\n    if (!_cfgLoadPromise && !(this.constructor._defaultPasteHandler || this.constructor._pasteFileHandler)) {\n      _cfgLoadPromise = cfgSvc.getCfg('paste').then(pasteProvider => {\n        if (pasteProvider.defaultPasteHandler) {\n          return declUtils.loadDependentModule(pasteProvider.defaultPasteHandler.dep).then(dep => {\n            this.constructor._defaultPasteHandler = dep;\n            return pasteProvider;\n          });\n        }\n\n        return pasteProvider;\n      }).then(pasteProvider => {\n        if (pasteProvider.defaultPasteFileHandler) {\n          return declUtils.loadDependentModule(pasteProvider.defaultPasteFileHandler.dep).then(dep => {\n            this.constructor._pasteFileHandler = dep;\n            return pasteProvider;\n          });\n        }\n      }).then(function () {\n        _cfgLoadPromise = null;\n      });\n    }\n  }\n\n  get pasteHandler() {\n    return this.constructor._defaultPasteHandler;\n  }\n\n  get pasteFileHandler() {\n    return this.constructor._pasteFileHandler;\n  }\n\n}\n/**\n * Data formats to put the data in. It would be better to only use aw_interop_type here, but that isn't working\n * with Chrome.\n */\n\n\nvar DATA_FORMATS = ['text/html', 'aw_interop_type'];\n/** Dataset type */\n\nvar TYPE_NAME_DATASET = 'Dataset';\n/** This is set to true if any of the dragged objects have a type set.\n */\n\nvar modelsHaveTypes;\n/**\n * {DOMElement} root container for the page.\n */\n\nvar mainReference;\n/**\n * {Boolean} TRUE if the drag event should have it's 'dataTransfer' object set/maintained.\n */\n\nvar _includeDataTransfer = true;\n/**\n * {Boolean} TRUE if various drag event activities should publish 'hosting' related events.\n */\n\nvar _publishHostingEvents = false;\n/**\n * {Function} A callback used to create the 'InteropObjectRef' encodings necessary to communicate more complex\n * selection information via drag event data format properties.\n * <P>\n * Note: Until the hosting 'InteropObjectRefFactory' is converted from GWT to native JS we must rely on it for\n * conversion of IModelObjects to the special encoding used for communications of 'source' objects to the host.\n */\n\nvar _createInteropObjectRefFn;\n/**\n * Temporary promise reference for loading of the configuration data. This is used to allow code to wait until\n * ready before doing work.\n *\n * @private\n */\n\n\nvar _cfgLoadPromise;\n/**\n * <pre>\n * Greater Than 0 If some basic event activity should be logged.\n * Greater Than 1 If some more fine-grained event activity should be logged.\n * </pre>\n */\n\n\nvar _debug_logEventActivity = 0;\nconst HOSTING_DRAG_DROP_EVENT = 'hosting.DragDropEvent';\nconst UI_GRID_ROW_CLASS = '.ui-grid-row';\nconst DROP_CLASS = '.aw-widgets-droppable';\nconst DRAG_DROP_HIGHLIGHT_EVENT = 'dragDropEvent.highlight';\nvar urlAttributes = browserUtils.getUrlAttributes();\n\nif (urlAttributes.logDnDEventActivity !== undefined) {\n  _debug_logEventActivity = 1;\n\n  if (urlAttributes.logDnDEventActivity > 0) {\n    _debug_logEventActivity = urlAttributes.logDnDEventActivity;\n  }\n}\n/**\n * TRUE if the type that was not valid for a target is logged. This is very handy when debugging issues.\n */\n\n\nvar m_debug_LogRejectedSourceType = false;\n/**\n * Map used to hold an unresolved {Promise} for a given 'evaluation key' *while* the async server call is being\n * made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\n\nvar m_mapKey2Promise = {};\n/**\n * Map used to hold the *result* of a previous async server call for a given 'evaluation key'.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\n\nvar m_mapKey2Result = {};\n/**\n * TRUE if dragging files from the OS file should be allowed.\n */\n\nvar m_supportingFileDrop = true;\n/**\n * Set used to hold an 'unresolved source type lookup key' *while( the async server call is being made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'unresolved source type lookup key'.\n * <P>\n * Note: The 'unresolved source type lookup key' is formed by a union of MissingSourceTypes.\n */\n\nvar m_typeLookupInProgress = {};\nlet isGlobalHighlightPublished = false; //* **********************************************************************\n\n/**\n * Clear out any 'dragData' that may have been created by the last Drag-n-Drop operation.\n */\n\nvar _clearCachedData = function () {\n  localStrg.publish('awDragData');\n};\n/**\n * @param {StringArray} validSourceTypes The 'sourceTypes' {@link JavaScriptObject} property from the\n *            pasteConfig for the given 'target' object type or its ancestor types up the hierarchy (or NULL if\n *            no match was found).\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n *\n * @returns {Object} A {@link Map} that relates 'source' types to the 1 or more possible relationship types that\n *         are valid for the 'owner' (i.e. 'target') {@link IModelObject}.\n */\n\n\nvar _createSourceType2RelationsMap = function (validSourceTypes, targetElement) {\n  var sourceType2RelationsMap = {};\n  var validSourceObjects = $(targetElement).data('validSourceTypes');\n\n  if (validSourceObjects) {\n    for (var i = 0; i < validSourceTypes.length; i++) {\n      var sourceType = validSourceTypes[i];\n      var validSourceObj = validSourceObjects[sourceType];\n      var relations = [];\n\n      if (validSourceObj.relation) {\n        relations.push(validSourceObj.relation);\n      } else {\n        relations.push('');\n      }\n\n      sourceType2RelationsMap[sourceType] = relations;\n    }\n  }\n\n  return sourceType2RelationsMap;\n};\n/**\n * Remove from selection any non-'target' object currently selected (like the ones we may have just pasted) so\n * that the 'target' can be cleanly selected later.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject the 'source' ViewModelObject(s) are being\n *            dropped onto.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAll = function (targetVMO, callbackAPIs) {\n  callbackAPIs.clearSelectionFn(targetVMO);\n};\n/**\n * Get the adapted objects corresponding to the VMOs if any.\n *\n * @param {ObjectArray} vmos - Array of viewmodel objects.\n *\n * @return {Array} Returns array of adapadted objects if any or else returns the vmos\n */\n\n\nconst getAdaptedObjects = vmos => {\n  return dragAndDropUtils.getObjects(vmos);\n};\n/**\n * Synchronously create Datasets, upload the given JS Files and attach the files to the Datasets using the\n * correct relation types and the tickets used to upload the files.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {ObjectArray} sourceFiles - The 'source' JS File objects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAllAndPasteSourceFiles = function (targetElement, targetVMO, sourceFiles, callbackAPIs) {\n  if (sourceFiles && sourceFiles.length > 0) {\n    _deselectAll(targetVMO, callbackAPIs);\n\n    _pasteSourceFiles(targetElement, targetVMO, sourceFiles, callbackAPIs);\n  }\n};\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObject(s) being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _deselectAllAndPasteSourceObjects = function (targetElement, targetVMO, sourceObjects, callbackAPIs) {\n  if (sourceObjects && sourceObjects.length > 0) {\n    _deselectAll(targetVMO, callbackAPIs);\n\n    _pasteSourceObjects(targetElement, targetVMO, sourceObjects, callbackAPIs);\n  }\n};\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element.\n *\n * @param {ObjectArray} sourceFiles - The array 'source' JS File objects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _dropFiles = function (targetElement, sourceFiles, callbackAPIs) {\n  var targetVMOs = callbackAPIs.getElementViewModelObjectFn(targetElement);\n\n  if (!targetVMOs || targetVMOs.length === 0) {\n    var targetUID = $(targetElement).data('dropuid');\n\n    if (targetUID) {\n      targetVMOs = [];\n      targetVMOs.push(exports.getTargetObjectByUid(targetUID));\n    }\n  }\n\n  if (targetVMOs && targetVMOs.length !== 0) {\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMOs[0].modelType)) {\n      adapterSvc.getAdaptedObjects(targetVMOs).then(function (adaptedObjs) {\n        _deselectAllAndPasteSourceFiles(targetElement, adaptedObjs[0], sourceFiles, callbackAPIs);\n      });\n    } else {\n      _deselectAllAndPasteSourceFiles(targetElement, targetVMOs[0], sourceFiles, callbackAPIs);\n    }\n  }\n\n  _clearCachedData();\n};\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _dropModelObjects = function (targetElement, sourceUIDs, callbackAPIs) {\n  var targetVMOs = callbackAPIs.getElementViewModelObjectFn(targetElement);\n\n  if (!targetVMOs || targetVMOs.length === 0) {\n    var targetUID = $(targetElement).data('dropuid');\n\n    if (targetUID) {\n      targetVMOs = [];\n      targetVMOs.push(exports.getTargetObjectByUid(targetUID));\n    }\n  }\n\n  if (targetVMOs && targetVMOs.length !== 0) {\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMOs[0].modelType)) {\n      adapterSvc.getAdaptedObjects(targetVMOs).then(function (adaptedObjs) {\n        _dropModelObjectsInternal(targetElement, sourceUIDs, callbackAPIs, adaptedObjs);\n      });\n    } else {\n      _dropModelObjectsInternal(targetElement, sourceUIDs, callbackAPIs, targetVMOs);\n    }\n  }\n};\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n *\n * @param {Object} targetVMOs - View model object of target.\n */\n\n\nvar _dropModelObjectsInternal = function (targetElement, sourceUIDs, callbackAPIs, targetVMOs) {\n  var sourceObjects = [];\n  var missingSourceUIDs = [];\n  /**\n   * Attempt to locate the 'source' objects in this browser's CDM cache.\n   * <P>\n   * Note: When 'source' objects are being dragged from another browser they may not have been loaded into the\n   * 'target' browser.\n   */\n\n  if (sourceUIDs) {\n    for (var i = 0; i < sourceUIDs.length; i++) {\n      var sourceObject = cdm.getObject(sourceUIDs[i]);\n\n      if (sourceObject) {\n        sourceObjects.push(sourceObject);\n      } else {\n        missingSourceUIDs.push(sourceUIDs[i]);\n      }\n    }\n  }\n  /**\n   * Check if NO 'source' objects are missing\n   * <P>\n   * If so: Process the past now\n   */\n\n\n  if (!missingSourceUIDs || missingSourceUIDs.length === 0) {\n    _deselectAllAndPasteSourceObjects(targetElement, targetVMOs[0], sourceObjects, callbackAPIs);\n\n    _clearCachedData();\n  } else {\n    /**\n     * Attempt to locate the missing 'source' objects on the server.\n     */\n    dms.loadObjects(missingSourceUIDs, function () {\n      /**\n       * Attempt to locate the (formerly) missing 'targets' and add them to the list of 'source' objects\n       * to drop on the 'target'\n       */\n      for (var j = 0; j < missingSourceUIDs.length; j++) {\n        var sourceObject = cdm.getObject(missingSourceUIDs[j]);\n\n        if (sourceObject) {\n          sourceObjects.push(sourceObject);\n        } else {// var sourceTypes = _getCachedSourceTypes();\n          // logger.warn( 'Unable to locate \\'source\\' IModelObject\\' (not loaded yet): ' +\n          //     missingSourceUIDs[ j ] + ' of type: ' + sourceTypes[ 0 ] );\n        }\n      }\n\n      if (sourceObjects && sourceObjects.length > 0) {\n        _deselectAllAndPasteSourceObjects(targetElement, targetVMOs[0], sourceObjects, callbackAPIs);\n      }\n\n      _clearCachedData();\n    });\n  }\n};\n/**\n * Starting with the given DOM Element and walking up the DOM, look for the 1st DOM Element with the\n * 'containerId' property set.\n *\n * @param {Element} testElement - The element to start the search at.\n *\n * @return {Number} The ID of the 'parent' element that has the 'containerId' set on it (or NULL if no Element\n *         was found).\n */\n\n\nvar _findContainerId = function (testElement) {\n  var currElement = testElement;\n\n  while (currElement) {\n    var containerId = $(currElement).data('containerId');\n\n    if (containerId) {\n      return containerId.toString();\n    }\n\n    currElement = currElement.parentElement;\n  }\n\n  return null;\n};\n/**\n * When object drag is cancelled , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {bool}_isDragCancelFlag -  true or false\n */\n\n\nvar _isDragCancelled = function (event) {\n  var _isDragCancelFlag = false;\n\n  if (event.x <= 0 || event.y <= 0) {\n    _isDragCancelFlag = true;\n  } else if (event.screenX <= 0 || event.screenY <= 0) {\n    _isDragCancelFlag = true;\n  } else {\n    _isDragCancelFlag = false;\n  }\n\n  return _isDragCancelFlag;\n};\n/**\n * When object is dragged over a cell list container , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\n\n\nvar _isDragWithinCellListContainer = function (event) {\n  var isCellListContainerFlag = false;\n  var cellListContainer = htmlUtils.closestElement(event.target, '.aw-widgets-cellListContainer');\n\n  if (_.isUndefined(cellListContainer) || cellListContainer === null) {\n    isCellListContainerFlag = false;\n  } else {\n    isCellListContainerFlag = true;\n  }\n\n  return isCellListContainerFlag;\n};\n/**\n * When object is dragged over a table row border, this check ensures the drag cursor does not go back to 'Not allowed' because of global\n * dragenter event since table row border is an invalid drop target\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\n\n\nvar _isDragWithinTableContainer = function (event) {\n  var isTableFlag = false;\n  var tableContainer = htmlUtils.closestElement(event.target, UI_GRID_ROW_CLASS);\n\n  if (_.isUndefined(tableContainer) || tableContainer === null) {\n    if (event && event.target && event.target.classList && event.target.classList.contains('ui-grid-row')) {\n      isTableFlag = true;\n    }\n  } else {\n    isTableFlag = true;\n  }\n\n  return isTableFlag;\n};\n/**\n * When object is dragged over the white area, this check ensures  dragenter, dragleave , dragover events on document do not trigger any action in turn giving\n * a flickering of highlight effect on the container\n *\n * @param {event} event - Drag event\n * @return {Object} bool - flag to suggest if drag is within an applicable and valid container\n */\n\n\nvar _isDragWithinApplicableValidContainer = function (event) {\n  var bool = false;\n  var jqTarget = $(event.target);\n  var jqContainer = jqTarget.closest(UI_GRID_ROW_CLASS);\n\n  if (jqContainer && jqContainer.length <= 0) {\n    jqContainer = jqTarget.closest('.aw-widgets-cellListItem');\n\n    if (jqContainer.length <= 0) {\n      jqContainer = jqTarget.closest(DROP_CLASS);\n\n      if (jqContainer.length <= 0) {\n        // this is when user just enters a cellListContainer from white area\n        if (jqTarget && jqTarget[0] && jqTarget[0].children && jqTarget[0].children.length > 0 && jqTarget[0].children[0].classList && jqTarget[0].children[0].classList.contains('aw-widgets-cellListContainer')) {\n          jqContainer = jqTarget[0].children;\n        }\n      }\n    }\n  }\n\n  if (jqContainer && jqContainer.length > 0 && exports.isValidObjectToDrop(event, jqContainer[0])) {\n    bool = true;\n  }\n\n  return bool;\n};\n/**\n * @param {event} event - Dragover event\n *\n * @return {Object} targetElement - choose or drop file widget which do not require validation or\n *                                   'undefined' if not over Choose or Drop File widgets\n */\n\n\nvar _isDragOverChooseOrDropFileContainer = function (event) {\n  var targetElement = null;\n\n  if (event && event.target && event.target.classList && event.target.classList.contains('aw-widgets-chooseordropfile')) {\n    targetElement = event.target;\n  } else {\n    var cfContainer = htmlUtils.closestElement(event.target, '.aw-widgets-chooseordropfile');\n\n    if (cfContainer) {\n      targetElement = cfContainer;\n    }\n  }\n\n  return targetElement;\n};\n/**\n * Determine if the DragEvent is over a white space on the page or on an applicable valid drop container\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\n\n\nexport let processDragOver = function (event, isCurrentTargetOverGlobalArea) {\n  // If drag is over Choose File or Drop File container , unhighlight other highlighted containers, highlight this\n  // container and set drop effect to 'Copy' ; these containers have a special css(in addition) to identify : 'aw-widgets-chooseordropfile'\n  var chooseFileContainer = _isDragOverChooseOrDropFileContainer(event);\n\n  if (chooseFileContainer) {\n    // Adding listeners to Choose/Drop File type widgets which mandatorily should have 'aw-widgets-chooseordropfile' associated\n    // along with 'aw-widgets-droppable' css class  to participate in highlight\n    chooseFileContainer.addEventListener('dragover', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS OVER CHOOSE/DROP FILE ZONE----------');\n      }\n\n      exports.processDragLeaveGlobal(event); // clear all the highlights\n\n      if (!exports.dataTransferContainsFiles(event)) {\n        _setDropEffect(event, 'none');\n\n        event.stopPropagation();\n      } else {\n        eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n          event: event,\n          isGlobalArea: false,\n          isHighlightFlag: true,\n          targetElement: chooseFileContainer\n        });\n\n        _setDropEffect(event, 'copy');\n\n        event.stopPropagation(); // required or else it hangs the page if file dragged over container for longer period of time.\n\n        event.preventDefault();\n      }\n    });\n    chooseFileContainer.addEventListener('dragleave', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS LEAVING CHOOSE/DROP FILE ZONE----------');\n      }\n\n      _setDropEffect(event, 'none');\n\n      exports.processDragLeaveGlobal(event);\n      event.stopPropagation();\n      event.preventDefault();\n    });\n    chooseFileContainer.addEventListener('drop', function (event) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('----------FILE IS DROPPED IN CHOOSE/DROP FILE ZONE----------');\n      }\n\n      _setDropEffect(event, 'none');\n\n      exports.processDragLeaveGlobal(event);\n      event.stopPropagation();\n      event.preventDefault();\n    });\n  }\n\n  var sourceUIDs = exports.getCachedSourceUids();\n\n  if (sourceUIDs) {\n    dragAndDropUtils.loadVMOsIfNotAlreadyLoaded(sourceUIDs);\n  }\n\n  _processDragOverInternal(event, isCurrentTargetOverGlobalArea);\n};\n/**\n * Starting with the 'target' of the given DragEvent and walking up the DOM, look for the 1st DOM Element with the\n * 'validSourceTypes' property set.\n *\n * @param {DragEvent} event - The event to start the search at.\n * @param {Bool} isCurrentTargetOverGlobalArea - is the dragged file over white/invalid area\n * @return {Element} The Element that has the 'validSourceTypes' property set on it (or NULL if no Element was\n *         found).\n */\n\nvar _findDropTargetElement = function (event) {\n  var targetElements = [];\n  /**\n   * Get the JQuery element for the event 'target' and look for common 'container' elements 'up' the DOM Tree.\n   */\n\n  var jqTarget = $(event.target);\n  var jqContainer = jqTarget.closest(UI_GRID_ROW_CLASS);\n\n  if (jqContainer !== undefined && jqContainer.length <= 0) {\n    jqContainer = jqTarget.closest('.aw-widgets-cellListItem');\n\n    if (jqContainer.length <= 0) {\n      jqContainer = jqTarget.closest(DROP_CLASS);\n    }\n  }\n\n  var targetElement;\n\n  if (jqContainer && jqContainer.length > 0) {\n    targetElement = jqContainer.get(0);\n  } else {\n    targetElement = jqTarget.get(0);\n  }\n\n  targetElements.push(targetElement);\n  /**\n   * Get the AngularJS element for the target 'container' element and try to find a {ViewModelObject} associated\n   * with it.\n   */\n\n  if (targetElements) {\n    _.forEach(targetElements, function (targetElement) {\n      //revisitme: fix the code as per react framework\n      // var ngTargetElement = ngModule.element( targetElement );\n      // var $scope = ngTargetElement.scope();\n      var targetVMO = null; // $scope &&\n      //     ( $scope.vmo || $scope.item ||\n      //         $scope.row && $scope.row.entity ||\n      //         $scope.data && $scope.data.vmo ) ||\n      //     targetElement.vmo || ngTargetElement.get( 0 ).vmo;\n\n      if (targetVMO) {\n        if (cmm.isInstanceOf('Awp0XRTObjectSetRow', targetVMO.modelType)) {\n          adapterSvc.getAdaptedObjects([targetVMO]).then(function (adaptedObjs) {\n            _setValidSourceTypesOnTarget(targetElement, adaptedObjs[0]);\n          });\n        } else {\n          _setValidSourceTypesOnTarget(targetElement, targetVMO);\n        }\n      }\n    });\n  }\n\n  return targetElements;\n};\n/**\n * Check if we have NOT already stored the collection of 'valid' 'source' types this 'target' will accept.\n * <P>\n * If so: Get that collection now.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - View model object of target.\n */\n\n\nvar _setValidSourceTypesOnTarget = function (targetElement, targetVMO) {\n  if (targetElement) {\n    var jqElement = $(targetElement);\n    var validSourceTypes = jqElement.data('validSourceTypes');\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n\n    if (!validSourceTypes && pasteHandler) {\n      validSourceTypes = pasteHandler.getObjectValidSourceTypes(targetVMO);\n      jqElement.data('validSourceTypes', validSourceTypes);\n      jqElement.data('dropuid', targetVMO.uid);\n\n      var containerId = _findContainerId(targetElement);\n\n      if (containerId) {\n        jqElement.data('containerId', containerId);\n      }\n    }\n  }\n};\n/**\n * @return {Object} The Object that represents cached drag data set when the drag operation began.\n */\n\n\nvar _getCachedDragData = function () {\n  var dragDataJSON = localStrg.get('awDragData');\n\n  if (dragDataJSON && dragDataJSON !== 'undefined') {\n    return JSON.parse(dragDataJSON);\n  }\n\n  return null;\n};\n/**\n * @param {String} dataTransferItem - The 'dataTransfer' Item to extract from.\n * @return {String} The type code of the given\n */\n\n\nfunction _getDataTransferType(dataTransferItem) {\n  var extensionIndex = dataTransferItem.lastIndexOf('/');\n\n  if (extensionIndex >= 0) {\n    return dataTransferItem.substring(extensionIndex + 1);\n  }\n\n  return '';\n}\n/**\n * @param {DragEvent} event - The DragEvent to extract the info from.\n *\n * @return {ObjectArray} Array of JS Files.\n */\n\n\nvar _getDataTransferSourceFiles = function (event) {\n  return event.dataTransfer.files;\n};\n/**\n * Return the 'source' element from the given drag event. The name of the element in the event can vary\n * depending on the browser the client is running with.\n *\n * @param {DragEvent} event - The event to extract the 'source' element from.\n *\n * @return {Element} The DOM element considered the 'source' of the given drag event.\n */\n\n\nvar _getEventSource = function (event) {\n  if (event.srcElement) {\n    return event.srcElement;\n  }\n\n  return event.target;\n};\n/**\n * Get the first child image element of the passed in element.\n *\n * @param {Element} sourceElement - element being dragged\n *\n * @return {Element} drag image element or returns passed in element if no image found.\n */\n\n\nvar _getFirstChildImage = function (sourceElement) {\n  var image = $(sourceElement).find('img:first')[0];\n  return image ? image : sourceElement;\n};\n/**\n * @param {String} uid - ID of the object to include in the URL.\n *\n * @return {String} The URL 'prefix' used to open an object in the 'show object' location of AW.\n */\n\n\nvar _getShowObjectURL = function (uid) {\n  // Have to decode as ui-router returns encoded URL (which is then decoded again by browser)\n  return window.decodeURIComponent(document.location.origin + document.location.pathname + AwStateService.instance.href('com_siemens_splm_clientfx_tcui_xrt_showObject', {\n    uid: uid\n  }));\n};\n/**\n * Returns the correct element to be dragged\n *\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} The correct drag element\n */\n\n\nvar _getDragElement = function (event, count) {\n  var element;\n\n  if (event && event.target && event.target.classList) {\n    if (event.target.classList.contains('aw-widgets-cellListItemContainer')) {\n      element = event.target.parentElement; // Cell element\n    } else if (event.target.classList.contains('ui-grid-cell')) {\n      var target = $(event.target);\n      var closest = target.closest(UI_GRID_ROW_CLASS);\n\n      if (closest && closest.length > 0 && count === 1) {\n        element = target.closest(UI_GRID_ROW_CLASS).get(0); // Table element\n      } else {\n        element = event.target;\n      }\n    }\n  }\n\n  return element;\n};\n/**\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} image element\n */\n\n\nvar _getMultiDragImage = function (event, count) {\n  var targetImage = _getDragElement(event, count);\n\n  var strWidth;\n  var strHeight;\n  var cloneImage = null;\n\n  if (targetImage) {\n    cloneImage = targetImage.cloneNode(true); // If cell, remove command icon/text\n\n    if (targetImage.classList && targetImage.classList.contains('aw-widgets-cellListItem')) {\n      // Keep the image from being duplicated at the top of the page\n      targetImage.style.position = 'relative';\n      strWidth = targetImage.offsetWidth - 50 + 'px';\n      strHeight = targetImage.offsetHeight - 10 + 'px'; // Remove commands from image\n\n      cloneImage.children[0].removeChild(cloneImage.children[0].children[1]); // Remove text from image\n\n      var cloneImageText = cloneImage.getElementsByClassName('aw-widgets-cellListCellTitleBlock')[0].parentNode;\n\n      if (cloneImageText) {\n        for (var i = 1; i < cloneImageText.children.length; i++) {\n          cloneImageText.removeChild(cloneImageText.children[i]);\n          i--;\n        }\n      }\n    } else {\n      // Else it is a row\n      strWidth = '150px';\n      strHeight = '100%';\n    }\n\n    cloneImage.id = 'dragCount';\n    cloneImage.style.maxWidth = strWidth;\n    cloneImage.style.minWidth = strWidth;\n    cloneImage.style.maxHeight = strHeight;\n    cloneImage.style.minHeight = strHeight;\n    cloneImage.style.position = 'absolute';\n    cloneImage.style.left = '0px';\n    cloneImage.style.top = '0px';\n    cloneImage.style.zIndex = '99';\n    cloneImage.classList.add('aw-theme-multidragimage');\n    cloneImage.classList.add('aw-widgets-multidragimage'); // the image that is dragged needs to be visible, so it is added to the existing node\n\n    targetImage.children[0].appendChild(cloneImage); // create a second offset image\n\n    var cloneImage2 = cloneImage.cloneNode(true);\n    cloneImage2.style.left = '5px';\n    cloneImage2.style.top = '5px'; // create a third offset image & append if necessary\n\n    var cloneImage3 = cloneImage.cloneNode(true);\n    cloneImage.appendChild(cloneImage2);\n\n    if (count > 2) {\n      cloneImage3.style.left = '10px';\n      cloneImage3.style.top = '10px';\n      cloneImage.appendChild(cloneImage3);\n    }\n  }\n\n  return cloneImage;\n};\n/**\n * Returns the 'validSourceTypes' property on the 'target' element being dropped onto.\n *\n * @param {Element} targetElement - The Element that will be dropped onto (i.e. the data 'target').\n *\n * @return {StringArray} Array of valid 'sourceTypes' (or an empty array if no 'sourceTypes' are valid).\n */\n\n\nvar _getValidSourceTypes = function (targetElement) {\n  var validSourceTypes = $(targetElement).data('validSourceTypes');\n\n  if (validSourceTypes) {\n    return Object.keys(validSourceTypes);\n  }\n\n  return [];\n};\n/**\n * Use the given ViewModelObject to return a string description of it.\n *\n * @param {ViewModelObject} vmo - The ViewModelObject to query.\n *\n * @return {String} Description of given ViewModelObject (or it's UID if no other name is possible).\n */\n\n\nvar _getViewModelObjectName = function (vmo) {\n  if (vmo.props.object_string) {\n    return vmo.props.object_string.displayValues[0];\n  } else if (vmo.props.items_tag) {\n    return vmo.props.items_tag.displayValues[0];\n  } else if (vmo.props.object_name) {\n    return vmo.props.object_name.displayValues[0];\n  } else if (vmo.props.object_desc && vmo.props.object_desc.length > 0) {\n    return vmo.props.object_desc.displayValues[0];\n  } else if (vmo.props.job_name) {\n    return vmo.props.job_name.displayValues[0];\n  } else if (vmo.props.awp0CellProperties) {\n    return vmo.props.awp0CellProperties.displayValues[0];\n  }\n\n  return vmo.uid;\n};\n/**\n * Check the user agent string to see if the browser is the NX embedded browser, the NX QT browser puts \"ugraf\"\n * in the user agent string.\n *\n * @return {boolean} true if NX browser false otherwise\n */\n\n\nvar _isNxWebBrowser = function () {\n  return navigator.userAgent.indexOf('ugraf') >= 0;\n};\n/**\n * @param {StringArray} validSourceTypes - Array of 'source' types this 'target' will accept.\n * @param {StringArray} sourceTypes - Arrays of 'source' types determined from the event's 'dataTransfer' being\n *            dragged.\n *\n * @return {Boolean} TRUE if ALL the given 'source' types are valid to drop onto the 'target' based on the given\n *         'validSourceTypes'.\n */\n\n\nvar _isValidObjectToDropInternal = function (validSourceTypes, sourceTypes) {\n  /**\n   * Check if we have anything to work with.\n   */\n  if (validSourceTypes && validSourceTypes.length > 0 && sourceTypes && sourceTypes.length > 0) {\n    /**\n     * Check if all the 'sources' matches at least one valid type for the 'target' Element.\n     * <P>\n     * If so: We will consider the drop of these 'sources' onto that 'target'.\n     */\n    for (var i = 0; i < sourceTypes.length; i++) {\n      var sourceType = sourceTypes[i];\n      var sourceTypeFound = null;\n      /**\n       * Consider each valid 'source' type the 'target' will accept.\n       */\n\n      for (var j = 0; j < validSourceTypes.length; j++) {\n        var validSourceType = validSourceTypes[j];\n        /**\n         * Check for an exact match\n         */\n\n        if (sourceType === validSourceType) {\n          sourceTypeFound = validSourceType;\n          break;\n        }\n        /**\n         * Get all the ancestor types for this 'source' type and see if one of them is valid for this\n         * 'target'.\n         */\n\n\n        var sourceModelType = cmm.getType(sourceType);\n\n        if (sourceModelType) {\n          var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n          if (sourceTypeHeirarchy) {\n            for (var k = 1; k < sourceTypeHeirarchy.length; k++) {\n              if (sourceTypeHeirarchy[k] === validSourceType) {\n                sourceTypeFound = validSourceType;\n                break;\n              }\n            }\n          }\n        } else {\n          logger.warn('Unable to locate \\'source\\' type (not loaded yet?): ' + sourceType);\n        }\n      }\n      /**\n       * Check if NONE of the valid 'source' types apply.\n       */\n\n\n      if (!sourceTypeFound) {\n        if (m_debug_LogRejectedSourceType) {\n          logger.warn('This \\'source\\' type is not valid for the \\'target\\': ' + sourceType);\n        }\n\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * @param {Object} pasteInput - An Object that maps a unique 'relationType' to the array of 'source'\n *            IModelObjects that should be pasted onto the 'target' with that 'relationType'.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\n\n\nvar _pasteFiles = function (pasteInput) {\n  let pasteFileHandler = DragAndDropService.instance.pasteFileHandler;\n  return pasteFileHandler.pasteFilesWithHandler(pasteInput).then(function (response) {\n    if (response && response.isOsFiles) {\n      const {\n        pasteFilesInput\n      } = response;\n      var deferred = AwPromiseService.instance.defer();\n\n      _.forEach(pasteFilesInput, function (input) {\n        const {\n          targetObject,\n          relationType,\n          sourceObjects\n        } = input;\n        pasteService.execute(targetObject, sourceObjects, relationType, {\n          isDragDropIntent: true\n        }).then(function (res) {\n          var eventData = {\n            relatedModified: [targetObject],\n            refreshLocationFlag: false,\n            createdObjects: sourceObjects\n          };\n          eventBus.publish('cdm.relatedModified', eventData);\n          deferred.resolve(res[0]);\n        }, function (err) {\n          deferred.reject(err);\n        });\n      });\n\n      return deferred.promise;\n    }\n\n    return response;\n  });\n};\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Array} sourceFiles - The 'source' JS File objects being dropped.\n * @param {FunctionArray} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _pasteSourceFiles = function (targetElement, targetVMO, sourceFiles, callbackAPIs) {\n  /**\n   * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n   * type.\n   */\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (!validSourceTypes || validSourceTypes.length === 0) {\n    validSourceTypes = [];\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n    var sourceTypesObject = pasteHandler.getObjectValidSourceTypes(targetVMO);\n\n    if (sourceTypesObject && typeof sourceTypesObject === 'object') {\n      var sourceTypes = Object.keys(sourceTypesObject);\n\n      if (sourceTypes) {\n        for (var counter = 0; counter < sourceTypes.length; counter++) {\n          var validSourceType = sourceTypes[counter];\n\n          if (cmm.containsType(validSourceType)) {\n            validSourceTypes.push(validSourceType);\n          }\n        }\n      }\n    }\n  }\n\n  var sourceType2RelationMap = _createSourceType2RelationsMap(validSourceTypes, targetElement);\n\n  var pasteRelation2SourceObjectsMap = {};\n\n  if (sourceFiles) {\n    for (var i = 0; i < sourceFiles.length; i++) {\n      var sourceObject = sourceFiles[i];\n      /**\n       * Get all the ancestor types for this 'source' type and see if one of them is valid.\n       * <P>\n       * Note: For dropping files we look to see if the 'target' accepts a 'Dataset' since that is what will\n       * ultimately be created.\n       */\n\n      var sourceModelType = cmm.getType(TYPE_NAME_DATASET);\n\n      if (sourceModelType) {\n        var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n        for (var j = 0; j < sourceTypeHeirarchy.length; j++) {\n          var currSourceType = sourceTypeHeirarchy[j];\n          var relationType = sourceType2RelationMap[currSourceType];\n\n          if (relationType) {\n            var sourceObjectsForType = pasteRelation2SourceObjectsMap[relationType];\n\n            if (!sourceObjectsForType) {\n              sourceObjectsForType = [];\n              pasteRelation2SourceObjectsMap[relationType] = sourceObjectsForType;\n            }\n\n            sourceObjectsForType.push(sourceObject);\n            break;\n          }\n        }\n      } else {\n        logger.warn('Unable to locate \\'source\\' type\\' (not loaded yet?): ' + TYPE_NAME_DATASET);\n      }\n    }\n  }\n\n  _scheduleSelectTarget(targetElement, targetVMO, callbackAPIs);\n  /**\n   * Paste 'sources' to 'target' for each unique 'relation' type.\n   */\n\n\n  var pasteInput = [];\n\n  _.forEach(pasteRelation2SourceObjectsMap, function (value, key) {\n    var curr = {};\n    curr.targetObject = targetVMO;\n    curr.relationType = key;\n    curr.sourceObjects = value;\n    pasteInput.push(curr);\n  });\n\n  var startTime = Date.now();\n\n  _pasteFiles(pasteInput).then(function (result) {\n    var stopTime = Date.now();\n    var pasteInputJS = pasteInput;\n    var sourceObjectsJS = result.sourceObjects;\n\n    if (_debug_logEventActivity > 1) {\n      var durationMs = stopTime - startTime;\n      var durationSec = durationMs / 1000.0;\n      var duration = durationSec;\n      logger.info('Time to process (' + sourceObjectsJS.length + ') files: ' + duration + 'sec');\n    }\n\n    var localTextBundle = {};\n    localTextBundle.dropCompletedDocument = localeService.getLoadedTextFromKey('dragAndDropMessages.dropCompletedDocument');\n    localTextBundle.dropCompleted = localeService.getLoadedTextFromKey('dragAndDropMessages.dropCompleted');\n    /**\n     * Based on passed parameters in return from create SOA post the correct success message to the user.\n     */\n\n    var droppedOnObject = pasteInputJS[0].targetObject.cellHeader1;\n\n    if (!droppedOnObject) {\n      droppedOnObject = pasteInputJS[0].targetObject.props.object_string.uiValues[0];\n    }\n\n    if (!droppedOnObject) {\n      droppedOnObject = '???';\n    }\n\n    if (result.docCreated) {\n      var dropCompletedDocumentMsg = localTextBundle.dropCompletedDocument;\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{0}', result.docName);\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{1}', droppedOnObject);\n      dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace('{2}', sourceObjectsJS.length);\n      messagingSvc.showInfo(dropCompletedDocumentMsg);\n    } else {\n      var dropCompletedMsg = localTextBundle.dropCompleted;\n      dropCompletedMsg = dropCompletedMsg.replace('{0}', sourceObjectsJS.length);\n      dropCompletedMsg = dropCompletedMsg.replace('{1}', droppedOnObject);\n      messagingSvc.showInfo(dropCompletedMsg);\n    }\n  }, function (ex) {\n    logger.error('uploadFailures' + ex);\n  });\n};\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObjects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _pasteSourceObjects = function (targetElement, targetVMO, sourceObjects, callbackAPIs) {\n  /**\n   * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n   * type.\n   */\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (!validSourceTypes || validSourceTypes.length === 0) {\n    validSourceTypes = [];\n    let pasteHandler = DragAndDropService.instance.pasteHandler;\n    var sourceTypesObject = pasteHandler.getObjectValidSourceTypes(targetVMO);\n    var sourceTypes = Object.keys(sourceTypesObject);\n\n    if (sourceTypes) {\n      for (var counter = 0; counter < sourceTypes.length; counter++) {\n        var validSourceType = sourceTypes[counter];\n\n        if (cmm.containsType(validSourceType)) {\n          validSourceTypes.push(validSourceType);\n        }\n      }\n    }\n  }\n\n  var sourceType2RelationMap = _createSourceType2RelationsMap(validSourceTypes, targetElement);\n\n  var pasteRelation2SourceObjectsMap = {};\n\n  if (sourceObjects) {\n    for (var i = 0; i < sourceObjects.length; i++) {\n      var sourceObject = sourceObjects[i];\n      /**\n       * Get all the ancestor types for this 'source' type and see if one of them is valid.\n       */\n\n      var sourceType = sourceObject.type;\n      var sourceModelType = cmm.getType(sourceType);\n\n      if (sourceModelType) {\n        var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n        for (var j = 0; j < sourceTypeHeirarchy.length; j++) {\n          var sourceParentType = sourceTypeHeirarchy[j];\n          var relationType = sourceType2RelationMap[sourceParentType];\n\n          if (relationType) {\n            var sourceObjectsForType = pasteRelation2SourceObjectsMap[relationType];\n\n            if (!sourceObjectsForType) {\n              sourceObjectsForType = [];\n              pasteRelation2SourceObjectsMap[relationType] = sourceObjectsForType;\n            }\n\n            sourceObjectsForType.push(sourceObject);\n            break;\n          }\n        }\n      } else {\n        logger.warn('Unable to locate \\'source\\' type\\' (not loaded yet?): ' + sourceType);\n      }\n    }\n  }\n\n  _scheduleSelectTarget(targetElement, targetVMO, callbackAPIs);\n  /**\n   * Paste each unique 'relation' type.\n   */\n\n\n  var keys = Object.keys(pasteRelation2SourceObjectsMap);\n\n  if (keys && keys.length > 0) {\n    var pasteInput = [];\n\n    _.forEach(pasteRelation2SourceObjectsMap, function (value, key) {\n      var jso = {};\n      jso.targetObject = targetVMO;\n      jso.relationType = key;\n      jso.sourceObjects = value;\n      pasteInput.push(jso);\n    });\n\n    exports.publishDropEvent(pasteInput);\n  }\n};\n/**\n * Determine all the valid containers on the page . Check if the 'target'  is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event - DragEnter or DragOver event from global area\n * @return {Object} validHighlightableContainers - All valid applicable containers for highlighing\n */\n\n\nvar getApplicableContainersFromGlobalArea = function (event) {\n  var validHighlightableContainers = [];\n  var isValid = false;\n  var targetElements = document.body.querySelectorAll(DROP_CLASS);\n\n  if (targetElements) {\n    _.forEach(targetElements, function (targetElement) {\n      isValid = exports.isValidObjectToDrop(event, targetElement);\n\n      if (isValid) {\n        validHighlightableContainers.push(targetElement);\n      }\n    });\n  }\n\n  if (validHighlightableContainers.length === 0) {\n    if (_debug_logEventActivity >= 1) {\n      logger.info('No valid containers found on the entire page');\n    }\n  } else {\n    if (_debug_logEventActivity >= 1) {\n      logger.info(validHighlightableContainers.length + ' valid containers found , highlight in progress');\n    }\n  }\n\n  return validHighlightableContainers;\n};\n/**\n * Set the type of drag-and-drop operation currently selected or sets the operation to a new type. The value\n * must be 'none', 'copy', 'link' or 'move'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n * @param {String} value - The 'dropEffect' value to set .\n */\n\n\nvar _setDropEffect = function (event, value) {\n  event.dataTransfer.dropEffect = value;\n};\n/**\n * Once the last 'paste' is complete, select the 'target' object to show the results of the 'drop'. This should\n * cause the new 'sources' in that object.\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nvar _scheduleSelectTarget = function (targetElement, targetVMO, callbackAPIs) {\n  callbackAPIs.selectResultFn(targetElement, targetVMO);\n}; //* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n\n\nvar exports = {};\n/**\n * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n *\n * @param {DragEvent} event - The DragEvent to set the DragData on.\n * @param {Object} dragDataMap - Map of name/value pairs to add.\n */\n\nexport let addDragDataToDragEvent = function (event, dragDataMap) {\n  if (_includeDataTransfer) {\n    try {\n      _.forEach(dragDataMap, function (value, name) {\n        event.dataTransfer.setData(name, value);\n      });\n    } catch (ex) {\n      // Current versions of Internet Explorer can only have types \"Text\" and \"URL\"\n      _.forEach(dragDataMap, function (value, name) {\n        // Only deal with the interop error from IE, to address DnD issue D-24972\n        if (name === 'aw_interop_type') {\n          event.dataTransfer.setData('text', value);\n        }\n      });\n    }\n  }\n};\n/**\n * @return {StringArray} An array of strings (placed into localStorage' at the start of a drag operation) that\n *         represent the UIDs of 'source' objects being dragged (or NULL if no types were found).\n */\n\nexport let getCachedSourceUids = function () {\n  var dragDataJSON = localStrg.get('awDragData');\n\n  if (dragDataJSON && dragDataJSON !== 'undefined') {\n    var dragData = JSON.parse(dragDataJSON);\n\n    if (dragData.uidList) {\n      return dragData.uidList;\n    }\n  }\n\n  return null;\n};\n/**\n * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n * <P>\n * Note: There will be multiple things being dragged over. We should look at the type (Files, ModelObject,\n * Text). Do we have three handlers, or a smarter handler?\n * <P>\n * For a smarter handler, if this is a folder, it can take objects. This should only cause the drop indicator to\n * be shown for objects.\n *\n * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n *            test.\n * @param {Object} targetElement - targetElement when object is over an invalid area . When drag is over a valid area,  targetElement\n *            is evaluated from event\n * @returns {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n */\n\nexport let isValidObjectToDrop = function (event, targetElement) {\n  // eslint-disable-line complexity\n\n  /**\n   * Find the DOM Element (potentially above the 'target' event's origin) where all the DnD information is\n   * stored.\n   */\n  if (_.isUndefined(targetElement)) {\n    targetElement = _findDropTargetElement(event)[0];\n  }\n\n  if (!targetElement) {\n    return false;\n  }\n\n  if (targetElement.classList && targetElement.classList.contains('aw-widgets-chooseordropfile') && exports.dataTransferContainsFiles(event)) {\n    return true;\n  }\n  /**\n   * Check if we do NOT want to allow files from the OS to be dropped and the 'dataTransfer' contains at least\n   * one file.\n   */\n\n\n  if (!m_supportingFileDrop && exports.dataTransferContainsFiles(event)) {\n    return false;\n  }\n  /**\n   * Check if the 'target' does not have information we need to process or that there are no 'source' objects\n   * being dragged.\n   * <P>\n   * If so: No need to consider it as a valid drop (onto itself).\n   */\n\n\n  var targetUID = $(targetElement).data('dropuid');\n\n  if (!targetUID || targetUID.length === 0) {\n    return false;\n  }\n  /**\n   * Make sure we have cached 'source' information to work with.\n   */\n  //            var sourceContainerId = null;\n\n\n  var sourceUids = null;\n  var sourceTypes = null;\n\n  var sourceDragData = _getCachedDragData();\n\n  if (sourceDragData) {\n    //                sourceContainerId = sourceDragData.containerId;\n    sourceUids = sourceDragData.uidList;\n    sourceTypes = sourceDragData.typeList;\n  }\n  /**\n   * Check if the 'target' is actually in the list of 'source' objects being dragged.\n   * <P>\n   * If so: No need to consider it as a valid drop (onto itself).\n   */\n\n\n  if (sourceUids && sourceUids.length > 0 && _.indexOf(sourceUids, targetUID) !== -1) {\n    return false;\n  }\n  /**\n   * Get the types that are valid to drop on this 'target' and check if the current drag operation 'source'\n   * contains at least one of that type.\n   */\n\n\n  var validSourceTypes = _getValidSourceTypes(targetElement);\n\n  if (validSourceTypes && validSourceTypes.length > 0) {\n    /**\n     * Check if the only 'sources' are JS Files on the event.\n     * <P>\n     * If so: Build a list of 'source' types based on the file extensions.\n     * <P>\n     * If not: Use the IModelObject 'sources'\n     */\n    if ((!sourceTypes || sourceTypes.length === 0) && exports.dataTransferContainsFiles(event)) {\n      /**\n       * Get any file type information carried in the 'dataTransfer' property.\n       * <P>\n       * Check if there are NONE\n       * <P>\n       * If so: Then just assume the source is just one or more 'DataSet'.\n       */\n      var fileTypes = exports.getDataTransferFileTypes(event);\n\n      if (fileTypes && fileTypes.length === 0) {\n        fileTypes.push(TYPE_NAME_DATASET);\n      }\n      /**\n       * Create key used to track status and remember the result of the validity test.\n       */\n\n\n      var sb = targetUID;\n\n      for (var i = 0; i < validSourceTypes.length; i++) {\n        sb += ',';\n        sb += validSourceTypes[i];\n      }\n\n      if (fileTypes) {\n        for (var j = 0; j < fileTypes.length; j++) {\n          sb += ',';\n          sb += fileTypes[j];\n        }\n      }\n\n      var mapKey = sb;\n      /**\n       * Check if we already know the result from the last time we asked this question for the same\n       * 'source' types and 'target'.\n       */\n\n      var result = m_mapKey2Result[mapKey];\n\n      if (result) {\n        return result.value;\n      }\n\n      var promise = m_mapKey2Promise[mapKey];\n\n      if (!promise) {\n        m_mapKey2Promise[mapKey] = exports.getDataTransferSourceTypes(targetUID, fileTypes).then(function (result2) {\n          delete m_mapKey2Promise[mapKey];\n          m_mapKey2Result[mapKey] = {\n            value: result2 && result2.length > 0 && _isValidObjectToDropInternal(validSourceTypes, result2)\n          };\n        }, function () {\n          delete m_mapKey2Promise[mapKey];\n          m_mapKey2Result[mapKey] = {\n            value: false\n          };\n        });\n      }\n\n      return false;\n    }\n    /**\n     * Check if any of the valid 'source' types are NOT currently loaded.\n     * <P>\n     * Note: We need them loaded so we can walk their type hierarchy while looking for a match.\n     */\n\n\n    var missingSourceTypes = null;\n    var availableSourceTypes = null;\n\n    for (var ii = 0; ii < validSourceTypes.length; ii++) {\n      var validSourceType = validSourceTypes[ii];\n\n      if (!cmm.containsType(validSourceType)) {\n        if (!missingSourceTypes) {\n          missingSourceTypes = [];\n        }\n\n        missingSourceTypes.push(validSourceType);\n      } else {\n        if (!availableSourceTypes) {\n          availableSourceTypes = [];\n        }\n\n        availableSourceTypes.push(validSourceType);\n      }\n    }\n    /**\n     * Check if any 'source' types are missing (not loaded yet).\n     * <P>\n     * If available 'source' types is null and missing 'source' types is not null, Then: Return 'false' for\n     * this drop but queue up a server request to get the type so that during further (future) dragging will\n     * see the type as loaded.\n     */\n\n\n    if (!availableSourceTypes && missingSourceTypes) {\n      var sb2 = targetUID;\n\n      for (var jj = 0; jj < missingSourceTypes.length; jj++) {\n        if (jj > 0) {\n          sb2 += ',';\n        }\n\n        sb2 += missingSourceTypes[jj];\n      }\n\n      var key = sb2;\n\n      if (!m_typeLookupInProgress[key]) {\n        m_typeLookupInProgress[key] = key;\n        soaSvc.ensureModelTypesLoaded(missingSourceTypes).then(function () {\n          /**\n           * Nothing to do now other than removing the lookup placeholder. We just wanted to make sure\n           * the type is loaded for the NEXT time we look for it.\n           */\n          delete m_typeLookupInProgress[key];\n        }, function (err) {\n          logger.error('Unable to get model types: ' + err);\n        });\n      }\n\n      return false;\n    }\n\n    return _isValidObjectToDropInternal(availableSourceTypes, sourceTypes);\n  }\n\n  return false;\n};\n/**\n * Get map of data format to drag data based on the given 'source' IModelObjects.\n *\n * @param {ViewModelObjectArray} sourceVMOs - The 'source' ViewModelObjects being dragged.\n * @param {String} containerId - The ID of the UI 'container' of the 'source' objects.\n *\n */\n\nexport let processAWInteropAndHosting = function (sourceVMOs, containerId) {\n  /**\n   * Create collections of data associated with the 'source' objects.\n   */\n  var uidList = [];\n  var typeSet = {};\n  var interopObjectRefs = [];\n  var firstObjectUrl = '';\n  var first = true;\n  modelsHaveTypes = false;\n  sourceVMOs.forEach(modelObject => {\n    if (modelObject.type) {\n      modelsHaveTypes = true;\n    }\n\n    if (cmm.isInstanceOf('Awp0XRTObjectSetRow', modelObject.modelType)) {\n      var adaptedObjs = adapterSvc.getAdaptedObjectsSync([modelObject]);\n      modelObject = adaptedObjs[0];\n    }\n    /**\n     * Grab the first uid from the list for the url and the type\n     */\n\n\n    if (first) {\n      first = false;\n      firstObjectUrl = _getShowObjectURL(modelObject.uid);\n    }\n    /**\n     * Add the UID and type of this object into the collections\n     */\n\n\n    if (modelObject.uid) {\n      uidList.push(modelObject.uid);\n    }\n\n    typeSet[modelObject.type] = modelObject.type;\n\n    if (_createInteropObjectRefFn) {\n      /**\n       * Generate a hosting InteropObjectRef to be used by host applications (i.e. NX) for\n       * interpreting this 'source' object.\n       */\n      var objRefArrayList = _createInteropObjectRefFn(modelObject);\n\n      _.forEach(objRefArrayList, function (objRef) {\n        interopObjectRefs.push(objRef);\n      });\n    } else {\n      if (_debug_logEventActivity) {\n        logger.warn('Unable to determine InteropObjectRef information due to missing callback function');\n      }\n    }\n  });\n  var dragData = {\n    'text/uri-list': firstObjectUrl,\n    'text/plain': firstObjectUrl\n  };\n  /**\n   * Include application interop references (if necessary)\n   */\n\n  if (interopObjectRefs && interopObjectRefs.length > 0 && _includeDataTransfer) {\n    /**\n     * Create the JSON message for interop with host applications.\n     */\n    var dragDataInterop = {\n      DragTargets: interopObjectRefs\n    };\n    var jsonString = JSON.stringify(dragDataInterop);\n    /**\n     * Add data for each data format\n     * <P>\n     * Note: Need multiple data formats right now to handle compatibility with different browsers.\n     */\n\n    for (var j = 0; j < DATA_FORMATS.length; j++) {\n      dragData[DATA_FORMATS[j]] = jsonString;\n    }\n  }\n\n  dragData['text/uri-list'] = firstObjectUrl;\n  dragData['text/plain'] = firstObjectUrl;\n  /**\n   * Put the other formats onto the dataTransport\n   * <P>\n   * Note: We need the UIDs and types in the 'keys' (for checking while dragging since the values are not\n   * available at that time) and the 'values' to be able to access the data without it being changed to lower\n   * case by the browser itself.\n   */\n\n  var dragDataJSO = {};\n  dragDataJSO.containerId = containerId;\n  dragDataJSO.uidList = uidList;\n  dragDataJSO.firstObjectUrl = firstObjectUrl;\n  dragDataJSO.typeList = [];\n\n  _.forEach(typeSet, function (type) {\n    dragDataJSO.typeList.push(type);\n  });\n\n  localStrg.publish('awDragData', JSON.stringify(dragDataJSO));\n  addDragDataToDragEvent(event, dragData);\n};\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n */\n\nexport let processDragEnd = function (event) {\n  // eslint-disable-line no-unused-vars\n  _clearCachedData();\n};\n/**\n * Remove Highlight from the drop area with CSS class(s) and prevent the 'default' behavior (which we assume to\n * be 'do not allow drop' for objects or 'load file into page' for files).\n *\n * @param {DragEvent} event -\n */\n\nexport let processDragLeave = function (event) {\n  event.preventDefault();\n};\n/**\n * Remove Highlight when object drag is skipped or object dragged outside white/invalid area\n *\n * @param {DragEvent} event -\n */\n\nexport let processDragLeaveGlobal = function (event) {\n  if (_.isUndefined(mainReference)) {\n    mainReference = document.body;\n  }\n\n  var allHighlightedTargets = mainReference.querySelectorAll('.aw-theme-dropframe.aw-widgets-dropframe');\n\n  if (allHighlightedTargets) {\n    isGlobalHighlightPublished = false;\n\n    _.forEach(allHighlightedTargets, function (target) {\n      eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: true,\n        isHighlightFlag: false,\n        targetElement: target\n      });\n    });\n  }\n};\n/**\n * Determine if the DragEvent is over a 'target' that is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\n\nvar _processDragOverInternal = function (event, isCurrentTargetOverGlobalArea) {\n  exports.processDragLeaveGlobal(event); // clearing all other highlights triggered due to file drag in global area\n\n  if (isCurrentTargetOverGlobalArea) {\n    if (exports.dataTransferContainsURLs(event)) {\n      _setDropEffect(event, 'copy');\n    } else {\n      _setDropEffect(event, 'none');\n\n      event.stopPropagation();\n      event.preventDefault();\n      var allHighlightableTargets = getApplicableContainersFromGlobalArea(event);\n\n      if (allHighlightableTargets) {\n        _.forEach(allHighlightableTargets, function (targetElement) {\n          eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n            event: event,\n            isGlobalArea: true,\n            isHighlightFlag: true,\n            targetElement: targetElement\n          });\n        });\n      }\n    }\n  } else {\n    if (exports.isValidObjectToDrop(event)) {\n      eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: false,\n        isHighlightFlag: true,\n        targetElement: _findDropTargetElement(event)[0]\n      });\n\n      _setDropEffect(event, 'copy'); // when dragged object is on a valid container, the dragged effect should be \\'Copy\\'\n\n\n      event.stopPropagation();\n      event.preventDefault();\n    } else {\n      // this ensures if the drop target is an applicable one however not a valid one , all the highlights are gone and a no drop cursor is shown\n      _setDropEffect(event, 'none');\n\n      event.dataTransfer.effectAllowed = 'none';\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n};\n/**\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\n\nexport let processDrop = function (event, callbackAPIs) {\n  event.stopPropagation();\n  event.preventDefault();\n\n  var targetElement = _findDropTargetElement(event)[0];\n\n  if (!targetElement) {\n    _clearCachedData();\n\n    return;\n  }\n\n  eventBus.publish(DRAG_DROP_HIGHLIGHT_EVENT, {\n    event: event,\n    isGlobalArea: false,\n    isHighlightFlag: false,\n    targetElement: targetElement\n  });\n  var sourceUids = exports.getCachedSourceUids();\n\n  if (sourceUids && sourceUids.length > 0) {\n    _dropModelObjects(targetElement, sourceUids, callbackAPIs);\n  } else {\n    var sourceFiles = _getDataTransferSourceFiles(event);\n\n    if (sourceFiles && sourceFiles.length > 0 && sourceFiles.item(0).size > 0) {\n      _dropFiles(targetElement, sourceFiles, callbackAPIs);\n    } else {\n      var dropFolderFailureDocument = localeService.getLoadedTextFromKey('dragAndDropMessages.dropFolderFailureDocument');\n      dropFolderFailureDocument = dropFolderFailureDocument.replace('{0}', sourceFiles.item(0).name);\n      messagingSvc.showError(dropFolderFailureDocument);\n\n      _clearCachedData();\n    }\n  }\n};\n/**\n * Set the current types of operations that are possible. Must be one of 'none', 'copy', 'copyLink', 'copyMove',\n * 'link', 'linkMove', 'move', 'all' or 'uninitialized'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n *\n * @param {String} value - The 'effectAllowed' allowed value to set.\n */\n\nexport let setEffectAllowed = function (event, value) {\n  try {\n    event.dataTransfer.effectAllowed = value;\n  } catch (ex) {// Do nothing\n  }\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various reasons of interaction with the\n *            container/frame:\n *\n * @param {Object} dataProvider - DataProvider for the panelElement\n * <P>\n * getElementViewModelObjectFn: Used to query the 'source' or 'target' ViewModelObject(s) under any given\n * DragEvent.\n * <P>\n * clearSelectionFn: Used to clear all currently selected 'source' objects just before the drop operation is\n * performed.\n * <P>\n * selectResultFn: Used to select the 'target' when the drop operation is complete.\n */\n\nexport let setupDragAndDrop = function (panelElement, callbackAPIs, dataProvider) {\n  // Init class here\n  DragAndDropService.instance;\n  var jqPanelElement = $(panelElement);\n  var showDropAreaAttr = jqPanelElement.attr('show-drop-area');\n  /**\n   * Set valid source types to the target drop element by retrieving from objectSetSource in data provider\n   */\n\n  var dropContainer = jqPanelElement.hasClass('aw-widgets-droppable') && !showDropAreaAttr ? jqPanelElement : jqPanelElement.find(DROP_CLASS);\n\n  if (dropContainer) {\n    var dropContScope = null; //ngModule.element( dropContainer ).scope();\n\n    if (dropContScope) {\n      var sourceType2RelationMap = {};\n      var declViewModel = declUtils.findViewModel(dropContScope, false, null); // ui-grid uses scope.dataprovider and plTable uses scope.dataProvider\n\n      var dropTableDataProvider = dataProvider || dropContScope.dataprovider || dropContScope.dataProvider;\n\n      if (dropTableDataProvider && dropTableDataProvider.validSourceTypes) {\n        var objectSetSources = dropTableDataProvider.validSourceTypes.split(',');\n\n        _.forEach(objectSetSources, function (source) {\n          var relationSources = source.split('.');\n          var sourceType = relationSources[1];\n\n          if (!sourceType2RelationMap[sourceType]) {\n            sourceType2RelationMap[sourceType] = [];\n            var relationObj = {\n              relation: relationSources[0]\n            };\n            sourceType2RelationMap[sourceType] = relationObj;\n          }\n        });\n      } else if (declViewModel && declViewModel.vmo) {\n        // fetch valid source types from paste service for vmo inside decl view model\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n\n        if (pasteHandler) {\n          sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes(declViewModel.vmo);\n        } else if (_cfgLoadPromise) {\n          _cfgLoadPromise.then(function () {\n            pasteHandler = DragAndDropService.instance.pasteHandler;\n            sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes(declViewModel.vmo);\n            dropContainer.data('validSourceTypes', sourceType2RelationMap);\n          });\n        }\n      }\n\n      dropContainer.data('validSourceTypes', sourceType2RelationMap);\n\n      if (declViewModel && declViewModel.vmo) {\n        // add the decl view model VMO as drop uid on the container\n        dropContainer.data('dropuid', declViewModel.vmo.uid);\n      }\n    }\n  }\n\n  callbackAPIs.dragStartFn = function (event) {\n    if (event) {\n      /**\n       * Determine some hosting related options at the start.\n       */\n      _includeDataTransfer = appCtxSvc.ctx.aw_host_type !== 'ADOBE';\n      _publishHostingEvents = appCtxSvc.ctx.aw_hosting_enabled; // D-52947: Prevent issues when text is highlighted as drag starts. Event.target may be text.\n\n      if (event.target.nodeName === '#text') {\n        jqPanelElement.data('dragging', false);\n        event.preventDefault();\n      } else {\n        if (_debug_logEventActivity >= 2) {\n          logger.info('dragstart: ' + '\\n' + JSON.stringify(event, null, 2));\n        }\n\n        if (_publishHostingEvents) {\n          eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n            type: 'dragstart',\n            event: event\n          });\n        }\n\n        var srcElement = _getEventSource(event);\n\n        var sourceVMOs = callbackAPIs.getElementViewModelObjectFn(srcElement, false);\n\n        if (sourceVMOs && sourceVMOs.length > 0) {\n          if (_debug_logEventActivity >= 1) {\n            logger.info('Source Item UID: ' + _getViewModelObjectName(sourceVMOs[0]));\n          }\n\n          $(panelElement).data('dragging', true);\n          var containerId = jqPanelElement.data('containerId');\n\n          if (!containerId) {\n            containerId = Date.now();\n            jqPanelElement.data('containerId', containerId);\n          }\n\n          exports.processAWInteropAndHosting(sourceVMOs, containerId.toString());\n          exports.updateDragImage(event, sourceVMOs.length);\n\n          if (!_includeDataTransfer) {\n            event.dataTransfer.clearData();\n          }\n        } else {\n          // No data so there is no reason to let the object be dragged.\n          jqPanelElement.data('dragging', false);\n          event.preventDefault();\n        }\n      }\n    }\n  };\n\n  callbackAPIs.dragEndFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragend: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      var element = _getDragElement(event);\n\n      if (element) {\n        var dragImage = element.getElementsByClassName('aw-widgets-multidragimage')[0];\n\n        if (dragImage) {\n          element.style.position = '';\n          dragImage.parentNode.removeChild(dragImage);\n        }\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragend',\n          event: event\n        });\n      }\n\n      jqPanelElement.data('dragging', false);\n    }\n  };\n\n  callbackAPIs.dragOverFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 3) {\n        logger.info('dragover: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragover',\n          event: event\n        });\n      }\n\n      event.stopPropagation();\n      exports.processDragOver(event, false);\n    }\n  };\n\n  callbackAPIs.dragEnterFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragenter: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragenter',\n          event: event\n        });\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      var target = _findDropTargetElement(event)[0];\n\n      if (!target) {\n        return;\n      }\n\n      if (exports.isValidObjectToDrop(event)) {\n        var targetVMOs = callbackAPIs.getElementViewModelObjectFn(target, true);\n\n        if (targetVMOs && targetVMOs.length > 0) {\n          if (_debug_logEventActivity >= 1) {\n            logger.info('Target Item Name: ' + _getViewModelObjectName(targetVMOs[0]));\n          }\n\n          var debounceProcessDragEnter = _.debounce(exports.processDragEnter, 100);\n\n          debounceProcessDragEnter(event, targetVMOs[0]);\n        }\n      }\n    }\n  };\n\n  callbackAPIs.dragLeaveFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('dragleave: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'dragleave',\n          event: event\n        });\n      }\n\n      var debounceProcessDragLeave = _.debounce(exports.processDragLeave, 100);\n\n      debounceProcessDragLeave(event);\n    }\n  };\n\n  callbackAPIs.dropFn = function (event) {\n    if (event) {\n      if (_debug_logEventActivity >= 2) {\n        logger.info('drop: ' + '\\n' + JSON.stringify(event, null, 2));\n      }\n\n      if (_publishHostingEvents) {\n        eventBus.publish(HOSTING_DRAG_DROP_EVENT, {\n          type: 'drop',\n          event: event\n        });\n      }\n\n      jqPanelElement.data('dragging', false);\n      exports.processDrop(event, callbackAPIs);\n    }\n  };\n\n  panelElement.addEventListener('dragstart', callbackAPIs.dragStartFn);\n  panelElement.addEventListener('dragend', callbackAPIs.dragEndFn);\n  panelElement.addEventListener('dragover', callbackAPIs.dragOverFn);\n  panelElement.addEventListener('dragenter', callbackAPIs.dragEnterFn);\n  panelElement.addEventListener('dragleave', callbackAPIs.dragLeaveFn);\n  panelElement.addEventListener('drop', callbackAPIs.dropFn);\n};\nexport let dragLeaveEventOnGlobalWindow = function (event) {\n  processDragLeaveGlobal(event);\n\n  if (exports.dataTransferContainsFiles(event)) {\n    //\n    _clearCachedData();\n  }\n};\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {ViewModelObject} targetVMO - The ViewModelObject associated with the given event's 'target' DOM\n *            Element.\n */\n\nexport let processDragEnter = function (event, targetVMO) {\n  /**\n   * Look 'up' the DOM Element tree (starting at the given event's 'target') looking for the 1st 'droppable'\n   * element (i.e. the 'drop container').\n   */\n  var currElement = _findDropTargetElement(event)[0];\n\n  _setValidSourceTypesOnTarget(currElement, targetVMO);\n\n  event.preventDefault();\n};\nexport let dragEndEventOnGlobalWindow = function (event) {\n  processDragLeaveGlobal(event);\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\n\nexport let tearDownDragAndDrop = function (panelElement, callbackAPIs) {\n  if (callbackAPIs.dragStartFn) {\n    panelElement.removeEventListener('dragstart', callbackAPIs.dragStartFn);\n    panelElement.removeEventListener('dragend', callbackAPIs.dragEndFn);\n    panelElement.removeEventListener('dragover', callbackAPIs.dragOverFn);\n    panelElement.removeEventListener('dragenter', callbackAPIs.dragEnterFn);\n    panelElement.removeEventListener('dragleave', callbackAPIs.dragLeaveFn);\n    panelElement.removeEventListener('drop', callbackAPIs.dropFn);\n    callbackAPIs.dragStartFn = null;\n    callbackAPIs.dragEndFn = null;\n    callbackAPIs.dragOverFn = null;\n    callbackAPIs.dragEnterFn = null;\n    callbackAPIs.dragLeaveFn = null;\n    callbackAPIs.dropFn = null;\n  }\n};\n/**\n * Update the drag image for the DragEvent based on the number of objects being dragged.\n *\n * @param {DragEvent} event - The DragEvent to set the image on.\n *\n * @param {Number} count - The number of objects being dragged\n */\n\nexport let updateDragImage = function (event, count) {\n  /**\n   * Internet Explorer doesn't support setDragImage at all (and some 'hosts' do not want 'dataTransfer').\n   * <P>\n   * See: http://mereskin.github.io/dnd/\n   */\n  if (!browserUtils.isIE && _includeDataTransfer) {\n    /**\n     * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n     * should be resolved after moving the list view to a flex display.\n     */\n    var dragImage;\n\n    if (_isNxWebBrowser()) {\n      dragImage = _getFirstChildImage(event.target);\n    } else if (count > 1) {\n      dragImage = _getMultiDragImage(event, count);\n    } else {\n      dragImage = _getDragElement(event, 1);\n    }\n\n    if (dragImage) {\n      event.dataTransfer.setDragImage(dragImage, 0, 0);\n    }\n  }\n};\n/**\n * Return the target model object for given UID\n *\n * @param {String} uid - UID of the modelObject on which source objects are dragged\n * @return {Object} Modelobject on which source objects are dragged\n */\n\nexport let getTargetObjectByUid = function (uid) {\n  return cdm.getObject(uid);\n};\n/**\n * Return an array of viewModelObjects that contains all currently selected viewModelObjects if the given UID is\n * contained in the set of selected viewModelObjects.\n *\n * @param {Object} dataProvider - data provider\n * @param {String} dragUID - UID of the modelObject being dragged.\n * @return {Array} array of viewModelObjects that are being dragged.\n */\n\nexport let getSourceObjects = function (dataProvider, dragUID) {\n  var sourceObjs = [];\n\n  if (!dataProvider) {\n    return sourceObjs;\n  }\n\n  var selectObjects = dataProvider.getSelectedObjects();\n  /**\n   * Check if the given UID is in the current set of selected objects.\n   */\n\n  var found = false;\n\n  if (selectObjects && selectObjects.length > 0) {\n    // eslint-disable-next-line consistent-return\n    _.forEach(selectObjects, function (selObj) {\n      if (selObj.uid === dragUID) {\n        found = true;\n        return false;\n      }\n    });\n  }\n\n  if (found) {\n    sourceObjs = _.clone(selectObjects);\n  }\n\n  return sourceObjs;\n};\n/**\n * Look for support of the 'files' in the 'dataTranfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'files' property is found in the 'dataTransfer' property of the event.\n */\n\nexport let dataTransferContainsFiles = function (event) {\n  if (event.dataTransfer) {\n    var types = event.dataTransfer.types;\n\n    if (types) {\n      for (var i = 0; i < types.length; ++i) {\n        if (types[i] === 'Files') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Look for support of the 'urls' in the 'dataTransfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'text/html' property is found in the 'dataTransfer' property of the event.\n */\n\nexport let dataTransferContainsURLs = function (event) {\n  if (event.dataTransfer) {\n    var types = event.dataTransfer.types;\n\n    if (types) {\n      for (var i = 0; i < types.length; ++i) {\n        if (types[i] === 'text/html') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * @param {DragEvent} event - The event to extract the files types from the 'dataTransfer' property.\n *\n * @return {StringArray} The set of unique file types.\n */\n\nexport let getDataTransferFileTypes = function (event) {\n  var dtTypes = [];\n\n  if (event.dataTransfer.items) {\n    var itemObjs = event.dataTransfer.items;\n\n    if (itemObjs) {\n      for (var i = 0; i < itemObjs.length; i++) {\n        var fileExt = _getDataTransferType(itemObjs[i].type);\n\n        if (fileExt && dtTypes.indexOf(fileExt) === -1) {\n          dtTypes.push(fileExt);\n        }\n      }\n    }\n  }\n\n  return dtTypes;\n};\n/**\n * Returns underlying Object for the given 'source' type.\n *\n * @param {String} targetUID - The UID of the IModelObject that will be the dropped onto (i.e. the data\n *            'target').\n *\n * @param {StringArray} fileTypes - The array with the set of unique file types.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\n\nexport let getDataTransferSourceTypes = function (targetUID, fileTypes) {\n  var targetObject = cdm.getObject(targetUID);\n  var request = {\n    parent: targetObject,\n    fileExtensions: fileTypes\n  };\n  return soaSvc.postUnchecked('Internal-AWS2-2015-10-DataManagement', 'getDatasetTypesWithDefaultRelation', request).then(function (response) {\n    if (response.partialErrors || response.PartialErrors || response.ServiceData && response.ServiceData.partialErrors) {\n      return [];\n    }\n\n    var dsTypes = [];\n    var output = response.output;\n\n    if (output) {\n      for (var i = 0; i < output.length; i++) {\n        var dsInfos = output[i].datasetTypesWithDefaultRelInfo;\n\n        if (dsInfos) {\n          const j = 0;\n          var dsInfo = dsInfos[j];\n          var dsUid = dsInfo.datasetType.uid;\n          var dsType = cdm.getObject(dsUid);\n          var type = dsType.props.object_string.dbValues[0];\n          dsTypes.push(type);\n        }\n      }\n    }\n\n    return soaSvc.ensureModelTypesLoaded(dsTypes).then(function () {\n      return dsTypes;\n    });\n  }, function (e) {\n    logger.trace(e);\n    return [];\n  });\n};\n/**\n * Set a callback function to use to encode 'source' objects in support of hosting.\n *\n * @param {Function} callBackFn - Function used to create InteropObjectRefs that are added to the information\n *            carried for 'source' objects in dragEvents.\n */\n\nexport let setCreateInteropObjectRef = function (callBackFn) {\n  _createInteropObjectRefFn = callBackFn;\n};\n/**\n * Publish a 'drop' topic on the 'paste' channel of the Native JS 'eventBus' with the given data.\n *\n * @param {ObjectArray} pasteInput - An array of objects that maps a unique 'relationType' to the array of\n *            'sourceObjects' {@link IModelObject} s that should be pasted onto the 'targetObject' with that\n *            'relationType'.\n */\n\nexport let publishDropEvent = function (pasteInput) {\n  eventBus.publishOnChannel({\n    channel: 'paste',\n    topic: 'drop',\n    data: {\n      pasteInput: pasteInput\n    }\n  });\n};\n\nconst _globalDragEnterAndOver = event => {\n  exports.processDragOver(event, true);\n};\n\nexport let registerEvents = function () {\n  // LCS-148724 , Adding listeners to global area i.e the area outside panelElement of setupDragAndDrop() function\n  document.body.addEventListener('dragenter', function (event) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (!_isDragWithinApplicableValidContainer(event) || _isDragOverChooseOrDropFileContainer(event)) {\n      // below check is to avoid global dragenter events in turn flickering highlight when within a table or list\n      if (!_isDragWithinTableContainer(event) && !_isDragWithinCellListContainer(event)) {\n        if (_debug_logEventActivity >= 1) {\n          logger.info('GLOBAL DRAG ENTER EVENT, DRAG NOT WITHIN A TABLE, NOT ALLOWED cursor should be shown => tag name :' + event.target.tagName);\n        }\n\n        _setDropEffect(event, 'none'); // to avoid 'Copy' cursor feedback when file just enters the page\n\n\n        _globalDragEnterAndOver(event);\n      } else {\n        if (_debug_logEventActivity >= 1) {\n          logger.info('GLOBAL DRAG ENTER EVENT, DRAG WITHIN A TABLE, COPY cursor should be shown => tag name :' + event.target.tagName);\n        }\n\n        _setDropEffect(event, 'copy');\n      }\n    }\n  });\n  document.body.addEventListener('dragover', function (event) {\n    if (!_isDragWithinApplicableValidContainer(event) || _isDragOverChooseOrDropFileContainer(event)) {\n      if (_debug_logEventActivity >= 1) {\n        logger.info('GLOBAL DRAG OVER EVENT ');\n      }\n\n      _globalDragEnterAndOver(event);\n    }\n  });\n  document.body.addEventListener('dragleave', function (event) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (_debug_logEventActivity >= 1) {\n      logger.info('GLOBAL DRAG LEAVE EVENT, Object either dragged outside the global window OR over an applicable valid container on the page OR over an applicable invalid container on the page');\n    }\n\n    if (_isDragCancelled(event)) {\n      isGlobalHighlightPublished = false;\n      exports.dragLeaveEventOnGlobalWindow(event);\n    }\n  });\n  document.body.addEventListener('dragend', function (event) {\n    if (_debug_logEventActivity >= 1) {\n      logger.info('GLOBAL DRAG END EVENT ');\n    }\n\n    isGlobalHighlightPublished = false;\n    exports.dragEndEventOnGlobalWindow(event);\n  });\n};\nexport const disableDragAndDrop = panelElement => {\n  const stopEventBubbling = event => {\n    event.stopPropagation();\n  };\n\n  const setDropEffectNone = event => {\n    stopEventBubbling(event);\n    event.dataTransfer.dropEffect = 'none';\n  };\n\n  panelElement.addEventListener('dragover', setDropEffectNone);\n  panelElement.addEventListener('dragenter', stopEventBubbling);\n  panelElement.addEventListener('dragleave', stopEventBubbling);\n  panelElement.addEventListener('drop', stopEventBubbling);\n};\nexports = {\n  disableDragAndDrop,\n  addDragDataToDragEvent,\n  getCachedSourceUids,\n  isValidObjectToDrop,\n  processAWInteropAndHosting,\n  processDragEnd,\n  processDragLeave,\n  processDragLeaveGlobal,\n  processDrop,\n  setEffectAllowed,\n  setupDragAndDrop,\n  dragLeaveEventOnGlobalWindow,\n  dragEndEventOnGlobalWindow,\n  tearDownDragAndDrop,\n  updateDragImage,\n  getTargetObjectByUid,\n  getSourceObjects,\n  dataTransferContainsFiles,\n  dataTransferContainsURLs,\n  getDataTransferFileTypes,\n  getDataTransferSourceTypes,\n  setCreateInteropObjectRef,\n  publishDropEvent,\n  registerEvents,\n  processDragOver,\n  processDragEnter\n};\nexport default exports;\n/*\n * Register the global drag and drop events only for AW.\n */\n\nif (appCtxSvc.ctx && appCtxSvc.ctx.tcSessionData) {//registerEvents();\n}","map":{"version":3,"names":["cdm","cmm","dms","soaSvc","cfgSvc","messagingSvc","localeService","appCtxSvc","adapterSvc","$","_","eventBus","browserUtils","declUtils","localStrg","logger","dragAndDropUtils","AwBaseService","AwStateService","pasteService","AwPromiseService","htmlUtils","DragAndDropService","reset","_defaultPasteHandler","_pasteFileHandler","constructor","_cfgLoadPromise","getCfg","then","pasteProvider","defaultPasteHandler","loadDependentModule","dep","defaultPasteFileHandler","pasteHandler","pasteFileHandler","DATA_FORMATS","TYPE_NAME_DATASET","modelsHaveTypes","mainReference","_includeDataTransfer","_publishHostingEvents","_createInteropObjectRefFn","_debug_logEventActivity","HOSTING_DRAG_DROP_EVENT","UI_GRID_ROW_CLASS","DROP_CLASS","DRAG_DROP_HIGHLIGHT_EVENT","urlAttributes","getUrlAttributes","logDnDEventActivity","undefined","m_debug_LogRejectedSourceType","m_mapKey2Promise","m_mapKey2Result","m_supportingFileDrop","m_typeLookupInProgress","isGlobalHighlightPublished","_clearCachedData","publish","_createSourceType2RelationsMap","validSourceTypes","targetElement","sourceType2RelationsMap","validSourceObjects","data","i","length","sourceType","validSourceObj","relations","relation","push","_deselectAll","targetVMO","callbackAPIs","clearSelectionFn","getAdaptedObjects","vmos","getObjects","_deselectAllAndPasteSourceFiles","sourceFiles","_pasteSourceFiles","_deselectAllAndPasteSourceObjects","sourceObjects","_pasteSourceObjects","_dropFiles","targetVMOs","getElementViewModelObjectFn","targetUID","exports","getTargetObjectByUid","isInstanceOf","modelType","adaptedObjs","_dropModelObjects","sourceUIDs","_dropModelObjectsInternal","missingSourceUIDs","sourceObject","getObject","loadObjects","j","_findContainerId","testElement","currElement","containerId","toString","parentElement","_isDragCancelled","event","_isDragCancelFlag","x","y","screenX","screenY","_isDragWithinCellListContainer","isCellListContainerFlag","cellListContainer","closestElement","target","isUndefined","_isDragWithinTableContainer","isTableFlag","tableContainer","classList","contains","_isDragWithinApplicableValidContainer","bool","jqTarget","jqContainer","closest","children","isValidObjectToDrop","_isDragOverChooseOrDropFileContainer","cfContainer","processDragOver","isCurrentTargetOverGlobalArea","chooseFileContainer","addEventListener","info","processDragLeaveGlobal","dataTransferContainsFiles","_setDropEffect","stopPropagation","isGlobalArea","isHighlightFlag","preventDefault","getCachedSourceUids","loadVMOsIfNotAlreadyLoaded","_processDragOverInternal","_findDropTargetElement","targetElements","get","forEach","_setValidSourceTypesOnTarget","jqElement","instance","getObjectValidSourceTypes","uid","_getCachedDragData","dragDataJSON","JSON","parse","_getDataTransferType","dataTransferItem","extensionIndex","lastIndexOf","substring","_getDataTransferSourceFiles","dataTransfer","files","_getEventSource","srcElement","_getFirstChildImage","sourceElement","image","find","_getShowObjectURL","window","decodeURIComponent","document","location","origin","pathname","href","_getDragElement","count","element","_getMultiDragImage","targetImage","strWidth","strHeight","cloneImage","cloneNode","style","position","offsetWidth","offsetHeight","removeChild","cloneImageText","getElementsByClassName","parentNode","id","maxWidth","minWidth","maxHeight","minHeight","left","top","zIndex","add","appendChild","cloneImage2","cloneImage3","_getValidSourceTypes","Object","keys","_getViewModelObjectName","vmo","props","object_string","displayValues","items_tag","object_name","object_desc","job_name","awp0CellProperties","_isNxWebBrowser","navigator","userAgent","indexOf","_isValidObjectToDropInternal","sourceTypes","sourceTypeFound","validSourceType","sourceModelType","getType","sourceTypeHeirarchy","typeHierarchyArray","k","warn","_pasteFiles","pasteInput","pasteFilesWithHandler","response","isOsFiles","pasteFilesInput","deferred","defer","input","targetObject","relationType","execute","isDragDropIntent","res","eventData","relatedModified","refreshLocationFlag","createdObjects","resolve","err","reject","promise","sourceTypesObject","counter","containsType","sourceType2RelationMap","pasteRelation2SourceObjectsMap","currSourceType","sourceObjectsForType","_scheduleSelectTarget","value","key","curr","startTime","Date","now","result","stopTime","pasteInputJS","sourceObjectsJS","durationMs","durationSec","duration","localTextBundle","dropCompletedDocument","getLoadedTextFromKey","dropCompleted","droppedOnObject","cellHeader1","uiValues","docCreated","dropCompletedDocumentMsg","replace","docName","showInfo","dropCompletedMsg","ex","error","type","sourceParentType","jso","publishDropEvent","getApplicableContainersFromGlobalArea","validHighlightableContainers","isValid","body","querySelectorAll","dropEffect","selectResultFn","addDragDataToDragEvent","dragDataMap","name","setData","dragData","uidList","sourceUids","sourceDragData","typeList","fileTypes","getDataTransferFileTypes","sb","mapKey","getDataTransferSourceTypes","result2","missingSourceTypes","availableSourceTypes","ii","sb2","jj","ensureModelTypesLoaded","processAWInteropAndHosting","sourceVMOs","typeSet","interopObjectRefs","firstObjectUrl","first","modelObject","getAdaptedObjectsSync","objRefArrayList","objRef","dragDataInterop","DragTargets","jsonString","stringify","dragDataJSO","processDragEnd","processDragLeave","allHighlightedTargets","dataTransferContainsURLs","allHighlightableTargets","effectAllowed","processDrop","item","size","dropFolderFailureDocument","showError","setEffectAllowed","setupDragAndDrop","panelElement","dataProvider","jqPanelElement","showDropAreaAttr","attr","dropContainer","hasClass","dropContScope","declViewModel","findViewModel","dropTableDataProvider","dataprovider","objectSetSources","split","source","relationSources","relationObj","dragStartFn","ctx","aw_host_type","aw_hosting_enabled","nodeName","updateDragImage","clearData","dragEndFn","dragImage","dragOverFn","dragEnterFn","debounceProcessDragEnter","debounce","processDragEnter","dragLeaveFn","debounceProcessDragLeave","dropFn","dragLeaveEventOnGlobalWindow","dragEndEventOnGlobalWindow","tearDownDragAndDrop","removeEventListener","isIE","setDragImage","getSourceObjects","dragUID","sourceObjs","selectObjects","getSelectedObjects","found","selObj","clone","types","dtTypes","items","itemObjs","fileExt","request","parent","fileExtensions","postUnchecked","partialErrors","PartialErrors","ServiceData","dsTypes","output","dsInfos","datasetTypesWithDefaultRelInfo","dsInfo","dsUid","datasetType","dsType","dbValues","e","trace","setCreateInteropObjectRef","callBackFn","publishOnChannel","channel","topic","_globalDragEnterAndOver","registerEvents","tagName","disableDragAndDrop","stopEventBubbling","setDropEffectNone","tcSessionData"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/uiwidget/src/js/dragAndDropService.js"],"sourcesContent":["/* eslint-disable max-lines */\n// Copyright (c) 2020 Siemens\n\n/**\n * This service manages the 'source' object information placed into 'localStorage' during drag-n-drop operations.\n *\n * @module js/dragAndDropService\n */\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport dms from 'soa/dataManagementService';\nimport soaSvc from 'soa/kernel/soaService';\nimport cfgSvc from 'js/configurationService';\nimport messagingSvc from 'js/messagingService';\nimport localeService from 'js/localeService';\nimport appCtxSvc from 'js/appCtxService';\nimport adapterSvc from 'js/adapterService';\nimport $ from 'jquery';\nimport _ from 'lodash';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport declUtils from 'js/declUtils';\nimport localStrg from 'js/localStorage';\nimport logger from 'js/logger';\nimport dragAndDropUtils from 'js/dragAndDropUtils';\n\n// Service\nimport AwBaseService from 'js/awBaseService';\nimport AwStateService from 'js/awStateService';\nimport pasteService from 'js/pasteService';\nimport AwPromiseService from 'js/awPromiseService';\nimport htmlUtils from 'js/htmlUtils';\n\n// Class for load handler\n// This file is too complex to convert it to a complete class\nclass DragAndDropService extends AwBaseService {\n    static reset() {\n        AwBaseService.reset();\n        delete this._defaultPasteHandler;\n        delete this._pasteFileHandler;\n    }\n\n    constructor() {\n        super();\n\n        // The following check is to support Karma testing which invokes this multiple times.\n        if( !_cfgLoadPromise && !( this.constructor._defaultPasteHandler || this.constructor._pasteFileHandler ) ) {\n            _cfgLoadPromise = cfgSvc.getCfg( 'paste' ).then( ( pasteProvider ) => {\n                if( pasteProvider.defaultPasteHandler ) {\n                    return declUtils.loadDependentModule( pasteProvider.defaultPasteHandler.dep ).then( ( dep ) => {\n                        this.constructor._defaultPasteHandler = dep;\n                        return pasteProvider;\n                    } );\n                }\n                return pasteProvider;\n            } ).then( ( pasteProvider ) => {\n                if( pasteProvider.defaultPasteFileHandler ) {\n                    return declUtils.loadDependentModule( pasteProvider.defaultPasteFileHandler.dep ).then( ( dep ) => {\n                        this.constructor._pasteFileHandler = dep;\n                        return pasteProvider;\n                    } );\n                }\n            } ).then( function() {\n                _cfgLoadPromise = null;\n            } );\n        }\n    }\n\n    get pasteHandler() {\n        return this.constructor._defaultPasteHandler;\n    }\n\n    get pasteFileHandler() {\n        return this.constructor._pasteFileHandler;\n    }\n}\n\n/**\n * Data formats to put the data in. It would be better to only use aw_interop_type here, but that isn't working\n * with Chrome.\n */\nvar DATA_FORMATS = [ 'text/html', 'aw_interop_type' ];\n\n/** Dataset type */\nvar TYPE_NAME_DATASET = 'Dataset';\n\n/** This is set to true if any of the dragged objects have a type set.\n */\nvar modelsHaveTypes;\n\n/**\n * {DOMElement} root container for the page.\n */\nvar mainReference;\n/**\n * {Boolean} TRUE if the drag event should have it's 'dataTransfer' object set/maintained.\n */\nvar _includeDataTransfer = true;\n\n/**\n * {Boolean} TRUE if various drag event activities should publish 'hosting' related events.\n */\nvar _publishHostingEvents = false;\n\n/**\n * {Function} A callback used to create the 'InteropObjectRef' encodings necessary to communicate more complex\n * selection information via drag event data format properties.\n * <P>\n * Note: Until the hosting 'InteropObjectRefFactory' is converted from GWT to native JS we must rely on it for\n * conversion of IModelObjects to the special encoding used for communications of 'source' objects to the host.\n */\nvar _createInteropObjectRefFn;\n\n/**\n * Temporary promise reference for loading of the configuration data. This is used to allow code to wait until\n * ready before doing work.\n *\n * @private\n */\nvar _cfgLoadPromise;\n\n/**\n * <pre>\n * Greater Than 0 If some basic event activity should be logged.\n * Greater Than 1 If some more fine-grained event activity should be logged.\n * </pre>\n */\nvar _debug_logEventActivity = 0;\n\nconst HOSTING_DRAG_DROP_EVENT = 'hosting.DragDropEvent';\nconst UI_GRID_ROW_CLASS = '.ui-grid-row';\nconst DROP_CLASS = '.aw-widgets-droppable';\nconst DRAG_DROP_HIGHLIGHT_EVENT = 'dragDropEvent.highlight';\n\nvar urlAttributes = browserUtils.getUrlAttributes();\n\nif( urlAttributes.logDnDEventActivity !== undefined ) {\n    _debug_logEventActivity = 1;\n\n    if( urlAttributes.logDnDEventActivity > 0 ) {\n        _debug_logEventActivity = urlAttributes.logDnDEventActivity;\n    }\n}\n\n/**\n * TRUE if the type that was not valid for a target is logged. This is very handy when debugging issues.\n */\nvar m_debug_LogRejectedSourceType = false;\n\n/**\n * Map used to hold an unresolved {Promise} for a given 'evaluation key' *while* the async server call is being\n * made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\nvar m_mapKey2Promise = {};\n\n/**\n * Map used to hold the *result* of a previous async server call for a given 'evaluation key'.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'evaluation key'.\n * <P>\n * Note: The 'evaluation key' is formed by TargetUID + ValidSourceTypes + FileExtensions.\n */\nvar m_mapKey2Result = {};\n\n/**\n * TRUE if dragging files from the OS file should be allowed.\n */\nvar m_supportingFileDrop = true;\n\n/**\n * Set used to hold an 'unresolved source type lookup key' *while( the async server call is being made.\n * <P>\n * Note: This map prevents repeatedly calling the server for the same 'unresolved source type lookup key'.\n * <P>\n * Note: The 'unresolved source type lookup key' is formed by a union of MissingSourceTypes.\n */\nvar m_typeLookupInProgress = {};\n\nlet isGlobalHighlightPublished = false;\n\n//* **********************************************************************\n\n/**\n * Clear out any 'dragData' that may have been created by the last Drag-n-Drop operation.\n */\nvar _clearCachedData = function() {\n    localStrg.publish( 'awDragData' );\n};\n\n/**\n * @param {StringArray} validSourceTypes The 'sourceTypes' {@link JavaScriptObject} property from the\n *            pasteConfig for the given 'target' object type or its ancestor types up the hierarchy (or NULL if\n *            no match was found).\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n *\n * @returns {Object} A {@link Map} that relates 'source' types to the 1 or more possible relationship types that\n *         are valid for the 'owner' (i.e. 'target') {@link IModelObject}.\n */\nvar _createSourceType2RelationsMap = function( validSourceTypes, targetElement ) {\n    var sourceType2RelationsMap = {};\n\n    var validSourceObjects = $( targetElement ).data( 'validSourceTypes' );\n\n    if( validSourceObjects ) {\n        for( var i = 0; i < validSourceTypes.length; i++ ) {\n            var sourceType = validSourceTypes[ i ];\n\n            var validSourceObj = validSourceObjects[ sourceType ];\n\n            var relations = [];\n\n            if( validSourceObj.relation ) {\n                relations.push( validSourceObj.relation );\n            } else {\n                relations.push( '' );\n            }\n\n            sourceType2RelationsMap[ sourceType ] = relations;\n        }\n    }\n\n    return sourceType2RelationsMap;\n};\n\n/**\n * Remove from selection any non-'target' object currently selected (like the ones we may have just pasted) so\n * that the 'target' can be cleanly selected later.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject the 'source' ViewModelObject(s) are being\n *            dropped onto.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAll = function( targetVMO, callbackAPIs ) {\n    callbackAPIs.clearSelectionFn( targetVMO );\n};\n\n/**\n * Get the adapted objects corresponding to the VMOs if any.\n *\n * @param {ObjectArray} vmos - Array of viewmodel objects.\n *\n * @return {Array} Returns array of adapadted objects if any or else returns the vmos\n */\nconst getAdaptedObjects = ( vmos ) => {\n    return dragAndDropUtils.getObjects( vmos );\n};\n\n/**\n * Synchronously create Datasets, upload the given JS Files and attach the files to the Datasets using the\n * correct relation types and the tickets used to upload the files.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {ObjectArray} sourceFiles - The 'source' JS File objects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAllAndPasteSourceFiles = function( targetElement, targetVMO, sourceFiles, callbackAPIs ) {\n    if( sourceFiles && sourceFiles.length > 0 ) {\n        _deselectAll( targetVMO, callbackAPIs );\n\n        _pasteSourceFiles( targetElement, targetVMO, sourceFiles, callbackAPIs );\n    }\n};\n\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObject(s) being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _deselectAllAndPasteSourceObjects = function( targetElement, targetVMO, sourceObjects, callbackAPIs ) {\n    if( sourceObjects && sourceObjects.length > 0 ) {\n        _deselectAll( targetVMO, callbackAPIs );\n\n        _pasteSourceObjects( targetElement, targetVMO, sourceObjects, callbackAPIs );\n    }\n};\n\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element.\n *\n * @param {ObjectArray} sourceFiles - The array 'source' JS File objects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _dropFiles = function( targetElement, sourceFiles, callbackAPIs ) {\n    var targetVMOs = callbackAPIs.getElementViewModelObjectFn( targetElement );\n    if( !targetVMOs || targetVMOs.length === 0 ) {\n        var targetUID = $( targetElement ).data( 'dropuid' );\n        if( targetUID ) {\n            targetVMOs = [];\n            targetVMOs.push( exports.getTargetObjectByUid( targetUID ) );\n        }\n    }\n\n    if( targetVMOs && targetVMOs.length !== 0 ) {\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMOs[ 0 ].modelType ) ) {\n            adapterSvc.getAdaptedObjects( targetVMOs ).then( function( adaptedObjs ) {\n                _deselectAllAndPasteSourceFiles( targetElement, adaptedObjs[ 0 ], sourceFiles, callbackAPIs );\n            } );\n        } else {\n            _deselectAllAndPasteSourceFiles( targetElement, targetVMOs[ 0 ], sourceFiles, callbackAPIs );\n        }\n    }\n    _clearCachedData();\n};\n\n/**\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _dropModelObjects = function( targetElement, sourceUIDs, callbackAPIs ) {\n    var targetVMOs = callbackAPIs.getElementViewModelObjectFn( targetElement );\n    if( !targetVMOs || targetVMOs.length === 0 ) {\n        var targetUID = $( targetElement ).data( 'dropuid' );\n        if( targetUID ) {\n            targetVMOs = [];\n            targetVMOs.push( exports.getTargetObjectByUid( targetUID ) );\n        }\n    }\n    if( targetVMOs && targetVMOs.length !== 0 ) {\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMOs[ 0 ].modelType ) ) {\n            adapterSvc.getAdaptedObjects( targetVMOs ).then( function( adaptedObjs ) {\n                _dropModelObjectsInternal( targetElement, sourceUIDs, callbackAPIs, adaptedObjs );\n            } );\n        } else {\n            _dropModelObjectsInternal( targetElement, sourceUIDs, callbackAPIs, targetVMOs );\n        }\n    }\n};\n\n/**\n * Perform the actual 'drop' (paste) of the 'source' objects onto the given 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {StringArray} sourceUIDs - The array of UIDs for the 'source' IModelObjects to drop onto the 'target'.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n *\n * @param {Object} targetVMOs - View model object of target.\n */\nvar _dropModelObjectsInternal = function( targetElement, sourceUIDs, callbackAPIs, targetVMOs ) {\n    var sourceObjects = [];\n    var missingSourceUIDs = [];\n    /**\n     * Attempt to locate the 'source' objects in this browser's CDM cache.\n     * <P>\n     * Note: When 'source' objects are being dragged from another browser they may not have been loaded into the\n     * 'target' browser.\n     */\n    if( sourceUIDs ) {\n        for( var i = 0; i < sourceUIDs.length; i++ ) {\n            var sourceObject = cdm.getObject( sourceUIDs[ i ] );\n            if( sourceObject ) {\n                sourceObjects.push( sourceObject );\n            } else {\n                missingSourceUIDs.push( sourceUIDs[ i ] );\n            }\n        }\n    }\n    /**\n     * Check if NO 'source' objects are missing\n     * <P>\n     * If so: Process the past now\n     */\n    if( !missingSourceUIDs || missingSourceUIDs.length === 0 ) {\n        _deselectAllAndPasteSourceObjects( targetElement, targetVMOs[ 0 ], sourceObjects, callbackAPIs );\n        _clearCachedData();\n    } else {\n        /**\n         * Attempt to locate the missing 'source' objects on the server.\n         */\n        dms.loadObjects( missingSourceUIDs, function() {\n            /**\n             * Attempt to locate the (formerly) missing 'targets' and add them to the list of 'source' objects\n             * to drop on the 'target'\n             */\n            for( var j = 0; j < missingSourceUIDs.length; j++ ) {\n                var sourceObject = cdm.getObject( missingSourceUIDs[ j ] );\n                if( sourceObject ) {\n                    sourceObjects.push( sourceObject );\n                } else {\n                    // var sourceTypes = _getCachedSourceTypes();\n                    // logger.warn( 'Unable to locate \\'source\\' IModelObject\\' (not loaded yet): ' +\n                    //     missingSourceUIDs[ j ] + ' of type: ' + sourceTypes[ 0 ] );\n                }\n            }\n            if( sourceObjects && sourceObjects.length > 0 ) {\n                _deselectAllAndPasteSourceObjects( targetElement, targetVMOs[ 0 ], sourceObjects, callbackAPIs );\n            }\n            _clearCachedData();\n        } );\n    }\n};\n\n/**\n * Starting with the given DOM Element and walking up the DOM, look for the 1st DOM Element with the\n * 'containerId' property set.\n *\n * @param {Element} testElement - The element to start the search at.\n *\n * @return {Number} The ID of the 'parent' element that has the 'containerId' set on it (or NULL if no Element\n *         was found).\n */\nvar _findContainerId = function( testElement ) {\n    var currElement = testElement;\n\n    while( currElement ) {\n        var containerId = $( currElement ).data( 'containerId' );\n\n        if( containerId ) {\n            return containerId.toString();\n        }\n\n        currElement = currElement.parentElement;\n    }\n\n    return null;\n};\n\n/**\n * When object drag is cancelled , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {bool}_isDragCancelFlag -  true or false\n */\nvar _isDragCancelled = function( event ) {\n    var _isDragCancelFlag = false;\n    if( event.x <= 0 || event.y <= 0 ) {\n        _isDragCancelFlag = true;\n    } else if( event.screenX <= 0 || event.screenY <= 0 ) {\n        _isDragCancelFlag = true;\n    } else {\n        _isDragCancelFlag = false;\n    }\n\n    return _isDragCancelFlag;\n};\n\n/**\n * When object is dragged over a cell list container , this function returns true or else false\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\nvar _isDragWithinCellListContainer = function( event ) {\n    var isCellListContainerFlag = false;\n    var cellListContainer = htmlUtils.closestElement( event.target, '.aw-widgets-cellListContainer' );\n    if( _.isUndefined( cellListContainer ) || cellListContainer === null ) {\n        isCellListContainerFlag = false;\n    } else {\n        isCellListContainerFlag = true;\n    }\n    return isCellListContainerFlag;\n};\n\n/**\n * When object is dragged over a table row border, this check ensures the drag cursor does not go back to 'Not allowed' because of global\n * dragenter event since table row border is an invalid drop target\n *\n * @param {event} event - Drag event\n *\n * @return {Object} isTableFlag - flag to suggest if drag is within table container\n */\nvar _isDragWithinTableContainer = function( event ) {\n    var isTableFlag = false;\n    var tableContainer = htmlUtils.closestElement( event.target, UI_GRID_ROW_CLASS );\n    if( _.isUndefined( tableContainer ) || tableContainer === null ) {\n        if( event && event.target && event.target.classList && event.target.classList.contains( 'ui-grid-row' ) ) {\n            isTableFlag = true;\n        }\n    } else {\n        isTableFlag = true;\n    }\n    return isTableFlag;\n};\n\n/**\n * When object is dragged over the white area, this check ensures  dragenter, dragleave , dragover events on document do not trigger any action in turn giving\n * a flickering of highlight effect on the container\n *\n * @param {event} event - Drag event\n * @return {Object} bool - flag to suggest if drag is within an applicable and valid container\n */\nvar _isDragWithinApplicableValidContainer = function( event ) {\n    var bool = false;\n    var jqTarget = $( event.target );\n\n    var jqContainer = jqTarget.closest( UI_GRID_ROW_CLASS );\n\n    if( jqContainer && jqContainer.length <= 0 ) {\n        jqContainer = jqTarget.closest( '.aw-widgets-cellListItem' );\n        if( jqContainer.length <= 0 ) {\n            jqContainer = jqTarget.closest( DROP_CLASS );\n\n            if( jqContainer.length <= 0 ) { // this is when user just enters a cellListContainer from white area\n                if( jqTarget &&\n                    jqTarget[ 0 ] &&\n                    jqTarget[ 0 ].children &&\n                    jqTarget[ 0 ].children.length > 0 &&\n                    jqTarget[ 0 ].children[ 0 ].classList &&\n                    jqTarget[ 0 ].children[ 0 ].classList.contains(\n                        'aw-widgets-cellListContainer' ) ) {\n                    jqContainer = jqTarget[ 0 ].children;\n                }\n            }\n        }\n    }\n    if( jqContainer && jqContainer.length > 0 && exports.isValidObjectToDrop( event, jqContainer[ 0 ] ) ) {\n        bool = true;\n    }\n    return bool;\n};\n\n/**\n * @param {event} event - Dragover event\n *\n * @return {Object} targetElement - choose or drop file widget which do not require validation or\n *                                   'undefined' if not over Choose or Drop File widgets\n */\nvar _isDragOverChooseOrDropFileContainer = function( event ) {\n    var targetElement = null;\n    if( event && event.target && event.target.classList && event.target.classList.contains( 'aw-widgets-chooseordropfile' ) ) {\n        targetElement = event.target;\n    } else {\n        var cfContainer = htmlUtils.closestElement( event.target, '.aw-widgets-chooseordropfile' );\n        if( cfContainer ) {\n            targetElement = cfContainer;\n        }\n    }\n    return targetElement;\n};\n\n/**\n * Determine if the DragEvent is over a white space on the page or on an applicable valid drop container\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\nexport let processDragOver = function( event, isCurrentTargetOverGlobalArea ) {\n    // If drag is over Choose File or Drop File container , unhighlight other highlighted containers, highlight this\n    // container and set drop effect to 'Copy' ; these containers have a special css(in addition) to identify : 'aw-widgets-chooseordropfile'\n    var chooseFileContainer = _isDragOverChooseOrDropFileContainer( event );\n    if( chooseFileContainer ) {\n        // Adding listeners to Choose/Drop File type widgets which mandatorily should have 'aw-widgets-chooseordropfile' associated\n        // along with 'aw-widgets-droppable' css class  to participate in highlight\n        chooseFileContainer.addEventListener( 'dragover', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS OVER CHOOSE/DROP FILE ZONE----------' );\n            }\n            exports.processDragLeaveGlobal( event ); // clear all the highlights\n            if( !exports.dataTransferContainsFiles( event ) ) {\n                _setDropEffect( event, 'none' );\n                event.stopPropagation();\n            } else {\n                eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                    event: event,\n                    isGlobalArea: false,\n                    isHighlightFlag: true,\n                    targetElement: chooseFileContainer\n                } );\n                _setDropEffect( event, 'copy' );\n                event.stopPropagation(); // required or else it hangs the page if file dragged over container for longer period of time.\n                event.preventDefault();\n            }\n        } );\n        chooseFileContainer.addEventListener( 'dragleave', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS LEAVING CHOOSE/DROP FILE ZONE----------' );\n            }\n            _setDropEffect( event, 'none' );\n            exports.processDragLeaveGlobal( event );\n            event.stopPropagation();\n            event.preventDefault();\n        } );\n        chooseFileContainer.addEventListener( 'drop', function( event ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( '----------FILE IS DROPPED IN CHOOSE/DROP FILE ZONE----------' );\n            }\n            _setDropEffect( event, 'none' );\n            exports.processDragLeaveGlobal( event );\n            event.stopPropagation();\n            event.preventDefault();\n        } );\n    }\n    var sourceUIDs = exports.getCachedSourceUids();\n\n    if( sourceUIDs ) {\n        dragAndDropUtils.loadVMOsIfNotAlreadyLoaded( sourceUIDs );\n    }\n\n    _processDragOverInternal( event, isCurrentTargetOverGlobalArea );\n};\n\n/**\n * Starting with the 'target' of the given DragEvent and walking up the DOM, look for the 1st DOM Element with the\n * 'validSourceTypes' property set.\n *\n * @param {DragEvent} event - The event to start the search at.\n * @param {Bool} isCurrentTargetOverGlobalArea - is the dragged file over white/invalid area\n * @return {Element} The Element that has the 'validSourceTypes' property set on it (or NULL if no Element was\n *         found).\n */\nvar _findDropTargetElement = function( event ) {\n    var targetElements = [];\n    /**\n     * Get the JQuery element for the event 'target' and look for common 'container' elements 'up' the DOM Tree.\n     */\n    var jqTarget = $( event.target );\n\n    var jqContainer = jqTarget.closest( UI_GRID_ROW_CLASS );\n\n    if( jqContainer !== undefined && jqContainer.length <= 0 ) {\n        jqContainer = jqTarget.closest( '.aw-widgets-cellListItem' );\n\n        if( jqContainer.length <= 0 ) {\n            jqContainer = jqTarget.closest( DROP_CLASS );\n        }\n    }\n\n    var targetElement;\n\n    if( jqContainer && jqContainer.length > 0 ) {\n        targetElement = jqContainer.get( 0 );\n    } else {\n        targetElement = jqTarget.get( 0 );\n    }\n    targetElements.push( targetElement );\n\n    /**\n     * Get the AngularJS element for the target 'container' element and try to find a {ViewModelObject} associated\n     * with it.\n     */\n    if( targetElements ) {\n        _.forEach( targetElements, function( targetElement ) {\n            //revisitme: fix the code as per react framework\n            // var ngTargetElement = ngModule.element( targetElement );\n\n            // var $scope = ngTargetElement.scope();\n\n            var targetVMO = null;\n            // $scope &&\n            //     ( $scope.vmo || $scope.item ||\n            //         $scope.row && $scope.row.entity ||\n            //         $scope.data && $scope.data.vmo ) ||\n            //     targetElement.vmo || ngTargetElement.get( 0 ).vmo;\n\n            if( targetVMO ) {\n                if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', targetVMO.modelType ) ) {\n                    adapterSvc.getAdaptedObjects( [ targetVMO ] ).then( function( adaptedObjs ) {\n                        _setValidSourceTypesOnTarget( targetElement, adaptedObjs[ 0 ] );\n                    } );\n                } else {\n                    _setValidSourceTypesOnTarget( targetElement, targetVMO );\n                }\n            }\n        } );\n    }\n\n    return targetElements;\n};\n\n/**\n * Check if we have NOT already stored the collection of 'valid' 'source' types this 'target' will accept.\n * <P>\n * If so: Get that collection now.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - View model object of target.\n */\nvar _setValidSourceTypesOnTarget = function( targetElement, targetVMO ) {\n    if( targetElement ) {\n        var jqElement = $( targetElement );\n        var validSourceTypes = jqElement.data( 'validSourceTypes' );\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        if( !validSourceTypes && pasteHandler ) {\n            validSourceTypes = pasteHandler.getObjectValidSourceTypes( targetVMO );\n            jqElement.data( 'validSourceTypes', validSourceTypes );\n            jqElement.data( 'dropuid', targetVMO.uid );\n            var containerId = _findContainerId( targetElement );\n            if( containerId ) {\n                jqElement.data( 'containerId', containerId );\n            }\n        }\n    }\n};\n\n/**\n * @return {Object} The Object that represents cached drag data set when the drag operation began.\n */\nvar _getCachedDragData = function() {\n    var dragDataJSON = localStrg.get( 'awDragData' );\n    if( dragDataJSON && dragDataJSON !== 'undefined' ) {\n        return JSON.parse( dragDataJSON );\n    }\n    return null;\n};\n\n/**\n * @param {String} dataTransferItem - The 'dataTransfer' Item to extract from.\n * @return {String} The type code of the given\n */\nfunction _getDataTransferType( dataTransferItem ) {\n    var extensionIndex = dataTransferItem.lastIndexOf( '/' );\n\n    if( extensionIndex >= 0 ) {\n        return dataTransferItem.substring( extensionIndex + 1 );\n    }\n\n    return '';\n}\n\n/**\n * @param {DragEvent} event - The DragEvent to extract the info from.\n *\n * @return {ObjectArray} Array of JS Files.\n */\nvar _getDataTransferSourceFiles = function( event ) {\n    return event.dataTransfer.files;\n};\n\n/**\n * Return the 'source' element from the given drag event. The name of the element in the event can vary\n * depending on the browser the client is running with.\n *\n * @param {DragEvent} event - The event to extract the 'source' element from.\n *\n * @return {Element} The DOM element considered the 'source' of the given drag event.\n */\nvar _getEventSource = function( event ) {\n    if( event.srcElement ) {\n        return event.srcElement;\n    }\n\n    return event.target;\n};\n\n/**\n * Get the first child image element of the passed in element.\n *\n * @param {Element} sourceElement - element being dragged\n *\n * @return {Element} drag image element or returns passed in element if no image found.\n */\nvar _getFirstChildImage = function( sourceElement ) {\n    var image = $( sourceElement ).find( 'img:first' )[ 0 ];\n\n    return image ? image : sourceElement;\n};\n\n/**\n * @param {String} uid - ID of the object to include in the URL.\n *\n * @return {String} The URL 'prefix' used to open an object in the 'show object' location of AW.\n */\nvar _getShowObjectURL = function( uid ) {\n    // Have to decode as ui-router returns encoded URL (which is then decoded again by browser)\n    return window.decodeURIComponent( document.location.origin + document.location.pathname +\n        AwStateService.instance.href( 'com_siemens_splm_clientfx_tcui_xrt_showObject', {\n            uid: uid\n        } ) );\n};\n\n/**\n * Returns the correct element to be dragged\n *\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} The correct drag element\n */\nvar _getDragElement = function( event, count ) {\n    var element;\n\n    if( event && event.target && event.target.classList ) {\n        if( event.target.classList.contains( 'aw-widgets-cellListItemContainer' ) ) {\n            element = event.target.parentElement; // Cell element\n        } else if( event.target.classList.contains( 'ui-grid-cell' ) ) {\n            var target = $( event.target );\n            var closest = target.closest( UI_GRID_ROW_CLASS );\n            if( closest && closest.length > 0 && count === 1 ) {\n                element = target.closest( UI_GRID_ROW_CLASS ).get( 0 ); // Table element\n            } else {\n                element = event.target;\n            }\n        }\n    }\n\n    return element;\n};\n\n/**\n * @param {DragEvent} event - element being dragged\n * @param {int} count - number of objects being dragged\n *\n * @return {Element} image element\n */\nvar _getMultiDragImage = function( event, count ) {\n    var targetImage = _getDragElement( event, count );\n\n    var strWidth;\n    var strHeight;\n\n    var cloneImage = null;\n    if( targetImage ) {\n        cloneImage = targetImage.cloneNode( true );\n\n        // If cell, remove command icon/text\n        if( targetImage.classList && targetImage.classList.contains( 'aw-widgets-cellListItem' ) ) {\n            // Keep the image from being duplicated at the top of the page\n            targetImage.style.position = 'relative';\n\n            strWidth = targetImage.offsetWidth - 50 + 'px';\n            strHeight = targetImage.offsetHeight - 10 + 'px';\n\n            // Remove commands from image\n            cloneImage.children[ 0 ].removeChild( cloneImage.children[ 0 ].children[ 1 ] );\n\n            // Remove text from image\n            var cloneImageText = cloneImage.getElementsByClassName( 'aw-widgets-cellListCellTitleBlock' )[ 0 ].parentNode;\n            if( cloneImageText ) {\n                for( var i = 1; i < cloneImageText.children.length; i++ ) {\n                    cloneImageText.removeChild( cloneImageText.children[ i ] );\n                    i--;\n                }\n            }\n        } else { // Else it is a row\n            strWidth = '150px';\n            strHeight = '100%';\n        }\n\n        cloneImage.id = 'dragCount';\n\n        cloneImage.style.maxWidth = strWidth;\n        cloneImage.style.minWidth = strWidth;\n        cloneImage.style.maxHeight = strHeight;\n        cloneImage.style.minHeight = strHeight;\n\n        cloneImage.style.position = 'absolute';\n        cloneImage.style.left = '0px';\n        cloneImage.style.top = '0px';\n        cloneImage.style.zIndex = '99';\n        cloneImage.classList.add( 'aw-theme-multidragimage' );\n        cloneImage.classList.add( 'aw-widgets-multidragimage' );\n\n        // the image that is dragged needs to be visible, so it is added to the existing node\n        targetImage.children[ 0 ].appendChild( cloneImage );\n\n        // create a second offset image\n        var cloneImage2 = cloneImage.cloneNode( true );\n\n        cloneImage2.style.left = '5px';\n        cloneImage2.style.top = '5px';\n\n        // create a third offset image & append if necessary\n        var cloneImage3 = cloneImage.cloneNode( true );\n\n        cloneImage.appendChild( cloneImage2 );\n\n        if( count > 2 ) {\n            cloneImage3.style.left = '10px';\n            cloneImage3.style.top = '10px';\n\n            cloneImage.appendChild( cloneImage3 );\n        }\n    }\n\n    return cloneImage;\n};\n\n/**\n * Returns the 'validSourceTypes' property on the 'target' element being dropped onto.\n *\n * @param {Element} targetElement - The Element that will be dropped onto (i.e. the data 'target').\n *\n * @return {StringArray} Array of valid 'sourceTypes' (or an empty array if no 'sourceTypes' are valid).\n */\nvar _getValidSourceTypes = function( targetElement ) {\n    var validSourceTypes = $( targetElement ).data( 'validSourceTypes' );\n    if( validSourceTypes ) {\n        return Object.keys( validSourceTypes );\n    }\n    return [];\n};\n\n/**\n * Use the given ViewModelObject to return a string description of it.\n *\n * @param {ViewModelObject} vmo - The ViewModelObject to query.\n *\n * @return {String} Description of given ViewModelObject (or it's UID if no other name is possible).\n */\nvar _getViewModelObjectName = function( vmo ) {\n    if( vmo.props.object_string ) {\n        return vmo.props.object_string.displayValues[ 0 ];\n    } else if( vmo.props.items_tag ) {\n        return vmo.props.items_tag.displayValues[ 0 ];\n    } else if( vmo.props.object_name ) {\n        return vmo.props.object_name.displayValues[ 0 ];\n    } else if( vmo.props.object_desc && vmo.props.object_desc.length > 0 ) {\n        return vmo.props.object_desc.displayValues[ 0 ];\n    } else if( vmo.props.job_name ) {\n        return vmo.props.job_name.displayValues[ 0 ];\n    } else if( vmo.props.awp0CellProperties ) {\n        return vmo.props.awp0CellProperties.displayValues[ 0 ];\n    }\n\n    return vmo.uid;\n};\n\n/**\n * Check the user agent string to see if the browser is the NX embedded browser, the NX QT browser puts \"ugraf\"\n * in the user agent string.\n *\n * @return {boolean} true if NX browser false otherwise\n */\nvar _isNxWebBrowser = function() {\n    return navigator.userAgent.indexOf( 'ugraf' ) >= 0;\n};\n\n/**\n * @param {StringArray} validSourceTypes - Array of 'source' types this 'target' will accept.\n * @param {StringArray} sourceTypes - Arrays of 'source' types determined from the event's 'dataTransfer' being\n *            dragged.\n *\n * @return {Boolean} TRUE if ALL the given 'source' types are valid to drop onto the 'target' based on the given\n *         'validSourceTypes'.\n */\nvar _isValidObjectToDropInternal = function( validSourceTypes, sourceTypes ) {\n    /**\n     * Check if we have anything to work with.\n     */\n    if( validSourceTypes && validSourceTypes.length > 0 && sourceTypes && sourceTypes.length > 0 ) {\n        /**\n         * Check if all the 'sources' matches at least one valid type for the 'target' Element.\n         * <P>\n         * If so: We will consider the drop of these 'sources' onto that 'target'.\n         */\n        for( var i = 0; i < sourceTypes.length; i++ ) {\n            var sourceType = sourceTypes[ i ];\n\n            var sourceTypeFound = null;\n\n            /**\n             * Consider each valid 'source' type the 'target' will accept.\n             */\n            for( var j = 0; j < validSourceTypes.length; j++ ) {\n                var validSourceType = validSourceTypes[ j ];\n\n                /**\n                 * Check for an exact match\n                 */\n                if( sourceType === validSourceType ) {\n                    sourceTypeFound = validSourceType;\n                    break;\n                }\n\n                /**\n                 * Get all the ancestor types for this 'source' type and see if one of them is valid for this\n                 * 'target'.\n                 */\n                var sourceModelType = cmm.getType( sourceType );\n\n                if( sourceModelType ) {\n                    var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                    if( sourceTypeHeirarchy ) {\n                        for( var k = 1; k < sourceTypeHeirarchy.length; k++ ) {\n                            if( sourceTypeHeirarchy[ k ] === validSourceType ) {\n                                sourceTypeFound = validSourceType;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    logger.warn( 'Unable to locate \\'source\\' type (not loaded yet?): ' + sourceType );\n                }\n            }\n\n            /**\n             * Check if NONE of the valid 'source' types apply.\n             */\n            if( !sourceTypeFound ) {\n                if( m_debug_LogRejectedSourceType ) {\n                    logger.warn( 'This \\'source\\' type is not valid for the \\'target\\': ' + sourceType );\n                }\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * @param {Object} pasteInput - An Object that maps a unique 'relationType' to the array of 'source'\n *            IModelObjects that should be pasted onto the 'target' with that 'relationType'.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\nvar _pasteFiles = function( pasteInput ) {\n    let pasteFileHandler = DragAndDropService.instance.pasteFileHandler;\n    return pasteFileHandler.pasteFilesWithHandler( pasteInput ).then( function( response ) {\n        if( response && response.isOsFiles ) {\n            const { pasteFilesInput } = response;\n            var deferred = AwPromiseService.instance.defer();\n\n            _.forEach( pasteFilesInput, function( input ) {\n                const { targetObject, relationType, sourceObjects } = input;\n                pasteService.execute( targetObject, sourceObjects, relationType, { isDragDropIntent: true } ).then( function( res ) {\n                    var eventData = {\n                        relatedModified: [ targetObject ],\n                        refreshLocationFlag: false,\n                        createdObjects: sourceObjects\n                    };\n                    eventBus.publish( 'cdm.relatedModified', eventData );\n                    deferred.resolve( res[ 0 ] );\n                }, function( err ) {\n                    deferred.reject( err );\n                } );\n            } );\n\n            return deferred.promise;\n        }\n        return response;\n    } );\n};\n\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Array} sourceFiles - The 'source' JS File objects being dropped.\n * @param {FunctionArray} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _pasteSourceFiles = function( targetElement, targetVMO, sourceFiles, callbackAPIs ) {\n    /**\n     * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n     * type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n    if( !validSourceTypes || validSourceTypes.length === 0 ) {\n        validSourceTypes = [];\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        var sourceTypesObject = pasteHandler.getObjectValidSourceTypes( targetVMO );\n        if( sourceTypesObject && typeof sourceTypesObject === 'object' ) {\n            var sourceTypes = Object.keys( sourceTypesObject );\n\n            if( sourceTypes ) {\n                for( var counter = 0; counter < sourceTypes.length; counter++ ) {\n                    var validSourceType = sourceTypes[ counter ];\n                    if( cmm.containsType( validSourceType ) ) {\n                        validSourceTypes.push( validSourceType );\n                    }\n                }\n            }\n        }\n    }\n\n    var sourceType2RelationMap = _createSourceType2RelationsMap( validSourceTypes, targetElement );\n\n    var pasteRelation2SourceObjectsMap = {};\n\n    if( sourceFiles ) {\n        for( var i = 0; i < sourceFiles.length; i++ ) {\n            var sourceObject = sourceFiles[ i ];\n\n            /**\n             * Get all the ancestor types for this 'source' type and see if one of them is valid.\n             * <P>\n             * Note: For dropping files we look to see if the 'target' accepts a 'Dataset' since that is what will\n             * ultimately be created.\n             */\n            var sourceModelType = cmm.getType( TYPE_NAME_DATASET );\n\n            if( sourceModelType ) {\n                var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                for( var j = 0; j < sourceTypeHeirarchy.length; j++ ) {\n                    var currSourceType = sourceTypeHeirarchy[ j ];\n\n                    var relationType = sourceType2RelationMap[ currSourceType ];\n\n                    if( relationType ) {\n                        var sourceObjectsForType = pasteRelation2SourceObjectsMap[ relationType ];\n\n                        if( !sourceObjectsForType ) {\n                            sourceObjectsForType = [];\n\n                            pasteRelation2SourceObjectsMap[ relationType ] = sourceObjectsForType;\n                        }\n\n                        sourceObjectsForType.push( sourceObject );\n                        break;\n                    }\n                }\n            } else {\n                logger.warn( 'Unable to locate \\'source\\' type\\' (not loaded yet?): ' + TYPE_NAME_DATASET );\n            }\n        }\n    }\n\n    _scheduleSelectTarget( targetElement, targetVMO, callbackAPIs );\n\n    /**\n     * Paste 'sources' to 'target' for each unique 'relation' type.\n     */\n    var pasteInput = [];\n\n    _.forEach( pasteRelation2SourceObjectsMap, function( value, key ) {\n        var curr = {};\n\n        curr.targetObject = targetVMO;\n        curr.relationType = key;\n        curr.sourceObjects = value;\n\n        pasteInput.push( curr );\n    } );\n\n    var startTime = Date.now();\n\n    _pasteFiles( pasteInput ).then( function( result ) {\n        var stopTime = Date.now();\n\n        var pasteInputJS = pasteInput;\n        var sourceObjectsJS = result.sourceObjects;\n\n        if( _debug_logEventActivity > 1 ) {\n            var durationMs = stopTime - startTime;\n\n            var durationSec = durationMs / 1000.0;\n            var duration = durationSec;\n\n            logger.info( 'Time to process (' + sourceObjectsJS.length + ') files: ' + duration + 'sec' );\n        }\n        var localTextBundle = {};\n        localTextBundle.dropCompletedDocument = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropCompletedDocument' );\n        localTextBundle.dropCompleted = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropCompleted' );\n\n        /**\n         * Based on passed parameters in return from create SOA post the correct success message to the user.\n         */\n\n        var droppedOnObject = pasteInputJS[ 0 ].targetObject.cellHeader1;\n\n        if( !droppedOnObject ) {\n            droppedOnObject = pasteInputJS[ 0 ].targetObject.props.object_string.uiValues[ 0 ];\n        }\n\n        if( !droppedOnObject ) {\n            droppedOnObject = '???';\n        }\n\n        if( result.docCreated ) {\n            var dropCompletedDocumentMsg = localTextBundle.dropCompletedDocument;\n\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{0}', result.docName );\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{1}', droppedOnObject );\n            dropCompletedDocumentMsg = dropCompletedDocumentMsg.replace( '{2}', sourceObjectsJS.length );\n\n            messagingSvc.showInfo( dropCompletedDocumentMsg );\n        } else {\n            var dropCompletedMsg = localTextBundle.dropCompleted;\n\n            dropCompletedMsg = dropCompletedMsg.replace( '{0}', sourceObjectsJS.length );\n            dropCompletedMsg = dropCompletedMsg.replace( '{1}', droppedOnObject );\n\n            messagingSvc.showInfo( dropCompletedMsg );\n        }\n    }, function( ex ) {\n        logger.error( 'uploadFailures' + ex );\n    } );\n};\n\n/**\n * Use the 'paste' operation command to perform the actual 'drop' onto the 'target'.\n *\n * @param {Element} targetElement - The 'target' DOM Element being dropped onto.\n *\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n *\n * @param {IModelObjectArray} sourceObjects - The 'source' IModelObjects being dropped.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _pasteSourceObjects = function( targetElement, targetVMO, sourceObjects, callbackAPIs ) {\n    /**\n     * Create a map of unique 'relation' type to a list of objects that will be pasted with that 'relation'\n     * type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n    if( !validSourceTypes || validSourceTypes.length === 0 ) {\n        validSourceTypes = [];\n        let pasteHandler = DragAndDropService.instance.pasteHandler;\n        var sourceTypesObject = pasteHandler.getObjectValidSourceTypes( targetVMO );\n        var sourceTypes = Object.keys( sourceTypesObject );\n\n        if( sourceTypes ) {\n            for( var counter = 0; counter < sourceTypes.length; counter++ ) {\n                var validSourceType = sourceTypes[ counter ];\n                if( cmm.containsType( validSourceType ) ) {\n                    validSourceTypes.push( validSourceType );\n                }\n            }\n        }\n    }\n\n    var sourceType2RelationMap = _createSourceType2RelationsMap( validSourceTypes, targetElement );\n\n    var pasteRelation2SourceObjectsMap = {};\n\n    if( sourceObjects ) {\n        for( var i = 0; i < sourceObjects.length; i++ ) {\n            var sourceObject = sourceObjects[ i ];\n\n            /**\n             * Get all the ancestor types for this 'source' type and see if one of them is valid.\n             */\n            var sourceType = sourceObject.type;\n\n            var sourceModelType = cmm.getType( sourceType );\n\n            if( sourceModelType ) {\n                var sourceTypeHeirarchy = sourceModelType.typeHierarchyArray;\n\n                for( var j = 0; j < sourceTypeHeirarchy.length; j++ ) {\n                    var sourceParentType = sourceTypeHeirarchy[ j ];\n\n                    var relationType = sourceType2RelationMap[ sourceParentType ];\n\n                    if( relationType ) {\n                        var sourceObjectsForType = pasteRelation2SourceObjectsMap[ relationType ];\n\n                        if( !sourceObjectsForType ) {\n                            sourceObjectsForType = [];\n\n                            pasteRelation2SourceObjectsMap[ relationType ] = sourceObjectsForType;\n                        }\n\n                        sourceObjectsForType.push( sourceObject );\n\n                        break;\n                    }\n                }\n            } else {\n                logger.warn( 'Unable to locate \\'source\\' type\\' (not loaded yet?): ' + sourceType );\n            }\n        }\n    }\n\n    _scheduleSelectTarget( targetElement, targetVMO, callbackAPIs );\n\n    /**\n     * Paste each unique 'relation' type.\n     */\n    var keys = Object.keys( pasteRelation2SourceObjectsMap );\n\n    if( keys && keys.length > 0 ) {\n        var pasteInput = [];\n\n        _.forEach( pasteRelation2SourceObjectsMap, function( value, key ) {\n            var jso = {};\n\n            jso.targetObject = targetVMO;\n            jso.relationType = key;\n            jso.sourceObjects = value;\n\n            pasteInput.push( jso );\n        } );\n\n        exports.publishDropEvent( pasteInput );\n    }\n};\n\n/**\n * Determine all the valid containers on the page . Check if the 'target'  is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event - DragEnter or DragOver event from global area\n * @return {Object} validHighlightableContainers - All valid applicable containers for highlighing\n */\nvar getApplicableContainersFromGlobalArea = function( event ) {\n    var validHighlightableContainers = [];\n    var isValid = false;\n    var targetElements = document.body.querySelectorAll( DROP_CLASS );\n    if( targetElements ) {\n        _.forEach( targetElements, function( targetElement ) {\n            isValid = exports.isValidObjectToDrop( event, targetElement );\n            if( isValid ) {\n                validHighlightableContainers.push( targetElement );\n            }\n        } );\n    }\n    if( validHighlightableContainers.length === 0 ) {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( 'No valid containers found on the entire page' );\n        }\n    } else {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( validHighlightableContainers.length + ' valid containers found , highlight in progress' );\n        }\n    }\n\n    return validHighlightableContainers;\n};\n\n/**\n * Set the type of drag-and-drop operation currently selected or sets the operation to a new type. The value\n * must be 'none', 'copy', 'link' or 'move'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n * @param {String} value - The 'dropEffect' value to set .\n */\nvar _setDropEffect = function( event, value ) {\n    event.dataTransfer.dropEffect = value;\n};\n\n/**\n * Once the last 'paste' is complete, select the 'target' object to show the results of the 'drop'. This should\n * cause the new 'sources' in that object.\n *\n * @param {DOMElement} targetElement - The element the mouse is over when the event was fired.\n * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nvar _scheduleSelectTarget = function( targetElement, targetVMO, callbackAPIs ) {\n    callbackAPIs.selectResultFn( targetElement, targetVMO );\n};\n\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n//* **************************************************************************\n\nvar exports = {};\n\n/**\n * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.\n *\n * @param {DragEvent} event - The DragEvent to set the DragData on.\n * @param {Object} dragDataMap - Map of name/value pairs to add.\n */\nexport let addDragDataToDragEvent = function( event, dragDataMap ) {\n    if( _includeDataTransfer ) {\n        try {\n            _.forEach( dragDataMap, function( value, name ) {\n                event.dataTransfer.setData( name, value );\n            } );\n        } catch ( ex ) {\n            // Current versions of Internet Explorer can only have types \"Text\" and \"URL\"\n            _.forEach( dragDataMap, function( value, name ) {\n                // Only deal with the interop error from IE, to address DnD issue D-24972\n                if( name === 'aw_interop_type' ) {\n                    event.dataTransfer.setData( 'text', value );\n                }\n            } );\n        }\n    }\n};\n\n/**\n * @return {StringArray} An array of strings (placed into localStorage' at the start of a drag operation) that\n *         represent the UIDs of 'source' objects being dragged (or NULL if no types were found).\n */\nexport let getCachedSourceUids = function() {\n    var dragDataJSON = localStrg.get( 'awDragData' );\n\n    if( dragDataJSON && dragDataJSON !== 'undefined' ) {\n        var dragData = JSON.parse( dragDataJSON );\n\n        if( dragData.uidList ) {\n            return dragData.uidList;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.\n * <P>\n * Note: There will be multiple things being dragged over. We should look at the type (Files, ModelObject,\n * Text). Do we have three handlers, or a smarter handler?\n * <P>\n * For a smarter handler, if this is a folder, it can take objects. This should only cause the drop indicator to\n * be shown for objects.\n *\n * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to\n *            test.\n * @param {Object} targetElement - targetElement when object is over an invalid area . When drag is over a valid area,  targetElement\n *            is evaluated from event\n * @returns {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.\n */\nexport let isValidObjectToDrop = function( event, targetElement ) { // eslint-disable-line complexity\n    /**\n     * Find the DOM Element (potentially above the 'target' event's origin) where all the DnD information is\n     * stored.\n     */\n\n    if( _.isUndefined( targetElement ) ) {\n        targetElement = _findDropTargetElement( event )[ 0 ];\n    }\n    if( !targetElement ) {\n        return false;\n    }\n\n    if( targetElement.classList && targetElement.classList.contains( 'aw-widgets-chooseordropfile' ) && exports.dataTransferContainsFiles( event ) ) {\n        return true;\n    }\n\n    /**\n     * Check if we do NOT want to allow files from the OS to be dropped and the 'dataTransfer' contains at least\n     * one file.\n     */\n    if( !m_supportingFileDrop && exports.dataTransferContainsFiles( event ) ) {\n        return false;\n    }\n\n    /**\n     * Check if the 'target' does not have information we need to process or that there are no 'source' objects\n     * being dragged.\n     * <P>\n     * If so: No need to consider it as a valid drop (onto itself).\n     */\n    var targetUID = $( targetElement ).data( 'dropuid' );\n\n    if( !targetUID || targetUID.length === 0 ) {\n        return false;\n    }\n\n    /**\n     * Make sure we have cached 'source' information to work with.\n     */\n    //            var sourceContainerId = null;\n    var sourceUids = null;\n    var sourceTypes = null;\n\n    var sourceDragData = _getCachedDragData();\n\n    if( sourceDragData ) {\n        //                sourceContainerId = sourceDragData.containerId;\n        sourceUids = sourceDragData.uidList;\n        sourceTypes = sourceDragData.typeList;\n    }\n\n    /**\n     * Check if the 'target' is actually in the list of 'source' objects being dragged.\n     * <P>\n     * If so: No need to consider it as a valid drop (onto itself).\n     */\n    if( sourceUids && sourceUids.length > 0 && _.indexOf( sourceUids, targetUID ) !== -1 ) {\n        return false;\n    }\n\n    /**\n     * Get the types that are valid to drop on this 'target' and check if the current drag operation 'source'\n     * contains at least one of that type.\n     */\n    var validSourceTypes = _getValidSourceTypes( targetElement );\n\n    if( validSourceTypes && validSourceTypes.length > 0 ) {\n        /**\n         * Check if the only 'sources' are JS Files on the event.\n         * <P>\n         * If so: Build a list of 'source' types based on the file extensions.\n         * <P>\n         * If not: Use the IModelObject 'sources'\n         */\n        if( ( !sourceTypes || sourceTypes.length === 0 ) && exports.dataTransferContainsFiles( event ) ) {\n            /**\n             * Get any file type information carried in the 'dataTransfer' property.\n             * <P>\n             * Check if there are NONE\n             * <P>\n             * If so: Then just assume the source is just one or more 'DataSet'.\n             */\n            var fileTypes = exports.getDataTransferFileTypes( event );\n\n            if( fileTypes && fileTypes.length === 0 ) {\n                fileTypes.push( TYPE_NAME_DATASET );\n            }\n\n            /**\n             * Create key used to track status and remember the result of the validity test.\n             */\n            var sb = targetUID;\n\n            for( var i = 0; i < validSourceTypes.length; i++ ) {\n                sb += ',';\n                sb += validSourceTypes[ i ];\n            }\n\n            if( fileTypes ) {\n                for( var j = 0; j < fileTypes.length; j++ ) {\n                    sb += ',';\n                    sb += fileTypes[ j ];\n                }\n            }\n            var mapKey = sb;\n\n            /**\n             * Check if we already know the result from the last time we asked this question for the same\n             * 'source' types and 'target'.\n             */\n            var result = m_mapKey2Result[ mapKey ];\n\n            if( result ) {\n                return result.value;\n            }\n\n            var promise = m_mapKey2Promise[ mapKey ];\n\n            if( !promise ) {\n                m_mapKey2Promise[ mapKey ] = exports.getDataTransferSourceTypes( targetUID, fileTypes ).then( function( result2 ) {\n                    delete m_mapKey2Promise[ mapKey ];\n\n                    m_mapKey2Result[ mapKey ] = {\n                        value: result2 && result2.length > 0 &&\n                            _isValidObjectToDropInternal( validSourceTypes, result2 )\n                    };\n                }, function() {\n                    delete m_mapKey2Promise[ mapKey ];\n\n                    m_mapKey2Result[ mapKey ] = {\n                        value: false\n                    };\n                } );\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if any of the valid 'source' types are NOT currently loaded.\n         * <P>\n         * Note: We need them loaded so we can walk their type hierarchy while looking for a match.\n         */\n        var missingSourceTypes = null;\n        var availableSourceTypes = null;\n\n        for( var ii = 0; ii < validSourceTypes.length; ii++ ) {\n            var validSourceType = validSourceTypes[ ii ];\n\n            if( !cmm.containsType( validSourceType ) ) {\n                if( !missingSourceTypes ) {\n                    missingSourceTypes = [];\n                }\n\n                missingSourceTypes.push( validSourceType );\n            } else {\n                if( !availableSourceTypes ) {\n                    availableSourceTypes = [];\n                }\n                availableSourceTypes.push( validSourceType );\n            }\n        }\n\n        /**\n         * Check if any 'source' types are missing (not loaded yet).\n         * <P>\n         * If available 'source' types is null and missing 'source' types is not null, Then: Return 'false' for\n         * this drop but queue up a server request to get the type so that during further (future) dragging will\n         * see the type as loaded.\n         */\n        if( !availableSourceTypes && missingSourceTypes ) {\n            var sb2 = targetUID;\n\n            for( var jj = 0; jj < missingSourceTypes.length; jj++ ) {\n                if( jj > 0 ) {\n                    sb2 += ',';\n                }\n\n                sb2 += missingSourceTypes[ jj ];\n            }\n\n            var key = sb2;\n\n            if( !m_typeLookupInProgress[ key ] ) {\n                m_typeLookupInProgress[ key ] = key;\n\n                soaSvc.ensureModelTypesLoaded( missingSourceTypes ).then( function() {\n                    /**\n                     * Nothing to do now other than removing the lookup placeholder. We just wanted to make sure\n                     * the type is loaded for the NEXT time we look for it.\n                     */\n                    delete m_typeLookupInProgress[ key ];\n                }, function( err ) {\n                    logger.error( 'Unable to get model types: ' + err );\n                } );\n            }\n\n            return false;\n        }\n\n        return _isValidObjectToDropInternal( availableSourceTypes, sourceTypes );\n    }\n\n    return false;\n};\n\n/**\n * Get map of data format to drag data based on the given 'source' IModelObjects.\n *\n * @param {ViewModelObjectArray} sourceVMOs - The 'source' ViewModelObjects being dragged.\n * @param {String} containerId - The ID of the UI 'container' of the 'source' objects.\n *\n */\nexport let processAWInteropAndHosting = function( sourceVMOs, containerId ) {\n    /**\n     * Create collections of data associated with the 'source' objects.\n     */\n    var uidList = [];\n    var typeSet = {};\n\n    var interopObjectRefs = [];\n\n    var firstObjectUrl = '';\n\n    var first = true;\n\n    modelsHaveTypes = false;\n\n    sourceVMOs.forEach( ( modelObject ) => {\n        if( modelObject.type ) {\n            modelsHaveTypes = true;\n        }\n\n        if( cmm.isInstanceOf( 'Awp0XRTObjectSetRow', modelObject.modelType ) ) {\n            var adaptedObjs = adapterSvc.getAdaptedObjectsSync( [ modelObject ] );\n            modelObject = adaptedObjs[ 0 ];\n        }\n\n        /**\n         * Grab the first uid from the list for the url and the type\n         */\n        if( first ) {\n            first = false;\n            firstObjectUrl = _getShowObjectURL( modelObject.uid );\n        }\n\n        /**\n         * Add the UID and type of this object into the collections\n         */\n        if( modelObject.uid ) {\n            uidList.push( modelObject.uid );\n        }\n\n        typeSet[ modelObject.type ] = modelObject.type;\n\n        if( _createInteropObjectRefFn ) {\n            /**\n             * Generate a hosting InteropObjectRef to be used by host applications (i.e. NX) for\n             * interpreting this 'source' object.\n             */\n            var objRefArrayList = _createInteropObjectRefFn( modelObject );\n\n            _.forEach( objRefArrayList, function( objRef ) {\n                interopObjectRefs.push( objRef );\n            } );\n        } else {\n            if( _debug_logEventActivity ) {\n                logger.warn( 'Unable to determine InteropObjectRef information due to missing callback function' );\n            }\n        }\n    } );\n\n    var dragData = {\n        'text/uri-list': firstObjectUrl,\n        'text/plain': firstObjectUrl\n    };\n\n    /**\n     * Include application interop references (if necessary)\n     */\n    if( interopObjectRefs && interopObjectRefs.length > 0 && _includeDataTransfer ) {\n        /**\n         * Create the JSON message for interop with host applications.\n         */\n        var dragDataInterop = {\n            DragTargets: interopObjectRefs\n        };\n\n        var jsonString = JSON.stringify( dragDataInterop );\n\n        /**\n         * Add data for each data format\n         * <P>\n         * Note: Need multiple data formats right now to handle compatibility with different browsers.\n         */\n        for( var j = 0; j < DATA_FORMATS.length; j++ ) {\n            dragData[ DATA_FORMATS[ j ] ] = jsonString;\n        }\n    }\n\n    dragData[ 'text/uri-list' ] = firstObjectUrl;\n    dragData[ 'text/plain' ] = firstObjectUrl;\n\n    /**\n     * Put the other formats onto the dataTransport\n     * <P>\n     * Note: We need the UIDs and types in the 'keys' (for checking while dragging since the values are not\n     * available at that time) and the 'values' to be able to access the data without it being changed to lower\n     * case by the browser itself.\n     */\n    var dragDataJSO = {};\n\n    dragDataJSO.containerId = containerId;\n    dragDataJSO.uidList = uidList;\n    dragDataJSO.firstObjectUrl = firstObjectUrl;\n\n    dragDataJSO.typeList = [];\n\n    _.forEach( typeSet, function( type ) {\n        dragDataJSO.typeList.push( type );\n    } );\n\n    localStrg.publish( 'awDragData', JSON.stringify( dragDataJSO ) );\n    addDragDataToDragEvent( event, dragData );\n};\n\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n */\nexport let processDragEnd = function( event ) { // eslint-disable-line no-unused-vars\n    _clearCachedData();\n};\n\n/**\n * Remove Highlight from the drop area with CSS class(s) and prevent the 'default' behavior (which we assume to\n * be 'do not allow drop' for objects or 'load file into page' for files).\n *\n * @param {DragEvent} event -\n */\nexport let processDragLeave = function( event ) {\n    event.preventDefault();\n};\n\n/**\n * Remove Highlight when object drag is skipped or object dragged outside white/invalid area\n *\n * @param {DragEvent} event -\n */\nexport let processDragLeaveGlobal = function( event ) {\n    if( _.isUndefined( mainReference ) ) {\n        mainReference = document.body;\n    }\n    var allHighlightedTargets = mainReference.querySelectorAll( '.aw-theme-dropframe.aw-widgets-dropframe' );\n    if( allHighlightedTargets ) {\n        isGlobalHighlightPublished = false;\n        _.forEach( allHighlightedTargets, function( target ) {\n            eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                event: event,\n                isGlobalArea: true,\n                isHighlightFlag: false,\n                targetElement: target\n            } );\n        } );\n    }\n};\n\n/**\n * Determine if the DragEvent is over a 'target' that is compatible with the 'source' types being dragged and,\n * if so, change drag effect to indicate if it is OK to drop on that 'target'.\n *\n * @param {DragEvent} event -\n * @param {boolean} isCurrentTargetOverGlobalArea - is the object drag over an invalid/white area\n */\nvar _processDragOverInternal = function( event, isCurrentTargetOverGlobalArea ) {\n    exports.processDragLeaveGlobal( event ); // clearing all other highlights triggered due to file drag in global area\n\n    if( isCurrentTargetOverGlobalArea ) {\n        if( exports.dataTransferContainsURLs( event ) ) {\n            _setDropEffect( event, 'copy' );\n        } else {\n            _setDropEffect( event, 'none' );\n            event.stopPropagation();\n            event.preventDefault();\n            var allHighlightableTargets = getApplicableContainersFromGlobalArea( event );\n            if( allHighlightableTargets ) {\n                _.forEach( allHighlightableTargets, function( targetElement ) {\n                    eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                        event: event,\n                        isGlobalArea: true,\n                        isHighlightFlag: true,\n                        targetElement: targetElement\n                    } );\n                } );\n            }\n        }\n    } else {\n        if( exports.isValidObjectToDrop( event ) ) {\n            eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n                event: event,\n                isGlobalArea: false,\n                isHighlightFlag: true,\n                targetElement: _findDropTargetElement( event )[ 0 ]\n            } );\n            _setDropEffect( event, 'copy' ); // when dragged object is on a valid container, the dragged effect should be \\'Copy\\'\n            event.stopPropagation();\n            event.preventDefault();\n        } else { // this ensures if the drop target is an applicable one however not a valid one , all the highlights are gone and a no drop cursor is shown\n            _setDropEffect( event, 'none' );\n            event.dataTransfer.effectAllowed = 'none';\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }\n};\n\n/**\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nexport let processDrop = function( event, callbackAPIs ) {\n    event.stopPropagation();\n    event.preventDefault();\n\n    var targetElement = _findDropTargetElement( event )[ 0 ];\n\n    if( !targetElement ) {\n        _clearCachedData();\n        return;\n    }\n\n    eventBus.publish( DRAG_DROP_HIGHLIGHT_EVENT, {\n        event: event,\n        isGlobalArea: false,\n        isHighlightFlag: false,\n        targetElement: targetElement\n    } );\n\n    var sourceUids = exports.getCachedSourceUids();\n    if( sourceUids && sourceUids.length > 0 ) {\n        _dropModelObjects( targetElement, sourceUids, callbackAPIs );\n    } else {\n        var sourceFiles = _getDataTransferSourceFiles( event );\n        if( sourceFiles && sourceFiles.length > 0 && sourceFiles.item( 0 ).size > 0 ) {\n            _dropFiles( targetElement, sourceFiles, callbackAPIs );\n        } else {\n            var dropFolderFailureDocument = localeService.getLoadedTextFromKey( 'dragAndDropMessages.dropFolderFailureDocument' );\n            dropFolderFailureDocument = dropFolderFailureDocument.replace( '{0}', sourceFiles.item( 0 ).name );\n            messagingSvc.showError( dropFolderFailureDocument );\n            _clearCachedData();\n        }\n    }\n};\n\n/**\n * Set the current types of operations that are possible. Must be one of 'none', 'copy', 'copyLink', 'copyMove',\n * 'link', 'linkMove', 'move', 'all' or 'uninitialized'.\n *\n * @param {DragEvent} event - The DragEvent that holds the 'dataTransfer' property to set.\n *\n * @param {String} value - The 'effectAllowed' allowed value to set.\n */\nexport let setEffectAllowed = function( event, value ) {\n    try {\n        event.dataTransfer.effectAllowed = value;\n    } catch ( ex ) {\n        // Do nothing\n    }\n};\n\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various reasons of interaction with the\n *            container/frame:\n *\n * @param {Object} dataProvider - DataProvider for the panelElement\n * <P>\n * getElementViewModelObjectFn: Used to query the 'source' or 'target' ViewModelObject(s) under any given\n * DragEvent.\n * <P>\n * clearSelectionFn: Used to clear all currently selected 'source' objects just before the drop operation is\n * performed.\n * <P>\n * selectResultFn: Used to select the 'target' when the drop operation is complete.\n */\nexport let setupDragAndDrop = function( panelElement, callbackAPIs, dataProvider ) {\n    // Init class here\n    DragAndDropService.instance;\n\n    var jqPanelElement = $( panelElement );\n\n    var showDropAreaAttr = jqPanelElement.attr( 'show-drop-area' );\n    /**\n     * Set valid source types to the target drop element by retrieving from objectSetSource in data provider\n     */\n    var dropContainer = jqPanelElement.hasClass( 'aw-widgets-droppable' ) && !showDropAreaAttr ? jqPanelElement : jqPanelElement.find( DROP_CLASS );\n    if( dropContainer ) {\n        var dropContScope = null; //ngModule.element( dropContainer ).scope();\n        if( dropContScope ) {\n            var sourceType2RelationMap = {};\n            var declViewModel = declUtils.findViewModel( dropContScope, false, null );\n            // ui-grid uses scope.dataprovider and plTable uses scope.dataProvider\n            var dropTableDataProvider = dataProvider || dropContScope.dataprovider || dropContScope.dataProvider;\n\n            if( dropTableDataProvider && dropTableDataProvider.validSourceTypes ) {\n                var objectSetSources = dropTableDataProvider.validSourceTypes.split( ',' );\n                _.forEach( objectSetSources, function( source ) {\n                    var relationSources = source.split( '.' );\n                    var sourceType = relationSources[ 1 ];\n                    if( !sourceType2RelationMap[ sourceType ] ) {\n                        sourceType2RelationMap[ sourceType ] = [];\n\n                        var relationObj = {\n                            relation: relationSources[ 0 ]\n                        };\n\n                        sourceType2RelationMap[ sourceType ] = relationObj;\n                    }\n                } );\n            } else if( declViewModel && declViewModel.vmo ) {\n                // fetch valid source types from paste service for vmo inside decl view model\n                let pasteHandler = DragAndDropService.instance.pasteHandler;\n                if( pasteHandler ) {\n                    sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes( declViewModel.vmo );\n                } else if( _cfgLoadPromise ) {\n                    _cfgLoadPromise.then( function() {\n                        pasteHandler = DragAndDropService.instance.pasteHandler;\n                        sourceType2RelationMap = pasteHandler.getObjectValidSourceTypes( declViewModel.vmo );\n                        dropContainer.data( 'validSourceTypes', sourceType2RelationMap );\n                    } );\n                }\n            }\n\n            dropContainer.data( 'validSourceTypes', sourceType2RelationMap );\n\n            if( declViewModel && declViewModel.vmo ) {\n                // add the decl view model VMO as drop uid on the container\n                dropContainer.data( 'dropuid', declViewModel.vmo.uid );\n            }\n        }\n    }\n\n    callbackAPIs.dragStartFn = function( event ) {\n        if( event ) {\n            /**\n             * Determine some hosting related options at the start.\n             */\n            _includeDataTransfer = appCtxSvc.ctx.aw_host_type !== 'ADOBE';\n            _publishHostingEvents = appCtxSvc.ctx.aw_hosting_enabled;\n\n            // D-52947: Prevent issues when text is highlighted as drag starts. Event.target may be text.\n            if( event.target.nodeName === '#text' ) {\n                jqPanelElement.data( 'dragging', false );\n                event.preventDefault();\n            } else {\n                if( _debug_logEventActivity >= 2 ) {\n                    logger.info( 'dragstart: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n                }\n\n                if( _publishHostingEvents ) {\n                    eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                        type: 'dragstart',\n                        event: event\n                    } );\n                }\n\n                var srcElement = _getEventSource( event );\n                var sourceVMOs = callbackAPIs.getElementViewModelObjectFn( srcElement, false );\n\n                if( sourceVMOs && sourceVMOs.length > 0 ) {\n                    if( _debug_logEventActivity >= 1 ) {\n                        logger.info( 'Source Item UID: ' + _getViewModelObjectName( sourceVMOs[ 0 ] ) );\n                    }\n\n                    $( panelElement ).data( 'dragging', true );\n\n                    var containerId = jqPanelElement.data( 'containerId' );\n\n                    if( !containerId ) {\n                        containerId = Date.now();\n                        jqPanelElement.data( 'containerId', containerId );\n                    }\n\n                    exports.processAWInteropAndHosting( sourceVMOs, containerId.toString() );\n                    exports.updateDragImage( event, sourceVMOs.length );\n\n                    if( !_includeDataTransfer ) {\n                        event.dataTransfer.clearData();\n                    }\n                } else {\n                    // No data so there is no reason to let the object be dragged.\n                    jqPanelElement.data( 'dragging', false );\n                    event.preventDefault();\n                }\n            }\n        }\n    };\n\n    callbackAPIs.dragEndFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragend: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            var element = _getDragElement( event );\n\n            if( element ) {\n                var dragImage = element.getElementsByClassName( 'aw-widgets-multidragimage' )[ 0 ];\n\n                if( dragImage ) {\n                    element.style.position = '';\n                    dragImage.parentNode.removeChild( dragImage );\n                }\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragend',\n                    event: event\n                } );\n            }\n\n            jqPanelElement.data( 'dragging', false );\n        }\n    };\n\n    callbackAPIs.dragOverFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 3 ) {\n                logger.info( 'dragover: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragover',\n                    event: event\n                } );\n            }\n\n            event.stopPropagation();\n            exports.processDragOver( event, false );\n        }\n    };\n\n    callbackAPIs.dragEnterFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragenter: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragenter',\n                    event: event\n                } );\n            }\n            event.preventDefault();\n            event.stopPropagation();\n\n            var target = _findDropTargetElement( event )[ 0 ];\n            if( !target ) {\n                return;\n            }\n\n            if( exports.isValidObjectToDrop( event ) ) {\n                var targetVMOs = callbackAPIs.getElementViewModelObjectFn( target, true );\n\n                if( targetVMOs && targetVMOs.length > 0 ) {\n                    if( _debug_logEventActivity >= 1 ) {\n                        logger.info( 'Target Item Name: ' + _getViewModelObjectName( targetVMOs[ 0 ] ) );\n                    }\n\n                    var debounceProcessDragEnter = _.debounce( exports.processDragEnter, 100 );\n                    debounceProcessDragEnter( event, targetVMOs[ 0 ] );\n                }\n            }\n        }\n    };\n\n    callbackAPIs.dragLeaveFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'dragleave: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'dragleave',\n                    event: event\n                } );\n            }\n\n            var debounceProcessDragLeave = _.debounce( exports.processDragLeave, 100 );\n\n            debounceProcessDragLeave( event );\n        }\n    };\n\n    callbackAPIs.dropFn = function( event ) {\n        if( event ) {\n            if( _debug_logEventActivity >= 2 ) {\n                logger.info( 'drop: ' + '\\n' + JSON.stringify( event, null, 2 ) );\n            }\n\n            if( _publishHostingEvents ) {\n                eventBus.publish( HOSTING_DRAG_DROP_EVENT, {\n                    type: 'drop',\n                    event: event\n                } );\n            }\n\n            jqPanelElement.data( 'dragging', false );\n\n            exports.processDrop( event, callbackAPIs );\n        }\n    };\n\n    panelElement.addEventListener( 'dragstart', callbackAPIs.dragStartFn );\n    panelElement.addEventListener( 'dragend', callbackAPIs.dragEndFn );\n    panelElement.addEventListener( 'dragover', callbackAPIs.dragOverFn );\n    panelElement.addEventListener( 'dragenter', callbackAPIs.dragEnterFn );\n    panelElement.addEventListener( 'dragleave', callbackAPIs.dragLeaveFn );\n    panelElement.addEventListener( 'drop', callbackAPIs.dropFn );\n};\n\nexport let dragLeaveEventOnGlobalWindow = function( event ) {\n    processDragLeaveGlobal( event );\n    if( exports.dataTransferContainsFiles( event ) ) { //\n        _clearCachedData();\n    }\n};\n\n/**\n * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the\n * 'target'.\n *\n * @param {DragEvent} event - The drag event with the 'target' to process.\n *\n * @param {ViewModelObject} targetVMO - The ViewModelObject associated with the given event's 'target' DOM\n *            Element.\n */\nexport let processDragEnter = function( event, targetVMO ) {\n    /**\n     * Look 'up' the DOM Element tree (starting at the given event's 'target') looking for the 1st 'droppable'\n     * element (i.e. the 'drop container').\n     */\n    var currElement = _findDropTargetElement( event )[ 0 ];\n    _setValidSourceTypesOnTarget( currElement, targetVMO );\n    event.preventDefault();\n};\n\nexport let dragEndEventOnGlobalWindow = function( event ) {\n    processDragLeaveGlobal( event );\n};\n/**\n * @param {Element} panelElement - The DOM element that is the overall container/frame for a collection of\n *            'source' and 'target' objects.\n *\n * @param {Object} callbackAPIs - Callback functions used for various interaction reasons.\n */\nexport let tearDownDragAndDrop = function( panelElement, callbackAPIs ) {\n    if( callbackAPIs.dragStartFn ) {\n        panelElement.removeEventListener( 'dragstart', callbackAPIs.dragStartFn );\n        panelElement.removeEventListener( 'dragend', callbackAPIs.dragEndFn );\n        panelElement.removeEventListener( 'dragover', callbackAPIs.dragOverFn );\n        panelElement.removeEventListener( 'dragenter', callbackAPIs.dragEnterFn );\n        panelElement.removeEventListener( 'dragleave', callbackAPIs.dragLeaveFn );\n        panelElement.removeEventListener( 'drop', callbackAPIs.dropFn );\n\n        callbackAPIs.dragStartFn = null;\n        callbackAPIs.dragEndFn = null;\n        callbackAPIs.dragOverFn = null;\n        callbackAPIs.dragEnterFn = null;\n        callbackAPIs.dragLeaveFn = null;\n        callbackAPIs.dropFn = null;\n    }\n};\n\n/**\n * Update the drag image for the DragEvent based on the number of objects being dragged.\n *\n * @param {DragEvent} event - The DragEvent to set the image on.\n *\n * @param {Number} count - The number of objects being dragged\n */\nexport let updateDragImage = function( event, count ) {\n    /**\n     * Internet Explorer doesn't support setDragImage at all (and some 'hosts' do not want 'dataTransfer').\n     * <P>\n     * See: http://mereskin.github.io/dnd/\n     */\n    if( !browserUtils.isIE && _includeDataTransfer ) {\n        /**\n         * The NX web browser (QT?) currently has a problem with child elements containing float elements. This\n         * should be resolved after moving the list view to a flex display.\n         */\n        var dragImage;\n\n        if( _isNxWebBrowser() ) {\n            dragImage = _getFirstChildImage( event.target );\n        } else if( count > 1 ) {\n            dragImage = _getMultiDragImage( event, count );\n        } else {\n            dragImage = _getDragElement( event, 1 );\n        }\n\n        if( dragImage ) {\n            event.dataTransfer.setDragImage( dragImage, 0, 0 );\n        }\n    }\n};\n\n/**\n * Return the target model object for given UID\n *\n * @param {String} uid - UID of the modelObject on which source objects are dragged\n * @return {Object} Modelobject on which source objects are dragged\n */\nexport let getTargetObjectByUid = function( uid ) {\n    return cdm.getObject( uid );\n};\n\n/**\n * Return an array of viewModelObjects that contains all currently selected viewModelObjects if the given UID is\n * contained in the set of selected viewModelObjects.\n *\n * @param {Object} dataProvider - data provider\n * @param {String} dragUID - UID of the modelObject being dragged.\n * @return {Array} array of viewModelObjects that are being dragged.\n */\nexport let getSourceObjects = function( dataProvider, dragUID ) {\n    var sourceObjs = [];\n    if( !dataProvider ) {\n        return sourceObjs;\n    }\n\n    var selectObjects = dataProvider.getSelectedObjects();\n    /**\n     * Check if the given UID is in the current set of selected objects.\n     */\n    var found = false;\n\n    if( selectObjects && selectObjects.length > 0 ) {\n        // eslint-disable-next-line consistent-return\n        _.forEach( selectObjects, function( selObj ) {\n            if( selObj.uid === dragUID ) {\n                found = true;\n                return false;\n            }\n        } );\n    }\n\n    if( found ) {\n        sourceObjs = _.clone( selectObjects );\n    }\n\n    return sourceObjs;\n};\n\n/**\n * Look for support of the 'files' in the 'dataTranfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'files' property is found in the 'dataTransfer' property of the event.\n */\nexport let dataTransferContainsFiles = function( event ) {\n    if( event.dataTransfer ) {\n        var types = event.dataTransfer.types;\n\n        if( types ) {\n            for( var i = 0; i < types.length; ++i ) {\n                if( types[ i ] === 'Files' ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * Look for support of the 'urls' in the 'dataTransfer' area of the event.\n *\n * @param {DragEvent} event - The event to test.\n *\n * @return {boolean} TRUE if the 'text/html' property is found in the 'dataTransfer' property of the event.\n */\nexport let dataTransferContainsURLs = function( event ) {\n    if( event.dataTransfer ) {\n        var types = event.dataTransfer.types;\n        if( types ) {\n            for( var i = 0; i < types.length; ++i ) {\n                if( types[ i ] === 'text/html' ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * @param {DragEvent} event - The event to extract the files types from the 'dataTransfer' property.\n *\n * @return {StringArray} The set of unique file types.\n */\nexport let getDataTransferFileTypes = function( event ) {\n    var dtTypes = [];\n\n    if( event.dataTransfer.items ) {\n        var itemObjs = event.dataTransfer.items;\n\n        if( itemObjs ) {\n            for( var i = 0; i < itemObjs.length; i++ ) {\n                var fileExt = _getDataTransferType( itemObjs[ i ].type );\n\n                if( fileExt && dtTypes.indexOf( fileExt ) === -1 ) {\n                    dtTypes.push( fileExt );\n                }\n            }\n        }\n    }\n\n    return dtTypes;\n};\n\n/**\n * Returns underlying Object for the given 'source' type.\n *\n * @param {String} targetUID - The UID of the IModelObject that will be the dropped onto (i.e. the data\n *            'target').\n *\n * @param {StringArray} fileTypes - The array with the set of unique file types.\n *\n * @return {Promise} A Promise that will be 'resolved' or 'rejected' when the service is invoked and its\n *         response data is available.\n */\nexport let getDataTransferSourceTypes = function( targetUID, fileTypes ) {\n    var targetObject = cdm.getObject( targetUID );\n\n    var request = {\n        parent: targetObject,\n        fileExtensions: fileTypes\n    };\n\n    return soaSvc.postUnchecked( 'Internal-AWS2-2015-10-DataManagement', 'getDatasetTypesWithDefaultRelation',\n        request ).then(\n        function( response ) {\n            if( response.partialErrors || response.PartialErrors || response.ServiceData &&\n                response.ServiceData.partialErrors ) {\n                return [];\n            }\n\n            var dsTypes = [];\n\n            var output = response.output;\n\n            if( output ) {\n                for( var i = 0; i < output.length; i++ ) {\n                    var dsInfos = output[ i ].datasetTypesWithDefaultRelInfo;\n\n                    if( dsInfos ) {\n                        const j = 0;\n                        var dsInfo = dsInfos[ j ];\n                        var dsUid = dsInfo.datasetType.uid;\n\n                        var dsType = cdm.getObject( dsUid );\n\n                        var type = dsType.props.object_string.dbValues[ 0 ];\n\n                        dsTypes.push( type );\n                    }\n                }\n            }\n\n            return soaSvc.ensureModelTypesLoaded( dsTypes ).then( function() {\n                return dsTypes;\n            } );\n        },\n        function( e ) {\n            logger.trace( e );\n            return [];\n        } );\n};\n\n/**\n * Set a callback function to use to encode 'source' objects in support of hosting.\n *\n * @param {Function} callBackFn - Function used to create InteropObjectRefs that are added to the information\n *            carried for 'source' objects in dragEvents.\n */\nexport let setCreateInteropObjectRef = function( callBackFn ) {\n    _createInteropObjectRefFn = callBackFn;\n};\n\n/**\n * Publish a 'drop' topic on the 'paste' channel of the Native JS 'eventBus' with the given data.\n *\n * @param {ObjectArray} pasteInput - An array of objects that maps a unique 'relationType' to the array of\n *            'sourceObjects' {@link IModelObject} s that should be pasted onto the 'targetObject' with that\n *            'relationType'.\n */\nexport let publishDropEvent = function( pasteInput ) {\n    eventBus.publishOnChannel( {\n        channel: 'paste',\n        topic: 'drop',\n        data: {\n            pasteInput: pasteInput\n        }\n    } );\n};\n\nconst _globalDragEnterAndOver = ( event ) => {\n    exports.processDragOver( event, true );\n};\n\nexport let registerEvents = function() {\n    // LCS-148724 , Adding listeners to global area i.e the area outside panelElement of setupDragAndDrop() function\n    document.body.addEventListener( 'dragenter', function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        if( !_isDragWithinApplicableValidContainer( event ) || _isDragOverChooseOrDropFileContainer( event ) ) {\n            // below check is to avoid global dragenter events in turn flickering highlight when within a table or list\n            if( !_isDragWithinTableContainer( event ) && !_isDragWithinCellListContainer( event ) ) {\n                if( _debug_logEventActivity >= 1 ) {\n                    logger.info( 'GLOBAL DRAG ENTER EVENT, DRAG NOT WITHIN A TABLE, NOT ALLOWED cursor should be shown => tag name :' + event.target.tagName );\n                }\n                _setDropEffect( event, 'none' ); // to avoid 'Copy' cursor feedback when file just enters the page\n                _globalDragEnterAndOver( event );\n            } else {\n                if( _debug_logEventActivity >= 1 ) {\n                    logger.info( 'GLOBAL DRAG ENTER EVENT, DRAG WITHIN A TABLE, COPY cursor should be shown => tag name :' + event.target.tagName );\n                }\n                _setDropEffect( event, 'copy' );\n            }\n        }\n    } );\n    document.body.addEventListener( 'dragover', function( event ) {\n        if( !_isDragWithinApplicableValidContainer( event ) || _isDragOverChooseOrDropFileContainer( event ) ) {\n            if( _debug_logEventActivity >= 1 ) {\n                logger.info( 'GLOBAL DRAG OVER EVENT ' );\n            }\n            _globalDragEnterAndOver( event );\n        }\n    } );\n    document.body.addEventListener( 'dragleave', function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info(\n                'GLOBAL DRAG LEAVE EVENT, Object either dragged outside the global window OR over an applicable valid container on the page OR over an applicable invalid container on the page'\n            );\n        }\n        if( _isDragCancelled( event ) ) {\n            isGlobalHighlightPublished = false;\n            exports.dragLeaveEventOnGlobalWindow( event );\n        }\n    } );\n    document.body.addEventListener( 'dragend', function( event ) {\n        if( _debug_logEventActivity >= 1 ) {\n            logger.info( 'GLOBAL DRAG END EVENT ' );\n        }\n        isGlobalHighlightPublished = false;\n        exports.dragEndEventOnGlobalWindow( event );\n    } );\n};\n\nexport const disableDragAndDrop = ( panelElement ) => {\n    const stopEventBubbling = ( event ) => {\n        event.stopPropagation();\n    };\n\n    const setDropEffectNone = ( event ) => {\n        stopEventBubbling( event );\n        event.dataTransfer.dropEffect = 'none';\n    };\n\n    panelElement.addEventListener( 'dragover', setDropEffectNone );\n    panelElement.addEventListener( 'dragenter', stopEventBubbling );\n    panelElement.addEventListener( 'dragleave', stopEventBubbling );\n    panelElement.addEventListener( 'drop', stopEventBubbling );\n};\n\nexports = {\n    disableDragAndDrop,\n    addDragDataToDragEvent,\n    getCachedSourceUids,\n    isValidObjectToDrop,\n    processAWInteropAndHosting,\n    processDragEnd,\n    processDragLeave,\n    processDragLeaveGlobal,\n    processDrop,\n    setEffectAllowed,\n    setupDragAndDrop,\n    dragLeaveEventOnGlobalWindow,\n    dragEndEventOnGlobalWindow,\n    tearDownDragAndDrop,\n    updateDragImage,\n    getTargetObjectByUid,\n    getSourceObjects,\n    dataTransferContainsFiles,\n    dataTransferContainsURLs,\n    getDataTransferFileTypes,\n    getDataTransferSourceTypes,\n    setCreateInteropObjectRef,\n    publishDropEvent,\n    registerEvents,\n    processDragOver,\n    processDragEnter\n};\nexport default exports;\n\n/*\n * Register the global drag and drop events only for AW.\n */\nif( appCtxSvc.ctx && appCtxSvc.ctx.tcSessionData ) {\n    //registerEvents();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}