{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\n// Copyright (c) 2021 Siemens\n\n/**\n * @module js/lovProviderUtils\n */\nimport { useEffect, useRef } from 'react';\nimport appCtxSvc from 'js/appCtxService';\nimport { useInitHook } from 'js/reactHelper';\nimport { useDataProvider } from 'js/dataProviderUtils';\nimport { loadAction, validateLovAction, createDynamicDataProvider } from 'js/dataProviderFactory';\n/**\n *  This particular hook is specific to dynamic dataprovider for LOV means not applicable for static dataprovider LOVS\n * @param {} dataProvider\n * @param {*} viewModel\n */\n\nconst useDynamicDataProviderForLOV = (dataProvider, viewModel, prop) => {\n  _s();\n\n  dataProvider.vmCollectionObj = useDataProvider(dataProvider).vmCollectionObj; // align dataCtxNode , check declViewModelProcessingFactory.js L216\n\n  let initial = {\n    data: viewModel\n  };\n  let dataCtxNode = useRef(initial); // dataCtxNode should be reactive,\n  // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/887\n  // update the viewModel and prop accordingly\n\n  dataCtxNode.current.data = viewModel;\n\n  if (prop) {\n    dataCtxNode.current.parameters = {\n      prop\n    };\n  }\n\n  useEffect(() => {\n    if (!dataProvider.loadAction && !dataProvider.validateLovAction) {\n      dataProvider.loadAction = async (vmCollection, startIndex, pageObject) => {\n        return loadAction(dataProvider, dataCtxNode.current, vmCollection, startIndex, pageObject);\n      };\n\n      dataProvider.validateLovAction = async input => {\n        return validateLovAction(input, dataProvider, dataCtxNode.current);\n      };\n    }\n\n    return () => {\n      if (dataProvider) {\n        dataProvider.destroy();\n      }\n    };\n  }, []);\n};\n\n_s(useDynamicDataProviderForLOV, \"fzeM+v8DBqsqwdkOxZwj9TrwzoY=\", false, function () {\n  return [useDataProvider];\n});\n\nconst useDataProviderInLovPopup = prop => {\n  _s2();\n\n  //OnMount\n  let currentLovEntry = null;\n  let dataProvider = prop.dataProvider;\n  /**\n   * This ref brings mutually exclusive behavior between init and useEffect hook.\n   * It prevents multiple REST calls.\n   */\n\n  let exclusiveHook = useRef({});\n  let lovConfig = useRef({});\n  currentLovEntry = {\n    propDisplayValue: prop.field.fielddata.uiValue,\n    propInternalValue: prop.field.typex === 'DATETIME' || prop.field.typex === 'DATE' ? Date.parse(prop.field.value) : String(prop.field.value)\n  }; // If the LOV type is checkbox array , then the UI value is never updated manually.\n  // It is updated by selecting on the checkbox.\n  // Hence, we never need to do the filtering.\n  // For checkboxarray lov filtering is done from another textbox which appears inside the LOV popup.\n  // So, added a check to make sure filtering never changes for checkbox array LOVs.\n\n  let filterString = prop.staticFilterStr;\n  lovConfig.current = {\n    filterString\n  };\n  useInitHook(() => {\n    if (dataProvider) {\n      exclusiveHook.current = {\n        isExecuted: true\n      };\n      dataProvider.resetDataProvider({});\n      dataProvider.selectionModel.setSelection(currentLovEntry); // TODO: how to support auto focus selection??\n      // reset attention\n\n      prop.selectIndex && (prop.selectIndex.current = null);\n      let lovInfo = {\n        ctxLovPropName: prop.field.name,\n        ctxLovPropVMO: prop.field.vmo\n      };\n      appCtxSvc.registerCtx('aw.lovInfo', lovInfo);\n    }\n  });\n  useEffect(() => {\n    let timeout = setTimeout(() => {\n      if (dataProvider && !exclusiveHook.current.isExecuted) {\n        // reset attention\n        prop.selectIndex && (prop.selectIndex.current = null);\n        dataProvider.resetDataProvider();\n      }\n    }, 500);\n    return () => {\n      exclusiveHook.current = {\n        isExecuted: false\n      };\n      clearTimeout(timeout);\n    };\n  }, [dataProvider, lovConfig.current.filterString]);\n};\n\n_s2(useDataProviderInLovPopup, \"YjzdMXH0Z00gUog6+eGmeLV/egQ=\", false, function () {\n  return [useInitHook];\n});\n\nexport const useLOVs = function (fields, prop, viewModel) {\n  _s3();\n\n  let {\n    elementRefList\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // useInit( () => {\n  //     if( viewModel.data.name === 'dataProviderLOV' ) {\n  //         useDynamicDataProviderForLOV( dataProvider, viewModel, prop );\n  //     }\n  // });\n  let lovEntryRef = useRef(null);\n\n  if (prop.lovlist) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useDataProviderInLovPopup(prop);\n  }\n\n  if (viewModel.data.name === 'dataProviderLOV') {\n    let dataProvider = prop.fielddata.dataProvider ? prop.fielddata.dataProvider : elementRefList.get('dynDataprovider').current;\n\n    if (!dataProvider) {\n      dataProvider = prop.isListbox ? createDynamicDataProvider(1) : createDynamicDataProvider();\n      elementRefList.get('dynDataprovider').current = dataProvider;\n    }\n\n    if (dataProvider.getLovEntryRef() === null) {\n      dataProvider.setLovEntryRef(lovEntryRef);\n    } //The hook is being called conditionally since it is only supposed to be invoked for dynamic dataproviders\n    //It is made sure that the dataprovider is always available before this stage\n    //thereby providing a gaurantee that the hooks will always be invoked in the same order for a particular component\n\n\n    if (dataProvider.dynamicDp) {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useDynamicDataProviderForLOV(dataProvider, viewModel, prop);\n    }\n  }\n};\n\n_s3(useLOVs, \"JDiuWoHUF1Kmv6CsM9IBzjXmX/o=\", false, function () {\n  return [useDataProviderInLovPopup, useDynamicDataProviderForLOV];\n});\n\nexport default {\n  useLOVs\n};","map":{"version":3,"names":["useEffect","useRef","appCtxSvc","useInitHook","useDataProvider","loadAction","validateLovAction","createDynamicDataProvider","useDynamicDataProviderForLOV","dataProvider","viewModel","prop","vmCollectionObj","initial","data","dataCtxNode","current","parameters","vmCollection","startIndex","pageObject","input","destroy","useDataProviderInLovPopup","currentLovEntry","exclusiveHook","lovConfig","propDisplayValue","field","fielddata","uiValue","propInternalValue","typex","Date","parse","value","String","filterString","staticFilterStr","isExecuted","resetDataProvider","selectionModel","setSelection","selectIndex","lovInfo","ctxLovPropName","name","ctxLovPropVMO","vmo","registerCtx","timeout","setTimeout","clearTimeout","useLOVs","fields","elementRefList","lovEntryRef","lovlist","get","isListbox","getLovEntryRef","setLovEntryRef","dynamicDp"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/lovProviderUtils.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/lovProviderUtils\n */\nimport { useEffect, useRef } from 'react';\nimport appCtxSvc from 'js/appCtxService';\nimport { useInitHook } from 'js/reactHelper';\nimport { useDataProvider } from 'js/dataProviderUtils';\nimport { loadAction, validateLovAction, createDynamicDataProvider } from 'js/dataProviderFactory';\n\n/**\n *  This particular hook is specific to dynamic dataprovider for LOV means not applicable for static dataprovider LOVS\n * @param {} dataProvider\n * @param {*} viewModel\n */\nconst useDynamicDataProviderForLOV = ( dataProvider, viewModel, prop ) => {\n    dataProvider.vmCollectionObj = useDataProvider( dataProvider ).vmCollectionObj;\n    // align dataCtxNode , check declViewModelProcessingFactory.js L216\n    let initial = { data: viewModel };\n    let dataCtxNode = useRef( initial );\n\n    // dataCtxNode should be reactive,\n    // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/887\n    // update the viewModel and prop accordingly\n    dataCtxNode.current.data = viewModel;\n    if( prop ) {\n        dataCtxNode.current.parameters = { prop };\n    }\n\n    useEffect( () => {\n        if( !dataProvider.loadAction && !dataProvider.validateLovAction ) {\n            dataProvider.loadAction = async( vmCollection, startIndex, pageObject ) => {\n                return loadAction( dataProvider, dataCtxNode.current, vmCollection, startIndex, pageObject );\n            };\n            dataProvider.validateLovAction = async( input ) => {\n                return validateLovAction( input, dataProvider, dataCtxNode.current );\n            };\n        }\n        return () => {\n            if( dataProvider ) {\n                dataProvider.destroy();\n            }\n        };\n    }, [] );\n};\n\nconst useDataProviderInLovPopup = ( prop ) => {\n    //OnMount\n    let currentLovEntry = null;\n    let dataProvider = prop.dataProvider;\n    /**\n     * This ref brings mutually exclusive behavior between init and useEffect hook.\n     * It prevents multiple REST calls.\n     */\n    let exclusiveHook = useRef( {} );\n    let lovConfig = useRef( {} );\n    currentLovEntry = {\n        propDisplayValue: prop.field.fielddata.uiValue,\n        propInternalValue: prop.field.typex === 'DATETIME' || prop.field.typex === 'DATE' ? Date.parse( prop.field.value ) : String( prop.field.value )\n    };\n\n    // If the LOV type is checkbox array , then the UI value is never updated manually.\n    // It is updated by selecting on the checkbox.\n    // Hence, we never need to do the filtering.\n    // For checkboxarray lov filtering is done from another textbox which appears inside the LOV popup.\n    // So, added a check to make sure filtering never changes for checkbox array LOVs.\n    let filterString = prop.staticFilterStr;\n    lovConfig.current = { filterString };\n    useInitHook( () => {\n        if( dataProvider ) {\n            exclusiveHook.current = { isExecuted: true };\n            dataProvider.resetDataProvider( {} );\n            dataProvider.selectionModel.setSelection( currentLovEntry );\n\n            // TODO: how to support auto focus selection??\n            // reset attention\n            prop.selectIndex && ( prop.selectIndex.current = null );\n\n            let lovInfo = {\n                ctxLovPropName: prop.field.name,\n                ctxLovPropVMO: prop.field.vmo\n            };\n            appCtxSvc.registerCtx( 'aw.lovInfo', lovInfo );\n        }\n    } );\n    useEffect( () => {\n        let timeout = setTimeout( () => {\n            if( dataProvider && !exclusiveHook.current.isExecuted ) {\n                // reset attention\n                prop.selectIndex && ( prop.selectIndex.current = null );\n                dataProvider.resetDataProvider();\n            }\n        }, 500 );\n        return () => {\n            exclusiveHook.current = { isExecuted: false };\n            clearTimeout( timeout );\n        };\n    }, [ dataProvider, lovConfig.current.filterString ] );\n};\n\nexport const useLOVs = ( fields, prop, viewModel, { elementRefList } = {} ) => {\n    // useInit( () => {\n    //     if( viewModel.data.name === 'dataProviderLOV' ) {\n    //         useDynamicDataProviderForLOV( dataProvider, viewModel, prop );\n    //     }\n    // });\n    let lovEntryRef = useRef( null );\n    if( prop.lovlist ) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useDataProviderInLovPopup( prop );\n    }\n    if( viewModel.data.name === 'dataProviderLOV' ) {\n        let dataProvider = prop.fielddata.dataProvider ? prop.fielddata.dataProvider : elementRefList.get( 'dynDataprovider' ).current;\n        if( !dataProvider ) {\n            dataProvider = prop.isListbox ? createDynamicDataProvider( 1 ) : createDynamicDataProvider();\n            elementRefList.get( 'dynDataprovider' ).current = dataProvider;\n        }\n        if( dataProvider.getLovEntryRef() === null ) {\n            dataProvider.setLovEntryRef( lovEntryRef );\n        }\n        //The hook is being called conditionally since it is only supposed to be invoked for dynamic dataproviders\n        //It is made sure that the dataprovider is always available before this stage\n        //thereby providing a gaurantee that the hooks will always be invoked in the same order for a particular component\n        if( dataProvider.dynamicDp ) {\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            useDynamicDataProviderForLOV( dataProvider, viewModel, prop );\n        }\n    }\n};\n\nexport default {\n    useLOVs\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}