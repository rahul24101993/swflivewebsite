{"ast":null,"code":"// Copyright (c) 2022 Siemens\n\n/* eslint-disable sonarjs/cognitive-complexity */\n\n/**\n * This is the Teamcenter SOA Service. It's the central pipeline for invoking JSON SOA APIs & FMS APIs from the client.\n *\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/soaService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwHttpService from 'js/awHttpService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport propPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport typeCacheSvc from 'soa/kernel/typeCacheService';\nimport configSvc from 'js/configurationService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport localStrg from 'js/localStorage';\n/**\n * Boolean to indicate if we're signed into the server. This is just an observer state. True signin state is\n * managed by the Session Manager.\n *\n * @private\n */\n\nlet _signedIn = false;\n/**\n * Date/Time of the last progress 'start'. This is used to compute the amount of time a single SOA post takes.\n *\n * @private\n */\n\nconst _lastStartDate = {};\n/**\n * List of type names which have been deemed invalid based upon the previous server responses.\n *\n * @private\n */\n\nlet _invalidTypeNames = ['contents'];\n/**\n * Types that need loaded if available.\n * On AW startup.\n * @private\n */\n\nlet _awStartupPreferences;\n/**\n * Types cache timestamp\n *\n * @private\n */\n\n\nlet _typeCacheLMD;\n/**\n * Regular expression used to test if a string ends with \"[]\"\n */\n\n\nconst REGEX_ARRAY_SUFFIX = /\\[\\]$/i;\n/**\n * Constant for operation name used for get TC Session Info\n *\n * @type {string}\n */\n\nconst GET_SESSION_INFO = {\n  serviceName: 'Internal-AWS2-2017-12-DataManagement',\n  operationName: 'getTCSessionAnalyticsInfo'\n};\n/**\n * SOA redirect\n */\n\nlet _redirectSoaSvc;\n\nexport const setSoaRedirect = function (redirect) {\n  _redirectSoaSvc = redirect;\n};\n/** Debug trace function */\n\nconst trace = new Debug('soaService');\n/** Object to track which types are currently being loaded such that getTypeDescriptions2 is not duplicated for the same type */\n\nconst _typeLoadInProgress = {};\n/** client ID used in SOA header */\n\nlet _clientId = 'ActiveWorkspaceClient';\n/** timeout to allow polling SOA calls to be made after last non-polling call */\n\nlet _pollingTimeout = 15 * 60; // 15 minutes default\n\n\nlet pendingRequests = 0;\n/**\n * Initialize 'bodyElement[key]' based on given information.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @param {String} key - key\n * @param {Boolean} deleted - was the key just deleted?\n */\n\nfunction initializeField(state, typeName, bodyElement, key, deleted) {\n  switch (typeName) {\n    case 'String':\n    case 'Date':\n      bodyElement[key] = '';\n      break;\n\n    case 'int':\n    case 'float':\n    case 'double':\n      bodyElement[key] = 0;\n      break;\n\n    case 'boolean':\n      bodyElement[key] = false;\n      break;\n\n    case 'ModelObj':\n    case 'ModelObject':\n      bodyElement[key] = {\n        uid: deleted ? cdm.NULL_UID : '',\n        type: deleted ? 'unknownType' : ''\n      };\n      break;\n\n    default:\n      if (REGEX_ARRAY_SUFFIX.test(typeName)) {\n        // Array\n        bodyElement[key] = [];\n      } else if (state.schemaService.hasOwnProperty(typeName) && _.isArray(state.schemaService[typeName])) {\n        // Enum support... default to first entry\n        bodyElement[key] = state.schemaService[typeName][0];\n      } else {\n        // Object or map\n        bodyElement[key] = {};\n      }\n\n  }\n}\n/**\n * TRUE if the given element is in the schema.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element to evaluate to determine if element should be a map\n *\n * @returns {Boolean} TRUE if the given element is in the schema.\n */\n\n\nfunction isMap(state, schemaElement) {\n  if (Object.keys(schemaElement).length === 2 && schemaElement.hasOwnProperty('key') && schemaElement.hasOwnProperty('value') && !state.schemaService.hasOwnProperty(schemaElement.key)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate element type & recurse if non-trivial type.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @returns {Object} ...\n */\n\n\nfunction validateElementType(state, typeName, bodyElement) {\n  // eslint-disable-line complexity\n  switch (typeName) {\n    case 'String':\n    case 'Date':\n      if (!_.isString(bodyElement)) {\n        state.issues.push('INVALID FIELD: Expected string, not ' + typeof bodyElement + ' --' + state.stack.join('.'));\n      }\n\n      break;\n\n    case 'int':\n    case 'float':\n    case 'double':\n      if (!_.isNumber(bodyElement)) {\n        state.issues.push('INVALID FIELD: Expected number, not ' + typeof bodyElement + ' --' + state.stack.join('.'));\n      }\n\n      break;\n\n    case 'boolean':\n      if (!_.isBoolean(bodyElement)) {\n        state.issues.push('INVALID FIELD: Expected boolean, not ' + typeof bodyElement + ' --' + state.stack.join('.'));\n      }\n\n      break;\n\n    case 'ModelObj':\n    case 'ModelObject':\n      if (!bodyElement || !bodyElement.uid || !bodyElement.type) {\n        return {\n          uid: !bodyElement || !bodyElement.uid ? cdm.NULL_UID : bodyElement.uid,\n          type: !bodyElement || !bodyElement.type ? 'unknownType' : bodyElement.type\n        };\n      }\n\n      if (Object.keys(bodyElement).length !== 2) {\n        // replace with new object if it's not already uid & type only\n        return {\n          uid: bodyElement.uid,\n          type: bodyElement.type\n        };\n      }\n\n      break;\n\n    case 'ICreateInput':\n      if (!bodyElement || !bodyElement.boName || !_.isString(bodyElement.boName)) {\n        state.issues.push('INVALID FIELD VALUE: Expect type of ICreateInput');\n      }\n\n      break;\n\n    default:\n      if (state.schemaService.hasOwnProperty(typeName)) {\n        if (_.isArray(state.schemaService[typeName])) {\n          // Enum\n          if (state.schemaService[typeName].indexOf(bodyElement) === -1) {\n            state.issues.push('INVALID FIELD VALUE: Not valid enum value ' + typeName + ' expected ' + state.schemaService[typeName].toString() + ' --' + state.stack.join('.'));\n          }\n        } else {\n          // Object processing\n          defaultAndValidateElementRecurse(state, state.schemaService[typeName], bodyElement);\n        }\n      } else if (REGEX_ARRAY_SUFFIX.test(typeName)) {\n        // Array processing\n        if (!_.isArray(bodyElement)) {\n          state.issues.push('INVALID FIELD: Expected array, not ' + typeof bodyElement + ' --' + state.stack.join('.'));\n          return undefined;\n        }\n\n        const typeName2 = typeName.substring(0, typeName.length - 2);\n        let replacementArray = null;\n\n        for (let ii = bodyElement.length - 1; ii >= 0; ii--) {\n          state.stack.push(ii);\n          const replacement = validateElementType(state, typeName2, bodyElement[ii]);\n\n          if (replacement) {\n            if (!replacementArray) {\n              // we should probably replace the array in case caller is using for something else...\n              replacementArray = bodyElement.slice(0);\n            }\n\n            replacementArray[ii] = replacement;\n          }\n\n          state.stack.pop();\n        }\n\n        if (replacementArray) {\n          return replacementArray;\n        }\n      } else if (/^(String|Int|Bool|Double|Float|Date|Tag)(|Vector)Map/.test(typeName)) {\n        // Map processing\n        let typeName2;\n\n        if (typeName.indexOf('String') === 0) {\n          typeName2 = 'String';\n        } else if (typeName.indexOf('Date') === 0) {\n          typeName2 = 'Date';\n        } else if (typeName.indexOf('Int') === 0) {\n          typeName2 = 'int';\n        } else if (typeName.indexOf('Float') === 0) {\n          typeName2 = 'float';\n        } else if (typeName.indexOf('Double') === 0) {\n          typeName2 = 'double';\n        } else if (typeName.indexOf('Bool') === 0) {\n          typeName2 = 'boolean';\n        } else if (typeName.indexOf('Tag') === 0) {\n          typeName2 = 'ModelObject';\n        }\n\n        if (/VectorMap/g.test(typeName)) {\n          typeName2 += '[]';\n        }\n\n        _.forEach(bodyElement, function (value, key) {\n          let valueFinal = value;\n\n          if (!_.isString(key)) {\n            state.issues.push('INVALID FIELD: Expected string, not ' + typeof key + ' --' + state.stack.join('.'));\n            return;\n          }\n\n          if (typeName2) {\n            if (!bodyElement[key]) {\n              initializeField(state, typeName2, bodyElement, key, false);\n              valueFinal = bodyElement[key];\n            }\n\n            if (typeName2) {\n              if (!bodyElement[key]) {\n                initializeField(state, typeName2, bodyElement, key, false);\n                valueFinal = bodyElement[key];\n              }\n\n              state.stack.push(key);\n              const replacement = validateElementType(state, typeName2, valueFinal);\n\n              if (replacement) {\n                bodyElement[key] = replacement;\n              }\n\n              state.stack.pop();\n            } else {\n              state.issues.push('INVALID FIELD: Unsupported map type of ' + typeName + ' --' + state.stack.join('.'));\n            }\n\n            state.stack.pop();\n          } else {\n            state.issues.push('INVALID FIELD: Unsupported map type of ' + typeName + ' --' + state.stack.join('.'));\n          }\n        });\n      } else {\n        state.issues.push('INVALID FIELD: Unsupported type of ' + typeName + ' --' + state.stack.join('.'));\n      }\n\n  }\n}\n/**\n * Recursive method for default & validate SOA operation body.\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element/cursor for the walk\n * @param {Object} bodyElement - body element/cursor for the walk\n * @private\n */\n\n\nfunction defaultAndValidateElementRecurse(state, schemaElement, bodyElement) {\n  // Walk schema to add any missing fields\n  const isMapLcl = isMap(state, schemaElement);\n\n  if (!isMapLcl) {\n    _.forEach(schemaElement, function (typeName, key2) {\n      let deleted = false;\n\n      if (bodyElement.hasOwnProperty(key2) && bodyElement[key2] === null) {\n        delete bodyElement[key2];\n        deleted = true;\n      }\n\n      if (!bodyElement.hasOwnProperty(key2) || !bodyElement[key2]) {\n        initializeField(state, typeName, bodyElement, key2, deleted);\n      }\n    });\n  } // Walk body element to validate against schema & recurse\n\n\n  let replacement = null;\n\n  _.forEach(bodyElement, function forEachdefaultAndValidateElementRecurse(value, key2) {\n    if (isMapLcl) {\n      if (_.isArray(bodyElement)) {\n        for (let ii = 0; ii < bodyElement[0].length; ii++) {\n          state.stack.push(ii);\n          replacement = validateElementType(state, schemaElement.key, bodyElement[0][ii]);\n\n          if (replacement) {\n            bodyElement[0][ii] = replacement;\n          }\n\n          replacement = validateElementType(state, schemaElement.value, bodyElement[1][ii]);\n\n          if (replacement) {\n            bodyElement[1][ii] = replacement;\n          }\n\n          state.stack.pop();\n        }\n      } else {\n        for (const mapKey in bodyElement) {\n          if (bodyElement.hasOwnProperty(key2)) {\n            state.stack.push(key2);\n            replacement = validateElementType(state, schemaElement.key, mapKey);\n\n            if (replacement) {\n              const oldValue = bodyElement[mapKey];\n              delete bodyElement[mapKey];\n              bodyElement[replacement] = oldValue;\n            }\n\n            replacement = validateElementType(state, schemaElement.value, bodyElement[mapKey]);\n\n            if (replacement) {\n              bodyElement[mapKey] = replacement;\n            }\n\n            state.stack.pop();\n          }\n        }\n      }\n    } else if (schemaElement.hasOwnProperty(key2)) {\n      state.stack.push(key2);\n      replacement = validateElementType(state, schemaElement[key2], value);\n\n      if (replacement) {\n        bodyElement[key2] = replacement;\n      }\n\n      state.stack.pop();\n    } else {\n      state.issues.push('INVALID FIELD: Unexpected type of ' + state.stack.join('.') + '.' + key2);\n      delete bodyElement[key2];\n    }\n  });\n}\n/**\n * Default & validate SOA operation body.\n *\n * @param {Object} schemaService - schema for service\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @param {Object} body - request body\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */\n\n\nfunction defaultAndValidateElement(schemaService, serviceName, operationName, body) {\n  const state = {\n    // If caller has passed null, they've indicated that there's an empty body.\n    body: body ? body : {},\n    serviceName: serviceName,\n    operationName: operationName,\n    schemaService: schemaService,\n    issues: [],\n    stack: []\n  };\n\n  if (state.schemaService) {\n    state.operation = state.schemaService[state.operationName];\n\n    if (state.operation) {\n      // Walk body make sure it aligns to the schema\n      defaultAndValidateElementRecurse(state, state.operation, state.body);\n\n      if (state.issues.length > 0) {\n        logger.error('Invalid SOA request body!\\n' + state.issues.join('\\n') + '\\n\\nInput body:', state.body);\n      }\n    } else {\n      logger.error('No SOA operation for ' + state.serviceName + ' ' + state.operationName + '! Skipping validation & default of SOA input.');\n    }\n  } else {\n    logger.error('No SOA service for ' + state.serviceName + '! Skipping validation & default of SOA input.');\n  }\n\n  return state.body;\n} // Response processing\n\n/**\n * Process an array of objects to create a single string of messages.\n *\n * @param {Object} messages - array of objects containing message fields\n * @param {Object} msgObj - message object with message value & level\n */\n\n\nfunction getMessageString(messages, msgObj) {\n  _.forEach(messages, function (object) {\n    if (msgObj.msg.length > 0) {\n      msgObj.msg += '\\n';\n    }\n\n    msgObj.msg += object.message;\n    msgObj.level = _.max([msgObj.level, object.level]);\n  });\n}\n/**\n * Return a reference to a new 'error' object set with the given error information.\n *\n * @param {Object} errIn - error in\n *\n * @returns {Object} - JavaScript Error object\n */\n\n\nexport const createError = function (errIn) {\n  const msgObj = {\n    msg: '',\n    level: 0\n  };\n\n  if (errIn.message) {\n    msgObj.msg = errIn.message;\n  } else if (errIn.status || errIn.statusText) {\n    msgObj.msg = errIn.status + ' ' + errIn.statusText;\n  } else if (errIn.PartialErrors) {\n    _.forEach(errIn.PartialErrors, function (partialError) {\n      getMessageString(partialError.errorValues, msgObj);\n    });\n  } else if (errIn.partialErrors) {\n    _.forEach(errIn.partialErrors, function (partialError) {\n      getMessageString(partialError.errorValues, msgObj);\n    });\n  } else if (errIn.messages) {\n    getMessageString(errIn.messages, msgObj);\n  } else {\n    msgObj.msg = errIn.toString();\n  }\n\n  if (errIn.data && errIn.data.messages) {\n    getMessageString(errIn.data.messages, msgObj);\n  }\n\n  const error = new Error(msgObj.msg);\n  error.cause = errIn;\n  error.level = msgObj.level;\n  return error;\n};\n/**\n * @param {Object} response - response\n * @return {Object|null} service data\n */\n\nfunction getServiceData(response) {\n  if (response.hasOwnProperty('.QName') && /\\.ServiceData$/.test(response['.QName'])) {\n    return response;\n  } else if (response.ServiceData) {\n    // If the service data is a member field, update the service data reference\n    return response.ServiceData;\n  }\n}\n/**\n * Process SOA partial exceptions in response.\n *\n * @param {Object} response JSON response data\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @return {Object} response JSON response data\n */\n\n\nfunction processExceptions(response, serviceName, operationName) {\n  const serviceData = getServiceData(response);\n\n  if (serviceData && serviceData.partialErrors || response.PartialErrors && !_.isEmpty(response.PartialErrors)) {\n    // Publish SAN event to log the SOA errors to analytics\n    let qName = 'unknown';\n\n    if (response.hasOwnProperty('.QName')) {\n      qName = response['.QName'];\n    }\n\n    eventBus.publishOnChannel({\n      channel: 'SAN_Events',\n      topic: 'aw-command-logErrros',\n      data: {\n        sanQName: qName,\n        sanPartialErrors: serviceData && serviceData.partialErrors || response,\n        sanServiceName: serviceName,\n        sanOperationName: operationName,\n        sanLogCorrelationID: logger.getCorrelationID()\n      }\n    });\n  } // Should we search for 'Exception' in QName?\n\n\n  if (response && response.hasOwnProperty('.QName')) {\n    if (/InvalidUserException$/.test(response['.QName'])) {\n      if (operationName === GET_SESSION_INFO.operationName) {\n        // This is the trivial case of initial connection to the server.\n        throw exports.createError(response);\n      } // hit the InvalidUserException during a non-login related SOA call.\n      // this is a session time-out situation.\n\n\n      eventBus.publish('session.stale', {});\n      console.log('Encountered Session timeout. SOA Request for service: ' + serviceName + ', ' + // eslint-disable-line no-console\n      operationName + '  Will refresh the page in order to re-Authenticate.'); // assumption is that we've timed out, so need to \"reAuthenticate\".\n      // Legacy GWT logic would call the session manager to reauthenticate(), but that\n      // pattern is no longer used.  In general we just will reload the page and\n      // that will update the authentication state and trigger reauthentication.\n\n      location.reload(false); // trigger a page refresh, that will reload and authenticate again.\n    } // FIXME this should be conditioned with a QName check...\n\n\n    if (/Exception$/.test(response['.QName'])) {\n      throw exports.createError(response);\n    }\n  }\n\n  return response;\n}\n/**\n * @private\n * @param {Object} parent - parent element\n * @param {Array} modelObjs - Array of {ModelObject} found in response\n * @param {Object} typeNames - array of referenced type names\n */\n\n\nfunction extractModelObjAndTypeFromResponse(parent, modelObjs, typeNames) {\n  _.forEach(parent, function (child, key) {\n    if (_.isPlainObject(child)) {\n      if (child.hasOwnProperty('uid') && child.hasOwnProperty('type')) {\n        if (child.uid && child.uid !== cdm.NULL_UID) {\n          if (modelObjs) {\n            modelObjs.push(child);\n          } else {\n            const modelObj = cdm.getObject(child.uid);\n\n            if (modelObj) {\n              parent[key] = modelObj;\n            }\n          }\n        }\n\n        if (typeNames && child.type && child.type !== 'unknownType') {\n          typeNames[child.type.toString()] = null;\n        }\n      } else {\n        extractModelObjAndTypeFromResponse(child, modelObjs, typeNames);\n      }\n    } else if (_.isArray(child)) {\n      extractModelObjAndTypeFromResponse(child, modelObjs, typeNames);\n    }\n  });\n}\n/**\n * @private\n * @param {Object} response - Response from SOA service.\n * @param {Array} modelObjs - Array of {ModelObject} from SOA service.\n * @returns {Object} Response from SOA service.\n */\n\n\nfunction processResponseObjects(response, modelObjs) {\n  const serviceData = getServiceData(response);\n  let updatedObjs = [];\n\n  if (modelObjs && modelObjs.length > 0) {\n    // Add objects to CDM\n    cdm.cacheObjects(modelObjs);\n    updatedObjs = modelObjs; // To support the anti-pattern of code pulling the modelObject from the response, we need to update the response serviceData.\n\n    extractModelObjAndTypeFromResponse(response);\n  }\n\n  if (serviceData) {\n    if (serviceData.created) {\n      const createdObjects = [];\n\n      _.forEach(serviceData.created, function (uid) {\n        const createdObject = cdm.getObject(uid);\n\n        if (createdObject) {\n          createdObjects.push(createdObject);\n        }\n      });\n\n      if (createdObjects.length) {\n        eventBus.publish('cdm.created', {\n          createdObjects: createdObjects\n        });\n      }\n    }\n\n    if (serviceData.updated) {\n      const updatedObjects = [];\n\n      _.forEach(serviceData.updated, function (uid) {\n        if (!cmm.isTypeUid(uid)) {\n          const updatedObject = cdm.getObject(uid);\n\n          if (updatedObject) {\n            updatedObjects.push(updatedObject);\n          }\n        }\n      });\n\n      if (updatedObjects.length) {\n        eventBus.publish('cdm.updated', {\n          updatedObjects: updatedObjects\n        });\n      }\n    }\n\n    if (serviceData.deleted) {\n      // Remove objects from CDM\n      cdm.removeObjects(serviceData.deleted);\n    }\n  }\n\n  const currentStore = appCtxSvc.getCtx('vmo') || {};\n  let timeNow = Date.now();\n  let values = {};\n\n  if (updatedObjs.length) {\n    for (const mo of updatedObjs) {\n      let refUid = getRefUid(mo);\n      let uidVal = mo.uid;\n      currentStore[uidVal] = {\n        type: mo.type,\n        time: timeNow,\n        ref: refUid\n      };\n\n      if (uidVal) {\n        values[uidVal] = true;\n      }\n    }\n\n    const storeValues = Object.entries(currentStore);\n\n    if (!_.isEmpty(values)) {\n      for (const [uid, {\n        type,\n        ref\n      }] of storeValues) {\n        if (values[ref]) {\n          currentStore[uid] = {\n            type: type,\n            time: timeNow,\n            ref: ref\n          };\n        }\n      }\n    }\n\n    appCtxSvc.registerCtx('vmo', currentStore);\n  }\n\n  return response;\n}\n\nconst getRefUid = mo => {\n  if (mo.type === 'Awp0XRTObjectSetRow' && mo.props && mo.props.awp0Target) {\n    return mo.props.awp0Target.dbValues[0];\n  }\n\n  return null;\n};\n/**\n * Process service data in HTTP response.\n *\n * @param {Object} response - JSON response data\n * @param {String} operationName - operation name\n * @return {Promise} Promise resolved once types are loaded\n */\n\n\nfunction processResponseTypes(response, operationName) {\n  if (response) {\n    const modelObjs = [];\n    const typeNamesObj = {};\n    const qName = response['.QName'];\n\n    if (qName !== 'http://teamcenter.com/Schemas/Soa/2011-06/MetaModel.TypeSchema') {\n      extractModelObjAndTypeFromResponse(response, modelObjs, typeNamesObj);\n    }\n\n    const typeNames = Object.keys(typeNamesObj);\n\n    if (operationName === GET_SESSION_INFO.operationName && response.extraInfoOut) {\n      if (response.extraInfoOut.AWC_StartupTypes) {\n        _typeCacheLMD = response.extraInfoOut.typeCacheLMD;\n        _awStartupPreferences = response.extraInfoOut.AWC_StartupTypes.split(','); // Always include TC_Project even if not in the start up preference\n\n        if (!_.includes(_awStartupPreferences, 'TC_Project')) {\n          _awStartupPreferences.push('TC_Project');\n        } // Always include ListOfValuesString even if not in the start up preference\n\n\n        if (!_.includes(_awStartupPreferences, 'ListOfValuesString')) {\n          _awStartupPreferences.push('ListOfValuesString');\n        }\n      }\n\n      const loadedTypes = typeCacheSvc.getLocalTypes(_typeCacheLMD);\n      cmm.cacheTypes(loadedTypes);\n    }\n\n    return exports.ensureModelTypesLoaded(typeNames).then(function () {\n      // Just in case we have more types, let's go get them...\n      return processResponseObjects(response, modelObjs);\n    });\n  }\n\n  return AwPromiseService.instance.resolve();\n}\n/**\n *\n * Gets the effective property policy\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {boolean} isSelectedPropertyPolicy - boolean which indicates whether the selected property is required\n *            or not.\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */\n\n\nfunction getEffectivePropertyPolicy(propertyPolicyOverride, isSelectedPropertyPolicy) {\n  if (_.isString(propertyPolicyOverride)) {\n    return JSON.parse(propertyPolicyOverride);\n  }\n\n  if (_.isObject(propertyPolicyOverride)) {\n    // No need to pass a property policy for this call.\n    return propertyPolicyOverride;\n  }\n\n  return propPolicySvc.getEffectivePolicy(exports, isSelectedPropertyPolicy);\n}\n/**\n * @param {String} clientId - client ID used in SOA header\n */\n\n\nexport const setClientIdHeader = function (clientId) {\n  _clientId = clientId;\n};\n/**\n * @return {String} client ID used in SOA header\n */\n\nexport const getClientIdHeader = function () {\n  return _clientId;\n};\n/**\n * @param {Number} pollingTimeout - timeout to allow polling SOA calls to be made after last non-polling call (minutes)\n */\n\nexport const setPollingTimeout = function (pollingTimeout) {\n  if (pollingTimeout) {\n    _pollingTimeout = pollingTimeout * 60;\n  }\n};\n/**\n * Teamcenter SOA request.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @param {Boolean} checkPartialErrors - check for partial errors in the response\n * @param {Boolean} polling - true if this is a polling call\n *\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\n\nexport const request = function (serviceName, operationName, body) {\n  let {\n    propertyPolicyOverride,\n    ignoreHost = false,\n    headerStateOverride = false,\n    checkPartialErrors = false,\n    polling = false\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  assert(serviceName, 'Service name not provided!');\n  assert(operationName, 'Operation name not provided!'); // Support polling SOA calls to have a timeout. This stops an idle client\n  // browser from making polling calls.This is required because the TC web\n  // tier needs to be able to allow it's session to timeout.\n\n  if (_pollingTimeout > 0) {\n    if (polling) {\n      // Determine when last call was made.\n      const timeOfLastCall = _.toNumber(localStrg.get('soaService.timeOfLastCall'));\n\n      if (timeOfLastCall) {\n        const secsSinceLastCall = (Date.now() - timeOfLastCall) / 1000; // If longer than polling timeout, avoid call.\n\n        if (secsSinceLastCall > _pollingTimeout) {\n          return AwPromiseService.instance.reject(new Error('Polling call skipped due to client inactivity.'));\n        }\n      }\n    } else {\n      // localStorage is being used because SOA calls from other\n      // browsers tabs allow this tab to make the polling call.\n      localStrg.publish('soaService.timeOfLastCall', Date.now());\n    }\n  }\n\n  let isSelectedPropertyPolicy = false;\n  let endPt;\n  let promise;\n\n  if (GET_SESSION_INFO.serviceName === serviceName && GET_SESSION_INFO.operationName === operationName) {\n    // avoid loading schema for get session info call\n    const schemaService = {};\n    schemaService[GET_SESSION_INFO.operationName] = {}; // extraInfoIn: \"String[]\"\n\n    promise = AwPromiseService.instance.resolve(schemaService);\n  } else {\n    promise = configSvc.getCfg('schema.' + serviceName).then(function (schemaService) {\n      return schemaService;\n    }, function () {\n      // none found\n      logger.warn('No SOA schema definition found!');\n      return {};\n    });\n  }\n\n  return promise.then(function (schemaService) {\n    if (appCtxSvc.ctx.aw_hosting_enabled && !appCtxSvc.ctx.aw_hosting_soa_support_checked) {\n      appCtxSvc.ctx.aw_hosting_soa_support_checked = true;\n    }\n\n    if (body) {\n      isSelectedPropertyPolicy = propPolicySvc.checkForSelectedObject(body);\n    }\n\n    const jsonData = {\n      header: {\n        state: {\n          clientVersion: '10000.1.2',\n\n          /**\n           * Correlation ID for logging purposes (debug).\n           */\n          logCorrelationID: logger.getCorrelationID(),\n\n          /**\n           * Permanent ID/recipes are used for the runtime business object’s (BOMLine objects) opaque UIDs\n           * in requests/responses.\n           * <p>\n           * If the unloadObjects key is not in the request headers, all business objects are unloaded at\n           * the top of each request; see the processTagManager ITK for more information.\n           */\n          stateless: true,\n\n          /**\n           * If true, All business objects are unloaded at the top of each request; see the\n           * processTagManager ITK for more information. Previously controlled through the stateless flag.\n           * <p>\n           * When is stateless=true mode this value must be explicitly set to false to keep objects\n           * loaded.\n           */\n          unloadObjects: true,\n\n          /**\n           * If true, process server-session state key/value pairs found in the request headers. This\n           * turns all session state into client-session data. The standalone AW client should set this to\n           * true, while the hosted AW client should set it false (or not send it at all).\n           */\n          enableServerStateHeaders: !_redirectSoaSvc,\n\n          /**\n           */\n          formatProperties: true\n        },\n        policy: getEffectivePropertyPolicy(propertyPolicyOverride, isSelectedPropertyPolicy)\n      },\n      body: defaultAndValidateElement(schemaService, serviceName, operationName, body)\n    };\n    mergeHeaderState(jsonData.header.state, headerStateOverride);\n\n    if (appCtxSvc && appCtxSvc.getCtx('objectQuotaContext.useObjectQuota')) {\n      /**\n       * If true, All business objects are unloaded at the top of each request. Applications might want to\n       * rely on object quota based unload. In such cases they can use \"objectQuotaContext\" to override this\n       * behavior and reset this flag to avail this feature\n       */\n      jsonData.header.state.unloadObjects = false;\n    }\n\n    if (!_redirectSoaSvc && _clientId !== '') {\n      jsonData.header.state.clientID = _clientId;\n    }\n\n    const headers = {\n      // Only US-ASCII characters are allowed in HTTP headers\n      // http://stackoverflow.com/questions/34670413/regexp-to-validate-a-http-header-value/34710882#34710882\n      'Log-Correlation-ID': jsonData.header.state.logCorrelationID.replace(/[^\\x20-\\x7E]+/g, '')\n    };\n\n    if (GET_SESSION_INFO.serviceName === serviceName && GET_SESSION_INFO.operationName === operationName) {\n      headers.clientIP = 'browser-client';\n    }\n\n    let awSession = localStrg.get('awSession');\n\n    if (awSession) {\n      try {\n        awSession = JSON.parse(awSession);\n\n        if (!appCtxSvc.ctx.aw_hosting_enabled) {\n          if (awSession.groupMemberUID) {\n            jsonData.header.state.groupMember = awSession.groupMemberUID;\n          }\n\n          if (awSession.roleName) {\n            jsonData.header.state.role = awSession.roleName;\n          }\n        }\n\n        if (awSession.locale) {\n          jsonData.header.state.locale = awSession.locale;\n        }\n      } catch (err) {\n        logger.debug(err);\n        localStrg.removeItem('awSession');\n      }\n    }\n\n    endPt = serviceName + '/' + operationName;\n\n    if (logger.isTraceEnabled()) {\n      logger.trace('\\n' + 'soaService.post to ' + endPt, jsonData);\n    }\n\n    pendingRequests++;\n    eventBus.publish('progress.start', {\n      endPoint: endPt\n    });\n    /**\n     * Check if there is a 'host' process that is handling SOA processing<BR>\n     * If so: Send the 'endPt' and data to that service.\n     */\n    // The only case the client will make its own login call when hosted would be when it needs credentials.\n    // If such a call is made, we should not make it through the host. This is the only case when AW talks directly to the server.\n    // This will allow Viewer to show up in hosts.\n\n    if (_redirectSoaSvc && !ignoreHost) {\n      return _redirectSoaSvc.post(serviceName, operationName, jsonData);\n    }\n\n    const $http = AwHttpService.instance;\n    trace('HTTP call start', serviceName, operationName);\n    return $http.post(browserUtils.getBaseURL() + 'tc/JsonRestServices/' + endPt, jsonData, {\n      headers: headers\n    }).then(function (response) {\n      trace('HTTP call complete', serviceName, operationName);\n      assert(response, 'No response given for ' + endPt);\n      const body2 = response.data;\n      assert(typeof body2 !== 'string' || body2.indexOf('<?xml version') === -1, 'Unexpected response body for: ' + endPt);\n      return body2;\n    });\n  }).then(function (response) {\n    pendingRequests--;\n    eventBus.publish('progress.end', {\n      endPoint: endPt\n    });\n\n    if (logger.isTraceEnabled()) {\n      logger.trace('endPt=' + endPt, response);\n    }\n\n    return processExceptions(response, serviceName, operationName);\n  }, function (err) {\n    pendingRequests--;\n    eventBus.publish('progress.end', {\n      endPoint: endPt\n    });\n    throw exports.createError(err);\n  }).then(function (response) {\n    if (!propertyPolicyOverride && !isSelectedPropertyPolicy) {\n      loadPropertiesIfRequired(response);\n    }\n\n    return processResponseTypes(response, operationName);\n  }).then(function (response) {\n    if (checkPartialErrors && response) {\n      if (response.PartialErrors) {\n        throw exports.createError(response.PartialErrors);\n      }\n\n      const serviceData = getServiceData(response);\n\n      if (serviceData && serviceData.partialErrors) {\n        throw exports.createError(serviceData);\n      }\n    }\n\n    return response;\n  });\n};\n/**\n * Merge default header state with the given overrides\n *\n * @param {Object|String} defaultHeaderState - SOA header state default (or NULL)\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n */\n\nfunction mergeHeaderState(defaultHeaderState, headerStateOverride) {\n  const keys = headerStateOverride ? Object.keys(headerStateOverride) : [];\n\n  for (let i = 0; i < keys.length; ++i) {\n    defaultHeaderState[keys[i]] = headerStateOverride[keys[i]];\n  }\n}\n/**\n * Calls getProperties Soa to load additional properties if required.\n *\n * @param {Object} response - JSON response data\n */\n\n\nfunction loadPropertiesIfRequired(response) {\n  if (response) {\n    const serviceData = getServiceData(response);\n\n    if (serviceData) {\n      const responseObjects = [];\n\n      if (serviceData.updated) {\n        for (let ii2 = 0; ii2 < serviceData.updated.length; ii2++) {\n          const updatedUid = serviceData.updated[ii2];\n\n          if (!cmm.isTypeUid(updatedUid)) {\n            const updatedObject = cdm.getObject(updatedUid);\n\n            if (updatedObject) {\n              responseObjects.push(updatedObject);\n            }\n          }\n        }\n      }\n\n      if (serviceData.created) {\n        for (let ii = 0; ii < serviceData.created.length; ii++) {\n          const createdObject = cdm.getObject(serviceData.created[ii]);\n\n          if (createdObject) {\n            responseObjects.push(createdObject);\n          }\n        }\n      }\n\n      if (responseObjects.length > 0 && propPolicySvc.checkForSelectedObject(null, responseObjects)) {\n        exports.request('Core-2006-03-DataManagement', 'getProperties', {\n          objects: responseObjects,\n          attributes: []\n        }, {\n          propertyPolicyOverride: propPolicySvc.getEffectivePolicy(null, true)\n        });\n      }\n    }\n  }\n}\n/**\n * SOA post unchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\n\n\nexport const postUnchecked = function (serviceName, operationName, body, propertyPolicyOverride, ignoreHost, headerStateOverride) {\n  return exports.request(serviceName, operationName, body, {\n    propertyPolicyOverride,\n    ignoreHost,\n    headerStateOverride\n  });\n};\n/**\n * SOA post.\n *\n * If the response contains partial errors, it will be treated as an exception & thrown. If this isn't desired,\n * use postUnchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\n\nexport const post = function (serviceName, operationName, body, propertyPolicyOverride, ignoreHost) {\n  return exports.request(serviceName, operationName, body, {\n    propertyPolicyOverride,\n    ignoreHost,\n    checkPartialErrors: true\n  });\n};\n/**\n * Set session information into local storage (if needed)\n *\n * @param {Boolean} signOut - sign out\n */\n\nexport const setSessionInfo = function (signOut) {\n  if (!signOut) {\n    const userSession = cdm.getUserSession();\n\n    if (userSession) {\n      // Store all the required fields to support the SOA header\n      const awSession = {\n        groupMemberUID: _.get(userSession, 'props.fnd0groupmember.dbValues.0'),\n        locale: _.get(userSession, 'props.fnd0locale.dbValues.0'),\n        roleName: _.get(userSession, 'props.role_name.dbValues.0')\n      };\n      localStrg.publish('awSession', JSON.stringify(awSession));\n    }\n  } else {\n    localStrg.removeItem('awSession');\n  }\n};\n/**\n * Perform an async get of current Teamcenter session information.\n *\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\n\nexport const getTCSessionInfo = function (ignoreHost) {\n  // Ensure we have the required properties for the UserSession.\n  const policyId = propPolicySvc.register({\n    types: [{\n      name: 'UserSession',\n      properties: [{\n        name: 'awp0RevRule',\n        modifiers: [{\n          name: 'includeIsModifiable',\n          Value: 'true'\n        }]\n      }, {\n        name: 'user',\n        modifiers: [{\n          name: 'withProperties',\n          Value: 'true'\n        }]\n      }, {\n        name: 'user_id'\n      }, {\n        name: 'group',\n        modifiers: [{\n          name: 'withProperties',\n          Value: 'true'\n        }]\n      }, {\n        name: 'group_name'\n      }, {\n        name: 'project'\n      }, {\n        name: 'role'\n      }, {\n        name: 'role_name'\n      }, {\n        name: 'fnd0locale'\n      }, {\n        name: 'fnd0LocationCode'\n      }, {\n        name: 'fnd0groupmember'\n      }]\n    }, {\n      name: 'Group',\n      properties: [{\n        name: 'privilege'\n      }]\n    }, {\n      name: 'User',\n      properties: [{\n        name: 'home_folder'\n      }]\n    }]\n  });\n  return exports.request(GET_SESSION_INFO.serviceName, GET_SESSION_INFO.operationName, {}, {\n    ignoreHost,\n    checkPartialErrors: true\n  }).then(function (response) {\n    propPolicySvc.unregister(policyId);\n    exports.setSessionInfo();\n    return response;\n  }).catch(function (err) {\n    propPolicySvc.unregister(policyId); // Since we have no session, clear the session from localStorage to ensure we don't try to use it.\n\n    localStrg.removeItem('awSession');\n    throw err;\n  });\n};\n/**\n * Get Type Descriptions from server.\n *\n * Note, this is hidden in this file to avoid anyone else directly calling this.\n *\n * @private\n *\n * @param {StringArray} typeNames - Array of type names\n *\n * @return {Promise} Promise who's resolution is the result of the SOA 'getTypeDescriptions2' operation.\n */\n\nasync function getTypeDescriptions(typeNames) {\n  assert(typeNames && typeNames.length > 0, 'No type names provided!');\n  typeNames.sort();\n\n  const typeNamesFinal = _.uniq(typeNames, true);\n\n  const typesToLoad = typeNamesFinal.filter(type => {\n    if (!_typeLoadInProgress[type]) {\n      return type;\n    }\n  });\n  const currentTypesBeingLoadedPromises = typeNamesFinal.filter(type => !typesToLoad.includes(type)).map(type => {\n    if (_typeLoadInProgress[type]) {\n      return _typeLoadInProgress[type];\n    }\n  });\n  const newLoadPromises = [];\n\n  if (typesToLoad.length > 0) {\n    const loadTypesPromise = exports.request('Core-2015-10-Session', 'getTypeDescriptions2', {\n      typeNames: typesToLoad,\n      options: {\n        PropertyExclusions: ['LovReferences', 'NamingRules', 'RendererReferences'],\n        TypeExclusions: ['DirectChildTypesInfo', 'RevisionNamingRules', 'ToolInfo']\n      }\n    }, {\n      propertyPolicyOverride: {}\n    });\n\n    for (const type of typesToLoad) {\n      _typeLoadInProgress[type] = loadTypesPromise;\n    }\n\n    newLoadPromises.push(loadTypesPromise);\n  }\n\n  const response = await Promise.all([...currentTypesBeingLoadedPromises, ...newLoadPromises]);\n\n  for (const type of typesToLoad) {\n    delete _typeLoadInProgress[type];\n  }\n\n  return response;\n}\n/**\n * Verify async that the given model types are loaded into the client's meta model.\n *\n * @param {StringArray} typeNames - An array of type names to ensure are cached.\n *\n * @return {Promise} Promise who's resolution is a 'null' value since the types are now loaded into the cache.\n *         This 'null' result is required because the GWT-side wrapper requires an AsyncCallback<Void> callback\n *         (not AsyncCallback<IJsAarray>).\n */\n\n\nexport const ensureModelTypesLoaded = function (typeNames) {\n  /**\n   * Handle trivial case\n   */\n  if (!typeNames) {\n    return AwPromiseService.instance.reject('Invalid type name array specified');\n  }\n  /**\n   * From the input list of type names, get a list of unique type names not in the CMM already.\n   */\n\n\n  const missingTypeNames = [];\n\n  _.forEach(typeNames, function (typeName) {\n    if (!cmm.containsType(typeName) && _invalidTypeNames.indexOf(typeName) === -1) {\n      missingTypeNames.push(typeName);\n    }\n  });\n  /**\n   * Check if we have any missing.\n   */\n\n\n  if (missingTypeNames.length > 0) {\n    // logger.info( \"Missing Types: \" + JSON.stringify( missingTypeNames ) );\n    return getTypeDescriptions(missingTypeNames).then(function (responseGetTypeDescriptions) {\n      for (const response of responseGetTypeDescriptions) {\n        if (response && response.types) {\n          const modelTypes = response.types;\n          const modelTypes2 = [];\n\n          _.forEach(modelTypes, function (typeName) {\n            if (!cmm.containsType(typeName)) {\n              modelTypes2.push(typeName);\n            }\n          });\n\n          if (modelTypes2.length > 0) {\n            cmm.cacheTypes(modelTypes2); // Cache the types in localStorage.\n\n            typeCacheSvc.setLocalTypes(modelTypes2, _awStartupPreferences, _typeCacheLMD, true);\n          }\n        } // Capture invalid type names\n\n\n        _.forEach(missingTypeNames, function (typeName) {\n          if (!cmm.containsType(typeName)) {\n            // add empty type to avoid future server calls\n            _invalidTypeNames.push(typeName);\n\n            _invalidTypeNames.sort();\n\n            _invalidTypeNames = _.uniq(_invalidTypeNames, true);\n          }\n        });\n      }\n\n      return null;\n    });\n  }\n\n  return AwPromiseService.instance.resolve();\n};\n/**\n * Setup to log all events fired on the 'soajs' eventBus event channel.\n */\n\nif (logger && logger.isTraceEnabled()) {\n  eventBus.subscribe('#', function (data, envelope) {\n    let msg = 'eventBus: ' + envelope.topic + ' @ ' + envelope.timeStamp;\n\n    if (data && data.endPoint) {\n      if (envelope.topic === 'progress.start') {\n        _lastStartDate[data.endPoint] = envelope.timeStamp;\n      } else if (envelope.topic === 'progress.end' && _lastStartDate[data.endPoint]) {\n        const msDelta = envelope.timeStamp.getTime() - _lastStartDate[data.endPoint].getTime();\n\n        msg = msg + '\\n' + '          Time: ' + msDelta + 'ms' + '    ' + data.endPoint;\n        _lastStartDate[data.endPoint] = null;\n      }\n    }\n\n    if (logger.isTraceEnabled()) {\n      // Just print, using logger.trace causes infinite recursion\n      console.debug(msg, envelope); // eslint-disable-line no-console\n    }\n  }, 'soa_kernel_soaService');\n}\n/**\n * Determine if the user is currently signed in.\n *\n * @return {boolean} is signed in?\n */\n\n\nexport const isSignedIn = function () {\n  return _signedIn;\n};\nexport const getPendingRequestsCount = function () {\n  return pendingRequests;\n};\n/**\n * Subscribe to listen when we are signed in/out. Just tracking state locally. NOTE - for non User/PW\n * authentication, this state may not be 100% accurate.\n */\n\neventBus.subscribe('session.signIn', function () {\n  _signedIn = true;\n}, 'soa_kernel_soaService');\neventBus.subscribe('session.signOut', function () {\n  _signedIn = false;\n}, 'soa_kernel_soaService');\nconst exports = {\n  createError,\n  postUnchecked,\n  post,\n  request,\n  setSessionInfo,\n  getTCSessionInfo,\n  ensureModelTypesLoaded,\n  isSignedIn,\n  setClientIdHeader,\n  getClientIdHeader,\n  setPollingTimeout,\n  setSoaRedirect,\n  getPendingRequestsCount\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/kernel/src/js/soa/kernel/soaService.js"],"names":["_signedIn","_lastStartDate","_invalidTypeNames","REGEX_ARRAY_SUFFIX","GET_SESSION_INFO","serviceName","operationName","setSoaRedirect","_redirectSoaSvc","trace","_typeLoadInProgress","_clientId","_pollingTimeout","pendingRequests","bodyElement","uid","deleted","cdm","type","state","_","Object","schemaElement","defaultAndValidateElementRecurse","typeName2","typeName","replacementArray","ii","replacement","validateElementType","valueFinal","initializeField","isMapLcl","isMap","oldValue","body","schemaService","issues","stack","logger","msgObj","object","createError","msg","level","errIn","getMessageString","partialError","error","response","serviceData","getServiceData","qName","eventBus","channel","topic","data","sanQName","sanPartialErrors","sanServiceName","sanOperationName","sanLogCorrelationID","exports","console","location","child","modelObjs","modelObj","parent","typeNames","extractModelObjAndTypeFromResponse","updatedObjs","createdObjects","createdObject","updatedObjects","cmm","updatedObject","currentStore","appCtxSvc","timeNow","Date","values","refUid","getRefUid","uidVal","mo","time","ref","storeValues","typeNamesObj","_typeCacheLMD","_awStartupPreferences","loadedTypes","typeCacheSvc","processResponseObjects","AwPromiseService","JSON","propPolicySvc","setClientIdHeader","getClientIdHeader","setPollingTimeout","pollingTimeout","request","ignoreHost","headerStateOverride","checkPartialErrors","polling","assert","timeOfLastCall","localStrg","secsSinceLastCall","isSelectedPropertyPolicy","promise","jsonData","header","clientVersion","logCorrelationID","stateless","unloadObjects","enableServerStateHeaders","formatProperties","policy","getEffectivePropertyPolicy","defaultAndValidateElement","mergeHeaderState","headers","awSession","endPt","endPoint","$http","AwHttpService","browserUtils","body2","processExceptions","loadPropertiesIfRequired","processResponseTypes","keys","i","defaultHeaderState","responseObjects","ii2","updatedUid","objects","attributes","propertyPolicyOverride","postUnchecked","post","setSessionInfo","userSession","groupMemberUID","locale","roleName","getTCSessionInfo","policyId","types","name","properties","modifiers","Value","typeNamesFinal","typesToLoad","currentTypesBeingLoadedPromises","newLoadPromises","loadTypesPromise","options","PropertyExclusions","TypeExclusions","Promise","ensureModelTypesLoaded","missingTypeNames","modelTypes","modelTypes2","envelope","msDelta","isSignedIn","getPendingRequestsCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2022 Siemens\n/* eslint-disable sonarjs/cognitive-complexity */\n\n/**\n * This is the Teamcenter SOA Service. It's the central pipeline for invoking JSON SOA APIs & FMS APIs from the client.\n *\n * Note: Many of the the functions defined in this module return a {@linkcode module:angujar~Promise|Promise} object.\n * The caller should provide callback function(s) to the 'then' method of this returned object (e.g. successCallback,\n * [errorCallback, [notifyCallback]]). These methods will be invoked when the associated service result is known.\n *\n * @module soa/kernel/soaService\n */\nimport AwPromiseService from 'js/awPromiseService';\nimport AwHttpService from 'js/awHttpService';\nimport cdm from 'soa/kernel/clientDataModel';\nimport cmm from 'soa/kernel/clientMetaModel';\nimport propPolicySvc from 'soa/kernel/propertyPolicyService';\nimport appCtxSvc from 'js/appCtxService';\nimport typeCacheSvc from 'soa/kernel/typeCacheService';\nimport configSvc from 'js/configurationService';\nimport _ from 'lodash';\nimport assert from 'assert';\nimport Debug from 'debug';\nimport logger from 'js/logger';\nimport eventBus from 'js/eventBus';\nimport browserUtils from 'js/browserUtils';\nimport localStrg from 'js/localStorage';\n\n/**\n * Boolean to indicate if we're signed into the server. This is just an observer state. True signin state is\n * managed by the Session Manager.\n *\n * @private\n */\nlet _signedIn = false;\n\n/**\n * Date/Time of the last progress 'start'. This is used to compute the amount of time a single SOA post takes.\n *\n * @private\n */\nconst _lastStartDate = {};\n\n/**\n * List of type names which have been deemed invalid based upon the previous server responses.\n *\n * @private\n */\nlet _invalidTypeNames = [ 'contents' ];\n\n/**\n * Types that need loaded if available.\n * On AW startup.\n * @private\n */\nlet _awStartupPreferences;\n\n/**\n * Types cache timestamp\n *\n * @private\n */\nlet _typeCacheLMD;\n\n/**\n * Regular expression used to test if a string ends with \"[]\"\n */\nconst REGEX_ARRAY_SUFFIX = /\\[\\]$/i;\n\n/**\n * Constant for operation name used for get TC Session Info\n *\n * @type {string}\n */\nconst GET_SESSION_INFO = {\n    serviceName: 'Internal-AWS2-2017-12-DataManagement',\n    operationName: 'getTCSessionAnalyticsInfo'\n};\n\n/**\n * SOA redirect\n */\nlet _redirectSoaSvc;\n\nexport const setSoaRedirect = function( redirect ) { _redirectSoaSvc = redirect; };\n\n/** Debug trace function */\nconst trace = new Debug( 'soaService' );\n\n/** Object to track which types are currently being loaded such that getTypeDescriptions2 is not duplicated for the same type */\nconst _typeLoadInProgress = {};\n\n/** client ID used in SOA header */\nlet _clientId = 'ActiveWorkspaceClient';\n\n/** timeout to allow polling SOA calls to be made after last non-polling call */\nlet _pollingTimeout = 15 * 60; // 15 minutes default\n\nlet pendingRequests = 0;\n\n/**\n * Initialize 'bodyElement[key]' based on given information.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @param {String} key - key\n * @param {Boolean} deleted - was the key just deleted?\n */\nfunction initializeField( state, typeName, bodyElement, key, deleted ) {\n    switch ( typeName ) {\n        case 'String':\n        case 'Date':\n            bodyElement[ key ] = '';\n            break;\n        case 'int':\n        case 'float':\n        case 'double':\n            bodyElement[ key ] = 0;\n            break;\n        case 'boolean':\n            bodyElement[ key ] = false;\n            break;\n        case 'ModelObj':\n        case 'ModelObject':\n            bodyElement[ key ] = {\n                uid: deleted ? cdm.NULL_UID : '',\n                type: deleted ? 'unknownType' : ''\n            };\n            break;\n        default:\n            if( REGEX_ARRAY_SUFFIX.test( typeName ) ) {\n                // Array\n                bodyElement[ key ] = [];\n            } else if( state.schemaService.hasOwnProperty( typeName ) && _.isArray( state.schemaService[ typeName ] ) ) {\n                // Enum support... default to first entry\n                bodyElement[ key ] = state.schemaService[ typeName ][ 0 ];\n            } else {\n                // Object or map\n                bodyElement[ key ] = {};\n            }\n    }\n}\n\n/**\n * TRUE if the given element is in the schema.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element to evaluate to determine if element should be a map\n *\n * @returns {Boolean} TRUE if the given element is in the schema.\n */\nfunction isMap( state, schemaElement ) {\n    if( Object.keys( schemaElement ).length === 2 &&\n        schemaElement.hasOwnProperty( 'key' ) &&\n        schemaElement.hasOwnProperty( 'value' ) &&\n        !state.schemaService.hasOwnProperty( schemaElement.key ) ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Validate element type & recurse if non-trivial type.\n *\n * @private\n *\n * @param {Object} state - state object\n * @param {String} typeName - type name\n * @param {Object} bodyElement - body element\n * @returns {Object} ...\n */\nfunction validateElementType( state, typeName, bodyElement ) { // eslint-disable-line complexity\n    switch ( typeName ) {\n        case 'String':\n        case 'Date':\n            if( !_.isString( bodyElement ) ) {\n                state.issues.push( 'INVALID FIELD: Expected string, not ' + typeof bodyElement + ' --' +\n                    state.stack.join( '.' ) );\n            }\n            break;\n        case 'int':\n        case 'float':\n        case 'double':\n            if( !_.isNumber( bodyElement ) ) {\n                state.issues.push( 'INVALID FIELD: Expected number, not ' + typeof bodyElement + ' --' +\n                    state.stack.join( '.' ) );\n            }\n            break;\n        case 'boolean':\n            if( !_.isBoolean( bodyElement ) ) {\n                state.issues.push( 'INVALID FIELD: Expected boolean, not ' + typeof bodyElement + ' --' +\n                    state.stack.join( '.' ) );\n            }\n            break;\n        case 'ModelObj':\n        case 'ModelObject':\n            if( !bodyElement || !bodyElement.uid || !bodyElement.type ) {\n                return {\n                    uid: !bodyElement || !bodyElement.uid ? cdm.NULL_UID : bodyElement.uid,\n                    type: !bodyElement || !bodyElement.type ? 'unknownType' : bodyElement.type\n                };\n            }\n            if( Object.keys( bodyElement ).length !== 2 ) {\n                // replace with new object if it's not already uid & type only\n                return {\n                    uid: bodyElement.uid,\n                    type: bodyElement.type\n                };\n            }\n            break;\n        case 'ICreateInput':\n            if( !bodyElement || !bodyElement.boName || !_.isString( bodyElement.boName ) ) {\n                state.issues.push( 'INVALID FIELD VALUE: Expect type of ICreateInput' );\n            }\n            break;\n        default:\n            if( state.schemaService.hasOwnProperty( typeName ) ) {\n                if( _.isArray( state.schemaService[ typeName ] ) ) {\n                    // Enum\n                    if( state.schemaService[ typeName ].indexOf( bodyElement ) === -1 ) {\n                        state.issues.push( 'INVALID FIELD VALUE: Not valid enum value ' + typeName + ' expected ' +\n                            state.schemaService[ typeName ].toString() + ' --' + state.stack.join( '.' ) );\n                    }\n                } else {\n                    // Object processing\n                    defaultAndValidateElementRecurse( state, state.schemaService[ typeName ], bodyElement );\n                }\n            } else if( REGEX_ARRAY_SUFFIX.test( typeName ) ) {\n                // Array processing\n                if( !_.isArray( bodyElement ) ) {\n                    state.issues.push( 'INVALID FIELD: Expected array, not ' + typeof bodyElement + ' --' +\n                        state.stack.join( '.' ) );\n                    return undefined;\n                }\n                const typeName2 = typeName.substring( 0, typeName.length - 2 );\n                let replacementArray = null;\n                for( let ii = bodyElement.length - 1; ii >= 0; ii-- ) {\n                    state.stack.push( ii );\n                    const replacement = validateElementType( state, typeName2, bodyElement[ ii ] );\n                    if( replacement ) {\n                        if( !replacementArray ) {\n                            // we should probably replace the array in case caller is using for something else...\n                            replacementArray = bodyElement.slice( 0 );\n                        }\n                        replacementArray[ ii ] = replacement;\n                    }\n                    state.stack.pop();\n                }\n                if( replacementArray ) {\n                    return replacementArray;\n                }\n            } else if( /^(String|Int|Bool|Double|Float|Date|Tag)(|Vector)Map/.test( typeName ) ) {\n                // Map processing\n                let typeName2;\n                if( typeName.indexOf( 'String' ) === 0 ) {\n                    typeName2 = 'String';\n                } else if( typeName.indexOf( 'Date' ) === 0 ) {\n                    typeName2 = 'Date';\n                } else if( typeName.indexOf( 'Int' ) === 0 ) {\n                    typeName2 = 'int';\n                } else if( typeName.indexOf( 'Float' ) === 0 ) {\n                    typeName2 = 'float';\n                } else if( typeName.indexOf( 'Double' ) === 0 ) {\n                    typeName2 = 'double';\n                } else if( typeName.indexOf( 'Bool' ) === 0 ) {\n                    typeName2 = 'boolean';\n                } else if( typeName.indexOf( 'Tag' ) === 0 ) {\n                    typeName2 = 'ModelObject';\n                }\n                if( /VectorMap/g.test( typeName ) ) {\n                    typeName2 += '[]';\n                }\n                _.forEach( bodyElement, function( value, key ) {\n                    let valueFinal = value;\n\n                    if( !_.isString( key ) ) {\n                        state.issues.push( 'INVALID FIELD: Expected string, not ' + typeof key + ' --' +\n                            state.stack.join( '.' ) );\n                        return;\n                    }\n                    if( typeName2 ) {\n                        if( !bodyElement[ key ] ) {\n                            initializeField( state, typeName2, bodyElement, key, false );\n                            valueFinal = bodyElement[ key ];\n                        }\n                        if( typeName2 ) {\n                            if( !bodyElement[ key ] ) {\n                                initializeField( state, typeName2, bodyElement, key, false );\n                                valueFinal = bodyElement[ key ];\n                            }\n                            state.stack.push( key );\n                            const replacement = validateElementType( state, typeName2, valueFinal );\n                            if( replacement ) {\n                                bodyElement[ key ] = replacement;\n                            }\n                            state.stack.pop();\n                        } else {\n                            state.issues.push( 'INVALID FIELD: Unsupported map type of ' + typeName + ' --' +\n                                state.stack.join( '.' ) );\n                        }\n                        state.stack.pop();\n                    } else {\n                        state.issues.push( 'INVALID FIELD: Unsupported map type of ' + typeName + ' --' +\n                            state.stack.join( '.' ) );\n                    }\n                } );\n            } else {\n                state.issues.push( 'INVALID FIELD: Unsupported type of ' + typeName + ' --' +\n                    state.stack.join( '.' ) );\n            }\n    }\n}\n\n/**\n * Recursive method for default & validate SOA operation body.\n *\n * @param {Object} state - state object\n * @param {Object} schemaElement - schema element/cursor for the walk\n * @param {Object} bodyElement - body element/cursor for the walk\n * @private\n */\nfunction defaultAndValidateElementRecurse( state, schemaElement, bodyElement ) {\n    // Walk schema to add any missing fields\n    const isMapLcl = isMap( state, schemaElement );\n\n    if( !isMapLcl ) {\n        _.forEach( schemaElement, function( typeName, key2 ) {\n            let deleted = false;\n            if( bodyElement.hasOwnProperty( key2 ) &&\n                bodyElement[ key2 ] === null ) {\n                delete bodyElement[ key2 ];\n                deleted = true;\n            }\n\n            if( !bodyElement.hasOwnProperty( key2 ) || !bodyElement[ key2 ] ) {\n                initializeField( state, typeName, bodyElement, key2, deleted );\n            }\n        } );\n    }\n\n    // Walk body element to validate against schema & recurse\n    let replacement = null;\n\n    _.forEach( bodyElement, function forEachdefaultAndValidateElementRecurse( value, key2 ) {\n        if( isMapLcl ) {\n            if( _.isArray( bodyElement ) ) {\n                for( let ii = 0; ii < bodyElement[ 0 ].length; ii++ ) {\n                    state.stack.push( ii );\n                    replacement = validateElementType( state, schemaElement.key, bodyElement[ 0 ][ ii ] );\n                    if( replacement ) {\n                        bodyElement[ 0 ][ ii ] = replacement;\n                    }\n                    replacement = validateElementType( state, schemaElement.value, bodyElement[ 1 ][ ii ] );\n                    if( replacement ) {\n                        bodyElement[ 1 ][ ii ] = replacement;\n                    }\n                    state.stack.pop();\n                }\n            } else {\n                for( const mapKey in bodyElement ) {\n                    if( bodyElement.hasOwnProperty( key2 ) ) {\n                        state.stack.push( key2 );\n                        replacement = validateElementType( state, schemaElement.key, mapKey );\n                        if( replacement ) {\n                            const oldValue = bodyElement[ mapKey ];\n                            delete bodyElement[ mapKey ];\n                            bodyElement[ replacement ] = oldValue;\n                        }\n                        replacement = validateElementType( state, schemaElement.value, bodyElement[ mapKey ] );\n                        if( replacement ) {\n                            bodyElement[ mapKey ] = replacement;\n                        }\n                        state.stack.pop();\n                    }\n                }\n            }\n        } else if( schemaElement.hasOwnProperty( key2 ) ) {\n            state.stack.push( key2 );\n            replacement = validateElementType( state, schemaElement[ key2 ], value );\n            if( replacement ) {\n                bodyElement[ key2 ] = replacement;\n            }\n            state.stack.pop();\n        } else {\n            state.issues.push( 'INVALID FIELD: Unexpected type of ' + state.stack.join( '.' ) + '.' + key2 );\n            delete bodyElement[ key2 ];\n        }\n    } );\n}\n\n/**\n * Default & validate SOA operation body.\n *\n * @param {Object} schemaService - schema for service\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @param {Object} body - request body\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */\nfunction defaultAndValidateElement( schemaService, serviceName, operationName, body ) {\n    const state = {\n        // If caller has passed null, they've indicated that there's an empty body.\n        body: body ? body : {},\n        serviceName: serviceName,\n        operationName: operationName,\n        schemaService: schemaService,\n        issues: [],\n        stack: []\n    };\n\n    if( state.schemaService ) {\n        state.operation = state.schemaService[ state.operationName ];\n        if( state.operation ) {\n            // Walk body make sure it aligns to the schema\n            defaultAndValidateElementRecurse( state, state.operation, state.body );\n\n            if( state.issues.length > 0 ) {\n                logger.error( 'Invalid SOA request body!\\n' + state.issues.join( '\\n' ) + '\\n\\nInput body:',\n                    state.body );\n            }\n        } else {\n            logger.error( 'No SOA operation for ' + state.serviceName + ' ' + state.operationName +\n                '! Skipping validation & default of SOA input.' );\n        }\n    } else {\n        logger.error( 'No SOA service for ' + state.serviceName +\n            '! Skipping validation & default of SOA input.' );\n    }\n    return state.body;\n}\n\n// Response processing\n\n/**\n * Process an array of objects to create a single string of messages.\n *\n * @param {Object} messages - array of objects containing message fields\n * @param {Object} msgObj - message object with message value & level\n */\nfunction getMessageString( messages, msgObj ) {\n    _.forEach( messages, function( object ) {\n        if( msgObj.msg.length > 0 ) {\n            msgObj.msg += '\\n';\n        }\n        msgObj.msg += object.message;\n        msgObj.level = _.max( [ msgObj.level, object.level ] );\n    } );\n}\n\n/**\n * Return a reference to a new 'error' object set with the given error information.\n *\n * @param {Object} errIn - error in\n *\n * @returns {Object} - JavaScript Error object\n */\nexport const createError = function( errIn ) {\n    const msgObj = {\n        msg: '',\n        level: 0\n    };\n    if( errIn.message ) {\n        msgObj.msg = errIn.message;\n    } else if( errIn.status || errIn.statusText ) {\n        msgObj.msg = errIn.status + ' ' + errIn.statusText;\n    } else if( errIn.PartialErrors ) {\n        _.forEach( errIn.PartialErrors, function( partialError ) {\n            getMessageString( partialError.errorValues, msgObj );\n        } );\n    } else if( errIn.partialErrors ) {\n        _.forEach( errIn.partialErrors, function( partialError ) {\n            getMessageString( partialError.errorValues, msgObj );\n        } );\n    } else if( errIn.messages ) {\n        getMessageString( errIn.messages, msgObj );\n    } else {\n        msgObj.msg = errIn.toString();\n    }\n    if( errIn.data && errIn.data.messages ) {\n        getMessageString( errIn.data.messages, msgObj );\n    }\n    const error = new Error( msgObj.msg );\n    error.cause = errIn;\n    error.level = msgObj.level;\n    return error;\n};\n\n/**\n * @param {Object} response - response\n * @return {Object|null} service data\n */\nfunction getServiceData( response ) {\n    if( response.hasOwnProperty( '.QName' ) && /\\.ServiceData$/.test( response[ '.QName' ] ) ) {\n        return response;\n    } else if( response.ServiceData ) {\n        // If the service data is a member field, update the service data reference\n        return response.ServiceData;\n    }\n}\n\n/**\n * Process SOA partial exceptions in response.\n *\n * @param {Object} response JSON response data\n * @param {String} serviceName - service name\n * @param {String} operationName - operation name\n * @return {Object} response JSON response data\n */\nfunction processExceptions( response, serviceName, operationName ) {\n    const serviceData = getServiceData( response );\n    if( serviceData && serviceData.partialErrors ||\n        response.PartialErrors && !_.isEmpty( response.PartialErrors ) ) {\n        // Publish SAN event to log the SOA errors to analytics\n        let qName = 'unknown';\n        if( response.hasOwnProperty( '.QName' ) ) {\n            qName = response[ '.QName' ];\n        }\n\n        eventBus.publishOnChannel( {\n            channel: 'SAN_Events',\n            topic: 'aw-command-logErrros',\n            data: {\n                sanQName: qName,\n                sanPartialErrors: serviceData && serviceData.partialErrors || response,\n                sanServiceName: serviceName,\n                sanOperationName: operationName,\n                sanLogCorrelationID: logger.getCorrelationID()\n            }\n        } );\n    }\n\n    // Should we search for 'Exception' in QName?\n    if( response && response.hasOwnProperty( '.QName' ) ) {\n        if( /InvalidUserException$/.test( response[ '.QName' ] ) ) {\n            if( operationName === GET_SESSION_INFO.operationName ) {\n                // This is the trivial case of initial connection to the server.\n                throw exports.createError( response );\n            }\n\n            // hit the InvalidUserException during a non-login related SOA call.\n            // this is a session time-out situation.\n            eventBus.publish( 'session.stale', {} );\n\n            console.log( 'Encountered Session timeout. SOA Request for service: ' + serviceName + ', ' + // eslint-disable-line no-console\n                operationName + '  Will refresh the page in order to re-Authenticate.' );\n            // assumption is that we've timed out, so need to \"reAuthenticate\".\n            // Legacy GWT logic would call the session manager to reauthenticate(), but that\n            // pattern is no longer used.  In general we just will reload the page and\n            // that will update the authentication state and trigger reauthentication.\n            location.reload( false ); // trigger a page refresh, that will reload and authenticate again.\n        }\n        // FIXME this should be conditioned with a QName check...\n        if( /Exception$/.test( response[ '.QName' ] ) ) {\n            throw exports.createError( response );\n        }\n    }\n\n    return response;\n}\n\n/**\n * @private\n * @param {Object} parent - parent element\n * @param {Array} modelObjs - Array of {ModelObject} found in response\n * @param {Object} typeNames - array of referenced type names\n */\nfunction extractModelObjAndTypeFromResponse( parent, modelObjs, typeNames ) {\n    _.forEach( parent, function( child, key ) {\n        if( _.isPlainObject( child ) ) {\n            if( child.hasOwnProperty( 'uid' ) && child.hasOwnProperty( 'type' ) ) {\n                if( child.uid && child.uid !== cdm.NULL_UID ) {\n                    if( modelObjs ) {\n                        modelObjs.push( child );\n                    } else {\n                        const modelObj = cdm.getObject( child.uid );\n                        if( modelObj ) {\n                            parent[ key ] = modelObj;\n                        }\n                    }\n                }\n                if( typeNames && child.type && child.type !== 'unknownType' ) {\n                    typeNames[ child.type.toString() ] = null;\n                }\n            } else {\n                extractModelObjAndTypeFromResponse( child, modelObjs, typeNames );\n            }\n        } else if( _.isArray( child ) ) {\n            extractModelObjAndTypeFromResponse( child, modelObjs, typeNames );\n        }\n    } );\n}\n\n/**\n * @private\n * @param {Object} response - Response from SOA service.\n * @param {Array} modelObjs - Array of {ModelObject} from SOA service.\n * @returns {Object} Response from SOA service.\n */\nfunction processResponseObjects( response, modelObjs ) {\n    const serviceData = getServiceData( response );\n    let updatedObjs = [];\n    if( modelObjs && modelObjs.length > 0 ) {\n        // Add objects to CDM\n        cdm.cacheObjects( modelObjs );\n        updatedObjs = modelObjs;\n\n        // To support the anti-pattern of code pulling the modelObject from the response, we need to update the response serviceData.\n        extractModelObjAndTypeFromResponse( response );\n    }\n    if( serviceData ) {\n        if( serviceData.created ) {\n            const createdObjects = [];\n            _.forEach( serviceData.created, function( uid ) {\n                const createdObject = cdm.getObject( uid );\n                if( createdObject ) {\n                    createdObjects.push( createdObject );\n                }\n            } );\n            if( createdObjects.length ) {\n                eventBus.publish( 'cdm.created', {\n                    createdObjects: createdObjects\n                } );\n            }\n        }\n        if( serviceData.updated ) {\n            const updatedObjects = [];\n            _.forEach( serviceData.updated, function( uid ) {\n                if( !cmm.isTypeUid( uid ) ) {\n                    const updatedObject = cdm.getObject( uid );\n                    if( updatedObject ) {\n                        updatedObjects.push( updatedObject );\n                    }\n                }\n            } );\n            if( updatedObjects.length ) {\n                eventBus.publish( 'cdm.updated', {\n                    updatedObjects: updatedObjects\n                } );\n            }\n        }\n        if( serviceData.deleted ) {\n            // Remove objects from CDM\n            cdm.removeObjects( serviceData.deleted );\n        }\n    }\n    const currentStore = appCtxSvc.getCtx( 'vmo' ) || {};\n    let timeNow = Date.now();\n    let values = {};\n    if( updatedObjs.length ) {\n        for( const mo of updatedObjs ) {\n            let refUid = getRefUid( mo );\n            let uidVal = mo.uid;\n            currentStore[ uidVal ] = {\n                type: mo.type,\n                time: timeNow,\n                ref: refUid\n            };\n            if( uidVal ) {\n                values[ uidVal ] = true;\n            }\n        }\n        const storeValues = Object.entries( currentStore );\n        if( !_.isEmpty( values ) ) {\n            for( const [ uid, { type, ref } ] of storeValues ) {\n                if( values[ ref ] ) {\n                    currentStore[ uid ] = {\n                        type: type,\n                        time: timeNow,\n                        ref: ref\n                    };\n                }\n            }\n        }\n        appCtxSvc.registerCtx( 'vmo', currentStore );\n    }\n    return response;\n}\n\nconst getRefUid = mo => {\n    if( mo.type === 'Awp0XRTObjectSetRow' && mo.props && mo.props.awp0Target ) {\n        return mo.props.awp0Target.dbValues[ 0 ];\n    }\n    return null;\n};\n\n/**\n * Process service data in HTTP response.\n *\n * @param {Object} response - JSON response data\n * @param {String} operationName - operation name\n * @return {Promise} Promise resolved once types are loaded\n */\nfunction processResponseTypes( response, operationName ) {\n    if( response ) {\n        const modelObjs = [];\n        const typeNamesObj = {};\n\n        const qName = response[ '.QName' ];\n        if( qName !== 'http://teamcenter.com/Schemas/Soa/2011-06/MetaModel.TypeSchema' ) {\n            extractModelObjAndTypeFromResponse( response, modelObjs, typeNamesObj );\n        }\n\n        const typeNames = Object.keys( typeNamesObj );\n\n        if( operationName === GET_SESSION_INFO.operationName && response.extraInfoOut ) {\n            if( response.extraInfoOut.AWC_StartupTypes ) {\n                _typeCacheLMD = response.extraInfoOut.typeCacheLMD;\n                _awStartupPreferences = response.extraInfoOut.AWC_StartupTypes.split( ',' );\n\n                // Always include TC_Project even if not in the start up preference\n                if( !_.includes( _awStartupPreferences, 'TC_Project' ) ) {\n                    _awStartupPreferences.push( 'TC_Project' );\n                }\n\n                // Always include ListOfValuesString even if not in the start up preference\n                if( !_.includes( _awStartupPreferences, 'ListOfValuesString' ) ) {\n                    _awStartupPreferences.push( 'ListOfValuesString' );\n                }\n            }\n            const loadedTypes = typeCacheSvc.getLocalTypes( _typeCacheLMD );\n            cmm.cacheTypes( loadedTypes );\n        }\n\n        return exports.ensureModelTypesLoaded( typeNames ).then( function() {\n            // Just in case we have more types, let's go get them...\n            return processResponseObjects( response, modelObjs );\n        } );\n    }\n\n    return AwPromiseService.instance.resolve();\n}\n\n/**\n *\n * Gets the effective property policy\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {boolean} isSelectedPropertyPolicy - boolean which indicates whether the selected property is required\n *            or not.\n * @returns {Object} request body with defaulting & validation complete\n * @private\n */\nfunction getEffectivePropertyPolicy( propertyPolicyOverride, isSelectedPropertyPolicy ) {\n    if( _.isString( propertyPolicyOverride ) ) {\n        return JSON.parse( propertyPolicyOverride );\n    }\n    if( _.isObject( propertyPolicyOverride ) ) {\n        // No need to pass a property policy for this call.\n        return propertyPolicyOverride;\n    }\n    return propPolicySvc.getEffectivePolicy( exports, isSelectedPropertyPolicy );\n}\n\n/**\n * @param {String} clientId - client ID used in SOA header\n */\nexport const setClientIdHeader = function( clientId ) {\n    _clientId = clientId;\n};\n\n/**\n * @return {String} client ID used in SOA header\n */\nexport const getClientIdHeader = function() {\n    return _clientId;\n};\n\n/**\n * @param {Number} pollingTimeout - timeout to allow polling SOA calls to be made after last non-polling call (minutes)\n */\nexport const setPollingTimeout = function( pollingTimeout ) {\n    if( pollingTimeout ) {\n        _pollingTimeout = pollingTimeout * 60;\n    }\n};\n\n/**\n * Teamcenter SOA request.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n *\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @param {Boolean} checkPartialErrors - check for partial errors in the response\n * @param {Boolean} polling - true if this is a polling call\n *\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\nexport const request = function( serviceName, operationName, body, {\n    propertyPolicyOverride,\n    ignoreHost = false,\n    headerStateOverride = false,\n    checkPartialErrors = false,\n    polling = false\n} = {} ) {\n    assert( serviceName, 'Service name not provided!' );\n    assert( operationName, 'Operation name not provided!' );\n\n    // Support polling SOA calls to have a timeout. This stops an idle client\n    // browser from making polling calls.This is required because the TC web\n    // tier needs to be able to allow it's session to timeout.\n    if( _pollingTimeout > 0 ) {\n        if( polling ) {\n            // Determine when last call was made.\n            const timeOfLastCall = _.toNumber( localStrg.get( 'soaService.timeOfLastCall' ) );\n            if( timeOfLastCall ) {\n                const secsSinceLastCall = ( Date.now() - timeOfLastCall ) / 1000;\n                // If longer than polling timeout, avoid call.\n                if( secsSinceLastCall > _pollingTimeout ) {\n                    return AwPromiseService.instance.reject( new Error( 'Polling call skipped due to client inactivity.' ) );\n                }\n            }\n        } else {\n            // localStorage is being used because SOA calls from other\n            // browsers tabs allow this tab to make the polling call.\n            localStrg.publish( 'soaService.timeOfLastCall', Date.now() );\n        }\n    }\n\n    let isSelectedPropertyPolicy = false;\n\n    let endPt;\n\n    let promise;\n    if( GET_SESSION_INFO.serviceName === serviceName && GET_SESSION_INFO.operationName === operationName ) {\n        // avoid loading schema for get session info call\n        const schemaService = {};\n        schemaService[ GET_SESSION_INFO.operationName ] = {}; // extraInfoIn: \"String[]\"\n        promise = AwPromiseService.instance.resolve( schemaService );\n    } else {\n        promise = configSvc.getCfg( 'schema.' + serviceName ).then( function( schemaService ) {\n            return schemaService;\n        }, function() {\n            // none found\n            logger.warn( 'No SOA schema definition found!' );\n            return {};\n        } );\n    }\n\n    return promise.then( function( schemaService ) {\n        if( appCtxSvc.ctx.aw_hosting_enabled && !appCtxSvc.ctx.aw_hosting_soa_support_checked ) {\n            appCtxSvc.ctx.aw_hosting_soa_support_checked = true;\n        }\n\n        if( body ) {\n            isSelectedPropertyPolicy = propPolicySvc.checkForSelectedObject( body );\n        }\n\n        const jsonData = {\n            header: {\n                state: {\n                    clientVersion: '10000.1.2',\n                    /**\n                     * Correlation ID for logging purposes (debug).\n                     */\n                    logCorrelationID: logger.getCorrelationID(),\n                    /**\n                     * Permanent ID/recipes are used for the runtime business object’s (BOMLine objects) opaque UIDs\n                     * in requests/responses.\n                     * <p>\n                     * If the unloadObjects key is not in the request headers, all business objects are unloaded at\n                     * the top of each request; see the processTagManager ITK for more information.\n                     */\n                    stateless: true,\n                    /**\n                     * If true, All business objects are unloaded at the top of each request; see the\n                     * processTagManager ITK for more information. Previously controlled through the stateless flag.\n                     * <p>\n                     * When is stateless=true mode this value must be explicitly set to false to keep objects\n                     * loaded.\n                     */\n                    unloadObjects: true,\n                    /**\n                     * If true, process server-session state key/value pairs found in the request headers. This\n                     * turns all session state into client-session data. The standalone AW client should set this to\n                     * true, while the hosted AW client should set it false (or not send it at all).\n                     */\n                    enableServerStateHeaders: !_redirectSoaSvc,\n                    /**\n                     */\n                    formatProperties: true\n                },\n                policy: getEffectivePropertyPolicy( propertyPolicyOverride, isSelectedPropertyPolicy )\n            },\n            body: defaultAndValidateElement( schemaService, serviceName, operationName, body )\n        };\n\n        mergeHeaderState( jsonData.header.state, headerStateOverride );\n\n        if( appCtxSvc && appCtxSvc.getCtx( 'objectQuotaContext.useObjectQuota' ) ) {\n            /**\n             * If true, All business objects are unloaded at the top of each request. Applications might want to\n             * rely on object quota based unload. In such cases they can use \"objectQuotaContext\" to override this\n             * behavior and reset this flag to avail this feature\n             */\n            jsonData.header.state.unloadObjects = false;\n        }\n\n        if( !_redirectSoaSvc && _clientId !== '' ) {\n            jsonData.header.state.clientID = _clientId;\n        }\n\n        const headers = {\n            // Only US-ASCII characters are allowed in HTTP headers\n            // http://stackoverflow.com/questions/34670413/regexp-to-validate-a-http-header-value/34710882#34710882\n            'Log-Correlation-ID': jsonData.header.state.logCorrelationID.replace( /[^\\x20-\\x7E]+/g, '' )\n        };\n\n        if( GET_SESSION_INFO.serviceName === serviceName && GET_SESSION_INFO.operationName === operationName ) {\n            headers.clientIP = 'browser-client';\n        }\n\n        let awSession = localStrg.get( 'awSession' );\n        if( awSession ) {\n            try {\n                awSession = JSON.parse( awSession );\n                if( !appCtxSvc.ctx.aw_hosting_enabled ) {\n                    if( awSession.groupMemberUID ) { jsonData.header.state.groupMember = awSession.groupMemberUID; }\n                    if( awSession.roleName ) { jsonData.header.state.role = awSession.roleName; }\n                }\n                if( awSession.locale ) { jsonData.header.state.locale = awSession.locale; }\n            } catch ( err ) {\n                logger.debug( err );\n                localStrg.removeItem( 'awSession' );\n            }\n        }\n\n        endPt = serviceName + '/' + operationName;\n\n        if( logger.isTraceEnabled() ) {\n            logger.trace( '\\n' + 'soaService.post to ' + endPt, jsonData );\n        }\n\n        pendingRequests++;\n        eventBus.publish( 'progress.start', {\n            endPoint: endPt\n        } );\n\n        /**\n         * Check if there is a 'host' process that is handling SOA processing<BR>\n         * If so: Send the 'endPt' and data to that service.\n         */\n\n        // The only case the client will make its own login call when hosted would be when it needs credentials.\n        // If such a call is made, we should not make it through the host. This is the only case when AW talks directly to the server.\n        // This will allow Viewer to show up in hosts.\n        if( _redirectSoaSvc && !ignoreHost ) {\n            return _redirectSoaSvc.post( serviceName, operationName, jsonData );\n        }\n\n        const $http = AwHttpService.instance;\n\n        trace( 'HTTP call start', serviceName, operationName );\n        return $http.post( browserUtils.getBaseURL() + 'tc/JsonRestServices/' + endPt, jsonData, {\n            headers: headers\n        } ).then( function( response ) {\n            trace( 'HTTP call complete', serviceName, operationName );\n            assert( response, 'No response given for ' + endPt );\n\n            const body2 = response.data;\n\n            assert( typeof body2 !== 'string' || body2.indexOf( '<?xml version' ) === -1,\n                'Unexpected response body for: ' + endPt );\n\n            return body2;\n        } );\n    } ).then( function( response ) {\n        pendingRequests--;\n        eventBus.publish( 'progress.end', {\n            endPoint: endPt\n        } );\n        if( logger.isTraceEnabled() ) {\n            logger.trace( 'endPt=' + endPt, response );\n        }\n        return processExceptions( response, serviceName, operationName );\n    }, function( err ) {\n        pendingRequests--;\n        eventBus.publish( 'progress.end', {\n            endPoint: endPt\n        } );\n        throw exports.createError( err );\n    } ).then( function( response ) {\n        if( !propertyPolicyOverride && !isSelectedPropertyPolicy ) {\n            loadPropertiesIfRequired( response );\n        }\n        return processResponseTypes( response, operationName );\n    } ).then( function( response ) {\n        if( checkPartialErrors && response ) {\n            if( response.PartialErrors ) {\n                throw exports.createError( response.PartialErrors );\n            }\n            const serviceData = getServiceData( response );\n            if( serviceData && serviceData.partialErrors ) {\n                throw exports.createError( serviceData );\n            }\n        }\n        return response;\n    } );\n};\n\n/**\n * Merge default header state with the given overrides\n *\n * @param {Object|String} defaultHeaderState - SOA header state default (or NULL)\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n */\nfunction mergeHeaderState( defaultHeaderState, headerStateOverride ) {\n    const keys = headerStateOverride ? Object.keys( headerStateOverride ) : [];\n    for( let i = 0; i < keys.length; ++i ) {\n        defaultHeaderState[ keys[ i ] ] = headerStateOverride[ keys[ i ] ];\n    }\n}\n\n/**\n * Calls getProperties Soa to load additional properties if required.\n *\n * @param {Object} response - JSON response data\n */\nfunction loadPropertiesIfRequired( response ) {\n    if( response ) {\n        const serviceData = getServiceData( response );\n        if( serviceData ) {\n            const responseObjects = [];\n            if( serviceData.updated ) {\n                for( let ii2 = 0; ii2 < serviceData.updated.length; ii2++ ) {\n                    const updatedUid = serviceData.updated[ ii2 ];\n                    if( !cmm.isTypeUid( updatedUid ) ) {\n                        const updatedObject = cdm.getObject( updatedUid );\n                        if( updatedObject ) {\n                            responseObjects.push( updatedObject );\n                        }\n                    }\n                }\n            }\n            if( serviceData.created ) {\n                for( let ii = 0; ii < serviceData.created.length; ii++ ) {\n                    const createdObject = cdm.getObject( serviceData.created[ ii ] );\n                    if( createdObject ) {\n                        responseObjects.push( createdObject );\n                    }\n                }\n            }\n\n            if( responseObjects.length > 0 &&\n                propPolicySvc.checkForSelectedObject( null, responseObjects ) ) {\n                exports.request( 'Core-2006-03-DataManagement', 'getProperties', {\n                    objects: responseObjects,\n                    attributes: []\n                }, {\n                    propertyPolicyOverride: propPolicySvc.getEffectivePolicy( null, true )\n                } );\n            }\n        }\n    }\n}\n\n/**\n * SOA post unchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Bool} ignoreHost - Flag to say ignore hosting when making soa call.\n * @param {Object|String} headerStateOverride - SOA header state override (or NULL)\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\nexport const postUnchecked = function( serviceName, operationName, body, propertyPolicyOverride, ignoreHost, headerStateOverride ) {\n    return exports.request( serviceName, operationName, body, {\n        propertyPolicyOverride,\n        ignoreHost,\n        headerStateOverride\n    } );\n};\n\n/**\n * SOA post.\n *\n * If the response contains partial errors, it will be treated as an exception & thrown. If this isn't desired,\n * use postUnchecked.\n *\n * @param {String} serviceName - SOA service name\n * @param {String} operationName - SOA operation name\n * @param {String} body - JSON body\n * @param {Object|String} propertyPolicyOverride - SOA property policy override (or NULL)\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\nexport const post = function( serviceName, operationName, body, propertyPolicyOverride, ignoreHost ) {\n    return exports.request( serviceName, operationName, body, {\n        propertyPolicyOverride,\n        ignoreHost,\n        checkPartialErrors: true\n    } );\n};\n\n\n/**\n * Set session information into local storage (if needed)\n *\n * @param {Boolean} signOut - sign out\n */\nexport const setSessionInfo = function( signOut ) {\n    if( !signOut ) {\n        const userSession = cdm.getUserSession();\n        if( userSession ) {\n            // Store all the required fields to support the SOA header\n            const awSession = {\n                groupMemberUID: _.get( userSession, 'props.fnd0groupmember.dbValues.0' ),\n                locale: _.get( userSession, 'props.fnd0locale.dbValues.0' ),\n                roleName: _.get( userSession, 'props.role_name.dbValues.0' )\n            };\n            localStrg.publish( 'awSession', JSON.stringify( awSession ) );\n        }\n    } else {\n        localStrg.removeItem( 'awSession' );\n    }\n};\n\n/**\n * Perform an async get of current Teamcenter session information.\n *\n * @param {Boolean} ignoreHost - ignore SOA tunnel by host?\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */\nexport const getTCSessionInfo = function( ignoreHost ) {\n    // Ensure we have the required properties for the UserSession.\n    const policyId = propPolicySvc.register( {\n        types: [ {\n            name: 'UserSession',\n            properties: [ {\n                name: 'awp0RevRule',\n                modifiers: [ {\n                    name: 'includeIsModifiable',\n                    Value: 'true'\n                } ]\n            }, {\n                name: 'user',\n                modifiers: [ {\n                    name: 'withProperties',\n                    Value: 'true'\n                } ]\n            }, {\n                name: 'user_id'\n            }, {\n                name: 'group',\n                modifiers: [ {\n                    name: 'withProperties',\n                    Value: 'true'\n                } ]\n            }, {\n                name: 'group_name'\n            }, {\n                name: 'project'\n            }, {\n                name: 'role'\n            }, {\n                name: 'role_name'\n            }, {\n                name: 'fnd0locale'\n            }, {\n                name: 'fnd0LocationCode'\n            }, {\n                name: 'fnd0groupmember'\n            } ]\n        }, {\n            name: 'Group',\n            properties: [ {\n                name: 'privilege'\n            } ]\n        }, {\n            name: 'User',\n            properties: [ {\n                name: 'home_folder'\n            } ]\n        } ]\n    } );\n    return exports.request( GET_SESSION_INFO.serviceName, GET_SESSION_INFO.operationName, {}, {\n        ignoreHost,\n        checkPartialErrors: true\n    } ).then( function( response ) {\n        propPolicySvc.unregister( policyId );\n        exports.setSessionInfo();\n        return response;\n    } ).catch( function( err ) {\n        propPolicySvc.unregister( policyId );\n\n        // Since we have no session, clear the session from localStorage to ensure we don't try to use it.\n        localStrg.removeItem( 'awSession' );\n\n        throw err;\n    } );\n};\n\n/**\n * Get Type Descriptions from server.\n *\n * Note, this is hidden in this file to avoid anyone else directly calling this.\n *\n * @private\n *\n * @param {StringArray} typeNames - Array of type names\n *\n * @return {Promise} Promise who's resolution is the result of the SOA 'getTypeDescriptions2' operation.\n */\nasync function getTypeDescriptions( typeNames ) {\n    assert( typeNames && typeNames.length > 0, 'No type names provided!' );\n    typeNames.sort();\n    const typeNamesFinal = _.uniq( typeNames, true );\n\n    const typesToLoad = typeNamesFinal.filter( type => {\n        if( !_typeLoadInProgress[ type ] ) {\n            return type;\n        }\n    } );\n\n    const currentTypesBeingLoadedPromises = typeNamesFinal.filter( type => !typesToLoad.includes( type ) ).map( type => {\n        if( _typeLoadInProgress[ type ] ) {\n            return _typeLoadInProgress[ type ];\n        }\n    } );\n\n    const newLoadPromises = [];\n\n    if( typesToLoad.length > 0 ) {\n        const loadTypesPromise = exports.request( 'Core-2015-10-Session', 'getTypeDescriptions2', {\n            typeNames: typesToLoad,\n            options: {\n                PropertyExclusions: [\n                    'LovReferences',\n                    'NamingRules',\n                    'RendererReferences'\n                ],\n                TypeExclusions: [\n                    'DirectChildTypesInfo',\n                    'RevisionNamingRules',\n                    'ToolInfo'\n                ]\n            }\n        }, {\n            propertyPolicyOverride: {}\n        } );\n\n        for( const type of typesToLoad ) {\n            _typeLoadInProgress[ type ] = loadTypesPromise;\n        }\n\n        newLoadPromises.push( loadTypesPromise );\n    }\n\n    const response = await Promise.all( [ ...currentTypesBeingLoadedPromises, ...newLoadPromises ] );\n\n    for( const type of typesToLoad ) {\n        delete _typeLoadInProgress[ type ];\n    }\n\n    return response;\n}\n\n/**\n * Verify async that the given model types are loaded into the client's meta model.\n *\n * @param {StringArray} typeNames - An array of type names to ensure are cached.\n *\n * @return {Promise} Promise who's resolution is a 'null' value since the types are now loaded into the cache.\n *         This 'null' result is required because the GWT-side wrapper requires an AsyncCallback<Void> callback\n *         (not AsyncCallback<IJsAarray>).\n */\nexport const ensureModelTypesLoaded = function( typeNames ) {\n    /**\n     * Handle trivial case\n     */\n    if( !typeNames ) {\n        return AwPromiseService.instance.reject( 'Invalid type name array specified' );\n    }\n\n    /**\n     * From the input list of type names, get a list of unique type names not in the CMM already.\n     */\n    const missingTypeNames = [];\n\n    _.forEach( typeNames, function( typeName ) {\n        if( !cmm.containsType( typeName ) && _invalidTypeNames.indexOf( typeName ) === -1 ) {\n            missingTypeNames.push( typeName );\n        }\n    } );\n\n    /**\n     * Check if we have any missing.\n     */\n    if( missingTypeNames.length > 0 ) {\n        // logger.info( \"Missing Types: \" + JSON.stringify( missingTypeNames ) );\n\n        return getTypeDescriptions( missingTypeNames ).then( function( responseGetTypeDescriptions ) {\n            for( const response of responseGetTypeDescriptions ) {\n                if( response && response.types ) {\n                    const modelTypes = response.types;\n                    const modelTypes2 = [];\n\n                    _.forEach( modelTypes, function( typeName ) {\n                        if( !cmm.containsType( typeName ) ) {\n                            modelTypes2.push( typeName );\n                        }\n                    } );\n\n                    if( modelTypes2.length > 0 ) {\n                        cmm.cacheTypes( modelTypes2 );\n                        // Cache the types in localStorage.\n                        typeCacheSvc.setLocalTypes( modelTypes2, _awStartupPreferences, _typeCacheLMD, true );\n                    }\n                }\n\n                // Capture invalid type names\n                _.forEach( missingTypeNames, function( typeName ) {\n                    if( !cmm.containsType( typeName ) ) {\n                        // add empty type to avoid future server calls\n                        _invalidTypeNames.push( typeName );\n                        _invalidTypeNames.sort();\n                        _invalidTypeNames = _.uniq( _invalidTypeNames, true );\n                    }\n                } );\n            }\n            return null;\n        } );\n    }\n\n    return AwPromiseService.instance.resolve();\n};\n\n/**\n * Setup to log all events fired on the 'soajs' eventBus event channel.\n */\nif( logger && logger.isTraceEnabled() ) {\n    eventBus.subscribe( '#', function( data, envelope ) {\n        let msg = 'eventBus: ' + envelope.topic + ' @ ' + envelope.timeStamp;\n\n        if( data && data.endPoint ) {\n            if( envelope.topic === 'progress.start' ) {\n                _lastStartDate[ data.endPoint ] = envelope.timeStamp;\n            } else if( envelope.topic === 'progress.end' && _lastStartDate[ data.endPoint ] ) {\n                const msDelta = envelope.timeStamp.getTime() - _lastStartDate[ data.endPoint ].getTime();\n\n                msg = msg + '\\n' + '          Time: ' + msDelta + 'ms' + '    ' + data.endPoint;\n\n                _lastStartDate[ data.endPoint ] = null;\n            }\n        }\n\n        if( logger.isTraceEnabled() ) {\n            // Just print, using logger.trace causes infinite recursion\n            console.debug( msg, envelope ); // eslint-disable-line no-console\n        }\n    }, 'soa_kernel_soaService' );\n}\n\n/**\n * Determine if the user is currently signed in.\n *\n * @return {boolean} is signed in?\n */\nexport const isSignedIn = function() {\n    return _signedIn;\n};\n\nexport const getPendingRequestsCount = function() {\n    return pendingRequests;\n};\n\n/**\n * Subscribe to listen when we are signed in/out. Just tracking state locally. NOTE - for non User/PW\n * authentication, this state may not be 100% accurate.\n */\neventBus.subscribe( 'session.signIn', function() {\n    _signedIn = true;\n}, 'soa_kernel_soaService' );\n\neventBus.subscribe( 'session.signOut', function() {\n    _signedIn = false;\n}, 'soa_kernel_soaService' );\n\nconst exports = {\n    createError,\n    postUnchecked,\n    post,\n    request,\n    setSessionInfo,\n    getTCSessionInfo,\n    ensureModelTypesLoaded,\n    isSignedIn,\n    setClientIdHeader,\n    getClientIdHeader,\n    setPollingTimeout,\n    setSoaRedirect,\n    getPendingRequestsCount\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}