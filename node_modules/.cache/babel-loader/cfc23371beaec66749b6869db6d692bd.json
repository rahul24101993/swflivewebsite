{"ast":null,"code":"/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.\n *\n * @module js/declViewModelProcessingFactory\n *\n * @namespace viewModelProcessingFactory\n */\nimport _ from 'lodash';\nimport viewModelSvc from 'js/viewModelService';\nimport { loadAction, validateLovAction } from 'js/dataProviderFactory';\nimport { processGrids } from 'js/gridProviderUtils';\nimport syncStrategySvc from 'js/syncStrategyService';\nimport { evalDataDefinition, cloneDeepJsonObject } from 'js/declReactUtils';\nimport conditionService from 'js/conditionService';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport { composeDispatch } from 'js/store';\nimport declUtils from 'js/declUtils';\nimport { shouldCreateViewModelProperty, initViewModel } from 'js/viewModelProcessingFactory';\nimport { defineLazyGetter } from 'js/functionalUtility.service';\nimport debugService from 'js/debugService';\nimport dataProviderService from 'js/declDataProviderService';\nimport declDragAndDropService from 'js/declDragAndDropService';\n/**\n * create data instance from data definition\n * @param {JSON} dataDef data section definition\n * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}\n * @param {object} vmDef viewModel template\n * @param {object} subPanelContext subPanelContext\n * @param {object} props props value\n * @returns {object} data object\n */\n\nfunction createData() {\n  let dataDef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let scope = arguments.length > 1 ? arguments[1] : undefined;\n  let vmDef = arguments.length > 2 ? arguments[2] : undefined;\n  let subPanelContext = arguments.length > 3 ? arguments[3] : undefined;\n  let props = arguments.length > 4 ? arguments[4] : undefined;\n  const filteredDataDef = {}; // This would filter out the atomic object from the data.\n\n  const dataKeys = Object.keys(dataDef).filter(keyName => !_.has(dataDef, `${keyName}.meta`));\n  dataKeys.forEach(key => filteredDataDef[key] = dataDef[key]);\n  const data = scope ? evalDataDefinition(filteredDataDef, scope) : cloneDeepJsonObject(filteredDataDef);\n  /**\n   * Recursively initialize the property values of the given JSON data object with the current value of any bound\n   * appContext properties (bound via {{ctx.*}}).\n   */\n\n  initViewModel(data, subPanelContext, props); // Assume all root value witout _ is vmo prop\n\n  for (const prop in data) {\n    if (prop === 'objects') {\n      data[prop] = vmDef[prop];\n      continue;\n    }\n\n    if (prop === 'uid') {\n      vmDef.vmo = vmDef.attachModelObject(data[prop]);\n      continue;\n    }\n\n    if (!shouldCreateViewModelProperty(data[prop])) {\n      continue;\n    }\n\n    let propAttrHolder = declUtils.buildPropHolder(data[prop]);\n    /**\n     * Make sure we have a 'propName' set.\n     */\n\n    if (!data[prop].propName) {\n      data[prop].propName = prop;\n    } // If this is not a view model prop, just save the object to the data.\n\n\n    if (_.isEmpty(propAttrHolder)) {\n      data[prop] = vmDef[prop];\n      continue;\n    }\n\n    if (!prop.startsWith('_') && typeof data[prop] === 'object') {\n      let vmProp = modelPropertySvc.createViewModelProperty(data[prop]);\n\n      if (!declUtils.isNil(data[prop].uiValue)) {\n        vmProp.uiValue = data[prop].uiValue;\n      }\n\n      if (!declUtils.isNil(data[prop].dbValue)) {\n        vmProp.dbValue = data[prop].dbValue;\n      }\n\n      if (dataDef[prop].dataProvider) {\n        // we have an lov, but the api is defined using the dataProvider\n        vmProp.dataProvider = dataDef[prop].dataProvider;\n        vmProp.hasLov = true;\n        vmProp.emptyLOVEntry = dataDef[prop].emptyLOVEntry;\n      }\n\n      data[prop] = vmProp;\n    }\n  } // do init hook her if needed\n  // vmDef.executeHook( 'onInit', props, [ data ], ctxHook );\n\n\n  return data;\n}\n/**\n * create lifecycle hook based on action map\n * @param {Object} lifecycleHookDefs life cycle hook definition\n * @param {Object} actions action map\n * @returns {object} lifecyclehook callback map\n */\n\n\nfunction createLifecycleHooks() {\n  let lifecycleHookDefs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let actions = arguments.length > 1 ? arguments[1] : undefined;\n  let hooksActionsMap = {};\n\n  _.forEach(lifecycleHookDefs, (actionName, hookName) => {\n    // Map onInit hook to onMount - This would not work when we have have both onInit and onMount\n    // defined for a component.onInit would never get a chance to get invoked.\n    //hookName = hookName === 'onInit' ? 'onMount' : hookName;\n    if (Array.isArray(actionName)) {\n      hooksActionsMap[hookName] = [];\n\n      _.forEach(actionName, function (actionObj) {\n        hooksActionsMap[hookName].push(actions[actionObj.action]);\n      });\n    } else {\n      if (!actions[actionName] && typeof Object) {\n        //Is mapped to an object with observer and action.\n        hooksActionsMap[hookName] = actions[actionName.action];\n      } else {\n        hooksActionsMap[hookName] = actions[actionName];\n      }\n    }\n  });\n\n  return hooksActionsMap;\n}\n/**\n * create valiation rule based on property definition\n * @param {JSON} props property definitions\n * @param {JSON} conds condition definitions\n * @returns {object} property validation objects\n */\n\n/**\n * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API\n * @param {JSON} declViewModelJson view model definition\n * @param {object} prop componet prop\n * @returns {object} view model factory\n */\n\n\nexport function createDeclViewModel(declViewModelJson) {\n  let prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    viewId,\n    subPanelContext\n  } = prop;\n  declViewModelJson.data = declViewModelJson.data || {};\n  const vmDef = viewModelSvc.populateViewModelPropertiesFromJson(declViewModelJson, null, null, null, null, subPanelContext);\n\n  if (viewId) {\n    vmDef._internal.viewId = viewId;\n  } // put declViewModelJson to vmDef\n\n\n  vmDef.declViewModelJson = declViewModelJson; // build data creation function\n\n  vmDef.createData = scope => createData(declViewModelJson.data, scope, vmDef, subPanelContext, prop); // create sync strategy ports\n\n\n  vmDef.createPorts = () => {\n    return cloneDeepJsonObject(declViewModelJson.ports);\n  };\n\n  vmDef.createFieldsData = () => {\n    let initialState = {};\n\n    for (const prop in declViewModelJson.data) {\n      if (declViewModelJson.data[prop] && declViewModelJson.data[prop].meta) {\n        initialState[prop] = declViewModelJson.data[prop].initialValues;\n      }\n    }\n\n    return initialState;\n  };\n\n  vmDef.createDataProvider = () => {\n    return vmDef.dataProviders;\n  }; //build LifecycleHooks\n\n\n  vmDef.createLifecycleHooks = actions => createLifecycleHooks(declViewModelJson.lifecycleHooks, actions); // bind drag drop handler  with declViewModal\n\n\n  declDragAndDropService.setupDragAndDropOnView(vmDef);\n  return vmDef;\n}\n\nconst bindActions = function (viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel) {\n  viewModel.actions = _.mapValues(declViewModelJson.actions, actionDef => renderOptions => {\n    let fields = dataCtxNode.getFields(); // #49 - Side effect in example 'Notification Messages'\n\n    Object.assign(dataCtxNode.data, getData());\n    getProps && Object.assign(dataCtxNode, {\n      props: getProps(),\n      getProps\n    });\n    fields && Object.assign(dataCtxNode, {\n      fields\n    });\n\n    if (renderOptions) {\n      //add the parameter here\n      //add the function ref necessary to execute a command action programatically\n      dataCtxNode.parameters = { ...renderOptions,\n        commandActionExecutor: {\n          runActionWithViewModel\n        }\n      };\n    }\n\n    return viewModelSvc.executeCommand(viewModel, actionDef.actionId, dataCtxNode);\n  });\n};\n\nconst bindChartProvider = function (viewModel, vmDef, dataCtxNode) {\n  if (viewModel.chartProviders && !_.isEmpty(viewModel.chartProviders)) {\n    _.mapValues(viewModel.chartProviders, function (chartProvider) {\n      if (chartProvider.loadDataAction) {\n        chartProvider.loadDataActionCallBack = () => {\n          return dataProviderService.executeLoadAction(vmDef.getAction(chartProvider.loadDataAction), {}, dataCtxNode);\n        };\n      }\n\n      if (chartProvider.selectAction) {\n        chartProvider.selectActionCallBack = selectedChartEntity => {\n          if (!dataCtxNode.parameters) {\n            dataCtxNode.parameters = {};\n          }\n\n          dataCtxNode.parameters.selectedChartEntity = { ...selectedChartEntity\n          };\n          return viewModelSvc.executeCommand(viewModel, vmDef.getAction(chartProvider.selectAction).actionId, dataCtxNode);\n        };\n      }\n\n      if (chartProvider.unSelectAction) {\n        chartProvider.unSelectedActionCallBack = unSelectedChartEntity => {\n          if (!dataCtxNode.parameters) {\n            dataCtxNode.parameters = {};\n          }\n\n          dataCtxNode.parameters.unSelectedChartEntity = { ...unSelectedChartEntity\n          };\n          return viewModelSvc.executeCommand(viewModel, vmDef.getAction(chartProvider.unSelectAction).actionId, dataCtxNode);\n        };\n      }\n    });\n  }\n};\n\nconst bindDataProvider = function (viewModel, dataCtxNode, getData, getProps) {\n  _.mapValues(viewModel.dataProviders, dataProvider => dataProvider.loadAction = async (vmCollection, startIndex, pageObject) => {\n    Object.assign(dataCtxNode.data, getData());\n    getProps && Object.assign(dataCtxNode, {\n      props: getProps(),\n      getProps\n    });\n    return loadAction(dataProvider, dataCtxNode, vmCollection, startIndex, pageObject);\n  });\n};\n\nconst bindStaticDataProvider = function (viewModel, dataCtxNode) {\n  _.mapValues(viewModel.dataProviders, dataProvider => dataProvider.validateLovAction = async input => {\n    return validateLovAction(input, dataProvider, dataCtxNode);\n  });\n};\n/**\n * process vmDef, ctx and data to create view model instance\n * @param {object} vmDef view model definition\n * @param {Array} ctxHook react ctx hook in data-dispatch pair\n * @param {Array} dataHook  react data hook in dta-dispatch pair\n * @param {Array} portsHook  react data hook in portsHook pair\n * @param {object} allAtomicData  react dataProviders\n * @param {object} getProps getProps\n * @param {object} runActionWithViewModel callback function\n * @param {object} getFields getFields\n * @returns {object} view model instance\n */\n\n\nexport function processViewModel(vmDef, ctxHook, dataHook, portsHook) {\n  let allAtomicData = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let getProps = arguments.length > 5 ? arguments[5] : undefined;\n  let runActionWithViewModel = arguments.length > 6 ? arguments[6] : undefined;\n  let getFields = arguments.length > 7 ? arguments[7] : undefined;\n  const [ctx, updateCtx] = ctxHook;\n  const props = getProps ? getProps() : {};\n  const [data, updateData, getData] = dataHook;\n  const declViewModelJson = vmDef.declViewModelJson;\n  let dispatchers = {\n    ctx: updateCtx,\n    data: updateData\n  };\n  debugService.debug('lifeCycles', vmDef._internal.panelId, 'init'); // fields data\n\n  let atomicData = {};\n  let updateAtomicData = {};\n  let atomicDataHook = allAtomicData.atomicDataHook ? allAtomicData.atomicDataHook : {};\n  const atomicDataHookKeys = Object.keys(atomicDataHook);\n\n  _.forEach(atomicDataHookKeys, function (stateName) {\n    atomicData[stateName] = atomicDataHook[stateName][0];\n    updateAtomicData[stateName] = allAtomicData.atomicDataRef[stateName].setAtomicData;\n  }); // sync strategy port dispatcher\n\n\n  let ports;\n  let updatePorts;\n\n  if (declViewModelJson.ports && portsHook) {\n    [ports, updatePorts] = portsHook;\n    dispatchers.ports = updatePorts;\n  } // dispatch method\n\n\n  const {\n    dispatch\n  } = composeDispatch(dispatchers);\n  const viewModel = {\n    // store\n    ctx,\n    data,\n    atomicData,\n    updateAtomicData,\n    atomicDataRef: allAtomicData.atomicDataRef,\n    //subPanelContext\n    subPanelContext: props.subPanelContext,\n    // dispatch\n    dispatch,\n    // getData\n    getData,\n    // context for post eval\n    conditions: {},\n    expressions: {},\n    oldExpressions: {},\n    i18n: declViewModelJson.i18n,\n    onEvent: declViewModelJson.onEvent,\n    messages: declViewModelJson.messages,\n    ports: ports\n  }; // revisitme - data (the section in the VM needs to be directly available on the viewModel)\n  // not doing deep copy has side effects. This will be modified depending on the approach\n  // that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.\n\n  _.assign(viewModel, vmDef);\n\n  let dataObj = data; // We need deep copy for data providers.\n\n  if (dataObj && dataObj.dataProviders) {\n    let dataObjDataProviders = dataObj.dataProviders;\n    delete dataObj.dataProviders;\n\n    for (const dpKey in dataObjDataProviders) {\n      if (viewModel.dataProviders && viewModel.dataProviders[dpKey]) {\n        _.assign(viewModel.dataProviders[dpKey], dataObjDataProviders[dpKey]);\n      }\n    }\n  } // Not sure whether other portion of data needs deep copy. So not touching the same.\n\n\n  _.assign(viewModel, dataObj);\n\n  _.assign(viewModel, atomicData);\n\n  let dataCtxNode = {\n    props,\n    data: viewModel,\n    ctx,\n    subPanelContext: props.subPanelContext,\n    ports: viewModel.ports,\n    getProps,\n    getFields\n  }; // conditions\n  //lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it\n  //forEach because closure is needed\n\n  Object.entries(declViewModelJson.conditions || {}).forEach(_ref => {\n    let [key, value] = _ref;\n    defineLazyGetter(viewModel.conditions, key, () => conditionService.evaluateCondition(viewModel, value.expression, dataCtxNode));\n    defineLazyGetter(viewModel.expressions, key, () => [conditionService.parseExpression(viewModel, value.expression, dataCtxNode)]);\n  }); // bind action\n\n  bindActions(viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel); // grids\n\n  const grids = processGrids(vmDef.grids, viewModel, ctxHook[0]); // bind data provider\n\n  bindDataProvider(viewModel, dataCtxNode, getData, getProps); //bind callback for chartsProvider loadActionData\n\n  bindChartProvider(viewModel, vmDef, dataCtxNode); // bind validate action for static dataproviders\n\n  bindStaticDataProvider(viewModel, dataCtxNode); // validation criteria\n  //vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );\n  // Lifecycle Hooks\n\n  viewModel.lifecycleHooks = createLifecycleHooks(declViewModelJson.lifecycleHooks, viewModel.actions); // sync strategy\n\n  if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n    syncStrategySvc.setupSyncStrategy(dataCtxNode);\n  }\n\n  return {\n    viewModel,\n    grids\n  };\n}","map":{"version":3,"names":["_","viewModelSvc","loadAction","validateLovAction","processGrids","syncStrategySvc","evalDataDefinition","cloneDeepJsonObject","conditionService","modelPropertySvc","composeDispatch","declUtils","shouldCreateViewModelProperty","initViewModel","defineLazyGetter","debugService","dataProviderService","declDragAndDropService","createData","dataDef","scope","vmDef","subPanelContext","props","filteredDataDef","dataKeys","Object","keys","filter","keyName","has","forEach","key","data","prop","vmo","attachModelObject","propAttrHolder","buildPropHolder","propName","isEmpty","startsWith","vmProp","createViewModelProperty","isNil","uiValue","dbValue","dataProvider","hasLov","emptyLOVEntry","createLifecycleHooks","lifecycleHookDefs","actions","hooksActionsMap","actionName","hookName","Array","isArray","actionObj","push","action","createDeclViewModel","declViewModelJson","viewId","populateViewModelPropertiesFromJson","_internal","createPorts","ports","createFieldsData","initialState","meta","initialValues","createDataProvider","dataProviders","lifecycleHooks","setupDragAndDropOnView","bindActions","viewModel","dataCtxNode","getData","getProps","runActionWithViewModel","mapValues","actionDef","renderOptions","fields","getFields","assign","parameters","commandActionExecutor","executeCommand","actionId","bindChartProvider","chartProviders","chartProvider","loadDataAction","loadDataActionCallBack","executeLoadAction","getAction","selectAction","selectActionCallBack","selectedChartEntity","unSelectAction","unSelectedActionCallBack","unSelectedChartEntity","bindDataProvider","vmCollection","startIndex","pageObject","bindStaticDataProvider","input","processViewModel","ctxHook","dataHook","portsHook","allAtomicData","ctx","updateCtx","updateData","dispatchers","debug","panelId","atomicData","updateAtomicData","atomicDataHook","atomicDataHookKeys","stateName","atomicDataRef","setAtomicData","updatePorts","dispatch","conditions","expressions","oldExpressions","i18n","onEvent","messages","dataObj","dataObjDataProviders","dpKey","entries","value","evaluateCondition","expression","parseExpression","grids","setupSyncStrategy"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declViewModelProcessingFactory.js"],"sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.\n *\n * @module js/declViewModelProcessingFactory\n *\n * @namespace viewModelProcessingFactory\n */\nimport _ from 'lodash';\nimport viewModelSvc from 'js/viewModelService';\nimport { loadAction, validateLovAction } from 'js/dataProviderFactory';\nimport { processGrids } from 'js/gridProviderUtils';\nimport syncStrategySvc from 'js/syncStrategyService';\nimport {\n    evalDataDefinition,\n    cloneDeepJsonObject\n} from 'js/declReactUtils';\n\nimport conditionService from 'js/conditionService';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport { composeDispatch } from 'js/store';\nimport declUtils from 'js/declUtils';\nimport { shouldCreateViewModelProperty, initViewModel } from 'js/viewModelProcessingFactory';\nimport { defineLazyGetter } from 'js/functionalUtility.service';\nimport debugService from 'js/debugService';\nimport dataProviderService from 'js/declDataProviderService';\nimport declDragAndDropService from 'js/declDragAndDropService';\n\n/**\n * create data instance from data definition\n * @param {JSON} dataDef data section definition\n * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}\n * @param {object} vmDef viewModel template\n * @param {object} subPanelContext subPanelContext\n * @param {object} props props value\n * @returns {object} data object\n */\nfunction createData( dataDef = {}, scope, vmDef, subPanelContext, props ) {\n    const filteredDataDef = {};\n    // This would filter out the atomic object from the data.\n    const dataKeys = Object.keys( dataDef ).filter( ( keyName ) => !_.has( dataDef, `${keyName}.meta` ) );\n    dataKeys.forEach( ( key ) => filteredDataDef[ key ] = dataDef[ key ] );\n    const data = scope ? evalDataDefinition( filteredDataDef, scope ) : cloneDeepJsonObject( filteredDataDef );\n\n    /**\n     * Recursively initialize the property values of the given JSON data object with the current value of any bound\n     * appContext properties (bound via {{ctx.*}}).\n     */\n    initViewModel( data, subPanelContext, props );\n\n    // Assume all root value witout _ is vmo prop\n    for( const prop in data ) {\n        if( prop === 'objects' ) {\n            data[ prop ] = vmDef[ prop ];\n            continue;\n        }\n        if( prop === 'uid' ) {\n            vmDef.vmo = vmDef.attachModelObject( data[ prop ] );\n            continue;\n        }\n        if( !shouldCreateViewModelProperty( data[ prop ] ) ) {\n            continue;\n        }\n\n        let propAttrHolder = declUtils.buildPropHolder( data[ prop ] );\n\n        /**\n         * Make sure we have a 'propName' set.\n         */\n        if( !data[ prop ].propName ) {\n            data[ prop ].propName = prop;\n        }\n\n        // If this is not a view model prop, just save the object to the data.\n        if( _.isEmpty( propAttrHolder ) ) {\n            data[ prop ] = vmDef[ prop ];\n            continue;\n        }\n        if( !prop.startsWith( '_' ) && typeof data[ prop ] === 'object' ) {\n            let vmProp = modelPropertySvc.createViewModelProperty( data[ prop ] );\n            if( !declUtils.isNil( data[ prop ].uiValue ) ) {\n                vmProp.uiValue = data[ prop ].uiValue;\n            }\n\n            if( !declUtils.isNil( data[ prop ].dbValue ) ) {\n                vmProp.dbValue = data[ prop ].dbValue;\n            }\n\n            if( dataDef[ prop ].dataProvider ) {\n                // we have an lov, but the api is defined using the dataProvider\n                vmProp.dataProvider = dataDef[ prop ].dataProvider;\n                vmProp.hasLov = true;\n                vmProp.emptyLOVEntry = dataDef[ prop ].emptyLOVEntry;\n            }\n            data[ prop ] = vmProp;\n        }\n    }\n\n    // do init hook her if needed\n    // vmDef.executeHook( 'onInit', props, [ data ], ctxHook );\n    return data;\n}\n\n/**\n * create lifecycle hook based on action map\n * @param {Object} lifecycleHookDefs life cycle hook definition\n * @param {Object} actions action map\n * @returns {object} lifecyclehook callback map\n */\nfunction createLifecycleHooks( lifecycleHookDefs = [], actions ) {\n    let hooksActionsMap = {};\n    _.forEach( lifecycleHookDefs, ( actionName, hookName ) => {\n        // Map onInit hook to onMount - This would not work when we have have both onInit and onMount\n        // defined for a component.onInit would never get a chance to get invoked.\n        //hookName = hookName === 'onInit' ? 'onMount' : hookName;\n        if( Array.isArray( actionName ) ) {\n            hooksActionsMap[ hookName ] = [];\n            _.forEach( actionName, function( actionObj ) {\n                hooksActionsMap[ hookName ].push( actions[ actionObj.action ] );\n            } );\n        } else {\n            if( !actions[ actionName ] && typeof Object ) {\n                //Is mapped to an object with observer and action.\n                hooksActionsMap[ hookName ] = actions[ actionName.action ];\n            } else {\n                hooksActionsMap[ hookName ] = actions[ actionName ];\n            }\n        }\n    } );\n    return hooksActionsMap;\n}\n\n/**\n * create valiation rule based on property definition\n * @param {JSON} props property definitions\n * @param {JSON} conds condition definitions\n * @returns {object} property validation objects\n */\n\n/**\n * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API\n * @param {JSON} declViewModelJson view model definition\n * @param {object} prop componet prop\n * @returns {object} view model factory\n */\nexport function createDeclViewModel( declViewModelJson, prop = {} ) {\n    const { viewId, subPanelContext } = prop;\n    declViewModelJson.data = declViewModelJson.data || {};\n\n    const vmDef = viewModelSvc.populateViewModelPropertiesFromJson( declViewModelJson, null, null, null, null, subPanelContext );\n    if( viewId ) {\n        vmDef._internal.viewId = viewId;\n    }\n    // put declViewModelJson to vmDef\n    vmDef.declViewModelJson = declViewModelJson;\n\n    // build data creation function\n    vmDef.createData = ( scope ) => createData( declViewModelJson.data, scope, vmDef, subPanelContext, prop );\n\n    // create sync strategy ports\n    vmDef.createPorts = () => {\n        return cloneDeepJsonObject( declViewModelJson.ports );\n    };\n\n    vmDef.createFieldsData = () => {\n        let initialState = {};\n        for( const prop in declViewModelJson.data ) {\n            if( declViewModelJson.data[ prop ] && declViewModelJson.data[ prop ].meta ) {\n                initialState[ prop ] = declViewModelJson.data[ prop ].initialValues;\n            }\n        }\n        return initialState;\n    };\n\n    vmDef.createDataProvider = () => {\n        return vmDef.dataProviders;\n    };\n\n    //build LifecycleHooks\n    vmDef.createLifecycleHooks = actions => createLifecycleHooks( declViewModelJson.lifecycleHooks, actions );\n\n    // bind drag drop handler  with declViewModal\n\n    declDragAndDropService.setupDragAndDropOnView( vmDef );\n\n    return vmDef;\n}\n\nconst bindActions = function( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel ) {\n    viewModel.actions = _.mapValues( declViewModelJson.actions, actionDef => ( renderOptions ) => {\n        let fields = dataCtxNode.getFields();\n        // #49 - Side effect in example 'Notification Messages'\n        Object.assign( dataCtxNode.data, getData() );\n        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );\n        fields && Object.assign( dataCtxNode, { fields } );\n\n        if( renderOptions ) {\n            //add the parameter here\n            //add the function ref necessary to execute a command action programatically\n            dataCtxNode.parameters = { ...renderOptions, commandActionExecutor: { runActionWithViewModel } };\n        }\n        return viewModelSvc.executeCommand( viewModel, actionDef.actionId, dataCtxNode );\n    } );\n};\n\nconst bindChartProvider = function( viewModel, vmDef, dataCtxNode ) {\n    if( viewModel.chartProviders && !_.isEmpty( viewModel.chartProviders ) ) {\n        _.mapValues( viewModel.chartProviders, function( chartProvider ) {\n            if( chartProvider.loadDataAction ) {\n                chartProvider.loadDataActionCallBack = () => {\n                    return dataProviderService.executeLoadAction( vmDef.getAction( chartProvider.loadDataAction ), {}, dataCtxNode );\n                };\n            }\n            if( chartProvider.selectAction ) {\n                chartProvider.selectActionCallBack = ( selectedChartEntity ) => {\n                    if( !dataCtxNode.parameters ) {\n                        dataCtxNode.parameters = {};\n                    }\n                    dataCtxNode.parameters.selectedChartEntity = { ...selectedChartEntity };\n                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.selectAction ).actionId, dataCtxNode );\n                };\n            }\n            if( chartProvider.unSelectAction ) {\n                chartProvider.unSelectedActionCallBack = ( unSelectedChartEntity ) => {\n                    if( !dataCtxNode.parameters ) {\n                        dataCtxNode.parameters = {};\n                    }\n                    dataCtxNode.parameters.unSelectedChartEntity = { ...unSelectedChartEntity };\n                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.unSelectAction ).actionId, dataCtxNode );\n                };\n            }\n        } );\n    }\n};\n\nconst bindDataProvider = function( viewModel, dataCtxNode, getData, getProps ) {\n    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.loadAction = async( vmCollection, startIndex, pageObject ) => {\n        Object.assign( dataCtxNode.data, getData() );\n        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );\n        return loadAction( dataProvider, dataCtxNode, vmCollection, startIndex, pageObject );\n    } );\n};\n\nconst bindStaticDataProvider = function( viewModel, dataCtxNode ) {\n    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.validateLovAction = async( input ) => {\n        return validateLovAction( input, dataProvider, dataCtxNode );\n    } );\n};\n\n/**\n * process vmDef, ctx and data to create view model instance\n * @param {object} vmDef view model definition\n * @param {Array} ctxHook react ctx hook in data-dispatch pair\n * @param {Array} dataHook  react data hook in dta-dispatch pair\n * @param {Array} portsHook  react data hook in portsHook pair\n * @param {object} allAtomicData  react dataProviders\n * @param {object} getProps getProps\n * @param {object} runActionWithViewModel callback function\n * @param {object} getFields getFields\n * @returns {object} view model instance\n */\nexport function processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData = {}, getProps, runActionWithViewModel, getFields ) {\n    const [ ctx, updateCtx ] = ctxHook;\n    const props = getProps ? getProps() : {};\n\n    const [ data, updateData, getData ] = dataHook;\n    const declViewModelJson = vmDef.declViewModelJson;\n    let dispatchers = { ctx: updateCtx, data: updateData };\n\n    debugService.debug( 'lifeCycles', vmDef._internal.panelId, 'init' );\n\n    // fields data\n    let atomicData = {};\n    let updateAtomicData = {};\n    let atomicDataHook = allAtomicData.atomicDataHook ? allAtomicData.atomicDataHook : {};\n\n    const atomicDataHookKeys = Object.keys( atomicDataHook );\n    _.forEach( atomicDataHookKeys, function( stateName ) {\n        atomicData[ stateName ] = atomicDataHook[ stateName ][ 0 ];\n        updateAtomicData[ stateName ] = allAtomicData.atomicDataRef[ stateName ].setAtomicData;\n    } );\n\n    // sync strategy port dispatcher\n    let ports;\n    let updatePorts;\n    if( declViewModelJson.ports && portsHook ) {\n        [ ports, updatePorts ] = portsHook;\n        dispatchers.ports = updatePorts;\n    }\n    // dispatch method\n    const { dispatch } = composeDispatch( dispatchers );\n\n    const viewModel = {\n        // store\n        ctx,\n        data,\n        atomicData,\n        updateAtomicData,\n        atomicDataRef: allAtomicData.atomicDataRef,\n        //subPanelContext\n        subPanelContext: props.subPanelContext,\n\n        // dispatch\n        dispatch,\n\n        // getData\n        getData,\n\n        // context for post eval\n        conditions: {},\n        expressions: {},\n        oldExpressions: {},\n        i18n: declViewModelJson.i18n,\n        onEvent: declViewModelJson.onEvent,\n        messages: declViewModelJson.messages,\n        ports: ports\n    };\n\n    // revisitme - data (the section in the VM needs to be directly available on the viewModel)\n    // not doing deep copy has side effects. This will be modified depending on the approach\n    // that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.\n    _.assign( viewModel, vmDef );\n    let dataObj = data;\n\n    // We need deep copy for data providers.\n    if( dataObj && dataObj.dataProviders ) {\n        let dataObjDataProviders = dataObj.dataProviders;\n        delete dataObj.dataProviders;\n        for( const dpKey in dataObjDataProviders ) {\n            if( viewModel.dataProviders && viewModel.dataProviders[ dpKey ] ) {\n                _.assign( viewModel.dataProviders[ dpKey ], dataObjDataProviders[ dpKey ] );\n            }\n        }\n    }\n\n    // Not sure whether other portion of data needs deep copy. So not touching the same.\n    _.assign( viewModel, dataObj );\n    _.assign( viewModel, atomicData );\n    let dataCtxNode = {\n        props,\n        data: viewModel,\n        ctx,\n        subPanelContext: props.subPanelContext,\n        ports: viewModel.ports,\n        getProps,\n        getFields\n    };\n\n    // conditions\n    //lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it\n    //forEach because closure is needed\n    Object.entries( declViewModelJson.conditions || {} ).forEach( ( [ key, value ] ) => {\n        defineLazyGetter( viewModel.conditions, key, () => conditionService.evaluateCondition( viewModel, value.expression, dataCtxNode ) );\n        defineLazyGetter( viewModel.expressions, key, () => [ conditionService.parseExpression( viewModel, value.expression, dataCtxNode ) ] );\n    } );\n\n    // bind action\n    bindActions( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel );\n\n    // grids\n    const grids = processGrids( vmDef.grids, viewModel, ctxHook[ 0 ] );\n\n    // bind data provider\n    bindDataProvider( viewModel, dataCtxNode, getData, getProps );\n\n    //bind callback for chartsProvider loadActionData\n    bindChartProvider( viewModel, vmDef, dataCtxNode );\n\n    // bind validate action for static dataproviders\n    bindStaticDataProvider( viewModel, dataCtxNode );\n\n    // validation criteria\n    //vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );\n\n    // Lifecycle Hooks\n    viewModel.lifecycleHooks = createLifecycleHooks( declViewModelJson.lifecycleHooks, viewModel.actions );\n\n    // sync strategy\n    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n        syncStrategySvc.setupSyncStrategy( dataCtxNode );\n    }\n    return {\n        viewModel,\n        grids\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}