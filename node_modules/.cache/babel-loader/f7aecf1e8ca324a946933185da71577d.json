{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the keyboard interactions for PL Table.\n *\n * @module js/splmTableKeyboardService\n */\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport wcagService from 'js/wcagService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n/**\n * Keyboard service to handle keyboard interactions for aw-splm-table\n * @param {HTMLElement} tableElem The table element\n * @param {SPLMTableEditor} tableEditor The table editor\n */\n\nconst SPLMTableKeyboardService = function (tableElem, tableEditor) {\n  let self = this;\n  let _tableElement = tableElem;\n  let _tableEditor = tableEditor;\n\n  let _tableInstance = util.getTableInstance(_tableElement);\n\n  let _trv = new Trv(tableElem);\n\n  const dataIndexNumber = 'data-indexNumber';\n  /**\n   * Prevents default and stops propagation for event\n   * @param {Event} event the event\n   */\n\n  const preventEventDefaults = function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n  /**\n   * Checks if key pressed is an arrow key\n   * @param {String} keyPressed the pressed key to check\n   * @returns {String|null} the direction if arrow key, or null if not\n   */\n\n\n  const checkIfArrowKey = function (keyPressed) {\n    switch (keyPressed) {\n      case 'Up':\n      case 'ArrowUp':\n        return 'UP';\n\n      case 'Down':\n      case 'ArrowDown':\n        return 'DOWN';\n\n      case 'Left':\n      case 'ArrowLeft':\n        return 'LEFT';\n\n      case 'Right':\n      case 'ArrowRight':\n        return 'RIGHT';\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Function for handling onfocus event\n   * @param {Event} event event data\n   */\n\n\n  const onFocusFunction = function (event) {\n    event.target.tabIndex = '0';\n  };\n  /**\n   * Function for handling onblur event\n   * @param {Event} event eventData\n   */\n\n\n  const onBlurFunction = function (event) {\n    event.target.tabIndex = '-1';\n  };\n  /**\n   * Sets focus and blur event listeners to passed element\n   * @param {HTMLElement} element Element to set focus and blur events for\n   */\n\n\n  self.setOnFocusAndBlur = function (element) {\n    element.addEventListener('focus', onFocusFunction);\n    element.addEventListener('blur', onBlurFunction);\n  };\n  /**\n   * Checks if passed element is a header element\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is a header element\n   */\n\n\n  const isHeaderElement = function (element) {\n    return element.classList.contains(Const.CLASS_HEADER_CELL);\n  };\n  /**\n   * Checks if passed element is a cell element\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is a cell element\n   */\n\n\n  const isCellElement = function (element) {\n    return element.classList.contains(Const.CLASS_CELL);\n  };\n  /**\n   * Checks if passed element is the table container\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is table container\n   */\n\n\n  const isTableContainer = function (element) {\n    return element.classList.contains(Const.CLASS_TABLE_CONTAINER);\n  };\n  /**\n   * Checks if passed element is the grid options button\n   * @param {HTMLElement} element Element to check\n   * @returns {Boolean} if the passed element is grid options button\n   */\n\n\n  const isGridOptionsButton = function (element) {\n    return util.closestElement(element, `.${Const.CLASS_TABLE_MENU_BUTTON}`);\n  };\n\n  const hasFocusableElements = function (element) {\n    return wcagService.findFocusableChildren(element).length > 0;\n  };\n  /**\n   * Focus' the grid options button for table\n   */\n\n\n  const focusGridOptionsButton = function () {\n    const gridMenuButton = _tableElement.querySelector(`.${Const.CLASS_TABLE_MENU_BUTTON} button`);\n\n    gridMenuButton.focus();\n  };\n  /**\n   * Gets the visible column defs for the table\n   * @returns {AwTableColumnInfo[]} Array of visible column defs\n   */\n\n\n  const getColumnDefs = function () {\n    let colDefs;\n\n    if (_tableInstance.gridOptions.transpose) {\n      colDefs = _tableInstance.controller.getColumnDefs();\n    } else {\n      colDefs = _tableInstance.dataProvider.cols;\n      colDefs = colDefs.filter(function (colDef) {\n        return colDef.hiddenFlag !== true;\n      });\n    }\n\n    return colDefs;\n  };\n  /**\n   * Calculates the scrollLeft for when focusing an element in the scroll container when navigating left or right\n   *\n   * @param {HTMLElement} currentElem The currently focused cell\n   * @param {Number} currentRowIdx The current focused element's aria-rowindex\n   * @param {Number} currentColIdx The current focused element aria-colindex\n   * @param {Number} nextColIdx The next column index that will be focused\n   * @returns {Number} Returns the scrollLeft value if a change is needed, or null if no need to set.\n   */\n\n\n  const calculateScrollLeft = function (currentElem, currentRowIdx, currentColIdx, nextColIdx) {\n    const colDefs = getColumnDefs();\n    let currentDef = currentElem.columnDef || currentElem.getElementsByClassName(Const.CLASS_COLUMN_DEF)[0].columnDef;\n    let defIndex = colDefs.indexOf(currentDef);\n    let scrollLeft = null;\n    let nextDef = colDefs[defIndex + (nextColIdx - currentColIdx)];\n\n    if (currentDef && nextDef && currentDef.pinnedLeft && !nextDef.pinnedLeft) {\n      // set scrollLeft to 0\n      scrollLeft = 0;\n    } else if (currentRowIdx === 1 && nextDef && !nextDef.pinnedLeft) {\n      scrollLeft = nextDef.startPosition;\n    }\n\n    return scrollLeft;\n  };\n\n  const getNewRowAndColumnIndex = (currentElem, direction, colDefs, currentRowIdx, numberOfRows) => {\n    let newIndexes = {\n      newRowIdx: null,\n      newColIdx: null,\n      scrollLeft: null\n    };\n\n    if (!currentElem) {\n      // No current element provided, focus very first header cell\n      newIndexes.newColIdx = 1;\n      newIndexes.newRowIdx = 1;\n      return newIndexes;\n    } else if (isGridOptionsButton(currentElem)) {\n      if (direction === 'LEFT') {\n        newIndexes.newColIdx = colDefs.length;\n        newIndexes.newRowIdx = 1;\n      } else if (direction === 'DOWN') {\n        newIndexes.newRowIdx = 2;\n        newIndexes.newColIdx = colDefs.length;\n        newIndexes.scrollLeft = colDefs[colDefs.length - 1].startPosition;\n      }\n\n      return newIndexes;\n    }\n\n    const currentColIdx = parseInt(currentElem.getAttribute('aria-colindex'));\n\n    switch (direction) {\n      case 'UP':\n        if (currentRowIdx <= 1) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx;\n        newIndexes.newRowIdx = currentRowIdx - 1;\n        break;\n\n      case 'DOWN':\n        // row index starts at 1\n        if (currentRowIdx >= numberOfRows) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx;\n        newIndexes.newRowIdx = currentRowIdx + 1;\n        break;\n\n      case 'LEFT':\n        if (currentColIdx <= 1) {\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx - 1;\n        newIndexes.newRowIdx = currentRowIdx;\n        break;\n\n      case 'RIGHT':\n        // index for aria-colindex starts at 1\n        if (currentColIdx >= colDefs.length) {\n          if (isHeaderElement(currentElem)) {\n            focusGridOptionsButton();\n          }\n\n          return null;\n        }\n\n        newIndexes.newColIdx = currentColIdx + 1;\n        newIndexes.newRowIdx = currentRowIdx;\n        break;\n\n      default:\n        break;\n    } // Set scrollLeft as needed\n\n\n    if (newIndexes.newColIdx !== currentColIdx) {\n      newIndexes.scrollLeft = calculateScrollLeft(currentElem, currentRowIdx, currentColIdx, newIndexes.newColIdx);\n    }\n\n    return newIndexes;\n  };\n  /**\n   * Handles the cell navigation in table. If no element provided, focuses the first header cell. Otherwise\n   * handles navigation based on current element and direction passed\n   * @param {HTMLElement} currentElem The currently focused element\n   * @param {String} direction The direction to navigate - UP, DOWN, LEFT, or RIGHT\n   */\n\n\n  const handleCellNavigation = (currentElem, direction) => {\n    const colDefs = getColumnDefs();\n    let numberOfRows;\n\n    if (_tableInstance.gridOptions.transpose) {\n      numberOfRows = _tableInstance.dataProvider.cols.length + 1;\n    } else {\n      numberOfRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length + 1;\n    }\n\n    const currentRowIdx = currentElem ? parseInt(currentElem.parentElement.getAttribute('aria-rowindex')) : null;\n    const newIndexes = getNewRowAndColumnIndex(currentElem, direction, colDefs, currentRowIdx, numberOfRows);\n\n    if (!newIndexes) {\n      return;\n    }\n\n    const newRowIdx = newIndexes.newRowIdx;\n    const newColIdx = newIndexes.newColIdx;\n    const scrollLeft = newIndexes.scrollLeft;\n\n    let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n    let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n\n    if (currentRowIdx === 1 && newRowIdx === 2) {\n      // Going from header row to first row, need to set scroll top to 0\n      viewport.scrollTop = 0;\n    }\n\n    if (scrollLeft !== null) {\n      viewport.scrollLeft = scrollLeft;\n    } // Find the correct next element to focus\n\n\n    setTimeout(function () {\n      let queryString = `[aria-rowindex='${newRowIdx}'] [aria-colindex='${newColIdx}']`;\n\n      let element = _tableElement.querySelector(queryString);\n\n      if (element) {\n        element.focus();\n      }\n    }, 100);\n  };\n  /**\n   * Focuses the first or last cell in a given row/header row\n   * @param {HTMLElement} srcElement The source cell\n   * @param {Boolean} focusFirstInRow If user should focus first in row. if false, then last\n   */\n\n\n  const focusFirstOrLastInRow = function (srcElement, focusFirstInRow) {\n    const colDefs = getColumnDefs();\n\n    if (isHeaderElement(srcElement)) {\n      if (focusFirstInRow) {\n        handleCellNavigation();\n      } else {\n        const lastDef = colDefs[colDefs.length - 1];\n        const scrollLeft = lastDef.startPosition;\n\n        if (!lastDef.pinnedLeft) {\n          let container = _trv.getScrollContainerElementFromTable().getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n\n          container.scrollLeft = scrollLeft;\n        }\n\n        setTimeout(function () {\n          let querySelector = `[aria-rowindex='1'] [aria-colindex='${colDefs.length}']`;\n\n          let headerCell = _tableElement.querySelector(querySelector);\n\n          headerCell && headerCell.focus();\n        }, 50);\n      }\n    } else if (isCellElement(srcElement) || util.closestElement(srcElement, `.${Const.CLASS_CELL}`)) {\n      let defToFind;\n      let closestCell = util.closestElement(srcElement, `.${Const.CLASS_CELL}`);\n      const rowIdx = closestCell ? closestCell.parentElement.getAttribute(dataIndexNumber) : srcElement.parentElement.getAttribute(dataIndexNumber);\n\n      if (focusFirstInRow) {\n        defToFind = colDefs[0];\n\n        if (!defToFind.pinnedLeft) {\n          let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n          let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n          viewport.scrollLeft = 0;\n        }\n      } else {\n        defToFind = colDefs[colDefs.length - 1];\n\n        if (!defToFind.pinnedLeft) {\n          let scrollContainer = _trv.getScrollContainerElementFromTable();\n\n          let viewport = scrollContainer.getElementsByClassName(Const.CLASS_VIEWPORT)[0];\n          viewport.scrollLeft = defToFind.startPosition;\n        }\n      }\n\n      setTimeout(function () {\n        let querySelector = `[aria-rowindex='${parseInt(rowIdx) + 2}'] [aria-colindex='${defToFind.index + 1}']`;\n\n        let focusElem = _tableElement.querySelector(querySelector);\n\n        focusElem && focusElem.focus();\n      }, 50);\n    }\n  };\n  /**\n   * Gets the edit context, either from dataProvider.json or declViewModel\n   * @returns {String|null} - The edit context, if any, or null\n   */\n\n\n  const getEditContext = function () {\n    if (_tableInstance.dataProvider.json && _tableInstance.dataProvider.json.editContext) {\n      return _tableInstance.dataProvider.json.editContext;\n    } else if (_tableInstance.declViewModel._internal.editContext) {\n      return _tableInstance.declViewModel._internal.editContext;\n    }\n\n    return null;\n  };\n  /**\n   * Handles selection when using keyboard. Will call the click handler and selection helper to handle the selection event\n   * @param {HTMLElement} keyboardTargetElement The destination element of the keyboard event (cell)\n   * @param {Event} event the event\n   */\n\n\n  const handleKeyboardSelection = function (keyboardTargetElement, event) {\n    let rowVmo = keyboardTargetElement.parentElement && keyboardTargetElement.parentElement.vmo;\n\n    _tableEditor.onClickHandler(event, keyboardTargetElement, rowVmo);\n\n    const selectionHandler = splmTableSelectionHelper.selectionChanged(_tableElement, keyboardTargetElement);\n    selectionHandler(event);\n  };\n  /**\n   * Handles the left/right internal navigation\n   * @param {HTMLElement} cellElement The cell element\n   * @param {String} direction The direction - left or right\n   * @param {Event} event The keyboard event\n   */\n\n\n  const handleLeftOrRightInternalNavigation = (cellElement, direction, event) => {\n    preventEventDefaults(event);\n\n    if (document.activeElement === cellElement && direction === 'RIGHT') {\n      // Navigate inside cell\n      _tableEditor.removeAllCellSelection();\n\n      let focusElem = wcagService.findNextFocusableChild(cellElement, true);\n      focusElem && focusElem.focus();\n    } else if (direction === 'RIGHT') {\n      let nextFocusableElement = wcagService.findNextFocusableChild(cellElement);\n\n      if (nextFocusableElement) {\n        nextFocusableElement.focus();\n      } else {\n        handleCellNavigation(cellElement, direction);\n      }\n    } else {\n      let prevFocusableElement = wcagService.findPreviousFocusableChild(cellElement);\n\n      if (prevFocusableElement) {\n        prevFocusableElement.focus();\n      } else {\n        handleCellNavigation(cellElement, direction);\n      }\n    }\n  };\n\n  self.setupInternalCellNavigation = cellElement => {\n    cellElement.onkeydown = function (event) {\n      const arrowKey = checkIfArrowKey(event.key);\n      let containsFocusableElems = hasFocusableElements(cellElement);\n      const isInternalCellNavigationAllowed = !util.isBulkEditing(_tableElement) && !cellElement.isElementInEdit && containsFocusableElems;\n\n      if (!isInternalCellNavigationAllowed) {\n        return;\n      }\n\n      if (arrowKey === 'LEFT' || arrowKey === 'RIGHT') {\n        delete _tableInstance.focusTreeNodeExpandAfterRender;\n        handleLeftOrRightInternalNavigation(cellElement, arrowKey, event);\n      } else if ((arrowKey === 'DOWN' || arrowKey === 'UP') && document.activeElement !== cellElement) {\n        delete _tableInstance.focusTreeNodeExpandAfterRender;\n        preventEventDefaults(event);\n        handleCellNavigation(cellElement, arrowKey);\n      }\n    };\n  };\n\n  const handleTabKey = (srcElement, event) => {\n    if (isHeaderElement(srcElement) && !event.shiftKey) {\n      preventEventDefaults(event);\n      focusGridOptionsButton();\n    } else if (isGridOptionsButton(srcElement) && event.shiftKey) {\n      preventEventDefaults(event);\n      handleCellNavigation();\n    } else if (isTableContainer(srcElement)) {\n      _tableEditor.removeAllCellSelection();\n    } else if (document.activeElement.closest(Const.CLASS_TABLE_CONTAINER)) {\n      _tableEditor.removeAllCellSelection();\n    }\n  };\n\n  const handleArrowKey = (srcElement, arrowKey, event) => {\n    if (isCellElement(srcElement) && event.shiftKey && (arrowKey === 'DOWN' || arrowKey === 'UP')) {\n      preventEventDefaults(event);\n\n      _tableEditor.removeAllCellSelection(); // Do shift select essentially\n\n\n      const rowIdx = parseInt(srcElement.parentElement.getAttribute(dataIndexNumber));\n\n      const totalRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length;\n\n      if (arrowKey === 'DOWN' && rowIdx < totalRows - 1 || arrowKey === 'UP' && rowIdx > 0) {\n        handleCellNavigation(srcElement, arrowKey);\n        setTimeout(function () {\n          handleKeyboardSelection(document.activeElement, event);\n        }, 100);\n      }\n    } else if (!srcElement.isElementInEdit) {\n      preventEventDefaults(event);\n\n      if (isHeaderElement(srcElement) || isCellElement(srcElement)) {\n        _tableEditor.removeAllCellSelection();\n\n        handleCellNavigation(srcElement, arrowKey);\n      } else if (isGridOptionsButton(srcElement)) {\n        handleCellNavigation(srcElement, arrowKey);\n      } else if (isTableContainer(srcElement)) {\n        _tableEditor.removeAllCellSelection();\n\n        handleCellNavigation();\n      }\n    }\n  };\n\n  const handleEscapeKey = srcElement => {\n    if (util.isCellEditing(_tableElement) && !srcElement.isElementInEdit) {\n      const context = getEditContext();\n      let editHandler = null;\n\n      if (context) {\n        editHandler = editHandlerSvc.getEditHandler(context);\n      }\n\n      if (editHandler) {\n        editHandler.cancelEdits();\n      } else if (_tableInstance.dataProvider.getEditConfiguration()) {\n        const dataCtxNode = {\n          data: _tableInstance.declViewModel,\n          ctx: appCtxService.ctx\n        };\n\n        _tableInstance.dataProvider.cancelEdits(dataCtxNode, _tableInstance.declViewModel);\n      } else if (_tableInstance.declViewModel.getEditConfiguration()) {\n        _tableInstance.declViewModel.cancelEdits();\n      }\n    }\n  };\n\n  const handleEnterOrSpaceKey = (srcElement, event) => {\n    if (isCellElement(srcElement) && !srcElement.isElementInEdit) {\n      preventEventDefaults(event); // We have to select the row since this is not a click, it wont trigger the selection change\n\n      handleKeyboardSelection(srcElement, event);\n    }\n  };\n  /**\n   * Sets up the onkeydown listener for table. This will add support for tab, arrows keys, enter/return/space, and escape\n   */\n\n\n  self.setupKeyListener = () => {\n    _tableElement.onkeydown = event => {\n      // check what srcElement, and key code are\n      let srcElement = event.srcElement; // if srcElement is input, then go up to cell level\n\n      if (srcElement.tagName === 'INPUT' || srcElement.tagName === 'TEXTAREA') {\n        srcElement = util.closestElement(srcElement, `.${Const.CLASS_CELL}`) || srcElement;\n      }\n\n      if (util.isBulkEditing(_tableElement)) {\n        if (isTableContainer(srcElement)) {\n          preventEventDefaults(event); // Focus very first edit cell\n\n          let editableGridCell = srcElement.getElementsByClassName('aw-jswidgets-editableGridCell')[0];\n\n          if (editableGridCell) {\n            editableGridCell.parentElement.focus();\n          }\n        }\n\n        return;\n      }\n\n      const keyPressed = event.key;\n      const arrowKey = checkIfArrowKey(keyPressed);\n\n      if (keyPressed === 'Tab') {\n        handleTabKey(srcElement, event);\n      } else if (arrowKey) {\n        handleArrowKey(srcElement, arrowKey, event);\n      } else if (keyPressed === 'Enter' || keyPressed === 'Space' || keyPressed === ' ') {\n        handleEnterOrSpaceKey(srcElement, event);\n      } else if (keyPressed === 'Escape' || keyPressed === 'Esc') {\n        handleEscapeKey(srcElement);\n      } else if (keyPressed === 'Home' && !srcElement.isElementInEdit) {\n        focusFirstOrLastInRow(srcElement, true);\n\n        _tableEditor.removeAllCellSelection();\n      } else if (keyPressed === 'End' && !srcElement.isElementInEdit) {\n        focusFirstOrLastInRow(srcElement, false);\n\n        _tableEditor.removeAllCellSelection();\n      }\n    };\n  };\n};\n\n_c = SPLMTableKeyboardService;\nexport default SPLMTableKeyboardService;\n\nvar _c;\n\n$RefreshReg$(_c, \"SPLMTableKeyboardService\");","map":{"version":3,"names":["appCtxService","editHandlerSvc","splmTableSelectionHelper","wcagService","Const","util","Trv","SPLMTableKeyboardService","tableElem","tableEditor","self","_tableElement","_tableEditor","_tableInstance","getTableInstance","_trv","dataIndexNumber","preventEventDefaults","event","preventDefault","stopPropagation","checkIfArrowKey","keyPressed","onFocusFunction","target","tabIndex","onBlurFunction","setOnFocusAndBlur","element","addEventListener","isHeaderElement","classList","contains","CLASS_HEADER_CELL","isCellElement","CLASS_CELL","isTableContainer","CLASS_TABLE_CONTAINER","isGridOptionsButton","closestElement","CLASS_TABLE_MENU_BUTTON","hasFocusableElements","findFocusableChildren","length","focusGridOptionsButton","gridMenuButton","querySelector","focus","getColumnDefs","colDefs","gridOptions","transpose","controller","dataProvider","cols","filter","colDef","hiddenFlag","calculateScrollLeft","currentElem","currentRowIdx","currentColIdx","nextColIdx","currentDef","columnDef","getElementsByClassName","CLASS_COLUMN_DEF","defIndex","indexOf","scrollLeft","nextDef","pinnedLeft","startPosition","getNewRowAndColumnIndex","direction","numberOfRows","newIndexes","newRowIdx","newColIdx","parseInt","getAttribute","handleCellNavigation","viewModelCollection","getLoadedViewModelObjects","parentElement","scrollContainer","getScrollContainerElementFromTable","viewport","CLASS_VIEWPORT","scrollTop","setTimeout","queryString","focusFirstOrLastInRow","srcElement","focusFirstInRow","lastDef","container","headerCell","defToFind","closestCell","rowIdx","index","focusElem","getEditContext","json","editContext","declViewModel","_internal","handleKeyboardSelection","keyboardTargetElement","rowVmo","vmo","onClickHandler","selectionHandler","selectionChanged","handleLeftOrRightInternalNavigation","cellElement","document","activeElement","removeAllCellSelection","findNextFocusableChild","nextFocusableElement","prevFocusableElement","findPreviousFocusableChild","setupInternalCellNavigation","onkeydown","arrowKey","key","containsFocusableElems","isInternalCellNavigationAllowed","isBulkEditing","isElementInEdit","focusTreeNodeExpandAfterRender","handleTabKey","shiftKey","closest","handleArrowKey","totalRows","handleEscapeKey","isCellEditing","context","editHandler","getEditHandler","cancelEdits","getEditConfiguration","dataCtxNode","data","ctx","handleEnterOrSpaceKey","setupKeyListener","tagName","editableGridCell"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/pltable/src/js/splmTableKeyboardService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This module defines the keyboard interactions for PL Table.\n *\n * @module js/splmTableKeyboardService\n */\n\nimport appCtxService from 'js/appCtxService';\nimport editHandlerSvc from 'js/editHandlerService';\nimport splmTableSelectionHelper from 'js/splmTableSelectionHelper';\nimport wcagService from 'js/wcagService';\nimport Const from 'js/splmTableConstants';\nimport util from 'js/splmTableUtils';\nimport Trv from 'js/splmTableTraversal';\n\n/**\n * Keyboard service to handle keyboard interactions for aw-splm-table\n * @param {HTMLElement} tableElem The table element\n * @param {SPLMTableEditor} tableEditor The table editor\n */\nconst SPLMTableKeyboardService = function( tableElem, tableEditor ) {\n    let self = this;\n\n    let _tableElement = tableElem;\n    let _tableEditor = tableEditor;\n    let _tableInstance = util.getTableInstance( _tableElement );\n    let _trv = new Trv( tableElem );\n    const dataIndexNumber = 'data-indexNumber';\n\n    /**\n     * Prevents default and stops propagation for event\n     * @param {Event} event the event\n     */\n    const preventEventDefaults = function( event ) {\n        event.preventDefault();\n        event.stopPropagation();\n    };\n\n    /**\n     * Checks if key pressed is an arrow key\n     * @param {String} keyPressed the pressed key to check\n     * @returns {String|null} the direction if arrow key, or null if not\n     */\n    const checkIfArrowKey = function( keyPressed ) {\n        switch ( keyPressed ) {\n            case 'Up':\n            case 'ArrowUp':\n                return 'UP';\n            case 'Down':\n            case 'ArrowDown':\n                return 'DOWN';\n            case 'Left':\n            case 'ArrowLeft':\n                return 'LEFT';\n            case 'Right':\n            case 'ArrowRight':\n                return 'RIGHT';\n            default:\n                return null;\n        }\n    };\n\n    /**\n     * Function for handling onfocus event\n     * @param {Event} event event data\n     */\n    const onFocusFunction = function( event ) {\n        event.target.tabIndex = '0';\n    };\n\n    /**\n     * Function for handling onblur event\n     * @param {Event} event eventData\n     */\n    const onBlurFunction = function( event ) {\n        event.target.tabIndex = '-1';\n    };\n\n    /**\n     * Sets focus and blur event listeners to passed element\n     * @param {HTMLElement} element Element to set focus and blur events for\n     */\n    self.setOnFocusAndBlur = function( element ) {\n        element.addEventListener( 'focus', onFocusFunction );\n        element.addEventListener( 'blur', onBlurFunction );\n    };\n\n    /**\n     * Checks if passed element is a header element\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is a header element\n     */\n    const isHeaderElement = function( element ) {\n        return element.classList.contains( Const.CLASS_HEADER_CELL );\n    };\n\n    /**\n     * Checks if passed element is a cell element\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is a cell element\n     */\n    const isCellElement = function( element ) {\n        return element.classList.contains( Const.CLASS_CELL );\n    };\n\n    /**\n     * Checks if passed element is the table container\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is table container\n     */\n    const isTableContainer = function( element ) {\n        return element.classList.contains( Const.CLASS_TABLE_CONTAINER );\n    };\n\n    /**\n     * Checks if passed element is the grid options button\n     * @param {HTMLElement} element Element to check\n     * @returns {Boolean} if the passed element is grid options button\n     */\n    const isGridOptionsButton = function( element ) {\n        return util.closestElement( element, `.${Const.CLASS_TABLE_MENU_BUTTON}` );\n    };\n\n    const hasFocusableElements = function( element ) {\n        return wcagService.findFocusableChildren( element ).length > 0;\n    };\n\n    /**\n     * Focus' the grid options button for table\n     */\n    const focusGridOptionsButton = function() {\n        const gridMenuButton = _tableElement.querySelector( `.${Const.CLASS_TABLE_MENU_BUTTON} button` );\n        gridMenuButton.focus();\n    };\n\n    /**\n     * Gets the visible column defs for the table\n     * @returns {AwTableColumnInfo[]} Array of visible column defs\n     */\n    const getColumnDefs = function() {\n        let colDefs;\n        if( _tableInstance.gridOptions.transpose ) {\n            colDefs = _tableInstance.controller.getColumnDefs();\n        } else {\n            colDefs = _tableInstance.dataProvider.cols;\n            colDefs = colDefs.filter( function( colDef ) {\n                return colDef.hiddenFlag !== true;\n            } );\n        }\n        return colDefs;\n    };\n\n    /**\n     * Calculates the scrollLeft for when focusing an element in the scroll container when navigating left or right\n     *\n     * @param {HTMLElement} currentElem The currently focused cell\n     * @param {Number} currentRowIdx The current focused element's aria-rowindex\n     * @param {Number} currentColIdx The current focused element aria-colindex\n     * @param {Number} nextColIdx The next column index that will be focused\n     * @returns {Number} Returns the scrollLeft value if a change is needed, or null if no need to set.\n     */\n    const calculateScrollLeft = function( currentElem, currentRowIdx, currentColIdx, nextColIdx ) {\n        const colDefs = getColumnDefs();\n        let currentDef = currentElem.columnDef || currentElem.getElementsByClassName( Const.CLASS_COLUMN_DEF )[ 0 ].columnDef;\n        let defIndex = colDefs.indexOf( currentDef );\n        let scrollLeft = null;\n\n        let nextDef = colDefs[ defIndex + ( nextColIdx - currentColIdx ) ];\n        if( currentDef && nextDef && currentDef.pinnedLeft && !nextDef.pinnedLeft ) {\n            // set scrollLeft to 0\n            scrollLeft = 0;\n        } else if( currentRowIdx === 1 && nextDef && !nextDef.pinnedLeft ) {\n            scrollLeft = nextDef.startPosition;\n        }\n        return scrollLeft;\n    };\n\n    const getNewRowAndColumnIndex = ( currentElem, direction, colDefs, currentRowIdx, numberOfRows ) => {\n        let newIndexes = {\n            newRowIdx: null,\n            newColIdx: null,\n            scrollLeft: null\n        };\n\n        if( !currentElem ) {\n            // No current element provided, focus very first header cell\n            newIndexes.newColIdx = 1;\n            newIndexes.newRowIdx = 1;\n            return newIndexes;\n        } else if( isGridOptionsButton( currentElem ) ) {\n            if( direction === 'LEFT' ) {\n                newIndexes.newColIdx = colDefs.length;\n                newIndexes.newRowIdx = 1;\n            } else if( direction === 'DOWN' ) {\n                newIndexes.newRowIdx = 2;\n                newIndexes.newColIdx = colDefs.length;\n                newIndexes.scrollLeft = colDefs[ colDefs.length - 1 ].startPosition;\n            }\n            return newIndexes;\n        }\n        const currentColIdx = parseInt( currentElem.getAttribute( 'aria-colindex' ) );\n\n        switch ( direction ) {\n            case 'UP':\n                if( currentRowIdx <= 1 ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx;\n                newIndexes.newRowIdx = currentRowIdx - 1;\n                break;\n            case 'DOWN':\n                // row index starts at 1\n                if( currentRowIdx >= numberOfRows ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx;\n                newIndexes.newRowIdx = currentRowIdx + 1;\n                break;\n            case 'LEFT':\n                if( currentColIdx <= 1 ) {\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx - 1;\n                newIndexes.newRowIdx = currentRowIdx;\n                break;\n            case 'RIGHT':\n                // index for aria-colindex starts at 1\n                if( currentColIdx >= colDefs.length ) {\n                    if( isHeaderElement( currentElem ) ) {\n                        focusGridOptionsButton();\n                    }\n                    return null;\n                }\n                newIndexes.newColIdx = currentColIdx + 1;\n                newIndexes.newRowIdx = currentRowIdx;\n                break;\n            default:\n                break;\n        }\n        // Set scrollLeft as needed\n        if( newIndexes.newColIdx !== currentColIdx ) {\n            newIndexes.scrollLeft = calculateScrollLeft( currentElem, currentRowIdx, currentColIdx, newIndexes.newColIdx );\n        }\n        return newIndexes;\n    };\n\n    /**\n     * Handles the cell navigation in table. If no element provided, focuses the first header cell. Otherwise\n     * handles navigation based on current element and direction passed\n     * @param {HTMLElement} currentElem The currently focused element\n     * @param {String} direction The direction to navigate - UP, DOWN, LEFT, or RIGHT\n     */\n    const handleCellNavigation = ( currentElem, direction ) => {\n        const colDefs = getColumnDefs();\n        let numberOfRows;\n        if( _tableInstance.gridOptions.transpose ) {\n            numberOfRows = _tableInstance.dataProvider.cols.length + 1;\n        } else {\n            numberOfRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length + 1;\n        }\n\n        const currentRowIdx = currentElem ? parseInt( currentElem.parentElement.getAttribute( 'aria-rowindex' ) ) : null;\n        const newIndexes = getNewRowAndColumnIndex( currentElem, direction, colDefs, currentRowIdx, numberOfRows );\n        if( !newIndexes ) {\n            return;\n        }\n        const newRowIdx = newIndexes.newRowIdx;\n        const newColIdx = newIndexes.newColIdx;\n        const scrollLeft = newIndexes.scrollLeft;\n\n        let scrollContainer = _trv.getScrollContainerElementFromTable();\n        let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n\n        if( currentRowIdx === 1 && newRowIdx === 2 ) {\n            // Going from header row to first row, need to set scroll top to 0\n            viewport.scrollTop = 0;\n        }\n\n        if( scrollLeft !== null ) {\n            viewport.scrollLeft = scrollLeft;\n        }\n        // Find the correct next element to focus\n        setTimeout( function() {\n            let queryString = `[aria-rowindex='${newRowIdx}'] [aria-colindex='${newColIdx}']`;\n            let element = _tableElement.querySelector( queryString );\n            if( element ) {\n                element.focus();\n            }\n        }, 100 );\n    };\n\n    /**\n     * Focuses the first or last cell in a given row/header row\n     * @param {HTMLElement} srcElement The source cell\n     * @param {Boolean} focusFirstInRow If user should focus first in row. if false, then last\n     */\n    const focusFirstOrLastInRow = function( srcElement, focusFirstInRow ) {\n        const colDefs = getColumnDefs();\n        if( isHeaderElement( srcElement ) ) {\n            if( focusFirstInRow ) {\n                handleCellNavigation();\n            } else {\n                const lastDef = colDefs[ colDefs.length - 1 ];\n                const scrollLeft = lastDef.startPosition;\n                if( !lastDef.pinnedLeft ) {\n                    let container = _trv.getScrollContainerElementFromTable().getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    container.scrollLeft = scrollLeft;\n                }\n\n                setTimeout( function() {\n                    let querySelector = `[aria-rowindex='1'] [aria-colindex='${colDefs.length}']`;\n                    let headerCell = _tableElement.querySelector( querySelector );\n                    headerCell && headerCell.focus();\n                }, 50 );\n            }\n        } else if( isCellElement( srcElement ) || util.closestElement( srcElement, `.${Const.CLASS_CELL}` ) ) {\n            let defToFind;\n            let closestCell = util.closestElement( srcElement, `.${Const.CLASS_CELL}` );\n            const rowIdx = closestCell ? closestCell.parentElement.getAttribute( dataIndexNumber ) : srcElement.parentElement.getAttribute( dataIndexNumber );\n            if( focusFirstInRow ) {\n                defToFind = colDefs[ 0 ];\n                if( !defToFind.pinnedLeft ) {\n                    let scrollContainer = _trv.getScrollContainerElementFromTable();\n                    let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    viewport.scrollLeft = 0;\n                }\n            } else {\n                defToFind = colDefs[ colDefs.length - 1 ];\n                if( !defToFind.pinnedLeft ) {\n                    let scrollContainer = _trv.getScrollContainerElementFromTable();\n                    let viewport = scrollContainer.getElementsByClassName( Const.CLASS_VIEWPORT )[ 0 ];\n                    viewport.scrollLeft = defToFind.startPosition;\n                }\n            }\n\n            setTimeout( function() {\n                let querySelector = `[aria-rowindex='${parseInt( rowIdx ) + 2}'] [aria-colindex='${defToFind.index + 1}']`;\n                let focusElem = _tableElement.querySelector( querySelector );\n                focusElem && focusElem.focus();\n            }, 50 );\n        }\n    };\n\n    /**\n     * Gets the edit context, either from dataProvider.json or declViewModel\n     * @returns {String|null} - The edit context, if any, or null\n     */\n    const getEditContext = function() {\n        if( _tableInstance.dataProvider.json && _tableInstance.dataProvider.json.editContext ) {\n            return _tableInstance.dataProvider.json.editContext;\n        } else if( _tableInstance.declViewModel._internal.editContext ) {\n            return _tableInstance.declViewModel._internal.editContext;\n        }\n        return null;\n    };\n\n    /**\n     * Handles selection when using keyboard. Will call the click handler and selection helper to handle the selection event\n     * @param {HTMLElement} keyboardTargetElement The destination element of the keyboard event (cell)\n     * @param {Event} event the event\n     */\n    const handleKeyboardSelection = function( keyboardTargetElement, event ) {\n        let rowVmo = keyboardTargetElement.parentElement && keyboardTargetElement.parentElement.vmo;\n        _tableEditor.onClickHandler( event, keyboardTargetElement, rowVmo );\n        const selectionHandler = splmTableSelectionHelper.selectionChanged( _tableElement, keyboardTargetElement );\n        selectionHandler( event );\n    };\n\n    /**\n     * Handles the left/right internal navigation\n     * @param {HTMLElement} cellElement The cell element\n     * @param {String} direction The direction - left or right\n     * @param {Event} event The keyboard event\n     */\n    const handleLeftOrRightInternalNavigation = ( cellElement, direction, event ) => {\n        preventEventDefaults( event );\n        if( document.activeElement === cellElement && direction === 'RIGHT' ) {\n            // Navigate inside cell\n            _tableEditor.removeAllCellSelection();\n            let focusElem = wcagService.findNextFocusableChild( cellElement, true );\n            focusElem && focusElem.focus();\n        } else if( direction === 'RIGHT' ) {\n            let nextFocusableElement = wcagService.findNextFocusableChild( cellElement );\n            if( nextFocusableElement ) {\n                nextFocusableElement.focus();\n            } else {\n                handleCellNavigation( cellElement, direction );\n            }\n        } else {\n            let prevFocusableElement = wcagService.findPreviousFocusableChild( cellElement );\n            if( prevFocusableElement ) {\n                prevFocusableElement.focus();\n            } else {\n                handleCellNavigation( cellElement, direction );\n            }\n        }\n    };\n\n    self.setupInternalCellNavigation = ( cellElement ) => {\n        cellElement.onkeydown = function( event ) {\n            const arrowKey = checkIfArrowKey( event.key );\n            let containsFocusableElems = hasFocusableElements( cellElement );\n            const isInternalCellNavigationAllowed = !util.isBulkEditing( _tableElement ) && !cellElement.isElementInEdit && containsFocusableElems;\n            if( !isInternalCellNavigationAllowed ) {\n                return;\n            }\n            if( arrowKey === 'LEFT' || arrowKey === 'RIGHT' ) {\n                delete _tableInstance.focusTreeNodeExpandAfterRender;\n                handleLeftOrRightInternalNavigation( cellElement, arrowKey, event );\n            } else if( ( arrowKey === 'DOWN' || arrowKey === 'UP' ) && document.activeElement !== cellElement ) {\n                delete _tableInstance.focusTreeNodeExpandAfterRender;\n                preventEventDefaults( event );\n                handleCellNavigation( cellElement, arrowKey );\n            }\n        };\n    };\n\n    const handleTabKey = ( srcElement, event ) => {\n        if( isHeaderElement( srcElement ) && !event.shiftKey ) {\n            preventEventDefaults( event );\n            focusGridOptionsButton();\n        } else if( isGridOptionsButton( srcElement ) && event.shiftKey ) {\n            preventEventDefaults( event );\n            handleCellNavigation();\n        } else if( isTableContainer( srcElement ) ) {\n            _tableEditor.removeAllCellSelection();\n        } else if( document.activeElement.closest( Const.CLASS_TABLE_CONTAINER ) ) {\n            _tableEditor.removeAllCellSelection();\n        }\n    };\n\n    const handleArrowKey = ( srcElement, arrowKey, event ) => {\n        if( isCellElement( srcElement ) && event.shiftKey && ( arrowKey === 'DOWN' || arrowKey === 'UP' ) ) {\n            preventEventDefaults( event );\n            _tableEditor.removeAllCellSelection();\n            // Do shift select essentially\n            const rowIdx = parseInt( srcElement.parentElement.getAttribute( dataIndexNumber ) );\n            const totalRows = _tableInstance.dataProvider.viewModelCollection.getLoadedViewModelObjects().length;\n            if( arrowKey === 'DOWN' && rowIdx < totalRows - 1 || arrowKey === 'UP' && rowIdx > 0 ) {\n                handleCellNavigation( srcElement, arrowKey );\n                setTimeout( function() {\n                    handleKeyboardSelection( document.activeElement, event );\n                }, 100 );\n            }\n        } else if( !srcElement.isElementInEdit ) {\n            preventEventDefaults( event );\n            if( isHeaderElement( srcElement ) || isCellElement( srcElement ) ) {\n                _tableEditor.removeAllCellSelection();\n                handleCellNavigation( srcElement, arrowKey );\n            } else if( isGridOptionsButton( srcElement ) ) {\n                handleCellNavigation( srcElement, arrowKey );\n            } else if( isTableContainer( srcElement ) ) {\n                _tableEditor.removeAllCellSelection();\n                handleCellNavigation();\n            }\n        }\n    };\n\n    const handleEscapeKey = ( srcElement ) => {\n        if( util.isCellEditing( _tableElement ) && !srcElement.isElementInEdit ) {\n            const context = getEditContext();\n            let editHandler = null;\n            if( context ) {\n                editHandler = editHandlerSvc.getEditHandler( context );\n            }\n\n            if( editHandler ) {\n                editHandler.cancelEdits();\n            } else if( _tableInstance.dataProvider.getEditConfiguration() ) {\n                const dataCtxNode = {\n                    data: _tableInstance.declViewModel,\n                    ctx: appCtxService.ctx\n                };\n                _tableInstance.dataProvider.cancelEdits( dataCtxNode, _tableInstance.declViewModel );\n            } else if( _tableInstance.declViewModel.getEditConfiguration() ) {\n                _tableInstance.declViewModel.cancelEdits();\n            }\n        }\n    };\n\n    const handleEnterOrSpaceKey = ( srcElement, event ) => {\n        if( isCellElement( srcElement ) && !srcElement.isElementInEdit ) {\n            preventEventDefaults( event );\n            // We have to select the row since this is not a click, it wont trigger the selection change\n            handleKeyboardSelection( srcElement, event );\n        }\n    };\n\n    /**\n     * Sets up the onkeydown listener for table. This will add support for tab, arrows keys, enter/return/space, and escape\n     */\n    self.setupKeyListener = () => {\n        _tableElement.onkeydown = ( event ) => {\n            // check what srcElement, and key code are\n            let srcElement = event.srcElement;\n\n            // if srcElement is input, then go up to cell level\n            if( srcElement.tagName === 'INPUT' || srcElement.tagName === 'TEXTAREA' ) {\n                srcElement = util.closestElement( srcElement, `.${Const.CLASS_CELL}` ) || srcElement;\n            }\n\n            if( util.isBulkEditing( _tableElement ) ) {\n                if( isTableContainer( srcElement ) ) {\n                    preventEventDefaults( event );\n                    // Focus very first edit cell\n                    let editableGridCell = srcElement.getElementsByClassName( 'aw-jswidgets-editableGridCell' )[ 0 ];\n                    if( editableGridCell ) {\n                        editableGridCell.parentElement.focus();\n                    }\n                }\n                return;\n            }\n\n            const keyPressed = event.key;\n\n            const arrowKey = checkIfArrowKey( keyPressed );\n\n            if( keyPressed === 'Tab' ) {\n                handleTabKey( srcElement, event );\n            } else if( arrowKey ) {\n                handleArrowKey( srcElement, arrowKey, event );\n            } else if( keyPressed === 'Enter' || keyPressed === 'Space' || keyPressed === ' ' ) {\n                handleEnterOrSpaceKey( srcElement, event );\n            } else if( keyPressed === 'Escape' || keyPressed === 'Esc' ) {\n                handleEscapeKey( srcElement );\n            } else if( keyPressed === 'Home' && !srcElement.isElementInEdit ) {\n                focusFirstOrLastInRow( srcElement, true );\n                _tableEditor.removeAllCellSelection();\n            } else if( keyPressed === 'End' && !srcElement.isElementInEdit ) {\n                focusFirstOrLastInRow( srcElement, false );\n                _tableEditor.removeAllCellSelection();\n            }\n        };\n    };\n};\n\nexport default SPLMTableKeyboardService;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}