{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This service is used by <aw-row> and <aw-column> to initialize the flexbox sizing attributes for all rows and\n * columns within the grid system. And to establish elements to implement offsets, align-contents (start, center, end) and justification options.\n *\n * @module js/awRowColumnService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\nlet exports = {}; // eslint-disable-line no-invalid-this\n\nexport let constants = {\n  gridSystemSize: 12,\n  standardWidthFactor: 1,\n  standardHeightFactor: 1\n};\n/**\n * Initialize Row or Column - every row or column element calls this method at link time to\n * initialized the flexbox attributes for all siblings. And to add elements to implement offsets\n * align-contents (start, center, end) and justification options.\n *\n * @param {object} scopeElements - The angularJS scope elements used to define the row or\n *            column.\n */\n\nexport let initRowOrColumn = function (scopeElements) {\n  // Get the container element used for the given row or column element\n  var containerElement = scopeElements[0].parentElement;\n  var containerClassName = scopeElements[0].className; // Get all sub-area in this row or column\n\n  var areaList = exports.getAreaList(containerElement);\n\n  if (areaList === null) {\n    return;\n  } // Set parent container element to use flexbox\n\n\n  containerElement.style.display = 'flex';\n\n  if (areaList[0].wrapStyle) {\n    containerElement.style.flexWrap = areaList[0].wrapStyle;\n  }\n\n  containerElement.style.webkitFlexDirection = areaList[0].stackDirection;\n  containerElement.style.flexDirection = areaList[0].stackDirection; // Variables used to captured the index for the first center justify\n  // and (right or bottom) justify elements\n  // Elements to implement the justification will be inserted before these elements\n\n  var centerJustifyIndex = -1;\n  var farJustifyIndex = -1; // Flag to control relative positions of offset elements\n\n  var insertBefore = true; // Get the number of fill areas and the amount of space that is\n  // NOT defined by proportional values needed to fill the grid system\n\n  var fillData = exports.getFillData(areaList);\n  var fillValue = fillData.fillSize;\n  var fillAreaCount = fillData.fillAreaCount;\n  var fillAreaString = ''; // If there are fill areas then all open area will be consumed by them\n  // Any justification options will be ignored\n\n  if (fillAreaCount > 0) {\n    // For multiple fill areas the area is split between them\n    fillAreaString = (fillValue / fillAreaCount).toString();\n    fillValue = 0;\n  } // Process all items in the current row or column:\n  // Set the flexbox size attributes\n  // Capture key justification positions\n  // Add elements needed to implement offsets\n\n\n  _.forEach(areaList, function (area, index) {\n    // Set flexbox size attributes for this element\n    exports.setAreaStyle(area.areaElement, area.sizeType, area.sizeValue, area.color, fillAreaString, area.alignContent, area.when, area.areaType); // Capture the index of the first center and (right or bottom) elements\n\n    var justifyOption = area.justify;\n\n    if (justifyOption === 'center' && centerJustifyIndex < 0) {\n      centerJustifyIndex = index;\n    }\n\n    if ((justifyOption === 'right' || justifyOption === 'bottom') && farJustifyIndex < 0) {\n      farJustifyIndex = index;\n      insertBefore = false;\n    } // If this element has an offset then create the offset element\n\n\n    var offsetValue = area.offsetSizeValue;\n\n    if (offsetValue > 0) {\n      exports.addNewElement(containerClassName, area.offsetSizeType, offsetValue, 'transparent', '', insertBefore, area.areaElement, area.areaType);\n    }\n  }); // End process all items\n  // Add filler elements to handle justification or to fill in undefined space at the end\n\n\n  if (fillValue > 0) {\n    fillAreaString = fillValue.toString();\n\n    if (centerJustifyIndex >= 0) {\n      // Two Element are needed to center - so split the remaining space\n      // Note that this also handles the case of a center AND a (right or bottom) justification\n      fillAreaString = (fillValue / 2).toString(); // Insert an element before the center justify element\n\n      exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[centerJustifyIndex].areaElement, areaList[0].areaType);\n\n      if (farJustifyIndex > 0) {\n        // Also insert a new element before the far justify element\n        exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[farJustifyIndex].areaElement, areaList[0].areaType);\n      } else {\n        // There is no right or bottom justify option - so insert at the end to center\n        exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, false, scopeElements[0], areaList[0].areaType);\n      }\n    } else if (farJustifyIndex >= 0) {\n      // Insert one new element before the far justify element\n      exports.addNewElement(containerClassName, 'P', 0, 'transparent', fillAreaString, true, areaList[farJustifyIndex].areaElement, areaList[0].areaType);\n    }\n  }\n};\n/**\n * Add New Element\n *\n * Add a new element of a given size before or after a given sibling element.\n *\n * @param {string} className - The class name used for all siblings.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n *            areas\n * @param {boolean} before - when true insert the new element before the sibling, otherwise\n *            insert after\n * @param {object} sibling - existing sibling element to insert before or after Note: pass in\n *            the DOM element not the JQuery/Angular scoping element\n */\n\nexport let addNewElement = function (className, sizeType, sizeValue, color, fillAreaString, before, sibling, areaType) {\n  // Example to get rid of ngModule.element\n\n  /*\n      ngModule.element - it is a $.element, which should be replaced by vallinaJS ( major usage )\n      ngModule.isUndefined - can be vanillaJS\n      ngModule.copy - simple deep copy\n      ngModule.bind - similar like function.bind, not sure why we need this. But should be able to replace.\n      ngModule.noop - similar like null? Anyway we can do equivalent\n      ngModule.forEach - _.forEachngModule.isFunction - _.isFunction\n   */\n  var newElement = document.createElement('div');\n\n  _.forEach(className.split(' '), function (cName) {\n    newElement.classList.add(cName);\n  });\n\n  exports.setAreaStyle(newElement, sizeType, sizeValue, color, fillAreaString, null, null, areaType);\n  sibling.parentNode.insertBefore(newElement, sibling);\n\n  if (!before) {\n    newElement.parentNode.insertBefore(sibling, newElement);\n  }\n};\n/**\n * Set Area Style\n *\n * Set the flexbox size attributes for Fixed and Proportional areas and set the given color.\n *\n * @param {object} areaElement - The row or column to size.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n * @param {string} alignContent - \"start\", \"center\" or \"end\" to flex align Items/ Content\n *            areas\n * @param {string} when - \"xlarge: <value>, large: <value>, medium: <value>, small: <value>, xsmall: <value>\"\n *            12 column responsive grid layout\n */\n\nexport let setAreaStyle = function (areaElement, sizeType, sizeValue, color, fillAreaString, alignContent, when, areaType) {\n  var valueString = sizeValue.toString();\n  var flexString;\n  var areaPercent = '';\n\n  if (sizeType === 'P') {\n    if (sizeValue > 0) {\n      // This is a normal proportional area\n      // note that for IE performance, numeric values should not be used for the flex-basis (3rd value in flexString)\n      flexString = valueString + ' ' + valueString + ' auto';\n\n      if (valueString > 1) {\n        areaPercent = 100 * valueString / 12 + '%';\n      }\n    } else {\n      // This is a fill area - which will also be proportional\n      flexString = fillAreaString + ' ' + fillAreaString + ' auto';\n\n      if (fillAreaString > 1) {\n        areaPercent = 100 * fillAreaString / 12 + '%';\n      }\n    }\n  } else if (sizeType === 'A') {\n    flexString = '0 0 auto';\n  } else {\n    // sizeType = \"F\"\n    // These are areas defined with fixed values\n    flexString = '0 0 ' + sizeValue.toString() + 'em';\n  }\n\n  if (when && sizeType === 'P') {\n    var deviceModeList = when.split(',');\n\n    if (deviceModeList && deviceModeList.length) {\n      deviceModeList.forEach(function (mode) {\n        var deviceMode = mode.split(':')[0].trim();\n        var size = parseInt(mode.split(':')[1]);\n\n        if (deviceMode === 'xlarge') {\n          areaElement.className += ' aw-xlarge-' + size + ' ';\n        } else if (deviceMode === 'large') {\n          areaElement.className += ' aw-large-' + size + ' ';\n        } else if (deviceMode === 'medium') {\n          areaElement.className += ' aw-medium-' + size + ' ';\n        } else if (deviceMode === 'small') {\n          areaElement.className += ' aw-small-' + size + ' ';\n        } else if (deviceMode === 'xsmall') {\n          areaElement.className += ' aw-xsmall-' + size + ' ';\n        } else {\n          areaElement.className += ' aw-default-' + sizeValue + ' ';\n        }\n      });\n    }\n  } else {\n    // apply the flex value inline\n    // Numeric flex-basis should be avoided.\n    // Any change their needs to be carefully tested in IE for performance validation.\n    areaElement.style.flex = flexString;\n\n    if (areaPercent) {\n      areaType === 'column' ? areaElement.style.width = areaPercent : areaElement.style.height = areaPercent;\n    }\n  } // Add the flexbox sizing string and user given color to the current element\n\n\n  areaElement.style.backgroundColor = color;\n  var alignContentValue = '';\n\n  switch (alignContent) {\n    case 'start':\n      alignContentValue = 'flex-start';\n      break;\n\n    case 'center':\n      alignContentValue = 'center';\n      break;\n\n    case 'end':\n      alignContentValue = 'flex-end';\n      break;\n  }\n\n  areaElement.style.alignItems = alignContentValue;\n};\n/**\n * Is Last Child\n *\n * Return true if the given child element is the last child element of the given parent element.\n *\n * @param {object} parent - container element\n * @param {object} child - a child of the container element\n *\n * @return {boolean} - true if child is the last child in parent\n */\n\nexport let isLastChild = function (parent, child) {\n  if (!parent) {\n    return false;\n  }\n\n  var children = parent.children;\n\n  if (!children) {\n    return false;\n  }\n\n  var length = children.length;\n\n  if (length < 1) {\n    return false;\n  }\n\n  if (children[length - 1] !== child) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Get Fill Data\n *\n * For the given row or column, return the number of areas defined with a size of \"fill\" and the\n * amount of space in the grid system that is not defined by proportional width or height or\n * offset values. This is the space to be filled by the \"fill\" areas or by justification\n * options.\n *\n * Note this method also verifies that all items are rows or columns and if not reports a usage\n * error.\n *\n * @param {array} areaList - Array of structures for all areas in a row or column (see\n *            getAreaData)\n *\n * @return {structure} - { fillSize:fillSize, fillAreaCount:fillAreaCount }\n */\n\nexport let getFillData = function (areaList) {\n  // Used to verify that areas are not defined with a mixture of row and column elements\n  var testAreaType = areaList[0].areaType;\n  var typeError = false;\n  var fillSize = exports.constants.gridSystemSize;\n  var fillAreaCount = 0;\n\n  _.forEach(areaList, function (area) {\n    // Subtract proportional widths or heights\n    if (area.sizeType === 'P') {\n      fillSize -= area.sizeValue; // Count Fill Area\n      // Fill areas are identified by having a size of zero\n\n      if (area.sizeValue === 0) {\n        ++fillAreaCount;\n      }\n    } // Subtract proportional offsets\n\n\n    if (area.offsetSizeType === 'P') {\n      fillSize -= area.offsetSizeValue;\n    } // Verify all items are rows or columns (not a mixture)\n\n\n    if (area.areaType !== testAreaType) {\n      typeError = true;\n    }\n  });\n\n  if (typeError) {\n    exports.reportError('area found that is defined with mixed rows and columns');\n  }\n\n  if (fillSize < 0) {\n    fillSize = 0;\n    exports.reportError('row or column found defined with proportional areas that exceed grid system size: ' + exports.constants.gridSystemSize);\n  }\n\n  return {\n    fillSize: fillSize,\n    fillAreaCount: fillAreaCount\n  };\n};\n/**\n * Get Area List\n *\n * For the given container element, return the list of sub-areas (rows or columns) that define\n * the layout for the container.\n *\n * If there are sub-elements then return an array of structures (see getAreaData) If there are\n * no sub-elements then return null.\n *\n * @param {object} containerElement - Element containing the list of row or column elements\n *\n * @return {structure} - see getAreaData\n */\n\nexport let getAreaList = function (containerElement) {\n  if (!containerElement) {\n    return null;\n  }\n\n  var childList = containerElement.children;\n\n  if (!childList) {\n    return null;\n  }\n\n  if (childList.length < 1) {\n    return null;\n  }\n\n  var areaList = [];\n\n  _.forEach(childList, function (subArea) {\n    var subAreaData = exports.getAreaData(subArea);\n\n    if (subAreaData) {\n      areaList.push(subAreaData);\n    }\n  });\n\n  if (areaList.length < 1) {\n    return null;\n  }\n\n  return areaList;\n};\n/**\n * Get Area Data\n *\n * For a given row or column, create and return the data defining the size and options\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { areaElement, areaType, stackDirection, sizeType, sizeValue,\n *         offsetSizeType, offsetSizeValue, justify, color, align-content }\n */\n\nexport let getAreaData = function (areaElement) {\n  // Set the area type based on the elements class name\n  var classList = areaElement.classList;\n  var areaType = 'unknown';\n  var standardSizeFactor;\n  var stackDirection;\n\n  if (classList.contains('aw-layout-row')) {\n    areaType = 'row';\n    stackDirection = 'column'; // flexbox direction\n\n    standardSizeFactor = exports.constants.standardHeightFactor;\n  } else if (classList.contains('aw-layout-column')) {\n    areaType = 'column';\n    stackDirection = 'row'; // flexbox direction\n\n    standardSizeFactor = exports.constants.standardWidthFactor;\n  } else {\n    // Ignore all other elements\n    return null;\n  }\n\n  var userAttributes = exports.getAreaUserAttributes(areaElement);\n  var sizeData = exports.getSizeDataFromAttribute(userAttributes.size, standardSizeFactor);\n  var sizeType = sizeData.sizeType;\n  var sizeValue = sizeData.sizeValue;\n  sizeData = exports.getSizeDataFromAttribute(userAttributes.offset, standardSizeFactor);\n  var offsetSizeType = sizeData.sizeType;\n  var offsetSizeValue = sizeData.sizeValue;\n  return {\n    areaElement: areaElement,\n    // row or column element\n    areaType: areaType,\n    // \"row\", \"column\"\n    stackDirection: stackDirection,\n    // \"row\" means stack horizontally, \"column\" vertically\n    sizeType: sizeType,\n    // \"F\" fixed, \"P\" proportional, \"A\" auto\n    sizeValue: sizeValue,\n    // value for width or height\n    offsetSizeType: offsetSizeType,\n    // \"F\" or \"P\" type of values used for offset\n    offsetSizeValue: offsetSizeValue,\n    // width or height of the desired offset\n    justify: userAttributes.justify,\n    // \"left\", \"right\", \"top\", \"bottom\", \"center\"\n    color: userAttributes.color,\n    alignContent: userAttributes.alignContent,\n    // \"start\", \"center\", \"end\"\n    when: userAttributes.when,\n    // large, medium, small\n    wrapStyle: userAttributes.wrapStyle // nowrap, wrap, wrap-reverse\n\n  }; // Any CSS color string\n};\n/**\n * Get Area User Attributes\n *\n * For the given row or column, return a structure containing either the attribute value as\n * defined by the user or the default attribute value for all possible attributes.\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { size, offset, justify, color, id, alignContent }\n */\n\nexport let getAreaUserAttributes = function (areaElement) {\n  var sizeAttributeName = 'width';\n  var defaultJustifyString = 'left';\n\n  if (areaElement.classList.contains('aw-layout-row')) {\n    sizeAttributeName = 'height';\n    defaultJustifyString = 'top';\n  } // Get original attributes as defined in the element by the user\n\n\n  var sizeString = areaElement.getAttribute(sizeAttributeName);\n  var offsetString = areaElement.getAttribute('offset');\n  var justifyString = areaElement.getAttribute('justify');\n  var colorString = areaElement.getAttribute('color');\n  var idString = areaElement.getAttribute('offset');\n  var alignContent = areaElement.getAttribute('align-content');\n  var when = areaElement.getAttribute('when');\n  var wrapStyle = areaElement.getAttribute('wrap-style'); // Set defaults for attributes that were not defined by the user\n\n  sizeString = sizeString ? sizeString : '1';\n  offsetString = offsetString ? offsetString : '0';\n  justifyString = justifyString ? justifyString : defaultJustifyString;\n  colorString = colorString ? colorString : '';\n  idString = idString ? idString : '';\n  alignContent = alignContent ? alignContent : '';\n  when = when ? when : '';\n  wrapStyle = wrapStyle ? wrapStyle : '';\n  return {\n    size: sizeString,\n    offset: offsetString,\n    justify: justifyString,\n    color: colorString,\n    id: idString,\n    alignContent: alignContent,\n    when: when,\n    wrapStyle: wrapStyle\n  };\n};\n/**\n * Get Size Data From Attribute\n *\n * Given a size attribute string as defined for an <aw-row> or <aw-column> element and used by\n * the width, height, or offset attribute, return the size type and value. Return a structure of\n * the form { sizeType, sizeValue } where: sizeType = \"P\" for proportional values OR \"F\" for\n * fixed values. sizeValue = the integer values times the given standard width or height for\n * fixed values OR the integer value for proportional values\n *\n * @param {string} sizeAttr - The size attribute string as defined by the user\n * @param {number} fixedSizeFactor - Number applied to fixed sized values\n *\n * @return {structure} - { sizeType, sizeValue }\n */\n\nexport let getSizeDataFromAttribute = function (sizeAttr, fixedSizeFactor) {\n  var sizeString = '1'; // Default value\n\n  var sizeType = 'P';\n  var sizeValue = '0';\n\n  if (sizeAttr) {\n    sizeString = sizeAttr;\n    /**\n     * When size attribute is given as percentage, converting it in such a way to calculate\n     * the number based off proportion of 12\n     */\n\n    if (_.endsWith(sizeString, '%')) {\n      var percentNum = _.trimEnd(sizeString, '%');\n\n      sizeString = (percentNum * 12 / 100).toString();\n    }\n  }\n\n  if (sizeString.length < 1) {\n    sizeString = '1';\n  } else if (sizeString === 'fill') {\n    sizeString = '0';\n  } else if (sizeString === 'auto') {\n    sizeString = '0';\n    sizeType = 'A';\n  }\n\n  sizeValue = parseFloat(sizeString, 10);\n\n  if (isNaN(sizeValue)) {\n    exports.reportError('invalid row, column or offset size value (' + sizeAttr + ') - using default of 1');\n    sizeValue = 1;\n  } else if (sizeString[sizeString.length - 1] === 'f') {\n    // Fixed Value\n    sizeType = 'F';\n    sizeValue *= fixedSizeFactor;\n  }\n\n  return {\n    sizeType: sizeType,\n    sizeValue: sizeValue\n  };\n};\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\n\nexport let reportError = function (errorMessage) {\n  logger.warn('awRowColumnService:' + errorMessage);\n};\nexports = {\n  constants,\n  initRowOrColumn,\n  addNewElement,\n  setAreaStyle,\n  isLastChild,\n  getFillData,\n  getAreaList,\n  getAreaData,\n  getAreaUserAttributes,\n  getSizeDataFromAttribute,\n  reportError\n};\nexport default exports;","map":{"version":3,"names":["_","logger","exports","constants","gridSystemSize","standardWidthFactor","standardHeightFactor","initRowOrColumn","scopeElements","containerElement","parentElement","containerClassName","className","areaList","getAreaList","style","display","wrapStyle","flexWrap","webkitFlexDirection","stackDirection","flexDirection","centerJustifyIndex","farJustifyIndex","insertBefore","fillData","getFillData","fillValue","fillSize","fillAreaCount","fillAreaString","toString","forEach","area","index","setAreaStyle","areaElement","sizeType","sizeValue","color","alignContent","when","areaType","justifyOption","justify","offsetValue","offsetSizeValue","addNewElement","offsetSizeType","before","sibling","newElement","document","createElement","split","cName","classList","add","parentNode","valueString","flexString","areaPercent","deviceModeList","length","mode","deviceMode","trim","size","parseInt","flex","width","height","backgroundColor","alignContentValue","alignItems","isLastChild","parent","child","children","testAreaType","typeError","reportError","childList","subArea","subAreaData","getAreaData","push","standardSizeFactor","contains","userAttributes","getAreaUserAttributes","sizeData","getSizeDataFromAttribute","offset","sizeAttributeName","defaultJustifyString","sizeString","getAttribute","offsetString","justifyString","colorString","idString","id","sizeAttr","fixedSizeFactor","endsWith","percentNum","trimEnd","parseFloat","isNaN","errorMessage","warn"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/awRowColumnService.js"],"sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This service is used by <aw-row> and <aw-column> to initialize the flexbox sizing attributes for all rows and\n * columns within the grid system. And to establish elements to implement offsets, align-contents (start, center, end) and justification options.\n *\n * @module js/awRowColumnService\n */\nimport _ from 'lodash';\nimport logger from 'js/logger';\n\nlet exports = {}; // eslint-disable-line no-invalid-this\n\nexport let constants = {\n    gridSystemSize: 12,\n    standardWidthFactor: 1,\n    standardHeightFactor: 1\n};\n\n/**\n * Initialize Row or Column - every row or column element calls this method at link time to\n * initialized the flexbox attributes for all siblings. And to add elements to implement offsets\n * align-contents (start, center, end) and justification options.\n *\n * @param {object} scopeElements - The angularJS scope elements used to define the row or\n *            column.\n */\nexport let initRowOrColumn = function( scopeElements ) {\n    // Get the container element used for the given row or column element\n    var containerElement = scopeElements[ 0 ].parentElement;\n    var containerClassName = scopeElements[ 0 ].className;\n\n\n    // Get all sub-area in this row or column\n    var areaList = exports.getAreaList( containerElement );\n    if( areaList === null ) {\n        return;\n    }\n\n    // Set parent container element to use flexbox\n    containerElement.style.display = 'flex';\n    if( areaList[ 0 ].wrapStyle ) {\n        containerElement.style.flexWrap = areaList[ 0 ].wrapStyle;\n    }\n\n    containerElement.style.webkitFlexDirection = areaList[ 0 ].stackDirection;\n    containerElement.style.flexDirection = areaList[ 0 ].stackDirection;\n\n    // Variables used to captured the index for the first center justify\n    // and (right or bottom) justify elements\n    // Elements to implement the justification will be inserted before these elements\n    var centerJustifyIndex = -1;\n    var farJustifyIndex = -1;\n\n    // Flag to control relative positions of offset elements\n    var insertBefore = true;\n\n    // Get the number of fill areas and the amount of space that is\n    // NOT defined by proportional values needed to fill the grid system\n    var fillData = exports.getFillData( areaList );\n    var fillValue = fillData.fillSize;\n    var fillAreaCount = fillData.fillAreaCount;\n    var fillAreaString = '';\n\n    // If there are fill areas then all open area will be consumed by them\n    // Any justification options will be ignored\n    if( fillAreaCount > 0 ) {\n        // For multiple fill areas the area is split between them\n        fillAreaString = ( fillValue / fillAreaCount ).toString();\n        fillValue = 0;\n    }\n\n    // Process all items in the current row or column:\n    // Set the flexbox size attributes\n    // Capture key justification positions\n    // Add elements needed to implement offsets\n    _.forEach( areaList, function( area, index ) {\n        // Set flexbox size attributes for this element\n        exports.setAreaStyle( area.areaElement, area.sizeType, area.sizeValue, area.color,\n            fillAreaString, area.alignContent, area.when, area.areaType );\n\n        // Capture the index of the first center and (right or bottom) elements\n        var justifyOption = area.justify;\n        if( justifyOption === 'center' && centerJustifyIndex < 0 ) {\n            centerJustifyIndex = index;\n        }\n        if( ( justifyOption === 'right' || justifyOption === 'bottom' ) &&\n            farJustifyIndex < 0 ) {\n            farJustifyIndex = index;\n            insertBefore = false;\n        }\n\n        // If this element has an offset then create the offset element\n        var offsetValue = area.offsetSizeValue;\n        if( offsetValue > 0 ) {\n            exports.addNewElement( containerClassName, area.offsetSizeType, offsetValue,\n                'transparent', '', insertBefore, area.areaElement, area.areaType );\n        }\n    } ); // End process all items\n\n    // Add filler elements to handle justification or to fill in undefined space at the end\n    if( fillValue > 0 ) {\n        fillAreaString = fillValue.toString();\n\n        if( centerJustifyIndex >= 0 ) {\n            // Two Element are needed to center - so split the remaining space\n            // Note that this also handles the case of a center AND a (right or bottom) justification\n            fillAreaString = ( fillValue / 2 ).toString();\n\n            // Insert an element before the center justify element\n            exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                true, areaList[ centerJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n\n            if( farJustifyIndex > 0 ) {\n                // Also insert a new element before the far justify element\n                exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                    true, areaList[ farJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n            } else {\n                // There is no right or bottom justify option - so insert at the end to center\n                exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                    false, scopeElements[ 0 ], areaList[ 0 ].areaType );\n            }\n        } else if( farJustifyIndex >= 0 ) {\n            // Insert one new element before the far justify element\n            exports.addNewElement( containerClassName, 'P', 0, 'transparent', fillAreaString,\n                true, areaList[ farJustifyIndex ].areaElement, areaList[ 0 ].areaType );\n        }\n    }\n};\n\n/**\n * Add New Element\n *\n * Add a new element of a given size before or after a given sibling element.\n *\n * @param {string} className - The class name used for all siblings.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n *            areas\n * @param {boolean} before - when true insert the new element before the sibling, otherwise\n *            insert after\n * @param {object} sibling - existing sibling element to insert before or after Note: pass in\n *            the DOM element not the JQuery/Angular scoping element\n */\nexport let addNewElement = function( className, sizeType, sizeValue, color, fillAreaString, before,\n    sibling, areaType ) {\n    // Example to get rid of ngModule.element\n    /*\n        ngModule.element - it is a $.element, which should be replaced by vallinaJS ( major usage )\n        ngModule.isUndefined - can be vanillaJS\n        ngModule.copy - simple deep copy\n        ngModule.bind - similar like function.bind, not sure why we need this. But should be able to replace.\n        ngModule.noop - similar like null? Anyway we can do equivalent\n        ngModule.forEach - _.forEachngModule.isFunction - _.isFunction\n     */\n    var newElement = document.createElement( 'div' );\n\n    _.forEach( className.split( ' ' ), function( cName ) {\n        newElement.classList.add( cName );\n    } );\n\n    exports.setAreaStyle( newElement, sizeType, sizeValue, color, fillAreaString, null, null, areaType );\n\n    sibling.parentNode.insertBefore( newElement, sibling );\n\n    if( !before ) {\n        newElement.parentNode.insertBefore( sibling, newElement );\n    }\n};\n\n/**\n * Set Area Style\n *\n * Set the flexbox size attributes for Fixed and Proportional areas and set the given color.\n *\n * @param {object} areaElement - The row or column to size.\n * @param {string} sizeType - \"P\" or \"F\" for proportional or fixed.\n * @param {number} sizeValue - The fixed or proportional size.\n * @param {string} color - Any CSS color value.\n * @param {string} fillAreaString - when sizeValue is zero then this string is used for fill\n * @param {string} alignContent - \"start\", \"center\" or \"end\" to flex align Items/ Content\n *            areas\n * @param {string} when - \"xlarge: <value>, large: <value>, medium: <value>, small: <value>, xsmall: <value>\"\n *            12 column responsive grid layout\n */\nexport let setAreaStyle = function( areaElement, sizeType, sizeValue, color, fillAreaString, alignContent, when, areaType ) {\n    var valueString = sizeValue.toString();\n    var flexString;\n\n    var areaPercent = '';\n\n    if( sizeType === 'P' ) {\n        if( sizeValue > 0 ) {\n            // This is a normal proportional area\n            // note that for IE performance, numeric values should not be used for the flex-basis (3rd value in flexString)\n            flexString = valueString + ' ' + valueString + ' auto';\n            if( valueString > 1 ) {\n                areaPercent = 100 * valueString / 12 + '%';\n            }\n        } else {\n            // This is a fill area - which will also be proportional\n            flexString = fillAreaString + ' ' + fillAreaString + ' auto';\n            if( fillAreaString > 1 ) {\n                areaPercent = 100 * fillAreaString / 12 + '%';\n            }\n        }\n    } else if( sizeType === 'A' ) {\n        flexString = '0 0 auto';\n    } else { // sizeType = \"F\"\n        // These are areas defined with fixed values\n        flexString = '0 0 ' + sizeValue.toString() + 'em';\n    }\n\n    if( when && sizeType === 'P' ) {\n        var deviceModeList = when.split( ',' );\n        if( deviceModeList && deviceModeList.length ) {\n            deviceModeList.forEach( function( mode ) {\n                var deviceMode = mode.split( ':' )[ 0 ].trim();\n                var size = parseInt( mode.split( ':' )[ 1 ] );\n\n                if( deviceMode === 'xlarge' ) {\n                    areaElement.className += ' aw-xlarge-' + size + ' ';\n                } else if( deviceMode === 'large' ) {\n                    areaElement.className += ' aw-large-' + size + ' ';\n                } else if( deviceMode === 'medium' ) {\n                    areaElement.className += ' aw-medium-' + size + ' ';\n                } else if( deviceMode === 'small' ) {\n                    areaElement.className += ' aw-small-' + size + ' ';\n                } else if( deviceMode === 'xsmall' ) {\n                    areaElement.className += ' aw-xsmall-' + size + ' ';\n                } else {\n                    areaElement.className += ' aw-default-' + sizeValue + ' ';\n                }\n            } );\n        }\n    } else {\n        // apply the flex value inline\n        // Numeric flex-basis should be avoided.\n        // Any change their needs to be carefully tested in IE for performance validation.\n        areaElement.style.flex = flexString;\n        if( areaPercent ) {\n            areaType === 'column' ? areaElement.style.width = areaPercent : areaElement.style.height = areaPercent;\n        }\n    }\n\n    // Add the flexbox sizing string and user given color to the current element\n    areaElement.style.backgroundColor = color;\n    var alignContentValue = '';\n    switch ( alignContent ) {\n    case 'start':\n        alignContentValue = 'flex-start';\n        break;\n    case 'center':\n        alignContentValue = 'center';\n        break;\n    case 'end':\n        alignContentValue = 'flex-end';\n        break;\n    }\n    areaElement.style.alignItems = alignContentValue;\n};\n\n/**\n * Is Last Child\n *\n * Return true if the given child element is the last child element of the given parent element.\n *\n * @param {object} parent - container element\n * @param {object} child - a child of the container element\n *\n * @return {boolean} - true if child is the last child in parent\n */\nexport let isLastChild = function( parent, child ) {\n    if( !parent ) {\n        return false;\n    }\n    var children = parent.children;\n    if( !children ) {\n        return false;\n    }\n    var length = children.length;\n    if( length < 1 ) {\n        return false;\n    }\n    if( children[ length - 1 ] !== child ) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Get Fill Data\n *\n * For the given row or column, return the number of areas defined with a size of \"fill\" and the\n * amount of space in the grid system that is not defined by proportional width or height or\n * offset values. This is the space to be filled by the \"fill\" areas or by justification\n * options.\n *\n * Note this method also verifies that all items are rows or columns and if not reports a usage\n * error.\n *\n * @param {array} areaList - Array of structures for all areas in a row or column (see\n *            getAreaData)\n *\n * @return {structure} - { fillSize:fillSize, fillAreaCount:fillAreaCount }\n */\nexport let getFillData = function( areaList ) {\n    // Used to verify that areas are not defined with a mixture of row and column elements\n    var testAreaType = areaList[ 0 ].areaType;\n    var typeError = false;\n\n    var fillSize = exports.constants.gridSystemSize;\n    var fillAreaCount = 0;\n\n    _.forEach( areaList, function( area ) {\n        // Subtract proportional widths or heights\n        if( area.sizeType === 'P' ) {\n            fillSize -= area.sizeValue;\n\n            // Count Fill Area\n            // Fill areas are identified by having a size of zero\n            if( area.sizeValue === 0 ) {\n                ++fillAreaCount;\n            }\n        }\n\n        // Subtract proportional offsets\n        if( area.offsetSizeType === 'P' ) {\n            fillSize -= area.offsetSizeValue;\n        }\n\n        // Verify all items are rows or columns (not a mixture)\n        if( area.areaType !== testAreaType ) {\n            typeError = true;\n        }\n    } );\n\n    if( typeError ) {\n        exports.reportError( 'area found that is defined with mixed rows and columns' );\n    }\n\n    if( fillSize < 0 ) {\n        fillSize = 0;\n        exports.reportError( 'row or column found defined with proportional areas that exceed grid system size: ' + exports.constants.gridSystemSize );\n    }\n\n    return {\n        fillSize: fillSize,\n        fillAreaCount: fillAreaCount\n    };\n};\n\n/**\n * Get Area List\n *\n * For the given container element, return the list of sub-areas (rows or columns) that define\n * the layout for the container.\n *\n * If there are sub-elements then return an array of structures (see getAreaData) If there are\n * no sub-elements then return null.\n *\n * @param {object} containerElement - Element containing the list of row or column elements\n *\n * @return {structure} - see getAreaData\n */\nexport let getAreaList = function( containerElement ) {\n    if( !containerElement ) {\n        return null;\n    }\n    var childList = containerElement.children;\n    if( !childList ) {\n        return null;\n    }\n    if( childList.length < 1 ) {\n        return null;\n    }\n\n    var areaList = [];\n\n    _.forEach( childList, function( subArea ) {\n        var subAreaData = exports.getAreaData( subArea );\n        if( subAreaData ) {\n            areaList.push( subAreaData );\n        }\n    } );\n\n    if( areaList.length < 1 ) {\n        return null;\n    }\n\n    return areaList;\n};\n\n/**\n * Get Area Data\n *\n * For a given row or column, create and return the data defining the size and options\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { areaElement, areaType, stackDirection, sizeType, sizeValue,\n *         offsetSizeType, offsetSizeValue, justify, color, align-content }\n */\nexport let getAreaData = function( areaElement ) {\n    // Set the area type based on the elements class name\n    var classList = areaElement.classList;\n\n    var areaType = 'unknown';\n    var standardSizeFactor;\n    var stackDirection;\n\n    if( classList.contains( 'aw-layout-row' ) ) {\n        areaType = 'row';\n        stackDirection = 'column'; // flexbox direction\n        standardSizeFactor = exports.constants.standardHeightFactor;\n    } else if( classList.contains( 'aw-layout-column' ) ) {\n        areaType = 'column';\n        stackDirection = 'row'; // flexbox direction\n        standardSizeFactor = exports.constants.standardWidthFactor;\n    } else {\n        // Ignore all other elements\n        return null;\n    }\n\n    var userAttributes = exports.getAreaUserAttributes( areaElement );\n\n    var sizeData = exports.getSizeDataFromAttribute( userAttributes.size, standardSizeFactor );\n    var sizeType = sizeData.sizeType;\n    var sizeValue = sizeData.sizeValue;\n\n    sizeData = exports.getSizeDataFromAttribute( userAttributes.offset, standardSizeFactor );\n    var offsetSizeType = sizeData.sizeType;\n    var offsetSizeValue = sizeData.sizeValue;\n\n    return {\n        areaElement: areaElement, // row or column element\n        areaType: areaType, // \"row\", \"column\"\n        stackDirection: stackDirection, // \"row\" means stack horizontally, \"column\" vertically\n        sizeType: sizeType, // \"F\" fixed, \"P\" proportional, \"A\" auto\n        sizeValue: sizeValue, // value for width or height\n        offsetSizeType: offsetSizeType, // \"F\" or \"P\" type of values used for offset\n        offsetSizeValue: offsetSizeValue, // width or height of the desired offset\n        justify: userAttributes.justify, // \"left\", \"right\", \"top\", \"bottom\", \"center\"\n        color: userAttributes.color,\n        alignContent: userAttributes.alignContent, // \"start\", \"center\", \"end\"\n        when: userAttributes.when, // large, medium, small\n        wrapStyle: userAttributes.wrapStyle // nowrap, wrap, wrap-reverse\n    }; // Any CSS color string\n};\n\n/**\n * Get Area User Attributes\n *\n * For the given row or column, return a structure containing either the attribute value as\n * defined by the user or the default attribute value for all possible attributes.\n *\n * @param {object} areaElement - Row or Column element\n *\n * @return {structure} - { size, offset, justify, color, id, alignContent }\n */\nexport let getAreaUserAttributes = function( areaElement ) {\n    var sizeAttributeName = 'width';\n    var defaultJustifyString = 'left';\n    if( areaElement.classList.contains( 'aw-layout-row' ) ) {\n        sizeAttributeName = 'height';\n        defaultJustifyString = 'top';\n    }\n\n    // Get original attributes as defined in the element by the user\n    var sizeString = areaElement.getAttribute( sizeAttributeName );\n    var offsetString = areaElement.getAttribute( 'offset' );\n    var justifyString = areaElement.getAttribute( 'justify' );\n    var colorString = areaElement.getAttribute( 'color' );\n    var idString = areaElement.getAttribute( 'offset' );\n    var alignContent = areaElement.getAttribute( 'align-content' );\n    var when = areaElement.getAttribute( 'when' );\n    var wrapStyle = areaElement.getAttribute( 'wrap-style' );\n\n    // Set defaults for attributes that were not defined by the user\n    sizeString = sizeString ? sizeString : '1';\n    offsetString = offsetString ? offsetString : '0';\n    justifyString = justifyString ? justifyString : defaultJustifyString;\n    colorString = colorString ? colorString : '';\n    idString = idString ? idString : '';\n    alignContent = alignContent ? alignContent : '';\n    when = when ? when : '';\n    wrapStyle = wrapStyle ? wrapStyle : '';\n\n    return {\n        size: sizeString,\n        offset: offsetString,\n        justify: justifyString,\n        color: colorString,\n        id: idString,\n        alignContent: alignContent,\n        when: when,\n        wrapStyle: wrapStyle\n    };\n};\n\n/**\n * Get Size Data From Attribute\n *\n * Given a size attribute string as defined for an <aw-row> or <aw-column> element and used by\n * the width, height, or offset attribute, return the size type and value. Return a structure of\n * the form { sizeType, sizeValue } where: sizeType = \"P\" for proportional values OR \"F\" for\n * fixed values. sizeValue = the integer values times the given standard width or height for\n * fixed values OR the integer value for proportional values\n *\n * @param {string} sizeAttr - The size attribute string as defined by the user\n * @param {number} fixedSizeFactor - Number applied to fixed sized values\n *\n * @return {structure} - { sizeType, sizeValue }\n */\nexport let getSizeDataFromAttribute = function( sizeAttr, fixedSizeFactor ) {\n    var sizeString = '1'; // Default value\n    var sizeType = 'P';\n    var sizeValue = '0';\n\n    if( sizeAttr ) {\n        sizeString = sizeAttr;\n\n        /**\n         * When size attribute is given as percentage, converting it in such a way to calculate\n         * the number based off proportion of 12\n         */\n        if( _.endsWith( sizeString, '%' ) ) {\n            var percentNum = _.trimEnd( sizeString, '%' );\n            sizeString = ( percentNum * 12 / 100 ).toString();\n        }\n    }\n\n    if( sizeString.length < 1 ) {\n        sizeString = '1';\n    } else if( sizeString === 'fill' ) {\n        sizeString = '0';\n    } else if( sizeString === 'auto' ) {\n        sizeString = '0';\n        sizeType = 'A';\n    }\n\n    sizeValue = parseFloat( sizeString, 10 );\n\n    if( isNaN( sizeValue ) ) {\n        exports.reportError( 'invalid row, column or offset size value (' + sizeAttr +\n            ') - using default of 1' );\n        sizeValue = 1;\n    } else if( sizeString[ sizeString.length - 1 ] === 'f' ) { // Fixed Value\n        sizeType = 'F';\n        sizeValue *= fixedSizeFactor;\n    }\n\n    return {\n        sizeType: sizeType,\n        sizeValue: sizeValue\n    };\n};\n\n/**\n * Report a usage error.\n *\n * @param {string} errorMessage - error to report.\n */\nexport let reportError = function( errorMessage ) {\n    logger.warn( 'awRowColumnService:' + errorMessage );\n};\n\nexports = {\n    constants,\n    initRowOrColumn,\n    addNewElement,\n    setAreaStyle,\n    isLastChild,\n    getFillData,\n    getAreaList,\n    getAreaData,\n    getAreaUserAttributes,\n    getSizeDataFromAttribute,\n    reportError\n};\nexport default exports;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}