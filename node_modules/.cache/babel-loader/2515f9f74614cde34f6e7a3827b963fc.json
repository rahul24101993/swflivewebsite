{"ast":null,"code":"/* eslint-disable class-methods-use-this */ // Copyright (c) 2020 Siemens\n/**\n * This service is used to manage the configuration of the paste operation.\n *\n * Please refer {@link https://gitlab.industrysoftware.automation.siemens.com/Apollo/afx/wikis/solution#solution-configuration-for-paste-handling|Solution configuration for paste handling}\n *\n * @module js/pasteService\n *\n * @publishedApolloService\n *\n */import AwPromiseService from'js/awPromiseService';import cfgSvc from'js/configurationService';import appCtxService from'js/appCtxService';import adapterSvc from'js/adapterService';import localeSvc from'js/localeService';import messagingSvc from'js/messagingService';import _ from'lodash';import logger from'js/logger';import eventBus from'js/eventBus';import declUtils from'js/declUtils';import viewModelService from'js/viewModelService';import actionService from'js/actionService';import conditionSvc from'js/conditionService';import expParUtils from'js/expressionParserUtils';import ccu from'js/commandConfigUtils.service';import awConfiguration from'js/awConfiguration';import moduleLoader from'js/moduleLoader';import awDuiLocalizationSvc from'js/awDuiLocalizationService';/**\n * This object represents the union of all module level 'paste.json' configurations for the current AW\n * application.\n *\n * Content & Structure of the 'paste.json' file located:<BR>\n * WAR: <war_root>\\assets\\config\\paste.json <BR>\n * Kit: <dev_root>\\out\\kit\\tcawframework_aws2stage.zip\\stage\\repo\\gwt\\tc-aw-framework\\module.json\n *\n * The 'paste.json' module is used during Drag-and-Drop operations to specify which types of objects\n * being dragged (i.e. the 'source' types) are valid to drop onto a specific type object (i.e. the 'target'\n * type). If no source/target match is found, the drop will not be allowed and the user will see the 'drop not\n * allowed' symbol for their cursor.\n * <P>\n * The most specific type in an object's type hierarchy is used. <BR>\n * There is no inheritance between properties in this file.\n * <P>\n *\n * For Each (sourceType) and (targetType) section must be specify with action\n * <P>\n * All 'source' object types must be valid for a specific 'target' before the drop will be allowed.\n *\n * Note 1: This mapping only applies for dropping 'source' objects onto a single 'target' object. When dropping\n * into an 'objectSet' of an XRT stylesheet, the relation information in the 'source' attribute of the\n * 'objectSet' is used.\n *\n *\n * The JSON object generically is structured as:\n *\n * <pre>\n * {\n    \"schemaVersion\": \"1.0.0\",\n    \"pasteHandlers\": {\n        \"handlerName\": {\n            \"action\": \"HandlerAction\",\n            \"activeWhen\": {\n                \"condition\": \"conditionToActiveTheHandler\"\n            }\n        }\n    },\n    \"actions\": {\n        \"HandlerAction\": {\n          // declartive action that we follow in commandsViewModel / ViewModel.json\n        }\n    },\n    \"conditions\": {\n        \"conditionToActiveTheHandler\": {\n            \"expression\": {\n                \"$and\": [ {\n                        \"$source\": \"pasteContext.targetObject\",\n                        \"$query\": {\n                            \"$typeOf\": \"nameOfTargetObject\"\n                        }\n                    },\n                    {\n                        \"$source\": \"pasteContext.sourceObject\",\n                        \"$query\": {\n                            \"$typeOf\": \"nameOfSourceObject\"\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}\n * </pre>\n *\n * Example: The following specifies that:<BR>\n * a) any 'target' of type 'Folder' should use the 'customPasteHandler' defined in the JS file\n * 'js/pasteHandlers.js' when items of type 'ItemRevision' are pasted on them\n * <P>\n * Similary we can create following combination\n * b) any 'target' of type 'WorkspaceObject' should use the 'tcDefaultPasteHandler' with default relations when\n * items of type 'ItemRevision' or 'DocumentRevision' are pasted on them.\n * <P>\n * c) any 'target' of type 'DocumentRevision' should use the 'defaultFilePasteHandler' specifying the\n * 'TC_Attaches' relations (and other datasetInfo properties) when objects of type 'Dataset' are pasted on them.\n *\n * <pre>\n * {\n    \"schemaVersion\": \"1.0.0\",\n    \"pasteHandlers\": {\n        \"defaultPasteHandlerForImpactAnalysis\": {\n            \"action\": \"defaultPasteHandlerForImpactAnalysis\",\n            \"activeWhen\": {\n                \"condition\": \"conditions.isPasteHandlerActiveForImpactAnalysisNew\"\n            }\n        }\n    },\n    \"actions\": {\n        \"defaultPasteHandlerForImpactAnalysis\": {\n            \"actionType\": \"JSFunction\",\n            \"method\": \"customPasteHandler\",\n            \"deps\": \"js/pasteHandlers\",\n            \"inputData\": {\n                \"targetObject\": \"{{pasteContext.targetObject}}\",\n                \"sourceObject\": \"{{pasteContext.sourceObject}}\"\n            },\n            \"events\": {\n                \"success\": [ {\n                    \"name\": \"dragDrop.success\",\n                    \"condition\": \"pasteContext.isDragDropIntent\",\n                    \"eventData\": {\n                        \"sourceObjects\": \"{{pasteContext.sourceObject}}\",\n                        \"targetObject\": \"{{pasteContext.targetObject}}\"\n                    }\n                } ]\n            }\n        }\n    },\n    \"conditions\": {\n        \"isPasteHandlerActiveForImpactAnalysisNew\": {\n            \"expression\": {\n                \"$and\": [ {\n                        \"$source\": \"pasteContext.targetObject\",\n                        \"$query\": {\n                            \"$typeOf\": \"Folder\"\n                        }\n                    },\n                    {\n                        \"$source\": \"pasteContext.sourceObject\",\n                        \"$query\": {\n                            \"$typeOf\": \"ItemRevision\"\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}\n* </pre>\n*/var _pasteConfig;var _pasteConfigMap;var targetSourceMap;var _declViewModel;/**\n * ############################################################<BR>\n * Define the public functions exposed by this module.<BR>\n * ############################################################<BR>\n * @ignore\n */let exports;/**\n * Create the declartive viewModel from all combined paste.json\n *\n * @param {Object} viewModel - event data information with name and value of changes\n * @returns {Promise} promise with decl view model json\n */const createViewModel=async function(viewModel){var deferred=AwPromiseService.instance.defer();viewModel._viewModelId='pasteViewModel_'+Math.random;viewModel.skipClone=true;let populatedViewModelJson=viewModelService.populateViewModelPropertiesFromJson(viewModel,null,null,true);populatedViewModelJson.i18n=await awDuiLocalizationSvc.populateI18nMap(viewModel.i18n,null);deferred.resolve(populatedViewModelJson);return deferred.promise;};var udpateMap=function(query,key,sourceObject,targetObject){var queryToUse=query;var matchAll=queryToUse[expParUtils.$ALL];queryToUse=matchAll||queryToUse;var performAND=queryToUse[expParUtils.$AND]||queryToUse[expParUtils.$ALL];var performOR=queryToUse[expParUtils.$OR];var evalChecks=performAND||performOR||[queryToUse];_.forEach(evalChecks,function(evalCheck){var path=expParUtils.resolve(expParUtils.$SOURCE,evalCheck);var condition=expParUtils.resolve(expParUtils.$QUERY,evalCheck)||evalCheck;if(path==='pasteContext.sourceObject'){sourceObject=condition.$typeOf;}else if(path==='pasteContext.targetObject'){targetObject=condition.$typeOf;}if(sourceObject&&targetObject&&path){if(!targetSourceMap.has(targetObject)){targetSourceMap.set(targetObject,{sourceTypes:{}});}if(!targetSourceMap.get(targetObject).sourceTypes[sourceObject]){targetSourceMap.get(targetObject).sourceTypes[sourceObject]=[];}targetSourceMap.get(targetObject).sourceTypes[sourceObject].push(key);}var recurseExpressionEvaluation=condition&&(condition[expParUtils.$ALL]||condition[expParUtils.$AND]||condition[expParUtils.$OR]||condition[expParUtils.$SOURCE]);if(recurseExpressionEvaluation){udpateMap(condition,key,sourceObject,targetObject);}});};/**\n * Update the '_pasteConfigMap' on with all combine paste.json\n *\n */function updateThePasteConfig(){targetSourceMap=new Map();_.forEach(_pasteConfig.pasteHandlers,function(value,key){if(value.activeWhen){var condition=value.activeWhen.condition;var conditionExpression=null;var sourceObject;var targetObject;if(_.startsWith(condition,'conditions.')){conditionExpression=_.get(_pasteConfig,condition);}else{conditionExpression=condition;}if(conditionExpression&&conditionExpression.expression){udpateMap(conditionExpression.expression,key,sourceObject,targetObject);}}});_pasteConfigMap=targetSourceMap;}/**\n * Update the 'selectedModelTypeRelations' on the appCtx for the one step Paste command.\n *\n * @param {Object} eventData - event data information with name and value of changes\n */function changeValidSourceTypesForSelected(eventData){if(eventData.name==='mselected'&&eventData.value&&eventData.value.length===1){var objectValidSourceTypes=exports.getObjectValidSourceTypes(eventData.value[0]);objectValidSourceTypes=objectValidSourceTypes||{};appCtxService.registerCtx('selectedModelTypeRelations',Object.keys(objectValidSourceTypes));}}/**\n * create Success Message For DND\n *\n * @param {sourceObjects} sourceObjects -Service to use.\n * @param {targetObject} targetObject -Service to use.\n *\n * invoke success message\n */function createSuccessMessageForDND(sourceObjects,targetObject){var pasteSuccessMessage={messageText:'',messageTextParams:[]};if(sourceObjects.length>1){localeSvc.getLocalizedTextFromKey('ZeroCompileCommandMessages.pasteMultipleSuccessMessage').then(function(response){pasteSuccessMessage.messageText=response;pasteSuccessMessage.messageTextParams=[sourceObjects.length,targetObject.props.object_string.uiValues[0]];var messageText=messagingSvc.applyMessageParamsWithoutContext(pasteSuccessMessage.messageText,pasteSuccessMessage.messageTextParams);messagingSvc.showInfo(messageText);});}else{localeSvc.getLocalizedTextFromKey('ZeroCompileCommandMessages.pasteSuccessMessage').then(function(response){pasteSuccessMessage.messageText=response;const sourceObjectName=sourceObjects&&sourceObjects[0].props&&sourceObjects[0].props.object_string?sourceObjects[0].props.object_string.uiValues[0]:sourceObjects[0].name;pasteSuccessMessage.messageTextParams=[sourceObjectName,targetObject.props.object_string.uiValues[0]];var messageText=messagingSvc.applyMessageParamsWithoutContext(pasteSuccessMessage.messageText,pasteSuccessMessage.messageTextParams);messagingSvc.showInfo(messageText);});}}/**\n * create Failure Message For DND\n *\n * @param {errorReason} errorReason -Service to use.\n *\n *  invokes  failure message\n */function createFailureMessageForDND(errorReason){localeSvc.getLocalizedTextFromKey('ZeroCompileCommandMessages.pasteFailureMessage').then(result=>{var pasteFailureMessage=result;var errorText=pasteFailureMessage+':';_.forEach(errorReason.message.split(/\\n/g),function(messageLine){errorText=errorText+'<br>'+messageLine;});messagingSvc.showInfo(errorText);});}/**\n * handler for dragDrop event\n * @param {Array} sourceObjects source objects drag frim\n * @param {Object} targetObject target object drop to\n */function handleSuccess(sourceObjects,targetObject){var adaptedSourceObjects=adapterSvc.getAdaptedObjectsSync(sourceObjects);createSuccessMessageForDND(adaptedSourceObjects,targetObject);}export const getTargetType=function(targetObject){var targetTypes=getTargetTypes();var typeHier=declUtils.getTypeHierarchy(targetObject)||[targetObject.type];if(typeHier[0]){for(var ii=0;ii<typeHier.length;ii++){var typeName=typeHier[ii];if(targetTypes.has(typeName)){return targetTypes.get(typeName);}}}return null;};export const getSourceType=function(sourceTypes,sourceObject){var typeHier=declUtils.getTypeHierarchy(sourceObject)||[sourceObject.type];if(typeHier[0]){for(var ii=0;ii<typeHier.length;ii++){var typeName=typeHier[ii];if(sourceTypes[typeName]){return sourceTypes[typeName];}}}return null;};/**\n * To Paste objects with single relationType\n *\n * This would\n * 1. use bestTargetFitFinder function to find the best possible Target Fit for the given target object by reading the paste configuration.\n * 2. use bestSourceFitFinder function to find the best possible Source Fit for the given source object by reading the paste configuration.\n * 3. Invoke the configured pasteHandler for the target + source type combination.\n * 4. If no suitable target + source type combination for paste handler is found then (configured) default paste handler is invoked.\n *\n * @param {Object} targetObject - The 'target' Object for the paste.\n * @param {Array} sourceObjects - Array of 'source' Objects to paste onto the 'target' Object.\n * @param {String} relationType - Relation type name\n * @param {object} customPasteContext - custom paste context\n *\n * @returns {Promise} This promise will be 'resolved' or 'rejected' when the service is invoked and its response\n *          data is available.\n */export let execute=function(targetObject,sourceObjects,relationType,customPasteContext){var queue={};var custObj=customPasteContext;if(custObj&&!custObj.hasOwnProperty('isDragDropIntent')){custObj.isDragDropIntent=false;}else if(!custObj){custObj={isDragDropIntent:false};}var defaultPasteHandlerConfiguration=awConfiguration.get('solutionDef.defaultPasteHandlerConfiguration');var doAction=function(defaultPasteHandler,declViewModel){_.forEach(sourceObjects,function(sourceObject){var pasteContext={targetObject:targetObject,sourceObject:sourceObject,relationType:relationType,...custObj};var targetTypeConfig=null;if(typeof defaultPasteHandlerConfiguration==='object'){targetTypeConfig=defaultPasteHandler[defaultPasteHandlerConfiguration.bestTargetFitFinder](targetObject);}else{targetTypeConfig=getTargetType(targetObject);}var action=null;var actionName=null;if(targetTypeConfig){var sourceTypeConfig=null;if(typeof defaultPasteHandlerConfiguration==='object'){sourceTypeConfig=defaultPasteHandler[defaultPasteHandlerConfiguration.bestSourceFitFinder](targetTypeConfig.sourceTypes,sourceObject);}else{sourceTypeConfig=getSourceType(targetTypeConfig.sourceTypes,sourceObject);}var length=0;var currentLength;if(sourceTypeConfig){_.forEach(sourceTypeConfig,function(pasteHandlers){var pasteHandlerObject=_pasteConfig.pasteHandlers[pasteHandlers];var conditionResult=false;var conditionExpression=pasteHandlerObject.activeWhen.condition;if(_.startsWith(pasteHandlerObject.activeWhen.condition,'conditions.')){conditionExpression=_.get(_pasteConfig,pasteHandlerObject.activeWhen.condition);}if(conditionExpression!==null){currentLength=ccu.getExpressionLength(conditionExpression.expression,declViewModel);conditionResult=conditionSvc.evaluateCondition({ctx:appCtxService.ctx,pasteContext:pasteContext},conditionExpression.expression);}if(conditionResult&&currentLength>length){length=currentLength;action=_pasteConfig.actions[pasteHandlerObject.action];actionName=pasteHandlerObject.action;}});}}if(!actionName&&typeof defaultPasteHandlerConfiguration==='object'){var handlerFunctionName=defaultPasteHandlerConfiguration.pasteHandler;actionName=_pasteConfig.pasteHandlers[handlerFunctionName].action;action=_pasteConfig.actions[actionName];logger.warn('No configured paste handler found for source object: \\''+sourceObject+'\\' when target object: \\''+targetObject+'\\''+'\\n'+'RelationType: \\''+relationType+'\\''+'\\n'+'...Assuming default handler');}if(actionName){if(!queue.hasOwnProperty(actionName)){queue[actionName]={};}if(!queue[actionName].hasOwnProperty('sourceObjs')){queue[actionName].sourceObjs=[];}queue[actionName].sourceObjs.push(sourceObject);if(action){queue[actionName].handlerAction=action;}}});/**\n         * Loop for each unique 'handler' and build up a promise chain.\n         */var promiseArray=[];_.forEach(queue,function(queuedSrcObjInfo){var depFileToLoad=queuedSrcObjInfo.handlerAction.deps;var depModuleObj=null;var dataCtxNode={data:declViewModel,ctx:appCtxService.ctx,pasteContext:{targetObject:targetObject,sourceObject:queuedSrcObjInfo.sourceObjs,relationType:relationType,...custObj}};if(depFileToLoad){//Revisit: getDependentModule is yet to be supported\n//depModuleObj = moduleLoader.getDependentModule( queuedSrcObjInfo.handlerAction.deps );\nif(!depModuleObj){promiseArray.push(moduleLoader.loadDependentModule(queuedSrcObjInfo.handlerAction.deps).then(function(pasteHandler){depModuleObj=pasteHandler;return actionService.executeAction(declViewModel,queuedSrcObjInfo.handlerAction,dataCtxNode,depModuleObj,false);}));}else{promiseArray.push(actionService.executeAction(declViewModel,queuedSrcObjInfo.handlerAction,dataCtxNode,depModuleObj,false));}}else{promiseArray.push(actionService.executeAction(declViewModel,queuedSrcObjInfo.handlerAction,dataCtxNode,depModuleObj,false));}});return AwPromiseService.instance.all(promiseArray);};var performAction=function(declViewModel){if(defaultPasteHandlerConfiguration.deps){//Revisit: getDependentModule is yet to be supported\n//var defaultPasteHandler = moduleLoader.getDependentModule( defaultPasteHandlerConfiguration.deps );\n//if( !defaultPasteHandler ) {\n// return moduleLoader.loadDependentModule( defaultPasteHandlerConfiguration.deps ).then( function( pasteHandler ) {\n//     return doAction( pasteHandler, declViewModel );\n// } );\n//}\n//return doAction( defaultPasteHandler, declViewModel );\nreturn moduleLoader.loadDependentModule(defaultPasteHandlerConfiguration.deps).then(function(pasteHandler){return doAction(pasteHandler,declViewModel);});}return doAction(null,declViewModel);};if(!_declViewModel){return createViewModel(_pasteConfig).then(function(declViewModel){_declViewModel=declViewModel;return performAction(_declViewModel);});}return performAction(_declViewModel);};/**\n * To Paste objects with different relationTypes\n * Same as {@link module:js/pasteService.execute|execute} except that this executes with multiple source object + relation types for a single target object.\n *\n * @param {Object} targetObject - the target object to paste the source objects to\n * @param {Object} relationTypeToSources - an object of key/value: relationType/array-of-sourceObjects\n *\n * @returns {Promise} Resolved when all processing is complete.\n */export let executeWithMultipleRelations=function(targetObject,relationTypeToSources){var allPromises=[];_.forOwn(relationTypeToSources,function(sourceObjects,relationType){allPromises.push(exports.execute(targetObject,sourceObjects,relationType));});return AwPromiseService.instance.all(allPromises);};export const determineActiveHandler=(sourceObjects,targetObject)=>{var conditionResult=false;_.forOwn(_pasteConfig.pasteHandlers,pasteHandlerObject=>{var conditionExpression=pasteHandlerObject.activeWhen?pasteHandlerObject.activeWhen.condition:null;if(conditionExpression){if(_.startsWith(pasteHandlerObject.activeWhen.condition,'conditions.')){conditionExpression=_.get(_pasteConfig,pasteHandlerObject.activeWhen.condition);}if(conditionExpression!==null){conditionResult=conditionResult||conditionSvc.evaluateCondition({ctx:appCtxService.ctx,pasteContext:{targetObject:targetObject,sourceObject:sourceObjects,relationType:''}},conditionExpression.expression);}}});return conditionResult;};/**\n * Gets all of the available targetTypes configured in paste.json files from different modules.\n *\n * @return {Object} The 'targetTypes' from the 'pasteConfig'\n */export let getTargetTypes=function(){return _pasteConfigMap?_pasteConfigMap:{};};/**\n * @param {Object} targetObject - The 'target' IModelObject to use when determining which 'source' types are\n *            potentially valid to be dropped upon it.\n * @return {Object|null} The 'sourceTypes' property from the 'pasteConfig' for the given 'target' object type or its\n *         ancestor types up the hierarchy (or NULL if no match was found).\n */export let getObjectValidSourceTypes=function(targetObject){if(targetObject&&targetObject.modelType&&targetObject.modelType.typeHierarchyArray||targetObject&&targetObject.typeHierarchy){var typeHier=declUtils.getTypeHierarchy(targetObject);/**\n         * Starting at the 'target' object's actual type, try to find a matching 'targetType' property in the\n         * 'pasteConfig'. If an exact match is not found, try the super type of the 'target' up its hierarchy tree. Stop\n         * looking when the 1st one (i.e. the 'closest' one) is found.\n         */var targetTypes=exports.getTargetTypes();for(var ii=0;ii<typeHier.length;ii++){var typeName=typeHier[ii];if(targetTypes.has(typeName)){return targetTypes.get(typeName).sourceTypes;}}}return null;};/**\n * Get underlying BO for view model objects\n *\n * @param {Array} viewModelObjects - view model objects to adapt\n * @return {input} adapted object\n */export let adaptedInput=function(viewModelObjects){if(viewModelObjects){var objectsToAdapt=_.isArray(viewModelObjects)?viewModelObjects:[viewModelObjects];return adapterSvc.getAdaptedObjectsSync(objectsToAdapt);}return[];};export let loadConfiguration=function(){_pasteConfig=cfgSvc.getCfgCached('paste')||{};updateThePasteConfig();eventBus.subscribe('appCtx.register',changeValidSourceTypesForSelected);eventBus.subscribe('dragDrop.success',function(event){handleSuccess(event.sourceObjects,event.targetObject);});eventBus.subscribe('dragDrop.failure',function(event){createFailureMessageForDND(event.reason);});eventBus.subscribePostal({channel:'paste',topic:'drop',callback:function(eventData){if(eventData&&eventData.pasteInput){_.forEach(eventData.pasteInput,function(pasteInput){var targetObject=pasteInput.targetObject;var relationType=pasteInput.relationType;var sourceObjects=pasteInput.sourceObjects;exports.execute(targetObject,sourceObjects,relationType,{...pasteInput.props,isDragDropIntent:true}).then(function(){var eventData={relatedModified:[targetObject],refreshLocationFlag:false,createdObjects:sourceObjects};eventBus.publish('cdm.relatedModified',eventData);});});}}});};exports={execute,executeWithMultipleRelations,getTargetTypes,getObjectValidSourceTypes,adaptedInput,loadConfiguration,determineActiveHandler};export default exports;loadConfiguration();","map":null,"metadata":{},"sourceType":"module"}