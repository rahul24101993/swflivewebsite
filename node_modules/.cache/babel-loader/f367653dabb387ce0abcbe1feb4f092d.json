{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rahukl57\\\\Desktop\\\\SWF\\\\CreatingOwnComponentUsingJsx\\\\node_modules\\\\@swf\\\\core\\\\src\\\\components\\\\src\\\\js\\\\AwTabContainerService.js\";\nimport _ from 'lodash';\nimport { registerTabSet, unregisterTabSet } from 'js/tabRegistry.service';\nimport tabOverflowSvc from 'js/tabOverflowService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport declUtils from 'js/declUtils';\nimport AwTab from 'viewmodel/AwTabViewModel';\nimport AwButton from 'viewmodel/AwButtonViewModel';\nimport AwTabSetOverflow from 'viewmodel/AwTabSetOverflowViewModel';\nimport AwPopup from 'viewmodel/AwPopupViewModel';\nimport AwStateService from 'js/awStateService';\nimport * as cas from 'js/centralAggregationService';\nimport localeService from 'js/localeService';\nimport analyticsSvc from 'js/analyticsService';\nimport wcagSvc from 'js/wcagService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet tabObserver = null;\nlet currentSelectedTabName;\nlet moreText = '';\nlet lessText = '';\n\nconst initializeObserver = (data, dispatch, tabsetRef) => {\n  if (resizeObserverSvc.supportsResizeObserver()) {\n    const callback = _.debounce(() => {\n      data.overflowConfig.hideMore = !tabOverflowSvc.hasOverflowForTabs(tabsetRef, 'HORIZONTAL');\n      tabOverflowSvc.updateTabIndexOnOverflow(tabsetRef, 'HORIZONTAL');\n      dispatch({\n        path: 'data',\n        value: { ...data\n        }\n      });\n    }, 200, {\n      maxWait: 10000,\n      trailing: true,\n      leading: false\n    });\n\n    if (tabsetRef !== null && tabsetRef !== undefined) {\n      tabObserver = resizeObserverSvc.observe(tabsetRef, callback);\n    }\n  }\n};\n/**\n * Listen to subPanelContext and log user gesture\n *  @param { subPanelContext } selection data from component props\n *  @param { data } viewModel data\n */\n\n\nexport const onSelectionDataChange = (subPanelContext, data) => {\n  logUserGesture(subPanelContext, data);\n};\n/**\n * Collect subject data like parent selection\n * @param {object} subPanelContext from component's props\n * @returns {object}\n */\n\nconst getSubject = subPanelContext => {\n  let subject = {};\n\n  if (!_.isEmpty(subPanelContext)) {\n    let pselected = subPanelContext.pselected ? subPanelContext.pselected : '';\n    let selected = subPanelContext.selected ? subPanelContext.selected : '';\n    subject = {\n      pselected: pselected,\n      selected: selected\n    };\n  }\n\n  return subject;\n};\n/**\n * Collect user gesture and transmit it to Central Aggregation Service\n *  @param { subPanelContext } subPanelContext from component props\n *  @param { data} viewModel data\n */\n\n\nconst logUserGesture = (subPanelContext, data) => {\n  let currentSelectedTabId = '';\n  currentSelectedTabId = data.currentSelectedTabId ? data.currentSelectedTabId : data.tabsModel.findIndex(tab => tab.selectedTab);\n  let widgetInfo = {\n    currentSelectedTabId: currentSelectedTabId,\n    tabSetId: data.tabSetId,\n    tabsModel: data.tabsModel\n  };\n  cas.notify({\n    widgetInfo: widgetInfo,\n    userGesture: 'onTabLoad',\n    subject: getSubject(subPanelContext)\n  });\n};\n/**\n * Method to publish analytics to server\n * @param {Number} tabModelId - id of the clicked tab\n * @param {String} tabModelName - name of the clicked tab\n */\n\n\nconst publishAnalytics = (tabModelId, tabModelName) => {\n  let sanEventData = {\n    sanAnalyticsType: 'Tab',\n    sanCommandId: tabModelId,\n    sanCommandTitle: tabModelName\n  };\n  analyticsSvc.logCommands(sanEventData);\n};\n\nexport const onMount = (elementRefList, prop, data) => {\n  let tabsetRef = elementRefList.get('tabset').current;\n  localeService.getLocalizedTextFromKey('BaseMessages.MORE_LINK_TEXT', true).then(value => moreText = value);\n  localeService.getLocalizedTextFromKey('BaseMessages.LESS_LINK_TEXT', true).then(value => lessText = value);\n  initializeObserver(data, data.dispatch, tabsetRef);\n}; //onUnmount\n\nexport const unRegisterTabSet = tabSetId => {\n  unregisterTabSet(tabSetId);\n\n  if (tabObserver) {\n    tabObserver();\n  }\n};\n\nconst initiateTabSetOverFlow = (overflownTabs, data, dispatch) => {\n  data.overflowConfig.overflownTabs = overflownTabs ? overflownTabs : [];\n  data.overflowConfig.isClicked = true;\n  data.overflowConfig.currentTabIndex = null;\n  data.overflowConfig.replacedTabIndex = null;\n  dispatch({\n    path: 'data',\n    value: { ...data\n    }\n  });\n};\n\nconst updateTabsIndices = (newSelectedTab, data, breakIndex) => {\n  let newSelNdx = newSelectedTab.tabIndex;\n  let temp;\n  temp = data.tabsModel[breakIndex];\n  data.tabsModel[breakIndex] = newSelectedTab;\n  data.tabsModel[newSelNdx] = temp;\n  return breakIndex;\n};\n\nconst isNewSelnFromOverFlowPopup = (index, data) => {\n  if (index >= data.tabsModel.length - data.overflowConfig.overflownTabs.length) {\n    return true;\n  }\n\n  return false;\n};\n\nconst setTabSelection = (data, tabSetOverflowPopup, callback, props) => {\n  let tabToBeSelected = data.tabsModel.find(tab => tab.selectedTab);\n\n  if (!tabToBeSelected && data.currentSelectedTabId) {\n    tabToBeSelected = data.tabsModel.find(tab => tab.pageId === data.currentSelectedTabId);\n  }\n\n  if (!tabToBeSelected || !tabToBeSelected.displayTab) {\n    data.tabsModel.some(tab => {\n      if (tab.displayTab) {\n        tabToBeSelected = tab;\n        return true;\n      }\n\n      return false;\n    });\n  }\n\n  if (tabToBeSelected && (!tabToBeSelected.selectedTab || !data.manualTabSelection && tabToBeSelected.selectedTab && tabToBeSelected.autoSelectTabOnLoad)) {\n    data.tabsModel.map((tabModel, index) => {\n      tabModel.selectedTab = false;\n      tabModel.tabIndex = index;\n    });\n\n    if (isNewSelnFromOverFlowPopup(tabToBeSelected.tabIndex, data)) {\n      updateTabsIndices(tabToBeSelected, data);\n\n      if (tabSetOverflowPopup.open) {\n        tabSetOverflowPopup.hide();\n      }\n    }\n\n    tabToBeSelected.selectedTab = true;\n\n    if (callback && tabToBeSelected.pageId !== data.currentSelectedTabId) {\n      data.currentSelectedTabId = tabToBeSelected.pageId;\n      callback(tabToBeSelected.pageId, tabToBeSelected.name, data.tabsModel);\n    }\n  } // Predictive UI: Notify subscribers when user gestures changes on tab selection/load\n\n\n  if (tabToBeSelected && tabToBeSelected.name !== currentSelectedTabName && data.tabsModel.length > 0) {\n    currentSelectedTabName = tabToBeSelected.name;\n    logUserGesture(props.subPanelContext, data);\n  }\n};\n\nexport const awTabContainerRenderFn = props => {\n  const {\n    actions,\n    viewModel,\n    elementRefList,\n    tabsModel,\n    callback,\n    tabSetId,\n    tabContainerModel\n  } = props;\n  let overflownTabs = [];\n  let {\n    tabSetOverflowPopup\n  } = actions;\n  const {\n    data,\n    dispatch\n  } = viewModel;\n  let tabsetRef = elementRefList.get('tabset').current;\n  const tabsModelForContainer = tabsModel || tabContainerModel;\n  /**\n   * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.\n   *\n   * @method calculateOverflow\n   */\n\n  const calculateTabSwitching = function (initialTabsModel, currentSelectedTab) {\n    var calculateBreakIndex = tabOverflowSvc.calculateBreakIndex();\n    var visibleTabs = data.tabsModel;\n\n    if (visibleTabs.length <= 1) {\n      return;\n    }\n\n    return calculateBreakIndex(initialTabsModel, tabsetRef, currentSelectedTab);\n  }; //swicth tabs here based on local state after overflow item click\n\n\n  let selectedTabModel = tabsModelForContainer.find(tab => tab.selectedTab);\n  let selectedTabIndex = tabsModelForContainer.findIndex(tab => tab.selectedTab); //If we have a selected tab on first render, we need to check if it's in the overflow to make it visible\n\n  let isInitialOverflowCalculation = data.overflowConfig && !data.overflowConfig.currentTabIndex && selectedTabIndex && !data.manualTabSelection;\n\n  if (isInitialOverflowCalculation || data.overflowConfig && data.overflowConfig.currentTabIndex && selectedTabIndex !== data.overflowConfig.replacedTabIndex || !data.manualTabSelection && selectedTabIndex && selectedTabModel && selectedTabIndex > 0 && selectedTabModel.autoSelectTabOnLoad) {\n    var breakTabIndex = calculateTabSwitching(tabsModelForContainer, selectedTabModel);\n\n    if (breakTabIndex) {\n      let temp = tabsModelForContainer[breakTabIndex];\n      tabsModelForContainer[breakTabIndex] = tabsModelForContainer[selectedTabIndex];\n      tabsModelForContainer[selectedTabIndex] = temp;\n    }\n  }\n\n  data.tabsModel = tabsModelForContainer.map(tab => {\n    if (declUtils.isNil(tab.displayTab)) {\n      tab.displayTab = true;\n    }\n\n    return tab;\n  });\n  /**\n   *  Highlight tab in the targeted tab set\n   *  @param {String} tabName the name of tab to be highlighted\n   */\n\n  const onHighlightTab = function (targetTab) {\n    let elementToHighlight;\n\n    if (targetTab && targetTab.displayTab) {\n      let tabContainerDomEl = tabsetRef.querySelectorAll('.sw-tabContainer>.sw-tab');\n      let tabElements = [...tabContainerDomEl];\n      let targetTabElement = tabElements.find(element => element.innerText === targetTab.name);\n      elementToHighlight = targetTabElement.querySelector('a');\n\n      if (elementToHighlight) {\n        wcagSvc.afxFocusElement(elementToHighlight);\n      }\n    } else if (!data.overflowConfig.hideMore) {\n      elementToHighlight = tabsetRef.parentNode.querySelector('.sw-tab-overflowButton.sw-jswidget-controlArrow');\n\n      if (elementToHighlight) {\n        wcagSvc.afxFocusElement(elementToHighlight);\n      }\n    }\n  };\n\n  const onTabSelected = selectedTabModel => {\n    //before change the tab update the params so we can navigate back to previous tab with old params\n    const previousTabIndex = data.tabsModel.findIndex(tab => tab.selectedTab);\n    data.tabsModel[previousTabIndex].params = AwStateService.instance.params;\n    data.previousSelectedTabId = data.tabsModel.find(tab => tab.selectedTab).pageId;\n    data.tabsModel.map(tabModel => tabModel.selectedTab = false);\n    data.currentSelectedTabId = selectedTabModel.pageId;\n    selectedTabModel.selectedTab = true;\n    data.manualTabSelection = true;\n    data.overflowConfig.currentTabIndex = null;\n    data.overflowConfig.replacedTabIndex = null;\n    var breakIndexFromCalc = calculateTabSwitching(data.tabsModel, selectedTabModel);\n\n    if (tabSetOverflowPopup.open && isNewSelnFromOverFlowPopup(selectedTabModel.tabIndex, data)) {\n      let breakIndex = updateTabsIndices(selectedTabModel, data, breakIndexFromCalc);\n      tabSetOverflowPopup.hide();\n      data.overflowConfig.currentTabIndex = selectedTabModel.tabIndex;\n      data.overflowConfig.replacedTabIndex = breakIndex;\n    } // Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.\n\n\n    if (callback && data.previousSelectedTabId !== data.currentSelectedTabId) {\n      callback(selectedTabModel.pageId, selectedTabModel.name, data.tabsModel);\n    }\n\n    publishAnalytics(selectedTabModel.pageId, selectedTabModel.name); //Update the overflow config object in the current view model too.\n    //This is done to cater to the standalone aw-tab-container scenario\n\n    dispatch({\n      path: 'data.overflowConfig',\n      value: { ...data.overflowConfig\n      }\n    });\n  };\n  /**\n   * Recalculate how many tabs can fit in the tab container before overflow occurs.\n   *\n   * @method calculateOverflow\n   */\n\n\n  const calculateOverflow = function () {\n    var overflowBreakPointCalculatorForTabs = tabOverflowSvc.overflowBreakPointCalculatorForTabs();\n    var visibleTabs = data.tabsModel;\n\n    if (visibleTabs.length <= 1) {\n      return;\n    }\n\n    var breakIndex = overflowBreakPointCalculatorForTabs(tabsetRef, 'HORIZONTAL'); // has tab overflow\n\n    if (breakIndex !== visibleTabs.length) {\n      overflownTabs = visibleTabs.slice(breakIndex);\n      initiateTabSetOverFlow(overflownTabs, data, dispatch);\n      tabSetOverflowPopup.show();\n    }\n  };\n\n  const getButtonClassNames = () => {\n    return tabSetOverflowPopup.open ? 'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight' : 'sw-tab-overflowButton sw-jswidget-controlArrow';\n  };\n\n  const showMoreButton = () => {\n    if (!data.overflowConfig.hideMore) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"sw-tab-overflowContainer\",\n        children: [/*#__PURE__*/_jsxDEV(AwButton, {\n          domRef: tabSetOverflowPopup.reference,\n          className: getButtonClassNames(),\n          tooltip: tabSetOverflowPopup.open ? lessText : moreText,\n          \"aria-label\": tabSetOverflowPopup.open ? lessText : moreText,\n          iconId: \"miscSmallChevronRight\",\n          action: calculateOverflow\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 296,\n          columnNumber: 21\n        }, this), tabSetOverflowPopup.open && /*#__PURE__*/_jsxDEV(AwPopup, { ...tabSetOverflowPopup.options,\n          children: /*#__PURE__*/_jsxDEV(AwTabSetOverflow, {\n            overflownTabs: data.overflowConfig.overflownTabs,\n            isClicked: data.overflowConfig.isClicked,\n            event: event,\n            onTabSelected: onTabSelected\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 304,\n            columnNumber: 29\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 303,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 17\n      }, this);\n    }\n  };\n\n  setTabSelection(data, tabSetOverflowPopup, callback, props);\n\n  if (tabSetId) {\n    data.tabSetId = tabSetId;\n    unregisterTabSet(tabSetId);\n    registerTabSet(tabSetId, {\n      changeTab: onTabSelected,\n      tabs: data.tabsModel,\n      highlightTab: onHighlightTab\n    });\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"sw-row align-items-center flex-shrink\",\n    children: [/*#__PURE__*/_jsxDEV(\"ul\", {\n      role: \"tablist\",\n      className: \"sw-tabContainer\",\n      ref: elementRefList.get('tabset'),\n      children: data.tabsModel && data.tabsModel.map((tabModel, index) => {\n        if (tabModel.displayTab) {\n          tabModel.tabIndex = index;\n          return /*#__PURE__*/_jsxDEV(AwTab, {\n            tabModel: tabModel,\n            onTabSelected: onTabSelected,\n            onTabClose: props.onTabClose\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 334,\n            columnNumber: 32\n          }, this);\n        }\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 13\n    }, this), showMoreButton()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 329,\n    columnNumber: 9\n  }, this);\n};","map":{"version":3,"names":["_","registerTabSet","unregisterTabSet","tabOverflowSvc","resizeObserverSvc","declUtils","AwTab","AwButton","AwTabSetOverflow","AwPopup","AwStateService","cas","localeService","analyticsSvc","wcagSvc","tabObserver","currentSelectedTabName","moreText","lessText","initializeObserver","data","dispatch","tabsetRef","supportsResizeObserver","callback","debounce","overflowConfig","hideMore","hasOverflowForTabs","updateTabIndexOnOverflow","path","value","maxWait","trailing","leading","undefined","observe","onSelectionDataChange","subPanelContext","logUserGesture","getSubject","subject","isEmpty","pselected","selected","currentSelectedTabId","tabsModel","findIndex","tab","selectedTab","widgetInfo","tabSetId","notify","userGesture","publishAnalytics","tabModelId","tabModelName","sanEventData","sanAnalyticsType","sanCommandId","sanCommandTitle","logCommands","onMount","elementRefList","prop","get","current","getLocalizedTextFromKey","then","unRegisterTabSet","initiateTabSetOverFlow","overflownTabs","isClicked","currentTabIndex","replacedTabIndex","updateTabsIndices","newSelectedTab","breakIndex","newSelNdx","tabIndex","temp","isNewSelnFromOverFlowPopup","index","length","setTabSelection","tabSetOverflowPopup","props","tabToBeSelected","find","pageId","displayTab","some","manualTabSelection","autoSelectTabOnLoad","map","tabModel","open","hide","name","awTabContainerRenderFn","actions","viewModel","tabContainerModel","tabsModelForContainer","calculateTabSwitching","initialTabsModel","currentSelectedTab","calculateBreakIndex","visibleTabs","selectedTabModel","selectedTabIndex","isInitialOverflowCalculation","breakTabIndex","isNil","onHighlightTab","targetTab","elementToHighlight","tabContainerDomEl","querySelectorAll","tabElements","targetTabElement","element","innerText","querySelector","afxFocusElement","parentNode","onTabSelected","previousTabIndex","params","instance","previousSelectedTabId","breakIndexFromCalc","calculateOverflow","overflowBreakPointCalculatorForTabs","slice","show","getButtonClassNames","showMoreButton","reference","options","event","changeTab","tabs","highlightTab","onTabClose"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/components/src/js/AwTabContainerService.js"],"sourcesContent":["import _ from 'lodash';\nimport { registerTabSet, unregisterTabSet } from 'js/tabRegistry.service';\nimport tabOverflowSvc from 'js/tabOverflowService';\nimport resizeObserverSvc from 'js/resizeObserver.service';\nimport declUtils from 'js/declUtils';\nimport AwTab from 'viewmodel/AwTabViewModel';\nimport AwButton from 'viewmodel/AwButtonViewModel';\nimport AwTabSetOverflow from 'viewmodel/AwTabSetOverflowViewModel';\nimport AwPopup from 'viewmodel/AwPopupViewModel';\nimport AwStateService from 'js/awStateService';\nimport * as cas from 'js/centralAggregationService';\nimport localeService from 'js/localeService';\nimport analyticsSvc from 'js/analyticsService';\nimport wcagSvc from 'js/wcagService';\n\nlet tabObserver = null;\nlet currentSelectedTabName;\nlet moreText = '';\nlet lessText = '';\n\nconst initializeObserver = ( data, dispatch, tabsetRef ) => {\n    if( resizeObserverSvc.supportsResizeObserver() ) {\n        const callback = _.debounce( () => {\n            data.overflowConfig.hideMore = !tabOverflowSvc.hasOverflowForTabs( tabsetRef, 'HORIZONTAL' );\n            tabOverflowSvc.updateTabIndexOnOverflow( tabsetRef, 'HORIZONTAL' );\n            dispatch( { path: 'data', value: { ...data } } );\n        }, 200, {\n            maxWait: 10000,\n            trailing: true,\n            leading: false\n        } );\n        if( tabsetRef !== null && tabsetRef !== undefined ) {\n            tabObserver = resizeObserverSvc.observe( tabsetRef, callback );\n        }\n    }\n};\n/**\n * Listen to subPanelContext and log user gesture\n *  @param { subPanelContext } selection data from component props\n *  @param { data } viewModel data\n */\nexport const onSelectionDataChange = ( subPanelContext, data ) => {\n    logUserGesture( subPanelContext, data );\n};\n\n/**\n * Collect subject data like parent selection\n * @param {object} subPanelContext from component's props\n * @returns {object}\n */\nconst getSubject = subPanelContext => {\n    let subject = {};\n    if( !_.isEmpty( subPanelContext ) ) {\n        let pselected = subPanelContext.pselected ? subPanelContext.pselected : '';\n        let selected = subPanelContext.selected ? subPanelContext.selected : '';\n        subject = { pselected: pselected, selected: selected };\n    }\n    return subject;\n};\n/**\n * Collect user gesture and transmit it to Central Aggregation Service\n *  @param { subPanelContext } subPanelContext from component props\n *  @param { data} viewModel data\n */\nconst logUserGesture = ( subPanelContext, data ) => {\n    let currentSelectedTabId = '';\n    currentSelectedTabId = data.currentSelectedTabId ? data.currentSelectedTabId : data.tabsModel.findIndex( tab => tab.selectedTab );\n    let widgetInfo = { currentSelectedTabId: currentSelectedTabId, tabSetId: data.tabSetId, tabsModel: data.tabsModel };\n    cas.notify( {\n        widgetInfo: widgetInfo,\n        userGesture: 'onTabLoad',\n        subject: getSubject( subPanelContext )\n    } );\n};\n\n/**\n * Method to publish analytics to server\n * @param {Number} tabModelId - id of the clicked tab\n * @param {String} tabModelName - name of the clicked tab\n */\nconst publishAnalytics = ( tabModelId, tabModelName ) => {\n    let sanEventData = {\n        sanAnalyticsType: 'Tab',\n        sanCommandId: tabModelId,\n        sanCommandTitle: tabModelName\n    };\n    analyticsSvc.logCommands( sanEventData );\n};\n\nexport const onMount = ( elementRefList, prop, data ) => {\n    let tabsetRef = elementRefList.get( 'tabset' ).current;\n    localeService.getLocalizedTextFromKey( 'BaseMessages.MORE_LINK_TEXT', true ).then( value => moreText = value );\n    localeService.getLocalizedTextFromKey( 'BaseMessages.LESS_LINK_TEXT', true ).then( value => lessText = value );\n    initializeObserver( data, data.dispatch, tabsetRef );\n};\n\n//onUnmount\nexport const unRegisterTabSet = ( tabSetId ) => {\n    unregisterTabSet( tabSetId );\n    if( tabObserver ) {\n        tabObserver();\n    }\n};\n\nconst initiateTabSetOverFlow = ( overflownTabs, data, dispatch ) => {\n    data.overflowConfig.overflownTabs = overflownTabs ? overflownTabs : [];\n    data.overflowConfig.isClicked = true;\n    data.overflowConfig.currentTabIndex = null;\n    data.overflowConfig.replacedTabIndex = null;\n    dispatch( { path: 'data', value: { ...data } } );\n};\n\nconst updateTabsIndices = ( newSelectedTab, data, breakIndex ) => {\n    let newSelNdx = newSelectedTab.tabIndex;\n    let temp;\n    temp = data.tabsModel[ breakIndex ];\n    data.tabsModel[ breakIndex ] = newSelectedTab;\n    data.tabsModel[ newSelNdx ] = temp;\n\n    return breakIndex;\n};\n\nconst isNewSelnFromOverFlowPopup = ( index, data ) => {\n    if( index >= data.tabsModel.length - data.overflowConfig.overflownTabs.length ) {\n        return true;\n    }\n    return false;\n};\n\nconst setTabSelection = ( data, tabSetOverflowPopup, callback, props ) => {\n    let tabToBeSelected = data.tabsModel.find( tab => tab.selectedTab );\n    if( !tabToBeSelected && data.currentSelectedTabId ) {\n        tabToBeSelected = data.tabsModel.find( tab => tab.pageId === data.currentSelectedTabId );\n    }\n    if( !tabToBeSelected || !tabToBeSelected.displayTab ) {\n        data.tabsModel.some( tab => {\n            if( tab.displayTab ) {\n                tabToBeSelected = tab;\n                return true;\n            }\n            return false;\n        } );\n    }\n\n    if( tabToBeSelected && ( !tabToBeSelected.selectedTab || !data.manualTabSelection && tabToBeSelected.selectedTab && tabToBeSelected.autoSelectTabOnLoad ) ) {\n        data.tabsModel.map( ( tabModel, index ) => {\n            tabModel.selectedTab = false;\n            tabModel.tabIndex = index;\n        } );\n        if( isNewSelnFromOverFlowPopup( tabToBeSelected.tabIndex, data ) ) {\n            updateTabsIndices( tabToBeSelected, data );\n            if( tabSetOverflowPopup.open ) {\n                tabSetOverflowPopup.hide();\n            }\n        }\n        tabToBeSelected.selectedTab = true;\n        if( callback && tabToBeSelected.pageId !== data.currentSelectedTabId ) {\n            data.currentSelectedTabId = tabToBeSelected.pageId;\n            callback( tabToBeSelected.pageId, tabToBeSelected.name, data.tabsModel );\n        }\n    }\n\n    // Predictive UI: Notify subscribers when user gestures changes on tab selection/load\n    if( tabToBeSelected && tabToBeSelected.name !== currentSelectedTabName && data.tabsModel.length > 0 ) {\n        currentSelectedTabName = tabToBeSelected.name;\n        logUserGesture( props.subPanelContext, data );\n    }\n};\n\nexport const awTabContainerRenderFn = ( props ) => {\n    const { actions, viewModel, elementRefList, tabsModel, callback, tabSetId, tabContainerModel } = props;\n    let overflownTabs = [];\n    let { tabSetOverflowPopup } = actions;\n    const { data, dispatch } = viewModel;\n    let tabsetRef = elementRefList.get( 'tabset' ).current;\n    const tabsModelForContainer = tabsModel || tabContainerModel;\n    /**\n     * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.\n     *\n     * @method calculateOverflow\n     */\n    const calculateTabSwitching = function( initialTabsModel, currentSelectedTab ) {\n        var calculateBreakIndex = tabOverflowSvc.calculateBreakIndex();\n        var visibleTabs = data.tabsModel;\n        if( visibleTabs.length <= 1 ) {\n            return;\n        }\n        return calculateBreakIndex( initialTabsModel, tabsetRef, currentSelectedTab );\n    };\n\n    //swicth tabs here based on local state after overflow item click\n    let selectedTabModel = tabsModelForContainer.find( tab => tab.selectedTab );\n    let selectedTabIndex = tabsModelForContainer.findIndex( tab => tab.selectedTab );\n    //If we have a selected tab on first render, we need to check if it's in the overflow to make it visible\n    let isInitialOverflowCalculation = data.overflowConfig && !data.overflowConfig.currentTabIndex && selectedTabIndex && !data.manualTabSelection;\n\n    if( isInitialOverflowCalculation || data.overflowConfig && data.overflowConfig.currentTabIndex && selectedTabIndex !== data.overflowConfig.replacedTabIndex ||\n        !data.manualTabSelection && selectedTabIndex && selectedTabModel && selectedTabIndex > 0 && selectedTabModel.autoSelectTabOnLoad ) {\n        var breakTabIndex = calculateTabSwitching( tabsModelForContainer, selectedTabModel );\n\n        if( breakTabIndex ) {\n            let temp = tabsModelForContainer[ breakTabIndex ];\n            tabsModelForContainer[ breakTabIndex ] = tabsModelForContainer[ selectedTabIndex ];\n            tabsModelForContainer[ selectedTabIndex ] = temp;\n        }\n    }\n\n    data.tabsModel = tabsModelForContainer.map( ( tab ) => {\n        if( declUtils.isNil( tab.displayTab ) ) {\n            tab.displayTab = true;\n        }\n        return tab;\n    } );\n    /**\n     *  Highlight tab in the targeted tab set\n     *  @param {String} tabName the name of tab to be highlighted\n     */\n    const onHighlightTab = function( targetTab ) {\n        let elementToHighlight;\n        if( targetTab && targetTab.displayTab ) {\n            let tabContainerDomEl = tabsetRef.querySelectorAll( '.sw-tabContainer>.sw-tab' );\n            let tabElements = [ ...tabContainerDomEl ];\n            let targetTabElement = tabElements.find( element => element.innerText === targetTab.name );\n            elementToHighlight = targetTabElement.querySelector( 'a' );\n            if( elementToHighlight ) {\n                wcagSvc.afxFocusElement( elementToHighlight );\n            }\n        } else if( !data.overflowConfig.hideMore ) {\n            elementToHighlight = tabsetRef.parentNode.querySelector( '.sw-tab-overflowButton.sw-jswidget-controlArrow' );\n            if( elementToHighlight ) {\n                wcagSvc.afxFocusElement( elementToHighlight );\n            }\n        }\n    };\n\n    const onTabSelected = selectedTabModel => {\n        //before change the tab update the params so we can navigate back to previous tab with old params\n        const previousTabIndex = data.tabsModel.findIndex( tab => tab.selectedTab );\n        data.tabsModel[ previousTabIndex ].params = AwStateService.instance.params;\n\n        data.previousSelectedTabId = data.tabsModel.find( tab => tab.selectedTab ).pageId;\n        data.tabsModel.map( ( tabModel ) => tabModel.selectedTab = false );\n        data.currentSelectedTabId = selectedTabModel.pageId;\n        selectedTabModel.selectedTab = true;\n        data.manualTabSelection = true;\n        data.overflowConfig.currentTabIndex = null;\n        data.overflowConfig.replacedTabIndex = null;\n\n        var breakIndexFromCalc = calculateTabSwitching( data.tabsModel, selectedTabModel );\n\n        if( tabSetOverflowPopup.open && isNewSelnFromOverFlowPopup( selectedTabModel.tabIndex, data ) ) {\n            let breakIndex = updateTabsIndices( selectedTabModel, data, breakIndexFromCalc );\n            tabSetOverflowPopup.hide();\n\n            data.overflowConfig.currentTabIndex = selectedTabModel.tabIndex;\n            data.overflowConfig.replacedTabIndex = breakIndex;\n        }\n        // Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.\n        if( callback && data.previousSelectedTabId !== data.currentSelectedTabId ) {\n            callback( selectedTabModel.pageId, selectedTabModel.name, data.tabsModel );\n        }\n        publishAnalytics( selectedTabModel.pageId, selectedTabModel.name );\n        //Update the overflow config object in the current view model too.\n        //This is done to cater to the standalone aw-tab-container scenario\n        dispatch( { path: 'data.overflowConfig', value: { ...data.overflowConfig } } );\n    };\n\n    /**\n     * Recalculate how many tabs can fit in the tab container before overflow occurs.\n     *\n     * @method calculateOverflow\n     */\n    const calculateOverflow = function() {\n        var overflowBreakPointCalculatorForTabs = tabOverflowSvc.overflowBreakPointCalculatorForTabs();\n        var visibleTabs = data.tabsModel;\n        if( visibleTabs.length <= 1 ) {\n            return;\n        }\n        var breakIndex = overflowBreakPointCalculatorForTabs( tabsetRef, 'HORIZONTAL' );\n        // has tab overflow\n        if( breakIndex !== visibleTabs.length ) {\n            overflownTabs = visibleTabs.slice( breakIndex );\n            initiateTabSetOverFlow( overflownTabs, data, dispatch );\n            tabSetOverflowPopup.show();\n        }\n    };\n\n    const getButtonClassNames = () => {\n        return tabSetOverflowPopup.open ? 'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight' : 'sw-tab-overflowButton sw-jswidget-controlArrow';\n    };\n\n    const showMoreButton = () => {\n        if( !data.overflowConfig.hideMore ) {\n            return (\n                <div className ='sw-tab-overflowContainer'>\n                    <AwButton domRef={tabSetOverflowPopup.reference}\n                        className={getButtonClassNames()}\n                        tooltip={tabSetOverflowPopup.open ? lessText : moreText}\n                        aria-label={tabSetOverflowPopup.open ? lessText : moreText}\n                        iconId='miscSmallChevronRight'\n                        action={calculateOverflow}></AwButton>\n                    { tabSetOverflowPopup.open &&\n                        <AwPopup {...tabSetOverflowPopup.options}>\n                            <AwTabSetOverflow overflownTabs={data.overflowConfig.overflownTabs}\n                                isClicked={data.overflowConfig.isClicked}\n                                event={event}\n                                onTabSelected={onTabSelected}>\n                            </AwTabSetOverflow>\n                        </AwPopup>\n                    }\n                </div>\n            );\n        }\n    };\n\n    setTabSelection( data, tabSetOverflowPopup, callback, props );\n\n    if( tabSetId ) {\n        data.tabSetId = tabSetId;\n        unregisterTabSet( tabSetId );\n        registerTabSet( tabSetId, {\n            changeTab: onTabSelected,\n            tabs: data.tabsModel,\n            highlightTab: onHighlightTab\n        } );\n    }\n\n    return (\n        <div className='sw-row align-items-center flex-shrink' >\n            <ul role='tablist' className='sw-tabContainer' ref={elementRefList.get( 'tabset' )}>\n                { data.tabsModel && data.tabsModel.map( ( tabModel, index ) => {\n                    if( tabModel.displayTab ) {\n                        tabModel.tabIndex = index;\n                        return <AwTab key={index} tabModel={tabModel} onTabSelected={onTabSelected}  onTabClose={props.onTabClose}></AwTab>;\n                    }\n                } )}\n            </ul>\n            {showMoreButton()}\n        </div>\n    );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}