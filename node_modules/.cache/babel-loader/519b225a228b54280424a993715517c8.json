{"ast":null,"code":"// Copyright (c) 2021 Siemens\n\n/**\n * @module js/conditionParser.service\n */\nimport _ from 'lodash';\n/**\n * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.\n */\n\nconst reCTX = /\\bctx\\b/;\nconst reLead = /^[.[]/;\nconst reLeadDot = /^\\./;\nconst reToStrip = /(\\s*(\\(|\\)|===|!==|>|<|>=|<=|\\|\\||&&|}})\\s*|\\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\\()/;\nconst reCC = /(commandContext\\.[a-zA-Z][.\\w]*)(\\W*|$)/g;\nconst reSV = /ctx\\.(visibleServerCommands\\.[a-zA-Z]\\w*)(\\W*|$)/g;\n/**\n * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\nexport const parseStringCondition = expression => {\n  const ctxParameters = [];\n  let m;\n\n  for (const elem of expression.split(reCTX)) {\n    if (reLead.test(elem)) {\n      m = elem.replace(reLeadDot, ''); // split leading dot if any\n\n      m = m.split(reToStrip)[0]; // split on conditions & functions\n\n      m = m.replace(/\"/g, '\\''); // use single quote to work with lodash toPath\n\n      m = m.replace(/\\[\\s*/g, '[').replace(/\\s*\\]/g, ']'); // remove spaces for left & right brackets to support _.toPath\n\n      m = _.toPath(m);\n\n      for (let ndx = 0; ndx < m.length; ndx++) {\n        if (/(:|^\\d+$)/.test(m[ndx]) && ndx > 0) {\n          m.length = ndx;\n          break;\n        }\n      }\n\n      ctxParameters.push(m.join('.'));\n    }\n  }\n\n  const commandContextParameters = parseRegex(reCC, expression);\n  const visibilityParameters = parseRegex(reSV, expression);\n  return {\n    ctxParameters,\n    additionalParameters: [...commandContextParameters, ...visibilityParameters]\n  };\n};\nexport const parseStringConditionWithAdditionalKeys = (expression, additionalKeys) => {\n  let {\n    ctxParameters,\n    additionalParameters\n  } = parseStringCondition(expression);\n\n  for (let key in additionalKeys) {\n    let additionalKeyRegex = new RegExp('(' + additionalKeys[key] + '\\\\.[a-zA-Z][.\\\\w]*)(\\\\W*|$)', 'g');\n    additionalParameters = additionalParameters.concat(parseRegex(additionalKeyRegex, expression));\n  }\n\n  return {\n    ctxParameters,\n    additionalParameters\n  };\n};\n\nconst parseRegex = (regex, expression) => {\n  const params = [];\n  let m = regex.exec(expression);\n\n  while (m) {\n    params.push(m[1]);\n    m = regex.exec(expression);\n  }\n\n  return params;\n};\n/**\n * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\n\nexport const parseObjectCondition = expression => {\n  return [...Object.keys(expression), ...Object.values(expression)].map(parseExpression).reduce(reduceParams, defaultParams);\n};\n\nconst reduceParams = (_ref, nxt) => {\n  let {\n    ctxParameters,\n    additionalParameters\n  } = _ref;\n  return {\n    ctxParameters: [...ctxParameters, ...nxt.ctxParameters],\n    additionalParameters: [...additionalParameters, ...nxt.additionalParameters]\n  };\n};\n\nconst defaultParams = {\n  ctxParameters: [],\n  additionalParameters: []\n};\nexport const parseObjectConditionWithAdditionalKeys = (expression, additionalKeys) => {\n  return [...Object.keys(expression), ...Object.values(expression)].map(expr => parseExpressionWithAdditionalKeys(expr, additionalKeys)).reduce(reduceParams, defaultParams);\n};\n/**\n * Parse the expression of a declarative condition for any ctx dependencies\n *\n * @param {String} expression Condition expression\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\nconst parseExpression = expression => typeof expression === 'string' ? parseStringCondition(expression) : parseObjectCondition(expression);\n\nconst parseExpressionWithAdditionalKeys = (expression, additionalKeys) => typeof expression === 'string' ? parseStringConditionWithAdditionalKeys(expression, additionalKeys) : parseObjectConditionWithAdditionalKeys(expression, additionalKeys);\n/**\n * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {Condition} condition Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\n\n\nexport const parseCondition = (condition, additionalKeys) => {\n  if (!condition || !condition.expression) {\n    return {\n      ctxParameters: [],\n      additionalParameters: []\n    };\n  }\n\n  return additionalKeys ? parseExpressionWithAdditionalKeys(condition.expression, additionalKeys) : parseExpression(condition.expression);\n};","map":{"version":3,"names":["_","reCTX","reLead","reLeadDot","reToStrip","reCC","reSV","parseStringCondition","expression","ctxParameters","m","elem","split","test","replace","toPath","ndx","length","push","join","commandContextParameters","parseRegex","visibilityParameters","additionalParameters","parseStringConditionWithAdditionalKeys","additionalKeys","key","additionalKeyRegex","RegExp","concat","regex","params","exec","parseObjectCondition","Object","keys","values","map","parseExpression","reduce","reduceParams","defaultParams","nxt","parseObjectConditionWithAdditionalKeys","expr","parseExpressionWithAdditionalKeys","parseCondition","condition"],"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/command/src/js/conditionParser.service.js"],"sourcesContent":["// Copyright (c) 2021 Siemens\n\n/**\n * @module js/conditionParser.service\n */\nimport _ from 'lodash';\n\n/**\n * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.\n */\n\nconst reCTX = /\\bctx\\b/;\nconst reLead = /^[.[]/;\nconst reLeadDot = /^\\./;\nconst reToStrip = /(\\s*(\\(|\\)|===|!==|>|<|>=|<=|\\|\\||&&|}})\\s*|\\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\\()/;\nconst reCC = /(commandContext\\.[a-zA-Z][.\\w]*)(\\W*|$)/g;\nconst reSV = /ctx\\.(visibleServerCommands\\.[a-zA-Z]\\w*)(\\W*|$)/g;\n\n/**\n * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseStringCondition = ( expression ) => {\n    const ctxParameters = [];\n    let m;\n    for( const elem of expression.split( reCTX ) ) {\n        if( reLead.test( elem ) ) {\n            m = elem.replace( reLeadDot, '' ); // split leading dot if any\n            m = m.split( reToStrip )[ 0 ]; // split on conditions & functions\n            m = m.replace( /\"/g, '\\'' ); // use single quote to work with lodash toPath\n            m = m.replace( /\\[\\s*/g, '[' ).replace( /\\s*\\]/g, ']' ); // remove spaces for left & right brackets to support _.toPath\n            m = _.toPath( m );\n            for( let ndx = 0; ndx < m.length; ndx++ ) {\n                if( /(:|^\\d+$)/.test( m[ ndx ] ) && ndx > 0 ) {\n                    m.length = ndx;\n                    break;\n                }\n            }\n            ctxParameters.push( m.join( '.' ) );\n        }\n    }\n    const commandContextParameters = parseRegex( reCC, expression );\n    const visibilityParameters = parseRegex( reSV, expression );\n    return {\n        ctxParameters,\n        additionalParameters: [ ...commandContextParameters, ...visibilityParameters ]\n    };\n};\n\nexport const parseStringConditionWithAdditionalKeys = ( expression, additionalKeys ) => {\n    let { ctxParameters, additionalParameters } = parseStringCondition( expression );\n    for( let key in additionalKeys ) {\n        let additionalKeyRegex = new RegExp( '(' + additionalKeys[ key ] + '\\\\.[a-zA-Z][.\\\\w]*)(\\\\W*|$)', 'g' );\n        additionalParameters = additionalParameters.concat( parseRegex( additionalKeyRegex, expression ) );\n    }\n    return { ctxParameters, additionalParameters };\n};\n\nconst parseRegex = ( regex, expression ) => {\n    const params = [];\n    let m = regex.exec( expression );\n    while( m ) {\n        params.push( m[ 1 ] );\n        m = regex.exec( expression );\n    }\n    return params;\n};\n\n/**\n * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseObjectCondition = ( expression ) => {\n    return [ ...Object.keys( expression ), ...Object.values( expression ) ]\n        .map( parseExpression )\n        .reduce( reduceParams, defaultParams );\n};\n\nconst reduceParams = ( { ctxParameters, additionalParameters }, nxt ) => {\n    return {\n        ctxParameters: [ ...ctxParameters, ...nxt.ctxParameters ],\n        additionalParameters: [ ...additionalParameters, ...nxt.additionalParameters ]\n    };\n};\n\nconst defaultParams = {\n    ctxParameters: [],\n    additionalParameters: []\n};\n\nexport const parseObjectConditionWithAdditionalKeys = ( expression, additionalKeys ) => {\n    return [ ...Object.keys( expression ), ...Object.values( expression ) ]\n        .map( ( expr ) => parseExpressionWithAdditionalKeys( expr, additionalKeys ) )\n        .reduce( reduceParams, defaultParams );\n};\n\n/**\n * Parse the expression of a declarative condition for any ctx dependencies\n *\n * @param {String} expression Condition expression\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nconst parseExpression = ( expression ) => typeof expression === 'string' ? parseStringCondition( expression ) : parseObjectCondition( expression );\n\nconst parseExpressionWithAdditionalKeys = ( expression, additionalKeys ) => typeof expression === 'string' ? parseStringConditionWithAdditionalKeys( expression, additionalKeys ) :\n    parseObjectConditionWithAdditionalKeys( expression, additionalKeys );\n\n/**\n * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {Condition} condition Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */\nexport const parseCondition = ( condition, additionalKeys ) => {\n    if( !condition || !condition.expression ) {\n        return {\n            ctxParameters: [],\n            additionalParameters: []\n        };\n    }\n    return additionalKeys ? parseExpressionWithAdditionalKeys( condition.expression, additionalKeys ) : parseExpression( condition.expression );\n};\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA,OAAOA,CAAP,MAAc,QAAd;AAEA;AACA;AACA;;AAEA,MAAMC,KAAK,GAAG,SAAd;AACA,MAAMC,MAAM,GAAG,OAAf;AACA,MAAMC,SAAS,GAAG,KAAlB;AACA,MAAMC,SAAS,GAAG,8HAAlB;AACA,MAAMC,IAAI,GAAG,0CAAb;AACA,MAAMC,IAAI,GAAG,mDAAb;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,oBAAoB,GAAKC,UAAF,IAAkB;EAClD,MAAMC,aAAa,GAAG,EAAtB;EACA,IAAIC,CAAJ;;EACA,KAAK,MAAMC,IAAX,IAAmBH,UAAU,CAACI,KAAX,CAAkBX,KAAlB,CAAnB,EAA+C;IAC3C,IAAIC,MAAM,CAACW,IAAP,CAAaF,IAAb,CAAJ,EAA0B;MACtBD,CAAC,GAAGC,IAAI,CAACG,OAAL,CAAcX,SAAd,EAAyB,EAAzB,CAAJ,CADsB,CACa;;MACnCO,CAAC,GAAGA,CAAC,CAACE,KAAF,CAASR,SAAT,EAAsB,CAAtB,CAAJ,CAFsB,CAES;;MAC/BM,CAAC,GAAGA,CAAC,CAACI,OAAF,CAAW,IAAX,EAAiB,IAAjB,CAAJ,CAHsB,CAGO;;MAC7BJ,CAAC,GAAGA,CAAC,CAACI,OAAF,CAAW,QAAX,EAAqB,GAArB,EAA2BA,OAA3B,CAAoC,QAApC,EAA8C,GAA9C,CAAJ,CAJsB,CAImC;;MACzDJ,CAAC,GAAGV,CAAC,CAACe,MAAF,CAAUL,CAAV,CAAJ;;MACA,KAAK,IAAIM,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGN,CAAC,CAACO,MAA1B,EAAkCD,GAAG,EAArC,EAA0C;QACtC,IAAI,YAAYH,IAAZ,CAAkBH,CAAC,CAAEM,GAAF,CAAnB,KAAgCA,GAAG,GAAG,CAA1C,EAA8C;UAC1CN,CAAC,CAACO,MAAF,GAAWD,GAAX;UACA;QACH;MACJ;;MACDP,aAAa,CAACS,IAAd,CAAoBR,CAAC,CAACS,IAAF,CAAQ,GAAR,CAApB;IACH;EACJ;;EACD,MAAMC,wBAAwB,GAAGC,UAAU,CAAEhB,IAAF,EAAQG,UAAR,CAA3C;EACA,MAAMc,oBAAoB,GAAGD,UAAU,CAAEf,IAAF,EAAQE,UAAR,CAAvC;EACA,OAAO;IACHC,aADG;IAEHc,oBAAoB,EAAE,CAAE,GAAGH,wBAAL,EAA+B,GAAGE,oBAAlC;EAFnB,CAAP;AAIH,CAzBM;AA2BP,OAAO,MAAME,sCAAsC,GAAG,CAAEhB,UAAF,EAAciB,cAAd,KAAkC;EACpF,IAAI;IAAEhB,aAAF;IAAiBc;EAAjB,IAA0ChB,oBAAoB,CAAEC,UAAF,CAAlE;;EACA,KAAK,IAAIkB,GAAT,IAAgBD,cAAhB,EAAiC;IAC7B,IAAIE,kBAAkB,GAAG,IAAIC,MAAJ,CAAY,MAAMH,cAAc,CAAEC,GAAF,CAApB,GAA8B,6BAA1C,EAAyE,GAAzE,CAAzB;IACAH,oBAAoB,GAAGA,oBAAoB,CAACM,MAArB,CAA6BR,UAAU,CAAEM,kBAAF,EAAsBnB,UAAtB,CAAvC,CAAvB;EACH;;EACD,OAAO;IAAEC,aAAF;IAAiBc;EAAjB,CAAP;AACH,CAPM;;AASP,MAAMF,UAAU,GAAG,CAAES,KAAF,EAAStB,UAAT,KAAyB;EACxC,MAAMuB,MAAM,GAAG,EAAf;EACA,IAAIrB,CAAC,GAAGoB,KAAK,CAACE,IAAN,CAAYxB,UAAZ,CAAR;;EACA,OAAOE,CAAP,EAAW;IACPqB,MAAM,CAACb,IAAP,CAAaR,CAAC,CAAE,CAAF,CAAd;IACAA,CAAC,GAAGoB,KAAK,CAACE,IAAN,CAAYxB,UAAZ,CAAJ;EACH;;EACD,OAAOuB,MAAP;AACH,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,oBAAoB,GAAKzB,UAAF,IAAkB;EAClD,OAAO,CAAE,GAAG0B,MAAM,CAACC,IAAP,CAAa3B,UAAb,CAAL,EAAgC,GAAG0B,MAAM,CAACE,MAAP,CAAe5B,UAAf,CAAnC,EACF6B,GADE,CACGC,eADH,EAEFC,MAFE,CAEMC,YAFN,EAEoBC,aAFpB,CAAP;AAGH,CAJM;;AAMP,MAAMD,YAAY,GAAG,OAA2CE,GAA3C,KAAoD;EAAA,IAAlD;IAAEjC,aAAF;IAAiBc;EAAjB,CAAkD;EACrE,OAAO;IACHd,aAAa,EAAE,CAAE,GAAGA,aAAL,EAAoB,GAAGiC,GAAG,CAACjC,aAA3B,CADZ;IAEHc,oBAAoB,EAAE,CAAE,GAAGA,oBAAL,EAA2B,GAAGmB,GAAG,CAACnB,oBAAlC;EAFnB,CAAP;AAIH,CALD;;AAOA,MAAMkB,aAAa,GAAG;EAClBhC,aAAa,EAAE,EADG;EAElBc,oBAAoB,EAAE;AAFJ,CAAtB;AAKA,OAAO,MAAMoB,sCAAsC,GAAG,CAAEnC,UAAF,EAAciB,cAAd,KAAkC;EACpF,OAAO,CAAE,GAAGS,MAAM,CAACC,IAAP,CAAa3B,UAAb,CAAL,EAAgC,GAAG0B,MAAM,CAACE,MAAP,CAAe5B,UAAf,CAAnC,EACF6B,GADE,CACKO,IAAF,IAAYC,iCAAiC,CAAED,IAAF,EAAQnB,cAAR,CADhD,EAEFc,MAFE,CAEMC,YAFN,EAEoBC,aAFpB,CAAP;AAGH,CAJM;AAMP;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMH,eAAe,GAAK9B,UAAF,IAAkB,OAAOA,UAAP,KAAsB,QAAtB,GAAiCD,oBAAoB,CAAEC,UAAF,CAArD,GAAsEyB,oBAAoB,CAAEzB,UAAF,CAApI;;AAEA,MAAMqC,iCAAiC,GAAG,CAAErC,UAAF,EAAciB,cAAd,KAAkC,OAAOjB,UAAP,KAAsB,QAAtB,GAAiCgB,sCAAsC,CAAEhB,UAAF,EAAciB,cAAd,CAAvE,GACxEkB,sCAAsC,CAAEnC,UAAF,EAAciB,cAAd,CAD1C;AAGA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMqB,cAAc,GAAG,CAAEC,SAAF,EAAatB,cAAb,KAAiC;EAC3D,IAAI,CAACsB,SAAD,IAAc,CAACA,SAAS,CAACvC,UAA7B,EAA0C;IACtC,OAAO;MACHC,aAAa,EAAE,EADZ;MAEHc,oBAAoB,EAAE;IAFnB,CAAP;EAIH;;EACD,OAAOE,cAAc,GAAGoB,iCAAiC,CAAEE,SAAS,CAACvC,UAAZ,EAAwBiB,cAAxB,CAApC,GAA+Ea,eAAe,CAAES,SAAS,CAACvC,UAAZ,CAAnH;AACH,CARM"},"metadata":{},"sourceType":"module"}