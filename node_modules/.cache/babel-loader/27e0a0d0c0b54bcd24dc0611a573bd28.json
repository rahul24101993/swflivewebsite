{"ast":null,"code":"// Copyright (c) 2020 Siemens\n\n/**\n * This is the integration logic with the route change events.\n *\n * NOTE - since this is loaded PRIOR to app.initModule() it can't use the typical angular resolution patterns. Needs to\n * be treated as a ES6 only module.\n *\n * @module js/routeChangeHandler\n */\nimport sessionState from 'js/sessionState';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\nimport workspaceValService from 'js/workspaceValidationService';\nimport pageService from 'js/page.service';\nimport postLoginPipeLineSvc from 'js/postLoginPipeline.service';\nimport awConfiguration from 'js/awConfiguration';\nimport eventBus from 'js/eventBus';\nvar exports = {};\n/**\n * state change handler function called when the router is about to transition states. Leverages the\n * authentication state information to determine whether or not to prevent the current route change, and trigger\n * the authentication path.\n *\n * If session state shows already authenticated, allow the transition.\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n * @param {Object} options ui-router navigation options\n */\n\nexport let routeStateChangeStart = function (toState, toParams, fromState, fromParams, options) {\n  // this gets run prior to bootstrap finishing, so there is no angular resolution available.\n  const defer = AwPromiseService.instance.defer();\n\n  if (!sessionState.getIsAuthenticated()) {\n    if (!sessionState.isAuthenticationInProgress()) {\n      // save these for future nav trigger -- NOT SURE about SSO case.\n      var targetNavDetails = {};\n      targetNavDetails.toState = toState;\n      targetNavDetails.toParams = toParams;\n      targetNavDetails.options = options; // the session may be ok, but until we ask the server we don't know.\n      // event.preventDefault();\n\n      defer.reject('routeChangeHandler: prevent State'); // From this point, we can trigger async load behavior since the event has been updated.\n      // check if there is a valid current session, if so continue, otherwise trigger\n      // the authentication path.\n\n      sessionState.performValidSessionCheck(targetNavDetails);\n    } else {\n      // during authInProgress true, Only page that without auth\n      // can be accessed.\n      if (!toState.noAuth) {\n        sessionState.setAuthStatus(false);\n        sessionState.setAuthenticationInProgress(false); // event.preventDefault();\n\n        defer.reject('routeChangeHandler: prevent State'); // stop the auth processing of the current flow, stop the nav request for\n        // this new URL, but trigger a state change to the new target route.\n\n        sessionState.forceNavigation(toState, toParams);\n      }\n    }\n\n    defer.resolve();\n  } else {\n    workspaceValService.isValidPageAsync(toState.name).then(function (changeState) {\n      var defRoutePath = awConfiguration.get('defaultRoutePath'); // If the page being navigated to is not a valid page (i.e. not in the list of available pages for the workspace),\n      // go to the default page. If it is a valid page, we might be here because the user has switched his workspace and the\n      // page user was on is no longer a valid page in the new workspace. So go to the default page.\n\n      if (!changeState || toParams.validateDefaultRoutePath === 'true' && toState.name !== defRoutePath) {\n        // event.preventDefault();\n        defer.reject('routeChangeHandler: prevent State');\n        AwStateService.instance.go(defRoutePath);\n      }\n    });\n    defer.resolve();\n  }\n\n  return defer.promise;\n};\n/**\n * Invoked when the state change was successful from UI router\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n */\n\nexport let routeStateChangeSuccess = function (toState, toParams, fromState, fromParams) {\n  var allStagesAuthenticated = postLoginPipeLineSvc.checkPostLoginAuthenticatedStages();\n\n  if (sessionState && sessionState.getIsAuthenticated()) {\n    if (allStagesAuthenticated) {\n      sessionState.routeStateChangeSuccess(toState, toParams, fromState, fromParams);\n      pageService.navigateToDefaultSubPage(toState, toParams);\n    } else {\n      sessionState.runPostLoginStages();\n    }\n  }\n};\n/**\n * delegates from the route resolution down into the session state ES6 module. This simply wraps the load\n * and call to the session manager.\n *\n * @param {Object} $q - promise Q\n * @return {Promise} promise\n */\n\nexport let pickAuthenticator = function () {\n  return sessionState.pickAuthenticator();\n};\neventBus.subscribe('transitionHooks', _ref => {\n  let {\n    transitionService\n  } = _ref;\n  /**\n   * Replacement of $stateChangeSuccess\n   */\n\n  transitionService.onSuccess({}, function (transition) {\n    exports.routeStateChangeSuccess(transition.to(), transition.params(), transition.from(), transition.params('from'));\n  });\n  /**\n   * Replacement of $stateChangeStart\n   */\n\n  transitionService.onEnter({}, function (transition) {\n    return exports.routeStateChangeStart(transition.to(), transition.params(), transition.from(), transition.params('from'), transition.options());\n  });\n});\nexports = {\n  routeStateChangeStart,\n  routeStateChangeSuccess,\n  pickAuthenticator\n};\nexport default exports;","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/ui/src/js/routeChangeHandler.js"],"names":["exports","routeStateChangeStart","defer","AwPromiseService","sessionState","targetNavDetails","toState","workspaceValService","defRoutePath","awConfiguration","toParams","AwStateService","routeStateChangeSuccess","allStagesAuthenticated","postLoginPipeLineSvc","pageService","pickAuthenticator","eventBus","transitionService","transition"],"mappings":"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","sourcesContent":["// Copyright (c) 2020 Siemens\n\n/**\n * This is the integration logic with the route change events.\n *\n * NOTE - since this is loaded PRIOR to app.initModule() it can't use the typical angular resolution patterns. Needs to\n * be treated as a ES6 only module.\n *\n * @module js/routeChangeHandler\n */\nimport sessionState from 'js/sessionState';\nimport AwPromiseService from 'js/awPromiseService';\nimport AwStateService from 'js/awStateService';\nimport workspaceValService from 'js/workspaceValidationService';\nimport pageService from 'js/page.service';\nimport postLoginPipeLineSvc from 'js/postLoginPipeline.service';\nimport awConfiguration from 'js/awConfiguration';\nimport eventBus from 'js/eventBus';\nvar exports = {};\n\n/**\n * state change handler function called when the router is about to transition states. Leverages the\n * authentication state information to determine whether or not to prevent the current route change, and trigger\n * the authentication path.\n *\n * If session state shows already authenticated, allow the transition.\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n * @param {Object} options ui-router navigation options\n */\nexport let routeStateChangeStart = function( toState, toParams, fromState, fromParams, options ) {\n    // this gets run prior to bootstrap finishing, so there is no angular resolution available.\n    const defer = AwPromiseService.instance.defer();\n    if( !sessionState.getIsAuthenticated() ) {\n        if( !sessionState.isAuthenticationInProgress() ) {\n            // save these for future nav trigger -- NOT SURE about SSO case.\n            var targetNavDetails = {};\n            targetNavDetails.toState = toState;\n            targetNavDetails.toParams = toParams;\n            targetNavDetails.options = options;\n\n            // the session may be ok, but until we ask the server we don't know.\n            // event.preventDefault();\n            defer.reject( 'routeChangeHandler: prevent State' );\n            // From this point, we can trigger async load behavior since the event has been updated.\n\n            // check if there is a valid current session, if so continue, otherwise trigger\n            // the authentication path.\n            sessionState.performValidSessionCheck( targetNavDetails );\n        } else {\n            // during authInProgress true, Only page that without auth\n            // can be accessed.\n            if( !toState.noAuth ) {\n                sessionState.setAuthStatus( false );\n                sessionState.setAuthenticationInProgress( false );\n                // event.preventDefault();\n                defer.reject( 'routeChangeHandler: prevent State' );\n\n                // stop the auth processing of the current flow, stop the nav request for\n                // this new URL, but trigger a state change to the new target route.\n                sessionState.forceNavigation( toState, toParams );\n            }\n        }\n        defer.resolve();\n    } else {\n        workspaceValService.isValidPageAsync( toState.name ).then(\n            function( changeState ) {\n                var defRoutePath = awConfiguration.get( 'defaultRoutePath' );\n                // If the page being navigated to is not a valid page (i.e. not in the list of available pages for the workspace),\n                // go to the default page. If it is a valid page, we might be here because the user has switched his workspace and the\n                // page user was on is no longer a valid page in the new workspace. So go to the default page.\n\n                if( !changeState || toParams.validateDefaultRoutePath === 'true' &&\n                    toState.name !== defRoutePath ) {\n                    // event.preventDefault();\n                    defer.reject( 'routeChangeHandler: prevent State' );\n\n                    AwStateService.instance.go( defRoutePath );\n                }\n            } );\n        defer.resolve();\n    }\n    return defer.promise;\n};\n\n/**\n * Invoked when the state change was successful from UI router\n *\n * @param {Object} toState target state name\n * @param {Object} toParams target state params\n * @param {Object} fromState current state name (if any)\n * @param {Object} fromParams current state params\n */\nexport let routeStateChangeSuccess = function( toState, toParams, fromState, fromParams ) {\n    var allStagesAuthenticated = postLoginPipeLineSvc.checkPostLoginAuthenticatedStages();\n    if( sessionState && sessionState.getIsAuthenticated() ) {\n        if( allStagesAuthenticated ) {\n            sessionState.routeStateChangeSuccess( toState, toParams, fromState, fromParams );\n            pageService.navigateToDefaultSubPage( toState, toParams );\n        } else {\n            sessionState.runPostLoginStages();\n        }\n    }\n};\n\n/**\n * delegates from the route resolution down into the session state ES6 module. This simply wraps the load\n * and call to the session manager.\n *\n * @param {Object} $q - promise Q\n * @return {Promise} promise\n */\nexport let pickAuthenticator = function() {\n    return sessionState.pickAuthenticator();\n};\neventBus.subscribe( 'transitionHooks', ( { transitionService } ) => {\n    /**\n     * Replacement of $stateChangeSuccess\n     */\n    transitionService.onSuccess( {}, function( transition ) {\n        exports.routeStateChangeSuccess( transition.to(), transition.params(), transition.from(), transition.params( 'from' ) );\n    } );\n    /**\n     * Replacement of $stateChangeStart\n     */\n    transitionService.onEnter( {}, function( transition ) {\n        return exports.routeStateChangeStart( transition.to(), transition.params(), transition.from(), transition.params( 'from' ), transition.options() );\n    } );\n} );\n\nexports = {\n    routeStateChangeStart,\n    routeStateChangeSuccess,\n    pickAuthenticator\n};\nexport default exports;\n"]},"metadata":{},"sourceType":"module"}