{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/**\n * @module js/conditionParser.service\n */import _ from'lodash';/**\n * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.\n */const reCTX=/\\bctx\\b/;const reLead=/^[.[]/;const reLeadDot=/^\\./;const reToStrip=/(\\s*(\\(|\\)|===|!==|>|<|>=|<=|\\|\\||&&|}})\\s*|\\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\\()/;const reCC=/(commandContext\\.[a-zA-Z][.\\w]*)(\\W*|$)/g;const reSV=/ctx\\.(visibleServerCommands\\.[a-zA-Z]\\w*)(\\W*|$)/g;/**\n * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */export const parseStringCondition=expression=>{const ctxParameters=[];let m;for(const elem of expression.split(reCTX)){if(reLead.test(elem)){m=elem.replace(reLeadDot,'');// split leading dot if any\nm=m.split(reToStrip)[0];// split on conditions & functions\nm=m.replace(/\"/g,'\\'');// use single quote to work with lodash toPath\nm=m.replace(/\\[\\s*/g,'[').replace(/\\s*\\]/g,']');// remove spaces for left & right brackets to support _.toPath\nm=_.toPath(m);for(let ndx=0;ndx<m.length;ndx++){if(/(:|^\\d+$)/.test(m[ndx])&&ndx>0){m.length=ndx;break;}}ctxParameters.push(m.join('.'));}}const commandContextParameters=parseRegex(reCC,expression);const visibilityParameters=parseRegex(reSV,expression);return{ctxParameters,additionalParameters:[...commandContextParameters,...visibilityParameters]};};export const parseStringConditionWithAdditionalKeys=(expression,additionalKeys)=>{let{ctxParameters,additionalParameters}=parseStringCondition(expression);for(let key in additionalKeys){let additionalKeyRegex=new RegExp('('+additionalKeys[key]+'\\\\.[a-zA-Z][.\\\\w]*)(\\\\W*|$)','g');additionalParameters=additionalParameters.concat(parseRegex(additionalKeyRegex,expression));}return{ctxParameters,additionalParameters};};const parseRegex=(regex,expression)=>{const params=[];let m=regex.exec(expression);while(m){params.push(m[1]);m=regex.exec(expression);}return params;};/**\n * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {String} expression Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */export const parseObjectCondition=expression=>{return[...Object.keys(expression),...Object.values(expression)].map(parseExpression).reduce(reduceParams,defaultParams);};const reduceParams=(_ref,nxt)=>{let{ctxParameters,additionalParameters}=_ref;return{ctxParameters:[...ctxParameters,...nxt.ctxParameters],additionalParameters:[...additionalParameters,...nxt.additionalParameters]};};const defaultParams={ctxParameters:[],additionalParameters:[]};export const parseObjectConditionWithAdditionalKeys=(expression,additionalKeys)=>{return[...Object.keys(expression),...Object.values(expression)].map(expr=>parseExpressionWithAdditionalKeys(expr,additionalKeys)).reduce(reduceParams,defaultParams);};/**\n * Parse the expression of a declarative condition for any ctx dependencies\n *\n * @param {String} expression Condition expression\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */const parseExpression=expression=>typeof expression==='string'?parseStringCondition(expression):parseObjectCondition(expression);const parseExpressionWithAdditionalKeys=(expression,additionalKeys)=>typeof expression==='string'?parseStringConditionWithAdditionalKeys(expression,additionalKeys):parseObjectConditionWithAdditionalKeys(expression,additionalKeys);/**\n * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition\n *\n * @param {Condition} condition Declarative condition to parse\n * @returns {Object} String list of ctx dependencies and additional parameters being checked\n */export const parseCondition=(condition,additionalKeys)=>{if(!condition||!condition.expression){return{ctxParameters:[],additionalParameters:[]};}return additionalKeys?parseExpressionWithAdditionalKeys(condition.expression,additionalKeys):parseExpression(condition.expression);};","map":null,"metadata":{},"sourceType":"module"}