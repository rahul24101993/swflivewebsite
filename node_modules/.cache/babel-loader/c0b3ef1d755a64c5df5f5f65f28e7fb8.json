{"ast":null,"code":"// Copyright (c) 2021 Siemens\n/* eslint-disable complexity */import AwPopup from'viewmodel/AwPopupViewModel';import AwIcon from'viewmodel/AwIconViewModel';import AWLovList from'viewmodel/AwLovListViewModel';import AWPropertyLovChild from'viewmodel/AwPropertyLovChildViewModel';import AwPropertyCheckboxLovChild from'viewmodel/AwPropertyCheckboxLovChildViewModel';import AwTextBoxVal from'viewmodel/AwTextBoxValViewModel';import{getValClass}from'js/componentUtils';import{DOMAPIs as dom}from'js/domUtils';import keyCode from'js/keyCode';import _ from'lodash';import wcagService from'js/wcagService';import AwButton from'viewmodel/AwButtonViewModel';import AwPropertyLabel from'viewmodel/AwPropertyLabelViewModel';import AwPic from'viewmodel/AwPicViewModel';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";const MIN_LENGTH_TO_DISPLAY_FILTER_FOR_EXHAUSTIVE_LOV=5;//Sets totalNumber of objects in dataprovider before filter and lovUsage ( exhaustive/suggestive )\nconst setInitialDataProviderInfo=(dataProvider,initialDataProviderInfo,popupOpen)=>{let initialLength=0;if(dataProvider.viewModelCollection&&dataProvider.viewModelCollection.loadedVMObjects.length>0){initialLength=dataProvider.viewModelCollection.loadedVMObjects.length;}else if(initialLength===0&&dataProvider.vmCollectionObj&&dataProvider.vmCollectionObj.vmCollection&&dataProvider.vmCollectionObj.vmCollection.loadedVMObjects.length>0){initialLength=dataProvider.vmCollectionObj.vmCollection.loadedVMObjects.length;}if(initialDataProviderInfo.current===null&&(initialLength>0||!_.isUndefined(dataProvider.lovUsage))){//Get length of objects on initialload - we cant use totalFound because\n//totalFound changes as we filter and some implementation does not have totalFound populated\nlet initalPrePoulatedDataLen=initialLength>0&&popupOpen===undefined?initialLength:undefined;let initialInfo={initialTotalFound:initialLength,initalPrePoulatedDataLen};if(dataProvider.hasOwnProperty('lovUsage')&&dataProvider.lovUsage==='SUGGESTIVE_LOV'){initialInfo.lovUsage='SUGGESTIVE_LOV';}initialDataProviderInfo.current=initialInfo;}if(initialDataProviderInfo.current&&initialDataProviderInfo.current.initalPrePoulatedDataLen!==undefined&&initialDataProviderInfo.current.initalPrePoulatedDataLen!==initialLength&&initialLength>0){//When popup opens and new initialLength is populated then update initialTotalFound\ndelete initialDataProviderInfo.current.initalPrePoulatedDataLen;initialDataProviderInfo.current.initialTotalFound=initialLength;}};// Gets isSearchable and isSelectOnly flag which is helped to decide LOV UI and behaviors\nconst getSelectOnlyAndSearchableFlags=(prop,initialDataProviderInfo,isCheckBoxArryLOV,hideFilter)=>{// isSelectOnly: true = exhaustive list; false = non-list val can be suggested\nlet isSelectOnly=_.isUndefined(prop.fielddata.isSelectOnly)?true:prop.fielddata.isSelectOnly;if(initialDataProviderInfo.current&&!_.isUndefined(initialDataProviderInfo.current.lovUsage)&&initialDataProviderInfo.current.lovUsage==='SUGGESTIVE_LOV'){isSelectOnly=false;}let initialTotalFound=initialDataProviderInfo.current===null||initialDataProviderInfo.current.initialTotalFound===undefined?0:initialDataProviderInfo.current.initialTotalFound;// Based on PO input, we have to display filter Box if no of values are more than 5\nconst isSearchable=isSelectOnly===false||isCheckBoxArryLOV||isSelectOnly===true&&hideFilter===false?true:initialTotalFound>MIN_LENGTH_TO_DISPLAY_FILTER_FOR_EXHAUSTIVE_LOV;return{isSelectOnly,isSearchable};};const updateInitialDataProviderInfo=initialDataProviderInfo=>{//If initalPrePoulatedDataLen still exists after popup open, we need to delete this as it is no more releavant\n// This can happen if initalPrePoulatedDataLen ===  dataProvider.len when popup is opened\n//If this is not updated then during filter isSearchable flag which depends on dataProvider.len gives false result\nif(initialDataProviderInfo.current&&initialDataProviderInfo.current.initalPrePoulatedDataLen){delete initialDataProviderInfo.current.initalPrePoulatedDataLen;}};/**\n * render function for AwLovVal\n * @param {*} props context for render function interpolation\n * @returns {JSX.Element} react component\n */export const awLovValRenderFunction=props=>{const{actions,fields,elementRefList,autoCorrect,action,viewModel,hideFilter,...prop}=props;const field=prop;const{isListbox}=props;let{data:{blankLovEntry,dirty,_most_recent_entry,parentSelectedHandled},searchBoxLOVFilterStr,dispatch}=viewModel;const selectIndex=elementRefList.get('selectIndex');const checkLovEntries=elementRefList.get('checkLovEntries');const isValidationInProgress=elementRefList.get('isValidationInProgress');const initialDataProviderInfo=elementRefList.get('initialDataProviderInfo');const dynProvider=elementRefList.get('dynDataprovider');let dataProvider=field.fielddata.dataProvider?field.fielddata.dataProvider:dynProvider&&dynProvider.current;let getFilteredEntries=()=>validEntries.current.map(_ref=>{let{propDisplayValue,propInternalValue}=_ref;return{propDisplayValue,propInternalValue};});const hint=prop.fielddata.renderingHint;const typex=prop.typex;const isCheckBoxArryLOV=hint==='checkboxoptionlov';const isArray=prop.fielddata.isArray;if(!dataProvider){return;}//zarq9k: This would be cleaned up when we have the infrastruture to pass ref from viewmodel.\nlet lovEntryRef=dataProvider.getLovEntryRef();setInitialDataProviderInfo(dataProvider,initialDataProviderInfo,actions.lovPopup.open);let{isSelectOnly,isSearchable}=getSelectOnlyAndSearchableFlags(prop,initialDataProviderInfo,isCheckBoxArryLOV,hideFilter);let staticFilterStr=null;let validEntries=elementRefList.get('validEntries');let{lovPopup}=actions;// provide application opportunity to override the size\nlet overridePopupOptions=()=>{let result={width:lovPopup.reference.current.offsetWidth,autoFocus:true};prop.maxHeight&&(result.maxHeight=prop.maxHeight);return result;};let isPropDateTypeAndNonArray=()=>typex&&DATE_TYPES.includes(typex)&&!prop.fielddata.isArray;let isInValidSearchForExhaustiveLOV=()=>!DATE_TYPES.includes(typex)&&selectIndex.current===null&&isSelectOnly===true;let isArrayWithValidateAction=prop.fielddata.isArray&&!_.isEmpty(dataProvider.validateAction)&&!isCheckBoxArryLOV;let isValidationErrorVisible=()=>props.error&&props.error.length>0;const resetFilterStr=()=>{if(lovEntryRef.current&&lovEntryRef.current.lovEntry){lovEntryRef.current.lovEntry.filterString=null;}prop.setLovVal({lovEntry:null},'resetFilterStr');};let hooks={whenOpened:()=>{isValidationInProgress.current=false;searchBoxLOVFilterStr.error=null;},whenClosed:popupRef=>{// TODO: add comment explaining why validate is needed or not needed here\nif((isCheckBoxArryLOV||DATE_TYPES.includes(typex))&&lovEntryRef.current&&lovEntryRef.current.lovEntry){validateLOVEntry(lovEntryRef.current.lovEntry);}resetFilterStr();// reset searchBoxLOVFilterStr\nfields.searchBoxLOVFilterStr&&fields.searchBoxLOVFilterStr.update(null);lovEntryRef.current=null;}};const showPopup=function(){let resetFilter=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;// case1: normal show, we want a reset each time.\n// case2: filter change - onChangeHandler, don't want a reset\nif(resetFilter){resetFilterStr();// save the original, used to recover when esc\nlet recent_entry={propDisplayValue:field.fielddata.uiValue,propInternalValue:prop.value};dispatch({path:'data._most_recent_entry',value:recent_entry});}lovPopup.show({hooks,...overridePopupOptions()});};const storeLatestLOVEntry=lovEntry=>{if(lovEntryRef.current){lovEntryRef.current.lovEntry=lovEntry;}else{lovEntryRef.current={lovEntry};}};// This function would be invoked when some value has been selected from the dropdown popup\nconst setLovEntryAndClose=(receivedLOVEntry,event,op,isAddingTypedValue)=>{storeLatestLOVEntry(receivedLOVEntry);let dateApi=null;if(prop.fielddata.dateApi){dateApi=prop.fielddata.dateApi;}if(dateApi&&dateApi.isDateEnabled&&dateApi.isTimeEnabled&&prop.fielddata.isArray){//If date and time enabled and if its array update only after time is selected\nprop.onTimeSelectedOrEntered(event.target.value||receivedLOVEntry.propInternalValue);lovPopup.hide();}else{receivedLOVEntry.filteredLOVEntries=getFilteredEntries();if(!DATE_TYPES.includes(typex)&&!isCheckBoxArryLOV){op='validateandadd';//For array vaidation is in progress for other it is not\nisValidationInProgress.current=true;}let lovEntry=receivedLOVEntry;if(isAddingTypedValue===true){// If isAddingTypedValue === true means user is adding typed value and not from selected list\n// lovEntry is what user has typed in and not from the list displayed in popup\nlovEntry={...receivedLOVEntry};lovEntry.filterString=searchBoxLOVFilterStr.dbValue;lovEntry.propInternalValue=searchBoxLOVFilterStr.dbValue;lovEntry.propDisplayValue=searchBoxLOVFilterStr.dbValue;}if(lovEntry.filterString===undefined){//After value is added in Array should show correct filter\nlovEntry.filterString=searchBoxLOVFilterStr.dbValue;}prop.setLovVal({lovEntry,dataProvider,checkLovEntries,dateApi},op).then(uiProp=>{isValidationInProgress.current=false;let isErrorEncountered=false;if(!_.isEmpty(uiProp)&&!_.isEmpty(uiProp.error)){isErrorEncountered=true;searchBoxLOVFilterStr.error=uiProp.error;}if(!isErrorEncountered&&!(isCheckBoxArryLOV||isArray===true)){lovPopup.hide();}// record the checked items\n// propInternalValue may in object\nlet key=_.isObject(lovEntry.propInternalValue)?lovEntry.propDisplayValue:lovEntry.propInternalValue;if(op==='checked'){lovEntry.isChecked=true;checkLovEntries.current[key]=lovEntry;}else if(op==='unchecked'){checkLovEntries.current[key].isChecked=false;delete checkLovEntries.current[key];}if(isErrorEncountered){dispatch({path:'data.dirty',value:dirty++});}});}};const validateLOVEntry=lovEntry=>{// This behaviour is only for aw-listbox\".\n// 1, nothing match\nif(autoCorrect){if(validEntries.current.length===0){// reverting back the value if incorrect value has typed in\nconst uiValue=prop.value;lovEntry={propDisplayValue:uiValue,propInternalValue:uiValue};}else if(lovEntryRef.current.lovEntry&&lovEntryRef.current.lovEntry.filterString){// 2, partial match, then take the first\nlovEntry=validEntries.current[0];}storeLatestLOVEntry(lovEntry);prop.setLovVal({lovEntry,dataProvider},null);}else{if(isPropDateTypeAndNonArray()){prop.setLovVal({lovEntry,dataProvider,dateApi:prop.fielddata.dateApi},null);}else{if(isValidationInProgress.current===false){if(isArrayWithValidateAction){lovEntry.filteredLOVEntries=getFilteredEntries();prop.setLovVal({lovEntry,dataProvider},'validateandadd');}else{//There was no validation action hence validate\nprop.setLovVal({lovEntry,dataProvider},'validate');}}}}};/**\n     * onChangeHandler is invoked, when user manually types-in some value in the LOV textbox.\n     * In that case we need to extract the uivalue and store it as filterStr.\n     * This filterStr would later used to pass to the server or in case of static lov's\n     * (lov's without dataprovider action) filter the result locally.\n     * @param {*} event\n     */const onChangeHandler=event=>{if(isCheckBoxArryLOV){prop.onChange(event);}if(event.target){field.fielddata.uiValue=event.target.value;if(!lovPopup.open){showPopup(false);}let lovEntry={propDisplayValue:field.fielddata.uiValue,propInternalValue:field.fielddata.uiValue,filterString:field.fielddata.uiValue,isSearchable};prop.setLovVal({lovEntry,dataProvider},'filter');storeLatestLOVEntry(lovEntry);}};const onFilterChangeHandler=(filter,previous)=>{let lovEntry={propDisplayValue:filter,propInternalValue:filter,filterString:filter,isSearchable};updateInitialDataProviderInfo(initialDataProviderInfo);storeLatestLOVEntry(lovEntry);prop.setLovVal({lovEntry,dataProvider},'filter');};const onBlurHandler=e=>{if(e.target.value===''&&isListbox){storeLatestLOVEntry(_most_recent_entry);}};const isTimeEnteredManually=dateApi=>isPropDateTypeAndNonArray()&&dateApi&&dateApi.isTimeEnabled&&dateApi.timeValue;const keyPressed=(event,isAddingTypedValue)=>{// handle SPACE key\nif(wcagService.getKeyName(event)===keyCode.SPACE&&!lovPopup.open){event.preventDefault();showPopup();return;}let dateApi=prop.fielddata.dateApi;if(event.key===keyCode.ENTER||event.type==='click'){event.preventDefault();if(DATE_TYPES.includes(typex)&&isValidationErrorVisible()&&!props.isListbox){return;}if(lovPopup.open){// if has any hover item\nif(isAddingTypedValue!==true&&selectIndex.current!==null&&validEntries.current&&validEntries.current[selectIndex.current]&&!isTimeEnteredManually(dateApi)){let hoverItem=validEntries.current[selectIndex.current];if(hoverItem.handleSelection){hoverItem.handleSelection(event);event.persist();event.target.value='';return;}}else if(isInValidSearchForExhaustiveLOV()){//For exhaustive LOV, if there is no filtered value and user hits enter,\n// simply close popup\nlovPopup.hide();}else{//Wait for validation to complete before closing popup\n// the current entry\nlet lovEntry=lovEntryRef.current.lovEntry;if(!autoCorrect){// Below line would cause re-rendering automatically\nif(isValidationInProgress.current===false){isValidationInProgress.current=true;lovEntry.filteredLOVEntries=getFilteredEntries();prop.setLovVal({lovEntry,dataProvider,dateApi},'validateandadd').then(uiProp=>{let isErrorEncountered=false;if(!_.isEmpty(uiProp)&&!_.isEmpty(uiProp.error)){isErrorEncountered=true;searchBoxLOVFilterStr.error=uiProp.error;}if(!isErrorEncountered&&!isArray){lovPopup.hide();}isValidationInProgress.current=false;dispatch({path:'data.dirty',value:dirty++});});}event.target.value='';}}}else{showPopup();}}else{evalKey(event);}};const scrollAttention=()=>{let chosenElem=dom.get('.aw-list-itemFocused',lovPopup.options.popupReference.current);chosenElem&&chosenElem.scrollIntoView&&chosenElem.scrollIntoView({block:'center',behavior:'smooth'});};// find the index in the lovEntries array of the value of current attention\nconst getAttnIndex=function(){let lovEntries=validEntries.current;if(lovEntries.length&&lovPopup.open){return lovEntries.map(lovEntry=>lovEntry.attn).indexOf(true);}};const evalKey=function(event){let code=event.key||event.code;// recover _most_recent_entry when esc\nif(code===keyCode.ESCAPE&&lovPopup.open){storeLatestLOVEntry(_most_recent_entry);prop.setLovVal({lovEntry:_most_recent_entry});}if(code===keyCode.TAB&&lovPopup.open){// on tab, accept the current text, don't auto-complete\nif(isSelectOnly===true||lovEntryRef.current===null){//For exhaustive LOVs only hide or if for suggestive user hits tab w/o entering\nlovPopup.hide();}}if(code===keyCode.ARROW_UP||code===keyCode.ARROW_DOWN){event.stopPropagation();event.cancelBubble=true;if(!lovPopup.open){showPopup();return;}var attnIndex=getAttnIndex();if(attnIndex<0){attnIndex=selectIndex.current||_getDefaultAttention();}let lovEntries=validEntries.current;if(code===keyCode.ARROW_DOWN){// down arrow: move the attention down\nif(lovEntries.length>attnIndex+1){lovEntries[attnIndex].attn=false;lovEntries[attnIndex+1].attn=true;selectIndex.current=attnIndex+1;}}else{// up arrow\nif(attnIndex>0){lovEntries[attnIndex].attn=false;lovEntries[attnIndex-1].attn=true;selectIndex.current=attnIndex-1;}}// trigger UI update and scrollAttention\ndispatch({path:'data.dirty',value:dirty++});scrollAttention();}};// syncLovEntries\nconst updateValidEntries=entries=>{validEntries.current=entries||[];};const handleClick=event=>{if(event.key===keyCode.ENTER||event.type==='click'){event.stopPropagation();event.preventDefault();if(!lovPopup.open){showPopup(true);}else{lovPopup.hide();}}};if(prop.parentSelected===undefined&&parentSelectedHandled===true){dispatch({path:'data.parentSelectedHandled',value:undefined});}if(prop.parentSelected&&parentSelectedHandled===undefined){handleClick(event);dispatch({path:'data.parentSelectedHandled',value:true});}let uiValue=field.fielddata.uiValue;let classes=[];let DATE_TYPES=['DATETIME','DATEARRAY','DATE'];classes.push(getValClass(prop));let iconId=null;let timeClassName='';if(prop.fielddata.dateApi&&prop.fielddata.dateApi.isNotLov&&DATE_TYPES.includes(typex)){uiValue=prop.fielddata.dateApi.timeValue;iconId='cmdTime';timeClassName='sw-time-lov-val';}else{iconId='miscSortedDescending';}// If the LOV does not have any dataProvider action, then only we will consider it as client side filtering.\n// This is as per the current afx-master logic.\n// If it is checkboxArray LOV with hint 'checkboxoptionlov', then the data.searchBoxLOVFilterStr.uiValue\n// would be considered as the filterString.\nif(isCheckBoxArryLOV&&fields.searchBoxLOVFilterStr&&fields.searchBoxLOVFilterStr.fielddata){staticFilterStr=fields.searchBoxLOVFilterStr.fielddata.uiValue;}else if(!isCheckBoxArryLOV&&lovEntryRef.current&&lovEntryRef.current.lovEntry){staticFilterStr=lovEntryRef.current.lovEntry.filterString;if(isValidationErrorVisible()&&!prop.isListbox&&!isArrayWithValidateAction){lovEntryRef.current.lovEntry.filterString=null;staticFilterStr=null;}}const renderChildComponent=()=>isCheckBoxArryLOV?/*#__PURE__*/_jsx(AwPropertyCheckboxLovChild,{}):/*#__PURE__*/_jsx(AWPropertyLovChild,{});// listbox don't have the blank entry, hence start  with 0\n// other lovs have a blank entry, hence start with 1\nconst _getDefaultAttention=()=>prop.fielddata.emptyLOVEntry===false?0:1;const getDefaultAttention=()=>{let lovEntries=validEntries.current;let defaultAttnStr=fields.searchBoxLOVFilterStr.dirty==='true'?fields.searchBoxLOVFilterStr.fielddata.uiValue:uiValue;let result=lovEntries.map(item=>item.propDisplayValue).indexOf(defaultAttnStr);return result>-1?result:_getDefaultAttention();};let getErrorLabelProp=()=>{return{...prop,className:'aw-jswidgets-cbaSearch',required:false,displayErrorLabel:false,error:[searchBoxLOVFilterStr.error]};};let addButtonClick=event=>{//Add button is displayed for suggestive LOV only hence when user cliks AddButton, add typed value and not from selected list\nlet isAddingTypedValue=true;keyPressed(event,isAddingTypedValue);};let onButtonBlur=event=>{//Check on Blur if it does not go to input ( previous to add button) element\nif(event.relatedTarget&&event.relatedTarget.tagName!=='INPUT'){lovPopup.hide();}};let onSearchBoxKeyDown=event=>{// if LOV is exhaustive/suggestive, onEnter --> isAddingTypedValue = false\nlet isAddingTypedValue=event.key!==keyCode.ENTER;keyPressed(event,isAddingTypedValue);// enter keyboard mode regardless of key pressed?\n// needed to pass tests atm, discuss with ux\ndocument.body.classList.add('keyboard');};const isAddButtonDisabled=()=>{let isDisabled=_.isEmpty(fields.searchBoxLOVFilterStr.value);let isValidEntry=validEntries.current!==null&&validEntries.current.length>0&&selectIndex.current!==null&&!_.isUndefined(validEntries.current[selectIndex.current].propDisplayValue);if(isValidEntry&&fields.searchBoxLOVFilterStr.value===validEntries.current[selectIndex.current].propDisplayValue){isDisabled=true;}return isDisabled;};const generateContent=()=>{let content=/*#__PURE__*/_jsx(AWLovList,{context:props// syncLovEntries={syncLovEntries}\n,blankLovEntry:blankLovEntry,action:action,lovlist:\"true\",field:field,dataProvider:dataProvider,staticFilterStr:staticFilterStr,updateValidEntries:updateValidEntries,autoCorrect:autoCorrect,lovPopup:lovPopup,isCheckBoxArryLOV:isCheckBoxArryLOV,selectIndex:selectIndex,getDefaultAttention:getDefaultAttention,checkLovEntries:checkLovEntries,setlovEntry:(selLovEntry,event,op)=>{setLovEntryAndClose(selLovEntry,event,op,false);},children:renderChildComponent()});return/*#__PURE__*/_jsxs(\"div\",{className:(isCheckBoxArryLOV?'aw-checkboxarray-lovParent ':'')+'sw-lov-contentContainer',children:[!DATE_TYPES.includes(typex)&&isSearchable&&/*#__PURE__*/_jsxs(\"div\",{className:(_.isEmpty(searchBoxLOVFilterStr.error)?'':'sw-errorFlag ')+'aw-jswidgets-cbaSearch aw-widget-iconParent sw-lov-textbox-container sw-noDirtyStyle',children:[/*#__PURE__*/_jsx(AwTextBoxVal,{...Object.assign({},fields.searchBoxLOVFilterStr,{autocomplete:'off',autocorrect:'off',autocapitalize:'off'}),...generateFilterProps}),isSelectOnly||isCheckBoxArryLOV?/*#__PURE__*/_jsx(AwIcon,{iconId:\"cmdSearch\",className:\"aw-widget-icon\"}):/*#__PURE__*/_jsx(AwButton,{onBlur:onButtonBlur,className:isAddButtonDisabled()?'disabled':'',action:addButtonClick,children:props.i18n.ADD_BUTTON_TITLE})]}),!_.isEmpty(searchBoxLOVFilterStr.error)&&/*#__PURE__*/_jsx(AwPropertyLabel,{...getErrorLabelProp()}),content]});};const hasUserTypedAValue=()=>{return lovEntryRef.current&&lovEntryRef.current.lovEntry&&(lovEntryRef.current.lovEntry.filterString||typeof lovEntryRef.current.lovEntry.propInternalValue==='string');};const getValueIfUserTypedTime=()=>hasUserTypedAValue()?uiValue:'';const generateDateArrayLOVContent=()=>{let{...restGeneratedProps}=generateProps;let dateProps={onClick:handleClick,onChange:onChangeHandler,dirty:prop.dirty,onKeyDown:keyPressed};let allProps={...restGeneratedProps,...dateProps};return isValidationErrorVisible()&&!prop.isListbox?/*#__PURE__*/_jsx(\"input\",{...allProps,value:uiValue}):/*#__PURE__*/_jsx(\"input\",{...allProps,value:field.fielddata.isArray?getValueIfUserTypedTime():uiValue});};// lov select field\nconst generateProps={'aria-label':prop.label,'data-locator':prop.label,'aria-required':prop.isRequired,className:classes.join(' '),onBlur:onBlurHandler,type:'text',placeholder:field.placeholder,ref:lovPopup.reference,dirty:prop.dirty,onClick:handleClick,onKeyDown:keyPressed,disabled:prop.disabled};// lov filter field\n// TODO: i18n on placeholder and use unique label/locator\nconst generateFilterProps={'aria-label':prop.label,'data-locator':prop.label,className:classes.join(' '),onSwChange:onFilterChangeHandler,type:'text',placeholder:isSelectOnly?'Search':'Search or Create',ref:lovPopup.reference,dirty:false,onKeyDown:onSearchBoxKeyDown,disabled:prop.disabled};return/*#__PURE__*/_jsxs(\"div\",{className:\"sw-lov-container\",children:[/*#__PURE__*/_jsx(AwPic,{className:\"sw-lov-thumb\",iconId:field.fielddata.iconName,source:field.fielddata.iconSource}),DATE_TYPES.includes(typex)&&generateDateArrayLOVContent(),!DATE_TYPES.includes(typex)&&/*#__PURE__*/_jsx(\"input\",{...generateProps,value:isArray&&!isCheckBoxArryLOV?null:uiValue}),/*#__PURE__*/_jsx(\"div\",{className:prop.disabled?'sw-widget-iconContainer disabled':'sw-widget-iconContainer',role:\"button\",\"aria-label\":prop.name,tabIndex:\"-1\",onKeyDown:keyPressed,onClick:handleClick,children:/*#__PURE__*/_jsx(AwIcon,{iconId:iconId,className:'aw-widget-icon '+timeClassName})}),/*#__PURE__*/_jsxs(AwPopup,{...lovPopup.options,className:\"sw-lov-popup\",children:[\" \",generateContent()]})]});};export const onMount=(prop,elementRefList)=>{let field=prop.fielddata;const hint=field.renderingHint;const isCheckBoxArryLOV=hint==='checkboxoptionlov';let values=prop.value;if(isCheckBoxArryLOV){let checkLovEntries=elementRefList.get('checkLovEntries');checkLovEntries.current={};if(values&&values.length>0){// we create placeHolders based on the default prop values\n// generate place-holder array for selected values that may or may not be loaded\ncheckLovEntries.current=_.reduce(values,(result,value,inx)=>{let disp=field.uiValues[inx]||field.displayValues[inx]||value;let item={propDisplayValue:disp,propInternalValue:value,isChecked:true};let key=_.isObject(value)?disp:value;result[key]=item;return result;},{});}}};// clear internal states when prop value was cleared\nexport const updateCheckLovEntries=(prop,elementRefList)=>{let field=prop.fielddata;const hint=field.renderingHint;const isCheckBoxArryLOV=hint==='checkboxoptionlov';if(isCheckBoxArryLOV){let checkLovEntries=elementRefList.get('checkLovEntries');let values=prop.value;// clear case\nif(!values||values.length===0){checkLovEntries.current={};}// async set initial values\nif(values.length>0){if(!checkLovEntries.current){checkLovEntries.current={};}let checked=checkLovEntries.current;// update checkLovEntries based on values,\n// case application set the values programly\n_.reduce(values,(result,value,inx)=>{let disp=field.uiValues[inx]||field.displayValues[inx]||value;let key=_.isObject(value)?disp:value;if(!checked[key]){checked[key]={propDisplayValue:disp,propInternalValue:value,isChecked:true};}},{});}}};","map":null,"metadata":{},"sourceType":"module"}