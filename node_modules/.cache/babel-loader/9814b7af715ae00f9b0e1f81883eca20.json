{"ast":null,"code":"/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.\n *\n * @module js/declViewModelProcessingFactory\n *\n * @namespace viewModelProcessingFactory\n */\nimport _ from 'lodash';\nimport viewModelSvc from 'js/viewModelService';\nimport { loadAction, validateLovAction } from 'js/dataProviderFactory';\nimport { processGrids } from 'js/gridProviderUtils';\nimport syncStrategySvc from 'js/syncStrategyService';\nimport { evalDataDefinition, cloneDeepJsonObject } from 'js/declReactUtils';\nimport conditionService from 'js/conditionService';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport { composeDispatch } from 'js/store';\nimport declUtils from 'js/declUtils';\nimport { shouldCreateViewModelProperty, initViewModel } from 'js/viewModelProcessingFactory';\nimport { defineLazyGetter } from 'js/functionalUtility.service';\nimport debugService from 'js/debugService';\nimport dataProviderService from 'js/declDataProviderService';\nimport declDragAndDropService from 'js/declDragAndDropService';\n/**\n * create data instance from data definition\n * @param {JSON} dataDef data section definition\n * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}\n * @param {object} vmDef viewModel template\n * @param {object} subPanelContext subPanelContext\n * @param {object} props props value\n * @returns {object} data object\n */\n\nfunction createData() {\n  let dataDef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let scope = arguments.length > 1 ? arguments[1] : undefined;\n  let vmDef = arguments.length > 2 ? arguments[2] : undefined;\n  let subPanelContext = arguments.length > 3 ? arguments[3] : undefined;\n  let props = arguments.length > 4 ? arguments[4] : undefined;\n  const filteredDataDef = {}; // This would filter out the atomic object from the data.\n\n  const dataKeys = Object.keys(dataDef).filter(keyName => !_.has(dataDef, `${keyName}.meta`));\n  dataKeys.forEach(key => filteredDataDef[key] = dataDef[key]);\n  const data = scope ? evalDataDefinition(filteredDataDef, scope) : cloneDeepJsonObject(filteredDataDef);\n  /**\n   * Recursively initialize the property values of the given JSON data object with the current value of any bound\n   * appContext properties (bound via {{ctx.*}}).\n   */\n\n  initViewModel(data, subPanelContext, props); // Assume all root value witout _ is vmo prop\n\n  for (const prop in data) {\n    if (prop === 'objects') {\n      data[prop] = vmDef[prop];\n      continue;\n    }\n\n    if (prop === 'uid') {\n      vmDef.vmo = vmDef.attachModelObject(data[prop]);\n      continue;\n    }\n\n    if (!shouldCreateViewModelProperty(data[prop])) {\n      continue;\n    }\n\n    let propAttrHolder = declUtils.buildPropHolder(data[prop]);\n    /**\n     * Make sure we have a 'propName' set.\n     */\n\n    if (!data[prop].propName) {\n      data[prop].propName = prop;\n    } // If this is not a view model prop, just save the object to the data.\n\n\n    if (_.isEmpty(propAttrHolder)) {\n      data[prop] = vmDef[prop];\n      continue;\n    }\n\n    if (!prop.startsWith('_') && typeof data[prop] === 'object') {\n      let vmProp = modelPropertySvc.createViewModelProperty(data[prop]);\n\n      if (!declUtils.isNil(data[prop].uiValue)) {\n        vmProp.uiValue = data[prop].uiValue;\n      }\n\n      if (!declUtils.isNil(data[prop].dbValue)) {\n        vmProp.dbValue = data[prop].dbValue;\n      }\n\n      if (dataDef[prop].dataProvider) {\n        // we have an lov, but the api is defined using the dataProvider\n        vmProp.dataProvider = dataDef[prop].dataProvider;\n        vmProp.hasLov = true;\n        vmProp.emptyLOVEntry = dataDef[prop].emptyLOVEntry;\n      }\n\n      data[prop] = vmProp;\n    }\n  } // do init hook her if needed\n  // vmDef.executeHook( 'onInit', props, [ data ], ctxHook );\n\n\n  return data;\n}\n/**\n * create lifecycle hook based on action map\n * @param {Object} lifecycleHookDefs life cycle hook definition\n * @param {Object} actions action map\n * @returns {object} lifecyclehook callback map\n */\n\n\nfunction createLifecycleHooks() {\n  let lifecycleHookDefs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let actions = arguments.length > 1 ? arguments[1] : undefined;\n  let hooksActionsMap = {};\n\n  _.forEach(lifecycleHookDefs, (actionName, hookName) => {\n    // Map onInit hook to onMount - This would not work when we have have both onInit and onMount\n    // defined for a component.onInit would never get a chance to get invoked.\n    //hookName = hookName === 'onInit' ? 'onMount' : hookName;\n    if (Array.isArray(actionName)) {\n      hooksActionsMap[hookName] = [];\n\n      _.forEach(actionName, function (actionObj) {\n        hooksActionsMap[hookName].push(actions[actionObj.action]);\n      });\n    } else {\n      if (!actions[actionName] && typeof Object) {\n        //Is mapped to an object with observer and action.\n        hooksActionsMap[hookName] = actions[actionName.action];\n      } else {\n        hooksActionsMap[hookName] = actions[actionName];\n      }\n    }\n  });\n\n  return hooksActionsMap;\n}\n/**\n * create valiation rule based on property definition\n * @param {JSON} props property definitions\n * @param {JSON} conds condition definitions\n * @returns {object} property validation objects\n */\n\n/**\n * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API\n * @param {JSON} declViewModelJson view model definition\n * @param {object} prop componet prop\n * @returns {object} view model factory\n */\n\n\nexport function createDeclViewModel(declViewModelJson) {\n  let prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    viewId,\n    subPanelContext\n  } = prop;\n  declViewModelJson.data = declViewModelJson.data || {};\n  const vmDef = viewModelSvc.populateViewModelPropertiesFromJson(declViewModelJson, null, null, null, null, subPanelContext);\n\n  if (viewId) {\n    vmDef._internal.viewId = viewId;\n  } // put declViewModelJson to vmDef\n\n\n  vmDef.declViewModelJson = declViewModelJson; // build data creation function\n\n  vmDef.createData = scope => createData(declViewModelJson.data, scope, vmDef, subPanelContext, prop); // create sync strategy ports\n\n\n  vmDef.createPorts = () => {\n    return cloneDeepJsonObject(declViewModelJson.ports);\n  };\n\n  vmDef.createFieldsData = () => {\n    let initialState = {};\n\n    for (const prop in declViewModelJson.data) {\n      if (declViewModelJson.data[prop] && declViewModelJson.data[prop].meta) {\n        initialState[prop] = declViewModelJson.data[prop].initialValues;\n      }\n    }\n\n    return initialState;\n  };\n\n  vmDef.createDataProvider = () => {\n    return vmDef.dataProviders;\n  }; //build LifecycleHooks\n\n\n  vmDef.createLifecycleHooks = actions => createLifecycleHooks(declViewModelJson.lifecycleHooks, actions); // bind drag drop handler  with declViewModal\n\n\n  declDragAndDropService.setupDragAndDropOnView(vmDef);\n  return vmDef;\n}\n\nconst bindActions = function (viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel) {\n  viewModel.actions = _.mapValues(declViewModelJson.actions, actionDef => renderOptions => {\n    let fields = dataCtxNode.getFields(); // #49 - Side effect in example 'Notification Messages'\n\n    Object.assign(dataCtxNode.data, getData());\n    getProps && Object.assign(dataCtxNode, {\n      props: getProps(),\n      getProps\n    });\n    fields && Object.assign(dataCtxNode, {\n      fields\n    });\n\n    if (renderOptions) {\n      //add the parameter here\n      //add the function ref necessary to execute a command action programatically\n      dataCtxNode.parameters = { ...renderOptions,\n        commandActionExecutor: {\n          runActionWithViewModel\n        }\n      };\n    }\n\n    return viewModelSvc.executeCommand(viewModel, actionDef.actionId, dataCtxNode);\n  });\n};\n\nconst bindChartProvider = function (viewModel, vmDef, dataCtxNode) {\n  if (viewModel.chartProviders && !_.isEmpty(viewModel.chartProviders)) {\n    _.mapValues(viewModel.chartProviders, function (chartProvider) {\n      if (chartProvider.loadDataAction) {\n        chartProvider.loadDataActionCallBack = () => {\n          return dataProviderService.executeLoadAction(vmDef.getAction(chartProvider.loadDataAction), {}, dataCtxNode);\n        };\n      }\n\n      if (chartProvider.selectAction) {\n        chartProvider.selectActionCallBack = selectedChartEntity => {\n          if (!dataCtxNode.parameters) {\n            dataCtxNode.parameters = {};\n          }\n\n          dataCtxNode.parameters.selectedChartEntity = { ...selectedChartEntity\n          };\n          return viewModelSvc.executeCommand(viewModel, vmDef.getAction(chartProvider.selectAction).actionId, dataCtxNode);\n        };\n      }\n\n      if (chartProvider.unSelectAction) {\n        chartProvider.unSelectedActionCallBack = unSelectedChartEntity => {\n          if (!dataCtxNode.parameters) {\n            dataCtxNode.parameters = {};\n          }\n\n          dataCtxNode.parameters.unSelectedChartEntity = { ...unSelectedChartEntity\n          };\n          return viewModelSvc.executeCommand(viewModel, vmDef.getAction(chartProvider.unSelectAction).actionId, dataCtxNode);\n        };\n      }\n    });\n  }\n};\n\nconst bindDataProvider = function (viewModel, dataCtxNode, getData, getProps) {\n  _.mapValues(viewModel.dataProviders, dataProvider => dataProvider.loadAction = async (vmCollection, startIndex, pageObject) => {\n    Object.assign(dataCtxNode.data, getData());\n    getProps && Object.assign(dataCtxNode, {\n      props: getProps(),\n      getProps\n    });\n    return loadAction(dataProvider, dataCtxNode, vmCollection, startIndex, pageObject);\n  });\n};\n\nconst bindStaticDataProvider = function (viewModel, dataCtxNode) {\n  _.mapValues(viewModel.dataProviders, dataProvider => dataProvider.validateLovAction = async input => {\n    return validateLovAction(input, dataProvider, dataCtxNode);\n  });\n};\n/**\n * process vmDef, ctx and data to create view model instance\n * @param {object} vmDef view model definition\n * @param {Array} ctxHook react ctx hook in data-dispatch pair\n * @param {Array} dataHook  react data hook in dta-dispatch pair\n * @param {Array} portsHook  react data hook in portsHook pair\n * @param {object} allAtomicData  react dataProviders\n * @param {object} getProps getProps\n * @param {object} runActionWithViewModel callback function\n * @param {object} getFields getFields\n * @returns {object} view model instance\n */\n\n\nexport function processViewModel(vmDef, ctxHook, dataHook, portsHook) {\n  let allAtomicData = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let getProps = arguments.length > 5 ? arguments[5] : undefined;\n  let runActionWithViewModel = arguments.length > 6 ? arguments[6] : undefined;\n  let getFields = arguments.length > 7 ? arguments[7] : undefined;\n  const [ctx, updateCtx] = ctxHook;\n  const props = getProps ? getProps() : {};\n  const [data, updateData, getData] = dataHook;\n  const declViewModelJson = vmDef.declViewModelJson;\n  let dispatchers = {\n    ctx: updateCtx,\n    data: updateData\n  };\n  debugService.debug('lifeCycles', vmDef._internal.panelId, 'init'); // fields data\n\n  let atomicData = {};\n  let updateAtomicData = {};\n  let atomicDataHook = allAtomicData.atomicDataHook ? allAtomicData.atomicDataHook : {};\n  const atomicDataHookKeys = Object.keys(atomicDataHook);\n\n  _.forEach(atomicDataHookKeys, function (stateName) {\n    atomicData[stateName] = atomicDataHook[stateName][0];\n    updateAtomicData[stateName] = allAtomicData.atomicDataRef[stateName].setAtomicData;\n  }); // sync strategy port dispatcher\n\n\n  let ports;\n  let updatePorts;\n\n  if (declViewModelJson.ports && portsHook) {\n    [ports, updatePorts] = portsHook;\n    dispatchers.ports = updatePorts;\n  } // dispatch method\n\n\n  const {\n    dispatch\n  } = composeDispatch(dispatchers);\n  const viewModel = {\n    // store\n    ctx,\n    data,\n    atomicData,\n    updateAtomicData,\n    atomicDataRef: allAtomicData.atomicDataRef,\n    //subPanelContext\n    subPanelContext: props.subPanelContext,\n    // dispatch\n    dispatch,\n    // getData\n    getData,\n    // context for post eval\n    conditions: {},\n    expressions: {},\n    oldExpressions: {},\n    i18n: declViewModelJson.i18n,\n    onEvent: declViewModelJson.onEvent,\n    messages: declViewModelJson.messages,\n    ports: ports\n  }; // revisitme - data (the section in the VM needs to be directly available on the viewModel)\n  // not doing deep copy has side effects. This will be modified depending on the approach\n  // that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.\n\n  _.assign(viewModel, vmDef);\n\n  let dataObj = data; // We need deep copy for data providers.\n\n  if (dataObj && dataObj.dataProviders) {\n    let dataObjDataProviders = dataObj.dataProviders;\n    delete dataObj.dataProviders;\n\n    for (const dpKey in dataObjDataProviders) {\n      if (viewModel.dataProviders && viewModel.dataProviders[dpKey]) {\n        _.assign(viewModel.dataProviders[dpKey], dataObjDataProviders[dpKey]);\n      }\n    }\n  } // Not sure whether other portion of data needs deep copy. So not touching the same.\n\n\n  _.assign(viewModel, dataObj);\n\n  _.assign(viewModel, atomicData);\n\n  let dataCtxNode = {\n    props,\n    data: viewModel,\n    ctx,\n    subPanelContext: props.subPanelContext,\n    ports: viewModel.ports,\n    getProps,\n    getFields\n  }; // conditions\n  //lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it\n  //forEach because closure is needed\n\n  Object.entries(declViewModelJson.conditions || {}).forEach(_ref => {\n    let [key, value] = _ref;\n    defineLazyGetter(viewModel.conditions, key, () => conditionService.evaluateCondition(viewModel, value.expression, dataCtxNode));\n    defineLazyGetter(viewModel.expressions, key, () => [conditionService.parseExpression(viewModel, value.expression, dataCtxNode)]);\n  }); // bind action\n\n  bindActions(viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel); // grids\n\n  const grids = processGrids(vmDef.grids, viewModel, ctxHook[0]); // bind data provider\n\n  bindDataProvider(viewModel, dataCtxNode, getData, getProps); //bind callback for chartsProvider loadActionData\n\n  bindChartProvider(viewModel, vmDef, dataCtxNode); // bind validate action for static dataproviders\n\n  bindStaticDataProvider(viewModel, dataCtxNode); // validation criteria\n  //vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );\n  // Lifecycle Hooks\n\n  viewModel.lifecycleHooks = createLifecycleHooks(declViewModelJson.lifecycleHooks, viewModel.actions); // sync strategy\n\n  if (viewModel.ports && !_.isEmpty(viewModel.ports)) {\n    syncStrategySvc.setupSyncStrategy(dataCtxNode);\n  }\n\n  return {\n    viewModel,\n    grids\n  };\n}","map":{"version":3,"sources":["C:/Users/rahukl57/Desktop/SWF/CreatingOwnComponentUsingJsx/node_modules/@swf/core/src/declreact/src/js/declViewModelProcessingFactory.js"],"names":["dataDef","scope","vmDef","subPanelContext","props","filteredDataDef","dataKeys","Object","keyName","_","key","data","evalDataDefinition","cloneDeepJsonObject","initViewModel","prop","shouldCreateViewModelProperty","propAttrHolder","declUtils","vmProp","modelPropertySvc","lifecycleHookDefs","actions","hooksActionsMap","Array","actionObj","actionName","declViewModelJson","viewModelSvc","createData","initialState","createLifecycleHooks","declDragAndDropService","bindActions","viewModel","actionDef","renderOptions","fields","dataCtxNode","getData","getProps","commandActionExecutor","runActionWithViewModel","bindChartProvider","chartProvider","dataProviderService","selectedChartEntity","unSelectedChartEntity","bindDataProvider","dataProvider","loadAction","bindStaticDataProvider","validateLovAction","allAtomicData","getFields","dispatchers","ctx","updateData","debugService","atomicData","updateAtomicData","atomicDataHook","atomicDataHookKeys","dispatch","composeDispatch","atomicDataRef","conditions","expressions","oldExpressions","i18n","onEvent","messages","ports","dataObj","dataObjDataProviders","defineLazyGetter","conditionService","value","grids","processGrids","ctxHook","syncStrategySvc"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n// Copyright (c) 2020 Siemens\n\n/**\n * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.\n *\n * @module js/declViewModelProcessingFactory\n *\n * @namespace viewModelProcessingFactory\n */\nimport _ from 'lodash';\nimport viewModelSvc from 'js/viewModelService';\nimport { loadAction, validateLovAction } from 'js/dataProviderFactory';\nimport { processGrids } from 'js/gridProviderUtils';\nimport syncStrategySvc from 'js/syncStrategyService';\nimport {\n    evalDataDefinition,\n    cloneDeepJsonObject\n} from 'js/declReactUtils';\n\nimport conditionService from 'js/conditionService';\nimport modelPropertySvc from 'js/modelPropertyService';\nimport { composeDispatch } from 'js/store';\nimport declUtils from 'js/declUtils';\nimport { shouldCreateViewModelProperty, initViewModel } from 'js/viewModelProcessingFactory';\nimport { defineLazyGetter } from 'js/functionalUtility.service';\nimport debugService from 'js/debugService';\nimport dataProviderService from 'js/declDataProviderService';\nimport declDragAndDropService from 'js/declDragAndDropService';\n\n/**\n * create data instance from data definition\n * @param {JSON} dataDef data section definition\n * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}\n * @param {object} vmDef viewModel template\n * @param {object} subPanelContext subPanelContext\n * @param {object} props props value\n * @returns {object} data object\n */\nfunction createData( dataDef = {}, scope, vmDef, subPanelContext, props ) {\n    const filteredDataDef = {};\n    // This would filter out the atomic object from the data.\n    const dataKeys = Object.keys( dataDef ).filter( ( keyName ) => !_.has( dataDef, `${keyName}.meta` ) );\n    dataKeys.forEach( ( key ) => filteredDataDef[ key ] = dataDef[ key ] );\n    const data = scope ? evalDataDefinition( filteredDataDef, scope ) : cloneDeepJsonObject( filteredDataDef );\n\n    /**\n     * Recursively initialize the property values of the given JSON data object with the current value of any bound\n     * appContext properties (bound via {{ctx.*}}).\n     */\n    initViewModel( data, subPanelContext, props );\n\n    // Assume all root value witout _ is vmo prop\n    for( const prop in data ) {\n        if( prop === 'objects' ) {\n            data[ prop ] = vmDef[ prop ];\n            continue;\n        }\n        if( prop === 'uid' ) {\n            vmDef.vmo = vmDef.attachModelObject( data[ prop ] );\n            continue;\n        }\n        if( !shouldCreateViewModelProperty( data[ prop ] ) ) {\n            continue;\n        }\n\n        let propAttrHolder = declUtils.buildPropHolder( data[ prop ] );\n\n        /**\n         * Make sure we have a 'propName' set.\n         */\n        if( !data[ prop ].propName ) {\n            data[ prop ].propName = prop;\n        }\n\n        // If this is not a view model prop, just save the object to the data.\n        if( _.isEmpty( propAttrHolder ) ) {\n            data[ prop ] = vmDef[ prop ];\n            continue;\n        }\n        if( !prop.startsWith( '_' ) && typeof data[ prop ] === 'object' ) {\n            let vmProp = modelPropertySvc.createViewModelProperty( data[ prop ] );\n            if( !declUtils.isNil( data[ prop ].uiValue ) ) {\n                vmProp.uiValue = data[ prop ].uiValue;\n            }\n\n            if( !declUtils.isNil( data[ prop ].dbValue ) ) {\n                vmProp.dbValue = data[ prop ].dbValue;\n            }\n\n            if( dataDef[ prop ].dataProvider ) {\n                // we have an lov, but the api is defined using the dataProvider\n                vmProp.dataProvider = dataDef[ prop ].dataProvider;\n                vmProp.hasLov = true;\n                vmProp.emptyLOVEntry = dataDef[ prop ].emptyLOVEntry;\n            }\n            data[ prop ] = vmProp;\n        }\n    }\n\n    // do init hook her if needed\n    // vmDef.executeHook( 'onInit', props, [ data ], ctxHook );\n    return data;\n}\n\n/**\n * create lifecycle hook based on action map\n * @param {Object} lifecycleHookDefs life cycle hook definition\n * @param {Object} actions action map\n * @returns {object} lifecyclehook callback map\n */\nfunction createLifecycleHooks( lifecycleHookDefs = [], actions ) {\n    let hooksActionsMap = {};\n    _.forEach( lifecycleHookDefs, ( actionName, hookName ) => {\n        // Map onInit hook to onMount - This would not work when we have have both onInit and onMount\n        // defined for a component.onInit would never get a chance to get invoked.\n        //hookName = hookName === 'onInit' ? 'onMount' : hookName;\n        if( Array.isArray( actionName ) ) {\n            hooksActionsMap[ hookName ] = [];\n            _.forEach( actionName, function( actionObj ) {\n                hooksActionsMap[ hookName ].push( actions[ actionObj.action ] );\n            } );\n        } else {\n            if( !actions[ actionName ] && typeof Object ) {\n                //Is mapped to an object with observer and action.\n                hooksActionsMap[ hookName ] = actions[ actionName.action ];\n            } else {\n                hooksActionsMap[ hookName ] = actions[ actionName ];\n            }\n        }\n    } );\n    return hooksActionsMap;\n}\n\n/**\n * create valiation rule based on property definition\n * @param {JSON} props property definitions\n * @param {JSON} conds condition definitions\n * @returns {object} property validation objects\n */\n\n/**\n * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API\n * @param {JSON} declViewModelJson view model definition\n * @param {object} prop componet prop\n * @returns {object} view model factory\n */\nexport function createDeclViewModel( declViewModelJson, prop = {} ) {\n    const { viewId, subPanelContext } = prop;\n    declViewModelJson.data = declViewModelJson.data || {};\n\n    const vmDef = viewModelSvc.populateViewModelPropertiesFromJson( declViewModelJson, null, null, null, null, subPanelContext );\n    if( viewId ) {\n        vmDef._internal.viewId = viewId;\n    }\n    // put declViewModelJson to vmDef\n    vmDef.declViewModelJson = declViewModelJson;\n\n    // build data creation function\n    vmDef.createData = ( scope ) => createData( declViewModelJson.data, scope, vmDef, subPanelContext, prop );\n\n    // create sync strategy ports\n    vmDef.createPorts = () => {\n        return cloneDeepJsonObject( declViewModelJson.ports );\n    };\n\n    vmDef.createFieldsData = () => {\n        let initialState = {};\n        for( const prop in declViewModelJson.data ) {\n            if( declViewModelJson.data[ prop ] && declViewModelJson.data[ prop ].meta ) {\n                initialState[ prop ] = declViewModelJson.data[ prop ].initialValues;\n            }\n        }\n        return initialState;\n    };\n\n    vmDef.createDataProvider = () => {\n        return vmDef.dataProviders;\n    };\n\n    //build LifecycleHooks\n    vmDef.createLifecycleHooks = actions => createLifecycleHooks( declViewModelJson.lifecycleHooks, actions );\n\n    // bind drag drop handler  with declViewModal\n\n    declDragAndDropService.setupDragAndDropOnView( vmDef );\n\n    return vmDef;\n}\n\nconst bindActions = function( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel ) {\n    viewModel.actions = _.mapValues( declViewModelJson.actions, actionDef => ( renderOptions ) => {\n        let fields = dataCtxNode.getFields();\n        // #49 - Side effect in example 'Notification Messages'\n        Object.assign( dataCtxNode.data, getData() );\n        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );\n        fields && Object.assign( dataCtxNode, { fields } );\n\n        if( renderOptions ) {\n            //add the parameter here\n            //add the function ref necessary to execute a command action programatically\n            dataCtxNode.parameters = { ...renderOptions, commandActionExecutor: { runActionWithViewModel } };\n        }\n        return viewModelSvc.executeCommand( viewModel, actionDef.actionId, dataCtxNode );\n    } );\n};\n\nconst bindChartProvider = function( viewModel, vmDef, dataCtxNode ) {\n    if( viewModel.chartProviders && !_.isEmpty( viewModel.chartProviders ) ) {\n        _.mapValues( viewModel.chartProviders, function( chartProvider ) {\n            if( chartProvider.loadDataAction ) {\n                chartProvider.loadDataActionCallBack = () => {\n                    return dataProviderService.executeLoadAction( vmDef.getAction( chartProvider.loadDataAction ), {}, dataCtxNode );\n                };\n            }\n            if( chartProvider.selectAction ) {\n                chartProvider.selectActionCallBack = ( selectedChartEntity ) => {\n                    if( !dataCtxNode.parameters ) {\n                        dataCtxNode.parameters = {};\n                    }\n                    dataCtxNode.parameters.selectedChartEntity = { ...selectedChartEntity };\n                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.selectAction ).actionId, dataCtxNode );\n                };\n            }\n            if( chartProvider.unSelectAction ) {\n                chartProvider.unSelectedActionCallBack = ( unSelectedChartEntity ) => {\n                    if( !dataCtxNode.parameters ) {\n                        dataCtxNode.parameters = {};\n                    }\n                    dataCtxNode.parameters.unSelectedChartEntity = { ...unSelectedChartEntity };\n                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.unSelectAction ).actionId, dataCtxNode );\n                };\n            }\n        } );\n    }\n};\n\nconst bindDataProvider = function( viewModel, dataCtxNode, getData, getProps ) {\n    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.loadAction = async( vmCollection, startIndex, pageObject ) => {\n        Object.assign( dataCtxNode.data, getData() );\n        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );\n        return loadAction( dataProvider, dataCtxNode, vmCollection, startIndex, pageObject );\n    } );\n};\n\nconst bindStaticDataProvider = function( viewModel, dataCtxNode ) {\n    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.validateLovAction = async( input ) => {\n        return validateLovAction( input, dataProvider, dataCtxNode );\n    } );\n};\n\n/**\n * process vmDef, ctx and data to create view model instance\n * @param {object} vmDef view model definition\n * @param {Array} ctxHook react ctx hook in data-dispatch pair\n * @param {Array} dataHook  react data hook in dta-dispatch pair\n * @param {Array} portsHook  react data hook in portsHook pair\n * @param {object} allAtomicData  react dataProviders\n * @param {object} getProps getProps\n * @param {object} runActionWithViewModel callback function\n * @param {object} getFields getFields\n * @returns {object} view model instance\n */\nexport function processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData = {}, getProps, runActionWithViewModel, getFields ) {\n    const [ ctx, updateCtx ] = ctxHook;\n    const props = getProps ? getProps() : {};\n\n    const [ data, updateData, getData ] = dataHook;\n    const declViewModelJson = vmDef.declViewModelJson;\n    let dispatchers = { ctx: updateCtx, data: updateData };\n\n    debugService.debug( 'lifeCycles', vmDef._internal.panelId, 'init' );\n\n    // fields data\n    let atomicData = {};\n    let updateAtomicData = {};\n    let atomicDataHook = allAtomicData.atomicDataHook ? allAtomicData.atomicDataHook : {};\n\n    const atomicDataHookKeys = Object.keys( atomicDataHook );\n    _.forEach( atomicDataHookKeys, function( stateName ) {\n        atomicData[ stateName ] = atomicDataHook[ stateName ][ 0 ];\n        updateAtomicData[ stateName ] = allAtomicData.atomicDataRef[ stateName ].setAtomicData;\n    } );\n\n    // sync strategy port dispatcher\n    let ports;\n    let updatePorts;\n    if( declViewModelJson.ports && portsHook ) {\n        [ ports, updatePorts ] = portsHook;\n        dispatchers.ports = updatePorts;\n    }\n    // dispatch method\n    const { dispatch } = composeDispatch( dispatchers );\n\n    const viewModel = {\n        // store\n        ctx,\n        data,\n        atomicData,\n        updateAtomicData,\n        atomicDataRef: allAtomicData.atomicDataRef,\n        //subPanelContext\n        subPanelContext: props.subPanelContext,\n\n        // dispatch\n        dispatch,\n\n        // getData\n        getData,\n\n        // context for post eval\n        conditions: {},\n        expressions: {},\n        oldExpressions: {},\n        i18n: declViewModelJson.i18n,\n        onEvent: declViewModelJson.onEvent,\n        messages: declViewModelJson.messages,\n        ports: ports\n    };\n\n    // revisitme - data (the section in the VM needs to be directly available on the viewModel)\n    // not doing deep copy has side effects. This will be modified depending on the approach\n    // that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.\n    _.assign( viewModel, vmDef );\n    let dataObj = data;\n\n    // We need deep copy for data providers.\n    if( dataObj && dataObj.dataProviders ) {\n        let dataObjDataProviders = dataObj.dataProviders;\n        delete dataObj.dataProviders;\n        for( const dpKey in dataObjDataProviders ) {\n            if( viewModel.dataProviders && viewModel.dataProviders[ dpKey ] ) {\n                _.assign( viewModel.dataProviders[ dpKey ], dataObjDataProviders[ dpKey ] );\n            }\n        }\n    }\n\n    // Not sure whether other portion of data needs deep copy. So not touching the same.\n    _.assign( viewModel, dataObj );\n    _.assign( viewModel, atomicData );\n    let dataCtxNode = {\n        props,\n        data: viewModel,\n        ctx,\n        subPanelContext: props.subPanelContext,\n        ports: viewModel.ports,\n        getProps,\n        getFields\n    };\n\n    // conditions\n    //lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it\n    //forEach because closure is needed\n    Object.entries( declViewModelJson.conditions || {} ).forEach( ( [ key, value ] ) => {\n        defineLazyGetter( viewModel.conditions, key, () => conditionService.evaluateCondition( viewModel, value.expression, dataCtxNode ) );\n        defineLazyGetter( viewModel.expressions, key, () => [ conditionService.parseExpression( viewModel, value.expression, dataCtxNode ) ] );\n    } );\n\n    // bind action\n    bindActions( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel );\n\n    // grids\n    const grids = processGrids( vmDef.grids, viewModel, ctxHook[ 0 ] );\n\n    // bind data provider\n    bindDataProvider( viewModel, dataCtxNode, getData, getProps );\n\n    //bind callback for chartsProvider loadActionData\n    bindChartProvider( viewModel, vmDef, dataCtxNode );\n\n    // bind validate action for static dataproviders\n    bindStaticDataProvider( viewModel, dataCtxNode );\n\n    // validation criteria\n    //vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );\n\n    // Lifecycle Hooks\n    viewModel.lifecycleHooks = createLifecycleHooks( declViewModelJson.lifecycleHooks, viewModel.actions );\n\n    // sync strategy\n    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {\n        syncStrategySvc.setupSyncStrategy( dataCtxNode );\n    }\n    return {\n        viewModel,\n        grids\n    };\n}\n"]},"metadata":{},"sourceType":"module"}