// Copyright (c) 2022 Siemens
/* eslint-disable complexity */
/* eslint-env node */

const { basename, join, normalize, resolve } = require( 'path' );
const _ = require( 'lodash' );
const fs = require( 'fs' );
const { copyFileSync, ensureDirSync, pathExistsSync, readFileSync, writeFileSync, readJSONSync, writeJSONSync } = require( 'fs-extra' );
const webpack = require( 'webpack' );
const CopyPlugin = require( 'copy-webpack-plugin' );
const MonacoWebpackPlugin = require( 'monaco-editor-webpack-plugin' );
const { getBabelLoader, addBabelPlugin, addBundleVisualizer, disableEsLint } = require( 'customize-cra' );
const AliasResolvePlugin = require( '@swf/tooling/rewired/AliasResolvePlugin' );
const PostBuildPlugin = require( '@swf/tooling/rewired/PostBuildPlugin' );
const logger = require( '@swf/tooling/js/logger' );
const webpackDevClientEntry = require.resolve( 'react-dev-utils/webpackHotDevClient' );
const ReactRefreshPlugin = require( '@pmmmwh/react-refresh-webpack-plugin' );
const {
    normalizePath,
    getKitCache,
    getModuleCache,
    getEffectiveKits,
    getEffectiveModules,
    findWebpackPlugin,
    findBaseKits,
    getSelectedSite,
    getResolvedSourcePaths,
    getBuildJson,
    getBuildPathCache,
    getEffectiveBootstrapCache,
    getAliasMap,
    customizeSassLoader,
    getEntryHtmlInfo,
    removeES5BabelLoader,
    addExcludeFileTypeToFileLoader,
    createTestDirs,
    getChunkName
} = require( '@swf/tooling/rewired/utils' );

// performance
const { initializePerfMonitor, Stopwatch } = require( '@swf/tooling/rewired/perfUtils' );
const swfJestResolver = require( '@swf/tooling/rewired/jestResolver' );
const stopwatchTotal = new Stopwatch( 'Total' );

const MSG_PREFIX = `${basename( __filename, '.js' )}: `;
const nodeModulePath = normalizePath( join( process.cwd(), 'node_modules/@swf/core' ) ); // FIXME resolve path from node_modules

let _paths;

module.exports = {
    webpack: config => {
        const stopwatch = new logger.Stopwatch();

        if( !config.output ) { config.output = {}; }
        config.output.publicPath = './';
        config.devtool = config.mode === 'development' ? 'cheap-module-eval-source-map' : config.devtool;
        const siteInfo = getSelectedSite();
        logger.info( `Building site: ${siteInfo.content.name}` );
        // TODO list out included kits in this build
        const kitCache = getKitCache();
        const baseKits = findBaseKits( kitCache );
        const effectiveKits = _.uniq( getEffectiveKits( kitCache, baseKits ).sort() );
        logger.info( `  Included kits:\n\t${effectiveKits.join( '\n\t' )}` );

        ensureDirSync( _paths.appPublic );

        // Monaco editor webpack plugin
        config.plugins.push( new MonacoWebpackPlugin( { languages: [ 'html', 'json', 'javascript', 'typescript' ] } ) );

        //Remove HotModuleReplacementPlugin since we're using ReactRefreshPlugin
        _.remove( config.plugins, plugin => /^(HotModuleReplacementPlugin)$/.test( plugin.constructor.name ) );
        _.remove( config.plugins, plugin => /^(ESLintWebpackPlugin)$/.test( plugin.constructor.name ) );
        // Remove Ignore Plugin as we aren't using it
        _.remove( config.plugins, plugin => /^(IgnorePlugin)$/.test( plugin.constructor.name ) );

        // Remove expensive "case-sensitive-paths-webpack-plugin" for performance improvement
        if( config.mode !== 'production' || process.env.CI !== 'true' ) {
            _.remove( config.plugins, plugin => plugin.constructor.name === 'CaseSensitivePathsPlugin' );
        }

        if( config.mode !== 'production' ) {
            //Support legacy FAST_REFRESH
            //Though react-scripts docs say FAST_REFRESH is disabled by default, it is not.
            //So the OOTB config and config added by us is causing problems.
            //We need to remove ootb config and then add our config.
            //Step 1: Remove internal react-refresh plugin
            _.remove( config.plugins, plugin => /^(ReactRefreshPlugin)$/.test( plugin.constructor.name ) );
            //Step 2: Remove internal react-refresh/babel plugin
            _.remove( getBabelLoader( config ).options.plugins, plugin => /react-refresh[\\/]babel/.test( plugin ) );
            config.entry = [ webpackDevClientEntry, config.entry ];
            config = addBabelPlugin( require.resolve( 'react-refresh/babel' ) )( config );
            const reactRefreshPlugin = new ReactRefreshPlugin();
            reactRefreshPlugin.options.include = /(\.([jt]sx?|flow)|ViewModel\.json)$/;
            config.plugins.push( reactRefreshPlugin );
        }

        // Create separate bundles for already minified files from splitChunks
        // Exclude these bundles for minify which is already minified
        // These process is for prod build (npm run build)
        if( config.mode === 'production' ) {
            const terserWebpackPlugin = findWebpackPlugin( config.optimization.minimizer, 'TerserPlugin' );
            terserWebpackPlugin.options.exclude = /\.min\.\S+\.chunk\.js$/;
            /**
             * Below code removes Sourcemaps by default in production build.
             * One needs to explicitely set GENERATE_SOURCEMAP=true in order to get
             * sourcemaps in production build.
             */
            const shouldUseSourceMap = process.env.GENERATE_SOURCEMAP;
            if( shouldUseSourceMap !== 'true' ) {
                terserWebpackPlugin.options.sourceMap = false;
                config.devtool = false;
                const optimizeCSSPlugin = findWebpackPlugin( config.optimization.minimizer, 'OptimizeCssAssetsWebpackPlugin' );
                if( optimizeCSSPlugin ) {
                    optimizeCSSPlugin.options.cssProcessorOptions = false;
                }
            }
        }

        // disable Eslint so that import react errors do not block the start
        //later we can condifure this just to skip the react import rule.
        config = disableEsLint()( config );

        // Remove Babel-loader for ES5 transpilation of 3rd party library files in node_modules
        config = removeES5BabelLoader( config );

        // borrow babel loader
        const defaultBabelLoader = getBabelLoader( config );
        const babelLoader = {
            loader: 'babel-loader',
            options: defaultBabelLoader.options
        };

        // overwrite css
        // https://github.com/facebook/create-react-app/blob/e2585329bc8411bb0bb8fad68fcea77c73b7248a/packages/react-scripts/config/webpack.config.js

        // alias plugin
        const buildJson = getBuildJson();
        config.resolve.plugins.push( new AliasResolvePlugin( { srcPaths: buildJson.srcPaths, solutionName: buildJson.solutionName } ) );

        // override default js rule in CRA since it doesn't handle jsx for non-src folder
        const buildPaths = getBuildPathCache();
        const nodeModuleAbsPath = normalizePath( resolve( join( process.cwd(), 'node_modules/@swf' ) ) );
        const ruleIncludes = [];
        for( let buildPath in buildPaths ) {
            if( !/\btest\b/.test( buildPath ) && pathExistsSync( buildPath ) ) {
                if( buildPath.startsWith( nodeModuleAbsPath ) ) {
                    buildPath = buildPath.replace( nodeModuleAbsPath, '' );

                    config.module.rules.push( {
                        test: new RegExp( `${buildPath.replace( /\//g, '[\\\\/]' )}[\\\\/].*\\.js$` ),
                        exclude: /(t|T)est\.js$/,
                        use: babelLoader
                    } );
                } else {
                    buildPath = buildPath.replace( process.cwd().replace( /\\/g, '/' ), '' );
                }
                ruleIncludes.push( new RegExp( buildPath.replace( /\//g, '[\\\\/]' ) ) );
            }
        }

        // support for any import 'js/xxx'
        config.module.rules.push( {
            test: /js[\\/]\S+\.js$/,
            exclude: /(t|T)est\.js$/,
            use: babelLoader
        } );

        //Support for nodeTemplates html import
        config.module.rules.push( {
            test: /[\\/]nodeTemplates[\\/]\S+\.html$/,
            use: { loader: require.resolve( 'raw-loader' ) }
        } );

        //Add Wasm Support

        //Step 1: Add wasmRegex to OOTB file-loader
        const wasmRegex = /\.wasm$/;
        config = addExcludeFileTypeToFileLoader( config, wasmRegex );
        //Step 2: Add new entry for wasm loader
        config.module.rules.push( {
            test: wasmRegex,
            type: 'javascript/auto',
            use: require.resolve( 'file-loader' )
        } );

        config = addExcludeFileTypeToFileLoader( config, /\.svg$/ );
        config.module.rules.push( {
            test: /\.svg$/,
            issuer: /(\.scss|\.css)$/,
            use: [ {
                loader: require.resolve( 'file-loader' ),
                options: {
                    name: 'static/media/[name].[hash:8].[ext]'
                }
            } ]
        } );
        config.module.rules.push( {
            test: /\.svg$/,
            issuer: /\.(?!(css|scss)).*$/,
            use: [ babelLoader,
                {
                    loader: require.resolve( 'cache-loader' )
                },
                {
                    loader: require.resolve( '@swf/tooling/rewired/imagesLoader2' )
                }
            ]
        } );

        config.module.rules.push( {
            test: /\bsoaService\b.js$/,
            use: [ babelLoader,
                {
                    loader: require.resolve( 'cache-loader' )
                },
                {
                    loader: require.resolve( '@swf/tooling/rewired/soaServiceLoader' )
                }
            ]
        } );

        // CRA has a wrapper node_modules/react-dev-utils/chalk.js which will confuse the webpack
        // any npm i potential package hoist may break some assumption will cause error
        const chalkPath = resolve( join( process.cwd(), 'node_modules/chalk' ) );
        if( pathExistsSync( chalkPath ) ) {
            config.resolve.alias.chalk = chalkPath;
        }

        //If there are multiple copies are react then, linking @swf/core with other application cuases issues in highcharts
        //https://github.com/facebook/react/issues/15315
        if( pathExistsSync( nodeModulePath ) ) {
            const stats = fs.lstatSync( nodeModulePath );
            const isSymLink = stats.isSymbolicLink();
            if( isSymLink ) {
                config.resolve.alias.react = resolve( join( process.cwd(), 'node_modules/react' ) );
            }
        }

        const bootstrapJsonCache = getEffectiveBootstrapCache();
        if( bootstrapJsonCache && bootstrapJsonCache.config && bootstrapJsonCache.config.provides ) {
            config.plugins.push( new webpack.ProvidePlugin( bootstrapJsonCache.config.provides ) );
        }
        // hijack config.module.rules
        if( config.module && config.module.rules ) {
            // viewmodel/xxxxViewModel.json
            config.module.rules.push( {
                test: /[\\/]viewmodel[\\/]\S+ViewModel\.json$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: [ babelLoader,
                    {
                        loader: require.resolve( 'cache-loader' )
                    },
                    {
                        loader: require.resolve( '@swf/tooling/rewired/declLoader' )
                    }
                ]
            } );

            // 'config/xxx' import support
            config.module.rules.push( {
                test: /[\\/]js[\\/]configEntry.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/configImportLoader' ) }
            } );

            // viewModelLoaderService.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]viewModelLoaderService.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/viewModelLoaderSvcLoader' ) }
            } );

            // bootstrap.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]bootstrap.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/bootstrapLoader.js' ) }
            } );

            // schema.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]schema.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/schemaLoader' ) }
            } );

            // moduleLoader.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]moduleLoader.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/moduleLoaderLoader' ) }
            } );

            // propertyPolicyLoaderService.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]propertyPolicyLoaderService.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/propertyPolicyLoaderSvcLoader' ) }
            } );

            // installedLocales.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]installedLocales.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/installedLocalesLoader' ) }
            } );

            // configurationService.js
            config.module.rules.push( {
                test: /[\\/]js[\\/]configurationService\.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/configSvcLoader' ) }
            } );

            config.module.rules.push( {
                test: /[\\/]js[\\/]componentRegistry\.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/componentRegistryLoader' ) }
            } );

            config.module.rules.push( {
                test: /[\\/]js[\\/]imageRegistry\.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/imageRegistryLoader' ) }
            } );

            config.module.rules.push( {
                test: /[\\/]js[\\/]typeIconRegistry\.js$/,
                include: ruleIncludes,
                type: 'javascript/auto',
                use: { loader: require.resolve( '@swf/tooling/rewired/typeIconLoader' ) }
            } );

            const kitCache = getKitCache();

            const configs = Object.values( kitCache ).reduce( ( sum, v ) => ( {
                ...sum,
                ...v.content.configuration
            } ), {} );

            const extraDepDefs = Object.values( kitCache ).reduce( ( sum, v ) => sum.concat( v.content.extraDeps || [] ), [] );

            for( const k in configs ) {
                config.module.rules.push( {
                    test: new RegExp( `[\\\\/]${k}\\.json$` ),
                    include: ruleIncludes,
                    type: 'javascript/auto',
                    use: [ babelLoader, {
                        loader: require.resolve( '@swf/tooling/rewired/configJsonLoader.js' )
                    } ]
                } );
            }

            const cssFolderPath = pathExistsSync( nodeModulePath ) ? normalizePath( join( nodeModulePath, 'src/css' ) ) : normalizePath( join( process.cwd(), 'src/css' ) );
            config = customizeSassLoader( config, cssFolderPath );

            // process JSON loading regex
            // https://github.com/arackaf/customize-cra/issues/44
            // leave comments below for possible usage later.
            // revisitme - how can we do devServer for site_xxx.json here?
            const definePlugin = findWebpackPlugin( config.plugins, 'DefinePlugin' );
            definePlugin.definitions.AFX_SITE_JSON_DEF = JSON.stringify( siteInfo.content, null, 4 );

            // html webpack plugin
            // CRA uses the public/index.html but use our solution/src/index.html standard
            const htmlWebpackPlugin = findWebpackPlugin( config.plugins, 'HtmlWebpackPlugin' );
            const entryHtmlInfo = getEntryHtmlInfo();
            htmlWebpackPlugin.options.filename = entryHtmlInfo.filename;
            htmlWebpackPlugin.options.template = entryHtmlInfo.template;

            // post build plugin to create site symlinks
            if( config.mode === 'production' ) {
                const siteName = siteInfo.content.name;
                config.plugins.push( new PostBuildPlugin( siteName ) );
            }

            // site env
            definePlugin.definitions.AFX_UTEST = 'false';
            definePlugin.definitions.AFX_EXTRA_DEPS = extraDepDefs.map( dep => `registerDynImportEntry( '${dep}', () => import( '${dep}' ) )` ).join( '\n' );
        }

        const sourcePaths = getResolvedSourcePaths();
        // copy afx type icons & indicator svg to assets folder
        const patterns = [ {
            from: `${process.cwd()}/${buildJson.imageDir}/**/type*.svg`.replace( /\\/g, '/' ),
            noErrorOnMissing: true,
            to: 'assets/image',
            flatten: true
        }, {
            from: `${process.cwd()}/${buildJson.imageDir}/**/indicator*.svg`.replace( /\\/g, '/' ),
            noErrorOnMissing: true,
            to: 'assets/image',
            flatten: true
        } ];
        const effectiveModules = getEffectiveModules();
        const moduleCache = getModuleCache();
        for( const moduleName of effectiveModules ) {
            if( moduleCache[ moduleName ] ) {
                const content = moduleCache[ moduleName ].content;
                if( content && content.copyAssets ) {
                    const copyAssetsConfig = content.copyAssets;
                    const moduleDir = moduleCache[ moduleName ].srcPath;
                    logger.debug( JSON.stringify( copyAssetsConfig, null, 2 ) );
                    for( const cfg of copyAssetsConfig ) {
                        const flatten = !cfg.copyDirectory;
                        let context = '.';
                        if( cfg.copyDirectory ) {
                            context = /^node_modules/.test( cfg.baseDir ) ? cfg.baseDir : `${moduleDir}/${cfg.baseDir}`;
                        }
                        const from = `${/^node_modules/.test( cfg.baseDir ) ? process.cwd() : moduleDir }/${cfg.baseDir}/${cfg.fileRegex}`.replace( /\\/g, '/' );
                        patterns.push( {
                            flatten,
                            context,
                            from,
                            to: cfg.destPath,
                            noErrorOnMissing: false
                        } );
                    }
                }
            } else {
                logger.info( 'module with name ' + moduleName + ' not found' );
            }
        }
        //Should we move below logic to respective module.jsons? Needs discussion
        _.map( sourcePaths, ( modules, srcPath ) => {
            for( const module of modules ) {
                // logger.info( module );
                //revisitme - assets needs to be unique to prevent browser caching in production builds and runtime code needs to be able
                // to retrieve the assets folder name to build up its src paths
                const moduleSrcPath = `${srcPath}/${module.replace( /\[\\\\\/\]/g, '/' )}/src`;
                if( pathExistsSync( `${moduleSrcPath}/image` ) ) {
                    patterns.push( {
                        from: `${moduleSrcPath}/image/**/!(*.svg)`,
                        noErrorOnMissing: true,
                        to: 'assets/image',
                        flatten: true
                    } );
                } else if( pathExistsSync( `${moduleSrcPath}/assets/image` ) ) {
                    patterns.push( {
                        from: `${moduleSrcPath}/assets/image/**/!(*.svg)`,
                        noErrorOnMissing: true,
                        to: 'assets/image',
                        flatten: true
                    } );
                }

                if( pathExistsSync( `${moduleSrcPath}/images` ) ) {
                    patterns.push( {
                        from: `${moduleSrcPath}/images/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/images',
                        flatten: true
                    } );
                } else if( pathExistsSync( `${moduleSrcPath}/assets/images` ) ) {
                    patterns.push( {
                        from: `${moduleSrcPath}/assets/images/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/images',
                        flatten: true
                    } );
                }

                if( pathExistsSync( `${moduleSrcPath}/propRenderTemplates` ) ) {
                    // propertyRenderers
                    patterns.push( {
                        from: `${moduleSrcPath}/propRenderTemplates/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/propRenderTemplates',
                        flatten: true
                    } );
                } else if( pathExistsSync( `${moduleSrcPath}/assets/propRenderTemplates` ) ) {
                    // propertyRenderers
                    patterns.push( {
                        from: `${moduleSrcPath}/assets/propRenderTemplates/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/propRenderTemplates',
                        flatten: true
                    } );
                }

                if( pathExistsSync( `${moduleSrcPath}/favicon.ico` ) ) {
                    // Support root files for site
                    patterns.push( {
                        from: `${moduleSrcPath}/(favicon.ico|serverError.html)`,
                        noErrorOnMissing: true,
                        to: '.',
                        flatten: true
                    } );
                } else if( pathExistsSync( `${moduleSrcPath}/assets/favicon.ico` ) ) {
                    // Support root files for site
                    patterns.push( {
                        from: `${moduleSrcPath}/assets/(favicon.ico|serverError.html)`,
                        noErrorOnMissing: true,
                        to: '.',
                        flatten: true
                    } );
                }

                if( pathExistsSync( `${moduleSrcPath}/cursor` ) ) {
                    // Copy cursor
                    patterns.push( {
                        from: `${moduleSrcPath}/cursor/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/cursor',
                        flatten: true
                    } );
                } else if( pathExistsSync( `${moduleSrcPath}/assets/cursor` ) ) {
                    // Copy cursor
                    patterns.push( {
                        from: `${moduleSrcPath}/assets/cursor/**/*`,
                        noErrorOnMissing: true,
                        to: 'assets/cursor',
                        flatten: true
                    } );
                }
            }
        } );

        config.plugins.push( new CopyPlugin( {
            patterns: patterns
        } ) );

        // splitchunks optimization for json stitching
        config.optimization.splitChunks = {
            chunks: 'all',
            maxSize: 0,
            minSize: 0,
            maxAsyncRequests: Infinity,
            cacheGroups: {
                commons: {
                    chunks: 'all',
                    priority: 0
                },
                minified: {
                    test: /\.(min).js$/,
                    name( module ) {
                        const filePath = module.userRequest;
                        return basename( filePath, '.js' );
                    },
                    chunks: 'all',
                    priority: 10
                },
                loginLocale: {
                    test: /[(/|\\)]LoginLocale(.*).json$/,
                    name( module ) {
                        const filePath = module.userRequest;
                        const fileName = basename( filePath, '.json' );
                        let localeName;
                        if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                            localeName = fileName.substring( fileName.length - 5 );
                        } else if( /_[\w]{2}$/.test( fileName ) ) {
                            localeName = fileName.substring( fileName.length - 2 );
                        } else {
                            localeName = 'en_US';
                        }
                        return `LoginLocale_${localeName}`;
                    },
                    chunks: 'all',
                    priority: 15
                },
                i18n: {
                    test: /[(/|\\)]i18n[(/|\\)](.*).json$/,
                    name( module ) {
                        const filePath = module.userRequest;
                        const fileName = basename( filePath, '.json' );
                        let localeName;
                        if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                            localeName = fileName.substring( fileName.length - 5 );
                        } else if( /_[\w]{2}$/.test( fileName ) ) {
                            localeName = fileName.substring( fileName.length - 2 );
                        } else {
                            localeName = 'en_US';
                        }
                        return `i18n_${localeName}`;
                    },
                    chunks: 'all',
                    priority: 10
                },
                swfImages: {
                    test: /[\\/]@swf[\\/]images/,
                    name( module ) {
                        const filePath = module.userRequest;
                        const fileName = basename( filePath, '.js' );
                        return getChunkName( fileName, module.issuer );
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 10
                },
                icons: {
                    test: /\.svg$/,
                    name( module ) {
                        const filePath = module.userRequest;
                        const fileName = basename( filePath, '.svg' );
                        return getChunkName( fileName, module.issuer );
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 10
                },
                states: {
                    test: /[(/|\\)]states.json/,
                    name() {
                        return 'states';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 10
                },
                commandsViewModel: {
                    test: /[(/|\\)]commandsViewModel.json/,
                    name() {
                        return 'commandsViewModel';
                    },
                    chunks: 'all',
                    priority: 10
                },
                secondaryWorkareaTabs: {
                    test: /[(/|\\)]secondaryWorkareaTabs.json/,
                    name() {
                        return 'secondaryWorkareaTabs';
                    },
                    chunks: 'all',
                    priority: 10
                },
                components: {
                    test: /[(/|\\)]components[(/|\\)]/,
                    name() {
                        return 'components';
                    },
                    chunks: 'all',
                    priority: 10
                },
                layoutSlots: {
                    test: /[(/|\\)]layoutSlots.json/,
                    name() {
                        return 'layoutSlots';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 20
                },
                navigationURLToken: {
                    test: /[(/|\\)]navigationURLToken.json/,
                    name() {
                        return 'navigationURLToken';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 20
                },
                syncStrategy: {
                    test: /[(/|\\)]syncStrategy.json/,
                    name() {
                        return 'syncStrategy';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 21
                },
                aliasRegistry: {
                    test: /[(/|\\)]aliasRegistry.json/,
                    name() {
                        return 'aliasRegistry';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 22
                },
                typeProperties: {
                    test: /[(/|\\)]typeProperties.json/,
                    name() {
                        return 'typeProperties';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 23
                },
                indicators: {
                    test: /[(/|\\)]indicators.json/,
                    name() {
                        return 'indicators';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 24
                },
                decorators: {
                    test: /[(/|\\)]decorators.json/,
                    name() {
                        return 'decorators';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 25
                },
                adapters: {
                    test: /[(/|\\)]adapters.json/,
                    name() {
                        return 'adapters';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 26
                },
                headerContributions: {
                    test: /[(/|\\)]headerContributions.json/,
                    name() {
                        return 'headerContributions';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 27
                },
                saveHandlers: {
                    test: /[(/|\\)]saveHandlers.json/,
                    name() {
                        return 'saveHandlers';
                    },
                    chunks: 'all',
                    enforce: true,
                    priority: 28
                }
            }
        };
        // add webpack bundle visualizer if BUNDLE_VISUALIZE flag is enabled
        process.env.BUNDLE_VISUALIZE && addBundleVisualizer()( config );

        // in production build then disable the source map for terser plugin
        // const terserPlugin = findWebpackPlugin( config.optimization.minimizer, 'TerserPlugin' );
        // terserPlugin.options.sourceMap = config.mode !== 'production';

        initializePerfMonitor( config, stopwatchTotal );

        // writeJsonSync( join( process.cwd(), 'out/webpack_config.json' ), config, { spaces: 2 } );
        logger.info( `webpack config${stopwatch.end()}`, MSG_PREFIX );
        return config;
    },
    // override dev server for detect different mode. Looks this is the only approach after scan several link:
    // https://github.com/webpack/webpack-dev-server/issues/305
    devServer: configFunction => {
        return ( proxy, allowedHost ) => {
            const config = configFunction( proxy, allowedHost );
            config.index = getEntryHtmlInfo().filename;
            config.watchOptions = {
                // https://webpack.js.org/configuration/watch/#watchoptionsaggregatetimeout
                aggregateTimeout: process.env.WEBPACK_REBUILD_DELAY ? parseInt( process.env.WEBPACK_REBUILD_DELAY, 10 ) : 5000, // milliseconds
                // https://webpack.js.org/configuration/watch/#watchoptionsignored
                ignored: [
                    '**/*.feature',
                    '**.test.js'
                ]
            };
            AliasResolvePlugin.isDevServer = true;
            return config;
        };
    },
    jest: config => {
        const stopwatch = new logger.Stopwatch();
        let reuseJestConfig = false; // This can be set to true if running unit tests more than once. It will reuse the created jest config
        const jestConfigPath = join( process.cwd(), 'out/test/jest_config.json' );
        if( !reuseJestConfig || !pathExistsSync( jestConfigPath ) ) {
            const testOutDir = createTestDirs();
            const buildJson = getBuildJson();
            const { aliasMap } = getAliasMap( buildJson.srcPaths, true );
            let testUtils = join( process.cwd(), 'test/testUtils' );
            if( pathExistsSync( `${testUtils}.js` ) ) {
                aliasMap[ '@swf/core/test/testUtils' ] = join( process.cwd(), 'test/testUtils' );
            } else {
                // FIXME use require.resolve to get the correct path to @swf/core
                aliasMap[ '@swf/core/test/testUtils' ] = join( process.cwd(), 'node_modules/@swf/core/test/testUtils' );
            }

            let regexStr = '';
            for( let srcPath of buildJson.srcPaths ) {
                if( srcPath.includes( 'node_modules/' ) ) {
                    srcPath = srcPath.replace( 'node_modules/', '' )
                        .replace( /@\(/g, '(' ); // convert global regex to standard regex
                    if( regexStr === '' ) {
                        regexStr = 'node_modules/(?!(' + srcPath;
                    } else {
                        regexStr = `${regexStr}|${srcPath}`;
                    }
                }
            }
            if( buildJson.jest && buildJson.jest.transformIgnorePatterns ) {
                for( let srcPath of buildJson.jest.transformIgnorePatterns ) {
                    if( srcPath.includes( 'node_modules/' ) ) {
                        srcPath = srcPath.replace( 'node_modules/', '' )
                            .replace( /@\(/g, '(' ); // convert global regex to standard regex
                        if( regexStr === '' ) {
                            regexStr = 'node_modules/(?!(' + srcPath;
                        } else {
                            regexStr = `${regexStr}|${srcPath}`;
                        }
                    }
                }
            }
            if( regexStr ) {
                config.transformIgnorePatterns = [ `${regexStr})/)` ];
            }

            let moduleNameMapper = config.moduleNameMapper;
            const declLoader = require( '@swf/tooling/rewired/declLoader' );
            const configSvcLoader = require( '@swf/tooling/rewired/configSvcLoader' );
            const typeIconLoader = require( '@swf/tooling/rewired/typeIconLoader' );
            const assestsConfig = {};
            for( const key in aliasMap ) {
                const value = aliasMap[ key ];
                // Use $ to ensure alias does not get used for another module that contins the key in its module name
                // I.E splmTableFillDown and splmTableFillDownHelper
                if( key.match( /viewmodel[\\/]\S+ViewModel$/ ) ) {
                    let partialPath = key + '.json';
                    const baseViewModelJsonPath = normalize( join( testOutDir, partialPath ) );
                    const testViewModelPathJs = normalize( baseViewModelJsonPath.replace( /\.json$/, '.js' ) );
                    moduleNameMapper[ key + '$' ] = testViewModelPathJs.replace( /\\/g,
                        '/' );
                    const viewModel = require( value );
                    const testComponent = declLoader( viewModel, value + '.json' );
                    try {
                        writeFileSync( testViewModelPathJs, testComponent );
                    } catch ( err ) {
                        logger.error( err );
                    }
                } else if( key.match( /js[\\/]configurationService$/ ) ) {
                    let partialPath = key + '.js';
                    const baseConfigurationServicePath = normalize( join( testOutDir, partialPath ) );
                    moduleNameMapper[ key + '$' ] = baseConfigurationServicePath.replace( /\\/g,
                        '/' );
                    const configurationService = readFileSync( value + '.js', { encoding: 'utf8', flag: 'r' } );
                    const configurationServiceLoaded = configSvcLoader( configurationService, value + '.js', true );
                    try {
                        writeFileSync( baseConfigurationServicePath, configurationServiceLoaded );
                    } catch ( err ) {
                        logger.error( err );
                    }
                } else if( key.match( /js[\\/]typeIconRegistry$/ ) ) {
                    let partialPath = key + '.js';
                    const typeIconRegistryPath = normalize( join( testOutDir, partialPath ) );
                    moduleNameMapper[ key + '$' ] = typeIconRegistryPath.replace( /\\/g,
                        '/' );
                    const typeIconReistrySvc = readFileSync( value + '.js', { encoding: 'utf8', flag: 'r' } );
                    const typeIconServiceLoaded = typeIconLoader( typeIconReistrySvc );
                    try {
                        writeFileSync( typeIconRegistryPath, typeIconServiceLoaded );
                    } catch ( err ) {
                        logger.error( err );
                    }
                } else if( key.match( /config[\\/]\S+[\\/]typeProperties$/ ) ) {
                    const filePath = value + '.json';
                    const configFile = JSON.parse( readFileSync( filePath, { encoding: 'utf8', flag: 'r' } ) );
                    const type = filePath.replace( /.*[\\/]([^\\/]*)\.json$/, '$1' );
                    if( assestsConfig[ type ] ) {
                        const prevObj = assestsConfig[ type ];
                        const newObj = configFile[ type ];
                        assestsConfig[ type ] = Object.assign( prevObj, newObj );
                    } else {
                        assestsConfig[ type ] = configFile[ type ];
                    }
                } else if( key.match( /config[\\/]\S+[\\/](adapters|hosting|paste|states|testdatamaster)$/ ) ) {
                    const filePath = value + '.json';
                    const configFile = JSON.parse( readFileSync( filePath, { encoding: 'utf8', flag: 'r' } ) );
                    const type = filePath.replace( /.*[\\/]([^\\/]*)\.json$/, '$1' );
                    if( assestsConfig[ type ] ) {
                        const prevObj = assestsConfig[ type ];
                        const newObj = configFile;
                        assestsConfig[ type ] = _.merge( prevObj, newObj );
                    } else {
                        assestsConfig[ type ] = configFile;
                    }
                } else if( key.match( /i18n[\\/]\S+(Messages|Constants)$/ ) ) {
                    const partialPath = key + '.json';
                    const filePath = value + '.json';
                    const i18nOutPath = normalize( join( testOutDir, partialPath ) );
                    moduleNameMapper[ key + '$' ] = i18nOutPath.replace( /\\/g,
                        '/' );
                    try {
                        copyFileSync( filePath, i18nOutPath );
                    } catch ( err ) {
                        logger.error( err );
                    }
                } else {
                    moduleNameMapper[ key + '$' ] = value;
                }
                // TODO process all the loaders here
                // - js/installedLocales.js
                // - js/moduleLoader.js ??
            }
            Object.keys( assestsConfig ).forEach( key => {
                const fileOutDir = normalize( join( testOutDir, 'config', key + '.json' ) );
                const jsonContents = {};
                jsonContents[ key ] = assestsConfig[ key ];
                const fileContents = JSON.stringify( jsonContents );
                moduleNameMapper[ `config/${key}` ] = fileOutDir;
                try {
                    if ( key === 'hosting' ) {
                        writeFileSync( fileOutDir, JSON.stringify( assestsConfig[ key ] ) );
                    } else{
                        writeFileSync( fileOutDir, fileContents );
                    }
                } catch ( err ) {
                    logger.error( err );
                }
            } );
            //this is require to handle issue with multiple copies of react created due to linking swf/core.
            //thus we resolve react dependency to a single reference i.e. node_modules/react
            moduleNameMapper[ '^react$' ] = resolve( join( process.cwd(), 'node_modules/react' ) );
            // revisitme: unit tests started failing because alias for app, there are more aliases like app/appCtxService so put app$.
            if( moduleNameMapper.app ) {
                moduleNameMapper.app$ = moduleNameMapper.app;
                delete moduleNameMapper.app;
            }

            //Map imported images to a mock image
            let mockImage = join( process.cwd(), 'test/mockImage' );
            if( pathExistsSync( `${mockImage}.js` ) ) {
                moduleNameMapper[ '^image[\\/]' ] = join( process.cwd(), 'test/mockImage' );
            } else {
                // FIXME use require.resolve to get the correct path to @swf/core
                moduleNameMapper[ '^image[\\/]' ] = join( process.cwd(), 'node_modules/@swf/core/test/mockImage' );
            }

            if( buildJson.jest && buildJson.jest.disableCustomResolver === true ) {
                config.moduleNameMapper = moduleNameMapper;
            } else {
                // Use custom jest resolver
                config.moduleNameMapper = swfJestResolver.initialize( moduleNameMapper );
                config.resolver = '<rootDir>/node_modules/@swf/tooling/rewired/jestResolver';
            }

            config.globals = {
                AFX_UTEST: true,
                AFX_EXTRA_DEPS: true
            };

            config.moduleDirectories = [ 'node_modules' ];
            config.resetMocks = false;
            config.roots = [
                '<rootDir>/src' // FIXME This should be pulled from the build.json
            ];
            config.testMatch = [
                '<rootDir>/src/**/test/*est.js'
            ];

            if( pathExistsSync( './jest.setup.js' ) ) {
                config.setupFiles.push( join( process.cwd(), 'jest.setup.js' ) );
            } else if( pathExistsSync( './node_modules/@swf/core/jest.setup.js' ) ) {
                config.setupFiles.push( join( process.cwd(), 'node_modules/@swf/core/jest.setup.js' ) );
            } else {
                logger.error( '- No jest.setup.js found!' );
            }
            // config.collectCoverageFrom.push( 'src/**/test/*est.js' );

            // config.verbose = true;
            writeJSONSync( jestConfigPath, config, { spaces: 2 } );
        } else {
            config = readJSONSync( jestConfigPath );
        }
        logger.info( `- config.setupFiles = ${config.setupFiles.join( ',' )}` );
        logger.info( `jest config${stopwatch.end()}`, MSG_PREFIX );
        return config;
    },
    // The paths config to use when compiling your react app for development or production.
    paths: paths => {
        const stopwatch = new logger.Stopwatch();
        // CRA uses the public/index.html but use our solution/src/index.html standard
        const entryHtmlInfo = getEntryHtmlInfo();
        paths.appHtml = entryHtmlInfo.template;
        // by default CRA creates the build folder but align with our afx approach to create
        // out/site/sitename/.. folder structure
        const siteInfo = getSelectedSite();
        const buildJson = getBuildJson();
        if( buildJson.siteOutDir ) {
            paths.appBuild = join( process.cwd(), buildJson.siteOutDir );
        } else {
            if( siteInfo.content ) {
                paths.appBuild = join( process.cwd(), 'out/site', siteInfo.content.name );
            }
        }
        // CRA production build looks for public folder, if doesn't exist create
        if( pathExistsSync( nodeModulePath ) ) {
            paths.appIndexJs = normalizePath( join( nodeModulePath, 'src/index.js' ) );
        }

        paths.appPublic = join( process.cwd(), 'public' );
        ensureDirSync( paths.appPublic );

        paths.appPublic = join( process.cwd(), 'public' );
        ensureDirSync( paths.appPublic );

        // writeJsonSync( join( process.cwd(), 'out/paths.json' ), paths, { spaces: 2 } );

        logger.info( `generated paths${stopwatch.end()}`, MSG_PREFIX );
        _paths = paths;
        return paths;
    }
};
