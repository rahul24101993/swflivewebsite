// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * JavaScript Processor to get total scripting time
 *
 * @module js/splmStatsComponentProcessor
 */

/**
 * JavaScript Processor to get total scripting time
 *
 * @class SPLMStatsComponentProcessor
 */
function SPLMStatsComponentProcessor() {
    let self = this;

    let _processingTime = 0;
    let _startProcessorTime = 0;
    let _endProcessorTime = 0;
    let _startComponentRenderTime = 0;
    let _endComponentRenderTime = 0;
    let componentMap = {};

    const _reset = function() {
        componentMap = {};
    };

    self.startComponentRenderTime = function() {
        _startProcessorTime = window.performance.now();
        _startComponentRenderTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.endComponentRenderTime = function() {
        _startProcessorTime = window.performance.now();
        _endComponentRenderTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.addComponent = function( componentName ) {
        _startProcessorTime = window.performance.now();
        if ( typeof componentMap[componentName] === 'undefined' ) {
            componentMap[componentName] = {};
            componentMap[componentName].renders = 1;
        } else {
            ++componentMap[componentName].renders;
        }

        if ( typeof componentMap[componentName].time === 'undefined' ) {
            componentMap[componentName].time = _endComponentRenderTime - _startComponentRenderTime;
        } else  {
            componentMap[componentName].time += _endComponentRenderTime - _startComponentRenderTime;
        }
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.start = function() {
        _reset();
        _startProcessorTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.stop = function() {
        _startProcessorTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.getProcessingTime = function() {
        const _time = _processingTime;
        _processingTime = 0;
        return { ComponentOverhead: _time };
    };

    self.getMetrics = function() {
        _startProcessorTime = window.performance.now();
        let componentDetails = [];
        let uniqueComponents = 0;
        let componentRenders = 0;
        let componentsRenderTime = 0;
        Object.keys( componentMap ).forEach( key => {
            componentsRenderTime += componentMap[key].time;
            componentDetails.push( {
                name: key,
                renders: componentMap[key].renders,
                estimatedRenderTime: componentMap[key].time.toFixed( 3 ) + 'ms'
            } );
            uniqueComponents++;
            componentRenders += componentMap[key].renders;
        } );
        componentDetails.sort( ( a, b ) => {
            return b.renders - a.renders;
        } );
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
        return {
            Component: {
                uniqueComponents,
                componentRenders,
                componentDetails,
                componentsRenderTime
            }
        };
    };

    return self;
}

export default SPLMStatsComponentProcessor;
