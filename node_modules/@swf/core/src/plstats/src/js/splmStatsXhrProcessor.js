// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * processor to profile XML HTTP Request
 *
 * @module js/splmStatsXhrProcessor
 */
import { logger } from 'js/splmStatsUtils';
import xhrService from 'js/splmStatsXhrService';

/**
 * Instances of this class represent a profiler for HTTP Request/Response
 *
 * @class SPLMStatsXhrProcessor
 */
function SPLMStatsXhrProcessor() {
    let self = this;

    let _processingTime = 0;
    let _startProcessorTime = 0;
    let _endProcessorTime = 0;

    let _XMLHttpRequests = {};
    let _XMLFinishedHttpRequests = [];
    let _internalXMLHttpRequests = [];
    let _maxHTTPPayload = {
        requestUrl: '',
        payloadSize: 0
    };
    let _totalHttpRequests = 0;
    let _transferSize = 0;
    let _requestSize = 0;
    let _responseSize = 0;
    let _XMLNetworkTimes = [];
    let _errorInfo = {
        requestsAborted: [],
        requestsErrored: [],
        requestsTimeout: []
    };
    let _sortedXMLNetworkTimes = [];
    let _eventListeners = {
        abort: function( xhr ) {
            _errorInfo.requestsAborted.push( xhr );
        },
        error: function( xhr ) {
            _errorInfo.requestsErrored.push( xhr );
        },
        timeout: function( xhr ) {
            _errorInfo.requestsTimeout.push( xhr );
        }
    };

    const max = function( a, b ) {
        return a > b ? a : b;
    };

    const _processRequestsTime = function() {
        _startProcessorTime = window.performance.now();
        for ( let reqUrl in _XMLHttpRequests ) {
            let reqTimings = window.performance.getEntriesByName( reqUrl );
            let i = 0;
            reqTimings.forEach( req => {
                let xmlHttpReq = _XMLHttpRequests[ reqUrl ][ i ];
                let xhr = xmlHttpReq.XHR;
                _transferSize += req.transferSize;
                _responseSize += xhr.response.length;
                xmlHttpReq.timeResponse = req.responseEnd;

                let url = xhr.responseURL;
                if( !url || url.length === 0 ) {
                    url = xhr.requestURL || '';
                }
                // / Access to response data here ///
                xmlHttpReq.timeStart = req.requestStart;
                xmlHttpReq.totalTime = xmlHttpReq.timeResponse - xmlHttpReq.timeStart;
                xmlHttpReq.responseUrl = url; // response url not available in IE, would have to customize looking in service data for url but not AW specific

                _XMLFinishedHttpRequests.push( {
                    timeTaken: xmlHttpReq.totalTime,
                    status: xhr.statusText,
                    responseUrl: url,
                    responseSize: xhr.response.length || xhr.response.byteLength,
                    logCorrelationID: xmlHttpReq.logCorrelationID,
                    startedDateTime: xmlHttpReq.startedDateTime,
                    requestSize: xmlHttpReq.requestSize
                } );
                _internalXMLHttpRequests.push( {
                    timeTaken: xmlHttpReq.totalTime
                } );
                if( _maxHTTPPayload.payloadSize < xhr.response.length ) {
                    _maxHTTPPayload.payloadSize = xhr.response.length;
                    _maxHTTPPayload.requestUrl = url;
                }

                _XMLNetworkTimes.push( {
                    timeStart: xmlHttpReq.timeStart,
                    timeStop: xmlHttpReq.timeResponse
                } );

                i++;
            } );
            delete _XMLHttpRequests[ reqUrl ];
        }
        _totalHttpRequests += window.performance.getEntriesByType( 'resource' ).length;
        if ( window.performance.clearResourceTimings ) {
            window.performance.clearResourceTimings();
        }
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    const _processNetworkGaps = function() {
        _startProcessorTime = window.performance.now();
        let firstStart = 0;
        let firstStop = 0;
        let tStart = 0;
        let tStop = 0;
        let totalTime = 0;
        if( _XMLNetworkTimes.length > 0 ) {
            _sortedXMLNetworkTimes = _XMLNetworkTimes.sort( function( a, b ) {
                return a.timeStart > b.timeStart ? 1 : -1;
            } );

            firstStart = _sortedXMLNetworkTimes[ 0 ].timeStart;
            firstStop = _sortedXMLNetworkTimes[ 0 ].timeStop;
            totalTime = firstStop - firstStart;

            for( let i = 1; i < _sortedXMLNetworkTimes.length; i++ ) {
                tStart = _sortedXMLNetworkTimes[ i ].timeStart;
                tStop = _sortedXMLNetworkTimes[ i ].timeStop;

                if( tStart < firstStop && firstStop < tStop ) {
                    totalTime += tStop - firstStop;
                } else if( tStart < firstStop && tStop < firstStop ) {
                    //Do nothing, time already accounted for...
                } else if( firstStop < tStart ) {
                    totalTime += tStop - tStart;
                }

                firstStop = max( tStop, firstStop );
            }
        }
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
        return totalTime;
    };

    const _processErrorInfo = function() {
        _startProcessorTime = window.performance.now();
        let errorXhrs = _errorInfo.requestsAborted.concat( _errorInfo.requestsErrored ).concat( _errorInfo.requestsTimeout );
        let _newErrorInfo = {
            requestsAborted: [],
            requestsErrored: [],
            requestsTimeout: []
        };
        _internalXMLHttpRequests.forEach( obj => {
            let idx = errorXhrs.indexOf( obj.XHR );
            if( idx !== -1 ) {
                if( _errorInfo.requestsTimeout.includes( obj.XHR ) ) {
                    _newErrorInfo.requestsTimeout.push( obj );
                } else if( _errorInfo.requestsErrored.includes( obj.XHR ) ) {
                    _newErrorInfo.requestsErrored.push( obj );
                } else {
                    _newErrorInfo.requestsAborted.push( obj );
                }
            }
        } );

        _XMLFinishedHttpRequests.forEach(  req => {
            if( req.status && req.status.toLowerCase() !== 'ok' ) {
                _newErrorInfo.requestsErrored = _newErrorInfo.requestsErrored.concat( [ req ] );
            }
        } );
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
        return _newErrorInfo;
    };

    // -------------------------------------------------------------
    // HTTP Request/Response Info
    // -------------------------------------------------------------

    const _xhrProc = function( xhr, data ) {
        _startProcessorTime = window.performance.now();
        _transferSize += data && data.length ? data.length : 0;
        _requestSize += data && data.length ? data.length : 0;
        let JSONData;
        try {
            JSONData = typeof data === 'string' ? JSON.parse( data ) : {};
        } catch ( error ) {
            if( !xhr.requestURL.includes( 'socket.io' ) ) {
                logger.warn( 'XHR Data not in JSON format' );
            }
            JSONData = {};
        }
        let dataObj = {
            timeStart: 0,
            XHR: xhr,
            timeResponse: 0,
            requestSize: data && data.length ? data.length : 0,
            logCorrelationID: JSONData.header && JSONData.header.state && JSONData.header.state.logCorrelationID ? JSONData.header.state.logCorrelationID : 0,
            startedDateTime: new Date().toISOString()
        };
        if ( _XMLHttpRequests.hasOwnProperty( xhr.requestURL ) ) {
            _XMLHttpRequests[ xhr.requestURL ].push( dataObj );
        } else {
            _XMLHttpRequests[ xhr.requestURL ] = [ dataObj ];
        }

        for( let key in _eventListeners ) {
            const listenerFn = _eventListeners[ key ];
            xhr.addEventListener( key, function() {
                listenerFn( xhr );
            } );
        }

        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    xhrService.setMainProc( _xhrProc );

    const _reset = function() {
        _XMLHttpRequests = {};
        _XMLFinishedHttpRequests = [];
        _internalXMLHttpRequests = [];
        _totalHttpRequests = 0;
        _maxHTTPPayload = {
            requestUrl: '',
            payloadSize: 0
        };
        _transferSize = 0;
        _requestSize = 0;
        _responseSize = 0;
        _XMLNetworkTimes = [];
        _sortedXMLNetworkTimes = [];
        _errorInfo = {
            requestsAborted: [],
            requestsErrored: [],
            requestsTimeout: []
        };
        if ( window.performance.clearResourceTimings ) {
            window.performance.clearResourceTimings();
        }
    };

    self.start = function() {
        _reset();
        _startProcessorTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.stop = function() {
        _startProcessorTime = window.performance.now();
        _endProcessorTime = window.performance.now();
        _processingTime += _endProcessorTime - _startProcessorTime;
    };

    self.getProcessingTime = function() {
        const _time = _processingTime;
        _processingTime = 0;
        return { XHRProcessorOverhead: _time };
    };

    self.getMetrics = function() {
        _processRequestsTime();
        return {
            totalNetworkTime: _processNetworkGaps(),
            Network: {
                requestSize: _requestSize,
                responseSize: _responseSize,
                totalSize: _transferSize,
                maxRequest: {
                    url: _maxHTTPPayload.requestUrl,
                    size: _maxHTTPPayload.payloadSize
                },
                totalHttpRequests: _totalHttpRequests,
                SoaDetails: _XMLFinishedHttpRequests,
                errorInfo: _processErrorInfo()
            },
            totalNetworkCost: _transferSize
        };
    };

    return self;
}

export default SPLMStatsXhrProcessor;
