// Copyright (c) 2020 Siemens

/**
 * General profier for async worker
 *
 * https://github.com/GoogleChromeLabs/tti-polyfill
 *
 * @module js/splmStatsProfiler
 */
import { now } from 'js/splmStatsUtils';
import { LAST_DIGEST_BUSY_WAIT } from 'js/splmStatsConstants';

// DOM Node type in browser
export const STATE = {
    IDLE: 0,
    HOLD: 1,
    WAIT: 2,
    DONE: 3
};

// pre save origin set timeout call
const globalSetTimeout = setTimeout;

export const createProfiler = ( watchers = [], interval = LAST_DIGEST_BUSY_WAIT ) => {
    let _promise;
    let _state = STATE.IDLE;

    const _watchers = [ ...watchers ];

    // addWatcher intreface to add more flexibility
    const addWatcher = watcher => _watchers.push( watcher );

    const profile = () => {
        _promise = _promise || new Promise( ( resolve, reject ) => {
            // start time
            const startTime = now();

            const completePageLoad = () => {
                _watchers.forEach( watcher => {
                    watcher.unregister();
                } );

                // WAIT => DONE
                _state = STATE.DONE;

                resolve( now() - startTime - interval );
            };

            let timeoutID = globalSetTimeout( completePageLoad, interval );

            let _requestCnt = 0;
            const _onStart = () => {
                if( _requestCnt === 0 ) {
                    timeoutID = clearTimeout( timeoutID );

                    // WAIT => HOLD
                    _state = STATE.HOLD;
                }
                _requestCnt++;
                // console.log( `Profiler rquestCnt: ${_requestCnt} (onStart)` );
            };

            const _onDone = () => {
                _requestCnt = _requestCnt > 0 ? _requestCnt - 1 : 0;
                if( _requestCnt === 0 ) {
                    // for the case onDone come in 1stly as side effect.
                    timeoutID = clearTimeout( timeoutID );
                    timeoutID = globalSetTimeout( completePageLoad, interval );

                    // HOLD => WAIT
                    _state = STATE.WAIT;
                }
                // console.log( `Profiler rquestCnt: ${_requestCnt} (onDone)` );
            };

            _watchers.forEach( watcher => {
                watcher.register( _onStart, _onDone );
            } );

            // IDLE => WAIT
            _state = STATE.WAIT;
        } );
        return _promise;
    };

    return {
        get state() {
            return _state;
        },
        get active() {
            return _state === STATE.HOLD || _state === STATE.WAIT;
        },
        addWatcher,
        profile
    };
};

const Profiler = () => createProfiler( [] );
export default Profiler;
