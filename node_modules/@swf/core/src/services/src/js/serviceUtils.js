/* eslint-disable complexity */
// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * This module provides the utility functions for supporting aw service.
 *
 * @module js/serviceUtils
 */
import _ from 'lodash';

/**
 * simple http get. PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode
 * @param {string} theUrl url as string
 * @returns {Promise} promise
 */
export function httpGet( theUrl ) {
    return new Promise( ( resolve, reject ) => {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function() {
            if( xmlHttp.readyState === 4 && xmlHttp.status === 200 ) {
                resolve( xmlHttp.responseText );
            }
        };

        xmlHttp.onerror = function( e ) {
            reject( e );
        };

        xmlHttp.open( 'GET', theUrl, true ); // true for asynchronous
        xmlHttp.send( null );
    } );
}

/**
 * simple http get for JSON specific and fake response data structure.
 * PLEASE DON'T use it as promise chain - it will cause issue in angularJS mode
 * @param {string} theUrl url as string
 * @returns {Promise} promise
 */
export function httpGetJsonObject( theUrl ) {
    return httpGet( theUrl ).then( ( txt ) => {
        return {
            data: JSON.parse( txt )
        };
    } );
}

/**
 * Quick check for if the expression can be splitted or not.
 *
 * NOTE: it is strictly based on logic in parseExpression, only handle the case that
 * parseExpression can handle
 * @param {String} expression The expression to parse.
 * @returns {Boolean} true if expression can be splitted.
 */
export const expressionCanSplit = expression => {
    return expression.match( /[)(+\-*/^!&|=><%?:]|\['|'\]/ );
};

/**
 * Splits expression into sub expression
 * @param {String} expression - The expression which needs to broken
 * @returns {Array} - Array of sub expressions
 */
export const processExpression = expression => {
    // remove trailing newline character which is added automatically
    const characters = Array.from( expression.replace( /(\r\n|\n|\r)/gm, '' ).trim() );
    let stack = [];
    let expr = '';
    let ignoreQuotes = false;
    characters.forEach( ( character, index ) => {
        if( character === '(' ) {
            if( expr === '' ) {
                stack.push( '(' );
            } else {
                expr = `${expr}${character}`;
            }
        } else if( character === ')' ) {
            const temp = `${expr}${character}`;
            const openBrackets = temp.split( '(' ).length - 1;
            const closedBrackets = temp.split( ')' ).length - 1;
            if( openBrackets === 0 ) {
                if( expr !== '' ) {
                    stack.push( { expr } );
                    expr = '';
                }
                stack.push( ')' );
            } else if( openBrackets > 0 ) {
                if( openBrackets < closedBrackets ) {
                    stack.push( { expr } );
                    expr = '';
                    stack.push( ')' );
                } else {
                    expr = `${expr}${character}`;
                }
            }
            // stack.push( ')' );
        } else if( /(\+|-|\*|\/|\^|!|&|\||=|>|<|%|\?|:)/.test( character ) ) {
            if( character !== ':' ) {
                // handle such expression that contains equal to ex- "ctx.message" === ""Hello=World"
                if( character === '=' && !( characters[ index - 1 ] === '=' || characters[ index - 1 ] === '!' || characters[ index - 1 ] === '>' || characters[ index - 1 ] === '<' ||
                        characters[ index + 1 ] === '=' ) ) {
                    expr = `${expr}${character}`;
                } else {
                    if( expr !== '' ) {
                        stack.push( { expr } );
                        expr = '';
                    }
                    stack.push( character );
                }
            } else {
                const qMark = _.filter( stack, element => element === '?' ).length;
                const colans = _.filter( stack, element => element === ':' ).length;
                if( qMark - colans > 0 ) {
                    if( expr !== '' ) {
                        stack.push( { expr } );
                        expr = '';
                    }
                    stack.push( character );
                } else {
                    expr = `${expr}${character}`;
                }
            }
        } else if( character === '[' && characters[ index + 1 ] === '\'' ) {
            expr = `${expr}.`;
            ignoreQuotes = true;
        } else if( character === ']' && characters[ index - 1 ] === '\'' ) {
            //DO not
            ignoreQuotes = false;
        } else if( character === '\'' && !ignoreQuotes ) {
            expr = `${expr}${character}`;
        } else if( character.trim() !== '' && character.trim() !== '\'' ) {
            expr = `${expr}${character}`;
        }

        if( index === characters.length - 1 ) {
            //process expr
            if( expr !== '' ) {
                // expr = `${expr}${character}`;
                stack.push( { expr } );
                expr = '';
            }
        }
        // if()
    } );
    return stack;
};

/**
 * This API evaluates expression against the evaluation context using dynamic function.
 * @param {Array} params - The parameter name array
 * @param {Array} paramValues - The parameter value array
 * @param {Object} applyObject - The apply Object
 * @param {String} expression - The expression which needs to be evaluated
 * @returns {Object} result
 */
export const parseNative = ( params, paramValues, applyObject, expression ) => {
    if( params ) {
        params = params.map( param => param.includes( '-' ) ? param.replace( /\-/g, '_' ) : param );
    }
    return evalExpression( expression, params, paramValues, false, applyObject );
};

/**
 * evaluate string as Javascript expression
 * @param {string} expr string as expression
 * @param {Array} params - The parameter name array
 * @param {Array} values - The parameter value array
 * @param {boolean} ignoreError if true the error is not thrown
 * @param {boolean} applyObject object will apply to the expr as this
 * @return {*} evaluation result
 *
 * https://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically
 */
export const evalExpression = ( expr, params, values, ignoreError, applyObject ) => {
    try {
        let sandBoxParams = [ 'window', 'document', 'eval', 'setTimeout', 'setInterval', 'XMLHttpRequest', 'Function' ];
        let sandBoxValues = [ {}, {}, {}, {}, {}, {}, {} ];

        //Replace all dot(.) as . are not valid arguments of function
        let newParams = params.map( ele => ele.indexOf( '.' ) < 0 ? ele : ele.replace( /\./g, '' ) );

        let func = new Function( ...newParams, ...sandBoxParams, `return ${expr};` );
        return func.apply( applyObject, values, ...sandBoxValues );
    } catch ( e ) {
        if( !ignoreError ) {
            throw new Error( `evalExpression('${expr}') => ${e.message}` );
        } else {
            return undefined;
        }
    }
};

/**
 * This metthod splits an expression into Array of subExpressions.
 * @param {String} expression - The expression to be interpolated
 * @returns {Array} Array of sub expressions
 */
export const splitExpressionForInterpolate = expression => {
    const startSyntax = '{{';
    if( expression.includes( startSyntax ) === false ) {
        return expression;
    }
    const endSyntax = '}}';
    const splits = expression.split( startSyntax );
    let finalSplits = [];
    _.forEach( splits, split => {
        if( split.includes( endSyntax ) ) {
            const subSplits = split.split( endSyntax );
            _.forEach( subSplits, ( sSplit, index ) => {
                if( index === 0 ) {
                    finalSplits.push( { expr: sSplit } );
                } else {
                    finalSplits.push( sSplit );
                }
            } );
        } else {
            finalSplits.push( split );
        }
    } );
    return finalSplits;
};

/**
 * Decode value from string.
 * @param {String} val - decode string value
 * @returns {String} value String
 */
export function valFromString( val ) {
    return val !== null ? val.toString().replace( /(~~|~2F)/g, function( m ) {
        const constantMap = { '~~': '~', '~2F': '/' };
        return constantMap[ m ];
    } ) : val;
}

export default {
    httpGet,
    httpGetJsonObject,
    processExpression,
    expressionCanSplit,
    valFromString,
    evalExpression
};
