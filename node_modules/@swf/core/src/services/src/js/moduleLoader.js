/* eslint-disable complexity */
// Copyright (c) 2020 Siemens

/* global
afxWeakImport
AFX_EXTRA_DEPS
*/

/**
 * mock for dynamic import
 *
 * @module js/moduleLoader
 *
 * @namespace moduleLoader
 */

import _ from 'lodash';
import loadable from '@loadable/component';
import AwPromiseService from 'js/awPromiseService';
import AwBaseService from 'js/awBaseService';
import { parseImports } from 'js/utils';
import { getImageAliasFromId } from 'js/imageRegistry';

let _includedComponentCache = {};

// revisitme - like John said we can do deps: () => callback directly. But approach
// below is lowest impact solution
const dynImportRegistration = {
    'js/browserUtils': async () => await import( 'js/browserUtils' )
};

/**
 * register dynamic import entry to dynImportRegistration.
 * mainly used by all JSON loader.
 * has best compatibility to existing declUtils design
 * @param {String} name module name when we use it in JSON
 * @param {Function} callback load callback, mostly will be `await import('js/mySvc')`
 */
export const registerDynImportEntry = ( name, callback ) => {
    dynImportRegistration[ name ] = callback;
};

AFX_EXTRA_DEPS;

export const loadDynModule = name => {
    if( dynImportRegistration[ name ] !== undefined ) {
        return new Promise( resolve => {
            dynImportRegistration[ name ]().then( obj => {
                const resolved = obj && obj.__esModule && obj.default ? obj.default : obj;
                if( resolved.prototype instanceof AwBaseService ) {
                    return resolve( resolved.instance );
                }
                return resolve( resolved );
            } );
        } );
    }
    throw Error( `Library ${name} does not exist!` );
};

export const afxDynamicImport = ( deps, func ) => {
    let modules = [];
    for( const contri of deps ) {
        modules.push( loadDynModule( contri ) );
    }

    return new Promise( resolve => {
        // LCS-294836: To match the requirejs event loop, we add a setTimeout of 0 to mimic the nextTick
        // behavior in requirejs.
        setTimeout( () => {
            return Promise.all( modules ).then( response => {
                return resolve( func.apply( null, response.map( obj => obj && obj.__esModule && obj.default ? obj.default : obj ) ) );
            } );
        }, 0 );
    } );
};

/**
 * Get angular injected module if necessary
 *
 * @param {*} moduleObj - The loaded module
 * @return {Object} Updated dep module
 */
const getModuleInstance = ( moduleObj ) => {
    if( moduleObj && moduleObj.prototype instanceof AwBaseService ) {
        return moduleObj.instance;
    }
    return moduleObj;
};

/**
 * Get a module synchronously. Returns null if module is not loaded.
 *
 * @param {*} depModuleName -
 *
 * @returns {Object|null} Reference to module API object.
 */
export const getDependentModule = depModuleName => {
    /** revisitme
     *  remove me later (loadModule)
     */
    return loadDynModule( depModuleName );

    // LCS-299148 Beyond Angular: Clean up app.getInjector usage
    // afxWeakImport will be setup either in aw_polyfill or afxImport
    //return afxWeakImport( depModuleName );
};

/**
 * @param {String} depModule - The dependent module to load.
 *
 * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has
 * been loaded.
 */
export const loadDependentModule = depModule => {
    return getDependentModule( depModule );
    /**
     * revsitme
     * afxDynamicImport is not supported yet
     */
    // return AwPromiseService.instance( function( resolve, reject ) {
    //     if( depModule ) {
    //         afxDynamicImport( [ depModule ], function( depModule2 ) {
    //             resolve( getModuleInstance( depModule2 ) );
    //         }, reject );
    //     } else {
    //         resolve();
    //     }
    // } );
};

export const loadStaticDependentModule = depModule => {
    if( depModule ) {
        return getModuleInstance( depModule );
    }
    return undefined;
};

/**
 * @param {String[]} depModules - The dependent modules to load.
 * @return {Promise} This promise will be resolved when the given module has been loaded.
 */
export const loadDependentModules = depModules => {
    return AwPromiseService.instance( function( resolve, reject ) {
        if( depModules && depModules.length > 0 ) {
            afxDynamicImport( depModules, function() {
                let retModulesMap = {};
                // LCS-299148 Beyond Angular: Clean up app.getInjector usage
                // This interface has bug for the else block, in no case it
                // will return arg as string which can run injector.get(arg)
                // who is using this interface will only supports angularJS service
                // with other limitaton
                //
                // They are:
                // - AFX
                //   - find function.deps in actionService
                //     - Example: src\thinclient\requirementscommandpanelsjs\src\viewmodel\Arm0ExportToRoundTripWordDocumentViewModel.json
                //     - in this use case after loadDependentModules, structure depModuleObj['appCtxService'] = appCtxSvc
                //       will be constructed. The downstream code will loop the whole depModuleObj and find the matching method
                //       - It is guessing filePath.includes(serviceName) -> for example 'js/appCtxService'.includes('appCtxService')
                //   - colorDecoratorService -> this caller is guessing fileName = 'js/' + serviceName :)
                //   - highlighterService -> this is fine which is a blind load
                // - AW
                //   - Ase0DualSaveHandler -> this is fine which is a blind load
                //   - aw-gantt.controller -> this is fine which is a blind load
                //
                // - Long term solution
                //   - Rewrite the interface to retrun array only. Refactor all caller
                // - Short term solution
                //   - try to fake fileName = 'js/' + serviceName to satisfy all our friends :)
                //
                // - How function definition works today
                //   - Not all function definition supports deps, only function in viewModel ( details see schema )
                //   - all the function imple should be sync otherwise you will get a unexpected promise object
                //   - It has different behavior in different place:
                //     - inputData.data: "{{function:testFunc}}"
                //       - When define {{function:testFunc}}, it SHOULD BE the key of the function definition.
                //       - While loading the deps by this function, it will blindly add key-module pare to depModules,
                //         For example you will get someActionService['functionSvcName'] = functionService, with all
                //         method provided by someActionService together...
                //       - During eval(declarativeDataCtxSvc.applyScope), it has the intellegence to loop depModules
                //         recursively to get the corrct function
                //         - But if a same function exist in someActionService, it will still take priority...
                //
                //     - outputData: "{{function: testFunc}}"
                //       - When define {{function:aaa}}, the aaa is NOT the key you defined in functions, BUT SHOULD
                //         BE the actual key in deps. For example:
                //         - You define { functions: { aaa: { functionName: showInfo }}}
                //         - When use it, we use {{function:showInfo}}, not {{function:aaa}}
                //       - No matter what you put in deps, it will always go to main dep (action dep)
                //         to try to evaluate your function name (declarativeDataCtxSvc.getOutput)
                _.forEach( arguments, function( arg, idx ) {
                    let moduleName = depModules[ idx ].replace( /^.*\//, '' );

                    if( arg.prototype instanceof AwBaseService ) {
                        retModulesMap[ moduleName ] = arg.instance;
                    } else {
                        retModulesMap[ moduleName ] = arg;
                    }
                } );
                resolve( retModulesMap );
            } );
        } else {
            resolve();
        }
    } );
};

/**
 * Loading the imported JS
 *
 * @param {StringArray} moduleNames - Array of module's to 'import'.
 *
 * @return {PromiseArray} Promise resolved with references to the module/service APIs of the given dependent
 *         modules.
 */
export const loadImports = moduleNames => {
    return AwPromiseService.instance( function( resolve, reject ) {
        if( moduleNames && moduleNames.length > 0 ) {
            afxDynamicImport( moduleNames, function() {
                var moduleObjs = [];
                _.forEach( arguments, function( arg ) {
                    if( arg ) {
                        if( arg.prototype instanceof AwBaseService ) {
                            moduleObjs.push( arg.instance );
                        } else {
                            moduleObjs.push( arg );
                        }
                    }
                } );
                resolve( moduleObjs );
            } );
        } else {
            resolve();
        }
    } );
};

/**
 * Loading the imported svgs dynamically.
 *
 * @param {String} imageId - String ImageId which can either be complete alias or just imageId.
 * @param {Boolean} exactMatch - If true, then includeImage wont try to get the alias from passed imageId.
 * @returns Dynamic Image Component
 */
export const includeImage = ( imageId, exactMatch ) => {
    if( imageId ) {
        let DynamicComponent = _includedComponentCache[ imageId ];
        if( !DynamicComponent ) {
            const imageAlias = exactMatch ? imageId : getImageAliasFromId( imageId );
            DynamicComponent = loadable( () => {
                try {
                    return loadDynModule( imageAlias ).then( resolved => resolved.SvgComponent );
                } catch ( error ) {
                    console.log( error.message );
                    return Promise.resolve( () => null );
                }
            }, { fallback: <svg style={{ width: '16px', height: '16px' }}></svg> } );
            _includedComponentCache[ imageId ] = DynamicComponent;
        }
        // add viewId to facilitate debug
        return <DynamicComponent/>;
    }
};

export const includeComponent = ( componentName, prop ) => {
    if( componentName ) {
        let DynamicComponent = _includedComponentCache[ componentName ];
        let viewId = prop.viewId ? prop.viewId : componentName;
        if( !DynamicComponent ) {
            DynamicComponent = loadable( () => {
                try {
                    return loadDynModule( `viewmodel/${componentName}ViewModel` );
                } catch ( error ) {
                    console.log( error.message );
                    return Promise.resolve( () => null );
                }
            } );
            _includedComponentCache[ componentName ] = DynamicComponent;
        }
        // add viewId to facilitate debug
        return <DynamicComponent viewId={viewId} { ...prop} />;
    }
};

window.afxDynamicImport = afxDynamicImport;

// dep definitions from kit.json. NOTE: this part doesn't support dev-server delta build
// AFX_CONFIG_ENTRY

// export default for test purpose
export default {
    getDependentModule,
    loadDependentModule,
    includeComponent,
    loadStaticDependentModule,
    loadDependentModules,
    loadImports,
    includeImage
};
