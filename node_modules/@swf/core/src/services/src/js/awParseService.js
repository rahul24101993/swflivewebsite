// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * This module provides core angularJS services abstraction.
 * Link below can we used for test complete accurate functionality:
 * http://embed.plnkr.co/J6pyQs4NY647JGupZVe3/preview
 *
 * For now all the use case in awParseService.test.js are guaranteed to work :)
 *
 * @module js/awParseService
 */

import {
    processExpression,
    expressionCanSplit,
    parseNative
} from 'js/serviceUtils';
import { $ParseProvider } from 'js/angularjsParseService';

const $parse = new $ParseProvider().$get[1]();
const getRandomInt = max => Math.floor( Math.random() * Math.floor( max ) );

/**
 * The API splits the expression and parse it.
 * @param {String} expression - The String expression to parse
 * @param {Array} names - The String Array of Parameters
 * @param {Array} vals - The Array of parameter values.
 * @returns {Object} parsed value
 */
const splitAndParse = ( expression, names, vals ) => {
    if( !expressionCanSplit( expression ) ) {
        return undefined;
    }
    const stack = processExpression( expression );
    let finalExpresions = stack.map( ( element, index ) => {
        if( element.expr ) {
            try {
                const response = parseNative( names, vals, null, element.expr );
                if( response === undefined ) {
                    //Check unary operator case
                    if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {
                        element.response = 0;
                    }
                    if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {
                        element.response = 0;
                    }
                } else {
                    element.response = response;
                }
            } catch ( e ) {
                //Check unary operator case
                if( index < stack.length - 1 && stack[ index + 1 ] === '+' || stack[ index + 1 ] === '-' ) {
                    element.response = 0;
                } else if( index > 0 && stack[ index - 1 ] === '+' || stack[ index - 1 ] === '-' ) {
                    element.response = 0;
                } else {
                    element.response = undefined;
                }
            }
        }
        return element;
    } );
    let params = [];
    let values = [];
    const finalExprs = finalExpresions.map( ( element ) => {
        if( element.expr ) {
            //TODO: generate random number
            const varName = `param${getRandomInt( 100000 )}`;
            params.push( varName );
            values.push( element.response );
            return varName;
        }
        return element;
    } );
    const evalExpr = finalExprs.join( '' ).trim();
    return parseNative( params, values, null, evalExpr );
};

const numberPropRe = /[a-zA-Z]\.[0-9]/;
export default class AwParseService {
    static instance( expression ) {
        if( !expression ) {
            return () => undefined;
        }
        const originalParseFunction = function( evaluationCtx ) {
            let names = Object.keys( evaluationCtx );
            let vals = Object.values( evaluationCtx );
            try {
                const response = parseNative( names, vals, null, expression );
                // revisitme - what is this isNaN mean? for now limits it to number only
                if( typeof response === 'number' && isNaN( response ) ) {
                    return splitAndParse( expression, names, vals );
                }
                return response;
            } catch ( e ) {
                //Split the expression and try to resolve
                return splitAndParse( expression, names, vals );
            }
        };
        //if angularjs $parse is passed invalid JS code (ex number as a key) it can get stuck in infinite loop and crash the browser
        //Some cases of this have been added in 6.1
        if( expression.match( numberPropRe ) ) {
            return originalParseFunction;
        }
        try {
            const fn = $parse( expression );
            return function( evaluationCtx ) {
                return fn( evaluationCtx );
            };
        } catch ( e ) {
            return originalParseFunction;
        }
    }
}
