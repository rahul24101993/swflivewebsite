// Copyright (c) 2022 Siemens

/**
 * This module provides the native implementation of the awHttpService.
 *
 * @module js/awHttpService
 */

import axios from 'axios';
import AwCacheFactoryService from 'js/awCacheFactoryService';

const cache = AwCacheFactoryService.instance( 'http' );
const pendingHttpCalls = {};

/**
 * create HTTP request
 * @param {Object} config http config object
 * @returns {Promise} http promise
 */
function createHttpRequest( config ) {
    return axios( config );
}

createHttpRequest.patch = ( url, data, config ) => {
    return new Promise( ( resolve, reject ) => {
        axios.patch( url, data, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};

createHttpRequest.put = ( url, data, config ) => {
    return new Promise( ( resolve, reject ) => {
        axios.put( url, data, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};

createHttpRequest.post = ( url, data, config ) => {
    // window.webdriverIsEnabled is set when we launch the browser from Selenium
    // this is a temporary hack to get past some file upload issues. Browser
    // is cancelling the network requests for some unknown reason
    if( window.webdriverIsEnabled === true ) {
        return new Promise( ( resolve, reject ) => {
            setTimeout( () => {
                axios.post( url, data, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
            }, 0 );
        } );
    }

    return new Promise( ( resolve, reject ) => {
        axios.post( url, data, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};

createHttpRequest.head = ( url, config ) => {
    return new Promise( ( resolve, reject ) => {
        axios.head( url, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};
createHttpRequest.delete = ( url, config ) => {
    return new Promise( ( resolve, reject ) => {
        axios.delete( url, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};

createHttpRequest.get = ( url, config ) => {
    if( config && config.cache ) {
        const cachedData = cache.get( url );
        if( cachedData ) {
            return cachedData;
        }
        const getCallPromise = new Promise( ( resolve, reject ) => {
            axios.get( url, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
        } );
        cache.put( url, getCallPromise );
        return getCallPromise;
    }

    return new Promise( ( resolve, reject ) => {
        axios.get( url, config ).then( ( data ) => resolve( data ), ( error ) => reject( error ) );
    } );
};

// Add a request interceptor
axios.interceptors.request.use( function( config ) {
    pendingHttpCalls[ config.url ] = config;
    updatePendingRequests();
    return config;
}, function( error ) {
    return Promise.reject( error );
} );

// Add a response interceptor
axios.interceptors.response.use( function( response ) {
    delete pendingHttpCalls[ response.config.url ];
    updatePendingRequests();
    return response;
}, function( error ) {
    delete pendingHttpCalls[ error.config.url ];
    updatePendingRequests();
    return Promise.reject( error );
} );

/**
 */
function updatePendingRequests() {
    createHttpRequest.pendingRequests = Object.values( pendingHttpCalls );
}

updatePendingRequests();

const exports = {
    instance: createHttpRequest
};

export default exports;
