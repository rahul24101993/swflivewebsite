// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * This module provides core angularJS services abstraction.
 * This is autogenerated file. If you hand modify this file, please remove this line.
 *
 * @module js/awInterpolateService
 */
import _ from 'lodash';
import { splitExpressionForInterpolate } from 'js/serviceUtils';
import AwParseService from 'js/awParseService';
export default class AwInterpolateService {
    /**
     * Algo
     * 1. Spilt statment into statement + Filters by |
     * 2. Evaluate expression then apply filters on it if any.
     * @param {String} expression - The String expression which needs to be evaluated
     * @returns {Object} the interpolate function
     */
    static instance( expression ) {
        return evalCtx => {
            if( !expression ) {
                return undefined;
            }
            let expressions = splitExpressionForInterpolate( expression );
            expressions = _.map( expressions, subExpr => {
                if( subExpr.expr ) {
                    let containsOR = false;
                    let localExpression = subExpr.expr;
                    if( localExpression.includes( '||' ) ) {
                        //Replace || for now till we split with |
                        localExpression = localExpression.replace( /\|\|/g, '@#@#' );
                        containsOR = true;
                    }
                    if( /\|/g.test( localExpression ) ) {
                        throw new Error( 'Filter expressions are not supported by interpolate' );
                    }
                    if( containsOR ) {
                        localExpression = localExpression.replace( /\@\#\@\#/g, '||' );
                    }

                    //If the length of the array is > 1 means filter exists, in that case 0th entry is going to be expression
                    //split removes seperators
                    const toParse = localExpression.trim();
                    try {
                        return AwParseService.instance( toParse )( evalCtx );
                    } catch ( error ) {
                        return undefined;
                    }
                }
                return subExpr;
            } );
            return expressions.join( '' );
        };
    }
}
