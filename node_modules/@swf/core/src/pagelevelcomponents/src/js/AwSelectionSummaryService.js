/* eslint-disable complexity */
// Copyright (c) 2021 Siemens
import _ from 'lodash';
import moduleLoader from 'js/moduleLoader';
import cfgSvc from 'js/configurationService';
import localeService from 'js/localeService';
import editHandlerService from 'js/editHandlerService';
import appCtxService from 'js/appCtxService';
import conditionService from 'js/conditionService';
import AwPromiseService from 'js/awPromiseService';
import localStorage from 'js/localStorage';
import Debug from 'debug';
import { DerivedStateResult } from 'js/derivedContextService';
import { parseCondition } from 'js/conditionParser.service';
import { concat, flatten } from 'lodash';

const trace = new Debug( 'selection' );

const loadTabTitle = tab => {
    if( typeof tab.name !== 'string' ) {
        localeService.getLocalizedText( tab.name.source, tab.name.key ).then( function( result ) {
            tab.name = result;
        } );
    }
};

const loadSecondaryWorkareaTabs = async() => {
    return await cfgSvc.getCfg( 'secondaryWorkareaTabs' ).then( tabsConfig => {
        tabsConfig.tabs.forEach( function( tab, idx ) {
            tab.pageId = tab.pageId ? tab.pageId : idx;
        } );
        tabsConfig.tabs.forEach( loadTabTitle );
        return tabsConfig;
    } );
};

export const initialize = () => {
    return loadSecondaryWorkareaTabs().then( tabsConfig => {
        const { ctxParameters, additionalParameters } = getTabsState( tabsConfig );
        return {
            tabsConfig,
            ctxParameters,
            additionalParameters
        };
    } );
};

const conditionFilter = ( tab, tabsConfig, selection, context ) => {
    var conditionExpression = tab.visibleWhen;
    if( tab.visibleWhen && tab.visibleWhen.condition ) {
        var conditionExpressionObj = _.get( tabsConfig, tab.visibleWhen.condition );
        conditionExpression = conditionExpressionObj.expression;
    }

    tab.displayTab = true;
    if( conditionExpression ) {
        tab.displayTab = conditionService.evaluateCondition( {
            ctx: appCtxService.ctx,
            selection: selection,
            context: { ...context, isXrtApplicable: context && context.hasOwnProperty( 'isXrtApplicable' ) ? context.isXrtApplicable : !_.isUndefined( appCtxService.ctx.tcSessionData ) }
        }, conditionExpression );
    }
    return tab.displayTab;
};

const isActiveTabStillVisible = ( visibleTabs, activeTab ) => {
    return visibleTabs.filter( tab => tab.tabContent ? tab.pageId === activeTab.pageId && _.isEqual( tab.tabContent, activeTab.tabContent ) : tab.pageId === activeTab.pageId ).length > 0;
};

const updateTabsToShow = ( tabsToShow, activeTab ) => {
    let index = _.findIndex( tabsToShow, ( tab ) => {
        return tab.pageId === activeTab.pageId || tab.name === activeTab.name;
    }, 0 );
    tabsToShow = _.map( tabsToShow, ( tab, idx ) => {
        if( idx === index ) {
            tab.selectedTab = true;
        } else {
            tab.selectedTab = undefined;
        }
        return tab;
    } );
    return tabsToShow;
};

const isContributedTabActive = ( swaContributedTabs, activeTab ) => {
    if( activeTab && swaContributedTabs && swaContributedTabs.length > 0 ) {
        let ndx = -1;
        if( typeof activeTab === 'object' ) {
            ndx = _.findIndex( swaContributedTabs, ( tab ) => {
                return tab.pageId === activeTab.pageId || tab.name === activeTab.name;
            }, 0 );
        } else if( typeof activeTab === 'string' ) {
            ndx = _.findIndex( swaContributedTabs, ( tab ) => {
                return tab.name === activeTab || tab.view === activeTab;
            }, 0 );
        }
        return ndx > -1;
    }
    return false;
};

const fetchChildTabs = ( containerTab, selection, activeTab, swaContributedTabs, context ) => {
    let isContributedTab = isContributedTabActive( swaContributedTabs, activeTab );
    activeTab = isContributedTab === false ? activeTab : undefined;
    var deferred = AwPromiseService.instance.defer();
    if( containerTab.deps ) {
        const doAction = depModuleObj => {
            return depModuleObj[ containerTab.method ]( selection, activeTab, context, isContributedTab  );
        };
        return moduleLoader.loadDependentModule( containerTab.deps ).then( doAction );
    }
    return deferred.Promise;
};

export const syncSublocationState = ( activeTab, sublocationState ) => {
    let newSublocationState;
    if( sublocationState ) {
        newSublocationState = { ...sublocationState.value };
    } else {
        newSublocationState = {};
    }
    newSublocationState.secondaryActiveTabId = activeTab.tabKey ? activeTab.tabKey : activeTab.view;
    if( sublocationState.secondaryActiveTabId !== newSublocationState.secondaryActiveTabId ) {
        sublocationState.update( newSublocationState );
    }
};

export const clearSublocationState = ( sublocationState ) => {
    let newSublocationState = { ...sublocationState.value };
    newSublocationState.secondaryActiveTabId = undefined;
    sublocationState.update( newSublocationState );
};

const processFetchedData = ( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerPriority, updatedTabsToShow, containerTab ) => {
    let tabToActivate = {};
    let tabsToShow = [];
    let childTabs = [];

    if( output ) {
        let allVisibleTabs = data.getData().changedAllVisibleTabs;
        let allVisibleContributedTabs = [];
        if( allVisibleTabs ) {
            allVisibleTabs.map( ( tab ) => {
                let tabClone = { ...tab };
                if( !tabClone.hasChildTabs ) {
                    allVisibleContributedTabs.push( tabClone );
                }
            } );
            if( allVisibleContributedTabs.length === 0 ) {
                allVisibleContributedTabs = swaContributedTabs;
            }
        } else {
            allVisibleContributedTabs = swaContributedTabs;
        }

        childTabs = output.childTabs;
        _.forEach( childTabs, ( childTab ) => { childTab.priority = containerPriority; } );
        tabsToShow = tabsToShow.concat( childTabs, allVisibleContributedTabs );
    } else {
        tabsToShow = updatedTabsToShow ? updatedTabsToShow : swaContributedTabs;
    }

    // sort the contributed and container tabs based on priority
    tabsToShow.sort( function( t1, t2 ) {
        return t1.priority - t2.priority;
    } );

    let requestedActiveTab = activeTab;
    activeTab = evalTabObj( tabsToShow, activeTab );
    if( !_.isEmpty( activeTab ) && isActiveTabStillVisible( tabsToShow, activeTab ) ) {
        tabToActivate = activeTab;
        tabsToShow = updateTabsToShow( tabsToShow, activeTab );
    } else if( _.isEmpty( activeTab ) ) {
        requestedActiveTab = localStorage.get( 'lastActiveTab' );
        let activeTab1 = evalTabObj( tabsToShow, requestedActiveTab );
        if( !_.isEmpty( activeTab1 ) && isActiveTabStillVisible( tabsToShow, activeTab1 ) && requestedActiveTab !== '' ) {
            return fetchTabsData( selectionData, tabsConfig, containerTab, selection, requestedActiveTab, swaContributedTabs, data, context, dispatch, tabsToShow );
        }
        tabToActivate = tabsToShow[ 0 ];
        tabsToShow = updateTabsToShow( tabsToShow, tabToActivate );
    } else {
        tabToActivate = tabsToShow[ 0 ];
        tabsToShow = updateTabsToShow( tabsToShow, tabToActivate );
    }
    if( tabToActivate ) {
        tabToActivate.tabContent = output ? output.activeTabContent : undefined;
        tabToActivate.extraInfo = output ? output.extraInfo : null;
    }

    const tabChangeCallback = ( pageId, tabTitle, refresh ) => {
        localStorage.publish( 'lastActiveTab', pageId );
        clearSelectionData( selectionData );
        activateTab( data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority );
    };

    const activeTabKey = tabToActivate && tabToActivate.tabKey ? tabToActivate.tabKey : tabToActivate ? tabToActivate.view : '';

    let unExpandedVisibleTabs = data && data.ctx && data.ctx.visibleTabs ? data.ctx.visibleTabs : undefined;
    if( !unExpandedVisibleTabs || unExpandedVisibleTabs.length === 0 ) {
        unExpandedVisibleTabs = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.unExpandedVisibleTabs;
    }

    return {
        summaryContext: {
            activeTab: tabToActivate,
            visibleTabs: tabsToShow,
            api: tabChangeCallback,
            selection: selection,
            allVisibleTabs: updatedTabsToShow,
            activeTabKey: activeTabKey,
            childTabs: childTabs,
            unExpandedVisibleTabs
        }
    };
};

const fetchTabsData = ( selectionData, tabsConfig, containerTab, selection, activeTab, swaContributedTabs, data, context, dispatch, allVisibleTabs ) => {
    return fetchChildTabs( containerTab, selection[ 0 ], activeTab, swaContributedTabs, context ).then( ( output ) => {
        const currentSelection = data.getData().summaryContext && data.getData().summaryContext.selection ? data.getData().summaryContext.selection : undefined;
        if( !currentSelection || currentSelection && currentSelection.length === 1 && currentSelection[ 0 ].uid === selection[ 0 ].uid ) {
            return processFetchedData( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, activeTab, output, containerTab.priority, allVisibleTabs, containerTab );
        }
        if( currentSelection && currentSelection.length === 1 ) {
            return fetchTabsData( selectionData, tabsConfig, containerTab, currentSelection, activeTab, swaContributedTabs, data, context, dispatch );
        }
        return AwPromiseService.instance.resolve( { summaryContext: data.getData().summaryContext } );
    } );
};

const evalTabObj = ( tabsToShow, activeTab ) => {
    if( typeof activeTab !== 'object' ) {
        let index = _.findIndex( tabsToShow, ( tab ) => {
            return tab.pageId && tab.pageId === activeTab || tab.tabKey && tab.tabKey === activeTab || tab.name && tab.name === activeTab
            || tab.view && tab.view === activeTab || tab.id && tab.id === activeTab;
        }, 0 );
        activeTab = tabsToShow[ index ];
    }
    return activeTab;
};

const isInputSelectionSameAsCurrentSelection = ( currentSelection, inputSelection ) => {
    if(  !currentSelection && !inputSelection  ||  currentSelection && currentSelection.length === 0 && inputSelection && inputSelection.length === 0  ) {
        return true;
    }
    return currentSelection.length === inputSelection.length && inputSelection.length > 0 && _.isEqual( currentSelection[ 0 ].uid, inputSelection[ 0 ].uid );
};

const areInputPropsAndDataNotPopulatedYet = ( props, data ) => {
    return !props || !props.selection || !data || !props.tabsConfig || !props.tabsConfig.tabs;
};

const areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs = ( currentlyVisibleUnExpandedTabs, inputUnExpandedTabs ) => {
    if( !currentlyVisibleUnExpandedTabs && !inputUnExpandedTabs ) {
        return true;
    }
    if( !currentlyVisibleUnExpandedTabs || !inputUnExpandedTabs ) {
        return false;
    }
    if( currentlyVisibleUnExpandedTabs.length !== inputUnExpandedTabs.length ) {
        return false;
    }

    for( var i = 0; i < currentlyVisibleUnExpandedTabs.length; ++i ) {
        var cachedTabKey = currentlyVisibleUnExpandedTabs[ i ].tabKey ? currentlyVisibleUnExpandedTabs[ i ].tabKey : currentlyVisibleUnExpandedTabs[ i ].name;
        var receivedTabKey = inputUnExpandedTabs[ i ].tabKey ? inputUnExpandedTabs[ i ].tabKey : inputUnExpandedTabs[ i ].name;
        if( cachedTabKey !== receivedTabKey ) {
            return false;
        }
    }
    return true;
};

const isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs = ( summaryContext, unExpandedVisibleTabs, currentlyActiveTabId ) => {
    return summaryContext && summaryContext.activeTab && !summaryContext.activeTab.api && unExpandedVisibleTabs && unExpandedVisibleTabs.filter( tab => tab.view === currentlyActiveTabId ).length === 0;
};

const isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab = ( tabRequestedToBeActivated, data ) => {
    let currentlyActiveTabKey = data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.tabKey ? data.summaryContext.activeTab.tabKey : data && data.summaryContext && data.summaryContext.activeTab && data.summaryContext.activeTab.view ? data.summaryContext.activeTab.view : '';
    if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {
        currentlyActiveTabKey = data && data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.tabKey ? data && data.getData().summaryContext.activeTab.tabKey : data.getData() && data.getData().summaryContext && data.getData().summaryContext.activeTab && data.getData().summaryContext.activeTab.view ? data.getData().summaryContext.activeTab.view : '';
        if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {
            currentlyActiveTabKey = data && data.summaryContext ? data.summaryContext.activeTabKey : '';
            if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {
                currentlyActiveTabKey = data && data.getData().summaryContext ? data.getData().summaryContext.activeTabKey : '';
                if( tabRequestedToBeActivated !== '' && tabRequestedToBeActivated !== currentlyActiveTabKey ) {
                    return true;
                }
            }
        }
    }
    return false;
};

export const getTabToActivateAndVisibleTabs = ( data, props, unExpandedVisibleTabs ) => {
    const getTabToActivate = () => {
        let containerTabs = [];
        let swaContributedTabs = [];
        if( tabsConfig ) {
            var allVisibleTabs = [];
            tabsConfig.tabs.map( ( tab ) => {
                let tabClone = { ...tab };
                if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {
                    allVisibleTabs.push( tabClone );
                }
            } );

            for( const tab of allVisibleTabs ) {
                if( tab.hasChildTabs === true ) {
                    containerTabs.push( tab );
                } else {
                    swaContributedTabs.push( tab );
                }
            }
        }

        if( containerTabs.length > 0 && !skipAfreshChildFetch ) {
            dispatch( { path: 'data.changedAllVisibleTabs', value: [] } );
            return fetchTabsData( props.selectionData, props.tabsConfig, containerTabs[ 0 ], localSelection, tabToActivateNow, swaContributedTabs, data, context, dispatch, allVisibleTabs );
        }
        if( containerTabs.length > 0 ) {
            var output = { childTabs: data.summaryContext ? data.summaryContext.childTabs : [], activeTabContent: _.get( data, 'summaryContext.activeTab.tabContent' ) };
            if( !output.extraInfo ) {
                output.extraInfo = data.summaryContext && data.summaryContext.activeTab ? data.summaryContext.activeTab.extraInfo : null;
            }
            if( !output.childTabs || output.childTabs.length === 0 ) {
                dispatch( { path: 'data.changedAllVisibleTabs', value: unExpandedVisibleTabs } );
                return;
            }
            return AwPromiseService.instance.resolve( processFetchedData( data, props.selectionData, props.tabsConfig, localSelection, context, dispatch,
                swaContributedTabs, tabToActivateNow, output, containerTabs[ 0 ].priority, allVisibleTabs, containerTabs[0] ) );
        }
        return AwPromiseService.instance.resolve( processFetchedData( data, props.selectionData, props.tabsConfig, localSelection, context, dispatch, swaContributedTabs, tabToActivateNow ) );
    };

    if( areInputPropsAndDataNotPopulatedYet( props, data ) ) {
        return;
    }

    const { dispatch } = data;
    const { summaryContext } = data.getData();
    const { selection, context, tabsConfig } = props;
    let localSelection = Array.isArray( selection ) ? selection : [ selection ];

    let allVisibleTabsInternal = [];
    if( tabsConfig ) {
        tabsConfig.tabs.map( ( tab ) => {
            let tabClone = { ...tab };
            if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {
                allVisibleTabsInternal.push( tabClone );
            }
        } );
    }

    let tabRequestedToBeActivated = context && context.pageContext && context.pageContext.sublocationState && context.pageContext.sublocationState.secondaryActiveTabId !== '' ? context.pageContext
        .sublocationState.secondaryActiveTabId : '';

    if( !tabRequestedToBeActivated ) {
        tabRequestedToBeActivated = '';
    }

    let currentlyActiveTabId = summaryContext && summaryContext.activeTabKey ? summaryContext.activeTabKey : '';
    let tabToActivateNow = currentlyActiveTabId;

    if( isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) ) {
        tabToActivateNow = tabRequestedToBeActivated;
        localStorage.publish( 'lastActiveTab', tabToActivateNow );
    }

    if( summaryContext ) {
        if( !isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) && isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection ) &&
            areCurrentUnexpandedVisibleTabsSameAsInputUnexpandedVisibleTabs( summaryContext.unExpandedVisibleTabs, allVisibleTabsInternal ) ) {
            return;
        }
    }

    let skipAfreshChildFetch = false;

    if( summaryContext ) {
        if( isProgrammaticTabChangeRequestedAndIsDifferentThanCurrentlyActiveTab( tabRequestedToBeActivated, data ) ) {
            tabToActivateNow = tabRequestedToBeActivated;
        } else if( isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection ) ) {
            skipAfreshChildFetch = true;
            if( isCurrentlyVisibleTabAContributedTabAndIsNoLongerAvailableInNewVisibleTabs( summaryContext, allVisibleTabsInternal, currentlyActiveTabId ) ) {
                skipAfreshChildFetch = false;
            }
        }
    }
    if( tabToActivateNow === '' ) {
        tabToActivateNow = localStorage.get( 'lastActiveTab' ) ? localStorage.get( 'lastActiveTab' ) : tabToActivateNow;
    }

    let localSummaryContext = { ...data.summaryContext };
    localSummaryContext.selection = localSelection;
    localSummaryContext.unExpandedVisibleTabs = allVisibleTabsInternal;
    localSummaryContext.activeTabKey = tabToActivateNow;
    dispatch( { path: 'data.summaryContext', value: localSummaryContext } );

    let pwaEditContext = context ? context.editContext : '';
    if( !pwaEditContext || pwaEditContext === '' ) {
        pwaEditContext = 'TABLE_CONTEXT';
    }
    let pwaEditHandler = editHandlerService.getEditHandler( pwaEditContext );
    const isActiveTabIsNonStickyAndNoSelectionChange = !summaryContext || _.get( summaryContext, 'activeTab.api' ) !== undefined || isInputSelectionSameAsCurrentSelection( summaryContext.selection, localSelection );
    if( !pwaEditHandler || !pwaEditHandler.editInProgress() && isActiveTabIsNonStickyAndNoSelectionChange ) {
        return editHandlerService.leaveConfirmation().then( function() {
            return getTabToActivate();
        } );
    }
    return getTabToActivate();
};

const activateTab = ( data, selectionData, tabsConfig, pageId, tabTitle, tabsToShow, swaContributedTabs, dispatch, selection, context, refresh, containerPriority ) => {
    const selectedTab = tabsToShow.filter( function( tab ) {
        return tab.pageId === pageId || tab.name === tabTitle;
    } )[ 0 ];

    const updateSelectionSummaryContext = ( output ) => {
        let { summaryContext } = processFetchedData( data, selectionData, tabsConfig, selection, context, dispatch, swaContributedTabs, selectedTab, output, containerPriority, tabsToShow );
        dispatch( { path: 'data.summaryContext', value: summaryContext } );
    };

    const handleTabChange = () => {
        if( selectedTab && selectedTab.api ) {
            if( !selectedTab.tabContent || refresh ) {
                const selectedTabTitle = selectedTab.tabKey ? selectedTab.tabKey : selectedTab.view;
                dispatch( { path: 'data.summaryContext.activeTabKey', value: selectedTabTitle } );
                selectedTab.api( selection[ 0 ], selectedTabTitle, null, null, context ).then( output => {
                    updateSelectionSummaryContext( output );
                } );
            }
        } else {
            updateSelectionSummaryContext();
        }
    };

    let pwaEditContext = context ? context.editContext : '';
    if( !pwaEditContext || pwaEditContext === '' ) {
        pwaEditContext = 'TABLE_CONTEXT';
    }

    let pwaEditHandler = editHandlerService.getEditHandler( pwaEditContext );

    if( !pwaEditHandler || !pwaEditHandler.editInProgress() ) {
        editHandlerService.leaveConfirmation().then( function() {
            return handleTabChange();
        } );
    } else {
        return handleTabChange();
    }
};

export const updateSelection = ( selection ) => {
    return Array.isArray( selection ) ? selection : [ selection ];
};

export const getContext = ( vmDef, props, data ) => {
    return [ new DerivedStateResult( {
        ctxParameters: [],
        additionalParameters: [ data.summaryContext, props.selection, props.context, props.selectionData ],
        compute: () => {
            return {
                activeTab: data.summaryContext ? data.summaryContext.activeTab : undefined,
                selection: Array.isArray( props.selection ) ? props.selection : [ props.selection ],
                context: props.context,
                api: data.summaryContext ? data.summaryContext.api : undefined,
                selectionData: props.selectionData
            };
        }
    } ) ];
};

const clearSelectionData = ( selectionData ) => {
    if( selectionData && selectionData.getValue() && selectionData.getValue().selected && selectionData.getValue().selected.length > 0 ) {
        selectionData.update( { selected: [], relationInfo: [] } );
    }
};

const getTabsState = ( tabsConfig ) => {
    if( tabsConfig ) {
        return ( tabsConfig.tabs || [] ).reduce( ( acc, tab ) => {
            let visibleWhenCondition = {};
            if( tab.visibleWhen && tab.visibleWhen.condition ) {
                visibleWhenCondition = _.get( tabsConfig, tab.visibleWhen.condition );
            } else {
                visibleWhenCondition.expression = tab.visibleWhen;
            }
            const conditionDeps = [ parseCondition( visibleWhenCondition, [ 'selection', 'context' ] ) ];
            return {
                ctxParameters: _.uniq( concat( flatten( conditionDeps.map( x => x.ctxParameters ) ), acc.ctxParameters ) ),
                additionalParameters: _.uniq( concat( acc.additionalParameters, flatten( conditionDeps.map( x => x.additionalParameters ) ) ) )
            };
        }, {
            ctxParameters: [],
            additionalParameters: []
        } );
    }
    return {
        ctxParameters: [],
        additionalParameters: []
    };
};

export const getVisibleTabs = ( vmDef, props, data ) => {
    let { context, tabsConfig, selection, additionalParameters, ctxParameters } = props;
    let localSelection = Array.isArray( selection ) ? selection : [ selection ];
    const getAllVisibleTabs = () => {
        let allVisibleTabs = [];
        if( tabsConfig ) {
            tabsConfig.tabs.map( ( tab ) => {
                let tabClone = { ...tab };
                if( conditionFilter( tabClone, tabsConfig, localSelection, context ) ) {
                    allVisibleTabs.push( tabClone );
                }
            } );
        }
        if( allVisibleTabs ) {
            return allVisibleTabs;
        }
    };
    const scope = {
        context,
        selection
    };
    const getFromProps = ( path ) => _.get( scope, path );
    const localAdditionalParameters = additionalParameters.map(
        getFromProps );

    return new DerivedStateResult( {
        ctxParameters,
        additionalParameters: localAdditionalParameters,
        compute: getAllVisibleTabs
    } );
};
