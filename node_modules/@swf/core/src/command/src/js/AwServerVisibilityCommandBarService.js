// Copyright (c) 2021 Siemens
/* eslint-disable sonarjs/no-duplicate-string */

/**
 * @module js/AwServerVisibilityCommandBarService
 */
import AwCommandBar from 'viewmodel/AwCommandBarViewModel';
import AwPopupCommandBar from 'viewmodel/AwPopupCommandBarViewModel';
import AwStateService from 'js/awStateService';
import AwToolbar from 'viewmodel/AwToolbarViewModel';
import DataLoader from 'dataloader';
import Debug from 'debug';
import appCtxSvc from 'js/appCtxService';
import cdm from 'soa/kernel/clientDataModel';
import dms from 'soa/dataManagementService';
import { DerivedStateResult } from 'js/derivedContextService';
import { createComponent } from 'js/declViewModelService';
import { debounce, forEach, uniq, includes, replace } from 'lodash';
import { registerDynImportEntry } from 'js/moduleLoader';

registerDynImportEntry( 'js/AwServerVisibilityCommandBarService', () => import( 'js/AwServerVisibilityCommandBarService' ) );

const trace = new Debug( 'command:tcCommandVisibilityService2' );

/**
 * Get the selection information for SOA input
 *
 * @param {Object[]} selection Currently selected objects
 * @param {Object} parentSelection Parent selection
 * @param {Boolean} istcgql Whether currently in GraphQL sublocation
 * @return {Object[]} Current selection information
 */
const getSelectionInfo = function( selection = [], parentSelection = null, istcgql = false ) {
    if( parentSelection && parentSelection.uid === cdm.NULL_UID ) {
        parentSelection = null;
    }
    var soaMOs = [];
    var isTCGQL = istcgql;
    forEach( selection, function( selectedObj ) {
        var mo = cdm.getObject( selectedObj.uid );
        if( mo ) {
            soaMOs.push( mo );
        } else {
            if( isTCGQL ) {
                soaMOs.push( selectedObj );
            }
        }
    } );
    var selInfo = [];
    if( soaMOs.length ) {
        var primarySelection = {
            contextName: '',
            parentSelectionIndex: parentSelection ? 1 : -1,
            selectedObjects: soaMOs
        };

        selInfo.push( primarySelection );
    }
    if( parentSelection ) {
        var pmo = cdm.getObject( parentSelection.uid );
        if( pmo ) {
            selInfo.push( {
                contextName: '',
                parentSelectionIndex: -1,
                selectedObjects: [ parentSelection ]
            } );
        }
    }
    return selInfo;
};

/**
 * Get the command information for SOA input
 *
 * @param {List<String>} commandIds Specific IDs to include in the call instead of all commands
 * @return {Object[]} Command info
 */
const getCommandInfo = function( commandIds ) {
    return uniq( commandIds ).sort().map( function( commandId ) {
        return {
            commandCollectionId: '',
            commandId
        };
    } );
};

/**
 * Command context parameter for the current XRT page
 */
const XRT_PAGE_ID = 'ActiveXrtPageId';

/**
 * Prefix use for any URL parameters included in command context
 */
const URL_PARAMETER_PREFIX = 'UrlParameter_';

/**
 * Get the selection information for SOA input
 *
 * @param {Boolean} aw_hosting_enabled Whether currently in hosted mode
 * @param {String} aw_host_type The current host type
 * @param {String[]} commandContextParameters List of URL parameters to include in command context
 * @param {Object} processedState The current state parameters
 * @return {Object[]} The current command context
 */
const getCommandContext = function( aw_hosting_enabled = false, aw_host_type = '', commandContextParameters = [], processedState = {} ) {
    var hostingInfo = [ {
        contextName: 'IsHosted',
        contextValue: aw_hosting_enabled ? 'true' : 'false'
    }, {
        contextName: 'HostType',
        contextValue: aw_host_type
    } ];

    //uid is always included since many teams have used to avoid writing conditions against what is selected vs the opened object
    var urlInfo = commandContextParameters.concat( [ 'uid' ] ).map( function( param ) {
        if( includes( param, XRT_PAGE_ID ) ) {
            return {
                contextName: XRT_PAGE_ID,
                contextValue: replace( param, XRT_PAGE_ID + ':', '' )
            };
        }
        return {
            contextName: URL_PARAMETER_PREFIX + param,
            contextValue: processedState[ param ] || ''
        };
    } );

    return hostingInfo.concat( urlInfo );
};

/**
 * Create a cache map for the dataloader to use
 *
 * Something in the declarative framework breaks the native JS map, so reimplement with the same API
 *
 * @returns {Object} Plain object matching the API of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
 */
const getCacheMap = () => {
    const cache = {};
    return {
        get: k => cache[ k ],
        set: ( k, v ) => cache[ k ] = v,
        delete: k => delete cache[ k ],
        clear: () => {
            for( const k in cache ) {
                delete cache[ k ];
            }
        }
    };
};

/**
 * Get the current server visibility for the list of commands
 *
 * @param {[String]} commandIds Command IDs to load server visibility for
 * @param {Object} ctx The current context for loading
 * @returns {[Boolean]} True/false for each command ID
 */
export const getCurrentServerVisibility = async( commandIds, ctx ) => {
    const {
        sublocation: { clientScopeURI = '' },
        mselected,
        pselected,
        istcgql = false,
        ViewModeContext: { ViewModeContext },
        aw_hosting_enabled,
        aw_host_type,
        commandContextParameters,
        services: {
            awCommandVisibilityLoader
        }
    } = ctx;
    //Support for GraphQL based sublocations
    if( istcgql ) {
        const isSummaryHidden = ViewModeContext === 'TableView' || ViewModeContext === 'ListView' || ViewModeContext === 'ImageView';
        const selectObjUids = mselected.map( x => x.uid ).filter( x => x );
        const isMultiSelected = mselected.length > 1;
        if( selectObjUids.length > 0 && ( isSummaryHidden || isMultiSelected ) ) {
            dms.loadObjects( selectObjUids );
        }
    }
    const stateParameters = AwStateService.instance.params;
    let pselectedIn = appCtxSvc.getCtx( 'pselected' );
    const getVisibleCommandsInfo = {
        clientScopeURI,
        selectionInfo: getSelectionInfo( mselected, pselectedIn, istcgql ),
        commandContextInfo: getCommandContext( aw_hosting_enabled, aw_host_type, commandContextParameters, stateParameters ),
        commandInfo: getCommandInfo( commandIds )
    };
    trace( 'Loading visibility commands with given context information', commandIds, getVisibleCommandsInfo );
    const visibleCommandsInfo = await awCommandVisibilityLoader.load( getVisibleCommandsInfo );
    const visibleCommandIds = visibleCommandsInfo.map( x => x.commandId );
    return commandIds.map( id => visibleCommandIds.includes( id ) );
};

/**
 * Get a dataloader for command visibility based on the current selection
 *
 * @param {Object} param0 Render context
 * @param {[ViewModelObject]} mselected Selected objects from props
 * @param {ViewModelObject} pselected Parent selection from props
 * @param {Number} visibilityLoaderIdCounter Counter used to force refresh
 * @returns {DataLoader} Loader for command visibility
 */
export const getServerVisibilityLoader = ( {
    ctx
}, mselected, pselected, visibilityLoaderIdCounter ) => {
    //note: we could simply do { ...ctx, mselected, pselected } but other cosumers of this loader not refactored yet to use props
    ctx.mselected = mselected ? mselected : ctx.mselected;
    ctx.pselected = pselected ? pselected : ctx.pselected;
    trace( 'Previous visibility loader is stale, creating new loader', ctx, visibilityLoaderIdCounter );
    return new DataLoader( async commandIds => getCurrentServerVisibility( commandIds, ctx ), {
        cacheMap: getCacheMap()
    } );
};

/**
 * Get the derived state configuration for visibility loader
 *
 * @param {Object} vmDef View model
 * @param {Object} prop Current properties
 * @param {Object} data Current view model data
 * @returns {[DerivedStateResult]} Derived state configurations
 */
export const getDerivedVisibilityLoader = ( vmDef, prop, data ) => {
    return new DerivedStateResult( {
        ctxParameters: [
            'ViewModeContext.ViewModeContext',
            'services.awCommandVisibilityLoader',
            'aw_host_type',
            'aw_hosting_enabled',
            'commandContextParameters',
            'istcgql',
            'mselected',
            'pselected',
            'sublocation.clientScopeURI'
        ],
        additionalParameters: [ prop.mselected, prop.pselected, data.visibilityLoaderIdCount || 0 ],
        compute: getServerVisibilityLoader
    } );
};

/**
 * Counter used to force server visibilty reload. Increment method is debounced to avoid
 * multiple calls when a "cdm.relatedModified" is happening at the same time as "cdm.updated"
 *
 * @returns {Object} Counter object
 */
export const getForcedLoaderCounter = () => {
    trace( 'Initializing visibility loader counter' );
    return {
        count: 0,
        counter: {
            increment: debounce( x => {
                return x + 1;
            }, 100, {
                leading: true,
                trailing: false
            } )
        }
    };
};

/**
 * Check the event data to determine if a server visibility reload is necessary.
 * Will increment counter only if update is required
 *
 * @param {Object} eventData cdm.relatedModified or cdm.updated event data
 * @param {*} mselected The current selected objects
 * @param {*} count The current count
 * @param {*} counter The current counter
 * @returns {Object} Updated counter
 */
export const checkForRefresh = ( eventData, mselected = [], count, counter ) => {
    if( !counter ) {
        return count;
    }
    const mselectedUids = mselected.map( x => x.uid );
    const modifiedObjects = eventData.relatedModified || eventData.updatedObjects || [];
    if( eventData.relatedModified ) {
        trace( 'cdm.relatedModified', eventData.relatedModified );
    }
    if( eventData.updatedObjects ) {
        trace( 'cdm.updated', eventData.updatedObjects );
    }
    for( const mo of modifiedObjects ) {
        if( mselectedUids.includes( mo.uid ) ) {
            trace( 'Incrementing counter to force reload of server visibility', mo.uid );
            return {
                count: counter.increment( count )
            };
        }
    }
    return {
        count
    };
};

/**
 * Wrap the given component with Active Workspace specific server visibility logic
 *
 * addServerVisibility :: ( [DataLoader,...props] => JSX ) => ( [Object,Object,...props] => JSX )
 *
 * @param {Component} ChildComponent The component to wrap
 * @param {String} componentId ID of the component (will appear in dev tools)
 * @returns {Component} The wrapper component
 */
export const addServerVisibility = ( ChildComponent, componentId ) => {
    const ctxImportObj = { serverVisibilityLoader: getDerivedVisibilityLoader };
    //Generated view model JSON for wrapper component
    const declViewModelJson = {
        schemaVersion: '1.0.0',
        actions: {
            //Refresh action used to force visibility reload without selection change
            checkForRefresh: {
                actionType: 'JSFunction',
                method: 'checkForRefresh',
                deps: 'js/AwServerVisibilityCommandBarService',
                inputData: {
                    0: '{{data.eventData}}',
                    1: '{{props.mselected}}',
                    2: '{{data.visibilityLoaderIdCount}}',
                    3: '{{data.visibilityLoaderIdCounter}}'
                },
                outputData: {
                    //Increment counter to force recreation of dataloader, causing server visibility reload
                    visibilityLoaderIdCount: 'count'
                }
            },
            //Initializes the counter used to "force" server visibility reloads
            getForcedLoaderCounter: {
                actionType: 'JSFunction',
                method: 'getForcedLoaderCounter',
                deps: 'js/AwServerVisibilityCommandBarService',
                inputData: {},
                outputData: {
                    visibilityLoaderIdCount: 'count',
                    visibilityLoaderIdCounter: 'counter'
                }
            }
        },
        ctx: {
            //Use derived state to recreate a data loader whenever the relevant data (selection, etc) changes
            //Creation of new data loader triggers reload of server visibility
            serverVisibilityLoader: {
                parser: {
                    method: 'getDerivedVisibilityLoader',
                    deps: 'js/AwServerVisibilityCommandBarService'
                }
            },
            mselected: null,
            pselected: null
        },
        onEvent: [ {
            eventId: 'cdm.relatedModified',
            action: 'checkForRefresh',
            cacheEventData: true
        }, {
            eventId: 'cdm.updated',
            action: 'checkForRefresh',
            cacheEventData: true
        } ],
        props: {
            mselected: {
                type: 'object'
            },
            pselected: {
                type: 'viewModelObject'
            }
        },
        lifecycleHooks: {
            onMount: 'getForcedLoaderCounter'
        },
        _viewModelId: componentId,
        _uniqueViewModelId: componentId
    };
    const render = ( props ) => {
        const { ctx } = props;
        return <ChildComponent
            {...props}
            visibilityLoader={ctx.serverVisibilityLoader}
        ></ChildComponent>;
    };
    return createComponent( declViewModelJson, render, undefined, ctxImportObj );
};

/**
 * AW specific wrappers of the standard AwCommandBar, AwToolbar, AwPopupCommandBar
 *
 * Instead of a server visibility loader these components will have "mselected" and "pselected" props. They
 * will use those props to manage server visiiblity. If either one of those props is not provided the values
 * from ctx.mselected and ctx.pselected will be used instead
 */
export const AwServerVisibilityPopupCommandBar = addServerVisibility( AwPopupCommandBar, 'AwServerVisibilityPopupCommandBarImpl' );
export const AwServerVisibilityCommandBar = addServerVisibility( AwCommandBar, 'AwServerVisibilityCommandBarImpl' );
export const AwServerVisibilityToolbar = addServerVisibility( AwToolbar, 'AwServerVisibilityToolbarImpl' );

/**
 * Fake render function to support HTML view usage
 *
 * @param {Object} props props
 * @returns {Component} component
 */
export const renderCommandBar = ( props ) => {
    return <AwServerVisibilityCommandBar
        {...props}
    ></AwServerVisibilityCommandBar>;
};

/**
 * Fake render function to support HTML view usage
 *
 * @param {Object} props props
 * @returns {Component} component
 */
export const renderToolbar = ( props ) => {
    return <AwServerVisibilityToolbar
        {...props}
    ></AwServerVisibilityToolbar>;
};

/**
 * Fake render function to support HTML view usage
 *
 * @param {Object} props props
 * @returns {Component} component
 */
export const renderPopupCommandBar = ( props ) => {
    return <AwServerVisibilityPopupCommandBar
        {...props}
    ></AwServerVisibilityPopupCommandBar>;
};

