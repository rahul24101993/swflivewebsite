/* eslint-disable jsx-a11y/no-noninteractive-element-to-interactive-role */
// Copyright (c) 2020 Siemens
import AwExtendedTooltip from 'viewmodel/AwExtendedTooltipViewModel';
import AwIcon from 'viewmodel/AwIconViewModel';
import AwPic from 'viewmodel/AwPicViewModel';
import AwPopup from 'viewmodel/AwPopupViewModel';
import eventBus from 'js/eventBus';
import wcagService from 'js/wcagService';
import { DerivedStateResult } from 'js/derivedContextService';
import { assignWith, get } from 'lodash';
import { getStringBetweenDoubleMustaches } from 'js/parsingUtils';
import { DOMAPIs as dom } from 'js/domUtils';
import analyticsSvc from 'js/analyticsService';
import * as cas from 'js/centralAggregationService';

/**
 * TODO: Predictive UI
 *   - Why is command calling two apis on analytics service? Need to merge and split internally
 *   - Can move to creation of input to this component
 */

let popupRef = null;

/**
 * Method to publish analytics to server
 * @param {Object} command - command clicked by user
 * @param {String} parentId - command id of parent of the child command
 */
const publishAnalytics = ( command, parentId ) => {
     var sanPopupCmdLogData = {
        sanAnalyticsType: 'Popup Commands',
        sanCommandId: command.id,
        sanCommandTitle: command.title
    };
    analyticsSvc.logCommands( sanPopupCmdLogData );
};

/**
 * Component to render a command that has already been processed
 *
 * @param {*} param0 context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awCommandRenderFunction = ( {
    viewModel: { dispatch, data: { isCommandExecuting } },
    command,
    ctxMin: { commandClass },
    runActionWithViewModel,
    actions: { openCommandPopup },
    childCommandClickCallback,
    commandContext,
    visibilityLoader
} ) => {
    /**
     * Click handler for the command button
     *
     * @param {Event} e Click event
     */
    const executeCommand = async( e ) => {
        e.stopPropagation();
        if( command.enabled ) {
            eventBus.publish( 'removeMessages', {} );
            dispatch( { path: 'data.isCommandExecuting', value: true } );
            const result = await command.execute( runActionWithViewModel, commandContext );
            dispatch( { path: 'data.isCommandExecuting', value: false } );
            logUserGesture();
            if( command.hasPopup ) {
                const overrideOptions = result.inputData.options;
                openCommandPopup.show( {
                    ...overrideOptions,
                    context: getPopupContext( overrideOptions )
                } ).then( ( popup )=>{
                    popupRef = popup;
                } );
            }
            if( childCommandClickCallback ) {
                childCommandClickCallback( command.hasPopup );
            }
        }

        if( childCommandClickCallback ) {
            childCommandClickCallback( command.hasPopup );
        }
        publishAnalytics( command, getParentGroupId() );
    };

    const getParentGroupId = function() {
        let parentGroupId = '';
        if( commandContext && commandContext.command ) {
            parentGroupId = commandContext.command.id;
        }
        return parentGroupId;
    };

    const getSubject = function() {
        let subject = {};
        if( commandContext && commandContext.selectionData ) {
            let pselected = commandContext.selectionData.pselected ? commandContext.selectionData.pselected : '';
            let selected = commandContext.selectionData.selected ? commandContext.selectionData.selected : '';
            subject = { pselected: pselected, selected: selected };
        }
        return subject;
    };

    const logUserGesture = function() {
        let widgetInfo = {
            commandId: command.id,
            parentGroupId: getParentGroupId(),
            commandContext: commandContext
        };
        cas.notify( {
            widgetInfo: widgetInfo,
            userGesture: 'commandClick',
            subject: getSubject()
        } );
    };

    const getPopupContext = ( options )=>{
        const scope = { commandContext };
        let subPanelContext = assignWith( {}, options.subPanelContext, ( objValue, srcValue ) => {
            const path = getStringBetweenDoubleMustaches( objValue || srcValue );
            return get( scope, path );
        } );

        return {
            anchor: command.id,
            //TODO: Command context will need to be included in this also
            context: {
                command,
                ...commandContext
            },
            visibilityLoader,
            subPanelContext,
            childCommandClickCallback: ( hasPopup ) => {
                if( hasPopup ) {
                    return;
                }
                openCommandPopup.hide();
                closeAncestorMenus();
            }
        };
    };

    const closeAncestorMenus = ()=>{
        if( !popupRef ) { return; }
        let menu = popupRef.parentPopup;
        // if it's a nested menu
        while( menu && dom.get( '.aw-popup-command-bar', menu.panelEl ) ) {
            menu.hide();
            menu = menu.parentPopup;
        }
        popupRef = null;
    };

    const onKeyDownHandler = ( event ) => {
        if( wcagService.isValidKeyPress( event ) ) {
            event.preventDefault();
            executeCommand( event );
        } else {
            wcagService.handleMoveUpOrDown( event, event.currentTarget.parentElement.parentElement );
        }
    };

    // move to memo function?
    if( !command.icon ) {
        if( command.selected ) {
            command.icon = 'cmdCheckmark';
        } else {
            command.icon = 'cmdBlankIcon';
        }
    }

    return <>
        <li ref={openCommandPopup.reference}
            onKeyDown={onKeyDownHandler}
            onClick={executeCommand}
            button-id={command.id}
            command-id={command.id}
            data-command-id={command.id}
            className={commandClass}
            tabIndex={-1} //Programatically focusable but not naturally
            aria-label={command.title}
            title={command.extendedTooltip || command.description ? null : command.title}
            aria-disabled={isCommandExecuting || !command.enabled}
            role='button'
            aria-haspopup={command.hasPopup}>
            <div className='aw-popup-cellContentContainer'>
                <AwPic className='aw-widget-thumbnail' iconId={command.icon}></AwPic>
                { command.decorator && command.decorator.text && command.decorator.visibleWhen ?
                    <div className='aw-commands-cellDecorator'>
                        { command.decorator.className ?
                            <div className={command.decorator.className}>{command.decorator.text}</div>
                            : <div>{command.decorator.text}</div> }
                    </div>
                    : null }
                {command.title}
            </div>
            { command.hasPopup ?
                <div className='aw-widgets-groupCommandStack'>
                    <AwIcon iconId='miscDownArrow_uxRefresh'></AwIcon>
                </div>
                : null }
        </li>

        <AwPopup {...openCommandPopup.options} />
        <AwExtendedTooltip
            reference = { openCommandPopup.reference }
            extendedTooltipOptions = { { isCommand: true, alignment: 'VERTICAL' } }
            extendedTooltipContext = { command }
            extendedTooltip = { command.extendedTooltip } >
        </AwExtendedTooltip>
    </>;
};

/**
 * Get the classes to use for the button in AwCommand
 *
 * @param {Object} renderContext Component render context
 * @param {Boolean} selected Command selected state
 * @param {Boolean} enabled Command enabled state
 * @param {Boolean} hasPopup Command popup state
 * @param {Boolean} isCommandExecuting Whether the command is currently executing
 * @returns {String} The class to use
 */
const getCommandClass = ( renderContext, selected, enabled, hasPopup, isCommandExecuting, icon ) => {
    const classNames = [
        'sw-aria-border',
        'aw-widgets-cellListItem',
        'aw-widgets-cellTop',
        selected ? 'aw-state-selected' : null,
        enabled && !isCommandExecuting ? null : 'disabled',
        hasPopup ? 'aw-hierarchical-popup' : null
    ].filter( x => x );
    return classNames.join( ' ' );
};

/**
 * Parser to get the class to set on command
 *
 * @param {Object} vmDef View model definition
 * @param {Object} prop Current properties
 * @param {Object} data Current view model data
 * @returns {[DerivedStateResult]} Derived state configurations
 */
export const getCommandClassMemo = ( vmDef, prop, data ) => {
    return [ new DerivedStateResult( {
        ctxParameters: [],
        additionalParameters: [ prop.command.selected, prop.command.enabled, prop.command.hasPopup, data.isCommandExecuting, prop.command.icon ],
        compute: getCommandClass
    } ) ];
};
