// Copyright (c) 2020 Siemens

/**
 * @module js/AwCommandService
 */
import AwExtendedTooltip from 'viewmodel/AwExtendedTooltipViewModel';
import AwIcon from 'viewmodel/AwIconViewModel';
import AwPic from 'viewmodel/AwPicViewModel';
import AwPopup from 'viewmodel/AwPopupViewModel';
import eventBus from 'js/eventBus';
import { DerivedStateResult } from 'js/derivedContextService';
import { assignWith, get } from 'lodash';
import { getStringBetweenDoubleMustaches } from 'js/parsingUtils';
import analyticsSvc from 'js/analyticsService';
import * as cas from 'js/centralAggregationService';

/**
 * TODO: Predictive UI
 *   - Why is command calling two apis on analytics service? Need to merge and split internally
 *   - Can move to creation of input to this component
 */

/**
 * Method to publish analytics to server
 * @param {Object} command - command clicked by user
 */
 const publishAnalytics = ( command ) => {
    let commandLogData = {
        sanAnalyticsType: 'Commands',
        sanCommandId: command.id,
        sanCommandTitle: command.title
    };
    analyticsSvc.logCommands( commandLogData );
};
/**
 * Component to render a command that has already been processed
 *
 * @param {*} param0 context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awCommandRenderFunction = ( {
    visibilityLoader,
    viewModel: { dispatch, data: { isCommandExecuting } },
    command,
    commandContext,
    ctx,
    ctxMin: { commandClass },
    runActionWithViewModel,
    actions: { openCommandPopup },
    alignment,
    overflow = false
} ) => {
    /**
     * Click handler for the command button
     *
     * @param {Event} e Click event
     */
    const executeCommand = async( e ) => {
        e.stopPropagation();
        eventBus.publish( 'removeMessages', {} );
        dispatch( { path: 'data.isCommandExecuting', value: true } );
        const result = await command.execute( runActionWithViewModel, { ...commandContext, popupAction: openCommandPopup, event: e } );
        dispatch( { path: 'data.isCommandExecuting', value: false } );
        logUserGesture();
        publishAnalytics( command );

        if( command.hasPopup ) {
            const overrideOptions = result.inputData.options;
            openCommandPopup.show( {
                ...overrideOptions,
                placement: alignment === 'VERTICAL' ? 'left-start' : 'bottom-start',
                context: getPopupContext( overrideOptions )
            } );
        }
    };

    const getParentGroupId = function() {
        let parentGroupId = '';
        if( commandContext && commandContext.command ) {
            parentGroupId = commandContext.command.id;
        }
        return parentGroupId;
    };

    const getSubject = function() {
        let subject = {};
        if( commandContext && commandContext.selectionData ) {
            let pselected = commandContext.selectionData.pselected ? commandContext.selectionData.pselected : '';
            let selected = commandContext.selectionData.selected ? commandContext.selectionData.selected : '';
            subject = { pselected: pselected, selected: selected };
        }
        return subject;
    };

    const logUserGesture = function() {
        let widgetInfo = {
            commandId: command.id,
            parentGroupId: getParentGroupId(),
            commandContext: commandContext
        };
        cas.notify( {
            widgetInfo: widgetInfo,
            userGesture: 'commandClick',
            subject: getSubject()
        } );
    };

    const getTooltipPlacement = function() {
        var placement = 'top';
        if( alignment === 'VERTICAL' ) {
            placement = 'left';
        }
        return placement;
    };

    const getPopupContext = ( options ) => {
        const scope = { commandContext };
        let subPanelContext = assignWith( {}, options.subPanelContext, ( objValue, srcValue ) => {
            const path = getStringBetweenDoubleMustaches( objValue || srcValue );
            return get( scope, path );
        } );

        return {
            anchor: command.id,
            //TODO: Command context will need to be included in this also
            context: {
                command,
                ...commandContext
            },
            visibilityLoader,
            subPanelContext,
            childCommandClickCallback: ( hasPopup ) => {
                if( hasPopup ) {
                    return;
                }
                openCommandPopup.hide();
            }
        };
    };

    return (
        <div className={'aw-command'} ref={openCommandPopup.reference} title={command.extendedTooltip || command.description ? null : command.title}>
            <button type='button'
                //TODO: button-id vs command-id vs data-command-id - not clear why changed to commandId
                button-id={command.id}
                command-id={command.id}
                data-command-id={command.id}
                className={commandClass + ( openCommandPopup.open ? ' aw-state-selected' : '' )}
                disabled={isCommandExecuting || !command.enabled}
                aria-disabled={isCommandExecuting || !command.enabled}
                title={command.extendedTooltip || command.description ? null : command.title}
                aria-label={command.title}
                aria-haspopup={command.hasPopup}
                onClick={executeCommand}
                tabIndex={overflow ? -1 : 0}
            >
                <div className={getCommandIconClass( command.hasPopup )}>
                    <AwPic className='aw-commands-svg' iconId={command.icon}></AwPic>
                    { command.hasPopup ?
                        <div className='aw-widgets-groupCommandStack'>
                            <AwIcon iconId='miscDownArrow_uxRefresh'></AwIcon>
                        </div>
                        : null }
                    { command.decorator && command.decorator.text && command.decorator.text !== '{0}' && command.decorator.visibleWhen ?
                        <div className='aw-commands-cellDecorator'>
                            { command.decorator.className ?
                                <div className={command.decorator.className}>{command.decorator.text}</div>
                                : <div>{command.decorator.text}</div> }
                        </div>
                        : null }

                </div>
                <div className='aw-commands-showIconLabel aw-commands-commandIconButtonText'>{command.title}</div>
            </button>

            <AwPopup {...openCommandPopup.options}/>
            <AwExtendedTooltip
                reference={openCommandPopup.reference}
                extendedTooltipOptions={{ isCommand: true, placement : getTooltipPlacement() }}
                extendedTooltipContext={command}
                extendedTooltip={command.extendedTooltip}>
            </AwExtendedTooltip>
        </div>
    );
};

/**
 * Get the classes to use for the button in AwCommand
 *
 * @param {Object} renderContext Component render context
 * @param {String} commandId Command ID
 * @param {String} alignment Command bar alignment
 * @param {Boolean} selected Command selected state
 * @param {Boolean} enabled Command enabled state
 * @param {Boolean} isCommandExecuting Whether the command is currently executing
 * @returns {String} The class to use
 */
const getCommandClass = ( renderContext, commandId, alignment, selected, enabled, isCommandExecuting ) => {
    const classNames = [
        'aw-commands-commandIconButton',
        'aw-commands-command',
        `aw-commandId-${commandId}`,
        alignment === 'VERTICAL' ? 'aw-commands-commandWrapperVertical' : null,
        alignment === 'HORIZONTAL' ? 'aw-commands-commandWrapperHorizontal' : null,
        selected ? 'aw-state-selected' : null,
        enabled && !isCommandExecuting ? null : 'disabled'
    ].filter( x => x );
    return classNames.join( ' ' );
};

/**
 * Get the class to use on the command icon
 *
 * @param {Boolean} hasPopup Whether the command is a group
 * @returns {String} Class to use for command icon
 */
const getCommandIconClass = ( hasPopup ) => `aw-commandIcon${hasPopup ? ' aw-widgets-groupCommand' : ''}`;

/**
 * Parser to get the class to set on command
 *
 * @param {Object} vmDef View model definition
 * @param {Object} prop Current properties
 * @param {Object} data Current view model data
 * @returns {[DerivedStateResult]} Derived state configurations
 */
export const getCommandClassMemo = ( vmDef, prop, data ) => {
    return [ new DerivedStateResult( {
        ctxParameters: [],
        additionalParameters: [ prop.command.id, prop.alignment, prop.command.selected, prop.command.enabled, data.isCommandExecuting ],
        compute: getCommandClass
    } ) ];
};
