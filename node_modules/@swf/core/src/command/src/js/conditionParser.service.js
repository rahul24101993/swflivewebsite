// Copyright (c) 2021 Siemens

/**
 * @module js/conditionParser.service
 */
import _ from 'lodash';

/**
 * TODO: Parsing is most likely going to be expensive and happen every render. Caching should be safe as functions are pure.
 */

const reCTX = /\bctx\b/;
const reLead = /^[.[]/;
const reLeadDot = /^\./;
const reToStrip = /(\s*(\(|\)|===|!==|>|<|>=|<=|\|\||&&|}})\s*|\.(includes|indexOf|split|localeCompare|(start|end)sWith|to(Lower|Upper)Case)\()/;
const reCC = /(commandContext\.[a-zA-Z][.\w]*)(\W*|$)/g;
const reSV = /ctx\.(visibleServerCommands\.[a-zA-Z]\w*)(\W*|$)/g;

/**
 * Parse a string condition for a list of any ctx and other parameters involved in the evaluation of the condition
 *
 * @param {String} expression Declarative condition to parse
 * @returns {Object} String list of ctx dependencies and additional parameters being checked
 */
export const parseStringCondition = ( expression ) => {
    const ctxParameters = [];
    let m;
    for( const elem of expression.split( reCTX ) ) {
        if( reLead.test( elem ) ) {
            m = elem.replace( reLeadDot, '' ); // split leading dot if any
            m = m.split( reToStrip )[ 0 ]; // split on conditions & functions
            m = m.replace( /"/g, '\'' ); // use single quote to work with lodash toPath
            m = m.replace( /\[\s*/g, '[' ).replace( /\s*\]/g, ']' ); // remove spaces for left & right brackets to support _.toPath
            m = _.toPath( m );
            for( let ndx = 0; ndx < m.length; ndx++ ) {
                if( /(:|^\d+$)/.test( m[ ndx ] ) && ndx > 0 ) {
                    m.length = ndx;
                    break;
                }
            }
            ctxParameters.push( m.join( '.' ) );
        }
    }
    const commandContextParameters = parseRegex( reCC, expression );
    const visibilityParameters = parseRegex( reSV, expression );
    return {
        ctxParameters,
        additionalParameters: [ ...commandContextParameters, ...visibilityParameters ]
    };
};

export const parseStringConditionWithAdditionalKeys = ( expression, additionalKeys ) => {
    let { ctxParameters, additionalParameters } = parseStringCondition( expression );
    for( let key in additionalKeys ) {
        let additionalKeyRegex = new RegExp( '(' + additionalKeys[ key ] + '\\.[a-zA-Z][.\\w]*)(\\W*|$)', 'g' );
        additionalParameters = additionalParameters.concat( parseRegex( additionalKeyRegex, expression ) );
    }
    return { ctxParameters, additionalParameters };
};

const parseRegex = ( regex, expression ) => {
    const params = [];
    let m = regex.exec( expression );
    while( m ) {
        params.push( m[ 1 ] );
        m = regex.exec( expression );
    }
    return params;
};

/**
 * Parse an object condition for a list of any ctx and other parameters involved in the evaluation of the condition
 *
 * @param {String} expression Declarative condition to parse
 * @returns {Object} String list of ctx dependencies and additional parameters being checked
 */
export const parseObjectCondition = ( expression ) => {
    return [ ...Object.keys( expression ), ...Object.values( expression ) ]
        .map( parseExpression )
        .reduce( reduceParams, defaultParams );
};

const reduceParams = ( { ctxParameters, additionalParameters }, nxt ) => {
    return {
        ctxParameters: [ ...ctxParameters, ...nxt.ctxParameters ],
        additionalParameters: [ ...additionalParameters, ...nxt.additionalParameters ]
    };
};

const defaultParams = {
    ctxParameters: [],
    additionalParameters: []
};

export const parseObjectConditionWithAdditionalKeys = ( expression, additionalKeys ) => {
    return [ ...Object.keys( expression ), ...Object.values( expression ) ]
        .map( ( expr ) => parseExpressionWithAdditionalKeys( expr, additionalKeys ) )
        .reduce( reduceParams, defaultParams );
};

/**
 * Parse the expression of a declarative condition for any ctx dependencies
 *
 * @param {String} expression Condition expression
 * @returns {Object} String list of ctx dependencies and additional parameters being checked
 */
const parseExpression = ( expression ) => typeof expression === 'string' ? parseStringCondition( expression ) : parseObjectCondition( expression );

const parseExpressionWithAdditionalKeys = ( expression, additionalKeys ) => typeof expression === 'string' ? parseStringConditionWithAdditionalKeys( expression, additionalKeys ) :
    parseObjectConditionWithAdditionalKeys( expression, additionalKeys );

/**
 * Parse a condition for a list of any ctx and other parameters involved in the evaluation of the condition
 *
 * @param {Condition} condition Declarative condition to parse
 * @returns {Object} String list of ctx dependencies and additional parameters being checked
 */
export const parseCondition = ( condition, additionalKeys ) => {
    if( !condition || !condition.expression ) {
        return {
            ctxParameters: [],
            additionalParameters: []
        };
    }
    return additionalKeys ? parseExpressionWithAdditionalKeys( condition.expression, additionalKeys ) : parseExpression( condition.expression );
};
