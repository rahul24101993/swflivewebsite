/* eslint-disable valid-jsdoc */
// Copyright (c) 2020 Siemens

/**
 * Defines provider for commands from the View model definition
 *
 * @module js/commandConfigurationService
 */
import _, { uniqBy } from 'lodash';
import logger from 'js/logger';
import 'js/iconService';
import ccu from 'js/commandConfigUtils.service';
import { getStringBetweenDoubleMustaches } from 'js/parsingUtils';
import { getLocalizedText } from 'js/localeService';
import Debug from 'debug';
import debugService from 'js/debugService';
import conditionService from 'js/conditionService';
import htmlUtils from 'js/htmlUtils';
const trace = new Debug( 'command:AwCommandBar' );

//TODO: Global state that should not be managed in a service - revisit later
let dynamicPlacements = [];
const handlerCache = {};
const getHandlersForCommand = ( id, commandsViewModel, useCache ) => {
    if( !handlerCache[ id ] || !useCache ) {
        handlerCache[ id ] = Object.entries( commandsViewModel.commandHandlers )
            .filter( ( [ , v ] ) => v.id === id );
    }
    return handlerCache[ id ];
};

const DeclarativeCondition = function( condition, commandsViewModel ) {
    this.id = condition.split( '.' ).slice( -1 )[ 0 ];
    this.expression = ccu.getConditionExpression( commandsViewModel, condition );
};

const getHandlerAction = ( handler, commandsViewModel, { isRibbon } ) => {
    if( isRibbon ) {
        //Ribbon commands use their configured action or open popup with child commands if not configured
        return commandsViewModel.actions[ handler.action || 'openCommandGroup' ];
    }
    if( handler.action ) {
        //Base commands use their configured action
        return commandsViewModel.actions[ handler.action ];
    }
    return null;
};

/**
 * Command handler information from commandsViewModel
 *
 * Will be used by AwCommand to setup any necessary hooks and process
 */
const CommandHandler = function( id, handler, commandsViewModel, definition ) {
    // String :: ID of the command handler
    this.id = id;
    // DeclarativeCondition :: Active condition for this handler
    this.activeWhen = new DeclarativeCondition( handler.activeWhen.condition, commandsViewModel );
    // Number :: Priority of the command handler (length of the activeWhen condition)
    this.priority = ccu.getExpressionLength( this.activeWhen.expression, commandsViewModel );
    // DeclarativeCondition :: Enabled state condition for this handler
    this.enableWhen = handler.enableWhen ? new DeclarativeCondition( handler.enableWhen.condition, commandsViewModel ) : null;
    // DeclarativeCondition :: Selected state condition for this handler
    this.selectWhen = handler.selectWhen ? new DeclarativeCondition( handler.selectWhen.condition, commandsViewModel ) : null;
    // DeclarativeCondition :: Visibility condition for this handler
    this.visibleWhen = handler.visibleWhen ? new DeclarativeCondition( handler.visibleWhen.condition, commandsViewModel ) : null;

    /**
     * The action that this handler will execute
     */
    this.action = getHandlerAction( handler, commandsViewModel, definition );

    /**
     * Callback function to execute this command handler
     *
     * @param {Function} runActionWithViewModel Magic function to run an action in a specific view model
     * @returns {CommandExecutionResult}
     */
    this.execute = async( runActionWithViewModel, scope, commandContext ) => {
        scope.commandContext = commandContext || scope.commandContext;
        return runActionWithViewModel( commandsViewModel, handler.action, scope );
    };
};

/**
 * The raw data from commands view model that will be used to determine the current command state
 */
export const CommandOverlay = function( {
    id,
    handlers,
    title,
    selectedTitle,
    icon,
    selectedIcon,
    decorator,
    extendedTooltip,
    selectedExtendedTooltip,
    description,
    selectedDescription,
    type,
    children,
    showGroupSelected = true,
    cellDisplay
} ) {
    // String! :: ID of the command
    this.id = id;

    // [CommandHandler] :: Handlers for this command
    this.handlers = handlers;

    // I18nReference :: Title definition of the command
    this.title = title;
    this.selectedTitle = selectedTitle;

    // String :: ID of the command icon
    this.icon = icon;
    this.selectedIcon = selectedIcon;
    this.decorator = decorator;
    this.extendedTooltip = extendedTooltip;
    this.selectedExtendedTooltip = selectedExtendedTooltip;
    this.description = description;
    this.selectedDescription = selectedDescription;
    this.type = type;

    this.children = children;

    this.showGroupSelected = showGroupSelected;
    this.cellDisplay = cellDisplay;

    this.trace = new Debug( `command:${id}` );
    this.trace( 'Overlay created', this );
};

/**
 * Get the i18n string configured in the given view model
 *
 * TODO: Pretty generic, probably already a function somewhere that can be reused
 *
 * @param {String} key Key within the i18n section
 * @param {Object} viewModel View model json
 * @returns {String} The localized text value
 */
const getI18nValue = async( key, viewModel ) => {
    const resource = viewModel.i18n[ key ] ? viewModel.i18n[ key ][ 0 ] : '';
    return getLocalizedText( resource, key );
};

/**
 * Resolve an i18n reference
 *
 * TODO: Pretty generic, probably already a function somewhere that can be reused
 *
 * @param {String|Object} i18nRef Reference information
 * @param {Object} viewModel View model json
 * @returns {Object} The string value and a list of any parameters it may have
 */
const resolveI18n = async( i18nRef, viewModel ) => {
    if( typeof i18nRef === 'string' ) {
        const reference = getStringBetweenDoubleMustaches( i18nRef );
        const value = reference.startsWith( 'i18n.' ) ? await getI18nValue( reference.slice( 5 ), viewModel ) : reference;
        return {
            value,
            parameters: []
        };
    }
    if( typeof i18nRef === 'object' ) {
        const { value } = await resolveI18n( i18nRef.text, viewModel );
        return {
            value,
            parameters: i18nRef.params || i18nRef.parameters
        };
    }
    return null;
};

/**
 * Get the type of a command
 *
 * @param {Object} definition Command definition
 * @returns {String} Command type
 */
const getCommandType = definition => {
    if( definition.isShuttle ) {
        return 'SHUTTLE';
    }
    if( definition.isRibbon ) {
        return 'RIBBON';
    }
    if( definition.isGroup ) {
        return 'GROUP';
    }
    if( definition.isToggle ) {
        return 'TOGGLE';
    }
    return 'BASE';
};

/**
 * Get a command overlay
 *
 * @param {String} id ID of the command
 * @returns {CommandOverlay} Overlay for the command
 */
export const getCommand = async( id, useCache ) => {
    const commandsViewModel = await ccu.getCommandsViewModel();
    return getCommandInternal( id, commandsViewModel, null, useCache );
};

const getDecoratorObject = async( template, commandsViewModel ) => {
    const checkVisbleWhenConditionForConversion = ( visibleWhen ) => {
        if( visibleWhen && visibleWhen.condition ) {
            return visibleWhen.condition;
        }
        if( visibleWhen === false ) {
            return 'conditions.false';
        }
        return 'conditions.true';
    };

    let value = getStringBetweenDoubleMustaches( template.text );
    if( value.startsWith( 'i18n.' ) ) {
        return {
            text: await resolveI18n( template.text, commandsViewModel ),
            visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,
            class: template.class ? template.class : null
        };
    }

    return {
        text: {
            value: '{0}',
            parameters: [ template.text ]
        },
        visibleWhen: typeof template.visibleWhen !== undefined ? new DeclarativeCondition( checkVisbleWhenConditionForConversion( template.visibleWhen ), commandsViewModel ) : null,
        class: template.class ? template.class : null
    };
};

/**
 * Load the necessary data to create a CommandOverlay and return it
 *
 * @param {String} id ID of the command
 * @param {Object} commandsViewModel Commands view model json
 * @param {Object} placement (Optional) Placement information
 */
const getCommandInternal = async( id, commandsViewModel, placement = null, useCache = true ) => {
    const definition = commandsViewModel.commands[ id ];
    if( !definition ) {
        logger.error( `Missing command definition for ${id}` );
    }
    const type = getCommandType( definition );

    const handlers = type === 'GROUP' || type === 'SHUTTLE' ? [ new CommandHandler( 'GroupCommandHandler', {
        activeWhen: {
            condition: 'conditions.true'
        },
        action: 'openCommandGroup'
    }, commandsViewModel, definition ) ] : getHandlersForCommand( id, commandsViewModel, useCache )
        .map( ( [ handlerId, value ] ) => new CommandHandler( handlerId, value, commandsViewModel, definition ) )
        .sort( ( a, b ) => b.priority - a.priority );

    const icon = definition.iconId;
    const selectedIcon = definition.selected ? definition.selected.iconId : null;

    //TODO: Some stuff (i18n) may need to be resolved here
    const extendedTooltip = definition.extendedTooltip;
    const selectedExtendedTooltip = definition.selected && definition.selected.extendedTooltip ? definition.selected.extendedTooltip : null;

    const [ title, selectedTitle, description, selectedDescription, decorator ] = await Promise.all( [
        resolveI18n( definition.title, commandsViewModel ),
        definition.selected && definition.selected.title ? resolveI18n( definition.selected.title, commandsViewModel ) : null,
        definition.description ? await resolveI18n( definition.description, commandsViewModel ) : null,
        definition.selected && definition.selected.description ? resolveI18n( definition.selected.description, commandsViewModel ) : null,
        definition.template && definition.template.text ? getDecoratorObject( definition.template, commandsViewModel ) : null
    ] );

    const children = type === 'GROUP' || type === 'SHUTTLE' ? await getCommands( id ) : [];

    return new CommandOverlay( {
        showGroupSelected: !placement || placement.showGroupSelected !== false,
        id,
        handlers,
        title,
        selectedTitle,
        icon,
        selectedIcon,
        decorator,
        extendedTooltip,
        selectedExtendedTooltip,
        description,
        selectedDescription,
        type,
        children,
        cellDisplay: placement ? placement.cellDisplay : null
    } );
};

/**
 * Sort the placements based on relativeTo and priority. Priority is 0 if not set.
 *
 * @param {[CommandPlacement]} placements - placements
 * @return {[CommandPlacement]} Sorted list of command placements
 */
const sortPlacements = function( placements ) {
    // Assign a priority to any placement that doesn't have one
    placements.forEach( function( cmd ) {
        cmd.priority = cmd.priority || 0;
    } );

    // Split based on whether placement is relative or absolute
    const p = _.partition( placements, function( cmd ) {
        return cmd.relativeTo;
    } );
    // Sort the commands with only priority
    const priorityCommands = _.sortBy( p[ 1 ], 'priority' );

    // Group the relative commands by the relativeTo property
    const allRelativeCmds = _.groupBy( p[ 0 ], 'relativeTo' );

    const commandsWithRelativeAdded = priorityCommands.reduce( ( acc, placement ) => {
        // Split into before / after based on negative / positive priority
        const p2 = _.partition( allRelativeCmds[ placement.id ] || [], function( cmd ) {
            return cmd.priority > 0;
        } );
        const afterPlacements = _.sortBy( p2[ 0 ], 'priority' );
        const beforePlacements = _.sortBy( p2[ 1 ], 'priority' );
        //side effect, could be refactored later
        delete allRelativeCmds[ placement.id ];
        return [ ...acc, ...beforePlacements, placement, ...afterPlacements ];
    }, [] );

    //Add any placement with relativeTo that is not in this command bar to the end
    return Object.values( allRelativeCmds ).reduce( ( acc, missingRelativeSet ) => {
        logger.debug( `Unable to find relative command ${missingRelativeSet[0].id}. Commands will be placed at end of list.`, missingRelativeSet );
        return [ ...acc, ...missingRelativeSet ];
    }, commandsWithRelativeAdded );
};

/**
 * Get the commands for the given anchor
 *
 * @param {String} anchor anchor
 * @returns {[CommandOverlay]} Command overlays for the anchor
 */
export const getCommands = async( anchor, useCache ) => {
    const commandsViewModel = await ccu.getCommandsViewModel();
    const anchors = anchor.split( ',' );
    const allPlacements = [ ...dynamicPlacements, ...Object.values( commandsViewModel.commandPlacements ) ];
    const placements = uniqBy( anchors.reduce( ( fullPlacementList, nextAnchor ) => {
        const newPlacements = allPlacements
            .filter( placement => !placement.parentGroupId && placement.uiAnchor === nextAnchor && commandsViewModel.commands[ placement.id ] );
        return [ ...fullPlacementList, ...newPlacements ];
    }, [] ), 'id' );

    let placementsSorted = sortPlacements( placements );


    const commands = await Promise.all( placementsSorted.map( placement => getCommandInternal( placement.id, commandsViewModel, placement, useCache ) ) );
    if( anchor ) {
        debugService.debugGetCommandsForAnchor( anchor, commands );
        debugService.reduceData( anchor, commands );
    }
    return commands;
};

/**
 * Add a placement for a command at runtime. All placements
 * must be defined before the AwCommandBar with the matching
 * anchor is rendered
 *
 * @param {[CommandPlacement]} placements Placements to add
 * @returns {Object} Tracking information to all for removal of the placements
 */
export const addPlacements = ( placements ) => {
    trace( 'Dynamic placements added', placements );
    dynamicPlacements = [ ...dynamicPlacements, ...placements ];
    return {
        placements,
        remove: () => {
            dynamicPlacements = dynamicPlacements.filter( x => !placements.includes( x ) );
            trace( 'Dynamic placements removed', placements );
        }
    };
};

/**
 * Get the commandContext of a given command bar/group
 *
 * @param {String} grpCmdAnchor - the group id/anchor for a given command group
 * @param {String} commandBarAnchor - the anchor for a given command bar
 * @returns {Object} commandContext for given command group or command bar
 */
export const getCommandContext = function( grpCmdAnchor, commandBarAnchor ) {
    let commandBarXPath = `//div[contains(@class, 'aw-command-bar') and @anchor='${grpCmdAnchor ? grpCmdAnchor : commandBarAnchor}']`;
    let commandBar = htmlUtils.getElementByXpath( commandBarXPath, document.body );
    if( commandBar ) {
        const key = Object.keys( commandBar ).find( key => {
            return key.startsWith( '__reactFiber$' );
        } );
        const commandBarFiber = commandBar[ key ];
        if( commandBarFiber.return.memoizedProps.commandContext ) {
            return commandBarFiber.return.memoizedProps.commandContext;
        }
        // get parent toolbar which has command context
        let toolbarFiber = commandBarFiber.return;
        while( typeof toolbarFiber.type === 'string' ) {
            toolbarFiber = toolbarFiber.return;
        }
        return toolbarFiber.return.memoizedProps.commandContext;
    }
    return null;
};


/**
 * Given the array of handlers for a command get the activeHandler
 *
 * @param {Array<Handler>} handlers - array of command handlers
 * @param {Object} scope - evaluation scope
 * @returns {Handler} the active handler
 */
export const getActiveCommandHandler = function( handlers, scope ) {
    for( const handler of handlers ) {
        const isActive = Boolean( conditionService.evaluateCondition( {}, handler.activeWhen.expression, scope ) );
        if( isActive ) {
            return handler;
        }
    }
    return null;
};

/**
 * Check whether a command is enabled and visible
 *
 * @param {Object} activeHandler - active command handler
 * @param {Object} scope - evaluation scope
 * @returns {Boolean} visbleWhen and enableWhen
 */
export const getCommandAndCheckVisibility = function( activeHandler, scope ) {
    const visibleWhen =  activeHandler.visibleWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.visibleWhen.expression, scope ) ) : true;
    const enableWhen = activeHandler.enableWhen ? Boolean( conditionService.evaluateCondition( {}, activeHandler.enableWhen.expression, scope ) ) : true;
    return visibleWhen && enableWhen;
};

export default {
    getCommand,
    getCommands,
    getCommandContext,
    getActiveCommandHandler,
    getCommandAndCheckVisibility
};
