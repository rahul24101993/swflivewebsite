// Copyright (c) 2021 Siemens

/**
 * Defines provider for commands from the View model definition
 * A set of utilities and methods related to processing and modifying the commadns view model
 *
 * @module js/commandConfigUtils.service
 */
import configurationService from 'js/configurationService';
import { getRealExpression } from 'js/conditionService';
import _, { get, isObject, isString, isArray, mapValues, cloneDeepWith } from 'lodash';
import logger from 'js/logger';
import Debug from 'debug';
const trace = new Debug( 'command:AwCommandBar' );

/** Regular Expression for the condition prefix in the expression. */
const conditionRE = /\bconditions\b\./;

/**
 * Get the conditions with any condition reuse within string expressions expanded
 *
 * @param {Object} viewModelJson View model with conditions to expand
 * @returns {Object} Processed condition expressions
 */
const getExpandedConditionExpressions = function( viewModelJson ) {
    const stringExpandedConditions = mapValues( viewModelJson.conditions, condition => {
        if( isString( condition.expression ) ) {
            //simple expansion of string conditions
            return {
                ...condition,
                expression: getRealExpression( condition.expression, viewModelJson )
            };
        }
        if( isObject( condition.expression ) ) {
            //recurse through object and expand any referenced string conditions
            return cloneDeepWith( condition, ( value ) => {
                if( isObject( value ) && value.$source && conditionRE.test( value.$source ) ) {
                    const refExpression = getRealExpression( value.$source, viewModelJson );
                    return isString( refExpression ) ? {
                        ...value,
                        $source: refExpression,
                        __useSourceParsing: true
                    } : value;
                }
            } );
        }
        return condition;
    } );
    const tempVm = {
        conditions: stringExpandedConditions
    };
    const checkObjectCondition = ( condition, shouldRecurse ) => {
        if( isObject( condition ) && condition.$source && conditionRE.test( condition.$source ) ) {
            const eqCheck = get( condition, '$query.$eq' );
            const neCheck = get( condition, '$query.$ne' );
            const refExpression = getRealExpression( condition.$source, tempVm );
            if( eqCheck === true || neCheck === false ) {
                //for true just swap original condition into same place
                //need to restart recursion for new object to ensure and "conditions.x" included in it are updated
                const newValue = cloneDeepWith( refExpression, expandObjectConditions );
                trace( 'Expanded object condition', condition, newValue );
                return newValue;
            }
            if( eqCheck === false || neCheck === true ) {
                //for false wrap with a $not
                const newValue = {
                    $not: cloneDeepWith( refExpression, expandObjectConditions )
                };
                trace( 'Expanded object condition', condition, newValue );
                return newValue;
            }
            logger.warn( 'Condition reuse only supports boolean checks', condition );
        }
        return shouldRecurse ? cloneDeepWith( condition, expandObjectConditions ) : condition;
    };
    const expandObjectConditions = ( value ) => {
        if( isArray( value ) ) {
            return value.map( x => checkObjectCondition( x, true ) );
        }
        const newVal = checkObjectCondition( value );
        if( newVal !== value ) {
            //don't return if not modifying anything, will stop recursion for the current object
            return newVal;
        }
    };
    return cloneDeepWith( stringExpandedConditions, expandObjectConditions );
};

/**
 * Convert every placement that has "parentGroupID" into a placement with
 * a dynamically generated anchor based on parent
 *
 * Dirty - modifies input
 *
 * @param {Object} viewModelJson View model json to modify
 */
const addChildPlacements = function( viewModelJson ) {
    for( const [ placementID, placement ] of Object.entries( viewModelJson.commandPlacements ) ) {
        if( placement.parentGroupId ) {
            viewModelJson.commandPlacements[ `$$${placementID}${placement.parentGroupId}` ] = {
                id: placement.id,
                priority: placement.priority,
                relativeTo: placement.relativeTo,
                uiAnchor: placement.parentGroupId
            };
        }
    }
};

/**
 * Ensure the primary commandsViewModel has all of the expected properties
 *
 * Dirty - modifies input
 *
 * @param {Object} viewModelJson View model json to modify
 */
const ensureProps = function( viewModelJson ) {
    [ 'actions', 'commandHandlers', 'commandPlacements', 'commands', 'conditions', 'messages' ].forEach( function( k ) {
        viewModelJson[ k ] = viewModelJson[ k ] || {};
    } );
    [ 'onEvent' ].forEach( function( k ) {
        viewModelJson[ k ] = viewModelJson[ k ] || [];
    } );
};

/**
 * Convert "true" and "false" shortcuts into actual conditions
 *
 * Dirty - modifies input
 *
 * @param {Object} viewModelJson View model json to modify
 * @param {Object} commandHandlers Command handlers to modify
 */
export const updateShortConditions = function( viewModelJson, commandHandlers ) {
    const trueCondition = {
        condition: 'conditions.true'
    };
    const falseCondition = {
        condition: 'conditions.false'
    };
    for( const handler of Object.values( commandHandlers ) ) {
        [ 'activeWhen', 'visibleWhen', 'selectWhen', 'enableWhen' ].forEach( function( conditionKey ) {
            if( handler[ conditionKey ] === true ||
                _.get( handler, [ conditionKey, 'condition' ] ) === true ) {
                handler[ conditionKey ] = trueCondition;
            } else if( handler[ conditionKey ] === false ||
                _.get( handler, [ conditionKey, 'condition' ] ) === false ) {
                handler[ conditionKey ] = falseCondition;
            }
        } );
    }
    viewModelJson.conditions.true = {
        expression: 'true'
    };
    viewModelJson.conditions.false = {
        expression: 'false'
    };
};

/**
 * Convert "title": "{{ctx.previousLocationDisplayName }}" to parameter format
 *
 * Dirty - modifies input
 *
 * @param {Object} viewModelJson View model json to modify
 */
const updateShortCommandTitles = function( viewModelJson ) {
    for( const command of Object.values( viewModelJson.commands ) ) {
        if( command.title && typeof command.title === 'string' && ( command.title.startsWith( '{{ctx' ) || command.title.startsWith( '{{commandContext' ) ) ) {
            command.title = {
                text: '{0}',
                params: [ command.title ]
            };
        }
    }
};

let viewModelJsonCache = null;
const setCommandsViewModelCache = ( newCache ) => {
    viewModelJsonCache = newCache;
};

/**
 * Get and pre process the commands view model from config service
 * @param {boolean} clearCache true if to clear any commandsViewModelCache
 * @returns {Promise<Object>} promise resolved with the commands view model (plain object)
 */
const getCommandsViewModel = async function( clearCache = false ) {
    if( viewModelJsonCache && !clearCache ) {
        return viewModelJsonCache;
    }
    let viewModelJson = await configurationService.getCfg( 'commandsViewModel' );
    ensureProps( viewModelJson );
    const expandedConditions = getExpandedConditionExpressions( viewModelJson );
    viewModelJson.conditions = expandedConditions;
    addChildPlacements( viewModelJson );
    updateShortConditions( viewModelJson, viewModelJson.commandHandlers );
    updateShortCommandTitles( viewModelJson );
    setCommandsViewModelCache( viewModelJson );
    return viewModelJson;
};

/**
 * Get all matches of a regex in the given string
 *
 * @param {RegExp} re Regex to used
 * @param {String} s String to search
 * @returns {Array<String>} List of all matches
 */
const getAllMatches = function( re, s ) {
    var result = [];
    var m = re.exec( s );
    while( m ) {
        result.push( m[ 1 ] );
        m = re.exec( s );
    }
    return result;
};

const conditionsRE = /conditions\.([a-zA-Z]\w*)(\W*|$)/g;

/**
 * Get all nested conditions from a condition expression. See unit tests for examples.
 *
 * @param {String|Object} s condition expression
 * @returns {String[]} nested conditions
 */
const getConditions = function( s ) {
    if( typeof s === 'string' ) {
        return getAllMatches( conditionsRE, s );
    }
    if( typeof s === 'object' ) {
        return Object.keys( s ).map( k => s[ k ] ) //Object.values( s ) if not for IE11
            .reduce( ( acc, nxt ) => acc.concat( getConditions( nxt ) ), [] );
    }
    return [];
};

/**
 * Utility to get the actual condition expression from the commands view model
 *
 * @param {Object} commandsViewModel The commands view model
 * @param {String} condition The conditon name ("conditions.asdf")
 * @returns {String|Object} The condition expression (string or object)
 */
const getConditionExpression = function( commandsViewModel, condition ) {
    var conditionName = condition.split( '.' )[ 1 ];
    var expression = _.get( commandsViewModel, `_internal.conditions.${conditionName}.expression`, null ) ||
        _.get( commandsViewModel, `conditions.${conditionName}.expression`, null );
    if( expression === null ) {
        //If condition does not exist return "false" to avoid console errors (same behavior)
        logger.error( `Reference to missing condition "${conditionName}"` );
        expression = 'false';
    }
    return expression;
};

/**
 * Recurses into the object and sub objects and finds real length of the expression by replacing the
 * references to other condition.xyz conditions
 *
 * @param {Object|String} expression expression whose actual length is desired
 * @param {Object} internalViewModel Object holding all expression definitions
 * @returns {Number} the length of the expression
 */
const getExpressionLength = function( expression, internalViewModel ) {
    var sum = function( a, b ) {
        return a + b;
    };
    if( typeof expression === 'string' ) {
        return expression.length;
    }
    return _.map( expression, function( value, key ) {
        if( key === '__useSourceParsing' ) {
            return 0;
        }
        var length = String( key ).length;
        if( value && _.isString( value ) ) {
            var nestedConditions = getConditions( value );
            if( nestedConditions.length > 0 ) {
                var nestedConditionLength = nestedConditions.map( function( condName ) {
                    return getExpressionLength( getConditionExpression( internalViewModel, 'conditions.' + condName ), internalViewModel );
                } ).reduce( sum );
                return length + nestedConditionLength;
            }
            return length + String( value ).length;
        }
        if( _.isObject( value ) ) {
            return length + getExpressionLength( value, internalViewModel );
        }
        return length + String( value ).length;
    } ).reduce( sum );
};

const exports = {
    updateShortConditions,
    getCommandsViewModel,
    getConditions,
    getConditionExpression,
    getExpressionLength
};
export default exports;
