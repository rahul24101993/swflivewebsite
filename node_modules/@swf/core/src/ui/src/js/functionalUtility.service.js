// Copyright (c) 2020 Siemens

/**
 * Defines provider for commands from the View model definition
 *
 * @module js/functionalUtility.service
 */

/**
 * Service to define some common functional utilities that are not available natively in Javascript
 *
 * The functions in this service support currying unless otherwise noted. See
 * https://www.sitepoint.com/currying-in-functional-javascript/ for more information.
 *
 * The unit tests provide example usages of these functions
 */
let exports = {};

/**
 * Reducer function to convert a list of strings into a object based map
 *
 * toBooleanMap : (Map Boolean, String) -> Map Boolean
 */
export let toBooleanMap = function toBooleanMap( acc, nxt ) {
    acc[ nxt ] = true;
    return acc;
};

/**
 * Get a property from an object.
 *
 * getProp : String -> Object -> a
 */
export let getProp = function getProp( propName ) {
    return function getPropInner( obj ) {
        return obj[ propName ];
    };
};

/**
 * Retrieve a value from the given map
 *
 * fromMap : Map a -> String -> a
 */
export let fromMap = function fromMap( map ) {
    return function fromMapInner( val ) {
        return map[ val ];
    };
};

/**
 * Identity function
 *
 * identity : a -> a
 */
export let identity = function identity( x ) {
    return x;
};

/**
 * Combine two lists
 *
 * concat : (List a, List a) -> List a
 */
export let concat = function concat( acc, nxt ) {
    return acc.concat( nxt );
};

/**
 * Use lazy compute and memoization for a property
 *
 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/XPCOMUtils.jsm#defineLazyGetter()
 *
 * @param {Object} aObject Object with the property
 * @param {String} aName Name of the property
 * @param {Function} aLambda Function to get the property value
 */
export const defineLazyGetter = ( aObject, aName, aLambda ) => {
    Object.defineProperty( aObject, aName, {
        get: function() {
            // Redefine this accessor property as a data property.
            // Delete it first, to rule out "too much recursion" in case aObject is
            // a proxy whose defineProperty handler might unwittingly trigger this
            // getter again.
            delete aObject[ aName ];
            let value = aLambda.apply( aObject );
            Object.defineProperty( aObject, aName, {
                value,
                writable: true,
                configurable: true,
                enumerable: true
            } );
            return value;
        },
        configurable: true,
        enumerable: true
    } );
};

exports = {
    toBooleanMap,
    getProp,
    fromMap,
    identity,
    concat,
    defineLazyGetter
};
export default exports;
