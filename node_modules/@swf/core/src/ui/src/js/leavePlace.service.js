// Copyright (c) 2020 Siemens

/**
 * Defines the {@link NgServices.leavePlaceService}
 *
 * @module js/leavePlace.service
 */
import logger from 'js/logger'; // => 'afx/src/kernel/src/js/logger'
import _ from 'lodash';
import eventBus from 'js/eventBus';

// Service
import AwStateService from 'js/awStateService';
import AwPromiseService from 'js/awPromiseService';

var exports = {};

/**
 * The currently registered handler.
 *
 * @private
 * @member _registeredAppHandler
 * @memberOf NgServices.leavePlaceService
 */
let _registeredAppHandler = null;

let _eventSubscriptions = [];

export let reset = function() {
    _registeredAppHandler = null;

    // unsuscribe _eventSubscriptions if exists
    _eventSubscriptions.forEach( ( s ) => {
        eventBus.unsubscribe( s );
    } );

    _eventSubscriptions = [];
};

/**
 * Initialization function, sets up the transition lifecycle hooks.
 * If the hook is invoked and there is a registered handler then we save the navigation target, prevent the navigation
 * event, and invoke the handler which returns a promise. Once the handler is done, the promise continuation will
 * trigger navigation to the original target.
 *
 * @private
 * @function initializeRootScope
 * @memberOf NgServices.leavePlaceService
 * @param {Object} $rootScope - $rootScope
 */
export let loadConfiguration = function() {
    reset();
    let _persistAppHandler = false;
    /**
     * Register the onBefore transition lifecycle hook, which is invoked before a transition even begins.
     */
    AwStateService.instance.transitionHooks.onBefore( {}, ( transition ) => {
        if( isLocationChangeStartEvent( transition ) ) {
            return locationChangeStart( transition );
        }
        if( isStateChangeStartEvent( transition ) ) {
            return stateChangeStart( transition );
        }
    } );

    const locationChangeStart = ( transition ) => {
        const defer = AwPromiseService.instance.defer();
        if( _registeredAppHandler && !_persistAppHandler ) {
            let fromState = transition.from();
            let fromParams = transition.params( 'from' );
            let toState = transition.to();
            let toParams = transition.params();
            let options = transition.options();
            var targetNavDetails = {};
            targetNavDetails.toState = toState;
            targetNavDetails.toParams = toParams;
            targetNavDetails.options = options;

            // Functions to call after the okToLeave promise
            // okToLeaveSuccess must be set, okToLeaveFailure can be null
            let okToLeaveSuccess;
            let okToLeaveFailure;
            okToLeaveSuccess = () => {
                // navigate to the target state using the current transition instance
                transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,
                    targetNavDetails.options );
                return true;
            };

            okToLeaveFailure = () => {
                // Don't clear handler when the promise is rejected
                logger.trace( 'Prevented navigation to ', targetNavDetails );
                return true;
            };
            const { targetNavInfo, oldState, newState } = getOkToLeaveInfo( fromState, fromParams, toState, toParams );
            // Run the okToLeave handler
            return _registeredAppHandler.okToLeave( targetNavInfo, oldState, newState ).then( ( options ) => {
                // Clear the handler
                if( options && options.clearLeaveHandler === false ) {
                    _persistAppHandler = true;
                } else {
                    _registeredAppHandler = null;
                }
                return okToLeaveSuccess();
            }, okToLeaveFailure );
        }
        defer.resolve();
        _persistAppHandler = false;
        return defer.promise;
    };

    const stateChangeStart = ( transition ) => {
        const defer = AwPromiseService.instance.defer();
        if( _registeredAppHandler ) {
            let fromState = transition.from();
            let toState = transition.to();
            let toParams = transition.params();
            let options = transition.options();
            var targetNavDetails = {};
            targetNavDetails.toState = toState;
            targetNavDetails.fromState = fromState;
            targetNavDetails.toParams = toParams;
            targetNavDetails.options = options;

            // invoke the handler and setup up the promise continuation
            return _registeredAppHandler.okToLeave( targetNavDetails ).then(
                () => {
                    // clear the handler reference that ran to avoid recursion
                    _registeredAppHandler = null;
                    // navigate to the target state using the current transition instance
                    transition.router.stateService.go( targetNavDetails.toState, targetNavDetails.toParams,
                        targetNavDetails.options );
                    return true;
                },
                ( err ) => { // eslint-disable-line no-unused-vars
                    logger.trace( 'Prevented navigation to ', targetNavDetails );
                    return true;
                } );
        }
        defer.resolve();
        return defer.promise;
    };

    const getOkToLeaveInfo = ( fromState, fromParams, toState, toParams ) => {
        return {
            targetNavInfo: {},
            oldState: {
                params: fromParams,
                state: {
                    name: fromState.name
                }
            },
            newState: {
                params: toParams,
                state: {
                    name: toState.name
                }
            }
        };
    };
};

/**
 * Method used by application to create leave handler object from an api object that can perform the okToLeave check
 *
 * @function createAndRegisterLeaveHandler
 * @memberOf NgServices.leavePlaceService
 * @param {Object} api - The object for the leave handler. Must have a method "okToLeave" that is called with a
 *            promise when the user attempts to change location / state.
 */
export let createAndRegisterLeaveHandler = function( api ) {
    var leaveHandler = {
        api: api
    };

    leaveHandler.okToLeave = function() {
        var deferred = AwPromiseService.instance.defer();
        this.api.okToLeave( deferred );
        return deferred.promise;
    };

    exports.registerLeaveHandler( leaveHandler );
};

/**
 * Method used for service consumer to register their handler function. Upon navigation, the "okToLeave" function
 * will be invoked. The function must return a promise, and when the handler logic completes the promise should be
 * resolved to allow navigation to continue or rejected to prevent the navigation.
 *
 * @function registerLeaveHandler
 * @memberOf NgServices.leavePlaceService
 * @param {Object} handler - The leave handler Object function. Must have a "okToLeave" property which returns a
 *            promise.
 */
export let registerLeaveHandler = function( handler ) {
    if( handler && !handler.okToLeave ) {
        logger.error( 'Leave place handler', handler, 'does not have okToLeave property' );
    } else {
        _registeredAppHandler = handler;
    }
};

/**
 * Method used for deregister a given leave handler
 *
 * @function deregisterLeaveHandler
 * @memberOf NgServices.leavePlaceService
 * @param {Object} handler - The leave handler to deregister
 */
export let deregisterLeaveHandler = function( handler ) {
    if( handler === _registeredAppHandler ) {
        _registeredAppHandler = null;
    }
};

export let isLocationChangeStartEvent = function( transition ) {
    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {
        return false;
    }
    // page refresh case
    if( transition.from().url === '^' && transition.from().name === '' ) {
        return false;
    }
    //invoke locationChangeStart logic if state has NOT changed but url has changed due to changed params
    if( _.isEqual( transition.from().name, transition.to().name ) && !_.isEqual( transition.params( 'from' ), transition.params( 'to' ) ) ) {
        return true;
    }
    return false;
};

export let isStateChangeStartEvent = function( transition ) {
    if( _.isUndefined( transition ) || _.isEmpty( transition ) ) {
        return false;
    }
    // page refresh case
    if( transition.from().url === '^' && transition.from().name === '' ) {
        return false;
    }
    if( !_.isEqual( transition.from().name, transition.to().name ) ) {
        return true;
    }
    return false;
};

exports = {
    reset,
    loadConfiguration,
    createAndRegisterLeaveHandler,
    registerLeaveHandler,
    deregisterLeaveHandler,
    isLocationChangeStartEvent,
    isStateChangeStartEvent
};
export default exports;

loadConfiguration();
