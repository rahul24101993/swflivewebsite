// Copyright (c) 2020 Siemens

/**
 * Defines {@link tabOverflowService} which manages tabs.
 *
 * @module js/tabOverflowService
 */

/**
 * Tab Overflow Service to manage tabs.
 */
let exports = {};

/**
 * Checks if overflow occurred on the specified tab on the tab container.
 *
 * The closure function arguments:
 * @param {Element} tabContainerElem the command bar element
 * @param {String} tabContainerAlignment the command bar alignment
 * @param {Element} tabElem the command element to check overflow.
 *                  Optional, if not specified, will check the last command element in command container.
 * @returns {Boolean} A boolean telling whether overflow occurred or not.
 */
export let hasOverflowForTabs = ( tabContainerElem, tabContainerAlignment, tabElem ) => {
    let propName = tabContainerAlignment === 'HORIZONTAL' ? 'offsetTop' : 'offsetLeft';
    var tabElement = tabElem;
    if( !tabElement ) {
        let currentTabElems = tabContainerElem ? tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' ) : undefined;
        tabElement = currentTabElems ? currentTabElems[ currentTabElems.length - 1 ] : undefined;
    }

    //We just check the element's offsetTop against the container's offset top to determine if there's an overflow
    if( !tabContainerElem || !tabElement ) {
        return false;
    }

    return tabElement[ propName ] > tabContainerElem[ propName ];
};

/**
 * Calculate the tab overflow break point in tabs et. The closure function
 *
 * The closure function arguments:
 * @param {Number} tabContainerElem the reference of the tab container element
 * @param {String} tabContainerAlignment the alignment of tab container
 * @returns {Function} the function to calculate command overflow break point.
 */
export let overflowBreakPointCalculatorForTabs = function() {
    var tabElems;
    var breakIndex = 0;

    return function( tabContainerElem, tabContainerAlignment ) {
        if( !tabContainerElem ) {
            return breakIndex;
        }

        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );

        breakIndex = tabElems.length;
        for( var i = tabElems.length - 1; i >= 0; i-- ) {
            // find the first tab which doesn't have overflow in reverse order
            if( !hasOverflowForTabs( tabContainerElem, tabContainerAlignment, tabElems[ i ] ) ) {
                breakIndex = i + 1;
                break;
            }
        }

        return breakIndex;
    };
};

export let updateTabIndexOnOverflow = function( tabContainerElement, tabContainerAlignment ) {
    let tabElements = tabContainerElement.querySelectorAll( '.sw-tabContainer >.sw-tab' );
    for( var i = tabElements.length - 1; i >= 0; i-- ) {
        var tabElementAnchor = tabElements[ i ].querySelector( 'a:not(.disabled)' );
        if( tabElementAnchor ) {
            if( hasOverflowForTabs( tabContainerElement, tabContainerAlignment, tabElements[ i ] ) ) {
                tabElementAnchor.setAttribute( 'tabindex', -1 );
            } else {
                tabElementAnchor.setAttribute( 'tabindex', 0 );
            }
        }
    }
};

/**
 * Evaluate if the total tabs width along with padding is greater than available container client width
 *
 * The closure function arguments:
 * @param {Object} tabContainerElem the reference of the tab container element.
 * @param {Array} tabElems the tab elements.
 * @param {Number} tabPadding the tab padding.
 * @returns {Boolean} true / false depending on width comparison.
 */
const isTabsOverflown = function( tabContainerElem, tabElems, tabPadding ) {
    let totalWidth = 0;
    for( var i = 0; i < tabElems.length; i++ ) {
        totalWidth += tabElems[ i ].getClientRects()[ 0 ].width + tabPadding;
    }
    return Math.round( totalWidth ) > tabContainerElem.clientWidth;
};

/**
 * Calculate the tab overflow break point in tabs et. The closure function
 *
 * The closure function arguments:
 * @param {Number} tabContainerElem the reference of the tab container element
 * @param {String} tabContainerAlignment the alignment of tab container
 * @returns {Function} the function to calculate command overflow break point.
 */
export let calculateBreakIndex = function() {
    var tabElems;
    var breakIndex = 0;

    return function( tabsModelForContainer, tabContainerElem, selectedTabModel ) {
        if( !tabContainerElem ) {
            return breakIndex;
        }

        tabElems = tabContainerElem.querySelectorAll( '.sw-tabContainer>.sw-tab' );
        let arr = [ ...tabElems ];
        var tabPadding = 16;

        if( selectedTabModel && isTabsOverflown( tabContainerElem, arr, tabPadding ) ) {
            let selectedTabObject = arr.find( ( element ) => {
                const anchor = element.getElementsByTagName( 'a' )[ 0 ];
                if( anchor ) {
                    return anchor.getAttribute( 'name' ) === String( selectedTabModel.pageId );
                }
                return false;
            } );

            let initialTabPadding = 16;
            let totalWidth = 0;
            if( selectedTabObject ) {
                totalWidth = selectedTabObject.getClientRects()[ 0 ].width + tabPadding + initialTabPadding;
            }

            for( var i = 0; i < tabsModelForContainer.length; i++ ) {
                let currentTabObject = arr.find( ( element ) => {
                    const anchor = element.getElementsByTagName( 'a' )[ 0 ];
                    if( anchor ) {
                        return anchor.getAttribute( 'name' ) === String( tabsModelForContainer[ i ].pageId );
                    }
                    return false;
                } );
                if( currentTabObject ) {
                    totalWidth += currentTabObject.getClientRects()[ 0 ].width + tabPadding;
                }

                if( totalWidth > tabContainerElem.clientWidth ) {
                    breakIndex = i;
                    break;
                }
            }

            return breakIndex;
        }
    };
};

exports = {
    overflowBreakPointCalculatorForTabs,
    hasOverflowForTabs,
    updateTabIndexOnOverflow,
    calculateBreakIndex
};
export default exports;
