// Copyright (c) 2021 Siemens

/**
 * @module js/atomicDataService
 */
import _ from 'lodash';

/**
 * @param {*} stateObject The stateobject inside atomic data section of viewmodel.
 * @param {*} metaObj The meta object for the same
 * @param {*} rootPath The name of the state object inside atomicdata.
 * @param {*} createField the function to create field objects
 * @returns
 */
export const createFieldsBasedOnMetaData = function( stateObject, metaObj, rootPath, createField ) {
    let atomicFields = {};
    const fieldsPath = [];
    fieldsPath.push( rootPath );
    parseMetaForFieldsPath( metaObj );
    validateObjWithMetaObjAndCreateFields( stateObject );
    let rootField = createField( '', rootPath, 'partialField' );
    atomicFields = { ...rootField, ...atomicFields };

    /**
     *
     * @param {*} propName
     * @param {*} basePath
     * @returns
     */
    function parsePath( propName, basePath ) {
        let path;
        if( basePath ) {
            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;
        } else {
            path = propName;
        }
        return path;
    }

    /**
     *
     * @param {*} metaObj
     * @param {*} rootPath
     */
    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {
        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {
            if( propName === 'field' || propName === 'type' ) {
                return undefined;
            }
            let path = parsePath( propName, basePath );
            fieldsPath.push( `${rootPath}.${path}` );
            if( _.isObject( propValue ) ) {
                parseMetaForFieldsPath( propValue, path );
            }
            return undefined;
        } );
        return undefined;
    }
    /**
     *
     * @param {*} obj
     * @param {*} metaObj
     * @param {*} basePath
     */
    function validateObjWithMetaObjAndCreateFields( currStateObj, basePath ) {
        _.forEach( currStateObj, function( propValue, propName ) {
            let path = parsePath( propName, basePath );
            const metaPathMatcher = path.replace( /\d+/g, '0' ); // This is just to match with schema
            const isFieldObject = _.indexOf( fieldsPath, `${rootPath}.${metaPathMatcher}` ) !== -1;
            const fieldType = _.get( metaObj, `${metaPathMatcher}.type`, 'partialField' );
            const isLeafLevelFieldObj = isFieldObject && fieldType !== 'partialField';
            if( isFieldObject ) {
                let atomicField = createField( path, rootPath, fieldType );
                if( _.isArray( propValue ) ) {
                    let fieldsObj = atomicField;
                    atomicField = [ ...propValue ];
                    _.assign( atomicField, fieldsObj );
                } else if( _.isObject( propValue ) && !isLeafLevelFieldObj ) {
                    _.assign( atomicField, propValue );
                }
                if( fieldType === 'partialField' ) {
                    Object.defineProperty( atomicField, 'getValue', { enumerable: false } );
                    Object.defineProperty( atomicField, 'value', { enumerable: false } );
                    Object.defineProperty( atomicField, 'update', { enumerable: false } );
                }
                _.set( atomicFields, path, atomicField );
            } else {
                //workaround to handle 'Categorization.category' as a prop name
                if( !Number.isInteger( propName ) && propName.includes( '.' ) ) {
                    path = path.replace( '.' + propName, `['${propName}']` );
                }
                // If only raw data (read only), then set it without generating any field.
                _.set( atomicFields, path, _.get( currStateObj, propName ) );
            }
            // If the data path is not specified in the meta section, that means there no point of un-necessary recusing it.
            // It would save lot of un-necessary recursions.
            // If current propValue is of type "Meta" and fieldType === 'FieldObject', then only traverse inside.
            // If the fieldType is of type "field" or "VMP", no need to traverse the object inside.
            /**
             *  Two Important cases
             * 1. Current Object (propValue) is not of type "Field" i.e not in meta, this means all down ward objects are also not fields
             *  Hence, no need to traverse inside it.
             *
             * 2. Current Object (propValue) is of type field more specifically 'partialField', then we need to traverse inside it,
             * but if the propValue is of type "field" but not 'partialField' ( ie. full fledged Field Object), this means it the end of
             * hierarchy (leaf leavel Field Node), no need to traverse inside it.
             * no need to go inside.
             */
            if( _.isObject( propValue ) && isFieldObject && !isLeafLevelFieldObj ) {
                validateObjWithMetaObjAndCreateFields( propValue, path );
            }
        } );
    }
    return atomicFields;
};
