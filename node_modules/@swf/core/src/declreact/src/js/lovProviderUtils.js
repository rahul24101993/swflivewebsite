// Copyright (c) 2021 Siemens

/**
 * @module js/lovProviderUtils
 */
import { useEffect, useRef } from 'react';
import appCtxSvc from 'js/appCtxService';
import { useInitHook } from 'js/reactHelper';
import { useDataProvider } from 'js/dataProviderUtils';
import { loadAction, validateLovAction, createDynamicDataProvider } from 'js/dataProviderFactory';

/**
 *  This particular hook is specific to dynamic dataprovider for LOV means not applicable for static dataprovider LOVS
 * @param {} dataProvider
 * @param {*} viewModel
 */
const useDynamicDataProviderForLOV = ( dataProvider, viewModel, prop ) => {
    dataProvider.vmCollectionObj = useDataProvider( dataProvider ).vmCollectionObj;
    // align dataCtxNode , check declViewModelProcessingFactory.js L216
    let initial = { data: viewModel };
    let dataCtxNode = useRef( initial );

    // dataCtxNode should be reactive,
    // ref issue: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/887
    // update the viewModel and prop accordingly
    dataCtxNode.current.data = viewModel;
    if( prop ) {
        dataCtxNode.current.parameters = { prop };
    }

    useEffect( () => {
        if( !dataProvider.loadAction && !dataProvider.validateLovAction ) {
            dataProvider.loadAction = async( vmCollection, startIndex, pageObject ) => {
                return loadAction( dataProvider, dataCtxNode.current, vmCollection, startIndex, pageObject );
            };
            dataProvider.validateLovAction = async( input ) => {
                return validateLovAction( input, dataProvider, dataCtxNode.current );
            };
        }
        return () => {
            if( dataProvider ) {
                dataProvider.destroy();
            }
        };
    }, [] );
};

const useDataProviderInLovPopup = ( prop ) => {
    //OnMount
    let currentLovEntry = null;
    let dataProvider = prop.dataProvider;
    /**
     * This ref brings mutually exclusive behavior between init and useEffect hook.
     * It prevents multiple REST calls.
     */
    let exclusiveHook = useRef( {} );
    let lovConfig = useRef( {} );
    currentLovEntry = {
        propDisplayValue: prop.field.fielddata.uiValue,
        propInternalValue: prop.field.typex === 'DATETIME' || prop.field.typex === 'DATE' ? Date.parse( prop.field.value ) : String( prop.field.value )
    };

    // If the LOV type is checkbox array , then the UI value is never updated manually.
    // It is updated by selecting on the checkbox.
    // Hence, we never need to do the filtering.
    // For checkboxarray lov filtering is done from another textbox which appears inside the LOV popup.
    // So, added a check to make sure filtering never changes for checkbox array LOVs.
    let filterString = prop.staticFilterStr;
    lovConfig.current = { filterString };
    useInitHook( () => {
        if( dataProvider ) {
            exclusiveHook.current = { isExecuted: true };
            dataProvider.resetDataProvider( {} );
            dataProvider.selectionModel.setSelection( currentLovEntry );

            // TODO: how to support auto focus selection??
            // reset attention
            prop.selectIndex && ( prop.selectIndex.current = null );

            let lovInfo = {
                ctxLovPropName: prop.field.name,
                ctxLovPropVMO: prop.field.vmo
            };
            appCtxSvc.registerCtx( 'aw.lovInfo', lovInfo );
        }
    } );
    useEffect( () => {
        let timeout = setTimeout( () => {
            if( dataProvider && !exclusiveHook.current.isExecuted ) {
                // reset attention
                prop.selectIndex && ( prop.selectIndex.current = null );
                dataProvider.resetDataProvider();
            }
        }, 500 );
        return () => {
            exclusiveHook.current = { isExecuted: false };
            clearTimeout( timeout );
        };
    }, [ dataProvider, lovConfig.current.filterString ] );
};

export const useLOVs = ( fields, prop, viewModel, { elementRefList } = {} ) => {
    // useInit( () => {
    //     if( viewModel.data.name === 'dataProviderLOV' ) {
    //         useDynamicDataProviderForLOV( dataProvider, viewModel, prop );
    //     }
    // });
    let lovEntryRef = useRef( null );
    if( prop.lovlist ) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useDataProviderInLovPopup( prop );
    }
    if( viewModel.data.name === 'dataProviderLOV' ) {
        let dataProvider = prop.fielddata.dataProvider ? prop.fielddata.dataProvider : elementRefList.get( 'dynDataprovider' ).current;
        if( !dataProvider ) {
            dataProvider = prop.isListbox ? createDynamicDataProvider( 1 ) : createDynamicDataProvider();
            elementRefList.get( 'dynDataprovider' ).current = dataProvider;
        }
        if( dataProvider.getLovEntryRef() === null ) {
            dataProvider.setLovEntryRef( lovEntryRef );
        }
        //The hook is being called conditionally since it is only supposed to be invoked for dynamic dataproviders
        //It is made sure that the dataprovider is always available before this stage
        //thereby providing a gaurantee that the hooks will always be invoked in the same order for a particular component
        if( dataProvider.dynamicDp ) {
            // eslint-disable-next-line react-hooks/rules-of-hooks
            useDynamicDataProviderForLOV( dataProvider, viewModel, prop );
        }
    }
};

export default {
    useLOVs
};
