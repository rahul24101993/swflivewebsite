/* eslint-disable complexity */
// Copyright (c) 2020 Siemens

/**
 * This module is part of declarative UI framework and provides DeclViewModel processing functionalities.
 *
 * @module js/declViewModelProcessingFactory
 *
 * @namespace viewModelProcessingFactory
 */
import _ from 'lodash';
import viewModelSvc from 'js/viewModelService';
import { loadAction, validateLovAction } from 'js/dataProviderFactory';
import { processGrids } from 'js/gridProviderUtils';
import syncStrategySvc from 'js/syncStrategyService';
import {
    evalDataDefinition,
    cloneDeepJsonObject
} from 'js/declReactUtils';

import conditionService from 'js/conditionService';
import modelPropertySvc from 'js/modelPropertyService';
import { composeDispatch } from 'js/store';
import declUtils from 'js/declUtils';
import { shouldCreateViewModelProperty, initViewModel } from 'js/viewModelProcessingFactory';
import { defineLazyGetter } from 'js/functionalUtility.service';
import debugService from 'js/debugService';
import dataProviderService from 'js/declDataProviderService';
import declDragAndDropService from 'js/declDragAndDropService';

/**
 * create data instance from data definition
 * @param {JSON} dataDef data section definition
 * @param {object} scope scope to resolve expression in data definiton like {{ctx.a}} or {{i18n.b}}
 * @param {object} vmDef viewModel template
 * @param {object} subPanelContext subPanelContext
 * @param {object} props props value
 * @returns {object} data object
 */
function createData( dataDef = {}, scope, vmDef, subPanelContext, props ) {
    const filteredDataDef = {};
    // This would filter out the atomic object from the data.
    const dataKeys = Object.keys( dataDef ).filter( ( keyName ) => !_.has( dataDef, `${keyName}.meta` ) );
    dataKeys.forEach( ( key ) => filteredDataDef[ key ] = dataDef[ key ] );
    const data = scope ? evalDataDefinition( filteredDataDef, scope ) : cloneDeepJsonObject( filteredDataDef );

    /**
     * Recursively initialize the property values of the given JSON data object with the current value of any bound
     * appContext properties (bound via {{ctx.*}}).
     */
    initViewModel( data, subPanelContext, props );

    // Assume all root value witout _ is vmo prop
    for( const prop in data ) {
        if( prop === 'objects' ) {
            data[ prop ] = vmDef[ prop ];
            continue;
        }
        if( prop === 'uid' ) {
            vmDef.vmo = vmDef.attachModelObject( data[ prop ] );
            continue;
        }
        if( !shouldCreateViewModelProperty( data[ prop ] ) ) {
            continue;
        }

        let propAttrHolder = declUtils.buildPropHolder( data[ prop ] );

        /**
         * Make sure we have a 'propName' set.
         */
        if( !data[ prop ].propName ) {
            data[ prop ].propName = prop;
        }

        // If this is not a view model prop, just save the object to the data.
        if( _.isEmpty( propAttrHolder ) ) {
            data[ prop ] = vmDef[ prop ];
            continue;
        }
        if( !prop.startsWith( '_' ) && typeof data[ prop ] === 'object' ) {
            let vmProp = modelPropertySvc.createViewModelProperty( data[ prop ] );
            if( !declUtils.isNil( data[ prop ].uiValue ) ) {
                vmProp.uiValue = data[ prop ].uiValue;
            }

            if( !declUtils.isNil( data[ prop ].dbValue ) ) {
                vmProp.dbValue = data[ prop ].dbValue;
            }

            if( dataDef[ prop ].dataProvider ) {
                // we have an lov, but the api is defined using the dataProvider
                vmProp.dataProvider = dataDef[ prop ].dataProvider;
                vmProp.hasLov = true;
                vmProp.emptyLOVEntry = dataDef[ prop ].emptyLOVEntry;
            }
            data[ prop ] = vmProp;
        }
    }

    // do init hook her if needed
    // vmDef.executeHook( 'onInit', props, [ data ], ctxHook );
    return data;
}

/**
 * create lifecycle hook based on action map
 * @param {Object} lifecycleHookDefs life cycle hook definition
 * @param {Object} actions action map
 * @returns {object} lifecyclehook callback map
 */
function createLifecycleHooks( lifecycleHookDefs = [], actions ) {
    let hooksActionsMap = {};
    _.forEach( lifecycleHookDefs, ( actionName, hookName ) => {
        // Map onInit hook to onMount - This would not work when we have have both onInit and onMount
        // defined for a component.onInit would never get a chance to get invoked.
        //hookName = hookName === 'onInit' ? 'onMount' : hookName;
        if( Array.isArray( actionName ) ) {
            hooksActionsMap[ hookName ] = [];
            _.forEach( actionName, function( actionObj ) {
                hooksActionsMap[ hookName ].push( actions[ actionObj.action ] );
            } );
        } else {
            if( !actions[ actionName ] && typeof Object ) {
                //Is mapped to an object with observer and action.
                hooksActionsMap[ hookName ] = actions[ actionName.action ];
            } else {
                hooksActionsMap[ hookName ] = actions[ actionName ];
            }
        }
    } );
    return hooksActionsMap;
}

/**
 * create valiation rule based on property definition
 * @param {JSON} props property definitions
 * @param {JSON} conds condition definitions
 * @returns {object} property validation objects
 */

/**
 * create view model factory based on declViewModelJson. Convert JSON def to a set of object and API
 * @param {JSON} declViewModelJson view model definition
 * @param {object} prop componet prop
 * @returns {object} view model factory
 */
export function createDeclViewModel( declViewModelJson, prop = {} ) {
    const { viewId, subPanelContext } = prop;
    declViewModelJson.data = declViewModelJson.data || {};

    const vmDef = viewModelSvc.populateViewModelPropertiesFromJson( declViewModelJson, null, null, null, null, subPanelContext );
    if( viewId ) {
        vmDef._internal.viewId = viewId;
    }
    // put declViewModelJson to vmDef
    vmDef.declViewModelJson = declViewModelJson;

    // build data creation function
    vmDef.createData = ( scope ) => createData( declViewModelJson.data, scope, vmDef, subPanelContext, prop );

    // create sync strategy ports
    vmDef.createPorts = () => {
        return cloneDeepJsonObject( declViewModelJson.ports );
    };

    vmDef.createFieldsData = () => {
        let initialState = {};
        for( const prop in declViewModelJson.data ) {
            if( declViewModelJson.data[ prop ] && declViewModelJson.data[ prop ].meta ) {
                initialState[ prop ] = declViewModelJson.data[ prop ].initialValues;
            }
        }
        return initialState;
    };

    vmDef.createDataProvider = () => {
        return vmDef.dataProviders;
    };

    //build LifecycleHooks
    vmDef.createLifecycleHooks = actions => createLifecycleHooks( declViewModelJson.lifecycleHooks, actions );

    // bind drag drop handler  with declViewModal

    declDragAndDropService.setupDragAndDropOnView( vmDef );

    return vmDef;
}

const bindActions = function( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel ) {
    viewModel.actions = _.mapValues( declViewModelJson.actions, actionDef => ( renderOptions ) => {
        let fields = dataCtxNode.getFields();
        // #49 - Side effect in example 'Notification Messages'
        Object.assign( dataCtxNode.data, getData() );
        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );
        fields && Object.assign( dataCtxNode, { fields } );

        if( renderOptions ) {
            //add the parameter here
            //add the function ref necessary to execute a command action programatically
            dataCtxNode.parameters = { ...renderOptions, commandActionExecutor: { runActionWithViewModel } };
        }
        return viewModelSvc.executeCommand( viewModel, actionDef.actionId, dataCtxNode );
    } );
};

const bindChartProvider = function( viewModel, vmDef, dataCtxNode ) {
    if( viewModel.chartProviders && !_.isEmpty( viewModel.chartProviders ) ) {
        _.mapValues( viewModel.chartProviders, function( chartProvider ) {
            if( chartProvider.loadDataAction ) {
                chartProvider.loadDataActionCallBack = () => {
                    return dataProviderService.executeLoadAction( vmDef.getAction( chartProvider.loadDataAction ), {}, dataCtxNode );
                };
            }
            if( chartProvider.selectAction ) {
                chartProvider.selectActionCallBack = ( selectedChartEntity ) => {
                    if( !dataCtxNode.parameters ) {
                        dataCtxNode.parameters = {};
                    }
                    dataCtxNode.parameters.selectedChartEntity = { ...selectedChartEntity };
                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.selectAction ).actionId, dataCtxNode );
                };
            }
            if( chartProvider.unSelectAction ) {
                chartProvider.unSelectedActionCallBack = ( unSelectedChartEntity ) => {
                    if( !dataCtxNode.parameters ) {
                        dataCtxNode.parameters = {};
                    }
                    dataCtxNode.parameters.unSelectedChartEntity = { ...unSelectedChartEntity };
                    return viewModelSvc.executeCommand( viewModel, vmDef.getAction( chartProvider.unSelectAction ).actionId, dataCtxNode );
                };
            }
        } );
    }
};

const bindDataProvider = function( viewModel, dataCtxNode, getData, getProps ) {
    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.loadAction = async( vmCollection, startIndex, pageObject ) => {
        Object.assign( dataCtxNode.data, getData() );
        getProps && Object.assign( dataCtxNode, { props: getProps(), getProps } );
        return loadAction( dataProvider, dataCtxNode, vmCollection, startIndex, pageObject );
    } );
};

const bindStaticDataProvider = function( viewModel, dataCtxNode ) {
    _.mapValues( viewModel.dataProviders, dataProvider => dataProvider.validateLovAction = async( input ) => {
        return validateLovAction( input, dataProvider, dataCtxNode );
    } );
};

/**
 * process vmDef, ctx and data to create view model instance
 * @param {object} vmDef view model definition
 * @param {Array} ctxHook react ctx hook in data-dispatch pair
 * @param {Array} dataHook  react data hook in dta-dispatch pair
 * @param {Array} portsHook  react data hook in portsHook pair
 * @param {object} allAtomicData  react dataProviders
 * @param {object} getProps getProps
 * @param {object} runActionWithViewModel callback function
 * @param {object} getFields getFields
 * @returns {object} view model instance
 */
export function processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData = {}, getProps, runActionWithViewModel, getFields ) {
    const [ ctx, updateCtx ] = ctxHook;
    const props = getProps ? getProps() : {};

    const [ data, updateData, getData ] = dataHook;
    const declViewModelJson = vmDef.declViewModelJson;
    let dispatchers = { ctx: updateCtx, data: updateData };

    debugService.debug( 'lifeCycles', vmDef._internal.panelId, 'init' );

    // fields data
    let atomicData = {};
    let updateAtomicData = {};
    let atomicDataHook = allAtomicData.atomicDataHook ? allAtomicData.atomicDataHook : {};

    const atomicDataHookKeys = Object.keys( atomicDataHook );
    _.forEach( atomicDataHookKeys, function( stateName ) {
        atomicData[ stateName ] = atomicDataHook[ stateName ][ 0 ];
        updateAtomicData[ stateName ] = allAtomicData.atomicDataRef[ stateName ].setAtomicData;
    } );

    // sync strategy port dispatcher
    let ports;
    let updatePorts;
    if( declViewModelJson.ports && portsHook ) {
        [ ports, updatePorts ] = portsHook;
        dispatchers.ports = updatePorts;
    }
    // dispatch method
    const { dispatch } = composeDispatch( dispatchers );

    const viewModel = {
        // store
        ctx,
        data,
        atomicData,
        updateAtomicData,
        atomicDataRef: allAtomicData.atomicDataRef,
        //subPanelContext
        subPanelContext: props.subPanelContext,

        // dispatch
        dispatch,

        // getData
        getData,

        // context for post eval
        conditions: {},
        expressions: {},
        oldExpressions: {},
        i18n: declViewModelJson.i18n,
        onEvent: declViewModelJson.onEvent,
        messages: declViewModelJson.messages,
        ports: ports
    };

    // revisitme - data (the section in the VM needs to be directly available on the viewModel)
    // not doing deep copy has side effects. This will be modified depending on the approach
    // that we take for deciding what is 'data' - viewModel section or entire viewModel as it used to be.
    _.assign( viewModel, vmDef );
    let dataObj = data;

    // We need deep copy for data providers.
    if( dataObj && dataObj.dataProviders ) {
        let dataObjDataProviders = dataObj.dataProviders;
        delete dataObj.dataProviders;
        for( const dpKey in dataObjDataProviders ) {
            if( viewModel.dataProviders && viewModel.dataProviders[ dpKey ] ) {
                _.assign( viewModel.dataProviders[ dpKey ], dataObjDataProviders[ dpKey ] );
            }
        }
    }

    // Not sure whether other portion of data needs deep copy. So not touching the same.
    _.assign( viewModel, dataObj );
    _.assign( viewModel, atomicData );
    let dataCtxNode = {
        props,
        data: viewModel,
        ctx,
        subPanelContext: props.subPanelContext,
        ports: viewModel.ports,
        getProps,
        getFields
    };

    // conditions
    //lazy evaluation for conditions/expressions - will not be evaluated until something tries to use it
    //forEach because closure is needed
    Object.entries( declViewModelJson.conditions || {} ).forEach( ( [ key, value ] ) => {
        defineLazyGetter( viewModel.conditions, key, () => conditionService.evaluateCondition( viewModel, value.expression, dataCtxNode ) );
        defineLazyGetter( viewModel.expressions, key, () => [ conditionService.parseExpression( viewModel, value.expression, dataCtxNode ) ] );
    } );

    // bind action
    bindActions( viewModel, declViewModelJson, dataCtxNode, getData, getProps, runActionWithViewModel );

    // grids
    const grids = processGrids( vmDef.grids, viewModel, ctxHook[ 0 ] );

    // bind data provider
    bindDataProvider( viewModel, dataCtxNode, getData, getProps );

    //bind callback for chartsProvider loadActionData
    bindChartProvider( viewModel, vmDef, dataCtxNode );

    // bind validate action for static dataproviders
    bindStaticDataProvider( viewModel, dataCtxNode );

    // validation criteria
    //vmDef.bindValidationContext( viewModel, _.assign( {}, viewModel, { ctx } ) );

    // Lifecycle Hooks
    viewModel.lifecycleHooks = createLifecycleHooks( declViewModelJson.lifecycleHooks, viewModel.actions );

    // sync strategy
    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {
        syncStrategySvc.setupSyncStrategy( dataCtxNode );
    }
    return {
        viewModel,
        grids
    };
}
