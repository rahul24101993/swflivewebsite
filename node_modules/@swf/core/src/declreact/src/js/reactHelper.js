// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * @module js/reactHelper
 */
import React, { useState } from 'react';
import parse from 'html-react-parser';
import _ from 'lodash';

/**
 * useReducer hook
 * @param {function} reducer reducer function
 * @param {object} initStateObj init state object
 * @param {function} initStateFn function to init state
 * @returns {Array} react hook in data-dispatch pair
 */
export function useReducer( reducer, initStateObj, initStateFn ) {
    const [ data, setDataState ] = React.useState( initStateObj || initStateFn );

    // overlay for async practice, using ref
    // https://github.com/nathanbuchar/react-hook-thunk-reducer
    const dataRef = React.useRef( data );
    const getData = React.useCallback( () => dataRef.current, [ dataRef ] );
    const setData = React.useCallback( ( newState ) => {
        dataRef.current = newState;
        setDataState( newState );
    }, [ dataRef, setDataState ] );

    // dispatch
    const dispatch = React.useCallback( ( action ) => {
        const newData = reducer( getData(), action );
        // NOTE: blindly set data will cause update issue without comparison
        if( newData !== data ) {
            setData( newData );
        }
    }, [ reducer, getData ] );

    return [ data, dispatch, getData ];
}

/**
 * General chainable init hook
 * @param {function} fn call back function for useEffect hook
 * @param {boolean} initialized true if former hook is done
 */
export function useInitHook( fn, initialized = true ) {
    React.useEffect( () => initialized ? fn() : undefined, [ initialized ] );
}

// Follow Stu's suggestion to add a cache
export const convertToHtml = value => parse( value );

// revisitme Charu - please see discussion on MR476
/**
 * Maps the objects on the child elements
 * @param {Array} children child elements
 * @param {object} context context to be mapped
 * @returns {Array} mapped child elements
 */
export function mapChildren( children, context ) {
    // case1: children is functions in form of {}
    // case2: children in normal form
    children = _.concat( [], children );
    let final_children = children.map( ( item )=> typeof item === 'function' ? item( context ) : item );

    return React.Children.map( final_children, child => {
        let { children } = child.props || {};
        // should always keep the children
        // case1: children is functions in form of {}
        // case2: children in normal form
        if ( typeof children === 'function' ) {
            children = children( context );
        }
        return React.cloneElement( child, context, children );
    } );
}

export function forwardComponent( children, context ) {
    return React.forwardRef();
}

export const useAtomicDataReducer = ( declViewModelJson ) => {
    // fieldsdata
    const atomicDataHook = {};
    const atomicDataRef = {};
    for( const prop in declViewModelJson.data ) {
        if( declViewModelJson.data[ prop ] && declViewModelJson.data[ prop ].meta ) {
            // eslint-disable-next-line react-hooks/rules-of-hooks
            const [ atomicData, dataUpdater ] = useState( declViewModelJson.data[ prop ].initialValues );
            atomicDataHook[ prop ] = [ atomicData, dataUpdater ];
            // eslint-disable-next-line react-hooks/rules-of-hooks
            const dataRef = React.useRef( atomicData );
            // eslint-disable-next-line react-hooks/rules-of-hooks
            const getAtomicData = React.useCallback( () => dataRef.current, [ dataRef ] );
            // eslint-disable-next-line react-hooks/rules-of-hooks
            const setAtomicData = ( newState ) => {
                dataRef.current = newState;
                dataUpdater( newState );
            };

            atomicDataRef[ prop ] = {
                getAtomicData,
                setAtomicData
            };
        }
    }
    return { atomicDataHook, atomicDataRef };
};
