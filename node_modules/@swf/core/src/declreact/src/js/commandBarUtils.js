import { useEffect, useLayoutEffect } from 'react';

/*
* Function to calulate the overflown commands in the commandbar/toolbar
*/
const calculateOverflow = ( { getData, dispatch } ) => {
    return ( entries ) => {
        let overflownCommands = { ...getData()._overflownCommands };
        let overCmdsUpdated = null;
        entries.forEach( entry => {
            if( entry && entry.target.childNodes && entry.target.childNodes.length ) {
                const id = entry.target.childNodes[ 0 ].attributes[ 'command-id' ].nodeValue;

                if( entry.isIntersecting === false && !overflownCommands[ id ] ) {
                    overflownCommands[ id ] = true;
                    overCmdsUpdated = true;
                } else if( entry.isIntersecting && overflownCommands[ id ] ) {
                    delete overflownCommands[ id ];
                    overCmdsUpdated = true;
                }
            }
        } );
        if( overCmdsUpdated ) {
            dispatch( { path: 'data._overflownCommands', value: overflownCommands } );
        }
    };
};

/*
* Attach observers to command bars and command elements
*/
const useCommandOverflow = ( { data, getData, actions, dispatch }, { commandObserver, overflow, alignment }, { elementRefList } ) => {
    let overflowEnabledForCmdbar = data._swfCommandBarComponent;
    //Overflow for horizontal commandBar is disabled by default
    //Do NOT attach observer for Horizontal cmdBar if not explicitly enabled
    if( overflowEnabledForCmdbar && ( alignment === 'HORIZONTAL' || !alignment ) && overflow !== true ) {
        overflowEnabledForCmdbar = false;
    }

    if( overflowEnabledForCmdbar || data._swfToolBarComponent && overflow && overflow !== 'false' ) {
        //eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect( () => {
            const element = elementRefList.get( 'commandBarMain' ).current;
            const observer = new IntersectionObserver(
                calculateOverflow( { getData, dispatch } ),
                {
                    root: element,
                    threshold: 0.1
                }
            );
            dispatch( { path: 'data._observer', value: observer } );
            return () => {
                const { _observer } = getData() || {};
                _observer && _observer.disconnect();
            };
        }, [] );
    }

    if( data._swfCommandComponent && commandObserver ) {
        //eslint-disable-next-line react-hooks/rules-of-hooks
        useLayoutEffect( () => {
            commandObserver.observe( actions.openCommandPopup.reference.current );
            return () => {
                commandObserver.unobserve( actions.openCommandPopup.reference.current );
            };
        }, [] );
    }
};

export const useCommands = ( viewModel, ...args ) => {
    if( viewModel.data._swfToolBarComponent || viewModel.data._swfCommandBarComponent || viewModel.data._swfCommandComponent ) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useCommandOverflow( viewModel, ...args );
    }
};

export default {
    useCommands
};
