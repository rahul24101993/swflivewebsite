// Copyright (c) 2021 Siemens

/**
 * @module js/declEditHandlerFactory
 */
import { useReducer, useState } from 'react';
import _ from 'lodash';
import declDataCtxService from 'js/declarativeDataCtxService';
import editHandlerFactory from 'js/editHandlerFactory';
import editHandlerService from 'js/editHandlerService';
import dataSourceService from 'js/dataSourceService';

const editHandlerReducer = ( state, action ) => {
    if( action.type === 'SET_EDIT_STATE_CHANGED' ) {
        return { ...state, _editing: action.value };
    }

    return state;
};

const useEditStateChangeObserver = () => {
    // cursor hook
    const [ editHandlerState, editStateChangeDispatcher ] = useReducer( editHandlerReducer, {
        // revisitme: move startIndex logic to here
        _editing: false
    } );

    return {
        editHandlerState,
        editStateChangeDispatcher
    };
};

export const useBuildEditHandler = ( editHandlerJson, ehName, viewModel, dataCtxNode, editHandlerRef, fields ) => {
    let editHandlerJsonIn = { ...editHandlerJson };
    declDataCtxService.applyScope( viewModel, editHandlerJsonIn, null, dataCtxNode );
    return useEditHandler( editHandlerJsonIn, ehName, viewModel, editHandlerRef, fields );
};

export const useEditHandler = ( editHandlerJson, ehName, viewModel, editHandlerRef, fields ) => {
    const { editHandlerState, editStateChangeDispatcher } = useEditStateChangeObserver();

    return buildEditHandler( editHandlerJson, ehName, viewModel, editHandlerRef, editStateChangeDispatcher, editHandlerState, fields );
};

const buildEditHandler = ( editHandlerJson, ehName, viewModel, editHandlerRef, editStateChangeDispatcher, editHandlerState, fields ) => {
    if( !editHandlerRef.current || !editHandlerService.getEditHandler( editHandlerJson.context ) && editHandlerJson.dataSource ) {
        editHandlerRef.current = editHandlerFactory.createEditHandler( dataSourceService.createNewDataSource( {
            declViewModel: { ...viewModel.atomicDataRef.xrtState,
                panelId: viewModel._internal.panelId,
                context: editHandlerJson.context,
                atomicData: fields.xrtState
            }
        } ) );
        editHandlerService.setEditHandler( editHandlerRef.current, editHandlerJson.context );

        if( editHandlerJson.setActive ) {
            editHandlerService.setActiveEditHandlerContext( editHandlerJson.context );
        }

        if( _.get( editHandlerRef.current, 'setDataUpdater' ) ) {
            editHandlerRef.current.setDataUpdater( editStateChangeDispatcher );
        }
    }

    editHandlerService.updateStates( editHandlerRef.current, editHandlerJson.context );
    editHandlerRef.current._editing = editHandlerState._editing;

    return editHandlerRef.current;
};

/**
  * Edit handlers hook
  * @param {Object} viewModel View model
  */
export function useEditHandlers( editHandlersJson, viewModel, dataCtxNode, editHandlerRef, fields ) {
    let editHandlers = {};
    // Just to make sure the editHandlers name order is same in every render.
    const [ editHandlerNames ] = useState( () => {
        return editHandlersJson ? Object.keys( editHandlersJson ) : [];
    } );

    editHandlerNames.forEach( ( ehName ) => {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        editHandlers[ ehName ] = useBuildEditHandler( editHandlersJson[ ehName ], ehName, viewModel, dataCtxNode, editHandlerRef, fields );
    } );
    return editHandlers;
}

/**
 *
 * @param {String} context - edit handler context key
 */
export function removeEditHandler( context ) {
    editHandlerService.removeEditHandler( context );
}
