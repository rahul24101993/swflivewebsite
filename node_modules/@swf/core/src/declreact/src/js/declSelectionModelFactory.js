// Copyright (c) 2021 Siemens

/**
 * @module js/declSelectionModelFactory
 */
import { useReducer, useRef, useState } from 'react';
import eventBus from 'js/eventBus';
import logger from 'js/logger';
import _ from 'lodash';
import { getEvaluatedId } from 'js/uwUtilService';
import declDataCtxService from 'js/declarativeDataCtxService';

const selectionReducer = ( state, action ) => {
    switch ( action.type ) {
        case 'SET_MODE':
            //handle deselect
            //If object is already selected then remove it
            return { ...state, mode: action.value };
        case 'SET_MULTI_SELECT_ENABLED':
            return { ...state, multiSelectEnabled: action.value };
        case 'SET_SELECTION_ENABLED':
            return { ...state, selectionEnabled: action.value };
        case 'SET_SELECTION_STATE':
            return { ...state, selectionState: action.value };
        case 'SET_SELECTION':
            return { ...state, lastSelected: state.selected, selected: action.value.selected, selectionModelActivated: action.value.isSelectionModelActive };
        case 'SET_SM_ACTIVE':
            return { ...state, selectionModelActivated: action.value };
        case 'SELECT_ALL':
            return { ...state, selectedObjects: [], selectAll: true };
        case 'SET_DP_LISTENER':
            if( state && !state.dpListener && !action.value ) {
                return state;
            }
            return { ...state, dpListener: action.value };
        default:
            return state;
    }
};

export const useBuildSelectionModel = ( selectionModelJson, smName, dataCtxNode, selectionModelRef ) => {
    declDataCtxService.applyScope( dataCtxNode.data, selectionModelJson, null, dataCtxNode, null );
    const mode = selectionModelJson && selectionModelJson.selectionMode ? selectionModelJson.selectionMode : 'multiple';
    return useSelectionModel( mode, null, null, smName, selectionModelRef );
};

export const useSelectionModel = ( mode, tracker, inputSelectionModel, smName, selectionModelRef ) => {
    const [ selectionModel, selectionModelDispatcher ] = useReducer( selectionReducer, {
        mode: mode,
        smName: smName,
        multiSelectEnabled: false,
        selectionEnabled: mode !== 'none',
        selectionState: 'none',
        selected: [],
        lastSelectionState: [],
        selectionModelActivated: true,
        dpListener: null
    } );

    // If selection Model is already passed no need to create another state.
    if( inputSelectionModel ) {
        return inputSelectionModel;
    }

    if( !selectionModelRef || !_.isEqual( selectionModelRef.getSelectionModelState(), selectionModel ) ) {
        return buildSelectionModel( selectionModel, selectionModelDispatcher, tracker );
    }
    return selectionModelRef;
};

const buildSelectionModel = ( selModel, selectionModelDispatcher, tracker ) => {
    const selectionModel = {};

    if( !tracker ) {
        tracker = ( input ) => {
            if( typeof input === 'string' ) {
                return input;
            } else if( typeof input === 'object' && input.propInternalValue ) {
                return input.propInternalValue;
            } else if( typeof input === 'object' && input.type === 'Awp0XRTObjectSetRow' ) {
                var targetObj = _.get( input, 'props.awp0Target' );
                if( targetObj && targetObj.dbValue ) {
                    return targetObj.dbValue;
                }
            } else if( typeof input === 'object' ) {
                return getEvaluatedId( input );
            }
            return input;
        };
    }

    selectionModel.getSelectionModelState = () => {
        return selModel;
    };

    selectionModel.setMode = ( mode ) => {
        selectionModelDispatcher( { type: 'SET_MODE', value: mode } );
    };
    selectionModel.getMode = () => selModel.mode;

    selectionModel.addRemoveDpListener = ( operation, dp ) => {
        if( operation === 'add' ) {
            selectionModelDispatcher( { type: 'SET_DP_LISTENER', value: dp } );
        } else if( operation === 'remove' ) {
            selectionModelDispatcher( { type: 'SET_DP_LISTENER', value: null } );
        }
    };

    selectionModel.getDpListener = () => {
        return selModel.dpListener;
    };

    selectionModel.setMode = ( mode ) => {
        selectionModelDispatcher( { type: 'SET_MODE', value: mode } );
    };

    selectionModel.mode = selModel.mode;

    selectionModel.selectionEnabled = selModel.selectionEnabled;

    selectionModel.multiSelectEnabled = selModel.multiSelectEnabled;

    selectionModel.selectionState = selModel.selectionState;

    selectionModel.name = selModel.smName; // for debugging purpose to identify which selectionModel is in action

    selectionModel.getLastSelection = () => selModel.lastSelected;

    selectionModel.setSelection = ( newSelection, isSelectionModelActive = true ) => {
        if( selModel.selectionEnabled ) {
            var uidList = newSelection ? asTrackedList( newSelection, tracker ) : [];
            // Replace selection
            selectionModelDispatcher( { type: 'SET_SELECTION', value: { selected: uidList, isSelectionModelActive: isSelectionModelActive } } ); // Auto exit multi select
            checkResetMultiSelect( selectionModel );
        }
    };

    selectionModel.getSelection = () => selModel.selected;

    selectionModel.getCanExecuteSelectLoaded = () => selModel.mode === 'multiple' && selModel.selectionState !== 'all';

    selectionModel.getCanExecuteDeselect = () => selModel.mode === 'multiple' && selModel.selectionState === 'all';

    selectionModel.setMultiSelectionEnabled = newMultiSelectState => {
        const mode = selModel.mode;
        const multiSelectEnabled = selModel.multiSelectEnabled;
        if( mode !== 'none' && multiSelectEnabled !== newMultiSelectState ) {
            if( newMultiSelectState && mode !== 'multiple' ) {
                logger.warn( 'Cannot enter multi select mode when selection model is single select' );
            } else {
                selectionModelDispatcher( { type: 'SET_MULTI_SELECT_ENABLED', value: newMultiSelectState } );
                // Update select / deselect command visibility
                notifySelectionState( selectionModel );
            }
        }
    };

    selectionModel.isMultiSelectionEnabled = () => selModel.multiSelectEnabled;

    selectionModel.setSelectionEnabled = isSelectionEnabled => {
        if( selModel.mode !== 'none' ) {
            selectionModelDispatcher( { type: 'SET_SELECTION_ENABLED', value: isSelectionEnabled } );
        }
    };

    selectionModel.isSelectionEnabled = () => selModel.selectionEnabled;

    selectionModel.setSelectionModelActivated = isSelectionModelActive => {
        selectionModelDispatcher( { type: 'SET_SM_ACTIVE', value: isSelectionModelActive } );
    };

    selectionModel.isSelectionModelActivated = () => selModel.selectionModelActivated;

    selectionModel.setSelectionState = ( value ) => selectionModelDispatcher( { type: 'SET_SELECTION_STATE', value } );

    selectionModel.getSelectionState = () => selModel.selectionState;

    selectionModel.evaluateSelectionStatusSummary = dataProvider => {
        if( dataProvider ) {
            if( dataProvider.viewModelCollection ) {
                // Check of there's any objects in the data provider that aren't selected
                var loadedVmos = dataProvider.viewModelCollection.getLoadedViewModelObjects();
                var objectsNotSelected = loadedVmos.filter( function( x ) {
                    return !selectionModel.isSelected( x );
                } );
                // If everything is selected state is 'all'
                if( loadedVmos.length && objectsNotSelected.length === 0 ) {
                    selectionModelDispatcher( { type: 'SET_SELECTION_STATE', value: 'all' } );
                } else {
                    // Otherwise it's some / none depending on what is selected
                    const selected = selModel.selected;
                    selectionModelDispatcher( { type: 'SET_SELECTION_STATE', value: selected.length > 0 ? 'some' : 'none' } );
                }
            }
            // Update select / deselect command visibility
            notifySelectionState( selectionModel );
        } else {
            logger.error( 'No data provider given to evaluate selection status against. Data provider must now be passed to selectionModel.evaluateSelectionStatusSummary' );
        }
    };

    selectionModel.addToSelection = ( newSelection ) => {
        // If selection is not disabled
        if( selModel.selectionEnabled ) {
            // Convert input to list of uids
            var uidList = asTrackedList( newSelection, tracker );

            // Add to selection if not already in there
            const toUpdate = selModel.selected.concat( uidList.filter( function( uid ) {
                return selModel.selected.indexOf( uid ) === -1;
            } ) );
            selectionModelDispatcher( { type: 'SET_SELECTION', value: { selected: toUpdate, isSelectionModelActive: true } } );
        }
    };

    selectionModel.removeFromSelection = ( newSelection ) => {
        // If selection is not disabled
        if( selModel.selectionEnabled ) {
            // Convert input to list of uids
            var uidList = asTrackedList( newSelection, tracker );

            // Remove any uid that is in the list of uids from the selection
            const toUpdate = selModel.selected.filter( function( uid ) {
                return uidList.indexOf( uid ) === -1;
            } );
            selectionModelDispatcher( { type: 'SET_SELECTION', value: { selected: toUpdate, isSelectionModelActive: true } } );
            checkResetMultiSelect( selectionModel );
        }
    };

    selectionModel.toggleSelection = function( newSelection ) {
        // If selection is not disabled
        if( selModel.selectionEnabled ) {
            // Convert input to list of uids
            const uidList = asTrackedList( newSelection, tracker );

            // Get the list of uids that are selected / not selected
            const uidsNotSelected = uidList.filter( function( uid ) {
                return selModel.selected.indexOf( uid ) === -1;
            } );
            const uidsSelected = uidList.filter( function( uid ) {
                return selModel.selected.indexOf( uid ) !== -1;
            } );
            // Remove any objects were selected
            const toUpdate = selModel.selected.filter( function( uid ) {
                return uidsSelected.indexOf( uid ) === -1;
            } )
            // And add the objects that were not selected
                .concat( uidsNotSelected );
            selectionModelDispatcher( { type: 'SET_SELECTION', value: { selected: toUpdate, isSelectionModelActive: true } } );
            checkResetMultiSelect( selectionModel );
        }
    };

    selectionModel.getCurrentSelectedCount = () => selModel.selected.length;
    selectionModel.selectNone = () => selectionModel.setSelection( [] );
    selectionModel.isSelected = ( obj ) => selectionModel.getSelectedIndex( obj ) !== -1;

    selectionModel.getSortedSelection = ( objList ) => {
        // Get the selected objects
        return objList.filter( function( x ) {
            return selectionModel.isSelected( x );
        } )
        // And sort by the order in selection model
            .sort( function( a, b ) {
                var tracked = tracker ? tracker( a ) : a;
                var tracked2 = tracker ? tracker( b ) : b;
                return selModel.selected.indexOf( tracked ) - selModel.selected.indexOf( tracked2 );
            } );
    };

    selectionModel.getSelectedIndex = ( obj ) => {
        var tracked = tracker ? tracker( obj ) : obj;
        return selModel.selected.indexOf( tracked );
    };

    selectionModel.updateSelectedObjects = ( x ) => {
        logger.warn( 'Please use selectionModel.setSelection() instead of selectionModel.updateSelectedObjects()' );
        selectionModel.setSelection( x );
    };

    return selectionModel;
};

/**
  * Utility to fire events that update select all / deselect all command visibility
  */
const notifySelectionState = selectionModel => {
    var canSelectLoaded = selectionModel.getCanExecuteSelectLoaded();
    var canDeselect = selectionModel.getCanExecuteDeselect();
    const lastSelectionState = selectionModel.lastSelectionState;
    if( lastSelectionState !== undefined && ( lastSelectionState.CanExecuteSelectLoaded !== canSelectLoaded ||
             lastSelectionState.CanExecuteDeselect !== canDeselect ) ) {
        lastSelectionState.CanExecuteSelectLoaded = canSelectLoaded;
        lastSelectionState.CanExecuteDeselect = canDeselect;

        eventBus.publish( 'CanExecuteSelectLoaded', {} );
        eventBus.publish( 'CanExecuteDeselect', {} );
    }
};

/**
  * Utility to exit multi select mode when selection is cleared
  */
const checkResetMultiSelect = ( selectionModel ) => {
    const selected = selectionModel.getSelection();
    const multiSelectEnabled = selectionModel.isMultiSelectionEnabled();
    // Disable multi select when all selection is cleared
    if( selected.length === 0 && !multiSelectEnabled ) {
        selectionModel.setMultiSelectionEnabled( false );
        selectionModel.setSelectionState( 'none' );
    }
};

export const asTrackedList = ( newSelection, tracker ) => {
    // Ensure it is array of some sort
    if( !_.isArray( newSelection ) ) {
        newSelection = [ newSelection ];
    }
    // Ensure everything in array is tracked
    return tracker ? newSelection.map( tracker ) : newSelection;
};

export const useSelectionModels = ( selectionModelsJson, dataCtxNode ) => {
    let selectionModelsRef = useRef( {} );
    // Just to make sure the selectionModels name order is same in every render.
    const [ selectionModelNames ] = useState( () => {
        return selectionModelsJson !== undefined ? Object.keys( selectionModelsJson ) : [];
    } );
    //selectionModels order will never change between render cycles, hence disabling the eslint
    //https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function
    // zarq9k: any better solution ?
    selectionModelNames.forEach( ( smName ) => {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        selectionModelsRef.current[ smName ] = useBuildSelectionModel( selectionModelsJson[ smName ], smName, dataCtxNode, selectionModelsRef.current[ smName ] );
    } );
    return selectionModelsRef.current;
};
