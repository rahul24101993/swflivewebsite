// Copyright (c) 2020 Siemens
/* eslint-disable require-jsdoc */

/**
 * @module js/reactPopup
 */
import AwPromiseService from 'js/awPromiseService';
import { consolidateOptions } from 'js/popupService';
import { Tooltip } from 'js/tooltip';
import React, { useState, useRef, useEffect } from 'react';
import { useInitHook } from 'js/reactHelper';
import _ from 'lodash';

const hasStaticReference = ( reference ) => reference && ( _.isString( reference ) || Boolean( reference.nodeName ) );

const usePopupInternal = ( initialOptions ) => {
    // the reference element which has the popup - could be static or dynamic
    // 1, static - existed, selector or native dom element, eg: 'div.sw-logoImage'
    // 2, dynamic - will be generated, vdom element
    let reference = useRef( null );
    if( hasStaticReference( initialOptions.reference ) ) {
        reference = initialOptions.reference;
    }

    let uuid = useRef( null );

    // the popup element
    let popupReference = useRef( null );

    // enable popup api return promise
    let [ showDeferred, hideDeferred ] = [ useRef( null ), useRef( null ) ];

    // popup options - only initialize once, call updateOptions to update the options
    let baseOptions = consolidateOptions( { ...initialOptions, popupReference, reference, showDeferred, hideDeferred, uuid }, hide, updateOptions );
    // could change incrementally
    let currentOptions = baseOptions;
    const [ options, setOptions ] = useState( baseOptions );

    useEffect( () => {
        if( options.open && popupReference.current ) {
            let componentWillUnMounted = options.componentMounted( options, popupReference.current );
            return () => componentWillUnMounted();
        }
        return undefined;
    }, [ options.open ] );

    // support dynamic popup reference
    useEffect( () => {
        updateOptions( { reference } );
    }, [ reference.current ] );

    function show( newOptions = null, force = false ) {
        // avoid event being passed in, cases of <Component action={popup.show} />
        newOptions && newOptions.type && ( newOptions = null );
        // always use base options for global popup
        const base = baseOptions.global ? baseOptions : options;
        // mix-in new options if any
        newOptions && Object.keys( newOptions ).length > 0 && ( currentOptions = consolidateOptions( { ...base, ...newOptions } ) );

        // run beforeOpen check to ensure whether need to change state
        // `force === true` to skip beforeOpen check
        let condition = force || currentOptions.beforeOpen();
        // exclude toggleMode case  - null
        // exclude multiple case    - popupRef
        if( condition === true ) {
            updateOptions( Object.assign( currentOptions, { open: true } ) );
        }

        showDeferred.current = AwPromiseService.instance.defer();
        hideDeferred.current = AwPromiseService.instance.defer();

        return showDeferred.current.promise;
    }

    function hide() {
        updateOptions( { open: false } );
        // case null hideDeferred.current - means already being closed, return directly
        return hideDeferred.current ? hideDeferred.current.promise : Promise.resolve( true );
    }

    function updateOptions( newOptions ) {
        setOptions( ( prev ) => {
            // always return independent options for global case
            if( newOptions.global ) {
                return newOptions;
            }
            return { ...prev, ...newOptions };
        } );
    }

    return {
        // popup state and options
        open: options && options.open,
        options,

        // getter - the reference element which owns the popup
        reference,

        // popup APIs - the apis to show / hide popup
        show,
        hide,
        update: updateOptions
    };
};

const usePopup = function( initialOptions ) {
    initialOptions = initialOptions || {};
    const popup = usePopupInternal( initialOptions );
    popup.userOptions = useRef( null );

    // mount
    useInitHook( () => {
        if( initialOptions.preset === 'tooltip' ) {
            // tipWrapper.hooks to support tooltip move-in feature
            // popup.userOptions - dynamic user options
            // for debug: to quick enable / disable tooltip
            // let show = () => null;
            // let hide = () => null;
            let show = () => popup.show( { ...tipWrapper.hooks, ...popup.userOptions.current }, true );
            let hide = () => popup.hide();
            const tipWrapper = new Tooltip( popup.reference.current, popup.options, show, hide );
            // return unmount fn inside of `tipWrapper.configure`
            return tipWrapper.configure( tipWrapper );
        }
        return undefined;
    }, popup.reference.current );

    return popup;
};

const handler = {
    get: ( target, key ) => {
        return target.prototype[ key ];
    }
};

// initialize popups for viewModel based on it's popup actions
const usePopups = function( viewModel ) {
    const initialOptionsMap = _.reduce( viewModel.declViewModelJson.actions, ( result, { actionType, options, inputData }, actionId ) => {
        actionType === 'popup' && ( result[ actionId ] = inputData && inputData.options || options );
        return result;
    }, {} );

    // fixed loop, safe to use.
    // https://stackoverflow.com/questions/53906843/why-cant-react-hooks-be-called-inside-loops-or-nested-function
    _.each( initialOptionsMap, function useLoop( initialOptions, actionId ) {
        let fn = initialOptions && initialOptions.preset === 'test' ? useTestContent : usePopup;
        let action = viewModel.actions[ actionId ];
        let actionHandler = fn( initialOptions );
        if( !initialOptions || initialOptions.preset !== 'test' ) {
            // extend action by proxy
            action.prototype = actionHandler;
            actionHandler = new Proxy( action, handler );
        }
        viewModel.actions[ actionId ] = actionHandler;
    } );
};

// test harness for popup, purpose to provide dynamic/rich content to demonstrate the reactivity of popup.
// remove in future.
let i = 1;
const title = <div className='header-label'>Lorem ipsum</div>;
// eslint-disable-next-line max-len
const lorem =
    'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure cillum dolore pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
const testActions = [
    { action: setter => () => setter( ( prev ) => { return { ...prev, ...{ body: generateContent() } }; } ), label: 'Load More Data' },
    { action: setter => () => setter( ( prev ) => { return { ...prev, ...{ body: generateContent( true ) } }; } ), label: 'Reset Data' },
    { action: target => () => target.hide(), label: 'Close', path: 'target' }
];
const actions = ( setter, target, ActionComponent ) => {
    return <div>
        { testActions.map( ( { action, label, path } ) => <ActionComponent key={label} action={ path ? action( target ) : action( setter ) } className='small sample-btn'>{ label }</ActionComponent> ) }
    </div>;
};
const generateContent = ( reset = false ) => {
    if( reset ) {
        i = 0;
    }
    i += 1;
    const items = Array.from( { length: i }, ( v, i ) => i );
    return items.reduce( ( total, item ) => {
        total.push( <p key={item}>{lorem}<br/><br/></p> );
        return total;
    }, [] );
};

// simulate dynamic binding data
// content could be changed anytime by actions
const useTestContent = () => ( ActionComponent ) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const [ content, setContent ] = useState( {
        header: title,
        actions: ( target ) => actions( setContent, target, ActionComponent ),
        body: <p key={-1}>{lorem}<br/><br/></p>
    } );

    return content;
};

export {
    usePopup,
    usePopups,
    useTestContent
};
