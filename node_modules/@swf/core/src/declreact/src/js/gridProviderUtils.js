// Copyright (c) 2021 Siemens

/**
 * @module js/gridProviderUtils
 */
import { useState, useEffect, useRef } from 'react';
import { useInitHook, useReducer } from 'js/reactHelper';
import awColumnSvc from 'js/awColumnService';

const gridContextReducer = ( state, action ) => {
    switch ( action.type ) {
        case 'UPDATE_VALUES':
            return {
                ...state,
                ...action
            };
        default:
            return state;
    }
};

export const useGridContext = ( prop ) => {
    const [ gridContextPlaceholder, gridContextDispatcher ] = useReducer( gridContextReducer, {
        columnDef: null,
        isBulkEditing: false,
        columnConfig: undefined,
        currentColumnIndex: -1,
        popupRef: null,
        editVmo: null,
        editPropertyName: '',
        contextVmo: [],
        sortDirection: 'none',
        newColumnIndex: -1,
        defaultColumnPinIndex: -1,
        pinColumnData: {},
        dynamicRowHeightStatus: false
    } );

    if( prop.gridContextDispatcher && prop.gridContextPlaceholder ) {
        return [ prop.gridContextPlaceholder, prop.gridContextDispatcher ];
    }

    return [ gridContextPlaceholder, gridContextDispatcher ];
};

export const processGrids = ( gridDefs, viewModel, ctx ) => {
    // revisitme - need to be refactor maybe
    // gridDefs = _.cloneDeep( gridDefs );

    for( const gridDefKey in gridDefs ) {
        let gridInstance = gridDefs[ gridDefKey ];
        const dataCtxNode = {
            data: viewModel,
            ctx
        };
        if( gridInstance.dataProvider ) {
            if( !gridInstance.gridOptions ) {
                gridInstance.gridOptions = {};
            }
        }
        gridInstance.dataCtxNode = dataCtxNode;
        gridInstance.gridid = gridDefKey;
    }
    return gridDefs;
};

export const useGrid = ( prop, panelId, gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel ) => {
    let columns;
    let gridContextColumns;
    const tableCallbackRef = useRef();
    let loadedVmObjects;
    let sortDirection;
    let newColumnIndex;
    let currentColumnIndex;
    let pinColumnData;
    let dynamicRowHeightStatus;
    let hideColumnField;
    let columnFilterInfo;
    let columnMenuData;
    let columnArrangeData;
    let selectedColumn = gridContextPlaceholder && gridContextPlaceholder.selectedColumn;

    if( prop.gridid && panelId === 'AwSplmTable' && prop.reusable !== 'true' ) {
        const { vmCollectionObj, columnConfig } = prop.dataProviderInstance;
        loadedVmObjects = vmCollectionObj.vmCollection.loadedVMObjects;
        if( gridContextPlaceholder.columnConfig ) {
            gridContextColumns = gridContextPlaceholder.columnConfig.columns;
        }
        if( columnConfig !== undefined && columnConfig.columns ) {
            columns = columnConfig.columns;
        }

        if( gridContextPlaceholder ) {
            sortDirection = gridContextPlaceholder.sortDirection;
            newColumnIndex = gridContextPlaceholder.newColumnIndex;
            currentColumnIndex = gridContextPlaceholder.currentColumnIndex;
            pinColumnData = gridContextPlaceholder.pinColumnData;
            dynamicRowHeightStatus = gridContextPlaceholder.dynamicRowHeightStatus;
            hideColumnField = gridContextPlaceholder.hideColumnField;
            columnFilterInfo = gridContextPlaceholder.columnFilterInfo;
            columnMenuData = gridContextPlaceholder.columnMenuData;
            columnArrangeData = gridContextPlaceholder.columnArrangeData;
        }

        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updateDeclGridObject( prop );
        }
    }

    //OnMount
    useInitHook( () => {
        if( prop.gridid && panelId === 'AwSplmTable' ) {
            //Need to set gridContextDispatcher on dataProviderInstance for arrange reset
            prop.dataProviderInstance.gridContextDispatcher = gridContextDispatcher;

            if ( prop.reusable !== 'true' ) {
                const { vmCollectionObj } = prop.dataProviderInstance;
                const element = prop.dataProviderInstance.getRootReference();
                prop.dataCtxNode.i18n = prop.dataCtxNode.data.i18n;
                prop.dataCtxNode.gridContextDispatcher = gridContextDispatcher;
                prop.dataCtxNode.gridContextPlaceholder = gridContextPlaceholder;
                import( 'js/awSPLMTableNativeService' ).then( ( awSPLMTableNativeService ) => {
                    tableCallbackRef.current = awSPLMTableNativeService.initializeTable( element.current, vmCollectionObj.vmCollection, prop.dataCtxNode, prop, runActionWithViewModel );
                } );
            }
        }
        //OnUnMount
        return () => {
            if( tableCallbackRef.current ) {
                tableCallbackRef.current.destroy();
            }
        };
    }, prop.i18nLoaded === true );

    const selectionModel = prop.dataProviderInstance && prop.dataProviderInstance.selectionModel;
    const selectionModelActivated = selectionModel && selectionModel.isSelectionModelActivated();

    useEffect( () => {
        const updateTableContents = async() => {
            if( tableCallbackRef.current ) {
                if( prop.dataProviderInstance.initializationComplete === false ) {
                    await tableCallbackRef.current.completeInitialization();
                }
                tableCallbackRef.current.updateState( prop.dataCtxNode.data );
                const { vmCollectionObj } = prop.dataProviderInstance;
                tableCallbackRef.current.updateVmCollection( vmCollectionObj.vmCollection );
            }
        };
        updateTableContents();
    }, [ loadedVmObjects ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updateContentRowSelection();
        }
    }, [ selectionModelActivated ] );

    useEffect( () => {
        const updateTableColumns = async( columns ) => {
            if( tableCallbackRef.current ) {
                if( prop.dataProviderInstance.initializationComplete === false ) {
                    await tableCallbackRef.current.completeInitialization();
                } else {
                    tableCallbackRef.current.updateTableColumns( columns );
                }
            }
        };
        updateTableColumns( columns );
    }, [ columns ] );

    useEffect( () => {
        if ( prop.dataProviderInstance && prop.dataProviderInstance.columnConfig && gridContextColumns ) {
            prop.dataProviderInstance.columnConfig.columns = gridContextColumns;
            if( tableCallbackRef.current ) {
                tableCallbackRef.current.updateTableColumns( gridContextColumns );
            }
        }
    }, [ gridContextColumns ] );

    // Column selection with enableColumnSelection grid option
    useEffect( () => {
        if( tableCallbackRef.current && selectedColumn ) {
            if( selectionModel && selectedColumn.vmo ) {
                selectionModel.setSelection( [ selectedColumn.vmo ] );
                selectionModel.selectionData.update( {
                    selected: [ selectedColumn.vmo ]
                } );
            }
            tableCallbackRef.current.selectTableColumn( selectedColumn );
        }
    }, [ selectedColumn ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updateSortDirection( currentColumnIndex, newColumnIndex, sortDirection );
        }
    }, [ newColumnIndex, sortDirection ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updateDynamicRowHeight( dynamicRowHeightStatus );
        }
    }, [ dynamicRowHeightStatus ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updatePinColumn( pinColumnData.columnDef, pinColumnData.isFreezeAction, pinColumnData.defaultColumnPinIndex );
        }
    }, [ pinColumnData ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.hideColumn( hideColumnField );
        }
    }, [ hideColumnField ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.columnFilterApplied( columnFilterInfo );
        }
    }, [ columnFilterInfo ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.columnsArranged( columnArrangeData );
        }
    }, [ columnArrangeData ] );

    useEffect( () => {
        if( tableCallbackRef.current ) {
            tableCallbackRef.current.updateColumnMenuData( columnMenuData );
        }
    }, [ columnMenuData ] );
};

export const useGrids = ( grids, dataCtxNode, dataProviders, gridContextPlaceholder, gridContextDispatcher, declViewModel, getProps ) => {
    // Just to make sure the dp name order is same in every render.
    const [ gridNames ] = useState( () => {
        return grids !== undefined ? Object.keys( grids ) : [];
    } );
    gridNames.forEach( ( gridName ) => {
        const dpInstance = dataProviders[ grids[ gridName ].dataProvider ];
        grids[ gridName ].dataProviderInstance = dpInstance;
        grids[ gridName ].i18n = dataCtxNode.data.i18n;
        grids[ gridName ].gridContextPlaceholder = gridContextPlaceholder;
        grids[ gridName ].gridContextDispatcher = gridContextDispatcher;
        grids[ gridName ].propsCallback = getProps;
        if( !grids[ gridName ].columnProviderInstance ) {
            grids[ gridName ].columnProviderInstance = awColumnSvc.createColumnProvider( declViewModel, dataCtxNode,
                dpInstance.commands, gridName, dpInstance.json.commandsAnchor );
        }
    } );
};

export default {
    processGrids,
    useGrid,
    useGrids,
    useGridContext
};
