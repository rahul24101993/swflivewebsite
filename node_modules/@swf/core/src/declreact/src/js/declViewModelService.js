/* eslint-disable complexity */
/* eslint-disable max-lines */
// Copyright (c) 2020 Siemens
/**
 * This module provides a way for declarative framework to do outgoing calls like SOA or REST.
 *
 * @module js/declViewModelService
 *
 * @namespace viewModelService
 */
import React, { useState, useMemo, useEffect, createRef, useRef } from 'react';
import ReactDOM from 'react-dom';
import { reducer } from 'js/store';
import { useReducer, useInitHook, useAtomicDataReducer, convertToHtml } from './reactHelper';
import { useDerivedState } from 'js/reactAppCtx';
import modelPropertySvc from 'js/modelPropertyService';
import uwPropertySvc from 'js/uwPropertyService';
import awDuiLocalizationSvc from 'js/awDuiLocalizationService';
import { processViewModel, createDeclViewModel } from 'js/declViewModelProcessingFactory';
import { subscribe, unsubscribe, publish } from 'js/eventBus';
import viewModelService, { handleRegisteredEvent } from 'js/viewModelService';
import conditionService from 'js/conditionService';
import { NULLDATE } from 'js/dateTimeService';
import _ from 'lodash';
import { resolveSubPanelContext, updateI18nTexts } from 'js/viewModelProcessingFactory';
import { useDataProviders } from 'js/dataProviderUtils';
import { useGrid, useGrids, useGridContext } from 'js/gridProviderUtils';
import { usePopups } from 'js/reactPopup';
import { useLOVs } from 'js/lovProviderUtils';
import { updateValidationSchema, getStateCollection, filterFlatViewModelPropForAtomic, filterFlatViewModelProps } from 'js/propValidationUtils';
import { performLOVOperation } from 'js/uwLovDataService';
import syncStrategyService from 'js/syncStrategyService';
import syncViewModelCacheService from 'js/syncViewModelCacheService';
import { useSelectionModels } from 'js/declSelectionModelFactory';
import { useEditHandlers, removeEditHandler } from 'js/declEditHandlerFactory';
import { useMessages } from 'js/messagesProviderUtils';
import appCtxSvc from 'js/appCtxService';
import editHandlerService from 'js/editHandlerService';
import declDragAndDropService from 'js/declDragAndDropService';
import Debug from 'debug';
import declUtils from 'js/declUtils';
import useVmoStore from './useVmoStore';
import debugService from 'js/debugService';
import logger from 'js/logger';
import { createFieldsBasedOnMetaData } from 'js/atomicDataService';
import { createAllFields, isFieldsEqual } from 'js/declFieldService';
import splmStatsService from 'js/splmStatsService';
import { useCommands } from 'js/commandBarUtils';
import AwInterpolateService from 'js/awInterpolateService';
/**
 * execute lifecycle hook
 * @param {string} hookName hook name as 'onInit', 'onMount' and 'onUnmount'
 * @param {object} viewModel view model instance
 */

const executeHook = ( hookName, viewModel, props, renderOptions ) => {
    if( viewModel.lifecycleHooks && viewModel.lifecycleHooks[ hookName ] ) {
        if( logger.isDeclarativeLogEnabled() ) {
            debugService.debugLifecyleHooks( hookName, viewModel );
        }
        if( hookName === 'onMount' ) {
            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'mount' );
        }
        viewModel.lifecycleHooks[ hookName ]( renderOptions );
    }
    // support backward compatibility of XXX.contentLoaded that is equivalent to onMount
    if( hookName === 'onMount' ) {
        const onEvents = viewModel.onEvent;
        if( onEvents && onEvents.length > 0 ) {
            let contentLoadedEvent = onEvents.find( ( event ) => {
                const eventName = event.eventId;
                if( eventName && eventName.includes( '.contentLoaded' ) ) {
                    // make sure contentLoaded event is subscribed for this viewmodel
                    // handle legacy use cases too compiler will convert viewModels to PascalCase but legacy viewNames could be in camel case
                    const viewName = viewModel.getViewId();
                    return eventName.split( '.contentLoaded' )[ 0 ].toLowerCase() === viewName.toLowerCase();
                }
                return false;
            } );
            if( contentLoadedEvent ) {
                publish( contentLoadedEvent.eventId );
            }
        }
        // Backward compatability for command-sub-panel
        if( props.isCommandSubPanel === 'true' ) {
            publish( 'awPanel.reveal', {
                panelId: props.viewId
            } );
        }
    }
};

/**
 * setup view model instance lifcycle in react
 * @param {object} viewModel view model Instance
 * @param {object} ctx App Ctx object
 * @param {object} prop view model property
 * @param {object} viewData view data
 * @param {boolean} limitEventScope Flag to control whether the even needs to be limited to specific view only
 * @param {object} subscriptions subscriptions
 * @returns {function} function to teardown view model intance
 */
const setupLifeCycle = ( vmDef, viewModel, ctx, getProps, renderOptions, limitEventScope, runActionWithViewModel, subscriptions, getFields ) => {
    const props = getProps();
    subscriptions.current = loadSubscriptions( viewModel.onEvent, viewModel, limitEventScope, getProps, runActionWithViewModel, getFields );
    let dataCtxNode = {
        data: viewModel,
        ctx: ctx,
        ports: viewModel.ports,
        props: props,
        getProps,
        subPanelContext: props.subPanelContext,
        getFields
    };
    //Execute onMount LifecycleHook
    executeHook( 'onInit', viewModel );
    executeHook( 'onMount', viewModel, props, renderOptions );
    if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {
        syncStrategyService.setupSyncStrategy( dataCtxNode );
        syncStrategyService.updateVmOnMountUnmount( dataCtxNode, true );
    }
    // TODO: can we split this out as teardownLifCycle later??
    return () => {
        const clearContext = () => {
            cleanupEditHandlers( vmDef._internal.editHandlers, dataCtxNode );
            unloadSubscriptions( subscriptions.current );
            vmDef._internal.destroy( true );
            dataCtxNode = null;
            viewModel.actions = null;
            viewModel.dispatch = null;
            viewModel = null;
        };
        //onUnmount
        //Make sure the onUnmount action is complete before destroying the declViewModel
        if( viewModel.lifecycleHooks && viewModel.lifecycleHooks.onUnmount ) {
            debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'unmount' );
            viewModel.lifecycleHooks.onUnmount( renderOptions ).then( () => {
                if( logger.isDeclarativeLogEnabled() ) {
                    debugService.debugLifecyleHooks( 'onUnmount', viewModel );
                }
                if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {
                    syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );
                    syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );
                }
                clearContext();
            } );
        } else {
            if( viewModel.ports && !_.isEmpty( viewModel.ports ) ) {
                syncStrategyService.updateVmOnMountUnmount( dataCtxNode, false );
                syncViewModelCacheService.set( 'syncViewModelCache.' + viewModel._internal.viewId, null );
            }
            clearContext();
        }
    };
};

/**
 * use i18n hook
 * @param {object} viewModel view model instance
 * @returns {object} i18n string map
 */
const useI18n = ( { i18n, data, dispatch, chartProviders, columnProviders, grids } ) => {
    const [ i18nData, setI18n ] = useState( {} );
    const [ i18nLoaded, setI18nLoaded ] = useState( false );

    useInitHook( () => {
        if( i18n && Object.keys( i18n ).length > 0 ) {
            awDuiLocalizationSvc.populateI18nMap( i18n, null ).then( results => {
                if( results && Object.keys( results ).length > 0 ) {
                    updateI18nTexts( data, { i18n: results }, 0 );
                    dispatch( { path: 'data', value: { ...data } } );
                    if( chartProviders ) {
                        updateI18nTexts( chartProviders, { i18n: results }, 0 );
                        dispatch( { path: 'chartProviders', value: { ...chartProviders } } );
                    }
                    if( columnProviders ) {
                        updateI18nTexts( columnProviders, { i18n: results }, 0 );
                        dispatch( { path: 'columnProviders', value: { ...columnProviders } } );
                    }
                    if( grids ) {
                        updateI18nTexts( grids, { i18n: results }, 0 );
                        dispatch( { path: 'grids', value: { ...grids } } );
                    }
                    setI18n( results );
                    setI18nLoaded( true );
                } else {
                    setI18nLoaded( true );
                }
            } );
        }
    } );

    // Stu: we should not return this i18nLoaded, the downstream setupLifCycle should not depend on i18n. If it is
    //      we should remove the dependency
    // Jesse: it will cause cucumber failure for sure, will do it in next MX
    return [ i18nData, i18n && Object.keys( i18n ).length > 0 ? i18nLoaded : true ];
};

// eslint-disable-next-line require-jsdoc
const updateSubPanelContext = ( jsonData, dataHook, subPanelContext ) => {
    if( subPanelContext ) {
        let resolvedData = {};
        resolveSubPanelContext( jsonData, subPanelContext, resolvedData );
        const [ data, updateData ] = dataHook;
        _.forEach( resolvedData, function( propValue, propName ) {
            let dataClone = _.cloneDeep( data[ propName ] );
            if( uwPropertySvc.isViewModelProperty( dataClone ) ) {
                uwPropertySvc.setValue( dataClone, Object.values( propValue ) );
                updateData( { path: propName, value: dataClone } );
            } else {
                _.merge( dataClone, propValue );
                updateData( { path: propName, value: dataClone } );
            }
        } );
    }
};

/**
 * afx form hook
 * @param {object} vmDef view model definition
 * @param {array} dataHook dataHook in data-dispatch pair
 * @param {object} i18n i18n data used by reset
 * @returns {object} fields and form props
 */
export const useAfxForm = ( vmDef, viewModel, ctx, dataHook, i18n, declViewModelJson, getProps, fieldsRef, vmpCollRef,
    vmpValidationSchema ) => { // create field part. If we dont have to toch this by action we are good
    const { dataProviders, createData } = vmDef;
    const [ touched, setTouched ] = useState( {} );
    const [ errors, setErrors ] = useState( {} );
    const [ isValid, setValid ] = useState( true );
    const [ data, updateData ] = dataHook;

    const validRef = useRef( isValid );
    const updateFormValidity = ( formValidity ) => {
        if( validRef.current !== formValidity ) {
            validRef.current = formValidity;
            setValid( formValidity );
        }
    };
    const getFormValidity = React.useCallback( () => validRef.current, [ validRef ] );

    const errorsRef = useRef( errors );
    const updateErrors = ( errorObj ) => {
        if( errorObj !== errorsRef.current ) {
            errorsRef.current = errorObj;
            setErrors( { ...errorObj } );
        }
    };
    const getErrorsState = React.useCallback( () => errorsRef.current, [ errorsRef ] );

    const touchedRef = useRef( touched );
    const updateTouched = function( path ) {
        if( touched && touched[ path ] !== true ) {
            let newTouched = { ...touchedRef.current, [ path ]: true };
            touchedRef.current = newTouched;
            setTouched( newTouched );
        }
    };
    const getTouchedState = React.useCallback( () => touchedRef.current, [ touchedRef ] );

    const { atomicData = {}, atomicDataRef = {} } = viewModel;
    const props = getProps ? getProps() : {};

    const getVmProp = ( isCtxProp, name ) => {
        const ctxObj = isCtxProp ? ctx : data;
        return _.get( ctxObj, name );
    };
    const getVmPropFromList = ( propName, index, isCtxProp ) => {
        const ctxObj = isCtxProp ? ctx : data;
        return _.get( ctxObj, propName )[ index ];
    };

    const validateAndUpdateDCPPath = ( path ) => {
        //Identify DCP property and escape using the bracket notation.
        //For non DCP properties too, if the keys are more than 3, we should update the path
        const propsKey = 'props.';
        let propName = path.substring( path.indexOf( propsKey ) + 6, path.length );
        if( uwPropertySvc.isDCPProperty( propName ) || path.split( '.' ).length > 3 ) {
            return path.replace( `.${propName}`, `['${propName}']` );
        }
        return path;
    };

    const updateValue = ( isCtxProp, name, updatedProp ) => {
        if( updatedProp.isDCP || name.split( '.' ).length > 3 ) {
            name = validateAndUpdateDCPPath( name );
        }
        isCtxProp ? appCtxSvc.updatePartialCtx( name, updatedProp ) : updateData( { path: name, value: updatedProp } );
    };

    const isFormValid = ( stateCollection ) => {
        let schema = vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;
        if( schema ) {
            return !hasInvalidProps( stateCollection, schema );
        }
        return true;
    };

    const hasInvalidProps = ( vmPropCollection, schema ) => {
        let invalidProps = {};
        let entries = schema && vmPropCollection && Object.entries( vmPropCollection );
        if( !declUtils.isNil( entries ) && entries.length > 0 ) {
            for( let [ key ] of entries ) {
                try {
                    schema.validateSyncAt( key, vmPropCollection );
                } catch ( e ) {
                    if( e && e.errors ) {
                        invalidProps[ key ] = e.errors;
                        break;
                    }
                }
            }
        }
        return Object.keys( invalidProps ).length !== 0;
    };

    const setFormValidity = ( stateCollection ) => {
        let validity = isFormValid( stateCollection );
        updateFormValidity( validity );
    };

    const validateField = ( name, viewModelProperty ) => {
        let newErrors = getErrorsState();
        let schema = null;
        try {
            schema = viewModelProperty && vmpValidationSchema.current ? vmpValidationSchema.current.validationSchema : null;
            if( schema ) {
                schema.validateSyncAt( name, viewModelProperty );
                // No need to update the errors object, if the "property name" is not present earlier.
                if( newErrors && newErrors[ name ] ) {
                    delete newErrors[ name ];
                    updateErrors( { ...newErrors } );
                }
            }
        } catch ( e ) {
            if( e && e.errors ) {
                newErrors = { ...newErrors, [ name ]: e.errors };
                updateErrors( newErrors );
            }
        } finally {
            setFormValidity( getStateCollection( viewModel ) );
        }
    };

    const setLovDataVal = ( name, isCtxProp, index ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {
        if( name.includes( '[' ) ) {
            name = name.replace( / *\[[^\]]*]/, '' );
        }
        let uiProperty;
        if( isCtxProp ) {
            uiProperty = appCtxSvc.getCtx( name );
        } else if( !_.isNil( index ) ) {
            uiProperty = viewModel.getData()[ name ][ index ];
        } else {
            uiProperty = viewModel.getData()[ name ];
        }
        let vmpPropName = _.isNil( index ) ? name : name + '[' + index + ']';
        let validateName = _.isNil( index ) ? name : name + '_' + index;

        return performLOVOperation( {
            uiProperty,
            vmo: null,
            lovEntry,
            dataProvider,
            createUpdateValue,
            checkLovEntries,
            dateApi
        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {
            if( newProp && isPropertyUpdateReqd ) {
                updateValue( isCtxProp, vmpPropName, newProp );
                updateTouched( validateName );
                validateField( validateName, {
                    [ validateName ]: newProp
                } );
            }
            return Promise.resolve( newProp );
        } );
    };
    const setLovDataValVMO = ( vmoName, propName, isCtxProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {
        let uiProperty = isCtxProp ? appCtxSvc.getCtx( propName ) : getVMPropForVMO( vmoName, propName );
        let pathName = vmoName + '.props.' + propName;

        return performLOVOperation( {
            uiProperty,
            vmo: getVMO( vmoName ),
            lovEntry,
            dataProvider,
            createUpdateValue,
            checkLovEntries,
            dateApi
        }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {
            if( newProp && isPropertyUpdateReqd ) {
                updateValue( isCtxProp, pathName, newProp );
                updateTouched( propName );
                validateField( uiProperty.propertyName, getVMOProps( vmoName ) );
                return Promise.resolve( newProp );
            }
        } );
    };

    const handleChange = ( name, isCtxProp, index ) => event => {
        const vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );
        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';
        let validateName = _.isNil( index ) ? name : name + '_' + index;
        if( event.persist ) {
            event.persist();
        }
        let newVMProp = createUpdateValue( vmProp, event );
        updateValue( isCtxProp, vmPropName, newVMProp );
        updateTouched( validateName );
        validateField( validateName, {
            [ validateName ]: newVMProp
        } );
    };

    const setValueForVmo = ( vmoName, propName, isCtxProp ) => ( newVal, additionalProp ) => {
        let vmProp = getVMPropForVMO( vmoName, propName );
        let pathName = vmoName + '.props.' + propName;
        let updateVal = { ...vmProp };
        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );
        updateValue( isCtxProp, pathName, updateVal );
        updateTouched( propName );
        validateField( vmProp.propertyName, getVMOProps( vmoName ) );
    };

    const setValue = ( name, isCtxProp, index ) => ( newVal, additionalProp ) => {
        const prevVal = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );
        let vmPropName = _.isNil( index ) ? name : name + '[' + index + ']';
        let validateName = _.isNil( index ) ? name : name + '_' + index;
        let updateVal = { ...prevVal };
        uwPropertySvc.updateViewModelProp( updateVal, newVal, additionalProp, true );
        updateValue( isCtxProp, vmPropName, updateVal );
        // check validity and update Touched
        updateTouched( validateName );
        validateField( validateName, {
            [ validateName ]: updateVal
        } );
    };

    const handleChangeVMO = ( vmoName, propName, isCtxProp ) => event => {
        if( event.persist ) {
            event.persist();
        }
        let vmProp = getVMPropForVMO( vmoName, propName );
        let pathName = vmoName + '.props.' + propName;
        updateValue( isCtxProp, pathName, createUpdateValue( vmProp, event ) );
        updateTouched( propName );
        validateField( vmProp.propertyName, getVMOProps( vmoName ) );
    };

    const moveUp = ( prop, index ) => {
        for( var i = 0; i < prop.displayValsModel.length; i++ ) {
            if( i === index ) {
                prop.displayValsModel[ i ].selected = false;
                prop.lastSelected = prop.displayValsModel[ index ];
            }
        }
        prop.lastSelected = null;
        var currDbVal = prop.dbValue[ index ];
        var currDisplayVal = prop.displayValues[ index ];
        var currDisplayValModel = prop.displayValsModel[ index ];

        prop.dbValue.splice( index, 1 );
        prop.dbValue.splice( index - 1, 0, currDbVal );

        prop.displayValues.splice( index, 1 );
        prop.displayValues.splice( index - 1, 0, currDisplayVal );

        prop.displayValsModel.splice( index, 1 );
        prop.displayValsModel.splice( index - 1, 0, currDisplayValModel );

        prop.dirty = true;
    };

    const moveDown = ( prop, index ) => {
        index -= 1;
        for( var i = 0; i < prop.displayValsModel.length; i++ ) {
            if( i === index ) {
                prop.displayValsModel[ i ].selected = false;
                prop.lastSelected = prop.displayValsModel[ index ];
            }
        }
        prop.lastSelected = null;
        var currDbVal = prop.dbValue[ index ];
        var currDisplayVal = prop.displayValues[ index ];
        var currDisplayValModel = prop.displayValsModel[ index ];
        prop.dbValue.splice( index, 1 );
        prop.dbValue.splice( index + 1, 0, currDbVal );

        prop.displayValues.splice( index, 1 );
        prop.displayValues.splice( index + 1, 0, currDisplayVal );

        prop.displayValsModel.splice( index, 1 );
        prop.displayValsModel.splice( index + 1, 0, currDisplayValModel );

        prop.dirty = true;
    };

    const remove = ( prop, index ) => {
        index -= 2;
        prop.dbValue.splice( index, 1 );

        if( prop.hasLov ) {
            prop.displayValues.splice( index, 1 );

            if( prop.isArray ) {
                prop.displayValsModel = prop.displayValsModel || [];
                prop.displayValsModel.splice( index, 1 );
            }
        }
        prop.dirty = true;
    };

    const handleClick = ( name, isCtxProp, $index ) => event => {
        let vmProp = _.isNil( $index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, $index, isCtxProp );
        let vmPropName = _.isNil( $index ) ? name : name + '[' + $index + ']';
        let validateName = _.isNil( $index ) ? name : name + '_' + $index;
        let prop = { ...vmProp };
        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {
            let indexStr = event.currentTarget.attributes.id.value;
            let index = parseInt( indexStr );
            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';
            if( !isButtonClicked ) {
                let isAnyValueSelected = false;
                if( prop.displayValsModel ) {
                    for( var j = 0; j < prop.displayValsModel.length; j++ ) {
                        if( prop.displayValsModel[ j ].selected && prop.displayValsModel[ j ].isInEditMode ) {
                            isAnyValueSelected = true;
                            break;
                        }
                    }
                }
                if( !isAnyValueSelected ) {
                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {
                        prop.autofocus = true;
                        prop.currArrayDbValue = prop.dbValue.slice( 0 );
                        prop.displayValsModel[ index ].isInEditMode = true;
                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );
                        updateTouched( validateName );
                        validateField( validateName, {
                            [ validateName ]: prop
                        } );
                    } else {
                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {
                            if( i === index && !prop.lastSelected ) {
                                prop.displayValsModel[ i ].selected = true;
                                prop.lastSelected = prop.displayValsModel[ index ];
                            } else if( i === index && prop.lastSelected ) {
                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {
                                    prop.displayValsModel[ i ].selected = false;
                                    prop.lastSelected = undefined;
                                } else {
                                    prop.displayValsModel[ i ].selected = true;
                                    prop.lastSelected = prop.displayValsModel[ index ];
                                }
                            } else {
                                prop.displayValsModel[ i ].selected = false;
                            }
                        }
                        updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );
                        updateTouched( validateName );
                        event.stopPropagation();
                    }
                }
            } else {
                let hasActionHappened = false;
                let titleVal;
                if( event.currentTarget.attributes.title ) {
                    titleVal = event.currentTarget.attributes.title.value;
                }
                if( titleVal && titleVal === 'Move Up' && index > 0 ) {
                    moveUp( prop, index );
                    hasActionHappened = true;
                }
                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {
                    moveDown( prop, index );
                    hasActionHappened = true;
                }
                if( titleVal && titleVal === 'Remove' ) {
                    remove( prop, index );
                    hasActionHappened = true;
                }

                if( hasActionHappened ) {
                    updateValue( isCtxProp, vmPropName, createUpdateValue( prop, event ) );
                    updateTouched( validateName );
                    validateField( validateName, {
                        [ name ]: prop
                    } );
                }
            }
        }
    };
    const handleClickVMO = ( vmoName, propName, isCtxProp ) => event => {
        let vmProp = getVMPropForVMO( vmoName, propName );
        let prop = { ...vmProp };
        if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {
            let indexStr = event.currentTarget.attributes.id.value;
            let index = parseInt( indexStr );
            let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';
            if( !isButtonClicked ) {
                if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {
                    prop.autofocus = true;
                    prop.currArrayDbValue = prop.dbValue.slice( 0 );
                    prop.displayValsModel[ index ].isInEditMode = true;

                    let pathName = vmoName + '.props.' + propName;
                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );
                    updateTouched( propName );
                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );
                } else {
                    for( var i = 0; i < prop.displayValsModel.length; i++ ) {
                        if( i === index && !prop.lastSelected ) {
                            prop.displayValsModel[ i ].selected = true;
                            prop.lastSelected = prop.displayValsModel[ index ];
                        } else if( i === index && prop.lastSelected ) {
                            if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {
                                prop.displayValsModel[ i ].selected = false;
                                prop.lastSelected = undefined;
                            } else {
                                prop.displayValsModel[ i ].selected = true;
                                prop.lastSelected = prop.displayValsModel[ index ];
                            }
                        } else {
                            prop.displayValsModel[ i ].selected = false;
                        }
                    }
                    event.stopPropagation();
                }
            } else {
                let hasActionHappened = false;
                let titleVal = event.currentTarget.attributes.title.value;
                if( titleVal && titleVal === 'Move Up' && index > 0 ) {
                    moveUp( prop, index );
                    hasActionHappened = true;
                }
                if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {
                    moveDown( prop, index );
                    hasActionHappened = true;
                }
                if( titleVal && titleVal === 'Remove' ) {
                    remove( prop, index );
                    hasActionHappened = true;
                }

                if( hasActionHappened ) {
                    let pathName = vmoName + '.props.' + propName;
                    updateValue( isCtxProp, pathName, createUpdateValue( prop, event ) );
                    updateTouched( propName );
                    validateField( vmProp.propertyName, getVMOProps( vmoName ) );
                }
            }
        }
    };

    const handleBlur = ( name, isCtxProp, index ) => event => {
        let vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );
        name = _.isNil( index ) ? name : vmProp.propertyName;
        if( vmProp.isArray && event.isBlurFromInput ) {
            //This method does not fire a dispatch, only accepts a prop to update the input and validate it
            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it
            updateArray( vmProp, event );
        }
        uwPropertySvc.updateViewModelProperty( vmProp );
        validateField( name, {
            [ name ]: vmProp
        } );
    };

    const handleBlurVMO = ( vmoName, propName ) => event => {
        let vmProp = getVMPropForVMO( vmoName, propName );

        if( vmProp.isArray && event.isBlurFromInput ) {
            //This method does not fire a dispatch, only accepts a prop to update the input and validate it
            //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it
            updateArray( vmProp, event );
        }
        uwPropertySvc.updateViewModelProperty( vmProp );
        validateField( vmProp.propertyName, getVMOProps( vmoName ) );
    };

    const isValidArrayValue = ( viewModelProperty, valToUpdate ) => {
        var isValid = false;

        if( valToUpdate !== undefined && valToUpdate !== '' && valToUpdate !== null &&
            viewModelProperty.dbValue !== undefined ) {
            if( viewModelProperty.type === 'INTEGERARRAY' || viewModelProperty.type === 'DOUBLEARRAY' ||
                viewModelProperty.type === 'DATEARRAY' ) {
                if( isFinite( valToUpdate ) ) {
                    isValid = true;
                }
            } else if( viewModelProperty.type === 'BOOLEANARRAY' ) {
                isValid = _.isBoolean( valToUpdate );
            } else {
                isValid = true;
            }
        }
        return isValid;
    };

    const updateArray = ( prop, event ) => {
        let indexStr;
        let index;
        let valToUpdate;
        if( prop.type === 'DATEARRAY' ) {
            index = event.index;
            valToUpdate = new Date( event.target.value );
        } else {
            if( prop.type === 'BOOLEANARRAY' && prop.renderingHint === 'radiobutton' ) {
                if( event.target.defaultValue === 'true' ) {
                    valToUpdate = true;
                } else if( event.target.defaultValue === 'false' ) {
                    valToUpdate = false;
                }
                index = event.index;
            } else if( prop.type === 'BOOLEANARRAY' ) {
                valToUpdate = event.target.checked;
                index = event.index;
            } else {
                indexStr = event.currentTarget.attributes.id.value;
                index = parseInt( indexStr );
                valToUpdate = event.currentTarget.value;
            }
        }
        if( isValidArrayValue( prop, valToUpdate ) && ( !prop.error || prop.hasServerValidationError ) ) {
            if( prop.currArrayDbValue ) {
                prop.currArrayDbValue.splice( index, 1, valToUpdate );
                prop.dirty = true;
                prop.dbValue = prop.currArrayDbValue.slice( 0 );
            }
        } else if( prop.dbValue === '' || prop.dbValue === null || prop.dbValue === undefined ) {
            prop.dbValue = prop.currArrayDbValue.slice( 0 );
        }

        if( prop.displayValsModel[ index ] && prop.dbValue.length > 0 ) {
            prop.displayValsModel[ index ].displayValue = prop.dbValue[ index ];
            prop.displayValsModel[ index ].isInEditMode = false;
            prop.displayValsModel[ index ].selected = false;
        }
        prop.lastSelected = undefined;
    };

    const createNewArrayVal = ( newVal, updateVal, event ) => {
        if( updateVal.type === 'DATEARRAY' ) {
            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {
                _.forEach( updateVal.dbValue, function( value ) {
                    if( value !== undefined && value !== '' ) {
                        newVal.push( value );
                    }
                } );
                if( event.target.value ) {
                    newVal.push( new Date( event.target.value ) );
                }
            } else if( event.target.value ) {
                newVal.push( new Date( event.target.value ) );
            }
        } else {
            if( _.isArray( updateVal.dbValue ) && updateVal.dbValue.length > 0 ) {
                _.forEach( updateVal.dbValue, function( value ) {
                    if( value !== undefined && value !== '' ) {
                        newVal.push( value );
                    }
                } );
            }
            if( event.target.value && updateVal.type !== 'BOOLEANARRAY' ) {
                newVal.push( event.target.value );
            }
            if( event.target.value && updateVal.type === 'BOOLEANARRAY' && updateVal.renderingHint === 'radiobutton' ) {
                newVal.push( event.target.value );
            }
            if( event.key === 'Enter' && updateVal.type === 'BOOLEANARRAY' && event.target.checked !== undefined && updateVal.renderingHint !== 'radiobutton' ) {
                newVal.push( event.target.checked );
            }
        }
    };

    const createUpdateValue = ( prevVal, event ) => {
        let updateVal = { ...prevVal };

        if( prevVal.type.toUpperCase() === 'DATEARRAY' && event.target.value === null ) {
            return updateVal;
        }

        let newVal;
        switch ( prevVal.type.toUpperCase() ) {
            case 'DATE':
                newVal = event.target.value ? Number( new Date( event.target.value ) ) : NULLDATE;
                break;
            case 'BOOLEAN':
                if( event.target.type === 'radio' ) {
                    newVal = event.target.value === 'true';
                } else {
                    newVal = event.target.checked;
                }
                break;
            case 'INTEGER':
                newVal = event.target.value.replace( /[^\+|\-|0-9]/g, '' );
                break;
            case 'DOUBLE':
                newVal = event.target.value.replace( /[^\+|\-|0-9\.|e]/g, '' );
                break;
            case 'DATETIME':
                newVal = new Date( event.target.value ).toLocaleTimeString();
                break;
            case 'OBJECT':
                newVal = Array.isArray( event.target.value ) && event.target.value.length > 0 ? event.target.value[ 0 ] : '';
                break;
            case 'OBJECTARRAY':
                if( !updateVal.hasLov ) {
                    newVal = _.clone( prevVal.dbValue );
                    _.forEach( event.target.value, function( value ) {
                        if( value !== undefined && value !== '' ) {
                            newVal.push( value );
                        }
                    } );
                } else {
                    newVal = [];
                    if( event.updateArray ) {
                        updateArray( updateVal, event );
                        _.forEach( updateVal.dbValue, function( value ) {
                            if( value !== undefined && value !== '' ) {
                                newVal.push( value );
                            }
                        } );
                    } else {
                        createNewArrayVal( newVal, updateVal, event );
                    }
                }
                break;
            case 'DOUBLEARRAY':
            case 'DATEARRAY':
            case 'INTEGERARRAY':
            case 'STRINGARRAY':
            case 'CHECKBOXARRAY':
            case 'BOOLEANARRAY': {
                newVal = [];
                if( event.updateArray ) {
                    updateArray( updateVal, event );
                    _.forEach( updateVal.dbValue, function( value ) {
                        if( value !== undefined && value !== '' ) {
                            newVal.push( value );
                        }
                    } );
                } else {
                    createNewArrayVal( newVal, updateVal, event );
                }
                break;
            }
            default:
                newVal = event.target.value;
        }
        uwPropertySvc.setValue( updateVal, newVal );
        return updateVal;
    };

    const getVMO = ( vmoName, isCtxProp ) => {
        const lData = isCtxProp ? ctx : viewModel.getData();
        const vmo = _.get( lData, vmoName );
        if( vmo ) {
            return vmo;
        }
        return undefined;
    };

    const getAutofocusVMO = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.autofocus;
        }
        return undefined;
    };

    const getAutofocus = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.autofocus;
    };

    const getVMOProps = ( vmoName ) => {
        let vmo = getVMO( vmoName );
        if( vmo && vmo.props ) {
            return vmo.props;
        }
        return undefined;
    };

    const getVMPropForVMO = ( vmoName, propName ) => {
        let vmo = getVMO( vmoName );
        if( vmo && vmo.props && vmo.props[ propName ] ) {
            return vmo.props[ propName ];
        }
        return undefined;
    };

    const getValueVMO = ( vmProp ) => {
        if( vmProp && vmProp.type === 'BOOLEAN' ) {
            if( vmProp.dbValue === '' ) {
                return undefined;
            }

            if( declUtils.isNil( vmProp.dbValue ) ) {
                return null;
            }

            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';
        }
        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';
    };

    const getValue = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && vmProp.type === 'BOOLEAN' ) {
            if( vmProp.dbValue === '' ) {
                return undefined;
            }
            if( declUtils.isNil( vmProp.dbValue ) ) {
                return null;
            }

            return String( vmProp.dbValue ) === 'true' || String( vmProp.dbValue ) === 'TRUE';
        }
        return vmProp && !_.isUndefined( vmProp && vmProp.dbValue ) ? vmProp.dbValue : '';
    };

    const getTouched = name => {
        let touchedState = getTouchedState();
        return touchedState[ name ] ? 'true' : 'false';
    };

    const getErrorsVMPArray = function( name, index ) {
        let errors = getErrorsState();
        let isTouched = getTouched( name + '_' + index );
        return isTouched === 'true' ? errors[ name + '_' + index ] : undefined;
    };

    const getErrors = function( name, rootPath, path ) {
        let errors = getErrorsState();
        if( !_.isNil( rootPath ) ) {
            let atomicPath = rootPath + '.' + path;
            atomicPath = atomicPath.replace( /\./g, '_' );
            atomicPath = atomicPath.replace( /\[/g, '_' );
            atomicPath = atomicPath.replace( /\]/g, '' );
            let isTouched = getTouched( atomicPath );
            return isTouched === 'true' ? errors[ atomicPath ] : undefined;
        }
        let isTouched = getTouched( name );
        return isTouched === 'true' ? errors[ name ] : undefined;
    };

    const getAtomicVmProp = ( name, isCtxProp, index, isAtomic = false, viewProp = null ) => {
        let vmProp;
        if( isAtomic && viewProp ) {
            vmProp = viewProp;
        } else {
            vmProp = _.isNil( index ) ? getVmProp( isCtxProp, name ) : getVmPropFromList( name, index, isCtxProp );
        }
        return vmProp;
    };

    const getPropertyDisplayName = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';
        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value
        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;
    };

    const getPropertyDisplayNameVMO = ( vmProp ) => {
        const propDisplayName = vmProp && vmProp.propertyDisplayName ? vmProp.propertyDisplayName : '';
        // Objects as a child prop not supported by react, property display names could be object if there is a paramterized i18n value
        return typeof propDisplayName === 'object' && propDisplayName.text ? propDisplayName.text : propDisplayName;
    };

    const getPlaceHolder = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        let placeholder = '';
        if( !vmProp ) {
            return placeholder;
        }
        let propertyType = getPropertyType( name, isCtxProp, index );
        switch ( propertyType && propertyType.toUpperCase() ) {
            case 'DATEARRAY':
            case 'DATE':
                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';
                break;
            default:
                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {
                    placeholder = vmProp.propertyRequiredText;
                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {
                    placeholder = vmProp.propertyRequiredText;
                } else {
                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';
                }
        }
        return placeholder;
    };

    const getPlaceHolderVMO = ( vmProp ) => {
        let placeholder = '';
        if( !vmProp ) {
            return placeholder;
        }
        let propertyType = vmProp.type;
        switch ( propertyType && propertyType.toUpperCase() ) {
            case 'DATEARRAY':
            case 'DATETIME':
                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY HH:mm' : '';
                break;
            case 'DATE':
                placeholder = vmProp.isEditable ? 'DD-MMM-YYYY' : '';
                break;
            case 'TIME':
                placeholder = vmProp.isEditable ? 'HH:mm:ss' : '';
                break;
            default:
                if( vmProp.isEditable && vmProp.isRequired && vmProp.propertyRequiredText ) {
                    placeholder = vmProp.propertyRequiredText;
                } else if( vmProp.isEditable && !vmProp.isRequired && vmProp.propertyRequiredText ) {
                    placeholder = vmProp.propertyRequiredText;
                } else {
                    placeholder = vmProp.isEditable && vmProp.isRequired ? 'Required' : '';
                }
        }
        return placeholder;
    };

    const getUIValue = ( name, isCtxProp, index, isAtomic, viewProp, key = 'uiValue' ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp[ key ];
    };

    const getUIValueVMO = ( vmProp, key = 'uiValue' ) => {
        if( vmProp ) {
            return vmProp[ key ];
        }
        return undefined;
    };

    const getRenderingHint = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.renderingHint;
    };

    const getRenderingHintVMO = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.renderingHint;
        }
        return undefined;
    };

    const getPropertyType = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {
            return 'DATETIME';
        }
        return vmProp && vmProp.type;
    };

    const getPropertyTypeVMO = ( vmProp ) => {
        if( vmProp && ( vmProp.type === 'DATE' && vmProp.dateApi && vmProp.dateApi.isDateEnabled && vmProp.dateApi.isTimeEnabled ) ) {
            return 'DATETIME';
        }
        return vmProp && vmProp.type;
    };

    const getRequired = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.isRequired;
    };

    const getRequiredVMO = ( vmProp ) => {
        return vmProp && vmProp.isRequired;
    };

    const getMaxLength = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.maxLength;
    };

    const getMaxLengthVMO = ( vmProp ) => {
        return vmProp && vmProp.maxLength;
    };

    const getPropertyRadioTrueText = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {
            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';
        }
        return undefined;
    };

    const getPropertyRadioTrueTextVMO = ( vmProp ) => {
        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {
            return vmProp.propertyRadioTrueText ? vmProp.propertyRadioTrueText : 'True';
        }
        return undefined;
    };

    const getPropertyRadioFalseText = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {
            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';
        }
        return undefined;
    };

    const getPropertyRadioFalseTextVMO = ( vmProp ) => {
        if( vmProp && ( vmProp.type === 'BOOLEAN' || vmProp.type === 'BOOLEANARRAY' ) ) {
            return vmProp.propertyRadioFalseText ? vmProp.propertyRadioFalseText : 'False';
        }
        return undefined;
    };

    const getDisplayValsModel = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||
                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||
                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {
            return vmProp.displayValsModel;
        }
        return undefined;
    };

    const getDisplayValsModelVMO = ( vmProp ) => {
        if( vmProp && ( vmProp.type === 'STRINGARRAY' || vmProp.type === 'INTEGERARRAY' ||
                vmProp.type === 'DATEARRAY' || vmProp.type === 'DOUBLEARRAY' ||
                vmProp.type === 'BOOLEANARRAY' || vmProp.type === 'OBJECTARRAY' ) ) {
            return vmProp.displayValsModel;
        }
        return undefined;
    };

    const getDateApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {
            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {
                uwPropertySvc.initializeDateApiValues( vmProp );
            }
            return vmProp.dateApi;
        }
        return undefined;
    };

    const getDateApiVMO = ( vmProp ) => {
        if( vmProp && ( vmProp.type === 'DATEARRAY' || vmProp.type === 'DATE' || vmProp.type === 'DATETIME' ) ) {
            if( vmProp.dateApi && vmProp.dateApi.isDateEnabled && !vmProp.dateApi.dateValue && vmProp.dbValue ) {
                uwPropertySvc.initializeDateApiValues( vmProp );
            }
            return vmProp.dateApi;
        }
        return undefined;
    };

    const getIsLov = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.hasLov;
    };
    const getIsLovVMO = ( vmProp ) => {
        return vmProp && vmProp.hasLov;
    };

    const getLovApiVMO = ( vmProp ) => {
        return vmProp && vmProp.lovApi;
    };

    const getDataProvider = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( !vmProp ) {
            return undefined;
        }

        // case dynamic dataProvider
        if( _.isFunction( vmProp.dataProvider ) ) {
            return vmProp.dataProvider();
        }

        return vmProp.dataProvider && dataProviders && dataProviders[ vmProp.dataProvider ] ? dataProviders[ vmProp.dataProvider ] : null;
    };

    const getDataProviderVMO = ( vmProp ) => {
        return vmProp && vmProp.dataProvider;
    };

    const getIsArray = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.isArray;
    };

    const getIsArrayVMO = ( vmProp ) => {
        return vmProp && vmProp.isArray;
    };

    const getLovApi = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && vmProp.lovApi ) {
            return vmProp.lovApi;
        }
        return null;
    };

    const getEditArrayInlineMode = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.editArrayInlineMode;
    };

    const getEditArrayInlineModeVMO = ( vmProp ) => {
        return vmProp && vmProp.editArrayInlineMode;
    };

    const getNumberOfLines = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.numberOfLines;
    };

    const getNumberOfLinesVMO = ( vmProp ) => {
        return vmProp && vmProp.numberOfLines;
    };

    // compute the label position
    // the precedence is like this:
    // 1. class in view (sw-row / sw-column / sw-reverse)
    // 2. v-m prop.labelPosition
    // 3. boolean and object use label at end
    // 4. editable props use label at top
    const getLabelPlacement = ( vmProp ) => {
        var labelPlacement = '';

        if( !vmProp ) {
            return labelPlacement;
        }

        // get rid of editLayoutSide and consolidate positioning here?
        // revisitMe ulrey. discuss with Nihar?
        switch ( vmProp.propertyLabelDisplay ) {
            case 'PROPERTY_LABEL_AT_RIGHT':
                labelPlacement = 'end';
                break;
            case 'PROPERTY_LABEL_AT_TOP':
                labelPlacement = 'top';
                break;
            case 'PROPERTY_LABEL_AT_SIDE':
                labelPlacement = 'start';
                break;
            case 'NO_PROPERTY_LABEL':
                // revistMe scott: is <aw-widget labeldisplay="Headless"> also supported?
                labelPlacement = 'none';
                break;
            default:
                labelPlacement = 'default';
        }
        return labelPlacement;
    };

    const getLabelPlacementFromData = ( propName, vmoName, index, isAtomic = false, viewProp ) => {
        const vmProp = isAtomic && viewProp ? viewProp : vmoName ? getVMPropForVMO( vmoName, propName ) : !declUtils.isNil( index ) ? data[ propName ][ index ] : data[ propName ];
        return getLabelPlacement( vmProp );
    };

    /**
     * Check if prop is dirty
     * if uncommitted value changes, but is reverted: dirty=false
     * @param {object} vmProp view model property
     * @returns {boolean} true if prop is dirty
     */
    const dirtyCheck = ( vmProp ) => {
        // deal with case where null !== emptystring if( vmProp.valueUpdated || vmProp.displayValueUpdated ) {
        if( _.isNil( vmProp.value ) && _.isNil( vmProp.newValue ) ) {
            return false;
        }
        return ( vmProp.valueUpdated || vmProp.displayValueUpdated ) && !_.isEqual( vmProp.value, vmProp.newValue );
    };

    /**
     * Check if prop is dirty
     * @param {string} name property namne
     * @param {boolean} isCtxProp is prop from ctx (optional)
     * @returns {boolean} true if prop is dirty / undefined if clean
     */
    const isPropDirty = ( name, isCtxProp, index, isAtomic = false, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        if( vmProp && dirtyCheck( vmProp ) ) {
            return 'true';
        }
        return undefined;
    };

    /**
     * Check if vmo prop is dirty
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {boolean} true if prop is dirty / undefined if clean
     */
    const isPropDirtyVMO = ( vmProp ) => {
        if( vmProp && dirtyCheck( vmProp ) ) {
            return 'true';
        }
        return undefined;
    };

    /**
     * Gets pattern for VMO
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {object} patterns object
     */
    const getPatterns = ( vmProp ) => {
        if( vmProp && vmProp.patterns ) {
            return vmProp.patterns;
        }
        return undefined;
    };

    /**
     * Gets preferred pattern
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {string} preferred patterns value
     */
    const getPreferredPattern = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.preferredPattern;
        }
        return undefined;
    };

    const getPreferredPatternVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );
        if( vmProp ) {
            return vmProp.preferredPattern;
        }
        return undefined;
    };

    const getAutoAssignVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );
        if( vmProp ) {
            return vmProp.isAutoAssign;
        }
        return undefined;
    };

    const getAutoAssignableVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );
        if( vmProp ) {
            return vmProp.isAutoAssignable;
        }
        return undefined;
    };

    const getPatternAutoAssignFlagsVMO = ( propName, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( propName, isCtxProp, index, isAtomic, viewProp );
        if( vmProp ) {
            return vmProp.patternAutoAssignFlags;
        }
        return undefined;
    };

    /**
     * Gets isAutoAssign boolean value for the patterns
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {boolean} isAutoAssign bool value
     */
    const getIsAutoAssign = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.isAutoAssign;
        }
        return undefined;
    };

    const getIsAutoAssignVMPArray = ( propName, isCtxProp, index ) => {
        const vmProp = getAtomicVmProp( propName, isCtxProp, index );
        if( vmProp ) {
            return vmProp.isAutoAssign;
        }
        return undefined;
    };

    /**
     * Gets isAutoAssignable boolean value for the patterns
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {boolean} isAutoAssignable bool value
     */
    const getIsAutoAssignable = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.isAutoAssignable;
        }
        return undefined;
    };

    /**
     * Gets patternAutoAssignFlags value for the patterns
     * @param {string} vmoName view-model object name
     * @param {string} propName property name
     * @returns {object} PatternAutoAssignFlags object
     */
    const getPatternAutoAssignFlags = ( vmProp ) => {
        if( vmProp ) {
            return vmProp.patternAutoAssignFlags;
        }
        return undefined;
    };

    /**
     * Gets parent uid
     * @param {string} vmoName view-model object name
     * @param {string} vmProp property name
     * @param {boolean} isCtxProp property name
     * @returns {string} parent uid
     */
    const getParentUid = ( vmoName, vmProp, isCtxProp ) => {
        if( vmProp && ( vmProp.patterns || vmProp.patternAutoAssignFlags ) ) {
            const vmo = getVMO( vmoName, isCtxProp );
            return vmo && vmo.uid ? vmo.uid : undefined;
        }
        return undefined;
    };

    const handleReset = () => {
        // revisitme - spond
        // HINT: In reset case, we need to consider all extra data we put in data store rather than
        // reset the whole data store to data def
        updateData( { value: { ...data, ...createData( { i18n } ) } } );
        setTouched( {} );
        updateErrors( {} );
        setFormValidity( getStateCollection( viewModel ) );
    };

    const getAction = ( name, isCtxProp, index, isAtomic, viewProp ) => {
        const vmProp = getAtomicVmProp( name, isCtxProp, index, isAtomic, viewProp );
        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;
    };

    const getActionVMO = ( vmProp ) => {
        return vmProp && vmProp.action && viewModel.actions && viewModel.actions[ vmProp.action ] ? viewModel.actions[ vmProp.action ] : null;
    };

    const constructFieldForNamedPropertyVMO = ( vmoName, propName, isCtxProp = null ) => {
        let vmProp = getVMPropForVMO( vmoName, propName );
        return {
            name: propName,
            onChange: handleChangeVMO( vmoName, propName, isCtxProp ),
            onBlur: handleBlurVMO( vmoName, propName ),
            onClick: handleClickVMO( vmoName, propName, isCtxProp ),
            value: getValueVMO( vmProp ),
            checked: getValueVMO( vmProp ),
            touched: getTouched( propName ),
            label: getPropertyDisplayNameVMO( vmProp ),
            typex: getPropertyTypeVMO( vmProp ),
            error: getErrors( propName ),
            required: getRequiredVMO( vmProp ),
            maxLength: getMaxLengthVMO( vmProp ),
            placeholder: getPlaceHolderVMO( vmProp ),
            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),
            dirty: isPropDirtyVMO( vmProp ),
            'data-locator': getPropertyDisplayNameVMO( vmProp ),
            'aria-label': getPropertyDisplayNameVMO( vmProp ),
            'aria-required': getRequiredVMO( vmProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute
            setLovVal: setLovDataValVMO( vmoName, propName, isCtxProp ),
            vmo: getVMO( vmoName, isCtxProp ),
            update: setValueForVmo( vmoName, propName, isCtxProp ),
            autoFocus: getAutofocusVMO( vmProp ),
            __vmprop__: () => vmProp,
            fielddata: {
                uiValue: getUIValueVMO( vmProp ),
                uiValues: getUIValueVMO( vmProp, 'uiValues' ),
                oldValue: getUIValueVMO( vmProp, 'oldValue' ),
                oldValues: getUIValueVMO( vmProp, 'oldValues' ),
                displayValues: getUIValueVMO( vmProp, 'displayValues' ),
                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),
                isEnabled: vmProp && vmProp.isEnabled,
                isSelectOnly: vmProp && vmProp.isSelectOnly,
                isEditable: vmProp && vmProp.isEditable,
                isLocalizable: vmProp && vmProp.isLocalizable,
                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',
                propertyDisplayName: getPropertyDisplayNameVMO( vmProp ),
                labelPlacement: getLabelPlacement( vmProp ),
                renderingHint: getRenderingHintVMO( vmProp ),
                propertyRadioTrueText: getPropertyRadioTrueTextVMO( vmProp ),
                propertyRadioFalseText: getPropertyRadioFalseTextVMO( vmProp ),
                radioVertical: vmProp && vmProp.vertical,
                displayValsModel: getDisplayValsModelVMO( vmProp ),
                numberOfLines: getNumberOfLinesVMO( vmProp ),
                dateApi: getDateApiVMO( vmProp ),
                isArray: getIsArrayVMO( vmProp ),
                hasLov: getIsLovVMO( vmProp ),
                dataProvider: getDataProviderVMO( vmProp ),
                editArrayInlineMode: getEditArrayInlineModeVMO( vmProp ),
                isRichText: vmProp && vmProp.isRichText,
                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry,
                patterns: getPatterns( vmProp ),
                preferredPattern: getPreferredPattern( vmProp ),
                lovApi: getLovApiVMO( vmProp ),
                action: getActionVMO( vmProp ),
                destPanelId: vmProp && vmProp.destPanelId,
                iconName: vmProp && vmProp.iconName,
                iconSource: vmProp && vmProp.iconSource,
                tooltip: vmProp && vmProp.tooltip,
                isAutoAssign: getIsAutoAssign( vmProp ),
                isAutoAssignable: getIsAutoAssignable( vmProp ),
                parentUid: getParentUid( vmoName, vmProp, isCtxProp ),
                propertyName: propName,
                patternAutoAssignFlags: getPatternAutoAssignFlags( vmProp ),
                hasRevRuleAttached: vmProp && vmProp.hasRevRuleAttached
            }
        };
    };

    const constructFieldForNamedProperty = ( propName, isCtxProp = null ) => {
        const vmProp = getVmProp( isCtxProp, propName );
        return {
            name: propName,
            onChange: handleChange( propName, isCtxProp ),
            onBlur: handleBlur( propName, isCtxProp ),
            onClick: handleClick( propName, isCtxProp ),
            value: getValue( propName, isCtxProp ),
            checked: getValue( propName, isCtxProp ),
            touched: getTouched( propName ),
            label: getPropertyDisplayName( propName, isCtxProp ),
            typex: getPropertyType( propName, isCtxProp ),
            error: getErrors( propName ),
            required: getRequired( propName, isCtxProp ),
            maxLength: getMaxLength( propName, isCtxProp ),
            placeholder: getPlaceHolder( propName, isCtxProp ),
            disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),
            dirty: isPropDirty( propName, isCtxProp ),
            'data-locator': getPropertyDisplayName( propName, isCtxProp ),
            'aria-label': getPropertyDisplayName( propName, isCtxProp ),
            'aria-required': getRequired( propName, isCtxProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute
            setLovVal: setLovDataVal( propName, isCtxProp ),
            update: setValue( propName, isCtxProp ),
            autoFocus: getAutofocus( propName, isCtxProp ),
            __vmprop__: () => vmProp,
            fielddata: {
                uiValue: getUIValue( propName, isCtxProp ),
                uiValues: getUIValue( propName, isCtxProp, null, false, null, 'uiValues' ),
                displayValues: getUIValue( propName, isCtxProp, null, false, null, 'displayValues' ),
                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),
                isEnabled: vmProp && vmProp.isEnabled,
                isSelectOnly: vmProp && vmProp.isSelectOnly,
                isEditable: vmProp && vmProp.isEditable,
                isLocalizable: vmProp && vmProp.isLocalizable,
                uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',
                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp ),
                labelPlacement: getLabelPlacementFromData( propName, isCtxProp ),
                renderingHint: getRenderingHint( propName, isCtxProp ),
                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp ),
                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp ),
                radioVertical: vmProp && vmProp.vertical,
                displayValsModel: getDisplayValsModel( propName, isCtxProp ),
                numberOfLines: getNumberOfLines( propName, isCtxProp ),
                dateApi: getDateApi( propName, isCtxProp ),
                isArray: getIsArray( propName, isCtxProp ),
                hasLov: getIsLov( propName, isCtxProp ),
                dataProvider: getDataProvider( propName, isCtxProp ),
                lovApi: getLovApi( propName, isCtxProp ),
                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp ),
                action: getAction( propName, isCtxProp ),
                iconName: vmProp && vmProp.iconName,
                iconSource: vmProp && vmProp.iconSource,
                tooltip: vmProp && vmProp.tooltip,
                parentUid: undefined,
                propertyName: propName,
                patterns: vmProp && vmProp.patterns,
                preferredPattern: vmProp && vmProp.preferredPattern,
                isAutoAssign: vmProp && vmProp.isAutoAssign,
                destPanelId: vmProp && vmProp.destPanelId,
                isRichText: vmProp && vmProp.isRichText,
                emptyLOVEntry: vmProp && vmProp.emptyLOVEntry
            }
        };
    };

    const constructFieldArrayOfNamedProperty = ( vmPropList, propName, isCtxProp = null ) => {
        let vmpFieldArray = [];
        _.forEach( vmPropList, function( value, index ) {
            if( value !== undefined && value !== '' ) {
                const vmProp = getVmPropFromList( propName, index, isCtxProp );
                let obj = {
                    name: vmProp.propertyName,
                    onChange: handleChange( propName, isCtxProp, index ),
                    onBlur: handleBlur( propName, isCtxProp, index ),
                    onClick: handleClick( propName, isCtxProp, index ),
                    value: getValue( propName, isCtxProp, index ),
                    checked: getValue( propName, isCtxProp, index ),
                    touched: getTouched( vmProp.propertyName ),
                    label: getPropertyDisplayName( propName, isCtxProp, index ),
                    typex: getPropertyType( propName, isCtxProp, index ),
                    error: getErrorsVMPArray( propName, index ),
                    required: getRequired( propName, isCtxProp, index ),
                    maxLength: getMaxLength( propName, isCtxProp, index ),
                    placeholder: getPlaceHolder( propName, isCtxProp, index ),
                    disabled: vmProp && ( !vmProp.isEnabled || !vmProp.isEditable ),
                    dirty: isPropDirty( propName, isCtxProp, index ),
                    'data-locator': getPropertyDisplayName( propName, isCtxProp, index ),
                    'aria-label': getPropertyDisplayName( propName, isCtxProp, index ),
                    'aria-required': getRequired( propName, isCtxProp,
                        index ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute
                    setLovVal: setLovDataVal( propName, isCtxProp, index ),
                    update: setValue( propName, isCtxProp, index ),
                    autoFocus: getAutofocus( propName, isCtxProp, index ),
                    __vmprop__: () => vmProp,
                    fielddata: {
                        uiValue: getUIValue( propName, isCtxProp, index ),
                        uiValues: getUIValue( propName, isCtxProp, index, false, null, 'uiValues' ),
                        displayValues: getUIValue( propName, isCtxProp, index, false, null, 'displayValues' ),
                        convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),
                        isEnabled: vmProp && vmProp.isEnabled,
                        isSelectOnly: vmProp && vmProp.isSelectOnly,
                        isEditable: vmProp && vmProp.isEditable,
                        isLocalizable: vmProp && vmProp.isLocalizable,
                        uwAnchor: vmProp && vmProp.uwAnchor ? vmProp.uwAnchor : '',
                        propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, index ),
                        labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index ),
                        renderingHint: getRenderingHint( propName, isCtxProp, index ),
                        propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index ),
                        propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index ),
                        radioVertical: vmProp && vmProp.vertical,
                        displayValsModel: getDisplayValsModel( propName, isCtxProp, index ),
                        numberOfLines: getNumberOfLines( propName, isCtxProp, index ),
                        dateApi: getDateApi( propName, isCtxProp, index ),
                        isArray: getIsArray( propName, isCtxProp, index ),
                        hasLov: getIsLov( propName, isCtxProp, index ),
                        dataProvider: getDataProvider( propName, isCtxProp, index ),
                        lovApi: getLovApi( propName, isCtxProp, index ),
                        editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index ),
                        action: getAction( propName, isCtxProp, index ),
                        iconName: vmProp && vmProp.iconName,
                        iconSource: vmProp && vmProp.iconSource,
                        tooltip: vmProp && vmProp.tooltip,
                        destPanelId: vmProp && vmProp.destPanelId,
                        isRichText: vmProp && vmProp.isRichText,
                        patterns: vmProp && vmProp.patterns,
                        preferredPattern: vmProp && vmProp.preferredPattern,
                        isAutoAssign: getIsAutoAssignVMPArray( propName, isCtxProp, index ),
                        parentUid: undefined,
                        propertyName: propName,
                        emptyLOVEntry: vmProp && vmProp.emptyLOVEntry
                    }
                };
                vmpFieldArray.push( obj );
            }
        } );
        return vmpFieldArray;
    };

    /**
     *
     * @param { string } path pathofAtomicData
     * @param { string } rootPath RootPath
     * @returns {object} partialObj
     */
    const createPartialField = ( path, rootPath ) => {
        return {
            get value() {
                return this.getValue();
            },
            getValue: () => {
                let rootObject = atomicDataRef[ rootPath ].getAtomicData();
                return path === '' ? rootObject : _.get( rootObject, path );
            },
            update: ( value ) => {
                let rootObject = atomicDataRef[ rootPath ].getAtomicData();
                if( path === '' ) {
                    rootObject = value;
                } else {
                    _.set( rootObject, path, { ...value } );
                }
                atomicDataRef[ rootPath ].setAtomicData( _.clone( rootObject ) );
                let atomicDataVmpCollection = filterFlatViewModelPropForAtomic( viewModel );
                if( Object.keys( atomicDataVmpCollection ).length > 0 ) {
                    let dataVmpCollection = filterFlatViewModelProps( viewModel.getData() );
                    let stateCollection = { ...dataVmpCollection, ...atomicDataVmpCollection };
                    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );
                    setFormValidity( stateCollection );
                }
            }
        };
    };

    /**
     *
     * @param {*} path String
     * @param {*} rootPath  String
     * @param {*} fieldType  String
     * @returns
     */
    const createFieldForAtomicData = ( path, rootPath, fieldType ) => {
        if( fieldType === 'partialField' ) {
            return createPartialField( path, rootPath );
        }
        return constructFieldForAtomicProperty( path, rootPath, fieldType );
    };
    /**
     * @param {*} path The path of partial state object with respect to state object
     * @param {*} rootPath  The root name of the state object
     * @param {*} fieldType The type of the field defined in meta
     * @returns { object }-
     */
    const constructFieldForAtomicProperty = ( path, rootPath, fieldType ) => {
        let rootObject = viewModel.atomicData[ rootPath ];
        let stateObj = _.get( rootObject, path );
        const propName = path.split( '.' )[ path.split( '.' ).length - 1 ];
        let viewProp = null;
        const vmo = { ...stateObj, props: {} };

        let prevFieldsRef = fieldsRef.current;
        let prevFieldObject = _.get( prevFieldsRef, rootPath + '.' + path, null );

        if( fieldType === 'viewModelObject' && stateObj && stateObj.props ) {
            Object.keys( stateObj.props ).forEach( ( propertyName ) => {
                viewProp = stateObj.props[ propertyName ];
                let prevField = prevFieldObject && prevFieldObject.props && prevFieldObject.props[ propertyName ];
                let path1 = `${path}.props.${propertyName}`;
                let newField = creatAtomicFields( propertyName, rootPath, viewProp, path1, fieldType, stateObj );
                if( isFieldsEqual( prevField, newField ) ) {
                    vmo.props[ propertyName ] = prevField;
                } else {
                    vmo.props[ propertyName ] = newField;
                }
            } );
            return vmo;
        } else if( fieldType === 'ViewModelProperty' ) {
            viewProp = stateObj;
        } else {
            viewProp = modelPropertySvc.createViewModelProperty( { ...stateObj, propName, type: fieldType } );
        }
        let newFieldObject = creatAtomicFields( propName, rootPath, viewProp, path, fieldType );
        if( isFieldsEqual( prevFieldObject, newFieldObject ) ) {
            return prevFieldObject;
        }
        return newFieldObject;
    };

    const creatAtomicFields = ( propName, rootPath, viewProp, path, fieldType, vmo = null,
        isCtxProp = false, index = null, isAtomic = true ) => {
        const updateAtomicData = ( event ) => {
            let rtObj = atomicDataRef[ rootPath ].getAtomicData();
            let atomicPath = path;
            if( path.split( '.' ).length > 3 ) {
                atomicPath = validateAndUpdateDCPPath( path );
            }
            if( event.persist ) {
                event.persist();
            }
            if( event.additionalProp ) {
                uwPropertySvc.updateViewModelProp( viewProp, null, event.additionalProp, false );
            }
            viewProp = createUpdateValue( viewProp, event );
            // This is required to do later instance check.
            // Mutating the object directly is not a good idea.
            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                _.set( rtObj, `${atomicPath}`, { ...viewProp } );
            } else {
                let val1 = _.get( rtObj, `${atomicPath}.value` );
                let val2 = _.get( rtObj, `${atomicPath}.value` );
                if( val1 === viewProp.dbValue && val2 === viewProp.dbValue ) {
                    return;
                }
                _.set( rtObj, `${atomicPath}.value`, viewProp.dbValue );
                _.set( rtObj, `${atomicPath}.dbValue`, viewProp.dbValue );
            }
            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                let atPath = rootPath + '.' + atomicPath;
                atPath = atPath.replace( /\./g, '_' );
                atPath = atPath.replace( /\[/g, '_' );
                atPath = atPath.replace( /\]/g, '' );
                validateField( atPath, {
                    [ atPath ]: viewProp
                } );
                updateTouched( atPath );
            }
            atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );
        };
        const getValue = () => {
            let rtObj = atomicDataRef[ rootPath ].getAtomicData();
            let atomicPath = path;
            if( path.split( '.' ).length > 3 ) {
                atomicPath = validateAndUpdateDCPPath( path );
            }
            return _.get( rtObj, `${atomicPath}.dbValue` );
        };

        const handleBlurAtomic = ( event ) => {
            let rtObj = atomicDataRef[ rootPath ].getAtomicData();
            let atomicPath = path;
            if( path.split( '.' ).length > 3 ) {
                atomicPath = validateAndUpdateDCPPath( path );
            }
            let vmProp = _.get( rtObj, `${atomicPath}` );

            if( vmProp.isArray && event.isBlurFromInput ) {
                //This method does not fire a dispatch, only accepts a prop to update the input and validate it
                //Hence, the ctxProp check is not required here as the api to fetch the property takes care of it
                updateArray( vmProp, event );
            }
            uwPropertySvc.updateViewModelProperty( vmProp );
            if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                let atPath = rootPath + '.' + atomicPath;
                atPath = atPath.replace( /\./g, '_' );
                atPath = atPath.replace( /\[/g, '_' );
                atPath = atPath.replace( /\]/g, '' );
                validateField( atPath, {
                    [ atPath ]: vmProp
                } );
            }
        };

        const handleClickAtomic = ( event ) => {
            let rtObj = atomicDataRef[ rootPath ].getAtomicData();
            let atomicPath = path;
            if( path.split( '.' ).length > 3 ) {
                atomicPath = validateAndUpdateDCPPath( path );
            }
            let vmProp = _.get( rtObj, `${atomicPath}` );
            let prop = { ...vmProp };
            if( prop.isArray && event.currentTarget.attributes.id && event.currentTarget.attributes.id.value ) {
                let indexStr = event.currentTarget.attributes.id.value;
                let index = parseInt( indexStr );
                let isButtonClicked = event.target.type === 'button' || event.currentTarget.type === 'button';
                if( !isButtonClicked ) {
                    if( prop.displayValsModel[ index ].selected && prop.type !== 'OBJECTARRAY' && !prop.hasLov ) {
                        prop.autofocus = true;
                        prop.currArrayDbValue = prop.dbValue.slice( 0 );
                        prop.displayValsModel[ index ].isInEditMode = true;

                        let newProp = createUpdateValue( prop, event );

                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                            _.set( rtObj, `${atomicPath}`, { ...newProp } );
                        } else {
                            let val1 = _.get( rtObj, `${atomicPath}.value` );
                            let val2 = _.get( rtObj, `${atomicPath}.value` );
                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {
                                return;
                            }
                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );
                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );
                        }
                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );
                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                            let atPath = rootPath + '.' + atomicPath;
                            atPath = atPath.replace( /\./g, '_' );
                            atPath = atPath.replace( /\[/g, '_' );
                            atPath = atPath.replace( /\]/g, '' );
                            validateField( atPath, {
                                [ atPath ]: newProp
                            } );
                            updateTouched( atPath );
                        }
                    } else {
                        for( var i = 0; i < prop.displayValsModel.length; i++ ) {
                            if( i === index && !prop.lastSelected ) {
                                prop.displayValsModel[ i ].selected = true;
                                prop.lastSelected = prop.displayValsModel[ index ];
                            } else if( i === index && prop.lastSelected ) {
                                if( prop.lastSelected.displayValue === prop.displayValsModel[ index ].displayValue ) {
                                    prop.displayValsModel[ i ].selected = false;
                                    prop.lastSelected = undefined;
                                } else {
                                    prop.displayValsModel[ i ].selected = true;
                                    prop.lastSelected = prop.displayValsModel[ index ];
                                }
                            } else {
                                prop.displayValsModel[ i ].selected = false;
                            }
                        }
                        event.stopPropagation();
                    }
                } else {
                    let hasActionHappened = false;
                    let titleVal = event.currentTarget.attributes.title.value;
                    if( titleVal && titleVal === 'Move Up' && index > 0 ) {
                        moveUp( prop, index );
                        hasActionHappened = true;
                    }
                    if( titleVal && titleVal === 'Move Down' && index <= prop.displayValsModel.length - 1 ) {
                        moveDown( prop, index );
                        hasActionHappened = true;
                    }
                    if( titleVal && titleVal === 'Remove' ) {
                        remove( prop, index );
                        hasActionHappened = true;
                    }

                    if( hasActionHappened ) {
                        let newProp = createUpdateValue( prop, event );
                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                            _.set( rtObj, `${atomicPath}`, { ...newProp } );
                        } else {
                            let val1 = _.get( rtObj, `${atomicPath}.value` );
                            let val2 = _.get( rtObj, `${atomicPath}.value` );
                            if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {
                                return;
                            }
                            _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );
                            _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );
                        }
                        atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );
                        if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                            let atPath = rootPath + '.' + atomicPath;
                            atPath = atPath.replace( /\./g, '_' );
                            atPath = atPath.replace( /\[/g, '_' );
                            atPath = atPath.replace( /\]/g, '' );
                            validateField( atPath, {
                                [ atPath ]: newProp
                            } );
                            updateTouched( atPath );
                        }
                    }
                }
            }
        };

        const setLovDataValAtomic = ( propName, isCtxProp, index, isAtomic, viewProp ) => ( { lovEntry, dataProvider, checkLovEntries, dateApi }, operation ) => {
            let rtObj = atomicDataRef[ rootPath ].getAtomicData();
            let atomicPath = path;
            if( path.split( '.' ).length > 3 ) {
                atomicPath = validateAndUpdateDCPPath( path );
            }
            let uiProperty = _.get( rtObj, `${atomicPath}` );

            return performLOVOperation( {
                uiProperty,
                vmo: vmo,
                lovEntry,
                dataProvider,
                createUpdateValue,
                checkLovEntries,
                dateApi
            }, operation ).then( ( { newProp, isPropertyUpdateReqd } ) => {
                if( newProp && isPropertyUpdateReqd ) {
                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                        _.set( rtObj, `${atomicPath}`, { ...newProp } );
                    } else {
                        let val1 = _.get( rtObj, `${atomicPath}.value` );
                        let val2 = _.get( rtObj, `${atomicPath}.value` );
                        if( val1 === newProp.dbValue && val2 === newProp.dbValue ) {
                            return;
                        }
                        _.set( rtObj, `${atomicPath}.value`, newProp.dbValue );
                        _.set( rtObj, `${atomicPath}.dbValue`, newProp.dbValue );
                    }
                    if( fieldType === 'ViewModelProperty' || fieldType === 'viewModelObject' ) {
                        let atPath = rootPath + '.' + atomicPath;
                        atPath = atPath.replace( /\./g, '_' );
                        atPath = atPath.replace( /\[/g, '_' );
                        atPath = atPath.replace( /\]/g, '' );
                        validateField( atPath, {
                            [ atPath ]: newProp
                        } );
                        updateTouched( atPath );
                    }
                    atomicDataRef[ rootPath ].setAtomicData( _.clone( rtObj ) );
                }
                return newProp;
            } );
        };
        return {
            name: propName,
            onChange: ( event ) => {
                updateAtomicData( event );
            },
            value: getValue(),
            getValue,
            onBlur: ( event ) => handleBlurAtomic( event ), // Need to fill in
            onClick: ( event ) => handleClickAtomic( event ), // Need to fill in
            update: ( value, additionalProp ) => {
                let event = {
                    target: {
                        type: 'OBJECT',
                        value: value,
                        additionalProp : additionalProp
                    }
                };
                updateAtomicData( event );
            }, // Need to fill in
            checked: getValue(),
            touched: getTouched( propName ),
            label: getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),
            typex: getPropertyType( propName, isCtxProp, index, isAtomic, viewProp ),
            error: getErrors( propName, rootPath, path ),
            required: getRequired( propName, isCtxProp, index, isAtomic, viewProp ),
            maxLength: getMaxLength( propName, isCtxProp, index, isAtomic, viewProp ),
            placeholder: getPlaceHolder( propName, isCtxProp, index, isAtomic, viewProp ),
            disabled: viewProp && ( !viewProp.isEnabled || !viewProp.isEditable ),
            setLovVal: setLovDataValAtomic( propName, isCtxProp, index, isAtomic, viewProp ),
            dirty: isPropDirty( propName, isCtxProp, index, isAtomic, viewProp ),
            'data-locator': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),
            'aria-label': getPropertyDisplayName( propName, isCtxProp, index, isAtomic, viewProp ),
            'aria-required': getRequired( propName, isCtxProp, index, isAtomic,
                viewProp ), //https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-required_attribute
            autoFocus: getAutofocus( propName, isCtxProp ),
            vmo: vmo,
            __vmprop__: () => viewProp,
            fielddata: {
                uiValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValue' ),
                uiValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'uiValues' ),
                displayValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'displayValues' ),
                convertToHtml: ( value ) => convertToHtml( value, isCtxProp ),
                oldValue: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValue' ),
                oldValues: getUIValue( propName, isCtxProp, index, isAtomic, viewProp, 'oldValues' ),
                isEnabled: viewProp && viewProp.isEnabled,
                isSelectOnly: viewProp && viewProp.isSelectOnly,
                isEditable: viewProp && viewProp.isEditable,
                isLocalizable: viewProp && viewProp.isLocalizable,
                uwAnchor: viewProp && viewProp.uwAnchor ? viewProp.uwAnchor : '',
                propertyDisplayName: getPropertyDisplayName( propName, isCtxProp, null, isAtomic, viewProp ),
                labelPlacement: getLabelPlacementFromData( propName, isCtxProp, index, isAtomic, viewProp ),
                renderingHint: getRenderingHint( propName, isCtxProp, index, isAtomic, viewProp ),
                propertyRadioTrueText: getPropertyRadioTrueText( propName, isCtxProp, index, isAtomic, viewProp ),
                propertyRadioFalseText: getPropertyRadioFalseText( propName, isCtxProp, index, isAtomic, viewProp ),
                radioVertical: viewProp && viewProp.vertical,
                displayValsModel: getDisplayValsModel( propName, isCtxProp, index, isAtomic, viewProp ),
                numberOfLines: getNumberOfLines( propName, isCtxProp, index, isAtomic, viewProp ),
                dateApi: getDateApi( propName, isCtxProp, index, isAtomic, viewProp ),
                isArray: getIsArray( propName, isCtxProp, index, isAtomic, viewProp ),
                hasLov: getIsLov( propName, isCtxProp, index, isAtomic, viewProp ),
                dataProvider: getDataProvider( propName, isCtxProp, index, isAtomic, viewProp ),
                lovApi: getLovApi( propName, isCtxProp, index, isAtomic, viewProp ),
                editArrayInlineMode: getEditArrayInlineMode( propName, isCtxProp, index, isAtomic, viewProp ),
                action: getAction( propName, isCtxProp, index, isAtomic, viewProp ),
                iconName: viewProp && viewProp.iconName,
                iconSource: viewProp && viewProp.iconSource,
                tooltip: viewProp && viewProp.tooltip,
                patterns: viewProp && viewProp.patterns,
                preferredPattern: getPreferredPatternVMO( propName, isCtxProp, index, isAtomic, viewProp ),
                propertyName: propName,
                parentUid: vmo ? vmo.uid : undefined,
                isAutoAssign: getAutoAssignVMO( propName, isCtxProp, index, isAtomic, viewProp ),
                isAutoAssignable: getAutoAssignableVMO( propName, isCtxProp, index, isAtomic, viewProp ),
                patternAutoAssignFlags: getPatternAutoAssignFlagsVMO( propName, isCtxProp, index, isAtomic, viewProp ),
                emptyLOVEntry: viewProp && viewProp.emptyLOVEntry,
                destPanelId: viewProp && viewProp.destPanelId,
                isRichText: viewProp && viewProp.isRichText,
                hasRevRuleAttached: viewProp && viewProp.hasRevRuleAttached
            }

        };
    };

    let fields = createAllFields( data,
        atomicData,
        declViewModelJson,
        createFieldForAtomicData,
        createFieldsBasedOnMetaData,
        constructFieldForNamedPropertyVMO,
        constructFieldArrayOfNamedProperty,
        constructFieldForNamedProperty,
        ctx, fieldsRef );

    fieldsRef.current = fields;

    const hasErrors = () => {
        let formErrors = getErrorsState();
        let hasError = false;
        if( formErrors ) {
            Object.keys( formErrors || {} ).forEach( value => {
                if( formErrors[ value ] ) {
                    hasError = true;
                }
            } );
        }
        return hasError;
    };

    const handleSubmit = async ( event, submitAction ) => {
        event.preventDefault();
        setFormValidity( getStateCollection( viewModel ) );
        if( !hasErrors() ) {
            document.activeElement.blur(); // focus out from the form
            await submitAction();
            handleReset();
        } else {
            const focusOnFirstError = () => {
                let inputElements = event.currentTarget;
                for( let idx = 0; idx < inputElements.length; idx++ ) {
                    if( inputElements[ idx ].hasAttribute( 'error' ) ) {
                        inputElements[ idx ].focus();
                        break;
                    }
                }
            };
            focusOnFirstError();
        }
    };

    useInitHook( () => {
        setFormValidity( getStateCollection( viewModel ) );
        // 20201013 - skip no field case
        // const keys = Object.keys( fields );
        //if( keys.length > 0 ) {
        //let initValues = {};
        // Object.keys( fields ).forEach( field => {
        //     initValues[ field ] = fields[ field ] && fields[ field ].value;
        // } );
        //setInitialValues( initValues );
        //}
    } );
    /**
     * This function checks the pristine state of the Form.
     * If the form has been touched, this would return false, otherwise true.
     * @returns boolean true/false
     */
    const isFormDirty = () => {
        let touchedObj = getTouchedState();
        let isFormDirty = false;
        let keys = Object.keys( touchedObj );
        for( let i = 0; i < keys.length; i++ ) {
            let name = keys[ i ];
            if( touchedObj[ name ] ) {
                isFormDirty = true;
                break;
            }
        }
        return isFormDirty;
    };

    const formProp = {
        onSubmit: handleSubmit,
        onReset: handleReset,
        children: {},
        id: viewModel._internal.panelId,
        attributes: {
            noValidate: true,
            autoComplete: 'off',
            valid: getFormValidity(),
            dirty: isFormDirty()
        }
    };

    return {
        fields,
        formProp
    };
};

/**
 * Keeping props inside a Ref. This is to avoid the stale prop issue specially with the actions
 * fired on event subscription.getProps would ensure to give latest prop;
 * @param {*} props React Props Object
 * @return {*} callback function to get the latest prop
 */
const useProps = ( props ) => {
    const propRef = useRef( props );
    propRef.current = props;
    return React.useCallback( () => propRef.current, [ propRef ] );
};

/**
 * get view model context based on input
 * @param {object} vmDef view model instance factory
 * @param {object} subPanelContext sub panel context
 * @returns {object} view model context as:
 * {
 *     viewModel: {
 *         data,
 *         dispatch: function( { path: 'ctx.a', value: 3 } ) // way to update viewModel directly
 *     },
 *     actions: {
 *         myAction: executeAction.bind(null, 'myAction', vm)
 *     },
 *     ctx,
 *     fields: {
 *         first_name: {
 *             name: value,
 *             onChange: handleChange(value),
 *             onBlur: handleBlur(value),
 *             value: getValue(value),
 *             checked: getValue(value),
 *             touched: getTouched(value),
 *             propertyDisplayName: getPropertyDisplayName(value),
 *             label:  getPropertyDisplayName(value),
 *             typex: getPropertyType(value),
 *             helperText: getErrors(value),
 *             error: getErrors(value),
 *             required: getRequired(value),
 *             labelPlacement: getLabelPlacement(value),
 *             dirty: isModified(value)
 *         }
 *     },
 *     formSubmit: // Please bind this with form submit button
 * }
 */
/* eslint-disable react-hooks/rules-of-hooks */

export const useAfxViewModel = ( vmDef, prop, renderOptions, ctxImports ) => {
    const declViewModelJson = vmDef._internal.origDeclViewModelJson;
    const getProps = useProps( prop );
    let vmpCollRef = useRef( null );
    let vmpValidationSchema = useRef( null );

    let fieldsRef = useRef( null );
    const getFields = React.useCallback( () => fieldsRef.current, [ fieldsRef ] );

    const setFields = ( fields ) => {
        if( fieldsRef.current !== fields ) {
            fieldsRef.current = fields;
        }
    };

    // data
    const dataHook = useReducer( reducer, null, vmDef.createData );

    // fieldsdata
    const allAtomicData = useAtomicDataReducer( declViewModelJson );

    // ctx
    const { ctx, ctxMin, ctxDispatch } = useDerivedState( vmDef, prop, dataHook[ 0 ], ctxImports );
    const ctxHook = [ { ...ctx, ...ctxMin }, ctxDispatch ];

    // sync strategy ports
    const portsHook = useReducer( reducer, null, vmDef.createPorts );

    // subPanelContext
    useMemo( () => {
        updateSubPanelContext( vmDef._internal.origDeclViewModelJson.data, dataHook, prop.subPanelContext );
    }, [ prop.subPanelContext ] );

    let subscriptions = useRef( null );
    let editHandlerRef = useRef( null );

    //CommandsViewModel maintains its own lifecycle and has separate subscriptions from parent viewModel
    //E.g. Container view has some events and container view has commandbar so there are 2 viewmodels
    // and 2 subscriptions. Lifecycle of command viewModel subscription though is limited to command click
    // since runActionWithViewModel is not component, we need to declare useRef outside ( under component)
    let subscriptionsForCommands = useRef( null );
    /**
     * Run an action with a different view model from the one used by this component
     *
     * @param {Object} viewModelJson The unprocessed JSON
     * @param {String} actionId ID of the action to execute
     * @param {Object} scope (Optional) Additional properties to include in execution scope
     */
    const runActionWithViewModel = async ( viewModelJson, actionId, scope = {} ) => {
        const trace = new Debug( 'declViewModelService:actionId' );
        //get view model ready for executing action
        const commandVmDef = createDeclViewModel( viewModelJson, prop );
        commandVmDef.data = commandVmDef.data || {};

        /**
         * TODO: This takes ~1s for commandsViewModel. Options to fix are:
         *  1. Cache based on view model ID (so first command click is slow but rest are not)
         *    - Still results in processing more i18n than necessary
         *  2. Use lazy getter
         *    - viewModel.i18n[key] would now be a promise, which would have significant impact
         */
        commandVmDef.i18n = await awDuiLocalizationSvc.populateI18nMap( viewModelJson.i18n, null );
        const processedVm = processViewModel( commandVmDef, ctxHook, dataHook );
        const commandsViewModel = processedVm.viewModel;

        const subscriptionObject = setupLifeCycle( commandVmDef, commandsViewModel, ctxHook[ 0 ], () => prop, null, true, runActionWithViewModel, subscriptionsForCommands, getFields );

        //Actions being executed can access anything in ctx, even if useSelector hook is not setup
        const executionScope = {
            ...scope,
            data: commandsViewModel,
            ctx: ctxHook[ 0 ]
        };

        const result = await viewModelService.executeCommand( commandsViewModel, actionId, executionScope );
        //executeCommand is resolved after first action is complete. We have to wait on all following actions (triggered by events) to complete before resolving
        const resolveWhenCommandsViewModelIsNotActive = new Promise( ( resolve ) => {
            const intervalId = setInterval( () => {
                if( !commandsViewModel.getToken().isActive() ) {
                    clearInterval( intervalId );
                    return resolve();
                }
                trace( 'Action is still executing checking again in 50ms', actionId );
                return null;
            }, 50 );
        } );
        await resolveWhenCommandsViewModelIsNotActive;
        //cleanup the view model
        subscriptionObject();
        return result;
    };

    // view model
    const { viewModel, grids } = processViewModel( vmDef, ctxHook, dataHook, portsHook, allAtomicData, getProps, runActionWithViewModel, getFields );

    // i18n
    const [ i18n, i18nLoaded ] = useI18n( viewModel );
    viewModel.i18n = i18n;

    let stateCollection = getStateCollection( viewModel );
    updateValidationSchema( viewModel, vmpCollRef, vmpValidationSchema, getProps, stateCollection );

    // form
    const { fields, formProp } = useAfxForm( vmDef, viewModel, ctxHook[ 0 ], dataHook, i18n, vmDef._internal.origDeclViewModelJson, getProps, fieldsRef, vmpCollRef, vmpValidationSchema );
    setFields( fields );

    let dataCtxNode = {
        props: prop,
        data: viewModel,
        ctx: ctxHook[ 0 ],
        subPanelContext: prop.subPanelContext,
        ports: viewModel.ports,
        getProps,
        getFields,
        fields
    };

    // selectionModels
    viewModel.selectionModels = useSelectionModels( vmDef._internal.selectionModels, dataCtxNode );

    useDataProviders( vmDef.dataProviders, getProps, dataCtxNode );

    // tableContext
    const [ gridContextPlaceholder, gridContextDispatcher ] = useGridContext( prop );
    useGrids( vmDef.grids, dataCtxNode, vmDef.dataProviders, gridContextPlaceholder, gridContextDispatcher, viewModel, getProps );

    // Setup lifecycle
    // NOTE: it should be setupLifeCycle, but there is a eslint rule to force the function name to be 'useXXX'
    useInitHook( () => setupLifeCycle( vmDef, viewModel, ctxHook[ 0 ], getProps, renderOptions, false, runActionWithViewModel, subscriptions, getFields ), i18nLoaded );

    useInitHook( () => declDragAndDropService.updateDeps( viewModel ) );

    // grids
    if( i18nLoaded === true ) {
        for( const gridDefKey in grids ) {
            let gridInstance = grids[ gridDefKey ];
            gridInstance.i18nLoaded = i18nLoaded;
        }
    }

    useGrid( prop, vmDef.getPanelId(), gridContextPlaceholder, gridContextDispatcher, runActionWithViewModel );

    //lovs
    useLOVs( fields, prop, viewModel, renderOptions );

    // initialize popups
    usePopups( viewModel );

    //messages

    const messages = useMessages( viewModel, fields );

    // drag and drop
    declDragAndDropService.setupDragAndDrop( viewModel, dataCtxNode, getProps );

    //update Event subscriptions
    updateSubscriptions( subscriptions.current, viewModel );

    useCommands( viewModel, prop, renderOptions );

    for( let key in viewModel.declViewModelJson.conditions ) {
        conditionService.registerWatch( viewModel.conditions, viewModel, key, [ viewModel.declViewModelJson.conditions[ key ].expression ], vmDef.oldExpressions );
    }
    vmDef.oldExpressions = viewModel.expressions;

    if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate && Array.isArray( viewModel.declViewModelJson.lifecycleHooks.onUpdate ) ) {
        _.forEach( viewModel.declViewModelJson.lifecycleHooks.onUpdate, function( onUpdateDef, i ) {
            let observerObjs = [];
            if( viewModel.declViewModelJson.lifecycleHooks && onUpdateDef ) {
                let obj = onUpdateDef;
                let evContext = { props: prop, viewModel, fields: getFields() };
                _.forEach( obj.observers, function( observer ) {
                    let evaluatedObj = _.get( evContext, observer );
                    //populate observers irrespective of their value
                    //This aids usecases where initial values for observers are null/undefined and are populated eventually
                    observerObjs.push( evaluatedObj );
                } );
            }

            useEffect( function() {
                //don't execute hook if all parameters are undefined
                if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {
                    if( logger.isDeclarativeLogEnabled() ) {
                        debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );
                    }
                    debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );
                    viewModel.lifecycleHooks.onUpdate[ i ]( renderOptions );
                }
            }, observerObjs );
        } );
    } else {
        let observerObjs = [];
        if( viewModel.declViewModelJson.lifecycleHooks && viewModel.declViewModelJson.lifecycleHooks.onUpdate ) {
            let obj = viewModel.declViewModelJson.lifecycleHooks.onUpdate;
            let evContext = { props: prop, viewModel, fields: getFields() };
            _.forEach( obj.observers, function( observer ) {
                let evaluatedObj = _.get( evContext, observer );
                //populate observers irrespective of their value
                //This aids usecases where initial values for observers are null/undefined and are populated eventually
                observerObjs.push( evaluatedObj );
            } );
        }

        useEffect( function() {
            //don't execute hook if all parameters are undefined
            if( observerObjs.filter( x => !_.isUndefined( x ) ).length ) {
                if( logger.isDeclarativeLogEnabled() ) {
                    debugService.debugLifecyleHooks( 'onUpdate', viewModel, observerObjs );
                }
                debugService.debug( 'lifeCycles', viewModel._internal.panelId, 'update' );
                executeHook( 'onUpdate', viewModel, prop, renderOptions );
            }
        }, observerObjs );
    }

    viewModel.editHandlers = useEditHandlers( vmDef._internal.editHandlers, viewModel, dataCtxNode, editHandlerRef, fields );

    // Edit handlers
    const editContexts = findEditContexts( viewModel );
    if( editContexts.length > 0 ) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEditHandlers2( viewModel );
    }

    // update Sync path
    let path = '';
    if( prop.viewId && prop.viewPath ) {
        let viewPathArray = prop.viewPath.split( '/' );
        if( prop.viewId === prop.viewPath ) {
            path = prop.viewPath;
        } else if( prop.viewId === viewPathArray[ viewPathArray.length - 1 ] ) {
            path = prop.viewPath;
        } else {
            path = prop.viewPath + '/' + prop.viewId;
        }
    } else if( prop.viewId ) {
        path = prop.viewId;
    }

    return {
        ctx: ctxMin,
        ctxDeprecated: ctx,
        ctxMin,
        viewModel,
        actions: viewModel.actions,
        i18n,
        fields,
        grids,
        formProp,
        messages,
        runActionWithViewModel,
        gridContextPlaceholder,
        gridContextDispatcher,
        viewPath: path
    };
};

/**
 * Edit handlers hook
 * @param {Object} viewModel View model
 */
export function useEditHandlers2( viewModel ) {
    useEffect( function() {
        editHandlerService.updateStates2( viewModel );
    } );
}

/**
 * Find edit contexts of view model
 * @param {Object} viewModel View model
 * @return {String} Edit contexts
 */
function findEditContexts( viewModel ) {
    let editContexts = [];
    if( viewModel.editHandlers ) {
        for( const editHandlerName in viewModel.editHandlers ) {
            if( !viewModel.editHandlers[ editHandlerName ].dataSource ) {
                editContexts.push( viewModel.editHandlers[ editHandlerName ].context );
            }
        }
    }
    if( viewModel.dataProviders ) {
        for( const dataProviderName in viewModel.dataProviders ) {
            const dataProvider = viewModel.dataProviders[ dataProviderName ];
            if( dataProvider.editContext ) {
                editContexts.push( dataProvider.editContext );
            }
        }
    }
    return editContexts;
}

/**
 * load subscriptions
 * @param {JSON} onEventDef onEvent definition
 * @param {ViewModelObject} vm view model object
 * @param {limitEventScope} limitEventScope Limit the event registration for certain view models like commands VM
 * @returns {Array} event subscriptions
 */
export function loadSubscriptions( onEventDef, vm, limitEventScope, getProps, runActionWithViewModel, getFields ) {
    // process event subscription
    const res = [];
    if( onEventDef ) {
        onEventDef.forEach( ( eventObj ) => {
            // - Construct a call back to process action.
            // - put vm to the scope of the fn and communicate to subscriber
            // - update that vm in every render cycle ( which is anti-pattern )
            if( !_.isEmpty( eventObj ) ) {
                const subscriber = eventData => {
                    const viewModel = subscriber.vm;
                    if( eventData && eventData.scope ) {
                        // Never mutate the existing eventData, it would causes issue when there are multiple subscriptions
                        // and the action associated with the event is async.
                        let newEventData = { ...eventData, scope: { ...eventData.scope } };
                        newEventData.scope.data = viewModel;
                        newEventData.scope.ctx = appCtxSvc.ctx;
                        handleRegisteredEvent( newEventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );
                    } else {
                        handleRegisteredEvent( eventData, viewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields );
                    }
                };
                subscriber.subDef = subscribe( eventObj.eventId, subscriber );
                subscriber.vm = vm;
                res.push( subscriber );
            }
        } );
    }
    return res;
}

/**
 * Update vm to scope in event subscriptions
 * @param {Array} subscriptions event subscriptions
 * @param {ViewModelObject} vm view model object
 */
export function updateSubscriptions( subscriptions, vm ) {
    if( subscriptions ) {
        subscriptions.forEach( subscriber => subscriber.vm = vm );
    }
}

/**
 * unload subscriptions from event bus
 * @param {Array} subscriptions event subscriptions
 */
export function unloadSubscriptions( subscriptions ) {
    subscriptions.forEach( subscriber => unsubscribe( subscriber.subDef ) && delete subscriber.vm );
    subscriptions.splice( 0, subscriptions.length );
}

/**
 * cleanup edit handlers
 * @param {Array} editHandlers  editHandlers
 * @param {Object} dataCtxNode dataCtxNode
 */
export function cleanupEditHandlers( editHandlers, dataCtxNode ) {
    if( editHandlers ) {
        for( const key in editHandlers ) {
            if( editHandlers[ key ] && editHandlers[ key ].context ) {
                let contextKey = editHandlers[ key ].context;
                if( contextKey && contextKey.match( /\{\{.*}}/g ) ) {
                    contextKey = AwInterpolateService.instance( contextKey )( dataCtxNode );
                }
                removeEditHandler( contextKey );
            }
        }
    }
}

const getDifferenceBetweenObjects = function( object, base ) {
    function changes( object, base ) {
        return _.transform( object, function( result, value, key ) {
            if( !_.isEqual( value, base[ key ] ) ) {
                result[ key ] = _.isObject( value ) && _.isObject( base[ key ] ) ? changes( value, base[ key ] ) : value;
            }
        } );
    }
    return changes( object, base );
};

const isObject = function( item ) {
    return item && typeof item === 'object' && !Array.isArray( item );
};

const mergeDeep = function( target, ...sources ) {
    if( !sources.length ) {
        return target;
    }
    const source = sources.shift();

    if( isObject( target ) && isObject( source ) ) {
        for( const key in source ) {
            if( isObject( source[ key ] ) ) {
                if( !target[ key ] ) {
                    Object.assign( target, {
                        [ key ]: {}
                    } );
                }
                mergeDeep( target[ key ], source[ key ] );
            } else {
                Object.assign( target, {
                    [ key ]: source[ key ]
                } );
            }
        }
    }

    return mergeDeep( target, ...sources );
};

/**
 * create react component based on view model JSON
 * @param {JSON} declViewModelJson view model definition
 * @param {Function} renderFn the renderFn, default null
 * @param {Object} options the render options
 * @returns {JSX.Element} context for view interpolation
 *
 */
export const createComponent = ( declViewModelJson, renderFn, options = {}, ctxImports ) => {
    const Component = prop => {
        splmStatsService.startComponentRenderTime();
        const [ vmDef ] = useState( () => createDeclViewModel( declViewModelJson, prop ) );
        const [ declViewModel ] = useState( () => declViewModelJson );
        let viewData = null;
        let elementsMap = useRef( new Map() );
        let ref = prop.domRef;
        if( !ref && options.elementRefList ) {
            viewData = {
                elementRefList: null
            };
            options.elementRefList.map( ( domElement ) => {
                if( !elementsMap.current.has( domElement ) ) {
                    elementsMap.current.set( domElement, createRef( null ) );
                }
            } );
            viewData.elementRefList = elementsMap.current;
            // How to update props ??
        }
        let { elementRefList, ...restOptionsParams } = { ...options };
        useVmoStore( prop, vmDef._internal.origDeclViewModelJson.props );
        const vm = useAfxViewModel( vmDef, prop, { ...viewData, ...restOptionsParams }, ctxImports );

        let { i18n, data, dispatch } = vm.viewModel;
        let createData = vmDef.createData;

        // deserve to put one more useRef since createData and createDeclViewModel is very expensive
        const hmrLastRef = useRef( null );
        useEffect( function useHmrEffect() {
            // console.log( 'hmrEffect triggered!' );
            // Merge new data into current data
            // TODO: Patch entire view model, maybe don't use hook approach to sync data.
            if( hmrLastRef.current !== null ) {
                const initialData = createData( i18n );
                const newData = createDeclViewModel( declViewModelJson, prop ).createData( i18n );
                const diffData = getDifferenceBetweenObjects( newData, initialData );
                let mergedData = null;
                if( !_.isEmpty( diffData ) ) {
                    mergedData = mergeDeep( data, diffData );
                    dispatch( { path: 'data', value: { ...mergedData } } );
                }
                hmrLastRef.current = declViewModel;
            }
        }, [ declViewModel ] );

        let props = { ...prop, ...vm };
        renderFn = renderFn || vmDef.renderFn;

        // support mixin (renderParams) based on render options
        if( !ref && options.elementRefList ) {
            props.elementRefList = viewData.elementRefList;
        }

        // initialize AwExtendedTooltip
        if( options && options.isTootip ) {
            let action = vm.actions.extendedTooltipPopup;
            // justification: hooks are called in the same order each time AwExtendedTooltip renders.
            // eslint-disable-next-line react-hooks/rules-of-hooks
            useEffect( () => {
                action.reference.current = prop.reference.current;
                action.userOptions.current = prop.extendedTooltipOptions;
            }, [ prop.reference.current ] );
        }

        if( options.registerCtx ) {
            // justification: hooks are called in the same order each time that component renders.
            // eslint-disable-next-line react-hooks/rules-of-hooks
            useEffect( () => {
                let { key, value, path } = options.registerCtx;
                appCtxSvc.registerCtx( prop.key || key, value || _.get( vm, path ) );
            } );
        }

        let component = renderFn( props );

        component = setDndHandler( vm, props, component );

        // generic style inheritance
        if( component && component.props && props && props.className ) {
            // don't repeat classes.... use simple string check
            if( !( component.props.className && component.props.className.includes( props.className ) ) ) {
                if( component.type && component.type.includes && component.type.includes( '-' ) ) {
                    component = React.cloneElement( component, { class: component.props.class + ' ' + props.className } );
                } else {
                    component = React.cloneElement( component, { className: component.props.className + ' ' + props.className } );
                }
            }
        }

        // inject ref prop by need
        if( ref && component ) {
            if( props.domRef ) {
                component = React.cloneElement( component, { ref, domRef: props.domRef } );
            } else {
                component = React.cloneElement( component, { ref } );
            }
        }

        // provide a opportunity to override appendToBody behavior through props
        if( options.usePortal && prop.enableAppend !== false ) {
            component = ReactDOM.createPortal( component, prop.parent || document.body );
        }

        splmStatsService.trackComponent( declViewModelJson._viewModelId );

        return component || null;
    };

    // Scenario: Verify zero group compile command with popup associated with ZCC (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:7
    // Scenario: Verify zero shuttle compile command (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:74
    // Scenario: Verify triangle and popup are not shown when there is only one visible command in the zero group compile command (attempt 2, retried)
    //     # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:40
    // Scenario: Verify zero shuttle compile command with/without label (attempt 2, retried) # out/cucumber_parallel/proc_p/zero-compile-group-command.feature:143
    // https://stackoverflow.com/questions/60453845/is-it-safe-to-usememo-for-jsx
    if( options.useMemo === false ) {
        Component.displayName = declViewModelJson._viewModelId;
        return Component;
    }

    Component.displayName = `${declViewModelJson._viewModelId}.memo`;
    return React.memo( Component );
};

const setDndHandler = function( vm, props, component ) {
    const dndHandlers = vm.viewModel.dndHandler || props.attachdndHandlers;
    if( dndHandlers ) {
        if( component && typeof component.type === 'string' ) {
            let dndListener = declDragAndDropService.setViewDnd( dndHandlers );
            component = React.cloneElement( component, { ...dndListener, className: component.props.className + ' aw-widgets-droppable' } );
        } else {
            if( component && component.props && !component.props.onDragEnter && component.type !== 'aw-splm-table' ) {
                component = React.cloneElement( component, { attachdndHandlers: dndHandlers } );
            }
        }
    }
    return component;
};
