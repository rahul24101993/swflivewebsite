// Copyright (c) 2021 Siemens
/* eslint-disable complexity */

/**
 * @module js/propValidationUtils
 */
import * as Yup from 'yup';
import _ from 'lodash';
import declUtils, { isNil } from 'js/declUtils';
import { isViewModelObject } from 'js/viewModelObjectService';
import { isViewModelProperty, isArrayOfViewModelProperty } from 'js/uwPropertyService';
import { getRealExpression, evaluateCondition } from 'js/conditionService';
import appCtxSvc from 'js/appCtxService';
import localeSvc from 'js/localeService';
import dateTimeSvc from 'js/dateTimeService';
import { isMatch } from 'date-fns';

const mapArrayOfVMPForValidation = ( parKey, objectArray ) => {
    let collection = [];
    objectArray.forEach( ( value, key ) => {
        collection[ parKey + '_' + key ] = value;
    } );
    return collection;
};
/**
 *  This method would filter out "ViewModelProperties" from data section.
 *  It would only look at first level and try to figure out all the VMP's inside it.
 *  If in a data-structure VMP's are underneath few level, use Atomic data.
 * @param {*} data -
 * @returns {object } -
 */
export const filterFlatViewModelProps = ( data ) => {
    // Below code would filter out the data and extract all the viewModel properties.
    // It considers all the static and dynamic properties (inside vmo)
    if( !isNil( data ) && !_.isEmpty( data ) ) {
        return Object.keys( data ).map( ( key ) => {
            let object = data[ key ];

            if( !_.isEmpty( object ) ) {
                // if the VMO is part of an object, then the validation is getting skipped.
                if( key === 'objects' ) {
                    let objKey = Object.keys( object )[ 0 ];
                    object = object[ objKey ];
                }
                if( isViewModelObject( object ) ) {
                    return object.props;
                } else if( isViewModelProperty( object ) ) {
                    return {
                        [ key ]: object
                    };
                } else if( _.isArray( object ) && isArrayOfViewModelProperty( object ) ) {
                    return {
                        ...mapArrayOfVMPForValidation( key, object )
                    };
                }
            }
            return undefined;
        } ).filter( ( props ) => {
            return props !== null && props !== undefined;
        } ).reduce( ( acc, current ) => {
            return Object.assign( acc, current );
        }, {} );
    }
    return {};
};

const getAtomicDataPath = function( metaObj, rootPath ) {
    let fieldsPath = [];

    function parsePath( propName, basePath ) {
        let path;
        if( basePath ) {
            path = Number.isInteger( propName ) ? `${basePath}[${propName}]` : `${basePath}.${propName}`;
        } else {
            path = propName;
        }
        return path;
    }

    function parseMetaForFieldsPath( currentMetaObj, basePath = null ) {
        _.forEach( currentMetaObj, function processMeta( propValue, propName ) {
            if( propName === 'field' || propName === 'type' ) {
                return undefined;
            }
            let path = parsePath( propName, basePath );
            fieldsPath.push( `${rootPath}.${path}` );
            if( _.isObject( propValue ) ) {
                parseMetaForFieldsPath( propValue, path );
            }
            return undefined;
        } );
    }

    parseMetaForFieldsPath( metaObj );

    return fieldsPath;
};

export const filterFlatViewModelPropForAtomic = ( viewModel ) => {
    let vmColl = {};
    if( !isNil( viewModel.atomicDataRef ) && !_.isEmpty( viewModel.atomicDataRef ) ) {
        Object.keys( viewModel.atomicDataRef ).forEach( ( stateName ) => {
            let stateObject = viewModel.atomicDataRef[ stateName ].getAtomicData();
            let metaObject = viewModel && viewModel.declViewModelJson.data[ stateName ] &&
                viewModel.declViewModelJson.data[ stateName ].meta;
            if( metaObject ) {
                let filePath = getAtomicDataPath( metaObject, stateName );
                let tempStateObject = {
                    [ stateName ]: stateObject
                };
                filePath.forEach( ( pathkey, index ) => {
                    let val = _.get( tempStateObject, pathkey );
                    if( !isNil( val ) && !_.isEmpty( val ) ) {
                        if( isViewModelObject( val ) ) {
                            extractAtomicVMO();
                        } else if( isViewModelProperty( val ) ) {
                            vmColl[ pathkey.replace( /\./g, '_' ) ] = val;
                        } else if( _.isArray( val ) && isArrayOfViewModelProperty( val ) ) {
                            extractAtomicListVMP();
                        } else if( _.isArray( val ) ) {
                            extractAtomicListVMo();
                        }
                    }

                    function extractAtomicListVMo() {
                        val.forEach( ( arrpathkey, kindex ) => {
                            if( isViewModelObject( val[ kindex ] ) ) {
                                _.forOwn( val[ kindex ].props, function( propValue, propName ) {
                                    let path = pathkey + '.' + kindex + '.props.' + propName;
                                    vmColl[ path.replace( /\./g, '_' ) ] = propValue;
                                } );
                            }
                        } );
                    }

                    function extractAtomicListVMP() {
                        val.forEach( ( arrpathkey, kindex ) => {
                            let path = pathkey + '.' + kindex;
                            vmColl[ path.replace( /\./g, '_' ) ] = val[ kindex ];
                        } );
                    }

                    function extractAtomicVMO() {
                        _.forOwn( val.props, function( propValue, propName ) {
                            let path = pathkey + '.props.' + propName;
                            vmColl[ path.replace( /\./g, '_' ) ] = propValue;
                        } );
                    }
                } );
            }
        } );
    }
    return vmColl;
};

export const getStateCollection = ( viewModel ) => {
    return {
        ...filterFlatViewModelProps( viewModel.getData() ),
        ...filterFlatViewModelPropForAtomic( viewModel )
    };
};

export const updateValidationSchema = ( viewModel, vmpCollRef, vmpValidationSchema, getProps, vmPropCollection ) => {
    let schemaForValidate = {};
    let oldVmPropCollection = vmpCollRef.current ? vmpCollRef.current.vmprop : null;
    if( !_.isNil( oldVmPropCollection ) && !_.isNil( vmPropCollection ) ) {
        let registeredPropNames = Object.keys( oldVmPropCollection );
        Object.keys( vmPropCollection ).forEach( ( key ) => {
            if( !registeredPropNames.includes( key ) || oldVmPropCollection[ key ] && vmPropCollection[ key ] && oldVmPropCollection[ key ].isRequired !== vmPropCollection[ key ].isRequired ) {
                schemaForValidate[ key ] = vmPropCollection[ key ];
            }
        } );
    } else {
        schemaForValidate = vmPropCollection;
    }
    vmpCollRef.current = { vmprop: vmPropCollection, vmModel: viewModel };
    if( !isNil( schemaForValidate ) && !_.isEmpty( schemaForValidate ) ) {
        const { validationSchemaDef } = getValidationSchema( schemaForValidate, vmpCollRef, getProps );
        let clubSchema = {};
        let exitingSchema = vmpValidationSchema.current ? vmpValidationSchema.current.exitingSchema : {};
        Object.assign( clubSchema, exitingSchema, validationSchemaDef );
        let _validationSchema = Yup.object().shape( clubSchema );
        vmpValidationSchema.current = { exitingSchema: clubSchema, validationSchema: _validationSchema };
    }
};

const isDatetimeValueInvalid = ( dateApiObj, dateOrTimeType ) => {
    let timeVal = dateApiObj.timeValue ? dateTimeSvc.getNormalizedTimeValue( dateApiObj.timeValue ) : null;
    let dateVal = dateApiObj.dateValue ? dateApiObj.dateValue.split( ' ' )[0] : null;
    switch( dateOrTimeType ) {
        case 'DATE':
            if( dateVal && !isMatch( dateVal, dateTimeSvc.getDateFilterFormat() ) ) {
                return true;
            }
            break;
        case 'TIME':
            if( timeVal && !isMatch( timeVal, dateTimeSvc.getTimeFilterFormat() ) ) {
                return true;
            }
            break;
        default:
            return false;
    }
    return false;
};

const validateDateTime = function() {
    let dateApiObj = this.options.parent.dateApi;
    if( isDatetimeValueInvalid( dateApiObj, 'DATE' ) ) {
        return this.createError( { message: localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] ) } );
    }
    if( isDatetimeValueInvalid( dateApiObj, 'TIME' ) ) {
        return this.createError( { message: localeSvc.getMessage( 'INVALID_TIME', [ dateTimeSvc.getTimeFormatPlaceholder() ] ) } );
    }
    return true;
};

const getValidationSchema = function( props = {}, vmpCollRef, getProps ) {
    let schemaInput = {};
    for( let [ key, value ] of Object.entries( props ) ) {
        if( value ) {
            // build the yup propSchema for checking dbValue
            let dbValue;
            let type = value.type || 'none';
            switch ( type.toUpperCase() ) {
                case 'DATE':
                    dbValue = Yup.string()
                        .nullable()
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )
                        .test( 'date-validation', 'invalid date', validateDateTime )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );
                        } );
                    break;
                case 'DATEARRAY':
                    dbValue = Yup.string()
                        .nullable()
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )
                        .test( 'date-array-validation', 'invalid date', validateDateTime )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_DATE', [ dateTimeSvc.getDateFormatPlaceholder() ] );
                        } );
                    break;
                case 'INTEGER':
                    dbValue = Yup.number()
                        .nullable()
                        .min( -2147483648, 'Out of range' )
                        .max( 2147483647, 'Out of range' )
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );
                        } );
                    break;
                case 'INTEGERARRAY':
                    dbValue = Yup.array().of( Yup.number()
                        .nullable()
                        .min( -2147483648, 'Out of range' )
                        .max( 2147483647, 'Out of range' )
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_INTEGER', [ obj.originalValue ] );
                        } );
                    break;
                case 'DOUBLE':
                    dbValue = Yup.number()
                        .nullable()
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );
                        } );
                    break;
                case 'DOUBLEARRAY':
                    dbValue = Yup.array().of( Yup.number()
                        .nullable()
                        .transform( ( value, originalValue ) => typeof originalValue === 'string' && originalValue.trim() === '' ? null : value ) )
                        .typeError( ( obj ) => {
                            return localeSvc.getMessage( 'INVALID_DOUBLE', [ obj.originalValue ] );
                        } );
                    break;
                case 'BOOLEAN':
                    dbValue = Yup.boolean()
                        .nullable();
                    break;
                default:
                    dbValue = Yup.string()
                        .nullable();
            }

            if( value.isRequired || value.isRequired === 'true' ) {
                dbValue = dbValue.required( () => {
                    return localeSvc.getMessage( 'PROP_REQUIRED_ERROR' );
                } );
            }

            if( value.validationCriteria ) {
                for( let criteria in value.validationCriteria ) {
                    dbValue = dbValue.test( value.validationCriteria[ criteria ].condition, value.validationCriteria[ criteria ].value, function() {
                        let conditionObj = value.validationCriteria[ criteria ].condition;
                        let viewModel = vmpCollRef.current.vmModel;
                        viewModel.data = viewModel.getData();
                        let evalContext = { viewModel, props: getProps, ctx: appCtxSvc.ctx };
                        let expression = getRealExpression( conditionObj, viewModel.declViewModelJson );
                        // eslint-disable-next-line no-invalid-this
                        return evaluateCondition( viewModel, expression, evalContext ) ? this.createError( {
                            message: viewModel.data[ key ].validationCriteria[ criteria ].value,
                            path: key
                        } ) : true;
                    } );
                }
            }

            let valueToTestSchema = dbValue.test( 'propertyError', 'Error', function() {
                // eslint-disable-next-line no-invalid-this
                let context = this;
                let hasError = declUtils.isNil( context.parent.error ) || context.parent.error.trim() === '';
                return !hasError ? context.createError( {
                    message: context.parent.error,
                    path: key
                } ) : true;
            } );
            if( [ 'DATETIME', 'DATEARRAY', 'DATE' ].includes( type.toUpperCase() ) ) {
                schemaInput[ key ] = Yup.object().shape( { uiValue: valueToTestSchema } );
            } else {
                schemaInput[ key ] = Yup.object().shape( { dbValue: valueToTestSchema } );
            }
        }
    }

    return {
        validationSchemaDef: schemaInput
    };
};
