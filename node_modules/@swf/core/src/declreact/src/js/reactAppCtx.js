// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * @module js/reactAppCtx
 */
import React, { useMemo } from 'react';
import lodashFpSet from 'lodash/fp/set';
import { get, set, orderBy, isArray, uniq } from 'lodash';
import { init } from 'js/appCtxService';
import { DerivedStateResult } from 'js/derivedContextService';

import { createStore } from 'redux';
import { useSelector, Provider as ReduxProvider, useDispatch } from 'react-redux';

export const _dispatchCtx = ( ctx = {}, action ) => {
    const { path, value } = action;

    if( path ) {
        return lodashFpSet( path, value, ctx );
    }
    return ctx;
};

// create store - will be decided by 1st param of the dispatchFn
const store = createStore( _dispatchCtx, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__() );

/**
 * Hook to pull a value from from the global ctx store
 *
 * @param {String|Array} path The path to the property
 * @returns {Any} The current value in ctx
 */
export const useCtx = path => useSelector( ctx => {
    return {
        path,
        value: get( ctx, path )
    };
}, ( l, r ) => l.value === r.value );

const getDerivedState = ( ctxCompute, { vmDef, prop, data } ) => {
    const derivedStateResult = ctxCompute( vmDef, prop, data );
    const derivedStates = isArray( derivedStateResult ) ? derivedStateResult : [ derivedStateResult ];
    for( const s of derivedStates ) {
        if( !( s instanceof DerivedStateResult ) ) {
            throw new Error( 'Results from the derived state calculation must be a DerivedStateResult. See https://gitlab.industrysoftware.automation.siemens.com/Apollo/afx/-/wikis/Derived-State' );
        }
    }
    return derivedStateResult;
};

// These methods will call hooks in the same order even though they use loops and callbacks
/* eslint-disable react-hooks/rules-of-hooks */
/**
 * Custom hook to get the ctxCompute result and use it to run other hooks
 *
 * @param {Object} derivedStateResult Function that returns DerivedStateResult
 * @param {Object} ctxMin Context available to ctxCompute
 * @returns {Any} The computed result
 */
const useDerivedStateCompute = ( derivedStateResult, ctxMin ) => {
    //Return the latest result of the memoized compute function
    const processDerivedState = ( { additionalParameters, ctxParameters, compute } ) => {
        return useMemo( () => compute( {
            ctx: ctxMin
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, ...additionalParameters ), [ ...additionalParameters, ...ctxParameters.map( x => get( ctxMin, x ) ) ] );
    };
    return isArray( derivedStateResult ) ? derivedStateResult.map( processDerivedState ) : processDerivedState( derivedStateResult );
};

const setupCtxFromDerivedStates = function( derivedStates ) {
    let entries = Object.entries( derivedStates );
    let derivedStatesCollection = entries.reduce( ( acc, [ ctxName, derivedStates ] ) => {
        let value = isArray( derivedStates ) ? derivedStates : [ derivedStates ];
        acc.push( ...value );
        return acc;
    }, [] );

    let allctx = orderBy( uniq( derivedStatesCollection.reduce( ( acc2, nxt ) => {
        return [ ...acc2, ...nxt.ctxParameters ];
    }, [] ) ), [ 'length' ], [ 'desc' ] );

    //allctx = uniq( allctx );

    return allctx.map( useCtx ).reduce( ( ctx, nxt ) => {
        //for some objects (such as array) set can have side effects, so avoid if values match
        if( nxt.value ) {
            if( get( ctx, nxt.path ) !== nxt.value ) {
                set( ctx, nxt.path, nxt.value );
            }
        } else {
            set( ctx, nxt.path, nxt.value );
        }
        return ctx;
    }, {} );
};

/**
 * Custom hook that will process the "ctx" configuration into the final object
 *
 * @param {Object} vmDef View model definition
 * @param {Object} prop Component properties
 * @param {Object} data View model data
 * @param {Object} ctxImports Imported function map
 * @returns {Object} Processed ctx, global ctx, and dispatch
 */
export const useDerivedState = ( vmDef, prop, data, ctxImports ) => {
    const ctxDefs = vmDef.declViewModelJson.ctx || {};
    let directCtx = {};
    let derivedStates = {};
    Object.entries( ctxDefs )
        .forEach( ( [ ctxName, ctxCompute ] ) => {
            ctxCompute = ctxCompute ? ctxImports[ ctxName ] : null;
            if( ctxCompute ) {
                set( derivedStates, ctxName, getDerivedState( ctxCompute, { vmDef, prop, data } ) );
            } else {
                set( directCtx, ctxName, useCtx( ctxName ).value );
            }
        }, {} );

    const computeFnDeps = setupCtxFromDerivedStates( derivedStates );
    //let entries = Object.entries( derivedStates );

    const ctxMinDS = Object.entries( derivedStates )
        .reduce( ( acc, [ ctxName, derivedStates ] ) => {
            const latestResult = useDerivedStateCompute( derivedStates, computeFnDeps );
            if( latestResult ) {
                if( get( acc, ctxName ) !== latestResult ) {
                    set( acc, ctxName, latestResult );
                }
            } else {
                set( acc, ctxName, latestResult );
            }
            return acc;
        }, {} );
    const ctxMin = Object.assign( {}, directCtx, ctxMinDS );

    return {
        //Everything in ctx. Need to be replaced by ctxMin
        ctx: store.getState(),
        //The derived ctx which only contains things this specific component needs
        ctxMin,
        //Dispatch to update ctx
        ctxDispatch: useDispatch
    };
};
/* eslint-enable react-hooks/rules-of-hooks */

/**
 * Application Context Component
 * @param {object} props properties
 * @returns {function} react component
 */
export const AppCtxComponent = ( { children } ) => {
    // NOTE: useMemo might not be safe here, if we see any side effect we
    // will change it later
    useMemo( () => init( {
        fetch: path => path ? get( store.getState(), path ) : store.getState(),
        dispatch: ( { path, value } ) => store.dispatch( { type: path, path, value } )
    } ), [] );

    return (
        <ReduxProvider store={store}>
            {children}
        </ReduxProvider>
    );
};
