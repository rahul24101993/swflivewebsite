// Copyright (c) 2020 Siemens
/* eslint-env es6 */
/**
 * This service provides data patch operation to sepecific data object.
 *
 * @module js/store
 */
import _ from 'lodash';
import {
    parseDataPath
} from 'js/declReactUtils';

/**
 * Get data patch based on dispatch action
 * action could be:
 * {
 *     scope: 'ctx.occMgmtCtx',
 *     path: 'prop.uiValue',
 *     value: 'myValue'
 * }
 * or:
 * {
 *     scope: 'ctx.occMgmtCtx',
 *     value: {
 *         'prop.uiValue': 'my name',
 *         'prop.dbValue': 'my_name'
 *     }
 * }
 * @param {object} data scope for evaluation
 * @param {object} action dispatch action input
 * @returns {Array} patch array
 */
export function getPatch( data, action ) {
    let res = {};
    if( action.path === undefined ) {
        const scope = action.scope;
        for( var path in action.value ) {
            const value = action.value[ path ];
            path = scope ? `${scope}.${path}` : path;
            if( _.get( data, path ) !== value ) {
                res[ path ] = value;
            }
        }
    } else {
        const path = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;
        const value = action.value;
        if( path ) {
            if( _.get( data, path ) !== value ) {
                res[ path ] = value;
            }
        } else if( path === '' ) {
            res = data !== value && _.isObject( value ) ? value : {};
        } else {
            // logically if path is always string this is not needed
            throw Error( 'getPatch: Invalid path!' );
        }
    }
    return res;
}

/**
 * Update data by specific path
 * @param {object} patch patch on data like { 'a.b': 3, 'c': 4 }
 * @param {object} data data for patching to like { a: { b: 2 }, c: 1 }
 * @returns {object} updated data as mutation result
 */
export const patchData = ( patch, data ) => _.reduce( patch,
    ( data, value, path ) => value === undefined ? _.unset( data, path ) && data || data : _.set( data, path, value ),
    data
);

/**
 * Update data. Only works for immutable framework
 * action could be:
 * {
 *     path: 'prop.uiValue',
 *     value: 'myValue'
 * }
 * or:
 * {
 *     value: {
 *         'prop.uiValue': 'my name',
 *         'prop.dbValue': 'my_name'
 *     }
 * }
 * @param {function} updateFn view update function
 * @returns {function} updateFn accepts data and action
 */
export const createReducer = ( updateFn ) => ( data, action ) => {
    const patch = getPatch( data, action );
    if( !_.isEmpty( patch ) ) {
        return updateFn( patch, data );
    }
    return data;
};

/**
 * reducer for react Reducer hook, return 'immutable' object when value change
 * @param {object} data data object
 * @param {object} action action as { path, value }
 * @returns {function} reducer function used for react hook
 */
export const reducer = createReducer( ( patch, data ) => ( { ...patchData( patch, data ) } ) );

/**
 * compose key-dispatch function map to one dispatch function
 * @param {object} dispatchFnMap dispatch function map as { ctx: updateCtx, data: updateData }
 * @returns {object} function pair dispatch and getDispatch
 */
export const composeDispatch = ( dispatchFnMap ) => {
    const dispatch = action => {
        const actions = [];
        if( action.scope ) {
            // this is needed for { scope: 'data.test', value: { path1: value1, path2: value2 } }
            actions.push( action );
        } else if( action.path === undefined ) {
            // re-assemble value to data and ctx
            // TODO: we can be more smart to identify the scope cluster more accurately
            // for eample if we have data.a.b and data.a.c, can we set the scope to data.a so that we can
            // save more performance
            const values = action.value;
            const patchMap = _.reduce( values, ( res, value, dataPath ) => {
                const { scope, path } = parseDataPath( dataPath );
                res[ scope ] = res[ scope ] || {};
                res[ scope ][ path ] = value;
                return res;
            }, {} );
            _.forEach( patchMap, ( value, scope ) => actions.push( { scope, value } ) );
        } else {
            // re-evaluate scope to get data or ctx. Actually if scope has value we dont' have to
            const value = action.value;
            const dataPath = action.scope && action.path ? `${action.scope}.${action.path}` : action.scope || action.path;
            let { scope, path } = parseDataPath( dataPath );
            // path should be exist in this else branch, need to maintain that intention
            path = path || '';
            actions.push( { scope, path, value } );
        }
        actions.forEach( action => getDispatch( action.scope )( { ...action, scope: undefined } ) );
    };

    const getDispatch = ( dataPath, updateFn ) => {
        const { scope, path } = parseDataPath( dataPath );
        // TODO: error out for last branch
        updateFn = updateFn || dispatchFnMap[ scope ] || ( () => null );

        return path ? ( action ) => {
            action.scope = action.scope ? `${path}.${action.scope}` : path;
            return updateFn( action );
        } : updateFn;
    };

    return { dispatch, getDispatch };
};
