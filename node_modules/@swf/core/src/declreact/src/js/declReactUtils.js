// Copyright (c) 2020 Siemens
/* eslint-env es6 */

import { evalExpression } from 'js/serviceUtils';
import { render, unmountComponentAtNode } from 'react-dom';

/**
 * fastest way to copy a pure JSON object, use on your own risk
 * https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript
 *
 * @param {Object} obj Current DOM Element
 * @returns {Object} new cloned object
 */
export function cloneDeepJsonObject( obj ) {
    return obj ? JSON.parse( JSON.stringify( obj ) ) : obj;
}

/**
 * parse data path to scope + subPatoh
 * @param {string} pathStr path string like 'ctx.a.b'
 * @returns {object} path structure like:
 * {
 *     scope: 'ctx'
 *     path: 'a.b'
 * }
 */
export function parseDataPath( pathStr ) {
    const match = pathStr.match( /[.[]/ );
    if( match ) {
        return {
            scope: pathStr.substr( 0, match.index ),
            path: pathStr.substr( match[ 0 ] === '[' ? match.index : match.index + 1 )
        };
    }
    return { scope: pathStr };
}

/**
 * evaluate string as Javascript expression
 * @param {string} expr string as expression
 * @param {Object} scope parameters as name value pair
 * @param {boolean} ignoreError if true the error is not thrown
 * @param {boolean} applyObject object will apply to the expr as this
 * @return {*} evaluation result
 */
export function evalInScope( expr, scope, ignoreError, applyObject ) {
    const params = scope ? Object.keys( scope ) : [];
    const values = scope ? Object.values( scope ) : [];
    return evalExpression( expr, params, values, ignoreError, applyObject );
}

/**
 * get value from scope
 * @param {object} data scope for evaluation
 * @param {string} path string as path/expression
 * @returns {*} result
 */
export function getValue( data, path ) {
    return evalInScope( path, data, true );
}

/**
 * parse expr {{aa.bb}} to get aa.bb
 * @param {string} str input string
 * @returns {string} the expression inside {{}}
 */
export function parseExpr( str ) {
    let match = str.match( /^{{(.*)}}$/ );
    return match ? match[ 1 ] : undefined;
}

/**
 * Evaluate from data definition like:
 * {
 *    attr1: {{data.curVal}}
 * }
 * @param {JSON} input data definition
 * @param {JSON} scope scope for evaluation
 * @param {number} level used for recursive call internally
 * @returns {JSON} evaluated input object
 */
export function evalDataDefinition( input, scope, level = 0 ) {
    // Make the method to be immutable at top level
    let obj = level > 0 ? input : cloneDeepJsonObject( input );

    for( let key in obj ) {
        let value = obj[ key ];
        if( typeof value === 'string' ) {
            let template = parseExpr( value );
            if( template ) {
                obj[ key ] = getValue( scope, template );
            }
        } else {
            evalDataDefinition( obj[ key ], scope, level + 1 );
        }
    }
    return obj;
}

/**
 * parse i18n definition. Given:
 * {
 *     myData: {
 *         value1: "a",
 *         value2: "{{i18n.myVal}}"
 *     }
 * }
 * returns:
 * {
 *     "myData.value2": "{{i18n.myVal}}"
 * }
 * NODE: No usage for now, keep it here for reference
 * @param {JSON} dataDef data definition
 * @param {Array} stack JSON path stack
 * @returns {JSON} i18n defintions in path-expr pair
 */
function getExprsFromDataDef( dataDef, stack = [] ) {
    const res = {};
    for( let key in dataDef ) {
        stack.push( key );
        let value = dataDef[ key ];
        if( typeof value === 'string' ) {
            let template = parseExpr( value );
            if( /^i18n\./.test( template ) ) {
                res[ stack.join( '.' ) ] = value;
            }
        } else {
            Object.assign( res, getExprsFromDataDef( value, stack ) );
        }
        stack.pop();
    }
    return res;
}

/**
 * This API is a wrapper to ReactDOM.render function which accepts the component to be rendered, the dom element location and optional callback.
 * @param {object} component React component.
 * @param {DOMElement} renderedElement The container element on which the component will be rendered.
 * @param {Function} callback callback function that will be executed by render method. This is optional.
 */
export function renderComponent( component, renderedElement, callback ) {
    if( component && renderedElement ) {
        render( <>{ component }</>, renderedElement, callback );
    }
}

/**
 * This API is a wrapper to ReactDOM.unmountComponentAtNode function which will find elements relative to the base element based on the selector provided.
 * These elements will then be unmounted if they have a react element mounted.
 * @param {HTMLElement} baseElement The base element to use
 * @param {String} [selector] CSS selector used to search for nodes from the base element
 */
export function unmountComponents( baseElement, selector ) {
    // get the container elements that could potentially have a component
    let components;
    if( !selector ) {
        components = [ baseElement ];
    } else {
        components = baseElement.querySelectorAll( selector );
    }

    for( let i = 0; i < components.length; i++ ) {
        unmountComponentAtNode( components[ i ] );
    }
}
