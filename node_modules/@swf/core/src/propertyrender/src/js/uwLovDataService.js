// Copyright (c) 2020 Siemens

/**
 * Note: This module does not return an API object. The API is only available when the service defined this module is
 * injected by AngularJS.
 *
 * @module js/uwLovDataService
 */
import AwPromiseService from 'js/awPromiseService';
import uwPropertySvc from 'js/uwPropertyService';
import eventBus from 'js/eventBus';
import dateTimeSvc from 'js/dateTimeService';
import _ from 'lodash';

export const performLOVOperation = ( { uiProperty, vmo, lovEntry, dataProvider, createUpdateValue, checkLovEntries, dateApi }, operation ) => {
    if( dateApi ) {
        uwPropertySvc.setDateApi( uiProperty, dateApi );
    }
    let isPropertyUpdateReqd = false;

    if( operation === 'resetFilterStr' ) {
        uiProperty.filterString = null;
        return Promise.resolve( { newProp: null, isPropertyUpdateReqd } );
    } else if( operation === 'filter' ) {
        let isDateAndTimeProp = [ 'DATE', 'DATEARRAY', 'DATETIME' ].includes( uiProperty.type );
        if( !isDateAndTimeProp && ( lovEntry.isSearchable === true || uiProperty.renderingHint === 'checkboxoptionlov' ) ) {
            uiProperty.filterString = lovEntry.filterString;
            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd } );
        }
        let lovEntries = dataProvider.vmCollectionObj.vmCollection.loadedVMObjects;
        if( isDateAndTimeProp ) {
            dateApi = uiProperty.dateApi;
            dateApi.timeValue = lovEntry.propInternalValue;
            uwPropertySvc.setDateApi( uiProperty, dateApi );
            for( var ndx = 0; ndx < lovEntries.length; ndx++ ) {
                if( lovEntries[ ndx ].propDisplayValue === lovEntry.propDisplayValue ) {
                    lovEntry.propInternalValue = lovEntries[ ndx ].propInternalValue;
                    break;
                }
            }
            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd: true } );
        } else if( uiProperty.type === 'OBJECT' || uiProperty.type === 'OBJECTARRAY' ) {
            // we can't set the dbValue for an object based on filter text, but we can check to see if the
            // input
            // has been cleared
            if( !uiProperty.uiValue ) {
                uiProperty.dbValue = '';
            }
        } else if( uiProperty.type === 'STRING' ) {
            uiProperty.dbValue = lovEntry.propInternalValue;
        } else {
            uiProperty.uiValue = lovEntry.propDisplayValue;
        }

        if( !uiProperty.isArray ) {
            uiProperty.uiValues = [ lovEntry.propDisplayValue ];
            uiProperty.uiValue = lovEntry.propDisplayValue;
            if( uiProperty.type !== 'OBJECT' && uiProperty.type !== 'OBJECTARRAY' ) {
                //For Reference property internal value is same as UI value so dont
                //process it for OBJECT type
                uiProperty.dbValues = [ lovEntry.propInternalValue ];
                uiProperty.dbValue = lovEntry.propInternalValue;
            }
        }
        uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;
        uiProperty.valueUpdated = true;
        return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd } );
    } else if( operation === 'validate' ) {
        let createInput = function() {
            let lovEntries = [];
            if( uiProperty.isArray && uiProperty.dbValue instanceof Array ) {
                uiProperty.dbValue.forEach( ( item, index ) => {
                    lovEntries.push( { propInternalValue: item, propDisplayValue: uiProperty.displayValues[ index ] } );
                } );
            } else {
                lovEntries.push( lovEntry );
            }
            return lovEntries;
        };
        let input = {
            lovEntries: createInput(),
            viewModelProp: uiProperty,
            vmo
        };
        if( uiProperty.type === 'DATEARRAY' ) {
            dateApi = uiProperty.dateApi;
            dateApi.timeValue = lovEntry.propDisplayValue;
            uwPropertySvc.setDateApi( uiProperty, dateApi );
        }
        return dataProvider.validateLovAction( input ).then( ( validationResult ) => {
            uiProperty.dbOriginalValue = uiProperty.dbValue;
            uiProperty.uiOriginalValue = uiProperty.uiValue;
            uwPropertySvc.updateValidationResult( lovEntry, validationResult, uiProperty );
            eventBus.publish( dataProvider.name + '.validSelectionEvent', {
                selectedObjects: input.lovEntries,
                viewModelProp: uiProperty,
                vmo
            } );
            return Promise.resolve( { newProp: { ...uiProperty }, isPropertyUpdateReqd: true } );
        }, ( validationError ) => {
            uwPropertySvc.setServerValidationError( uiProperty, true );
            uiProperty.error = validationError.message;
            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );
        } );
    } else if( operation === 'validateandadd' ) {
        let createInput = function() {
            //get selected LOV entries
            let lovEntries = [];
            if( uiProperty.isArray && uiProperty.dbValue instanceof Array ) {
                uiProperty.dbValue.forEach( ( item, index ) => {
                    lovEntries.push( { propInternalValue: item, propDisplayValue: uiProperty.displayValues[ index ] } );
                } );
                if( !_.isNil( lovEntry.propInternalValue ) ) {
                //Add in selected LOV entries so that it can be validated
                    lovEntries.push( { propInternalValue: lovEntry.propInternalValue, propDisplayValue: lovEntry.propDisplayValue } );
                }
            } else {
                lovEntries.push( lovEntry );
            }

            return lovEntries;
        };
        //uiProperty.filterString = _.isNil( lovEntry.filterString ) ? lovEntry.propDisplayValue : lovEntry.filterString;
        //Cascase LOV selecting from Array:Test CFx_Property_Support_Item Cascade Array LOV and Cascade Suggestive Array LOV Properties
        uiProperty.filterString = lovEntry.filterString ? lovEntry.filterString : null;

        uiProperty.filteredLOVEntries = lovEntry.filteredLOVEntries;
        let input = {
            lovEntries: createInput(), //selected LOV entries = existing + newly selected values
            viewModelProp: uiProperty,
            vmo
        };
        return dataProvider.validateLovAction( input ).then( ( validationResult ) => {
            let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;
            if( changed ) {
                uwPropertySvc.updateValidationResult( lovEntry, validationResult, uiProperty );
                eventBus.publish( dataProvider.name + '.validSelectionEvent', {
                    selectedObjects: input.lovEntries,
                    viewModelProp: uiProperty,
                    vmo
                } );
                return uwPropertySvc.updateLov( { ...uiProperty }, lovEntry, createUpdateValue, operation, checkLovEntries )
                    .then( ( newProperty ) => {
                        uiProperty.dbOriginalValue = uiProperty.dbValue;
                        uiProperty.uiOriginalValue = uiProperty.uiValue;
                        uiProperty.filterString = '';
                        return Promise.resolve( { newProp: newProperty, isPropertyUpdateReqd: true } );
                    } );
            }
            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );
        }, ( validationError ) => {
            uwPropertySvc.setServerValidationError( uiProperty, true );
            uiProperty.error = validationError.message;
            return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );
        } );
    }
    let changed = lovEntry && uiProperty.dbOriginalValue !== lovEntry.propInternalValue;
    if( changed ) {
        return uwPropertySvc.updateLov( { ...uiProperty }, lovEntry, createUpdateValue, operation, checkLovEntries )
            .then( ( newProperty ) => {
                return Promise.resolve( { newProp: newProperty, isPropertyUpdateReqd: true } );
            } );
    }
    return Promise.resolve( { newProp: uiProperty, isPropertyUpdateReqd } );
};
/**
 * Initialize the lov api using a data provider from the view-model
 * @param {Object} lovScope - scope object for the lov
 */
export const initLovApi = function( lovScope ) {
    //revisitme : Prasad $scope usage
    if( lovScope.prop.dataProvider ) {
        lovScope.prop.lovApi = {};

        // retrieve the initialized dataProvider object for this lov property
        var listProvider = lovScope.prop.getViewModel().dataProviders[ lovScope.prop.dataProvider ];

        if( !listProvider.initializeAction && !listProvider.action ) {
            lovScope.prop.lovApi.type = 'static';
        }

        // map the lovApi to use the provider's initialize method
        lovScope.prop.lovApi.getInitialValues = function( filterStr, deferred ) {
            lovScope.filterStr = filterStr;

            // reset the lov type if necessary
            if( ( listProvider.initializeAction || listProvider.action ) && lovScope.prop && lovScope.prop.lovApi.type === 'static' ) {
                lovScope.prop.lovApi.type = '';
            }

            listProvider.initialize( lovScope )
                .then( function( initProviderResp ) {
                    if( initProviderResp.moreValuesExist === false ) {
                        // since we have all the values, treat as static (enables simplified filtering)
                        lovScope.prop.lovApi.type = 'static';
                    }
                    // conforming to existing data structure here, but note for future:
                    // moreValuesExist should probably be moved off of results since it's not valid json
                    if( initProviderResp.hasOwnProperty( 'moreValuesExist' ) ) {
                        initProviderResp.results.moreValuesExist = initProviderResp.moreValuesExist;
                    }
                    deferred.resolve( initProviderResp.results );
                } );
        };

        // use the provider's getNext method
        lovScope.prop.lovApi.getNextValues = function( promise ) {
            listProvider.accessMode = 'lov';

            listProvider.getNextPage( lovScope )
                .then( function( nextProviderResp ) {
                    if( nextProviderResp.moreValuesExist === false ) {
                        lovScope.prop.lovApi.type = 'static';
                    }

                    if( nextProviderResp.hasOwnProperty( 'moreValuesExist' ) ) {
                        nextProviderResp.results.moreValuesExist = nextProviderResp.moreValuesExist;
                    }
                    promise.resolve( nextProviderResp.results );
                } );
        };

        // use the provider's validate method
        lovScope.prop.lovApi.validateLOVValueSelections = function( selected ) {
            // are the selected value(s) in lovScope.lovEntries?
            // if not, a new value is being suggested which may or may not be allowed
            var suggestion = false;
            selected.forEach( function( sel ) {
                if( sel.suggested ) {
                    suggestion = sel.propDisplayValue;
                }
            } );

            // make server call via lov data provider interface: returns a promise
            return listProvider.validateSelections( lovScope, selected, suggestion );
        };
    }
};

/**
 * Returns an AngularJS promise to fetch the initial LOV values.
 *
 * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.
 *
 * @param {String} filterStr - Filter to apply to the results before being returned.
 *
 * @param {String} name - Name of the property we are requesting LOV entries for.
 *
 * @returns {Promise} - Returns an AngularJS promise to fetch the initial LOV values.
 */
export const promiseInitialValues = function( lovApi, filterStr, name ) {
    var deferred = AwPromiseService.instance.defer();
    // make server call via lov data provider interface
    lovApi.getInitialValues( filterStr, deferred, name );
    return deferred.promise;
};

/**
 * Returns an AngularJS promise to fetch the 'next' set of LOV values.
 *
 * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.
 *
 * @param {String} name - Name of the property we are requesting LOV entries for.
 *
 * @returns {Promise} - Returns an AngularJS promise to fetch the 'next' set of LOV values.
 */
export const promiseNextValues = function( lovApi, name ) {
    var deferred = AwPromiseService.instance.defer();
    // make server call via lov data provider interface
    lovApi.getNextValues( deferred, name );
    return deferred.promise;
};

/**
 * Validate the given LOV entry value(s).
 *
 * @param {LOVCallbackAPI} lovApi - Reference to the LOV Callback API to use.
 *
 * @param {LovEntryArray} lovEntries - set lov vals
 *
 * @param {String} name - Name of the property we are requesting LOV entries for.
 *
 * @returns {Void} -
 */
export const validateLOVValueSelections = function( lovApi, lovEntries, name ) {
    // make server call via lov data provider interface
    return lovApi.validateLOVValueSelections( lovEntries, name );
};

const exports = {
    initLovApi,
    promiseInitialValues,
    promiseNextValues,
    validateLOVValueSelections
};
export default exports;
