// Copyright (c) 2022 Siemens

/**
 * @module js/utils
 */
import _ from 'lodash';
import logger from 'js/logger';
import AwParseService from 'js/awParseService';
import workspaceUtils from 'js/workspaceUtils';
/**
 * Polyfill to match dynamic import result back to ES5 supported module
 *
 * @param {Object} obj - function to evaluate after loading the dependencies.
 * @returns {Object} ES5 module object
 */
export function interopES6Default( obj ) {
    // for case like appCtxSerivce, for unknown reason, it has __esModule but no default
    // In the case we will use module itself
    // LCS-299148 Beyond Angular: Clean up app.getInjector usage
    // NOTE: '!obj.moduleServiceNameToInject' here is impacting the class practice in service conversion
    // it makes that we defined the moduleServiceNameToInject at top level for that practice, not class
    // level.
    // It is causing a shaky factor now when we start removing moduleServiceNameToInject from class practice
    // the return is inconsistent for requireJS API:
    // - class with moduleServiceNameToInject => { moduleServiceNameToInject, default: svcClass }
    // - class without moduleServiceNameToInject => svcClass
    // - non class => it doen't matter since module === module.default
    // webpack and non-webpack mode will be same snce they have the same _interopES6Default
    //
    // Long term solution
    // - stop supporting non-webpack build
    // - see if we can remove this _interopES6Default when use dynamic import
    //
    // Short term solution (aw4.3)
    // - Document this apperance difference for class service
    // - it should be a minor minor case in regular practice
    return obj && obj.__esModule && obj.default && !obj.moduleServiceNameToInject ? obj.default : obj;
}

/**
 * Set the "isToggle" flag on any commands that have a handler with a "selectWhen" condition
 *
 * Dirty - modifies input
 *
 * @param {Object} viewModelJson View model json to modify
 */
function updateIsToggleFlag( viewModelJson ) {
    if( viewModelJson.commands ) {
        const cmdId2handlers = {};
        let handlers = [];
        for( const handler of Object.values( viewModelJson.commandHandlers ) ) {
            handlers = cmdId2handlers[ handler.id ];
            if( !handlers ) {
                handlers = [];
                cmdId2handlers[ handler.id ] = handlers;
            }
            handlers.push( handler );
        }
        for( const cmdId in viewModelJson.commands ) {
            const command = viewModelJson.commands[ cmdId ];
            // The handlers for the given command
            handlers = cmdId2handlers[ cmdId ] || [];
            // If any handler for this command has selectWhen the command is a toggle command
            command.isToggle = !command.isGroup && !command.isShuttle && handlers.reduce( function( acc, handler ) {
                return acc || handler.hasOwnProperty( 'selectWhen' );
            }, false ) || false;
        }
    }
}

/**
 * @param {Object} objValue - destination object
 * @param {Object} srcValue source object
 * @return {Object|undefined} modified destination object
 */
function mergeCustomizer( objValue, srcValue ) {
    if( _.isArray( objValue ) ) {
        return objValue.concat( srcValue );
    }
}

/**
 * @param {Object} obj1 object 1
 * @param {Object} obj2 object 2
 * @param {Object|null} check - optional checker object
 * @param {Number|null} depth - depth of merge
 * @type {module.exports.merge}
 */
const merge = ( obj1, obj2, check, depth ) => {
    if( !depth ) { depth = 1; }
    if( _.isNull( obj2 ) ) {
        // nothing to merge
    } else if( _.isNull( obj1 ) ) {
        logger.error( 'Null object to merge!' );
    } else if( _.isArray( obj1 ) && _.isArray( obj2 ) ) {
        for( let element of obj2 ) {
            // If there was a 'identity' test for the elements, we might be able to merge objects in the array.
            if( !obj1.includes( element ) ) {
                obj1.push( _.cloneDeep( element ) );
            }
        }
    } else if( _.isObject( obj1 ) && _.isObject( obj2 ) ) {
        if( !check ) {
            _.mergeWith( obj1, obj2, mergeCustomizer );
        } else {
            for( const key in obj2 ) {
                const field = obj2[ key ];
                if( obj1.hasOwnProperty( key ) ) {
                    if( check ) {
                        check.path.push( key );
                        if( check.uniqueDepth !== undefined &&
                            check.uniqueDepth === depth &&
                            !check.path.includes( 'i18n' ) ) {
                            throw new Error( 'Name conflict in ' + check.file + '.json path=' + check.path.join( '.' ) + ' for module ' + check.moduleName + ' (2nd occurrence)!' );
                        }
                    }
                    merge( obj1[ key ], field, check, depth + 1 );
                    if( check ) { check.path.pop(); }
                } else {
                    obj1[ key ] = _.cloneDeep( field );
                }
            }
        }
    } else if( _.isArray( obj1 ) || _.isArray( obj2 ) ) {
        throw new Error( 'Invalid array merge!' );
    } else if( _.isObject( obj1 ) || _.isObject( obj2 ) ) {
        throw new Error( 'Invalid object merge!' );
    }
};

export const processWorkspaces = ( solutionDef, workspacesInfo ) => {
    let workspaceData = {};
    const workspaceArray = solutionDef.workspaces;
    let filteredWorkspaceContributions = [];
    if( solutionDef && solutionDef.workspaces ) {
        let filteredWorkspaces = workspacesInfo.filter( function( workspaceInfo ) {
            if( /workspace_contribution.*/.test( workspaceInfo.name ) ) {
                filteredWorkspaceContributions.push( workspaceInfo );
                return false;
            }
            return true;
        } );
        for( const data of Object.values( filteredWorkspaces ) ) {
            const workspace = data.contents;
            if( _.includes( workspaceArray, workspace.workspaceId ) || workspace.scope === 'Internal' ||
                workspace.includeInSolutions && workspace.includeInSolutions.includes( solutionDef.solutionId ) ) {
                workspaceData[ workspace.workspaceId ] = workspace;
            }
        }
        //now filter the workspace contributions and stitch them only if this workspaceId is present in workspaceData
        for( const data of Object.values( filteredWorkspaceContributions ) ) {
            const workspace = data.contents;
            if( workspaceData[ workspace.workspaceId ] !== undefined ) {
                _.mergeWith( workspaceData[ workspace.workspaceId ], workspace, function customizer( objValue, srcValue ) {
                    if( _.isArray( objValue ) ) {
                        _.each( srcValue, function( item ) {
                            if( objValue.indexOf( item ) < 0 ) {
                                objValue.push( item );
                            }
                        } );
                        return objValue;
                    }
                } );
            }
        }
    }
    return workspaceData;
};

/**
 * Add all the configurations from the exclusive kits to the workspaces.
 * @param {object} WorkspacesInfo all workspaces
 * @param {Object} allKitsJson - all kits
 * @param {Object} allStatesJson - all states
 */
export const processExclusiveKits = ( WorkspacesInfo, allKitsJson, allModules2StatesJson ) => {
    for( var workspaceObject of Object.values( WorkspacesInfo ) ) {
        workspaceUtils.resolveKitDefinitions( workspaceObject.contents, allKitsJson, allModules2StatesJson );
    }
    return;
};
export const processJsonImports = ( name, importResArray, config = {}, lazy ) => {
    let res = {};
    let lazyLoadPromises = [];
    // have to put it here because of clojure
    const reduceJsonContents = ( sum, cur ) => {
        const [ fullStr, moduleName, file ] = cur.name.match( /^.*[\\|/]([^\\/]*)[\\|/]([^\\/]*)\.json$/ );

        merge( sum, cur.contents, config.uniqueDepth && {
            moduleName,
            file,
            path: [],
            uniqueDepth: config.uniqueDepth
        } );
        return sum;
    };

    if( lazy ) {
        for( const imp of importResArray ) {
            if( typeof imp.contents.then === 'function' ) {
                lazyLoadPromises.push( imp.contents.then( ( contents ) => {
                    return { contents: interopES6Default( contents ), name: imp.name };
                } ) );
            } else {
                // require.context in mendix does not support lazy loading
                // For now wrap the response in promise until we fix rollup-plugin-require-context2
                lazyLoadPromises.push( new Promise( resolve => {
                    const contents = imp.contents;
                    return resolve( { contents: interopES6Default( contents ), name: imp.name } );
                } ) );
            }
        }
    }
    // revisitme - need to consider "configuration.format === 'array'" use case later
    if( name === 'commandsViewModel' ) {
        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {
            let res = importResArray.reduce( reduceJsonContents, {} );
            updateIsToggleFlag( res );
            return res;
        } );
    } else if( name === 'secondaryWorkareaTabs' ) {
        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {
            return importResArray.reduce( ( sum, cur ) => {
                // old schema support
                if( _.isArray( cur.contents ) ) {
                    sum.tabs.push( ...cur.contents );
                } else {
                    // new schema support
                    let { tabs, ...rest } = cur.contents;
                    sum.tabs.push( ...Object.values( tabs ) );
                    merge( sum, rest );
                }
                return sum;
            }, { tabs: [] } );
        } );
    } else if( name === 'layoutSlots' ||
        name === 'navigationURLToken' ||
        name === 'syncStrategy' ||
        name === 'indicators' ||
        name === 'adapters' ||
        name === 'headerContributions' ||
        name === 'saveHandlers' ) {
        return Promise.all( lazyLoadPromises ).then( ( importResArray ) => {
            res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );
            return res;
        } );
    } else if( name === 'workspace' ) {
        return importResArray;
    } else if( name === 'states' ) {
        res = importResArray.reduce( ( sum, cur ) => {
            if( cur.contents ) {
                for( const stateName in cur.contents ) {
                    const state = cur.contents[ stateName ];
                    if( state.type === 'location' ) {
                        if( !state.hasOwnProperty( 'abstract' ) ) {
                            state.abstract = true;
                        }
                        if( !state.view ) {
                            state.view = 'AwDefaultLocation';
                        }
                        if( !state.parent ) {
                            state.parent = 'root';
                        }
                    } else if( state.type === 'subLocation' ) {
                        if( !state.view ) {
                            state.view = 'AwDefaultSublocation';
                        }
                        if( !state.hasOwnProperty( 'reloadOnSearch' ) ) {
                            state.reloadOnSearch = false;
                        }
                        if( !state.parent ) {
                            throw new Error( `Sublocation state ${stateName} does not have parent location` );
                        }
                        if( !state.hasOwnProperty( 'url' ) ) {
                            throw new Error( `No url defined for sublocation state ${stateName}` );
                        }
                    } else if( state.type === 'parameter' ) {
                        if( !state.params ) {
                            throw new Error( `Parameter state ${stateName} must have parameters` );
                        } else if( Object.keys( state ).length > 2 ) {
                            throw new Error( `Parameter state ${stateName} should only have type and params` );
                        }
                        // Merging states is handled later
                    } else {
                        logger.debug( `No type or unknown type on state ${stateName} cannot validate state` );
                    }

                    if( state.params ) {
                        for( let param in state.params ) {
                            if( !state.params[ param ] ) {
                                state.params[ param ] = { type: 'any' };
                            }
                        }
                    }
                    // Temporary hack to support states that have not set type (ex search)
                    if( state.type !== 'location' && !state.parent && state.controller === 'DefaultLocationCtrl' ) {
                        logger.warn( `${stateName} is using DefaultLocationCtrl but is not a location` );
                        state.parent = 'root';
                    }
                    if( !sum[ stateName ] ) {
                        sum[ stateName ] = state;
                    } else {
                        if( sum[ stateName ].type === 'parameter' || state.type === 'parameter' ) {
                            // If the current state is just parameters merge it into the finalState
                            if( state.type === 'parameter' ) {
                                _.assign( sum[ stateName ].params, state.params );
                            } else {
                                // If the final state is currently just parameters and the new state is not merge into the new state
                                _.assign( state.params, sum[ stateName ].params );
                                sum[ stateName ] = state;
                            }
                        } else {
                            logger.error( `State name conflict with state ${stateName}` );
                        }
                    }
                }
            }
            return sum;
        }, {} );
        return res;
    } else if( name === 'aliasRegistry' ) {
        res = importResArray.reduce( ( sum, cur ) => {
            if( cur.contents ) {
                for( const iconName in cur.contents ) {
                    const aliases = cur.contents[ iconName ];
                    let icoName = iconName;
                    if( aliases.length === 0 ) {
                        throw new Error( `No aliases provided for type icons declared for [${icoName}]` );
                    }
                    // If not a type alias, then strip the size numbers at the end of the filename.
                    if( !/^type/.test( icoName ) ) { icoName = icoName.replace( /[0-9]+$/, '' ); }
                    const token = icoName.substring( 0, 4 );
                    for( const alias of aliases ) {
                        const aliasToken = token + alias;
                        if( sum[ aliasToken ] ) {
                            throw new Error( `Multiple aliases declared for ${aliasToken} [${icoName} & ${sum[ aliasToken ]}]` );
                        }
                        if( aliasToken === iconName ) {
                            throw new Error( `Why map the same name to itself? ${alias}` );
                        }
                        sum[ aliasToken ] = icoName;
                    }
                }
            }
            return sum;
        }, {} );
        return res;
    } else if( name === 'typeProperties' ) {
        res = importResArray.reduce( ( sum, cur ) => {
            if( cur.contents && cur.contents.typeProperties ) {
                const typeProperties = cur.contents.typeProperties;
                for( const key2 in typeProperties ) {
                    const value = typeProperties[ key2 ];
                    if( !sum[ key2 ] ) {
                        sum[ key2 ] = value;
                    } else {
                        if( sum[ key2 ].displayProperty &&
                            value.displayProperty &&
                            sum[ key2 ].displayProperty !== value.displayProperty ) {
                            logger.error( `TypeProperties displayProperty conflict with type ${key2}` );
                        } else if( value.displayProperty ) {
                            sum[ key2 ].displayProperty = value.displayProperty;
                        }
                        if( value.additionalProperties ) {
                            if( !sum[ key2 ].additionalProperties ) {
                                sum[ key2 ].additionalProperties = [];
                            }
                            for( const property of value.additionalProperties ) {
                                const foundProp = _.find( sum[ key2 ].additionalProperties, o => {
                                    return o.name === property.name;
                                } );
                                if( !foundProp ) {
                                    sum[ key2 ].additionalProperties.push( property );
                                }
                            }
                        }
                    }
                }
            }
            return sum;
        }, {} );
        return res;
    }
    // else
    res = importResArray.reduce( reduceJsonContents, config.format === 'array' ? [] : {} );
    return res;
};

export const processI10n = ( name, imports ) => {
    const i18nAllFiles = {};
    const MSG_PREFIX = 'processL10n: ';
    let importResArray = imports.reduce( ( res, m ) =>
        res.concat(
            _.filter( m.keys(), ( path ) => {
                let localeCode;
                // get base name
                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];

                if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                    localeCode = 'i18n_' + fileName.substring( fileName.length - 5 );
                } else if( /_[\w]{2}$/.test( fileName ) ) {
                    localeCode = 'i18n_' + fileName.substring( fileName.length - 2 );
                } else {
                    localeCode = 'i18n';
                }
                return localeCode === name || name !== 'i18n' && localeCode === 'i18n';
            } ).map( path => {
                if( typeof m( path ).then === 'function' ) {
                    return m( path ).then( ( contents ) => {
                        return { contents: interopES6Default( contents ), name: path };
                    } );
                }
                // The plugin used in mendix integration does not support lazy m(path) i.e then api is missing
                return new Promise( resolve => {
                    const contents = m( path );
                    return resolve( { contents: interopES6Default( contents ), name: path } );
                } );
            } ) ), []
    );

    /**
     * Add missing entries in the non-English localization with the English values.
     *
     * @param {Object} nonEnglish - non-English localization data
     * @param {Object} english - English localization data
     */
    function backFillFromEnglish( nonEnglish, english ) {
        for( const bundleName in english ) {
            const bundle = english[ bundleName ];
            if( !nonEnglish[ bundleName ] ) {
                nonEnglish[ bundleName ] = bundle;
                continue;
            }
            for( const key in bundle ) {
                const value = bundle[ bundleName ];
                if( !nonEnglish[ bundleName ][ key ] ) {
                    nonEnglish[ bundleName ][ key ] = value;
                }
            }
        }
    }

    return Promise.all( importResArray ).then( ( i18nlanguages ) => {
        for( const cur of i18nlanguages ) {
            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\|/]([^\\/]*)[\\|/]([^\\/]*)\.json$/ );
            let localeName;
            if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                localeName = fileName.substring( fileName.length - 5 );
                fileName = fileName.substring( 0, fileName.length - 6 );
            } else if( /_[\w]{2}$/.test( fileName ) ) {
                localeName = fileName.substring( fileName.length - 2 );
                fileName = fileName.substring( 0, fileName.length - 3 );
            } else {
                localeName = 'en_US';
            }
            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }
            if( cur.contents ) {
                try {
                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;
                } catch ( err ) {
                    logger.error( `Unable to parse ${cur.name}` );
                    throw err;
                }
            }
        }

        for( const locale in i18nAllFiles ) {
            const json = i18nAllFiles[ locale ];
            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }
        }

        /**
         * Existing i18n logic: ( for all step below, en_US doesn't have suffix)
         * - i18n src is defined as:
         *   adobejsTooltipMessages_zh_CN ->
         *   {
         *       "openInIllustrator": "Local test in Chinese"
         *   }
         *
         * - It will be reassemble as:
         *   i18n_zh_CN.json ->
         *   {
         *       adobejsTooltipMessages: {
         *           "openInIllustrator": "Local test in Chinese"
         *       }
         *   }
         *
         * - At runtime it will be loaded on demand by localeService.getTextPromise by 'bundle' as 'adobejsTooltipMessages',
         *   which eventually reach to cfgSvc.getCfg with 'i18n_zh_CN.adobejsTooltipMessages'
         *
         * - In cfgSvc.getCfg, it will be splitted out and load the correct 'i18n_zh_CN.json'
         *
         * - in the final cfgCache it will looks like:
         *   {
         *       actionTemplateDefs,
         *       ....,
         *       i18n_zh_CN: {
         *           adobejsTooltipMessages: {
         *               "openInIllustrator": "Local test in Chinese"
         *           }
         *       }
         *   }
         *
         * - regarding to installedLocales:
         *   - it depends on on how man JSON config our customer has in src
         *   - it depends on war_mySite.json
         *   We will check it later
         */
        let res;
        for( const locale in i18nAllFiles ) {
            const json = i18nAllFiles[ locale ];
            if( name.endsWith( locale ) ) {
                res = json;
            }
        }

        // load english by default
        // revisitme: may have side effect when user try invalid input like 'i18n_non_exist_locale', we will
        // see how can we handle that later
        return res ? res : i18nAllFiles.en_US;
    } );
};

export const processLoginLocales = ( name, imports ) => {
    const i18nAllFiles = {};
    let importResArray = imports.reduce( ( res, m ) =>
        res.concat(
            _.filter( m.keys(), ( path ) => {
                let localeCode;
                // get base name
                let fileName = path.split( '/' ).reverse()[ 0 ].split( '.json' )[ 0 ];

                if( !fileName.startsWith( 'LoginLocale' ) ) {
                    return false;
                }

                if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 5 );
                } else if( /_[\w]{2}$/.test( fileName ) ) {
                    localeCode = 'LoginLocale_' + fileName.substring( fileName.length - 2 );
                } else {
                    localeCode = 'LoginLocale';
                }
                return localeCode === name || name !== 'LoginLocale' && localeCode === 'LoginLocale';
            } ).map( path => m( path ).then( ( contents ) => {
                return { contents: interopES6Default( contents ), name: path };
            } ) ) ), []
    );

    /**
     * Add missing entries in the non-English localization with the English values.
     *
     * @param {Object} nonEnglish - non-English localization data
     * @param {Object} english - English localization data
     */
    function backFillFromEnglish( nonEnglish, english ) {
        for( const bundleName in english ) {
            const bundle = english[ bundleName ];
            if( !nonEnglish[ bundleName ] ) {
                nonEnglish[ bundleName ] = bundle;
                continue;
            }
            for( const key in bundle ) {
                const value = bundle[ bundleName ];
                if( !nonEnglish[ bundleName ][ key ] ) {
                    nonEnglish[ bundleName ][ key ] = value;
                }
            }
        }
    }

    return Promise.all( importResArray ).then( ( i18nlanguages ) => {
        for( const cur of i18nlanguages ) {
            let [ fullStr, moduleName, fileName ] = cur.name.match( /^.*[\\|/]([^\\/]*)[\\|/]([^\\/]*)\.json$/ );
            let localeName;
            if( /_[\w]{2}_[\w]{2}$/.test( fileName ) ) {
                localeName = fileName.substring( fileName.length - 5 );
                fileName = fileName.substring( 0, fileName.length - 6 );
            } else if( /_[\w]{2}$/.test( fileName ) ) {
                localeName = fileName.substring( fileName.length - 2 );
                fileName = fileName.substring( 0, fileName.length - 3 );
            } else {
                localeName = 'en_US';
            }
            if( !i18nAllFiles[ localeName ] ) { i18nAllFiles[ localeName ] = {}; }
            if( cur.contents ) {
                try {
                    i18nAllFiles[ localeName ][ fileName ] = cur.contents;
                } catch ( err ) {
                    logger.error( `Unable to parse ${cur.name}` );
                    throw err;
                }
            }
        }

        for( const locale in i18nAllFiles ) {
            const json = i18nAllFiles[ locale ];
            if( locale !== 'en_US' ) { backFillFromEnglish( json, i18nAllFiles.en_US ); }
            if( json.LoginLocale && json.LoginLocale[ locale ] ) {
                for( const locale2 of Object.keys( i18nAllFiles ) ) {
                    _.set( i18nAllFiles, [ locale2, 'LoginLocale', locale ], json.LoginLocale[ locale ] );
                }
            }
        }

        let res;
        for( const locale in i18nAllFiles ) {
            const json = i18nAllFiles[ locale ];
            if( name.endsWith( locale ) ) {
                res = json;
            }
        }

        return res ? res : i18nAllFiles.en_US;
    } );
};

/**
 * parse return value webpack.require.context to module object array
 * @param {Array} imports module structure return by webpack.require.context API
 * @returns {Object} module object array
 */
export const parseImports = imports => imports.reduce( ( res, m ) =>
    res.concat( m.keys().map( path => ( {
        name: path,
        contents: interopES6Default( m( path ) )
    } ) ) ), [] );

/**
 * stitch JSON from require.context import
 * @param {String} name module structure return by webpack.require.context API
 * @param {Array} imports module structure return by webpack.require.context API
 * @param {Object} config JSON configuration definition
 * @returns {Object} stitched JSON object
 */
export const stitchJSON = ( name, imports, config = {}, lazy ) =>
    processJsonImports( name, parseImports( imports ), config, lazy );

/**
 * Try to get field object from expr and field context
 * @param {String} expr field input expression
 * @param {Object} fields fields context
 * @param {String} $index $index context
 * @param {String} path fields context
 * @param {Object} context fields context
 * @returns {Object} field object consumed by universal widget
 */
export const getField = ( expr, fields, $index, path, context ) => {
    if( path && $index ) {
        if( /^ctx\./.test( path ) ) {
            return AwParseService.instance( path.replace( /^ctx\./, '' ).replace( /\./g, '_' ) )( fields )[ $index ] || { fielddata: {} };
        }
        // support the use case of atomic data with aw-repeat
        if( path.startsWith( 'fields.' ) ) {
            return AwParseService.instance( expr )( context );
        }
        return AwParseService.instance( path.replace( /\.props([.[][^.]+\]?)$/, '$1' ).replace( /^data\./, '' ).replace( /^props\.|\.props/, '' ) )( fields )[ $index ] || { fielddata: {} };
    }
    if( /^ctx\./.test( expr ) ) {
        return AwParseService.instance( expr.replace( /^ctx\./, '' ).replace( /\./g, '_' ) )( fields ) || { fielddata: {} };
    }
    if( !_.isNil( $index ) ) {
        expr = expr.replace( '$index', $index.toString() );
    }

    if( expr.startsWith( 'fields.' ) ) {
        return AwParseService.instance( expr.replace( /^data\./, '' ).replace( /^fields\./, '' ) )( fields ) || { fielddata: {} };
    }

    // - put { fielddata: {} } as default value to match with widget design
    // - Supported use case:
    //   - data.myText => myText
    //   - data.myObj.props.object_name => myObj.object_name
    return AwParseService.instance( expr.replace( /\.props([.[][^.]+\]?)$/, '$1' ).replace( /^data\./, '' ).replace( /^fields\./, '' ) )( fields ) || { fielddata: {} };
};

/**
 * Replace all instances of a given string within a larger string.
 *
 * @param {String} input - input string to replace content
 * @param {String} toFind - string to locate
 * @param {String} toReplace - string to replace
 * @return {String} modified string
 */
export const replaceAll = ( input, toFind, toReplace ) => {
    let output = input;
    if( output.indexOf( toFind ) > -1 ) {
        output = output.split( toFind ).join( toReplace );
    }
    return output;
};
