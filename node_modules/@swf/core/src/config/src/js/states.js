// Copyright (c) 2021 Siemens

/**
 * @module js/states
 */
import loadable from '@loadable/component';
import _ from 'lodash';
import { getResolvedActions } from 'js/stateResolveService';
import cfgSvc from 'js/configurationService';
import { loadDynModule, afxDynamicImport, includeComponent } from 'js/moduleLoader';
import AwPromiseService from 'js/awPromiseService';
import AwStateService from 'js/awStateService';
let routes = [];

const mapStatesToRoutes = ( states ) =>
    _.forEach( states, ( state, name ) => routes.push( buildStates( state, name ) ) );

const doLazyLoad = componentName => {
    if( componentName === 'AwDefaultSublocation' ) {
        // to use AwDefaultSublocation from states.json needs to pass subpanel context
        return ( props ) => {
            const stateData = AwStateService.instance.current.data;
            //Ui router sets the parent data in the prototype of child
            //get the parent state data and pass it to the component
            const parentData = Object.getPrototypeOf( stateData );
            //current state data should always take precedence over parent
            return includeComponent( componentName, { subPanelContext: { ...props.subPanelContext, ...parentData, ...stateData } } );
        };
    }
    return loadable( () => loadDynModule( `viewmodel/${componentName}ViewModel` ) );
};

const buildStates = ( state, name ) => {
    return {
        ...state.url && { url: state.url },
        name: name,
        ...state.parent && { parent: state.parent },
        ...state.params && { params: state.params },
        ...state.data && { data: state.data },
        ...state.visibleWhen && { visibleWhen: state.visibleWhen },
        resolve: getResolvedActions( state ),
        ...state.noAuth && { noAuth: state.noAuth },
        ...state.view && { component: doLazyLoad( state.view ) },
        reloadOnSearch: state.hasOwnProperty( 'reloadOnSearch' ) ? state.reloadOnSearch : false,
        dynamic: state.dynamic,
        refresh: state.refresh,
        notify: state.notify
    };
};

export const buildAndGetAllStates = ( contributionStates ) => {
    var statesCfg = cfgSvc.getCfgCached( 'states' );
    var mergedRoutes = _.merge.apply( this, [ statesCfg ].concat( contributionStates ) ); // eslint-disable-line no-invalid-this

    // Global parameters that apply to every route
    var globalParameters = [
        'ah', // hosting enablement
        'debugApp', // debug
        'locale', // locale override
        'logActionActivity',
        'logEventBusActivity',
        'logLevel',
        'logLifeCycle'
    ];

    // Parameters that should not be in the URL (runtime only)
    var nonUrlParameters = [
        'validateDefaultRoutePath' // workspace validation
    ];

    /**
     * Async load dependency for given state object.
     *
     * @param {Object} state - Object who's dependencies to load.
     *
     * @returns {Promise} Resolved when the dependencies are loaded.
     */
    function createLoad( state ) {
        return AwPromiseService.instance( ( resolve ) => {
            return afxDynamicImport( state.dependencies, resolve );
        } );
    }

    /**
     * Update given object with global parameters.
     *
     * @param {Object} state - Object to update.
     */
    function updateWithParameters( state ) {
        var params = globalParameters.slice(); // copy globalParameters

        if( state.params ) {
            params = _.union( params, Object.keys( state.params ) );
        }

        if( state.parent ) {
            var parent = mergedRoutes[ state.parent ];
            if( parent && parent.params ) {
                params = _.union( params, Object.keys( parent.params ) );
            }
        }

        var urlParams = params.filter( function( p ) {
            return nonUrlParameters.indexOf( p ) === -1;
        } );

        if( urlParams.length > 0 ) {
            var haveQueryParam = state.url.indexOf( '?' ) !== -1;
            state.url += ( haveQueryParam ? '&' : '?' ) + urlParams.join( '&' );
        }
    }

    _.forEach( mergedRoutes, function( route ) {
        // in angular dependencies was getting used for load the controller
        // it's not needed

        // if( route.dependencies ) {
        // if( route.resolve ) {
        //     route.resolve.push( {
        //         token: 'load',
        //         resolveFn: () => { createLoad( route ); }
        //     } );
        // } else {
        //     route.resolve = [ {
        //         token: 'load',
        //         resolveFn: () => { createLoad( route ); }
        //     } ];
        // }
        // }

        if( route.url && !route.abstract ) {
            updateWithParameters( route );
        }
    } );

    mapStatesToRoutes( mergedRoutes );

    return routes;
};
export default {
    buildAndGetAllStates
};
