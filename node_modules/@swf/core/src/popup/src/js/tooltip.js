// Copyright (c) 2020 Siemens

/**
 * @module js/tooltip
 */
import { DOMAPIs as dom } from 'js/domUtils';
import wcagSvc from 'js/wcagService';
import keyCode from 'js/keyCode';

class Tooltip {
    constructor( target, options, show, hide ) {
        this.target = target;
        this.options = options;
        this._show = show;
        this._hide = hide;
        this.popupRef = null;
        this.initialize();
    }

    initialize() {
        this.show = () => { this.showId = setTimeout( this._show, this.options.showDuration ); };
        this.hide = () => {
            clearTimeout( this.showId );
            this.hideId = setTimeout( this._hide, this.options.hideDuration );
        };
        this.keyFocusHandler = this._keyFocusHandler.bind( this );
        this.keyBlurHandler = this._keyBlurHandler.bind( this );
        this.setHooks();
    }

    configure( tooltipObj ) {
        // attach trigger event
        let focusTarget = this.target;
        if( this.target.classList.contains( 'aw-command' ) ) {
            focusTarget = this.target.children[ 0 ];
        }
        dom.on( this.target, 'mouseenter', this.show );
        dom.on( this.target, 'mouseleave,click', this.hide );
        dom.on( focusTarget, 'focus', this.keyFocusHandler );
        dom.on( focusTarget, 'blur', this.keyBlurHandler );
        // required by useEffect to clear resource
        return () => {
            dom.off( this.target, 'mouseenter', this.show );
            dom.off( this.target, 'mouseleave,click', this.hide );
            dom.off( focusTarget, 'focus', this.keyFocusHandler );
            dom.off( focusTarget, 'blur', this.keyBlurHandler );
            tooltipObj = null;
        };
    }

    _keyFocusHandler() {
        if( wcagSvc.areWeInKeyboardMode() && event ) {
            let key = wcagSvc.getKeyName( event );
            if( key !== keyCode.ESC ) { // escape key should not directly impact tooltip popupRef
                this.show();
            }
        }
    }

    _keyBlurHandler() {
        if( wcagSvc.areWeInKeyboardMode() && event ) {
            let key = wcagSvc.getKeyName( event );
            if( key !== keyCode.ESC ) { // escape key should not directly impact tooltip popupRef
                this.hide();
            }
        }
    }

    setHooks() {
        this.hooks = {
            hooks: {
                whenOpened: ( popupRef ) => {
                    this.popupRef = popupRef;
                    let { panelEl } = popupRef;

                    // enable move-in feature when tooltip fully shows up
                    setTimeout( () => {
                        if( this.popupRef ) {
                            panelEl.addEventListener( 'mouseenter', ( event ) => {
                                event.stopImmediatePropagation();
                                clearTimeout( this.hideId );
                            } );

                            panelEl.addEventListener( 'mouseleave', ( event ) => {
                                event.stopImmediatePropagation();
                                this.hide();
                            } );
                        }
                    }, 150 );
                },
                whenClosed: ( popupRef ) => {
                    this.popupRef = null;
                }
            }
        };
    }
    // end
}

export {
    Tooltip
};
