/* eslint-disable valid-jsdoc */

/**
 * @module js/ariaUtils
 */
const ariaUtils = {};

ariaUtils.isFocusable = function( element ) {
    if( element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute( 'tabIndex' ) !== null ) {
        return true;
    }

    if( element.disabled ) {
        return false;
    }

    switch ( element.nodeName ) {
        case 'A':
            return Boolean( element.href ) && element.rel !== 'ignore';
        case 'INPUT':
            return element.type !== 'hidden' && element.type !== 'file';
        case 'BUTTON':
        case 'SELECT':
        case 'TEXTAREA':
            return true;
        default:
            return false;
    }
};

ariaUtils.attemptFocus = function( element ) {
    if( !ariaUtils.isFocusable( element ) ) {
        return false;
    }

    ariaUtils.IgnoreUtilFocusChanges = true;
    try {
        element.focus();
    } catch ( e ) {
        //
    }
    ariaUtils.IgnoreUtilFocusChanges = false;
    return document.activeElement === element;
};

ariaUtils.focusFirstDescendant = function( element ) {
    for( var i = 0; i < element.childNodes.length; i++ ) {
        var child = element.childNodes[ i ];
        if( ariaUtils.attemptFocus( child ) ||
            ariaUtils.focusFirstDescendant( child ) ) {
            return true;
        }
    }
    return false;
};

ariaUtils.focusLastDescendant = function( element ) {
    for( var i = element.childNodes.length - 1; i >= 0; i-- ) {
        var child = element.childNodes[ i ];
        if( ariaUtils.attemptFocus( child ) ||
            ariaUtils.focusLastDescendant( child ) ) {
            return true;
        }
    }
    return false;
};

// Bracket the dialog node with two invisible, focusable nodes.
// While this dialog is open, we use these to make sure that focus never
// leaves the document even if dialogNode is the first or last node.
ariaUtils.createSentinel = function( element ) {
    let preDiv = document.createElement( 'div' );
    let preNode = element.parentNode.insertBefore( preDiv, element );
    preNode.tabIndex = 0;
    let postDiv = document.createElement( 'div' );
    let postNode = element.parentNode.insertBefore( postDiv, element.nextSibling );
    postNode.tabIndex = 0;
    return () => {
        element.parentNode.removeChild( preNode );
        element.parentNode.removeChild( postNode );
    };
};

ariaUtils.trapFocus = ( element ) => ( event ) => {
    if( ariaUtils.IgnoreUtilFocusChanges ) { return; }
    if( element.contains( event.target ) ) {
        ariaUtils.lastFocus = event.target;
    } else {
        ariaUtils.focusFirstDescendant( element );
        if( ariaUtils.lastFocus === document.activeElement ) {
            ariaUtils.focusLastDescendant( element );
        }
        ariaUtils.lastFocus = document.activeElement;
    }
};

ariaUtils.configureFocusListener = ( element ) => {
    const focusHandler = ariaUtils.trapFocus( element );
    document.addEventListener( 'focus', focusHandler, true );
    return () => {
        document.removeEventListener( 'focus', focusHandler, true );
    };
};

ariaUtils.configureAutoFocusAndLoopTabbable = ( dialogNode, focusAfterClosed ) => {
    const removeHandlers = [];

    // createSentinel
    removeHandlers.push( ariaUtils.createSentinel( dialogNode ) );

    // trapFocus, ensure tabIndex loops in popup
    removeHandlers.push( ariaUtils.configureFocusListener( dialogNode ) );

    // clean lastFocus
    removeHandlers.push( () => delete ariaUtils.lastFocus );

    // honour focusAfterClosed, ensure reference element(if applicable) being focused when popup closed.
    const onClose = () => { focusAfterClosed && focusAfterClosed.focus(); };

    // trigger focus first element in popup when it opens.
    ariaUtils.focusFirstDescendant( dialogNode );

    return {
        removeHandlers,
        onClose
    };
};

export default ariaUtils;
