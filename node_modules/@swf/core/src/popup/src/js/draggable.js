// Copyright (c) 2020 Siemens

/**
 * @module js/draggable
 */
import { DOMAPIs as dom } from 'js/domUtils';

/* eslint-disable require-jsdoc */
/* eslint-disable max-statements-per-line */
const defaults = {
    // settings
    grid: 0, // grid cell size for snapping to on drag
    filterTarget: null, // disallow drag for these target
    limit: { // limit the drag bounds
        x: null, // [minimum position, maximum position] || position
        y: null // [minimum position, maximum position] || position
    },
    threshold: 0, // threshold to move before drag begins (in px)

    // flags
    setCursor: false, // change cursor to reflect draggable?
    smoothDrag: true, // snap to grid when dropped, but not during

    // event hooks
    onDrag: noop, // function(element, X, Y, event)
    onDragStart: noop, // function(element, X, Y, event)
    onDragEnd: noop // function(element, X, Y, event)
};

/**
 * usage: new Draggable (element, options)
 *
 * @param {DOMElement} element the element to enable drag
 * @param {Object} options the drag options
 */
function Draggable( element, options ) {
    options = Object.assign( {}, defaults, options );

    var start = this.start.bind( this );
    var drag = this.drag.bind( this );
    var stop = this.stop.bind( this );
    Object.assign( this, {
        element,
        options,
        handle: options.handle && isElement( options.handle ) ? options.handle : element,
        handlers: {
            start: {
                mousedown: start,
                touchstart: start
            },
            move: {
                mousemove: drag,
                mouseup: stop,
                touchmove: drag,
                touchend: stop
            }
        }
    } );
    this.initialize();
}

Object.assign( Draggable.prototype, {
    // internal
    dragEvent: {
        started: false,
        x: 0,
        y: 0
    },
    // public
    setOption: function( property, value ) {
        this.options[ property ] = value;
        this.initialize();
        return this;
    },
    initialize: function() {
        var element = this.element;
        var options = this.options;

        // cache element dimensions (for performance)
        // cannot work with advancePositioning
        this._dimensions = {
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop,
            width: element.offsetWidth
        };

        options.setCursor && dom.addClass( this.handle, this.options.className );

        // set limit
        this.setLimit( options.limit );
        this.updateLimit = () => this.setLimit( options.limit );
        // update limit when page resized
        window.addEventListener( 'resize', this.updateLimit, true );

        // attach mousedown event
        on( this.handle, this.handlers.start );
    },

    start: function( e ) {
        // filter the target?
        if( !this.useTarget( e.target || e.srcElement ) ) {
            return;
        }

        // set initial position
        this.setCursor( this.getCursor( e ) );
        this.setPosition();

        // add event listeners
        on( document, this.handlers.move );
    },

    drag: function( e ) {
        e.preventDefault();
        var dragEvent = this.dragEvent;
        var element = this.element;
        var initialCursor = this._cursor;
        var initialPosition = this._dimensions;
        var options = this.options;
        var cursor = this.getCursor( e );
        var threshold = options.threshold;
        var x = cursor.x - initialCursor.x + initialPosition.left;
        var y = cursor.y - initialCursor.y + initialPosition.top;

        // check threshold
        if( !dragEvent.started && threshold &&
            Math.abs( initialCursor.x - cursor.x ) < threshold &&
            Math.abs( initialCursor.y - cursor.y ) < threshold
        ) {
            return;
        }

        // save original position?
        if( !dragEvent.original ) {
            dragEvent.original = { x: x, y: y };
        }

        // trigger start event?
        if( !dragEvent.started ) {
            options.onDragStart( element, x, y, e );
            dragEvent.started = true;
        }

        // move the element
        if( this.move( x, y ) ) {
            // trigger drag event
            options.onDrag( element, dragEvent.x, dragEvent.y, e );
        }
    },

    move: function( x, y ) {
        var dragEvent = this.dragEvent;
        var options = this.options;
        var grid = options.grid;
        var style = this.element.style;
        var pos = this.limit( x, y, dragEvent.original.x, dragEvent.original.y );

        // snap to grid?
        if( !options.smoothDrag && grid ) {
            pos = this.round( pos, grid );
        }

        // move it
        if( pos.x !== dragEvent.x || pos.y !== dragEvent.y ) {
            dragEvent.x = pos.x;
            dragEvent.y = pos.y;
            style.left = pos.x + 'px';
            style.top = pos.y + 'px';
            return true;
        }
        return false;
    },

    stop: function( e ) {
        var dragEvent = this.dragEvent;
        var element = this.element;
        var options = this.options;
        var grid = options.grid;
        var pos;

        // remove event listeners
        off( document, this.handlers.move );

        // snap to grid?
        if( options.smoothDrag && grid ) {
            pos = this.round( { x: dragEvent.x, y: dragEvent.y }, grid );
            this.move( pos.x, pos.y );
            Object.assign( this.dragEvent, pos );
        }

        // trigger dragend event
        if( this.dragEvent.started ) {
            options.onDragEnd( element, dragEvent.x, dragEvent.y, e );
        }

        // clear temp vars
        this.reset();
    },
    reset: function() {
        this.dragEvent.started = false;
    },
    round: function( pos ) {
        var grid = this.options.grid;
        return {
            x: grid * Math.round( pos.x / grid ),
            y: grid * Math.round( pos.y / grid )
        };
    },
    getCursor: function( e ) {
        return {
            x: ( e.targetTouches ? e.targetTouches[ 0 ] : e ).clientX,
            y: ( e.targetTouches ? e.targetTouches[ 0 ] : e ).clientY
        };
    },
    setCursor: function( xy ) {
        this._cursor = xy;
    },
    setLimit: function( limit ) {
        var _true = function( x, y ) {
            return { x: x, y: y };
        };

        if( isFunction( limit ) ) {
            this.limit = limit;
        } else if( isElement( limit ) ) {
            var draggableSize = this._dimensions;
            var height = limit.scrollHeight - draggableSize.height;
            var width = limit.scrollWidth - draggableSize.width;

            this.limit = function( x, y ) {
                return {
                    x: checkLimit( x, [ 0, width ] ),
                    y: checkLimit( y, [ 0, height ] )
                };
            };
        } else if( limit ) {
            var defined = {
                x: isDefined( limit.x ),
                y: isDefined( limit.y )
            };
            if( !defined.x && !defined.y ) {
                this.limit = _true;
            } else {
                this.limit = function( x, y ) {
                    return {
                        x: defined.x ? checkLimit( x, limit.x ) : x,
                        y: defined.y ? checkLimit( y, limit.y ) : y
                    };
                };
            }
        } else {
            this.limit = _true;
        }
    },

    setPosition: function() {
        var element = this.element;
        var style = element.style;

        Object.assign( this._dimensions, {
            left: parse( style.left ) || element.offsetLeft,
            top: parse( style.top ) || element.offsetTop
        } );
    },

    useTarget: function( element ) {
        var filterTarget = this.options.filterTarget;
        if( filterTarget instanceof Function ) {
            return filterTarget( element );
        }
        return true;
    },

    destroy: function() {
        this.handle && off( this.handle, this.handlers.start );
        off( document, this.handlers.move );
        window.removeEventListener( 'resize', this.updateLimit, true );
        this.options.setCursor && dom.removeClass( this.handle, this.options.className );
        delete this.element;
        delete this.options;
    }
} );

// helpers
function parse( string ) {
    return parseInt( string, 10 );
}

function isArray( thing ) {
    return thing instanceof Array;
}

function isDefined( thing ) {
    return thing !== void 0 && thing !== null;
}

function isElement( thing ) {
    return thing instanceof Element || typeof HTMLDocument !== 'undefined' && thing instanceof HTMLDocument;
}

function isFunction( thing ) {
    return thing instanceof Function;
}

// eslint-disable-next-line no-empty-function
function noop() {}

function on( element, obj ) {
    if( obj ) {
        for( var ee in obj ) {
            element.addEventListener( ee, obj[ ee ], false );
        }
    }
}

function off( element, obj ) {
    if( obj ) {
        for( var ee in obj ) {
            element.removeEventListener( ee, obj[ ee ] );
        }
    }
}

function checkLimit( n, limit ) {
    if( isArray( limit ) ) {
        limit = [ Number( limit[ 0 ] ), Number( limit[ 1 ] ) ];
        if( n < limit[ 0 ] ) { n = limit[ 0 ]; } else if( n > limit[ 1 ] ) { n = limit[ 1 ]; }
    } else {
        n = Number( limit );
    }
    return n;
}

export default Draggable;
