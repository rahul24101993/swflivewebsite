// Copyright (c) 2021 Siemens
/* eslint-disable valid-jsdoc */
/* eslint-disable require-jsdoc */

/**
 * @module js/popupService
 */
import _ from 'lodash';
import utils from 'js/popupUtils';
import { DOMAPIs as dom } from 'js/domUtils';
import positionService from 'js/positionService';
import appCtxService from 'js/appCtxService';

const manager = new utils.PopupManager();
const MIN_SIZE = 50;
const BUFFER_SIZE = 20;

// the default popup options
const _defaultOptions = {
    // enable open multiple popups at the same time
    // multiple: false,

    // pre-defined popup configures provided by framework. accept values: modal, balloon, tooltip
    // preset: null,

    // enable close the popup when click outside the popup
    clickOutsideToClose: true,

    // auto update popup position or close popup when the reference element moves, accept values: 'follow', 'close'
    whenParentScrolls: 'follow',

    // use outside scroll event to do scroll detection, then based on option whenParentScrolls to close or do follow
    // if set to false, scroll detection will fall back to naive mode: where scroll happens from body to reference.
    useOutsideScrollEvent: true,

    // modal mode
    // hasMask: false,

    // has arrow / bubble
    // hasArrow: false,

    arrowOptions: {
        // specify where to align the arrow, relative to reference element,
        // valid value: auto / center / start / end
        // auto: based on the popup alignment, arrow should be smart position itself.
        alignment: 'auto',
        // specify the alignment offset in px, relative to reference element,
        // could be positive / negative
        // special used for start / end case.
        offset: 0,
        // specify the shift offset in px, relative to popup element,
        // must be positive
        shift: 5
    },

    // the default parent element where the popup element mount to, accept native Element or css selector
    // only valid when enableAppend is true, disable it by set enableAppend = false
    parent: document.body,

    // set to false when user uses popup in multiple level / nested case
    enableAppend: true,

    // the reference element which trigger the popup, accept native Element or css selector
    // reference: null,

    // enable popup overlapping on reference element
    // overlapOnReference: false,

    // expect to position popup relative to the reference element
    relative: true,

    // Use this option when you want to position popup on the current mouse position. It could be the native targetEvent which triggers to show the popup, or any event with clientX, clientY information
    // targetEvent: null,

    // support add custom styles from application.
    // required for aw-navigate-breadcrumb and aw-search-breadcrumb
    // className: '',

    // popup container size, unit should be included and it could be any. optional
    // height: '',
    // width: '',
    // maxWidth: '',
    // maxHeight: '',
    // minHeight: '',
    // minWidth: '',

    // define the minimal size a popup could be, it's required because:
    // 1, prevent popup too small
    // 2, smart flip side and alignment to support smart position
    minSize: MIN_SIZE,

    // UX requirement: define the gap/buffer size for drop shadow when the available space is highly limited
    marginBufferSize: BUFFER_SIZE,

    // enable popup draggable or not
    // draggable: false,

    // placement options: ['top-start','top','top-end','right-start','right','right-end',
    // 'bottom-end','bottom','bottom-start','left-end','left','left-start']
    placement: 'bottom-start',

    // smart position behavior, accept values: 'fixed', 'opposite', 'clockwise', 'counterclockwise'
    // define how the position engine to search a available space to place the popup.
    flipBehavior: 'opposite',

    // popup lifeCycle hooks
    hooks: {
        whenOpened: null,
        whenUpdated: null,
        whenClosed: null
    }

    // Only available for command popup action case - whether to show a popup independent(not nested) of that command. By default command popup are nested.
    // independent: false
};

/**
 * the default preset options for AFX provided popups,
 * user can override by explicitly configure options
 */
const _popupPresets = {
    modal: {
        options: {
            relative: false,
            hasMask: true,
            innerClassName: 'aw-popup-Modal',
            clickOutsideToClose: false,
            adaptiveShift: true,
            draggable: true,
            handle: '.aw-layout-panelTitle, .panel-header',
            whenParentScrolls: 'close'
        }
    },
    balloon: {
        options: {
            ownContainer: true,
            hasArrow: true,
            innerClassName: 'aw-popup-balloon',
            clickOutsideToClose: true,
            adaptiveShift: true,
            placement: [ 'top', 'bottom', 'left', 'right' ],
            flipBehavior: 'opposite',
            padding: {
                x: 4,
                y: 4
            },
            arrowOptions: {
                // specify where to align the arrow, relative to reference element,
                // valid value: auto / center / start / end
                alignment: 'auto',
                // specify the alignment offset in px, relative to reference element,
                // could be positive / negative
                // special used for start / end case.
                offset: 5,
                // specify the shift offset in px, relative to popup element,
                // must be positive
                shift: 15
            }
        }
    },
    tooltip: {
        options: {
            autoFocus: false,
            showDuration: 100,
            hideDuration: 100,
            ownContainer: true,
            placement: [ 'top', 'bottom', 'right', 'left' ],
            flipBehavior: 'opposite',
            whenParentScrolls: 'close',
            adaptiveShift: true, // prevent tooltip cut off in corner case
            resizeToClose: true,
            advancePositioning: true, // prevent overlap or flash when popup content growing
            hasArrow: true,
            padding: { x: 4, y: 4 },
            arrowOptions: {
                alignment: 'center'
            },
            minSize: 5,
            hasPadding: true,
            forceCloseOthers: false,
            innerClassName: 'sw-popup-tooltip sw-popup-easein'
        }
    }
    // EXTENDED FUTURE
};

// popup node name,
const POPUP_NODE_SELECTOR = 'div.sw-popup';

/**
 * serves as advanced version of hide api
 *
 * close popup by the popupEl or target event. null to force close all popups
 *
 * @param {Object | String} popupEl - the popupEl to close. accept native Element element or css selector
 * @param {String} excludeId - the popupEl to exclude
 * @param {Boolean} force - force to close all popups on current page
 * @returns {Promise} promise with the close result, true or false
 */
function close( popupEl, excludeId = null, force = false ) {
    let elements = [];
    // if specified and still available on DOM
    popupEl = utils.getElement( utils.extendSelector( popupEl ) );
    if( popupEl ) {
        elements = _.concat( [], popupEl );
    }
    // default to force close all popups if no element specified.
    if( !popupEl ) {
        elements = dom.getAll( POPUP_NODE_SELECTOR );
    }

    let tasks = [];
    _.forEach( elements, function( elem ) {
        if( excludeId && excludeId === elem.id ) { return; }
        const popupRef = manager.get( elem.id );
        popupRef && tasks.push( popupRef.hide( force ) );
    } );

    return Promise.all( tasks ).then( () => true );
}

function processExistingPopups( options ) {
    let result = true;
    const { reference } = options;
    if( options.multiple === true ) {
        // prevent create duplicate popup instance for one referenceEl
        // if the referenceEl already has a popup, show again just by bring the popup to foreground,
        // return popupRef or true
        result = utils.handleOpenedPopup( reference, manager );
    } else {
        // if in singleton mode, always force close others
        // process others
        // return true
        if( options.forceCloseOthers !== false ) {
            const id = reference ? reference.getAttribute( utils.POPUP_ID_ATTRIBUTE ) : null;
            close( null, id );
            result = true;
        }
        // process self
        // return null or true
        if( options.toggleMode === true ) {
            // if the referenceEl already has a popup, close it and return null to indicate exit
            result = utils.handleOpenedPopup( reference, manager, true );
        }
    }
    return result;
}

function deepAssign() {
    function customize( objValue, srcValue, key ) {
        // simple assign by default
        let result = srcValue;
        // go deeper for these keys
        if( [ 'arrowOptions', 'hooks' ].indexOf( key ) !== -1 ) {
            result = _.assign( {}, objValue, srcValue );
        }
        return result;
    }
    return _.assignWith( {}, ...arguments, customize );
    //return _.partialRight( _.assignWith, customize )( ...arguments );
}

const getReference = ( reference, force = false ) => {
    // case ref
    if( reference && _.has( reference, 'current' ) ) {
        if( force ) { return reference.current; }
        return reference.current || reference;
    }
    // case native dom or normal selector
    return utils.getElement( reference );
};

const componentMounted = ( options, popupEl ) => {
    // re-evaluate reference
    const reference = getReference( options.reference, true );
    let popupRef = new utils.PanelRef( popupEl, { ...options, reference } );

    options.showDeferred.current && options.showDeferred.current.resolve( popupRef );

    manager.add( popupRef );
    popupRef.attach();
    updatePosition( popupRef );

    return function componentWillUnMounted() {
        options.hideDeferred.current && options.hideDeferred.current.resolve( true );
        options.showDeferred.current && options.showDeferred.current.resolve( true );
        manager.remove( popupRef );
        popupRef.detach();

        // clean up resources
        options.showDeferred.current = null;
        options.hideDeferred.current = null;
        popupRef = null;
    };
};

function consolidateOptions( options, hide, update ) {
    // backup user options
    const userOptions = deepAssign( {}, options );

    // merge presetOptions if any preset defined
    let presetOptions = {};
    const preset = options.preset;
    if( preset && _.has( _popupPresets, preset ) ) {
        presetOptions = _popupPresets[ preset ].options;
    }

    options = deepAssign( {}, _defaultOptions, presetOptions, options );
    options.userOptions = userOptions;
    options.parent = utils.getElement( options.parent ) || document.body;
    options.reference = getReference( options.reference );
    options.manager = manager;
    inflateOptions( options );

    // apis being passed around(to subview) to control popups, only initial once
    if( !options.api ) {
        const getCurrent = () => manager.get( options.popupReference.current.id );

        options.api = {
            // hide this popup
            // hide()
            hide,
            // update options for this popup
            // update({ height: 500 } )
            update,
            // get this popup - return popupRef
            // getCurrent()
            getCurrent,
            // update position for this popup
            // updatePosition()
            updatePosition: () => updatePosition( getCurrent() )
        };
    }

    const beforeOpen = () => {
        // re-evaluate reference
        options.reference = getReference( options.reference, true );
        return processExistingPopups( options );
    };
    const handlePrevents = ( e ) => {
        e.stopPropagation();
    };
    Object.assign( options, { componentMounted, beforeOpen, handlePrevents } );
    return options;
}

function inflateOptions( options ) {
    if( options.multiple === true ) {
        options.forceUid = true;
        options.useCloseContext = true;
    }
    if( options.whenParentScrolls === 'follow' ) {
        options.followParentScroll = true;
    } else {
        options.followParentScroll = false;
        options.closeWhenParentScroll = true;
    }
    if( options.toggleMode ) {
        options.ignoreReferenceClick = true;
    }
    if( options.preset === 'modal' ) {
        options.relative = false;
    }
    if( options.hasMask ) {
        options.isModal = true;
    }

    // legacy compatible
    // 'isModal' was deprecated, suggest use 'preset' only
    if( options.hasMask && !_.has( options, 'isModal' ) ) {
        options.isModal = true;
    }
    //if preset is not included in options but hasArrow is true, user a wants balloon popup
    if( !_.has( options, 'preset' ) && options.hasArrow && !options.innerClassName ) {
        options.innerClassName = 'aw-popup-balloon';
    }
    if( options.isModal && !_.has( options, 'preset' ) ) {
        options.preset = 'modal';
    }
    // end

    // improve the flexibility to support both single value and array values.
    if( options.placement && _.isArray( options.placement ) ) {
        [ options.placement, ...options.alternativePlacements ] = options.placement;
    }
}

function setPositionAtMousePosition( popupEl, event ) {
    const popup = utils.getContainerElement( popupEl );
    const resizeContainer = utils.getResizeContainer( popupEl );
    const height = popup.offsetHeight;
    const width = popup.offsetWidth;
    const position = utils.getMousePosition( event );
    let left = position.x;
    let top = position.y;

    // Check if context menu would go outside of visible window, and move up if needed
    let resizeInfo = null;
    const maxYNeeded = top + height;
    if( maxYNeeded >= window.innerHeight ) {
        top -= height;
        // case go out of boundary
        if( top < 0 ) {
            resizeInfo = { ...resizeInfo, 'max-height': position.y };
            top = 0;
        }
    }
    const maxXNeeded = left + width;
    if( maxXNeeded >= window.innerWidth ) {
        left -= width;
        // case go out of boundary
        if( left < 0 ) {
            resizeInfo = { ...resizeInfo, 'max-width': position.x };
            left = 0;
        }
    }

    if( resizeContainer ) {
        // clear resize info case application use cache
        dom.setStyles( resizeContainer, { 'max-height': null, 'max-width': null } );
        // resize if needed
        resizeInfo && dom.setStyles( resizeContainer, resizeInfo );
    }
    // position itself
    dom.setStyles( popup, {
        left: left + 'px',
        top: top + 'px'
    } );
}

function setPositionAtPage( popupEl, options ) {
    const popup = utils.getContainerElement( popupEl );
    const height = popup.offsetHeight;
    const width = popup.offsetWidth;

    const w = window.innerWidth;
    const h = window.innerHeight;

    const { placement, resizeContainer, ignoreLimit } = options;
    const container = utils.getResizeContainer( popupEl, resizeContainer );
    container && !ignoreLimit && dom.setStyles( container, { 'max-width': w * 0.6, 'max-height': h * 0.8 } );

    const left = ( w - width ) / 2;
    let top = ( h - height ) / 2;
    if( placement === 'top' ) {
        top = 0;
    }

    dom.setStyles( popup, { left, top } );
}

// positioning
function updatePosition( popupRef ) {
    const options = popupRef.options;
    const popupEl = popupRef.panelEl;

    if( options.disableUpdate ) { return; }

    // case1: position at the mouse position
    if( options.targetEvent ) {
        setPositionAtMousePosition( popupEl, options.targetEvent );
        // case2: position relative to reference element
    } else if( options.reference && options.relative ) {
        const reference = utils.getElement( options.reference );
        // referenceEl could be destroyed in detachMode. need to get it again.
        // if ( options.detachMode ) { reference = utils.getElement( utils.extendSelector( options.userOptions.reference ) ); }
        setPosition( popupEl, reference, options );
    } else {
        // case3: position at the page center by default, or top center
        if( options.draggable ) {
            options.disableUpdate = true;
        }
        setPositionAtPage( popupEl, options );
    }
    popupRef.triggerHook( 'update' );
}

function setPosition( popupEl, referenceEl, options ) {
    const containerEl = utils.getContainerElement( popupEl );
    if( !referenceEl || !containerEl ) { return; }

    if( !dom.inDOM( referenceEl ) ) {
        close( popupEl );
        return;
    }

    if( options && options.placement ) {
        const offset = positionService.calculateOffsets( referenceEl, containerEl, options );

        const { popup, arrow } = offset;
        const { top, bottom, left, right } = popup;
        dom.setStyles( containerEl, { top, bottom, left, right } );

        if( options.hasArrow && arrow ) {
            const arrowEl = utils.getArrowElement( containerEl );
            arrowEl && dom.setStyles( arrowEl, arrow, true );
        }
    }
}

const adaptiveOptions = ( options ) => {
    options = options || {};
    let result = options;
    // old fashion
    if( options.declView || options.options ) {
        result = {
            ...options.options,
            ...options.locals,
            // apply first level and any overrides
            ...options
        };
        // rename
        if( options.declView ) {
            result.view = options.declView;
        }

        // clear the garbage to avoid pollution
        delete result.options;
        delete result.locals;
        delete result.declView;
    }
    return result;
};

/*
 * @alternative use popup action and popup view, ref: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/wikis/popup-design-and-interface
 *
 */
function show( options ) {
    const globalPopup = appCtxService.getCtx( 'globalPopup' );
    if( globalPopup ) {
        const finalOptions = adaptiveOptions( options );
        return globalPopup.show( finalOptions );
    }
}

/**
 * Schedules an update by popupEl or popupRef. It will run on the next UI update available.
 *
 * @param {Object} popupEl - the popupEl / popupRef to update.
 *
 * @returns {Promise} promise with the updated popupRef
 */
function update( popupEl ) {
    const popupRef = manager.get( popupEl.id );
    popupRef && popupRef.scheduleUpdate();
    return Promise.resolve( popupRef );
}

/*
 * @alternative use popup action and popup view, ref: https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/wikis/popup-design-and-interface
 *
 */
// support hide as an alias for post compatibility
const hide = close;

export {
    show,
    hide,
    close,
    update,
    consolidateOptions
};

const popupService = {
    show,
    hide,
    close,
    update,
    consolidateOptions
};
export { popupService };
export default popupService;
