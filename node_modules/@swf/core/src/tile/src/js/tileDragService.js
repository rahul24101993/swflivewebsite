// Copyright (c) 2021 Siemens

/**
 * This service manages tiles drag and reorder functionality.
 *
 * @module js/tileDragService
 */
import $ from 'jquery';
import _ from 'lodash';
import browserUtils from 'js/browserUtils';
import logger from 'js/logger';

/**
   * Static Strings referencing css classes
   */
var TILEMAIN_CSS_CLASS = 'aw-tile-tileMain';
var TILE_CONT_CSS_CLASS = 'sw-column.aw-tile-tileContainer';
var TILE_DRAGGABLE_CSS_CLASS = 'aw-tile-draggable';
var TILEGROUP_CSS_CLASS = 'aw-tile-tileGroup';
var PLACEHOLDER_GROUP_CSS_CLASS = 'aw-tile-placeHolderGroupSep';
var PLACEHOLDER_TILE_CSS_CLASS = 'aw-tile-placeHolderTile';
var DRAGTILE_CSS_CLASS = 'aw-tile-dragTile';
var TILE_GROUP_TAGNAME = 'aw-tile-group';
var TILE_MAIN_CONTAINER_CSS_CLASS = 'aw-tile-mainContainer';

/**
   * <pre>
   * Greater Than 0 If some basic event activity should be logged.
   * Greater Than 1 If some more fine-grained event activity should be logged.
   * </pre>
   */
var _debug_logEventActivity = 0;

var placeHolderTile;
let draggedTileInfo;
let droppedTileInfo;

/**
   * Check if <b>everything</b> in the 'dataTransfer' is valid to drop on the 'target'.
   *
   * @param {DragEvent} event - The event containing the details of the 'dataTransfer' and 'target' element to
   *            test.
   * @return {Boolean} TRUE if something in the 'dataTransfer' is valid to drop on the 'target'.
   */
var _isValidToDrop = function( event ) {
    return true;
};

/**
   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that
   * represents to create a new group OR placeHolder tile element to find out the reorder position
   *
   * @param {DragEvent} event - The event to start the search at.
   * @param {Boolean} isNewGroup - If a new tile group is to be created
   *
   * @return {Element} The Element where we need to reorder and insert dragged tile after this.
   */
var _findDropTargetElement = function( event, isNewGroup ) {
    var dropTarget = {};
    dropTarget.inPlace = false;
    let eventSrc = event.currentTarget;

    if( isNewGroup ) {
        var placeholderGroup = $( '.' + TILE_MAIN_CONTAINER_CSS_CLASS ).find( '.' + PLACEHOLDER_GROUP_CSS_CLASS );
        dropTarget.element = placeholderGroup.prev( '.' + TILEGROUP_CSS_CLASS );

        // For the use case of the previous element not being an actual tile group
        while( dropTarget.element.hasClass( 'aw-tile-emptyTileGroup' ) ) {
            dropTarget.element = dropTarget.element.prev( '.' + TILEGROUP_CSS_CLASS );
        }

        // If the new group is in the 1st tile group location
        if( dropTarget.element.length === 0 ) {
            dropTarget.element = dropTarget.element.prevObject;
        }

        dropTarget.element = dropTarget.element[ 0 ];
        return dropTarget;
    }

    dropTarget.element = $( '.aw-tile-mainContainer .aw-tile-placeHolderTile' );

    if( dropTarget.element.length === 0 ) {
        if( !$( eventSrc ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {
            // find the closest
            var parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );
            // if its not on the parent level, then try to find it in the children
            if( parentTileElem.length === 0 ) {
                parentTileElem = $( eventSrc ).find( '.' + TILE_DRAGGABLE_CSS_CLASS );
            }

            if( parentTileElem && parentTileElem.length > 0 ) {
                dropTarget.element = parentTileElem[ 0 ];
            }
        } else {
            dropTarget.element = eventSrc;
        }
    } else {
        //  If we are the first tile && the next tile is a valid tile, use the next tile and drop the tile 'inPlace'
        if( dropTarget.element[ 0 ].style.order === '0' && dropTarget.element.next().length !== 0 ) {
            dropTarget.element = dropTarget.element.next();
            dropTarget.inPlace = true;
        } else {
            dropTarget.element = dropTarget.element.prev();
        }
    }

    return dropTarget;
};

/**
   * Starting with the 'target' of the given DragEvent and walking up the DOM, looking for tileGroup separator element that
   * represents to create a new group OR placeHolder tile element to find out the reorder position
   *
   * @param {DragEvent} event - The event to start the search at.
   *
   * @return {Element} The Element where we need to insert placeHolders by showing indication about new order
   * of dragged tile.
   */
var _findDragEnterElement = function( event ) {
    var dragEnterElement;
    let eventSrc = event.target;
    // find the closest
    let parentTileElem = $( eventSrc ).closest( '.' + TILE_DRAGGABLE_CSS_CLASS );

    if( parentTileElem && parentTileElem.length > 0 ) {
        dragEnterElement = parentTileElem[ 0 ];
    } else if( $( eventSrc ).hasClass( TILEGROUP_CSS_CLASS ) ) {
        dragEnterElement = $( eventSrc );
    }

    return dragEnterElement;
};

/**
   * Remove place holder elements from DOM.
   */
var _removePlaceHolders = function() {
    $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).remove();
    $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).remove();
};

/**
   * Create dummy placeHolder TileGroup element to represent the position in the UI before dropping
   *
   * @return {Element} The Element which represents dummy placeHolder tileGroup
   */
var _createPlaceHolderTileGroup = function() {
    // hidden tile to place it where dragging tile will dropped
    var newTileGroup = $( '<div class="' + TILEGROUP_CSS_CLASS + '"></div>' );
    newTileGroup.addClass( PLACEHOLDER_GROUP_CSS_CLASS );
    return newTileGroup;
};

/**
   * Create dummy placeHolder Tile element to represent the position in the UI before dropping
   *
   * @param {Object} sourceTile - based on source Tile size we need to create the placeHolder element
   *
   * @return {Element} The Element which represents dummy placeHolder tile
   */
var _createPlaceHolderTile = function( sourceTile ) {
    // hidden tile to place it where dragging tile will dropped
    placeHolderTile = $( '<div class="' + PLACEHOLDER_TILE_CSS_CLASS + '"></div>' );
    placeHolderTile.addClass( TILEMAIN_CSS_CLASS );

    if( $( sourceTile ).hasClass( 'aw-tile-doubleSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-doubleSize' );
    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-tripleSize' );
    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-quadroSize' );
    }

    if( $( sourceTile ).hasClass( 'aw-tile-doubleVerticalSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-doubleVerticalSize' );
    } else if( $( sourceTile ).hasClass( 'aw-tile-tripleVerticalSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-tripleVerticalSize' );
    } else if( $( sourceTile ).hasClass( 'aw-tile-quadroVerticalSize' ) ) {
        placeHolderTile.addClass( 'aw-tile-quadroVerticalSize' );
    }

    return placeHolderTile;
};

/**
   * Cleanup CSS classes and attributes added as part of drag events and remove the placeHolder elements
   *
   * @param {Element} dragTileIn - The DOM element for dragging tile
   * @param {Element} element - container element for dragging tile
   */
var _cleanUp = function( dragTileIn, element ) {
    _removePlaceHolders();

    if( dragTileIn ) {
        dragTileIn.removeAttribute( 'id' );
    } else {
        let dragTile = document.querySelector( '#draggedTile' );
        dragTile.classList.remove( DRAGTILE_CSS_CLASS );
        dragTile.removeAttribute( 'id' );
        let tileContElem = dragTile;
    }

    placeHolderTile = null;

    if( _debug_logEventActivity >= 1 ) {
        postLog( 'Cleaning up' );
    }
};

/**
   * Handle caching of DnD mapping data on the 'target' element's 'drop container' the 1st time we encounter the
   * 'target'.
   *
   * @param {DragEvent} event - The drag event with the 'target' to process.
   * @param {Element} targetElement - The target element associate with dragEnter event
   */
var _processDragEnterInternal = function( event, targetElement, targetObjects ) {
    event.preventDefault();
    // place phantom tile instead dragging one
    if( placeHolderTile && targetElement && targetObjects ) {
        // reordering in existing tiles
        if( $( targetElement ).hasClass( TILEMAIN_CSS_CLASS ) && $( targetElement ).hasClass( TILE_DRAGGABLE_CSS_CLASS ) ) {
            _removePlaceHolders();

            var targetCssOrder = targetElement.style.order;
            var order = parseInt( targetCssOrder, 10 );

            var side;
            var element = $( targetElement )[ 0 ];
            var mouseX = event.clientX;
            var elementWidth = element.offsetWidth;
            var halfElementWidth = elementWidth / 2;
            if( mouseX > halfElementWidth + element.offsetLeft ) {
                side = 'right';
            } else {
                side = 'left';
            }

            // If mouse is on left side of first gateway tile, place placeHolderTile before 1st tile. Else, put it after
            if( order === 0 && side === 'left' ) {
                placeHolderTile.insertBefore( targetElement );
                $( placeHolderTile ).css( 'order', 0 );
            } else {
                placeHolderTile.insertAfter( targetElement );
                $( placeHolderTile ).css( 'order', order++ );
            }

            _.forEach( $( placeHolderTile ).nextAll(), function( nextSib ) {
                if( nextSib ) {
                    nextSib.style.order = order++;
                }
            } );

            if( _debug_logEventActivity >= 1 ) {
                var tgtTile = targetObjects[0].tile;

                postLog( 'processDragEnter - PlaceHolder Tile Inserted: ' + tgtTile.displayName );
            }
        } else if( $( targetElement ).hasClass( TILEGROUP_CSS_CLASS ) ) { // vertically or horizontally creating new group
            _removePlaceHolders();

            var targetGroupElem = $( targetElement );
            var placeHolderTileGroup = _createPlaceHolderTileGroup();
            placeHolderTileGroup.insertBefore( targetGroupElem[ 0 ] );

            if( _debug_logEventActivity >= 1 ) {
                postLog( 'processDragEnter - Insert vertical or horizontal placeHolder Group' );
            }
        }
        droppedTileInfo = {
            targetTile: targetObjects[0].tile,
            targetTileGroup: targetObjects[0].tileGroup,
            viewModel: targetObjects.viewModel
        };
    }
};

/**
   * Get base order value from the input parameter's order number
   * <p>
   * ex: 212 -> returns 200; 399 -> returns 300
   *
   * @param {Number} orderNumber - order number
   * @returns {Number} base order number if orderNumber is defined, otherwise 0
   */
function getBaseOrder( orderNumber ) {
    if( !orderNumber ) {
        return 0;
    }
    var tensAndOnesDigits = orderNumber % 100;
    return orderNumber - tensAndOnesDigits;
}

/**
   * Add the given map of 'dragData' name/value pairs to the 'dataTransfer' property of the given DragEvent.
   *
   * @param {DragEvent} event - The DragEvent to set the DragData on.
   * @param {Object} dragDataMap - Map of name/value pairs to add.
   */
function addDragDataToDragEvent( event, dragDataMap ) {
    if( event.dataTransfer && dragDataMap ) {
        event.dataTransfer.setData( 'text', JSON.stringify( {
            sourceTile: dragDataMap.sourceTile,
            sourceGroupName: dragDataMap.sourceTileGroup.groupName
        } ) );
    }
    draggedTileInfo = dragDataMap;
}

/**
   * Update the drag image for the DragEvent based on draggable element.
   *
   * @param {DragEvent} event - The DragEvent to set the image on.
   * @param {DOMElement} draggableElem - element being dragged.
   */
function updateDragImage( event, draggableElem ) {
    /**
       * Internet Explorer doesn't support setDragImage at all.
       * <P>
       * See: http://mereskin.github.io/dnd/
       */
    if( !browserUtils.isIE && event.dataTransfer ) {
        /**
           * The NX web browser (QT?) currently has a problem with child elements containing float elements. This
           * should be resolved after moving the list view to a flex display.
           */
        event.dataTransfer.setDragImage( draggableElem, 0, 0 );
    }
}

/**
   * Processes drag start event
   *
   * @param {DragEvent} event - The event to extract the 'source' element from.
   * @param {Element} element - The DOM element considered the 'source' of the given drag event.
   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.
   */
function processDragStart( event, element, targetObjects, callBackAPIs = {} ) {
    let srcElement = event.target;
    let sourceTile = targetObjects[0].tile;
    let sourceTileGroup = targetObjects[0].tileGroup;
    let tileContElem = srcElement.parentElement.parentElement;

    if( sourceTile ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'processDragStart - Source Tile name: ' + sourceTile.displayName +
                 ' && Source Tile Group name: ' + sourceTileGroup.groupName );
        }

        element.data( 'dragging', true );
        var containerId = element.data( 'containerId' );

        if( !containerId ) {
            containerId = Date.now();
            element.data( 'containerId', containerId );
        }
        let width = 0;
        for( let index = 0; index < 3; index++ ) {
            if ( index < sourceTileGroup.tiles.length ) {
                width += sourceTileGroup.tiles[index].tileSize + 1;
            } else {
                break;
            }
        }

        // // Default width for the single width tile
        let parentTileMinWidth = 155 * width + 'px';
        tileContElem.parentElement.style.minWidth = parentTileMinWidth;
        tileContElem.setAttribute( 'id', 'draggedTile' );
        tileContElem.classList.add( DRAGTILE_CSS_CLASS );

        if( event.dataTransfer ) {
            event.dataTransfer.effectAllowed = 'move'; // only allow moves
        }

        updateDragImage( event, tileContElem );
        addDragDataToDragEvent( event, {
            sourceTile: sourceTile,
            sourceTileGroup: sourceTileGroup
        } );

        placeHolderTile = _createPlaceHolderTile( srcElement );
    } else {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'processDragStart - no tile Info, Set element data "dragging" to false' );
        }

        // No data so there is no reason to let the object be dragged.
        element.data( 'dragging', false );
        event.preventDefault();
    }
}

/**
   * Processes drag over event
   *
   * @param {DragEvent} event - The event to extract the 'source' element from.
   */
function processDragOver( event ) {
    if( event.dataTransfer ) {
        event.dataTransfer.effectAllowed = 'move'; // only allow moves
    }
}

/**
   * Processes drag enter event
   *
   * @param {DragEvent} event - The event to extract the 'target' element from.
   * @param {Element} targetElement - The DOM element considered the 'target' of the given drag event.
   */
function processDragEnter( event, targetElement, targetObjects ) {
    if( _isValidToDrop( event ) ) {
        let targetData = targetObjects[0].tile;
        let targetTileGroup = targetObjects[0].tileGroup;
        if( targetData ) {
            if( _debug_logEventActivity >= 2 ) {
                if( targetData.tiles ) {
                    postLog( 'processDragEnter - Target tileGroup: ' + targetData.groupName );
                } else if( targetTileGroup && targetData.displayName ) {
                    postLog( 'processDragEnter - Target tile: ' + targetData.displayName +
                          ' && Target Item tileGroup: ' + targetTileGroup.groupName );
                } else if( targetTileGroup && !targetData.displayName ) {
                    postLog( 'processDragEnter - Target Item tileGroup: ' + targetTileGroup.groupName );
                }
            }

            if( !targetData.tiles && ( !targetTileGroup || !targetTileGroup.groupName ) ) {
                return;
            }

            if( event.dataTransfer ) {
                event.dataTransfer.effectAllowed = 'move'; // only allow moves
            }

            let debounceProcessDragEnter = _.debounce( _processDragEnterInternal, 100 );
            debounceProcessDragEnter( event, targetElement, targetObjects );
        }
    }
}

/**
   * Processes drag leave event
   *
   * @param {DragEvent} event - The event to extract the 'target' element from.
   */
function processDragLeave( event ) {
    event.preventDefault();

    if( event.dataTransfer ) {
        event.dataTransfer.effectAllowed = 'move'; // only allow moves
    }
}

/**
   * Processes drag end event
   *
   * @param {DragEvent} event - The event to extract the 'target' element from.
   * @param {Element} element - The DOM element considered the 'target' of the given drag event.
   */
function processDragEnd( event, element, targetObjects ) {
    event.preventDefault();

    if( _debug_logEventActivity >= 1 ) {
        postLog( 'processDragEnd - Processing drag end' );
    }

    let evtElement = event.target.parentElement.parentElement;
    $( evtElement ).removeClass( DRAGTILE_CSS_CLASS );
    $( evtElement ).removeAttr( 'id' );

    let tileContElem = event.target;
}

/**
   * @param {DragEvent} event - The drag event with the 'target' to process.
   * @param {Object} callBackAPIs - Callback functions used for various interaction reasons.
   * @param {Element} element - The DOM element considered the 'target' of the given drag event.
   * @param {Object}  targetObjects
   */
function processDrop( event, callBackAPIs, element, targetObjects, props ) {
    const propertyToUpdate = props;
    event.stopPropagation();
    event.preventDefault();
    if( _debug_logEventActivity >= 1 ) {
        postLog( 'processDrop - Processing drop' );
    }

    let dragTile = document.querySelector( '#draggedTile' );
    var isNewGroup = false;
    dragTile.classList.remove( DRAGTILE_CSS_CLASS );
    dragTile.parentElement.style.minWidth = '';
    let tileContElem = dragTile.firstElementChild.firstElementChild;

    if( $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).length > 0 ) {
        var prevSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).prevAll();
        var nextSiblings = $( '.' + PLACEHOLDER_TILE_CSS_CLASS + '.' + TILEMAIN_CSS_CLASS ).nextAll();
        var index = 0;

        _.forEachRight( prevSiblings, function( sibling ) {
            if( sibling.id !== 'draggedTile' ) {
                sibling.style.order = index;
                index++;
            }
        } );

        if( dragTile ) {
            dragTile.style.order = index;
            index++;
            if( _debug_logEventActivity >= 1 ) {
                postLog( 'processDrop - Set new order style for dragged tile' );
            }
        }

        _.forEach( nextSiblings, function( sibling ) {
            if( sibling.id !== 'draggedTile' ) {
                sibling.style.order = index;
                index++;
            }
        } );
    } else if( $( '.' + TILEGROUP_CSS_CLASS + '.' + PLACEHOLDER_GROUP_CSS_CLASS ).length > 0 ) {
        isNewGroup = true;
    }

    let targetElement = _findDropTargetElement( event, isNewGroup );
    if( !targetElement.element ) {
        _cleanUp( dragTile );
        return;
    }

    let draggingData = event.dataTransfer.getData( 'text' );

    if( _debug_logEventActivity >= 1 ) {
        postLog( 'processDrop - Retrieving drag data' );
    }

    if( draggingData ) {
        var dragDataTile = JSON.parse( draggingData );
        var targetTile = droppedTileInfo.targetTile;
        let targetTileGroup = droppedTileInfo.targetTileGroup;
        let canvasViewModel = droppedTileInfo.viewModel;
        if( !isNewGroup && updateOrder && targetTile !== dragDataTile.sourceTile ) {
            updateOrder( canvasViewModel, dragDataTile.sourceTile, dragDataTile.sourceGroupName, targetTile, targetTileGroup, targetElement.inPlace, propertyToUpdate );
        } else if( isNewGroup && createNewGroup ) {
            var tileGroupElemData = targetObjects[0].tile;
            var tileGroupData;

            if( tileGroupElemData ) {
                tileGroupData = tileGroupElemData.tileGroup;
            }
            createNewGroup( dragDataTile.sourceTile, dragDataTile.sourceGroupName, tileGroupData, propertyToUpdate );
        }

        if( _debug_logEventActivity >= 1 ) {
            postLog( 'processDrop - Dropping data: ' + draggingData );
        }
    }

    _cleanUp( dragTile );
}

export const dragStartFn = ( { event, targetObjects, declViewModel } ) => {
    let targetObjectsDragStart;
    event.stopPropagation();
    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );
    var jqElement = $( panelElement );
    if( event.target.nodeName === '#text' ) {
        jqElement.data( 'dragging', false );
        event.preventDefault();
    } else {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'dragstart: ' + event );
        }
        targetObjectsDragStart = assignViewModelToObject( targetObjects, declViewModel );
        processDragStart( event, jqElement, targetObjectsDragStart, {} );
    }
};

export const dragEndFn = ( { event, targetObjects, declViewModel } ) => {
    let targetObjectsDragEnd;
    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );
    var jqElement = $( panelElement );
    event.stopPropagation();
    if( event ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'dragend: ' + event );
        }

        jqElement.data( 'dragging', false );

        var target = _findDropTargetElement( event );
        if( !target ) {
            return;
        }
        targetObjectsDragEnd = assignViewModelToObject( targetObjects, declViewModel );
        processDragEnd( event, jqElement, targetObjectsDragEnd );
    }
};

export const dragOverFn = ( { event, targetObjects, declViewModel } ) => {
    event.stopPropagation();
    event.preventDefault();
    if( event ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'dragover: ' + event );
        }

        if( _isValidToDrop( event ) ) {
            if( event.dataTransfer && !browserUtils.isQt ) {
                event.dataTransfer.dropEffect = 'move'; // only allow moves
            }

            event.stopPropagation();
            event.preventDefault();
            var debounceProcessDragOver = _.debounce( processDragOver, 100 );
            debounceProcessDragOver( event );
        }
    }
};

export const dragEnterFn = ( { event, targetObjects, declViewModel } ) => {
    let targetObjectsDragEnter;
    event.stopPropagation();
    if( event ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'dragenter: ' + event );
        }

        var target = _findDragEnterElement( event );
        if( !target ) {
            return;
        }
        targetObjectsDragEnter = assignViewModelToObject( targetObjects, declViewModel );
        targetObjects.viewModel = declViewModel;
        processDragEnter( event, target, targetObjectsDragEnter );
    }
};

export const createNewGroup = function( viewModel, sourceTile, sourceGroupName, targetTileGroup ) {
    var sourceGroup = self.getTileGroup( sourceGroupName );
    var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );
    var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetTileGroup );

    var sourceTileIn = retrieveTileInTileGroup( sourceTile, sourceGroupIndx );
    var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );

    var baseOrder = 0;
    var newGroupIncrement = 100;
    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {
        baseOrder = getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );
    }

    // remove tile from source group
    var srcGroup = viewModel.tileGroups[ sourceGroupIndx ];
    srcGroup.tiles.splice( sourceTileIndx, 1 );

    var srcGroupNull = false;
    // If we removed the last tile in the group
    if( srcGroup.tiles.length === 0 ) {
        srcGroupNull = true;
    }

    // create new group using current time
    var newGroup = {};
    newGroup.groupName = 'group' + new Date().getTime();

    // add sourceTile to newly created group
    newGroup.tiles = [];
    newGroup.tiles.push( sourceTileIn );

    newGroup.tiles.forEach( function( tile, indx ) {
        tile.orderNumber = baseOrder + newGroupIncrement + indx;
        tile.isDirty = true;
    } );

    // update tileGroups array
    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {
        viewModel.tileGroups.splice( targetGroupIndx, 0, newGroup );
    } else {
        viewModel.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );
    }

    var newGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, newGroup );

    // update order number for all tiles in each and every tile group
    _.forEach( viewModel.tileGroups, function( tileGroup, index ) {
        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {
            var grpBaseOrder = getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );
            tileGroup.tiles.map( function( tile, indx ) {
                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;
                tile.isDirty = true;
                return tile;
            } );
        }
    } );
};

export const updateOrder = function( viewModel, sourceTile, sourceGroupName, targetTile, targetTileGroup, inPlace, propertyToUpdate ) {
    if( targetTile ) {
        var targetTileOrder = targetTile.orderNumber;

        var targetGroup = getTileGroup( viewModel, targetTileGroup.groupName );
        var sourceGroup = getTileGroup( viewModel, sourceGroupName );
        var sourceGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, sourceGroup );
        var targetGroupIndx = retrieveTileGroupIndex( viewModel.tileGroups, targetGroup );

        var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );

        var sourceTileIndx = viewModel.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );
        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );
        var targetBaseOrder = getBaseOrder( targetTileOrder );

        if( sourceGroupIndx === targetGroupIndx ) { // same group rearrange
            reOrderInSameGroup( sourceTileIn, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace );
        } else { // different group rearrange
            reOrderInDifferentGroup( viewModel, sourceTileIn, sourceTileIndx, sourceGroupIndx, targetTileIndx,
                targetGroupIndx, targetBaseOrder, inPlace, propertyToUpdate );
        }
    }
};

export const getTileGroup = function( viewModel, groupName ) {
    var tileGroupIn;
    _.forEach( viewModel.tileGroups, function( tileGroup ) {
        if( tileGroup.groupName === groupName ) {
            tileGroupIn = tileGroup;
            return false;
        }
        return true;
    } );

    return tileGroupIn;
};

export const retrieveTileInTileGroup = function( viewModel, tile, groupIndex ) {
    var retrievedTile;

    if( viewModel.tileGroups[ groupIndex ] && !_.isEmpty( viewModel.tileGroups[ groupIndex ].tiles ) ) {
        _.forEach( viewModel.tileGroups[ groupIndex ].tiles, function( tileObj ) {
            if( _.isEqual( tileObj.displayName, tile.displayName ) ) {
                retrievedTile = tileObj;
                return false;
            }
            return true;
        } );
    }

    return retrievedTile;
};

export const reOrderInSameGroup = function( sourceTile, sourceTileIndx, targetTile, targetTileGroup, targetBaseOrder, inPlace ) {
    if( targetTileGroup ) {
        targetTileGroup.tiles.splice( sourceTileIndx, 1 );

        var targetTileIndx = targetTileGroup.tiles.indexOf( targetTile );
        if( inPlace ) {
            targetTileGroup.tiles.splice( targetTileIndx, 0, sourceTile );
        } else {
            targetTileGroup.tiles.splice( targetTileIndx + 1, 0, sourceTile );
        }

        _.forEach( targetTileGroup.tiles, function reorderTiles( tile, index ) {
            if( tile ) {
                tile.orderNumber = targetBaseOrder + index;
                tile.isDirty = true;
            }
        } );
    }
};

export const reOrderInDifferentGroup = function( viewModel, sourceTile, sourceTileIndex, sourceGroupIndex, targetTileIndex,
    targetGroupIndex, targetBaseOrder, inPlace, propertyToUpdate ) {
    const { dispatch } = viewModel;
    const propertyName = propertyToUpdate;
    let updatedTileGroups = { ...viewModel.getData() }.tileGroups;
    var sourceBaseOrder = getBaseOrder( sourceTile.orderNumber );
    var srcGroup = updatedTileGroups[ sourceGroupIndex ];
    var targetGroupDifferent = updatedTileGroups[ targetGroupIndex ];
    // remove tile from source group
    srcGroup.tiles.splice( sourceTileIndex, 1 );
    // add tile to target group
    if( inPlace ) {
        targetGroupDifferent.tiles.splice( targetTileIndex, 0, sourceTile );
    } else {
        targetGroupDifferent.tiles.splice( targetTileIndex + 1, 0, sourceTile );
    }

    // modify order in source group
    srcGroup.tiles.map( function( tile, idx ) {
        tile.orderNumber = sourceBaseOrder + idx;
        tile.isDirty = true;
        return tile;
    } );
    updatedTileGroups[ sourceGroupIndex ] = srcGroup;
    // modify order in target group
    targetGroupDifferent.tiles.map( function( tile, idx ) {
        tile.orderNumber = targetBaseOrder + idx;
        tile.isDirty = true;
        return tile;
    } );
    updatedTileGroups[ targetGroupIndex ] = targetGroupDifferent;
    let propertyPath = propertyName ? 'data.' + propertyName : 'data.tileGroups';
    dispatch( { path: propertyPath, value: [ ...updatedTileGroups ] } );
};

export const dragLeaveFn = ( { event, targetObjects, declViewModel } ) => {
    event.stopPropagation();
    if( event ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'dragleave: ' + event );
        }
        var debounceProcessDragLeave = _.debounce( processDragLeave, 100 );
        debounceProcessDragLeave( event );
    }
};

export const dropFn = ( props, {  event, targetObjects, declViewModel } ) => {
    let targetObjectsDrop;
    let panelElement = document.children[0].querySelector( '.aw-tile-tileCanvasPanel.aw-layout-flexColumn ' );
    var jqElement = $( panelElement );
    event.stopPropagation();
    if( event ) {
        if( _debug_logEventActivity >= 2 ) {
            postLog( 'drop: ' + event );
        }

        jqElement.data( 'dragging', false );
        targetObjectsDrop = assignViewModelToObject( targetObjects, declViewModel );
        processDrop( event, {}, jqElement, targetObjectsDrop, props );
    }
};

export const postLog = ( message ) => {
    logger.info( message );
};

const retrieveTileGroupIndex = ( tileGroups, group ) => {
    if( tileGroups ) {
        return tileGroups.indexOf( group );
    }
    return -1;
};

const assignViewModelToObject = ( targetObjects, declViewModel ) => {
    let targetObjectsUpdated = { ...targetObjects };
    targetObjectsUpdated.viewModel = declViewModel;
    return targetObjectsUpdated;
};

export default {
    getBaseOrder,
    addDragDataToDragEvent,
    updateDragImage,
    processDragStart,
    processDragOver,
    processDragEnter,
    processDragLeave,
    processDragEnd,
    processDrop,
    dragStartFn,
    dragEndFn,
    dragOverFn,
    dragEnterFn,
    dragLeaveFn,
    dropFn,
    updateOrder,
    createNewGroup,
    reOrderInSameGroup,
    reOrderInDifferentGroup,
    retrieveTileInTileGroup,
    getTileGroup,
    postLog
};

