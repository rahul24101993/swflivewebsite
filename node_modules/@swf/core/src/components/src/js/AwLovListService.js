// Copyright (c) 2021 Siemens
/* eslint-disable complexity */
/* eslint-disable @swf/swf/no-react-usage */
import React from 'react';
import _ from 'lodash';

/**
 * render function for AwList
 * @param {*} props context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awLovListRenderFunction = ( props ) => {
    const { i18n, viewModel, actions, blankLovEntry, checkLovEntries, context, ...prop } = props;
    const { children, field, setlovEntry, lovPopup, staticFilterStr, isCheckBoxArryLOV, dataProvider } = prop;
    const { data, dispatch } = viewModel;
    let vmCollectionObj = [];
    let scrollElement;
    let lovEntries = [];
    let preferredChoices = [];
    let { selectedEntries = [], dirty } = data;
    let restEntries = [];
    let hasPreferredChoices = false;

    const renderChildWithItem = ( lovEntry ) => {
        return React.Children.map( children, child => {
            let key = lovEntry.propInternalValue !== '' ? lovEntry.propInternalValue : '_blank_';
            return React.cloneElement( child, { field, lovEntry, dataProvider, setLovEntry: setlovEntry, key, prop } );
        } );
    };

    if( dataProvider ) {
        scrollElement = dataProvider.getRootReference();
        let paginationOption = dataProvider.getPagination();
        if( !paginationOption ) {
            dataProvider.setPagination( {
                root: scrollElement,
                rootMargin: '5px',
                threshold: 1,
                bottomAnchorSelector: '.page-bottom'
            } );
        }
        vmCollectionObj = dataProvider.vmCollectionObj;
    }

    // there are applications using object as propInternalValue,
    // in this case, comparator expected to use propDisplayValue as key
    let propInternalValueInObject = false;

    if( vmCollectionObj && vmCollectionObj.dataLoaded && vmCollectionObj.vmCollection && vmCollectionObj.vmCollection.loadedVMObjects.length > 0 ) {
        lovEntries = [ ...vmCollectionObj.vmCollection.loadedVMObjects ];

        // check for any preferred values
        if( vmCollectionObj.preferredChoices && vmCollectionObj.preferredChoices.length > 0 ) {
            preferredChoices = [ ...vmCollectionObj.preferredChoices ];
            hasPreferredChoices = true;
        }

        propInternalValueInObject = Boolean( _.find( lovEntries, ( item ) => _.isObject( item.propInternalValue ) ) );
    }

    const comparator = ( item1, item2 ) => {
        let key = propInternalValueInObject ? 'propDisplayValue' : 'propInternalValue';
        return item1[ key ] === item2[ key ];
    };

    // As per the previous code...we are assuming if dataprovider does not have action
    // It means it is static and client-side filtering can be done.
    // apply filter if not null
    if( staticFilterStr && _.isString( staticFilterStr ) &&
        ( context.isListbox || !( dataProvider.action || dataProvider.initializeAction ) )
    ) {
        // alway keep the empty entry if has
        lovEntries = applyFilter( lovEntries, staticFilterStr, true );
    }

    // syncLovEntries
    prop.updateValidEntries( lovEntries );

    if( hasPreferredChoices ) {
        // MRU can always be filtered client-side
        preferredChoices = applyFilter( preferredChoices, staticFilterStr );

        // denote last preferred choice for styling purposes
        if( preferredChoices.length ) {
            preferredChoices[ preferredChoices.length - 1 ].lastMru = true;
        }
    }

    if( lovEntries.length > 0 ) {
        if ( !isCheckBoxArryLOV ) {
            // prepend preferredChoices to top of list
            lovEntries = preferredChoices.concat( lovEntries );

            // syncLovEntries
            prop.updateValidEntries( lovEntries );

            // honor emptyLOVEntry
            if( field.fielddata.emptyLOVEntry !== false ) {
                lovEntries.splice( 0, 0, blankLovEntry );
            }

            // initialize attention
            if( prop.selectIndex.current === null ) {
                prop.selectIndex.current = prop.getDefaultAttention();
            }

            // set attention
            let inx = prop.selectIndex.current;
            _.forEach( lovEntries, ( item, jnx ) => {
                item.attn = inx === jnx;
            } );
        } else {
            // isCheckBoxArryLOV
            // need to filter the checked lov at the top
            // apply filter if has selectedEntries and has filter
            // selectedEntries may have placeHolders, we should replace then with valid (if matched) lovEntries
            let selectedEntries_fixed = [];
            if( staticFilterStr || dirty ) {
                // replace the selectedEntries with latest if dirty
                selectedEntries = getLatestCheckLovEntries( checkLovEntries.current );

                // remember the list had been filtered, and we should pull latest CheckLovEntries each time
                if( !dirty ) { dispatch( { path: 'data.dirty', value: true } ); }
            }

            if( selectedEntries ) {
                // replace with valid (if matched) lovEntries
                for( let index = 0; index < selectedEntries.length; index++ ) {
                    const item = selectedEntries[ index ];
                    let entry = _.find( lovEntries, ( i ) => comparator( i, item ) );

                    // only pick the valid ones:
                    // 1, case all data loaded, we only pick the ones already in lovEntries, entry maybe valid or null
                    // 2, case data partial loaded, we need to keep the placeholders, ensure entry always valid
                    if( vmCollectionObj.hasMoreValuesExist && !entry ) {
                        entry = item;
                    }

                    if( entry ) {
                        selectedEntries_fixed.push( { ...entry, isChecked: true } );
                    }
                }
                selectedEntries = selectedEntries_fixed;

                // apply filter
                staticFilterStr && ( selectedEntries = applyFilter( selectedEntries_fixed, staticFilterStr ) );

                // cbLov is a bit complex...
                // selected values float to top and DON'T duplicate values in list below
                // preferredChoices can be duplicates though
                // rm any selected entries from preferred choices array
                preferredChoices = _.differenceWith( preferredChoices, selectedEntries, ( item1, item2 ) => comparator( item1, item2 ) );

                // reset lastMru
                preferredChoices.forEach( function( choice ) {
                    choice.lastMru = false;
                } );

                // set lastMru state on last in list
                if( preferredChoices.length ) {
                    preferredChoices[ preferredChoices.length - 1 ].lastMru = true;
                }
            }

            // filter out selected entries and preferred choices to avoid duplicates
            restEntries = _.differenceWith( lovEntries, selectedEntries.concat( preferredChoices ), ( item1, item2 ) => comparator( item1, item2 ) );

            // prepend preferred choices to top
            restEntries = preferredChoices.concat( restEntries );

            // syncLovEntries
            prop.updateValidEntries( selectedEntries.concat( restEntries ) );
        }
    }

    const hasValidEntries = () => {
        return lovEntries && lovEntries.length > 0;
    };

    const transform = ( item ) => renderChildWithItem( item );
    const renderContents = () => {
        let result = [];

        if( isCheckBoxArryLOV ) {
            // selectedEntries
            if( selectedEntries && selectedEntries.length > 0 ) {
                let part1 = <div className='afx-selected-vals'>
                    { selectedEntries.map( transform ) }
                </div>;
                result.push( part1 );
            }
            // others
            if( restEntries && restEntries.length > 0 ) {
                let part2 = restEntries.map( transform );
                result.push( part2 );
            }
        } else {
            if( hasValidEntries() ) {
                result.push( lovEntries.map( transform ) );
            }
        }
        return result;
    };

    const NO_LOV_VALUES = i18n.NO_LOV_VALUES;

    return (
        <div className='aw-base-scrollPanel' ref={scrollElement}>
            <ul role='listbox' aria-label={field.name} className='sw-column flex-shrink' >
                {
                    renderContents()
                }
                {
                    !hasValidEntries() && !vmCollectionObj.fetching && <li className='aw-jswidgets-lov-novals' title={NO_LOV_VALUES}>{NO_LOV_VALUES}</li>
                }
                {
                    vmCollectionObj.fetching && <li className='aw-jswidgets-loadingItem'>
                        <div className='aw-jswidgets-loading'>&nbsp;</div>
                    </li>
                }
            </ul>
            <div className='page-bottom'></div>
        </div>
    );
};

export const onMount = ( prop ) => {
    prop.selectIndex.current = null;

    const { isCheckBoxArryLOV, checkLovEntries } = prop;
    if( isCheckBoxArryLOV && checkLovEntries.current ) {
        return getLatestCheckLovEntries( checkLovEntries.current );
    }
};

const getLatestCheckLovEntries = ( checkLovEntries ) => {
    return _.reduce( checkLovEntries, ( result, value, key ) => {
        result.push( value );
        return result;
    }, [] );
};

const applyFilter = ( collection, filterString, keepNull = false ) => {
    if( !filterString ) { return collection; }
    return collection.filter( ( item ) => {
        return keepNull && !item.propDisplayValue ||
            // only filter it when it's a string
            _.isString( item.propInternalValue ) && item.propInternalValue.toLowerCase().indexOf( filterString.toLowerCase() ) !== -1 ||
            item.propDisplayValue.toLowerCase().indexOf( filterString.toLowerCase() ) !== -1;
    } );
};
