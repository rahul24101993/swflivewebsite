// Copyright (c) 2020 Siemens

/**
 * @module js/AwSidenavHelperService
 */
import $ from 'jquery';
import appCtx from 'js/appCtxService';

import localStorage from 'js/localStorage';
import commandHandlerSvc from 'js/commandHandlerService';
import browserUtils from 'js/browserUtils';
import AwPromiseService from 'js/awPromiseService';

let exports = {};

var localStorageTopicId = 'wysiwygChannel';
// Scope being used by the "background" command for the current panel
var commandScope = {};
var command = {};

//Register activeToolsAndInfoCommand and activeNavigationCommand for backward compatibility
//to support existing consumers in AW
// Save the two location contexts here
var currentLocationCtx = null;
var otherLocationCtx = null;

export let setLocationCtx = ( id ) => {
    if( id === 'aw_navigation' ) {
        currentLocationCtx = 'activeNavigationCommand';
    } else if( id === 'aw_toolsAndInfo' ) {
        currentLocationCtx = 'activeToolsAndInfoCommand';
    }
    if( id === 'aw_navigation' ) {
        otherLocationCtx = 'activeToolsAndInfoCommand';
    } else if( id === 'aw_toolsAndInfo' ) {
        otherLocationCtx = 'activeNavigationCommand';
    }
};

var handleCommand = function( vmProps, eventData ) {
    if( eventData.command ) {
        // If a panel in the other area is open, remove it's ctx value
        if( otherLocationCtx ) {
            if( appCtx.getCtx( otherLocationCtx ) ) {
                appCtx.unRegisterCtx( otherLocationCtx );
            }
        }

        if( currentLocationCtx ) {
            //Register current location ctx
            appCtx.registerCtx( currentLocationCtx, eventData.command );
        }

        //revisitMe: Jignesh: Let's keep this code commented for now.
        //Will reevaluate if this is required after the new commands architecture
        // if( eventData.command.closeWhenCommandHidden ) {
        //     // Start evaluating the currently opened command in the background
        //     // When the command is hidden or disabled the panel will close even if command is not active anywhere else on page
        //     commandScope[ vmProps.id ] = {};
        //     commandScope[ vmProps.id ].ctx = undefined;

        //     // Note: Command context cannot be handled generically as putting it somewhere this directive can reach it will result in a memory leak
        //     // Any command that opens a panel and needs command context must set "closeWhenCommandHidden" to true in command panel service action
        //     // and update their panel to know when to close
        //     commandScope[ vmProps.id ].commandContext = null;
        //     commandService.getCommand( eventData.commandId, commandScope[ vmProps.id ] );
        // }

        //Set the panel context
        commandHandlerSvc.setupDeclarativeView( eventData.command ).then( function() {
            command[ vmProps.id ] = eventData.command;
        } );
    }
};

/**
 * Close the currently opened command panel.
 *
 * @return {Promise} Promise resolved when panel has been closed
 */
var removeCommandScope = ( vmProps ) => {
    if( command[ vmProps.id ] ) {
        return commandHandlerSvc.getPanelLifeCycleClose( command[ vmProps.id ] ).then( () => {
            if( commandScope[ vmProps.id ] ) {
                commandScope[ vmProps.id ] = null;
            }
            command[ vmProps.id ] = null;
        } );
    }
    return AwPromiseService.instance.resolve();
};

var toggleParentClass = function( isAdd, vmProps ) {
    //The left-side-nav-pushed class is required in sidenav to remove the white dot on the left corner of sidenav
    //When this class is present, we remove the border-radius on top left corner of sidenav
    if( vmProps.isLeftToRight && vmProps.slide === 'PUSH' ) {
        if( isAdd ) {
            $( '.aw-layout-mainView' ).addClass( 'left-sidenav-pushed' );
        } else {
            $( '.aw-layout-mainView' ).removeClass( 'left-sidenav-pushed' );
        }
    }
};

var setSlideForPinnablePanel = function( sidenavOpened, vmProps ) {
    if( sidenavOpened ) {
        //Only required for primary navigation panel that can be pinned
        vmProps.slide = vmProps.pinned ? 'PUSH' : 'FLOAT';
        if( vmProps.pinned ) {
            $( '.aw-layout-mainView' ).addClass( 'aw-global-navigationPanelPinned' );
        }

        //revisitMe: Jignesh - test Safari
        if( browserUtils.isSafari ) {
            reCalculateCss();
        }
    } else {
        //Need to make the slide revert to its initial state
        vmProps.slide = 'FLOAT';
        if( vmProps.pinned ) {
            $( '.aw-layout-mainView' ).removeClass( 'aw-global-navigationPanelPinned' );
        }
    }
};

// Need this specifically for Safari browser. As safari does not repaint css properly.
var reCalculateCss = function() {
    var sidenavContainer = $( '.aw-sidenav-layoutContainer' );
    sidenavContainer.css( 'display', 'none' );
    sidenavContainer.outerHeight();
    sidenavContainer.css( 'display', 'flex' );
};

let doesSideNavRemainOpen = function( eventData, vmProps ) {
    return vmProps.currentCommandId !== eventData.commandId ? true : !vmProps.sidenavOpened;
};

/**
 * @param {*} status
 * @param {*} vmProps
 * do not update the prop.sidenavOpened by your own some where else in the code.
 * Use proper API's to update state of a component.
 */
export let updateSideNavStatus = ( status, vmProps ) => {
    vmProps.sidenavOpened = status;
};

/**
 * @param {*} slide
 * @param {*} vmProps
 */
export let updateSideNavSlide = ( slide, vmProps ) => {
    vmProps.slide = slide;
};

/**
 *
 * @param {*} viewName
 * @param {*} vmProps
 * do not update the prop.view by your own some where else in the code.
 * Use proper API's to update state of a component.
 *
 * if prop.sidenavOpened is evaluated to true, then only we can update the viewname.
 * if it is evaluated to false then sideNav is being closed, hence view can become null.
 */
export let updateView = ( viewName, vmProps ) => {
    vmProps.view = vmProps.sidenavOpened ? viewName : null;
};

/**
 *
 * @param {*} viewName
 * @param {*} vmProps
 * do not update the prop.view by your own some where else in the code.
 * Use proper API's to update state of a component.
 *
 * if prop.sidenavOpened is evaluated to true, then only we can update the viewname.
 * if it is evaluated to false then sideNav is being closed, hence view can become null.
 */
export let updatePinUnpinEnabled = ( vmProps, eventData ) => {
    vmProps.isPinUnpinEnabled = eventData && eventData.config ? eventData.config.isPinUnpinEnabled : false;
    vmProps.panelPinned = eventData && eventData.config ? eventData.config.panelPinned : false;
};

/**
 *
 * @param {*} commandId
 * @param {*} vmProps
 */
let updateCommandId = ( commandId, vmProps ) => {
    vmProps.currentCommandId = commandId;
};

let toggleSidenav = function( shallRemainOpen, vmProps, eventData ) {
    if( vmProps.isPinnable ) {
        setSlideForPinnablePanel( shallRemainOpen, vmProps );
    }

    if( eventData.commandId ) {
        if( shallRemainOpen ) {
            appCtx.registerCtx( 'sidenavCommandId', eventData.commandId );
            // revisitme - hack for 20200919 demo
            // appCtx.ctx.sidenavCommandId = eventData.commandId;
        } else {
            appCtx.unRegisterCtx( 'sidenavCommandId' );
            // revisitme - hack for 20200919 demo
            // appCtx.ctx.sidenavCommandId = undefined;
        }
    }

    toggleParentClass( shallRemainOpen, vmProps );
};

var updateGlobalSidenavContext = function( vmProps ) {
    appCtx.updatePartialCtx( 'awSidenavConfig.globalSidenavContext.' + vmProps.id, {
        open: vmProps.sidenavOpened,
        pinned: vmProps.pinned,
        slide: vmProps.slide
    } );

    // revisitme - hack for 20200919 demo
    // appCtx.ctx[ 'awSidenavConfig.globalSidenavContext.' + vmProps.id ] = {
    //     open: vmProps.sidenavOpened,
    //     pinned: vmProps.pinned,
    //     slide: vmProps.slide
    // };
};

export let closeSidenav = ( vmProps, eventData ) => {
    return removeCommandScope( vmProps ).then( () => {
        if( !( vmProps.isPinnable && vmProps.pinned ) ) {
            updateSideNavStatus( false, vmProps );
            updateView( null, vmProps );
        }
        if( !eventData.commandId ) {
            if( appCtx.getCtx( 'sidenavCommandId' ) ) {
                appCtx.unRegisterCtx( 'sidenavCommandId' );
                // revisitme - hack for 20200919 demo
                // appCtx.ctx.sidenavCommandId = undefined;
            }
        }
        updateGlobalSidenavContext( vmProps );
    } );
};

export let togglePinState = function( prop ) {
    prop.pinned = !prop.pinned;
    $( '.aw-layout-mainView' ).toggleClass( 'aw-global-navigationPanelPinned' );
    prop.slide = prop.pinned ? 'PUSH' : 'FLOAT';
    // This is specific to Safari browser. As safari browser does not repaint css properly.
    // Here is stack overflow link which I referred - https://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
    if( browserUtils.isSafari ) {
        reCalculateCss();
    }
    updateGlobalSidenavContext( prop );
};

export let togglePinUnpinPanelState = function( prop ) {
    prop.panelPinned = !prop.panelPinned;
};

export let createSidenav = ( config, eventData ) => {
    let vmProps = { ...config };
    let shallRemainOpen = doesSideNavRemainOpen( eventData, vmProps );
    return removeCommandScope( vmProps ).then( () => {
        toggleSidenav( shallRemainOpen, vmProps, eventData );
        if( eventData.commandId ) {
            if( shallRemainOpen ) {
                handleCommand( vmProps, eventData );
                // Export env for wysiwyg
                if( localStorage.get( localStorageTopicId ) ) {
                    localStorage.removeItem( localStorageTopicId );
                }
                localStorage.publish( localStorageTopicId, eventData.commandId );
            } else {
                if( currentLocationCtx ) {
                    appCtx.unRegisterCtx( currentLocationCtx );
                }
            }
        }
        updateSideNavStatus( shallRemainOpen, vmProps );
        updateView( eventData.includeView, vmProps );
        updatePinUnpinEnabled( vmProps, eventData );
        updateGlobalSidenavContext( vmProps );
        updateCommandId( eventData.commandId, vmProps );

        if( eventData.config && eventData.config.slide ) {
            updateSideNavSlide( eventData.config.slide, vmProps );
        }

        return vmProps;
    } );
};

exports = {
    setLocationCtx,
    createSidenav,
    closeSidenav,
    togglePinState,
    togglePinUnpinPanelState
};
export default exports;
