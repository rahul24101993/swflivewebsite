import _ from 'lodash';
import { registerTabSet, unregisterTabSet } from 'js/tabRegistry.service';
import tabOverflowSvc from 'js/tabOverflowService';
import resizeObserverSvc from 'js/resizeObserver.service';
import declUtils from 'js/declUtils';
import AwTab from 'viewmodel/AwTabViewModel';
import AwButton from 'viewmodel/AwButtonViewModel';
import AwTabSetOverflow from 'viewmodel/AwTabSetOverflowViewModel';
import AwPopup from 'viewmodel/AwPopupViewModel';
import AwStateService from 'js/awStateService';
import * as cas from 'js/centralAggregationService';
import localeService from 'js/localeService';
import analyticsSvc from 'js/analyticsService';
import wcagSvc from 'js/wcagService';

let tabObserver = null;
let currentSelectedTabName;
let moreText = '';
let lessText = '';

const initializeObserver = ( data, dispatch, tabsetRef ) => {
    if( resizeObserverSvc.supportsResizeObserver() ) {
        const callback = _.debounce( () => {
            data.overflowConfig.hideMore = !tabOverflowSvc.hasOverflowForTabs( tabsetRef, 'HORIZONTAL' );
            tabOverflowSvc.updateTabIndexOnOverflow( tabsetRef, 'HORIZONTAL' );
            dispatch( { path: 'data', value: { ...data } } );
        }, 200, {
            maxWait: 10000,
            trailing: true,
            leading: false
        } );
        if( tabsetRef !== null && tabsetRef !== undefined ) {
            tabObserver = resizeObserverSvc.observe( tabsetRef, callback );
        }
    }
};
/**
 * Listen to subPanelContext and log user gesture
 *  @param { subPanelContext } selection data from component props
 *  @param { data } viewModel data
 */
export const onSelectionDataChange = ( subPanelContext, data ) => {
    logUserGesture( subPanelContext, data );
};

/**
 * Collect subject data like parent selection
 * @param {object} subPanelContext from component's props
 * @returns {object}
 */
const getSubject = subPanelContext => {
    let subject = {};
    if( !_.isEmpty( subPanelContext ) ) {
        let pselected = subPanelContext.pselected ? subPanelContext.pselected : '';
        let selected = subPanelContext.selected ? subPanelContext.selected : '';
        subject = { pselected: pselected, selected: selected };
    }
    return subject;
};
/**
 * Collect user gesture and transmit it to Central Aggregation Service
 *  @param { subPanelContext } subPanelContext from component props
 *  @param { data} viewModel data
 */
const logUserGesture = ( subPanelContext, data ) => {
    let currentSelectedTabId = '';
    currentSelectedTabId = data.currentSelectedTabId ? data.currentSelectedTabId : data.tabsModel.findIndex( tab => tab.selectedTab );
    let widgetInfo = { currentSelectedTabId: currentSelectedTabId, tabSetId: data.tabSetId, tabsModel: data.tabsModel };
    cas.notify( {
        widgetInfo: widgetInfo,
        userGesture: 'onTabLoad',
        subject: getSubject( subPanelContext )
    } );
};

/**
 * Method to publish analytics to server
 * @param {Number} tabModelId - id of the clicked tab
 * @param {String} tabModelName - name of the clicked tab
 */
const publishAnalytics = ( tabModelId, tabModelName ) => {
    let sanEventData = {
        sanAnalyticsType: 'Tab',
        sanCommandId: tabModelId,
        sanCommandTitle: tabModelName
    };
    analyticsSvc.logCommands( sanEventData );
};

export const onMount = ( elementRefList, prop, data ) => {
    let tabsetRef = elementRefList.get( 'tabset' ).current;
    localeService.getLocalizedTextFromKey( 'BaseMessages.MORE_LINK_TEXT', true ).then( value => moreText = value );
    localeService.getLocalizedTextFromKey( 'BaseMessages.LESS_LINK_TEXT', true ).then( value => lessText = value );
    initializeObserver( data, data.dispatch, tabsetRef );
};

//onUnmount
export const unRegisterTabSet = ( tabSetId ) => {
    unregisterTabSet( tabSetId );
    if( tabObserver ) {
        tabObserver();
    }
};

const initiateTabSetOverFlow = ( overflownTabs, data, dispatch ) => {
    data.overflowConfig.overflownTabs = overflownTabs ? overflownTabs : [];
    data.overflowConfig.isClicked = true;
    data.overflowConfig.currentTabIndex = null;
    data.overflowConfig.replacedTabIndex = null;
    dispatch( { path: 'data', value: { ...data } } );
};

const updateTabsIndices = ( newSelectedTab, data, breakIndex ) => {
    let newSelNdx = newSelectedTab.tabIndex;
    let temp;
    temp = data.tabsModel[ breakIndex ];
    data.tabsModel[ breakIndex ] = newSelectedTab;
    data.tabsModel[ newSelNdx ] = temp;

    return breakIndex;
};

const isNewSelnFromOverFlowPopup = ( index, data ) => {
    if( index >= data.tabsModel.length - data.overflowConfig.overflownTabs.length ) {
        return true;
    }
    return false;
};

const setTabSelection = ( data, tabSetOverflowPopup, callback, props ) => {
    let tabToBeSelected = data.tabsModel.find( tab => tab.selectedTab );
    if( !tabToBeSelected && data.currentSelectedTabId ) {
        tabToBeSelected = data.tabsModel.find( tab => tab.pageId === data.currentSelectedTabId );
    }
    if( !tabToBeSelected || !tabToBeSelected.displayTab ) {
        data.tabsModel.some( tab => {
            if( tab.displayTab ) {
                tabToBeSelected = tab;
                return true;
            }
            return false;
        } );
    }

    if( tabToBeSelected && ( !tabToBeSelected.selectedTab || !data.manualTabSelection && tabToBeSelected.selectedTab && tabToBeSelected.autoSelectTabOnLoad ) ) {
        data.tabsModel.map( ( tabModel, index ) => {
            tabModel.selectedTab = false;
            tabModel.tabIndex = index;
        } );
        if( isNewSelnFromOverFlowPopup( tabToBeSelected.tabIndex, data ) ) {
            updateTabsIndices( tabToBeSelected, data );
            if( tabSetOverflowPopup.open ) {
                tabSetOverflowPopup.hide();
            }
        }
        tabToBeSelected.selectedTab = true;
        if( callback && tabToBeSelected.pageId !== data.currentSelectedTabId ) {
            data.currentSelectedTabId = tabToBeSelected.pageId;
            callback( tabToBeSelected.pageId, tabToBeSelected.name, data.tabsModel );
        }
    }

    // Predictive UI: Notify subscribers when user gestures changes on tab selection/load
    if( tabToBeSelected && tabToBeSelected.name !== currentSelectedTabName && data.tabsModel.length > 0 ) {
        currentSelectedTabName = tabToBeSelected.name;
        logUserGesture( props.subPanelContext, data );
    }
};

export const awTabContainerRenderFn = ( props ) => {
    const { actions, viewModel, elementRefList, tabsModel, callback, tabSetId, tabContainerModel } = props;
    let overflownTabs = [];
    let { tabSetOverflowPopup } = actions;
    const { data, dispatch } = viewModel;
    let tabsetRef = elementRefList.get( 'tabset' ).current;
    const tabsModelForContainer = tabsModel || tabContainerModel;
    /**
     * Calculate how many tabs can fit in the tab container actually using width before overflow occurs.
     *
     * @method calculateOverflow
     */
    const calculateTabSwitching = function( initialTabsModel, currentSelectedTab ) {
        var calculateBreakIndex = tabOverflowSvc.calculateBreakIndex();
        var visibleTabs = data.tabsModel;
        if( visibleTabs.length <= 1 ) {
            return;
        }
        return calculateBreakIndex( initialTabsModel, tabsetRef, currentSelectedTab );
    };

    //swicth tabs here based on local state after overflow item click
    let selectedTabModel = tabsModelForContainer.find( tab => tab.selectedTab );
    let selectedTabIndex = tabsModelForContainer.findIndex( tab => tab.selectedTab );
    //If we have a selected tab on first render, we need to check if it's in the overflow to make it visible
    let isInitialOverflowCalculation = data.overflowConfig && !data.overflowConfig.currentTabIndex && selectedTabIndex && !data.manualTabSelection;

    if( isInitialOverflowCalculation || data.overflowConfig && data.overflowConfig.currentTabIndex && selectedTabIndex !== data.overflowConfig.replacedTabIndex ||
        !data.manualTabSelection && selectedTabIndex && selectedTabModel && selectedTabIndex > 0 && selectedTabModel.autoSelectTabOnLoad ) {
        var breakTabIndex = calculateTabSwitching( tabsModelForContainer, selectedTabModel );

        if( breakTabIndex ) {
            let temp = tabsModelForContainer[ breakTabIndex ];
            tabsModelForContainer[ breakTabIndex ] = tabsModelForContainer[ selectedTabIndex ];
            tabsModelForContainer[ selectedTabIndex ] = temp;
        }
    }

    data.tabsModel = tabsModelForContainer.map( ( tab ) => {
        if( declUtils.isNil( tab.displayTab ) ) {
            tab.displayTab = true;
        }
        return tab;
    } );
    /**
     *  Highlight tab in the targeted tab set
     *  @param {String} tabName the name of tab to be highlighted
     */
    const onHighlightTab = function( targetTab ) {
        let elementToHighlight;
        if( targetTab && targetTab.displayTab ) {
            let tabContainerDomEl = tabsetRef.querySelectorAll( '.sw-tabContainer>.sw-tab' );
            let tabElements = [ ...tabContainerDomEl ];
            let targetTabElement = tabElements.find( element => element.innerText === targetTab.name );
            elementToHighlight = targetTabElement.querySelector( 'a' );
            if( elementToHighlight ) {
                wcagSvc.afxFocusElement( elementToHighlight );
            }
        } else if( !data.overflowConfig.hideMore ) {
            elementToHighlight = tabsetRef.parentNode.querySelector( '.sw-tab-overflowButton.sw-jswidget-controlArrow' );
            if( elementToHighlight ) {
                wcagSvc.afxFocusElement( elementToHighlight );
            }
        }
    };

    const onTabSelected = selectedTabModel => {
        //before change the tab update the params so we can navigate back to previous tab with old params
        const previousTabIndex = data.tabsModel.findIndex( tab => tab.selectedTab );
        data.tabsModel[ previousTabIndex ].params = AwStateService.instance.params;

        data.previousSelectedTabId = data.tabsModel.find( tab => tab.selectedTab ).pageId;
        data.tabsModel.map( ( tabModel ) => tabModel.selectedTab = false );
        data.currentSelectedTabId = selectedTabModel.pageId;
        selectedTabModel.selectedTab = true;
        data.manualTabSelection = true;
        data.overflowConfig.currentTabIndex = null;
        data.overflowConfig.replacedTabIndex = null;

        var breakIndexFromCalc = calculateTabSwitching( data.tabsModel, selectedTabModel );

        if( tabSetOverflowPopup.open && isNewSelnFromOverFlowPopup( selectedTabModel.tabIndex, data ) ) {
            let breakIndex = updateTabsIndices( selectedTabModel, data, breakIndexFromCalc );
            tabSetOverflowPopup.hide();

            data.overflowConfig.currentTabIndex = selectedTabModel.tabIndex;
            data.overflowConfig.replacedTabIndex = breakIndex;
        }
        // Clicking on the already selected tab should not re-render the same tab again. Added below condition for fixing this issue.
        if( callback && data.previousSelectedTabId !== data.currentSelectedTabId ) {
            callback( selectedTabModel.pageId, selectedTabModel.name, data.tabsModel );
        }
        publishAnalytics( selectedTabModel.pageId, selectedTabModel.name );
        //Update the overflow config object in the current view model too.
        //This is done to cater to the standalone aw-tab-container scenario
        dispatch( { path: 'data.overflowConfig', value: { ...data.overflowConfig } } );
    };

    /**
     * Recalculate how many tabs can fit in the tab container before overflow occurs.
     *
     * @method calculateOverflow
     */
    const calculateOverflow = function() {
        var overflowBreakPointCalculatorForTabs = tabOverflowSvc.overflowBreakPointCalculatorForTabs();
        var visibleTabs = data.tabsModel;
        if( visibleTabs.length <= 1 ) {
            return;
        }
        var breakIndex = overflowBreakPointCalculatorForTabs( tabsetRef, 'HORIZONTAL' );
        // has tab overflow
        if( breakIndex !== visibleTabs.length ) {
            overflownTabs = visibleTabs.slice( breakIndex );
            initiateTabSetOverFlow( overflownTabs, data, dispatch );
            tabSetOverflowPopup.show();
        }
    };

    const getButtonClassNames = () => {
        return tabSetOverflowPopup.open ? 'sw-tab-overflowButton aw-jswidget-controlArrowRotateRight' : 'sw-tab-overflowButton sw-jswidget-controlArrow';
    };

    const showMoreButton = () => {
        if( !data.overflowConfig.hideMore ) {
            return (
                <div className ='sw-tab-overflowContainer'>
                    <AwButton domRef={tabSetOverflowPopup.reference}
                        className={getButtonClassNames()}
                        tooltip={tabSetOverflowPopup.open ? lessText : moreText}
                        aria-label={tabSetOverflowPopup.open ? lessText : moreText}
                        iconId='miscSmallChevronRight'
                        action={calculateOverflow}></AwButton>
                    { tabSetOverflowPopup.open &&
                        <AwPopup {...tabSetOverflowPopup.options}>
                            <AwTabSetOverflow overflownTabs={data.overflowConfig.overflownTabs}
                                isClicked={data.overflowConfig.isClicked}
                                event={event}
                                onTabSelected={onTabSelected}>
                            </AwTabSetOverflow>
                        </AwPopup>
                    }
                </div>
            );
        }
    };

    setTabSelection( data, tabSetOverflowPopup, callback, props );

    if( tabSetId ) {
        data.tabSetId = tabSetId;
        unregisterTabSet( tabSetId );
        registerTabSet( tabSetId, {
            changeTab: onTabSelected,
            tabs: data.tabsModel,
            highlightTab: onHighlightTab
        } );
    }

    return (
        <div className='sw-row align-items-center flex-shrink' >
            <ul role='tablist' className='sw-tabContainer' ref={elementRefList.get( 'tabset' )}>
                { data.tabsModel && data.tabsModel.map( ( tabModel, index ) => {
                    if( tabModel.displayTab ) {
                        tabModel.tabIndex = index;
                        return <AwTab key={index} tabModel={tabModel} onTabSelected={onTabSelected}  onTabClose={props.onTabClose}></AwTab>;
                    }
                } )}
            </ul>
            {showMoreButton()}
        </div>
    );
};
