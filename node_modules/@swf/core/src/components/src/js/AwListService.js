// Copyright (c) 2021 Siemens
import AwPopup from 'viewmodel/AwPopupViewModel';
import { AwServerVisibilityPopupCommandBar } from 'js/AwServerVisibilityCommandBarService';
import AwListItem from 'viewmodel/AwListItemViewModel';
import dragAndDropSvc from 'js/dragAndDropService';
import _ from 'lodash';
import ariaList from 'js/ariaList';
import wcagSvc from 'js/wcagService';
import domUtils from 'js/domUtils';
import eventBus from 'js/eventBus';

const eleRef = domUtils.DOMAPIs;

export const onMount = ( data ) => {
    const listElement = data.dataprovider.getRootReference() && data.dataprovider.getRootReference().current;

    if( listElement ) {
        const list = new ariaList();
        let ul = listElement.querySelector( '[role="listbox"]' );
        if( !ul ) { return; }

        ul.setAttribute( 'aria-label', 'i18n.listAriaLabel' );
        wcagSvc.updateArialabel( ul, '', 'UIElementsMessages' );

        let childSelector = 'option';
        list.init( ul, {}, childSelector );
    }
};

export const selectionUpdated = ( props ) => {
    const {
        dataprovider,
        useVirtual
    } = props;

    let listElement = dataprovider.getRootReference();
    if( !useVirtual && listElement && listElement.current ) {
        const scrollContainer = eleRef.closest( listElement.current, '.aw-base-scrollPanel' );
        const selectedElement = eleRef.get( '.aw-widgets-cellListItemSelected', listElement.current );
        if( scrollContainer && selectedElement ) {
            const scrollEleDim = scrollContainer.getBoundingClientRect();
            const selectedEleDim = selectedElement.getBoundingClientRect();

            if( selectedEleDim.top + selectedEleDim.height > scrollEleDim.bottom || selectedEleDim.bottom - selectedEleDim.height < scrollEleDim.top ) {
                selectedElement.focus();
            }
        }
    }
};

/**
 * render function for AwList
 * @param {*} param0 context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awListRenderFunction = ( props ) => {
    const {
        actions,
        commandContext = {},
        ctx,
        ...prop
    } = props;
    const {
        dataprovider,
        children,
        showCheckbox,
        listOptions,
        itemOptions,
        showContextMenu,
        fixedCellHeight,
        isGroupList,
        // Given as "true" - cells appears on hover and selection of the item.
        // Given as "false" - cells appears always.
        hasFloatingCellCommands,
        showDropArea,
        dndHandler,
        showDecorators,
        doubleClickAction
    } = prop;
    const { contextPopup } = actions;
    const { json } = dataprovider;

    const anchor = json.contextMenuCommandsAnchor || 'aw_contextMenu2';

    let scrollElement = dataprovider.getRootReference();
    let paginationOption = dataprovider.getPagination();

    if( !paginationOption ) {
        dataprovider.setPagination( {
            root: scrollElement,
            rootMargin: '5px',
            threshold: 1,
            bottomAnchorSelector: '.page-bottom'
        } );
    }

    let vmCollectionObj = dataprovider.vmCollectionObj;
    let loadedVMO = vmCollectionObj.vmCollection.loadedVMObjects;

    const menuContext = ( event ) => {
        if( !showContextMenu ) { return; }
        event.persist();
        // don't show browser's context menu
        event.preventDefault();
        // activate selection if not already selected
        if( event.currentTarget.ariaSelected !== 'true' ) {
            event.currentTarget.click();
        }
        contextPopup.show( { targetEvent: event } );
    };

    let highlightListWidget = function( target ) {
        if( target ) {
            target.classList.add( 'aw-widgets-dropframe' );
            target.classList.add( 'aw-theme-dropframe' );
        }
    };

    let unHighlightListWidget = function( target ) {
        if( target ) {
            target.classList.remove( 'aw-theme-dropframe' );
            target.classList.remove( 'aw-widgets-dropframe' );
        }
    };

    const highlightUnhighlightList = ( eventData ) => {
        if( !_.isUndefined( eventData ) && eventData.targetElement && eventData.targetElement.classList ) {
            var isHighlightFlag = eventData.isHighlightFlag;
            var target = eventData.targetElement;
            if( target ) {
                if( target.classList.contains( 'aw-widgets-cellListItemContainer' ) ) {
                    target = target.parentElement;
                }
                var isGlobalArea = eventData.isGlobalArea;
                if( isGlobalArea ) { // OBJECT DRAG OVER GLOBAL AREA
                    if( isHighlightFlag ) {
                        if( target.classList.contains( 'aw-widgets-cellListContainer' ) || target.children[ 0 ].classList.contains( 'aw-widgets-cellListContainer' ) ) {
                            highlightListWidget( target );
                        }
                    } else {
                        if( target.classList.contains( 'aw-widgets-cellListContainer' ) || target.classList.contains( 'aw-widgets-cellListItem' ) || target.children.length > 0 && target
                            .children[ 0 ].classList.contains( 'aw-widgets-cellListContainer' ) ) {
                            unHighlightListWidget( target );
                        }
                    }
                } else { // OBJECT DRAG OVER APPLICABLE AREA
                    if( isHighlightFlag ) {
                        if( target.classList.contains( 'aw-widgets-cellListContainer' ) || target.classList.contains( 'aw-widgets-cellListItem' ) || target.children.length > 0 && target
                            .children[ 0 ].classList.contains( 'aw-widgets-cellListContainer' ) ) {
                            highlightListWidget( target );
                        }
                    } else {
                        unHighlightListWidget( target );
                    }
                }
            }
        }
    };

    let newCallbackApis = {
        /**
         * Use the given ViewModelObject(s) .
         */
        clearSelection: function() {
            // Handle clear previous selection
            dataprovider.selectNone();
        },
        /**
         * Use the given ViewModelObject ...
         *
         * @param {ViewModelObject} targetVMO - The 'target' ViewModelObject being dropped onto.
         */
        setSelection: function( targetVMO ) {
            // Handle select result
            var subDef = null;

            subDef = eventBus.subscribe( 'cdm.relatedModified', function() {
                eventBus.unsubscribe( subDef );

                if( targetVMO ) { targetVMO.selected = true; }

                // Handle select result
                if( dataprovider ) { dataprovider.selectionModel.setSelection( [ targetVMO ] ); }
            } );
        },
        highlightTarget: highlightUnhighlightList
    };

    const processContextMenu = () => {
        return showContextMenu && contextPopup.open ? <AwPopup {...contextPopup.options}>
            <AwServerVisibilityPopupCommandBar
                anchor={anchor}
                context={commandContext}
                childCommandClickCallback={()=> contextPopup.hide()}
                mselected={dataprovider.selectedObjects}
                pselected={commandContext.pSelected}
            >
            </AwServerVisibilityPopupCommandBar>
        </AwPopup> : null;
    };

    const processShowDropArea = () => {
        return showDropArea && dndHandler ? <div className='aw-widgets-emptyCell'></div> : null;
    };

    const handleDrag = ( event, item ) => {
        let target = eleRef.closest( event.target, '.aw-widgets-cellListItem' ) || eleRef.closest( event.target, '.aw-widgets-droppable' );
        let targetVMO = [];
        if( target && item ) {
            targetVMO = dragAndDropSvc.getSourceObjects( dataprovider, item.uid ).filter( function( obj ) { return targetVMO.indexOf( obj ) === -1; } );
        }
        if( !targetVMO.length && item ) {
            targetVMO.push( item );
        }
        if( dndHandler && dndHandler[ event.type ] ) {
            let fun = dndHandler[ event.type ];
            fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );
        }
    };

    const handleDrop = ( event, item ) => {
        let target = eleRef.closest( event.target, '.aw-widgets-cellListItem' ) || eleRef.closest( event.target, '.aw-widgets-droppable' );
        let targetVMO = [];
        if( target && item ) {
            targetVMO = [ item ];
        }
        if( showDropArea !== 'false' && showDropArea !== false && dndHandler && dndHandler[ event.type ] ) {
            let fun = dndHandler[ event.type ];
            fun( event, { targetElement: target, targetVMO: targetVMO }, newCallbackApis, dataprovider );
        }
    };

    const ownCellCommands = () => dataprovider.commands || dataprovider.json.commandsAnchor;

    // cell commands or list commands
    const showCellCommandsAlways = () => dataprovider.json.commandsAnchor && hasFloatingCellCommands === false || dataprovider.commands && _.some( dataprovider.commands, i => i.displayOption ===
        'ALWAYS' );

    const processCellItem = ( item, index ) => {
        const listItemRole = 'option';
        const context = commandContext;
        const listItemProps = {
            item,
            index,
            dataprovider,
            ownCellCommands: ownCellCommands(),
            showCellCommandsAlways: showCellCommandsAlways(),
            showCheckbox,
            listOptions,
            itemOptions,
            fixedCellHeight,
            isGroupList,
            hasFloatingCellCommands,
            menuContext,
            listItemRole,
            handleDragAndDrop: { drag: handleDrag, drop: handleDrop, draggable: true },
            showDecorators,
            context,
            doubleClickAction
        };

        return <AwListItem {...listItemProps} key={item.uid ? item.uid : index}>{children}</AwListItem>;
    };

    const processFetching = () => {
        return vmCollectionObj.fetching ? <li className='aw-jswidgets-loadingItem'><div className='aw-jswidgets-loading'>&nbsp;</div></li> : null;
    };

    const processNoResults = () => {
        return dataprovider.noResults ? <div className='aw-widgets-noResultsLabel'>{dataprovider.noResultsFound}</div> : null;
    };

    return (
        <div onDragOver={ e => handleDrop( e )}
            onDragEnter={e => handleDrop( e )}
            onDragLeave={e => handleDrop( e )}
            onDrop={e => handleDrop( e )}
            className='aw-base-scrollPanel' ref={scrollElement}>
            { processContextMenu() }

            <ul role='listbox' tabIndex={dataprovider.viewModelCollection.totalFound > 0 ? 0 : -1} className='aw-widgets-cellListWidget sw-column flex-shrink'>
                { loadedVMO.length > 0 && loadedVMO.map( processCellItem ) }
                { processFetching() }
            </ul>

            <div className='page-bottom' ></div>

            { processNoResults() }

            { processShowDropArea() }
        </div>
    );
};
