import AwCommandBar from 'viewmodel/AwCommandBarViewModel';
import eventBus from 'js/eventBus';
import AwNavigatePanel from 'viewmodel/AwNavigatePanelViewModel';
import { ShowWhen } from 'js/hocCollection';
import _ from 'lodash';
import appCtxSvc from 'js/appCtxService';

const AwShowWhenProvider = ShowWhen( AwNavigatePanel );
export const awCommandPanelRenderFunction = ( props ) => {
    const { attributes, onSubmit, submitAction, subPanelContext = {}, updateActiveView = {}, viewModel } = props;
    const { data } = viewModel;
    const { activeView = null } = updateActiveView;
    let previousView = null;
    let rootNode = data.panelNavTree || null;
    if( rootNode && activeView ) {
        let currentPanelNode = findNode( activeView, rootNode );
        if( currentPanelNode ) {
            previousView = currentPanelNode.getParentNode().getNodeName();
        }
    }

    const loadSubPanels = () => {
        let dynamicSubPanels = data.dynamicSubPanels || [];
        let hierarchy = findHierarchy( activeView, rootNode );
        return dynamicSubPanels.map( ( subPanel ) => {
            let panelId = subPanel.destPanelId;
            let reCreatePanel = subPanel.hasOwnProperty( 'recreatePanel' ) ? subPanel.recreatePanel === true : false;
            let condition = reCreatePanel ? activeView === panelId : true;
            if( !condition ) {
                //When move from panel in higher order, we dont destroy it immediately but destroy and recreate on revisit to panel based on recreatePanel flag
                if( hierarchy.indexOf( activeView ) > hierarchy.indexOf( panelId ) ) {
                    condition = true; // DO NOT DESTROY
                }
            }

            return (
                condition && <AwShowWhenProvider
                    showWhen={activeView === panelId}
                    key={panelId}
                    destPanelId = {panelId}
                    prePanelId={previousView}
                    updateActiveView={updateActiveView}
                    subPanelContext={subPanel.subPanelContext}
                    title={subPanel.title}>
                </AwShowWhenProvider>
            );
        } );
    };
    return (
        <form { ...attributes }
            onSubmit = { event => { onSubmit && onSubmit( event, submitAction ); } }
            className = 'sw-column flex-auto aw-panel sw-command-panel align-self-stretch afx-content-background'>
            { !props.hideTitle ? <div className='aw-layout-panelTitle sw-row justify-justified'>
                <div className={( props.caption ? '' : 'hidden ' ) + 'aw-panel-caption align-self-stretch'}>
                    { props.caption }
                </div>
                <div className='sw-row align-center justify-right flex-shrink sw-panel-bar'>
                    {/* revisitMe: Jignesh to add map for icon buttons */}
                    {/* <aw-icon-button class='aw-layout-right' command='command' visible-when='{{command.condition}}' ng-repeat='command in commands'></aw-icon-button> */}
                    <AwCommandBar
                        className='aw-layout-workareaCommandbar'
                        anchor={ props.anchor }
                        alignment='HORIZONTAL'
                        context={ props.context}>
                    </AwCommandBar>
                    <AwCommandBar
                        context={ props.context }
                        class='aw-layout-workareaCommandbar'
                        anchor='aw_commandPanel'
                        alignment='HORIZONTAL'>
                    </AwCommandBar>
                </div>
            </div>
                : '' }
            <div className='sw-command-panelContent sw-column flex-auto'>
                { props.children }
                { loadSubPanels()}
            </div>
            <button type='submit' className='aw-hide-form-button' disabled={true} aria-hidden='true'></button>
        </form>
    );
};

export const executeReveal = function( revealAction, subPanels ) {
    if( _.isFunction( revealAction ) ) {
        revealAction();
    }
    // preloadedPanels are the panels which are statically declared inside command -panel child as command-sub-panel.
    let preLoadedCommandSubPanels = [];
    if( subPanels ) {
        let children = _.isArray( subPanels ) ? subPanels : [ subPanels ];
        preLoadedCommandSubPanels = children.map( ( child ) => {
            return child.props && child.props.panelId ? child.props.panelId : '';
        } ).filter( ( child ) => child !== '' );
    }
    eventBus.publish( 'awPanel.reveal', {} );
    return preLoadedCommandSubPanels;
};

/**
 * @param {*} subPanelContext
 */
export const navigatePanel = ( eventData, updateActiveView, panelNavTree, dynamicSubPanels, staticCommandSubPanels ) => {
    let activeView = updateActiveView.activeView;
    const pDispatch = updateActiveView.dispatch;
    if( pDispatch && activeView ) {
        appCtxSvc.updateCtx( 'panelContext', eventData );

        // If the incoming sub-panel is not yet registered with dynamicSubPanels state, It must be a getting loaded newly.
        const isAlreadyLoadedDynPanel = dynamicSubPanels.findIndex( ( loadedPanel ) => loadedPanel.destPanelId === eventData.destPanelId ) !== -1;
        const isStaticCommandPanel = staticCommandSubPanels.findIndex( ( staticCommandSubPanel ) => staticCommandSubPanel === eventData.destPanelId ) !== -1;
        /**
         *  isNewNavigationSystemEnabled
         *  BA Specific case
         * ----------------------------------------------------------------------------------------------------
         *  In BA , user might use a component directly inside a command-panel and later do navigation from the
         *  <aw-command-panel><aw-info show-when="data.activeView==='awInfo'"/><aw-command-panel>
         *  In these cases, when navigating back, user need to specify "backNavigation" as true as part of "aw.navigate" eventdata.
         *  isNewNavigationSystemEnabled will be enabled when "backNavigation" is set as true in the event data.
         *
         *  In other cases ( same as ng-afx)
         * -----------------------------------------------------------------------------------------------------------
         *  <aw-command-panel><aw-command-sub-panel panel-id='awInfo' show-when="data.activeView==='awInfo'"/><aw-command-panel>
         *  User need not required to define backNavigation as true as part of eventdata amd should work as ng-afx worked.       *
         *
         *  If the incoming new panel is not part of dynamicSubPanels and staticCommandSubPanel, then only add it to dynamicSubPanels.
         *  Otherwise it means the incoming panel( specified destPanelId in eventData) is already loaded and not a new one.
         */
        let isNewNavigationSystemEnabled = false;
        let backNavigation = false;
        if( eventData.hasOwnProperty( 'backNavigation' ) ) {
            isNewNavigationSystemEnabled = true;
            if( eventData.backNavigation ) {
                backNavigation = true;
            }
        }
        if( isNewNavigationSystemEnabled && !isAlreadyLoadedDynPanel && !backNavigation ) {
            dynamicSubPanels.push( eventData );
        }
        if( !isNewNavigationSystemEnabled && !isAlreadyLoadedDynPanel && !isStaticCommandPanel ) {
            dynamicSubPanels.push( eventData );
        }
        dynamicSubPanels = dynamicSubPanels.map( ( subPanel ) => subPanel.destPanelId === eventData.destPanelId ? eventData : subPanel );
        // The current view will be evetually becomes the previousView
        let previousView = null;
        // The Panel name came from event will become the activeView eventually
        //let activeView = null;
        let rootNode = panelNavTree || new Node( 'root' );
        if( activeView !== eventData.destPanelId ) {
            previousView = activeView;
            activeView = eventData.destPanelId;
            let prevPanelNode = findNode( previousView, rootNode );
            // If the current panel is not found in tree, then this is the first
            if( !prevPanelNode ) {
                let prevNode = new Node( previousView );
                rootNode.addChildNodes( prevNode );
                prevNode.addChildNodes( new Node( activeView ) );
            } else {
                // If the new Panel( suppose to load) is found in the Tree, then no need to add it.
                // probably the navigation already happened.
                if( !findNode( activeView, rootNode ) ) {
                    prevPanelNode.addChildNodes( new Node( activeView ) );
                }
            }
        }
        return {
            panelNavTree: { ...rootNode },
            dynamicSubPanels: [ ...dynamicSubPanels ],
            currentView: activeView
        };
    }
};

export const dispatchActiveView = ( updateActiveView, currentView ) => {
    const pDispatch = updateActiveView.dispatch;
    if( pDispatch && currentView ) {
        pDispatch( { value: { 'data.activeView': currentView } } );
    }
};

/**
 * Simple Data Structure to hold the Panel Navigation sequence.
 * @param {*} name
 * @param {*} pNode
 * @param {*} cNode
 */
const Node = function( name ) {
    let nodeName = name;
    let parentNode = null;
    const childNodes = [];

    this.getNodeName = () => nodeName;
    this.setNodeName = ( name ) => nodeName = name;

    this.getParentNode = () => parentNode;
    this.setParentNode = ( pNode ) => parentNode = pNode;

    this.getChildNodes = () => childNodes;
    this.addChildNodes = ( childNode ) => {
        let _self = this;
        let hasChildNode = childNodes.filter( ( cNode ) => cNode.getNodeName() === childNode.getNodeName() );
        if( hasChildNode.length === 0 ) {
            childNodes.push( childNode );
            childNode.setParentNode( _self );
        }
    };
};

const findHierarchy = ( name, rootNode ) => {
    let order = [];
    if( rootNode === null || rootNode.getNodeName() === name ) {
        return [ 'root' ];
    }
    let traverseHierarchy = function( rootNode ) {
        _.forEach( rootNode.getChildNodes(), ( Node ) => {
            order.push( Node.getNodeName() );
            return traverseHierarchy( Node );
        } );
    };
    traverseHierarchy( rootNode );
    return order;
};

const findNode = ( name, rootNode ) => {
    if( rootNode.getNodeName() === name ) {
        return rootNode;
    }
    let visitedNode = null;
    let inOrderTraversal = function( rootNode ) {
        _.forEach( rootNode.getChildNodes(), ( Node ) => {
            if( Node && Node.getNodeName() === name ) {
                visitedNode = Node;
                return;
            }
            return inOrderTraversal( Node );
        } );
    };
    inOrderTraversal( rootNode );
    return visitedNode;
};
