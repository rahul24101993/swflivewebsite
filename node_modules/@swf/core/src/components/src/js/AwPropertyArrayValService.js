// Copyright (c) 2021 Siemens
/* eslint-disable react-hooks/rules-of-hooks */
import AwIcon from 'viewmodel/AwIconViewModel';
import AwPropertyArrayEditVal from 'viewmodel/AwPropertyArrayEditValViewModel';
import AwDateTimeVal from 'viewmodel/AwDateTimeValViewModel';
import AwToggleButtonVal from 'viewmodel/AwToggleButtonValViewModel';
import AwRadioButtonVal from 'viewmodel/AwRadiobuttonValViewModel';
import AwCheckboxVal from 'viewmodel/AwCheckboxValViewModel';
import { getValClass } from 'js/componentUtils';
import { useState } from 'react';
import ariaList from 'js/ariaList';
import wcagSvc from 'js/wcagService';
import _ from 'lodash';

export const onMount = ( elementRefList ) => {
    //WCAG keyboard handling
    const list = new ariaList();
    let ul = elementRefList.get( 'arrayVal' ).current;
    if( !ul ) { return; }

    var obj = {
        setAriaAttributes: false,
        autoScroll: false,
        listSelector: '.aw-jswidgets-arrayValueCellListItem'
    };

    let childSelector = 'option';
    list.init( ul, obj, childSelector );
};

const focusOnSiblingLi = ( action ) => {
    //manage focus & tabindex on moveUp/moveDown Command.
    let li = document.querySelector( 'li.aw-state-selected' );
    if( li ) {
        li.setAttribute( 'tabindex', -1 );
        let siblingToFocus;
        if( action === 'Move Up' ) {
            siblingToFocus = li.previousElementSibling;
        } else if( action === 'Move Down' ) {
            siblingToFocus = li.nextElementSibling;
        }
        if( siblingToFocus ) {
            siblingToFocus.focus();
            siblingToFocus.setAttribute( 'tabindex', 0 );
        } else {
            //if no focusable sibling focus on current selected
            li.focus();
            li.setAttribute( 'tabindex', 0 );
        }
    }
};

const focusRequiredElement = ( prop, event ) => {
    if( ( event.target.type === 'button' || event.currentTarget.type === 'button' ) && event.currentTarget.attributes.title ) {
        let operation = event.currentTarget.attributes.title.value;
        switch ( operation ) {
            case 'Move Up':
            case 'Move Down':
                focusOnSiblingLi( operation );
                break;
            case 'Remove': {
                //set tabIndex of parent ul to 0 since no active tabIndex left after removal
                let locator = `[data-locator='${prop.label}']`;
                let inputEle = document.querySelector( `input${locator},textarea${locator}` );
                if( inputEle && inputEle.previousElementSibling !== null ) {
                    let ulEle = inputEle.previousElementSibling.firstElementChild;
                    if( ulEle !== null ) {
                        propArrayLength( prop ) > 0 ? ulEle.setAttribute( 'tabIndex', '0' ) : ulEle.setAttribute( 'tabIndex', '-1' );
                    }
                }
                // focus on input box once li element removed
                inputEle && inputEle.focus();
                break;
            }
        }
    }
};

const isLiItemSelected = ( event ) => {
    return event.currentTarget.classList.contains( 'aw-state-selected' );
};

const propArrayLength = ( prop ) => prop.fielddata.displayValsModel.length;

const handleClick = ( prop, event ) => {
    let isAnyValueSelected = false;
    if( prop.fielddata.displayValsModel ) {
        for( var j = 0; j < propArrayLength( prop ); j++ ) {
            if( prop.fielddata.displayValsModel[ j ].selected && prop.fielddata.displayValsModel[ j ].isInEditMode ) {
                isAnyValueSelected = true;
                break;
            }
        }
    }
    if( !isAnyValueSelected ) {
        event.preventDefault();
        prop.onClick( event );
    }
    focusRequiredElement( prop, event );
};

const handleKeyDown = ( prop, event ) => {
    if( wcagSvc.isValidKeyPress( event, true ) ) {
        handleClick( prop, event );
    }
};

const handleBlur = ( prop, event ) => {
    event.isBlurFromInput = true;
    prop.onBlur( event );
};

const handleKeyPress = ( prop, event ) => {
    if( event.key === 'Enter' ) {
        event.updateArray = true;
        event.preventDefault();
        prop.onChange( event );
        // revisitme: what is the bext way to clear widget
        event.target.value = '';
    }
};

const renderPropertyEditMode = ( prop, displayValue, index ) => {
    if( prop.fielddata.displayValsModel[ index ].isInEditMode && prop.typex !== 'DATEARRAY' && prop.typex !== 'BOOLEANARRAY' ) {
        // eslint-disable-next-line jsx-a11y/no-autofocus
        return <input type='text' onKeyPress={( event ) => handleKeyPress( prop, event )} onBlur={( event ) => handleBlur( prop, event )} id={index} defaultValue={displayValue} autoFocus className='aw-jswidgets-arrayValue'/>;
    } else if( prop.fielddata.displayValsModel[ index ].isInEditMode && prop.typex === 'DATEARRAY' ) {
        return (
            <AwDateTimeVal {...prop} className={ getValClass( prop ) }/>
        );
    } else if( prop.fielddata.displayValsModel[ index ].isInEditMode && prop.typex === 'BOOLEANARRAY' && prop.fielddata.renderingHint === 'radiobutton' ) {
        return (
            <AwRadioButtonVal prop={prop} className={ getValClass( prop ) }/>
        );
    } else if( prop.fielddata.displayValsModel[ index ].isInEditMode && prop.typex === 'BOOLEANARRAY' && prop.fielddata.renderingHint === 'togglebutton' ) {
        return (
            <AwToggleButtonVal {...prop} className={ getValClass( prop ) }/>
        );
    } else if( prop.fielddata.displayValsModel[ index ].isInEditMode && prop.typex === 'BOOLEANARRAY' ) {
        return (
            <AwCheckboxVal {...prop} className={ getValClass( prop ) }/>
        );
    }
    return (
        <div role='button' tabIndex='-1' id={index} onKeyDown={( event ) => handleKeyDown( prop, event )} onClick={( event ) => handleClick( prop, event )} className='aw-jswidgets-arrayValue'>{displayValue}</div>
    );
};

const renderProperty = ( prop, displayNode, index, setIsShown, isShown ) => {
    let displayValue = displayNode.displayValue;
    let isAnyValueSelected = false;
    let focusAndHoverEvents = {
        onFocus: () => {
            if( wcagSvc.areWeInKeyboardMode() ) {
                setIsShown( true );
            }
        },
        onBlur: ( event ) => {
            if( wcagSvc.areWeInKeyboardMode() && !isLiItemSelected( event ) ) {
                setIsShown( false );
            }
        },
        onMouseEnter: () => { setIsShown( true ); },
        onMouseLeave: () => { setIsShown( false ); }
    };
    if( prop.fielddata.displayValsModel ) {
        for( var i = 0; i < propArrayLength( prop ); i++ ) {
            if( prop.fielddata.displayValsModel[ i ].selected && prop.fielddata.displayValsModel[ i ].isInEditMode ) {
                isAnyValueSelected = true;
                break;
            }
        }
    }
    const getCellListItemClass = () => {
        const selectedClass = propArrayLength( prop ) > 0 && prop.fielddata.displayValsModel[ index ].selected ? ' aw-state-selected' : '';
        return 'sw-aria-border aw-jswidgets-arrayValueCellListItem' + selectedClass;
    };

    return (
        <li role='option' aria-selected={isAnyValueSelected} tabIndex='-1' key={index} id={index} onKeyDown={( event )=> handleKeyDown( prop, event )} className={ getCellListItemClass() } {...focusAndHoverEvents}>
            <div className='aw-jswidgets-arrayValueContainer'>
                {
                    renderPropertyEditMode( prop, displayValue, index )
                }
                { ( isShown || displayNode.selected ) && !isAnyValueSelected && !prop.disabled ? <div className='aw-layout-flexColumnContainer'>
                    <div className='aw-jswidgets-arrayIcons'>
                        <button onClick={( event ) => handleClick( prop, event )} id={index} onKeyDown={( event )=> handleKeyDown( prop, event )} type='button' className='aw-commands-commandIconButton aw-widgets-defaultPropertyValueButton'
                            disabled={prop.fielddata.displayValsModel[ index ].isInEditMode} title={'Move Up'} >
                            <AwIcon iconId='cmdMoveUp'/>
                        </button>
                        <button onClick={( event ) => handleClick( prop, event )} id={index + 1} onKeyDown={( event )=> handleKeyDown( prop, event )} type='button' className='aw-commands-commandIconButton aw-widgets-defaultPropertyValueButton'
                            disabled={prop.fielddata.displayValsModel[ index ].isInEditMode} title={'Move Down'} >
                            <AwIcon iconId='cmdMoveDown'/>
                        </button>
                        <button onClick={( event ) => handleClick( prop, event )} id={index + 2} onKeyDown={( event )=> handleKeyDown( prop, event )} type='button' className='aw-commands-commandIconButton aw-widgets-defaultPropertyValueButton'
                            disabled={prop.fielddata.displayValsModel[ index ].isInEditMode} title={'Remove'} >
                            <AwIcon iconId='cmdRemove'/>
                        </button>
                    </div>
                </div> : ''}
            </div>
        </li>
    );
};

export const awPropertyArrayValRenderFunction = ( props ) => {
    const {
        viewModel,
        ctxMin,
        actions,
        i18n,
        fields,
        grids,
        formProp,
        messages,
        elementRefList,
        ...prop
    } = props;

    const getContainerClass = () => {
        let borderClass = '';
        if( prop.fielddata.displayValsModel && propArrayLength( prop ) > 0 ) {
            borderClass = ' sw-border';
        }

        return 'aw-jswidgets-arrayWidgetContainer' + borderClass;
    };

    const getPropContainerClass = () => {
        let classVal = 'sw-array-val sw-property-val sw-column';
        const changedClass = !prop.disabled && ( prop.dirty === 'true' || prop.dirty === true ) ? ' sw-changed' : '';
        return classVal + changedClass;
    };

    const [ isShown, setIsShown ] = useState( false );

    let ariaProp = {};
    _.each( prop, ( v, k ) => { k.startsWith( 'aria-' ) && ( ariaProp[ k ] = v ); } );

    return (
        <div className={ getPropContainerClass() }>
            <div className={ getContainerClass() } >
                <ul role='listbox' {...ariaProp} className='aw-jswidgets-arrayEditValueCellList' tabIndex={propArrayLength( prop ) > 0 ? '0' : '-1'} ref={elementRefList.get( 'arrayVal' )}>
                    {
                        prop.fielddata.displayValsModel && prop.fielddata.displayValsModel.map( ( displayNode, index ) =>
                            renderProperty( prop, displayNode, index, setIsShown, isShown )
                        )
                    }
                </ul>
            </div>
            { !prop.disabled ? <AwPropertyArrayEditVal {...prop}/> : '' }
        </div>
    );
};
