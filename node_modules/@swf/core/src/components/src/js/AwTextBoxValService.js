// Copyright (c) 2021 Siemens
import AwPropertyNonEditVal from 'viewmodel/AwPropertyNonEditValViewModel';
import sanitizer from 'js/sanitizer';
import { getValClass } from 'js/componentUtils';

/**
 * render function for AwTextBoxVal
 * @param {*} param0 context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awTextBoxValRenderFunction = ( props ) => {
    const {
        viewModel,
        ctxMin,
        actions,
        i18n,
        fields,
        grids,
        formProp,
        messages,
        ...prop
    } = props;
    const { onChange, onSwChange } = prop;

    let filteredAttrs = sanitizer.sanitizeHTMLTagProps( prop, 'input' );
    delete filteredAttrs.maxLength;
    const inputClass = getValClass( prop );

    // use simple non-edit val if not editing
    if( !prop.fielddata.isEditable ) {
        return (
            <AwPropertyNonEditVal {...prop}></AwPropertyNonEditVal>
        );
    }

    var keyPressed = ( event, props ) => {
        if( event.key === 'Enter' ) {
            event.preventDefault();
            event.target.value = event.target.value.trim();
            changeHandler( event, true );
            event.target.value = '';
            event.persist();
            return props && props.action && props.action( event );
        }
        //handle maxLength
        const textLength = ( event.target.value + event.key ).trim().length;
        if( textLength > prop.maxLength ) {
            event.preventDefault();
        }
    };

    const changeHandler = ( event, immediate = false ) => {
        // provide callback handler which application can hook, with parameters: current value, old value
        onSwChange && onSwChange( event.target.value, prop.value, immediate );

        // at last
        onChange( event );
    };

    const handleBlur = ( event, props ) => {
        event.target.value = event.target.value.trim();
        // why call changeHandler onBlur? this breaks ACE's aw-list-filter in an aw-include in an aw-link-with-popup
        if( prop.typex === 'STRINGARRAY' ) {
            changeHandler( event, true );
            //clear value after update
            event.target.value = '';
            event.persist();
        }

        if( props && props.blurAction ) {
            event.persist();
            return props.blurAction( event );
        }
    };

    if( prop.typex === 'STRINGARRAY' ) {
        return (
            <input type='text' data-locator={prop.label} aria-required={prop.isRequired} placeholder={prop.placeholder} className={inputClass} onBlur={handleBlur} onKeyPress={keyPressed}/>
        );
    }

    return (
        <input {...filteredAttrs}
            type={prop.inputType ? prop.inputType : 'text'}
            aria-label={prop.name}
            className={inputClass}
            onChange={changeHandler}
            onKeyPress={( e )=>keyPressed( e, props )}
            value={filteredAttrs.value || ''}
            onBlur={( e )=>handleBlur( e, props )}
            autoComplete='off'
        />
    );
};
