/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
/* eslint-disable react/jsx-no-undef */
/* eslint-disable @swf/swf/no-react-usage */
import { handleSelectionEvent } from 'js/selectionHelper';
import { getListItemClasses } from 'js/componentUtils';
import { mapChildren } from 'js/reactHelper';
import AwListCheckboxItem from 'viewmodel/AwListCheckboxItemViewModel';
import AwStaticListCommand from 'viewmodel/AwStaticListCommandViewModel';
import wcagSvc from 'js/wcagService';
import eventBus from 'js/eventBus';
import _ from 'lodash';

export const awListItemRenderFunction = ( props ) => {
    const {
        item,
        index,
        dataprovider,
        ownCellCommands,
        showCellCommandsAlways,
        children,
        showCheckbox,
        listOptions,
        itemOptions,
        fixedCellHeight,
        isGroupList,
        hasFloatingCellCommands,
        menuContext,
        listItemRole,
        viewModel,
        elementRefList,
        handleDragAndDrop,
        context,
        doubleClickAction
    } = props;
    const { data, dispatch } = viewModel;
    const cellDecoratorClass = props.showDecorators ? 'aw-widgets-showCellDecorator' : '';
    const groupHeader = elementRefList.get( 'groupHeader' );

    let vmCollectionObj = dataprovider.vmCollectionObj;
    let loadedVMO = vmCollectionObj.vmCollection.loadedVMObjects;
    const selectionEnabled = dataprovider.selectionModel.isSelectionEnabled();

    const selectionModelActivated = dataprovider.selectionModel.isSelectionModelActivated();

    const handleSelection = ( event, vmo ) => {
        if( dataprovider.selectionModel.isSelectionEnabled() ) {
            handleSelectionEvent( [ vmo ], dataprovider.selectionModel, event, vmCollectionObj.vmCollection );
        }
        if( listOptions && listOptions.selectionHandler ) {
            listOptions.selectionHandler( vmo );
        }
    };

    // uxt6xo: revisit me: Double click event is needed for Arrange panel; need to find best way of implementing.
    const handleDoubleClick = ( event, vmo ) => {
        doubleClickAction && doubleClickAction( { eventTargetObjs: [ vmo ] } );
        eventBus.publish( dataprovider.name + '.listDoubleClick', { eventTargetObjs: [ vmo ] } );
    };

    const handleDrag = ( event, dItem ) => {
        handleDragAndDrop.drag( event, dItem );
    };

    const handleDrop = ( event, dItem ) => {
        handleDragAndDrop.drop( event, dItem );
    };

    const handleKeyDown = ( event, vmo ) => {
        // ignore case keydown on other element
        if( event.target.tagName !== 'LI' ) {
            return;
        }

        if( wcagSvc.isValidKeyPress( event ) ) {
            handleSelection( event, vmo );
        } else if( listItemRole === undefined ) {
            wcagSvc.handleMoveUpOrDown( event, event.currentTarget.parentElement.parentElement );
        }
    };

    // zarq9k: revisit me: This is to avoid react warning. onChange={()=> {} is wrong, we  got to remove this.
    const renderChildWithItem = ( item, showCheckbox, isSelected, index ) => {
        let props = { item, index, isSelected, options: itemOptions, key: index, tabIndex: -1 };
        if( isGroupList ) {
            props.parent = groupHeader.current;
            props.previousItem = loadedVMO[ index - 1 ];
        }
        let candidate = _.concat( [], children );
        if( ownCellCommands ) {
            if( showCellCommandsAlways || // always
                ( data._showCellCommand || item.selected ) // load on demand
            ) {
                let cellCommand = processFloatingCellCommand( item, index, itemOptions, fixedCellHeight, isGroupList );
                candidate = _.concat( candidate, cellCommand );
            }
        }

        let child = mapChildren( candidate, props );
        if( showCheckbox === true ) {
            return <AwListCheckboxItem {...props} key={index}>{child}</AwListCheckboxItem>;
        }
        return child;
    };

    // parse fixedCellHeight if any
    const getStyle = () => {
        if( !fixedCellHeight ) { return; }
        const height = parseInt( fixedCellHeight );
        return { style: { height } };
    };

    const processFloatingCellCommand = ( item, index, itemOptions, fixedCellHeight, isGroupList ) => {
        const props = { item, index, itemOptions, fixedCellHeight, isGroupList, dataprovider, context };
        return <AwStaticListCommand {...props} selectedObjects={dataprovider.selectedObjects} key={index}></AwStaticListCommand>;
    };

    const checkSelected = ( item ) => {
        if( listOptions && listOptions.selectionCheck ) {
            return listOptions.selectionCheck( item );
        }
        return dataprovider.selectionModel.isSelected( item );
    };

    const keepCellCommands = ( event ) => {
        // Do not remove the cell commands,
        // case1: if moving using tab on the list item
        // case2: if moving to noty_msg
        // case3: if clicking on a cell command
        let result = false;
        if( event.type === 'blur' && data._showCellCommand && event.relatedTarget ) {
            if(  [ 'BUTTON', 'A' ].indexOf( event.relatedTarget.tagName ) > -1 ||
                    event.relatedTarget.className && event.relatedTarget.className.indexOf( 'noty_msg' ) > -1  ||
                    event.relatedTarget.tagName === 'LI' && event.relatedTarget.attributes['data-command-id']
            ) {
                result = true;
            }
        }
        return result;
    };

    const toggleHovered = ( event, flag ) => {
        if( !ownCellCommands ) { return; }

        if( keepCellCommands( event ) ) {
            return;
        }

        if( data._showCellCommand !== flag ) {
            dispatch( { path: 'data._showCellCommand', value: flag } );
        }
    };

    const processCellItem = ( item, index ) => {
        const isSelected = checkSelected( item );
        return <>
            {isGroupList && <div ref={groupHeader}></div>
            } { handleDragAndDrop.draggable ? <li role={listItemRole}
                aria-selected={isSelected}
                draggable={handleDragAndDrop.draggable}
                onDragStart={ e => handleDrag( e, item )}
                onDragOver={ e => handleDrop( e, item )}
                onDrag={ e => handleDrag( e, item )}
                onDragEnter={ e => handleDrop( e, item )}
                onDragLeave={ e=> handleDrop( e, item )}
                onDrop={ e => handleDrop( e, item )}
                onFocus={ e => toggleHovered( e, true )}
                onBlur={e=>toggleHovered( e, false )}
                onMouseEnter={e=>toggleHovered( e, true )}
                onMouseLeave={e=>toggleHovered( e, false )}
                onClick={( e )=>handleSelection( e, item )}
                onDoubleClick={( e )=>handleDoubleClick( e, item )}
                onKeyDown={( e )=>handleKeyDown( e, item )}
                className={`${getListItemClasses( isSelected, selectionEnabled, isGroupList, fixedCellHeight, null, selectionModelActivated )}`}
                key={index}
                tabIndex={-1} /*By default not focusable but programatically focusable*/
                onContextMenu={menuContext}
                {...getStyle()}>
                <div className={`sw-row aw-widgets-cellListItemContainer aw-widgets-droptable ${item.cellDecoratorStyle || ''} ${cellDecoratorClass}`}  draggable={handleDragAndDrop.draggable} >
                    { renderChildWithItem( item, showCheckbox, isSelected, index ) }
                </div>
            </li> : <li role={listItemRole}
                aria-selected={isSelected}
                draggable={handleDragAndDrop.draggable}
                onFocus={ e => toggleHovered( e, true )}
                onBlur={e=>toggleHovered( e, false )}
                onMouseEnter={e=>toggleHovered( e, true )}
                onMouseLeave={e=>toggleHovered( e, false )}
                onClick={( e )=>handleSelection( e, item )}
                onDoubleClick={( e )=>handleDoubleClick( e, item )}
                onKeyDown={( e )=>handleKeyDown( e, item )}
                className={`${getListItemClasses( isSelected, selectionEnabled, isGroupList, fixedCellHeight, null, selectionModelActivated )}`}
                key={index}
                tabIndex={-1} /*By default not focusable but programatically focusable*/
                onContextMenu={menuContext}
                {...getStyle()}>
                <div className={`sw-row aw-widgets-cellListItemContainer aw-widgets-droptable ${item.cellDecoratorStyle || ''} ${cellDecoratorClass}`}  draggable={handleDragAndDrop.draggable} >
                    { renderChildWithItem( item, showCheckbox, isSelected, index ) }
                </div>
            </li> } </>;
    };

    return processCellItem( item, index );
};
