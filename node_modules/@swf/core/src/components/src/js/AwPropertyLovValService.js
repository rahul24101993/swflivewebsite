// Copyright (c) 2021 Siemens
/* eslint-disable complexity */
import AwPopup from 'viewmodel/AwPopupViewModel';
import AwIcon from 'viewmodel/AwIconViewModel';
import AWLovList from 'viewmodel/AwLovListViewModel';
import AWPropertyLovChild from 'viewmodel/AwPropertyLovChildViewModel';
import AwPropertyCheckboxLovChild from 'viewmodel/AwPropertyCheckboxLovChildViewModel';
import AwTextBoxVal from 'viewmodel/AwTextBoxValViewModel';
import { getValClass } from 'js/componentUtils';
import { DOMAPIs as dom } from 'js/domUtils';
import keyCode from 'js/keyCode';
import _ from 'lodash';
import wcagService from 'js/wcagService';
import AwButton from 'viewmodel/AwButtonViewModel';
import AwPropertyLabel from 'viewmodel/AwPropertyLabelViewModel';
import AwPic from 'viewmodel/AwPicViewModel';

const MIN_LENGTH_TO_DISPLAY_FILTER_FOR_EXHAUSTIVE_LOV = 5;

//Sets totalNumber of objects in dataprovider before filter and lovUsage ( exhaustive/suggestive )
const setInitialDataProviderInfo = ( dataProvider, initialDataProviderInfo, popupOpen ) => {
    let initialLength = 0;
    if( dataProvider.viewModelCollection && dataProvider.viewModelCollection.loadedVMObjects.length > 0 ) {
        initialLength = dataProvider.viewModelCollection.loadedVMObjects.length;
    } else if( initialLength === 0 && dataProvider.vmCollectionObj && dataProvider.vmCollectionObj.vmCollection && dataProvider.vmCollectionObj.vmCollection.loadedVMObjects.length > 0 ) {
        initialLength = dataProvider.vmCollectionObj.vmCollection.loadedVMObjects.length;
    }

    if( initialDataProviderInfo.current === null && ( initialLength > 0 || !_.isUndefined( dataProvider.lovUsage ) ) ) {
        //Get length of objects on initialload - we cant use totalFound because
        //totalFound changes as we filter and some implementation does not have totalFound populated
        let initalPrePoulatedDataLen = initialLength > 0 && popupOpen === undefined ? initialLength : undefined;
        let initialInfo = {
            initialTotalFound: initialLength,
            initalPrePoulatedDataLen
        };
        if( dataProvider.hasOwnProperty( 'lovUsage' ) && dataProvider.lovUsage === 'SUGGESTIVE_LOV' ) {
            initialInfo.lovUsage = 'SUGGESTIVE_LOV';
        }
        initialDataProviderInfo.current = initialInfo;
    }
    if( initialDataProviderInfo.current && initialDataProviderInfo.current.initalPrePoulatedDataLen !== undefined &&
        initialDataProviderInfo.current.initalPrePoulatedDataLen !== initialLength && initialLength > 0 ) {
        //When popup opens and new initialLength is populated then update initialTotalFound
        delete initialDataProviderInfo.current.initalPrePoulatedDataLen;
        initialDataProviderInfo.current.initialTotalFound = initialLength;
    }
};

// Gets isSearchable and isSelectOnly flag which is helped to decide LOV UI and behaviors
const getSelectOnlyAndSearchableFlags = ( prop, initialDataProviderInfo, isCheckBoxArryLOV, hideFilter ) => {
    // isSelectOnly: true = exhaustive list; false = non-list val can be suggested
    let isSelectOnly = _.isUndefined( prop.fielddata.isSelectOnly ) ? true : prop.fielddata.isSelectOnly;

    if( initialDataProviderInfo.current && !_.isUndefined( initialDataProviderInfo.current.lovUsage ) && initialDataProviderInfo.current.lovUsage === 'SUGGESTIVE_LOV' ) {
        isSelectOnly = false;
    }

    let initialTotalFound = initialDataProviderInfo.current === null || initialDataProviderInfo.current.initialTotalFound === undefined ? 0 : initialDataProviderInfo.current.initialTotalFound;

    // Based on PO input, we have to display filter Box if no of values are more than 5
    const isSearchable = isSelectOnly === false || isCheckBoxArryLOV || isSelectOnly === true && hideFilter === false ? true :
        initialTotalFound > MIN_LENGTH_TO_DISPLAY_FILTER_FOR_EXHAUSTIVE_LOV;

    return { isSelectOnly, isSearchable };
};

const updateInitialDataProviderInfo = ( initialDataProviderInfo ) => {
    //If initalPrePoulatedDataLen still exists after popup open, we need to delete this as it is no more releavant
    // This can happen if initalPrePoulatedDataLen ===  dataProvider.len when popup is opened
    //If this is not updated then during filter isSearchable flag which depends on dataProvider.len gives false result
    if( initialDataProviderInfo.current && initialDataProviderInfo.current.initalPrePoulatedDataLen ) {
        delete initialDataProviderInfo.current.initalPrePoulatedDataLen;
    }
};
/**
 * render function for AwLovVal
 * @param {*} props context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awLovValRenderFunction = ( props ) => {
    const {
        actions,
        fields,
        elementRefList,
        autoCorrect,
        action,
        viewModel,
        hideFilter,
        ...prop
    } = props;

    const field = prop;
    const { isListbox } = props;
    let { data: { blankLovEntry, dirty, _most_recent_entry, parentSelectedHandled }, searchBoxLOVFilterStr, dispatch } = viewModel;

    const selectIndex = elementRefList.get( 'selectIndex' );
    const checkLovEntries = elementRefList.get( 'checkLovEntries' );
    const isValidationInProgress = elementRefList.get( 'isValidationInProgress' );
    const initialDataProviderInfo = elementRefList.get( 'initialDataProviderInfo' );
    const dynProvider = elementRefList.get( 'dynDataprovider' );
    let dataProvider = field.fielddata.dataProvider ? field.fielddata.dataProvider : dynProvider && dynProvider.current;

    let getFilteredEntries = () => validEntries.current.map( ( { propDisplayValue, propInternalValue } ) => {
        return { propDisplayValue, propInternalValue };
    } );

    const hint = prop.fielddata.renderingHint;
    const typex = prop.typex;
    const isCheckBoxArryLOV = hint === 'checkboxoptionlov';
    const isArray = prop.fielddata.isArray;

    if( !dataProvider ) {
        return;
    }

    //zarq9k: This would be cleaned up when we have the infrastruture to pass ref from viewmodel.
    let lovEntryRef = dataProvider.getLovEntryRef();
    setInitialDataProviderInfo( dataProvider, initialDataProviderInfo, actions.lovPopup.open );

    let { isSelectOnly, isSearchable } = getSelectOnlyAndSearchableFlags( prop, initialDataProviderInfo, isCheckBoxArryLOV, hideFilter );

    let staticFilterStr = null;
    let validEntries = elementRefList.get( 'validEntries' );
    let { lovPopup } = actions;

    // provide application opportunity to override the size
    let overridePopupOptions = () => {
        let result = { width: lovPopup.reference.current.offsetWidth, autoFocus: true };
        prop.maxHeight && ( result.maxHeight = prop.maxHeight );
        return result;
    };

    let isPropDateTypeAndNonArray = () => typex && DATE_TYPES.includes( typex ) && !prop.fielddata.isArray;
    let isInValidSearchForExhaustiveLOV = () => !DATE_TYPES.includes( typex ) && selectIndex.current === null && isSelectOnly === true;

    let isArrayWithValidateAction = prop.fielddata.isArray && !_.isEmpty( dataProvider.validateAction ) && !isCheckBoxArryLOV;
    let isValidationErrorVisible = () => props.error && props.error.length > 0;

    const resetFilterStr = () => {
        if( lovEntryRef.current && lovEntryRef.current.lovEntry ) {
            lovEntryRef.current.lovEntry.filterString = null;
        }
        prop.setLovVal( { lovEntry: null }, 'resetFilterStr' );
    };

    let hooks = {
        whenOpened: () => {
            isValidationInProgress.current = false;
            searchBoxLOVFilterStr.error = null;
        },
        whenClosed: ( popupRef ) => {
            // TODO: add comment explaining why validate is needed or not needed here
            if( ( isCheckBoxArryLOV || DATE_TYPES.includes( typex ) ) && lovEntryRef.current && lovEntryRef.current.lovEntry ) {
                validateLOVEntry( lovEntryRef.current.lovEntry );
            }

            resetFilterStr();
            // reset searchBoxLOVFilterStr
            fields.searchBoxLOVFilterStr && fields.searchBoxLOVFilterStr.update( null );
            lovEntryRef.current = null;
        }
    };

    const showPopup = ( resetFilter = true ) => {
        // case1: normal show, we want a reset each time.
        // case2: filter change - onChangeHandler, don't want a reset
        if( resetFilter ) {
            resetFilterStr();

            // save the original, used to recover when esc
            let recent_entry = {
                propDisplayValue: field.fielddata.uiValue,
                propInternalValue: prop.value
            };
            dispatch( { path: 'data._most_recent_entry', value: recent_entry } );
        }

        lovPopup.show( {
            hooks,
            ...overridePopupOptions()
        } );
    };

    const storeLatestLOVEntry = ( lovEntry ) => {
        if( lovEntryRef.current ) {
            lovEntryRef.current.lovEntry = lovEntry;
        } else {
            lovEntryRef.current = { lovEntry };
        }
    };

    // This function would be invoked when some value has been selected from the dropdown popup
    const setLovEntryAndClose = ( receivedLOVEntry, event, op, isAddingTypedValue ) => {
        storeLatestLOVEntry( receivedLOVEntry );
        let dateApi = null;
        if( prop.fielddata.dateApi ) {
            dateApi = prop.fielddata.dateApi;
        }

        if( dateApi && dateApi.isDateEnabled && dateApi.isTimeEnabled && prop.fielddata.isArray ) {
            //If date and time enabled and if its array update only after time is selected
            prop.onTimeSelectedOrEntered( event.target.value || receivedLOVEntry.propInternalValue );
            lovPopup.hide();
        } else {
            receivedLOVEntry.filteredLOVEntries = getFilteredEntries();
            if( !DATE_TYPES.includes( typex ) && !isCheckBoxArryLOV ) {
                op = 'validateandadd';
                //For array vaidation is in progress for other it is not
                isValidationInProgress.current = true;
            }
            let lovEntry = receivedLOVEntry;
            if( isAddingTypedValue === true ) {
                // If isAddingTypedValue === true means user is adding typed value and not from selected list
                // lovEntry is what user has typed in and not from the list displayed in popup
                lovEntry = { ...receivedLOVEntry };
                lovEntry.filterString = searchBoxLOVFilterStr.dbValue;
                lovEntry.propInternalValue = searchBoxLOVFilterStr.dbValue;
                lovEntry.propDisplayValue = searchBoxLOVFilterStr.dbValue;
            }
            if( lovEntry.filterString === undefined ) {
                //After value is added in Array should show correct filter
                lovEntry.filterString = searchBoxLOVFilterStr.dbValue;
            }
            prop.setLovVal( { lovEntry, dataProvider, checkLovEntries, dateApi }, op )
                .then( ( uiProp ) => {
                    isValidationInProgress.current = false;
                    let isErrorEncountered = false;
                    if( !_.isEmpty( uiProp ) && !_.isEmpty( uiProp.error ) ) {
                        isErrorEncountered = true;
                        searchBoxLOVFilterStr.error = uiProp.error;
                    }
                    if( !isErrorEncountered && !( isCheckBoxArryLOV || isArray === true ) ) {
                        lovPopup.hide();
                    }

                    // record the checked items
                    // propInternalValue may in object
                    let key = _.isObject( lovEntry.propInternalValue ) ? lovEntry.propDisplayValue : lovEntry.propInternalValue;
                    if( op === 'checked' ) {
                        lovEntry.isChecked = true;
                        checkLovEntries.current[ key ] = lovEntry;
                    } else if( op === 'unchecked' ) {
                        checkLovEntries.current[ key ].isChecked = false;
                        delete checkLovEntries.current[ key ];
                    }
                    if( isErrorEncountered ) {
                        dispatch( { path: 'data.dirty', value: dirty++ } );
                    }
                } );
        }
    };

    const validateLOVEntry = ( lovEntry ) => {
        // This behaviour is only for aw-listbox".
        // 1, nothing match
        if( autoCorrect ) {
            if( validEntries.current.length === 0 ) {
                // reverting back the value if incorrect value has typed in
                const uiValue = prop.value;
                lovEntry = {
                    propDisplayValue: uiValue,
                    propInternalValue: uiValue
                };
            } else if( lovEntryRef.current.lovEntry && lovEntryRef.current.lovEntry.filterString ) {
                // 2, partial match, then take the first
                lovEntry = validEntries.current[ 0 ];
            }
            storeLatestLOVEntry( lovEntry );

            prop.setLovVal( { lovEntry, dataProvider }, null );
        } else {
            if( isPropDateTypeAndNonArray() ) {
                prop.setLovVal( { lovEntry, dataProvider, dateApi: prop.fielddata.dateApi }, null );
            } else {
                if( isValidationInProgress.current === false ) {
                    if( isArrayWithValidateAction ) {
                        lovEntry.filteredLOVEntries = getFilteredEntries();
                        prop.setLovVal( { lovEntry, dataProvider }, 'validateandadd' );
                    } else {
                        //There was no validation action hence validate
                        prop.setLovVal( { lovEntry, dataProvider }, 'validate' );
                    }
                }
            }
        }
    };

    /**
     * onChangeHandler is invoked, when user manually types-in some value in the LOV textbox.
     * In that case we need to extract the uivalue and store it as filterStr.
     * This filterStr would later used to pass to the server or in case of static lov's
     * (lov's without dataprovider action) filter the result locally.
     * @param {*} event
     */
    const onChangeHandler = ( event ) => {
        if( isCheckBoxArryLOV ) {
            prop.onChange( event );
        }
        if( event.target ) {
            field.fielddata.uiValue = event.target.value;
            if( !lovPopup.open ) {
                showPopup( false );
            }
            let lovEntry = {
                propDisplayValue: field.fielddata.uiValue,
                propInternalValue: field.fielddata.uiValue,
                filterString: field.fielddata.uiValue,
                isSearchable
            };
            prop.setLovVal( { lovEntry, dataProvider }, 'filter' );
            storeLatestLOVEntry( lovEntry );
        }
    };

    const onFilterChangeHandler = ( filter, previous ) => {
        let lovEntry = {
            propDisplayValue: filter,
            propInternalValue: filter,
            filterString: filter,
            isSearchable
        };
        updateInitialDataProviderInfo( initialDataProviderInfo );
        storeLatestLOVEntry( lovEntry );
        prop.setLovVal( { lovEntry, dataProvider }, 'filter' );
    };

    const onBlurHandler = ( e ) => {
        if( e.target.value === '' && isListbox ) {
            storeLatestLOVEntry( _most_recent_entry );
        }
    };

    const isTimeEnteredManually = ( dateApi ) => isPropDateTypeAndNonArray() && dateApi && dateApi.isTimeEnabled && dateApi.timeValue;

    const keyPressed = ( event, isAddingTypedValue ) => {
        // handle SPACE key
        if( wcagService.getKeyName( event ) === keyCode.SPACE && !lovPopup.open ) {
            event.preventDefault();
            showPopup();
            return;
        }
        let dateApi = prop.fielddata.dateApi;
        if( event.key === keyCode.ENTER || event.type === 'click' ) {
            event.preventDefault();
            if( DATE_TYPES.includes( typex ) && isValidationErrorVisible() && !props.isListbox ) {
                return;
            }
            if( lovPopup.open ) {
                // if has any hover item
                if( isAddingTypedValue !== true && selectIndex.current !== null && validEntries.current && validEntries.current[ selectIndex.current ] && !isTimeEnteredManually( dateApi ) ) {
                    let hoverItem = validEntries.current[ selectIndex.current ];
                    if( hoverItem.handleSelection ) {
                        hoverItem.handleSelection( event );
                        event.persist();
                        event.target.value = '';
                        return;
                    }
                } else if( isInValidSearchForExhaustiveLOV() ) {
                    //For exhaustive LOV, if there is no filtered value and user hits enter,
                    // simply close popup
                    lovPopup.hide();
                } else {
                    //Wait for validation to complete before closing popup
                    // the current entry
                    let lovEntry = lovEntryRef.current.lovEntry;

                    if( !autoCorrect ) {
                        // Below line would cause re-rendering automatically
                        if( isValidationInProgress.current === false ) {
                            isValidationInProgress.current = true;
                            lovEntry.filteredLOVEntries = getFilteredEntries();
                            prop.setLovVal( { lovEntry, dataProvider, dateApi }, 'validateandadd' ).then( ( uiProp ) => {
                                let isErrorEncountered = false;
                                if( !_.isEmpty( uiProp ) && !_.isEmpty( uiProp.error ) ) {
                                    isErrorEncountered = true;
                                    searchBoxLOVFilterStr.error = uiProp.error;
                                }
                                if( !isErrorEncountered && !isArray ) {
                                    lovPopup.hide();
                                }
                                isValidationInProgress.current = false;
                                dispatch( { path: 'data.dirty', value: dirty++ } );
                            } );
                        }
                        event.target.value = '';
                    }
                }
            } else {
                showPopup();
            }
        } else {
            evalKey( event );
        }
    };

    const scrollAttention = () => {
        let chosenElem = dom.get( '.aw-list-itemFocused', lovPopup.options.popupReference.current );
        chosenElem && chosenElem.scrollIntoView && chosenElem.scrollIntoView( {
            block: 'center',
            behavior: 'smooth'
        } );
    };

    // find the index in the lovEntries array of the value of current attention
    const getAttnIndex = function() {
        let lovEntries = validEntries.current;
        if( lovEntries.length && lovPopup.open ) {
            return lovEntries.map( ( lovEntry ) => lovEntry.attn ).indexOf( true );
        }
    };

    const evalKey = function( event ) {
        let code = event.key || event.code;

        // recover _most_recent_entry when esc
        if( code === keyCode.ESCAPE && lovPopup.open ) {
            storeLatestLOVEntry( _most_recent_entry );
            prop.setLovVal( { lovEntry: _most_recent_entry } );
        }

        if( code === keyCode.TAB && lovPopup.open ) {
            // on tab, accept the current text, don't auto-complete
            if( isSelectOnly === true || lovEntryRef.current === null ) {
                //For exhaustive LOVs only hide or if for suggestive user hits tab w/o entering
                lovPopup.hide();
            }
        }
        if( code === keyCode.ARROW_UP || code === keyCode.ARROW_DOWN ) {
            event.stopPropagation();
            event.cancelBubble = true;

            if( !lovPopup.open ) {
                showPopup();
                return;
            }

            var attnIndex = getAttnIndex();
            if( attnIndex < 0 ) {
                attnIndex = selectIndex.current || _getDefaultAttention();
            }

            let lovEntries = validEntries.current;
            if( code === keyCode.ARROW_DOWN ) {
                // down arrow: move the attention down
                if( lovEntries.length > attnIndex + 1 ) {
                    lovEntries[ attnIndex ].attn = false;
                    lovEntries[ attnIndex + 1 ].attn = true;
                    selectIndex.current = attnIndex + 1;
                }
            } else {
                // up arrow
                if( attnIndex > 0 ) {
                    lovEntries[ attnIndex ].attn = false;
                    lovEntries[ attnIndex - 1 ].attn = true;
                    selectIndex.current = attnIndex - 1;
                }
            }

            // trigger UI update and scrollAttention
            dispatch( { path: 'data.dirty', value: dirty++ } );
            scrollAttention();
        }
    };

    // syncLovEntries
    const updateValidEntries = ( entries ) => {
        validEntries.current = entries || [];
    };

    const handleClick = ( event ) => {
        if( event.key === keyCode.ENTER || event.type === 'click' ) {
            event.stopPropagation();
            event.preventDefault();
            if( !lovPopup.open ) {
                showPopup( true );
            } else {
                lovPopup.hide();
            }
        }
    };

    if( prop.parentSelected === undefined && parentSelectedHandled === true ) {
        dispatch( { path: 'data.parentSelectedHandled', value: undefined } );
    }
    if( prop.parentSelected && parentSelectedHandled === undefined ) {
        handleClick( event );
        dispatch( { path: 'data.parentSelectedHandled', value: true } );
    }

    let uiValue = field.fielddata.uiValue;
    let classes = [];
    let DATE_TYPES = [ 'DATETIME', 'DATEARRAY', 'DATE' ];
    classes.push( getValClass( prop ) );
    let iconId = null;
    let timeClassName = '';
    if( prop.fielddata.dateApi && prop.fielddata.dateApi.isNotLov && DATE_TYPES.includes( typex ) ) {
        uiValue = prop.fielddata.dateApi.timeValue;
        iconId = 'cmdTime';
        timeClassName = 'sw-time-lov-val';
    } else {
        iconId = 'miscSortedDescending';
    }

    // If the LOV does not have any dataProvider action, then only we will consider it as client side filtering.
    // This is as per the current afx-master logic.
    // If it is checkboxArray LOV with hint 'checkboxoptionlov', then the data.searchBoxLOVFilterStr.uiValue
    // would be considered as the filterString.
    if( isCheckBoxArryLOV && fields.searchBoxLOVFilterStr && fields.searchBoxLOVFilterStr.fielddata ) {
        staticFilterStr = fields.searchBoxLOVFilterStr.fielddata.uiValue;
    } else if( !isCheckBoxArryLOV && lovEntryRef.current && lovEntryRef.current.lovEntry ) {
        staticFilterStr = lovEntryRef.current.lovEntry.filterString;
        if( isValidationErrorVisible() && !prop.isListbox && !isArrayWithValidateAction ) {
            lovEntryRef.current.lovEntry.filterString = null;
            staticFilterStr = null;
        }
    }

    const renderChildComponent = () => isCheckBoxArryLOV ? <AwPropertyCheckboxLovChild /> : <AWPropertyLovChild />;

    // listbox don't have the blank entry, hence start  with 0
    // other lovs have a blank entry, hence start with 1
    const _getDefaultAttention = () => prop.fielddata.emptyLOVEntry === false ? 0 : 1;

    const getDefaultAttention = () => {
        let lovEntries = validEntries.current;
        let defaultAttnStr = fields.searchBoxLOVFilterStr.dirty === 'true' ? fields.searchBoxLOVFilterStr.fielddata.uiValue : uiValue;
        let result = lovEntries.map( ( item ) => item.propDisplayValue ).indexOf( defaultAttnStr );
        return result > -1 ? result : _getDefaultAttention();
    };

    let getErrorLabelProp = () => {
        return { ...prop, className: 'aw-jswidgets-cbaSearch', required: false, displayErrorLabel: false, error: [ searchBoxLOVFilterStr.error ] };
    };

    let addButtonClick = ( event ) => {
        //Add button is displayed for suggestive LOV only hence when user cliks AddButton, add typed value and not from selected list
        let isAddingTypedValue = true;
        keyPressed( event, isAddingTypedValue );
    };

    let onButtonBlur = ( event ) => {
        //Check on Blur if it does not go to input ( previous to add button) element
        if( event.relatedTarget && event.relatedTarget.tagName !== 'INPUT' ) {
            lovPopup.hide();
        }
    };

    let onSearchBoxKeyDown = ( event ) => {
        // if LOV is exhaustive/suggestive, onEnter --> isAddingTypedValue = false
        let isAddingTypedValue = event.key !== keyCode.ENTER;
        keyPressed( event, isAddingTypedValue );
        // enter keyboard mode regardless of key pressed?
        // needed to pass tests atm, discuss with ux
        document.body.classList.add( 'keyboard' );
    };

    const isAddButtonDisabled = () => {
        let isDisabled = _.isEmpty( fields.searchBoxLOVFilterStr.value );
        let isValidEntry = validEntries.current !== null && validEntries.current.length > 0 && selectIndex.current !== null &&
            !_.isUndefined( validEntries.current[ selectIndex.current ].propDisplayValue );
        if( isValidEntry && fields.searchBoxLOVFilterStr.value === validEntries.current[ selectIndex.current ].propDisplayValue ) {
            isDisabled = true;
        }
        return isDisabled;
    };

    const generateContent = () => {
        let content = <AWLovList
            context={props}
            // syncLovEntries={syncLovEntries}
            blankLovEntry={blankLovEntry}
            action={action}
            lovlist='true'
            field={field}
            dataProvider={dataProvider}
            staticFilterStr={staticFilterStr}
            updateValidEntries={updateValidEntries}
            autoCorrect={autoCorrect}
            lovPopup={lovPopup}
            isCheckBoxArryLOV={isCheckBoxArryLOV}
            selectIndex={selectIndex}
            getDefaultAttention={getDefaultAttention}
            checkLovEntries={checkLovEntries}
            setlovEntry={( selLovEntry, event, op ) => { setLovEntryAndClose( selLovEntry, event, op, false ); }} >
            {
                renderChildComponent()
            }
        </AWLovList>;

        return <div className={ ( isCheckBoxArryLOV ? 'aw-checkboxarray-lovParent ' : '' ) + 'sw-lov-contentContainer' }>
            { !DATE_TYPES.includes( typex ) && isSearchable &&
                <div className={ ( _.isEmpty( searchBoxLOVFilterStr.error ) ? '' : 'sw-errorFlag ' ) + 'aw-jswidgets-cbaSearch aw-widget-iconParent sw-lov-textbox-container sw-noDirtyStyle' }>
                    <AwTextBoxVal { ...Object.assign( {}, fields.searchBoxLOVFilterStr, { autocomplete: 'off', autocorrect: 'off', autocapitalize: 'off' } ) }
                        { ...generateFilterProps }>
                    </AwTextBoxVal>
                    { isSelectOnly || isCheckBoxArryLOV ? <AwIcon iconId='cmdSearch' className='aw-widget-icon'></AwIcon> :
                        <AwButton onBlur={ onButtonBlur } className={ isAddButtonDisabled() ? 'disabled' : '' } action={addButtonClick}>{ props.i18n.ADD_BUTTON_TITLE }</AwButton> }
                </div>}
            { !_.isEmpty( searchBoxLOVFilterStr.error ) && <AwPropertyLabel { ...getErrorLabelProp() }></AwPropertyLabel> }
            { content }
        </div>;
    };

    const hasUserTypedAValue = () => {
        return lovEntryRef.current && lovEntryRef.current.lovEntry &&
            ( lovEntryRef.current.lovEntry.filterString || typeof lovEntryRef.current.lovEntry.propInternalValue === 'string' );
    };

    const getValueIfUserTypedTime = () => hasUserTypedAValue() ? uiValue : '';

    const generateDateArrayLOVContent = () => {
        let { ...restGeneratedProps } = generateProps;
        let dateProps = {
            onClick: handleClick,
            onChange: onChangeHandler,
            dirty: prop.dirty,
            onKeyDown: keyPressed
        };
        let allProps = { ...restGeneratedProps, ...dateProps };

        return isValidationErrorVisible() && !prop.isListbox ?
            <input {...allProps} value={uiValue} /> :
            <input {...allProps} value={field.fielddata.isArray ? getValueIfUserTypedTime() : uiValue} />;
    };

    // lov select field
    const generateProps = {
        'aria-label': prop.label,
        'data-locator': prop.label,
        'aria-required': prop.isRequired,
        className: classes.join( ' ' ),
        onBlur: onBlurHandler,
        type: 'text',
        placeholder: field.placeholder,
        ref: lovPopup.reference,
        dirty: prop.dirty,
        onClick: handleClick,
        onKeyDown: keyPressed,
        disabled: prop.disabled
    };

    // lov filter field
    // TODO: i18n on placeholder and use unique label/locator
    const generateFilterProps = {
        'aria-label': prop.label,
        'data-locator': prop.label,
        className: classes.join( ' ' ),
        onSwChange: onFilterChangeHandler,
        type: 'text',
        placeholder: isSelectOnly ? 'Search' : 'Search or Create',
        ref: lovPopup.reference,
        dirty: false,
        onKeyDown: onSearchBoxKeyDown,
        disabled: prop.disabled
    };

    return (
        <div className='sw-lov-container'>
            <AwPic className='sw-lov-thumb' iconId={field.fielddata.iconName} source={field.fielddata.iconSource}></AwPic>

            { DATE_TYPES.includes( typex ) && generateDateArrayLOVContent() }
            { !DATE_TYPES.includes( typex ) && <input  {...generateProps} value={ isArray && !isCheckBoxArryLOV ? null : uiValue} /> }

            <div className={ prop.disabled ? 'sw-widget-iconContainer disabled' : 'sw-widget-iconContainer' } role='button' aria-label={prop.name} tabIndex='-1' onKeyDown={keyPressed} onClick={handleClick}>
                <AwIcon iconId={iconId} className={'aw-widget-icon ' + timeClassName}></AwIcon>
            </div>
            <AwPopup {...lovPopup.options} className='sw-lov-popup'> {generateContent()}</AwPopup>
        </div>
    );
};

export const onMount = ( prop, elementRefList ) => {
    let field = prop.fielddata;
    const hint = field.renderingHint;
    const isCheckBoxArryLOV = hint === 'checkboxoptionlov';

    let values = prop.value;
    if( isCheckBoxArryLOV ) {
        let checkLovEntries = elementRefList.get( 'checkLovEntries' );
        checkLovEntries.current = {};

        if( values && values.length > 0 ) {
            // we create placeHolders based on the default prop values
            // generate place-holder array for selected values that may or may not be loaded
            checkLovEntries.current = _.reduce( values, ( result, value, inx ) => {
                let disp = field.uiValues[ inx ] || field.displayValues[ inx ] || value;
                let item = {
                    propDisplayValue: disp,
                    propInternalValue: value,
                    isChecked: true
                };
                let key = _.isObject( value ) ? disp : value;
                result[ key ] = item;
                return result;
            }, {} );
        }
    }
};

// clear internal states when prop value was cleared
export const updateCheckLovEntries = ( prop, elementRefList ) => {
    let field = prop.fielddata;
    const hint = field.renderingHint;
    const isCheckBoxArryLOV = hint === 'checkboxoptionlov';

    if( isCheckBoxArryLOV ) {
        let checkLovEntries = elementRefList.get( 'checkLovEntries' );
        let values = prop.value;

        // clear case
        if( !values || values.length === 0 ) {
            checkLovEntries.current = {};
        }

        // async set initial values
        if( values.length > 0 ) {
            if( !checkLovEntries.current ) { checkLovEntries.current = {}; }
            let checked = checkLovEntries.current;

            // update checkLovEntries based on values,
            // case application set the values programly
            _.reduce( values, ( result, value, inx ) => {
                let disp = field.uiValues[ inx ] || field.displayValues[ inx ] || value;
                let key = _.isObject( value ) ? disp : value;
                if( !checked[ key ] ) {
                    checked[ key ] = {
                        propDisplayValue: disp,
                        propInternalValue: value,
                        isChecked: true
                    };
                }
            }, {} );
        }
    }
};
