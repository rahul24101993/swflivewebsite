// Copyright (c) 2020 Siemens
import _ from 'lodash';
import eventBus from 'js/eventBus';
import fileSvc from 'js/awFileService';
import AwFileUploadLabel from 'viewmodel/AwFileUploadLabelViewModel';
import AwPopup from 'viewmodel/AwPopupViewModel';
import AwPic from 'viewmodel/AwPicViewModel';
import domUtils from 'js/domUtils';

const domApis = domUtils.DOMAPIs;
var fileLabelElement;
var fileNameElement;
var fileNameElementAfterFileUploaded;
var classesForFileLabelElementFocus = [
    'aw-file-uploadFocus',
    'aw-file-uploadFileLabelFocus'
];
var classesForFileNameElementFocus = [
    'aw-file-uploadFocus',
    'aw-file-uploadFileNameFocus'
];

const addStyleToElem = elem => {
    elem.classList.add( 'aw-widgets-dropframe' );
    elem.classList.add( 'aw-theme-dropframe' );
};

const removeStyleFromElem = elem => {
    elem.classList.remove( 'aw-widgets-dropframe' );
    elem.classList.remove( 'aw-theme-dropframe' );
};

const highlightWidget = ( eventData ) => {
    if( !_.isUndefined( eventData ) && !_.isUndefined( eventData.targetElement ) && eventData.targetElement.classList ) {
        let isHighlightFlag = eventData.isHighlightFlag;
        let target = eventData.targetElement;
        if( target.classList.contains( 'aw-widgets-chooseordropfile' ) ) {
            if( isHighlightFlag ) {
                addStyleToElem( target );
            } else {
                removeStyleFromElem( target );
            }
        }
    }
};

export const handleViewFileSelection = function( props, data ) {
    const { dispatch } = data;
    const { selectionData } = props;

    if( selectionData.value && selectionData.value.files ) {
        const updatedFileChosen = {
            now: true,
            uploadModelProviderSelected: true,
            _attachedFiles: selectionData.value.files
        };
        dispatch( { path: 'data.fileChosen', value: updatedFileChosen } );
    }
};

export const awFileUploadRenderFunction = ( {
    viewModel,
    i18n,
    removeTooltip,
    fileChangeAction,
    typeFilter,
    multiple,
    dndHandler,
    formData,
    chooseFileName,
    uploadModel,
    selectionData,
    actions,
    elementRefList
} ) => {
    let { providerPopup, customViewPopup } = actions;
    const { data, dispatch } = viewModel;

    const providerPopupRef = elementRefList.get( 'providerPopupRef' );
    const customViewPopupRef = elementRefList.get( 'customViewPopupRef' );

    if( uploadModel && uploadModel.length > 1 ) {
        uploadModel = _.sortBy( uploadModel, [ 'priority' ] );
    }

    let attachedFiles;
    let attachedFile = [];
    if( formData instanceof FormData ) {
        for( var value of formData.values() ) {
            attachedFile.push( value );
        }
    }
    if( !multiple && formData instanceof FormData && attachedFile.length > 0 ) {
        attachedFiles = formData;
        data.fileChosen.now = true;
        let fileExt = fileSvc.getFileExtension( attachedFile[ 0 ].name );
        if( fileExt !== '' ) {
            fileExt = _.replace( fileExt, '.', '' );
        }
        let validFile = fileSvc.fileMatchTypes( typeFilter, fileExt );
        if( !validFile ) {
            eventBus.publish( 'invalidFileSelected', {} );
            dispatch( { path: 'data.fileChosen', value: { now: false, uploadModelProviderSelected: false } } );
        }
    } else {
        attachedFiles = data.fileChosen._attachedFiles ? data.fileChosen._attachedFiles : new FormData();
    }
    data.fileChosen._attachedFiles = attachedFiles;

    // ChangeEvent<HTMLInputElement>
    const updateData = ( files, isAppend ) => {
        let validFile = true;
        if( files.length > 0 ) {
            let fileNames = [];
            let fileNameNoExts = [];
            let fileExts = [];
            let fileInputForms = [];
            files.forEach( fileItem => {
                let fileName = fileItem.name;
                let fileNameNoExt = fileSvc.getFileNameWithoutExtension( fileName );
                let fileExt = fileSvc.getFileExtension( fileName );
                if( fileExt !== '' ) {
                    fileExt = _.replace( fileExt, '.', '' );
                }
                validFile = fileSvc.fileMatchTypes( typeFilter, fileExt );
                fileNames.push( fileName );
                fileNameNoExts.push( fileNameNoExt );
                fileExts.push( fileExt );
                fileInputForms.push( { selectedFile: fileName, file: fileItem } );
            } );
            if( !multiple ) {
                if( !validFile ) {
                    eventBus.publish( 'invalidFileSelected', {} );
                    dispatch( { path: 'data.fileChosen', value: { now: false, uploadModelProviderSelected: false } } );
                }
                data.formData = new FormData();
                data.formData.append( 'fmsFile', files[ 0 ] );
                data.fileInputForms = data.formData;
                data.fileName = fileNames[ 0 ];
                data.fileNameNoExt = fileNameNoExts[ 0 ];
                data.fileExt = fileExts[ 0 ];
            } else {
                data.fileName = data.fileName && isAppend ? [ ...data.fileName, ...fileNames ] : fileNames;
                data.fileNameNoExt = data.fileNameNoExt && isAppend ? [ ...data.fileNameNoExt, ...fileNameNoExts ] : fileNameNoExts;
                data.fileExt = data.fileExt && isAppend ? [ ...data.fileExt, ...fileExts ] : fileExts;
                data.fileInputForms = data.fileInputForms && isAppend ? [ ...fileInputForms, ...data.fileInputForms ] : fileInputForms;
            }
            data.validFile = validFile;
            data.fileChosen.now = true;
            if( validFile && data.fileChosen.uploadModelProviderSelected ) {
                attachedFiles = new FormData();
            }
            dispatch( { path: 'data.fileChosen', value: { now: true, uploadModelProviderSelected: false } } );

            const fileInfo = {
                fileName: data.fileName,
                fileNameNoExt: data.fileNameNoExt,
                validFile: data.validFile,
                fileExt: data.fileExt,
                formData: data.fileInputForms
            };

            // call action when file selection changed, inputData : {{ data.formData}}
            if( fileChangeAction ) {
                fileChangeAction( fileInfo );
            }
            if( selectionData ) {
                // Required model info & file info updates
                const updateInfo = selectionData.value;
                updateInfo.selectedFileInfo = fileInfo;
                if ( _.isEmpty( updateInfo.modelInfo ) && uploadModel && uploadModel.length > 0 ) {
                    updateInfo.modelInfo = uploadModel[0];
                }
                selectionData.update( updateInfo );
            }
        } else {
            const fileInfo = {
                fileName: undefined,
                fileNameNoExt: undefined,
                validFile: undefined,
                fileExt: undefined,
                formData: undefined
            };
            if( fileChangeAction ) {
                fileChangeAction( fileInfo );
            }
            if( selectionData ) {
                // Required model info & file info updates
                const updateInfo = selectionData.value;
                updateInfo.modelInfo = undefined;
                updateInfo.selectedFileInfo = fileInfo;
                selectionData.update( updateInfo );
            }
        }
        return validFile;
    };

    let typesSet = null;

    if( typeFilter && '*' !== typeFilter && '.' !== typeFilter ) {
        typesSet = new Set( typeFilter.split( ',' ).map( item => {
            const validFileExt = item.trim();
            return _.replace( validFileExt.toLowerCase(), '.', '' );
        } ) );
    }

    const allFileMatchTypes = ( items ) => {
        if( !typesSet ) {
            return true;
        }
        let allMatched = true;
        const fileItemsArray = Array.from( items );
        fileItemsArray.forEach( fileItem => {
            let fileExt = fileSvc.getFileExtension( fileItem.name );
            if( fileExt !== '' ) {
                fileExt = _.replace( fileExt, '.', '' );
            }
            if( !typesSet.has( fileExt.toLowerCase() ) ) {
                allMatched = false;
            }
        } );
        return allMatched;
    };

    // ChangeEvent<HTMLInputElement>
    const handleFileChange = ( e ) => {
        const files = e.target.files;
        let filesArr = Array.from( files );
        updateAttachedFiles( filesArr );
        e.target.value = '';
    };

    // ClickEvent<HTMLInputElement>
    const handleClick = ( e ) => {
        if( uploadModel ) {
            let providerPopupToDisplay = true;
            // By default if there is a single configuration without popupViewId then the local file selection is invoked.
            if( uploadModel.length === 1 && !uploadModel[ 0 ].popupViewId ) {
                providerPopupToDisplay = false;
                if( selectionData ) {
                    // Required model info update
                    selectionData.value.modelInfo = uploadModel[ 0 ];
                }
            }

            if( providerPopupToDisplay ) {
                const inputElement = providerPopupRef.current;
                const isUploadModelOptionClick = inputElement.getAttribute( 'isUploadModelOptionClick' );
                if( !isUploadModelOptionClick ) {
                    e.preventDefault();

                    // case click or enter
                    providerPopup.show( {
                        reference: inputElement,
                        width: inputElement.offsetWidth,
                        className: 'sw-lov-popup'
                    } );
                } else {
                    domApis.removeAttribute( inputElement, 'isUploadModelOptionClick' );
                    providerPopup.hide();
                }
            }
        }
    };

    const handleUploadModelOptionSelect = ( e, model ) => {
        if( model.name && model.popupViewId ) {
            e.preventDefault();

            customViewPopup.show( {
                reference: customViewPopupRef.current,
                view: model.popupViewId,
                subPanelContext: {
                    selectionData: selectionData,
                    ...model
                },
                caption: model.caption
            } );

            providerPopup.hide();
        } else {
            if( selectionData ) {
                // Required model info update
                selectionData.value.modelInfo = model;
            }
            const inputElement = providerPopupRef.current;
            domApis.setAttribute( inputElement, 'isUploadModelOptionClick', true );
            inputElement.click();
        }
    };

    // KeyDownEvent<HTMLInputElement>
    const handleUploadModelOptionKeyDown = ( e, optionName ) => {
        if( e.key && ( e.key === 'Enter' || e.key === ' ' ) ) {
            handleUploadModelOptionSelect( e, optionName );
        }
    };

    const isFileUploadWidgetFocused = () => {
        let fileInputElement = document.getElementsByClassName( 'aw-file-upload-fileInput' );
        if( fileInputElement && fileInputElement.length > 0 ) {
            return document.activeElement === fileInputElement[ 0 ];
        }
        return false;
    };

    const handleFocus = () => {
        fileLabelElement = document.getElementsByClassName( 'aw-file-upload-fileLabel' );
        if( fileLabelElement && fileLabelElement.length > 0 ) {
            fileLabelElement[ 0 ].classList.add( ...classesForFileLabelElementFocus );
        }

        fileNameElement = document.getElementsByClassName( 'aw-file-upload-fileName' );
        if( fileNameElement && fileNameElement.length > 0 ) {
            fileNameElement[ 0 ].classList.add( ...classesForFileNameElementFocus );
        }
    };

    const handleBlur = () => {
        if( fileLabelElement && fileLabelElement.length > 0 ) {
            fileLabelElement[ 0 ].classList.remove( ...classesForFileLabelElementFocus );
        }
        if( fileNameElement && fileNameElement.length > 0 ) {
            fileNameElement[ 0 ].classList.remove( ...classesForFileNameElementFocus );
        }

        fileNameElementAfterFileUploaded = document.getElementsByClassName( 'file-upload-selected-file' );
        if( fileNameElementAfterFileUploaded && fileNameElementAfterFileUploaded.length > 0 ) {
            fileNameElementAfterFileUploaded[ 0 ].classList.remove( ...classesForFileNameElementFocus );
        }
    };

    const getClassesAfterFileUpload = () => {
        if( isFileUploadWidgetFocused() ) {
            return 'aw-file-upload-fileName '
                .concat( 'file-upload-selected-file ' )
                .concat( 'aw-file-uploadFocus ' )
                .concat( 'aw-file-uploadFileNameFocus' );
        }
        return 'aw-file-upload-fileName '
            .concat( 'file-upload-selected-file' );
    };

    const refreshFileListInfo = ( isChosen ) => {
        dispatch( { path: 'data.fileChosen', value: { now: isChosen, uploadModelProviderSelected: false, _attachedFiles: attachedFiles } } );
    };

    // Deletes file from attachedFiles list
    const deleteFile = ( name ) => {
        let fileNames = data.fileName;
        if( _.isArray( fileNames ) ) {
            let indxToRemove = fileNames.indexOf( name );
            data.fileName.splice( indxToRemove, 1 );
            data.fileNameNoExt.splice( indxToRemove, 1 );
            data.fileInputForms.splice( indxToRemove, 1 );
            data.fileExt.splice( indxToRemove, 1 );
        }
        attachedFiles.delete( name );
    };

    /**
     * @param { File[] } files - files
     * @return {File[] } resultFiles
     */
    const filterTypes = function( files ) {
        let allMatchedType = true;

        if( !typesSet ) {
            return files;
        }
        const resultFiles = files.filter( file => {
            const fileTypes = file.name.split( '.' );
            // in case of 1.x.dat
            const fileType = fileTypes[ fileTypes.length - 1 ];
            if( !multiple || typesSet.has( fileType ) ) {
                return true;
            }
            allMatchedType = false;
            return false;
        } );
        if( !allMatchedType ) {
            eventBus.publish( 'invalidFileSelected', {} );
        }
        return resultFiles;
    };

    /**
     *
     * @param { File[] } filesArray - array of files to be uploaded
     * @param { Boolean } isAppend - isAppend
     */
    const updateAttachedFiles = ( filesArray, isAppend = true ) => {
        updateData( filesArray, isAppend );
        const typeFilterFiles = filterTypes( filesArray );
        if( !multiple && typeFilterFiles.length > 0 ) {
            //If single mode and typeFilterFiles are valid , delete existing file before updating
            for( var file of attachedFiles.values() ) {
                deleteFile( file.name );
            }
        }
        typeFilterFiles.forEach( ( file ) => {
            attachedFiles.set( file.name, file );
        } );
        refreshFileListInfo( true );
    };

    const handleImplicitFilesAttachment = e => {
        if( fileSvc.dataTransferContainsFiles( e ) && allFileMatchTypes( e.dataTransfer.files ) ) {
            const filesArray = Array.from( e.dataTransfer.files );
            updateAttachedFiles( filesArray );
        }
    };

    const callbackAPIs = {
        highlightTarget: highlightWidget,
        updateFileData: handleImplicitFilesAttachment,
        getTargetElementAndVmo: ( event ) => {
            let targetVMO = null;
            let target = event.currentTarget;
            return {
                targetElement: target,
                targetVMO: targetVMO
            };
        }
    };

    //DragEvent<HTMLElement>
    const handleDrop = ( e ) => {
        let targetEle = e.currentTarget;
        // logic of applying DnD style on element and DnD cursor change is assumed to be implicit functionalities
        // hence NOT leaving it to contributed handlers to implement it
        removeStyleFromElem( targetEle );
        if( e.dataTransfer ) {
            e.dataTransfer.dropEffect = 'none';
            e.preventDefault();
        }
        handleDrag( false );

        if( dndHandler && dndHandler[ e.type ] ) {
            let fun = dndHandler[ e.type ];
            fun( e, { targetElement: targetEle, targetVMO: null }, callbackAPIs );
        } else {
            handleImplicitFilesAttachment( e );
        }
    };
    const handleClickDeselect = ( e, name ) => {
        if( !data.fileChosen.uploadModelProviderSelected ) {
            e.preventDefault();
            deleteFile( name );
            updateAttachedFiles( getAttachedFiles(), false );
        } else {
            const currentAttachedFiles = data.fileChosen._attachedFiles;
            const index = currentAttachedFiles.findIndex( ( file ) => file.name === name );
            currentAttachedFiles.splice( index, 1 );
            if( currentAttachedFiles.length === 0 ) {
                updateData( [], false );
            }
            dispatch( { path: 'data.fileChosen', value: { now: true, uploadModelProviderSelected: true, _attachedFiles: currentAttachedFiles } } );
        }
    };

    const getAttachedFiles = () => {
        let attachedFileArray = [];
        for( var value of attachedFiles.values() ) {
            attachedFileArray.push( value );
        }
        return attachedFileArray;
    };

    // set Dragger highlight when over: boolean
    const handleDrag = ( over ) => {
        dispatch( { path: 'data.isDragOn', value: over } );
    };

    const fileDragOver = ( e ) => {
        let targetEle = e.currentTarget;
        // logic of applying DnD style on element and DnD cursor change is assumed to be implicit functionalities
        // hence NOT leaving it to contributed handlers to implement it
        addStyleToElem( targetEle );
        e.preventDefault();
        e.stopPropagation();

        if( dndHandler && dndHandler[ e.type ] ) {
            let fun = dndHandler[ e.type ];
            fun( e, { targetElement: targetEle, targetVMO: null }, callbackAPIs );
        }
    };
    // clear the drag style after drop or drop leave
    /**
     * @param {DragEvent<HtmlElement>} e : the drag event
     */
    const fileDragLeave = e => {
        let targetEle = e.currentTarget;
        // logic of applying DnD style on element and DnD cursor change is assumed to be implicit functionalities
        // hence NOT leaving it to contributed handlers to implement it
        removeStyleFromElem( targetEle );
        if( e.dataTransfer ) {
            e.dataTransfer.dropEffect = 'none';
            e.preventDefault();
        }
        handleDrag( false );
        if( dndHandler && dndHandler[ e.type ] ) {
            let fun = dndHandler[ e.type ];
            fun( e, { targetElement: targetEle, targetVMO: null }, callbackAPIs );
        }
    };

    let filesToDisp = getAttachedFiles();
    return (
        <div className = 'aw-file-upload-container aw-file-upload-initial aw-widgets-chooseordropfile' onDragOver = { e => fileDragOver( e )}
            onDragLeave={e => { fileDragLeave( e ); } } onDrop={handleDrop}>
            <div className = 'sw-row'>
                <div className = 'aw-file-upload-fileLabel' ref={customViewPopupRef}>  { chooseFileName ? chooseFileName : i18n.ChooseFile } </div>
                { filesToDisp && filesToDisp.length === 0 && !multiple && <div className='aw-file-upload-fileName'> { i18n.singleUpload } </div> }
                {  multiple && <div className='aw-file-upload-fileName'> { i18n.multipleUpload } </div> }
                { filesToDisp && filesToDisp.length > 0 && data.fileChosen.now && !multiple && <div onDrop={handleDrop} className={ getClassesAfterFileUpload() }>
                    <AwFileUploadLabel removeTooltip={removeTooltip} key={filesToDisp[0].name} item={filesToDisp[0]} removeFileHandler={handleClickDeselect}/>
                </div> }
                <input ref={providerPopupRef} data-locator='aw-fileUpload' multiple =  { multiple } className = 'aw-file-upload-fileInput' type='file'  accept = { typeFilter }
                    onChange={ handleFileChange } onClick={ handleClick } title={filesToDisp && filesToDisp[0] && filesToDisp[0].name} onFocus={ handleFocus } onBlur={ handleBlur }
                />
                { providerPopup.open && <AwPopup {...providerPopup.options}>
                    <div className='aw-base-scrollPanel'>
                        <ul role='listbox' tabIndex={0}  className='sw-column'>
                            { uploadModel.map( ( model ) => {
                                return <li role='option' aria-selected='false' key={model.name} tabIndex={-1}
                                    onClick={( e ) => handleUploadModelOptionSelect( e, model ) }
                                    onKeyDown={( e ) => handleUploadModelOptionKeyDown( e, model.name ) }>
                                    <div className='sw-aria-border aw-widgets-cellListItem aw-widgets-cellTop'>
                                        <div className='sw-row sw-component'>
                                            <AwPic className='aw-widget-thumbnail' iconId={model.iconName} source={model.iconName}></AwPic>
                                            <div className='sw-cell-valName' title={model.name}>{model.name}</div>
                                        </div>
                                    </div>
                                </li>;
                            } )}
                        </ul>
                    </div>
                </AwPopup> }
                {
                    customViewPopup.open && <AwPopup {...customViewPopup.options} />
                }
            </div>
            {
                multiple && filesToDisp && filesToDisp.length > 0 &&
                    <ul className = 'aw-upload-list-items'>
                        {
                            filesToDisp.map( item=>{
                                return (
                                    <li className = 'sw-flex-row' key={item.name}>
                                        <AwFileUploadLabel removeTooltip={removeTooltip}  item={item} removeFileHandler={handleClickDeselect}></AwFileUploadLabel>
                                    </li>
                                );
                            } )
                        }
                    </ul>
            }
        </div>
    );
};
