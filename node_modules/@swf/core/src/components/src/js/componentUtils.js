// Copyright (c) 2020 Siemens
import { DerivedStateResult } from 'js/derivedContextService';

/**
 * DEPRECATED: no longer needed since components inherit class automatically now. Only used in a few rare cases
 * where class propagation was skipping a level. This is not best-practice and should be fixed too.
 *
 * Constructs component classes. Need a new name since component already means something else in terms of layout.
 * In this context, this is just an swf/react component (could be section, component, or element)...
 * All swf components should inherit class from their view element
 * @param {String} className class to use on component
 * @param {Object} prop property vm
 * @returns {String} ready to use classe names
 */
export function getCompClass( className, prop ) {
    let classes = [];

    if( className ) {
        classes.push( className );
    }
    if( prop.className ) {
        classes.push( prop.className );
    }

    return classes.join( ' ' );
}

/**
 * Constructs property widget classes for properties.
 * Look at property vmo and set appropriate classes
 * @param {String} className any additional class to use on this property
 * @param {Object} prop property vm
 * @returns {String} ready to use classe names
 */
export function getPropClass( className, prop ) {
    let classes = [ 'sw-property', 'sw-component' ];

    if( className ) {
        classes.unshift( className );
    }

    if( prop.className ) {
        classes.push( prop.className );
    }

    const isEnabled = prop.fielddata.isEnabled;
    const isEditable = prop.fielddata.isEditable;
    const modifiable = prop.modifiable;
    const hint = prop.fielddata.renderingHint;

    if( prop.fielddata.labelPlacement === 'default' ) {
        prop.fielddata.labelPlacement = isEditable === false || modifiable === false ? 'start' : 'top';

        // override for special-cases
        if( isEditable && prop.typex === 'BOOLEAN' || hint === 'radiobutton' ) {
            if( hint === 'radiobutton' || hint === 'togglebutton' ) {
                prop.fielddata.labelPlacement = 'start';
            } else {
                // reverse label/val order for editable checkbox
                prop.fielddata.labelPlacement = 'end';
            }
        }
    }

    if( isEditable && prop.typex === 'BOOLEAN' || hint === 'radiobutton' || hint === 'togglebutton' || hint === 'checkbox' ) {
        // used to align label with value
        classes.push( 'sw-nonText' );
    }

    // apply label position - by default, it is top
    if( !classes.includes( 'sw-column' ) && !classes.includes( 'sw-row' ) ) {
        if( prop.fielddata.labelPlacement === 'end' ) {
            classes.push( 'sw-reverse sw-row' );
        } else if( prop.fielddata.labelPlacement === 'start' ) {
            classes.push( 'sw-row' );
        } else if( prop.fielddata.labelPlacement === 'none' ) {
            classes.push( 'sw-hideLabelName' );
        }
    }

    // special-case sizing
    if( prop.typex === 'BOOLEAN' ) {
        classes.push( 'sw-autoSize' );
    }

    if( isEditable === false || modifiable === false || hint === 'label' ) {
        classes.push( 'sw-readOnly' );
        //prop.fielddata.disabled = true;
    } else if( isEnabled === false ) {
        // only set disabled on the prop level if it's editable. (disabled will still get set on the input)
        classes.push( 'sw-disabled' );
    }

    if( prop.error && prop.error.length > 0 ) {
        classes.push( 'sw-errorFlag' );
    }

    return classes.join( ' ' );
}

/**
 * Constructs property val classes.
 * @param {Object} prop property vm
 * @returns {String} ready to use classe names
 */
export function getValClass( prop ) {
    let classes = [ 'sw-property-val' ];
    if( ( prop.dirty === 'true' || prop.dirty === true ) && prop.fielddata.isEditable ) {
        classes.push( 'sw-changed' );
    }
    return classes.join( ' ' );
}

/**
 * A version of getValClass that uses derived state to improve performance
 *
 * @param {Object} vmDef View model
 * @param {Object} prop Current properties
 * @returns {[DerivedStateResult]} Derived state configurations
 */
export const getValClassMemo = ( vmDef, prop ) => {
    return [ new DerivedStateResult( {
        ctxParameters: [],
        additionalParameters: [ prop.dirty ],
        compute: ( renderContext, isDirty ) => {
            let classes = [ 'sw-property-val' ];
            if( isDirty === 'true' || isDirty === true ) {
                classes.push( 'sw-changed' );
            }
            return classes.join( ' ' );
        }
    } ) ];
};

/**
 * Get list item classes for aw-list
 * @param {Boolean} isSelectionEnabled true/false
 * @param {Boolean} isGroupList true/false
 * @param {Boolean} fixedCellHeight true/false
 * @returns {String} classes
 */
export function getListItemClasses( selected, isSelectionEnabled, isGroupList, fixedCellHeight, isFocused, selectionModelActivated ) {
    let classes = [ 'sw-aria-border aw-widgets-cellListItem aw-widgets-cellTop' ];
    if( selected ) {
        classes.push( 'aw-widgets-cellListItemSelected' );
    }
    if( isFocused ) {
        classes.push( 'aw-list-itemFocused' );
    }
    if( !isSelectionEnabled ) {
        classes.push( 'aw-widgets-hideCellListSelEffect' );
    }
    if( isGroupList ) {
        classes.push( 'aw-widgets-groupCellListItem' );
    }
    if( fixedCellHeight ) {
        classes.push( 'aw-widgets-fixedCellHeight' );
    }
    if( selected && !selectionModelActivated ) {
        classes.push( 'aw-widgets-cellListItemInactivated' );
    }
    return classes.join( ' ' );
}
