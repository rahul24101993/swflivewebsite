// Copyright (c) 2021 Siemens
import { includeComponent } from 'js/moduleLoader';
import _ from 'lodash';
import logger from 'js/logger';
import eventBus from 'js/eventBus';
import AwIconButton from 'viewmodel/AwIconButtonViewModel';
import AwIcon from 'viewmodel/AwIconViewModel';
import AwInclude from 'viewmodel/AwIncludeViewModel';
import sidenavService from './AwSidenavHelperService';
import appCtx from 'js/appCtxService';
import narrowModeSvc from 'js/aw.narrowMode.service';
import wcagSvc from 'js/wcagService';

var hasConfigChanged = false;
let _ongoing = {};
let sidenavConfig = {};
let ctxPath = 'awSidenavConfig.globalSidenavContext.';

const MOBILE = 'mobile';
const DESKTOP = 'desktop';
const TABLET = 'tablet';

var configProperties = {
    large: 'LARGE',
    default: 'DEFAULT',
    full: 'FULL',
    standard: 'STANDARD',
    wide: 'WIDE',
    extraWide: 'EXTRAWIDE',
    doubleWide: 'DOUBLEWIDE',
    float: 'FLOAT',
    push: 'PUSH',
    right_to_left: 'RIGHT_TO_LEFT',
    left_to_right: 'LEFT_TO_RIGHT',
    isPinUnpinEnabled: false,
    isFloatPanel: function( id ) {
        return sidenavConfig[ id ].slide === this.float;
    },
    isPushPanel: function( id ) {
        return sidenavConfig[ id ].slide === this.push;
    },
    isDefaultHeightPanel: function( id ) {
        return sidenavConfig[ id ].height === this.default;
    },
    isFullHeightPanel: function( id ) {
        return sidenavConfig[ id ].height === this.full;
    },
    isLargeHeightPanel: function( id ) {
        return sidenavConfig[ id ].height === this.large;
    },
    isWideWidthPanel: function( id ) {
        return sidenavConfig[ id ].width === this.wide;
    },
    isStandardWidthPanel: function( id ) {
        return sidenavConfig[ id ].width === this.standard;
    },
    isHeightWidthEqual: function( id ) {
        return sidenavConfig[ id ].width === sidenavConfig[ id ].height;
    },
    getSidenavMode: function( id ) {
        let mode = DESKTOP;
        if( sidenavConfig[ id ].width === this.standard ) {
            mode = MOBILE;
        } else if( sidenavConfig[ id ].width === this.wide || sidenavConfig[ id ].width === this.extraWide || sidenavConfig[ id ].width === this.doubleWide ) {
            mode = TABLET;
        }

        return mode;
    }
};
export const copyRef = ( params ) => {
    return params.get( 'sideNavInfo' );
};
const patchVMData = ( vm, updatedData ) => {
    vm.dispatch( {
        path: 'data.config',
        value: updatedData
    } );
};

let setSidenavInitialData = ( vm, prop ) => {
    let dataToUpdate = { ...vm.data.config };

    if( vm.data.config.id !== prop.id ) {
        dataToUpdate.id = prop.id;
        sidenavConfig[ prop.id ] = {};
    }

    if( vm.data.config.isPinnable === null || vm.data.config.isPinnable === undefined ) {
        dataToUpdate.isPinnable = prop.config.isPinnable || false;
    }

    if( vm.data.config.isPinUnpinEnabled === null || vm.data.config.isPinUnpinEnabled === undefined ) {
        dataToUpdate.isPinUnpinEnabled = prop.config.isPinUnpinEnabled || false;
    }

    if( vm.data.config.panelPinned === null || vm.data.config.panelPinned === undefined ) {
        dataToUpdate.panelPinned = prop.config.panelPinned || false;
    }

    if( !vm.data.config.slide ) {
        dataToUpdate.slide = prop.config.slide;
    }

    if( !_.isEqual( vm.data.config, dataToUpdate ) ) {
        patchVMData( vm, dataToUpdate );
    }
};

let resetConfigStatus = () => {
    hasConfigChanged = false;
};

// called on unMount
export let clearSidenav = ( data ) => {
    var sidenavCmdId = appCtx.getCtx( 'sidenavCommandId' );
    if( sidenavCmdId && sidenavCmdId === data.currentCommandId ) {
        appCtx.unRegisterCtx( 'sidenavCommandId' );
    }
    resetConfigStatus();
    appCtx.updatePartialCtx( ctxPath + data.id, null );
    // Once the page level component hosting the sidenav is destroyed , it ought to be
    // SideNav's responsibility to also deregister the attributes from ctx it registered when the sidenav mounted
    appCtx.unRegisterCtx( 'activeToolsAndInfoCommand' );
    appCtx.unRegisterCtx( 'activeNavigationCommand' );
};

export let togglePinState = ( data ) => {
    if( data.isPinnable ) {
        let config = { ...data };
        sidenavService.togglePinState( config );
        return config;
    }
};

export let togglePinUnpinPanelState = ( data ) => {
    let config = { ...data };
    sidenavService.togglePinUnpinPanelState( config );
    return config;
};

var setDefaultConfig = function( prop ) {
    const { viewModel } = prop;
    setSidenavInitialData( viewModel, prop );

    if( hasConfigChanged ) {
        return;
    }

    let updatedConfig = {};

    // default placeholder height and width values
    updatedConfig.width = prop.config.width || configProperties.standard;
    updatedConfig.height = prop.config.height || configProperties.full;
    updatedConfig.isPinnable = prop.config.isPinnable || false;
    updatedConfig.isPinUnpinEnabled = prop.config.isPinUnpinEnabled || false;
    updatedConfig.panelPinned = prop.config.panelPinned || false;
    updatedConfig.direction = prop.config.direction || configProperties.left_to_right;
    updatedConfig.slide = prop.config.slide;
    updatedConfig.animation = prop.config.animation !== false;

    if( configProperties.isDefaultHeightPanel( prop.id ) ) {
        updatedConfig.height = updatedConfig.width;
    }
    // push panels will always be full height
    if( configProperties.isPushPanel( prop.id ) ) {
        updatedConfig.height = configProperties.full;
    }
    updatedConfig.isAnimationDisabled = !updatedConfig.animation;
    updatedConfig.isLeftToRight = updatedConfig.direction === configProperties.left_to_right;

    if( !_.isEqual( updatedConfig, sidenavConfig[ prop.id ] ) ) {
        sidenavConfig[ prop.id ] = updatedConfig;
    }
};
export let createSideNavInfo = ( sideNavInfo ) => {
    if( sideNavInfo ) {
        sideNavInfo.current = {
            sideNavFocused: false
        };
    }
    return sideNavInfo;
};
export let sideNavOpenCloseCallback = async function( eventData, id, data, sideNavInfo ) {
    let config = { ...data };
    //create object to store sidenav info (status)
    if( !data.sideNavInfo ) {
        data.sideNavInfo = createSideNavInfo( sideNavInfo );
    }
    // All consumers should be using id and eventData should be passed through
    if( !id || !eventData ) {
        logger.error( 'id attribute and eventData are required' );
        return config;
    }
    if( !_ongoing[ id ] ) {
        if( id === eventData.id ) {
            if( eventData.config ) {
                sidenavConfig[ id ].width = eventData.config.width || sidenavConfig[ id ].width || configProperties.standard;
                sidenavConfig[ id ].height = eventData.config.height || sidenavConfig[ id ].height || configProperties.full;
                sidenavConfig[ id ].hasSlideChanged = Boolean( eventData.config.slide );
                if( eventData.config.slide ) {
                    if( eventData.config.slide !== sidenavConfig[ id ].slide ) {
                        sidenavConfig[ id ].slide = eventData.config.slide;
                    }
                } else {
                    sidenavConfig[ id ].slide = configProperties.float;
                }
                sidenavConfig[ id ].isPinnable = eventData.config.isPinnable || sidenavConfig[ id ].isPinnable || false;
                sidenavConfig[ id ].isPinUnpinEnabled = eventData.config.isPinUnpinEnabled || sidenavConfig[ id ].isPinUnpinEnabled || false;
                sidenavConfig[ id ].panelPinned = eventData.config.panelPinned || sidenavConfig[ id ].panelPinned || false;
                if( configProperties.isDefaultHeightPanel( id ) ) {
                    sidenavConfig[ id ].height = sidenavConfig[ id ].width;
                }
                if( configProperties.isPushPanel( id ) ) {
                    sidenavConfig[ id ].height = configProperties.full;
                }
                hasConfigChanged = true;
            } else if( hasConfigChanged ) {
                hasConfigChanged = false;
            }

            sidenavService.setLocationCtx( id );
            //revisitMe: Jignesh Put back the other code for autoclose of sidenav
            _ongoing[ eventData.id ] = sidenavService.createSidenav( config, eventData ).then( ( vmProps ) => {
                //reCalcPanelPosition();
                delete _ongoing[ eventData.id ];
                return vmProps;
            } );

            return _ongoing[ eventData.id ];
        } // pass keepOthersOpen to keep the other sidenavs open when the current sidenav is opened
        else if( !eventData.keepOthersOpen ) {
            // Need to close all the other open panels not having this id
            return sidenavService.closeSidenav( config, eventData ).then( () => {
                return config;
            } );
        }
    }

    //revisitMe: Jignesh: Returna promise here for command panel service
    return config;
};

/**
 * render function for AwSidenav
 * @param {*} param context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awSidenavRenderFunction = ( prop ) => {
    setDefaultConfig( prop );
    const { config, id } = prop;

    const getSidenavContainerClasses = () => {
        let classes = 'sw-column aw-sidenav-layoutContainer';

        if( sidenavConfig[ id ].width ) {
            classes += ' aw-sidenav-' + sidenavConfig[ id ].width.toLowerCase();
        }

        if( sidenavConfig[ id ].height ) {
            classes += ' aw-sidenav-vertical-' + sidenavConfig[ id ].height.toLowerCase();
        }

        const addSlideClasses = ( slide ) => {
            let sidenavClasses = '';
            sidenavClasses += slide ? ' aw-sidenav-' + slide.toLowerCase() : '';
            sidenavClasses += slide === configProperties.float && !sidenavConfig[ id ].isLeftToRight ? ' aw-sidenav-float-right' : '';
            sidenavClasses += slide === configProperties.float && sidenavConfig[ id ].isLeftToRight ? ' aw-sidenav-float-left' : '';

            return sidenavClasses;
        };

        if( sidenavConfig[ id ].hasSlideChanged ) {
            classes += addSlideClasses( prop.viewModel.data.config.slide );
        } else {
            classes += addSlideClasses( prop.config.slide );
        }

        classes += prop.viewModel.data.config.sidenavOpened ? ' aw-sidenav-expand' : '';
        classes += sidenavConfig[ id ].isAnimationDisabled ? ' aw-sidenav-transition' : '';
        classes += config.direction === 'RIGHT_TO_LEFT' ? ' aw-sidenav-leftBackground' : ' aw-sidenav-rightBackground';
        classes += sidenavConfig[ id ].isPinnable ? ' autoclose afx-accent-background' : '';
        classes += !prop.viewModel.data.config.sidenavOpened ? ' invisible' : '';

        return classes;
    };

    const getPinnedClass = () => {
        let justifyClass = 'sw-row justify-right ';
        return prop.viewModel.data.config.pinned ? justifyClass + 'pinned' : justifyClass + 'unpinned';
    };
    const getAriaLabel = ( id, i18n ) => {
        let label = i18n.TASK_PANEL;
        if( id === 'aw_navigation' ) {
            label = i18n.COMMAND_PANEL;
        } else if( id === 'globalNavigationSideNav' ) {
            label = i18n.GLOBALNAV_PANEL;
        }
        return label;
    };

    const handleClick = e => {
        setTimeout( () => {
            let sidenavContainer = prop.elementRefList.get( 'sidenav' ).current;
            var autoCloseRect = sidenavContainer.getBoundingClientRect();

            //Handle the case where the click is triggered right after resize
            var mouseXCord = e.pageX || e.touches && e.touches[ 0 ].pageX;
            if( sidenavContainer.offsetWidth === mouseXCord - sidenavContainer.offsetLeft ) {
                return;
            }

            // If the panel is already open and it is not pinned and user clicks outside of panel i.e. not on panel itself, then close the panel
            if( mouseXCord < autoCloseRect.right && mouseXCord > autoCloseRect.left ) {
                // inside click
                return;
            }
            // outside click
            if( !prop.viewModel.data.config.pinned ) {
                //revisitMe: Jignesh - Need to fix the same element click issue that opened the sidenav
                //let shallRemainOpen = $scope.doesSideNavRemainOpen( eventData );
                //if( !shallRemainOpen ) {
                //appCtx.unRegisterCtx( 'sidenavCommandId' );

                let dataToUpdate = { ...prop.viewModel.data.config };
                dataToUpdate.sidenavOpened = false;
                dataToUpdate.view = null;
                patchVMData( prop.viewModel, dataToUpdate );

                emptyHandler();
                appCtx.updatePartialCtx( ctxPath + prop.viewModel.data.config.id, {
                    open: false,
                    pinned: prop.viewModel.data.config.pinned,
                    slide: prop.viewModel.data.config.slide
                } );
            }
        }, 200 );
    };

    /* Resizable drag handle starts here */
    let handleMouseUp = ( mouseEvent ) => {
        document.removeEventListener( 'mousemove', handleMouseMove );
        document.removeEventListener( 'touchmove', handleMouseMove );

        document.removeEventListener( 'mouseup', handleMouseUp );
        document.removeEventListener( 'touchend', handleMouseUp );
        if( mouseEvent ) {
            // Publish an event that the sidenav drag has ended
            eventBus.publish( 'awsidenav.resizeEnded' );

            let dataToUpdate = { ...prop.viewModel.data.config };
            dataToUpdate.mode = TABLET;
            let sidenavWidth = prop.elementRefList.get( 'sidenav' ).current.offsetWidth;

            if( sidenavWidth < 400 ) {
                dataToUpdate.mode = MOBILE;
            } else if( sidenavWidth > 800 ) {
                dataToUpdate.mode = DESKTOP;
            }
            patchVMData( prop.viewModel, dataToUpdate );
        }
    };

    let handleMouseMove = ( e ) => {
        let sidenavContainer = prop.elementRefList.get( 'sidenav' ).current;
        var pageX = e.pageX || e.touches && e.touches[ 0 ].pageX;
        //Update the sidenav width
        var newWidth = pageX - sidenavContainer.offsetLeft;

        if( config.direction !== configProperties.left_to_right ) {
            newWidth = sidenavContainer.offsetWidth + ( sidenavContainer.offsetLeft - pageX );
        }
        if( newWidth + sidenavContainer.offsetLeft > window.innerWidth ) {
            newWidth = window.innerWidth - sidenavContainer.offsetLeft;
        }
        if( newWidth > 0 ) {
            sidenavContainer.style.width = newWidth + 'px';
        }
    };

    let handleMousedown = ( e ) => {
        e.stopPropagation();
        e.preventDefault();
        document.addEventListener( 'mousemove', handleMouseMove );
        document.addEventListener( 'touchmove', handleMouseMove );
        document.addEventListener( 'mouseup', handleMouseUp );
        document.addEventListener( 'touchend', handleMouseUp );
    };

    const emptyHandler = () => {
        let _removeHanlder = prop.elementRefList.get( 'eventListnerHandler' ).current || [];
        if( _removeHanlder.length > 0 ) {
            _removeHanlder.forEach( ( item ) => item() );
            prop.elementRefList.get( 'eventListnerHandler' ).current = null;
        }
    };

    emptyHandler();

    /* Resizable drag handle ends here */
    if( config.isPinnable && prop.viewModel.data.config.sidenavOpened ) {
        //Lets check for the ctx objects again
        //This is required because the sidenav is updating ctx objects in the middle of it work,
        //which triggers this render cycle again
        let ctxObj = appCtx.getCtx( 'awSidenavConfig.globalSidenavContext.' + id );
        if( ctxObj && ctxObj.open && !ctxObj.pinned && appCtx.getCtx( 'sidenavCommandId' ) ) {
            let _removeHanlder = [];
            document.addEventListener( 'click', handleClick, { capture: true } );
            document.addEventListener( 'touchstart', handleClick, { capture: true } );
            _removeHanlder.push( () => document.removeEventListener( 'click', handleClick, { capture: true } ) );
            _removeHanlder.push( () => document.removeEventListener( 'touchstart', handleClick, { capture: true } ) );
            prop.elementRefList.get( 'eventListnerHandler' ).current = _removeHanlder;
        }
    }

    // The isNarrowMode check is required for narrow mode devices, where the panel covers the whole screen
    // We cannot check isMobileOS as it covers iPad devices also
    if( !narrowModeSvc.isNarrowMode() && sidenavConfig[ id ].direction !== configProperties.left_to_right && prop.viewModel.data.config.sidenavOpened ) {
        let sidenavContainer = prop.elementRefList.get( 'sidenav' ).current;
        if( sidenavConfig[ id ].slide === 'FLOAT' ) {
            sidenavContainer.style.right = window.innerWidth - ( sidenavContainer.parentElement.offsetWidth + sidenavContainer.parentElement.getClientRects()[ 0 ].x ) + 'px';
        } else {
            sidenavContainer.style.right = '';
        }
    }

    let reCalcPanelPosition = _.debounce( function() {
        if( prop.viewModel.data && prop.viewModel.data.config && prop.viewModel.data.config.sidenavOpened && ( sidenavConfig[ id ].slide === 'FLOAT' || prop.viewModel.data.config.isPinnable ) ) {
            let sidenavContainer = prop.elementRefList.get( 'sidenav' ).current;

            // TODO: sidenav isn't always cleaned up?
            if( sidenavContainer ) {
                if( configProperties.isFullHeightPanel( id ) ) {
                    sidenavContainer.style.height = sidenavContainer.parentElement.offsetHeight + 'px';
                } else {
                    sidenavContainer.style.height = '';
                }
                //use case when sidenav is streched to max width and browser window gets resized.
                let currentSidenavWidth = parseInt( sidenavContainer.style.width.substring( 0, sidenavContainer.style.width.length - 2 ) );
                if( currentSidenavWidth + sidenavContainer.offsetLeft > window.innerWidth ) {
                    sidenavContainer.style.width = window.innerWidth - sidenavContainer.offsetLeft + 'px';
                }
            }
        }
    }, 500, {
        maxWait: 10000,
        trailing: true,
        leading: false
    } );

    reCalcPanelPosition();

    // The full height panel needs to be resized on window resize
    eventBus.subscribe( 'aw.windowResize', function() {
        reCalcPanelPosition();
    } );

    let context = {
        subPanelContext: {
            ...prop.viewModel.subPanelContext,
            ...{ sidenavMode: prop.viewModel.data.config.mode || configProperties.getSidenavMode( id ) },
            ...{ isPinUnpinEnabled: prop.viewModel.data.config.isPinUnpinEnabled },
            ...{ panelPinned: prop.viewModel.data.config.panelPinned }
        }
    };
    let getSidenavFocusStatus = ( sideNavInfoRef ) => {
        if ( sideNavInfoRef && sideNavInfoRef.current ) {
            return sideNavInfoRef.current.sideNavFocused;
        }
        return undefined;
    };
    let refCallBack = ( el ) => {
        let sideNavInfoRef = prop.viewModel.data.sideNavInfo;
        let isSideNavFocused = getSidenavFocusStatus( sideNavInfoRef );
        if( el && prop.viewModel.data.config.sidenavOpened && isSideNavFocused === false ) {
            sideNavInfoRef.current.sideNavFocused = true;
            let sidenavContainer = prop.elementRefList.get( 'sidenav' ).current;
            wcagSvc.focusFirstDescendantWithDelay( sidenavContainer );
        }
    };
    return (
        <aside data-locator='aw-sidenav' aria-live ='polite' aria-label={ getAriaLabel(  id, prop.i18n ) } id={ id} className={ getSidenavContainerClasses() } ref={prop.elementRefList.get( 'sidenav' )}>
            <div className={ getPinnedClass() } >
                { sidenavConfig[  id ].isPinnable && prop.viewModel.data.config.sidenavOpened ?
                    <AwIconButton command={prop.fields.pinButton}></AwIconButton> : '' }
            </div>
            {prop.viewModel.data.config.sidenavOpened && <div className='aw-layout-declarativePanelRoot aw-layout-panel'>
                <AwInclude name={prop.viewModel.data.config.view} {...context} domRef={( el )=>refCallBack( el )}></AwInclude>
            </div>}
            <div className='aw-sidenav-resizer'>
                <div className='resize-handle sw-aria-border' role='button' aria-label={ prop.i18n.resizeCommandTitle} tabIndex='0' onMouseDown={handleMousedown}>
                    <AwIcon iconId='uiPrimeNavGripper16'></AwIcon>
                </div>
            </div>
        </aside>
    );
};
