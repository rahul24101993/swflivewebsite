import AwTileGroup from 'viewmodel/AwTileGroupViewModel';
import domUtils from 'js/domUtils';
import eventBus from 'js/eventBus';
import _ from 'lodash';
import tileDragSvc from 'js/tileDragService';
const eleRef = domUtils.DOMAPIs;

export const awTileCanvasRenderFunction = ( props ) => {
    const {
        viewModel,
        ctxMin,
        actions,
        i18n,
        fields,
        grids,
        formProp,
        messages,
        ...prop
    } = props;
    const { data } = viewModel;
    const { dndHandler } = prop;
    let callback = getStartTileEditFn( viewModel, prop );
    let subscriptions = viewModel.data.subscriptions;
    let subscribedEventsStr = getEventSubscribtionsList( subscriptions );

    if( _.isEmpty( viewModel.data.tileGroups ) && !_.isEmpty( prop.tileGroups ) ) {
        initialize( prop, viewModel );
    }

    const unPinTileCallback = () => {
        if( !_.isEmpty( viewModel.data.tileGroups ) ) {
            resetTilesEditFlag( viewModel );
            _.defer( function() {
                prop.unPinTileCallback && prop.unPinTileCallback( viewModel );
            } );
        }
    };

    const tileClickCallback = () => {
        if( !_.isEmpty( viewModel.data.tileGroups ) ) {
            let vmprop = { ...viewModel.getData() };
            vmprop.isGatewayInEditMode = false;
            viewModel.dispatch( { path: 'data', value: { ...vmprop } } );
            _.defer( function() {
                prop.tileClickCallback && prop.tileClickCallback( viewModel );
            } );
        }
    };

    const handleDrag = (  event, target, targetVMO  ) => {
        if( dndHandler && dndHandler[ event.type ] ) {
            let fun = dndHandler[ event.type ];
            fun( event, { targetElement: target, targetVMO: targetVMO } );
        }
    };

    const handleDrop = (  event, target, targetVMO  ) => {
        if( dndHandler && dndHandler[ event.type ] ) {
            let funDrop = dndHandler[ event.type ];
            funDrop( event, { targetElement: target, targetVMO: targetVMO } );
        }
    };
    const handleDragAndDrop = { drag: handleDrag, drop: handleDrop, draggable: true };
    return (
        <div className='aw-tile-canvas'>
            <div data-locator='tile-canvas' className={getCanvasClass( viewModel )}>
                <div className='aw-tile-mainContainer aw-layout-flexColumnContainer'>
                    <div className='aw-tile-tileGroups aw-layout-flexRowContainer'>
                        {
                            ( prop.tileGroups || [] ).map( ( tileGroup, index ) =>createTileGroup( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, ( e ) =>{
                                callback( e );
                                tileGroup.toggleEdit && tileGroup.toggleEdit();
                            } ) )
                        }
                        <div className='aw-tile-tileGroups'>
                            <AwTileGroup tileGroup={data.dummyTileGroup}></AwTileGroup>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

const initialize = ( prop, viewModel ) => {
    let data = { ...viewModel.getData() };
    data.tileGroups = prop.tileGroups || [];
    viewModel.dispatch( { path: 'data', value: { ...data } } );
};

const getCanvasClass = ( viewModel ) => {
    let canvasClass = [ 'aw-tile-tileCanvasPanel aw-layout-flexColumn' ];
    canvasClass.push( viewModel.data.isGatewayInEditMode ? 'aw-tile-editMode' : '' );
    return canvasClass.join( ' ' );
};

const createTileGroup = ( index, viewModel, tileGroup, handleDragAndDrop, unPinTileCallback, tileClickCallback, callback ) => {
    tileGroup.editTileCallback = callback;
    tileGroup.isGatewayInEditMode = viewModel.data.isGatewayInEditMode;
    //tileGroup.handleDragAndDrop = handleDragAndDrop;
    return (
        <div key={index} className={getTileGroupClass( tileGroup )}>
            <AwTileGroup tileGroup={tileGroup} handleDragAndDrop={handleDragAndDrop} unPinTileCallback={unPinTileCallback} tileClickCallback={tileClickCallback}></AwTileGroup>
        </div>
    );
};

const getTileGroupClass = ( tileGroup ) => {
    let tileGroupClass = [ 'aw-tile-tileGroup aw-layout-flexRowContainer' ];
    tileGroupClass.push( tileGroup.tiles.length === 0 ? 'aw-tile-emptyTileGroup' : '' );
    return tileGroupClass.join( ' ' );
};

/**
 * Callback Fn triggered from AwTile for tile edit
 * @param {*} viewModel viewModel
 * @returns {*} anonymous function triggered on 'contextmenu'
 */
let _removeHanlder = [];
const getStartTileEditFn = ( viewModel, prop ) => {
    let canvasViewModel = { ...viewModel };
    return ( event ) => {
        let data = { ...canvasViewModel.getData() };
        data.isGatewayInEditMode = true;
        canvasViewModel.dispatch( { path: 'data', value: { ...data } } );
        emptyHandler();

        let handler = handleDocumentClick.bind( null, canvasViewModel, prop );

        document.addEventListener( 'click', handler );
        document.addEventListener( 'touchstart', handler );

        _removeHanlder.push( () => document.removeEventListener( 'click', handler ) );
        _removeHanlder.push( () => document.removeEventListener( 'touchstart', handler ) );
    };
};

/**
 *
 * @param {*} viewModel canvasViewModel
 * @param {*} event onClick MouseEvent
 */
const handleDocumentClick = function( viewModel, prop, event ) {
    if( event && event.target && event.target.parentElement ) {
        let isEditingTile = domUtils.DOMAPIs.closest( event.target, '.aw-tile-tileContainer' );
        if( !isEditingTile || isEditingTile.length === 0 ) {
            stopEditing( viewModel, prop );
        }
    }
};

const stopEditing = ( viewModel, prop ) => {
    resetTilesEditFlag( viewModel );

    let dirtyTiles = findDirtyTiles( viewModel );
    if( dirtyTiles && dirtyTiles.tiles.length > 0 ) {
        eventBus.publish( 'gateway.updateTile', dirtyTiles );
        prop.updateTileCallback && prop.updateTileCallback();
    }

    emptyHandler();
};

const emptyHandler = () => {
    if( _removeHanlder.length > 0 ) {
        _removeHanlder.forEach( ( tile ) => tile() );
        _removeHanlder = [];
    }
};

const resetTilesEditFlag = ( viewModel ) => {
    _.forEach( viewModel.data.tileGroups, ( tileGroup ) => {
        if( tileGroup && tileGroup.tiles ) {
            _.forEach( tileGroup.tiles, ( tile ) => {
                if( tile && tile.editing ) {
                    delete tile.editing;
                }
            } );
        }
    } );
    let vmprop = { ...viewModel.getData() };
    vmprop.isGatewayInEditMode = false;
    viewModel.dispatch( { path: 'data', value: { ...vmprop } } );
};

const findDirtyTiles = ( viewModel ) => {
    var dirtyTiles = {};
    dirtyTiles.tiles = [];
    dirtyTiles.groupNames = [];

    _.forEach(  viewModel && viewModel.data.tileGroups, function( tileGroup ) {
        if( tileGroup && tileGroup.tiles ) {
            _.forEach( tileGroup.tiles, function( tile ) {
                if( tile && tile.isDirty ) {
                    // reset dirty state and return the tile info
                    delete tile.isDirty;
                    delete tile.$$hashKey;
                    _.forEach( tile.content, function( content ) {
                        if( content ) {
                            delete content.$$hashKey;
                        }
                    } );

                    dirtyTiles.tiles.push( tile );
                    dirtyTiles.groupNames.push( tileGroup.groupName );
                }
            } );
        }
    } );

    return dirtyTiles;
};

const getEventSubscribtionsList = ( subscriptions ) => {
    let subscribedEventsStr = [];
    if( subscriptions.length !== 0 ) {
        subscriptions.map( ( eventSubscribed ) => {
            subscribedEventsStr.push( eventSubscribed.topic );
        } );
    }
    return subscribedEventsStr;
};

/**
 * Create New Tile Group while DnD tiles
 *
 * @param {*} sourceTile sourceTile
 * @param {*} sourceGroupName sourceGroupName
 * @param {*} targetTileGroup targetTileGroup
 */
export const createNewTileGroup = ( sourceTile, sourceGroupName, targetTileGroup ) => {
    //TODO: hook viewModel while working on Drag n Drop. May be pass from the DnD service or something
    let viewModel;

    var sourceGroup = getTileGroup( viewModel, sourceGroupName );
    var sourceGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( sourceGroup );
    var targetGroupIndx = viewModel && viewModel.tileGroups.indexOf( targetTileGroup );

    var sourceTileIn = retrieveTileInTileGroup( viewModel, sourceTile, sourceGroupIndx );
    var sourceTileIndx = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ].tiles.indexOf( sourceTileIn );

    var baseOrder = 0;
    var newGroupIncrement = 100;
    if( targetTileGroup && targetTileGroup.tiles.length > 0 ) {
        baseOrder = tileDragSvc.getBaseOrder( targetTileGroup.tiles[ 0 ].orderNumber );
    }

    // remove tile from source group
    var srcGroup = viewModel && viewModel.data.tileGroups[ sourceGroupIndx ];
    srcGroup.tiles.splice( sourceTileIndx, 1 );

    var srcGroupNull = false;
    // If we removed the last tile in the group
    if( srcGroup.tiles.length === 0 ) {
        srcGroupNull = true;
    }

    // create new group using current time
    var newGroup = {};
    newGroup.groupName = 'group' + new Date().getTime();

    // add sourceTile to newly created group
    newGroup.tiles = [];
    newGroup.tiles.push( sourceTileIn );

    newGroup.tiles.forEach( function( tile, indx ) {
        tile.orderNumber = baseOrder + newGroupIncrement + indx;
        tile.isDirty = true;
    } );

    // update tileGroups array
    if( sourceGroupIndx === targetGroupIndx && srcGroupNull ) {
        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx, 0, newGroup );
    } else {
        viewModel && viewModel.data.tileGroups.splice( targetGroupIndx + 1, 0, newGroup );
    }

    var newGroupIndx = viewModel && viewModel.data.tileGroups.indexOf( newGroup );

    // update order number for all tiles in each and every tile group
    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup, index ) {
        if( index > newGroupIndx && tileGroup.tiles.length > 0 ) {
            var grpBaseOrder = tileDragSvc.getBaseOrder( tileGroup.tiles[ 0 ].orderNumber );
            tileGroup.tiles.map( function( tile, indx ) {
                tile.orderNumber = grpBaseOrder + newGroupIncrement + indx;
                tile.isDirty = true;
                return tile;
            } );
        }
    } );
    viewModel &&  viewModel.dispatch( { path: 'data', value: { ...viewModel.data } } );
};

const getTileGroup = ( viewModel, groupName ) => {
    var tileGroupIn;

    _.forEach( viewModel && viewModel.data.tileGroups, function( tileGroup ) {
        if( tileGroup.groupName === groupName ) {
            tileGroupIn = tileGroup;
            return false;
        }
        return null;
    } );

    return tileGroupIn;
};

const retrieveTileInTileGroup = ( viewModel, tile, groupIndex ) => {
    var retrievedTile;

    if( viewModel && viewModel.data.tileGroups[ groupIndex ] && !_.isEmpty( viewModel && viewModel.data.tileGroups[ groupIndex ].tiles ) ) {
        _.forEach( viewModel.data.tileGroups[ groupIndex ].tiles, function( tileObj ) {
            if( _.isEqual( tileObj, tile ) ) {
                retrievedTile = tileObj;
                return false;
            }
            return null;
        } );
    }

    return retrievedTile;
};
