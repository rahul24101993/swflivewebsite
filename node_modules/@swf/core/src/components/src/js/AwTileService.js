/* eslint-disable jsx-a11y/click-events-have-key-events */
/* eslint-disable jsx-a11y/no-static-element-interactions */

import AwTileIcon from 'viewmodel/AwTileIconViewModel';
import tileSvc from 'js/tileService';
import AwIcon from 'viewmodel/AwIconViewModel';
import _ from 'lodash';
import eventBus from 'js/eventBus';
import wcagService from 'js/wcagService';
import { AwLongPress } from 'js/hocCollection';

const AwLongPressProvider = AwLongPress( 'div' );

const colorClassNames = [
    'aw-theme-adminLocationsTile',
    'aw-theme-pinnedObjectsTile',
    'aw-theme-locationsTile',
    'aw-theme-commandsActionsTile',
    'aw-theme-savedSearchesTile'
];

export const awTileRenderFunction = ( props ) => {
    const {
        viewModel,
        i18n,
        runActionWithViewModel,
        ...prop
    } = props;
    const { handleTileGroupDragAndDrop } = prop;
    if( _.isEmpty( viewModel.data.tile ) ) {
        initialize( prop.tile, viewModel );
    }

    const tile = viewModel.tile;
    let context = {
        tile: tile
    };

    const isDraggable = handleTileGroupDragAndDrop && handleTileGroupDragAndDrop.draggable ? handleTileGroupDragAndDrop.draggable : false;
    const openLocation = ( event ) => {
        if( !prop.tile.isGatewayInEditMode ) {
            tileSvc.performAction( tile.action, context, runActionWithViewModel );
        } else {
            eventBus.publish( 'gateway.tileClick' );
            _.defer( function() {
                prop.tileClickCallback();
            } );
            dispatchTileEdit( event );
        }
    };

    /* Launch tile from keyboard
     *
     * @param {Event} event - the event object
     */
    const handleKeyPress = ( event ) => {
        if( wcagService.isValidKeyPress( event ) ) {
            openLocation( event );
        }
    };

    const startEdit = ( event ) => {
        event.preventDefault();
        if( !_.isUndefined( prop.tile.isGatewayInEditMode ) && ( event.type === 'mousedown' || event.type === 'contextmenu' ) ) {
            dispatchTileEdit( event );
        }
    };

    const dispatchTileEdit = ( event ) => {
        let vmProp = { ...viewModel.getData() };
        vmProp.tile.editing = true;
        vmProp.tile.isGatewayInEditMode = true;
        viewModel.dispatch( { path: 'data', value: { ...vmProp } } );
        prop.tile.editTileCallback( event );
    };

    const handleRemoveTile = ( event ) => {
        event.stopPropagation();
        let vmProp = { ...viewModel.getData() };
        vmProp.tile.isDirty = true;
        viewModel.dispatch( { path: 'data', value: { ...vmProp } } );
        eventBus.publish( 'gateway.unpinTile', viewModel.tile );
        _.defer( function() {
            prop.unPinTileCallback( viewModel.tile );
        } );
    };
    const handleDrag = ( event ) => {
        handleTileGroupDragAndDrop.drag( event, tile );
    };

    const handleDrop = ( event, tile ) => {
        handleTileGroupDragAndDrop.drop( event, tile );
    };

    if( !_.isEmpty( tile ) ) {
        return (
            <div className='aw-tile'>
                <AwLongPressProvider data-locator='tile-container' className={getTileContainerClass( tile, viewModel )}
                    onContextMenu={( e )=>startEdit( e )}
                    awLongPress={( e )=>startEdit( e )}
                    onClick={( e )=>openLocation( e )}
                    onKeyDown={( e )=>handleKeyPress( e )}
                    draggable={isDraggable}
                    onDragOver={( e )=> handleDrop( e, tile )}
                    onDragStart={( e )=> handleDrag( e )}
                    onDragEnter={( e )=> handleDrop( e, tile )}
                    onDragLeave={( e )=> handleDrop( e, tile )}
                    onDrop={( e )=> handleDrop( e, tile )}
                    onDragEnd={( e )=>handleDrag( e )}
                    tabIndex='0'
                    role='button'
                    title={tile.displayName}>
                    <div data-locator='afx-tile' className={getTileDisplayClass( tile )} aria-hidden={true}>
                        <div className='aw-tile-tileName aw-theme-tileText'>
                            {tile.displayName}
                        </div>
                    </div>
                    <div className='aw-tile-tileContent sw-column aw-theme-tileText justify-center'>
                        {
                            tile.tileSize !== 0 && tile.content.length > 0 &&
                        <ul className='aw-tile-tileContentData' >
                            {
                                tile.content.map( ( entry, currentIndex ) => getTileContentDataList( entry, currentIndex, tile.content.length ) )
                            }
                        </ul>
                        }
                        {
                            ( tile.content.length === 0 || tile.tileSize === 0 ) &&
                        <div className={getTileIconClass( tile )}>
                            <AwTileIcon icon={tile.icons} primary='true'></AwTileIcon>
                        </div>
                        }
                    </div>
                    <div className='aw-tile-brand aw-layout-flexColumnContainer aw-theme-tileText'>
                        {
                            tile.content.length > 0 &&
                        <div className='sw-column'>
                            {
                                tile.tileSize !== 0 &&
                            <div className='aw-tile-tileIcon aw-tile-tileImage aw-tile-dynamicIcon'>
                                <AwTileIcon icon={tile.icons} primary='true'></AwTileIcon>
                            </div>
                            }
                            {
                                tile.content[0].contentValue !== '0' &&
                            <div className='aw-tile-tileBadge'>{tile.content[0].contentValue}</div>
                            }
                        </div>
                        }
                        {
                            tile.content.length === 0 && tile.icons.secondaryIcon &&
                        <div className='sw-column'>
                            <div className='aw-tile-tileIcon aw-tile-tileImage aw-tile-dynamicIcon'>
                                <AwTileIcon icon='tile.icons'></AwTileIcon>
                            </div>
                        </div>
                        }
                    </div>
                    {
                        !tile.isProtected &&
                    <div data-locator='tile-unpinButton' className='aw-tile-tileEditButton aw-tile-unpin'
                        onClick={( e )=>handleRemoveTile( e )} title={i18n.unpinCommandTitle}>
                        <AwIcon iconId='homeUnpinButton'></AwIcon>
                    </div>
                    }
                    <div data-locator='tile-resizeButton' className='aw-tile-tileEditButton aw-tile-resize'
                        onClick={( e )=>toggleTileSize( e, viewModel )} title={i18n.resizeCommandTitle}>
                        <AwIcon iconId={viewModel.data.resizeSvg}></AwIcon>
                    </div>
                </AwLongPressProvider>
            </div>
        );
    }
};

const getTileContentDataList = ( entry, currentIndex, tileContent ) => {
    return (
        <li key={currentIndex}>
            <span className='aw-tile-counterContainer'>
                <span className='aw-tile-counter'>{entry.contentValue}</span>
                <span className='aw-tile-countDesc'>{entry.contentName}</span>
            </span>
            { currentIndex !== tileContent - 1 && <span className='aw-tile-contentSep'></span> }
        </li>
    );
};

const initialize = ( tile, viewModel ) => {
    let vmProp = { ...viewModel.getData() };
    vmProp.tile = tile;
    viewModel.dispatch( { path: 'data', value: { ...vmProp } } );
    evaluateResizeSvg( viewModel );
};

const toggleTileSize = ( event, viewModel ) => {
    event.stopPropagation();
    changeTileSize( viewModel );
    evaluateResizeSvg( viewModel );
};

const changeTileSize = ( viewModel ) => {
    let vmProp = { ...viewModel.getData() };
    vmProp.tile.isDirty = true;

    if( vmProp.tile.tileSize === 1 ) {
        vmProp.tile.tileSize = 0;
    } else if( vmProp.tile.tileSize === 2 ) {
        vmProp.tile.tileSize = 1;
    } else {
        vmProp.tile.tileSize = 2;
    }
    viewModel.dispatch( { path: 'data', value: { ...vmProp } } );
};

const evaluateResizeSvg = ( viewModel ) => {
    let resizeSvg;
    if( viewModel.tile ) {
        let vmData = { ...viewModel.getData() };
        if( vmData.tile.tileSize === 0 ) {
            resizeSvg = 'homeDownRightArrowMakeMedium';
        } else if( vmData.tile.tileSize === 1 ) {
            resizeSvg = 'homeLeftArrowMakeSmall';
        } else if( vmData.tile.tileSize === 2 ) {
            resizeSvg = 'homeUpLeftArrowMakeLarge';
        }
        vmData.resizeSvg = resizeSvg;
        viewModel.dispatch( { path: 'data', value: { ...vmData } } );
    }
};

// CSS classes loading dynamically
/**
 * Function to get dynamic css classes from tile size
 * @param {*} tile tile
 * @param {*} viewModel vm
 * @returns {String} CSS classes
 */
const getTileContainerClass = ( tile, viewModel ) => {
    let tileContainerClass = [ 'sw-column', 'aw-tile-tileContainer' ];
    tileContainerClass.push( tile.styleOverride );
    tileContainerClass.push( colorClassNames[ tile.themeIndex ] );

    if( viewModel.tile.editing ) {
        tileContainerClass.push( 'aw-tile-tileEdit' );
    }

    switch ( viewModel.tile.tileSize ) {
        case 0:
            tileContainerClass.push( 'aw-tile-smallSize' );
            break;

        case 1:
            tileContainerClass.push( 'aw-tile-doubleSize' );
            break;

        case 2:
            tileContainerClass.push( 'aw-tile-doubleSize aw-tile-doubleVerticalSize' );
            break;

        default:
            break;
    }
    return tileContainerClass.join( ' ' );
};

/**
 * Function to get dynamic CSS classes for tile display div
 * @param {*} tile tile
 * @returns {*} CSS classes
 */
const getTileDisplayClass = ( tile ) => {
    let tileDisplayClass = [ 'aw-tile-brand aw-tile-displayTitle aw-theme-tileText' ];
    tileDisplayClass.push( colorClassNames[ tile.themeIndex ] );

    return tileDisplayClass.join( ' ' );
};

/**
 * Function to get dynamic CSS classes for tile icon
 * @param {*} tile tile
 * @returns {*} CSS classes
 */
const getTileIconClass = ( tile ) => {
    let tileIconClass = [ 'aw-tile-tileIcon aw-tile-tileImage sw-column aw-tile-fullsizeIcon' ];
    tileIconClass.push( tile.icons.primaryIcon !== '__TYPEICON__' ? 'aw-tile-dynamicIcon' : '' );

    return tileIconClass.join( ' ' );
};
