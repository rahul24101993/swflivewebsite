import { parseDate } from 'js/uwDirectiveDateTimeService';
import dateTimeSvc, { NULLDATE, isNullDate, getNormalizedTimeValue } from 'js/dateTimeService';

export let propTypeDate = prop => prop.type === 'DATE';

export let propTypeDateArray = prop => prop.type === 'DATEARRAY';

class DateTimeValues {
    constructor( data ) {
        this.values = {
            dateVal: data.dateVal,
            timeVal: data.timeVal
        };
    }
    get dateValue() {
        return this.values.dateVal;
    }
    get timeValue() {
        return this.values.timeVal;
    }
    cleanDateTimeValues() {
        this.values.dateVal = null;
        this.values.timeVal = null;
    }
}

let isDateEnabled = dateApi => dateApi.isDateEnabled;

let isTimeEnabled = dateApi => dateApi.isTimeEnabled;

let findDateObject = function( prop ) {
    let dbValue;
    let dateObj;
    if( propTypeDate( prop ) ) {
        dbValue = prop.dbValue;
    } else if( propTypeDateArray( prop ) ) {
        dbValue = prop.dbValue[ prop.dbValue.length - 1 ];
    }
    if( !isNullDate( dbValue ) ) {
        dateObj = parseDate( dbValue );
    } else if( dbValue === NULLDATE ) {
        dateObj = NULLDATE;
    }
    return dateObj;
};

let findDateValue = function( { dateApi } ) {
    let dateVal = null;
    if( isDateEnabled( dateApi ) ) {
        dateVal = dateTimeSvc.formatSessionDate( dateApi.dateObject );
    }
    return dateVal;
};

let findTimeValue = function( { dateApi } ) {
    let timeVal = null;
    if( isTimeEnabled( dateApi ) ) {
        timeVal = dateObject ? dateObject.timeValue : dateTimeSvc.formatTime( dateApi.dateObject );
    }
    return dateTimeSvc.getNormalizedTimeValue( timeVal );
};

let dateObject = null;
let dateWithTime;

/**
 * Sets data and time values and creates a new object
 * @param {Object} data - contains date and time values as keys
 */
export let setDateTimeValues = function( data ) {
    dateObject = new DateTimeValues( data );
};

/**
 * Cleas data and time values from the object
 * @param {Object} prop - ViewModelProperty
 */
export let clearDateTimeValues = function( prop ) {
    if( propTypeDate( prop ) || propTypeDateArray( prop ) ) {
        dateObject && dateObject.cleanDateTimeValues();
        dateObject = null;
    }
};

/**
 * Returns dbValue
 * @param {Object} prop - ViewModelProperty
 */
export let getDBValueForDate = function( prop ) {
    let dateApi = prop.dateApi;
    if( isDateEnabled( dateApi ) ) {
        let oldDateObject = !dateApi.dateValue ? dateTimeSvc.getDefaultDate( dateApi ) : findDateObject( prop );
        dateWithTime = dateTimeSvc.setTimeIntoDateModel( oldDateObject, getNormalizedTimeValue( dateObject.timeValue ) );
    } else {
        dateWithTime = dateTimeSvc.setTimeIntoDateModel( dateTimeSvc.getEpochDate(), getNormalizedTimeValue( dateObject.timeValue ) );
    }
    return dateWithTime.getTime();
};

/**
 * Returns uiValue
 * @param {Object} dateApi - dateApi object
 */
export let getUIValueForDate = function( dateApi ) {
    let uiValue;
    if( isTimeEnabled( dateApi ) && !isDateEnabled( dateApi ) ) {
        uiValue = dateTimeSvc.formatSessionTime( dateWithTime );
    } else {
        uiValue = dateTimeSvc.formatSessionDateTime( dateWithTime );
    }
    return uiValue;
};

/**
 * Returns updated dateApi based on dbValue
 * @param {Object} vmProp - ViewModelProperty
 */
export let updateDateApi = function( vmProp ) {
    if( propTypeDate( vmProp ) || propTypeDateArray( vmProp ) ) {
        let dateApi = vmProp.dateApi;
        dateApi.dateObject = findDateObject( vmProp );
        dateApi.dateValue = findDateValue( vmProp );
        dateApi.timeValue = findTimeValue( vmProp );
    }
};
