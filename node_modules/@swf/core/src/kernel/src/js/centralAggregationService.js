// Copyright (c) 2021 Siemens
/**
 * Defines {@link centralAggregationService} .
 * @module js/centralAggregationService
 */
import tabRegistryService from 'js/tabRegistry.service';
import commandHighlightService from 'js/commandHighlightService';
import appCtxService from 'js/appCtxService';
import localStorage from 'js/localStorage';
import htmlUtils from 'js/htmlUtils';

let _services = [];

/**
 *
 * @param {String} xpath xpath to evaluate.
 * @param {DOMElement} contextNode element to evaluate upon.
 * @returns {DOMElement} null or the found html element.
 */
export function getElement( xpath, contextNode ) {
    return htmlUtils.getElementByXpath( xpath, contextNode );
}

/**
 * Helper function to get the command bar + anchor of contextNode using xpath
 * to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @param {*} xpath - xpath to update the contextNode if needed
 * @returns {Object} command bar information. commandBarAnchor, the xpath to
 * the command bar, and the updated context node.
 */
const getCommandBarInfo = ( contextNode, xpath ) => {
    const cmdBarXpath = './ancestor::*[contains(@class, \'aw-command-bar\')]';
    const cmdBar = htmlUtils.getElementByXpath( cmdBarXpath, contextNode );
    if( cmdBar ) {
        const cmdBarAnchor = cmdBar.getAttribute( 'anchor' );
        const cmdBarXpath = '//*[contains(@class, \'aw-command-bar\') and @anchor=\'' + cmdBarAnchor + '\']';
        return {
            cmdBarAnchor: cmdBarAnchor,
            xpath: cmdBarXpath,
            contextNode: contextNode
        };
    }

    let cmdBarAnchor = '';
    const popupCmdBarXpath = './ancestor::*[contains(@class, \'aw-popup-command-bar\')]';
    const popupCmdBar = htmlUtils.getElementByXpath( popupCmdBarXpath, contextNode );
    if( popupCmdBar ) {
        cmdBarAnchor = popupCmdBar.getAttribute( 'anchor' );
    }

    /**
     * if there is no command bar from the clicked command, it is an overflow or group command
     * check the command bar that the overflow command or group command is a part of
     *      1. if it is an overflow command, find the actual hidden command in the DOM with it's anchor
     *          a. singular command bar
     *          b. multiple command bars
     *      2. if it is a group command, find the group command id and anchor
     */
    const overflowButtonXpath = '//*[contains(@class,\'aw-commands-moreButton\')]//*[contains(@class, \'aw-state-selected\')]';
    const overflowButton = htmlUtils.getElementByXpath( overflowButtonXpath, document );
    if( overflowButton ) {
        // 1. if it is an overflow command, find the actual hidden command in the DOM with it's anchor
        const cmdBar2 = htmlUtils.getElementByXpath( cmdBarXpath, overflowButton );
        if( cmdBar2 ) {
            const cmdBarAnchor2 = cmdBar2.getAttribute( 'anchor' );
            const cmdBarXpath2 = '//*[contains(@class, \'aw-command-bar\') and @anchor=\'' + cmdBarAnchor2 + '\']';
            return {
                cmdBarAnchor: cmdBarAnchor2,
                grpCmdBarAnchor: undefined,
                grpCmdId: undefined,
                xpath: cmdBarXpath2,
                contextNode: htmlUtils.getElementByXpath( cmdBarXpath + xpath, overflowButton )
            };
        }

        // singular command bar is not found, searching multiple command bars
        const cmdBarsXpath = './ancestor::*[contains(@class, \'aw-commandBars\')]';
        const cmdBars = htmlUtils.getElementByXpath( cmdBarsXpath, overflowButton );
        if( cmdBars ) {
            const cmd = htmlUtils.getElementByXpath( xpath, cmdBars );
            if( cmd ) {
                const cmdBar3 = htmlUtils.getElementByXpath( cmdBarXpath, cmd );
                if( cmdBar3 ) {
                    const cmdBarAnchor3 = cmdBar3.getAttribute( 'anchor' );
                    const cmdBarXpath = '//*[contains(@class, \'aw-command-bar\') and @anchor=\'' + cmdBarAnchor3 + '\']';
                    return {
                        cmdBarAnchor: cmdBarAnchor3,
                        grpCmdBarAnchor: undefined,
                        grpCmdId: undefined,
                        xpath: cmdBarXpath,
                        contextNode: cmd
                    };
                }
            }
        }
    } else {
        const grpCmdXpath = '//*[contains(@class, \'aw-state-selected\') and @data-command-id]//*[contains(@class, \'aw-widgets-groupCommand\')]/ancestor::*[@data-command-id]';
        const grpCmd = htmlUtils.getElementByXpath( grpCmdXpath, document );
        // 2. if it is a group command, find the group command id and anchor
        if( grpCmd ) {
            const grpCmdId = grpCmd.getAttribute( 'data-command-id' );
            const grpCmdAnchorElem = htmlUtils.getElementByXpath( cmdBarXpath, grpCmd );
            let grpCmdAnchor = grpCmdAnchorElem ? grpCmdAnchorElem.getAttribute( 'anchor' ) : undefined;
            return {
                cmdBarAnchor: cmdBarAnchor,
                grpCmdBarAnchor: grpCmdAnchor,
                grpCmdId: grpCmdId,
                xpath: '',
                contextNode: grpCmd
            };
        }
    }
    return {
        cmdBarAnchor: cmdBarAnchor,
        grpCmdBarAnchor: undefined,
        grpCmdId: undefined,
        xpath: '',
        contextNode: contextNode
    };
};

/**
 * Helper function to get the containing property of contextNode using xpath
 * to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @returns {Object} property information. Property name and its xpath.
 */
const getPropertyInfo = ( contextNode ) => {
    const propXpath = './ancestor::*[contains(@class, \'sw-property\')]//*[contains(@class, \'sw-property-name\')]';
    const propNameElement = htmlUtils.getElementByXpath( propXpath, contextNode );
    if( propNameElement ) {
        const propName = propNameElement.getInnerHTML();
        return {
            propName: propName,
            xpath: '//*[contains(@class, \'sw-property-name\') and text()=\'' + propName + '\']/ancestor::*[contains(@class, \'sw-property\')]'
        };
    }
    return {
        propName: undefined,
        xpath: ''
    };
};

/**
 * Helper function to get the containing section of contextNode using xpath
 * to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @returns {Object} section information. Section titleKey and its xpath.
 */
const getSectionInfo = ( contextNode ) => {
    const sectionXpath = './ancestor::*[contains(@class, \'sw-section\') and contains(@class, \'aw-panelSection\')]';
    const section = htmlUtils.getElementByXpath( sectionXpath, contextNode );
    if( section ) {
        const sectionTitleKey = section.getAttribute( 'titlekey' );
        const sectionTitleKeyXpath = '//*[contains(@class, \'sw-section\') and contains(@class, \'aw-panelSection\') and @titlekey=\'' + sectionTitleKey + '\']';
        return {
            sectionTitleKey: sectionTitleKey,
            xpath: sectionTitleKeyXpath
        };
    }
    return {
        sectionTitleKey: undefined,
        xpath: ''
    };
};

/**
 * Helper function to get the containing secondary workarea tab of contextNode
 * using xpath to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @returns {Object} secondary workarea tab information. Secondary workarea tab key
 * and its xpath.
 */
const getSwaTabInfo = ( contextNode ) => {
    const swaTabsXpath = './ancestor::*[contains(@class, \'sw-secondary-workarea\')]//*[contains(@class, \'sw-tabContainer\')]//*[contains(@class, \'sw-tab-selected\')]';
    const swaTab = htmlUtils.getElementByXpath( swaTabsXpath, contextNode );
    if( swaTab ) {
        const swaTabKey = swaTab.getAttribute( 'tabkey' );
        const swaTabKeyXpath = '//*[contains(@class, \'sw-secondary-workarea\')]//*[contains(@class, \'sw-tabContainer\')]//*[contains(@class, \'sw-tab-selected\') and @tabkey=\''
         + swaTabKey + '\']/ancestor::*[contains(@class, \'sw-secondary-workarea\')]';
        return {
            swaTabKey: swaTabKey,
            xpath: swaTabKeyXpath
        };
    }
    return {
        swaTabKey: undefined,
        xpath: ''
    };
};

/**
 * Helper function to get the containing primary workarea tab of contextNode using xpath
 * to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @returns {Object} primary workarea information. Primary workarea tab key and its xpath.
 */
const getPwaTabInfo = ( contextNode ) => {
    const pwaTabsXpath = './ancestor::*[contains(@class, \'sw-showobject-page\')]//*[contains(@class, \'aw-layout-subLocationTitles\')]'
     + '//*[contains(@class, \'sw-tabContainer\')]//*[contains(@class, \'sw-tab-selected\')]';
    const pwaTab = htmlUtils.getElementByXpath( pwaTabsXpath, contextNode );
    if( pwaTab ) {
        const pwaTabName = pwaTab.getAttribute( 'tabkey' );
        const pwaTabNameXpath = '//*[contains(@class, \'aw-layout-subLocationTitles\')]//*[contains(@class, \'sw-tabContainer\')]//*[contains(@class, \'sw-tab-selected\') and @tabkey=\''
         + pwaTabName + '\']/ancestor::*[contains(@class, \'sw-showobject-page\')]';
        return {
            pwaTabName: pwaTabName,
            xpath: pwaTabNameXpath
        };
    }
    return {
        pwaTabName: undefined,
        xpath: ''
    };
};

/**
 * Helper function to get the containing view of contextNode using xpath
 * to fish the DOM.
 *
 * @param {DOMElement} contextNode - context element to search
 * @param {*} xpath - xpath to update the contextNode if needed
 * @returns {Object} view information. xpath to the containing view.
 */
const getViewInfo = ( contextNode, xpath ) => {
    const viewXpath = './ancestor::*[contains(@class, \'sw-showobject-page\')]';
    const view = htmlUtils.getElementByXpath( viewXpath, contextNode );
    if( view ) {
        const result = document.evaluate( '//*[contains(@class, \'sw-showobject-page\')]', document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null );
        let index = 1;
        //multiple work areas
        let node = result.iterateNext();
        while( node ) {
            const elem = htmlUtils.getElementByXpath( '(//*[contains(@class, \'sw-showobject-page\')])[' + index + ']' + xpath, document );
            if( elem === contextNode ) {
                break;
            } else {
                index += 1;
            }
            node = result.iterateNext();
        }
        return '(//*[contains(@class, \'sw-showobject-page\')])[' + index + ']';
    }
    return '';
};

/**
 * Helper function to get the currently selected type.
 *
 * @returns {String} the selected type.
 */
const getSelectedTypeInfo = () => {
    return appCtxService.ctx.selected && appCtxService.ctx.selected !== null && appCtxService.ctx.selected.type ? appCtxService.ctx.selected.type : '';
};

/**
 * Helper function to get the current selection mode.
 *
 * @returns {String} the selection mode.
 */
const getSelectionModeInfo = () => {
    const mselected = appCtxService.ctx.mselected;
    if( mselected && mselected !== null && mselected.length >= 1 ) {
        for( let index = 1; index < mselected.length; index++ ) {
            if( mselected[ index ].type !== mselected[ index - 1 ].type ) {
                return 'MULTIPLE';
            }
        }
        return mselected.length > 1 ? 'MULTIPLE' : 'SINGLE';
    }
    return 'SINGLE';
};

/**
 * Helper function to get the current user context information (user/role/group/workspace).
 *
 * @returns {Object} user context information. User uid, role uid, group uid, and workspace id.
 */
const getUserContextInfo = () => {
    let user = '';
    let role = '';
    let group = '';
    let workspace = '';
    if( appCtxService.ctx && appCtxService.ctx.userSession && appCtxService.ctx.userSession.props ) {
        user = appCtxService.ctx.userSession.props.user.dbValues[ 0 ];
        role = appCtxService.ctx.userSession.props.role.dbValues[ 0 ];
        group = appCtxService.ctx.userSession.props.group.dbValues[ 0 ];
        if( appCtxService.ctx.workspace ) {
            workspace = appCtxService.ctx.workspace.workspaceId;
        }
    }
    return {
        user: user,
        role: role,
        group: group,
        workspace: workspace
    };
};

/**
 * Helper function to get command information from contextNode.
 *
 * @param {HTMLElement} contextNode - button element that contains command id attribute
 * @returns {Object} command information. Command id, command bar anchor, property name,
 * section titlekey, secondary workarea tab, primary workarea tab, view xpath, user,
 * role, group, workspace, selected type, and selection mode.
 */
const getCommandInfo = ( contextNode ) => {
    let localContextNode = contextNode;
    const cmdId = contextNode.getAttribute( 'data-command-id' );
    let xpath = '//*[@data-command-id=\'' + cmdId + '\']';

    const cmdBarInfo = getCommandBarInfo( localContextNode, xpath );
    xpath = cmdBarInfo.grpCmdId ? '//*[@data-command-id=\'' + cmdBarInfo.grpCmdId + '\']' : cmdBarInfo.xpath + xpath;
    localContextNode = cmdBarInfo.contextNode;
    const propInfo = getPropertyInfo( localContextNode );
    xpath = propInfo.xpath + xpath;
    const sectionInfo = getSectionInfo( localContextNode );
    xpath = sectionInfo.xpath + xpath;
    const swaTabInfo = getSwaTabInfo( localContextNode );
    xpath = swaTabInfo.xpath + xpath;
    const pwaTabInfo = getPwaTabInfo( localContextNode );
    xpath = pwaTabInfo.xpath + xpath;
    xpath = getViewInfo( localContextNode, xpath ) + xpath;
    const userContextInfo = getUserContextInfo();

    return {
        xpath: xpath,
        commandId: cmdId,
        commandBarAnchor: cmdBarInfo.cmdBarAnchor,
        grpCmdId: cmdBarInfo.grpCmdId,
        grpCmdAnchor: cmdBarInfo.grpCmdBarAnchor,
        propName: propInfo.propName,
        sectionTitleKey: sectionInfo.sectionTitleKey,
        swaTab: swaTabInfo.swaTabKey,
        pwaTab: pwaTabInfo.pwaTabKey,
        selectedType: getSelectedTypeInfo(),
        selectionMode: getSelectionModeInfo(),
        user: userContextInfo.user,
        role: userContextInfo.role,
        group: userContextInfo.group,
        workspace: userContextInfo.workspace
    };
};

/**
 *
 * @param {HTMLElement} contextNode - anchor element that contains tab key attribute
 * @returns {Object} tab information
 */
const getTabInfo = ( contextNode ) => {
    let localContextNode = contextNode;
    const tabKey = localContextNode.getAttribute( 'tabkey' );
    // determine if we are in overflow
    const overflowXpath = '//*[contains(@class, \'sw-tab-overflowContainer\')]//*[contains(@class, \'sw-tab-overflowButton\') and contains(@class, \'aw-jswidget-controlArrowRotateRight\')]';
    const overflowButtonElem = htmlUtils.getElementByXpath( overflowXpath, document );
    if( overflowButtonElem ) {
        // in overflow, get the hidden tab
        const hiddenTabXpath = './ancestor::*[contains(@class, \'sw-tab-overflowContainer\')]/ancestor::*//*[@role=\'tablist\' and contains(@class, \'sw-tabContainer\')]//*[@role=\'tab\']//*[@tabkey=\''
         + tabKey + '\']';
        const hiddenTabElem = htmlUtils.getElementByXpath( hiddenTabXpath, overflowButtonElem );
        if( hiddenTabElem ) {
            localContextNode = hiddenTabElem;
        }
    }
    const tabName = localContextNode.getAttribute( 'aria-label' );
    let xpath = '//*[@tabkey=\'' + tabKey + '\']';
    const swaXpath = './ancestor::*[contains(@class, \'sw-secondary-workarea\')]';
    const swaElem = htmlUtils.getElementByXpath( swaXpath, localContextNode );

    if( swaElem ) {
        // clicked on swa tab
        xpath = '//*[contains(@class, \'sw-secondary-workarea\')]' + xpath;
        const pwaTabInfo = getPwaTabInfo( localContextNode );
        xpath = pwaTabInfo.xpath + xpath;
        xpath = getViewInfo( localContextNode, xpath ) + xpath;
    } else {
        const pwaXpath = './ancestor::*[contains(@class, \'sw-tabContainer\')]/ancestor::*[contains(@class, \'aw-layout-subLocationTitles\')]';
        const pwaElem = htmlUtils.getElementByXpath( pwaXpath, localContextNode );
        if( pwaElem ) {
            xpath = '//*[contains(@class, \'aw-layout-subLocationTitles\')]//*[contains(@class, \'sw-tabContainer\')]' + xpath;
            xpath = getViewInfo( localContextNode, xpath ) + xpath;
        }
    }
    const userContextInfo = getUserContextInfo();

    return {
        xpath: xpath,
        tabName: tabName,
        selectedType: getSelectedTypeInfo(),
        selectionMode: getSelectionModeInfo(),
        user: userContextInfo.user,
        role: userContextInfo.role,
        group: userContextInfo.group,
        workspace: userContextInfo.workspace
    };
};

/**
 *
 * @param {HTMLElement} contextNode - aw-tile element
 * @returns {Object} tile information
 */
const getTileInfo = ( contextNode ) => {
    const tileName = contextNode.getAttribute( 'title' );
    const userContextInfo = getUserContextInfo();
    return {
        xpath: '//*[contains(@class, \'aw-tile-tileContainer\') and @data-locator=\'tile-container\' and @title=\'' + tileName + '\']',
        tileName: tileName,
        selectedType: getSelectedTypeInfo(),
        selectionMode: getSelectionModeInfo(),
        user: userContextInfo.user,
        role: userContextInfo.role,
        group: userContextInfo.group,
        workspace: userContextInfo.workspace
    };
};

// TODO: (mm) decide if this function is needed. This function is just pushing to localStorage.
const tempFn = ( key, info ) => {
    let infos = [];
    const result = localStorage.get( key );
    if( result ) {
        infos = JSON.parse( result );
        let found = false;
        let index = 0;
        for( let element of infos ) {
            if( element.xpath === info.xpath && element.selectedType === info.selectedType && element.user === info.user
                && element.group === info.group && element.role === info.role && element.workspace === info.workspace ) {
                found = true;
                break;
            }
            index += 1;
        }
        if( found ) {
            // move to front
            const elem = infos[index];
            infos.splice( index, 1 );
            infos.unshift( elem );
        } else {
            if( infos.length === 5 ) {
                infos.pop();
            }
            infos.push( info );
        }
    } else {
        infos.push( info );
    }
    localStorage.publish( key, JSON.stringify( infos ) );
};

/**
 * Global click listener on the "bubble down" so this code is invoked first.
 * Collect information from the DOM for commands/tabs/tiles and notify all services.
 */
export function initClickListener() {
    document.addEventListener( 'click', function( event ) {
        const commandElement = htmlUtils.getElementByXpath( './ancestor-or-self::*[@data-command-id]', event.target );
        if( commandElement ) {
            const cmdInfo = getCommandInfo( commandElement );
            tempFn( 'commandInformation', cmdInfo );
            notify2( cmdInfo );
            return;
        }

        const tabElement = htmlUtils.getElementByXpath( './ancestor-or-self::*[@tabkey]', event.target );
        if( tabElement ) {
            const tabInfo = getTabInfo( tabElement );
            tempFn( 'tabInformation', tabInfo );
            notify2( tabInfo );
            return;
        }

        const tileXpath = './ancestor-or-self::*[not(@data-locator=\'tile-resizeButton\')]/ancestor::*[contains(@class, \'aw-tile-tileContainer\') and @data-locator=\'tile-container\']';
        const tileElement = htmlUtils.getElementByXpath( tileXpath, event.target );
        if( tileElement ) {
            const tileInfo = getTileInfo( tileElement );
            tempFn( 'tileInformation', tileInfo );
            notify2( tileInfo );
        }
    }, true );
}

/**
 * Register a service
 *
 * @param {String} serviceName name of service to register
 * @param {Object} service instance to register
 */
export function registerService( serviceName, service ) {
    _services.push( { name: serviceName, instance: service } );
}

/**
 * Remove service registration
 *
 * @param {String} serviceName service name to un-register
 */
export function unregisterService( serviceName ) {
    _services = _services.filter( function( value ) {
        return value.name !== serviceName;
    } );
}

/**
 * capture current user gesture and publish-
 * TODO: (mm) delete this function and it's references
 * then re-name notify2 to notify
 * @param  {...currentContext} payload for callee service
 * @returns {Function} callback function for subscribed services
 */
export const notify = async( ...currentContext ) => {};

/**
 * Notify the registered services of the click information
 * gathered by the global click listener.
 *
 * @param  {Object} clickInfo - information gathered by the global click listener.
 */
export function notify2( clickInfo ) {
    for( let service of _services ) {
        service.instance.notify( clickInfo );
    }
}

/**
 * Highlight widget as per widget context
 * TODO: (mm) move or delete this function, doesn't belong here.
 * @param {String} widgetType - can be tab, tile or command
 * @param {String} widgetId - 123
 * @param {String} selector params like target tab, command selector
 */
export const highlightWidget = async( widgetType, widgetId, selector ) => {
    if( widgetType.toLowerCase() === 'tab' ) {
        tabRegistryService.highlightTab( widgetId, selector );
    } else {
        commandHighlightService.highlightCommand( widgetId, selector );
    }
};
const exports = {
    registerService,
    unregisterService,
    notify,
    highlightWidget,
    initClickListener
};
export default exports;
