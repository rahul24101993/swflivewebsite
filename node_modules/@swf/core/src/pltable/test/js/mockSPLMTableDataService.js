/**
 * @module test/mockSPLMTableDataService
 */
import AwPromiseService from 'js/awPromiseService';
import uwPropertySvc from 'js/uwPropertyService';
import awColumnSvc from 'js/awColumnService';
import awTableSvc from 'js/awTableService';
import iconSvc from 'js/iconService';
import _ from 'lodash';

// var _debug_delayEnabled = true;

// var _debug_pageDelay = 1000;

/**
 * Cached static default AwTableColumnInfo.
 */
var _flatTableColumnInfos = null;

/**
 * Cached static default AwTableColumnInfo.
 */
var _treeTableColumnInfos = null;

/**
 * Cached static default ViewModelRows.
 */
var _flatTableRows = null;

/**
 */
var _numInitialTopChildren = 147;

/**
 */
var _numNextChildren = 53;

/**
 */
var _maxTreeLevel = 3;

/**
 */
var _s = [ 'th', 'st', 'nd', 'rd' ];

/**
 */
var _childTypes = [ 'ItemRevision', 'ItemRevision', 'Document', 'Item', 'DocumentRevision', 'Item', 'Dataset',
    'CompanyContact', 'User'
];

/**
 * Map of nodeId of a 'parent' TableModelObject to an array of its 'child' TableModelObjects.
 */
var _mapNodeId2ChildArray = {};

/**
 * @return {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
 */
function _getFlatTableColumnInfos() {
    if( !_flatTableColumnInfos ) {
        _flatTableColumnInfos = _buildFlatTableColumnInfos();
    }

    return _flatTableColumnInfos;
}

/**
 * @return {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
 */
function _getTreeTableColumnInfos() {
    if( !_treeTableColumnInfos ) {
        _treeTableColumnInfos = _buildTreeTableColumnInfos();
    }

    return _treeTableColumnInfos;
}

/**
 * @param n
 * @returns {String} 1st, 2nd, etc.
 */
function getGetOrdinal( n ) {
    var v = n % 100;
    return n + ( _s[ ( v - 20 ) % 10 ] || _s[ v ] || _s[ 0 ] );
}

/**
 * @return {AwTableColumnInfoArray} Array of column information objects set with specific information.
 */
function _buildFlatTableColumnInfos() {
    var columnInfos = [];

    /**
     * Set 1st column to special 'name' column to support tree-table.
     */
    var propName;
    var propDisplayName;
    var isTableCommand;

    for( var colNdx = 0; colNdx < 20; colNdx++ ) {
        var columnNumber = colNdx;

        if( colNdx === 0 ) {
            propName = 'object_name';
            propDisplayName = 'Name';
            isTableCommand = true;
        } else {
            propName = 'prop' + columnNumber;
            propDisplayName = getGetOrdinal( columnNumber );
            isTableCommand = false;
        }

        var columnInfo = awColumnSvc.createColumnInfo();

        /**
         * Set values for common properties
         */
        columnInfo.name = propName;
        columnInfo.displayName = propDisplayName;
        columnInfo.isFilteringEnabled = true;
        columnInfo.isTableCommand = isTableCommand;

        /**
         * Set values for un-common properties
         */
        columnInfo.typeName = 'String';
        columnInfo.enablePinning = true;
        columnInfo.enableSorting = false;
        columnInfo.enableColumnMenu = false;

        if( colNdx === 0 ) {
            columnInfo.pinnedLeft = true;
        }

        columnInfos.push( columnInfo );
    }

    return columnInfos;
}

/**
 * @return {AwTableColumnInfoArray} Array of column information objects set with specific information.
 */
function _buildTreeTableColumnInfos() {
    var columnInfos = [];

    /**
     * Set 1st column to special 'name' column to support tree-table.
     */
    var propName;
    var propDisplayName;
    var isTreeNavigation;
    var width;
    var minWidth;

    for( var colNdx = 0; colNdx < 10; colNdx++ ) {
        var columnNumber = colNdx;

        /**
         * @property {Number|String} width - Number of pixels
         * @memberOf module:js/awColumnService~AwTableColumnInfo
         */
        if( colNdx === 0 ) {
            propName = 'object_name';
            propDisplayName = 'Name';
            isTreeNavigation = true;
            width = 250;
            minWidth = 150;
        } else {
            propName = 'prop' + columnNumber;
            propDisplayName = getGetOrdinal( columnNumber );
            isTreeNavigation = false;
            minWidth = 20;
            width = 150 - colNdx * 5;
        }

        var columnInfo = awColumnSvc.createColumnInfo();

        /**
         * Set values for common properties
         */
        columnInfo.name = propName;
        columnInfo.displayName = propDisplayName;
        columnInfo.isFilteringEnabled = true;
        columnInfo.isTreeNavigation = isTreeNavigation;
        columnInfo.width = width;
        columnInfo.minWidth = minWidth;

        /**
         * Set values for un-common properties
         */
        columnInfo.typeName = 'String';
        columnInfo.enablePinning = true;
        columnInfo.enableSorting = true;

        columnInfos.push( columnInfo );
    }

    return columnInfos;
}

/**
 * @param {AwTableColumnInfoArray} columnInfos - Array of column information objects to use when building the
 *            table rows.
 * @returns {ViewModelRowArray} Array of row objects in a 'flat' table (no hierarchy)
 */
function _buildFlatTableRows( columnInfos ) {
    var vmRows = [];

    for( var rowNdx = 0; rowNdx < 120; rowNdx++ ) {
        var rowNumber = rowNdx + 1;

        var type = _childTypes[ rowNdx % _childTypes.length ];

        var vmRow = new ViewModelRow( rowNumber, type );

        var dbValues;
        var displayValues;

        _.forEach( columnInfos, function( columnInfo, columnNdx ) {
            var columnNumber = columnNdx;

            if( columnInfo.isTableCommand ) {
                dbValues = [ rowNumber ];
                displayValues = [ 'r' + rowNumber ];
            } else {
                dbValues = [ rowNumber + ':' + columnNumber ];
                displayValues = [ 'r' + rowNumber + 'c' + columnNumber ];
            }

            var vmProp = uwPropertySvc.createViewModelProperty( columnInfo.name, columnInfo.displayName,
                columnInfo.typeName, dbValues, displayValues );

            vmProp.propertyDescriptor = {
                displayName: columnInfo.displayName
            };

            if( columnInfo.isTableCommand ) {
                vmProp.typeIconURL = iconSvc.getTypeIconURL( vmRow.type );
            }

            vmRow.props[ columnInfo.name ] = vmProp;
        } );

        vmRows.push( vmRow );
    }

    return vmRows;
}

/**
 * @param {AwTableColumnInfoArray} columnInfos - Array of column information objects to use when building the
 *            table rows.
 * @param {ViewModelTreeNode} parentNode - A node that acts 'parent' of a hierarchy of 'child'
 *            ViewModelTreeNodes.
 * @param {Number} nChildren - The # of child nodes to add to the given 'parent'.
 * @param {Boolean} isLoadAllEnabled - TRUE if all properties should be included.
 */
function _buildTreeTableStructure( columnInfos, parentNode, nChildren, isLoadAllEnabled ) {
    var children = [];

    _mapNodeId2ChildArray[ parentNode.id ] = children;

    var levelNdx = parentNode.levelNdx + 1;

    if( nChildren < 1 ) {
        nChildren = 4;
    }

    for( var childNdx = 1; childNdx <= nChildren; childNdx++ ) {
        /**
         * Create a new node for this level. and Create props for it
         */
        var childNumber = childNdx;

        var nodeId = parentNode.id + '.' + childNumber;

        var type = _childTypes[ childNdx % _childTypes.length ];

        var iconURL = iconSvc.getTypeIconURL( type );

        var vmNode = awTableSvc.createViewModelTreeNode( nodeId, type, nodeId, levelNdx, childNdx, iconURL );

        if( levelNdx >= _maxTreeLevel || type === 'Document' || type === 'DocumentRevision' ||
            type === 'Dataset' ) {
            vmNode.isLeaf = true;
        }

        _populateColumns( columnInfos, isLoadAllEnabled, vmNode, childNdx );

        /**
         * Add it to the 'parent' based on its ID
         */
        children.push( vmNode );
    }
}

/**
 * @param {Number} columnNumber -
 * @param {AwTableColumnInfo} columnInfo -
 * @param {String} nodeId -
 * @param {String} type -
 * @param {Number} childNumber -
 * @return {ViewModelProperty}
 */
function _createViewModelProperty( columnNumber, columnInfo, nodeId, type, childNumber ) {
    var dbValues;
    var uiValues;

    if( columnInfo.isTableCommand || columnInfo.isTreeNavigation ) {
        dbValues = [ nodeId ];
        uiValues = [ nodeId ];
    } else {
        dbValues = [ childNumber + ':' + columnNumber ];
        uiValues = [ 'n' + childNumber + 'c' + columnNumber ];
    }

    var vmProp = uwPropertySvc.createViewModelProperty( columnInfo.name, columnInfo.displayName,
        columnInfo.typeName, dbValues, uiValues );

    vmProp.propertyDescriptor = {
        displayName: columnInfo.displayName
    };

    if( columnInfo.isTableCommand || columnInfo.isTreeNavigation ) {
        vmProp.typeIconURL = iconSvc.getTypeIconURL( type );
    }

    return vmProp;
}

/**
 * Resolve the 'next' page of row data.
 *
 * @param {Object} data - An Object (usually the DeclViewModel on the $scope) this action function is invoked
 *            from. The r/o 'pageSize' and r/w 'searchIndex' properties on this object are used.
 *
 * <pre>
 * {
 *     pageSize : {Number} (Optional) Maximum number of rows to return. If not set, default is 20.
 *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
 * }
 * </pre>
 *
 * @param {DeferredResolution} deferred - Deferral to resolve with the requested row data.
 * @param {ViewModelRowArray} vmRows - Array of all rows in the table.
 */
function _loadFlatTableRows( data, deferred, vmRows, pageSizeIn ) {
    var pageSize = pageSizeIn ? pageSizeIn : 20;

    var searchIndex = 0;

    if( data.searchIndex ) {
        searchIndex = data.searchIndex;
    }

    if( searchIndex < 0 ) {
        deferred.resolve( awTableSvc.createTableLoadResult( vmRows.length ) );
        return;
    }

    var begNdx = searchIndex * pageSize;

    if( begNdx >= vmRows.length ) {
        deferred.resolve( awTableSvc.createTableLoadResult( vmRows.length ) );
        return;
    }

    var endNdx = begNdx + pageSize;

    if( endNdx > vmRows.length ) {
        endNdx = vmRows.length;
    }

    var nextSearchIndex = searchIndex + 1;

    if( endNdx === vmRows.length ) {
        nextSearchIndex = -1;
    }

    var loadResult = awTableSvc.createTableLoadResult( vmRows.length );

    loadResult.searchResults = vmRows.slice( begNdx, endNdx );
    loadResult.searchIndex = nextSearchIndex;

    deferred.resolve( loadResult );
}

/**
 * @param deferred
 * @param propertyLoadRequests
 */
function _loadProperties( deferred, propertyLoadInput ) {
    var allChildNodes = [];

    _.forEach( propertyLoadInput.propertyLoadRequests, function( propertyLoadRequest ) {
        _.forEach( propertyLoadRequest.childNodes, function( childNode ) {
            if( !childNode.props ) {
                childNode.props = {};
            }

            _populateColumns( propertyLoadRequest.columnInfos, true, childNode, childNode.childNdx + 1 );

            allChildNodes.push( childNode );
        } );
    } );

    var propertyLoadResult = awTableSvc.createPropertyLoadResult( allChildNodes );

    var resolutionObj = {
        propertyLoadResult: propertyLoadResult
    };

    deferred.resolve( resolutionObj );
}

/**
 * Resolve the row data for the 'next' page of 'children' nodes of the given 'parent'.
 * <P>
 * Note: The paging status is maintained in the 'parent' node.
 *
 * @param {DeferredResolution} deferred -
 * @param {TreeLoadInput} treeLoadInput -
 * @return {Promise} Revolved with a TreeLoadResult object containing result/status information.
 */
function _loadTreeTableRows( deferred, treeLoadInput ) {
    /**
     * Check if this 'parent' is NOT known to be a 'leaf' and has no 'children' yet.
     */
    var parentNode = treeLoadInput.parentNode;

    if( !parentNode.isLeaf ) {
        var nChild = parentNode.children ? parentNode.children.length : 0;

        if( nChild === 0 ) {
            // get props with intial tree for now. In future, should set this to false and populate
            // the props seperately.
            var isLoadAllEnabled = true;
            if( parentNode.levelNdx < 0 ) {
                _buildTreeTableStructure( _getTreeTableColumnInfos(), parentNode, _numInitialTopChildren, isLoadAllEnabled );
            } else {
                if( parentNode.levelNdx < _maxTreeLevel ) {
                    _buildTreeTableStructure( _getTreeTableColumnInfos(), parentNode, _numNextChildren -
                        parentNode.levelNdx * 23, isLoadAllEnabled );
                } else {
                    parentNode.isLeaf = true;
                }
            }
        }
    }

    /**
     *
     */
    var mockChildNodes = _mapNodeId2ChildArray[ parentNode.id ];

    var endReached = parentNode.startChildNdx + treeLoadInput.pageSize > mockChildNodes.length;

    var treeLoadResult = awTableSvc.buildTreeLoadResult( treeLoadInput, mockChildNodes, false, true,
        endReached, null );

    deferred.resolve( {
        treeLoadResult: treeLoadResult
    } );
}

/**
 * @param {ObjectArray} columnInfos -
 * @param {Boolean} isLoadAllEnabled -
 * @param {ViewModelTreeNode} vmNode -
 * @param {Number} childNdx -
 */
function _populateColumns( columnInfos, isLoadAllEnabled, vmNode, childNdx ) {
    if( isLoadAllEnabled ) {
        if( !vmNode.props ) {
            vmNode.props = [];
        }

        _.forEach( columnInfos, function( columnInfo, columnNdx ) {
            /**
             * Do not put any properties in the 'isTreeNavigation' column.
             */
            if( !columnInfos.isTreeNavigation ) {
                vmNode.props[ columnInfo.name ] = _createViewModelProperty( columnNdx, columnInfo, vmNode.id,
                    vmNode.type, childNdx );
            }
        } );
    }
}

/**
 * Instances of this class represent the properties and status of a single row in a flat table.
 *
 * @class ViewModelRow
 * @param {String} rowId - Unique ID for this row within the table.
 * @param {String} type - The type of model object represented by this tree node (i.e. 'Item'
 *            'DocumentRevision', etc.).
 */
var ViewModelRow = function( rowId, type ) {
    this.id = rowId;
    this.type = type;
    this.props = {};
};

var exports = {};

/**
 * @param {Object} uwDataProvider - An Object (usually a UwDataProvider) on the DeclViewModel on the $scope this
 *            action function is invoked from.
 * @return {Promise} A Promise that will be resolved with the requested data when the data is available.
 *
 * <pre>
 * {
 *     columnInfos : {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
 * }
 * </pre>
 */
export let loadFlatTableColumns = function( uwDataProvider ) {
    var deferred = AwPromiseService.instance.defer();

    uwDataProvider.columnConfig = {
        columns: _getFlatTableColumnInfos()
    };

    deferred.resolve( {
        columnInfos: _getFlatTableColumnInfos()
    } );

    return deferred.promise;
};

/**
 * @param {Object} uwDataProvider - An Object (usually a UwDataProvider) on the DeclViewModel on the $scope this
 *            action function is invoked from.
 * @return {Promise} A Promise that will be resolved with the requested data when the data is available.
 *
 * <pre>
 * {
 *     columnInfos : {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
 * }
 * </pre>
 */
export let loadTreeTableColumns = function( uwDataProvider ) {
    var deferred = AwPromiseService.instance.defer();

    uwDataProvider.columnConfig = {
        columns: _getTreeTableColumnInfos()
    };

    deferred.resolve( {
        columnInfos: _getTreeTableColumnInfos()
    } );

    return deferred.promise;
};

/**
 * Get a page of row data for a 'flat' table.
 *
 * @param {Object} data - An Object (usually the DeclViewModel on the $scope) this action function is invoked
 *            from. The r/o 'pageSize' and r/w 'searchIndex' properties on this object are used.
 *
 * <pre>
 * {
 *     pageSize : {Number} (Optional) Maximum number of rows to return. If not set, default is 20.
 *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
 * }
 * </pre>
 *
 * @return {Promise} A Promise that will be resolved with the requested data when the data is available.
 *
 * <pre>
 * {
 *     searchResults : {ViewModelObjectArray} Objects just loaded,
 *     totalFound : {Number} Total # of item in the overall table.
 *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
 * }
 * </pre>
 */
export let loadFlatTableData = function( data ) {
    if( !_flatTableRows || _flatTableRows.length === 0 ) {
        _flatTableRows = _buildFlatTableRows( _getFlatTableColumnInfos() );
    }

    var deferred = AwPromiseService.instance.defer();

    /* if( _debug_delayEnabled ) {
        _.delay( _loadFlatTableRows, _debug_pageDelay, data, deferred, _flatTableRows );
    } else {*/
    _loadFlatTableRows( data, deferred, _flatTableRows );
    /* }*/

    return deferred.promise;
};

/**
 * Get a page of row data for a 'tree' table.
 *
 * @param {TreeLoadInput} treeLoadInput - An Object this action function is invoked from. The object is usually
 *            the result of processing the 'inputData' property of a DeclAction based on data from the current
 *            DeclViewModel on the $scope) . The 'pageSize' properties on this object is used (if defined).
 *
 * <pre>
 * {
 * Extra 'debug' Properties
 *     delayTimeTree: {Number}
 * }
 * </pre>
 *
 * @return {Promise} A Promise that will be resolved with a TreeLoadResult object when the requested data is
 *         available.
 */
export let loadTreeTableData = function() { // eslint-disable-line no-unused-vars
    /**
     * Extract action parameters from the arguments to this function.
     */
    var treeLoadInput = awTableSvc.findTreeLoadInput( arguments );

    /**
     * Extract action parameters from the arguments to this function.
     * <P>
     * Note: The order or existence of parameters can varey when more-than-one property is specified in the
     * 'inputData' property of a DeclAction JSON. This code seeks out the ones this function expects.
     */
    var delayTimeTree = 0;

    for( var ndx = 0; ndx < arguments.length; ndx++ ) {
        var arg = arguments[ ndx ];

        if( uwPropertySvc.isViewModelProperty( arg ) && arg.propertyName === 'delayTimeTree' ) {
            delayTimeTree = arg.dbValue;
        } else if( uwPropertySvc.isViewModelProperty( arg ) && arg.propertyName === 'maxTreeLevel' ) {
            _maxTreeLevel = arg.dbValue;
        }
    }

    /**
     * Check the validity of the parameters
     */
    var deferred = AwPromiseService.instance.defer();

    var failureReason = awTableSvc.validateTreeLoadInput( treeLoadInput );

    if( failureReason ) {
        deferred.reject( failureReason );

        return deferred.promise;
    }

    /**
     * Load the 'child' nodes for the 'parent' node.
     */
    /* if( delayTimeTree > 0 ) {
        _.delay( _loadTreeTableRows, delayTimeTree, deferred, treeLoadInput );
    } else {*/
    _loadTreeTableRows( deferred, treeLoadInput );
    /* }*/

    return deferred.promise;
};

/**
 * Get a page of row data for a 'tree' table.
 *
 * @param {PropertyLoadRequestArray} propertyLoadRequests - An array of PropertyLoadRequest objects this action
 *            function is invoked from. The object is usually the result of processing the 'inputData' property
 *            of a DeclAction based on data from the current DeclViewModel on the $scope) . The 'pageSize'
 *            properties on this object is used (if defined).
 */
export let loadTreeTableProperties = function() { // eslint-disable-line no-unused-vars
    /**
     * Extract action parameters from the arguments to this function.
     * <P>
     * Note: The order or existence of parameters can varey when more-than-one property is specified in the
     * 'inputData' property of a DeclAction JSON. This code seeks out the ones this function expects.
     */
    var propertyLoadInput;

    var delayTimeProperty = 0;

    for( var ndx = 0; ndx < arguments.length; ndx++ ) {
        var arg = arguments[ ndx ];

        if( awTableSvc.isPropertyLoadInput( arg ) ) {
            propertyLoadInput = arg;
        } else if( uwPropertySvc.isViewModelProperty( arg ) && arg.propertyName === 'delayTimeProperty' ) {
            delayTimeProperty = arg.dbValue;
        }
    }

    var deferred = AwPromiseService.instance.defer();

    /**
     * Load the 'child' nodes for the 'parent' node.
     */
    if( delayTimeProperty > 0 ) {
        _.delay( _loadProperties, delayTimeProperty, deferred, propertyLoadInput );
    } else {
        if( propertyLoadInput ) {
            _loadProperties( deferred, propertyLoadInput );
        }
    }

    return deferred.promise;
};

export default exports = {
    loadFlatTableColumns,
    loadTreeTableColumns,
    loadFlatTableData,
    loadTreeTableData,
    loadTreeTableProperties
};
