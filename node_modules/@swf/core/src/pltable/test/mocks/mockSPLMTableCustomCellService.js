// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * @module test/mockSPLMTableCustomCellService
 */
import uwPropertySvc from 'js/uwPropertyService';
import awColumnSvc from 'js/awColumnService';
import awTableSvc from 'js/awTableService';
import iconSvc from 'js/iconService';
import awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';
import _ from 'lodash';
import Cell from 'js/splmTableCellRenderer';
import util from 'js/splmTableUtils';
import Const from 'js/splmTableConstants';

/**
  * Cached static default AwTableColumnInfo.
  */
var _flatTableColumnInfos = null;

/**
  * Cached static default ViewModelRows.
  */
var _flatTableRows = null;

/**
  */
var _s = [ 'th', 'st', 'nd', 'rd' ];

/**
  */
var _childTypes = [ 'ItemRevision', 'ItemRevision', 'Document', 'Item', 'DocumentRevision', 'Item', 'Dataset',
    'CompanyContact', 'User'
];

/**
  * @return {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
  */
function _getFlatTableColumnInfos() {
    if( !_flatTableColumnInfos ) {
        _flatTableColumnInfos = _buildFlatTableColumnInfos();
    }

    return _flatTableColumnInfos;
}

/**
  * @param n
  * @returns {String} 1st, 2nd, etc.
  */
function getGetOrdinal( n ) {
    var v = n % 100;
    return n + ( _s[ ( v - 20 ) % 10 ] || _s[ v ] || _s[ 0 ] );
}

/**
  * @return {AwTableColumnInfoArray} Array of column information objects set with specific information.
  */
function _buildFlatTableColumnInfos() {
    var columnInfos = [];

    /**
      * Set 1st column to special 'name' column to support tree-table.
      */
    var propName;
    var propDisplayName;
    var isTableCommand;

    for( var colNdx = 0; colNdx < 20; colNdx++ ) {
        var columnNumber = colNdx;

        if( colNdx === 0 ) {
            propName = 'object_name';
            propDisplayName = 'Name';
            isTableCommand = true;
        } else if( colNdx === 3 ) {
            //This will be used for graphical property rendering , 1 and 2 index already has customCell
            propName = 'release_status_list';
            propDisplayName = 'Release Status';
            isTableCommand = false;
        } else if( colNdx === 4 ) {
            //This will be used for graphical property rendering , 1 and 2 index already has customCell
            propName = 'release_status_with_custom_fn';
            propDisplayName = 'Release Status Custom Function';
            isTableCommand = false;
        } else if( colNdx === 5 ) {
            //This will be used for graphical property rendering , 1 and 2 index already has customCell
            propName = 'release_status_templateUrl';
            propDisplayName = 'Release Status Template URL';
            isTableCommand = false;
        } else {
            propName = 'prop' + columnNumber;
            propDisplayName = getGetOrdinal( columnNumber );
            isTableCommand = false;
        }

        var columnInfo = awColumnSvc.createColumnInfo();

        /**
          * Set values for common properties
          */
        columnInfo.name = propName;
        columnInfo.displayName = propDisplayName;
        columnInfo.isFilteringEnabled = true;
        columnInfo.isTableCommand = isTableCommand;

        /**
          * Set values for un-common properties
          */
        columnInfo.typeName = 'String';
        columnInfo.enablePinning = true;
        columnInfo.enableSorting = false;
        columnInfo.enableColumnMenu = false;

        if( colNdx === 0 ) {
            columnInfo.pinnedLeft = true;
        }

        columnInfos.push( columnInfo );
    }

    // Add custom cell renderer. Whey _.forEach has closure effect? :)
    _.forEach( columnInfos, function( column, idx ) {
        if( idx === 0 ) {
            // Overwirte cell template
            column.cellRenderers = [ {
                action: function( column, vmo, tableElem ) {
                    var cellContent = Cell.createElement( column, vmo, tableElem );
                    cellContent.appendChild( awSPLMTableCellRendererFactory.createCellCommandElement( column, vmo, tableElem ) );
                    return cellContent;
                },
                condition: function( column, vmo, tableElem ) {
                    return column.isTableCommand === true &&
                             vmo.props && vmo.props[ column.field ] &&
                             vmo.props[ column.field ].dbValue.endsWith( '_updateCmd' );
                }
            },
            {
                action: function( column, vmo, tableElem ) {
                    var cellTop = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                    var elem = document.createElement( 'span' );
                    elem.classList.add( 'customCell' );
                    elem.textContent = 'customCell_' + idx;
                    cellTop.appendChild( elem );
                    return cellTop;
                },
                condition: function( column, vmo, tableElem ) {
                    return true;
                }
            }
            ];
        } else if( idx === 1 ) {
            // Cell Decorator
            column.cellRenderers = [ {
                action: function( column, vmo, tableElem ) {
                    var cellContentElem = Cell.createElement( column, vmo, tableElem );
                    if( cellContentElem ) {
                        cellContentElem.textContent += '_decorator2';
                    }
                    return cellContentElem;
                },
                condition: function( column, vmo, tableElem ) {
                    return true;
                }
            },
            {
                action: function( column, vmo, tableElem ) {
                    var cellContentElem = Cell.createElement( column, vmo, tableElem );
                    if( cellContentElem ) {
                        cellContentElem.textContent += '_decorator1';
                    }
                    return cellContentElem;
                },
                condition: function( column, vmo, tableElem ) {
                    return true;
                }
            },
            {
                action: function( column, vmo, tableElem ) {
                    var elem = document.createElement( 'span' );
                    elem.classList.add( 'customCell' );
                    elem.textContent = 'customCell_' + idx;
                    return elem;
                },
                condition: function( column, vmo, tableElem ) {
                    return true;
                }
            }
            ];
        } else if( idx === 2 ) {
            // command cell
            column.cellRenderers = [ {
                action: function( column, vmo, tableElem ) {
                    var cellTop = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                    var elem = document.createElement( 'span' );
                    elem.classList.add( 'customCell' );
                    elem.textContent = 'customCell_' + idx;
                    cellTop.appendChild( elem );
                    cellTop.appendChild( awSPLMTableCellRendererFactory.createCellCommandElement( column, vmo, tableElem ) );

                    return cellTop;
                },
                condition: function( column, vmo, tableElem ) {
                    return true;
                }
            } ];
        }
    } );

    return columnInfos;
}

/**
  * @param {AwTableColumnInfoArray} columnInfos - Array of column information objects to use when building the
  *            table rows.
  * @returns {ViewModelRowArray} Array of row objects in a 'flat' table (no hierarchy)
  */
function _buildFlatTableRows( columnInfos ) {
    var vmRows = [];

    for( var rowNdx = 0; rowNdx < 120; rowNdx++ ) {
        var rowNumber = rowNdx + 1;

        var type = _childTypes[ rowNdx % _childTypes.length ];

        var vmRow = new ViewModelRow( rowNumber, type );

        var dbValue;
        var displayValues;

        _.forEach( columnInfos, function( columnInfo, columnNdx ) {
            var columnNumber = columnNdx;

            if( columnInfo.isTableCommand ) {
                dbValue = 'r' + rowNumber;
            } else {
                dbValue = 'r' + rowNumber + 'c' + columnNumber;
            }
            displayValues = [ dbValue ];

            var vmProp = uwPropertySvc.createViewModelProperty( columnInfo.name, columnInfo.displayName,
                columnInfo.typeName, dbValue, displayValues );

            vmProp.propertyDescriptor = {
                displayName: columnInfo.displayName
            };

            vmProp.uiValues = _.clone( displayValues );

            if( columnInfo.isTableCommand ) {
                vmProp.typeIconURL = iconSvc.getTypeIconURL( vmRow.type );
            }

            vmRow.props[ columnInfo.name ] = vmProp;
        } );

        vmRow.uid = 'r' + rowNumber;
        vmRows.push( vmRow );
    }

    return vmRows;
}

/**
  * @param {Number} columnNumber - column number
  * @param {AwTableColumnInfo} columnInfo - column info
  * @param {String} nodeId - nodeID
  * @param {String} type - type
  * @param {Number} childNumber - child number
  * @return {ViewModelProperty} viewModelProperty
  */
function _createViewModelProperty( columnNumber, columnInfo, nodeId, type, childNumber ) {
    var dbValues;
    var uiValues;

    if( columnInfo.isTableCommand || columnInfo.isTreeNavigation ) {
        dbValues = [ nodeId ];
        uiValues = [ nodeId ];
    } else {
        dbValues = [ childNumber + ':' + columnNumber ];
        uiValues = [ 'n' + childNumber + 'c' + columnNumber ];
    }

    var vmProp = uwPropertySvc.createViewModelProperty( columnInfo.name, columnInfo.displayName,
        columnInfo.typeName, dbValues, uiValues );

    vmProp.propertyDescriptor = {
        displayName: columnInfo.displayName
    };

    if( columnInfo.isTableCommand || columnInfo.isTreeNavigation ) {
        vmProp.typeIconURL = iconSvc.getTypeIconURL( type );
    }

    return vmProp;
}

/**
  * Resolve the 'next' page of row data.
  *
  * @param {Object} data - An Object (usually the DeclViewModel on the $scope) this action function is invoked
  *            from. The r/o 'pageSize' and r/w 'searchIndex' properties on this object are used.
  *
  * <pre>
  * {
  *     pageSize : {Number} (Optional) Maximum number of rows to return. If not set, default is 20.
  *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
  * }
  * </pre>
  *
  * @param {ViewModelRowArray} vmRows - Array of all rows in the table.
  * @param { number } pageSizeIn - page size.
  */
function _loadFlatTableRows( data, vmRows, pageSizeIn ) {
    var pageSize = pageSizeIn ? pageSizeIn : 20;

    var searchIndex = 0;

    if( data.searchIndex ) {
        searchIndex = data.searchIndex;
    }

    if( searchIndex < 0 ) {
        awTableSvc.createTableLoadResult( vmRows.length );
        return;
    }

    var begNdx = searchIndex * pageSize;

    if( begNdx >= vmRows.length ) {
        awTableSvc.createTableLoadResult( vmRows.length );
        return;
    }

    var endNdx = begNdx + pageSize;

    if( endNdx > vmRows.length ) {
        endNdx = vmRows.length;
    }

    var nextSearchIndex = searchIndex + 1;

    if( endNdx === vmRows.length ) {
        nextSearchIndex = -1;
    }

    var loadResult = awTableSvc.createTableLoadResult( vmRows.length );

    loadResult.searchResults = vmRows.slice( begNdx, endNdx );
    loadResult.searchIndex = nextSearchIndex;
    return loadResult;
}

/**
  * @param {ObjectArray} columnInfos -
  * @param {Boolean} isLoadAllEnabled -
  * @param {ViewModelTreeNode} vmNode -
  * @param {Number} childNdx -
  */
function _populateColumns( columnInfos, isLoadAllEnabled, vmNode, childNdx ) {
    if( isLoadAllEnabled ) {
        if( !vmNode.props ) {
            vmNode.props = [];
        }

        _.forEach( columnInfos, function( columnInfo, columnNdx ) {
            /**
              * Do not put any properties in the 'isTreeNavigation' column.
              */
            if( !columnInfos.isTreeNavigation ) {
                vmNode.props[ columnInfo.name ] = _createViewModelProperty( columnNdx, columnInfo, vmNode.id,
                    vmNode.type, childNdx );
            }
        } );
    }
}

/**
  * Instances of this class represent the properties and status of a single row in a flat table.
  *
  * @class ViewModelRow
  * @param {String} rowId - Unique ID for this row within the table.
  * @param {String} type - The type of model object represented by this tree node (i.e. 'Item'
  *            'DocumentRevision', etc.).
  */
var ViewModelRow = function( rowId, type ) {
    this.id = rowId;
    this.type = type;
    this.props = {};
};

var exports = {};

/**
  * @param {Object} uwDataProvider - An Object (usually a UwDataProvider) on the DeclViewModel on the $scope this
  *            action function is invoked from.
  *
  * <pre>
  * {
  *     columnInfos : {AwTableColumnInfoArray} An array of columns related to the row data created by this service.
  * }
  * </pre>
  */
export let loadFlatTableColumns = function( uwDataProvider ) {
    uwDataProvider.columnConfig = {
        columns: _getFlatTableColumnInfos()
    };
};

/**
  * Get a page of row data for a 'flat' table.
  *
  * @param {Object} data - An Object (usually the DeclViewModel on the $scope) this action function is invoked
  *            from. The r/o 'pageSize' and r/w 'searchIndex' properties on this object are used.
  *
  * <pre>
  * {
  *     pageSize : {Number} (Optional) Maximum number of rows to return. If not set, default is 20.
  *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
  * }
  * </pre>
  *
  * <pre>
  * {
  *     searchResults : {ViewModelObjectArray} Objects just loaded,
  *     totalFound : {Number} Total # of item in the overall table.
  *     searchIndex : {Number} Next page index to be returned (or -1 if no more data)
  * }
  * </pre>
  */
export let loadFlatTableData = function( data ) {
    if( !_flatTableRows || _flatTableRows.length === 0 ) {
        _flatTableRows = _buildFlatTableRows( _getFlatTableColumnInfos() );
    }

    return _loadFlatTableRows( data, _flatTableRows );
};

exports = {
    loadFlatTableColumns,
    loadFlatTableData
};

export default exports;

