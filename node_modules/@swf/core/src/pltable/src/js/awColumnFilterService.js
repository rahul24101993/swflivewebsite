/* eslint-disable max-lines */
// Copyright (c) 2020 Siemens

/**
 * This service is used for PLTable as Column Filter Service
 *
 * @module js/awColumnFilterService
 *
 */
import messagingService from 'js/messagingService';
import dateTimeService from 'js/dateTimeService';
import localeService from 'js/localeService';
import appContextService from 'js/appCtxService';
import propertyService from 'js/uwPropertyService';
import _ from 'lodash';
import eventBus from 'js/eventBus';
import columnFilterUtility from 'js/awColumnFilterUtility';

var _localeTextBundle = {};

var exports = {};

/*********************************
 * Temporary Constants for Facet *
 ********************************/
const numberFacetsToShow = 10;
const facetCheckboxHeight = 33;
const SELECT_ALL_PROPERTY = 'awSelectAllOption';

/**
 * Determines if value is valid number to process.
 *
 * @param {Number|String} value - Number value
 *
 * @returns {Boolean} true if valid number
 */
var isValidNumber = function( value ) {
    return isFinite( value ) && value !== null && value !== '';
};

/**
 * Check if property has a default value.
 *
 * @param {Object} property - property to check values
 * @returns {boolean} true is has blank value
 */
const isDefaultFilterValue = function( property ) {
    return property && ( _.isNil( property.dbValue ) || property.dbValue === '' );
};

/**
 * Check if existing filters have not equal facets.
 *
 * @param {Array} columnFilters
 * @param {String} value
 * @returns {boolean} true if facets are existing and not equals
 */
const isExistingFacetValueNotEquals = function( columnFilters, value ) {
    let isExistingNotEqualsFacet = false;
    _.forEach( columnFilters, function( filter ) {
        if( filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_NOT_EQUALS && filter.values && filter.values.includes( value ) ) {
            isExistingNotEqualsFacet = true;
            return false;
        }
    } );
    return isExistingNotEqualsFacet;
};

/**
 * Check if existing filters have equals facets.
 *
 * @param {Array} columnFilters
 * @param {String} value
 * @returns {boolean} true if facets are existing and equals
 */
const isExistingFacetValueEquals = function( columnFilters, value ) {
    let isExistingEqualsFacet = false;
    _.forEach( columnFilters, function( filter ) {
        if( filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_EQUALS && filter.values && filter.values.includes( value ) ) {
            isExistingEqualsFacet = true;
            return false;
        }
    } );
    return isExistingEqualsFacet;
};

/**
 * Get the default selection of facets based on existing filters.
 *
 * @param {Array} columnFilters
 * @returns true if existing filters have not equals, false if equals
 */
const getDefaultFacetSelectionValue = function( columnFilters ) {
    let defaultSelectionValue = null;
    _.forEach( columnFilters, function( filter ) {
        if( filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_EQUALS ) {
            defaultSelectionValue = false;
            return false;
        }
        if( filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_NOT_EQUALS ) {
            defaultSelectionValue = true;
            return false;
        }
    } );
    return defaultSelectionValue;
};

/**
 * Initialize the column menu's default variables.
 *
 * @param {Object} column - column information
 * @param {Object} viewModelData - menu view model data
 * @param {Object} operation - column filtering operation
 */
export let initializeMenu = function( column, columnFilterData, columnMenuData = {} ) {
    let registerContext = false;
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( !columnMenuContext ) {
        columnMenuContext = {};
        registerContext = true;
    }
    columnMenuContext.isFacetsInitialized = false;
    columnMenuContext.isFacetLoading = false;
    columnMenuContext.isSelectedFacetValues = false;
    columnMenuContext.isMenuIntialized = true;
    if( column.filter ) {
        // Set the defaultFacetSection for when an existing facet filter was applied
        columnMenuContext.defaultFacetSelection = getDefaultFacetSelectionValue( column.filter.columnFilters );
        if( columnMenuContext.defaultFacetSelection === false ) {
            columnMenuContext.isSelectedFacetValues = true;
        }
    }
    registerContext && appContextService.registerCtx( 'columnMenuContext', columnMenuContext );

    columnMenuData = { ...columnFilterData, ...columnMenuData };

    return { columnMenuData: columnMenuData };
};

/**
 * Sets the filter information on the column filter and the column provider filters used for SOA.
 *
 * @param {Object} columnProvider column provider for the data
 * @param {Object} dataProvider data provider for the data
 * @param {Array} newProviderFilters new column provider filters to set
 * @param {Object} updatedColumn column with the updated filter attached
 */
export let setFilters = function( columnProvider, dataProvider, newProviderFilters, updatedColumn ) {
    const updatedColumnFilters = columnFilterUtility.addOrReplaceColumnFilter( columnProvider.getColumnFilters(), newProviderFilters );
    columnProvider.setColumnFilters( updatedColumnFilters );

    // Set all filters as stale except for column in newProviderFilters
    _.forEach( dataProvider.cols, function( col ) {
        if( col.field === updatedColumn.field ) {
            // Need to preserve whether show filters was on/off
            const oldShowFilterFacets = col.filter.showFilterFacets;
            exports.updateColumnFilter( col, newProviderFilters );
            col.filter.showFilterFacets = oldShowFilterFacets;
        } else {
            exports.setColumnFilterStale( col );
        }
    } );
};

/**
 * Check if text filter inputs are default values.
 *
 * @param {Object} column column definition object
 * @returns {Boolean} whether input values are all original values
 */
var isTextFilterInputDefault = function( column, viewModelData ) {
    var isInputDefault = false;
    if( !column.filter.isFilterApplied && isDefaultFilterValue( viewModelData.textValue ) ) {
        isInputDefault = true;
    }
    return isInputDefault;
};

/**
 * Check if date filter inputs are default values.
 *
 * @param {Object} column column definition object
 * @returns {Boolean} whether input values are all original values
 */
var isDateFilterInputDefault = function( column, viewModelData ) {
    var isInputDefault = false;
    if( !column.filter.isFilterApplied && viewModelData.startDate &&
        dateTimeService.isNullDate( viewModelData.startDate.dbValue ) &&
        viewModelData.endDate &&
        dateTimeService.isNullDate( viewModelData.endDate.dbValue ) &&
        viewModelData.startDate.dateApi && !viewModelData.startDate.dateApi.dateValue &&
        viewModelData.endDate.dateApi && !viewModelData.endDate.dateApi.dateValue ) {
        isInputDefault = true;
    }
    return isInputDefault;
};

/**
 * Check if numeric filter inputs are default values.
 *
 * @param {Object} column column definition object
 * @returns {Boolean} whether input values are all original values
 */
var isNumericFilterInputDefault = function( column, viewModelData ) {
    var isInputDefault = false;
    if( !column.filter.isFilterApplied ) {
        const opeartionValue = viewModelData.operation.dbValue;
        switch ( opeartionValue ) {
            case columnFilterUtility.OPERATION_TYPE.RANGE:
                isInputDefault = isDefaultFilterValue( viewModelData.startNumber ) && isDefaultFilterValue( viewModelData.endNumber );
                break;
            case columnFilterUtility.OPERATION_TYPE.GREATER:
                isInputDefault = isDefaultFilterValue( viewModelData.numberValue );
                break;
            case columnFilterUtility.OPERATION_TYPE.LESS:
                isInputDefault = isDefaultFilterValue( viewModelData.numberValue );
                break;
            case columnFilterUtility.OPERATION_TYPE.EQUALS:
                isInputDefault = isDefaultFilterValue( viewModelData.numberValue );
                break;
        }
    }
    return isInputDefault;
};

/**
 * Check if all facets are checked
 *
 * @param {Object} column column definition object
 * @returns {Boolean} true if all facets are selected
 */
var isFacetInputDefault = function( facetDataProvider ) {
    var isInputDefault = true;
    const facetObjects = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
    if( facetObjects ) {
        _.forEach( facetObjects, function( currentValue ) {
            if( !currentValue.dbValue && currentValue.serverValue !== SELECT_ALL_PROPERTY ) {
                isInputDefault = false;
                return false;
            }
            return true;
        } );
    }
    return isInputDefault;
};

/**
 * Check if all facets are unchecked
 *
 * @param {Object} column column definition object
 * @returns {Boolean} true if all facets are deselected
 */
var areAllFacetsUnchecked = function( facetDataProvider ) {
    var allFacetsUnchecked;
    const facetObjects = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
    if( facetObjects && !isFacetInputDefault( facetDataProvider ) ) {
        allFacetsUnchecked = true;
        _.forEach( facetObjects, function( currentValue ) {
            if( currentValue.dbValue ) {
                allFacetsUnchecked = false;
                return false;
            }
            return true;
        } );
    }
    return allFacetsUnchecked;
};

/**
 * Disable filtering in menu.
 *
 * @param {Object} column column definition object
 */
var disableFiltering = function( isFilterDisabled ) {
    if ( isFilterDisabled.update ) {
        isFilterDisabled.update( { value: true } );
    } else {
        isFilterDisabled.value = true;
    }
};

/**
 * Enable filtering in menu.
 *
 * @param {Object} column column definition object
 */
var enableFiltering = function( isFilterDisabled ) {
    if ( isFilterDisabled.update ) {
        isFilterDisabled.update( { value: false } );
    } else {
        isFilterDisabled.value = false;
    }
};

/**
 * Clear an filter errors from the menu.
 *
 * @param {Object} context - menu context information
 */
var clearContextAttributes = function( context ) {
    if( context.filterError ) {
        delete context.filterError; // remove error if exists
    }
};

/**
 * Validate the text information coming from the filter column menu UI.
 *
 * @param {Object} textValue - The text value coming from the filter menu
 * @param {Object} viewModelData - The viewModel data used for validation
 *
 * @returns {Boolean} true if textValue is valid
 */
export let doTextValidation = function( textValue, viewModelData ) {
    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( columnMenuContext ) {
        clearContextAttributes( columnMenuContext );
    }
    return true;
};

/**
 * Validate the numeric information coming from the filter column menu UI.
 *
 * @param {Object} viewModelData - The viewModel data used for validation
 *
 * @returns {Boolean} true if numeric information is valid
 */
export let doNumericValidation = function( viewModelData ) {
    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( columnMenuContext ) {
        clearContextAttributes( columnMenuContext );

        if( _.isNumber( viewModelData.startNumber.dbValue ) && _.isNumber( viewModelData.endNumber.dbValue ) && viewModelData.startNumber.dbValue > viewModelData.endNumber.dbValue ) {
            columnMenuContext.filterError = true;
            messagingService.showError( _localeTextBundle.invalidNumberRange );
        }
        return !columnMenuContext.filterError;
    }
    return true;
};

/**
 * Create a column filter from the facet values in column.
 *
 * @param {Object} column - column definition object
 * @returns {Object} filter object created from facet values
 */
export let processFacetValuesInFilter = function( column, facetDataProvider ) {
    var facetFilter = null;
    const facetObjects = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( facetObjects ) {
        var facetUiValues = [];
        _.forEach( facetObjects, function( currentValue ) {
            if( currentValue.serverValue !== SELECT_ALL_PROPERTY &&
                ( columnMenuContext.isSelectedFacetValues && currentValue.dbValue === true ||
                    !columnMenuContext.isSelectedFacetValues && currentValue.dbValue === false ) ) {
                facetUiValues.push( currentValue.serverValue );
            }
        } );

        if( columnMenuContext.isSelectedFacetValues ) {
            facetFilter = columnFilterUtility.createCaseSensitiveEqualsFilter( column.field, facetUiValues );
        } else {
            facetFilter = columnFilterUtility.createCaseSensitiveNotEqualsFilter( column.field, facetUiValues );
        }
    }
    return facetFilter;
};

/**
 * Creates a text filter based on column filter information
 *
 * @param {Object} eventData - Event Data for filter
 * @returns {Object} filter object
 */
var createTextFilter = function( eventData ) {
    var filter = null;
    if( eventData ) {
        filter = columnFilterUtility.createFilter( eventData.operation, eventData.columnName, [ eventData.textValue ] );
    }
    return filter;
};

export let updateTableWithColumnFilters = function( gridContextDispatcher, column, columnFilters ) {
    const columnFilterInfo = {
        column: column,
        filters: columnFilters
    };
    gridContextDispatcher( {
        type: 'UPDATE_VALUES',
        columnFilterInfo: columnFilterInfo
    } );
};

/**
 * Add/remove the text filter information to the column provider.
 *
 * @param {Object} column - Column object
 * @param {Object} viewModelData - The viewModel data used for validation
 * @param {Object} facetDataProvider - The data provider of the facets.
 */
export let doTextFiltering = function( column, viewModelData, facetDataProvider, gridContextDispatcher ) {
    // client side validation
    let newFilters = null;
    if( exports.doTextValidation( viewModelData ) ) {
        // Set columnProvider.columnFilters so dataProvider/actions can use the information
        const isFacetInputDefaultResult = isFacetInputDefault( facetDataProvider );
        if( viewModelData.textValue || !isFacetInputDefaultResult ) {
            newFilters = [];
            if( viewModelData.textValue && viewModelData.textValue.dbValue ) {
                const filterData = {
                    columnName: column.field,
                    operation: viewModelData.operation.dbValue,
                    textValue: viewModelData.textValue.dbValue
                };
                var textColumnFilter = createTextFilter( filterData );
                newFilters.push( textColumnFilter );
            }
            if( !isFacetInputDefaultResult ) {
                const facetFilter = exports.processFacetValuesInFilter( column, facetDataProvider );
                if( facetFilter && facetFilter.values && facetFilter.values.length ) {
                    newFilters.push( facetFilter );
                }
            }
        }
    }

    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if ( columnMenuContext.filterError !== true && gridContextDispatcher ) {
        updateTableWithColumnFilters( gridContextDispatcher, column, newFilters );
    }
    return newFilters;
};

/**
 * Validate the date information coming from the filter column menu UI.
 *
 * @param {Object} viewModelData - The viewModel data used for validation
 *
 * @returns {Boolean} true if date is valid
 */
export let doDateValidation = function( viewModelData ) {
    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( columnMenuContext ) {
        clearContextAttributes( columnMenuContext );

        if( !dateTimeService.isNullDate( viewModelData.startDate.dbValue ) && !dateTimeService.isNullDate( viewModelData.endDate.dbValue ) ) {
            var startDateTime = _.isNumber( viewModelData.startDate.dbValue ) ? viewModelData.startDate.dbValue : new Date( viewModelData.startDate.dbValue ).getTime();
            var endDateTime = _.isNumber( viewModelData.endDate.dbValue ) ? viewModelData.endDate.dbValue : new Date( viewModelData.endDate.dbValue ).getTime();
            if( startDateTime > endDateTime ) {
                columnMenuContext.filterError = true;
                messagingService.showError( _localeTextBundle.invalidDate );
            }
        }
        return !columnMenuContext.filterError;
    }
    return true;
};

/**
 * Creates a date filter based on column filter information
 *
 * @param {Object} eventData - Event Data for filter
 * @returns {Object} filter object
 */
var createDateFilter = function( eventData ) {
    var filter = null;
    // Set columnProvider.columnFilters so dataProvider/actions can use the information
    if( !dateTimeService.isNullDate( eventData.startDate ) && !dateTimeService.isNullDate( eventData.endDate ) ) {
        var startDateUtc = dateTimeService.formatUTC( new Date( eventData.startDate ) );
        var endDate = new Date( eventData.endDate );
        var endDateUtc = dateTimeService.formatUTC( endDate.setHours( 23, 59, 59, 999 ) );
        filter = columnFilterUtility.createRangeFilter( eventData.columnName, [ startDateUtc, endDateUtc ] );
    } else if( !dateTimeService.isNullDate( eventData.startDate ) ) {
        startDateUtc = dateTimeService.formatUTC( new Date( eventData.startDate ) );
        filter = columnFilterUtility.createGreaterThanEqualsFilter( eventData.columnName, [ startDateUtc ] );
    } else if( !dateTimeService.isNullDate( eventData.endDate ) ) {
        endDate = new Date( eventData.endDate );
        endDateUtc = dateTimeService.formatUTC( endDate.setHours( 23, 59, 59, 999 ) );
        filter = columnFilterUtility.createLessThanEqualsFilter( eventData.columnName, [ endDateUtc ] );
    }
    return filter;
};

/**
 * Add/remove the date filter information to the column provider.
 *
 * @param {Object} column - Column object
 * @param {Object} viewModelData - The viewModel data used for validation
 * @param {Object} facetDataProvider - The data provider of the facets.
 */
export let doDateFiltering = function( column, viewModelData, facetDataProvider, gridContextDispatcher ) {
    let newFilters = null;
    // Client validation
    const isFacetInputDefaultResult = isFacetInputDefault( facetDataProvider );
    if( exports.doDateValidation( viewModelData ) || !isFacetInputDefaultResult ) {
        newFilters = [];
        const filterData = {
            columnName: column.field,
            startDate: viewModelData.startDate.dbValue,
            endDate: viewModelData.endDate.dbValue
        };
        var filter = createDateFilter( filterData );
        if( filter ) {
            newFilters.push( filter );
        }
        if( !isFacetInputDefaultResult ) {
            const facetFilter = exports.processFacetValuesInFilter( column, facetDataProvider );
            if( facetFilter && facetFilter.values && facetFilter.values.length ) {
                newFilters.push( facetFilter );
            }
        }
    }

    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if ( columnMenuContext.filterError !== true && gridContextDispatcher ) {
        updateTableWithColumnFilters( gridContextDispatcher, column, newFilters );
    }
    return newFilters;
};

/**
 * Creates a numeric filter based on column filter information
 *
 * @param {Object} eventData - Event Data for filter
 * @returns {Object} filter object
 */
var createNumericFilter = function( eventData ) {
    var filter = null;
    // Set columnProvider.columnFilters so dataProvider/actions can use the information
    if( eventData.operation === columnFilterUtility.OPERATION_TYPE.RANGE &&
        isValidNumber( eventData.startNumber ) && isValidNumber( eventData.endNumber ) ) {
        filter = columnFilterUtility.createRangeFilter( eventData.columnName, [ eventData.startNumber, eventData.endNumber ] );
    } else if( eventData.operation === columnFilterUtility.OPERATION_TYPE.RANGE && isValidNumber( eventData.startNumber ) ) {
        filter = columnFilterUtility.createGreaterThanEqualsFilter( eventData.columnName, [ eventData.startNumber ] );
    } else if( eventData.operation === columnFilterUtility.OPERATION_TYPE.RANGE && isValidNumber( eventData.endNumber ) ) {
        filter = columnFilterUtility.createLessThanEqualsFilter( eventData.columnName, [ eventData.endNumber ] );
    } else if( eventData.operation === columnFilterUtility.OPERATION_TYPE.GREATER && isValidNumber( eventData.numberValue ) ) {
        filter = columnFilterUtility.createGreaterThanFilter( eventData.columnName, [ eventData.numberValue ] );
    } else if( eventData.operation === columnFilterUtility.OPERATION_TYPE.LESS && isValidNumber( eventData.numberValue ) ) {
        filter = columnFilterUtility.createLessThanFilter( eventData.columnName, [ eventData.numberValue ] );
    } else if( eventData.operation === columnFilterUtility.OPERATION_TYPE.EQUALS && isValidNumber( eventData.numberValue ) ) {
        filter = columnFilterUtility.createEqualsFilter( eventData.columnName, [ eventData.numberValue ] );
    }
    return filter;
};

/**
 * Add/remove the numeric filter information to the column provider.
 *
 * @param {Object} column - Column object
 * @param {Object} viewModelData - The viewModel data used for validation
 * @param {Object} facetDataProvider - The data provider of the facets.
 */
export let doNumericFiltering = function( column, viewModelData, facetDataProvider, gridContextDispatcher ) {
    let newFilters = null;
    const isFacetInputDefaultResult = isFacetInputDefault( facetDataProvider );
    if( exports.doNumericValidation( viewModelData ) || !isFacetInputDefaultResult ) {
        // Set columnProvider.columnFilters so dataProvider/actions can use the information
        newFilters = [];
        const filterData = {
            columnName: column.field,
            operation: viewModelData.operation.dbValue,
            numberValue: viewModelData.numberValue.dbValue,
            startNumber: viewModelData.startNumber.dbValue,
            endNumber: viewModelData.endNumber.dbValue
        };
        var filter = createNumericFilter( filterData );
        if( filter ) {
            newFilters.push( filter );
        }
        if( !isFacetInputDefaultResult ) {
            const facetFilter = exports.processFacetValuesInFilter( column, facetDataProvider );
            if( facetFilter && facetFilter.values && facetFilter.values.length ) {
                newFilters.push( facetFilter );
            }
        }
    }

    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if ( columnMenuContext.filterError !== true && gridContextDispatcher ) {
        updateTableWithColumnFilters( gridContextDispatcher, column, newFilters );
    }
    return newFilters;
};

/**
 * Find the type of filter to use by the column type.
 *
 * @param {String} columnType - Repersents the data type of the column
 *
 * @returns {String} The type of filter to use in the column menu
 */
export let getFilterTypeByColumnType = function( columnType ) {
    var returnFilterType = columnFilterUtility.FILTER_VIEW.TEXT;

    if( columnType ) {
        if( _.isString( columnType ) ) {
            columnType = columnType.toUpperCase();
        }

        var columnTypeString = columnType.toString();

        switch ( columnTypeString ) {
            case 'DOUBLE':
            case 'INTEGER':
            case 'FLOAT':
            case '3': // Client Property Type
            case '4': // Client Property Type Double
            case '5': // Client Property Type Integer
            case '7': // Client Property Type Short
                returnFilterType = columnFilterUtility.FILTER_VIEW.NUMERIC;
                break;
            case 'DATE':
            case '2': // Client Property Type Date
                returnFilterType = columnFilterUtility.FILTER_VIEW.DATE;
                break;
            case 'STRING':
            default:
                returnFilterType = columnFilterUtility.FILTER_VIEW.TEXT;
        }
    }

    return returnFilterType;
};

/**
 * Add filter information to the column object.
 *
 * @param {Object} column - Column to add filter information to
 * @param {String} currentFilterView - Filter view
 * @param {Array} existingFilters - Existing filter view to reference
 */
export let addFilterValue = function( column, currentFilterView, existingFilters ) {
    existingFilters = existingFilters || [];

    switch ( currentFilterView ) {
        case columnFilterUtility.FILTER_VIEW.NUMERIC:
            column.filter = {
                isFilterApplied: false,
                isDirty: false,
                view: currentFilterView,
                summaryText: '',
                operation: {
                    dbValue: 'equals',
                    uiValue: _localeTextBundle.equalsOperation,
                    hasLov: true,
                    isEditable: true,
                    isEnabled: true,
                    propApi: {},
                    propertyLabelDisplay: 'NO_PROPERTY_LABEL',
                    propertyName: 'operation',
                    type: 'STRING',
                    operationType: 'childcommand'
                },
                numberValue: {
                    dbValue: '',
                    isEnabled: true,
                    type: 'DOUBLE',
                    isRequired: false,
                    isEditable: true,
                    propertyLabelDisplay: 'NO_PROPERTY_LABEL'
                },
                startNumber: {
                    dbValue: '',
                    isEnabled: true,
                    type: 'DOUBLE',
                    isRequired: false,
                    isEditable: true,
                    propertyLabelDisplay: 'NO_PROPERTY_LABEL'
                },
                endNumber: {
                    dbValue: '',
                    isEnabled: true,
                    type: 'DOUBLE',
                    isRequired: false,
                    isEditable: true,
                    propertyLabelDisplay: 'NO_PROPERTY_LABEL'
                }
            };
            exports.setExistingNumericFilter( column.filter, existingFilters );
            break;
        case columnFilterUtility.FILTER_VIEW.DATE:
            column.filter = {
                isFilterApplied: false,
                view: currentFilterView,
                summaryText: '',
                startDate: {
                    dbValue: '',
                    dateApi: {},
                    isEnabled: true,
                    type: 'DATE'
                },
                endDate: {
                    dbValue: '',
                    dateApi: {},
                    isEnabled: true,
                    type: 'DATE'
                }
            };
            exports.setExistingDateFilter( column.filter, existingFilters );
            break;
        case columnFilterUtility.FILTER_VIEW.TEXT:
        default:
            column.filter = {
                isFilterApplied: false,
                isDirty: false,
                view: currentFilterView,
                summaryText: '',
                columnFilters: [],
                operation: {
                    dbValue: 'contains',
                    value: 'contains',
                    uiValue: _localeTextBundle.containsOperation
                },
                textValue: {
                    dbValue: ''
                }
            };
            exports.setExistingTextFilter( column.filter, existingFilters );
            // default to equals for custom filter
            if( currentFilterView !== columnFilterUtility.FILTER_VIEW.TEXT ) {
                column.filter.operation.dbValue = 'equals';
                column.filter.operation.uiValue = _localeTextBundle.equalsOperation;
                if ( existingFilters.length > 0 ) {
                    column.filter.isFilterApplied = true;
                }
            }
    }

    // Set values common to all types
    column.filter.isSelectedFacetValues = false;
    column.filter.blanksI18n = _localeTextBundle.blanks;
    column.filter.noMatchesFoundI18n = _localeTextBundle.noMatchesFound;
    column.filter.selectAllDefault = true;
    column.filter.showFilterFacets = false;

    exports.checkExistingFacetFilter( column.filter, existingFilters );

    if( column.filter.isFilterApplied ) {
        column.filter.columnFilters = existingFilters;
        column.filter.summaryText = exports.createFilterSummary( existingFilters, column.filter.view );
    } else {
        column.filter.columnFilters = [];
    }
};

/**
 * Sets the existing filters on to the new numeric filter.
 *
 * @param {Object} newFilter The new filter that was created.
 * @param {Array} existingFilters All the existing filters from column provider.
 */
export let setExistingNumericFilter = function( newFilter, existingFilters ) {
    _.forEach( existingFilters, function( currentFilter ) {
        if( columnFilterUtility.isValidRangeColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.RANGE;
            newFilter.operation.uiValue = _localeTextBundle.rangeOperation;
            newFilter.startNumber.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.endNumber.dbValue = Number( currentFilter.values[ 1 ] );
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidGreaterThanEqualsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.RANGE;
            newFilter.operation.uiValue = _localeTextBundle.rangeOperation;
            newFilter.startNumber.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidLessThanEqualsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.RANGE;
            newFilter.operation.uiValue = _localeTextBundle.rangeOperation;
            newFilter.endNumber.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidGreaterThanColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.GREATER;
            newFilter.operation.uiValue = _localeTextBundle.greaterThanOperation;
            newFilter.numberValue.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidLessThanColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.LESS;
            newFilter.operation.uiValue = _localeTextBundle.lessThanOperation;
            newFilter.numberValue.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidEqualsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.EQUALS;
            newFilter.operation.uiValue = _localeTextBundle.equalsOperation;
            newFilter.numberValue.dbValue = Number( currentFilter.values[ 0 ] );
            newFilter.isFilterApplied = true;
        }
    } );
};

/**
 * Sets the existing filters on to the new date filter.
 *
 * @param {Object} newFilter The new filter that was created.
 * @param {Array} existingFilters All the existing filters from column provider.
 */
export let setExistingDateFilter = function( newFilter, existingFilters ) {
    _.forEach( existingFilters, function( currentFilter ) {
        if( columnFilterUtility.isValidRangeColumnFilter( currentFilter ) ) {
            var startDate = new Date( currentFilter.values[ 0 ] );
            var endDate = new Date( currentFilter.values[ 1 ] );
            newFilter.startDate.dbValue = startDate.getTime();
            newFilter.endDate.dbValue = endDate.getTime();
            newFilter.isFilterApplied = true;
        } else if( columnFilterUtility.isValidGreaterThanEqualsColumnFilter( currentFilter ) ) {
            startDate = new Date( currentFilter.values[ 0 ] );
            newFilter.startDate.dbValue = startDate.getTime();
            newFilter.isFilterApplied = true;
        } else if( columnFilterUtility.isValidLessThanEqualsColumnFilter( currentFilter ) ) {
            endDate = new Date( currentFilter.values[ 0 ] );
            newFilter.endDate.dbValue = endDate.getTime();
            newFilter.isFilterApplied = true;
        }
    } );
};

/**
 * Sets the existing filters on to the new text filter.
 *
 * @param {Object} newFilter The new filter that was created.
 * @param {Array} existingFilters All the existing filters from column provider.
 */
export let setExistingTextFilter = function( newFilter, existingFilters ) {
    _.forEach( existingFilters, function( currentFilter ) {
        if( columnFilterUtility.isValidContainsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.CONTAINS;
            newFilter.operation.uiValue = _localeTextBundle.containsOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidNotContainsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.NOT_CONTAINS;
            newFilter.operation.uiValue = _localeTextBundle.notContainsOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidStartsWithColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.STARTS_WITH;
            newFilter.operation.uiValue = _localeTextBundle.startsWithOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidEndsWithColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.ENDS_WITH;
            newFilter.operation.uiValue = _localeTextBundle.endsWithOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
            return false;
        } else if( columnFilterUtility.isValidEqualsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.EQUALS;
            newFilter.operation.uiValue = _localeTextBundle.equalsOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
        } else if( columnFilterUtility.isValidNotEqualsColumnFilter( currentFilter ) ) {
            newFilter.operation.dbValue = columnFilterUtility.OPERATION_TYPE.NOT_EQUALS;
            newFilter.operation.uiValue = _localeTextBundle.notEqualsOperation;
            newFilter.textValue.dbValue = currentFilter.values[ 0 ];
            newFilter.isFilterApplied = true;
        }
    } );
};

/**
 * Sets if filter is Applied for facets based on existing filters
 * @param {Object} newFilter - the new filter object that was created
 * @param {Object} existingFilters - The existing filters
 */
export let checkExistingFacetFilter = function( newFilter, existingFilters ) {
    _.forEach( existingFilters, function( filter ) {
        if( ( filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_EQUALS || filter.operation === columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_NOT_EQUALS ) &&
            filter.values && filter.values.length > 0 ) {
            newFilter.showFilterFacets = true;
            newFilter.selectAllDefault = false;
            newFilter.isFilterApplied = true;
        }
    } );
};

/**
 * Update the column with filter information.
 *
 * @param {Object} column columnInfo
 * @param {Array} existingFilters existing column filter
 */
export let updateColumnFilter = function( column, existingFilters ) {
    var currentFilterView = column.filterDefinition;

    if( !currentFilterView ) {
        currentFilterView = exports.getFilterTypeByColumnType( column.dataType );
    }

    exports.addFilterValue( column, currentFilterView, existingFilters );
};

/**
 * Reset the column with default filter information.
 *
 * @param {Object} column columnInfo
 */
export let resetColumnFilter = function( column ) {
    exports.updateColumnFilter( column, [] );
};

/**
 * Removes column filters that no longer apply to the table.
 *
 * @param {Object} columnProvider - Column provider used to store the filters
 * @param {Array} columns - columns in the table
 */
export let removeStaleFilters = function( columnProvider, columns ) {
    if( columnProvider && columns && columns.length ) {
        var columnFilters = columnProvider.getColumnFilters();
        if( columnFilters && columnFilters.length ) {
            var newColumnFilters = _.filter( columnFilters, function( currentFilter ) {
                var isValidFilter = false;
                _.forEach( columns, function( currentColumn ) {
                    if( ( currentFilter.columnName === currentColumn.propertyName || currentFilter.columnName === currentColumn.field ) && !currentColumn.hiddenFlag ) {
                        isValidFilter = true;
                        return false;
                    }
                    return true;
                } );
                return isValidFilter;
            } );
            columnProvider.setColumnFilters( newColumnFilters );
        }
    }
};

/**
 * Create a filter summary text of the applied filter.
 *
 * @param {Array} columnFilters - Column filter objects that contains operation and values
 * @param {String} filterView - filter view in use
 *
 * @returns {String} returns the text summary of the applied filter
 */
export let createFilterSummary = function( columnFilters, filterView ) {
    var filterSummary = '';
    var filterCount = columnFilters.length;
    if( !columnFilters || filterCount < 1 ) {
        return filterSummary;
    }

    for( var i = 0; i < filterCount; i++ ) {
        var columnFilter = columnFilters[ i ];
        var firstValue = columnFilter.values[ 0 ];
        var secondValue = columnFilter.values.length > 1 ? columnFilter.values[ 1 ] : '';

        // Convert date values to readable strings
        if( filterView === columnFilterUtility.FILTER_VIEW.DATE ) {
            var firstValueDateTime = Date.parse( firstValue );
            if( firstValueDateTime ) {
                var firstValueDate = new Date( firstValueDateTime );
                firstValue = firstValueDate.toLocaleDateString();
            }
            if( secondValue ) {
                var secondValueDateTime = Date.parse( secondValue );
                if( secondValueDateTime ) {
                    var secondValueDate = new Date( secondValueDateTime );
                    secondValue = secondValueDate.toLocaleDateString();
                }
            }
        }

        var arrayAsString = '';
        for( var j = 0; j < columnFilter.values.length; j++ ) {
            if( j > 0 && j < columnFilter.values.length ) {
                arrayAsString += ',';
            }

            var value = columnFilter.values[ j ];
            if( value === '' ) {
                arrayAsString += _localeTextBundle.blanks;
            } else {
                arrayAsString += value;
            }
        }

        // Set the filter summary text based on the operation type
        switch ( columnFilter.operation ) {
            case columnFilterUtility.OPERATION_TYPE.RANGE:
                filterSummary += _localeTextBundle.greaterThanEqualsFilterTooltip;
                filterSummary += ' "' + firstValue + '" ';
                filterSummary += _localeTextBundle.andFilterTooltip + ' ';
                filterSummary += _localeTextBundle.lessThanEqualsFilterTooltip;
                filterSummary += ' "' + secondValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.GREATER:
                filterSummary += _localeTextBundle.greaterThanFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.GREATER_EQUALS:
                filterSummary += _localeTextBundle.greaterThanEqualsFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.LESS:
                filterSummary += _localeTextBundle.lessThanFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.LESS_EQUALS:
                filterSummary += _localeTextBundle.lessThanEqualsFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.EQUALS:
            case columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_EQUALS:
                filterSummary += _localeTextBundle.equalsFilterTooltip;
                filterSummary += ' "' + arrayAsString + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.NOT_EQUALS:
            case columnFilterUtility.OPERATION_TYPE.CASE_SENSITIVE_NOT_EQUALS:
                filterSummary += _localeTextBundle.notEqualsFilterTooltip;
                filterSummary += ' "' + arrayAsString + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.CONTAINS:
                filterSummary += _localeTextBundle.containsFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.NOT_CONTAINS:
                filterSummary += _localeTextBundle.notContainsFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.STARTS_WITH:
                filterSummary += _localeTextBundle.startsWithFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            case columnFilterUtility.OPERATION_TYPE.ENDS_WITH:
                filterSummary += _localeTextBundle.endWithFilterTooltip;
                filterSummary += ' "' + firstValue + '"';
                break;
            default:
                filterSummary += filterView;
        }

        if( filterCount > 1 && i === 0 ) {
            filterSummary += ', ';
        }
    }
    return filterSummary;
};

/**
 * Remove all the filters from the column provider, reset the dataProvider column filters.
 *
 * @param {Object} dataProvider data provider that contains the columns
 * @param {Object} columnProvider column provider that contains the column filters
 */
export let removeAllFilters = function( dataProvider, columnProvider ) {
    var columns = dataProvider.cols;
    for( var i = 0; i < columns.length; i++ ) {
        exports.setColumnFilterStale( columns[ i ] );
        exports.resetColumnFilter( columns[ i ] );
    }
    columnProvider.setColumnFilters( [] );
};

/**
 * Check if any of the columns have a filter applied.
 *
 * @param {Object} dataProvider data provider containing all the columns
 * @returns {Boolean} true/false based on if any column has a filter applied
 */
export let isColumnFilterApplied = function( dataProvider ) {
    var columns = dataProvider.cols;
    for( var i = 0; i < columns.length; i++ ) {
        if( columns[ i ].filter && columns[ i ].filter.isFilterApplied ) {
            return true;
        }
    }
    return false;
};

/**
 * Select All toggle has been switched, switch all facets to checked/unchecked.
 *
 * @param {boolean} selectAllValue - Value if select all is checked
 * @param {Object} facetDataProvider - data provider of facet list
 * @returns {boolean} selectAllValue
 */
export let selectAllInputChanged = function( gridContextDispatcher, column, viewModelData, selectAllValue, facetDataProvider, isBulkEditing, isFilterDisabled ) {
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    columnMenuContext.isSelectedFacetValues = !selectAllValue;
    const facetObjects = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
    _.forEach( facetObjects, function( currentFacetObject ) {
        propertyService.setValue( currentFacetObject, selectAllValue );
    } );

    const columnMenuData = { columnName: column.field };
    columnMenuData.facetValues = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
    columnMenuData.facetValuesTotalFound = facetDataProvider.getViewModelCollection().getTotalObjectsFound();
    exports.updateColumnMenuData( gridContextDispatcher, columnMenuData );

    checkForFilterDisability( column, viewModelData, true, facetDataProvider, isBulkEditing, isFilterDisabled );
    return selectAllValue;
};

const getTypeFilter = ( column, viewModel ) => {
    var typeFilter = null;
    var eventData = null;
    if ( column.filter.view === columnFilterUtility.FILTER_VIEW.TEXT && viewModel.data.textValue.dbValue ) {
        eventData = {
            columnName: column.field,
            operation: viewModel.data.operation.dbValue,
            textValue: viewModel.data.textValue.dbValue
        };
        typeFilter = createTextFilter( eventData );
    } else if ( column.filter.view === columnFilterUtility.FILTER_VIEW.NUMERIC ) {
        eventData = {
            columnName: column.field,
            operation: viewModel.data.operation.dbValue,
            numberValue: viewModel.data.numberValue.dbValue,
            startNumber: viewModel.data.startNumber.dbValue,
            endNumber: viewModel.data.endNumber.dbValue
        };
        if ( exports.doNumericValidation( viewModel.data ) ) {
            typeFilter = createNumericFilter( eventData );
        }
    } else if ( column.filter.view === columnFilterUtility.FILTER_VIEW.DATE ) {
        eventData = {
            columnName: column.field,
            startDate: viewModel.data.startDate.dbValue,
            endDate: viewModel.data.endDate.dbValue
        };
        if ( exports.doDateValidation( viewModel.data ) ) {
            typeFilter = createDateFilter( eventData );
        }
    }
    return typeFilter;
};

/**
 * Call the 'getFacets' function from the dataProvider if available.
 *
 * @param {Object} gridContextDispatcher - table data dispatcher
 * @param {Object} column - column definition object
 * @param {Object} viewModel - view model of the table
 * @param {Object} subPanelContext - menu context information
 * @param {Object} facetDataProvider - The data provider of the facets.
 * @param {Boolean} reload - if reloading facets
 * @param {Object} isFilterDisabled - atomic data to determine filter disability
 */
export let loadFacetValues = async function( gridContextDispatcher, column, viewModel, subPanelContext, facetDataProvider, reload, isFilterDisabled ) {
    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( columnMenuContext && !columnMenuContext.isFacetLoading ) {
        columnMenuContext.isFacetLoading = true;
        if( subPanelContext.hasFilterFacetAction && viewModel.data.showFilters.dbValue ) {
            let filterFacetValues = [];
            let filterFacetValuesTotalFound = 0;
            if( !column.filter.isStale && column.filter.facetValues && reload ) {
                filterFacetValues = column.filter.facetValues;
                filterFacetValuesTotalFound = column.filter.facetValuesTotalFound;
                facetDataProvider.update( filterFacetValues, filterFacetValuesTotalFound );
                exports.checkForFilterDisability( column, viewModel.data, subPanelContext.hasFilterFacetAction, facetDataProvider, subPanelContext.gridContext.isBulkediting, isFilterDisabled );
            } else {
                var filters = [];
                var typeFilter = getTypeFilter( column, viewModel );

                if( typeFilter ) {
                    filters.push( typeFilter );
                }

                // Add other column's filters to input
                _.forEach( subPanelContext.existingColumnFilters, function( existingFilter ) {
                    if( existingFilter.columnName !== column.propertyName && existingFilter.columnName !== column.field ) {
                        filters.push( existingFilter );
                    }
                } );

                var startIndex = 0;
                const facetObjects = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
                let defaultFacetValue = columnMenuContext.defaultFacetSelection !== false;
                if( !reload && facetObjects ) {
                    startIndex = facetObjects.length - 1;
                } else if( columnMenuContext.isFacetsInitialized && reload ) {
                    // reset show all since data is being reloaded
                    defaultFacetValue = true;
                }

                var filterFacetInput = {
                    column: column,
                    columnFilters: filters,
                    maxToReturn: 50,
                    startIndex: startIndex
                };

                let filterFacetResults = await subPanelContext.getFilterFacetsAction( filterFacetInput );

                const selectAllProperty = {
                    propertyDisplayName: _localeTextBundle.selectAll,
                    typex: 'BOOLEAN',
                    serverValue: SELECT_ALL_PROPERTY
                };

                if( filterFacetResults && filterFacetResults.values && filterFacetResults.values.length ) {
                    // Add select all if reload
                    if( reload ) {
                        filterFacetValues.push( selectAllProperty );
                        if( columnMenuContext.isFacetsInitialized ) {
                            propertyService.setValue( selectAllProperty, true );
                        } else {
                            propertyService.setValue( selectAllProperty, column.filter.selectAllDefault );
                        }
                    }

                    _.forEach( filterFacetResults.values, function( value ) {
                        let fieldValue = value;
                        if( !fieldValue ) {
                            fieldValue = column.filter.blanksI18n;
                        }
                        const facetProperty = {
                            propertyDisplayName: fieldValue,
                            typex: 'BOOLEAN',
                            serverValue: value
                        };
                        let facetValue = defaultFacetValue;

                        // Load existing facet selections into values
                        if( !columnMenuContext.isFacetsInitialized && column.filter.columnFilters.length ) {
                            if( isExistingFacetValueNotEquals( column.filter.columnFilters, value ) ) {
                                facetValue = false;
                            }

                            if( !facetValue && isExistingFacetValueEquals( column.filter.columnFilters, value ) ) {
                                facetValue = true;
                            }
                        }

                        propertyService.setValue( facetProperty, facetValue );
                        filterFacetValues.push( facetProperty );
                    } );
                    filterFacetValuesTotalFound = filterFacetResults.totalFound + 1;
                    if( reload ) {
                        facetDataProvider.update( filterFacetValues, filterFacetValuesTotalFound );
                    }
                } else {
                    facetDataProvider.update( [] );
                }

                const columnMenuData = { columnName: column.field };
                let facetProperties = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
                if( !reload ) {
                    facetProperties = _.concat( facetProperties, filterFacetValues );
                }
                columnMenuData.facetValues = facetProperties;
                columnMenuData.facetValuesTotalFound = filterFacetValuesTotalFound;
                columnMenuData.isStale = false;
                exports.updateColumnMenuData( gridContextDispatcher, columnMenuData );
            }

            columnMenuContext.isFacetsInitialized = true;
            columnMenuContext.isFacetLoading = false;

            return {
                results: filterFacetValues,
                totalFound: filterFacetValuesTotalFound
            };
        }
        columnMenuContext.isFacetLoading = false;
    }
    return {
        results: [],
        totalFound: 0
    };
};

/**
 * Update the facet values, waiting for user entry.
 */
export let updateFacetValuesDebounce = _.debounce( loadFacetValues, 500, {
    maxWait: 10000,
    trailing: true,
    leading: false
} );

/**
 * Remove a filter from the columnProvider and reset the column's filter.
 *
 * @param {Object} column column def object
 * @param {Object} columnProvider column provider for the data
 * @param {Object} dataProvider data provider for the data
 */
export let removeFilter = function( column, columnProvider, dataProvider ) {
    let columnFiltersToUpdate = columnProvider.getColumnFilters();
    columnFilterUtility.removeColumnFilter( columnFiltersToUpdate, column.field );
    columnProvider.setColumnFilters( columnFiltersToUpdate );

    // Set all filters as stale
    _.forEach( dataProvider.cols, function( col ) {
        if( col.field === column.field ) {
            exports.resetColumnFilter( col );
        } else {
            exports.setColumnFilterStale( col );
        }
    } );
};

/**
 * Remove a filter action from the menu button.
 *
 * @param {Object} column column def object
 */
export let clearFilterFromMenu = function( column, gridContextDispatcher ) {
    const columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    columnMenuContext.isClearActionUsed = true;

    const columnFilterInfo = {
        column: column
    };
    gridContextDispatcher( {
        type: 'UPDATE_VALUES',
        columnFilterInfo: columnFilterInfo,
        columnMenuData: {
            columnName: column.field
        }
    } );

    // Return empty array because there are no filters
    return [];
};

/**
 * Save the information of type-based filter.
 *
 * @param {Object} column - table column information
 * @param {Object} viewModelData - column menu view model data
 */
export let updateViewTypeMenuData = function( gridContextDispatcher, column, viewModelData ) {
    const columnMenuData = { columnName: column.field };

    switch ( column.filter.view ) {
        case columnFilterUtility.FILTER_VIEW.NUMERIC:
            columnMenuData.startNumber = viewModelData.startNumber;
            columnMenuData.endNumber = viewModelData.endNumber;
            columnMenuData.numberValue = viewModelData.numberValue;
            columnMenuData.operation = viewModelData.operation;
            break;
        case columnFilterUtility.FILTER_VIEW.DATE:
            columnMenuData.startDate = viewModelData.startDate;
            columnMenuData.endDate = viewModelData.endDate;
            break;
        case columnFilterUtility.FILTER_VIEW.TEXT:
            columnMenuData.textValue = viewModelData.textValue;
            columnMenuData.operation = viewModelData.operation;
            break;
    }

    if( columnMenuData.operation ) {
        columnMenuData.operation.dbValue = viewModelData.operation.dbValue;
    }

    columnMenuData.isStale = true;

    exports.updateColumnMenuData( gridContextDispatcher, columnMenuData );
    return columnMenuData;
};

/**
 * Validate filter enable/disable based on text filter.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let textEnableFilterToggle = function( isFilterDisabled, column, viewModelData, isBulkEditing ) {
    if( isTextFilterInputDefault( column, viewModelData ) || isBulkEditing ) {
        disableFiltering( isFilterDisabled );
    } else {
        enableFiltering( isFilterDisabled );
    }
};

/**
 * Text value changes, revalidate filtering state.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let textFilterInputChanged = function( gridContextDispatcher, column, viewModelData, isBulkEditing, isFilterDisabled ) {
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( column.filter && columnMenuContext && columnMenuContext.isMenuIntialized ) {
        exports.updateViewTypeMenuData( gridContextDispatcher, column, viewModelData );
        exports.textEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
    }
};

/**
 * Validate filter enable/disable based on date filter.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let dateEnableFilterToggle = function( isFilterDisabled, column, viewModelData, isBulkEditing ) {
    if( isDateFilterInputDefault( column, viewModelData ) || isBulkEditing ) {
        disableFiltering( isFilterDisabled );
    } else {
        enableFiltering( isFilterDisabled );
    }
};

/**
 * Date value changes, revalidate filtering state.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let dateFilterInputChanged = function( gridContextDispatcher, column, viewModelData, isBulkEditing, isFilterDisabled ) {
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( column.filter && columnMenuContext && columnMenuContext.isMenuIntialized ) {
        exports.updateViewTypeMenuData( gridContextDispatcher, column, viewModelData );
        exports.dateEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
    }
};

/**
 * Validate filter enable/disable based on numeric filter.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let numericEnableFilterToggle = function( isFilterDisabled, column, viewModelData, isBulkEditing ) {
    if( isNumericFilterInputDefault( column, viewModelData ) || isBulkEditing ) {
        disableFiltering( isFilterDisabled );
    } else {
        enableFiltering( isFilterDisabled );
    }
};

/**
 * Numeric value changes, revalidate filtering state.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let numericFilterInputChanged = function( gridContextDispatcher, column, viewModelData, isBulkEditing, isFilterDisabled ) {
    let columnMenuContext = appContextService.getCtx( 'columnMenuContext' );
    if( column.filter && columnMenuContext && columnMenuContext.isMenuIntialized ) {
        exports.updateViewTypeMenuData( gridContextDispatcher, column, viewModelData );
        exports.numericEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
    }
};

/**
 * Facet value changes, revalidate filtering state.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 * @param {Object} facetDataProvider - facet values data provider
 * @param {Object} facetParameters - facet information from checkbox that was changed
 */
export let filterFacetInputChanged = function( gridContextDispatcher, column, viewModelData, facetDataProvider, facetParameters, isBulkEditing, isFilterDisabled ) {
    if( column.filter ) {
        if( facetParameters.item.serverValue === SELECT_ALL_PROPERTY ) {
            return selectAllInputChanged( gridContextDispatcher, column, viewModelData, facetParameters.checked, facetDataProvider, isBulkEditing, isFilterDisabled );
        }

        let selectAllFacet = null;
        let facetProperties = facetDataProvider.getViewModelCollection().getLoadedViewModelObjects();
        _.forEach( facetProperties, function( currentFacet ) {
            if( currentFacet.serverValue === SELECT_ALL_PROPERTY ) {
                selectAllFacet = currentFacet;
                return false;
            }
        } );

        const isFacetInputDefaultValue = isFacetInputDefault( facetDataProvider );

        if( selectAllFacet && selectAllFacet.dbValue === false && isFacetInputDefaultValue ) {
            propertyService.setValue( selectAllFacet, true );
        } else if( selectAllFacet && selectAllFacet.dbValue === true && facetParameters.checked === false ) {
            propertyService.setValue( selectAllFacet, false );
        }

        const columnMenuData = { columnName: column.field };
        columnMenuData.facetValues = facetProperties;
        columnMenuData.facetValuesTotalFound = facetDataProvider.getViewModelCollection().getTotalObjectsFound();
        exports.updateColumnMenuData( gridContextDispatcher, columnMenuData );

        checkForFilterDisability( column, viewModelData, true, facetDataProvider, isBulkEditing, isFilterDisabled );

        return selectAllFacet ? selectAllFacet.dbValue : true;
    }
    return true;
};

/**
 * Check for filter disability state based on the filter view.
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let checkForFilterDisability = function( column, viewModelData, hasFilterFacetAction, facetDataProvider, isBulkEditing, isFilterDisabled ) {
    if( isBulkEditing ) {
        disableFiltering( isFilterDisabled );
    } else {
        if( hasFilterFacetAction && areAllFacetsUnchecked( facetDataProvider ) ) {
            disableFiltering( isFilterDisabled );
        } else if( hasFilterFacetAction && !isFacetInputDefault( facetDataProvider ) ) {
            enableFiltering( isFilterDisabled );
        } else if( column.filter && column.filter.view ) {
            switch ( column.filter.view ) {
                case columnFilterUtility.FILTER_VIEW.NUMERIC:
                    exports.numericEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
                    break;
                case columnFilterUtility.FILTER_VIEW.DATE:
                    exports.dateEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
                    break;
                case columnFilterUtility.FILTER_VIEW.TEXT:
                    exports.textEnableFilterToggle( isFilterDisabled, column, viewModelData, isBulkEditing );
                    break;
                default: // enable filtering button by default when custom filter
                    enableFiltering( isFilterDisabled );
            }
        }
    }
};

/**
 * Show Facet Filters Toggle button changed function
 * Saves the toggle state for that column and calls dataprovider for
 * facets if needed
 *
 * @param {Object} column - column definition object
 * @param {Object} viewModelData - column menu view model data
 */
export let showFiltersToggleChanged = function( gridContextDispatcher, column, viewModelData ) {
    const columnMenuData = { columnName: column.field };

    columnMenuData.showFilters = viewModelData.showFilters;
    exports.updateColumnMenuData( gridContextDispatcher, columnMenuData );
};

/**
 * Save the menu information to be loaded if re-opened.
 *
 * @param {String} columnName - Column that menu was used
 * @param {Object} columnMenuData - menu information to be saved
 */
export let updateColumnMenuData = function( gridContextDispatcher, columnMenuData ) {
    gridContextDispatcher( {
        type: 'UPDATE_VALUES',
        columnMenuData: columnMenuData
    } );
};

/**
 * Sets the column's filter as stale
 *
 * @param {Object} column - column definition object
 */
export let setColumnFilterStale = function( column ) {
    if( column.filter ) {
        column.filter.isStale = true;
    }
};

/**
 * Copies over filter data from old column to new one
 * and sets the filter as stale on hidden
 *
 * @param {Object} newColumn - new column info
 * @param {Object} oldColumn - old column info
 */
export let updateNewColumnFilter = function( newColumn, oldColumn ) {
    if( newColumn.field === oldColumn.field && newColumn.filter && oldColumn.filter ) {
        newColumn.filter.isSelectedFacetValues = oldColumn.filter.isSelectedFacetValues;
        newColumn.filter.isStale = newColumn.hiddenFlag || oldColumn.filter.isStale;

        newColumn.filter = { ...newColumn.filter, ...oldColumn.filter.columnMenuData };
        if( oldColumn.filter.columnMenuData &&
            oldColumn.filter.columnMenuData.showFilters &&
            oldColumn.filter.columnMenuData.showFilters.dbValue ||
            oldColumn.filter.showFilterFacets ) {
            newColumn.filter.showFilterFacets = true;
        }
    }
};

/**
 * Load the locale text.
 */
export let loadConfiguration = async function() {
    _localeTextBundle.invalidNumberRange = await localeService.getLocalizedTextFromKey( 'UIMessages.invalidNumberRange' );
    _localeTextBundle.invalidDate = await localeService.getLocalizedTextFromKey( 'UIMessages.invalidDate' );
    _localeTextBundle.equalsOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.equalsOperation' );
    _localeTextBundle.containsOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.containsOperation' );
    _localeTextBundle.selectAll = await localeService.getLocalizedTextFromKey( 'UIMessages.selectAll' );
    _localeTextBundle.blanks = await localeService.getLocalizedTextFromKey( 'UIMessages.blanks' );
    _localeTextBundle.noMatchesFound = await localeService.getLocalizedTextFromKey( 'UIMessages.noMatchesFound' );
    _localeTextBundle.rangeOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.rangeOperation' );
    _localeTextBundle.greaterThanOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.greaterThanOperation' );
    _localeTextBundle.lessThanOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.lessThanOperation' );
    _localeTextBundle.notContainsOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.notContainsOperation' );
    _localeTextBundle.startsWithOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.startsWithOperation' );
    _localeTextBundle.endsWithOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.endsWithOperation' );
    _localeTextBundle.notEqualsOperation = await localeService.getLocalizedTextFromKey( 'UIMessages.notEqualsOperation' );

    _localeTextBundle.andFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.andFilterTooltip' );
    _localeTextBundle.greaterThanFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.greaterThanFilterTooltip' );
    _localeTextBundle.greaterThanEqualsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.greaterThanEqualsFilterTooltip' );
    _localeTextBundle.lessThanFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.lessThanFilterTooltip' );
    _localeTextBundle.lessThanEqualsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.lessThanEqualsFilterTooltip' );
    _localeTextBundle.equalsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.equalsFilterTooltip' );
    _localeTextBundle.notEqualsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.notEqualsFilterTooltip' );
    _localeTextBundle.containsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.containsFilterTooltip' );
    _localeTextBundle.notContainsFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.notContainsFilterTooltip' );
    _localeTextBundle.startsWithFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.startsWithFilterTooltip' );
    _localeTextBundle.endWithFilterTooltip = await localeService.getLocalizedTextFromKey( 'UIMessages.endWithFilterTooltip' );
};

/**
 * Setup to listen to changes in locale.
 *
 * @param {String} locale - String with the updated locale value.
 */
eventBus.subscribe( 'locale.changed', function() {
    loadConfiguration();
}, 'awColumnFilterService' );

exports = {
    loadConfiguration,
    doTextValidation,
    doNumericValidation,
    processFacetValuesInFilter,
    doTextFiltering,
    doDateValidation,
    doDateFiltering,
    doNumericFiltering,
    getFilterTypeByColumnType,
    addFilterValue,
    setExistingNumericFilter,
    setExistingDateFilter,
    setExistingTextFilter,
    checkExistingFacetFilter,
    updateColumnFilter,
    resetColumnFilter,
    removeStaleFilters,
    createFilterSummary,
    removeAllFilters,
    isColumnFilterApplied,
    loadFacetValues,
    updateFacetValuesDebounce,
    removeFilter,
    textEnableFilterToggle,
    textFilterInputChanged,
    dateEnableFilterToggle,
    dateFilterInputChanged,
    numericEnableFilterToggle,
    numericFilterInputChanged,
    filterFacetInputChanged,
    checkForFilterDisability,
    showFiltersToggleChanged,
    setColumnFilterStale,
    updateNewColumnFilter,
    setFilters,
    initializeMenu,
    selectAllInputChanged,
    clearFilterFromMenu,
    updateViewTypeMenuData,
    updateColumnMenuData,
    updateTableWithColumnFilters
};
export default exports;

loadConfiguration();
