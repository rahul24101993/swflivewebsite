// Copyright (c) 2021 Siemens
import AwPopup from 'viewmodel/AwPopupViewModel';
import AwPopupCommandBar from 'viewmodel/AwPopupCommandBarViewModel';
import { AwServerVisibilityPopupCommandBar } from 'js/AwServerVisibilityCommandBarService';
import AwInclude from 'viewmodel/AwIncludeViewModel';
import narrowModeService from 'js/aw.narrowMode.service';
import SplmTableCellEditor from 'viewmodel/SplmTableCellEditorViewModel';
import awSPLMTableNativeService from 'js/awSPLMTableNativeService';

const getColumnMenuName = ( gridContextPlaceholder ) => {
    let columnMenuName = 'splmTableTextColumnMenu';
    if( gridContextPlaceholder.columnDef && gridContextPlaceholder.columnDef.filter && gridContextPlaceholder.columnDef.filter.view ) {
        columnMenuName = gridContextPlaceholder.columnDef.filter.view;
    }
    return columnMenuName;
};

export const initializeTable = ( elemRefList, props ) => {
    if( props.reusable === 'true' ) {
        var dataCtxNode = props.dataCtxNode;
        //updating dataCtxNode with props
        if( props.propsCallback ) {
            dataCtxNode.props = props.propsCallback();
            dataCtxNode.getProps = props.propsCallback;
        }
        return awSPLMTableNativeService.initializeTable( elemRefList.get( 'tableElem' ).current,
            props.dataProviderInstance.vmCollectionObj.vmCollection, dataCtxNode, props );
    }
};

export const updateTableData = ( tableCallbacks, vmCollection, props ) => {
    if( tableCallbacks && props.reusable === 'true' ) {
        tableCallbacks.updateVmCollection( vmCollection );
    }
};

export const updateSortDirection = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updateSortDirection( props.gridContextPlaceholder.currentColumnIndex, props.gridContextPlaceholder.newColumnIndex, props.gridContextPlaceholder.sortDirection );
    }
};

export const updatePinColumn = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updatePinColumn( props.gridContextPlaceholder.pinColumnData.columnDef, props.gridContextPlaceholder.pinColumnData.isFreezeAction,
            props.gridContextPlaceholder.pinColumnData.defaultColumnPinIndex );
    }
};

export const updateDynamicRowHeightStatus = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updateDynamicRowHeight( props.gridContextPlaceholder.dynamicRowHeightStatus );
    }
};

export const hideColumn = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.hideColumn( props.gridContextPlaceholder.hideColumnField );
    }
};

export const columnFilterApplied = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.columnFilterApplied( props.gridContextPlaceholder.columnFilterInfo );
    }
};

export const columnsArranged = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.columnsArranged( props.gridContextPlaceholder.columnArrangeData );
    }
};

export const updateColumnMenuData = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updateColumnMenuData( props.gridContextPlaceholder.columnMenuData );
    }
};

export const updateEditState = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updateEditState( props );
    }
};

export const updateTableColumns = ( tableCallbacks, props ) => {
    if( tableCallbacks ) {
        tableCallbacks.updateTableColumns( props.dataProviderInstance.columnConfig.columns );
    }
};

export const editStateUpdated = ( tableCallbacks ) => {
    if( tableCallbacks ) {
        tableCallbacks.editStateUpdated();
    }
};

export const destroyTable = ( tableCallbacks, props ) => {
    if( tableCallbacks && props.reusable === 'true' ) {
        tableCallbacks.destroy();
    }
};

export const setMultiSelectionEnabledInTable = ( props ) => {
    if( props && props.dataProviderInstance ) {
        if( props.showCheckBox ) {
            props.dataProviderInstance.selectionModel.setMultiSelectionEnabled( true );
        } else {
            props.dataProviderInstance.selectionModel.setMultiSelectionEnabled( false );
        }
    }
};

export const refreshTable = ( tableCallbacks ) => {
    if( tableCallbacks ) {
        tableCallbacks.refreshTable();
    }
};

export const updateGridOptions = ( tableCallbacks, props ) => {
    if( tableCallbacks && props ) {
        tableCallbacks.updateGridOptionsForTableInstance( props );
    }
};

export const handleSelectionChange = ( tableCallbacks, props ) => {
    if( tableCallbacks && props && props.reusable === 'true' && props.selectionData ) {
        tableCallbacks.updateContentRowSelection();
    }
};

export const selectRows = ( tableCallbacks, props ) => {
    if ( tableCallbacks && props && props.reusable === 'true' && props.selectionData && props.dataProviderInstance &&
             props.dataProviderInstance.selectionModel ) {
        let resetSelectRows = false;
        if ( props.tableContext && props.tableContext.selectRows &&  props.tableContext.selectRows.value === 'all'  ) {
            props.dataProviderInstance.selectionModel.setMultiSelectionEnabled( true );
            props.dataProviderInstance.selectAll();
            resetSelectRows = true;
            tableCallbacks.updateContentRowSelection();
        }else if( props.tableContext && props.tableContext.selectRows && props.tableContext.selectRows.value === 'none' ) {
            // When we do de-selectAll and also showCheckBoxes are still opened, we should not reset multiSelection to false.
            // MultiSelection should be set to false when checkBoxes are not shown and when selections are cleared.
            if ( props.showCheckBox !== true ) {
                props.dataProviderInstance.selectionModel.setMultiSelectionEnabled( false );
            }
            props.dataProviderInstance.selectNone();
            resetSelectRows = true;
            tableCallbacks.updateContentRowSelection();
        }
        // Reset selectRows State. This is needed when the table goes for re-render for some state updates, we should not be doing all or none again.
        if ( resetSelectRows ) {
            let newSelectRows = { ...props.tableContext.selectRows.getValue() };
            newSelectRows.value = '';
            props.tableContext.selectRows.update( newSelectRows );
        }
    }
};

/**
 * render function for AwSplmTable
 * @param {*} props context for render function interpolation
 * @returns {JSX.Element} react component
 */
export const awSplmTableRenderFunction = ( props ) => {
    const { columnProviderInstance, dataProviderInstance, gridid, gridOptions, actions, gridContextPlaceholder, dataCtxNode, ctx, commandContext = {},
        elementRefList, gridContextDispatcher } = props;
    const element = props.reusable === 'true' ? elementRefList.get( 'tableElem' ) : dataProviderInstance.getRootReference();
    const commandOverrides = dataProviderInstance.getCommandOverrides();

    // Add popups to gridOptions so table can call popup.show()/popup.hide()
    gridOptions.popupContext = {
        columnMenuPopup: actions.columnMenuPopup,
        gridMenuPopup: actions.gridMenuPopup,
        contextMenuPopup: actions.contextMenuPopup,
        editArrayPopup: actions.editArrayPopup
    };
    // add support for vmo
    const isArrangeSupported = columnProviderInstance.isArrangeSupported();
    const isNarrowMode = narrowModeService.isNarrowMode();
    const gridMenuContext = {
        anchor: commandOverrides.gridMenuCommandsAnchor ? commandOverrides.gridMenuCommandsAnchor : 'aw_gridMenu',
        dataProvider: dataProviderInstance,
        columnProvider: columnProviderInstance,
        gridId: gridid,
        gridOptions: gridOptions,
        isArrangeSupported: isArrangeSupported,
        isNarrowMode: isNarrowMode,
        isColumnFilterApplied: dataProviderInstance.isColumnFilterApplied,
        gridContextDispatcher: gridContextDispatcher,
        gridContext: gridContextPlaceholder,
        ...commandContext
    };
    //commandContext should have information about selected vmo. This is needed for application command condition use-case.
    //Pass the currently selected object from table to the context menu command bar context instead of relying on ctx.mselected.
    commandContext.selected = gridContextPlaceholder.contextVmo && gridContextPlaceholder.contextVmo.length ? gridContextPlaceholder.contextVmo : ctx.mselected;
    const contextAnchor = commandOverrides.contextMenuCommandsAnchor ? commandOverrides.contextMenuCommandsAnchor : 'aw_contextMenu2';
    const contextMenuContext = {
        anchor: contextAnchor,
        dataProvider: dataProviderInstance,
        columnProvider: columnProviderInstance,
        gridId: gridid,
        gridOptions: gridOptions,
        gridContext: gridContextPlaceholder,
        ...commandContext
    };


    const isPinningEnabled = gridOptions.enablePinning !== false;
    const getFilterFacetsAction = async( filterFacetInput ) => {
        return await dataProviderInstance.getFilterFacets( dataCtxNode.data, filterFacetInput );
    };
    //commandContext should have information about selected columnDef. This is needed for application command condition use-case.
    commandContext.columnDef = gridContextPlaceholder.columnDef;
    const columnMenuContext = {
        anchor: commandOverrides.columnMenuCommandsAnchor ? commandOverrides.columnMenuCommandsAnchor : 'aw_splmTable_columnMenu',
        dataProvider: dataProviderInstance,
        columnProvider: columnProviderInstance,
        gridId: gridid,
        gridContext: gridContextPlaceholder,
        gridContextDispatcher: gridContextDispatcher,
        menuId: gridid + '_menu',
        menuContainerId: gridid + '_menuContainer',
        gridOptions: gridOptions,
        isArrangeSupported: isArrangeSupported,
        isPinningEnabled: isPinningEnabled,
        sortCriteria: columnProviderInstance.getSortCriteria(),
        hasFilterFacetAction: dataProviderInstance.getFilterFacets && dataProviderInstance.filterFacetAction,
        getFilterFacetsAction: getFilterFacetsAction,
        existingColumnFilters: columnProviderInstance.getColumnFilters(),
        ...dataCtxNode.data.subPanelContext,
        ...commandContext
    };

    const childCommandCLickCallback = function( hasPopup ) {
        if( hasPopup ) {
            return;
        }
        actions.contextMenuPopup.hide();
    };

    const columnMenuName = getColumnMenuName( gridContextPlaceholder );
    return (
        <aw-splm-table ref={element}>
            {
                actions.columnMenuPopup.open && <AwPopup {...actions.columnMenuPopup.options}><AwInclude name={ columnMenuName } subPanelContext={ columnMenuContext } /></AwPopup>
            } {
                actions.gridMenuPopup.open && <AwPopup {...actions.gridMenuPopup.options}>
                    <AwPopupCommandBar
                        anchor={ gridMenuContext.anchor }
                        context={ gridMenuContext }
                        childCommandClickCallback={actions.gridMenuPopup.hide}
                        class='grid-menu-command'
                        alignment='HORIZONTAL'
                    ></AwPopupCommandBar>
                </AwPopup>
            } {
                actions.contextMenuPopup.open && <AwPopup {...actions.contextMenuPopup.options}>
                    <AwServerVisibilityPopupCommandBar
                        anchor={ contextAnchor }
                        context={ contextMenuContext }
                        childCommandClickCallback={childCommandCLickCallback}
                        mselected={ commandContext.selected }
                        pselected={ctx.pselected}>
                    </AwServerVisibilityPopupCommandBar>
                </AwPopup>
            } {
                actions.editArrayPopup.open && <AwPopup {...actions.editArrayPopup.options}>
                    <SplmTableCellEditor vmo={ gridContextPlaceholder.editVmo } name={ gridContextPlaceholder.editPropertyName }></SplmTableCellEditor>
                </AwPopup>
            }
        </aw-splm-table>
    );
};
