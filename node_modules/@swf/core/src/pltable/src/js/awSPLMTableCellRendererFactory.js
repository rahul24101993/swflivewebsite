/* eslint-disable max-lines */
/* eslint-disable @swf/swf/no-react-usage */
// Copyright (c) 2020 Siemens

/**
 * This module defines the primary classes used to manage the 'aw-table' directive (used by decl grid).
 *
 * DOM Structure:
 * - Cell Command
 *     CLASS_CELL|ui-grid-cell
 *       CLASS_TABLE_CELL_TOP|aw-splm-tableCellTop
 *         ( Content in CLASS_TABLE_CELL_TOP for all case above )
 *         CLASS_AW_CELL_COMMANDS|aw-jswidgets-gridCellCommands --> Custom command cell if exist
 *         CLASS_NATIVE_CELL_COMMANDS|aw-splm-tableGridCellCommands --> OOTB command cell, check mark
 *
 *
 * - Object/Object List:
 *     CLASS_CELL|ui-grid-cell
 *       CLASS_TABLE_NON_EDIT_CELL_LIST|aw-jswidgets-arrayNonEditValueCellList  --> ( <ul>, CLASS_TABLE_CELL_TOP )
 *         CLASS_TOOLTIP_POPUP|aw-splm-tableTooltipPopup
 *         CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM|aw-jswidgets-arrayValueCellListItem --> ( <li> )
 *           CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS|aw-splm-tablePropertyValueLinks --> ( <a>, innerHTML from addHighlights )
 *           CLASS_AW_OLD_TEXT|aw-jswidgets-oldText --> ( <div>, innerHTML from addHighlights )
 *
 *
 * - Rich Text/Rich Text List:
 *     CLASS_CELL|ui-grid-cell
 *       CLASS_TABLE_NON_EDIT_CELL_LIST|aw-jswidgets-arrayNonEditValueCellList  --> ( <ul>, CLASS_TABLE_CELL_TOP )
 *         CLASS_TOOLTIP_POPUP|aw-splm-tableTooltipPopup
 *         CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM|aw-jswidgets-arrayValueCellListItem  --> ( <li> )
 *           CLASS_TABLE_RTF_CELL_ITEM|aw-splm-tableRTFCellItem ( <div>, innerHTML from addHighlights )
 *           CLASS_AW_OLD_TEXT|aw-jswidgets-oldText --> ( <div>, innerHTML from addHighlights )
 *
 *
 * - Changed Text/Text List:
 *     CLASS_CELL|ui-grid-cell
 *       CLASS_TABLE_NON_EDIT_CELL_LIST|aw-jswidgets-arrayNonEditValueCellList  --> ( <ul>, CLASS_TABLE_CELL_TOP )
 *         CLASS_TOOLTIP_POPUP|aw-splm-tableTooltipPopup
 *         CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM|aw-jswidgets-arrayValueCellListItem --> ( <li> )
 *           CLASS_WIDGET_TABLE_CELL_TEXT|aw-splm-tableCellText --> ( <div>, innerHTML from addHighlights )
 *           CLASS_AW_OLD_TEXT|aw-jswidgets-oldText --> ( <div>, innerHTML from addHighlights )
 *
 * - Text:
 *     CLASS_CELL|ui-grid-cell
 *       CLASS_TABLE_CELL_TOP|aw-splm-tableCellTop --> ( <div> )
 *         CLASS_WIDGET_TABLE_CELL_TEXT|aw-splm-tableCellText --> ( <div>, innerHTML from addHighlights )
 *
 *
 * @module js/awSPLMTableCellRendererFactory
 */
import sanitizer from 'js/sanitizer';
import appCtxService from 'js/appCtxService';
import commandService from 'js/command.service';
import clickableTitleService from 'js/clickableTitleService';
import cdm from 'soa/kernel/clientDataModel';
import AwHttpService from 'js/awHttpService';
import AwPromiseService from 'js/awPromiseService';
import AwCacheFactoryService from 'js/awCacheFactoryService';
import navigationTokenService from 'js/navigationTokenService';
import _ from 'lodash';
import eventBus from 'js/eventBus';
import cfgSvc from 'js/configurationService';
import { includeComponent, getDependentModule, loadDependentModule } from 'js/moduleLoader';
import awConfiguration from 'js/awConfiguration';
import { renderComponent } from 'js/declReactUtils';
import { AppCtxComponent } from 'js/reactAppCtx';
import { svgString as miscInProcessIndicator } from 'image/miscInProcessIndicator16.svg';
import { svgString as miscExpandedTree } from 'image/miscExpandedTree12.svg';
import { svgString as miscCollapsedTree } from 'image/miscCollapsedTree12.svg';
import util from 'js/splmTableUtils';
import Const from 'js/splmTableConstants';
import Cell from 'js/splmTableCellRenderer';

var exports = {};

var _propVsRenderingTemplate;
var _defaultRenderingTemplates = {};

let highlighter;

/**
 * Method to render rows
 *
 * @param {Number} startIndex Start render index
 * @param {Number} endIndex End render Index
 */
function generatePropRendererTemplateMap() {
    _propVsRenderingTemplate = {};
    var _contributedTemplates = cfgSvc.getCfgCached( 'propertyRendererTemplates' );
    _.forEach( _contributedTemplates, function( contributedTemplate ) {
        if( !_.isEmpty( contributedTemplate.headerTemplate ) || !_.isEmpty( contributedTemplate.headerTemplateUrl ) ||
            !_.isEmpty( contributedTemplate.headerRenderFunction ) || !_.isEmpty( contributedTemplate.headerComponent ) ) {
            contributedTemplate.isHeaderTemplate = true;
        }
        if( !_.isEmpty( contributedTemplate.template ) || !_.isEmpty( contributedTemplate.templateUrl ) ||
            !_.isEmpty( contributedTemplate.renderFunction ) ) {
            contributedTemplate.isCellTemplate = true;
        }

        var isDefaultTemplate = false;
        if( _.isEmpty( contributedTemplate.grids ) ) {
            // default rendering template for property
            isDefaultTemplate = true;
        }
        // Get ModelTypes for this Indicator Json
        if( _.isEmpty( contributedTemplate.columns ) ) {
            _.forEach( contributedTemplate.grids, function( gridid ) {
                _defaultRenderingTemplates[ gridid ] = contributedTemplate;
            } );
        }
        _.forEach( contributedTemplate.columns, function( column ) {
            if( !_propVsRenderingTemplate[ column ] ) {
                _.set( _propVsRenderingTemplate, [ column ], { specificRenderingTemplates: [], defaultPropRenderingTemplate: {} } );
            }
            var renderingTemplatesForProp = _propVsRenderingTemplate[ column ];
            if( isDefaultTemplate ) {
                _.set( renderingTemplatesForProp, 'defaultPropRenderingTemplate', contributedTemplate );
            } else {
                renderingTemplatesForProp.specificRenderingTemplates.push( contributedTemplate );
            }
        } );
    } );
}

var applyCommandCellScope = function( cellCmdElem, column, vmo, extraDigest ) {
    // The below getElementScope method is commented out and the usages are commented too by assigning empty object to scope.
    //var scope = util.getElementScope( cellCmdElem );
    var scope = {};
    scope.anchor = column.commandsAnchor;
    scope.commandContext = {
        vmo: vmo
    };

    if( vmo.props !== undefined ) {
        scope.prop = vmo.props[ column.field ];
    }

    if( extraDigest ) {
        scope.$evalAsync();
    }
};

const getTreeIconCellInfo = function( vmo ) {
    if( vmo.loadingStatus ) {
        return { id: 'miscInProcessIndicator', icon: miscInProcessIndicator };
    } else if( vmo.isLeaf ) {
        // we made the decision to stop rendering 'typeBlankIcon' because (1) there is no visual difference, (2) we want
        // to decrease the number of DOM elements and (3) we don't know the history of why it was there.
        return {};
    } else if( vmo.isExpanded ) {
        return { id: 'miscExpandedTree', icon: miscExpandedTree };
    }
    return { id: 'miscCollapsedTree', icon: miscCollapsedTree };
};

/**
 * Creates the Icon cell for tree command cell.
 *
 * @param {DOMElement} tableElem tree table element
 * @param {Object} vmo the vmo for the cell
 *
 * @returns {DOMElement} icon element
 */
const createIconElement = function( tableElem, vmo ) {
    let treeCellButtonHeaderCell = util.createElement( 'div', Const.CLASS_TREE_ROW_HEADER_BUTTONS, Const.CLASS_TREE_BASE_HEADER );
    if( !vmo.isLeaf ) {
        treeCellButtonHeaderCell.classList.add( Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD );
        treeCellButtonHeaderCell.tabIndex = -1;
        tableElem._tableInstance.keyboardService.setOnFocusAndBlur( treeCellButtonHeaderCell );
    }
    const treeIndent = 16;
    treeCellButtonHeaderCell.style.marginLeft = treeIndent * vmo.levelNdx + 'px';
    treeCellButtonHeaderCell.title = vmo._twistieTitle;
    const iconCellInfo = getTreeIconCellInfo( vmo );
    // this if check is for the vmo.isLeaf use case where there is no need to render an icon
    if( iconCellInfo && iconCellInfo.id ) {
        let iconElem = document.createElement( 'span' );
        iconElem.classList.add( 'aw-icon', 'aw-base-icon' );
        let attr = document.createAttribute( 'iconid' );
        attr.value = iconCellInfo.id;
        let attrLegacy = document.createAttribute( 'icon-id' );
        attrLegacy.value = iconCellInfo.id;
        iconElem.setAttributeNode( attr );
        iconElem.setAttributeNode( attrLegacy );
        iconElem.innerHTML = iconCellInfo.icon;
        treeCellButtonHeaderCell.appendChild( iconElem );
    }

    return treeCellButtonHeaderCell;
};

/**
 * Creates the cell decorator element for tree command cell.
 *
 * @param {DOMElement} tableElem tree table element
 * @param {Object} vmo the vmo for the cell
 *
 * @returns {DOMElement} cell decorator element
 */
var createCellDecoratorElement = function( tableElem, vmo ) {
    var cellColorContainerElement = util.createElement( 'div', Const.CLASS_GRID_CELL_COLOR_CONTAINER, Const.CLASS_TREE_COLOR_CONTAINER );
    var cellColorElement = util.createColorIndicatorElement( vmo );
    cellColorContainerElement.appendChild( cellColorElement );

    return cellColorContainerElement;
};

/**
 * Get the img element tag alt text for WCAG accessibility compliance
 * @param {Object} vmo - View model object
 * @returns {String} Returns alt text
 */
var getImageAltText = function( vmo ) {
    if( vmo.hasThumbnail ) {
        return vmo.cellHeader1;
    } else if( vmo.props && vmo.props.object_type && vmo.props.object_type.uiValue ) {
        return vmo.props.object_type.uiValue;
    }
    return vmo.modelType && vmo.modelType.displayName ? vmo.modelType.displayName : '';
};

/**
 * Creates the cell image element for tree command cell.
 *
 * @param {DOMElement} tableElem tree table element
 * @param {Object} vmo the vmo for the cell
 *
 * @returns {DOMElement} cell image element
 */
var createCellImageElement = function( tableElem, vmo ) {
    let imgURL = util.getImgURL( vmo );
    let svgString = vmo.svgString;
    if( imgURL === '' && !svgString ) {
        return null;
    }

    let cellImageContainerElement = util.createElement( 'div', Const.CLASS_GRID_CELL_IMAGE );
    let cellImageElement = null;
    if( imgURL && imgURL !== '' ) {
        cellImageElement = util.createElement( 'img', Const.CLASS_ICON_BASE );
        cellImageElement.src = imgURL;
    } else if( svgString ) {
        cellImageElement = util.createElement( 'span', Const.CLASS_ICON_BASE );
        cellImageElement.innerHTML = svgString;
    }
    if( cellImageElement ) {
        cellImageElement.alt = getImageAltText( vmo );
        cellImageContainerElement.appendChild( cellImageElement );
    }
    return cellImageContainerElement;
};

var toggleTreeCellAction = function( vmo, tableElem, treeCellElement ) {
    if( vmo.isExpanded || vmo.isInExpandBelowMode ) {
        // collapse
        delete vmo.isExpanded;
        vmo.isInExpandBelowMode = false;
    } else {
        vmo.isExpanded = true;
        // Set icon cell to loading icon
        var iconContainerElement = treeCellElement.getElementsByClassName( Const.CLASS_ICON_BASE )[ 0 ];
        if( iconContainerElement !== undefined ) {
            iconContainerElement.innerHTML = miscInProcessIndicator;
        }
    }
    // Prevent the selected row from being scrolled to if it goes out of view
    tableElem._tableInstance.tableInstanceCallbacks.unsetScrollToRowIndex();
    if( tableElem._tableInstance.tableInstanceCallbacks.toggleTreeNode ) {
        tableElem._tableInstance.tableInstanceCallbacks.toggleTreeNode( vmo );
    } else {
        eventBus.publish( tableElem.id + '.plTable.toggleTreeNode', vmo );
    }
};

var populateHrefContentPerPropValue = function( objectElement, scope, uidToBeEvaluated, vmo ) {
    var deferred = AwPromiseService.instance.defer();
    if( objectElement && scope && uidToBeEvaluated ) {
        navigationTokenService.getNavigationContent( scope, uidToBeEvaluated, vmo ).then( function( urlDetails ) {
            var hrefDetails = urlDetails;
            if( hrefDetails ) {
                deferred.resolve( { objectElement: objectElement, url: hrefDetails } );
            }
        } );
    }
    return deferred.promise;
};

var addHrefToAnchorLink = function( objectElement, scope, uidToBeEvaluated, vmo ) {
    objectElement.addEventListener( 'mouseenter', function() {
        populateHrefContentPerPropValue( objectElement, scope, uidToBeEvaluated, vmo ).then( function( response ) {
            if( !_.isUndefined( response ) ) {
                objectElement = util.addAttributeToDOMElement( response.objectElement, 'href', response.url.urlContent );
                objectElement = util.addAttributeToDOMElement( objectElement, 'target', response.url.target );
            }
        } );
    } );
    return objectElement;
};

var addClickableCellTitle = function( element, vmo, value, tableElem ) {
    // make cell text clickable
    var clickableTextDiv = util.createElement( 'div' );
    var clickableText = util.createElement( 'a', 'aw-uiwidgets-clickableTitle' );
    const scope = {
        data: tableElem._tableInstance.declViewModel,
        ctx: tableElem._tableInstance.ctx,
        tableContext: tableElem._tableInstance
    };
    clickableText.onclick = function( event ) {
        scope.vmo = vmo;
        clickableTitleService.doIt( event, scope, tableElem._tableInstance.runActionWithViewModel );
    };

    clickableText.innerHTML = exports.addHighlights( value );
    clickableTextDiv.appendChild( clickableText );
    element.appendChild( clickableTextDiv );
};

/**
 * Creates the title and command container element for tree command cell.
 *
 * @param {DOMElement} tableElem tree table element
 * @param {Object} vmo the vmo for the cell
 * @param {Object} column the column associated with the cell
 * @returns {DOMElement} title/command container element
 */
let createTitleElement = function( tableElem, vmo, column ) {
    let tableNonEditContainerElement = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER,
        Const.CLASS_LAYOUT_ROW_CONTAINER );
    let displayName = vmo.displayName;
    tableNonEditContainerElement.title = displayName;

    let parsedValue = sanitizer.htmlEscapeAllowEntities( displayName, true, true );
    let gridCellText = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_CELL_TEXT );

    if( ( column.isTableCommand || column.isTreeNavigation ) && clickableTitleService.hasClickableCellTitleActions() ) {
        addClickableCellTitle( gridCellText, vmo, parsedValue, tableElem );
    } else {
        gridCellText.innerHTML = exports.addHighlights( parsedValue );
    }

    const dynamicRowHeightEnabled = tableElem && tableElem._tableInstance.dynamicRowHeightStatus;
    if( dynamicRowHeightEnabled ) {
        tableNonEditContainerElement.classList.add( Const.CLASS_TABLE_CELL_TOP_DYNAMIC );
        gridCellText.classList.add( Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );
    }

    // Skeletons fix - if no cell content, remove table cell text class
    if( gridCellText.innerHTML === '' ) {
        gridCellText.classList.remove( Const.CLASS_WIDGET_TABLE_CELL_TEXT );
    }

    tableNonEditContainerElement.appendChild( gridCellText );

    return tableNonEditContainerElement;
};

/**
 * Show or hide the element based on 'isSelected'.
 *
 * @param {DOMElement} element DOM element to show/hide
 * @param {Boolean} isSelected used to either show or hide element
 */
var toggleCellCommandVisibility = function( element, isSelected ) {
    if( isSelected ) {
        util.showHideElement( element, false );
    } else {
        util.showHideElement( element, true );
    }
};

/**
 * Add events to the tree command cell elements.
 *
 * @param {DOMElement} treeCellElement tree cell container element
 * @param {Object} vmo the vmo for the cell
 * @param {DOMElement} tableElem table element
 */
var addTreeCommandCellEvents = function( treeCellElement, vmo, tableElem ) {
    var tableInstance = util.getTableInstance( tableElem );
    var dataProviderName = tableInstance.dataProvider.name;

    var treeCellButtonElement = treeCellElement.getElementsByClassName( Const.CLASS_TREE_ROW_HEADER_BUTTONS )[ 0 ];
    if( treeCellButtonElement ) {
        const treeCommandCellClickListener = function() {
            if( !vmo.isLeaf && util.isExpandAllowed( tableElem ) ) {
                toggleTreeCellAction( vmo, tableElem, treeCellElement );
            }
        };
        treeCellButtonElement.addEventListener( 'click', treeCommandCellClickListener );
        treeCellButtonElement.addEventListener( 'keydown', function( event ) {
            if( event.code === 'Enter' || event.code === 'Space' ) {
                treeCommandCellClickListener();
            }
        } );
    }

    var treeCellImageElement = treeCellElement.getElementsByClassName( Const.CLASS_GRID_CELL_IMAGE )[ 0 ];
    if( treeCellImageElement ) {
        treeCellImageElement.addEventListener( 'click', function() {
            eventBus.publish( 'plTable.imageButtonClick', vmo );
        } );
    }

    var cellCommandBarElement = treeCellElement.getElementsByClassName( 'cellCommandBarContainer' )[ 0 ];
    if( cellCommandBarElement ) {
        var isSelected = tableInstance.dataProvider.selectionModel.multiSelectEnabled && vmo.selected;
        toggleCellCommandVisibility( cellCommandBarElement, isSelected );

        eventBus.subscribe( dataProviderName + '.selectionChangeEvent', function() {
            isSelected = tableInstance.dataProvider.selectionModel.multiSelectEnabled && vmo.selected;
            toggleCellCommandVisibility( cellCommandBarElement, isSelected );
        } );
    }
};

/**
 * @memberOf js/awSPLMTableCellRendererFactory
 *
 * This method is used for creating cell commands for PL Table in AW usecase.
 *
 * @param {Object} column - column Definition
 * @param {Object} vmo - View model object
 * @param {Boolean} [isInternal] - true if function being called from internal PL Table code
 * @returns {DOMElement} DOMElement presents cell command bar
 *
 */
export let createCellCommandElement = function( column, vmo, isInternal ) {
    const fields = {
        anchor: column.commandsAnchor,
        column: column,
        vmo: vmo,
        isInternal: isInternal
    };
    var cellCommandsContainer = util.createElement( 'div', Const.CLASS_AW_CELL_COMMANDS_CONTAINER );
    let cellCmdElem = includeComponent( 'AwTableCommandBar', fields );
    renderComponent( <AppCtxComponent>{ cellCmdElem }</AppCtxComponent>, cellCommandsContainer );
    return cellCommandsContainer;
};

export let createTreeCellCommandElement = function( column, vmo, tableElem ) {
    // CELL CONTAINER
    var tableTreeCommandCell = util.createElement( 'div', Const.CLASS_AW_TREE_COMMAND_CELL, Const.CLASS_WIDGET_TABLE_CELL );
    var treeCellTop = util.createElement( 'div', Const.CLASS_AW_JS_CELL_TOP, Const.CLASS_WIDGET_UI_NON_EDIT_CELL );
    tableTreeCommandCell.appendChild( treeCellTop );

    // ICON
    var iconElement = createIconElement( tableElem, vmo );
    treeCellTop.appendChild( iconElement );

    // DECORATOR
    var cellDecoratorElement = createCellDecoratorElement( tableElem, vmo );
    treeCellTop.appendChild( cellDecoratorElement );

    // IMAGE
    var cellImageElement = createCellImageElement( tableElem, vmo );
    if( cellImageElement ) {
        treeCellTop.appendChild( cellImageElement );
    }

    // TITLE
    var tableNonEditContainerElement = createTitleElement( tableElem, vmo, column );
    treeCellTop.appendChild( tableNonEditContainerElement );

    addTreeCommandCellEvents( tableTreeCommandCell, vmo, tableElem );

    return tableTreeCommandCell;
};

var createCheckMarkElementInternal = function( tableElem ) {
    var commandBarHtml =
        '<div class="aw-splm-tableCheckBoxPresent" >' + //
        '<a class="aw-commands-cellCommandCommon">' + //
        '<div class="afx-checkbox afx-checkbox-label-side">' + //
        '<input type="checkbox" class="aw-jswidgets-checkboxButton"/>' + //
        '<span class="afx-checkbox-md-style">' + //
        '<span class="check"></span>' + //
        '</span>' + //
        '</div>' + //
        '</a>' + //
        '</div>'; //
    var cellScope = {};

    return util.createNgElement( commandBarHtml, tableElem, cellScope );
};

// NOTE: By this design, the cell command will only be available for OOTB AW Cell.
export let createCheckMarkElement = function( column, vmo, tableElem ) {
    var elem = createCheckMarkElementInternal( tableElem );
    applyCommandCellScope( elem, column, vmo );
    return elem;
};

export let addHighlights = function( displayValue ) {
    if( !highlighter ) {
        highlighter = appCtxService.getCtx( 'highlighter' );
    }
    if( highlighter && typeof displayValue === 'string' ) {
        return displayValue.replace( highlighter.regEx, highlighter.style );
    }
    return displayValue;
};

// This function is called when we click on any object link
// REFACTOR: Awp0ShowObjectCell is TC specific. Try to pull command ID from solution configuration
// instead.
var openObjectLink = function( propertyName, uid, objectElement ) {
    if( uid && uid.length > 0 ) {
        var modelObject = cdm.getObject( uid );

        var vmo = {
            propertyName: propertyName,
            uid: uid
        };

        var commandContext = {
            vmo: modelObject || vmo, // vmo needed for gwt commands
            edit: false
        };
        commandService.executeCommand( 'Awp0ShowObjectCell', null, null, commandContext, objectElement.runActionWithViewModel );
    }
};

// REFACTOR: The only meaning here to keep this is the _cellCmdElem mechanism, we can separate it out later.
export let createCellRenderer = function() {
    var _renderer = {};

    var _cellCmdElem;

    var _tooltipElement = util.createElement( 'div', Const.CLASS_AW_POPUP, Const.CLASS_AW_TOOLTIP_POPUP, Const.CLASS_TOOLTIP_POPUP );

    var createCommandCellHandler = function( cellTop, column, vmo, tableElem ) {
        return function() {
            //no commands visible when in multiselection/visible checkbox
            if( !tableElem._tableInstance.showCheckBox && cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length === 0 ) {
                _cellCmdElem = createCellCommandElement( column, vmo, true );
                cellTop.appendChild( _cellCmdElem );
            }
        };
    };

    var destroyCommandCellHandler = function( cellTop, column, vmo, tableElem ) {
        return function() {
            //no commands visible when in multiselection/visible checkbox
            if( !tableElem._tableInstance.showCheckBox && cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length === 1 && _cellCmdElem ) {
                _renderer.destroyHoverCommandElement();
            }
        };
    };

    var addCommandOnHover = function( commandHandlerParent, column, vmo, tableElem ) {
        commandHandlerParent.addEventListener( 'mouseover', createCommandCellHandler( commandHandlerParent, column, vmo, tableElem ) );
    };

    var removeCommandOnHover = function( commandHandlerParent, column, vmo, tableElem ) {
        commandHandlerParent.addEventListener( 'mouseleave', destroyCommandCellHandler( commandHandlerParent, column, vmo, tableElem ) );
    };

    var createInlineComponent = function( extendedTooltip, containerElement, vmo, column ) {
        const subPanelContext = {
            vmo: vmo,
            column: column
        };
        let extendedTooltipElement = includeComponent( extendedTooltip, subPanelContext );
        if( containerElement ) {
            renderComponent( <AppCtxComponent>{ extendedTooltipElement }</AppCtxComponent>, containerElement );
        }
        return containerElement;
    };

    var getTooltipHTML = function( values ) {
        var tooltipInnerHTML = '<ul>';
        _.forEach( values, function( value ) {
            tooltipInnerHTML += '<li>' + exports.addHighlights( value ) + '</li>';
        } );
        tooltipInnerHTML += '</ul>';
        return tooltipInnerHTML;
    };

    var containsOnlyEmptyStrings = function( values ) {
        if( values.length ) {
            for( var i = 0; i < values.length; i++ ) {
                if( values[ i ] !== '' ) {
                    return false;
                }
            }
        }
        return true;
    };

    var getNewValues = function( prop ) {
        var newValues = [];
        // Get the new values, return an empty array if the values are all empty strings
        // to avoid creating unnecessary DOM elements.
        if( prop.isArray === true ) {
            // Only use uiValues if displayValues is not defined.
            if( prop.displayValues ) {
                if( !containsOnlyEmptyStrings( prop.displayValues ) ) {
                    newValues = prop.displayValues.slice();
                }
            } else if( prop.uiValues ) {
                if( !containsOnlyEmptyStrings( prop.uiValues ) ) {
                    newValues = prop.uiValues.slice();
                }
            }
        } else if( !containsOnlyEmptyStrings( [ prop.uiValue ] ) ) {
            newValues = [ prop.uiValue ];
        }
        return newValues;
    };

    var getOldValues = function( prop ) {
        var oldValues = [];
        if( prop.isArray === true && prop.oldValues && !containsOnlyEmptyStrings( prop.oldValues ) ) {
            oldValues = prop.oldValues.slice();
        } else if( prop.oldValue && !containsOnlyEmptyStrings( [ prop.oldValue ] ) ) {
            oldValues = [ prop.oldValue ];
        }
        return oldValues;
    };

    var addOpenObjectLinkHandler = function( objectElement, prop, index ) {
        var openObjLinkHandle = function( e ) {
            if( e.target && e.target.tagName.toLowerCase() === 'a' && e.target.href !== '' ) {
                return;
            }
            if( !prop.isEditable ) {
                e.cancelBubble = true;
                openObjectLink( prop.propertyName, prop.dbValues[ index ], objectElement );
            }
        };

        objectElement.addEventListener( 'click', function( event ) {
            openObjLinkHandle( event );
        } );

        objectElement.addEventListener( 'keydown', function( event ) {
            if( event.code === 'Enter' || event.code === 'Space' ) {
                openObjLinkHandle( event );
            }
        } );
    };

    const createPropertyValueLinkElement = function( prop, oldValue ) {
        if( prop.isEditable ) {
            return util.createElement( 'a', Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED );
        } else if( oldValue ) {
            return util.createElement( 'a', Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS, Const.CLASS_AW_CHANGED_TEXT );
        }
        return util.createElement( 'a', Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS );
    };

    var createObjectListFragment = function( prop, addOldValue, scope, dynamicRowHeightEnabled, tableElem ) {
        var fragment = document.createDocumentFragment();
        var newValues = getNewValues( prop );
        var oldValues = getOldValues( prop );
        let runActionWithViewModel = tableElem._tableInstance.runActionWithViewModel;
        var index = 0;
        while( newValues.length > 0 || oldValues.length > 0 ) {
            var liForObjectLinks = util.createElement( 'li', Const.CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM );
            var newValue = newValues.shift();
            var oldValue = oldValues.shift();

            if( newValue ) {
                // use a different class when there is an object array.
                let objectElement = createPropertyValueLinkElement( prop, oldValue );
                objectElement.tabIndex = -1;
                if( dynamicRowHeightEnabled ) {
                    objectElement.style.whiteSpace = 'normal';
                }
                // href not to be associated with editable prop
                if( !util.isBulkEditing( tableElem ) ) {
                    // associating every prop with href
                    var uidToBeEvaluated = '';
                    if( prop.isArray ) {
                        uidToBeEvaluated = prop.dbValue[ index ];
                    } else {
                        uidToBeEvaluated = prop.dbValue;
                    }
                    addHrefToAnchorLink( objectElement, scope, uidToBeEvaluated );
                }
                objectElement.runActionWithViewModel = runActionWithViewModel;
                addOpenObjectLinkHandler( objectElement, prop, index );
                objectElement.innerHTML = exports.addHighlights( newValue );
                liForObjectLinks.appendChild( objectElement );
            }

            if( addOldValue && hasOldValue( oldValue, prop.oldValue ) ) {
                var oldCellTextElement = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_PROPERTY_VALUE_LINKS_DISABLED, Const.CLASS_AW_OLD_TEXT );
                oldCellTextElement.innerHTML = exports.addHighlights( oldValue );
                liForObjectLinks.appendChild( oldCellTextElement );
            }

            fragment.appendChild( liForObjectLinks );

            // Add cell text class to last li
            if( fragment.childNodes.length > 0 ) {
                fragment.childNodes[ fragment.childNodes.length - 1 ].classList.add( Const.CLASS_WIDGET_TABLE_CELL_TEXT );
            }
            index++;
        }
        return fragment;
    };

    /**
     * Clear the child elements of the _tooltipElement.
     */
    var clearTooltipContent = function() {
        if( _tooltipElement.parentElement ) {
            _tooltipElement.parentElement.removeChild( _tooltipElement );
        }
        while( _tooltipElement.firstChild ) {
            _tooltipElement.removeChild( _tooltipElement.firstChild );
        }
    };

    var addTooltipListeners = function( parentElement, tooltipContent, tableElement ) {
        var tooltipTimeout = null;
        parentElement.addEventListener( 'mouseenter', function( event ) {
            clearTimeout( tooltipTimeout );
            if( event.offsetX > event.target.clientWidth ) {
                return false;
            }
            tooltipTimeout = setTimeout( function() {
                clearTooltipContent();
                var parentElementDimensions = parentElement.getBoundingClientRect();
                _tooltipElement.style.left = parentElementDimensions.left + 'px';
                _tooltipElement.style.top = parentElementDimensions.top + 'px';
                var tableBoundingBox = tableElement.getBoundingClientRect();
                _tooltipElement.style.maxWidth = tableBoundingBox.right - parentElementDimensions.left + 'px';
                // When tooltipContent is a document fragment, convert to array of html elements to maintain
                // references after appending
                if( tooltipContent instanceof DocumentFragment ) {
                    tooltipContent = Array.prototype.slice.call( tooltipContent.childNodes );
                }

                if( Array.isArray( tooltipContent ) ) {
                    for( var i = 0; i < tooltipContent.length; i++ ) {
                        _tooltipElement.appendChild( tooltipContent[ i ] );
                    }
                } else if( tooltipContent instanceof Element ) {
                    _tooltipElement.appendChild( tooltipContent );
                } else {
                    _tooltipElement.innerHTML = tooltipContent;
                }
                parentElement.appendChild( _tooltipElement );
            }, 750 );
        } );

        parentElement.addEventListener( 'mouseleave', function() {
            clearTimeout( tooltipTimeout );
            tooltipTimeout = setTimeout( clearTooltipContent, 750 );
        } );

        return _tooltipElement;
    };

    /**
     * Icon cell
     */
    var iconCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var cell = util.createElement( 'div', Const.CLASS_CELL_CONTENTS, Const.CLASS_SPLM_TABLE_ICON_CELL );

            var colorIndicatorElement = util.createColorIndicatorElement( vmo );
            cell.appendChild( colorIndicatorElement );

            var cellImg = util.createElement( 'img', Const.CLASS_ICON_BASE, Const.CLASS_ICON_TYPE,
                Const.CLASS_SPLM_TABLE_ICON );
            var rowHeight = util.getTableRowHeightForIconCellRenderer( util.getTableInstance( tableElem ).gridOptions, undefined );
            if( rowHeight !== undefined ) {
                cellImg.style.height = rowHeight + 'px';
                cellImg.style.width = rowHeight + 'px';
            }
            cellImg.src = util.getImgURL( vmo );
            cellImg.alt = getImageAltText( vmo );
            cell.appendChild( cellImg );
            return cell;
        },
        condition: function( column, vmo, tableElem ) {
            return column.name === 'icon';
        }
    };

    /**
     * Transpose Icon cell
     */
    const transposeIconCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            const cell = util.createElement( 'div', Const.CLASS_CELL_CONTENTS, Const.CLASS_SPLM_TABLE_ICON_CELL );

            const colorIndicatorElement = util.createColorIndicatorElement( vmo );
            cell.appendChild( colorIndicatorElement );

            const cellImg = util.createElement( 'img', Const.CLASS_ICON_BASE, Const.CLASS_ICON_TYPE,
                Const.CLASS_SPLM_TABLE_ICON );
            const rowHeight = util.getTableRowHeightForIconCellRenderer( util.getTableInstance( tableElem ).gridOptions, undefined );
            if( rowHeight !== undefined ) {
                cellImg.style.height = rowHeight + 'px';
                cellImg.style.width = rowHeight + 'px';
            }
            cellImg.src = util.getImgURL( vmo.props[ column.field ] );
            cellImg.alt = getImageAltText( vmo );
            cell.appendChild( cellImg );
            return cell;
        },
        condition: function( column, vmo, tableElem ) {
            return tableElem._tableInstance.gridOptions.transpose === true && vmo.name === 'icon' && column.field !== 'transposedColumnProperty';
        }
    };

    /**
     * Command in cell
     */
    var commandCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var cellContent = Cell.createElement( column, vmo, tableElem, rowElem );
            if( cellContent ) {
                addCommandOnHover( cellContent, column, vmo, tableElem );
                removeCommandOnHover( cellContent, column, vmo, tableElem );
            }
            return cellContent;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return column.isTableCommand;
        }
    };

    /**
     * Tree Node
     */
    var treeTableCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var createTreeCellCommandElement = exports.createTreeCellCommandElement( column, vmo, tableElem );
            var commandHandlerParent = createTreeCellCommandElement.getElementsByClassName( Const.CLASS_WIDGET_TABLE_NON_EDIT_CONTAINER )[ 0 ];
            addCommandOnHover( commandHandlerParent, column, vmo, tableElem );
            removeCommandOnHover( commandHandlerParent, column, vmo, tableElem );
            return createTreeCellCommandElement;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return column.isTreeNavigation;
        }
    };

    /**
     * AW Object Reference
     */
    var objectCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var prop = vmo.props[ column.field ];
            var ulForObjectLinks = util.createElement( 'ul', Const.CLASS_TABLE_NON_EDIT_CELL_LIST, Const.CLASS_TABLE_CELL_TOP );
            var dynamicRowHeightEnabled = tableElem && tableElem._tableInstance.dynamicRowHeightStatus;
            if( dynamicRowHeightEnabled ) {
                ulForObjectLinks.classList.add( Const.CLASS_TABLE_CELL_TOP_DYNAMIC );
            }

            // Prevent wrapping for cells that could have a command
            if( column.isTableCommand === true ) {
                ulForObjectLinks.style.flexWrap = 'nowrap';
                ulForObjectLinks.style.overflow = 'hidden';
            }

            var values = prop.displayValues || prop.uiValues;
            // Add tooltip
            /** revisitme Shaishav: What is the replacement? Do we need anything from parent element?
              * tstark - needed for navigationToken, only thing added is .vmo to scope, anything else is needed here
         var scope = util.getElementScope( tableElem.parentElement, true );
          */
            var scope = {};
            if( prop.isArray && values.length > 0 ) {
                var objectListDomFragment = createObjectListFragment( prop, null, scope, dynamicRowHeightEnabled, tableElem );
                if( objectListDomFragment ) {
                    addTooltipListeners( ulForObjectLinks, objectListDomFragment, tableElem );
                }
            } else {
                ulForObjectLinks.title = prop.uiValue;
            }

            var contentDomFragment = createObjectListFragment( prop, true, scope, dynamicRowHeightEnabled, tableElem );
            if( contentDomFragment ) {
                ulForObjectLinks.appendChild( contentDomFragment );
            }
            return ulForObjectLinks;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return vmo.props &&
                vmo.props[ column.field ] &&
                ( vmo.props[ column.field ].type === 'OBJECT' ||
                    vmo.props[ column.field ].type === 'OBJECTARRAY' );
        }
    };

    var getCompiledFunctionFromCache = function( templateUrl, htmlString ) {
        // In order to stop loading/compiling same template again, template should be cached against its URL
        var renderingTemplateCache = AwCacheFactoryService.instance.get( 'propRenderingTemplate' );
        if( !renderingTemplateCache ) {
            renderingTemplateCache = AwCacheFactoryService.instance( 'propRenderingTemplate' );
        }
        var compiledTemplateFn = renderingTemplateCache.get( templateUrl );
        if( !compiledTemplateFn && !_.isEmpty( htmlString ) ) {
            compiledTemplateFn = _.template( htmlString );
            renderingTemplateCache.put( templateUrl, compiledTemplateFn );
        }
        return compiledTemplateFn;
    };

    var loadTemplate = function( containerElement, vmo, templateUrl, dependentServices ) {
        var deferred = AwPromiseService.instance.defer();
        AwHttpService.instance.get( templateUrl, { cache: true } ).then( function( response ) {
            var htmlString = response;
            if( htmlString ) {
                deferred.resolve( { containerElement: containerElement, templateUrl: templateUrl, vmo: vmo, htmlString: response.data, dependentServices: dependentServices } );
            }
        } );
        return deferred.promise;
    };

    var updateContainerElement = function( containerElement, vmo, propName, tooltipProps, templateUrl, htmlString, depServices, column, tableElem ) {
        var compiledTemplateFn = getCompiledFunctionFromCache( templateUrl, htmlString );
        var generatedElement = compiledTemplateFn( {
            vmo: vmo,
            propName: propName,
            tooltipProps: tooltipProps,
            basePath: awConfiguration.get( 'baseUrl' ),
            dependentServices: depServices,
            column: column,
            tableContext: tableElem._tableInstance.tableContext
        } );
        containerElement.innerHTML = generatedElement.trim();
    };
    const updateContainerWithCellTemplate = async function( containerElement, vmo, propName, tooltipProps, templateUrl, htmlString, depsToInject, column, tableElem ) {
        if( depsToInject && depsToInject.length > 0 ) {
            for( let dep in depsToInject ) {
                // eslint-disable-next-line no-await-in-loop
                const cachedDep = await getDependentModule( depsToInject[ dep ] );
                if( cachedDep && _.isEmpty( htmlString ) ) {
                    updateContainerElement( containerElement, vmo, propName, tooltipProps, templateUrl, htmlString, [ cachedDep ], column, tableElem );
                } else {
                    // eslint-disable-next-line no-await-in-loop
                    const loadedDep = await loadDependentModule( depsToInject[ dep ] );
                    updateContainerElement( containerElement, vmo, propName, tooltipProps, templateUrl, htmlString, [ loadedDep ], column, tableElem );
                }
            }
        } else {
            updateContainerElement( containerElement, vmo, propName, tooltipProps, templateUrl, htmlString, depsToInject, column, tableElem );
        }
    };

    var getColRendererTemplateToUse = function( propName, tableElem, retrieveHeader ) {
        var renderingTemplate = {};
        var propRenderTemplates = _propVsRenderingTemplate[ propName ];
        var gridId = tableElem.id;
        var defaultRenderingTemplate = _defaultRenderingTemplates[ gridId ];
        if( defaultRenderingTemplate ) {
            if( defaultRenderingTemplate.isHeaderTemplate === true && retrieveHeader === true || defaultRenderingTemplate.isCellTemplate === true && retrieveHeader === false ) {
                renderingTemplate = defaultRenderingTemplate;
            }
        }

        if( propRenderTemplates ) {
            var propDefault = propRenderTemplates.defaultPropRenderingTemplate;
            if( propDefault ) {
                if( propDefault.isHeaderTemplate === true && retrieveHeader === true || propDefault.isCellTemplate === true && retrieveHeader === false ) {
                    renderingTemplate = propDefault;
                }
            }
            _.forEach( propRenderTemplates.specificRenderingTemplates, function( propRenderTemplate ) {
                if( propRenderTemplate.grids.indexOf( gridId ) >= 0 ) {
                    if( propRenderTemplate.isHeaderTemplate === true && retrieveHeader === true ||
                        propRenderTemplate.isCellTemplate === true && retrieveHeader === false ) {
                        renderingTemplate = propRenderTemplate;
                        return;
                    }
                }
            } );
        }
        return renderingTemplate;
    };

    var isCustomTemplate = function( defaultTemplate, specificTemplate, retrieveHeader ) {
        if( !_.isEmpty( specificTemplate ) ) {
            for( var i = 0; i < specificTemplate.length; i++ ) {
                var currentTemplate = specificTemplate[ i ];
                if( retrieveHeader ) {
                    if( currentTemplate.isHeaderTemplate === true ) {
                        return true;
                    }
                } else {
                    if( currentTemplate.isCellTemplate === true ) {
                        return true;
                    }
                }
            }
        }
        if( !_.isEmpty( defaultTemplate ) ) {
            if( retrieveHeader ) {
                if( defaultTemplate.isHeaderTemplate === true ) {
                    return true;
                }
            } else {
                if( defaultTemplate.isCellTemplate === true ) {
                    return true;
                }
            }
        }
        return false;
    };

    var isGraphicalRenderrDefinedForProp = function( propName, gridid, retrieveHeader ) {
        if( _.isEmpty( _propVsRenderingTemplate ) ) {
            generatePropRendererTemplateMap();
        }

        var propRenderingObj = _propVsRenderingTemplate[ propName ];
        if( propRenderingObj ) {
            var isHeaderTrue = isCustomTemplate( propRenderingObj.defaultPropRenderingTemplate, propRenderingObj.specificRenderingTemplates, retrieveHeader );
            var isCellTrue = isCustomTemplate( propRenderingObj.defaultPropRenderingTemplate, propRenderingObj.specificRenderingTemplates, retrieveHeader );
            if( isHeaderTrue === true && retrieveHeader === true || isCellTrue === true && retrieveHeader === false ) {
                return true;
            }
        }

        if( _defaultRenderingTemplates[ gridid ] ) {
            if( _defaultRenderingTemplates[ gridid ].isHeaderTemplate === true && retrieveHeader === true || _defaultRenderingTemplates[ gridid ].isCellTemplate === true && retrieveHeader ===
                false ) {
                return true;
            }
        }
        return false;
    };

    // Returns the correct property name
    const getPropName = function( column, vmo, tableElem ) {
        let propName = column.field;
        if( tableElem._tableInstance.gridOptions.transpose === true ) {
            propName = vmo.props.transposedColumnProperty.dbValue;
        }
        return propName;
    };

    var customCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var retrieveHeader = false;
            var propName = getPropName( column, vmo, tableElem );
            var colRenderTemplateDef = getColRendererTemplateToUse( propName, tableElem, retrieveHeader );
            var containerElement = null;
            if( !_.isEmpty( colRenderTemplateDef.template ) ) {
                //Template processing -> No need for async processing..
                containerElement = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                updateContainerWithCellTemplate( containerElement, vmo, column.field, colRenderTemplateDef.tooltip,
                    colRenderTemplateDef.template, colRenderTemplateDef.template, colRenderTemplateDef.dependentServices, column, tableElem );
            } else if( !_.isEmpty( colRenderTemplateDef.templateUrl ) ) {
                //Async loading for template once template is loaded
                containerElement = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                var templateUrl = awConfiguration.get( 'baseUrl' ) + colRenderTemplateDef.templateUrl;

                var compiledTemplateFn = getCompiledFunctionFromCache( templateUrl, null );
                if( compiledTemplateFn ) {
                    //If compiled function already exists for templateUrl, return
                    updateContainerWithCellTemplate( containerElement, vmo, column.field, colRenderTemplateDef.tooltip,
                        templateUrl, '', colRenderTemplateDef.dependentServices, column, tableElem );
                } else {
                    loadTemplate( containerElement, vmo, templateUrl, colRenderTemplateDef.dependentServices ).then( function( response ) {
                        updateContainerWithCellTemplate( response.containerElement, response.vmo, column.field, colRenderTemplateDef.tooltip,
                            response.templateUrl, response.htmlString, response.dependentServices, column, tableElem );
                    } );
                }
            } else if( !_.isEmpty( colRenderTemplateDef.renderFunction ) ) {
                containerElement = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                var args = [ vmo, containerElement, column.field, colRenderTemplateDef.tooltip ];

                /** revisitme Santhosh - The below methods to get and load dependent module has changed and both of them are same now.
                 *  Now getDependentModule method returns a promise which is not the case in old afx.
                 *  If the method implementations are changed again, we need to revert the code back to two method calls for get and load.
                 * we need to understand what this cachedDep obj is really doing in terms of performance or if there is any other reason
                 * and once we have that understanding, we need to add similar logic again.
                 * */
                /* var cachedDepModuleObj = getDependentModule( colRenderTemplateDef.deps );
                if( !cachedDepModuleObj ) {
                    loadDependentModule( colRenderTemplateDef.deps ).then( function( depModuleObj ) {
                        depModuleObj[ colRenderTemplateDef.renderFunction ].apply( null, args );
                        return containerElement;
                    } );
                } else {
                    cachedDepModuleObj[ colRenderTemplateDef.renderFunction ].apply( null, args );
                }*/

                loadDependentModule( colRenderTemplateDef.deps ).then( function( depModuleObj ) {
                    depModuleObj[ colRenderTemplateDef.renderFunction ].apply( null, args );
                    //return containerElement;
                } );
            }
            if( containerElement !== null ) {
                containerElement.style.paddingLeft = Const.CUSTOM_CELL_LEFTPADDING_DEFAULT_SPACE + 'px';
            }
            return containerElement; // If container element is null, default rendering will happen
        },
        condition: function( column, vmo, tableElem ) {
            var retrieveHeader = false;
            var propName = column.field;

            // If transpose, use the propName representing the vmo to apply the renderer across the row instead of column for transpose.
            // Don't apply renderer for the first column in transpose since it represents the column property.
            if( tableElem._tableInstance.gridOptions.transpose === true && column.field !== 'transposedColumnProperty' ) {
                propName = vmo.props.transposedColumnProperty.dbValue;
            }

            if( column.enableRendererContribution && isGraphicalRenderrDefinedForProp( propName, tableElem.id, retrieveHeader ) ) {
                //If propertyRenderer template defined for a given property, use it for rendering
                return true;
            }
            return false;
        }
    };

    var customCellHeaderRenderer = {
        action: function( column, tableElem ) {
            var retrieveHeader = true;
            var colRenderTemplateDef = getColRendererTemplateToUse( column.field, tableElem, retrieveHeader );
            var containerElement = null;
            if( !_.isEmpty( colRenderTemplateDef.headerTemplate ) ) {
                //Template processing -> No need for async processing..
                containerElement = document.createElement( 'div' );
                updateContainerWithCellTemplate( containerElement, null, column.field, colRenderTemplateDef.tooltip,
                    colRenderTemplateDef.headerTemplate, colRenderTemplateDef.headerTemplate, colRenderTemplateDef.dependentServices, column, tableElem );
            } else if( !_.isEmpty( colRenderTemplateDef.headerTemplateUrl ) ) {
                //Async loading for template once template is loaded
                containerElement = document.createElement( 'div' );
                var templateUrl = awConfiguration.get( 'baseUrl' ) + colRenderTemplateDef.headerTemplateUrl;
                var compiledTemplateFn = getCompiledFunctionFromCache( templateUrl, null );
                if( compiledTemplateFn ) {
                    //If compiled function already exists for templateUrl, return
                    updateContainerWithCellTemplate( containerElement, null, column.field, colRenderTemplateDef.tooltip,
                        templateUrl, '', colRenderTemplateDef.dependentServices, column, tableElem );
                } else {
                    loadTemplate( containerElement, null, templateUrl, colRenderTemplateDef.dependentServices ).then( function( response ) {
                        updateContainerWithCellTemplate( response.containerElement, response.vmo, column.field, colRenderTemplateDef.tooltip,
                            response.templateUrl, response.htmlString, response.dependentServices, column, tableElem );
                    } );
                }
            } else if( !_.isEmpty( colRenderTemplateDef.headerRenderFunction ) ) {
                containerElement = document.createElement( 'div' );
                var args = [ containerElement, column.field, colRenderTemplateDef.tooltip, column ];
                /** revisitme Santhosh - The below methods to get and load dependent module has changed and both of them are same now.
                 *  Now getDependentModule method returns a promise which is not the case in old afx.
                 *  If the method implementations are changed again, we need to revert the code back to two method calls for get and load.
                 * we need to understand what this cachedDep obj is really doing in terms of performance or if there is any other reason
                 * and once we have that understanding, we need to add similar logic again.
                 * */
                /*  var cachedDepModuleObj = getDependentModule( colRenderTemplateDef.deps );
                if( !cachedDepModuleObj ) {
                    loadDependentModule( colRenderTemplateDef.deps ).then( function( depModuleObj ) {
                        depModuleObj[ colRenderTemplateDef.headerRenderFunction ].apply( null, args );
                        return containerElement;
                    } );
                } else {
                    cachedDepModuleObj[ colRenderTemplateDef.headerRenderFunction ].apply( null, args );
                } */
                loadDependentModule( colRenderTemplateDef.deps ).then( function( depModuleObj ) {
                    depModuleObj[ colRenderTemplateDef.headerRenderFunction ].apply( null, args );
                } );
            } else if( !_.isEmpty( colRenderTemplateDef.headerComponent ) ) {
                var vmo = {};
                containerElement = document.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
                createInlineComponent( colRenderTemplateDef.headerComponent, containerElement, vmo, column );
            }
            return containerElement; // If container element is null, default rendering will happen
        },
        condition: function( column, tableElem ) {
            var retrieveHeader = true;
            if( column.enableRendererContribution && isGraphicalRenderrDefinedForProp( column.field, tableElem.id, retrieveHeader ) ) {
                //If propertyRenderer template defined for a given property, use it for rendering
                return true;
            }
            return false;
        }
    };

    /**
     * Rich Text Field
     */
    var richTextCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var prop = vmo.props[ column.field ];
            var newValues = getNewValues( prop );
            var oldValues = getOldValues( prop );

            var cellTop = util.createElement( 'ul', Const.CLASS_TABLE_NON_EDIT_CELL_LIST, Const.CLASS_TABLE_CELL_TOP );
            if( tableElem && tableElem._tableInstance.dynamicRowHeightStatus ) {
                cellTop.classList.add( Const.CLASS_TABLE_CELL_TOP_DYNAMIC );
            }

            // Add tooltip
            if( newValues.length > 0 ) {
                var tooltipHTML = getTooltipHTML( newValues );
                addTooltipListeners( cellTop, tooltipHTML, tableElem );
            }

            while( newValues.length > 0 || oldValues.length > 0 ) {
                var liElement = util.createElement( 'li', Const.CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM );
                liElement.style.width = '100%';

                var rtfContainer;
                var newValue = newValues.shift();
                var oldValue = oldValues.shift();

                if( newValue ) {
                    if( oldValue ) {
                        rtfContainer = util.createElement( 'div', Const.CLASS_TABLE_RTF_CELL_ITEM, Const.CLASS_AW_CHANGED_TEXT );
                    } else {
                        rtfContainer = util.createElement( 'div', Const.CLASS_TABLE_RTF_CELL_ITEM );
                    }
                    rtfContainer.innerHTML = exports.addHighlights( newValue );
                    liElement.appendChild( rtfContainer );
                }

                if( hasOldValue( oldValue, prop.oldValue ) ) {
                    var oldCellTextElement = util.createElement( 'div', Const.CLASS_AW_OLD_TEXT );
                    oldCellTextElement.innerHTML = exports.addHighlights( oldValue );
                    liElement.appendChild( oldCellTextElement );
                }

                // NOTE: For Firefox there is a limitation that the vertical scroll bar is not show up,
                // because of issue below:
                // https://stackoverflow.com/questions/28636832/firefox-overflow-y-not-working-with-nested-flexbox
                // there is a workaround by using { min-height: 0 }, I have not tested it yet and no plan to fix it
                // now.
                // It is not only an RTF issue, same problem for string list and object list

                // Dynamic styling for RTF
                if( rtfContainer && rtfContainer.childElementCount > 1 && newValues.length === 1 ) {
                    liElement.style.height = '100%';
                }
                cellTop.appendChild( liElement );
            }

            return cellTop;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return vmo.props &&
                vmo.props[ column.field ] &&
                vmo.props[ column.field ].isRichText;
        }
    };

    /**
     * Plain Text
     */
    var simpleTextCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var prop = vmo.props[ column.field ];
            var dynamicRowHeightEnabled = tableElem && tableElem._tableInstance.dynamicRowHeightStatus;
            var cellTop = util.createElement( 'div', Const.CLASS_TABLE_CELL_TOP );
            if( dynamicRowHeightEnabled ) {
                cellTop.classList.add( Const.CLASS_TABLE_CELL_TOP_DYNAMIC );
            }

            if( prop.uiValue ) {
                var gridCellText = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_CELL_TEXT );
                if( dynamicRowHeightEnabled ) {
                    gridCellText.classList.add( Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );
                }
                cellTop.title = prop.uiValue;
                var parsedValue = sanitizer.htmlEscapeAllowEntities( prop.uiValue, true, true );

                if( ( column.isTableCommand || column.isTreeNavigation ) && clickableTitleService.hasClickableCellTitleActions() ) {
                    addClickableCellTitle( gridCellText, vmo, parsedValue, tableElem );
                } else {
                    gridCellText.innerHTML = exports.addHighlights( parsedValue );
                }
                cellTop.appendChild( gridCellText );
            }

            return cellTop;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return vmo.props &&
                vmo.props[ column.field ] &&
                !vmo.props[ column.field ].isRichText &&
                !vmo.props[ column.field ].oldValue &&
                !vmo.props[ column.field ].isArray;
        }
    };

    var plainTextCellRenderer = {
        action: function( column, vmo, tableElem, rowElem ) {
            var prop = vmo.props[ column.field ];
            var newValues = getNewValues( prop );
            var oldValues = getOldValues( prop );

            var dynamicRowHeightEnabled = tableElem && tableElem._tableInstance.dynamicRowHeightStatus;

            var ulElement = util.createElement( 'ul', Const.CLASS_TABLE_NON_EDIT_CELL_LIST, Const.CLASS_TABLE_CELL_TOP );
            if( dynamicRowHeightEnabled ) {
                ulElement.classList.add( Const.CLASS_TABLE_CELL_TOP_DYNAMIC );
            }

            // Add tooltip
            if( prop.isArray ) {
                if( newValues.length > 0 ) {
                    var tooltipHTML = getTooltipHTML( newValues );
                    addTooltipListeners( ulElement, tooltipHTML, tableElem );
                }
            } else {
                ulElement.title = prop.uiValue;
            }

            while( newValues.length > 0 || oldValues.length > 0 ) {
                var liElement = util.createElement( 'li', Const.CLASS_TABLE_NON_EDIT_CELL_LIST_ITEM );
                var newValue = newValues.shift();
                var oldValue = oldValues.shift();
                var textElem;

                if( newValue ) {
                    if( hasOldValue( oldValue, prop.oldValue ) ) {
                        textElem = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_CELL_TEXT, Const.CLASS_AW_CHANGED_TEXT );
                    } else {
                        textElem = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_CELL_TEXT );
                    }

                    var parsedValue = sanitizer.htmlEscapeAllowEntities( newValue, true, true );
                    textElem.innerHTML = exports.addHighlights( parsedValue );
                    if( dynamicRowHeightEnabled ) {
                        textElem.classList.add( Const.CLASS_WIDGET_TABLE_CELL_TEXT_DYNAMIC );
                    }
                    liElement.appendChild( textElem );
                }

                if( oldValue ) {
                    var oldCellTextElement = util.createElement( 'div', Const.CLASS_WIDGET_TABLE_CELL_TEXT, Const.CLASS_AW_OLD_TEXT );
                    oldCellTextElement.innerHTML = exports.addHighlights( oldValue );
                    liElement.appendChild( oldCellTextElement );
                }
                ulElement.appendChild( liElement );
            }

            return ulElement;
        },
        condition: function( column, vmo, tableElem, rowElem ) {
            return vmo.props && vmo.props[ column.field ] &&
                !vmo.props[ column.field ].isRichText &&
                ( vmo.props[ column.field ].isArray ||
                    vmo.props[ column.field ].oldValue );
        }
    };

    var headerCellRenderer = {
        action: function( column ) {
            var labelElem = document.createElement( 'div' );
            labelElem.classList.add( Const.CLASS_HEADER_CELL_LABEL );
            labelElem.textContent = column.displayName;
            return labelElem;
        },
        condition: function() {
            return true;
        }
    };

    var headerIconCellRenderer = {
        action: function( column ) {
            let cellContent = document.createElement( 'div' );
            let imgContainer = util.createElement( 'div', Const.CLASS_HEADER_ICON_CONTAINER );
            var cellImg = util.createElement( 'img', Const.CLASS_HEADER_ICON );
            cellImg.src = util.getImgURL( column.vmo );
            cellImg.alt = getImageAltText( column.vmo );
            imgContainer.appendChild( cellImg );
            cellContent.appendChild( imgContainer );
            cellContent.appendChild( headerCellRenderer.action( column ) );
            return cellContent;
        },
        condition: function( column, tableElem ) {
            return tableElem._tableInstance.gridOptions.enableHeaderIcon === true && column.field !== 'transposedColumnProperty';
        }
    };

    /**
     * exposed method
     */
    _renderer.resetHoverCommandElement = function() {
        if( _cellCmdElem && _cellCmdElem.parentElement ) {
            util.cleanupComponents( _cellCmdElem.parentElement );
            if( _cellCmdElem.parentElement ) {
                _cellCmdElem.parentElement.removeChild( _cellCmdElem );
            }
        }
    };

    _renderer.destroyHoverCommandElement = function() {
        if( _cellCmdElem && _cellCmdElem.parentElement ) {
            util.cleanupComponents( _cellCmdElem.parentElement );
            if( _cellCmdElem.parentElement ) {
                _cellCmdElem.parentElement.removeChild( _cellCmdElem );
            }
            util.destroyElement( _cellCmdElem );
        }
        _cellCmdElem = null;
    };

    _renderer.getAwCellRenderers = function() {
        // NOTE: If the condition is not isolated, then the sequence matters.
        // Decorator renderers should be first in the array since they will call
        // Cell.createElement to get cell content provided by the next valid renderer.
        return [
            commandCellRenderer,
            customCellRenderer,
            iconCellRenderer,
            transposeIconCellRenderer,
            treeTableCellRenderer,
            objectCellRenderer,
            simpleTextCellRenderer,
            plainTextCellRenderer,
            richTextCellRenderer
        ];
    };

    _renderer.getAwHeaderRenderers = function() {
        return [
            customCellHeaderRenderer,
            headerIconCellRenderer,
            headerCellRenderer
        ];
    };

    return _renderer;
};
/**
 * Check if old value is available or not
 * @param  old value
 * @param old value of prop
 * @return boolean True/False
 */
function hasOldValue( oldValue, propOldValue ) {
    return oldValue || !_.isUndefined( propOldValue );
}

// cleanup global variables.
export let cleanup = function() {
    if( _propVsRenderingTemplate ) {
        _propVsRenderingTemplate = null;
    }
    if( _defaultRenderingTemplates ) {
        _defaultRenderingTemplates = {};
    }
};

exports = {
    createCellCommandElement,
    createTreeCellCommandElement,
    createCheckMarkElement,
    addHighlights,
    createCellRenderer,
    cleanup
};
export default exports;
