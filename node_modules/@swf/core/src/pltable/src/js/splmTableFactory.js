/* eslint-disable max-lines */
// Copyright (c) 2020 Siemens

/**
 * This service is the entry point for SPLM table. It initializes the table and renders it
 *
 * @module js/splmTableFactory
 */
import SPLMTableColumnRearrangement from 'js/splmTableColumnRearrangement';
import SPLMTableInfiniteScrollService from 'js/splmTableInfiniteScrollService';
import SPLMTableKeyboardService from 'js/splmTableKeyboardService';
import SPLMTableTranspose from 'js/splmTableTranspose';
import _ from 'lodash';
import appCtxService from 'js/appCtxService';
import awColumnFilterService from 'js/awColumnFilterService';
import awSPLMTableCellRendererFactory from 'js/awSPLMTableCellRendererFactory';
import declDragAndDropService from 'js/declDragAndDropService';
import domUtils from 'js/domUtils';
import dragAndDropService from 'js/dragAndDropService';
import eventBus from 'js/eventBus';
import localeService from 'js/localeService';
import selectionHelper from 'js/selectionHelper';
import splmTableDragHandler from 'js/splmTableDragHandler';
import uwUtilSvc from 'js/uwUtilService';
import messagingService from 'js/messagingService';
import { svgString as miscInProcessIndicator } from 'image/miscInProcessIndicator16.svg';
import { svgString as miscExpandedTree } from 'image/miscExpandedTree12.svg';
import { svgString as miscCollapsedTree } from 'image/miscCollapsedTree12.svg';
import util from 'js/splmTableUtils';
import Trv from 'js/splmTableTraversal';
import Const from 'js/splmTableConstants';
import Editor from 'js/splmTableEditor';
import MenuService from 'js/splmTableMenuService';
import Ctrl from 'js/splmTableDomController';
import Cell from 'js/splmTableCellRenderer';
import SPLMTableSelectionHelper from 'js/splmTableSelectionHelper';

/**
 * Cached reference to the various AngularJS and AW services.
 */
var exports = {};

var _splmTableMessages = {};

var _defaultContentFilter = {
    isIdOfObject: function( vmo, uid ) {
        let matchedId = false;
        if( vmo ) {
            if( vmo.alternateID ) {
                matchedId = vmo.alternateID === uid;
            }

            if( !matchedId && vmo.uid ) {
                matchedId = vmo.uid === uid || vmo.uid.indexOf( uid ) !== -1;
            }
        }
        return matchedId;
    }
};

const dom = domUtils.DOMAPIs;
/**
 * Check if we are using a 'gridid' in the closest 'declViewModel' in the scope tree.<BR>
 * If so: Use it to display the aw-table data<BR>
 *
 */
export let createTableObject = function( directiveElement, gridid, dataProvider, viewModelCollection, columnProvider, declViewModel, contentFilter, gridOptions, containerHeight,
    gridContextDispatcher, runActionWithViewModel, tableInstanceCallbacks, tableContext, reusable, showCheckBox ) {
    // 20180920: put it to null so that it will error out when there is an code error
    var _tableColumns = null;
    var _contentFilter = contentFilter || _defaultContentFilter;

    // setup cell renderer
    var cellRenderer = awSPLMTableCellRendererFactory.createCellRenderer();
    var table = util.createElement( 'div' );
    var _trv = new Trv( table );
    var tableCtrl = null;
    var tableEditor = null;
    var menuService = null;
    var _nodeExpansionInProgress = false;
    let tableScroll = null;
    let columnRearrangementService = null;
    let keyboardService = null;
    let updateEditState = null;
    let _showCheckBox = showCheckBox;

    // LCS-138303 - Performance tuning for 14 Objectset Table case - implementation
    // Define header and row height here to save computed CSS reading
    var _rowBorderWidth = 1;
    var _rowHeight = appCtxService.ctx.layout === 'compact' ? Const.HEIGHT_COMPACT_ROW : Const.HEIGHT_ROW;
    _rowHeight = util.getTableRowHeight( gridOptions, _rowHeight );

    var _headerHeight = Const.HEIGHT_HEADER;
    _headerHeight = util.getTableHeaderHeight( gridOptions, _headerHeight );

    // This updateColumnDefs function is called as part of the buildDynamicColumns.
    let _updateColumnDefs = function() {
        let columns = dataProvider.cols;
        if( gridOptions.transpose === true ) {
            // Get and assign transposed columns
            columns = SPLMTableTranspose.getTransposedColumns( _tableColumns, dataProvider.viewModelCollection.loadedVMObjects );
        }
        for( let i = 0; i < columns.length; i++ ) {
            columns[ i ].visible = !columns[ i ].hasOwnProperty( 'visible' ) || columns[ i ].visible;
        }

        _tableColumns = _.filter( columns, function( column ) {
            if( column.visible ) {
                return column;
            }
            return false;
        } );

        _.forEach( _tableColumns, function( column, index ) {
            column.index = index;

            if( !column.cellRenderers ) {
                column.cellRenderers = [];
            }
            if( column.name === 'icon' && column.iconCellRenderer ) {
                column.cellRenderers = column.cellRenderers.concat( column.iconCellRenderer );
            }
            column.cellRenderers = column.cellRenderers.concat( cellRenderer.getAwCellRenderers() );
        } );

        _.forEach( _tableColumns, function( column, index ) {
            column.index = index;

            if( !column.headerRenderers ) {
                column.headerRenderers = [];
            }

            column.headerRenderers = column.headerRenderers.concat( cellRenderer.getAwHeaderRenderers() );
        } );

        menuService.loadDefaultColumnMenus();
    };

    let getObjects = function() {
        if( !dataProvider.viewModelCollection ) {
            return [];
        }
        if( gridOptions.transpose === true ) {
            return SPLMTableTranspose.getTransposedVmos( dataProvider.cols, dataProvider.viewModelCollection.loadedVMObjects );
        }
        return dataProvider.viewModelCollection.loadedVMObjects;
    };

    let resetColumns = function() {
        _updateColumnDefs();

        awColumnFilterService.removeStaleFilters( columnProvider, _tableColumns );

        // property loading has completed
        tableCtrl.resetColumnDefs( _tableColumns );
        // Table headers recreated, need to initialize column rearrangement
        columnRearrangementService.initialize();

        // Trick for update scroll container position
        if( tableScroll.isInitialized() ) {
            cellRenderer.resetHoverCommandElement();
            tableScroll.setLoadedVMObjects( getObjects() );
            tableScroll.handleScroll();
        }
    };

    /**
     * Finds VMOs with undefined props within the specified range.
     *
     * @param {int} startIndex - starting VMO index
     * @param {int} endIndex - edning VMO index
     */
    var findVMOsWithMissingProps = function( startIndex, endIndex ) {
        var emptyVMOs = [];

        for( var i = startIndex; i <= endIndex; i++ ) {
            var vmo = dataProvider.viewModelCollection.loadedVMObjects[ i ];
            if( vmo.isPropLoading ) {
                continue;
            } else if( !vmo.props ) {
                emptyVMOs.push( vmo );
            } else {
                var keys = Object.keys( vmo.props );

                if( keys.length === 0 ) {
                    emptyVMOs.push( vmo );
                }
            }
        }

        return emptyVMOs;
    };

    let loadMissingProps = function() {
        var firstRenderedItemIndex = tableScroll.getFirstRenderedItemIndex();
        var lastRenderedItemIndex = tableScroll.getLastRenderedItemIndex();
        var emptyVMOs = findVMOsWithMissingProps( firstRenderedItemIndex, lastRenderedItemIndex );
        if( emptyVMOs.length > 0 ) {
            eventBus.publish( gridid + '.plTable.loadProps', {
                VMOs: emptyVMOs
            } );
        }
    };

    if( gridid ) {
        var instanceEventSubcr = [];

        // Do essential table DOM Element initialization for further processing
        table.id = gridid;

        table.classList.add( Const.CLASS_TABLE );
        table.classList.add( Const.CLASS_WIDGET_GRID );
        table.classList.add( Const.CLASS_LAYOUT_COLUMN );
        table.classList.add( Const.CLASS_WIDGET_TABLE_DROP );
        table.classList.add( Const.CLASS_SELECTION_ENABLED );

        util.setSortCriteriaOnColumns( columnProvider, dataProvider );

        var getContainerHeight = function() {
            if( containerHeight !== undefined ) {
                return containerHeight;
            }

            if( gridOptions.maxRowsToShow !== undefined ) {
                return ( _rowHeight + _rowBorderWidth ) * gridOptions.maxRowsToShow + Const.HEIGHT_HEADER;
            }

            return undefined;
        };

        tableScroll = new SPLMTableInfiniteScrollService( getContainerHeight() );

        table._tableInstance = {
            ctx: appCtxService.ctx,
            messages: _splmTableMessages,
            declViewModel: declViewModel,
            dataProvider: dataProvider,
            viewModelCollection: viewModelCollection,
            columnProvider: columnProvider,
            gridId: gridid,
            gridOptions: gridOptions,
            isBulkEditing: false,
            isCellEditing: false,
            renderer: tableScroll,
            dynamicRowHeightStatus: false,
            cellRenderer: cellRenderer,
            runActionWithViewModel: runActionWithViewModel,
            tableInstanceCallbacks,
            tableContext: tableContext ? tableContext : {},
            showCheckBox: showCheckBox
        };

        tableEditor = new Editor( table, directiveElement, gridContextDispatcher );
        table._tableInstance.editor = tableEditor;
        keyboardService = new SPLMTableKeyboardService( table, tableEditor );
        keyboardService.setupKeyListener();
        table._tableInstance.keyboardService = keyboardService;

        menuService = new MenuService( table, directiveElement, table._tableInstance, gridContextDispatcher );

        if( gridOptions.enableGridMenu ) {
            menuService.addGridMenu();
        }

        if( gridOptions.showContextMenu === true ) {
            menuService.setContextSelectionHelper( selectionHelper );
        }

        if( gridOptions.enableDynamicRowHeight ) {
            table._tableInstance.dynamicRowHeightStatus = true;
        }

        _updateColumnDefs();

        tableCtrl = new Ctrl( table, _tableColumns, tableEditor, gridContextDispatcher );
        table._tableInstance.controller = tableCtrl;
        table._tableInstance.editor = tableEditor;

        // LCS-13247 Pagination SOA performance issue for Objectset Table
        // - Put a debounce here to avoid possible sending traffic jam, the number
        //   is from _pingRedrawDebounce from aw.table.controller
        // - With debounce IE performance improves a lot and no impact to chrome performance,
        //   so leave the debounce for all
        var _loadMorePageDebounce = _.debounce( function( firstRenderedItem, lastRenderedItem ) {
            eventBus.publish( gridid + '.plTable.loadMorePages', {
                firstRenderedItem: firstRenderedItem,
                lastRenderedItem: lastRenderedItem
            } );
        }, 500 );

        var pendingUpdatedProps = {};

        var updateRowContents = function( updatedPropsMaps ) {
            var rowElements = _trv.queryAllRowCellElementsFromTable();
            _.forEach( updatedPropsMaps, function( updatedProps, vmoUid ) {
                _.forEach( rowElements, function( rowElem ) {
                    _.forEach( rowElem.children, function( cellElem ) {
                        // Check if the vmo has been updated, if not continue to next cell
                        let updatedVmo = null;
                        if( rowElem.vmo && rowElem.vmo.uid === vmoUid ) {
                            updatedVmo = rowElem.vmo;
                        } else if( gridOptions.transpose === true && cellElem.columnDef.vmo && cellElem.columnDef.vmo.uid === vmoUid ) {
                            updatedVmo = cellElem.columnDef.vmo;
                        } else {
                            return;
                        }

                        var needsUpdate = false;
                        if( cellElem.columnDef && cellElem.columnDef.name === 'icon' ||
                            gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === 'icon' ) {
                            var imgElem = cellElem.getElementsByTagName( 'img' )[ 0 ];
                            if( imgElem && imgElem.getAttribute( 'src' ) !== util.getImgURL( updatedVmo ) ) {
                                needsUpdate = true;
                            }
                        } else {
                            for( var i = 0; i < updatedProps.length; i++ ) {
                                if( cellElem.propName === updatedProps[ i ] ||
                                    gridOptions.transpose === true && rowElem.vmo.props.transposedColumnProperty.dbValue === updatedProps[ i ] ) {
                                    needsUpdate = true;
                                    break;
                                }
                            }
                        }

                        if( needsUpdate ) {
                            Cell.updateCell( cellElem, rowElem, table, tableEditor );
                            if( rowElem.vmo.selected && ( cellElem.columnDef.isTableCommand || cellElem.columnDef.isTreeNavigation ) ) {
                                let cellTop = cellElem.children[ 0 ];
                                if( cellElem.columnDef.isTreeNavigation ) {
                                    cellTop = cellElem.getElementsByClassName( 'aw-jswidgets-tableNonEditContainer' )[ 0 ];
                                }
                                if( cellTop.getElementsByClassName( Const.CLASS_AW_CELL_COMMANDS_CONTAINER ).length === 0 ) {
                                    if( dataProvider.selectionModel && !dataProvider.selectionModel.multiSelectEnabled && dataProvider.selectionModel
                                        .getCurrentSelectedCount() === 1 ) {
                                        let cellCommand = awSPLMTableCellRendererFactory.createCellCommandElement( cellElem.columnDef, rowElem.vmo, true );
                                        cellTop.appendChild( cellCommand );
                                    }
                                }
                            }
                        }
                    } );
                } );
            } );
        };

        var updatePendingProps = _.debounce( function() {
            // prevent from calling if table has been destroyed in meantime
            if( !table._tableInstance.isDestroyed ) {
                updateRowContents( pendingUpdatedProps );
                pendingUpdatedProps = {};
            }
        }, 250 );

        instanceEventSubcr.push( eventBus.subscribe( 'viewModelObject.propsUpdated', function( updatedProps ) {
            // Merge the updatedVmos into pendingUpdatedVmos
            for( var vmoUid in updatedProps ) {
                if( pendingUpdatedProps[ vmoUid ] === undefined ) {
                    pendingUpdatedProps[ vmoUid ] = updatedProps[ vmoUid ];
                } else {
                    for( var i = 0; i < updatedProps[ vmoUid ].length; i++ ) {
                        var updatedPropName = updatedProps[ vmoUid ][ i ];
                        if( pendingUpdatedProps[ vmoUid ].indexOf( updatedPropName ) === -1 ) {
                            pendingUpdatedProps[ vmoUid ].push( updatedPropName );
                        }
                    }
                }
            }
            updatePendingProps();
        } ) );

        var loadProps = function( emptyVMOs ) {
            eventBus.publish( gridid + '.plTable.loadProps', {
                VMOs: emptyVMOs
            } );
        };

        var editCellElement;

        columnRearrangementService = new SPLMTableColumnRearrangement( table );

        // 20180927: This is not related to global isEdit anymore, feel free
        // to refactor:)
        var updateEditStatusForTableCanvas = function( isEditing ) {
            tableCtrl.setDraggable( !isEditing );
            tableEditor.updateEditStatus( isEditing );
        };

        var _setupTreeForRestrictiveEditing = function( isEditing ) {
            tableScroll.setupTreeEditScroll( isEditing );
        };

        updateEditState = function( eventData ) {
            // We should not start edit for any non table cases.
            // This should be started only for table cases and also based on the grid id you are on.
            // PWA case the dataSource is the dataProvider, thus has no .dataProviders property (we check if it is the dataProvider in scope with .name)
            // SWA case we have dataSource.dataProvider and can check with dataProviders[ dataProvider.name ]
            if( tableCtrl && eventData.dataSource && ( eventData.dataSource.getAtomicData
              && eventData.dataSource.getAtomicData().dpRef && eventData.dataSource.getAtomicData().dpRef.current
              || eventData.dataSource.name === dataProvider.name ) ) {
                var isEditing = eventData.state === 'partialSave' || eventData.state === 'starting';

                // If saving, set all column filters to be stale as data could have changed
                if( eventData.state === 'saved' ) {
                    _.forEach( dataProvider.cols, function( column ) {
                        awColumnFilterService.setColumnFilterStale( column );
                    } );
                    if( !util.isAutoSaveEnabled( table ) ) {
                        tableEditor.clearPropIsEditableCache();
                    }
                    util.setIsCellEditing( table, false );
                } else if( eventData.state === 'canceling' ) {
                    tableEditor.clearPropIsEditableCache();
                    util.setIsCellEditing( table, false );
                }

                // Enable vmo caching on collapse in edit mode
                dataProvider.cacheCollapse = true;

                util.setIsBulkEditing( table, isEditing );
                gridContextDispatcher( {
                    type: 'UPDATE_VALUES',
                    isBulkEditing: table._tableInstance.isBulkEditing,
                    dynamicRowHeightStatus: table._tableInstance.dynamicRowHeightStatus
                } );

                tableCtrl.setSelectable( !isEditing );

                if( util.isCellEditing( table ) === false || util.isCellEditing( table ) && !util.isAutoSaveEnabled( table ) ) {
                    updateEditStatusForTableCanvas( isEditing );
                }

                if( gridOptions.useTree && !util.isExpandOrPaginationAllowedInEdit( table ) ) {
                    _setupTreeForRestrictiveEditing( isEditing );
                }

                if( !isEditing ) {
                    // Restore original cache collapse state when leaving edit mode
                    dataProvider.restoreInitialCacheCollapseState();
                }
                if( table._tableInstance.dynamicRowHeightStatus === true ) {
                    resetDynamicRowHeights();
                    clientRefresh();
                }
            }
        };

        instanceEventSubcr.push( eventBus.subscribe( dataProvider._eventTopicEditInProgress, function() {
            if ( reusable !== true ) {
                const eventData = {
                    dataSource: dataProvider,
                    state: dataProvider._editingState
                };
                updateEditState( eventData );
            }
        } ) );

        instanceEventSubcr.push( eventBus.subscribe( declViewModel._internal.eventTopicEditInProgress, function() {
            const eventData = {
                dataSource: declViewModel,
                state: declViewModel._editingState
            };
            updateEditState( eventData );
        } ) );

        instanceEventSubcr.push( eventBus.subscribe( 'plTable.editStateChange', function( eventData ) {
            updateEditState( eventData );
        } ) );

        instanceEventSubcr.push( eventBus.subscribe( 'editHandlerStateChange', function( eventData ) {
            updateEditState( eventData );
        } ) );

        var _updateAllRowsVisibilityDebounce = _.debounce( function() {
            var rowElements = _trv.queryAllRowCellElementsFromTable();
            _.forEach( rowElements, function( row ) {
                if( row.vmo ) {
                    var cellTopElem = row.getElementsByClassName( Const.CLASS_SPLM_TABLE_ICON_CELL )[ 0 ];
                    if( !cellTopElem ) {
                        cellTopElem = row.getElementsByClassName( Const.CLASS_AW_TREE_COMMAND_CELL )[ 0 ];
                    }
                    if( cellTopElem ) {
                        var iconCellElem = cellTopElem.parentElement;
                        var columnDef = iconCellElem.columnDef;
                        var newCellTop = Cell.createElement( columnDef, row.vmo, table, row );
                        iconCellElem.replaceChild( newCellTop, cellTopElem );
                    }
                }
            } );
        }, 100 );

        /**
         * Subscribe to resetScroll. Clear the tables rendered items cache and scroll to top of table.
         */
        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.resetScroll', function() {
            resetInfiniteScroll();
        } ) );

        var verdict = util.validateRowHeightGridOption( table._tableInstance.gridOptions );
        /**
         * Subscribe to LayoutChangeEvent. Update row height to correct value
         */
        if( verdict === false ) {
            instanceEventSubcr.push( eventBus.subscribe( 'LayoutChangeEvent', function( data ) {
                var oldHeight = _rowHeight;
                _rowHeight = data.rowHeight;
                if( oldHeight === _rowHeight ) {
                    return;
                }
                if( tableScroll.isInitialized() ) {
                    tableScroll.setRowHeight( _rowHeight + _rowBorderWidth );

                    var newContainerHeight = getContainerHeight();
                    if( newContainerHeight !== undefined ) {
                        tableScroll.setContainerHeight( newContainerHeight );
                    }
                    // Reinitialize properties so that the rendering calculations are valid
                    tableScroll.initializeProperties();

                    // Reset dynamic row height if enabled
                    if( table._tableInstance.dynamicRowHeightStatus ) {
                        resetDynamicRowHeights();
                    }

                    tableScroll.updateRowAlignment();

                    // Scroll to rows in that were in view before layout change
                    var scrollContainer = _trv.getScrollCanvasElementFromTable();
                    var oldScrollTop = scrollContainer.scrollTop;
                    scrollContainer.scrollTop = oldScrollTop / oldHeight * _rowHeight;
                    tableScroll.handleScroll();
                }
            } ) );
        }

        // Reusable table does not need below named events for selection changes, it will now work with selectionData.
        let isReusable = _.isString( reusable ) ?  reusable === 'true' : reusable;
        if (  isReusable !== true ) {
            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectionChangeEvent', function() {
                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );
            } ) );

            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectAll', function() {
                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );
            } ) );

            instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.selectNone', function() {
                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );
            } ) );
        }

        instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.visibilityStateChanged', _updateAllRowsVisibilityDebounce ) );

        instanceEventSubcr.push( eventBus.subscribe( gridid + '.plTable.resizeCheck', function() {
            if( tableScroll.isInitialized() ) {
                tableScroll.checkForResize();
            }
        } ) );

        var scrollToRow = function( gridId, rowUids ) {
            if( gridid === gridId ) {
                if( util.isBulkEditing( table ) ) {
                    return;
                }
                var rowIndexes = [];
                for( var i = 0; i < rowUids.length; i++ ) {
                    var uid = rowUids[ i ].uid ? rowUids[ i ].uid : rowUids[ i ];
                    var rowIndex = dataProvider.viewModelCollection.findViewModelObjectById( uid );
                    if( rowIndex !== -1 ) {
                        rowIndexes.push( rowIndex );
                    }
                }
                if( rowIndexes.length > 0 ) {
                    tableScroll.scrollToRowIndex( rowIndexes );
                }
            }
        };

        instanceEventSubcr.push( eventBus.subscribe( 'plTable.scrollToRow', function( eventData ) {
            scrollToRow( eventData.gridId, eventData.rowUids );
        } ) );

        var updateDecoratorVisibility = function( isEnabled ) {
            if( isEnabled === true && gridOptions.showDecorators !== false ) {
                table.classList.add( Const.CLASS_AW_SHOW_DECORATORS );
            } else {
                table.classList.remove( Const.CLASS_AW_SHOW_DECORATORS );
            }
        };

        var decoratorToggle = 'decoratorToggle';

        var showDecorators = appCtxService.getCtx( decoratorToggle );
        updateDecoratorVisibility( showDecorators );

        instanceEventSubcr.push( eventBus.subscribe( 'appCtx.register', function( event ) {
            if( event.name === decoratorToggle ) {
                updateDecoratorVisibility( event.value );
            }
        } ) );

        instanceEventSubcr.push( eventBus.subscribe( 'appCtx.update', function( event ) {
            if( event.name === decoratorToggle ) {
                updateDecoratorVisibility( event.value.decoratorToggle );
            }
        } ) );

        instanceEventSubcr.push( eventBus.subscribe( 'decoratorsUpdated', function( updateVMOs ) {
            updateVMOs = updateVMOs.length === undefined ? [ updateVMOs ] : updateVMOs;
            tableCtrl.updateColorIndicatorElements( updateVMOs );
        } ) );

        /**
         * React to request for node expansions.
         */
        instanceEventSubcr.push( eventBus.subscribe( dataProvider.name + '.expandTreeNode', function( eventData ) {
            if( eventData.parentNode ) {
                var vmCollection = dataProvider.getViewModelCollection();

                var rowNdx = vmCollection.findViewModelObjectById( eventData.parentNode.id );

                if( rowNdx !== -1 ) {
                    var vmo = vmCollection.getViewModelObject( rowNdx );
                    if( vmo.isExpanded !== true ) {
                        vmo.isExpanded = true;
                        if( tableInstanceCallbacks.toggleTreeNode ) {
                            tableInstanceCallbacks.toggleTreeNode( vmo );
                        } else {
                            eventBus.publish( table.id + '.plTable.toggleTreeNode', vmo );
                        }
                    }
                }
            }
        } ) );

        const getTargetVmo = function( element, isTarget ) {
            /**
             * Merge event 'target' with any other objects currently selected.
             */
            var targetObjects = [];

            var elementRow = element.classList.contains( Const.CLASS_ROW ) ? element : util.closestElement( element, '.' + Const.CLASS_ROW );

            if( elementRow && elementRow.vmo ) {
                targetObjects.push( elementRow.vmo );
                var targetUid = elementRow.vmo.uid;

                if( !isTarget ) {
                    var sourceObjects = dragAndDropService.getSourceObjects(
                        dataProvider, targetUid ).filter( function( obj ) {
                        return targetObjects.indexOf( obj ) === -1;
                    } );
                    targetObjects = targetObjects.concat( sourceObjects );
                }

                return targetObjects;
            }

            return null;
        };

        const clearRowSelection = ( targetVMO ) => { // eslint-disable-line
            dataProvider.selectNone();
        };

        var listenToRelatedModifiedEvent = false;
        var targetVMOScoped = null;
        const selectTarget = ( targetElement, targetVMO ) => { // eslint-disable-line
            /**
             * Setup to listen when the 'drop' is complete
             */
            if ( !listenToRelatedModifiedEvent ) {
                listenToRelatedModifiedEvent = true;
                targetVMOScoped = targetVMO;
            }
        };

        const isTextNodeDragged = ( dataTranferObj ) => {
            if( dataTranferObj && dataTranferObj.types ) {
                return event.type === 'dragstart' && [ ...dataTranferObj.types ].some( type => type === 'text/plain' || type === 'Text' );
            }
            return false;
        };

        let newCallbackApis = {
            clearSelection: clearRowSelection,
            setSelection: ( targetVMO ) => {
                selectTarget( null, targetVMO );
            },
            getTargetElementAndVmo: ( event, isSourceEle ) => {
                let targetVMO = null;
                let target = null;
                if( !isTextNodeDragged( event.dataTransfer ) ) {
                    target = dom.closest( event.target, '.ui-grid-row' ) || dom.closest( event.target, '.aw-widgets-droppable' );
                }
                if( target ) {
                    targetVMO = getTargetVmo( target, !isSourceEle );
                }
                return {
                    targetElement: target,
                    targetVMO: targetVMO
                };
            },
            highlightTarget: ( eventData ) => {
                splmTableDragHandler.handleDragDropHighlightPLTable( eventData );
            }
        };

        const registerSplmTableDndListner = ( element, callbackApis, declViewModel, tableProvider ) => {
            const getEventCallbackFn = ( event ) => {
                let target = {};
                let isSourceEle = event.type === 'dragstart';
                if( callbackApis.getTargetElementAndVmo ) {
                    target = callbackApis.getTargetElementAndVmo( event, isSourceEle );
                }
                let fun = declViewModel.dndHandler[ event.type ];
                fun( event, target, callbackApis, tableProvider );
            };
            const setListener = ( eventType ) => {
                let callBackFn = getEventCallbackFn.bind( null );
                element.addEventListener( eventType, callBackFn );
            };
            const setEventListener = ( providers ) => {
                Object.keys( providers ).forEach( ( providerName ) => {
                    setListener( providerName.toLowerCase() );
                } );
            };
            let dragProviders = declDragAndDropService.getDragHandler( declViewModel );
            if( dragProviders ) {
                setEventListener( dragProviders );
            }
            let dropProviders = declDragAndDropService.getDropHandler( declViewModel );
            if( dropProviders ) {
                setEventListener( dropProviders );
            }
        };
        table._tableInstance.subDefs = instanceEventSubcr;

        directiveElement.appendChild( table );

        // Drag and drop service needs to be setup after table has been attached to the directive element so
        // that it can properly get the scope.
        if( gridOptions.enableDragAndDrop !== false ) {
            /**
             * LCS-315044: Setup the drag and drop with the new design pattern if drag and drop
             * handlers are defined for table's container view.
             *
             * The branching is done to support AW, as AW is still consuming the old drag and drop pattern.
             */
            if( declDragAndDropService.areDnDHandelersDefined( declViewModel ) ) {
                registerSplmTableDndListner( table, newCallbackApis, declViewModel, dataProvider );
            }
        } else {
            dragAndDropService.disableDragAndDrop( table );
        }
    }

    var getIconCellSVG = function( vmo ) {
        if( vmo.loadingStatus ) {
            return { id: 'miscInProcessIndicator', image: miscInProcessIndicator };
        } else if( vmo.isLeaf ) {
            // we made the decision to stop rendering 'typeBlankIcon' because (1) there is no visual difference, (2) we want
            // to decrease the number of DOM elements and (3) we don't know the history of why it was there.
            return {};
        } else if( vmo.isExpanded ) {
            return { id: 'miscExpandedTree', image: miscExpandedTree };
        }
        return { id: 'miscCollapsedTree', image: miscCollapsedTree };
    };

    let updateContentRowSelection = () => {
        SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
            _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );
    };

    let updateSortDirection = ( currentColumnIndex, newColumnIndex, sortDirection ) => {
        tableCtrl.setHeaderCellSortDirection( currentColumnIndex, newColumnIndex, sortDirection );
    };

    let refresh = function() {
        var columnAttrs = [];

        // attributesToInflate at server side cannot accept full name i.e typename.propertyname.
        // we don't need to inflate the attributes or properties that are hidden.
        _.forEach( dataProvider.cols, function( uwColumnInfo ) {
            if( uwColumnInfo.field && uwColumnInfo.hiddenFlag !== true ) {
                columnAttrs.push( uwColumnInfo.field );
            }
        } );

        if( dataProvider && dataProvider.action && dataProvider.action.inputData ) {
            dataProvider.action.inputData.searchInput = dataProvider.action.inputData.searchInput || {};
            var searchInput = dataProvider.action.inputData.searchInput;

            if( searchInput.attributesToInflate ) {
                searchInput.attributesToInflate = _.union( searchInput.attributesToInflate, columnAttrs );
            } else {
                searchInput.attributesToInflate = columnAttrs;
            }
        }

        // Since VMOs represent columns, we need to reset the columns also for transpose mode
        if( gridOptions.transpose === true ) {
            resetColumns();
        }

        // REFACTOR: infinite scroll code should be refactor to follow:
        // 1. DOMElement should be the only interface for interaction between service and function
        // 2. Lot of code below should be pull out from anonymous function, a initialize grid which
        //    is taking 70 line of code is a bad smell.
        if( !tableScroll.isInitialized() ) {
            // Set initial scroll index before table initializes
            if( dataProvider.isFocusedLoad ) {
                var selection = dataProvider.getSelectedObjects();
                if( selection.length === 1 ) {
                    scrollToRow( gridid, [ selection[ 0 ].uid ] );
                }
            }

            tableScroll.initializeGrid( {
                tableElem: table,
                directiveElem: directiveElement,
                scrollViewportElem: _trv.getScrollCanvasElementFromTable(),
                pinViewportElem: _trv.getPinCanvasElementFromTable(),
                rowSelector: '.' + Const.CLASS_ROW,
                rowHeight: _rowHeight + _rowBorderWidth,
                headerHeight: _headerHeight,
                dynamicRowHeightStatus: gridOptions.enableDynamicRowHeight,
                loadedVMObjects: getObjects(),
                updateVisibleCells: function( rowParentElem ) {
                    tableCtrl.updateVisibleCells( rowParentElem );
                },
                updateScrollColumnsInView: function( scrollLeft, scrollContainerWidth ) {
                    tableCtrl.updateScrollColumnsInView( scrollLeft, scrollContainerWidth );
                },
                onStartScroll: function() {
                    if( !util.isBulkEditing( table ) || !editCellElement ) {
                        return;
                    }

                    // Close drop down if it is open on the edit cell
                    var cellListElement = editCellElement.getElementsByClassName( 'aw-jswidgets-popUpVisible' )[ 0 ];
                    if( cellListElement ) {
                        editCellElement.click();
                    }
                },
                syncHeader: function( isPin, scrollLeft ) {
                    let traversalTable = new Trv( table );
                    util.syncHeader( traversalTable, isPin, scrollLeft );
                },
                renderRows: function( startIndex, endIndex ) {
                    var subVMObjects = getObjects().slice( startIndex, endIndex + 1 );
                    // Return if there is nothing to render
                    if( subVMObjects.length === 0 ) {
                        return;
                    }
                    if( gridOptions.useTree === true ) {
                        let messages = gridOptions.textBundle ? gridOptions.textBundle : _splmTableMessages;
                        _.forEach( subVMObjects, function( vmo ) {
                            if( vmo.isLeaf ) {
                                vmo._twistieTitle = '';
                            } else {
                                vmo._twistieTitle = vmo.isExpanded ? messages.TwistieTooltipExpanded : messages.TwistieTooltipCollapsed;
                            }

                            if( !util.isExpandAllowed( table ) ) {
                                vmo._twistieTitle = '';
                            }
                        } );
                    }
                    var insertBefore = false;
                    var scrollContents = _trv.getScrollContentElementFromTable();
                    var pinContents = _trv.getPinContentElementFromTable();
                    var firstPinElement = pinContents.childElementCount > 0 ? pinContents.childNodes[ 0 ] : 0;
                    var firstScrollElement = scrollContents.childElementCount > 0 ? scrollContents.childNodes[ 0 ] : 0;
                    if( firstScrollElement && firstScrollElement.getAttribute( 'data-indexNumber' ) ) {
                        var firstRowIdx = parseInt( firstScrollElement.getAttribute( 'data-indexNumber' ) );
                        insertBefore = firstRowIdx > startIndex;
                    }
                    var pinContentElement = tableCtrl.constructContentElement( subVMObjects, startIndex, _rowHeight, true );
                    var scrollContentElement = tableCtrl.constructContentElement( subVMObjects, startIndex, _rowHeight, false );
                    tableCtrl.setAriaLabelledAndDescribedBy( directiveElement, _trv.getTableContainerElementFromTable() );
                    tableCtrl.setAriaRowCount( _trv.getTableContainerElementFromTable() );
                    if( table._tableInstance.dynamicRowHeightStatus ) {
                        tableCtrl.syncContentRowHeights( pinContentElement, scrollContentElement );
                    }

                    SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
                        pinContentElement.childNodes, scrollContentElement.childNodes, table );

                    if( insertBefore ) {
                        _trv.getPinContentElementFromTable().insertBefore( pinContentElement, firstPinElement );
                        _trv.getScrollContentElementFromTable().insertBefore( scrollContentElement, firstScrollElement );
                    } else {
                        _trv.getPinContentElementFromTable().appendChild( pinContentElement );
                        _trv.getScrollContentElementFromTable().appendChild( scrollContentElement );
                    }

                    if( table._tableInstance.focusTreeNodeExpandAfterRender ) {
                        let node = table._tableInstance.focusTreeNodeExpandAfterRender;
                        let rowContents = _trv.queryAllRowCellElementsFromTable();
                        let rowElem = _.filter( rowContents, { vmo: node } )[ 0 ];
                        if( rowElem ) {
                            let elementToFocus = rowElem.getElementsByClassName( Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD )[ 0 ];
                            elementToFocus && elementToFocus.focus();
                        }
                    }
                },
                removeRows: function( upperCount, lowerCounter ) {
                    cellRenderer.resetHoverCommandElement();
                    tableCtrl.removeContentElement( upperCount, lowerCounter );
                    tableCtrl.setAriaRowCount( _trv.getTableContainerElementFromTable() );
                },
                afterGridRenderCallback: function( firstRenderedItem, lastRenderedItem ) {
                    let containerElement = _trv.getTableContainerElementFromTable();
                    if( containerElement && containerElement.hasAttribute( 'aria-activedescendant' ) ) {
                        var activedescendantId = containerElement.getAttribute( 'aria-activedescendant' );
                        if( !document.getElementById( activedescendantId ) ) {
                            containerElement.removeAttribute( 'aria-activedescendant' );
                        }
                    }
                    var isEditing = util.isBulkEditing( table );
                    let loadingProps = false;

                    if( isEditing ) {
                        updateEditStatusForTableCanvas( isEditing );
                    }

                    if( gridOptions.useTree === true ) {
                        if( _nodeExpansionInProgress === true ) {
                            return;
                        }

                        var nonPlaceholderFound = false;
                        for( var i = lastRenderedItem.index; i >= firstRenderedItem.index; i-- ) {
                            var vmo = dataProvider.viewModelCollection.loadedVMObjects[ i ];

                            if( dataProvider.focusAction ) {
                                if( vmo._focusRequested ) {
                                    return;
                                }

                                if( vmo.isPlaceholder ) { // ...use .isPlaceholder or .isFocusParent instead
                                    if( nonPlaceholderFound ) {
                                        delete vmo.isPlaceholder;

                                        vmo._focusRequested = true;

                                        tableInstanceCallbacks.doFocusPlaceHolder( vmo );
                                        return;
                                    }
                                } else {
                                    nonPlaceholderFound = true;
                                }
                            }
                        }

                        // Find and expand the first of any nodes that need to be expanded
                        for( var j = firstRenderedItem.index; j <= lastRenderedItem.index; j++ ) {
                            var vmObject = dataProvider.viewModelCollection.loadedVMObjects[ j ];
                            var expandNode = false;

                            if( vmObject.isLeaf !== true && vmObject._expandRequested !== true && vmObject.isExpanded !== true ) {
                                // Mark for expansion if the node was already expanded
                                if( util.performStateServiceAction( 'isNodeExpanded', declViewModel, gridid, vmObject ) ) {
                                    expandNode = true;
                                }
                            }

                            // Expand the node
                            if( expandNode === true ) {
                                vmObject.isExpanded = true;
                                if( tableInstanceCallbacks.toggleTreeNode ) {
                                    tableInstanceCallbacks.toggleTreeNode( vmObject );
                                } else {
                                    eventBus.publish( table.id + '.plTable.toggleTreeNode', vmObject );
                                }

                                return;
                            }
                        }

                        // If any VMOs need props to be loaded, we will call for the props to be loaded and not
                        // render the rows. The row rendering will then occur once they props have been loaded.
                        var emptyVMOs = findVMOsWithMissingProps( firstRenderedItem.index, lastRenderedItem.index );
                        if( emptyVMOs.length > 0 ) {
                            loadProps( emptyVMOs );
                            loadingProps = true;
                        }
                    }

                    if( util.isPaginationAllowed( table ) ) {
                        // _loadMorePageDebounce( firstRenderedItem, lastRenderedItem );
                        if( tableInstanceCallbacks ) {
                            _loadMorePageDebounce( firstRenderedItem, lastRenderedItem, tableInstanceCallbacks );
                            tableInstanceCallbacks.loadMorePages( {
                                firstRenderedItem: firstRenderedItem,
                                lastRenderedItem: lastRenderedItem
                            } );
                        }
                    }

                    // Set scrollToRow to false after row is scrolled to and all
                    // visible nodes around the scrolled to row are expanded
                    if( dataProvider.scrollToRow === true && tableScroll.isInitialRowIndexInView() === true ) {
                        dataProvider.scrollToRow = false;
                    }
                }
            } );
            tableScroll.renderInitialRows();
            var setContainerHeightEvent = eventBus.subscribe(
                gridid + '.plTable.containerHeightUpdated',
                function( heightVal ) {
                    updateContainerHeight( heightVal );
                } );
            instanceEventSubcr.push( setContainerHeightEvent );
        } else {
            // reset the row height cache
            tableScroll.resetRowHeightCache();
            // Set the loaded view model objects
            tableScroll.setLoadedVMObjects( getObjects() );

            // Render initial rows if at top of table
            if( _trv.getScrollCanvasElementFromTable().scrollTop === 0 ) {
                tableScroll.renderInitialRows();
            } else {
                tableScroll.handleScroll();
            }
        }
    };

    let clientRefresh = function() {
        if( table && table._tableInstance ) {
            table._tableInstance.showCheckBox = _showCheckBox;
        }
        util.cleanupComponents( table );
        refresh();
    };

    let updateContainerHeight = function( heightVal ) {
        tableScroll.setContainerHeight( heightVal );
        tableScroll.initializeProperties();
        tableScroll.handleScrollDown();
    };

    let updateDynamicRowHeight = function( dynamicRowHeightStatus ) {
        table._tableInstance.dynamicRowHeightStatus = dynamicRowHeightStatus;
        tableScroll.setDynamicRowHeight( table._tableInstance.dynamicRowHeightStatus );

        clientRefresh();
        if( !table._tableInstance.dynamicRowHeightStatus ) {
            resetDynamicRowHeights();
        }
    };

    let updatePinColumn = ( columnDef, isFreezeAction, defaultColumnPinIndex ) => {
        const pinColumnIndex = isFreezeAction ? columnDef.index : defaultColumnPinIndex;
        tableCtrl.pinToColumn( pinColumnIndex );
        if( !isFreezeAction ) {
            tableCtrl.resetFreezeScroll( columnDef.field );
        }
        tableScroll.handlePinViewportScrollbarPadding();
    };

    let hideColumn = ( columnFieldName ) => {
        let columnDef;
        var columns = dataProvider.cols;

        _.forEach( columns, function( currentColumn ) {
            if ( currentColumn.field === columnFieldName ) {
                columnDef = currentColumn;
                return false;
            }
        } );

        if ( columnDef ) {
            var columnIndex = columnDef.index;

            let isOnlyVisibleColumn = true;
            _.forEach( columns, function( currentColumn ) {
                if( currentColumn.name !== columnDef.name && currentColumn.visible === true && currentColumn.name !== 'icon' ) {
                    isOnlyVisibleColumn = false;
                    return false;
                }
            } );

            if( !isOnlyVisibleColumn ) {
                if( columnProvider.isArrangeSupported() && columnProvider.hideColumn ) {
                    // account for hidden columns
                    if( dataProvider.cols[ columnIndex ].propertyName !== columnDef.propertyName ) {
                        for( var i = 0; i < columns.length; i++ ) {
                            if( columns[ i ].propertyName === columnDef.propertyName ) {
                                columnIndex = i;
                                break;
                            }
                        }
                    }
                    columnProvider.hideColumn( columnIndex );
                }
                tableCtrl.updateColumnVisibility( columnDef.field );

                if( columnDef.filter && columnDef.filter.isFilterApplied ) {
                    const eventData = {
                        gridId: gridid,
                        column: columnDef
                    };
                    eventBus.publish( 'pltable.columnFilterApplied', eventData );
                }
            } else {
                localeService.getLocalizedText( 'UIMessages', 'hideColumnOnlyVisibleError' ).then( function( message ) {
                    messagingService.showError( message );
                } );
            }
        }
    };

    let resetDynamicRowHeights = function() {
        if( dataProvider.viewModelCollection ) {
            _.forEach( dataProvider.viewModelCollection.loadedVMObjects, function( vmo ) {
                delete vmo.rowHeight;
            } );
        }
    };

    let resetInfiniteScroll = function() {
        if( tableScroll && tableScroll.isInitialized() ) {
            tableScroll.resetInfiniteScroll();
        }
    };

    let maintainScrollPosition = function() {
        tableScroll.setScrollPositionToBeMaintained();
    };

    let unsetScrollToRowIndex = function() {
        if( tableScroll && tableScroll.isInitialized() ) {
            tableScroll.resetInitialRowIndex();
        }
    };

    let relatedModified = function() {
        if ( listenToRelatedModifiedEvent ) {
            listenToRelatedModifiedEvent = false;
            var selectionModel = dataProvider.selectionModel;

            if( selectionModel ) {
                selectionHelper.handleSelectionEvent( [ targetVMOScoped ], selectionModel, null, dataProvider );
                SPLMTableSelectionHelper.updateContentRowSelection( dataProvider.selectionModel, dataProvider.cols,
                    _trv.getPinContentRowElementsFromTable(), _trv.getScrollContentRowElementsFromTable(), table );
            }
        }
    };

    let columnsResized = function( eventData ) {
        // Prevent columnSizeChanged for transpose mode since the columns in transpose represent VMOs
        // and not the columns in the columnProvider
        if( gridOptions.transpose !== true ) {
            columnProvider.columnSizeChanged( eventData.name, eventData.delta );
        }
        if( table._tableInstance.dynamicRowHeightStatus ) {
            resetDynamicRowHeights();
            clientRefresh();
        }
    };
    let columnsRearranged = function( eventData )  {
        if( gridOptions.transpose === true ) {
            // Update the dom columns so they reflect correct data
            // and return since the columns represent VMOs and not the columns in
            // the columnProvider
            resetColumns();
            return;
        }
        // Get column position in relation to all columns, not just visible columns
        var originalPosition = eventData.originalPosition;
        var newPosition = null;

        // Get new position index
        _.forEach( dataProvider.cols, function( column ) {
            if( eventData.name === column.name ) {
                newPosition = column.index;
            }
        } );

        // Adjust for hidden columns
        _.forEach( dataProvider.cols, function( column, index ) {
            if( column.hiddenFlag === true && index <= newPosition ) {
                newPosition += 1;
            }

            if( column.hiddenFlag === true && index <= originalPosition ) {
                originalPosition += 1;
            }
        } );

        // awColumnService adjusts the column positions when the icon column is not present.
        // By incrementing the positions by 1, we are able to ensure awColumnService still uses
        // the correct column positions. Once  UI-Grid is removed, we can remove this hack and update awColumnService
        // to not adjust positions when icon column is not present.
        if( dataProvider.cols && dataProvider.cols[ 0 ].name !== 'icon' ) {
            originalPosition += 1;
            newPosition += 1;
        }

        if( originalPosition !== null && newPosition !== null ) {
            columnProvider.columnOrderChanged( eventData.name, originalPosition, newPosition );
        }
    };

    return {
        getDynamicRowHeightStatus: function() {
            return table._tableInstance.dynamicRowHeightStatus;
        },
        resetDynamicRowHeights: resetDynamicRowHeights,
        updateDynamicRowHeight: updateDynamicRowHeight,
        maintainScrollPosition:maintainScrollPosition,
        unsetScrollToRowIndex:unsetScrollToRowIndex,
        relatedModified: relatedModified,
        columnsResized: columnsResized,
        columnsRearranged:columnsRearranged,
        resetInfiniteScroll: resetInfiniteScroll,

        getTableElement: function() {
            return table;
        },
        updateContentRowSelection: updateContentRowSelection,
        updateContainerHeight: updateContainerHeight,
        updateSortDirection: updateSortDirection,
        updatePinColumn: updatePinColumn,
        hideColumn: hideColumn,
        /**
         * Reset columns for PL Table
         * this method out of exports.initializeTable, cannot do it now since it depends on dataProvider
         * any other members whose scope is inside initializeTable.
         */
        resetColumns: function() {
            resetColumns();
        },
        updateEditState: updateEditState,
        removeStaleFilters: function( columns ) {
            awColumnFilterService.removeStaleFilters( columnProvider, columns || _tableColumns );
        },
        setNodeExpansionInProgress: function( isInProgress ) {
            _nodeExpansionInProgress = isInProgress;
        },
        updateFilterIcons: function( columnName ) {
            if( columnName ) {
                tableCtrl.updateFilterIcon( columnName );
            } else {
                tableCtrl.updateAllFilterIcons();
            }
        },
        setFilterDisability: function( isDisabled ) {
            menuService.setFilterDisability( isDisabled );
        },
        loadMissingProps: function() {
            loadMissingProps();
        },
        updateTreeCellIcon: function( vmo ) {
            const rowContents = _trv.queryAllRowCellElementsFromTable();
            _.forEach( rowContents, function( rowElem ) {
                if( rowElem.vmo ) {
                    const matchingId = _contentFilter.isIdOfObject( rowElem.vmo, uwUtilSvc.getEvaluatedId( vmo ) );
                    if( matchingId === true ) {
                        // Only update if there is expand/collapse button available
                        let treeNodeCommandElement = rowElem.querySelector( `.${Const.CLASS_WIDGET_TREE_NODE_TOGGLE_CMD}` );
                        if( treeNodeCommandElement ) {
                            const iconCell = getIconCellSVG( vmo );
                            // this if check is for the vmo.isLeaf use case where there is no need to render an icon
                            let iconContainerElement = treeNodeCommandElement.querySelector( `.${Const.CLASS_ICON_BASE}` );
                            if( iconContainerElement && iconCell && iconCell.image && iconCell.image.length > 0 ) {
                                // add both for consistency, same as AwIcon
                                iconContainerElement = util.addAttributeToDOMElement( iconContainerElement, 'iconId', iconCell.id );
                                iconContainerElement = util.addAttributeToDOMElement( iconContainerElement, 'icon-id', iconCell.id );

                                treeNodeCommandElement.title = vmo._twistieTitle;
                                iconContainerElement.innerHTML = iconCell.image;
                            }
                        }
                    }
                }
            } );
        },
        /**
         * Refreshes the content in the table with the data currently in the dataProvider
         */
        refresh: refresh,
        updateInstanceState: function( newState ) {
            declViewModel = newState;
            table._tableInstance.declViewModel = newState;
        }
    };
};

/**
 *  Release the resources occupied by SPLM table
 *
 * @param {String} gridId - Grid ID to be destroyed
 * @param {Element} tableElement - The table element
 * @param {Object} columnDefs - The column defs
 */
export let destroyTable = function( gridId, tableElement, columnDefs ) {
    var table = tableElement.querySelector( `.${Const.CLASS_TABLE}` );
    var instance = table && table._tableInstance || {};
    var instanceEventSubcr = instance.subDefs;
    _.forEach( instanceEventSubcr, function( eventBusSub ) {
        if( eventBusSub !== null ) {
            eventBus.unsubscribe( eventBusSub );
        }
    } );

    for( var i = 0; i < columnDefs.length; i++ ) {
        var cellRenderers = columnDefs[ i ].cellRenderers;
        if( cellRenderers ) {
            for( var j = 0; j < cellRenderers.length; j++ ) {
                if( _.isFunction( cellRenderers[ j ].destroy ) ) {
                    cellRenderers[ j ].destroy();
                }
            }
        }
    }

    // Cleanup any leftover components
    util.cleanupComponents( tableElement );

    // Destroy the column/table menu
    var menu = document.getElementById( gridId + '_menuContainer' );
    if( menu !== null ) {
        menu.parentElement.removeChild( menu );
    }

    // Destroy table renderer
    if( instance.renderer ) {
        instance.renderer.destroyGrid();
    }

    // table editor eventBusSubs unsubscribe
    if( instance.editor ) {
        instance.editor.destroy();
    }

    // NOTE: This is not need for now since we force every
    // angularJS Compile must based on table scope. But leave
    // it here for now by commenting it out.
    // var cellRenderer = _cellRendererDefs[gridId];
    // cellRenderer.destroyHoverCommandElement();
    // delete _cellRendererDefs[gridId];

    instance.isDestroyed = true;

    eventBus.publish( 'tableDestroyed' );
};

_splmTableMessages.arrangeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.arrangeMenu' );
_splmTableMessages.removeAllFilters = localeService.getLoadedTextFromKey( 'treeTableMessages.removeAllFilters' );
_splmTableMessages.TwistieTooltipExpanded = localeService.getLoadedTextFromKey( 'treeTableMessages.TwistieTooltipExpanded' );
_splmTableMessages.TwistieTooltipCollapsed = localeService.getLoadedTextFromKey( 'treeTableMessages.TwistieTooltipCollapsed' );
_splmTableMessages.hideColumn = localeService.getLoadedTextFromKey( 'treeTableMessages.hideColumn' );
_splmTableMessages.sortAscending = localeService.getLoadedTextFromKey( 'treeTableMessages.sortAscending' );
_splmTableMessages.sortDescending = localeService.getLoadedTextFromKey( 'treeTableMessages.sortDescending' );
_splmTableMessages.removeSort = localeService.getLoadedTextFromKey( 'treeTableMessages.removeSort' );
_splmTableMessages.freezeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.freezeMenu' );
_splmTableMessages.unfreezeMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.unfreezeMenu' );
_splmTableMessages.visibilityControlsTitle = localeService.getLoadedTextFromKey( 'treeTableMessages.visibilityControlsTitle' );
_splmTableMessages.gridMenu = localeService.getLoadedTextFromKey( 'treeTableMessages.gridMenu' );

exports = {
    createTableObject,
    destroyTable
};
export default exports;
