/* eslint-disable max-lines */
// Copyright (c) 2020 Siemens

/**
 * Note: This module does not return an API object. The API is only available when the service defined this module is
 * injected by AngularJS.
 *
 * @module js/aw.searchFilter.service
 * @requires js/filterPanelUtils
 */
import AwStateService from 'js/awStateService';
import AwPromiseService from 'js/awPromiseService';
import localeService from 'js/localeService';
import appCtxService from 'js/appCtxService';
import filterPanelUtils from 'js/filterPanelUtils';
import cdm from 'soa/kernel/clientDataModel';
import _ from 'lodash';
import analyticsSvc from 'js/analyticsService';
import cmm from 'soa/kernel/clientMetaModel';
import eventBus from 'js/eventBus';

var localTextBundle = {};
var _local = 'local';
var OWNING_SITE = 'OwningSite.owning_site';

export let _dateFilterMarker = '_0Z0_';

export let _dateFilterLevels = [ 'year', 'year_month', 'week', 'year_month_day' ];

export let _filterSeparator = '~';

const _filterSeparatorOption1 = '~';

const _filterSeparatorOption2 = '##';

export let _filterValueSeparator = appCtxService.ctx.preferences && appCtxService.ctx.preferences.AW_FacetValue_Separator && appCtxService.ctx.preferences.AW_FacetValue_Separator[ 0 ] ?
    appCtxService.ctx.preferences.AW_FacetValue_Separator[ 0 ] : '^';

const removeSelectedFiltersFromCategory = ( category ) => {
    if( category && category.filterValues && category.filterValues.length > 0 ) {
        for( let filterIndex = 0; filterIndex < category.filterValues.length; filterIndex++ ) {
            category.filterValues[ filterIndex ].selected.dbValue = false;
            category.filterValues[ filterIndex ].selected.value = false;
        }
    }
    return category;
};

export let clearNumericRangeInfoFromCategory = ( category ) => {
    if( category ) {
        delete category.numericRangeString;
        delete category.numericrange;
    }
    return category;
};

export let clearDateRangeInfoFromCategory = ( category ) => {
    if( category ) {
        delete category.dateRangeString;
        category.daterange.endDate.value = -62135579040000;
        category.daterange.endDate.dbValue = -62135579040000;
        category.daterange.startDate.value = -62135579040000;
        category.daterange.startDate.dbValue = -62135579040000;
    }
    return category;
};

export let clearAllSelectedFiltersAndRanges = ( categories, activeFilters, positivePendingFilters ) => {
    if( categories && categories.length > 0 && activeFilters && activeFilters.length > 0 ) {
        let categoriesToRemoveSelectionsAndRangesFrom = new Set();
        for( let activeFilterIndex = 0; activeFilterIndex < activeFilters.length; activeFilterIndex++ ) {
            let categoryName = activeFilters[ activeFilterIndex ].name;
            let dateMarkerIndex = categoryName && categoryName.length > 0 ? categoryName.indexOf( _dateFilterMarker ) : -1;
            categoryName = categoryName && dateMarkerIndex > -1 ? categoryName.substring( 0, dateMarkerIndex ) : categoryName;
            if( categoryName && categoryName.length > 0 ) {
                categoriesToRemoveSelectionsAndRangesFrom.add( categoryName );
            }
        }
        if( positivePendingFilters && positivePendingFilters.length > 0 ) {
            for( let positivePendingFilterIndex = 0; positivePendingFilterIndex < positivePendingFilters.length; positivePendingFilterIndex++ ) {
                let categoryName = positivePendingFilters[ positivePendingFilterIndex ].name;
                let dateMarkerIndex = categoryName.indexOf( _dateFilterMarker );
                categoryName = categoryName && dateMarkerIndex > -1 ? categoryName.substring( 0, dateMarkerIndex ) : categoryName;
                if( categoryName && categoryName.length > 0 ) {
                    categoriesToRemoveSelectionsAndRangesFrom.add( categoryName );
                }
            }
        }
        for( let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++ ) {
            let categoryName = categories[ categoryIndex ].internalName;
            if( categoryName && categoriesToRemoveSelectionsAndRangesFrom.has( categoryName ) ) {
                let eachCategory = categories[ categoryIndex ];
                eachCategory = removeSelectedFiltersFromCategory( eachCategory );
                switch ( eachCategory.type ) {
                    case 'DateFilter':
                        eachCategory = clearDateRangeInfoFromCategory( eachCategory );
                        break;
                    case 'NumericFilter':
                        eachCategory = clearNumericRangeInfoFromCategory( eachCategory );
                        break;
                    default:
                        break;
                }
                categories[ categoryIndex ] = eachCategory;
            }
        }
    }
    return categories;
};

const getOnlyFilterValuesFromActiveFilterMap = ( activeFilterMapValue ) => {
    let values = [];
    if( activeFilterMapValue && activeFilterMapValue.length > 0 ) {
        for( let index = 0; index < activeFilterMapValue.length; index++ ) {
            switch ( activeFilterMapValue[ index ].searchFilterType ) {
                case 'DateFilter': {
                    if( activeFilterMapValue[ index ].startDateValue.includes( filterPanelUtils.BEGINNING_OF_TIME ) ) {
                        values.push( filterPanelUtils.INTERNAL_DATE_FILTER + '*' + '_TO_' + activeFilterMapValue[ index ].endDateValue );
                    } else if( activeFilterMapValue[ index ].startDateValue.includes( filterPanelUtils.ENDING_OF_TIME ) ) {
                        values.push( filterPanelUtils.INTERNAL_DATE_FILTER + activeFilterMapValue[ index ].startDateValue + '_TO_' + '*' );
                    } else {
                        values.push( filterPanelUtils.INTERNAL_DATE_FILTER + activeFilterMapValue[ index ].startDateValue + '_TO_' + activeFilterMapValue[ index ].endDateValue );
                    }
                    break;
                }
                case 'NumericFilter': {
                    if( activeFilterMapValue[ index ].stringValue && activeFilterMapValue[ index ].stringValue.length > 0 &&
                        activeFilterMapValue[ index ].startEndRange !== 'NumericRange' &&
                        activeFilterMapValue[ index ].startEndRange !== 'NumericRangeBlankStart' &&
                        activeFilterMapValue[ index ].startEndRange !== 'NumericRangeBlankEnd' ) {
                        values.push( filterPanelUtils.INTERNAL_NUMERIC_FILTER + activeFilterMapValue[ index ].stringValue );
                    } else {
                        if( activeFilterMapValue[ index ].startNumericValue > 0 && activeFilterMapValue[ index ].endNumericValue > 0 ) {
                            values.push( filterPanelUtils.INTERNAL_NUMERIC_RANGE + activeFilterMapValue[ index ].startNumericValue + '_TO_' + activeFilterMapValue[ index ].endNumericValue );
                        } else if( activeFilterMapValue[ index ].startNumericValue > 0 ) {
                            values.push( filterPanelUtils.INTERNAL_NUMERIC_RANGE + activeFilterMapValue[ index ].startNumericValue + '_TO_' );
                        } else {
                            values.push( filterPanelUtils.INTERNAL_NUMERIC_RANGE + '_TO_' + activeFilterMapValue[ index ].endNumericValue );
                        }
                    }
                    break;
                }
                case 'RadioFilter':
                case 'StringFilter':
                    values.push( activeFilterMapValue[ index ].stringValue );
                    break;
                default:
                    break;
            }
        }
    }
    return values.sort();
};

export let getPendingFiltersMap = ( selectedFiltersMap, activeFilterMap ) => {
    let positivePendingFilterMap = {};
    let negativePendingFilterMap = {};
    const orderedSelectedFiltersMap = Object.keys( selectedFiltersMap ).sort().reduce(
        ( obj, key ) => {
            obj[ key ] = selectedFiltersMap[ key ];
            return obj;
        }, {}
    );
    const orderedActiveFiltersMap = Object.keys( activeFilterMap ).sort().reduce(
        ( obj, key ) => {
            obj[ key ] = activeFilterMap[ key ];
            return obj;
        }, {}
    );
    for( const [ orderedSelectedFiltersMapKey, orderedSelectedFiltersMapValue ] of Object.entries( orderedSelectedFiltersMap ) ) {
        if( !orderedActiveFiltersMap[ orderedSelectedFiltersMapKey ] ) {
            positivePendingFilterMap[ orderedSelectedFiltersMapKey ] = orderedSelectedFiltersMap[ orderedSelectedFiltersMapKey ];
        } else if( orderedActiveFiltersMap[ orderedSelectedFiltersMapKey ] ) {
            let activeFiltersWithJustFilterValues = getOnlyFilterValuesFromActiveFilterMap( orderedActiveFiltersMap[ orderedSelectedFiltersMapKey ] );
            let positivePendingFiltersWithJustValues = _.difference( orderedSelectedFiltersMapValue, activeFiltersWithJustFilterValues );
            let negativePendingFiltersWithJustValues = _.difference( activeFiltersWithJustFilterValues, orderedSelectedFiltersMapValue );
            if( positivePendingFiltersWithJustValues && positivePendingFiltersWithJustValues.length > 0 ) {
                // these are positive filters, meaning they are filters which got selected.
                positivePendingFilterMap[ orderedSelectedFiltersMapKey ] = positivePendingFiltersWithJustValues;
            }
            if( negativePendingFiltersWithJustValues && negativePendingFiltersWithJustValues.length > 0 ) {
                // these are negative filters, meaning they are filters which got deselected.
                negativePendingFilterMap[ orderedSelectedFiltersMapKey ] = negativePendingFiltersWithJustValues;
            }
        }
    }
    for( const [ orderedActiveFiltersMapKey, orderedActiveFiltersMapValue ] of Object.entries( orderedActiveFiltersMap ) ) {
        if( !orderedSelectedFiltersMap[ orderedActiveFiltersMapKey ] ) {
            negativePendingFilterMap[ orderedActiveFiltersMapKey ] = orderedActiveFiltersMap[ orderedActiveFiltersMapKey ];
        }
    }
    return {
        positivePendingFilterMap: positivePendingFilterMap,
        negativePendingFilterMap: negativePendingFilterMap
    };
};

export let removeDependentDateFilters = ( searchFilterMap ) => {
    let searchFilterMapWithNonRedundantDateCategories = _.cloneDeep( searchFilterMap );
    let keys = Object.keys( searchFilterMapWithNonRedundantDateCategories );
    let mapWithKeyAsCategoryNameAndValueAsLevelsOfDate = {};
    if( keys && keys.length > 0 ) {
        for( let index = 0; index < keys.length; index++ ) {
            if( keys[ index ].includes( _dateFilterMarker ) && keys[ index ].substr( keys[ index ].length - 4, 4 ) === _dateFilterLevels[ 0 ] ) {
                let indexOfYear = keys[ index ].indexOf( _dateFilterMarker );
                let catName = keys[ index ].substr( 0, indexOfYear );
                if( mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] ) {
                    let existingLevels = mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ];
                    existingLevels.push( 1 );
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = existingLevels;
                } else {
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = [ 1 ];
                }
            } else if( keys[ index ].includes( _dateFilterMarker ) && keys[ index ].substr( keys[ index ].length - 10, 10 ) === _dateFilterLevels[ 1 ] ) {
                let indexOfYear = keys[ index ].indexOf( _dateFilterMarker );
                let catName = keys[ index ].substr( 0, indexOfYear );
                if( mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] ) {
                    let existingLevels = mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ];
                    existingLevels.push( 2 );
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = existingLevels;
                } else {
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = [ 2 ];
                }
            } else if( keys[ index ].includes( _dateFilterMarker ) && keys[ index ].substr( keys[ index ].length - 4, 4 ) === _dateFilterLevels[ 2 ] ) {
                let indexOfYear = keys[ index ].indexOf( _dateFilterMarker );
                let catName = keys[ index ].substr( 0, indexOfYear );
                if( mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] ) {
                    let existingLevels = mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ];
                    existingLevels.push( 3 );
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = existingLevels;
                } else {
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = [ 3 ];
                }
            } else if( keys[ index ].includes( _dateFilterMarker ) && keys[ index ].substr( keys[ index ].length - 14, 14 ) === _dateFilterLevels[ 3 ] ) {
                let indexOfYear = keys[ index ].indexOf( _dateFilterMarker );
                let catName = keys[ index ].substr( 0, indexOfYear );
                if( mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] ) {
                    let existingLevels = mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ];
                    existingLevels.push( 4 );
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = existingLevels;
                } else {
                    mapWithKeyAsCategoryNameAndValueAsLevelsOfDate[ catName ] = [ 4 ];
                }
            }
        }
        for( let [ key, value ] of Object.entries( mapWithKeyAsCategoryNameAndValueAsLevelsOfDate ) ) {
            let minLevel = 0;
            const dateLevelOne = key + _dateFilterMarker + _dateFilterLevels[ 0 ];
            const dateLevelTwo = key + _dateFilterMarker + _dateFilterLevels[ 1 ];
            const dateLevelThree = key + _dateFilterMarker + _dateFilterLevels[ 2 ];
            const dateLevelFour = key + _dateFilterMarker + _dateFilterLevels[ 3 ];
            let isMissingSomeDateLevel = false;
            if( value && value.length > 0 ) {
                value.sort();
                for( let index2 = 0; index2 < value.length; index2++ ) {
                    if( value[ index2 ] === index2 + 1 ) {
                        minLevel++;
                    } else {
                        isMissingSomeDateLevel = true;
                        break;
                    }
                }
            }
            if( isMissingSomeDateLevel ) {
                switch ( minLevel ) {
                    case 0: {
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelOne ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelOne ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelTwo ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelTwo ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ];
                        }
                        break;
                    }
                    case 1: {
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelTwo ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelTwo ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ];
                        }
                        break;
                    }
                    case 2: {
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelThree ];
                        }
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ];
                        }
                        break;
                    }
                    case 3: {
                        if( searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ] ) {
                            delete searchFilterMapWithNonRedundantDateCategories[ dateLevelFour ];
                        }
                        break;
                    }
                    default:
                        break;
                }
            }
        }
    }
    return searchFilterMapWithNonRedundantDateCategories;
};

export let removeDependentClassificationFilters = ( filterValue ) => {
    let value = filterValue.internalName;
    let stringValue = '';
    let values = value.split( '/' );
    if( values && values.length > 0 ) {
        let level = parseInt( values[ 0 ] );
        if( level === 0 ) {
            return [];
        } else if( level > 0 ) {
            let currentLevel = level;
            level -= 1;
            stringValue = level.toString();
            for( let index = 1; index < currentLevel + 1; index++ ) {
                stringValue += '/' + values[ index ];
            }
            return [ stringValue ];
        }
    }
    return [];
};

export let chooseFilterSeparator = function( filters ) {
    let conflictFound = false;
    _.forEach( filters, ( value, key ) => {
        if( _.indexOf( value[ 0 ], _filterSeparatorOption1 ) > -1 ) {
            conflictFound = true;
            return false;
        }
    } );
    if( conflictFound ) {
        _filterSeparator = _filterSeparatorOption2;
    } else {
        _filterSeparator = _filterSeparatorOption1;
    }
};

export const sortFilterMapKeys = ( filters ) => {
    let sortedFilterMap = {};
    let keys = Object.keys( filters );
    keys.sort();
    for( let index = 0; index < keys.length; index++ ) {
        let values = filters[ keys[ index ] ];
        values.sort();
        sortedFilterMap[ keys[ index ] ] = values;
    }
    return sortedFilterMap;
};

export const processFilterValues = ( filterVals ) => {
    for( let index = 0; index < filterVals.length; index++ ) {
        let eachValue = filterVals[ index ];
        eachValue = getDisplayNameForSpecialKeyWord( eachValue );
        filterVals[ index ] = eachValue;
    }
    return filterVals;
};

export let buildFilterString = function( filters ) {
    chooseFilterSeparator( filters );
    filters = sortFilterMapKeys( filters );
    return _.map( filters, function( value, key ) {
        value = processFilterValues( value );
        return key + '=' + value.join( _filterValueSeparator );
    } ).join( _filterSeparator );
};

export let isHierarchicalChildFilter = function( filterString ) {
    var isChildFilter = false;
    if( filterString ) {
        var nodes = filterString.split( filterPanelUtils.HIERARCHICAL_FACET_SEPARATOR );
        if( nodes && nodes.length > 2 && !isNaN( nodes[ 0 ] ) ) {
            var level = parseInt( nodes[ 0 ], 10 );
            if( level > 0 ) {
                isChildFilter = true;
            }
        }
    }
    return isChildFilter;
};

export let parseHierarchicalChildFilters = function( filterString, keepIdentifier ) {
    var filterValues = [];
    var nodes = filterString.split( filterPanelUtils.HIERARCHICAL_FACET_SEPARATOR );

    if( !isNaN( nodes[ 0 ] ) ) {
        var level = parseInt( nodes[ 0 ], 10 );
        for( var i = 0; i <= level; i++ ) {
            var filterValue = i.toString();
            for( var j = 1; j <= i + 1; j++ ) {
                filterValue += filterPanelUtils.HIERARCHICAL_FACET_SEPARATOR + nodes[ j ];
            }
            if( keepIdentifier ) {
                filterValues.push( filterPanelUtils.INTERNAL_OBJECT_FILTER + filterValue );
            } else {
                filterValues.push( filterValue );
            }
        }
    }
    return filterValues;
};

export let getFilters = function( groupByCategory, sort, checkHierarchy, keepHierarchyIdentifier, isShapeOrSavedSearch ) {
    var filterMap = {};
    if( AwStateService.instance.params.filter ) {
        // Build the filter map
        AwStateService.instance.params.filter.split( _filterSeparator ).map( function( filterVal ) {
            var separatorIndex = filterVal.search( '=' );
            var key = filterVal.slice( 0, separatorIndex );
            var valuePart = filterVal.slice( separatorIndex + 1 );
            var filterPair = [];
            filterPair[ 0 ] = key;
            filterPair[ 1 ] = valuePart;
            if( filterPair.length === 2 && filterPair[ 1 ] !== '' ) {
                var realFilter = filterPanelUtils.getRealFilterWithNoFilterType( filterPair[ 1 ] );
                if( checkHierarchy && isHierarchicalChildFilter( realFilter ) && checkIfObjectFilterType( filterPair[ 0 ] ) ) {
                    filterMap[ filterPair[ 0 ] ] = parseHierarchicalChildFilters( realFilter, keepHierarchyIdentifier );
                } else if( isShapeOrSavedSearch ) {
                    if( filterPair[ 0 ] !== 'ShapeSearchProvider' && filterPair[ 0 ] !== 'Geolus Criteria' && filterPair[ 0 ] !== 'SS1shapeBeginFilter' &&
                        filterPair[ 0 ] !== 'SS1shapeEndFilter' && filterPair[ 0 ] !== 'SS1partShapeFilter' && filterPair[ 0 ] !== 'UpdatedResults.updated_results' ) {
                        filterMap[ filterPair[ 0 ] ] = filterPair[ 1 ].split( _filterValueSeparator );
                    }
                } else {
                    filterMap[ filterPair[ 0 ] ] = filterPair[ 1 ].split( _filterValueSeparator );
                }
            }
        } );
    }
    if( groupByCategory ) {
        return groupByCategory( filterMap );
    }
    return sort ? getSortedFilterMap( filterMap ) : filterMap;
};

export let getFilterMapWithPrefilters = () => {
    var filterMap = {};
    if( AwStateService.instance.params.filter ) {
        AwStateService.instance.params.filter.split( _filterSeparator ).map( function( filterVal ) {
            var separatorIndex = filterVal.search( '=' );
            var key = filterVal.slice( 0, separatorIndex );
            var valuePart = filterVal.slice( separatorIndex + 1 );
            var filterPair = [];
            filterPair[ 0 ] = key;
            filterPair[ 1 ] = valuePart;
            if( filterPair.length === 2 && filterPair[ 1 ] !== '' ) {
                filterMap[ filterPair[ 0 ] ] = filterPair[ 1 ].split( _filterValueSeparator );
            }
        } );
    }
    return filterMap;
};

export let checkIfObjectFilterType = function( filterCategoryName ) {
    var isObjectFilterType = false;
    var responseFilterMap = appCtxService.getCtx( 'searchResponseInfo.searchFilterMap' );
    if( responseFilterMap && filterCategoryName && responseFilterMap[ filterCategoryName ] ) {
        var filters = [];
        filters = responseFilterMap[ filterCategoryName ];
        if( filters && filters.length > 0 ) {
            if( filters[ 0 ].searchFilterType === 'ObjectFilter' ) {
                isObjectFilterType = true;
            }
        }
    }
    return isObjectFilterType;
};

export let getSortedFilterMap = function( params ) {
    return _.reduce( params, function( acc, nxt, key ) {
        var trueKey = key.split( _dateFilterMarker )[ 0 ];
        if( trueKey !== key ) {
            _.forEach( nxt, function( nxtValue ) {
                var decoratedNxt = {};
                decoratedNxt.property = key;
                decoratedNxt.filter = nxtValue;
                if( acc[ trueKey ] ) {
                    acc[ trueKey ].push( decoratedNxt );
                } else {
                    acc[ trueKey ] = [];
                    acc[ trueKey ].push( decoratedNxt );
                }
            } );
        } else {
            if( acc[ key ] ) {
                acc[ key ] = acc[ key ].concat( nxt );
            } else {
                acc[ key ] = nxt;
            }
        }
        return acc;
    }, {} );
};

export let buildSearchFiltersInt = function( searchContext, filterMap ) {
    _.forEach( filterMap, function( value, key ) {
        // If it's a valid filter
        // get filter type
        var filterType = 'StringFilter';

        if( key === OWNING_SITE ) {
            filterType = 'RadioFilter';
            searchContext.activeFilterMap[ key ] = value.map( function( v1 ) {
                var filter = {};
                filter.searchFilterType = 'RadioFilter';
                filter.stringValue = v1;
                return filter;
            } );
        } else {
            // Map is used directly by data provider
            searchContext.activeFilterMap[ key ] = value.map( function( v1 ) {
                var filter = {};

                if( _.startsWith( v1, filterPanelUtils.INTERNAL_DATE_FILTER ) ) {
                    filter = filterPanelUtils.getDateRangeFilter( v1.substring( 12, v1.length ) );
                } else if( _.startsWith( v1, filterPanelUtils.INTERNAL_NUMERIC_RANGE ) ) {
                    filter = filterPanelUtils.getNumericRangeFilter( v1.substring( 14,
                        v1.length ) );
                } else if( _.startsWith( v1, filterPanelUtils.INTERNAL_NUMERIC_FILTER ) ) {
                    filter.searchFilterType = 'NumericFilter';
                    var numericValue = parseFloat( v1.substring( 15, v1.length ) );
                    if( !isNaN( numericValue ) ) {
                        filter.startNumericValue = numericValue;
                        filter.endNumericValue = numericValue;
                    }
                    filter.stringValue = v1.substring( 15, v1.length );
                } else if( _.startsWith( v1, filterPanelUtils.INTERNAL_OBJECT_FILTER ) ) {
                    // SOA handles object filters differently in aw4.0.
                    // So we need to pass "StringFilter" until server side is changed to be the same as aw3.4
                    // filter.searchFilterType = "ObjectFilter";
                    filter.searchFilterType = 'StringFilter';
                    filter.stringValue = v1.substring( 14, v1.length );
                } else if( v1 === '$TODAY' || v1 === '$THIS_WEEK' || v1 === '$THIS_MONTH' ) {
                    // For special Solr filters like TODAY, THIS_WEEK or THIS_MONTH, mark the filter as DateFilter but keep string values
                    filter.searchFilterType = 'DateFilter';
                    filter.stringValue = v1;
                } else {
                    filter.searchFilterType = 'StringFilter';
                    filter.stringValue = v1;
                }
                filterType = filter.searchFilterType;
                return filter;
            } );
        }

        // Array to maintain the order
        searchContext.activeFilters.push( {
            name: key,
            values: value,
            type: filterType
        } );
    } );
};

export let buildSearchFilters = function( context ) {
    // Initialize the search context if necessary
    let searchContext = {};

    // Filter map and filter array are both required
    // Input to performSearch needs filter map
    searchContext.activeFilterMap = context && context.search && context.search.activeFilterMap ? _
        .cloneDeep( context.search.activeFilterMap ) : {};

    // But order matters in some cases and so array is needed
    searchContext.activeFilters = [];

    // Build up filter map and array
    buildSearchFiltersInt( searchContext, getFilters() );

    return searchContext;
};

export let buildSearchFiltersFromSearchState = function( activeSelectedFiltersMap ) {
    let activeFiltersMap = {
        activeFilterMap: {},
        activeFilters: []
    };
    // Build up filter map and array
    buildSearchFiltersInt( activeFiltersMap, activeSelectedFiltersMap );
    return activeFiltersMap;
};

export let getFilterStringFromActiveFilterMap = function( searchFilterMap, searchFilterCategories ) {
    var searchParams = getFilters( false );

    var displayString = '';
    _.map( searchParams, function( value, property ) {
        var trueProperty = property.split( _dateFilterMarker )[ 0 ];
        // If it's a valid filter
        var index = _.findIndex( searchFilterCategories, function( o ) {
            return o.internalName === trueProperty;
        } );
        // Get the filter name first
        var filterName = '';
        if( index > -1 ) {
            filterName = searchFilterCategories[ index ].displayName;
        } else if( !searchFilterCategories || searchFilterCategories && searchFilterCategories.length < 1 ) {
            filterName = getCategoryDisplayName( property );
        } else {
            return '';
        }

        // Get display name for all the filter values
        var filterValues = '';
        _.forEach( searchParams[ property ], function( filter ) {
            var filterValue = getBreadCrumbDisplayValue( searchFilterMap[ property ], filterPanelUtils.getRealFilterWithNoFilterType( filter ), searchFilterMap[
                property ] );
            filterValues += filterValues === '' ? filterValue : ', ' + filterValue;
        } );
        if( filterValues !== '' ) {
            var individualFilterString = filterName + '=' + filterValues;
            displayString += displayString === '' ? individualFilterString : ', ' +
                individualFilterString;
        }
    } );
    return displayString;
};

export let convertFilterMapToSavedSearchFilterMap = function( searchContext = {} ) {
    //var searchContext = appCtxService.getCtx( 'search' );
    var activeFilterMap = searchContext.activeFilterMap;
    var activeFilters = searchContext.activeFilters;
    var searchStringFilterMap = {};
    if( activeFilterMap ) {
        _
            .forEach( activeFilterMap,
                function( value, key ) {
                    var filters = [];
                    for( var indx = 0; indx < value.length; indx++ ) {
                        var filter = {};
                        // Saved search object only store SearchStringFilter types
                        filter.searchFilterType = 'SearchStringFilter';
                        filter.startNumericValue = 0;
                        filter.endNumericValue = 0;
                        filter.startDateValue = 0;
                        filter.endDateValue = 0;
                        // Handle date range filters and numeric range filters
                        if( value[ indx ].searchFilterType === 'DateFilter' &&
                            !value[ indx ].stringValue ) {
                            var dateParts1 = value[ indx ].startDateValue.match( /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/ );
                            var dateParts2 = value[ indx ].endDateValue.match( /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/ );
                            if( dateParts1 && dateParts2 ) {
                                var fromDate = new Date( dateParts1 );
                                var toDate = new Date( dateParts2 );
                                filter.stringValue = filterPanelUtils.getDateRangeString( fromDate, new Date(
                                    toDate ) );
                            } else {
                                continue;
                            }
                        } else if( value[ indx ].searchFilterType === 'NumericFilter' ) {
                            if( !value[ indx ].stringValue ) {
                                filter.stringValue = filterPanelUtils.getNumericRangeString(
                                    value[ indx ].startNumericValue, value[ indx ].endNumericValue );
                            } else {
                                filter.stringValue = filterPanelUtils.INTERNAL_NUMERIC_FILTER.concat( value[ indx ].stringValue );
                            }
                        } else {
                            filter = processConvertFilterMapToSavedSearchFilterMap( value, indx, key, filter, activeFilters );
                        }
                        filters.push( filter );
                    }
                    searchStringFilterMap[ key ] = filters;
                } );
    }
    return searchStringFilterMap;
};

/**
 * processConvertFilterMapToSavedSearchFilterMap
 * @param {Object} value Value
 * @param {Integer} indx  The index
 * @param {Integer} key  Key
 * @param {Object} filter  The filter object
 * @param {ObjectArray} activeFilters The array of active filters
 * @returns {Object} filter
 */
export let processConvertFilterMapToSavedSearchFilterMap = function( value, indx, key, filter, activeFilters ) {
    // Currently NumericFilters are also being treated as String Filters
    // verify this filter is numeric filter by checking against activeFilters data structure
    var numericFilterIndex = _.findIndex( activeFilters, function( object ) {
        if( object.name === key && object.values ) {
            return _.startsWith( object.values[ 0 ], filterPanelUtils.INTERNAL_NUMERIC_FILTER ) ||
                _.startsWith( object.values[ 0 ], filterPanelUtils.INTERNAL_NUMERIC_RANGE );
        }
    } );
    if( numericFilterIndex > -1 ) {
        filter.stringValue = filterPanelUtils.INTERNAL_NUMERIC_FILTER.concat( value[ indx ].stringValue );
    } else {
        filter.stringValue = value[ indx ].stringValue;
    }

    return filter;
};

export let getFilterDisplayValue = function( values, value ) {
    var dispValue = '';
    var filterValue = '';
    var dArray = [];
    if( _.startsWith( value, filterPanelUtils.INTERNAL_DATE_FILTER ) ) {
        filterValue = value.replace( filterPanelUtils.INTERNAL_DATE_FILTER, '' );
        dArray = filterValue.split( '_TO_' );
        if( dArray.length > 1 ) {
            var startDate = new Date( dArray[ 0 ] );
            var endDate = new Date( dArray[ 1 ] );
            var dateRange = filterPanelUtils.getDateRangeDisplayString( startDate, endDate );
            dispValue = dateRange.displayName;
        }
    } else if( _.startsWith( value, filterPanelUtils.INTERNAL_NUMERIC_RANGE ) ) {
        filterValue = value.replace( filterPanelUtils.INTERNAL_NUMERIC_RANGE, '' );
        dArray = filterValue.split( '_TO_' );
        if( dArray.length > 1 ) {
            var numericRange = filterPanelUtils.getNumericRangeDisplayString( dArray[ 0 ],
                dArray[ 1 ] );
            dispValue = numericRange.displayName;
        }
    } else {
        var ind = _.findIndex( values, function( o ) {
            return o.stringValue === value;
        } );
        if( ind > -1 ) {
            if( _.endsWith( values[ ind ].stringValue, '$NONE' ) ) {
                dispValue = localTextBundle.noFilterValue;
            } else {
                dispValue = values[ ind ].stringDisplayValue;
            }
        }
    }
    return dispValue;
};

export let getUserValue = function() {
    let userName = appCtxService.getCtx( 'user' ).props.user_name.dbValue;
    let userId = appCtxService.getCtx( 'user' ).props.userid.dbValue;
    return userName + ' ( ' + userId + ' )';
};

export const getDisplayNameForSpecialKeyWord = ( value ) => {
    if( value === '$ME' ) {
        return getUserValue();
    }
    if( value === '$TODAY' ) {
        return getLocalTextBundle().searchFilterVariableToday;
    }
    if( value === '$THIS_WEEK' ) {
        return getLocalTextBundle().searchFilterVariableThisWeek;
    }
    if( value === '$THIS_MONTH' ) {
        return getLocalTextBundle().searchFilterVariableThisMonth;
    }
    if( value === '$MY_GROUP' ) {
        return getLocalTextBundle().searchFilterVariableMyGroup;
    }
    return value;
};

export let getSpecialDisplayName = function( value ) {
    if( value === '$ME' ) {
        return getUserValue();
    }
    if( value === '$TODAY' ) {
        return getLocalTextBundle().searchFilterVariableToday;
    }
    if( value === '$THIS_WEEK' ) {
        return getLocalTextBundle().searchFilterVariableThisWeek;
    }
    if( value === '$THIS_MONTH' ) {
        return getLocalTextBundle().searchFilterVariableThisMonth;
    }
    if( value === '$MY_GROUP' ) {
        return getLocalTextBundle().searchFilterVariableMyGroup;
    }
    return '';
};

export let getLocalTextBundle = function() {
    return localTextBundle;
};

export let getBreadCrumbDisplayValue = function( values, value, searchFilters ) {
    var dispValue = getSpecialDisplayName( value );
    if( dispValue === '' ) {
        if( _.startsWith( value, filterPanelUtils.INTERNAL_DATE_FILTER ) ) {
            var startDate = filterPanelUtils.getDate( processDateStringOffset( values[ 0 ].startDateValue ) );
            var endDate = filterPanelUtils.getDate( processDateStringOffset( values[ 0 ].endDateValue ) );
            var dateRange = filterPanelUtils.getDateRangeDisplayString( startDate, endDate );
            dispValue = dateRange.displayName;
        } else if( _.startsWith( value, filterPanelUtils.INTERNAL_NUMERIC_RANGE ) ) {
            var startRange = values[ 0 ].startNumericValue;
            var endRange = values[ 0 ].endNumericValue;
            var startEndRange = values[ 0 ].startEndRange;
            var numericRange = filterPanelUtils.getNumericRangeDisplayString( startRange, endRange,
                startEndRange );
            dispValue = numericRange.displayName;
        } else {
            var ind = _.findIndex( values, function( o ) {
                return o.stringValue === value;
            } );
            if( ind > -1 ) {
                // some "$NONE" stringValue actually has non-empty stringDisplayValue, so we don't want to display the default "Unassigned" in that case.
                if( values[ ind ].stringDisplayValue ) {
                    dispValue = values[ ind ].stringDisplayValue;
                } else if( _.endsWith( value, '$NONE' ) ) {
                    dispValue = localTextBundle.noFilterValue;
                } else if( searchFilters ) {
                    var theFilter = _.find( searchFilters, function( o ) {
                        return o.stringValue === value;
                    } );
                    if( theFilter && theFilter.stringDisplayValue ) {
                        dispValue = theFilter.stringDisplayValue;
                    } else {
                        dispValue = value;
                    }
                } else {
                    dispValue = value;
                }
            }
        }
    }

    return dispValue;
};

export let processDateStringOffset = function( dateString ) {
    if( dateString.length > 19 ) {
        var offsetString = dateString.substring( 19 );
        if( offsetString.length > 4 && offsetString.indexOf( ':' ) === -1 ) {
            var hour = offsetString.substring( 0, offsetString.length - 2 );
            var min = offsetString.substring( offsetString.length - 2 );
            var newOffset = hour.concat( ':', min );
            dateString = dateString.replace( offsetString, newOffset );
        }
    }
    return dateString;
};

export let groupByCategory = function( params ) {
    return _.reduce( params, function( acc, nxt, key ) {
        var trueKey = key.split( _dateFilterMarker )[ 0 ];
        if( trueKey !== key ) {
            _.forEach( nxt, function( aFilter ) {
                aFilter.startEndRange = key.substring( trueKey.length, key.length );
            } );
        }
        if( acc[ trueKey ] ) {
            acc[ trueKey ] = acc[ trueKey ].concat( nxt );
        } else {
            acc[ trueKey ] = nxt;
        }
        return acc;
    }, {} );
};

export let setFilters = function( params ) {
    AwStateService.instance.go( '.', {
        filter: buildFilterString( params )
    } );
};

export let addOrRemoveObjectFilter = function( newParams, category, filter, addRemoveOnly ) {};

let removePrefilter = function( value ) {
    if( value && Array.isArray( value ) ) {
        // remove prefix from prefilter
        _.forEach( value, function( removePrefix, index, arr ) {
            if( removePrefix && !removePrefix.hasOwnProperty( 'property' ) && removePrefix.trim().length !== 0 ) {
                arr[ index ] = arr[ index ].replace( 'AW_PreFilter_', '' );
            }
        } );
    }
};

export let addOrRemoveFilter = function( category, filter, addRemoveOnly, filterType ) {};

export let getFilterExtension = function( filter ) {
    if( filter.startEndRange === '+1YEAR' ) {
        return _dateFilterMarker + _dateFilterLevels[ 0 ];
    }
    if( filter.startEndRange === '+1MONTH' ) {
        return _dateFilterMarker + _dateFilterLevels[ 1 ];
    }
    if( filter.startEndRange === '+7DAYS' ) {
        return _dateFilterMarker + _dateFilterLevels[ 2 ];
    }
    if( filter.startEndRange === '+1DAY' ) {
        return _dateFilterMarker + _dateFilterLevels[ 3 ];
    }
    return filter.startEndRange;
};

export let doSearch = function( targetState, searchCriteria, filters ) {
    AwStateService.instance.go( targetState ? targetState : '.', {
        filter: buildFilterString( filters ),
        searchCriteria: searchCriteria
    } );
};

export let doSearchKeepFilter = function( targetState, searchCriteria, shapeSearchProviderActive, savedSearchUid ) {
    // If we are in Shape Search or Saved Search context we do not want to keep the filters related to
    // either when we perform this search.
    if( shapeSearchProviderActive === 'true' || savedSearchUid ) {
        AwStateService.instance.go( targetState ? targetState : '.', {
            filter: buildFilterString( getFilters( false, undefined, undefined, undefined, true ) ),
            searchCriteria: searchCriteria
        } );
    } else {
        AwStateService.instance.go( targetState ? targetState : '.', {
            filter: buildFilterString( getFilters( false ) ),
            searchCriteria: searchCriteria
        } );
    }
};

export let loadBreadcrumbClearTitle = function() {
    return localeService.getLocalizedText( 'UIMessages', 'clearBreadCrumb' );
};

export let doShapeSearch = function( targetState, searchCriteria, filter ) {
    var ctx = appCtxService.getCtx( 'searchSearch' );
    if( ctx ) {
        delete ctx.savedSearchUid;
        delete ctx.searchStringPrimary;
        if( ctx.searchStringSecondary ) {
            delete ctx.searchStringSecondary;
            eventBus.publish( 'search.clearSearchBox' );
        }
        appCtxService.updateCtx( 'searchSearch', ctx );
    }
    var shapeSearchCtx = appCtxService.getCtx( 'shapeSearch' );
    if( !shapeSearchCtx ) {
        shapeSearchCtx = {};
        appCtxService.registerCtx( 'shapeSearch', shapeSearchCtx );
    }
    var selectedCtx = appCtxService.getCtx( 'selected' );
    if( selectedCtx && selectedCtx.props && selectedCtx.props.awb0ArchetypeId && selectedCtx.props.awb0ArchetypeName ) {
        shapeSearchCtx.seedObjectItemId = selectedCtx.props.awb0ArchetypeId.uiValues[ 0 ];
        shapeSearchCtx.seedObjectItemName = selectedCtx.props.awb0ArchetypeName.uiValues[ 0 ];
    } else if( selectedCtx && selectedCtx.props ) {
        shapeSearchCtx.seedObjectItemId = selectedCtx.props.item_id.uiValues[ 0 ];
        shapeSearchCtx.seedObjectItemName = selectedCtx.props.object_name.uiValues[ 0 ];
    }

    AwStateService.instance.go( targetState ? targetState : '.', {
        filter: filter,
        searchCriteria: searchCriteria
    } );
    return shapeSearchCtx;
};

export let loadBreadcrumbTitle = function( label, searchCriteria, totalResultCount, selectionModel ) {
    // If no label is provided return the loading message
    if( !label || totalResultCount === undefined ) {
        return localeService.getLocalizedText( 'BaseMessages', 'LOADING_TEXT' );
    }
    return AwPromiseService.instance.all( {
        label: typeof label === 'string' ? AwPromiseService.instance.when( label ) : localeService.getLocalizedText( label.source, label.key ),
        selectionCountLabel: localeService.getLocalizedTextFromKey( 'XRTMessages.selectionCountLabel' ),
        noSearchResultsWithSearchBox: localeService.getLocalizedTextFromKey( 'UIMessages.noSearchResultsWithSearchBox' ),
        noSearchResults: localeService.getLocalizedTextFromKey( 'UIMessages.noSearchResults' ),
        resultsCountLabelWithSearchBox: localeService.getLocalizedTextFromKey( 'UIMessages.resultsCountLabelWithSearchBox' ),
        resultsCountLabel: localeService.getLocalizedTextFromKey( 'UIMessages.resultsCountLabel' )
    } ).then(
        function( localizedText ) {
            // If no results return the no results message
            if( totalResultCount === 0 ) {
                if( searchCriteria ) {
                    return localizedText.noSearchResults.format( '', searchCriteria );
                }
                return localizedText.noSearchResults.format( '', localizedText.label );
            }
            var resultsCountLabel;
            if( searchCriteria ) {
                resultsCountLabel = localizedText.resultsCountLabel.format(
                    totalResultCount, '', searchCriteria );
            } else {
                resultsCountLabel = localizedText.resultsCountLabel.format(
                    totalResultCount, '', localizedText.label );
            }
            // If not in multiselect mode return the result count message
            if( !selectionModel || !selectionModel.multiSelectEnabled ) {
                return resultsCountLabel;
            }

            // Otherwise return the selection count message
            return localizedText.selectionCountLabel.format( selectionModel
                .getCurrentSelectedCount(), resultsCountLabel );
        } );
};

export let isShapeSearchContext = function() {
    let isShapeSearch = appCtxService.ctx.search && appCtxService.ctx.search.reqFilters;
    isShapeSearch = isShapeSearch && appCtxService.ctx.search.reqFilters.ShapeSearchProvider && appCtxService.ctx.search.reqFilters.ShapeSearchProvider[ 0 ] === 'true';
    return isShapeSearch;
};

export let loadInContentBreadcrumbTitle = function( label, totalResultCount, selectionModel ) {
    // If no label is provided return the loading message
    var totalFound = appCtxService.getCtx( 'search.totalFound' );
    var searchString = appCtxService.getCtx( 'search.criteria.searchString' );
    var searchInfoCtx = appCtxService.getCtx( 'searchInfo' );
    var ctxSearchSearch = appCtxService.ctx.searchSearch;
    if( !label || totalFound === undefined ) {
        return localeService.getLocalizedText( 'BaseMessages', 'LOADING_TEXT' );
    }
    return AwPromiseService.instance.all( {
        label: typeof label === 'string' ? AwPromiseService.instance.when( label ) : localeService.getLocalizedText( label.source, label.key ),
        selectionCountLabel: localeService.getLocalizedTextFromKey( 'XRTMessages.selectionCountLabel' ),
        noSearchResultsWithInContentSearch: localeService.getLocalizedTextFromKey( 'UIMessages.noSearchResultsWithInContentSearch' ),
        thresholdExceeded: localeService.getLocalizedTextFromKey( 'UIMessages.thresholdExceeded' ),
        noSearchResultsWithoutInContentSearch: localeService.getLocalizedTextFromKey( 'UIMessages.noSearchResultsWithoutInContentSearch' ),
        noSearchResults: localeService.getLocalizedTextFromKey( 'UIMessages.noSearchResults' ),
        resultsCountLabel: localeService.getLocalizedTextFromKey( 'UIMessages.resultsCountLabel' ),
        shapesCountLabelPart1: localeService.getLocalizedTextFromKey( 'UIMessages.shapesCountLabelPart1' ),
        shapesCountLabelPart2: localeService.getLocalizedTextFromKey( 'UIMessages.shapesCountLabelPart2' ),
        oneShapeCountLabelPart1: localeService.getLocalizedTextFromKey( 'UIMessages.oneShapeCountLabelPart1' ),
        resultsCountLabelWithInContentSearch: localeService.getLocalizedTextFromKey( 'UIMessages.resultsCountLabelWithInContentSearch' ),
        resultsCountLabelWithoutInContentSearch: localeService.getLocalizedTextFromKey( 'UIMessages.resultsCountLabelWithoutInContentSearch' )

    } ).then(
        function( localizedText ) {
            // If no results return the no results message
            if( totalResultCount === 0 ) {
                if( searchString ) {
                    if( ctxSearchSearch && ctxSearchSearch.searchStringSecondary && searchString === ctxSearchSearch.searchStringPrimary + ' AND ' + ctxSearchSearch.searchStringSecondary ) {
                        return localizedText.noSearchResultsWithInContentSearch.format( ctxSearchSearch.searchStringPrimary, ctxSearchSearch.searchStringSecondary );
                    }
                    if( searchInfoCtx && searchInfoCtx.thresholdExceeded === 'true' ) {
                        searchInfoCtx.noResultsFound = localizedText.thresholdExceeded.format( searchString );
                        return '';
                    }
                    return localizedText.noSearchResultsWithoutInContentSearch.format( searchString );
                }
                return localizedText.noSearchResults.format( '', localizedText.label );
            }
            var resultsCountLabel;
            if( searchString ) {
                resultsCountLabel = processLoadInContentBreadcrumbTitle( ctxSearchSearch, searchString, localizedText, totalResultCount, resultsCountLabel );
            } else {
                resultsCountLabel = localizedText.resultsCountLabel.format(
                    totalResultCount, '', localizedText.label );
            }
            // If not in multiselect mode return the result count message
            if( !selectionModel || !selectionModel.multiSelectEnabled ) {
                return resultsCountLabel;
            }

            // Otherwise return the selection count message
            return localizedText.selectionCountLabel.format( selectionModel
                .getCurrentSelectedCount(), resultsCountLabel );
        } );
};
/**
 * Process Localized text search results.
 * @function processLoadInContentBreadcrumbTitleShape
 * @param {Object} ctxSearchSearch searchString context object
 * @param {Object} searchString searchString context object
 * @param {Object} localizedText The localized text
 * @param {Object} totalResultCount Total Result count
 * @param {Object} resultsCountLabel Results Count Label
 * @return {Object} resultsCountLabel
 */
export let processLoadInContentBreadcrumbTitleShape = function( ctxSearchSearch, searchString, localizedText, totalResultCount, resultsCountLabel ) {
    var shapeSearchCtx = appCtxService.getCtx( 'shapeSearch' );
    resultsCountLabel = {};
    resultsCountLabel.seedObjectLink = shapeSearchCtx.seedObjectItemId + '/' + shapeSearchCtx.seedObjectItemName;
    if( ctxSearchSearch.searchStringSecondary ) {
        if( totalResultCount > 1 ) {
            resultsCountLabel.part1 = localizedText.shapesCountLabelPart1.format( totalResultCount );
            resultsCountLabel.part2 = localizedText.shapesCountLabelPart2.format( ctxSearchSearch.searchStringSecondary );
        } else {
            resultsCountLabel.part1 = localizedText.oneShapeCountLabelPart1.format( totalResultCount );
            resultsCountLabel.part2 = localizedText.shapesCountLabelPart2.format( ctxSearchSearch.searchStringSecondary );
        }
    } else {
        if( totalResultCount > 1 ) {
            resultsCountLabel.part1 = localizedText.shapesCountLabelPart1.format( totalResultCount );
        } else {
            resultsCountLabel.part1 = localizedText.oneShapeCountLabelPart1.format( totalResultCount );
        }
    }
    return resultsCountLabel;
};

/**
 * Process Localized text search results.
 * @function processLoadInContentBreadcrumbTitle
 * @param {Object} ctxSearchSearch searchString context object
 * @param {String} searchString searchString
 * @param {Object} localizedText The localized text
 * @param {Object} totalResultCount Total Result count
 * @param {Object} resultsCountLabel Results Count Label
 * @return {Object} resultsCountLabel
 */
export let processLoadInContentBreadcrumbTitle = function( ctxSearchSearch, searchString, localizedText, totalResultCount, resultsCountLabel ) {
    if( isShapeSearchContext() ) {
        resultsCountLabel = processLoadInContentBreadcrumbTitleShape( ctxSearchSearch, searchString, localizedText, totalResultCount, resultsCountLabel );
    } else if( ctxSearchSearch && ctxSearchSearch.searchStringSecondary && searchString === ctxSearchSearch.searchStringPrimary + ' AND ' + ctxSearchSearch.searchStringSecondary ) {
        // define a variable so that the line length does not exceed 207 max-len...
        let labelText = localizedText.resultsCountLabelWithInContentSearch;
        resultsCountLabel = labelText.format( totalResultCount, ctxSearchSearch.searchStringPrimary, ctxSearchSearch.searchStringSecondary );
    } else {
        resultsCountLabel = localizedText.resultsCountLabelWithoutInContentSearch.format( totalResultCount, searchString );
    }

    return resultsCountLabel;
};

export let setFiltersFromCrumbs = function( crumbs, indexBreadCrumb ) {
    var newCrumbs = _.dropRightWhile( crumbs, function( c ) {
        return c.indexBreadCrumb > indexBreadCrumb;
    } );
    var filterMap = {};
    _.forEach( newCrumbs, function( c ) {
        if( filterMap[ c.internalName ] ) {
            filterMap[ c.internalName ].push( c.internalValue );
        } else {
            filterMap[ c.internalName ] = [ c.internalValue ];
        }
    } );
    var searchContext = appCtxService.getCtx( 'search' );
    var reqFilters = searchContext.reqFilters;
    if( reqFilters ) {
        _.forEach( reqFilters, function( value, key ) {
            if( filterMap[ key ] ) {
                filterMap[ key ].push( value );
            } else {
                filterMap[ key ] = [ value ];
            }
        } );
    }

    setFilters( filterMap );
};

export let displayNoBreadCrumbProvider = function( breadcrumbConfig, label, totalResultCount, searchCriteria ) {
    var provider = {};
    AwPromiseService.instance.all( {
        noCriteriaSpecifiedMessage: localeService.getLocalizedText(
            breadcrumbConfig.noCriteriaSpecifiedMessage.source,
            breadcrumbConfig.noCriteriaSpecifiedMessage.key ),
        noResultsFoundMessage: localeService.getLocalizedText(
            breadcrumbConfig.noResultsFoundMessage.source,
            breadcrumbConfig.noResultsFoundMessage.key ),
        resultsFoundMessage: localeService.getLocalizedText(
            breadcrumbConfig.resultsFoundMessage.source,
            breadcrumbConfig.resultsFoundMessage.key )
    } ).then( function( localizedText ) {
        if( !searchCriteria ) {
            provider.title = localizedText.noCriteriaSpecifiedMessage.format();
        } else if( totalResultCount === undefined || totalResultCount === 0 ) {
            provider.title = localizedText.noResultsFoundMessage.format( label );
        } else {
            provider.title = localizedText.resultsFoundMessage.format( label );
        }
    } );

    return provider;
};

export let getBreadcrumbProvider = function() {
    return {
        crumbs: [],
        clear: function() {
            // Publish to AW analytics
            var sanEvent = {
                sanAnalyticsType: 'Commands',
                sanCommandId: 'clearSearchFilter',
                sanCommandTitle: 'Clear All Search Filters'
            };

            analyticsSvc.logCommands( sanEvent );

            var searchContext = appCtxService.getCtx( 'search' );
            var reqFilters = searchContext.reqFilters;
            if( reqFilters ) {
                setFilters( reqFilters );
            } else {
                setFilters( [] );
            }
        },
        onRemove: function( crumb ) {
            // Publish to analytics
            var sanEvent = {
                sanAnalyticsType: 'Commands',
                sanCommandId: 'removeSearchFilterCrumb',
                sanCommandTitle: 'Remove Crumb Filter',
                sanCmdLocation: 'primarySearchPanel'
            };

            analyticsSvc.logCommands( sanEvent );
        },
        onSelect: function( crumb ) {
            // Publish to analytics
            var sanEvent = {
                sanAnalyticsType: 'Commands',
                sanCommandId: 'clickSearchFilterCrumb',
                sanCommandTitle: 'Click Search Filter Crumb',
                sanCmdLocation: 'primarySearchPanel'
            };

            analyticsSvc.logCommands( sanEvent );

            setFiltersFromCrumbs( this.crumbs, crumb.indexBreadCrumb );
        }
    };
};

export let setBreadcrumbValue = function( newBreadcrumb ) {
    if( newBreadcrumb.internalValue && newBreadcrumb.internalValue !== '' && newBreadcrumb.internalValue === newBreadcrumb.value ) {
        var searchContext = appCtxService.getCtx( 'searchSearch' );
        if( searchContext && searchContext.originalInputCategories ) {
            var categoryId = _.findIndex( searchContext.originalInputCategories, function( aCat ) {
                return newBreadcrumb.internalName === aCat.internalName;
            } );
            if( searchContext.originalInputCategories[ categoryId ] && searchContext.originalInputCategories[ categoryId ].filterValues ) {
                if( searchContext.originalInputCategories[ categoryId ].filterValues.parentnodes ) {
                    var foundFilter = _.findIndex( searchContext.originalInputCategories[ categoryId ].filterValues.parentnodes, function( aFilter ) {
                        return newBreadcrumb.internalValue === aFilter.stringValue;
                    } );
                    newBreadcrumb.value = searchContext.originalInputCategories[ categoryId ].filterValues.parentnodes[ foundFilter ].stringDisplayValue;
                }
            }
        }
    }
};

export let setBreadcrumbDisplayName = function( newBreadcrumb, categoriesDisplayed ) {
    var foundCategory = _.findIndex( categoriesDisplayed, function( aCategory ) {
        return aCategory === newBreadcrumb.displayName;
    } );
    if( foundCategory < 0 ) {
        categoriesDisplayed.push( newBreadcrumb.displayName );
    } else {
        newBreadcrumb.displayName = '';
    }
};

export let setBreadcrumbProviderTitle = function( provider, label, totalResultCount,
    selectionModel, secondarySearchEnabled ) {
    loadBreadcrumbClearTitle().then( function( result ) {
        provider.clearBreadCrumb = result;
    } );
    // Load and set the title async
    if( secondarySearchEnabled ) {
        loadInContentBreadcrumbTitle( label, totalResultCount, selectionModel ).then(
            function( result ) {
                provider.title = result;
            } );
    } else {
        loadBreadcrumbTitle( label, totalResultCount, selectionModel ).then(
            function( result ) {
                provider.title = result;
            } );
    }
};

export let buildBreadcrumbProvider = function( breadcrumbConfig, label, totalResultCount,
    selectionModel, searchFilterCategories, searchFilterMap, secondarySearchEnabled, searchCriteria ) {
    if( breadcrumbConfig && breadcrumbConfig.noBreadCrumb === 'true' ) {
        return displayNoBreadCrumbProvider( breadcrumbConfig, label, totalResultCount, searchCriteria );
    }
    var provider = getBreadcrumbProvider();

    // For each of the current search params
    var searchParams = getFilters( false, true, true, true );
    var categoriesDisplayed = [];
    var indexBreadCrumb = -1;
    _.forEach( searchParams, function( value ) {
        removePrefilter( value );
    } );
    _.map( searchParams, function( value, property ) {
        // If it's a valid filter
        var index = _.findIndex( searchFilterCategories, function( o ) {
            return o.internalName === property;
        } );
        var newBreadcrumb = {};

        _.forEach( searchParams[ property ], function( filter ) {
            var origProperty = property;
            var origFilter = filterPanelUtils.getRealFilterWithNoFilterType( filter );
            var filterType = filterPanelUtils.getFilterTypeFromFilterValue( filter );
            if( filter.hasOwnProperty( 'property' ) ) {
                origProperty = filter.property;
                origFilter = filter.filter;
            }
            if( index > -1 ) {
                // Make a breadcrumb for it
                newBreadcrumb = {
                    displayName: searchFilterCategories[ index ].displayName + ':',
                    displayNameHidden: searchFilterCategories[ index ].displayName + ':',
                    internalName: origProperty,
                    internalValue: origFilter,
                    filterType: filterType
                };
            } else if( !searchFilterCategories || searchFilterCategories &&
                searchFilterCategories.length < 1 ) {
                // Need still display the crumbs
                var categoryDisplayName = getCategoryDisplayName( property );
                if( !categoryDisplayName ) {
                    return provider;
                }
                newBreadcrumb = {
                    displayName: categoryDisplayName + ':',
                    displayNameHidden: categoryDisplayName + ':',
                    internalName: property,
                    internalValue: origFilter,
                    filterType: filterType
                };
            } else {
                return provider;
            }
            provider = processBreadCrumbsSearchFilters( provider, indexBreadCrumb, categoriesDisplayed, newBreadcrumb, searchFilterMap, origProperty, origFilter );
        } );
    } );
    setBreadcrumbProviderTitle( provider, label, totalResultCount,
        selectionModel, secondarySearchEnabled );

    return provider;
};

/**
 * Process Breadcrumbs with Search Filters.
 * @function processBreadCrumbsSearchFilters
 * @param {Object} provider The object newBreadCrumb
 * @param {Object} indexBreadCrumb The object newBreadCrumb
 * @param {Object} categoriesDisplayed The object newBreadCrumb
 * @param {Object} newBreadcrumb The object newBreadCrumb
 * @param {Object} searchFilterMap The search filter map
 * @param {Object} origProperty Original Property
 * @param {Object} origFilter Original filter
 * @return {Object} BreadCrumd Provider
 */
export let processBreadCrumbsSearchFilters = function( provider, indexBreadCrumb, categoriesDisplayed, newBreadcrumb, searchFilterMap, origProperty, origFilter ) {
    if( searchFilterMap ) {
        newBreadcrumb.value = getBreadCrumbDisplayValue( searchFilterMap[ origProperty ], origFilter );
    }

    if( newBreadcrumb.value && newBreadcrumb.value !== '' ) {
        setBreadcrumbValue( newBreadcrumb );
        setBreadcrumbDisplayName( newBreadcrumb, categoriesDisplayed );
        ++indexBreadCrumb;
        newBreadcrumb.indexBreadCrumb = indexBreadCrumb;
        provider.crumbs.push( newBreadcrumb );
    }

    if( newBreadcrumb.internalName === OWNING_SITE ) {
        newBreadcrumb.filterType = 'RadioFilter';
    }

    /* the OwningSite.owning_site is a property which server side filters on to return local or remote objects.
    This property does not exists in DB. It's a hardcoded value that server side expects and returns.*/
    if( newBreadcrumb.internalName === OWNING_SITE && newBreadcrumb.internalValue === _local ) {
        newBreadcrumb.showRemoveButton = false;
    } else {
        newBreadcrumb.showRemoveButton = true;
    }

    return provider;
};

// Return display name for a category
export let getCategoryDisplayName = function( property ) {
    var categoryDisplayName = '';
    // first check if it can be found in the prior search.
    var context = appCtxService.getCtx( 'searchSearch' );
    if( context && context.originalInputCategories && context.originalInputCategories.length > 0 ) {
        var index = _.findIndex( context.originalInputCategories, function( o ) {
            return o.internalName === property;
        } );
        if( index > -1 ) {
            categoryDisplayName = context.originalInputCategories[ index ].displayName;
            return categoryDisplayName;
        }
    }
    var aTypeProperty = property.split( '.' );
    if( aTypeProperty && aTypeProperty.length === 2 ) {
        var type = cmm.getType( aTypeProperty[ 0 ] );
        if( !type ) {
            // Category.category
            var catName = aTypeProperty[ 1 ];
            categoryDisplayName = catName[ 0 ].toUpperCase() + catName.slice( 1 ).toLowerCase();
        } else {
            var propName = filterPanelUtils.getPropertyFromFilter( aTypeProperty[ 1 ] );
            var pd = type.propertyDescriptorsMap[ propName ];
            if( !pd ) {
                categoryDisplayName = aTypeProperty[ 1 ];
            } else {
                categoryDisplayName = pd.displayName;
            }
        }
    }
    return categoryDisplayName;
};

export let loadConfiguration = function() {
    localeService.getLocalizedTextFromKey( 'UIMessages.noFilterValue', true ).then( result => localTextBundle.noFilterValue = result );
    localeService.getLocalizedTextFromKey( 'SearchMessages.searchFilterVariableMyGroup', true ).then( result => localTextBundle.searchFilterVariableMyGroup = result );
    localeService.getLocalizedTextFromKey( 'SearchMessages.searchFilterVariableThisMonth', true ).then( result => localTextBundle.searchFilterVariableThisMonth = result );
    localeService.getLocalizedTextFromKey( 'SearchMessages.searchFilterVariableThisWeek', true ).then( result => localTextBundle.searchFilterVariableThisWeek = result );
    localeService.getLocalizedTextFromKey( 'dateTimeServiceMessages.currentText', true ).then( result => localTextBundle.searchFilterVariableToday = result );
};

loadConfiguration();

const awSearchFilterService = {
    _dateFilterMarker,
    _dateFilterLevels,
    _filterSeparator,
    _filterValueSeparator,
    chooseFilterSeparator,
    buildFilterString,
    isHierarchicalChildFilter,
    parseHierarchicalChildFilters,
    getFilters,
    checkIfObjectFilterType,
    getSortedFilterMap,
    buildSearchFiltersInt,
    buildSearchFilters,
    getFilterStringFromActiveFilterMap,
    convertFilterMapToSavedSearchFilterMap,
    getFilterDisplayValue,
    getSpecialDisplayName,
    getLocalTextBundle,
    getBreadCrumbDisplayValue,
    processDateStringOffset,
    groupByCategory,
    setFilters,
    addOrRemoveObjectFilter,
    addOrRemoveFilter,
    getFilterExtension,
    doSearch,
    doSearchKeepFilter,
    isShapeSearchContext,
    loadBreadcrumbClearTitle,
    doShapeSearch,
    loadBreadcrumbTitle,
    loadInContentBreadcrumbTitle,
    setFiltersFromCrumbs,
    displayNoBreadCrumbProvider,
    getBreadcrumbProvider,
    setBreadcrumbValue,
    setBreadcrumbDisplayName,
    setBreadcrumbProviderTitle,
    buildBreadcrumbProvider,
    getCategoryDisplayName,
    loadConfiguration,
    processLoadInContentBreadcrumbTitleShape,
    processLoadInContentBreadcrumbTitle,
    processConvertFilterMapToSavedSearchFilterMap,
    processBreadCrumbsSearchFilters,
    buildSearchFiltersFromSearchState,
    getFilterMapWithPrefilters,
    getDisplayNameForSpecialKeyWord,
    getUserValue,
    sortFilterMapKeys,
    processFilterValues,
    removeDependentDateFilters,
    getPendingFiltersMap,
    clearAllSelectedFiltersAndRanges,
    clearNumericRangeInfoFromCategory,
    clearDateRangeInfoFromCategory,
    removeDependentClassificationFilters
};

export default awSearchFilterService;
