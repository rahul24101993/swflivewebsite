// Copyright (c) 2020 Siemens

/**
 * Note: This module does not return an API object. The API is only available when the service defined this module is
 * injected by AngularJS.
 *
 * @module js/filterPanelUtils
 */
import appCtxService from 'js/appCtxService';
import dateTimeService from 'js/dateTimeService';
import messagingService from 'js/messagingService';
import localeSvc from 'js/localeService';
import $ from 'jquery';
import logger from 'js/logger';
import _ from 'lodash';

var _invalidDateText = '';
var _invalidRangeText = '';
var _invalidPrefilter = '';
var AWC_LIMITED_FILTER_CATEGORIES_ENABLED = 'AWC_Limited_Filter_Categories_Enabled';

export let HIERARCHICAL_FACET_SEPARATOR = '/';
export let PRESET_CATEGORY = 'WorkspaceObject.object_type';
export let DATE_FILTER = 'DateFilter';
export let INTERNAL_DATE_FILTER = '_DateFilter_';
export let DATE_RANGE_FILTER = 'DateRangeFilter';
export let DATE_DRILLDOWN_FILTER = 'DrilldownDateFilter';
export let NUMERIC_RANGE_FILTER = 'NumericRangeFilter';
export let INTERNAL_NUMERIC_FILTER = '_NumericFilter_';
export let INTERNAL_OBJECT_FILTER = '_ObjectFilter_';
export let INTERNAL_NUMERIC_RANGE = '_NumericRange_';
export let NUMERIC_FILTER = 'NumericFilter';
export let NUMERIC_RANGE = 'NumericRange';
export let NumericRangeBlankStart = 'NumericRangeBlankStart';
export let NumericRangeBlankEnd = 'NumericRangeBlankEnd';
var INTERNAL_TO = '_TO_';
export let NO_STARTDATE = '*';
export let NO_ENDDATE = '2100-12-31';
export let NO_STARTRANGE = '';
export let NO_ENDRANGE = '';
export let BEGINNING_OF_TIME = '0001-01-01T00:00:00';
export let ENDING_OF_TIME = '2100-12-31T23:59:59';
var START_OF_DAY = '00:00:00';
var _presetFilters = true;
var _hasTypeFilter = false;
var _incontextFlag = false;
var customPropValueColorMap = {};

/**
 * Returns a date object.
 *
 * @function getDate
 * @memberOf filterPanelUtils
 *
 * @param {String}dateString - date string to be converted to date object
 *
 * @return {JsDate} a date object.
 */
export let getDate = function( dateString ) {
    var dateStr = dateString.substring( 0, 10 );
    var date;
    // change open start/end date to null dates
    if( _.startsWith( dateStr, '0001-01-0' ) || _.startsWith( dateStr, '2100-12-3' ) ) {
        date = dateTimeService.getNullDate();
    } else {
        var timeStr = dateString.substring( 11, dateString.length - 6 );
        if( timeStr.indexOf( '59' ) !== -1 ) {
            dateStr = dateString.replace( timeStr, START_OF_DAY );
        } else {
            dateStr = dateString;
        }
        date = new Date( dateStr );
    }

    return date;
};

/**
 * Returns a UTC date object.
 *
 * @function convertToUTC
 * @memberOf filterPanelUtils
 *
 * @param {Object}date - date object
 *
 * @return {JsDate} a UTC date object.
 */
function convertToUTC( date ) {
    var gmtTime = date.getTime();
    var offset = date.getTimezoneOffset();
    var jsDate = new Date( gmtTime + offset * 60 * 1000 );
    return new Date( jsDate.getTime() );
}
/**
 * Check if a date is null. The dateTimeService.isNullDate is not adequate, as the blank date from date widget can
 * sometimes be 0-0-0 0:0:0, or 0-0-0 23:59:XX, or 0-0-1 0:0:0, etc, only the first case is evaluated to true by the
 * dateTimeService.isNullDate.
 *
 * @function isNullDate
 * @memberOf filterPanelUtils
 *
 * @param {Object} dateToTest - a Date object.
 * @returns {Boolean} - true if it's a null date.
 */
export let isNullDate = function( dateToTest ) {
    if( !dateToTest ) {
        return true;
    }
    return dateToTest.getFullYear() <= 1;
};

/**
 * Validate dates for category date range.
 *
 * @function validateDates
 * @memberOf filterPanelUtils
 *
 * @param {Object}category - category. This object is modified in this function.
 * @param {Object}startDate - startDate
 * @param {Object}origStartDate - origStartDate
 * @param {Object}endDate - endDate
 * @param {Object}origEndDate - origEndDate
 */
export let validateDates = function( category, startDate, origStartDate, endDate, origEndDate ) {
    category.showSearch = true;

    var cStartDate = category.daterange.startDate;
    var eEndDate = category.daterange.endDate;
    if( category.daterange.dateRangeSelected && !cStartDate.valueUpdated && !eEndDate.valueUpdated ) {
        category.showSearch = false;
        return;
    }
    // The blank date in date range widget sometimes show up as 0-0-0 23:59:58 which is the end of the day,
    // which makes the isNullDate return false. Need to move to start of day then do the isNullDate check.
    var tmpStartDate = moveDateToStartOfDay( startDate );
    var tmpEndDate = moveDateToStartOfDay( endDate );
    var noStartDate = dateTimeService.isNullDate( tmpStartDate );
    var noEndDate = dateTimeService.isNullDate( tmpEndDate );

    // if both dates are not set, disable search button
    if( noStartDate && noEndDate ) {
        category.showSearch = false;
        return;
    }
    var temp1 = dateTimeService.compare( startDate, endDate );
    // if start date is later than end date, disable search button
    if( !noStartDate && !noEndDate && startDate !== null && temp1 === 1 ) {
        messagingService.showError( _invalidDateText );
        category.showSearch = false;
        return;
    }

    var disable;
    // check if dates vary from previous search to avoid enabling search
    var tmpOrigEndDate = moveDateToStartOfDay( origEndDate );

    if( noStartDate ) {
        // check if there is no startdate and if end date is same, disable search button
        disable = category.daterange.startDate === null &&
            dateTimeService.compare( tmpEndDate, tmpOrigEndDate ) === 0;
    } else if( noEndDate ) {
        // check if there is no enddate and  start date is same, disable search button
        disable = category.daterange.endDate === null &&
            dateTimeService.compare( startDate, category.daterange.startDate.dateApi.dateObject ) === 0;
    } else {
        // if the dates are same as previous search, disable search button
        var compare1 = dateTimeService.compare( startDate, origStartDate ) === 0;
        var compare2 = dateTimeService.compare( endDate, tmpOrigEndDate ) === 0;
        disable = compare1 && compare2;
    }
    category.showSearch = !disable;
};

/**
 * get date range filter.
 *
 * @function getDateRangeString
 * @memberOf filterPanelUtils
 *
 * @param {Object}startDate - startDate
 * @param {Object}endDate - endDate
 *
 * @return {String} a string that represents the date range.
 */
export let getDateRangeString = function( startDate, endDate ) {
    var noStartDate = isNullDate( startDate );
    var noEndDate = isNullDate( endDate );
    var fromDateString = noStartDate ? NO_STARTDATE : dateTimeService.formatUTC( startDate );
    if( noEndDate ) {
        endDate = new Date( NO_ENDDATE );
    }
    var toDateString = dateTimeService.formatUTC( moveDateToEndOfDay( endDate ) );
    return INTERNAL_DATE_FILTER + fromDateString + INTERNAL_TO + toDateString;
};

/**
 * get filter of date range.
 *
 * @function getDateRangeString
 * @memberOf filterPanelUtils
 *
 * @param {String}filter - filter
 *
 * @return {Object} a filter object of date range for the filter string.
 */
export let getDateRangeFilter = function( filter ) {
    var searchFilter = {};
    var sArr = filter.split( INTERNAL_TO );
    searchFilter.searchFilterType = 'DateFilter';
    sArr[ 0 ] = sArr[ 0 ] === NO_STARTDATE ? dateTimeService.NULLDATE : dateTimeService.formatUTC( sArr[ 0 ] );
    searchFilter.startDateValue = sArr[ 0 ];
    searchFilter.endDateValue = sArr[ 1 ];
    return searchFilter;
};

/**
 * get a date range filter with display name and category type.
 *
 * @function getDateRangeDisplayString
 * @memberOf filterPanelUtils
 *
 * @param {String}startDate - startDate
 * @param {String}endDate - endDate
 *
 * @return {Object} a date range filter with display name and category type.
 */
export let getDateRangeDisplayString = function( startDate, endDate ) {
    var dateRangeFilter = {};
    var noStartDate = dateTimeService.isNullDate( startDate );
    var noEndDate = dateTimeService.isNullDate( endDate );
    var dateRangeString;
    if( noStartDate ) {
        dateRangeString = 'To ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );
    } else if( noEndDate ) {
        dateRangeString = 'From ' +
            dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 );
    } else {
        dateRangeString = dateTimeService.formatDate( new Date( startDate ) ).substring( 0, 11 ) +
            ' - ' + dateTimeService.formatDate( new Date( endDate ) ).substring( 0, 11 );
    }
    dateRangeFilter.displayName = dateRangeString;
    dateRangeFilter.categoryType = DATE_RANGE_FILTER;
    return dateRangeFilter;
};

/**
 * Simple check to validate the given category numeric range.
 *
 * @function checkIfValidRange
 * @memberOf filterPanelUtils
 *
 * @param {String}category - category
 * @param {Number}startRange - startRange
 * @param {Number}endRange - endRange
 *
 * @return {Boolean} true if valid range.
 */
export let checkIfValidRange = function( category, startRange, endRange ) {
    category.showSearch = true;

    if( startRange !== null && endRange !== null && startRange > endRange ) {
        var errorValue = startRange + '-' + endRange;
        var msg = _invalidRangeText.replace( '{0}', errorValue );
        messagingService.showError( msg );
        category.showSearch = false;
        return false;
    }

    return true;
};

/**
 * Validate the given category numeric range if the range is selected.
 *
 * @function validateNumericRangeSelected
 * @memberOf filterPanelUtils
 *
 * @param {String}category - category
 * @param {Number}startRange - startRange
 * @param {Number}endRange - endRange
 * @param {Number}cStartRange - current startRange
 * @param {Number}cEndRange - current endRange
 * @return {Boolean} true if valid range.
 */
export let validateNumericRangeSelected = function( category, startRange, endRange, cStartRange, cEndRange ) {
    var hasValidated = false;

    var oStartRange = category.numericrange.filter.startNumericValue;
    var oEndRange = category.numericrange.filter.endNumericValue;

    var pStartRange = parseFloat( cStartRange );
    var pEndRange = parseFloat( cEndRange );

    var invalidStart = cStartRange === oStartRange || pStartRange === oStartRange ||
        isNaN( pStartRange ) && oStartRange === NO_STARTRANGE;
    // when the start range goes from blank to 0, it's a real change, so the search button should be enabled.
    if( category.numericrange.filter.startEndRange === NumericRangeBlankStart ) {
        invalidStart = isNaN( pStartRange );
    }
    var invalidEnd = cEndRange === oEndRange || pEndRange === oEndRange || isNaN( pEndRange ) && oEndRange === NO_ENDRANGE;
    if( category.numericrange.filter.startEndRange === NumericRangeBlankEnd ) {
        invalidEnd = isNaN( pEndRange );
    }
    // when the end range goes from blank to 0, it's a real change, so the search button should be enabled.
    if( invalidStart && invalidEnd ) {
        category.showSearch = false;
        hasValidated = true;
    }
    return hasValidated;
};
/**
 * Validate ranges for category numeric range.
 *
 * @function validateNumericRange
 * @memberOf filterPanelUtils
 *
 * @param {String} category - category
 * @param {String} startRange - startRange
 * @param {String} endRange - endRange
 *
 */
export let validateNumericRange = function( category, startRange, endRange ) {
    category.showSearch = true;

    // Validate values to be numbers
    var cStartRange = category.numericrange.startValue.dbValue;
    var cEndRange = category.numericrange.endValue.dbValue;
    var oStartRange = null;
    var oEndRange = null;

    if( category.numericrange.numericRangeSelected && validateNumericRangeSelected( category, startRange, endRange, cStartRange, cEndRange ) ) {
        return;
    }

    var noStartRange = cStartRange === undefined || cStartRange === null || cStartRange === '';
    var noEndRange = cEndRange === undefined || cEndRange === null || cEndRange === '';

    // if both numbers are not set, disable search button
    if( noStartRange && noEndRange ) {
        category.showSearch = false;
        return;
    }

    var disable = false;
    if( noStartRange ) {
        disable = endRange === oEndRange || isNaN( endRange );
    } else if( noEndRange ) {
        // check if there is no endRange and  start number is same, disable search button
        disable = startRange === oStartRange || isNaN( startRange );
    } else {
        disable = !isFinite( startRange ) || isNaN( startRange ) || !isFinite( endRange ) || isNaN( endRange );
    }
    category.showSearch = !disable;
};

/**
 * get numeric range filter string.
 *
 * @function getNumericRangeString
 * @memberOf filterPanelUtils
 *
 * @param {String}startRange - startRange
 * @param {String}endRange - endRange
 *
 * @return {String} a numeric range string.
 */
export let getNumericRangeString = function( startRange, endRange ) {
    var fromValue = startRange && startRange.toString();
    if( fromValue === undefined || fromValue === null || fromValue.length === 0 || isNaN( fromValue ) ) {
        fromValue = NO_STARTRANGE;
    }
    var toValue = endRange && endRange.toString();
    if( toValue === undefined || toValue === null || toValue.length === 0 || isNaN( toValue ) ) {
        toValue = NO_ENDRANGE;
    }
    return INTERNAL_NUMERIC_RANGE + fromValue + INTERNAL_TO + toValue;
};

/**
 * get numeric range filter from a filter string.
 *
 * @function getDateRangeDisplayString
 * @memberOf filterPanelUtils
 *
 * @param {String}filter - filter
 *
 * @return {Object} a numeric range filter.
 */
export let getNumericRangeFilter = function( filter ) {
    var searchFilter = {};
    var sArr = filter.split( INTERNAL_TO );
    searchFilter.searchFilterType = NUMERIC_FILTER;
    searchFilter.startNumericValue = parseFloat( sArr[ 0 ] );
    searchFilter.endNumericValue = parseFloat( sArr[ 1 ] );
    if( isNaN( searchFilter.startNumericValue ) ) {
        searchFilter.startEndRange = NumericRangeBlankStart;
    } else if( isNaN( searchFilter.endNumericValue ) ) {
        searchFilter.startEndRange = NumericRangeBlankEnd;
    } else {
        searchFilter.startEndRange = NUMERIC_RANGE;
    }
    return searchFilter;
};

/**
 * get a numeric range filter.
 *
 * @function getNumericRangeDisplayString
 * @memberOf filterPanelUtils
 *
 * @param {Number}startRange - startRange
 * @param {Number}endRange - endRange
 * @param {String}startEndRange - startEndRange
 *
 * @return {Object} a numeric range filter with display name and category type.
 */
export let getNumericRangeDisplayString = function( startRange, endRange, startEndRange ) {
    var numericRangeFilter = {};
    var noStartRange = startEndRange === NumericRangeBlankStart || startRange !== 0 && !startRange;
    var noEndRange = startEndRange === NumericRangeBlankEnd || endRange !== 0 && !endRange;

    var numericRangeString;
    if( noStartRange ) {
        numericRangeString = 'To ' + endRange.toString();
    } else if( noEndRange ) {
        numericRangeString = 'From ' + startRange.toString();
    } else {
        numericRangeString = startRange.toString() + ' - ' + endRange.toString();
    }
    numericRangeFilter.displayName = numericRangeString;
    numericRangeFilter.categoryType = NUMERIC_RANGE_FILTER;
    return numericRangeFilter;
};

/**
 * get a real filter.
 *
 * @function getRealFilterWithNoFilterType
 * @memberOf filterPanelUtils
 *
 * @param {String}filter - filter
 *
 * @return {Object} the real filter stripped off the identifiers.
 */
export let getRealFilterWithNoFilterType = function( filter ) {
    var realFilter = filter;
    if( !filter.hasOwnProperty( 'property' ) ) {
        realFilter = filter.replace( INTERNAL_NUMERIC_FILTER, '' ).replace( INTERNAL_OBJECT_FILTER, '' );
    }
    return realFilter;
};

/**
 * get filter type from filter value.
 *
 * @function getFilterTypeFromFilterValue
 * @memberOf filterPanelUtils
 *
 * @param {String}filter - filter
 *
 * @return {String} filter type, if it can be derived.
 */
export let getFilterTypeFromFilterValue = function( filter ) {
    var filterType;
    if( _.startsWith( filter, INTERNAL_OBJECT_FILTER ) ) {
        filterType = 'ObjectFilter';
    } else if( _.startsWith( filter, INTERNAL_NUMERIC_FILTER ) ) {
        filterType = 'NumericFilter';
    } else {
        filterType = 'DateFilter';
    }
    return filterType;
};

/**
 * /** Return date to start of the day
 *
 * @param {Date} date a given date
 * @return {Date} date
 */
function moveDateToStartOfDay( date ) {
    if( !dateTimeService.isNullDate( date ) ) {
        date.setHours( 0, 0, 0 );
        return date;
    }
    return date;
}

/**
 * Return date to start of the day
 *
 * @param {Date} date a given date
 * @return {Date} date
 */
function moveDateToEndOfDay( date ) {
    if( !dateTimeService.isNullDate( date ) ) {
        date.setHours( 23, 59, 59 );
        return date;
    }
    return date;
}

/**
 * Returns true if preset filters are hidden
 *
 * @returns {Object} preset filter flag
 */
export let isPresetFilters = function() {
    return _presetFilters;
};

/**
 * Sets preset filters flag
 *
 * @param {Object} flag flag
 */
export let setPresetFilters = function( flag ) {
    _presetFilters = flag;
};

/**
 * Returns true if preset filters are hidden
 *
 * @returns {Object} preset filter flag
 */
export let getHasTypeFilter = function() {
    return _hasTypeFilter;
};

/**
 * Sets preset filters flag
 *
 * @param {Object} flag preset filter flag
 */
export let setHasTypeFilter = function( flag ) {
    _hasTypeFilter = flag;
};

/**
 * Sets incontext flag
 *
 * @param {Object} flag incontext flag
 */
export let setIncontext = function( flag ) {
    _incontextFlag = flag;
};

/**
 * Gets incontext flag
 *
 * @returns {Object} incontext flag
 */
export let getIncontext = function() {
    return _incontextFlag;
};

/**
 * Save source filter map in appcontext for incontext
 *
 * @param {Object} data data
 */
export let saveIncontextFilterMap = function( data ) {
    let inContextMap = {};
    if( getHasTypeFilter() ) {
        // Create a filter value for each category value
        let tmpValues = data.searchFilterMap[ PRESET_CATEGORY ];
        inContextMap[ PRESET_CATEGORY ] = tmpValues;
    }
    return inContextMap;
};

/**
 * Returns category internal name
 * @param {Object} category category
 * @returns {Object} The category internal name
 */
export let getCategoryInternalName = function( category ) {
    return category.internalName;
};

/**
 * Returns current category
 *
 * @param {Object} response the response from the search SOA
 * @returns {Object} The current category
 */
export let getCurrentCategory = function( response ) {
    return response.groupedObjectsList[ 0 ].internalPropertyName;
};

/**
 * Returns filter values for a category to be shown in panel
 *
 * @param {Object} category the category to get values for
 *
 * @returns {ObjectArray} The array of filters to show in panel
 */
export let getPropGroupValues = function( category ) {
    getPreferenceValue();

    var values = [];
    for( var i = 0; i < category.filterValues.length; i++ ) {
        var categoryValue = category.filterValues[ i ];
        if( categoryValue && ( i < 9 || categoryValue.color ) ) {
            values.push( getPropGroupValue( category.type, category.drilldown, categoryValue ) );
        }
    }

    return values;
};

/**
 * Returns filter values for a category to be shown in panel
 * @param {String} categoryType categoryType
 * @param {Integer} categoryDrillDown category Drill Down
 * @param {String} categoryValue categoryValue
 * @returns {Object} filter value
 */
export let getPropGroupValue = function( categoryType, categoryDrillDown, categoryValue ) {
    var pos = categoryValue.categoryName.indexOf( '.' );
    var propertyName;

    if( pos !== -1 ) {
        propertyName = categoryValue.categoryName.slice( pos + 1 );
    } else {
        propertyName = categoryValue.categoryName;
    }
    var mapKey = propertyName + '.' + categoryValue.name;

    var filterValue = {};
    if( categoryValue.color && customPropValueColorMap[ mapKey ] ) {
        filterValue.propertyGroupID = categoryValue.color;
        var rgbColorValue = getFilterColorRGBValue( categoryValue.color );
        filterValue.colorValue = rgbColorValue;
    } else {
        filterValue.propertyGroupID = getFilterColorValue( categoryValue.colorIndex );
        filterValue.colorIndex = categoryValue.colorIndex;
        filterValue.colorValue = getFilterColorRGBValue( 'aw-charts-chartColor' + ( categoryValue.colorIndex % 9 + 1 ) );
    }

    if( categoryType === 'DateFilter' ) {
        if( categoryValue.colorIndex >= categoryDrillDown ) {
            if( categoryValue.internalName !== '$NONE' ) {
                filterValue.startValue = categoryValue.startDateValue;
                filterValue.endValue = categoryValue.endDateValue;
            } else {
                filterValue.startValue = '$NONE';
            }
        }
    } else {
        filterValue.startValue = categoryValue.internalName;
        filterValue.endValue = '';
    }

    return filterValue;
};

/**
 * Returns filter RGB values for a category to be shown in viewer
 * @param {STRING} color color
 * @returns {Object} filter Color RGB value
 */
export let getFilterColorRGBValue = function( color ) {
    var colorBlock = '.aw-ui-filterNameColorBlock';
    var colorBlockElement = $( colorBlock );
    var elementExists = colorBlockElement && colorBlockElement.length > 0;
    if( !elementExists ) {
        //in the case of ACE filter panel, the rendering of the panel is delayed
        colorBlock = '.aw-layout-globalToolbarPanel';
        colorBlockElement = $( colorBlock );
        elementExists = colorBlockElement && colorBlockElement.length > 0;
    }
    if( elementExists ) {
        var p = colorBlockElement[ 0 ];
        var replacedClassName = p.className;
        p.className = 'aw-ui-filterNameColorBlock ' + color;
        var style2 = window.getComputedStyle( p, null ).getPropertyValue(
            'background-color' );
        p.className = replacedClassName;
        return style2;
    }
    return '';
};

/**
 * Returns filter values for a category to be shown in panel
 * @param {Integer} index index
 * @returns {Object} filter value
 */
export let getFilterColorValue = function( index ) {
    return index > -1 ? 'aw-charts-chartColor' + ( index % 9 + 1 ) : '';
};

/**
 * Get property name from filter name.
 *
 * @param {String} filterName - The filter name
 * @return {propName} property name
 */
export let getPropertyFromFilter = function( filterName ) {
    var propName = filterName;

    var YEAR_SUFFIX = '_0Z0_year';
    var YEAR_MONTH_SUFFIX = '_0Z0_year_month';
    var WEEK_SUFFIX = '_0Z0_week';
    var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';

    if( _.endsWith( filterName, YEAR_MONTH_DAY_SUFFIX ) === true ) {
        propName = filterName.replace( YEAR_MONTH_DAY_SUFFIX, '' );
    }
    if( _.endsWith( filterName, WEEK_SUFFIX ) === true ) {
        propName = filterName.replace( WEEK_SUFFIX, '' );
    }
    if( _.endsWith( filterName, YEAR_MONTH_SUFFIX ) === true ) {
        propName = filterName.replace( YEAR_MONTH_SUFFIX, '' );
    }
    if( _.endsWith( filterName, YEAR_SUFFIX ) === true ) {
        propName = filterName.replace( YEAR_SUFFIX, '' );
    }
    return propName;
};

/**
 * Get formatted date.
 *
 * @param {String} dateString - input date
 *
 * @param {Boolean} isDateRangeToDate - indicate if it's an end date in a date range
 *
 * @return {formattedDate} formatted date
 */
export let getFormattedFilterDate = function( dateString, isDateRangeToDate ) {
    var formattedDate;
    if( dateString === '*' ) {
        if( isDateRangeToDate ) {
            formattedDate = ENDING_OF_TIME;
        } else {
            formattedDate = BEGINNING_OF_TIME;
        }
    } else {
        try {
            var date = convertToUTC( new Date( dateString ) );
            formattedDate = dateTimeService.formatUTC( date );
        } catch ( e ) {
            logger.error( 'The specified date is invalid and will be ignored for the search:', dateString );
            return null;
        }
    }
    return formattedDate;
};

/**
 * Get formatted numeric range filter.
 *
 * @param {String} filterValue - filterValue
 *
 * @return {formattedNumber} formatted filter
 */
export let getFormattedFilterNumber = function( filterValue ) {
    var formattedFilter = {};
    var startToEnd = filterValue.split( ' TO ' );
    var startNumber = parseFloat( startToEnd[ 0 ] );
    var endNumber = parseFloat( startToEnd[ 1 ] );
    if( isNaN( startNumber ) && isNaN( endNumber ) ) {
        logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );
        return null;
    } else if( startToEnd[ 0 ] === '*' ) {
        formattedFilter = {
            searchFilterType: 'NumericFilter',
            startNumericValue: 0,
            endNumericValue: endNumber,
            startEndRange: NumericRangeBlankStart
        };
    } else if( startToEnd[ 1 ] === '*' ) {
        formattedFilter = {
            searchFilterType: 'NumericFilter',
            startNumericValue: startNumber,
            endNumericValue: 0,
            startEndRange: NumericRangeBlankEnd
        };
    } else {
        if( isNaN( startNumber ) || isNaN( endNumber ) ) {
            logger.error( 'The specified range is invalid and will be ignored for the search:', filterValue );
            return null;
        }
        formattedFilter = {
            searchFilterType: 'NumericFilter',
            startNumericValue: startNumber,
            endNumericValue: endNumber,
            startEndRange: NUMERIC_RANGE
        };
    }
    return formattedFilter;
};

/**
 * Get Range Filter.
 *
 * @param {String} filterType - filter type
 *
 * @param {String} filterValue - filter value
 *
 * @return {searchFilter} Search Filter
 */
export let getRangeSearchFilter = function( filterType, filterValue ) {
    // range search.
    var searchFilter;
    var startToEnd = filterValue.split( ' TO ' );

    if( filterType === 'NumericFilter' ) {
        searchFilter = getFormattedFilterNumber( filterValue );
    } else if( filterType === 'DateFilter' ) {
        var startDate = getFormattedFilterDate( startToEnd[ 0 ].trim(), false );
        var endDate = getFormattedFilterDate( startToEnd[ 1 ].trim(), true );
        if( startDate && endDate ) {
            searchFilter = {
                searchFilterType: filterType,
                startDateValue: startDate,
                endDateValue: endDate
            };
        }
    } else {
        // String type, but string type should not support range search,
        // so treat the " TO " as just part of the filter value
        searchFilter = {
            searchFilterType: filterType,
            stringValue: filterValue
        };
    }
    return searchFilter;
};

/**
 * Get Single Filter.
 *
 * @param {String} filterType - filter type
 *
 * @param {String} filterValue - filter value
 *
 * @return {searchFilter} Search Filter
 */
export let getSingleSearchFilter = function( filterType, filterValue ) {
    // range search.
    var searchFilter;

    if( filterType === 'NumericFilter' ) {
        try {
            var formattedNumber = parseFloat( filterValue );
            if( isNaN( formattedNumber ) ) {
                logger.error( 'The specified number is invalid and will be ignored for the search:',
                    filterValue );
            } else {
                searchFilter = {
                    searchFilterType: filterType,
                    startNumericValue: formattedNumber,
                    endNumericValue: formattedNumber,
                    stringValue: filterValue
                };
            }
        } catch ( e ) {
            logger.error( 'The specified number is invalid and will be ignored for the search:', filterValue );
        }
    } else {
        // Date type is also treated as String, if it's not date range.
        searchFilter = {
            searchFilterType: 'StringFilter',
            stringValue: filterValue
        };
    }

    return searchFilter;
};

/**
 * Get filter type based on the value type.
 *
 * @param {Integer} valueType - The valueType for this property
 *
 * @return {filterType} filter type based off the integer value of valueType (String/Double/char etc.)
 */
export let getFilterType = function( valueType ) {
    var filterType;
    switch ( valueType ) {
        case 2:
            filterType = 'DateFilter';
            break;
        case 3:
        case 4:
        case 5:
        case 7:
            filterType = 'NumericFilter';
            break;
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
            // filterType = 'ObjectFilter';
            // ObjectFilter will be treated as StringFilter for the searchInput of performSearch SOA.
            filterType = 'StringFilter';
            break;
        default:
            filterType = 'StringFilter';
            break;
    }
    return filterType;
};

/**
 * Display search prefilter error
 *
 * @param {String} prefilter - The search prefilter
 *
 */
export let displayPrefilterError = function( prefilter ) {
    var msg = _invalidPrefilter.replace( '{0}', prefilter );
    messagingService.showError( msg );
};

/**
 * This function reads the “AWC_CustomPropValueColor” preference value and populates the customPropValueColorMap.
 * This is used to overide filter color in filter panel.
 * Preference value is in formate <propertyname>.<value>:<colorValue>
 */
export let getPreferenceValue = () => {
    let values = appCtxService.getCtx( 'preferences.AWC_CustomPropValueColor' );
    if( values && values[ 0 ] ) {
        for( var i = 0; i < values.length; i++ ) {
            var prefVal = values[ i ];
            var pos = prefVal.indexOf( ':' );
            var color = prefVal.slice( pos + 1 );
            var property = prefVal.slice( 0, pos );
            customPropValueColorMap[ property ] = color;
        }
    }
};

/**
 * get filter color
 *
 * @param propertyName filter name
 *
 * @returns color color code need to be applied for filter
 */
export let getCustomPropValueColorMap = function( propertyName ) {
    return customPropValueColorMap[ propertyName ];
};

/**
 * set filter color
 *
 * @param propertyName filter name
 *
 * @param color color code need to be applied for filter
 */
export let setCustomPropValueColorMap = function( propertyName, color ) {
    customPropValueColorMap[ propertyName ] = color;
};

/**
 * This function reads the “AWC_CustomPropValueColor” preference value and applies the color to the filter.
 */
export let applyCustomColor = function( categoryName, categoryValue, filterValue ) {
    var pos = categoryName.indexOf( '.' );
    var propertyName;

    if( pos !== -1 ) {
        propertyName = categoryName.slice( pos + 1 );
    } else {
        propertyName = categoryName;
    }
    var mapKey = propertyName + '.' + categoryValue.stringValue;

    //Overriding the filter color based on preference AWC_CustomPropValueColor value if this property's color is defined in this preference
    if( customPropValueColorMap[ mapKey ] ) {
        if( categoryValue.colorValue ) {
            //This scenario will be hit in the cases where color value is being populated by server response - searchFilter3 or later
            filterValue.color = categoryValue.colorValue;
        } else {
            //This scenario will be hit in the cases where color value is not being populated by server response
            filterValue.color = customPropValueColorMap[ mapKey ];
        }
    }
};

/**
 * @function checkIfFilterValuesExist - this function checks if the category has filtervalues or not
 * @param { Object } category - the current category
 * @returns { Boolean } true/false
 */

export let checkIfFilterValuesExist = function( category ) {
    if( category.filterValues && category.filterValues.length > 0 ) {
        return true;
    }
    return false;
};

/**
 * @function isLimitedCategoriesFeatureEnabled - this function checks if AWC_LIMITED_FILTER_CATEGORIES_ENABLED is true
 * @returns { Boolean } true/false
 */

export let isLimitedCategoriesFeatureEnabled = function() {
    var preferenceValue = appCtxService.getCtx( 'preferences.' + AWC_LIMITED_FILTER_CATEGORIES_ENABLED );
    if( preferenceValue && preferenceValue[ 0 ].toLowerCase() === 'true' ) {
        return true;
    }
    return false;
};

/**
 * ifFilterSelectedForCategory - check if the current category has some filter as selected
 * @param { Object } category the current category
 * @returns { Boolean } true/false
 */
export let ifFilterSelectedForCategory = function( category ) {
    var filterValuesExist = checkIfFilterValuesExist( category );
    if( filterValuesExist ) {
        for( var index = 0; index < category.filterValues.length; index++ ) {
            if( category.filterValues[ index ].selected ) {
                return true;
            }
        }
    }
    return false;
};

/**
 * isClsCategory - check if the current category is a classification type
 * @param { Object } category the current category
 * @returns { Boolean } true/false
 */
export let isClsCategory = ( category ) => {
    if( category.filterValues && ( category.filterValues.parentnodes &&
            category.filterValues.parentnodes.length > 0 || category.filterValues.childnodes && category.filterValues.childnodes.length > 0 ) ) {
        return true;
    }
    return false;
};

/**
 * ifFilterSelectedForCls - check if the current category is a classification category with a filter selected
 * @param { Object } category the current category
 * @returns { Boolean } true/false
 */
export let ifFilterSelectedForCls = ( category ) => {
    var filterValuesExist = isClsCategory( category );
    if( filterValuesExist ) {
        for( var index = 0; index < category.filterValues.parentnodes.length; index++ ) {
            if( category.filterValues.parentnodes[ index ].selected ) {
                return true;
            }
        }
    }
    return false;
};

/**
 * getFilterFocus - return whether to set autoFocus for a filter as true or false
 * @param { Object } lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @param { Object } filter current filter
 * @param { Object } categoryInternalName current category internal name
 * @param { Integer } index - current filter index
 * @returns { Boolean } autoFocus value for the filter - true/false
 */
export const getFilterFocus = ( lastSelectedFilterAndCategoryInfo, filter, categoryInternalName, index ) => {
    let lastAction = lastSelectedFilterAndCategoryInfo ? lastSelectedFilterAndCategoryInfo.lastAction : '';
    switch( lastAction ) {
        case 'selectFilter':
            if( lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastSelectedFilter.categoryName === filter.categoryName &&
                lastSelectedFilterAndCategoryInfo.lastSelectedFilter.internalName === filter.internalName ) {
                return true;
            }
            return false;
        case 'dateRangeSearch':
            if( index === 0 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastDateRangeSearchCategory === categoryInternalName ) {
                return true;
            }
            return false;
        case 'numericRangeSearch':
            if( index === 1 && lastSelectedFilterAndCategoryInfo && lastSelectedFilterAndCategoryInfo.lastNumericRangeSearchCategory === categoryInternalName ) {
                return true;
            }
            return false;
        default:
            return false;
    }
};

export let loadConfiguration = function() {
    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidDate', true ).then( result => _invalidDateText = result );
    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidRange', true ).then( result => _invalidRangeText = result );
    localeSvc.getLocalizedTextFromKey( 'UIMessages.invalidPrefilter', true ).then( result => _invalidPrefilter = result );
};

loadConfiguration();

export default {
    HIERARCHICAL_FACET_SEPARATOR,
    PRESET_CATEGORY,
    DATE_FILTER,
    INTERNAL_DATE_FILTER,
    DATE_RANGE_FILTER,
    DATE_DRILLDOWN_FILTER,
    NUMERIC_RANGE_FILTER,
    INTERNAL_NUMERIC_FILTER,
    INTERNAL_OBJECT_FILTER,
    INTERNAL_NUMERIC_RANGE,
    NUMERIC_FILTER,
    NUMERIC_RANGE,
    NumericRangeBlankStart,
    NumericRangeBlankEnd,
    NO_STARTDATE,
    NO_ENDDATE,
    NO_STARTRANGE,
    NO_ENDRANGE,
    BEGINNING_OF_TIME,
    ENDING_OF_TIME,
    getDate,
    isNullDate,
    validateDates,
    getDateRangeString,
    getDateRangeFilter,
    getDateRangeDisplayString,
    checkIfValidRange,
    validateNumericRangeSelected,
    validateNumericRange,
    getNumericRangeString,
    getNumericRangeFilter,
    getNumericRangeDisplayString,
    getRealFilterWithNoFilterType,
    getFilterTypeFromFilterValue,
    isPresetFilters,
    setPresetFilters,
    getHasTypeFilter,
    setHasTypeFilter,
    setIncontext,
    getIncontext,
    saveIncontextFilterMap,
    getCategoryInternalName,
    getCurrentCategory,
    getPropGroupValues,
    getPropGroupValue,
    getFilterColorRGBValue,
    getFilterColorValue,
    getPropertyFromFilter,
    getFormattedFilterDate,
    getFormattedFilterNumber,
    getRangeSearchFilter,
    getSingleSearchFilter,
    getFilterType,
    displayPrefilterError,
    getPreferenceValue,
    getCustomPropValueColorMap,
    setCustomPropValueColorMap,
    applyCustomColor,
    checkIfFilterValuesExist,
    isLimitedCategoriesFeatureEnabled,
    ifFilterSelectedForCategory,
    isClsCategory,
    ifFilterSelectedForCls,
    getFilterFocus
};
