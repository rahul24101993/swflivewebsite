// Copyright (c) 2020 Siemens

/**
 *
 * @module js/filterPanelService
 * @requires js/filterPanelCommonUtils
 */
import AwStateService from 'js/awStateService';
import appCtxService from 'js/appCtxService';
import localeSvc from 'js/localeService';
import filterPanelUtils from 'js/filterPanelUtils';
import filterPanelCommonUtils from 'js/filterPanelCommonUtils';
import _ from 'lodash';
import 'js/messagingService';

export let DATA_RANGE_FILTER = 'DateRangeFilter';
var YEAR_SUFFIX = '_0Z0_year';
var YEAR_MONTH_SUFFIX = '_0Z0_year_month';
var WEEK_SUFFIX = '_0Z0_week';
var YEAR_MONTH_DAY_SUFFIX = '_0Z0_year_month_day';
var _noFilterValue = '';
var _defaultFilterLimit = 50;

/**
 * Parses boolean
 *
 * @param {String} value to evaluated
 *
 * @returns {Boolean} true or false.
 */
export let parseBoolean = function( value ) {
    if( value === undefined || value === null ) {
        return false;
    }
    return ( /^true$/i ).test( value );
};

/**
 * @function decideExpansionStateOfCategory - if AWC_LIMITED_FILTER_CATEGORIES is true, then if filterValues has length > 0, expand the category
 * @param { Object } category - the current category
 * @param { Integer } defaultFilterFieldDisplayCount - the default number of filters
 */

export let decideExpansionStateOfCategory = ( category, defaultFilterFieldDisplayCount, provider ) => {
    let isLimitedCategoriesEnabled = filterPanelUtils.isLimitedCategoriesFeatureEnabled();
    let isFilterSelectedForCls = filterPanelUtils.ifFilterSelectedForCls( category );
    let isFilterSelected = isFilterSelectedForCls ? true : filterPanelUtils.ifFilterSelectedForCategory( category );
    if( isLimitedCategoriesEnabled && provider === 'Awp0FullTextSearchProvider' ) {
        if( category.filterValues && ( isFilterSelectedForCls || category.filterValues.length > 0 ) && category.expand === undefined ) {
            category.expand = true;
        }
    } else if( ( category.index < defaultFilterFieldDisplayCount || isFilterSelected ) && category.expand === undefined ) {
        category.expand = true;
    }
    return category;
};

/**
 * Returns categories from search response
 *
 * @param {ObjectArray} category categories
 * @param {INTEGER} index index
 * @param {ObjectArray} categories categories
 * @param {ObjectArray} categoryValues category values
 * @param {String} groupProperty property to be grouped on
 * @param {Boolean} colorToggle true if to toggle color
 * @param {Boolean} showRange true if to show range
 * @param {Array} categoryHasMoreFacetValuesList list of categories which have more filters on the server side
 * @param {Object} defaultFilterFieldDisplayCountFromSOA the number of categories to show by default expanded
 * @param {String} provider the search provider name
 * @param {Boolean} showExtraChips - whether to show extra breadcrumb chips
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 */
export let getCategories2Int = (
    category,
    index,
    categories,
    categoryValues,
    groupProperty,
    colorToggle,
    showRange,
    categoryHasMoreFacetValuesList,
    defaultFilterFieldDisplayCountFromSOA,
    provider,
    showExtraChips,
    lastSelectedFilterAndCategoryInfo ) => {
    // getCategories2 internal function
    category.index = index;
    category.showExpand = true;
    category.currentCategory = '';
    category.showEnabled = false;
    var _colorToggle = parseBoolean( colorToggle );
    category.showColor = _colorToggle;

    var defaultFilterFieldDisplayCount = defaultFilterFieldDisplayCountFromSOA ? defaultFilterFieldDisplayCountFromSOA : 10;

    var isLimitedCategoriesEnabled = filterPanelUtils.isLimitedCategoriesFeatureEnabled();

    var catName = category.internalName;
    if( groupProperty.hasOwnProperty( 'internalPropertyName' ) ) {
        groupProperty = groupProperty.internalPropertyName;
    }
    var i = groupProperty.indexOf( '.' );
    if( i === -1 ) {
        i = category.internalName.indexOf( '.' );
        catName = category.internalName.substring( i + 1, category.internalName.length );
    }

    category = filterPanelCommonUtils.processCatGroupProperty( catName, groupProperty, category );

    category.filterValues = getFiltersForCategory( category, categoryValues, groupProperty, _colorToggle, lastSelectedFilterAndCategoryInfo );
    category = decideExpansionStateOfCategory( category, defaultFilterFieldDisplayCount, provider );

    category = filterPanelCommonUtils.processCategoryHasMoreFacetValues( category, categoryHasMoreFacetValuesList );

    if( category.filterValues.length > category.defaultFilterValueDisplayCount * 2 || category.hasMoreFacetValues ) {
        category.showFilterText = true;
    }

    category.filterLimitForCategory = getFilterLimitForCategory( category );

    category = filterPanelCommonUtils.processFilterCategories( showRange, category, categoryValues, showExtraChips );

    // Set category parameters required to differentiate a populated category from an unpopulated one.
    category = setParametersForPopulatedCategory( category );

    categories = filterPanelCommonUtils.processSelectedPopulatedCategories( isLimitedCategoriesEnabled, category, categories );
};

/**
 * Returns categories from search response
 *
 * @param {ObjectArray} inputForGetCategories input for constructing categories
 * @returns {Array} The array of categories.
 */
export let getCategories2 = ( inputForGetCategories ) => {
    if( inputForGetCategories.searchFilterCategories === undefined ) {
        return undefined;
    }
    let categories = _.cloneDeep( inputForGetCategories.searchFilterCategories );

    //This function reads the “AWC_CustomPropValueColor” preference value.
    //This is used to overide filter color in filter panel.
    filterPanelUtils.getPreferenceValue();

    categories.refineCategories = [];
    categories.navigateCategories = [];
    // Currently, shape search does not provide group property in performsearch call. It calls groupByProperties separately.
    // So default groupProperty to the first category
    let groupProperty = inputForGetCategories.groupProperty;
    if( groupProperty === undefined && categories.length > 0 ) {
        groupProperty = categories[ 0 ].internalName;
    }

    _.forEach( categories, function( category, index ) {
        getCategories2Int(
            category,
            index,
            categories,
            inputForGetCategories.categoryValues,
            groupProperty,
            inputForGetCategories.colorToggle,
            inputForGetCategories.showRange,
            inputForGetCategories.categoryHasMoreFacetValuesList,
            inputForGetCategories.defaultFilterFieldDisplayCountFromSOA,
            inputForGetCategories.provider,
            inputForGetCategories.showExtraChips,
            inputForGetCategories.lastSelectedFilterAndCategoryInfo
        );
    } );

    if( !inputForGetCategories.skipUnpopulated ) {
        appendUnpopulatedCategories( categories, inputForGetCategories.unpopulatedSearchFilterCategories );
    }

    return categories;
};

/**
 * Returns categories from search response
 *
 * @param {Object} searchState search state info
 * @param {Boolean} showRange whether to show the range boxes for numeric and date categories
 * @returns {ObjectArray} The categories to show in the filter panel.
 */
export let getCategories3 = ( searchState, showRange ) =>{
    const categoryValues = searchState.searchFilterMap;
    if( !categoryValues ) {
        return [];
    }
    const groupProperty = searchState.objectsGroupedByProperty && searchState.objectsGroupedByProperty.internalPropertyName;
    const categoryHasMoreFacetValuesList = searchState.hasMoreFacetValues;
    const defaultFilterFieldDisplayCountFromSOA = searchState.defaultFilterFieldDisplayCount;
    const provider = searchState.provider;
    const colorToggle = searchState.colorToggle;
    const searchFilterCategories = searchState.searchFilterCategories;
    const unpopulatedSearchFilterCategories = searchState.unpopulatedSearchFilterCategories;
    const displayNamesOfPropsInFilterMap = searchState.additionalSearchInfoMap && searchState.additionalSearchInfoMap.displayNamesOfPropsInFilterMap ?
        searchState.additionalSearchInfoMap.displayNamesOfPropsInFilterMap : [];
    const showExtraChips = displayNamesOfPropsInFilterMap && displayNamesOfPropsInFilterMap.length > 0;
    const lastSelectedFilterAndCategoryInfo = searchState.lastSelectedFilterAndCategoryInfo;
    const inputForGetCategories = {
        searchFilterCategories: searchFilterCategories,
        categoryValues: categoryValues,
        groupProperty: groupProperty,
        colorToggle: colorToggle,
        showRange: showRange,
        categoryHasMoreFacetValuesList: categoryHasMoreFacetValuesList,
        defaultFilterFieldDisplayCountFromSOA: defaultFilterFieldDisplayCountFromSOA,
        provider: provider,
        unpopulatedSearchFilterCategories: unpopulatedSearchFilterCategories,
        skipUnpopulated: false,
        showExtraChips: showExtraChips,
        lastSelectedFilterAndCategoryInfo: lastSelectedFilterAndCategoryInfo
    };
    let categories = getCategories2( inputForGetCategories );
    let orderedCategories = [];
    _.forEach( categories.navigateCategories, ( eachNavigateCategory ) => {
        orderedCategories.push( eachNavigateCategory );
    } );
    _.forEach( categories.refineCategories, ( eachRefineCategory ) => {
        orderedCategories.push( eachRefineCategory );
    } );
    return orderedCategories;
};

/**
 * Set category parameters required to differentiate a populated category from unpopulated ones.
 * @param {Object} category The input category
 * @returns {Object} category
 */
export let setParametersForPopulatedCategory = ( category ) => {
    // isSelected is used to identify an empty category that has just been populated.
    if( category.isSelected === undefined ) {
        category.isSelected = false;
    }

    // isPopulated will differentiate empty categories from populated categories
    category.isPopulated = Boolean( category.filterValues && ( _.isArray( category.filterValues ) && category.filterValues.length > 0
        || !_.isArray( category.filterValues ) ) );

    // isServerSearch will determine whether to route a filter-in-values search within a category to server
    if( category.isServerSearch === undefined ) {
        category.isServerSearch = category.hasMoreFacetValues;

        // Ensure category with different internal and display names are always filtered on client
        if( category.isServerSearch && category.internalName === 'Categorization.category' ) {
            category.isServerSearch = false;
        }
    }

    return category;
};

/**
 * Appends unpopulated/empty categories to the list of populated categories.
 *
 * @param {ObjectArray} categories categories
 * @param {ObjectArray} unpopulatedSearchFilterCategories unpopulated search filter categories
 * @returns {ObjectArray} The array of categories to be displayed.
 */
export let appendUnpopulatedCategories = ( categories, unpopulatedSearchFilterCategories ) => {
    if( categories === undefined ) {
        categories = [];
    }
    if( categories.refineCategories === undefined ) {
        categories.refineCategories = [];
    }

    if( !unpopulatedSearchFilterCategories || unpopulatedSearchFilterCategories && unpopulatedSearchFilterCategories.length === 0 ) {
        return undefined;
    }

    // Temporary container to hold classification categories for sorting later on
    var classificationCategories = [];
    _.forEach( unpopulatedSearchFilterCategories, function( emptyCategory ) {
        emptyCategory = filterPanelCommonUtils.processEmptyCategory( emptyCategory );
        if( emptyCategory && emptyCategory.internalName && emptyCategory.internalName.substr( 0, 4 ) === 'CLS.' ) {
            classificationCategories.push( emptyCategory );
        } else {
            categories.refineCategories.push( emptyCategory );
        }
    } );

    // Sort classification categories alphabetically
    classificationCategories.sort( function( a, b ) {
        if( a.displayName && b.displayName ) {
            return a.displayName.toUpperCase().localeCompare( b.displayName.toUpperCase() );
        }
    } );

    Array.prototype.push.apply( categories.refineCategories, classificationCategories );

    return categories;
};

/**
 * Returns the filterLimitForCategory value for a given category.
 *
 * @param {Object} category the given category
 *
 * @returns {INTEGER} the filter show count for the given category
 */
export let getFilterLimitForCategory = ( category ) => {
    var filterLimitForCategory = _defaultFilterLimit;
    var preferences = appCtxService.getCtx( 'preferences' );
    if( preferences !== undefined ) {
        var filterLimits = preferences.AWC_Category_Filter_Show_Count;
        if( filterLimits && _.isArray( filterLimits ) ) {
            _.forEach( filterLimits, function( filterLimit ) {
                var filterCount = _.split( filterLimit, '=' );
                if( _.startsWith( filterLimit, category.internalName + '=' ) ) {
                    filterLimitForCategory = _.toInteger( filterCount[ 1 ] );
                    if( filterCount[ 1 ] === 'ALL' ) {
                        filterLimitForCategory = Number.MAX_SAFE_INTEGER;
                    } else if( filterCount[ 1 ] === 'HIDDEN' ) {
                        filterLimitForCategory = 0;
                    } else if( _.toInteger( filterCount[ 1 ] ) < category.defaultFilterValueDisplayCount ) {
                        filterLimitForCategory = category.defaultFilterValueDisplayCount;
                    }
                    return filterLimitForCategory;
                } else if( _.startsWith( filterLimit, 'Default=' ) ) {
                    var defaultCount = _.split( filterLimit, '=' );
                    if( _.toInteger( defaultCount[ 1 ] ) > 0 ) {
                        _defaultFilterLimit = _.toInteger( defaultCount[ 1 ] );
                        filterLimitForCategory = _defaultFilterLimit;
                    } else {
                        filterLimitForCategory = _defaultFilterLimit;
                    }
                }
            } );
        } else {
            filterLimitForCategory = _defaultFilterLimit;
        }
    } else {
        return filterLimitForCategory;
    }
    return filterLimitForCategory;
};

/**
 * Returns the filter values for a category based on the type.
 *
 * @param {Object} category from the getCategoryValues
 * @param {Object} categoryValues from the getCategoryValues
 * @param {Object} groupProperty category grouped by
 * @param {Object} colorToggle true if color bar is shown
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of filters for category
 */
export let getFiltersForCategory = ( category, categoryValues, groupProperty, colorToggle, lastSelectedFilterAndCategoryInfo ) => {
    var filterValues = [];
    var internalName = category.internalName;
    var values = categoryValues[ internalName ];
    if( values && values.length > 0 ) {
        category.type = values[ 0 ].searchFilterType;
        switch( category.type ) {
            case 'DateFilter': {
                filterValues = getDateFiltersForCategory( category, categoryValues, groupProperty, colorToggle, lastSelectedFilterAndCategoryInfo );
                break;
            }
            case 'RadioFilter':
                filterValues = getToggleFiltersForCategory( category, values, lastSelectedFilterAndCategoryInfo );
                break;
            case 'ObjectFilter':
                filterValues = getTypeFiltersForCategory( category, values, null, null, lastSelectedFilterAndCategoryInfo );
                break;
            default:
                filterValues = getTypeFiltersForCategory( category, values, groupProperty, colorToggle, lastSelectedFilterAndCategoryInfo );
                break;
        }
    }
    category.filterCount = filterValues.length;
    return filterValues;
};

/**
 * Returns filter values for a date category. List contains all years or selected year and months under it
 *
 * @param {Object} category from the getCategoryValues *
 * @param {ObjectArray} categoryValues from the getCategoryValues
 * @param {Object} groupProperty category grouped by
 * @param {Object} colorToggle true if color bar is shown
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of filters for category
 */
function getTypeFiltersForCategory( category, categoryValues, groupProperty, colorToggle, lastSelectedFilterAndCategoryInfo ) {
    let internalName = category.internalName;
    let catName = category.internalName;
    let i = groupProperty && groupProperty.indexOf( '.' );
    if( i === -1 ) {
        i = internalName.indexOf( '.' );
        catName = internalName.substring( i + 1, category.internalName.length );
    }

    let color = colorToggle && catName === groupProperty;

    // Set the color on the first "defaultFilterValueDisplayCount" values and any values that are selected (in that order)
    // Skip numeric range filters for coloring. The filter display count needs to be adjusted accordingly
    let filterDisplayCount = category.defaultFilterValueDisplayCount;
    let tmpValsToSetColor = categoryValues.filter( function( categoryValue, index ) {
        if( categoryValue.startEndRange === 'NumericRange' ) {
            filterDisplayCount++;
        }
        return ( index < filterDisplayCount || categoryValue.selected ) &&
            categoryValue.startEndRange !== 'NumericRange';
    } );

    let valsToSetColor;
    // Colors can only be shown on first 9. Remove items as necessary
    if( tmpValsToSetColor.length < 9 ) {
        valsToSetColor = tmpValsToSetColor;
    } else {
        valsToSetColor = tmpValsToSetColor.filter( function( categoryValue, index ) {
            return index < 9;
        } );
    }

    // Create a filter value for each category value
    let filterValues = categoryValues.map( function( categoryValue ) {
        // Pass -1 as index of category should not have a color
        let filterValue = getFilterValue( internalName, categoryValue, color, valsToSetColor
            .indexOf( categoryValue ), lastSelectedFilterAndCategoryInfo );
        if( category.type === 'NumericFilter' ) {
            filterValue.startNumericValue = categoryValue.startNumericValue;
            filterValue.endNumericValue = categoryValue.endNumericValue;
            filterValue.startEndRange = categoryValue.startEndRange;
        }
        return filterValue;
    } );
    // Put the selected filters first
    return filterValues.filter( function( val ) {
        return val.selected.dbValue;
    } ).concat( filterValues.filter( function( val ) {
        return !val.selected.dbValue;
    } ) );
}
/**
 * @param {Object} categoryValue - category value
 * @return {String} filter display value
 */
function getFilterDisplayName( categoryValue ) {
    if( categoryValue.stringValue === '$NONE' && categoryValue.stringDisplayValue === '' ) {
        return _noFilterValue;
    }
    return categoryValue.stringDisplayValue;
}

/**
 * Returns filter values for a date category. List contains all years or selected year and months under it
 *
 * @param {Object} category category
 * @param {ObjectArray} categoryValues category values
 * @param {String} groupProperty property to be grouped on
 * @param {Boolean} colorToggle true if to toggle color
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of child node objects to be displayed.
 */
function getDateFiltersForCategory( category, categoryValues, groupProperty, colorToggle, lastSelectedFilterAndCategoryInfo ) {
    var filterValues = [];

    var internalName = category.internalName + YEAR_SUFFIX;
    var color = colorToggle && internalName.indexOf( groupProperty ) !== -1;

    var values = categoryValues[ internalName ];
    if( !values ) {
        internalName = category.internalName + YEAR_MONTH_SUFFIX;
        values = categoryValues[ internalName ];
        if( !values ) {
            internalName = category.internalName + WEEK_SUFFIX;
            values = categoryValues[ internalName ];
        }
        if( !values ) {
            internalName = category.internalName + YEAR_MONTH_DAY_SUFFIX;
            values = categoryValues[ internalName ];
        }
        if( values ) {
            filterValues = addAllDates( category, internalName, values, color, 0, undefined, lastSelectedFilterAndCategoryInfo );
        }
        return filterValues;
    }
    var selectedYear = isDateFilterSelected( values );
    if( selectedYear === null ) {
        // add all years
        filterValues = addAllDates( category, internalName, values, color, 0, undefined, lastSelectedFilterAndCategoryInfo );
    } else {
        // add selected year and months for the year
        filterValues.push( getDateFilterValue( category, internalName, selectedYear, color, 0, 0, lastSelectedFilterAndCategoryInfo ) );
        var monthValues = getDateFiltersForYear( category, categoryValues, groupProperty, colorToggle, selectedYear, lastSelectedFilterAndCategoryInfo );
        for( var i = 0; i < monthValues.length; i++ ) {
            filterValues.push( monthValues[ i ] );
        }
    }

    return filterValues;
}

/**
 * Returns filter values for a date year category. List contains all months or selected month and weeks under it
 *
 * @param {Object} category category
 * @param {ObjectArray} categoryValues category values
 * @param {String} groupProperty property to be grouped on
 * @param {Boolean} colorToggle true if to toggle color
 * @param {Object} selectedYear Year currently selected
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of filters for category
 */
function getDateFiltersForYear( category, categoryValues, groupProperty, colorToggle, selectedYear, lastSelectedFilterAndCategoryInfo ) {
    var filterValues = [];
    var internalName = category.internalName + YEAR_MONTH_SUFFIX;
    var color = colorToggle && internalName.indexOf( groupProperty ) !== -1;

    var values = categoryValues[ internalName ];
    if( !values ) {
        values = [];
    }
    var selectedMonth = isDateFilterSelected( values );
    if( selectedMonth === null ) {
        // add all months
        filterValues = addAllDates( category, internalName, values, color, 1, selectedYear, lastSelectedFilterAndCategoryInfo );
    } else {
        // add selected month and weeks for the month
        filterValues.push( getDateFilterValue( category, internalName, selectedMonth, color, 0, 1, lastSelectedFilterAndCategoryInfo ) );
        var weekValues = getDateFiltersForYearMonth( category, categoryValues, groupProperty, colorToggle, selectedMonth, lastSelectedFilterAndCategoryInfo );
        for( var i = 0; i < weekValues.length; i++ ) {
            filterValues.push( weekValues[ i ] );
        }
    }

    return filterValues;
}

/**
 * Returns filter values for a category. List contains all weeks or selected week and days under it
 *
 * @param {Object} category category
 * @param {ObjectArray} categoryValues category values
 * @param {String} groupProperty property to be grouped on
 * @param {Boolean} colorToggle true if to toggle color
 * @param {Object} selectedMonth Year-Month currently selected
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of filters for category
 */
function getDateFiltersForYearMonth( category, categoryValues, groupProperty, colorToggle, selectedMonth, lastSelectedFilterAndCategoryInfo ) {
    var filterValues = [];
    var internalName = category.internalName + WEEK_SUFFIX;
    var color = colorToggle && internalName.indexOf( groupProperty ) !== -1;

    var values = categoryValues[ internalName ];
    if( !values ) {
        values = [];
    }
    var selectedWeek = isDateFilterSelected( values );
    if( selectedWeek === null ) {
        // add all months
        filterValues = addAllDates( category, internalName, values, color, 2, selectedMonth, lastSelectedFilterAndCategoryInfo );
    } else {
        // add selected week and days for the week
        filterValues.push( getDateFilterValue( category, internalName, selectedWeek, color, 0, 2, lastSelectedFilterAndCategoryInfo ) );
        var dayValues = getDateFiltersForYearMonthDay( category, categoryValues, groupProperty, colorToggle, selectedWeek, lastSelectedFilterAndCategoryInfo );
        for( var i = 0; i < dayValues.length; i++ ) {
            filterValues.push( dayValues[ i ] );
        }
    }

    return filterValues;
}

/**
 * Returns filter values for a category. List contains all days under the week
 *
 * @param {Object} category category
 * @param {ObjectArray} categoryValues category values
 * @param {String} groupProperty property to be grouped on
 * @param {Boolean} colorToggle true if to toggle color
 * @param {Object} selectedWeek Week currently selected
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of filters for category
 */
function getDateFiltersForYearMonthDay( category, categoryValues, groupProperty, colorToggle, selectedWeek, lastSelectedFilterAndCategoryInfo ) {
    var filterValues = [];
    var internalName = category.internalName + YEAR_MONTH_DAY_SUFFIX;
    var color = colorToggle && internalName.indexOf( groupProperty ) !== -1;

    var values = categoryValues[ internalName ];
    if( values ) {
        if( typeof selectedWeek !== 'undefined' ) {
            var startTime = new Date( selectedWeek.startDateValue ).getTime();
            var endTime = new Date( selectedWeek.endDateValue ).getTime();
            values = values.filter( function( filterItem ) {
                var startTimeForDay = new Date( filterItem.startDateValue ).getTime();
                var endTimeForDay = new Date( filterItem.endDateValue ).getTime();
                if( startTimeForDay >= startTime && endTimeForDay <= endTime ) {
                    return true;
                }
                return false;
            } );
        }
        for( var i = 0; i < values.length; i++ ) {
            filterValues.push( getDateFilterValue( category, internalName, values[ i ], color, i, 3, lastSelectedFilterAndCategoryInfo ) );
        }
    }

    return filterValues;
}

/**
 * Returns all dates for a given year, month or week.
 *
 * @param {Object} category - category
 * @param {String} internalName - internal name
 * @param {Array} values - set of dates
 * @param {String} color - color
 * @param {Object} drilldown - drill down
 * @param {Object} selectedDate - Currently selected year/month/week
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @return {Object} filter
 */
function addAllDates( category, internalName, values, color, drilldown, selectedDate, lastSelectedFilterAndCategoryInfo ) {
    var filterValuesToAdd = values;
    if( selectedDate && selectedDate.startDateValue && selectedDate.endDateValue ) {
        var startTime = new Date( selectedDate.startDateValue ).getTime();
        var endTime = new Date( selectedDate.endDateValue ).getTime();
        filterValuesToAdd = filterValuesToAdd.filter( function( filterItem ) {
            if( new Date( filterItem.startDateValue ).getTime() >= startTime && new Date( filterItem.endDateValue ).getTime() <= endTime ) {
                return true;
            }
            return false;
        } );
    }
    // Create a filter value for each category value
    return filterValuesToAdd.map( function( value, index ) {
        // Pass -1 as index of category should not have a color
        return getDateFilterValue( category, internalName, value, color, index, drilldown, lastSelectedFilterAndCategoryInfo );
    } )

        // Remove color from filters that should not have a filter
        .map( function( filter, index ) {
            // dirty map, modifies data
            filter.color = index < category.defaultFilterValueDisplayCount ? filter.color : '';
            return filter;
        } );
}

/**
 * Returns true if a a date is selected in the given list
 *
 * @param {ObjectArray} values set of dates.
 * @returns {Boolean} true if filter is selected.
 */
function isDateFilterSelected( values ) {
    return isFilterSelected( values, false );
}

/**
 * Returns true if a a date is selected in the given list
 *
 * @param {ObjectArray} values set of dates.
 * @param {Boolean} flag flag.
 * @returns {Boolean} true if filter is selected.
 */
function isFilterSelected( values, flag ) {
    var selectedValue = null;
    for( var i = 0; i < values.length; i++ ) {
        if( values[ i ].selected === true ) {
            selectedValue = values[ i ];
            if( flag ) {
                selectedValue.index = i;
            }
            break;
        }
    }
    return selectedValue;
}

/**
 * Returns a given date filter's value
 * @param {Object} category category
 * @param {String} categoryName category name
 * @param {Object} categoryValue category value
 * @param {String} color color
 * @param {Integer} index index
 * @param {Bollean} drilldown true if to drill down
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {Object} filter value
 */
function getDateFilterValue( category, categoryName, categoryValue, color, index, drilldown, lastSelectedFilterAndCategoryInfo ) {
    var filterValue = {};
    var filterIndex = drilldown + index;
    filterValue = getFilterValue( categoryName, categoryValue, color, filterIndex, lastSelectedFilterAndCategoryInfo );
    if( filterIndex >= category.defaultFilterValueDisplayCount + drilldown || filterIndex >= 9 ) {
        filterValue.colorIndex = -1;
    }

    filterValue.startDateValue = categoryValue.startDateValue;
    filterValue.endDateValue = categoryValue.endDateValue;
    filterValue.drilldown = drilldown;
    if( drilldown > 0 ) {
        filterValue.type = 'DrilldownDateFilter';
        filterValue.showDrilldown = true;
    } else {
        filterValue.type = 'DateFilter';
    }
    return filterValue;
}

/**
 * Returns a given filter's value
 * @param {String} categoryName category name
 * @param {Object} categoryValue category value
 * @param {String} color color
 * @param {Integer} index index
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {Object} filter value
 */
function getFilterValue( categoryName, categoryValue, color, index, lastSelectedFilterAndCategoryInfo ) {
    var filterValue = {};
    filterValue.categoryName = categoryName;
    filterValue.internalName = categoryValue.stringValue;
    filterValue.name = getFilterDisplayName( categoryValue );
    filterValue.count = categoryValue.count;
    let autoFocus = filterPanelUtils.getFilterFocus( lastSelectedFilterAndCategoryInfo, filterValue, categoryName, index );
    filterValue.autoFocus = autoFocus;
    filterValue.selected = {
        displayName: categoryValue.count > 0 ? `${filterValue.name} (${categoryValue.count})` : `${filterValue.name}`,
        uiValue: categoryValue.count > 0 ? `${filterValue.name} (${categoryValue.count})` : `${filterValue.name}`,
        dbValue: categoryValue.selected
    };
    // filterValue.type = categoryValue.searchFilterType;
    filterValue.showCount = filterValue.count;
    filterValue.showSuffixIcon = false;
    filterValue.drilldown = 0;

    filterPanelUtils.applyCustomColor( categoryName, categoryValue, filterValue );

    // if current category, set colors for first 5 items
    if( color ) {
        filterValue.showColor = true;
        if( index > -1 && !filterValue.color ) {
            filterValue.color = filterPanelUtils.getFilterColorValue( index );
        }
    }
    filterValue.colorIndex = index;

    return filterValue;
}

/**
 * Returns filter values for a radio category. List contains all years or selected year and months under it
 *
 * @param {Object} category the category
 * @param {ObjectArray} categoryValues the category values
 * @param {Object} lastSelectedFilterAndCategoryInfo last selected filter and category info
 * @returns {ObjectArray} The array of radio filters for category
 */
function getToggleFiltersForCategory( category, categoryValues, lastSelectedFilterAndCategoryInfo ) {
    var internalName = category.internalName;

    // Create a filter value for each category value
    return categoryValues.map( function( categoryValue ) {
        return getFilterValue( internalName, categoryValue, null, null, lastSelectedFilterAndCategoryInfo );
    } );
}

/**
 * Simple wrapper around $state.go with new searchCriteria
 *
 * @param {String} searchCriteria search criteria
 * @param {String} searchState search state
 * @returns {Object} routing return.
 */
export let simpleSearch = ( searchCriteria, searchState ) => {
    return AwStateService.instance.go( searchState ? searchState : '.', {
        searchCriteria: searchCriteria
    } );
};

export let loadConfiguration = () => {
    localeSvc.getLocalizedTextFromKey( 'UIMessages.noFilterValue', true ).then( result => _noFilterValue = result );
};

loadConfiguration();

export default {
    DATA_RANGE_FILTER,
    parseBoolean,
    decideExpansionStateOfCategory,
    getCategories2Int,
    getCategories2,
    getCategories3,
    getFiltersForCategory,
    getFilterLimitForCategory,
    simpleSearch,
    loadConfiguration,
    setParametersForPopulatedCategory,
    appendUnpopulatedCategories
};
