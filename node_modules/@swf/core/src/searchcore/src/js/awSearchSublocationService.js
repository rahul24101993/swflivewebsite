// Copyright (c) 2021 Siemens

/**
 * @module js/awSearchSublocationService
 */
import _ from 'lodash';
import searchFilterService from 'js/aw.searchFilter.service';
import filterPanelUtils from 'js/filterPanelUtils';
import appCtxService from 'js/appCtxService';
import AwStateService from 'js/awStateService';
import localeService from 'js/localeService';
import searchStateHelperService from 'js/searchStateHelperService';
import { tabCallbackApi } from 'js/awSearchLocationService';
import selectionService from 'js/selection.service';
import Debug from 'debug';

const trace = new Debug( 'selection' );

export const updateSearchContext = ( provider ) => {
    // Set the sort criteria for sublocation if its not already populated in ctx.ClientScopeURI.sortCriteria
    // This sort criteria will be shared across all views in a sublocation in a given session.
    var sortCriteria = appCtxService.getCtx( provider.clientScopeURI + '.sortCriteria' );
    if( sortCriteria === undefined || sortCriteria === '' ) {
        appCtxService.updatePartialCtx( provider.clientScopeURI + '.sortCriteria', [] );
        appCtxService.updatePartialCtx( 'sublocation.sortCriteria', [] );
    } else {
        appCtxService.updatePartialCtx( 'sublocation.sortCriteria', sortCriteria );
    }
};

/**
 * This API would re-create the VMO's from the URL on Mount of subLocation.
 * @param {*} searchString
 * @param {*} totalFound
 * @param {*} provider
 */
export const createStateFromUrl = ( provider, searchStateProp, searchState, searchStateUpdater, skipURL, searchCriteria, pwaSelectionModel ) => {
    if( skipURL ) {
        return;
    }

    const [ defaultSearchStateData, updateAtomicData ] = getSearchState( searchStateProp, searchState, searchStateUpdater );
    const stateProvider = AwStateService.instance;
    const changedParams = stateProvider.params;
    const searchContext = provider.context && provider.context.search ? provider.context.search : {};
    const providerSelectionQueryParamKey = provider.selectionQueryParamKey ? provider.selectionQueryParamKey : 's_uid';
    let selectionQueryParamValue;
    let selectionQueryParamKey;
    let searchString = '';
    let filterStringFromUrl = '';
    if( changedParams.hasOwnProperty( 'searchCriteria' ) ) {
        searchString = changedParams.searchCriteria ? changedParams.searchCriteria : searchString;
    }
    if( changedParams.hasOwnProperty( 'filter' ) ) {
        filterStringFromUrl = changedParams.filter ? changedParams.filter : filterStringFromUrl;
    }
    if( changedParams.hasOwnProperty( providerSelectionQueryParamKey ) ) {
        selectionQueryParamValue = changedParams[ providerSelectionQueryParamKey ];
        selectionQueryParamKey = providerSelectionQueryParamKey;
    }
    const bcLabel = stateProvider.current.data && stateProvider.current.data.label ? stateProvider.current.data.label : '';
    let updatedSearchContext = searchStateHelperService.constructBaseSearchCriteria( searchContext, changedParams );
    const searchStateData = { ...updatedSearchContext };
    const chartTitle = searchContext.chartTitle; // Need to evaluate from props.chartTitle i18n
    let promise = chartTitle ? localeService.getLocalizedText( chartTitle.source, chartTitle.key ) : new Promise( ( resolve ) => resolve() );
    let searchStr = searchStateData.criteria && searchStateData.criteria.hasOwnProperty( 'searchString' ) &&
        searchStateData.criteria.searchString.length > 0 ? searchStateData.criteria.searchString : searchString;
    return promise.then( ( chartTitleValue ) => {
        const { activeFilterMap } = createSearchFilterMapFromUrl( provider );
        const activeFilters = searchFilterService.getFilters();
        searchStateData.criteria = Object.assign( {}, searchStateData.criteria, searchCriteria );
        searchStateData.criteria.searchString = searchStr;
        let resolvedData = {
            searchStringPrimary: searchStr,
            searchStringSecondary: '',
            label: bcLabel,
            filterString: filterStringFromUrl,
            totalFound: searchContext.showLoadingText ? undefined : 0,
            loadDataAction: searchContext.loadDataAction,
            provider: searchContext.provider,
            sortType: searchContext.sortType,
            chartTitle: chartTitleValue,
            objectsGroupedByProperty: null,
            activeFilters: activeFilters,
            activeFilterMap: activeFilterMap,
            searchInProgress: searchStr && searchStr.length > 0 || filterStringFromUrl && filterStringFromUrl.length > 0,
            searchFilterMap: {},
            selectionQueryParam: {
                key: selectionQueryParamKey,
                value: selectionQueryParamValue
            }
        };
        Object.assign( searchStateData, resolvedData );
        if( updateAtomicData ) {
            updateAtomicData( searchStateData );
        } else {
            defaultSearchStateData.update( searchStateData );
        }
        updateSearchPWASelectionModel( pwaSelectionModel, resolvedData.selectionQueryParam );
    } );
};

export const createSearchFilterMapFromUrl = ( provider ) => {
    let searchContext = searchFilterService.buildSearchFilters( provider.context );
    return {
        activeFilterMap: searchContext.activeFilterMap
    };
};

export const getSearchFilterStringFromActiveFilterMap = ( activeFilters ) => {
    let searchFilterMap = {};
    if( activeFilters && activeFilters.length > 0 ) {
        for( let index = 0; index < activeFilters.length; index++ ) {
            let eachActiveFilterCategory = activeFilters[ index ];
            searchFilterMap[ eachActiveFilterCategory.name ] = eachActiveFilterCategory.values;
        }
    }
    return searchFilterService.buildFilterString( searchFilterMap );
};

export const getActiveFilters = ( searchFilterCategories ) => {
    const allSelectedFilters = searchFilterCategories.map( ( category ) => {
        if( category && category.filterValues && category.filterValues.length > 0 ) {
            return category.filterValues.filter( ( filterObject ) => {
                return filterObject.selected.value;
            } );
        }
        return [];
    } );
    return _.flatten( allSelectedFilters );
};

export const lazyUpdate = ( searchState, updateAtomicData ) => {
    // update URL if there are selection in filter panel
    if( searchState && searchState.activeFilters ) {
        let searchCriteria = AwStateService.instance.params.searchCriteria;
        const filterString = searchFilterService.buildFilterString( searchState.activeFilters );
        if( searchState.filterString !== filterString && ( searchState.autoApplyFilters || searchState.bulkFiltersApplied ) ) {
            const selectedFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( searchState.activeFilters );
            let updatedCriteria = searchStateHelperService.getCriteriaAfterFilterSelection( searchState );
            let forceChart = searchStateHelperService.getForceChartParameterValue( searchState );
            searchFilterService.doSearch( null, updatedCriteria ? updatedCriteria.searchString : null, searchState.activeFilters );
            if( updateAtomicData ) {
                updateAtomicData( {
                    ...searchState,
                    criteria: updatedCriteria,
                    forceChart: forceChart,
                    filterString: filterString,
                    activeFilterMap: selectedFiltersInfo.activeFilterMap,
                    searchInProgress: true,
                    categories: undefined,
                    additionalSearchString: undefined
                } );
            } else {
                let newSearchState = { ...searchState.value };
                newSearchState.criteria = updatedCriteria;
                newSearchState.forceChart = forceChart;
                newSearchState.filterString = filterString;
                newSearchState.activeFilterMap = selectedFiltersInfo.activeFilterMap;
                newSearchState.searchInProgress = true;
                newSearchState.categories = undefined;
                newSearchState.additionalSearchString = undefined;
                searchState.update( newSearchState );
            }
        } else if( filterString !== searchState.selectedFiltersString && !searchState.autoApplyFilters && !searchState.bulkFiltersApplied ) {
            searchState.selectedFiltersString = filterString;
            const pendingFilterMapInfo = searchFilterService.getPendingFiltersMap( searchState.activeFilters, searchState.activeFilterMap );
            const positivePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( pendingFilterMapInfo.positivePendingFilterMap );
            const negativePendingFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( pendingFilterMapInfo.negativePendingFilterMap );
            if( updateAtomicData ) {
                updateAtomicData( {
                    ...searchState,
                    positivePendingFilters: positivePendingFiltersInfo.activeFilters,
                    negativePendingFilters: negativePendingFiltersInfo.activeFilters,
                    positivePendingFilterMap: positivePendingFiltersInfo.activeFilterMap,
                    negativePendingFilterMap: negativePendingFiltersInfo.activeFilterMap
                } );
            } else {
                let newSearchState = { ...searchState.value };
                newSearchState.positivePendingFilters = positivePendingFiltersInfo.activeFilters;
                newSearchState.negativePendingFilters = negativePendingFiltersInfo.activeFilters;
                newSearchState.positivePendingFilterMap = positivePendingFiltersInfo.activeFilterMap;
                newSearchState.negativePendingFilterMap = negativePendingFiltersInfo.activeFilterMap;
                searchState.update( newSearchState );
            }
        } else if( searchCriteria && searchState.criteria && searchState.criteria.searchString !== searchCriteria ) {
            searchFilterService.doSearch( null, searchState.criteria.searchString, searchState.activeFilters );
            if( updateAtomicData ) {
                updateAtomicData( { ...searchState, categories: undefined } );
            } else {
                let newSearchState = { ...searchState.value };
                newSearchState.categories = undefined;
                searchState.update( newSearchState );
            }
        }
    } else if( AwStateService.instance.params.filter ) {
        //Or no change in filter panel but prefilter is changed
        if( searchState.filterString !== AwStateService.instance.params.filter ) {
            if( updateAtomicData ) {
                updateAtomicData( { ...searchState, filterString: AwStateService.instance.params.filter } );
            } else {
                let newSearchState = { ...searchState.value };
                newSearchState.filterString = AwStateService.instance.params.filter;
                searchState.update( newSearchState );
            }
        }
    }
};

let debounceUpdateURL = _.debounce( ( searchState, updateAtomicData ) => {
    lazyUpdate( searchState, updateAtomicData );
}, 800 );

export const updateURL = ( searchStateProp, searchState, searchStateUpdater, skipURL ) => {
    if( skipURL ) {
        return;
    }
    const [ searchStateData, updateAtomicData ] = getSearchState( searchStateProp, searchState, searchStateUpdater );
    debounceUpdateURL( searchStateData, updateAtomicData );
};

export const updateSearchCriteria = ( searchStateAtomicDataRef, searchStateUpdater, searchCriteria ) => {
    let searchState = searchStateAtomicDataRef.getAtomicData();
    const criteria = Object.assign( {}, searchState.criteria, searchCriteria );
    searchStateUpdater.searchState( { ...searchState, criteria } );
};

const getSearchState = ( searchStateProp, searchState, searchStateUpdater ) => {
    const searchStateData = searchStateProp ? searchStateProp : searchState;
    if( searchStateProp && searchStateProp.update ) {
        return [ searchStateData, undefined ];
    }
    return [ searchStateData, searchStateUpdater.searchState ];
};

export const syncStateFromUrl = ( searchStateProp, searchStateData, searchStateUpdater ) => {
    const [ searchState, updateAtomicData ] = getSearchState( searchStateProp, searchStateData, searchStateUpdater );
    const stateProvider = AwStateService.instance;
    const changedParams = stateProvider.params;
    let urlSearchString = null;
    let urlFilterString = '';
    if( changedParams.hasOwnProperty( 'searchCriteria' ) ) {
        urlSearchString = changedParams.searchCriteria;
    }
    if( changedParams.hasOwnProperty( 'filter' ) ) {
        urlFilterString = changedParams.filter ? changedParams.filter : urlFilterString;
    }
    if( urlSearchString && searchState && searchState.criteria && searchState.criteria.searchString !== urlSearchString || urlFilterString !==
        searchState.filterString ) {
        const prefilterMap = searchFilterService.getFilterMapWithPrefilters();
        const activeFiltersInfo = searchFilterService.buildSearchFiltersFromSearchState( prefilterMap );
        let newSearchCriteria = {
            criteria: searchStateHelperService.getCriteriaForNewSearch( searchState, urlSearchString ),
            searchStringPrimary: urlSearchString,
            searchStringSecondary: '',
            activeFilters: prefilterMap,
            activeFilterMap: activeFiltersInfo.activeFilterMap,
            categories: [],
            filterString: urlFilterString,
            searchFilterCategories: [],
            categoriesExpandCollapseMap: undefined,
            allCategoriesVisible: undefined,
            searchInProgress: true,
            totalFound: searchState.showLoadingText ? undefined : 0,
            forceChart: searchStateHelperService.getForceChartParameterValue( searchState )
        };
        newSearchCriteria.criteriaJSONString  = JSON.stringify( newSearchCriteria.criteria );
        if( updateAtomicData ) {
            updateAtomicData( { ...searchState, ...newSearchCriteria } );
        } else {
            let newSearchState = { ...searchState.value };
            Object.assign( newSearchState, newSearchCriteria );
            searchState.update( newSearchState );
        }
    }
};

export const getSelectedFiltersMap = ( categories ) => {
    var searchFilterMap = {};
    for( const [ key, value ] of Object.entries( categories ) ) {
        if( value ) {
            let filtersForCurrentCategory = [];
            if( value.filterValues && value.filterValues.length > 0 ) {
                value.filterValues.forEach( ( val ) => {
                    if( val.selected.dbValue ) {
                        switch ( value.type ) {
                            case 'NumericFilter': {
                                let numericValue = filterPanelUtils.INTERNAL_NUMERIC_FILTER + val.internalName;
                                filtersForCurrentCategory.push( numericValue );
                                break;
                            }
                            case 'DateFilter': {
                                let selectedDateFilters = searchFilterMap[ val.categoryName ] ? searchFilterMap[ val.categoryName ] : [];
                                selectedDateFilters.push( val.internalName );
                                searchFilterMap[ val.categoryName ] = selectedDateFilters;
                                break;
                            }
                            default:
                                filtersForCurrentCategory.push( val.internalName );
                                break;
                        }
                    }
                } );
            }
            if( value.numericRangeString ) {
                filtersForCurrentCategory.push( value.numericRangeString );
            }
            if( value.dateRangeString ) {
                filtersForCurrentCategory.push( value.dateRangeString );
            }
            if( filtersForCurrentCategory.length ) {
                searchFilterMap[ value.internalName ] = filtersForCurrentCategory;
            }
        }
    }
    return searchFilterService.removeDependentDateFilters( searchFilterMap );
};

/**
 * update pwa selection model with selection query param value
 * @param {*} selectionModel selection model
 * @param {*} selectionQueryParam selection query param object with key, value
 */
export const updateSearchPWASelectionModel = ( selectionModel, selectionQueryParam ) => {
    const pwaSelection = selectionModel.getSelection();
    if( !pwaSelection.length && selectionQueryParam && selectionQueryParam.value ) {
        selectionModel.setSelection( [ selectionQueryParam.value ] );
    }
};

export const getActiveSublocationTab = ( sublocationsTabs ) => {
    let activeSublocTab = '';
    if( sublocationsTabs && sublocationsTabs.length > 0 ) {
        let activeSublocTabObj = sublocationsTabs.filter( ( tab ) => {
            return tab.selectedTab;
        } )[ 0 ];
        activeSublocTab = activeSublocTabObj.id || activeSublocTabObj.tabKey || activeSublocTabObj.name;
    }
    return activeSublocTab;
};

/**
    * update charts data on selection change
    * @param {*} searchStateProp search state from parent
    * @param {*} searchState search state from view model data
    * @param {*} searchStateUpdater search state updater
*/
export const updateChartsDataOnSelectionChange = ( searchStateProp, searchState, searchStateUpdater ) => {
    const [ searchStateData, updateSearchState ] = getSearchState( searchStateProp, searchState, searchStateUpdater );
    if( searchStateData && searchStateData.pwaSelection ) {
        const selectedObjects = searchStateData.pwaSelection;
        const forceChart = !selectedObjects || selectedObjects.length === 0;
        const recreateChartProvider = forceChart ? 'true' : 'false';
        if( updateSearchState ) {
            updateSearchState( { ...searchStateData, forceChart, recreateChartProvider } );
        } else {
            let newSearchStateData = { ...searchStateData.value };
            newSearchStateData.forceChart = forceChart;
            newSearchStateData.recreateChartProvider = recreateChartProvider;
            searchStateData.update( newSearchStateData );
        }
    }
};

export const updateSublocationTabs = ( sublocationsTabs, primarySublocTabState ) => {
    if( sublocationsTabs && primarySublocTabState.dbValue && primarySublocTabState.dbValue.primaryActiveTabId && primarySublocTabState.dbValue.primaryActiveTabId !== '' ) {
        tabCallbackApi( undefined, primarySublocTabState.dbValue.primaryActiveTabId, sublocationsTabs );
    }
};

export const updateGlobalSelection = ( localSelectionData, parentSelectionData ) => {
    if( !_.isEmpty( localSelectionData ) ) {
        parentSelectionData ? parentSelectionData.update( localSelectionData ) : selectionService.updateSelection( localSelectionData.selected, localSelectionData.pselected, localSelectionData
            .relationInfo );
        trace( 'AwSearchSublocationService selectionData: ', localSelectionData );
    }
};

export const updateSelectionQueryParamInURL = ( searchStateProp, searchState ) => {
    const searchStateData = searchStateProp ? searchStateProp : searchState;
    // update URL if selectionQueryParam applicable
    if( searchStateData.selectionQueryParam && searchStateData.selectionQueryParam.key ) {
        let uid = searchStateData.pwaSelection && searchStateData.pwaSelection.length === 1 ? searchStateData.pwaSelection[ 0 ].uid : null;
        AwStateService.instance.go( '.', {
            [ searchStateData.selectionQueryParam.key ]: uid
        } );
    }
};

export const updateSearchStateWithSelectionData = ( searchStateProp, searchState, selectionData ) => {
    const searchStateData = searchStateProp ? searchStateProp : searchState;
    if( !_.isEmpty( selectionData ) ) {
        let newSearchState = searchStateData ? { ...searchStateData.value } : undefined;
        if( newSearchState ) {
            if( selectionData.source === 'primary' ) {
                newSearchState.pwaSelection = selectionData.selected ? selectionData.selected : [];
            } else if( selectionData.source === 'base' || selectionData.source === undefined ) {
                newSearchState.pwaSelection = [];
            }
            searchStateData.update( newSearchState );
        }
    }
};

const awSearchSublocationService = {
    updateSearchContext,
    createStateFromUrl,
    createSearchFilterMapFromUrl,
    getSearchFilterStringFromActiveFilterMap,
    getActiveFilters,
    lazyUpdate,
    updateURL,
    updateSearchCriteria,
    syncStateFromUrl,
    getSelectedFiltersMap,
    updateSearchPWASelectionModel,
    getActiveSublocationTab,
    updateChartsDataOnSelectionChange,
    updateSublocationTabs,
    updateGlobalSelection,
    updateSearchStateWithSelectionData,
    updateSelectionQueryParamInURL
};

export default awSearchSublocationService;
