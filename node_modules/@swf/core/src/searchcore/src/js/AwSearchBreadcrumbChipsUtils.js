// Copyright (c) 2021 Siemens

/**
 * @module js/AwSearchBreadcrumbChipsUtils
 */
import filterPanelUtils from 'js/filterPanelUtils';
import searchFilterService from 'js/aw.searchFilter.service';
import _ from 'lodash';


/**
 * Build master list of chips to display in breadcrumb location
 * @param {*} searchObject context for render function interpolation
 * @returns array of chips to display
 */
export let buildSearchChips = ( searchObject, existingBreadcrumbChips ) => {
    let chips = [];
    var parentChip;
    var appliedFilters = [];
    let appliedFiltersExist = searchObject && searchObject.appliedFilters && searchObject.appliedFilters.length > 0;
    let categoriesExist = searchObject.categories && searchObject.categories.length > 0;
    let specialCategoriesExist = searchObject.categoriesForRangeSearches && searchObject.categoriesForRangeSearches.length > 0;
    let isFacetSearch = searchObject.isFacetSearch;
    if( appliedFiltersExist && categoriesExist && !isFacetSearch ) {
        appliedFilters = removeDuplicateDateFilters( searchObject.appliedFilters );

        //Get the display value of the Category to display on the chip
        for( var i = 0; i < appliedFilters.length; i++ ) {
            for( var j = 0; j < searchObject.categories.length; j++ ) {
                switch ( searchObject.categories[ j ].type ) {
                    case 'StringFilter':
                        parentChip = getFilterParentChip( searchObject.categories[ j ], appliedFilters[ i ], 'StringFilter' );
                        break;
                    case 'NumericFilter':
                        parentChip = getFilterParentChip( searchObject.categories[ j ], appliedFilters[ i ], 'NumericFilter' );
                        break;
                    case 'DateFilter':
                        parentChip = getDateFilterParentChip( searchObject.categories[ j ], appliedFilters[ i ], searchObject.appliedFilters );
                        break;
                    case 'RadioFilter':
                        parentChip = getFilterParentChip( searchObject.categories[ j ], appliedFilters[ i ], 'RadioFilter' );
                        break;
                    case 'ObjectFilter':
                        parentChip = getFilterParentChip( searchObject.categories[ j ], appliedFilters[ i ], 'ObjectFilter' );
                        break;
                }
                //Check if parentChip is populated and add to chips
                if( parentChip ) {
                    chips.push( parentChip );
                    parentChip = undefined;
                }
            }
        }
    } else if( appliedFiltersExist && specialCategoriesExist && !isFacetSearch ) {
        appliedFilters = removeDuplicateDateFilters( searchObject.appliedFilters );
        //Get the display value of the Category to display on the chip
        for( var i = 0; i < appliedFilters.length; i++ ) {
            for( var j = 0; j < searchObject.categoriesForRangeSearches.length; j++ ) {
                switch ( searchObject.categoriesForRangeSearches[ j ].type ) {
                    case 'StringFilter':
                        parentChip = getFilterParentChip( searchObject.categoriesForRangeSearches[ j ], appliedFilters[ i ], 'StringFilter' );
                        break;
                    case 'NumericFilter':
                        parentChip = getFilterParentChip( searchObject.categoriesForRangeSearches[ j ], appliedFilters[ i ], 'NumericFilter' );
                        break;
                    case 'DateFilter':
                        parentChip = getDateFilterParentChip( searchObject.categoriesForRangeSearches[ j ], appliedFilters[ i ], searchObject.appliedFilters );
                        break;
                    case 'RadioFilter':
                        parentChip = getFilterParentChip( searchObject.categoriesForRangeSearches[ j ], appliedFilters[ i ], 'RadioFilter' );
                        break;
                    case 'ObjectFilter':
                        parentChip = getFilterParentChip( searchObject.categoriesForRangeSearches[ j ], appliedFilters[ i ], 'ObjectFilter' );
                        break;
                }
                //Check if parentChip is populated and add to chips
                if( parentChip ) {
                    chips.push( parentChip );
                    parentChip = undefined;
                }
            }
        }
    } else if( isFacetSearch ) {
        return existingBreadcrumbChips;
    }
    return chips;
};

/**
 * Remove selected chip from current list of displayed or overflow chips
 * @param {*} searchObject searchObject
 * @param {*} chipToRemove selected chip to remove
 * @param {*} data data
 * @param {*} chiplistRef displayed chip ref
 * @returns display and overflow chips for rerender
 */
export let removeSelectedChip = function( searchObject, chipToRemove, data, chiplistRef ) {
    let displayChips = _.cloneDeep( data.displayBreadcrumbChips );
    let overflownChips = [];

    switch ( chipToRemove.chipFilterType ) {
        case 'StringFilter':
        case 'NumericFilter':
            removeChip( searchObject, chipToRemove );
            break;
        case 'DateFilter':
            removeDateChip( searchObject, chipToRemove );
            break;
        case 'RadioFilter':
            removeRadioChip( searchObject, chipToRemove );
            break;
        case 'ObjectFilter':
            removeObjectChip( searchObject, chipToRemove );
            break;
    }

    for ( let i = 0; displayChips.length > i; i++ ) {
        if ( displayChips[i].labelDisplayName === chipToRemove.labelDisplayName ) {
            displayChips.splice( i, 1 );
        }
    }

    return { displayChips, overflownChips };
};

/**
 * Creates the chip that will be added to the master chip list
 * @function createChip
 * @param {Object} parent If chip is a parent chip
 * @param {Object} numberOfChips if parent chip how many children chips exist
 * @param {Object} categoryName name of category
 * @param {Object} filterDisplayName display name of filter
 * @param {Object} internalCategoryName intenal category name
 * @param {Object} internalFilterName intenal filter name
 * @param {Object} filterType type of filter
 * @param {Object} childrenChips if parent this is children chips to display in group
 * @param {Object} defaultSelection default selection, this selection will not display remove button
 * @returns {Object} breadcrumbChip
 */
function createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, filterType, childrenChips, defaultSelection ) {
    let displayLabel;

    if ( numberOfChips > 1 && parent ) {
        displayLabel = categoryName + ': ' + numberOfChips + ' Selected';
        internalFilterName = 'parentChip';
    } else {
        displayLabel = categoryName + ': ' + filterDisplayName;
    }

    let breadcrumbChip = {
        uiIconId: 'miscRemoveBreadcrumb',
        chipType: 'BUTTON',
        selected: false,
        labelDisplayName: displayLabel,
        labelInternalCategoryName: internalCategoryName,
        labelInternalFilterName: internalFilterName,
        chipFilterType: filterType,
        className: 'aw-search-breadcrumb-chip'
    };

    if ( filterType === 'RadioFilter' && defaultSelection ) {
        breadcrumbChip.uiIconId = '';
    }

    if ( childrenChips && childrenChips.length > 1 ) {
        breadcrumbChip.children = childrenChips;
    }

    return breadcrumbChip;
}

/**
 * Returns active filters after removing repetitive date filters ie. year_week filters
 * @function removeDuplicateDateFilters
 * @param {Object} activeFilters current active filter
 * @returns {Object} editedActiveFilters
 */
function removeDuplicateDateFilters( appliedFilters ) {
    var editedAppliedFilters = [];
    var dateExists = false;
    for( let i = 0; i < appliedFilters.length; i++ ) {
        //Handles checkbox date filters selected
        if( appliedFilters[ i ].name.includes( '_0Z0_' ) ) {
            if( appliedFilters[ i ].name.includes( '_month' ) || appliedFilters[ i ].name.includes( '_week' ) ) {
                appliedFilters.slice( i, 1 );
            } else {
                editedAppliedFilters.push( appliedFilters[ i ] );
            }
        }
        //Handle the Date Range Filter being set
        else if( appliedFilters[ i ].type === 'DateFilter' ) {
            for( let j = 0; j < appliedFilters.length; j++ ) {
                if( appliedFilters[ i ].name === appliedFilters[ j ].name.substr( 0, appliedFilters[ j ].name.indexOf( '_0Z0' ) ) ) {
                    dateExists = true;
                }
            }
            if( dateExists ) {
                appliedFilters.slice( i, 1 );
                dateExists = false;
            } else {
                editedAppliedFilters.push( appliedFilters[ i ] );
                dateExists = false;
            }
        } else {
            editedAppliedFilters.push( appliedFilters[ i ] );
        }
    }
    return editedAppliedFilters;
}

/**
 * Returns a parent chip to build chips for addition to the display chips array
 * @function getFilterParentChip
 * @param {Object} category filterCategory
 * @param {Object} activeFilter current active filters
 * @param {Object} filterType filter type
 * @returns {Object} parentChip
 */
function getFilterParentChip( category, activeFilter, filterType ) {
    var childrenChips = [];
    var defaultSelection = false;
    var parent;
    if( category.internalName === activeFilter.name ) {
        //Create initial chip. If multiple of same category exist create child chip
        for( var k = 0; k < activeFilter.values.length; k++ ) {
            var categoryName = category.displayName;
            var numberOfChips = activeFilter.values.length;
            var internalCategoryName = activeFilter.name;
            var internalFilterName = activeFilter.values[ k ];
            var filterDisplayName = category.filterValues && category.filterValues.length > 0 ? category.filterValues[ 0 ].name : undefined;
            if( activeFilter.values[ k ].includes( '_NumericRange_' ) ) {
                parent = false;
                filterDisplayName = getNumericString( activeFilter.values[ k ] );
            }
            if( category.type === 'RadioFilter' ) {
                if( activeFilter.values[ 0 ] === category.filterValues[ 0 ].internalName ) {
                    defaultSelection = true;
                }
            }
            if( numberOfChips > 1 ) {
                if( category.type === 'StringFilter' || category.type === 'ObjectFilter' ) {
                    for( var l = 0; l < category.filterValues.length; l++ ) {
                        if( category.filterValues[ l ].internalName === internalFilterName ) {
                            parent = false;
                            filterDisplayName = category.filterValues[ l ].name;
                            let chipChild = createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, filterType, null, false );
                            childrenChips.push( chipChild );
                        }
                    }
                } else if( category.type === 'NumericFilter' ) {
                    parent = false;
                    filterDisplayName = activeFilter.values[ k ].replace( '_NumericFilter_', '' );
                    if( activeFilter.values[ k ].includes( '_NumericRange_' ) ) {
                        parent = false;
                        filterDisplayName = getNumericString( activeFilter.values[ k ] );
                    }
                    let chipChild = createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, filterType, null, false );
                    childrenChips.push( chipChild );
                }
            }
        }
        parent = true;
        return createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, filterType, childrenChips, defaultSelection );
    }
}

/**
 * Returns a date parent chip to build chips for addition to the display chips array
 * @function getDateFilterParentChip
 * @param {Object} category filterCategory
 * @param {Object} activeFilter current active filters
 * @param {Object} filterType filter type
 * @returns {Object} parentChip
 */
function getDateFilterParentChip( category, currentActiveFilter, activeFilter ) {
    var childrenChips = [];
    var parent;
    var filterDisplayName;
    if( category.filterValues.length > 0 ) {
        for( var datechipfilter = 0; datechipfilter < category.filterValues.length; datechipfilter++ ) {
            if( category.filterValues[ datechipfilter ].categoryName === currentActiveFilter.name || category.internalName === currentActiveFilter.name ) {
                //Get Category Name and Internal Category value
                var categoryName = category.displayName;

                //Get Group of DateFilter Chips
                var dateFilterArray = getDateFilterChipArray( activeFilter, category );
                let numberOfChips = dateFilterArray.length;
                var internalFilterName = dateFilterArray[ 0 ].values[ 0 ];
                var internalCategoryName = dateFilterArray[ 0 ].name;

                //Get filter display name. If Filter Range get the proper Filter display name then
                filterDisplayName = dateFilterArray[ 0 ].values[ 0 ] === '"$NONE"' ? dateFilterArray[ 0 ].values[ 0 ] : category.filterValues[ 0 ].name;
                if( dateFilterArray[ 0 ].values[ 0 ].length > 13 && dateFilterArray[ 0 ].values[ 0 ].substr( 0, 12 ) === '_DateFilter_' ) {
                    let filterDisplayArray = getDateString( dateFilterArray[ 0 ].values[ 0 ] );
                    filterDisplayName = filterDisplayArray.displayName;
                }

                //Incase of child chips get children chips
                if( numberOfChips > 1 ) {
                    for( var k = 0; k < dateFilterArray.length; k++ ) {
                        parent = false;
                        internalCategoryName = dateFilterArray[ k ].name;
                        internalFilterName = dateFilterArray[ k ].values[ 0 ];
                        if( dateFilterArray[ k ].values[ 0 ].length > 13 && dateFilterArray[ k ].values[ 0 ].substr( 0, 12 ) === '_DateFilter_' ) {
                            let filterDisplayArray = getDateString( dateFilterArray[ k ].values[ 0 ] );
                            filterDisplayName = filterDisplayArray.displayName;
                        } else {
                            for( var l = 0; l < category.filterValues.length; l++ ) {
                                if( category.filterValues[ l ].internalName === dateFilterArray[ k ].values[ 0 ] ) {
                                    filterDisplayName = category.filterValues[ l ].name;
                                }
                            }
                        }
                        let chipChild = createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, 'DateFilter', null, false );
                        childrenChips.push( chipChild );
                    }
                }
                parent = true;
                var parentChip = createChip( parent, numberOfChips, categoryName, filterDisplayName, internalCategoryName, internalFilterName, 'DateFilter', childrenChips, false );
                break;
            }
        }
    } else if( category.filterValues && category.filterValues.length === 0
        && category.internalName === currentActiveFilter.name && category.dateRangeString && category.dateRangeString.length > 0 ) {
        filterDisplayName = getDateString( category.dateRangeString ).displayName;
        parentChip = createChip( parent, 1, category.displayName, filterDisplayName, category.internalName, category.dateRangeString, 'DateFilter', [], false );
    }
    return parentChip;
}

/**
 * Returns dateRange in proper format for date chip display
 * @function getDateString
 * @param {Object} dateString filter string date value
 * @returns {Object} dateRange
 */
function getDateString( dateString ) {
    if( dateString.length > 19 ) {
        var offsetString = dateString.substring( 12 );
        if( offsetString.length > 4 ) {
            var startDate = offsetString.substr( 0, offsetString.indexOf( '_TO_' ) );
            var endDate = offsetString.substr( offsetString.indexOf( '_TO_' ) + 4, offsetString.length );
        }

        if( startDate === '*' ) {
            startDate = '0001-01-01T00:00:00+00:00';
        }

        startDate = filterPanelUtils.getDate( searchFilterService.processDateStringOffset( startDate ) );
        endDate = filterPanelUtils.getDate( searchFilterService.processDateStringOffset( endDate ) );

        var dateRange = filterPanelUtils.getDateRangeDisplayString( startDate, endDate );
    }
    return dateRange;
}

/**
 * Returns group of date filters in array
 * @function getDateFilterChipArray
 * @param {Object} activeFilterArray all current active filters
 * @param {Object} filterCategory current filter category
 * @returns {Object} dateFilterArray
 */
function getDateFilterChipArray( activeFilterArray, filterCategory ) {
    var dateFilterArray = [];
    for( var i = 0; i < activeFilterArray.length; i++ ) {
        if( activeFilterArray[ i ].name === filterCategory.internalName ) {
            dateFilterArray.push( activeFilterArray[ i ] );
        } else {
            let shortFilterIntenal = activeFilterArray[ i ].name.substr( 0, activeFilterArray[ i ].name.indexOf( '_0Z0' ) );
            if( shortFilterIntenal === filterCategory.internalName ) {
                dateFilterArray.push( activeFilterArray[ i ] );
            }
        }
    }

    return dateFilterArray;
}

/**
 * Returns filterDisplayName in proper format for numeric chip display
 * @function getNumericString
 * @param {Object} numericString from the getCategoryValues
 * @returns {Object} filterDisplayName
 */
function getNumericString( numericString ) {
    if( numericString.length > 4 ) {
        let value = numericString.replace( '_NumericRange_', '' );
        let startValue = value.substr( 0, value.indexOf( '_TO_' ) );
        let endValue = value.substr( value.indexOf( '_TO_' ) + 4, value.length );
        if( !startValue ) {
            var filterDisplayName = 'To ' + endValue;
        } else if( !endValue ) {
            var filterDisplayName = 'From ' + startValue;
        } else {
            var filterDisplayName = startValue + ' - ' + endValue;
        }
    }
    return filterDisplayName;
}

/**
 * Updates search object with removed radio filter
 * @function removeRadioChip
 * @param {Object} searchObject searchObject
 * @param {Object} chipToRemove selected chip to remove
 */
function removeRadioChip( searchObject, chipToRemove ) {
    const newSearchObject = { ...searchObject.value };

    for ( var i = 0; i < newSearchObject.categories.length; i++ ) {
        if ( chipToRemove.labelInternalCategoryName === newSearchObject.categories[i].internalName ) {
            if ( chipToRemove.labelInternalFilterName === newSearchObject.categories[i].filterValues[ 0 ].internalName ) {
                newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ] = [ newSearchObject.categories[ i ].filterValues[ 1 ].internalName ];
            } else {
                newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ] = [ newSearchObject.categories[ i ].filterValues[ 0 ].internalName ];
            }
        }
    }
    newSearchObject.bulkFiltersApplied = true;
    searchObject.update( newSearchObject );
}

/**
 * Updates search object with removed object filter
 * @function removeObjectChip
 * @param {Object} searchObject searchObject
 * @param {Object} chipToRemove selected chip to remove
 */
function removeObjectChip( searchObject, chipToRemove ) {
    const newSearchObject = { ...searchObject.value };
    let updatedFilters = searchFilterService.removeDependentClassificationFilters( { internalName: chipToRemove.labelInternalFilterName } );
    if( updatedFilters.length > 0 ) {
        newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ] = updatedFilters;
    } else {
        delete newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName  ];
    }
    newSearchObject.bulkFiltersApplied = true;
    searchObject.update( newSearchObject );
}

/**
 * Updates search object with after removing single string filter
 * @function removeSingleStringChip
 * @param {Object} newSearchObject searchObject
 * @param {Object} chipToRemove selected chip to remove
 */
function removeSingleChip( newSearchObject, chipToRemove ) {
    let filtersForCategory = newSearchObject.activeFilters && newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ]
        ? newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ] : [];
    let updatedFilters = [];
    for( let index = 0; index < filtersForCategory.length; index++ ) {
        if( filtersForCategory[ index ] !== chipToRemove.labelInternalFilterName ) {
            updatedFilters.push( filtersForCategory[ index ] );
        }
    }
    if( updatedFilters.length > 0 ) {
        newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName  ] = updatedFilters;
    } else {
        delete newSearchObject.activeFilters[ chipToRemove.labelInternalCategoryName ];
    }
    if ( newSearchObject.activeFilters && Object.keys( newSearchObject.activeFilters ).length > 0 ) {
        newSearchObject.activeFilterString = searchFilterService.buildFilterString( newSearchObject.activeFilters );
    } else {
        newSearchObject.activeFilterString = '';
    }
}

/**
 * Updates search object after removing multiple string filters from the same category
 * @function removeStringChip
 * @param {Object} newSearchObject searchObject
 * @param {Object} chipToRemove chip which is to be removed
 */
function removeMultipleChip( newSearchObject, chipToRemove ) {
    let children = chipToRemove.children;
    for( let index = 0; index < children.length; index++ ) {
        removeSingleChip( newSearchObject, children[ index ] );
    }
}


/**
 * Updates search object after removing string chip
 * @function removeStringChip
 * @param {Object} searchObject searchObject
 * @param {Object} chipToRemove selected chip to remove
 */
function removeChip( searchObject, chipToRemove ) {
    const newSearchObject = { ...searchObject.value };

    if( chipToRemove && chipToRemove.children && chipToRemove.children.length === 0 || chipToRemove && !chipToRemove.children ) {
        removeSingleChip( newSearchObject, chipToRemove );
    } else {
        removeMultipleChip( newSearchObject, chipToRemove );
    }

    newSearchObject.bulkFiltersApplied = true;
    searchObject.update( newSearchObject );
}

/**
 * Updates search object with removed date filter
 * @function removeDateChip
 * @param {Object} searchObject searchObject
 * @param {Object} chipToRemove selected chip to remove
 */
function removeDateChip( searchObject, chipToRemove ) {
    const newSearchObject = { ...searchObject.value };
    if( chipToRemove && chipToRemove.children && chipToRemove.children.length === 0 || chipToRemove && !chipToRemove.children ) {
        removeSingleChip( newSearchObject, chipToRemove );
    } else {
        removeMultipleChip( newSearchObject, chipToRemove );
    }
    newSearchObject.activeFilters = searchFilterService.removeDependentDateFilters( newSearchObject.activeFilters );
    newSearchObject.bulkFiltersApplied = true;
    searchObject.update( newSearchObject );
}

export let checkSearchLocation = ( searchObject ) => {
    //Check if in Panel or Global Search Area
    if ( searchObject && searchObject.criteria && searchObject.criteria.searchFromLocation ) {
        let currentLocation = _.cloneDeep( searchObject.criteria.searchFromLocation );
        if ( currentLocation === 'global' ) {
            return true;
        }

        return false;
    }

    return true;
};

/**
 * ClearAll action removes all selected chips in the breadcrumb location
 * @function removeDateChip
 * @param {Object} searchObject searchObject
 */
export let clearAll = ( searchObject ) => {
    const newSearchObject = { ...searchObject.value };
    const categories = searchFilterService.clearAllSelectedFiltersAndRanges( newSearchObject.categories, newSearchObject.activeFilters, newSearchObject.positivePendingFilters );
    newSearchObject.categories = categories;
    if( newSearchObject.skipFiltersForClearAll && newSearchObject.activeFilters
        && newSearchObject.activeFilterMap && Object.keys( newSearchObject.activeFilters ).length > 0 ) {
        for( const[ key, value ] of Object.entries( newSearchObject.activeFilters ) ) {
            if( !newSearchObject.skipFiltersForClearAll.includes( key ) ) {
                delete newSearchObject.activeFilters[ key ];
                delete newSearchObject.activeFilterMap[ key ];
            }
        }
    } else {
        newSearchObject.activeFilterMap = {};
        newSearchObject.activeFilters = {};
    }
    delete newSearchObject.positivePendingFilters;
    delete newSearchObject.negativePendingFilters;
    delete newSearchObject.allCategoriesVisible;
    newSearchObject.bulkFiltersApplied = true;
    searchObject.update( newSearchObject );
};

export let calculateOverflow = ( elementRefList, totalVisibleArea, totalVisibleHeight, breadcrumbChips, currentOverflowChips,
    displayBreadcrumbChips, inHeader, searchFilterCategoryExpandMore, visibleChipAreaMaintained ) => {
    var tabElems;
    var displayChips = [];
    var overflownChips = [];
    var breakIndex = null;
    var filledHeader = true;

    if ( elementRefList ) {
        let chiplist = elementRefList.get( 'chiplist' ).current;

        if( !chiplist ) {
            return breakIndex;
        }

        if( !tabElems ) {
            tabElems = chiplist.querySelectorAll( '.aw-widgets-chip' );
        }

        let arr = [ ...tabElems ];
        var tabPadding = 16;
        let searchCountAreaSpacing = 0;
        if ( chiplist.parentNode.parentElement && chiplist.parentNode.parentElement.firstChild
        && chiplist.parentNode.parentElement.firstChild.childNodes
        && chiplist.parentNode.parentElement.firstChild.childNodes.length > 0
        && chiplist.parentNode.parentElement.firstChild.childNodes[0].clientWidth ) {
            searchCountAreaSpacing = chiplist.parentNode.parentElement.firstChild.childNodes[0].clientWidth;
        }
        let cmdMoreButtonSpacing = 80;
        let clearButtonSpacing = chiplist.lastChild ? chiplist.lastChild.clientWidth + 24 : 24;
        if ( !totalVisibleArea || !visibleChipAreaMaintained ) {
            totalVisibleArea = chiplist.parentElement.parentElement ? chiplist.parentElement.parentElement.clientWidth : 0;
        }

        var totalCalculatedArea = tabPadding + searchCountAreaSpacing + cmdMoreButtonSpacing + clearButtonSpacing;

        //Determine where overflow takes place. If overflow is already hit then this keeps breakIndex as undefined
        for( var i = 0; i < arr.length; i++ ) {
            totalCalculatedArea = arr[i].clientWidth + totalCalculatedArea;
            if( totalCalculatedArea > totalVisibleArea ) {
                breakIndex = i;
                break;
            }
        }

        if ( !inHeader ) {
            if ( !totalVisibleHeight || !visibleChipAreaMaintained ) {
                totalVisibleHeight =  chiplist.parentElement.parentElement.clientHeight / 2;
            }
            let chipElementHeight = chiplist.parentElement.clientHeight;
            let clearButtonSpacing = chiplist.lastChild ? chiplist.lastChild.clientHeight : 0;
            cmdMoreButtonSpacing = 32;
            tabPadding = 32;
            totalCalculatedArea = tabPadding + clearButtonSpacing + cmdMoreButtonSpacing + chipElementHeight;

            if ( totalCalculatedArea > totalVisibleHeight ) {
                for( i = 0; i < arr.length; i++ ) {
                    totalCalculatedArea -= 26;
                    if( totalCalculatedArea < totalVisibleHeight ) {
                        breakIndex = arr.length - i;
                        break;
                    }
                }
            }
        }

        //Check if header is completely filled. Used when going from a smaller window size to larger window size
        //diffChipArea helps with accounting for scenarios where there is only a small space difference in calculated and actual size
        let diffChipArea = totalVisibleArea - totalCalculatedArea - 200;
        if ( totalCalculatedArea < totalVisibleArea - 200 && diffChipArea > tabPadding ) {
            filledHeader = false;
        }

        if ( breakIndex === 0 && inHeader ) {
            displayChips = [];
            overflownChips = breadcrumbChips;
        } else if ( breakIndex > 0 ) {
            overflownChips = breadcrumbChips.slice( breakIndex );
            displayChips = breadcrumbChips.slice( 0, breakIndex );
        } else if ( breadcrumbChips.length >= 7 ) {
            overflownChips = breadcrumbChips.slice( 1 );
            displayChips = breadcrumbChips.slice( 0, 1 );
        } else if ( currentOverflowChips.length > 0 && arr.length < breadcrumbChips.length && filledHeader ) {
            overflownChips = breadcrumbChips.slice( arr.length );
            displayChips = breadcrumbChips.slice( 0, arr.length );
        } else {
            displayChips = breadcrumbChips;
            overflownChips = [];
        }
    } else if ( currentOverflowChips.length !== 0 && displayBreadcrumbChips.length !== 0 )  {
        overflownChips = currentOverflowChips;
        displayChips = displayBreadcrumbChips;
    } else {
        overflownChips = [];
        displayChips = breadcrumbChips;
    }
    let displayOverflowButton = overflownChips.length + ' ' + searchFilterCategoryExpandMore;

    return  { displayChips, overflownChips, displayOverflowButton, totalVisibleArea, totalVisibleHeight };
};

export default {
    buildSearchChips,
    removeSelectedChip,
    checkSearchLocation,
    clearAll,
    calculateOverflow
};
