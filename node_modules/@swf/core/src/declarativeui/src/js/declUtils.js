// Copyright (c) 2020 Siemens

/* global afxDynamicImport afxWeakImport */

/**
 * Thue module defines helpful shared APIs and constants used throughout the DeclarativeUI code base.
 * <P>
 * Note: This modules does not create an injectable service.
 *
 * @module js/declUtils
 */
import assert from 'js/assert';
import _ from 'lodash';
import logger from 'js/logger';
import moduleLoader from 'js/moduleLoader';
/** revisitme Shaishav
 * Hint: We need to integrate with appCtxService
import appCtxSvc from 'js/appCtxService';
*/
import parsingUtils from 'js/parsingUtils';
import browserUtils from 'js/browserUtils';
import appCtxSvc from 'js/appCtxService';

// Service
import AwParseService from 'js/awParseService';

var exports = {};

var MSG_1 = 'Required DeclViewModel not specified';

var MSG_PREFIX_1 = 'Invalid to process with destroyed DeclViewModel: ';

var MSG_PREFIX_2 = 'Invalid to process with destroyed DataContextNode: ';

/**
 * {StringAray} Props to include when logging the properties of a dseclAction.
 */
var _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'steps' ];

/**
 * {Boolean} TRUE if activity interupted by a destroyed {DeclViewModel} should be logged to the log service.
 * <P>
 * Note: This flag is controlled by the existence of the 'logLifeCycleIssues' attribute in the current document's
 * URL.
 */
var _debug_logLifeCycleIssues = browserUtils.getUrlAttributes().logLifeCycleIssues !== undefined;

/**
 * Array used to confirm if the property name in a 'declViewModelJson' 'data' object's property is a valid
 * property name in the 'propAttrHolder' object used to create a new 'ViewModelProperty' (kind of a schema
 * checker).
 */
export let attrHolderPropName = [ 'dbValue', 'displayName', 'dispValue', 'isArray', 'isEditable', 'isRequired', 'isEnabled', 'displayValue', 'value', 'isModifiable', 'isAutoAssign', 'isAutoAssignable',
    'labelPosition', 'requiredText', 'type', 'propName', 'hasLov', 'dataProvider', 'isSelectOnly', 'isRichText', 'referenceTypeName', 'maxLength', 'maxArraySize', 'renderingHint', 'autofocus',
    'propertyDisplayName',
    'patterns', 'preferredPattern', 'patternAutoAssignFlags', 'condition', 'validationCriteria', 'oldValue', 'oldValues', 'vertical', 'propertyRadioTrueText', 'propertyRadioFalseText', 'numberOfLines',
    'iconName'
];
/**
 * @param {String} depModule - The dependent module to load.
 *
 * @return {Promise} This promise will be resolved with the service (or module) API object when the given module has
 * been loaded.
 */
export const loadDependentModule = depModule => {
    return moduleLoader.loadDependentModule( depModule );
};

/**
 * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.
 *
 * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life
 * cycle issue.
 *
 * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.
 *
 * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}
 * has been destroyed.
 *
 * @param {String} methodName - Name of the method where the issues was found.
 *
 * @returns {String} Formatted message
 */
export let buildLifeCycleIssueMessage = function( declViewModel, action, consequence, methodName ) {
    var errorMsg = 'Attempted processing after an associated DeclViewModel was destroyed...';

    if( consequence ) {
        errorMsg += '\n';
        errorMsg += consequence;
    }

    if( declViewModel ) {
        errorMsg += '\n';
        errorMsg += 'DeclViewModel: ';
        errorMsg += declViewModel;
    }

    if( methodName ) {
        errorMsg += '\n';
        errorMsg += 'Method: ';
        errorMsg += methodName;
    }

    if( action ) {
        errorMsg += '\n';
        errorMsg += 'Action:';
        errorMsg += '\n';
        errorMsg += JSON.stringify( action, _actionPropsToLog, 2 );
    }

    return errorMsg;
};

/**
 * Format a message with the given information and log a 'warning' if the 'logLifeCycleIssue' URL flag has been set.
 *
 * @param {DeclViewModel} declViewModel - (Optional) The {DeclViewModel} that was destroyed and thus caused the life
 * cycle issue.
 *
 * @param {DeclAction} action - (Optional) The {DeclAction} Being processed when the issue was detected.
 *
 * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}
 * has been destroyed.
 *
 * @param {String} methodName - Name of the method where the issues was found.
 *
 * @returns {String} Formatted message
 */
export let logLifeCycleIssue = function( declViewModel, action, consequence, methodName ) {
    var errorMsg = exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName );

    if( _debug_logLifeCycleIssues ) {
        logger.warn( errorMsg );
    }

    return errorMsg;
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 */
export let assertValidModel = function( declViewModel ) {
    assert( declViewModel, MSG_1 );

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        assert( false, MSG_PREFIX_1 + declViewModel );
    }
};

/**
 * Clone scope without copying angular scope's internal properties.
 *
 * @param {Object} scope - Object to clone.
 *
 * @return {Object} an object that holds data from provided Object
 */
export let cloneData = function( scope ) {
    var object = {};
    _.forOwn( scope, function( value, key ) {
        if( !_.startsWith( key, '$' ) ) {
            object[ key ] = value;
        }
    } );
    return object;
};

/**
 * update data for fileData
 *
 * @param {Object} fileData - key string value the location of the file
 * @param {Object} data the view model data object
 */
/** revisitme Shaishav
 * Hint: We need a jquery free solution here
export let updateFormData = function( fileData, data ) {
    if( fileData && fileData.value ) {
        var form = $( '#fileUploadForm' );
        data.formData = new FormData( $( form )[ 0 ] );
        data.formData.append( fileData.key, fileData.value );
    }
};
*/

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 */
export let assertValidModelWithOriginalJSON = function( declViewModel ) {
    assert( declViewModel, MSG_1 );

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        assert( false, MSG_PREFIX_1 + declViewModel );
    }

    assert( declViewModel._internal.origDeclViewModelJson, 'Required DeclViewModel JSON object not specified' );
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 * @param {Object} dataCtxNode - The context object to test.
 */
export let assertValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {
    assert( declViewModel, MSG_1 );

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        assert( false, MSG_PREFIX_1 + declViewModel );
    }

    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {
        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) + ' DeclViewModel=' + declViewModel );
    }
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * a 'warning' will be logged and this function will return FALSE.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 * @param {Object} dataCtxNode - The context object to test.
 *
 * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid
 * properties set. TRUE otherwise.
 */
export let isValidModelAndDataCtxNode = function( declViewModel, dataCtxNode ) {
    if( !declViewModel ) {
        if( _debug_logLifeCycleIssues ) {
            logger.warn( MSG_1 );
        }
        return false;
    }

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        exports.logLifeCycleIssue( declViewModel, null, null, 'isValidModelAndDataCtxNode' );
        return false;
    }

    if( !declViewModel.isUnmounting && dataCtxNode && dataCtxNode.$$destroyed ) {
        if( _debug_logLifeCycleIssues ) {
            logger.warn( MSG_PREFIX_2 + dataCtxNode.$id + ' DeclViewModel=' + declViewModel );
        }
        return false;
    }

    return true;
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 * @param {Object} dataCtxNode - The context object to test.
 * @param {DeclAction} action - The declAction object to test.
 */
export let assertValidModelDataCtxNodeAndAction = function( declViewModel, dataCtxNode, action ) {
    assert( declViewModel, MSG_1 );

    if( declViewModel._internal.isDestroyed ) {
        assert( false, MSG_PREFIX_1 + declViewModel +
            ' actionType: ' + action.actionType +
            ' method: ' + action.method +
            ' deps: ' + action.deps );
    }

    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {
        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +
            ' DeclViewModel=' + declViewModel +
            ' actionType: ' + action.actionType +
            ' method: ' + action.method +
            ' deps: ' + action.deps );
    }
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 *
 * @param {Object} dataCtxNode - The context object to test.
 *
 * @param {DeclAction} action - The declAction object to test.
 *
 * @param {String} consequence - (Optional) Text describing what is NOT going to happen since the {DeclViewModel}
 * has been destroyed.
 *
 * @param {String} methodName - Name of the method where the issues was found.
 */
export let assertValidModelDataCtxNodeAndAction2 = function( declViewModel, dataCtxNode, action, consequence, methodName ) {
    assert( declViewModel, MSG_1 );

    if( declViewModel._internal.isDestroyed ) {
        assert( false, exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );
    }

    if( !declViewModel.isUnmounting && ( !dataCtxNode || dataCtxNode.$$destroyed ) ) {
        assert( false, MSG_PREFIX_2 + ( dataCtxNode ? dataCtxNode.$id : '???' ) +
            exports.buildLifeCycleIssueMessage( declViewModel, action, consequence, methodName ) );
    }
};

/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * an 'assert' failure will be thrown.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for
 *            validity.
 */
export let assertValidModelAndEventData = function( declViewModel, eventData ) {
    assert( declViewModel, MSG_1 );

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        assert( false, MSG_PREFIX_1 + declViewModel );
    }

    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {
        assert( false, MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );
    }
};

/**
 * Evaluate message with its parameters
 *
 * @param {String} messageString - The message String.
 *
 * @param {String} messageParams - The message parameters.
 *
 * @param {Object} messageContext - The context object (e.g. a 'declViewModel') that holds the text string map to
 *            search within.
 *
 * @return {String} Result string after applying passed parameters.
 */
export let applyMessageParams = function( messageString, messageParams, messageContext ) {
    var placeHolders = messageString.match( /\{[0-9]*\}/g );

    var resultString = messageString;

    if( placeHolders && messageParams ) {
        for( var i in placeHolders ) {
            if( placeHolders.hasOwnProperty( i ) ) {
                var placeHolder = placeHolders[ i ];

                var index = placeHolder;
                index = _.trimStart( index, '{' );
                index = _.trimEnd( index, '}' );

                var key = parsingUtils.getStringBetweenDoubleMustaches( messageParams[ index ] );
                var replacementString = _.get( messageContext, key );
                resultString = resultString.replace( placeHolder, replacementString );
            }
        }
    }

    return resultString;
};


/**
 * Validate if any of the given parameters does not exist, has been destroyed or has invalid properties set. If so,
 * a 'warning' will be logged and this function will return FALSE.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel to test.
 *
 * @param {Object} eventData - The object used in an event to test. Any optional dataCtxNode will be tested for
 *            validity.
 *
 * @returns {Boolean} FALSE  if any of the given parameters does not exist, has been destroyed or has invalid
 * properties set. TRUE otherwise.
 */
export let isValidModelAndEventData = function( declViewModel, eventData ) {
    if( !declViewModel ) {
        logger.warn( MSG_1 );
        return false;
    }

    if( !declViewModel._internal || declViewModel._internal.isDestroyed ) {
        logger.warn( MSG_PREFIX_1 + declViewModel );
        return false;
    }

    if( eventData && eventData.scope && eventData.scope.$$destroyed ) {
        logger.warn( MSG_PREFIX_2 + ( eventData.scope ? eventData.scope.$id : '???' ) + ' DeclViewModel=' + declViewModel );
        return false;
    }

    return true;
};

/**
 * Check if the given dataCtxNode we need has been destroyed (due to DOM manipulation?) since processing was
 * started.
 * <P>
 * If so: Use the dataCtxNode the DeclViewModel was originally created on.
 * <P>
 * Note: This case can happen when, say, an event is thrown by a 'source' data context that was destroyed before the
 * event was processed.
 *
 * @param {DeclViewModel} declViewModel - The {DeclDataModel} to check
 * @param {Object} dataCtxNode - The 'dataCtxNode' to return if NOT destroyed.
 *
 * @returns {Object} The dataCtxNode object to use.
 */
export let resolveLocalDataCtx = function( declViewModel, dataCtxNode ) {
    if( dataCtxNode.$$destroyed ) {
        return declViewModel._internal.origCtxNode;
    }

    return dataCtxNode;
};

/**
 * Return true if provided value is 'nil' (i.e. not null or undefined).
 *
 * @param {Object} value - The value to test.
 *
 * @returns {Boolean|null} true if provided value is 'nil' (i.e. not null or undefined).
 */
export let isNil = function( value ) {
    return value === undefined || value === null;
};

/**
 * Return a empty function
 *
 * @returns {null} null
 */
export const noop = () => null;

/**
 * The function will attempt to locate the 'nearest' 'declViewModel' in the 'dataCtxTree' starting at the given
 * 'dataCtxNode'.
 *
 * @param {Object} dataCtxNode - The leaf 'dataCtxNode' (a.k.a AngularJS '$scope') in the 'dataCtxTree' to start the
 *            lookup of the 'declViewModel'.
 *
 * @param {Boolean} setInScope - TRUE if, when found, the 'declViewModel' and 'appCtxService.ctx' should be set as
 *            the 'data' and 'ctx' properties (respectively) on the given dataCtxNode object.
 *
 * @param {AppCtxService} appCtxSvc - A reference to the service to set on the 'dataCtxNode' IFF 'setInScope' is
 *            TRUE.
 *
 * @return {DeclViewModel} The 'declViewModel' found.
 */
export let findViewModel = function( dataCtxNode, setInScope ) {
    /**
     * Check for the case where the declViewModel is already set on the given node.
     */
    if( dataCtxNode.data ) {
        /** revisitme
        if( setInScope && appCtxSvc && !dataCtxNode.ctx ) {
            dataCtxNode.ctx = appCtxSvc.ctx;
        }
        */

        return dataCtxNode.data;
    }

    /**
     * Look for the model on a 'parent' node.
     */
    var currCtxNode = dataCtxNode;

    while( currCtxNode && !currCtxNode.data ) {
        currCtxNode = currCtxNode.$parent;
    }

    if( currCtxNode ) {
        if( setInScope ) {
            dataCtxNode.data = currCtxNode.data;

            /** revisitme
            if( appCtxSvc ) {
                dataCtxNode.ctx = appCtxSvc.ctx;
            }
            */

            //if subPanelContext is available on scope then add it dataCtxNode
            if( currCtxNode.subPanelContext ) {
                dataCtxNode.subPanelContext = currCtxNode.subPanelContext;
            }

            /**
             * Setup to clean up these references when this particular 'dataCtxNode' is later destroyed.
             */
            if( dataCtxNode.$on ) {
                dataCtxNode.$on( '$destroy', function( data ) {
                    data.currentScope.data = null;
                    data.currentScope.ctx = null;
                } );
            }
        }

        return currCtxNode.data;
    }

    return null;
};

/**
 * Consolidate the second object's properties into the first one
 *
 * @param {Object} targetObj - The 'target' object to merge to
 * @param {Object} sourceObj - The 'source' object to be merge from
 *
 * @return {Object} The 'target' object, updated (or a new object set to the 'source' if the 'target' did not exist.
 */
export let consolidateObjects = function( targetObj, sourceObj ) {
    var returnObj = null;

    if( targetObj ) {
        returnObj = targetObj;

        _.forEach( sourceObj, function( n, key ) {
            returnObj[ key ] = n;
        } );
    } else if( sourceObj ) {
        returnObj = sourceObj;
    }

    return returnObj;
};

/**
 * Create custom event. Mainly for IE
 *
 * @param {String} eventName - Name of the event
 *
 * @param {Object} eventDetail - Object for event detail

 * @param {Object} canBubble -is bubble is up/down

 * @param {Object} isCancellable - event can ne canclable or not
 *
 * @return {DOMElement} created DOMElement
 */
export let createCustomEvent = function( eventName, eventDetail, canBubble, isCancellable ) {
    if( browserUtils.isNonEdgeIE ) {
        var evt = document.createEvent( 'CustomEvent' );
        evt.initCustomEvent( eventName, canBubble, isCancellable, eventDetail );
        return evt;
    }
    return new CustomEvent( eventName, {
        detail: eventDetail,
        bubbles: canBubble
    } );
};

/**
 * process output data
 * @param {JSON} outputData output data definition
 * @param {object} result function result
 * @returns {object} data patch as:
 * {
 *     "ctx.b": 3,
 *     "data.c": 5
 * }
 */
export const processOutputData = ( outputData, result ) => {
    if( outputData ) {
        const value = {};
        for( let vmPath in outputData ) {
            let valPath = outputData[ vmPath ];
            let res = undefined;
            if( _.isBoolean( valPath ) ) {
                res = valPath;
            } else {
                var expression = parsingUtils.getStringBetweenDoubleMustaches( valPath );
                if( _.startsWith( expression, 'json:' ) ) {
                    var jsonStringVariable = expression.replace( 'json:', '' );
                    var jsonString = _.get( result, jsonStringVariable );
                    res = parsingUtils.parseJsonString( jsonString );
                } else {
                    res = valPath && valPath.length > 0 ? _.get( result, valPath ) : result;
                }
            }
            // TODO: move it to createDeclViewModel to fill up 'aaa' to 'data.aaa'
            value[ /^ctx\./.test( vmPath ) ? vmPath : `data.${vmPath}` ] = res;
        }
        return value;
    }
    return undefined;
};

/**
 * Evaluate condition expression
 *
 * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.
 * @param {String} expression expression {note: currently supporting ==,!=,&&,>,>=,<,<=}
 * @param {Object} evaluationEnv - the data environment for expression evaluation
 * evaluation
 *
 * @return {Boolean} the evaluated condition result
 */
export let evaluateCondition = function( declViewModel, expression, evaluationEnv ) {
    let parse = AwParseService.instance;
    return parse( expression )( evaluationEnv );
};

/**
 * Evaluate condition expression
 *
 * @param {DeclViewModel} declViewModel - (Not Used) The model to use when evaluating.
 * @param {String} condition name of condition
 *
 * @return {String} the evaluated condition result
 */
export let getConditionExpression = function( declViewModel, condition ) {
    var conditionExpression = null;

    if( _.startsWith( condition, 'conditions.' ) ) {
        var conditionObject = _.get( declViewModel._internal, condition );

        conditionExpression = conditionObject.expression;
    } else {
        conditionExpression = condition;
    }

    return conditionExpression;
};

/**
 * Evaluate condition name
 *
 * @param {String} conditionString name of condition
 *
 * @return {String} the evaluated condition result
 */
export let getConditionName = function( conditionString ) {
    if( _.startsWith( conditionString, 'conditions.' ) ) {
        var index = conditionString.indexOf( '.' );
        return conditionString.substr( index + 1 );
    }
    return null;
};

/**
 * Get dirty properties of the view model object
 *
 * @param {Object} vmo - the view model object
 *
 * @return {Array} the dirty properties of the view model object
 */
export let getAllModifiedValues = function( vmo ) {
    var modifiedProperties = [];
    if( vmo ) {
        modifiedProperties = vmo.getDirtyProps();
    }
    return modifiedProperties;
};

/**
 * Update the properties of the view model property with new values
 *
 * @param {Object} dataObject - view model object.
 * @param {Object} dataProperty - view model object property.
 * @param {Object} dataPropertyValue - view model object property value.
 */
export let updatePropertyValues = function( dataObject, dataProperty, dataPropertyValue ) {
    dataObject[ dataProperty ] = dataPropertyValue;
    return {
        data:{ ...dataObject }
    };
};

/**
 * get type hierarchy from modleObject or view model Object
 *
 * @param {Object} dataObject - view model object.
 *
 *  @return {Array} - hierarchy of model object names

 */
export let getTypeHierarchy = function( dataObject ) {
    return dataObject.typeHierarchy || dataObject.modelType && dataObject.modelType.typeHierarchyArray;
};

/**
 *  get functions used in action input/output data
 */
let getActionDataFunc = function( value, functionsUsedInActions ) {
    if( typeof value === 'string' ) {
        var results = value.match( parsingUtils.REGEX_DATABINDING );
        if( results && results.length === 4 ) {
            var newVal = results[ 2 ];
            if( _.startsWith( newVal, 'function:' ) ) {
                functionsUsedInActions.push( newVal.replace( 'function:', '' ) );
            }
        }
    }
    return functionsUsedInActions;
};

/**
 * Get Function dependancies
 *
 * @param {Object} action - The action object
 *
 * @param {Object} viewModel - The view model
 *
 * @return {Array} - The Array contains function dependancies to load.
 */
export let getFunctionDeps = function( action, viewModel ) {
    var depsToLoad = [];
    var functionsUsedInActions = [];
    const functions = viewModel.functions;
    // get functions used in action input data
    if( action && action.inputData ) {
        _.forEach( action.inputData.request, function( value ) {
            getActionDataFunc( value, functionsUsedInActions );
        } );
    }
    if( action && action.outputData ) {
        _.forEach( action.outputData, function( value ) {
            getActionDataFunc( value, functionsUsedInActions );
        } );
    }
    if( action && action.dataParsers && action.dataParsers.length ) {
        _.forEach( action.dataParsers, dataParser => {
            const dataParserDef = viewModel.dataParseDefinitions[ dataParser.id ];
            const fnUsedInDataParsers = getFunctionUsageRecursive( dataParserDef );
            _.forEach( fnUsedInDataParsers, fnUsed => getActionDataFunc( fnUsed, functionsUsedInActions ) );
        } );
    }
    if( functions ) {
        _.forEach( functions, function( func ) {
            if( func.deps && depsToLoad.includes( func.deps ) === false &&
                functionsUsedInActions.includes( func.functionName ) ) {
                depsToLoad.push( func.deps );
            }
        } );
    }
    return depsToLoad;
};

const getFunctionUsageRecursive = ( object ) => {
    let values = [];
    _.each( object, ( value ) => {
        if( _.isString( value ) && value.startsWith( '{{function:' ) ) {
            values.push( value );
        } else if( _.isObject( value ) ) {
            values = values.concat( getFunctionUsageRecursive( value ) );
        }
    } );
    return values;
};

/**
 * Build common proprty Place holder
 *
 *
 * @param {Object} prop - raw property
 *
 * @return {object}  - propAttrHolder will blank if not valid VMP else filled
 */

export let buildPropHolder = ( prop ) => {
    let propAttrHolder = {};

    _.forEach( prop, function( dataPropValue, dataPropName ) {
        if( exports.attrHolderPropName.indexOf( dataPropName ) > -1 ) {
            propAttrHolder[ dataPropName ] = dataPropValue;
        }
    } );

    return propAttrHolder;
};

export let getLatestContext = function( dataCtxNode, declViewModel ) {
    let subPanelContext = null;
    let ports = null;
    let conditions = null;

    if( dataCtxNode && dataCtxNode.getProps && _.isFunction( dataCtxNode.getProps ) ) {
        let props = dataCtxNode.getProps();
        dataCtxNode.props = props;
        subPanelContext = props.subPanelContext;
    }

    if( dataCtxNode && dataCtxNode.getFields && _.isFunction( dataCtxNode.getFields ) ) {
        dataCtxNode.fields = dataCtxNode.getFields();
    }

    if( declViewModel && declViewModel.getData && _.isFunction( declViewModel.getData ) ) {
        let val = declViewModel.getData();
        if( val.hasOwnProperty( 'data' ) ) {
            declViewModel.data = val.data;
        } else {
            declViewModel.data = val;
        }
    }

    if( dataCtxNode && !dataCtxNode.conditions && declViewModel ) {
        conditions = declViewModel.conditions;
        dataCtxNode.conditions = conditions;
    }

    if( !dataCtxNode ) {
        dataCtxNode = {};
    } else {
        ports = dataCtxNode.ports;
    }

    return {
        ...dataCtxNode,
        data: declViewModel,
        ctx: { ...dataCtxNode.ctx, ...appCtxSvc.ctx },
        parameters: dataCtxNode.parameters,
        subPanelContext: subPanelContext ? subPanelContext : declViewModel.subPanelContext,
        commandContext: dataCtxNode.commandContext,
        pasteContext: dataCtxNode.pasteContext,
        ports: ports ? ports : declViewModel._internal.ports
    };
};

exports = {
    buildLifeCycleIssueMessage,
    logLifeCycleIssue,
    assertValidModel,
    cloneData,
    /** revisitme
    updateFormData,
    */
    assertValidModelWithOriginalJSON,
    assertValidModelAndDataCtxNode,
    isValidModelAndDataCtxNode,
    assertValidModelDataCtxNodeAndAction,
    assertValidModelDataCtxNodeAndAction2,
    assertValidModelAndEventData,
    isValidModelAndEventData,
    applyMessageParams,
    resolveLocalDataCtx,
    isNil,
    findViewModel,
    consolidateObjects,
    createCustomEvent,
    evaluateCondition,
    getConditionExpression,
    getConditionName,
    getAllModifiedValues,
    updatePropertyValues,
    getFunctionDeps,
    getTypeHierarchy,
    processOutputData,
    noop,
    loadDependentModule,
    attrHolderPropName,
    buildPropHolder,
    getLatestContext
};
export default exports;
