// Copyright (c) 2020 Siemens

/**
 * This module provides a way for declarative framework to do outgoing calls like SOA or REST.
 *
 * @module js/actionService
 *
 * @namespace actionService
 */

import soaSvc from 'soa/kernel/soaService';
import declarativeDataCtxSvc from 'js/declarativeDataCtxService';
import propertyPolicySvc from 'soa/kernel/propertyPolicyService';
import appCtxSvc from 'js/appCtxService';
import messagingSvc from 'js/messagingService';
import conditionSvc from 'js/conditionService';
import navigationService from 'js/navigationService';
import adapterSvc from 'js/adapterService';
import dataMapperSvc from 'js/dataMapperService';
import cfgSvc from 'js/configurationService';
import batchActionService from 'js/batchActionService';
/** revisitme Shaishav
 * Hint: We need to bring following services
import wysModeSvc from 'js/wysiwygModeService';
*/
import _ from 'lodash';
import eventBus from 'js/eventBus';
import browserUtils from 'js/browserUtils';
import parsingUtils from 'js/parsingUtils';
import declUtils from 'js/declUtils';
import logger from 'js/logger';
import moduleLoader from 'js/moduleLoader';

// Services
import AwHttpService from 'js/awHttpService';
import AwPromiseService from 'js/awPromiseService';
import ClipboardService from 'js/clipboardService';
import debugService from 'js/debugService';

/**
 * {StringAray} Props to include when logging the properties of a dseclAction.
 */
var _actionPropsToLog = [ 'actionId', 'actionType', 'method', 'serviceName', 'deps', 'actionId' ];

/**
 * {Boolean} TRUE if 'action' activity should be logged to the log service.
 * <P>
 * Note: This flag is controlled by the existence of the 'logActionActivity' attribute in the current
 * document's URL.
 */
var _logActionActivity = browserUtils.getUrlAttributes().logActionActivity !== undefined;

/**
 * {Boolean} TRUE if 'action' event activity should be logged to the log service.
 * <P>
 * Note: This flag is controlled by the existence of the 'logActionEventActivity' attribute in the current
 * document's URL.
 */
var _logActionEventActivity = browserUtils.getUrlAttributes().logActionEventActivity !== undefined;

/**
 * Define public API
 */
var exports = {};

/**
 * Makes SOA call with given action and inputData. return the promise object.
 *
 * @param {Object} action - The 'declAction' object.
 * @param {Object} inputData - The 'inputData' object.
 *
 * @return {Promise} A promise object resolved with the results of the SOA call (or rejected if there is a
 *         problem).
 */
var _callSOA = function( action, inputData, propertyPolicyOverride ) {
    var promise = null;
    if( action.actionType === 'TcSoaService' ) {
        if( action.serviceName ) {
            if( action.inputData ) {
                promise = soaSvc.postUnchecked( action.serviceName, action.method, inputData, propertyPolicyOverride, null, action.headerState );
            } else {
                promise = AwPromiseService.instance.reject( 'No TcSoaService input data specified' );
            }
        } else {
            promise = AwPromiseService.instance.reject( 'No TcSoaService service specified' );
        }
    } else {
        promise = AwPromiseService.instance.reject( 'Unknown action type: ' + action.actionType );
    }
    return promise;
};

var actionInputDataLogging = function( action, inputData ) {
    /**
     * Now that any binding has happened, log the current action (if necessary)
     */
    if( _logActionActivity ) {
        logger.info( 'action: ' + '\n' + JSON.stringify( action, _actionPropsToLog, 2 ) );

        if( action.actionType === 'RESTService' ) {
            logger.info( 'RESTService.inputData: ' + '\n' + JSON.stringify( inputData, null, 2 ) );
        } else if( action.actionType === 'GraphQL' || action.actionType === 'JSFunctionAsync' && action.method === 'callGraphQL' ) {
            logger.info( 'GraphQL.inputData: ' + '\n' + JSON.stringify( inputData, null, 2 ) );
            if( action.outputData ) {
                logger.info( 'GraphQL.outputData: ' + '\n' + JSON.stringify( action.outputData, null, 2 ) );
            }
        }
    }
};

var processActionTypeEvent = function( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred ) {
    setTimeout( function() {
        if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {
            declUtils.logLifeCycleIssue( declViewModel, action, 'Action not processed.',
                'applyExpression' );
            return;
        }
        // here needs updated info and eveulation context
        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
        /**
         * Loop for each 'event' type action and publish the ones who's conditions are
         * currently TRUE.
         */
        _.forEach( action.inputData.events, function( event ) {
            var conditionValue = true;

            if( event.condition ) {
                conditionValue = conditionSvc.evaluateConditionExpression( event.condition, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );
            }

            if( conditionValue ) {
                if( _logActionEventActivity ) {
                    logger.info( 'action: ' + '\n' +
                        JSON.stringify( action, _actionPropsToLog, 2 ) + '\n' +
                        'ActionEvent: ' + event.name );
                }

                var eventDataToPublish = {};

                if( event.eventData ) {
                    eventDataToPublish = _.cloneDeep( event.eventData );

                    declarativeDataCtxSvc.applyScope( localContext.data, eventDataToPublish,
                        functionsList, localContext, depModuleObj );
                }

                eventDataToPublish._source = declViewModel._internal.modelId;

                if( event.excludeLocalDataCtx !== true ) {
                    eventDataToPublish.scope = localContext;
                }

                if( logger.isDeclarativeLogEnabled() ) {
                    debugService.debugEventPub( action, event, localContext.data, localContext, eventDataToPublish );
                }

                eventBus.publish( event.name, eventDataToPublish, true );
            }
        } );

        deferred.resolve();
    }, 0 );
};

var processActionTypeJsFun = function( inputData, action, deferred, depModuleObj ) {
    var params = [];
    _.forEach( inputData, function( param ) {
        params.push( param );
    } );
    try {
        const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );
        if( typeof applyFn?.then === 'function' ) {
            applyFn.then(
                resolved => {
                    deferred.resolve( resolved );
                },
                err => {
                    deferred.reject( err );
                } );
        } else {
            deferred.resolve( applyFn );
        }
    } catch ( error ) {
        deferred.reject( {
            errorCode: error
        } );
    }
};

var getActionInputData = function( action, inputData ) {
    if( action.inputData ) {
        inputData = _.cloneDeep( action.inputData );
    } else if( action.navigationParams ) {
        if( typeof action.navigationParams === 'string' ) {
            inputData = { navigationParams: action.navigationParams };
        } else {
            inputData = _.cloneDeep( action.navigationParams );
        }
    }
    return inputData;
};

var eveulateActionParameters = function( dataCtxNode, action, inputData ) {
    // if dataCtxNode.paramter does not exist, we can assume action is not fired from event or event-data
    // does not exist. In that case we need to process the dataCtxNode.parameter section to get default value
    // for the parameters We might have some inputdata, which is referring to parameters section. The
    // below code scans the action.inputData for "{{parameters" keyword as value in action.inputdata.
    // {action: parameters: { "param1": "{{data.xyz}}"}, inputdata : { "key1":"{{parameter.param1}}"}}
    // and replaces them with the default value specified in parameters in action.inputdata :
    // {"key1":"{{data.param1}}" later we resolve the inputData, this helps us not to use applyScope
    // twice.
    if( !dataCtxNode.parameters && action.parameters ) {
        var keySequence = [];
        var pattern = /^{{parameters/;
        _.forEach( action.inputData, function processInputData( value, key ) {
            if( value && _.isObject( value ) ) {
                keySequence.push( key );
                _.forEach( value, processInputData );
                keySequence.pop();
            } else if( value && _.isString( value ) && pattern.test( value ) ) {
                keySequence.push( key );
                var eventMapKey = keySequence.join( '.' );
                var parameterKey = parsingUtils.getStringBetweenDoubleMustaches( value );
                _.set( inputData, eventMapKey, _.get( action, parameterKey, null ) );
                keySequence.pop();
            }
        } );
    }
};

var resolveInputData = function( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError ) {
    if( inputData ) {
        if( declViewModel.isDestroyed() ) {
            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',
                '_performAction' );
        } else {
            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
            try {
                declarativeDataCtxSvc.applyScope( localContext.data, inputData, functionsList, localContext,
                    depModuleObj );
            } catch ( error ) {
                inputError = error;
            }
        }
    }
    return inputError;
};

var _processAllDataProvider = function( dataProviderArray, declViewModel, dataCtxNode ) {
    var promises = [];

    _.forEach( dataProviderArray, function( providerObj ) {
        var provider = providerObj.dataProvider;
        /**
         * Check if the provider specifies specific objects to display on the 1st page<BR> If so: Load those
         * viewModelObjects into an array and update the dataProvider with them.<BR> If not: Just initialize
         * the dataProvider and let it decide what to load.
         */

        if( provider.json.firstPage ) {
            var firstPageObjs = [];

            _.forEach( provider.json.firstPage, function( uid ) {
                var vmos = declViewModel.objects[ uid ];
                if( Array.isArray( vmos ) ) {
                    Array.prototype.push.apply( firstPageObjs, vmos );
                } else if( vmos !== undefined ) { // LCS-165693 vmos will be undefined in case of dcp n cardinality and we don't want to add undefined vmos here.
                    firstPageObjs.push( vmos );
                }
            } );

            /**
             * This code evaluates the page size to determine if we need to increment total. This is
             * necessary for object sets, as we do not know the totalFound.
             */
            var maxToLoad;
            if( provider.action && provider.action.inputData ) {
                var actionInputData = provider.action.inputData;
                if( actionInputData.searchInput ) {
                    maxToLoad = actionInputData.searchInput.maxToLoad;
                }
            }

            var totalFound = firstPageObjs.length > 0 ? firstPageObjs.length + 1 : 0;
            if( maxToLoad ) {
                totalFound = firstPageObjs.length === maxToLoad ? firstPageObjs.length + 1 :
                    firstPageObjs.length;
            }

            provider.update( firstPageObjs, totalFound );
        } else {
            var args = [ dataCtxNode, declViewModel ];
            promises.push( provider[ providerObj.action ].apply( provider, args ) );
        }
    } );

    return AwPromiseService.instance.all( promises );
};

/**
 * Execute the given 'dataprovider action' using the given related parameters
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.
 * @param {DeclAction} action - The DeclAction to execute.
 * @param {Object} dataCtxNode - The data context to use during execution.
 *
 * @return {Promise} A promise resolved with an 'dataprovider action' when it is completed.
 */
export let performDataProviderAction = function( declViewModel, action, dataCtxNode ) {
    var dataProviderArray = [];

    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel );
    var createDataProviderInput = function( dataProvider, action ) {
        return {
            dataProvider: dataProvider,
            action: action ? action : 'initialize'
        };
    };

    if( action.methods && _.isArray( action.methods ) ) {
        _.forEach( action.methods, function( method ) {
            var dataProvider = declViewModel.dataProviders[ method ];
            var dpAction = action.inputData && action.inputData.action ? action.inputData.action : 'initialize';
            if( dataProvider ) {
                dataProviderArray.push( createDataProviderInput( dataProvider, dpAction ) );
            }
        } );
    } else if( action.method ) {
        if( action.inputData && action.inputData.action ) {
            // Table edit use case
            var dpAction = action.inputData.action;
            dataProviderArray.push( createDataProviderInput( declViewModel.dataProviders[ action.method ], dpAction ) );
        } else {
            // with the new implementation resetDataProvider will re-initialize the dataprovider.
            declViewModel.dataProviders[ action.method ].resetDataProvider();
        }
    } else {
        logger.warn( 'Missing action method(s) name for action: ' + '\n' +
            JSON.stringify( action, _actionPropsToLog, 2 ) );
    }

    if( !_.isEmpty( dataProviderArray ) ) {
        const { dispatch } = declViewModel;
        return _processAllDataProvider( dataProviderArray, declViewModel, dataCtxNode )
            .then( () => {
                // Rules to use dispatch:
                // - Make sure it is 'immutable change' otherwise it is not getting rerender
                // - Make sure 'immutable change' dosen't change the object type with no indention
                //   - {...x} will wash a object from 'Mytype' to 'Object', make sure u do it only on 'Object
                dispatch( { path: 'dataProviders', value: { ...declViewModel.dataProviders } } );
            } );
    }
    return 0;
};

var processActionTypePopup = function( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj ) {
    let popupAction = declViewModel.actions[ action.actionId ];
    let updateOptions = inputData && inputData.options || {};
    // override popupAction if defined in commandContext - AwCommandService
    // options could be overridden and customized
    if( dataCtxNode.commandContext?.popupAction ) {
        // case: it's a normal command
        popupAction = dataCtxNode.commandContext.popupAction;
    } else if( !popupAction.show ) {
        // case: it's a cell command, which always being destroyed when user clicked, hence use globalPopup take over.
        popupAction = appCtxSvc.getCtx( 'globalPopup' );
    }

    // case customized popup actions - inject popupAction as last params for action.method
    // application manages when / how to invoke show / hide
    if( action.method && action.deps ) {
        let params = [];
        _.forEach( inputData, function( param ) {
            params.push( param );
        } );
        params.push( popupAction, updateOptions );
        try {
            const applyFn = depModuleObj[ action.method ].apply( depModuleObj, params );
            if( typeof applyFn?.then === 'function' ) {
                applyFn.then(
                    resolved => {
                        deferred.resolve( resolved );
                    },
                    err => {
                        deferred.reject( err );
                    } );
            } else {
                deferred.resolve( applyFn );
            }
        } catch ( error ) {
            deferred.reject( {
                errorCode: error
            } );
        }
        // default plain popup actions
    } else {
        // TODO: build params based on inputData, props, viewData
        let evaluatedOptions = inputData && inputData.options || null;
        // only apply dynamic options
        // if( evaluatedOptions && ( !prop || !prop.popupAction ) ) {
        //     updateOptions = _.reduce( evaluatedOptions, ( result, value, key ) => {
        //         [ 'caption', 'subPanelContext' ].indexOf( key ) > -1 && ( result[ key ] = value );
        //         return result;
        //     }, {} );
        // }
        try {
            popupAction.show( evaluatedOptions ).then(
                function( resolved ) {
                    deferred.resolve( resolved );
                },
                function( err ) {
                    deferred.reject( err );
                } );
        } catch ( error2 ) {
            deferred.reject( {
                errorCode: error2
            } );
        }
    }
};

var processActionTypeCopy = function( inputData, promise ) {
    /**
     * This actionType is needed when we are dealing with OS commands like copying to clipboard
     * which needs to run without any defer mechanism. Since document.execCommand('copy') will
     * be successful only when it runs through a user click event and not with defer and digest
     * cycle event. we can use this actionType for other copy command too apart from shareURL
     * since it calls the same document.execCommand('copy') function after copying it to
     * awclipboard.
     */
    /**
     * There will be two copyTypes: one is copying URL to clipboard, other is copying an object.
     */
    if( inputData.copyType === 'URL' ) {
        var adaptedObjects = adapterSvc.getAdaptedObjectsSync( inputData.objectToCopy );

        ClipboardService.instance.copyUrlToClipboard( adaptedObjects );

        promise = AwPromiseService.instance.when();
    } else if( inputData.copyType === 'Object' ) {
        ClipboardService.instance.copyHyperlinkToClipboard( inputData.objectToCopy );

        promise = AwPromiseService.instance.when();
    }
    return promise;
};

var processActionTypeNaviagte = function( action, inputData ) {
    if( action.navigateTo ) {
        if( inputData.navigationParams ) {
            inputData = inputData.navigationParams;
        }
        return navigationService.navigate( action, inputData );
    }
    return AwPromiseService.instance.reject( 'Missing navigate to in action type: ' + action.actionType +
        ' for actionId: ' + action.actionId );
};

var processActionTypeEdit = function( action, declViewModel ) {
    var methods = [ 'startEdit', 'saveEdits', 'cancelEdits', 'isDirty' ];

    if( action.method && methods.indexOf( action.method ) !== -1 ) {
        return declViewModel[ action.method ].apply( declViewModel );
    }
    return AwPromiseService.instance.reject( 'Not a valid edit action : ' + action.method );
};

var processActionTypeSync = function( action, inputData, declViewModel ) {
    if( inputData.port ) {
        return import( 'js/syncStrategyService' ).then( function( syncStrategyService ) {
            return syncStrategyService.updatePort( declViewModel, inputData, exports );
        } );
    }
    return AwPromiseService.instance.reject( 'Missing port to in action type: ' + action.actionType + ' for actionId: ' + action.actionId );
};

var loadCustomActionDependentModule = function( customAction ) {
    var depModuleObj = moduleLoader.getDependentModule( customAction.deps );

    if( depModuleObj ) {
        return AwPromiseService.instance.resolve( depModuleObj );
    }
    return moduleLoader.loadDependentModule( customAction.deps ).then( function success( depModuleObj ) {
        return AwPromiseService.instance.resolve( depModuleObj );
    }, function reject( error ) {
        return AwPromiseService.instance.reject( error );
    } );
};

/**
 * Perform a action. Support calling SOA service, JavaScript function and RESTful API. A promise object will
 * be returned.
 *
 * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed
 * within.
 * @param {Object} action - The 'declAction' to be executed.
 * @param {FunctionArray} functionsList - An array of functions that can be used when applying the dataCtxNode values.
 * @param {Object} dataCtxNode - The data context node which holds interpolation values.
 * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be
 *            executed.
 * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a
 *         problem).
 * @param {Object} prop - (Optional) vmprops used for onMount lifecycle
 * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle
 */
var _performAction = function( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride ) {
    if( !action ) {
        return AwPromiseService.instance.reject( 'Missing action parameter' );
    }

    if( !action.actionType ) {
        return AwPromiseService.instance.reject( 'Missing action type for actionId: ' + action.actionId );
    }

    var inputData = null;
    var inputError = null;

    /**
     * If an 'alternate' set of 'inputData' is specified, use it as-is without applying the dataCtxNode values.
     * <P>
     * Note: This 'alternate' is used to handle async operations where the dataCtxNode can change between the
     * time the action is queued to be executed and when we get here.
     */

    if( action.altInputData ) {
        inputData = action.altInputData;
    } else {
        inputData = getActionInputData( action, inputData );

        eveulateActionParameters( dataCtxNode, action, inputData );

        inputError = resolveInputData( inputData, declViewModel, action, dataCtxNode, functionsList, depModuleObj, inputError );
    }

    /**
     * Now that any binding has happened, log the current action (if necessary)
     */
    actionInputDataLogging( action, inputData );

    /**
     * Check for an input error
     */
    var promise = null;

    var deferred;

    if( inputError ) {
        promise = AwPromiseService.instance.reject( {
            errorCode: inputError
        } );
        return promise;
    }

    return declarativeDataCtxSvc.applyExpression( inputData ).then(
        function() {
            debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'pre', action, declViewModel, inputData );
            if( action.actionType === 'dataProvider' ) {
                promise = exports.performDataProviderAction( declViewModel, action, dataCtxNode );
            } else if( action.actionType === 'TcSoaService' ) {
                promise = _callSOA( action, inputData, propertyPolicyOverride );
            } else if( action.actionType === 'RESTService' ) {
                promise = AwHttpService.instance( inputData.request );
            } else if( action.actionType === 'Event' ) {
                if( action.inputData ) {
                    deferred = AwPromiseService.instance.defer();
                    processActionTypeEvent( declViewModel, dataCtxNode, action, functionsList, depModuleObj, deferred );
                    promise = deferred.promise;
                }
            } else if( action.actionType === 'JSFunction' || action.actionType === 'JSFunctionAsync' ) {
                deferred = AwPromiseService.instance.defer();
                promise = deferred.promise;
                processActionTypeJsFun( inputData, action, deferred, depModuleObj );
            } else if( action.actionType === 'Test' ) {
                /**
                 * This actionType is meant to allow automated testing without the need for a live server to
                 * load dependent modules. The resolved data for the deferred action is just the same object
                 * that was given as the 'inputData'.
                 */
                deferred = AwPromiseService.instance.defer();
                promise = deferred.promise;
                deferred.resolve( inputData );
            } else if( action.actionType === 'popup' ) {
                deferred = AwPromiseService.instance.defer();
                promise = deferred.promise;
                processActionTypePopup( declViewModel, action, inputData, dataCtxNode, deferred, depModuleObj );
            } else if( action.actionType === 'Copy' ) {
                promise = processActionTypeCopy( inputData, promise );
            } else if( action.actionType === 'Navigate' ) {
                promise = processActionTypeNaviagte( action, inputData );
            } else if( action.actionType === 'Edit' ) {
                promise = processActionTypeEdit( action, declViewModel );
            } else if( action.actionType === 'batchJob' ) {
                promise = batchActionService.executeBatchActions( declViewModel, action, dataCtxNode, exports );
            } else if( action.actionType === 'Sync' ) {
                return processActionTypeSync( action, inputData, declViewModel );
            } else {
                // process custom Action Type
                deferred = AwPromiseService.instance.defer();
                promise = deferred.promise;
                processActionTypeCustom( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj );
            } // end of custom action
            return promise;
        } );
};

var processActionTypeCustom = function( action, inputData, declViewModel, dataCtxNode, deferred, functionsList, depModuleObj ) {
    cfgSvc.getCfg( 'actionTemplateDefs' ).then( function( actionTemplateDefs ) {
        if( actionTemplateDefs[ action.actionType ] ) {
            var customAction = _.cloneDeep( actionTemplateDefs[ action.actionType ] );
            // resolver for inputData defined at successive action template defs that include
            // ctx, data and inputData
            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
            var resolver = {
                ...localContext,
                inputData: inputData
            };
            // load the dependent modules if deps is specified
            if( customAction.deps ) {
                var depModuleObjPromise = loadCustomActionDependentModule( customAction );

                depModuleObjPromise.then( function( depModuleObj ) {
                    deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );
                } );
            } else {
                deferred.resolve( _performAction( declViewModel, customAction, functionsList, resolver, depModuleObj ) );
            }
        } else {
            logger.error( 'error :: action type ->' + action.actionType + ' is missing.' );
            deferred.reject( 'Unknown action type: ' + action.actionType );
        }
    } );
};

var processDefaultErrorMsg = function( err, action ) {
    //var msg = null;
    //var level = 1;
    if( _.isString( err ) ) {
        /**msg = err;
        level = 3; */
    } else if( err && err.message ) {
        /**msg = err.message.replace( /\n/g, '<br>' );
        level = err.level ? err.level : 3; */
    } else {
        /**msg = 'Unknown error message type for action ' + action.method;
        level = 3;*/
        logger.error( err );
    }
    /** revisitme Shaishav
         * Hint: We need to bring wysiwygModeService
         if( level <= 1 ) {
             logger.info( msg );
         } else {
             wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( msg ) : logger.error( msg );
         }
    */
};

var processDefaultErrorTypeObject = function( err, isReported ) {
    var errInfo = null;
    if( err.config && err.status && ( err.status < 200 || err.status > 299 ) ) {
        /**
         * Error from Angular's $http service.
         */
        errInfo = {
            url: err.config.url,
            method: err.config.method,
            status: err.status,
            statusText: err.statusText
        };
    } else if( err.cause && err.cause.config ) {
        /**
         * Error due to lost network connectivity, server crash etc.
         */
        errInfo = {
            url: err.cause.config.url,
            method: err.cause.config.method,
            status: err.cause.status,
            statusText: err.cause.statusText
        };
    }

    if( errInfo !== null ) {
        var errMsg = 'The HTTP "' + errInfo.method + '" method to url "' + errInfo.url + '" failed';

        if( _.isString( errInfo.statusText ) && errInfo.statusText.length > 0 ) {
            errMsg = errMsg + ' (status = "' + errInfo.statusText + '").';
        } else {
            errMsg = errMsg + ' (status = "' + errInfo.status + '").';
        }

        isReported = true;

        logger.error( errMsg );
    }
    return isReported;
};

const parseConditonExp = ( expression, evaluationEnv ) => {
    //This is not acomplete fix, needs to be revisited - LCS-565498
    const exp = conditionSvc.getRealExpression( expression, evaluationEnv );
    if( _.isString( exp ) ) {
        return exp;
    }
    //If the condition is object based, return the original expression
    return expression;
};

/**
 * Process the events of the executed action
 *
 * @param {DeclViewModel} declViewModel - The declarative view model
 * @param {DeclAction} action - The declarative action.
 * @param {Object} events - The events of an action object on the View model
 * @param {Object} evaluationEnv - The environment on which to evaluate event conditions
 * @param {Object} dataCtxNode - The data context
 * @param {ModuleObject} depModuleObj - The dependent module object
 * @param {Boolean} isSuccess - TRUE if we are processing 'success' of the action. FALSE if processing
 *            action 'failure'.
 */
var _processActionEvents = function( declViewModel, action, events, evaluationEnv, dataCtxNode, depModuleObj,
    isSuccess ) {
    /**
     * Check if there is no reason to continue.
     */
    if( _.isEmpty( events ) ) {
        return;
    }

    //new in afx 3.1.0
    if( declViewModel.isDestroyed() ) {
        declUtils.logLifeCycleIssue( declViewModel, action, 'Action event(s) not processed.', '_processActionEvents' );
        return;
    }

    var functionsList = declViewModel._internal.functions;

    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'events' );

    _.forEach( events, function( event ) {
        /**
         * Fire event when condition value is true
         */
        var conditionValue = true;

        if( event.condition ) {
            const expression = parseConditonExp( event.condition, declViewModel._internal );
            conditionValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );
        }

        if( conditionValue ) {
            if( _logActionEventActivity ) {
                if( isSuccess ) {
                    logger.info( 'action: ' + '\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\n' +
                        'SuccessEvent: ' + event.name );
                } else {
                    logger.info( 'action: ' + '\n' + JSON.stringify( action, _actionPropsToLog, 2 ) + '\n' +
                        'FailureEvent: ' + event.name );
                }
            }
            var eventData = {};
            if( event.eventData ) {
                eventData = _.cloneDeep( event.eventData );
                declarativeDataCtxSvc.applyScope( declViewModel, eventData, functionsList, dataCtxNode,
                    depModuleObj );
            }
            if( event.excludeLocalDataCtx !== true ) {
                eventData.scope = dataCtxNode;
            }
            eventData._source = declViewModel._internal.modelId;
            eventBus.publish( event.name, eventData, true );

            if( logger.isDeclarativeLogEnabled() ) {
                debugService.debugEventPub( action, event, declViewModel, dataCtxNode, eventData );
            }
        }
    } );
};

var processActionFailureEvents = function( events, err, evaluationEnv, declViewModel, action, dataCtxNode, depModuleObj ) {
    if( events && events.failure ) {
        if( err.cause && err.cause.partialErrors ) {
            /**
             * Add the error in the evaluation env for each of the events
             */
            _.forEach( events.failure, function( failureEvt ) {
                _.forEach( err.cause.partialErrors, function( partialError ) {
                    if( partialError.errorValues ) {
                        _.forEach( partialError.errorValues, function( errorValue ) {
                            if( errorValue.code ) {
                                evaluationEnv.errorCode = errorValue;

                                if( !evaluationEnv.errorCodes ) {
                                    evaluationEnv.errorCodes = [];
                                }

                                evaluationEnv.errorCodes.push( errorValue );
                            }
                        } );
                    }
                } );

                _processActionEvents( declViewModel, action, [ failureEvt ], evaluationEnv, dataCtxNode,
                    depModuleObj, false );
            } );

            // If REST call is failed with error
        } else if( err.status || err.response?.status  ) {
            // Add the error in the evaluation env for each of the events
            evaluationEnv.errorCode = err;

            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,
                depModuleObj, false );
        } else {
            // Process all events in bulk
            _processActionEvents( declViewModel, action, events.failure, evaluationEnv, dataCtxNode,
                depModuleObj, false );
        }
    }
};

var processPartialError = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {
    let matchingMessages = [];
    _.forEach( err.cause.partialErrors, function( partialError ) {
        if( partialError.errorValues ) {
            _.forEach( partialError.errorValues, function( errorValue ) {
                if( errorValue.code ) {
                    _.forEach( actionMessages.failure, function( failureErr ) {
                        var condValue = true;

                        if( failureErr.condition ) {
                            evaluationEnv.errorCode = errorValue;
                            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );
                            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );
                        }

                        if( condValue ) {
                            if( !failureErr.errorCode ) {
                                failureErr.errorCode = [];
                            }
                            failureErr.errorCode.push( errorValue );

                            if( matchingMessages.indexOf( failureErr ) === -1 ) {
                                matchingMessages.push( failureErr );
                            }
                        }
                    } );
                }
            } );
        }
    } );
    return matchingMessages;
};

var processActionHavingCause = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj ) {
    let allMessages = null;
    let isReported = false;
    _.forEach( err.cause.messages, function( message ) {
        if( message.code ) {
            _.forEach( actionMessages.failure, function( failureErr ) {
                let conditionResult = false;
                if( failureErr.condition ) {
                    // two variations of condition in actionMessages : errorCode.code === 123 OR errorCode === 123
                    evaluationEnv.errorCode = failureErr.condition.indexOf( '.code' ) > -1 ? message : message.code;
                    const expression = parseConditonExp( failureErr.condition, declViewModel._internal );
                    conditionResult = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );
                }
                if( conditionResult || failureErr.message && failureErr.condition === undefined ) {
                    isReported = true;

                    if( !allMessages ) {
                        allMessages = _.cloneDeep( declViewModel._internal.messages );
                    }

                    evaluationEnv.errorCode = message.message;
                    messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message, evaluationEnv );
                }
            } );
        }
    } );
    return isReported;
};

var processActionHavingErrorCode = function( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode ) {
    var isReported = false;
    var allMessages = null;
    /**
     * Notify error raised by a JS function call
     */
    _.forEach( actionMessages.failure, function( failureErr ) {
        var condValue = true;
        if( failureErr.condition ) {
            if( err.status || err.response?.status ) {
                // In case failure is from REST call
                evaluationEnv.errorCode = err;
            } else {
                evaluationEnv.errorCode = err.errorCode;
            }
            const expression = parseConditonExp( failureErr.condition, declViewModel._internal );
            condValue = conditionSvc.evaluateConditionExpression( expression, declViewModel, { evaluationEnv, depModuleObj } );
        }
        if( condValue ) {
            isReported = true;

            if( !allMessages ) {
                allMessages = _.cloneDeep( declViewModel._internal.messages );
            }

            messagingSvc.reportNotyMessage( declViewModel, allMessages, failureErr.message,
                dataCtxNode, depModuleObj );
        }
    } );

    return isReported;
};

var processActionFailureMessage = function( actionMessages, err, evaluationEnv, declViewModel, depModuleObj, isReported, dataCtxNode ) {
    if( actionMessages && actionMessages.failure ) {
        if( err.cause && err.cause.partialErrors ) {
            // Notify error message when condition matched
            var allMessages;
            if( actionMessages.failure.length > 0 ) {
                var matchingMessages = [];
                var scopedAllMessages = [];
                var reportError = function( failureErr, idx ) {
                    evaluationEnv.errorCode = failureErr.errorCode.reduce( ( acc, err, index, arr ) => {
                        acc += err.message + ( arr.length - 1 === index ? '' : '<br/>' );
                        return acc;
                    }, '' );

                    messagingSvc.reportNotyMessage( declViewModel, scopedAllMessages[ idx ], failureErr.message,
                        evaluationEnv );
                    failureErr.errorCode = null;
                };

                matchingMessages = processPartialError( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );
                if( !allMessages && matchingMessages.length > 0 ) {
                    allMessages = _.cloneDeep( declViewModel._internal.messages );
                    scopedAllMessages.push( allMessages );
                    isReported = true;
                }
                matchingMessages.forEach( function( message, index ) {
                    reportError( message, index );
                } );
            } else {
                /**
                 * Notify SOA error message when no condition specified

                var errMessage = messagingSvc.getSOAErrorMessage( err ); */
                isReported = true;
                /** revisitme Shaishav
                 * Hint: We need to bring wysiwygModeService. Also, the file in declarativeui module
                 * should not depend on layer 3 modules. We need to correct that.
                wysModeSvc.isWysiwygMode( dataCtxNode ) ? logger.info( errMessage ) : messagingSvc.showError( errMessage );
                */
            }
        } else if( err.cause && err.cause.messages ) {
            isReported = processActionHavingCause( err, actionMessages, evaluationEnv, declViewModel, depModuleObj );
        } else if( err.errorCode || err.status || err.response?.status ) {
            isReported = processActionHavingErrorCode( err, actionMessages, evaluationEnv, declViewModel, depModuleObj, dataCtxNode );
        }
    }
    return isReported;
};

var performOutputDataMapping = function( resolvedAssignments, declViewModel, prop ) {
    const { dispatch, updateAtomicData } = declViewModel;
    let finalObj = {};

    for( prop in resolvedAssignments ) {
        // special property
        const basePath = prop.split( '.' )[ 0 ];
        if( declViewModel.atomicData && declViewModel.atomicData[ basePath ] ) {
            _.set( declViewModel.atomicData, prop, resolvedAssignments[ prop ] );
            updateAtomicData[ basePath ]( _.cloneDeep( declViewModel.atomicData[ basePath ] ) );
        } else {
            let key = `data.${prop}`;
            finalObj[ key ] = resolvedAssignments[ prop ];
        }
    }

    if( dispatch && Object.keys( finalObj ).length > 0 ) {
        dispatch( { value: finalObj } );

        _.forEach( resolvedAssignments, function( fromPath, toPath ) {
            _.set( declViewModel, toPath, fromPath );
        } );
    }
};

var loadFuncDependency = function( action, declViewModel, depModuleObj ) {
    // load function deps
    var functionDeps = declUtils.getFunctionDeps( action, declViewModel._internal );

    // Filter already loaded deps
    _.forEach( depModuleObj, function( funcValue, funcKey ) {
        var loaded = _.find( functionDeps, function( funcDep ) {
            // LCS-299148 Beyond Angular: Clean up app.getInjector usage
            // funcKey here is module name, fundDep here is js/fileName
            // luckly it is passing today
            return funcDep.includes( funcKey );
        } );
        if( loaded ) {
            _.remove( functionDeps, function( funcDep ) {
                return funcDep === loaded;
            } );
        }
    } );

    return functionDeps;
};

var getActionPolicyInfo = function( action, declViewModel, functionsList, dataCtxNode, depModuleObj ) {
    if( action.policy && action.actionType === 'TcSoaService' ) {
        var policy = _.cloneDeep( action.policy );

        declarativeDataCtxSvc.applyScope( declViewModel, policy, functionsList, dataCtxNode, depModuleObj );
        if( policy.override === true ) {
            return { propertyPolicyOverride: { types: policy.types } };
        }
        return { actionPolicyId: propertyPolicySvc.register( { types: policy.types }, action.method + '_Policy' ) };
    }
    return {};
};

/**
 * Process the 'Success' part of the executed action
 *
 * @param {Object} declViewModel - The declarative view model
 * @param {Object} action - The action object on the View model
 * @param {Object} dataCtxNode - The data context
 * @param {ModuleObject} depModuleObj - The dependent module object
 */
var _processSuccess = function( declViewModel, action, dataCtxNode, depModuleObj ) {
    var events = action.events;
    var actionMessages = action.actionMessages;
    var allMessages;

    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );

    if( events && events.success ) {
        _processActionEvents( localContext.data, action, events.success, localContext, localContext, depModuleObj,
            true );
    }

    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );

    if( actionMessages && actionMessages.success ) {
        _.forEach( actionMessages.success, function( successMessage ) {
            if( successMessage ) {
                var condValue = true;

                if( successMessage.condition ) {
                    const expression = parseConditonExp( successMessage.condition, declViewModel._internal );
                    condValue = conditionSvc.evaluateConditionExpression( expression, localContext.data, { evaluationEnv : { ...localContext }, depModuleObj } );
                }

                if( condValue ) {
                    if( !allMessages ) {
                        allMessages = _.cloneDeep( declViewModel._internal.messages );
                    }

                    messagingSvc.reportNotyMessage( localContext.data, allMessages, successMessage.message,
                        localContext );
                }
            } else {
                logger.error( 'Invalid action successMessage:' + successMessage );
            }
        } );
    }
};

/**
 * Process the error and the 'Failure' part of the executed action
 *
 * @param {Object} err - JavaScript Error object
 * @param {Object} declViewModel - The declarative view model
 * @param {Object} action - The action object on the View model
 * @param {Object} dataCtxNode - The data context
 * @param {ModuleObject} depModuleObj - The dependent module object
 */
var _processError = function( err, declViewModel, action, dataCtxNode, depModuleObj ) {
    var events = action.events;
    var actionMessages = action.actionMessages;
    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );

    processActionFailureEvents( events, err, localContext, localContext.data, action, localContext, depModuleObj );

    var isReported = false;

    debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'actionMessages' );

    isReported = processActionFailureMessage( actionMessages, err, localContext, localContext.data, depModuleObj, isReported, localContext );

    if( !isReported && typeof err === 'object' ) {
        isReported = processDefaultErrorTypeObject( err, isReported );
    }

    /**
     * Fall back, report error if not raised till this point
     */
    if( !isReported ) {
        processDefaultErrorMsg( err, action );
    }
};

/**
 * @param {DeclViewModel} declViewModel - Model that owns the action.
 * @param {DeclAction} action - Action to 'finish'.
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 * @param {Object} depModuleObj - (Optional) Reference to any extra module used to finish the action.
 * @param {Object} actionResponseObj - The 'raw' object returned from the action itself.
 * @param {DeferredResolution} deferred - Deferred action resolved when the action is finished.
 */
var _finishAction = function( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred ) {
    var err = null;

    if( !_.isEmpty( actionResponseObj ) ) {
        if( !_.isEmpty( actionResponseObj.partialErrors ) || !_.isEmpty( actionResponseObj.PartialErrors ) ) {
            err = soaSvc.createError( actionResponseObj );
        }

        if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {
            err = soaSvc.createError( actionResponseObj.ServiceData );
        }
    }

    if( err ) {
        _processError( err, declViewModel, action, dataCtxNode, depModuleObj );

        deferred.reject( err );
    } else {
        _processSuccess( declViewModel, action, dataCtxNode, depModuleObj );

        deferred.resolve( actionResponseObj );
    }
};

var performOutputDataMappingForBatch = function( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred ) {
    var data = { actionData: [] };
    _.forEach( resolvedAssignments, function( fromPath, toPath ) {
        _.set( data.actionData, toPath, fromPath );
    } );
    _finishAction( declViewModel, action, dataCtxNode, depModuleObj, data,
        deferred );
};

var resolveActionOutputData = function( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode ) {
    var deferredAssignments = {};
    /**
     * Loop for each mapping in the 'outputData' spec
     */
    var index = 0;
    _.forEach( action.outputData, function( fromPath, toPath ) {
        var fromObj;

        if( mapDataOnAction && action.outputArg ) {
            toPath = action.outputArg[ index ];
        }

        if( _.isBoolean( fromPath ) ) {
            fromObj = fromPath;
        } else if( _.isEmpty( fromPath ) ) {
            /**
             * To support action as JS function call, assign function return value as the result
             * when empty value expression specified
             */
            fromObj = actionResponseObj;
        } else if( _.isString( fromPath ) && fromPath.indexOf( 'result.' ) === 0 ) {
            /**
             * If fromPath has a 'result.' prefix, parse the expression within fromPath to get
             * the correct value.
             */
            var fromResultPath = fromPath.split( 'result.' )[ 1 ];

            fromObj = _.get( actionResponseObj, fromResultPath );
        } else {
            /**
             * If fromPath is defined, parse the expression within fromPath to get the correct
             * value.
             */
            let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
            fromObj = declarativeDataCtxSvc.getOutput( declViewModel, actionResponseObj, fromPath,
                depModuleObj, localContext );
        }

        /**
         * If the toPath starts with ctx. update the appCtxService
         */
        if( toPath.indexOf( 'ctx.' ) === 0 ) {
            var toCtxName = toPath.split( 'ctx.' )[ 1 ];
            appCtxSvc.updatePartialCtx( toCtxName, fromObj );
        } else if( _.startsWith( toPath, 'ports.' ) ) {
            if( dataCtxNode.ports ) {
                _.set( dataCtxNode.ports, toPath.replace( 'ports.', '' ), fromObj );
            }
        } else {
            // The function can return a promise object. So delegating to AwPromiseService.instance.when to handle the
            // case in cleaner way
            deferredAssignments[ toPath ] = AwPromiseService.instance.when( fromObj );
        }
        index += 1;
    } );

    return deferredAssignments;
};

/**
 * @param {DeclViewModel} declViewModel - The {DeclViewModel} to check.
 * @param {Object} actionResponseObj - Optonal object resulting from the {DeclAction}
 * @param {DeclAction} action - {DeclAction} being performed
 * @param {DeferredResponse} deferred - Resolved or Rejected or untouched based on return value.
 * @param {String} methodName - Name of the method where the issues was found.
 *
 * @returns {Boolean} TRUE if the {DeclViewModel} has been destroyed and details are logged (based on
 * inputs) and the 'deferred' has been 'resolved'. FALSE if the {DeclViewModel} is still valid and the
 * 'deferred' remains untouched.
 */
var _isViewModelDestroyed = function( declViewModel, actionResponseObj, action, deferred, methodName ) {
    /**
     * Check if the declViewModel got destroyed while we were waiting for the action to complete. This can
     * happen, for example, when multiple subscribers are listening to a common event like 'selection' and
     * one of them (I'm looking at you GWT) causes the panel the declViewModel is associated with to close
     * (thus destroying the dataCtxNode and the declViewModel associated with it).
     * <P>
     * If so: There is nothing more that can be done with the declViewModel and we just want to log a
     * warning about the life cycle issue and 'resolve' the given 'deferred'.
     */
    if( declViewModel.isDestroyed() ) {
        /**
         * If the action is trying to actually do something with the response and the view model is
         * destroyed log an error
         */
        if( actionResponseObj ) {
            declUtils.logLifeCycleIssue( declViewModel, action, 'Action was therefore not finished.',
                methodName );
        }

        // Otherwise do nothing
        deferred.resolve();

        return true;
    }

    return false;
};

/**
 * Perform a SOA action. Support calling SOA service, return the response object.
 *
 * @param {Object} action - The 'declAction' to be executed.
 * @return {Promise} A promise object resolved with the results of the action (or rejected if there is a
 *         problem).
 */
export let performSOAAction = function( action ) {
    var deferred = AwPromiseService.instance.defer();
    _callSOA( action, action.inputData ).then( function( actionResponseObj ) {
        if( !declUtils.isNil( actionResponseObj ) ) {
            var err = null;
            if( actionResponseObj.partialErrors || actionResponseObj.PartialErrors ) {
                err = soaSvc.createError( actionResponseObj );
            }

            if( actionResponseObj.ServiceData && actionResponseObj.ServiceData.partialErrors ) {
                err = soaSvc.createError( actionResponseObj.ServiceData );
            }
            if( err ) {
                deferred.reject( err );
            } else if( !_.isEmpty( action.outputData ) ) {
                deferred.resolve( actionResponseObj );
            }
        }
    }, function( err ) {
        deferred.reject( err );
    } );
    return deferred.promise;
};

/**
 * Perform a action synchronously. Specificly for 'syncFunction' actionType.
 * Returns nothing.
 *
 * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed
 * within.
 *
 * @param {Object} action - The 'declAction' to be executed.
 *
 * @param {Object} dataCtxNode - The AngularJS $scope context of this operation.
 *
 * @param {ModuleObject} depModuleObj - The dependent module of the 'action' containing any functions to be
 *            executed.
 *
 * @returns {Object} The result of the called function.
 */
export let performActionSync = function( declViewModel, action, dataCtxNode, depModuleObj ) {
    if( !action ) {
        logger.error( 'Missing action definition for actionId ' + action.actionId );
        return null;
    }

    if( !action.actionType ) {
        logger.error( 'Missing action type for actionId: ' + action.actionId );
        return null;
    }

    if( action.actionType !== 'syncFunction' ) {
        logger.error( 'Invalid action type for actionId: ' + action.actionId );
        return null;
    }
    var inputData = null;
    let inputError = null;

    if( action.inputData ) {
        inputData = _.cloneDeep( action.inputData );
    }

    if( inputData ) {
        if( declViewModel.isDestroyed() ) {
            declUtils.logLifeCycleIssue( declViewModel, action, 'Action results not applied to data context.',
                'performActionSync' );
        } else {
            try {
                // this may require it  latest info update to latest
                let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
                declarativeDataCtxSvc.applyScope( localContext.data, inputData, null, localContext,
                    depModuleObj );
            } catch ( error ) {
                inputError = error;
            }
        }
    }

    if( inputError ) {
        return null;
    }

    /**
     * Collect function parameters from input data
     */
    var params = [];

    _.forEach( inputData, function( param ) {
        params.push( param );
    } );

    try {
        return depModuleObj[ action.method ].apply( depModuleObj, params );
    } catch ( err ) {
        logger.error( 'Action ' + action.actionId + ' cannot be executed\n' + err );
    }
    return null;
};

/**
 * Execute the given 'action' using the given related parameters
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel the DeclAction is a member of.
 * @param {DeclAction} action - The DeclAction to execute.
 * @param {Object} dataCtxNode - The data context to use during execution.
 * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in
 *            the execution.
 * @param {Object} mapDataOnAction - (Optional) True if outputData of action should not map on
 * viewModel/ctx.
 * @param {Object} prop - (Optional) vmprops used for onMount lifecycle
 * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle
 *
 * @return {Promise} A promise resolved with an 'actionResponseObj' when the action is completed.
 */
export let executeAction = function( declViewModel, action, dataCtxNode, depModuleObj, mapDataOnAction, prop ) {
    // Note: Clipboard Service is not following the correct
    // another approach is we can try to create asyncLoad method
    // for all these case and merge them with current thenable flow
    /** revisitme Shaishav
     * Hint: Need to find the reason for this line. It is failing to compile in afx-next
    ClipboardService.instance;
    */

    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, 'executeAction (a)' );

    var deferred = AwPromiseService.instance.defer();

    var functionsList = declViewModel._internal.functions;
    var { actionPolicyId, propertyPolicyOverride } = getActionPolicyInfo( action, declViewModel, functionsList, dataCtxNode, depModuleObj );
    // load function deps
    var functionDeps = loadFuncDependency( action, declViewModel, depModuleObj );

    /**
     * Note: For some reason the 'breadcrumb' UI needed this async load even if there is nothing to load.
     * This should probably be made right in the future as part of better performance work.
     */
    moduleLoader.loadDependentModules( functionDeps ).then( function( functionDependancies ) {
        _.forEach( functionDependancies, function( funcDepVal, funcDepKey ) {
            depModuleObj[ funcDepKey ] = funcDepVal;
        } );

        var promise = _performAction( declViewModel, action, functionsList, dataCtxNode, depModuleObj, propertyPolicyOverride );

        if( !promise ) {
            deferred.resolved();
            return;
        }

        promise.then( function( actionResponseObj ) {
            /**
             * Remove any policies that were registered for this action.
             */
            if( actionPolicyId ) {
                propertyPolicySvc.unregister( actionPolicyId );
            }

            if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (b)' ) ) {
                return;
            }

            /**
             * Check if we have a response and an output data map to work with.
             * <P>
             * If so: Process all the action output definitions and stick them on the dataCtxNode.
             * <P>
             * Note: We must use the logic of 'declUtils.isNil' instead of Lodash's 'isEmpty' for the action
             * object to handle boolean or number type object responses (D-47571).
             */
            if( !declUtils.isNil( actionResponseObj ) && !_.isEmpty( action.outputData ) ) {
                var deferredAssignments = {};

                /* If dataParsers are defined, then run the actionResponseObj through them before pipelining
                 * to outPutData.
                 */
                if( _.isArray( action.dataParsers ) ) {
                    actionResponseObj = dataMapperSvc.applyDataParseDefinitions( actionResponseObj, declViewModel, action.dataParsers, dataCtxNode, depModuleObj );
                }

                deferredAssignments = resolveActionOutputData( action, mapDataOnAction, actionResponseObj, declViewModel, depModuleObj, dataCtxNode );

                AwPromiseService.instance.all( deferredAssignments ).then(
                    function( resolvedAssignments ) {
                        //new in afx 3.1.0
                        if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (c)' ) ) {
                            return;
                        }

                        if( mapDataOnAction ) {
                            performOutputDataMappingForBatch( resolvedAssignments, declViewModel, action, dataCtxNode, depModuleObj, deferred );
                        } else {
                            performOutputDataMapping( resolvedAssignments, declViewModel, prop );

                            // Update binding when data changed
                            _.defer( function() {
                                //new in afx 3.1.0
                                if( _isViewModelDestroyed( declViewModel, actionResponseObj, action, deferred, 'executeAction (d)' ) ) {
                                    return;
                                }

                                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj,
                                    deferred );
                            } );
                        }
                        debugService.debug( 'actions', declViewModel._internal.panelId, action.actionId, 'post', action, declViewModel, resolvedAssignments );
                        if( logger.isTraceEnabled() ) {
                            let actionName = action.actionId ? action.actionId : action.method;
                            let actionName2 = declViewModel._internal.viewId + '::' + actionName;
                            logger.trace( 'Action: ', actionName2 );
                        }
                    } );
            } else {
                _finishAction( declViewModel, action, dataCtxNode, depModuleObj, actionResponseObj, deferred );
                if( logger.isTraceEnabled() ) {
                    let actionName = action.actionId ? action.actionId : action.method;
                    let actionName2 = declViewModel._internal.viewId + '::' + actionName;
                    logger.trace( 'Action: ', actionName2 );
                }
            }
        }, function( err ) {
            // Extract error message from response and store it in view model
            var error = _.cloneDeep( err );
            _.set( declViewModel, 'error', error );
            if( actionPolicyId ) {
                propertyPolicySvc.unregister( actionPolicyId );
            }
            _processError( err, declViewModel, action, dataCtxNode, depModuleObj );
            deferred.reject( err );
        } );
    } );

    return deferred.promise;
};

exports = {
    performSOAAction,
    executeAction,
    performDataProviderAction,
    performActionSync
};
export default exports;
