// Copyright (c) 2020 Siemens

/**
 * Declarative UI data provider service
 * This service performs actions to retrieve data in a paged fashion based solely on a given 'declAction' object.
 *
 * @module js/declDataProviderService
 */
import declDataCtxSvc from 'js/declarativeDataCtxService';
import appCtxSvc from 'js/appCtxService';
import _ from 'lodash';
import logger from 'js/logger';
import Debug from 'debug';
import declUtils from 'js/declUtils';
import actionSvc from 'js/actionService';
import moduleLoader from 'js/moduleLoader';
import AwPromiseService from 'js/awPromiseService';

var dataProviderTcLOV = 'TcLOV';

var trace = new Debug( 'declDataProviderService' );

/**
 * Use the 'actionService' to execute the given action and resolve the returned 'promise' with the either no object
 * or a reference to the any dependent module's API object.
 * <P>
 * Note: Any dependent module will be loaded before the action is executed.
 * <P>
 * Note: It is assumed that the action will use its 'input' and 'output' properties to move action related data into
 * or out of the dataCtxNode or declViewModel.
 *
 * @param {Object} dataCtxNode - The data context node the action is being performed within.
 * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.
 * @param {DeclAction} action - The declarative action to be executed.
 * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the
 *            execution.
 *
 * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:
 *
 * <pre>
 * {
 *     responseObj: responseObj,
 *     depModuleObj: depModuleObj
 * }
 * </pre>
 */
function _executeAction( dataCtxNode, declViewModel, action, depModuleObj ) {
    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, '_executeAction' );
    return actionSvc.executeAction( declViewModel, action, dataCtxNode, depModuleObj ).then( function( responseObj ) {
        return {
            responseObj: responseObj,
            depModuleObj: depModuleObj
        };
    } ).catch( function( x ) {
        trace( 'exception', x );
        logger.error( 'exception: ' + x );
    } );
}

/**
 *
 * @param {DeclViewModel} declViewModel - The view model containing the action to be executed.
 *
 * @param {DeclAction} action - The 'declAction' object to use to get the page data.
 *
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @param {dataProviderJson} dataProviderJson - The data provider's json object.
 *
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *            <P>
 *            If not provided all action options are resolved solely from action's 'inputData' via the given dataCtxNode.
 *            <P>
 *            Note: The properties in this object are guaranteed to be passed to the action being invoked and that
 *            the results of that particular action invocation are returned as the resolution of the promise
 *            returned by this function. Use of the dataCtxNode for 'inputData' binding can result in mixed input vs.
 *            output results when multiple async calls are made to the same action.
 *
 * @param {ModuleObject} depModuleObj - (Optional) Reference to a module containing 'glue code' to assist in the
 *            execution.
 *
 * @return {Promise} A promise resolved with the response/result(s) of the action as properties as follows:
 */
function _executeLoadAction( declViewModel, action, dataCtxNode, dataProviderJson, actionRequestObj, depModuleObj ) {
    //new in aw4.2
    declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, null, '_executeLoadAction' );

    var actionFinal = action;

    if( actionRequestObj ) {
        actionFinal = _prepareActionAltInputData( dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj );
    }

    return _executeAction( dataCtxNode, declViewModel, actionFinal, depModuleObj ).then( function( actionResultObj ) {
        // revisitme - somehow in the long SOA case like search, the dataCtxNode.data is not equal to declViewModel
        // anymore which is cause side effect - will investigate later
        dataCtxNode.data.totalFound = declViewModel.totalFound;
        dataCtxNode.data.searchResults = declViewModel.searchResults;
        return _postProcessAction( dataCtxNode, dataCtxNode.data, dataProviderJson, actionResultObj );
    }, function( rejectObj ) {
        return AwPromiseService.instance.reject( rejectObj );
    } );
}

/**
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 * @param {DeclViewModel} declViewModel - The view model the action is defined within.
 * @param {Object} dataProviderJson - The original JSON definition of the declDataProvider.
 * @param {Object} actionResultObj - The resolved response object from executing the action.
 *
 * @return {Promise} A Promise object resolved with the processed result of the action. The result contains updated
 *         values for all the properties in the given 'dataProviderJson' object.
 */
function _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, actionResultObj ) {
    var responseObj;

    if( dataProviderJson && declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {
        let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
        var dpResult = _.cloneDeep( dataProviderJson );

        // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes
        // Fix cucumber 'Record Utilization Declarative Panel': depModuleObj is needed for all {{function:}}
        var depModuleObj = actionResultObj && actionResultObj.depModuleObj ? actionResultObj.depModuleObj : null;

        /**
         * Check if the dataCtxNode we need has been destroyed (due to DOM manipulation) since the action event
         * processing was started.
         */
        var localDataCtx = declUtils.resolveLocalDataCtx( localContext.data, localContext );

        /**
         * Resolve any other data 'from' the declViewModel and/or dataCtxNode
         */
        declDataCtxSvc.applyScope( localContext.data, dpResult, declViewModel._internal.functions, localDataCtx,
            depModuleObj );

        if( actionResultObj ) {
            _.forEach( dpResult, function( fromPath, toPath ) {
                /**
                 * If fromPath has a 'result.' prefix, parse the expression within fromPath to get the correct
                 * value.
                 */
                if( _.isString( fromPath ) && /^action\.result\./.test( fromPath ) ) {
                    var fromResultPath = fromPath.split( 'action.result.' )[ 1 ];

                    var fromObj = _.get( actionResultObj.responseObj, fromResultPath );

                    _.set( dpResult, toPath, fromObj );
                }
            } );
        }

        /**
         * Build the response object from the updated (i.e. data bound) properties in the declDataProvider's JSON
         * definition.
         */
        responseObj = {
            actionResultObj: actionResultObj
        };

        _.forEach( dpResult, function( value, name ) {
            if( name === 'action' ) {
                return;
            }

            /**
             * Handle special case of a mapping to a different property name (e.g. 'response' to 'result').
             */
            if( name === 'response' ) {
                responseObj.results = value;
            } else if( /^ctx\./.test( name ) ) {
                /**
                 * If the name starts with ctx. update the appCtxService
                 */
                var toCtxName = name.split( 'ctx.' )[ 1 ];
                appCtxSvc.updatePartialCtx( toCtxName, value );
            } else {
                responseObj[ name ] = value;
            }
        } );

        /**
         * Make sure the 'totalFound' is set if we had any data returned.
         */
        if( responseObj.results && _.isUndefined( responseObj.totalFound ) ) {
            responseObj.totalFound = responseObj.results.length;
        }
    }

    return AwPromiseService.instance.resolve( responseObj );
}

/**
 * @param {Object} inputData - Input properties from JSON.
 * @param {Object} altInputData - Input properties to use.
 * @param {Object} actionRequestObj - Object from action to use.
 */
function _applyActionRequestObject( inputData, altInputData, actionRequestObj ) {
    /**
     * Put the specific action's request values on the 'atInputData' of the action's inputData clone.
     */
    _.forEach( inputData, function( fromPath, toPath ) {
        if( _.isString( fromPath ) ) {
            if( /^request\./.test( fromPath ) ) {
                var fromRequestPath = fromPath.split( 'request.' )[ 1 ];

                var fromObj = _.get( actionRequestObj, fromRequestPath );

                _.set( altInputData, toPath, fromObj );
            }
        } else {
            _applyActionRequestObject( fromPath, altInputData[ toPath ], actionRequestObj );
        }
    } );
} // _applyActionRequestObject

/**
 * Note 1: Multiple async load requests can be made before any given one completes. So we cannot put action-related
 * objects on the dataCtxNode since the dataCtxNode may change before the original dataCtxNode is applied to the action the objects
 * were ment for.
 * <P>
 * To address this, the dataCtxNode will be applied to the 'inputData' of a clone of the action NOW. This clone (and the
 * now static 'inputData' objects) will be passed to the actionService which will use this 'altInputData' as-is
 * without trying to apply the dataCtxNode to it again.
 * <P>
 * Note 2: The post processing of the action results do not have this problem since a new 'outputData' object is
 * created and passed back through the 'promise chain' in a more synchronous fashion. So any output data placed on
 * the dataCtxNode is not there long enough to be overwritten by another action completing before it.
 *
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @param {DeclViewModel} declViewModel - The 'declViewModel' context the operation is being performed within.
 *
 * @param {DeclAction} action - The 'declAction' object to use to get the page data.
 *
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *
 * @param {Object} depModuleObj - Dependent module object on which the 'apply' method of any named functions will be
 *            called (action.deps).

 *
 * @returns {DeclAction} Action object to actually use.
 */
function _prepareActionAltInputData( dataCtxNode, declViewModel, action, actionRequestObj, depModuleObj ) {
    var actionFinal = action;

    if( action.inputData ) {
        /**
         * Make copied of the 'action' and 'inputData' objects (to keep the originals safe from modification)
         */
        actionFinal = _.cloneDeep( action );

        actionFinal.altInputData = _.cloneDeep( action.inputData );

        // LCS-166817 - Active Workspace tree table view performance in IE and embedded in TCVis is bad - Framework Fixes
        // The actonRequestObj, which may be a very complex structure, can be applied after applyScope
        declDataCtxSvc.applyScope( declViewModel, actionFinal.altInputData, declViewModel._internal.functions,
            dataCtxNode, depModuleObj );

        /**
         * Put the specific action's request values on the 'atInputData' of the action's inputData clone.
         */
        _applyActionRequestObject( actionFinal.inputData, actionFinal.altInputData, actionRequestObj );
    }

    return actionFinal;
} // _prepareActionAltInputData

/**
 * --------------------------------------------------------------------------<BR>
 * Define external API<BR>
 * --------------------------------------------------------------------------<BR>
 */

var exports = {};

/**
 * validate the LOV sections using the function in the lovService
 *
 * @param {array} lovEntries - The 'lovEntries' to update.
 * @param {Object} dataProviderJson - data provider json object
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @return {Promise} A promise object. validateLOVValueSelections
 */
export let validateLOVSelection = function( { lovEntries, vmo, viewModelProp }, dataCtxNode, action, dataProviderJson ) {
    //let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );
    // if( dataProviderJson.dataProviderType && dataProviderJson.dataProviderType === dataProviderTcLOV ) {
    //     declDataCtxSvc.applyScope( declViewModel, dataProviderJson, null, dataCtxNode, null );
    //     var lovConfig = dataProviderJson.lovConfiguration;
    //     var viewModelObj = lovConfig.viewModelObj;
    //     var viewProp = lovConfig.viewProp;
    //     var operationName = lovConfig.operationName;
    //     return lovService.validateLOVValueSelections( lovEntries, viewProp, operationName, viewModelObj );
    // }
    if( action && viewModelProp ) {
        let actionRequestObj = {
            selected: lovEntries,
            suggestion: viewModelProp.filterString,
            vmo,
            vmProp: viewModelProp
        };
        return validateSelections( action, dataProviderJson, dataCtxNode, actionRequestObj ).then( ( resp ) => {
            let response;
            if( resp.actionResultObj && resp.actionResultObj.responseObj ) {
                response = resp.actionResultObj.responseObj;
                if( !response.valid ) {
                    return Promise.reject( response );
                }
                return Promise.resolve( response );
            } else if( !resp.valid ) {
                resp.cause = { partialErrors: true };
                return Promise.reject( resp );
            }

            return resp;
        } );
    }
    return Promise.resolve( { valid: true } );
};

/**
 * Validate the LOV selections using the function in the dataProvider.
 *
 * @param {DeclAction} action - The 'declAction' object to use.
 * @param {Object} dataProviderJson - data provider json object
 * @param {Object} lovScope - The context in which to evaluate any conditions/bindings.
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *
 * @return {Promise} A promise object.
 */
export let validateSelections = function( action, dataProviderJson, lovScope, actionRequestObj ) {
    return exports.executeLoadAction( action, dataProviderJson, lovScope, actionRequestObj );
};

/**
 * Execute the given action and return results in the async resolution.
 *
 * @param {DeclAction} action - The 'declAction' object to use.
 *
 * @param {dataProviderJson} dataProviderJson - The data provider's JSON object.
 *
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *
 * @return {Promise} A promise object resolved with the results (IModelObject, ViewModelObjects, etc.) of the given
 *         action.
 *
 * <pre>
 * If NOT LOV:
 * {Number} totalFound -
 * {Object} results -
 *
 * If LOV:
 * {Object}
 * </pre>
 */
export let executeLoadAction = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {
    // if( !action ) {
    //     logger.error( 'Invalid action specified' );
    // }

    let declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );
    // add update To latestHere ...
    let localContext = declUtils.getLatestContext( dataCtxNode, declViewModel );
    if( !declUtils.isNil( action ) ) {
        /**
         * Execute the action within the context of the DeclViewModel on the dataCtxNode.
         */
        declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (a)' );
        // Get Function deps
        var functionDeps = declUtils.getFunctionDeps( action, declViewModel._internal );
        if( !_.isEmpty( action.deps ) ) {
            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObj ) {
                //new in aw4.2
                declUtils.assertValidModelDataCtxNodeAndAction2( declViewModel, dataCtxNode, action, 'Load action not executed.', 'executeLoadAction (b)' );

                // Load function.deps
                //
                // Note: Even if the list of 'functionDeps' is empty we need to execute the async load since some
                // code (breadcrumbs) needs the extra digest cycle (or two). This is odd since the same 'empty'
                // check later in this function seems to work ok.
                //
                return moduleLoader.loadDependentModules( functionDeps ).then( function( depFunctionObj ) {
                    _.forEach( depFunctionObj, function( depFuncValue, depFuncKey ) {
                        depModuleObj[ depFuncKey ] = depFuncValue;
                    } );

                    var localScope = declUtils.resolveLocalDataCtx( localContext.data, localContext );

                    return _executeLoadAction( localContext.data, action, localScope, dataProviderJson, actionRequestObj,
                        depModuleObj );
                } );
            } );
        }

        if( !_.isEmpty( functionDeps ) ) {
            // Load function.deps
            return moduleLoader.loadDependentModules( functionDeps ).then( function( depFunctionObj ) {
                var localScope = declUtils.resolveLocalDataCtx( localContext.data, localContext );

                return _executeLoadAction( localContext.data, action, localScope, dataProviderJson, actionRequestObj, depFunctionObj );
            } );
        }
        return _executeLoadAction( localContext.data, action, localContext, dataProviderJson, actionRequestObj, null );
    }
    //let localScope = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );
    return _postProcessAction( localContext, localContext.data, dataProviderJson, null );
};

/**
 * Get first page of results
 *
 * @param {DeclAction} action - The 'declAction' object to use to get the page data.
 *
 * @param {dataProviderJson} dataProviderJson - The data provider's json object.
 *
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *
 * @return {Promise} A promise object resolved with the IModelObject results of this operation.
 *
 * <pre>
 * If NOT LOV:
 * {Number} totalFound -
 * {Object} results -
 *
 * If LOV:
 * {Object}
 * </pre>
 *
 */
export let getFirstPage = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {
    if( action ) {
        return exports.executeLoadAction( action, dataProviderJson, dataCtxNode, actionRequestObj );
    }

    /**
     * Execute the action within the context of the DeclViewModel on the dataCtxNode.
     */
    var declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );

    declUtils.assertValidModelAndDataCtxNode( declViewModel, dataCtxNode );


    /**
     * Support for binding dataProvider's response to a static list, when action is not provided.
     */
    return _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, null );
};

/**
 * Get next page of results
 *
 * @param {DeclAction} action - The 'declAction' to perform.
 *
 * @param {Object} dataProviderJson - data provider json object
 *
 * @param {Object} dataCtxNode - The context in which to evaluate any conditions/bindings.
 *
 * @param {Object} actionRequestObj - (Optional) An Object holding details of the action's 'inputData' and options
 *            for this load operation. Its properties are accessed via the 'request.' prefix on properties on the
 *            action's 'inputData' (e.g. "myActionParam1": "request.listLoadInput" where 'listLoadInput' is a
 *            parameter on the 'actionRequestObj' object)
 *
 * @return {Promise} A promise object resolved with the IModelObject results of this operation.
 */
export let getNextPage = function( action, dataProviderJson, dataCtxNode, actionRequestObj ) {
    if( action ) {
        return exports.executeLoadAction( action, dataProviderJson, dataCtxNode, actionRequestObj );
    }

    /**
     * Execute the action within the context of the DeclViewModel on the dataCtxNode.
     */
    var declViewModel = declUtils.findViewModel( dataCtxNode, true, appCtxSvc );

    declUtils.assertValidModelAndDataCtxNode( declViewModel, dataCtxNode );


    /**
     * Support for binding dataProvider's response to a static list, when action is not provided.
     */
    return _postProcessAction( dataCtxNode, declViewModel, dataProviderJson, null );
};

exports = {
    validateLOVSelection,
    validateSelections,
    executeLoadAction,
    getFirstPage,
    getNextPage
};
export default exports;
