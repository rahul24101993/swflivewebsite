// Copyright (c) 2020 Siemens

/**
 * This module is part of declarative UI framework and provides high level functionalities to work with view model.
 * <P>
 * Note: This module does not return an API object. The API is only available when the service defined this module is
 * injected by AngularJS.
 *
 * @module js/viewModelService
 */
import AwPromiseService from 'js/awPromiseService';
import declViewModProcFact from 'js/viewModelProcessingFactory';
import messagingSvc from 'js/messagingService';
import actionSvc from 'js/actionService';
import conditionSvc from 'js/conditionService';
import appCtxSvc from 'js/appCtxService';
import declDataCtxService from 'js/declarativeDataCtxService';
import Debug from 'debug';
import _ from 'lodash';
import logger from 'js/logger';
import declUtils from './declUtils';
import debugService from 'js/debugService';
import syncViewModelCacheService from 'js/syncViewModelCacheService';
import { loadDynModule } from 'js/moduleLoader';

var trace = new Debug( 'viewModel' );

var exports = {};

const eveulateEventCondition = function( eventObj, declViewModel, matched, props, context, fields ) {
    var conditionResult = false;

    if( eventObj.condition ) {
        var conditionExpression = null;

        if( _.startsWith( eventObj.condition, 'conditions.' ) ) {
            var conditionObject = _.get( declViewModel._internal, eventObj.condition );

            conditionExpression = conditionObject.expression;
        } else {
            conditionExpression = eventObj.condition;
        }
        let currContext = null;
        if( context ) {
            if( context.scope ) {
                currContext = context.scope;
            } else {
                currContext = context;
            }
        } else {
            currContext = { data: declViewModel, props: props, subPanelContext: props.subPanelContext, fields };
        }
        conditionResult = conditionSvc.evaluateCondition( declUtils.getLatestContext( currContext, declViewModel ), conditionExpression, context );

        // if conditionResult is undefined or null we should consider result as false.
        if( !conditionResult ) {
            conditionResult = false;
        }
    }
    return eventObj.condition && conditionResult || eventObj.criteria && matched ||
        !( eventObj.condition || eventObj.criteria );
};

const processMessageOnEvent = function( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields ) {
    var allMessages = _.cloneDeep( declViewModel._internal.messages );
    if( !context.scope ) {
        context.scope = {
            data: declViewModel,
            ctx: appCtxSvc.ctx,
            props,
            getProps,
            parameters: inputArgs ? inputArgs : null,
            fields,
            getFields
        };
        context.scope.parameters = context.scope.parameters ? {
            ...context.scope.parameters,
            commandActionExecutor: {
                runActionWithViewModel
            }
        } : {
            commandActionExecutor: {
                runActionWithViewModel
            }
        };
    }
    messagingSvc.reportNotyMessage( declViewModel, allMessages, eventObj.message,
        context.scope );
};

const processActionOnEventHavingScope = function( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields ) {
    context.scope.parameters = inputArgs ? inputArgs : null;
    context.scope.parameters = context.scope.parameters ? {
        ...context.scope.parameters,
        commandActionExecutor: {
            runActionWithViewModel
        }
    } : {
        commandActionExecutor: {
            runActionWithViewModel
        }
    };
    context.scope.props = props;
    context.scope.getProps = getProps;
    context.scope.fields = fields;
    context.scope.getFields = getFields;

    exports.executeCommand( declViewModel, eventObj.action, context.scope );
};

const processActionOnEventWithScope = function( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields ) {
    var scope = {
        data: declViewModel,
        ctx: appCtxSvc.ctx,
        parameters: inputArgs ? inputArgs : null,
        subPanelContext: subPanelContext,
        props,
        getProps,
        fields,
        getFields
    };
    scope.parameters = scope.parameters ? {
        ...scope.parameters,
        commandActionExecutor: {
            runActionWithViewModel
        }
    } : {
        commandActionExecutor: {
            runActionWithViewModel
        }
    };
    exports.executeCommand( declViewModel, eventObj.action, scope );
};

const reteriveInputParOfEvent = function( context, inputArgs, eventObj, declViewModel ) {
    var contextObj = {
        eventData: context
    };
    inputArgs = _.cloneDeep( eventObj.inputArgs );
    if( inputArgs ) {
        try {
            declDataCtxService.applyScope( declViewModel, inputArgs, null, contextObj, null );
        } catch ( error ) {
            throw new Error( error );
        }
    }
    return inputArgs;
};

const handleEventDataCache = function( eventObj, declViewModel, context ) {
    if( eventObj.eventId ) {
        if( !declViewModel.eventMap ) {
            declViewModel.eventMap = {};
        }

        const key = eventObj.eventId;
        const value = {};
        value[ key ] = context;
        declViewModel.eventMap[ eventObj.eventId ] = value[ key ];
        declViewModel.data.eventMap = { ...declViewModel.eventMap };
    }

    declViewModel.eventData = context;
    declViewModel.data.eventData = context;
};

// eslint-disable-next-line complexity
export let handleRegisteredEvent = function( context, declViewModel, eventObj, limitEventScope, getProps, runActionWithViewModel, getFields ) {
    if( declViewModel.getData && _.isFunction( declViewModel.getData ) ) {
        declViewModel.data = declViewModel.getData();
    }
    const props = getProps();
    const fields = getFields();
    const subPanelContext = props.subPanelContext;
    debugService.debug( 'events', declViewModel._internal.panelId, eventObj.eventId );

    if( limitEventScope && context._source !== declViewModel._internal.modelId ) {
        return;
    }

    // Check if the event source is set to 'current' and _source id is available.
    // If yes, make event listeners only listen to events fired by the current view model instance.
    if( eventObj.eventSource === 'current' && context._source && context._source !== declViewModel._internal.modelId ) {
        return;
    }

    if( !declUtils.isValidModelAndEventData( declViewModel, context ) ) {
        logger.error( '_processEventRegistration: ' + 'Invalid input: eventId=' + eventObj.eventId );
        return;
    }

    var matched = true;

    /**
     * @deprecated : 'criteria' is deprecated we should use condition instead.
     */
    _.forEach( eventObj.criteria, function( value, key ) {
        // For panel change events, the context doesn't have a scope, so check the properties on context directly.
        if( _.get( context.scope, key ) !== value && _.get( context, key ) !== value ) {
            matched = false;
        }
    } );

    /**
     * "onEvent": [ { "eventId": "someEvent", "condition": "conditions.shouldIDoSomething",
     * "action":"doSomething" } ]
     */

    var isEventExecutable = eveulateEventCondition( eventObj, declViewModel, matched, props, context, fields );

    if( logger.isDeclarativeLogEnabled() ) {
        debugService.debugEventSub( eventObj, declViewModel, context, isEventExecutable );
    }
    if( isEventExecutable ) {
        var inputArgs = null;
        // Store the context eventData on declViewModel's eventData
        if( eventObj.cacheEventData ) {
            // const { dispatch } = declViewModel;
            // let finalObj = {};
            handleEventDataCache( eventObj, declViewModel, context );
        }
        // If an event has some eventData and the same eventdata is required in the action,
        // associated with event, then user can construct inputArgs.
        // "eventId": "AWEvent.test",
        //     "action": "fireSaveEdit",
        //         "inputArgs": {
        //         "param1": "{{eventData.operation1}}",
        //         "param3": {
        //             "param4": "{{eventData.operation4}}",
        //             "param5": "{{eventData.operation5}}"
        //         }
        //     }
        // Later the same input Args can be reused in action through {{parameters.param1}}.

        if( eventObj.inputArgs ) {
            inputArgs = reteriveInputParOfEvent( context, inputArgs, eventObj, declViewModel );
        }

        if( eventObj.message ) {
            processMessageOnEvent( declViewModel, context, props, getProps, inputArgs, runActionWithViewModel, eventObj, fields, getFields );
        } else if( context && context.scope ) {
            processActionOnEventHavingScope( context, inputArgs, runActionWithViewModel, props, getProps, declViewModel, eventObj, fields, getFields );
        } else {
            processActionOnEventWithScope( declViewModel, inputArgs, subPanelContext, props, getProps, runActionWithViewModel, eventObj, fields, getFields );
        }
    }
};

/**
 * Load any dependent modules, register any necessary events and populate the resolved 'declViewModel' object with
 * any data that is bound to various values including localized messages.
 *
 * @param {Object} declViewModelJson - Loaded JSON Object for the 'declViewModel' to populate.
 *            <P>
 *            Note: The JSON contents are actually represented in the 'data' property of this object.
 *
 * @param {Object} declViewModelTarget - (Optional) If specified, the data from the given 'declViewModel' will be
 *            merged into this object (e.g viewModel of subPanel is merged in the parent panel's viewModel)
 *
 * @param {String} subPanelId - (Optional) Id of the sub-panel in case the passed viewModelUrl belongs to a
 *            sub-panel
 * @param {Boolean} limitEventScope - (Optional) If true will make event listeners only listen to events fired by
 *            the current view model
 * @param {String} cacheI18nKey - (Optional) Key value which refers to processed i18n in cached i18n Map.
 *
 * @param {Object} subPanelContext - (Optional) Subpanlecontext attribute of aw-include directive
 *
 * @return {Promise} Resolved with the resulting 'declViewModel' resulting from loading the given DeclViewModel's
 *         JSON.
 */
export let populateViewModelPropertiesFromJson = function( declViewModelJson, declViewModelTarget, subPanelId,
    limitEventScope, cacheI18nKey, subPanelContext ) {
    if( !declViewModelJson ) {
        return AwPromiseService.instance.reject( 'No ViewModel JSON object specified' );
    }

    if( declViewModelTarget ) {
        if( !declViewModelTarget._internal.eventSubscriptions ) {
            return AwPromiseService.instance.reject( 'Target ViewModel missing required event property' );
        }

        if( !declViewModelTarget._internal.origDeclViewModelJson ) {
            return AwPromiseService.instance.reject( 'Target ViewModel missing required JSON object property' );
        }
    }

    /**
     * Process the JSON into a new 'declViewModel' and Move/Merge the properties just loaded into the resolved
     * 'declViewModel'.
     */
    var newDeclViewModel = declViewModProcFact.processViewModel( declViewModelJson, subPanelContext );
    var jsonData = declViewModelJson;

    /**
     * Determine the object to be 'resolved' (i.e. a new one or an existing 'target')
     */
    var resDeclViewModel;

    if( declViewModelTarget ) {
        resDeclViewModel = declViewModelTarget;

        /**
         * Consolidate 'fresh' JSON properties into the given 'target'
         * <P>
         * Move all of the now populated 'data' properties into the 'target'
         */
        _.forEach( jsonData.data, function( propValue, propName ) {
            resDeclViewModel[ propName ] = newDeclViewModel[ propName ];
        } );

        resDeclViewModel.dataProviders = declUtils.consolidateObjects( resDeclViewModel.dataProviders,
            newDeclViewModel.dataProviders );

        resDeclViewModel.grids = declUtils.consolidateObjects( resDeclViewModel.grids,
            newDeclViewModel.grids );

        resDeclViewModel.columnProviders = declUtils.consolidateObjects( resDeclViewModel.columnProviders,
            newDeclViewModel.columnProviders );

        resDeclViewModel.chartProviders = declUtils.consolidateObjects( resDeclViewModel.chartProviders,
            newDeclViewModel.chartProviders );

        resDeclViewModel.commands = declUtils.consolidateObjects( resDeclViewModel.commands,
            newDeclViewModel.commands );

        resDeclViewModel.commandHandlers = declUtils.consolidateObjects( resDeclViewModel.commandHandlers,
            newDeclViewModel.commandHandlers );

        resDeclViewModel.commandPlacements = declUtils.consolidateObjects(
            resDeclViewModel.commandPlacements, newDeclViewModel.commandPlacements );

        // Consolidate all properties from view model object in newDeclViewModel
        var vmo = newDeclViewModel.vmo;
        if( vmo ) {
            if( jsonData.data.objects ) {
                // Loop through the objects in jsonData, jsonData may contain multiple vmo in case of object set.
                //                            _.forEach( jsonData.data.objects, function( dataPropValue, dataPropName ) {
                //                                var newVmo = resDeclViewModel.attachModelObject( vmo.uid, jsonData.data.operationName,
                //                                    jsonData.data.owningObjUid, dataPropValue[0] );
                //                                if( dataPropValue[0].selected ) {
                //                                    resDeclViewModel.vmo = newVmo;
                //                                }
                //                            } );
                // The above code is no longer required. As there is no need to create a separate viewModelobject instance of
                // of the same model object multiple times (declViewModelObject.objects and declViewModelObject.vmo),
                // we already created  resDeclViewModel.vmo instance while forming the
                // newDeclViewModel.
                // Also difficult to determine which widgets are binded to which viewModel Object
                resDeclViewModel.vmo = newDeclViewModel.vmo;
                resDeclViewModel = declUtils.consolidateObjects( resDeclViewModel,
                    newDeclViewModel.vmo.props );
                resDeclViewModel.attachEvents();
            } else {
                resDeclViewModel.vmo = resDeclViewModel.attachModelObject( vmo.uid,
                    jsonData.data.operationName, jsonData.data.owningObjUid );
            }
        }

        resDeclViewModel._internal.consolidateJsonData( jsonData );
        newDeclViewModel._internal.destroy( false );
    } else {
        resDeclViewModel = newDeclViewModel;

        /**
         * Move over fresh JSON properties
         */
        resDeclViewModel._internal.setJsonData( jsonData );

        /**
         * Object used to hold details of context changes that are being delayed (debounced).
         */
        resDeclViewModel._internal.pendingContextChanges = {};

        /**
         * This function is used to buffer up some of the appCtx 'noise' and delay the 'update' until things
         * calm down a bit.
         *
         * When running in test mode this function will not be debounced
         *
         * @private
         */
        // revisitme charu
        // resDeclViewModel._internal.pingUpdateViewModel = app.isTestMode ? pingUpdateViewModelInternal : _.debounce( pingUpdateViewModelInternal, 100, {
        //     maxWait: 10000,
        //     trailing: true,
        //     leading: false
        // } );

        /**
        * revisitme Shaishav
        * Hint: It was agreed that we do not need these event subscriptions are not required anymore.
        * Keeping comments till we support all the usecases in new declarative engine
        /**
         * Listener for appCtx registration events
        var subDef1 = eventBus.subscribe( 'appCtx.register', function( context ) {
            if( context ) {
                if( _logCtxPathActivity_1 ) {
                    logger.info( 'appCtx.register Subscribe: ' + context.name );
                }

                resDeclViewModel._internal.pendingContextChanges[ context.name ] = context.value;

                resDeclViewModel._internal.pingUpdateViewModel( context, resDeclViewModel );
            }
        }, 'viewModelService' );

        /**
         * Listener for command panel 'reveal' events
        var subDef2 = eventBus.subscribe( 'awPanel.reveal', function( context ) {
            /**
             * Only call the default "reveal" action on reveal of main panel which doesn't have a panel ID
             * in this context. Check if the view model available on scope is same as the result view model.
             * In case two declarative panels are displayed on a page, then it results in two subscriptions
             * to the panel reveal event. Use the decl view model comparison to execute action against
             * reveal for appropriate panel
            if( context.scope && !context.scope.panelId ) {
                var declViewModel = context.scope.data;

                if( declViewModel === resDeclViewModel ) {
                    exports.executeCommand( declViewModel, 'reveal', context.scope );
                }
            }
        }, 'viewModelService' );

        /**
         * Remember these subscriptions to allow unsubscribe later.
        resDeclViewModel._internal.eventSubscriptions.push( subDef1 );
        resDeclViewModel._internal.eventSubscriptions.push( subDef2 );
        */
    }

    /**
     * Register any fresh 'eventBus' conditions
     */
    /**
     * revisitme Shaishav
     * Hint: This code needs to be replaced by the duplicate onEvent registration we do in declreact viewModelService
    if( jsonData.onEvent ) {
        var eventSubscriptions = _processEventRegistration( resDeclViewModel, jsonData.onEvent,
            limitEventScope, subPanelContext );
        if( !declUtils.isNil( subPanelId ) ) {
            if( !resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] ) {
                resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ] = eventSubscriptions;
            } else {
                _.forEach( eventSubscriptions, function( eventSubs ) {
                    resDeclViewModel._internal.subPanelId2EventSubscriptionsMap[ subPanelId ].push( eventSubs );
                } );
            }
        } else {
            resDeclViewModel._internal.eventSubscriptions = _.union(
                resDeclViewModel._internal.eventSubscriptions, eventSubscriptions );
        }
    }
     */

    /**
     * Queue up loading and processing of the other model resources
     */
    /**
     * revisitme Shaishav
    * Hint: It was agreed that
    * 1) We do not need load imports as we will rely on ES6 import / export
    * 2) i18n population is already happening in the declreact/viewModelService.js
    * 3) We have to populate TC preferences into the same flow when this revisitme is removed
    * 4) Keeping comments till we support all the usecases in new declarative engine
    var importsPromise = null;

    if( jsonData.imports ) {
        importsPromise = moduleLoader.loadImports( jsonData.imports, AwPromiseService.instance );
    }

    var prefPromise = null;

    if( jsonData.preferences && jsonData.preferences.length > 0 ) {
        prefPromise = preferenceSvc.getMultiStringValues( jsonData.preferences );
    }

    var i18nPromise = null;

    if( jsonData.i18n ) {
        i18nPromise = awDuiLocalizationSvc.populateI18nMap( jsonData.i18n, cacheI18nKey );
    }

    /**
     * Wait for them all to complete
    return AwPromiseService.instance.all( [ resDeclViewModel, prefPromise, i18nPromise, importsPromise ] ).then(
        function( results ) {
            resDeclViewModel.preferences = declUtils.consolidateObjects( resDeclViewModel.preferences,
                results[ 1 ] );

            resDeclViewModel.i18n = declUtils.consolidateObjects( resDeclViewModel.i18n, results[ 2 ] );

            declViewModProcFact.updateI18nTexts( resDeclViewModel, resDeclViewModel, 0 );

            return resDeclViewModel;
        } );
     */
    return resDeclViewModel;
};

/**
 * @param {Object} dataCtxNode - The 'root' 'dataCtxNode' (aka '$scope') in the 'dataCtxTree' where the
 *            'declViewModel' was created and who's life cycle determines the life cycle of this 'declViewModel'.
 *
 * @param {DeclViewModel} declViewModel -
 */
export let setupLifeCycle = function( dataCtxNode, declViewModel ) {
    dataCtxNode.data = declViewModel;
    dataCtxNode.i18n = declViewModel.i18n;
    dataCtxNode.ctx = appCtxSvc.ctx;

    if( !dataCtxNode.conditions ) {
        dataCtxNode.conditions = declViewModel.getConditionStates();
    }

    debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'mount' );

    if( declViewModel._internal.ports ) {
        if( !syncViewModelCacheService.get( 'syncViewModelCache' ) ) {
            syncViewModelCacheService.set( 'syncViewModelCache', {} );
        }
        const id = dataCtxNode.data._internal.modelId;
        const path = 'syncViewModelCache.' + dataCtxNode.data._internal.viewId;
        if( syncViewModelCacheService.get( path ) === null || syncViewModelCacheService.get( path ) === undefined ) {
            syncViewModelCacheService.set( 'syncViewModelCache', Object.assign( syncViewModelCacheService.get( 'syncViewModelCache' ), {
                [ dataCtxNode.data._internal.viewId ]: {
                    [ id ]: dataCtxNode
                }
            } ) );
        } else {
            syncViewModelCacheService.set( path, { ...syncViewModelCacheService.get( path ), [ id ]: dataCtxNode } );
        }
        dataCtxNode.ports = declViewModel._internal.ports;
    }

    /**
     * Here we are keeping the original scope id ( the first scope for which declViewModel is created and assigned)
     * in declViewModel. Only when the original scope is destroyed, the corresponding viewModelObject would be
     * destroyed. Any child scope which has the same declViewModel, when destroyed should not destroy the
     * declViewModel.
     * <P>
     * Note: We are adding a reference back to the 'original' dataCtxNode. This is being done to address some very
     * difficult cases when 'child' nodes are destroyed and valid events generated by them are later processed. The
     * process will use this reference to the 'original' to resolve the event processing.
     * <P>
     * This property is nulled out when this declViewModel is destroyed.
     * <P>
     * **** This property should not be used for any other purpose until we can determine it won't cause more memory
     * issues. *****
     */
    if( !dataCtxNode.data._internal.dataCtxNodeId ) {
        dataCtxNode.data._internal.dataCtxNodeId = dataCtxNode.$id;
        dataCtxNode.data._internal.origCtxNode = dataCtxNode;
    }

    /**
     * Setup to clean up properties on this declViewModel when it's 'original' dataCtxNode.
     */
    var handleDestroyEvent = function() {
        var declViewModel2 = dataCtxNode.data;
        var cleanupDataCtxNode = function() {
            // remove vm from the syncViewModelCacheService
            if( declViewModel2 && declViewModel2._internal && declViewModel2._internal.ports ) {
                syncViewModelCacheService.set( 'syncViewModelCache.' + declViewModel2._internal.viewId, null );
            }

            /**
             * This code ensures, Until unless the original scope is destroyed, the declViewModel would not be
             * destroyed.
             */
            if( declViewModel2 && declViewModel2._internal.dataCtxNodeId !== dataCtxNode.$id ) {
                dataCtxNode.data = null;
                dataCtxNode.conditions = null;
                dataCtxNode.ctx = null;
                dataCtxNode.i18n = null;
                dataCtxNode.dataProvider = null;
                dataCtxNode.eventMap = null;
                dataCtxNode.eventData = null;
                dataCtxNode.subPanelContext = null;
                return;
            }

            if( declViewModel2 ) {
                if( declViewModel2._internal.destroy ) {
                    declViewModel2._internal.destroy( true );
                } else {
                    logger.warn( 'Attempt to delete a "dataCtxNode.data" that did not have a destroy method: ' +
                        declViewModel2 );
                }
                dataCtxNode.conditions = null;
                dataCtxNode.data = null;
                dataCtxNode.ctx = null;
                dataCtxNode.i18n = null;
                dataCtxNode.dataProvider = null;
                dataCtxNode.eventMap = null;
                dataCtxNode.eventData = null;
                dataCtxNode.subPanelContext = null;
            }
        };
        debugService.debug( 'lifeCycles', declViewModel._internal.panelId, 'destroy' );
        var onUnmountAction = _.get( declViewModel, '_internal.lifecycleHooks.onUnmount' );
        if( onUnmountAction ) {
            declViewModel.isUnmounting = true;
            exports.executeCommand( declViewModel, onUnmountAction, dataCtxNode ).then( function() {
                cleanupDataCtxNode();
            } );
        } else {
            cleanupDataCtxNode();
        }
    };

    if( dataCtxNode.$$destroyed ) {
        trace( 'View model attached to destroyed scope', declViewModel, dataCtxNode );
        handleDestroyEvent();
    } else {
        /** revisitme Shaishav: What's the alternative for the whole if / else block?
            dataCtxNode.$on( '$destroy', handleDestroyEvent );
        */
    }

    var onInitAction = _.get( declViewModel, '_internal.lifecycleHooks.onInit' );
    if( onInitAction ) {
        exports.executeCommand( declViewModel, onInitAction, dataCtxNode );
    }
};

/**
 * return true for actionType dataProvider otherwise false
 * @param {string} actionOrProviderId - The name of command action or data provider to be executed.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.
 *
 * @returns {true|false} ...
 */
var _isDataProviderAction = function( actionOrProviderId, declViewModel ) {
    if( declViewModel._internal.actions ) {
        var action = declViewModel._internal.actions[ actionOrProviderId ];
        if( action && action.actionType === 'dataProvider' && declViewModel.dataProviders ) {
            return true;
        }
    }
    return false;
};

/**
 * return true for actionType other than dataProvider
 * @param {Object} actionOrProviderId - The name of command action or data provider to be executed.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.
 *
 * @returns {true|false} ...
 */
var _isAnAction = function( actionOrProviderId, declViewModel ) {
    return declViewModel._internal.actions && declViewModel._internal.actions[ actionOrProviderId ];
};

/**
 *
 * return true for dataProvider and false for action
 *
 * @param {String} actionOrProviderId - The name of command action or data provider to be executed.
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.
 *
 * @returns {true|false} ...
 */
var _isDataProvider = function( actionOrProviderId, declViewModel ) {
    return declViewModel.dataProviders && declViewModel.dataProviders[ actionOrProviderId ];
};

/**
 * Execute command
 *
 * @param {DeclViewModel} declViewModel - The DeclViewModel context to execute the command with.
 *
 * @param {String} actionOrProviderId - The name of command action or data provider to be executed.
 *
 * @param {String} dataCtxNode - The AngularJS scope of this action command
 *
 * @param {Object} prop - (Optional) vmprops used for onMount lifecycle
 *
 * @param {Object} viewData - (Optional) viewData contains the dom reference used for onMount lifecycle
 *
 * @returns {null|Promise} ...
 */
export let executeCommand = function( declViewModel, actionOrProviderId, dataCtxNode, prop, viewData ) {
    if( !declUtils.isValidModelAndDataCtxNode( declViewModel, dataCtxNode ) ) {
        return AwPromiseService.instance.resolve();
    }

    var action = null;

    if( declViewModel._internal.actions ) {
        action = declViewModel._internal.actions[ actionOrProviderId ];
    }

    /**
     * If action is NOT specified, then check for dataProviders and if it's valid, initialize it. <br>
     * If action is specified, check for action type 'dataProvider', if so initialize the given data provider.
     */

    if( _isDataProviderAction( actionOrProviderId, declViewModel ) && action ) {
        /** action ID will be used for better logging */
        action.actionId = actionOrProviderId;
        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );
    } else if( _isAnAction( actionOrProviderId, declViewModel ) ) {
        declViewModel.getToken().addAction( action );
        /** action ID will be used for better logging */
        action.actionId = actionOrProviderId;
        if( action.deps ) {
            var doAction = function( depModuleObj ) {
                /**
                 * Check if the declViewModel got destroyed while we were waiting for the dependent module to be
                 * loaded. This can happen, for example, when multiple subscribers are listening to a common
                 * event like 'selection' and one of them (I'm look at you GWT) causes the panel the
                 * declViewModel is associated with to close (thus destroying the $scope and the declViewModel
                 * associated with it).
                 * <P>
                 * If so: There is nothing more that can be done with the declViewModel and we just want to log
                 * a warning about the situation and move on.
                 */
                if( declViewModel.isDestroyed() ) {
                    declUtils.logLifeCycleIssue( declViewModel, action, 'The command action was therefore not executed.',
                        'executeCommand' );
                } else {
                    /**
                     * Check if the $scope we need has been destroyed (due to DOM manipulation) since the action
                     * event processing was started.
                     */
                    var localDataCtx = declUtils.resolveLocalDataCtx( declViewModel, dataCtxNode );

                    // _deps will be undefined when try to load viewModelService inside itself
                    var _depModuleObj = depModuleObj;

                    if( !depModuleObj && action.deps === 'js/viewModelService' ) {
                        _depModuleObj = exports;
                    }

                    return actionSvc.executeAction( declViewModel, action, localDataCtx, _depModuleObj, null, prop, viewData ).then( function() {
                        declViewModel.getToken().removeAction( action );
                    } ).catch( function( x ) {
                        declViewModel.getToken().removeAction( action );
                        trace( 'exception', x );
                        logger.error( 'exception', x );
                        //return AwPromiseService.instance.reject( x );
                    } );
                }
                return undefined;
            };

            /**
            * revisitme Jesse
            * Hint: This needs to be uncommented once we have afxWeakImport supported
            * Keeping comments till we support all the usecases in new declarative engine
            var depModuleObj = moduleLoader.getDependentModule( action.deps );

            if( depModuleObj ) {
                return doAction( depModuleObj );
            }

            return moduleLoader.loadDependentModule( action.deps ).then( function( depModuleObject ) {
                return doAction( depModuleObject );
            } );
            */
            return loadDynModule( action.deps ).then( function( depModuleObject ) {
                return doAction( depModuleObject );
            } );
        }
        return actionSvc.executeAction( declViewModel, action, dataCtxNode, null, null, prop, viewData ).then( function() {
            declViewModel.getToken().removeAction( action );
        } ).catch( function( x ) {
            declViewModel.getToken().removeAction( action );
            trace( 'exception', x );
            logger.error( 'exception: ' + x );
            //return AwPromiseService.instance.reject( x );
        } );
    } else if( _isDataProvider( actionOrProviderId, declViewModel ) ) {
        action = {};
        action.actionType = 'dataProvider';
        action.method = actionOrProviderId;
        return actionSvc.performDataProviderAction( declViewModel, action, dataCtxNode );
    }

    return AwPromiseService.instance.resolve();
};

exports = {
    populateViewModelPropertiesFromJson,
    setupLifeCycle,
    executeCommand
};
export default exports;
