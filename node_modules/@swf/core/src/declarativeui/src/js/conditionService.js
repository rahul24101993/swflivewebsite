// Copyright (c) 2020 Siemens
/* eslint-env es6 */

/**
 * This service provides the APIs to evaluate the declarative condition expression using given viewmodel context
 *
 * @publishedApolloService
 *
 * @module js/conditionService
 */

import _ from 'lodash';
import logger from 'js/logger';
import eventBus from 'js/eventBus';
import debugService from 'js/debugService';
import AwParseService from 'js/awParseService';
import adapterService from 'js/adapterService';
import expressionParserUtils from 'js/expressionParserUtils';

var exports = {};

/**
 * Evaluate condition expression
 *
 * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.
 * @param {String} expression - Expression
 * @param {Object} evaluationEnv - The data environment for expression evaluation.
 * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.
 *
 * @return {Any} The evaluated expression result.
 */
export let parseExpression = function( declViewModel, expression, evaluationEnv, depModuleObj ) {
    var evaluationContext = {};
    _.assign( evaluationContext, declViewModel, evaluationEnv, depModuleObj );
    if( _.isObject( expression ) ) {
        // loop through query and replace all instances of dynamic values i.e. {{xyz}} by actual values
        var updatedExpression = expressionParserUtils.updateDynamicValues( expression, evaluationContext );
        return expressionParserUtils.evaluateExpressions( updatedExpression, evaluationContext, adapterService );
    }

    return AwParseService.instance( expression )( evaluationContext );
};

/**
 * Evaluate condition expression and ensure a boolean is returned
 *
 * @param {DeclViewModel} declViewModel - The 'declViewModel' context to evaluate the condition within.
 * @param {String} expression - Expression
 * @param {Object} evaluationEnv - The data environment for expression evaluation.
 * @param {Object} depModuleObj - The module object who's functions can be used in expression evaluation.
 *
 * @return {Boolean} The evaluated condition result.
 */
export let evaluateCondition = function( declViewModel, expression, evaluationEnv, depModuleObj ) {
    return Boolean( exports.parseExpression( declViewModel, expression, evaluationEnv, depModuleObj ) );
};

const _evaluateConditionBasedExpression = function( condition, declViewModel, evaluateDepParams ) {
    var finalConditionExpression;
    if( _.startsWith( condition, 'conditions.' ) ) {
        if( declViewModel._internal ) {
            finalConditionExpression = _.get( declViewModel._internal, condition );
        } else {
            finalConditionExpression = _.get( evaluateDepParams.conditionList, condition );
        }
    }
    // for condition": 'ctx.xyz || ctx.abc' or condition": '!ctx.xyz' or condition": '!conditions.xyz'
    if( finalConditionExpression === undefined ) {
        finalConditionExpression = condition;
    } else if( finalConditionExpression.expression ) {
        finalConditionExpression = finalConditionExpression.expression;
    }

    if( evaluateDepParams ) {
        return evaluateCondition( declViewModel, finalConditionExpression, evaluateDepParams.evaluationEnv, evaluateDepParams.depModuleObj );
    }
    return evaluateCondition( declViewModel, finalConditionExpression );
};

/**
 * Evaluate all variants of condition
 *
 * @param {String} condition - condition to evaluate
 * @param {DeclViewModel} declViewModel - context obj that is used for resolution like viewModel object
 * @param {Object} evaluateDepParams - attributes conditionList, clauseName, evaluationEnv, depModuleOb
 *                                {Object} conditionList- Conditions object of viewmodel
 *                                {String} clauseName -"activewhen","visiblewhen"
 *                                {Object} evaluationEnv -specific data required for this call like ctx.
 *                                {Object} depModuleObj
 * @return {Boolean} return true, if expression evalutes to true.
 */
export let evaluateConditionExpression = function( condition, declViewModel, evaluateDepParams ) {
    if( evaluateDepParams && typeof condition[ evaluateDepParams.clauseName ] === 'boolean' ) {
        return condition[ evaluateDepParams.clauseName ];
        /*
         *    activewhen: true
         */
    } else if( evaluateDepParams && condition[ evaluateDepParams.clauseName ] ) {
        condition = _.get( condition, evaluateDepParams.clauseName + '.condition' );

        if( typeof condition === 'boolean' ) {
            return condition;
        }
    }
    if( condition && condition.length ) {
        /*
          evaluate * conditions expression
          *: {
              condition: "conditions.xyz"
          }
          */
        return _evaluateConditionBasedExpression( condition, declViewModel, evaluateDepParams );
    }
    return false;
};

/**
 * Processes call back from watch due to state change and fires a 'condition.valueChanged' event in case the evaluation result of
 * the condition differs from the old value
 *
 * @param {Object} conditionStates - The set of conditions to announce any expression changes to.
 * @param {String} conditionName - The name of the condition to update when the expression changes.
 * @param {Array} queries - The array of objects containing query definitions
 * @param {Array} values - The array of objects of changed value to be used for each of the query object
 * @param {BooleanArray} adaptExpressions - The array of boolean values indicating whether each of the value needs to be adapted prior to usage
 * @param {Boolean} performAnd - Boolean value true indicating results of each query evaluation should be ANDed, false indicates ORed
 * @param {Object} conditionExpressions - The set of conditions values to announce any expression changes to.
 * @param {Object} trackValues - Whether or not to track expression value changes.
 */
let processWatch = function( conditionStates, conditionName, queries, values, adaptExpressions, performAnd, conditionExpressions, trackValues, viewModelName ) {
    var oldValue = conditionStates[ conditionName ];
    var newValue = queries.reduce( function( prevVerdict, currQuery, queryIndex ) {
        var verdict;
        var valuesToUse = values[ queryIndex ];
        if( currQuery && _.isObject( currQuery ) && values && values.length === queries.length ) {
            // determine whether object requires to be adapted
            if( adaptExpressions[ queryIndex ] ) {
                var valuesToAdapt = _.isArray( valuesToUse ) ? valuesToUse : [ valuesToUse ];
                valuesToUse = adapterService.getAdaptedObjectsSync( valuesToAdapt );
            }
            // expression is an object, hence process the query object inside it
            verdict = expressionParserUtils.evaluateExpressions( currQuery, valuesToUse, adapterService );
        } else {
            // expression is simple string with boolean result
            verdict = Boolean( values && valuesToUse );
        }

        var newExpressionValue = valuesToUse;
        var conditionVal;
        if( conditionExpressions ) {
            conditionVal = conditionExpressions[ conditionName ];
        }
        if( trackValues && conditionExpressions && conditionVal[ 0 ] !== newExpressionValue ) {
            eventBus.publish( 'condition.expressionValueChanged', {
                condition: 'conditions.' + conditionName,
                oldValue: conditionExpressions[ conditionName ],
                newValue: newExpressionValue
            } );
        }
        return performAnd ? prevVerdict && verdict : prevVerdict || verdict;
    }, performAnd );

    if( logger.isDeclarativeLogEnabled() ) {
        debugService.debugConditions( conditionName, newValue, queries, viewModelName );
    }

    if( oldValue !== newValue ) {
        eventBus.publish( 'condition.valueChanged', {
            condition: 'conditions.' + conditionName,
            oldValue: oldValue,
            newValue: newValue
        } );
    }
};

/**
 * Register a watch for given expression on provided scope and update conditionStates[conditionName] when
 * expression's value changes.
 *
 * @param {Object} conditionStates - The set of conditions to announce any expression changes to.
 * @param {Object} dataCtxNode - The 'dataCtxNode' (aka '$scope') to register the expression watch against.
 * @param {String} conditionName - The name of the condition to update when the expression changes.
 * @param {Array} expressions - Array of expression to be watched for value change.
 * @param {Object} conditionExpressions - The set of conditions to announce any values changes to.
 * @param {Array} queries - Optional parameter of array of objects containing query definitions for expression
 * @param {Array} adaptExpressions - Optional parameter array of booleans to indcate whether each expression should be adapted on watch callback
 * @param {Boolean} deepWatch - Optional parameter to indicate whether deep watching of the object is required or not
 * @param {Boolean} performAnd - Option parameter to indicate whether to perform AND or OR. Value true indicates ANDing
 */
export let registerWatch = function( conditionStates, dataCtxNode, conditionName, expressions, conditionExpressions, queries, adaptExpressions, deepWatch, performAnd ) {
    if( !queries ) {
        var watchQueryAdaptInfo = {
            watchers: [],
            queries: [],
            adapt: []
        };

        var multiAttributeANDExpression;
        var multiAttributeORExpression;
        _.forEach( expressions, function( expr ) {
            multiAttributeANDExpression = expr[ expressionParserUtils.$AND ];
            multiAttributeORExpression = expr[ expressionParserUtils.$OR ];

            var expressionsFinal = multiAttributeANDExpression || multiAttributeORExpression || expressions;
            _.forEach( expressionsFinal, function( finalExpr ) {
                var sourceToWatch = expressionParserUtils.resolve( expressionParserUtils.$SOURCE, finalExpr );
                var needsToAdapt = sourceToWatch && sourceToWatch[ expressionParserUtils.$ADAPT ];
                sourceToWatch = needsToAdapt || sourceToWatch || finalExpr;

                var executeQuery = expressionParserUtils.resolve( expressionParserUtils.$QUERY, finalExpr );
                watchQueryAdaptInfo.watchers.push( sourceToWatch );
                watchQueryAdaptInfo.queries.push( executeQuery || finalExpr );
                watchQueryAdaptInfo.adapt.push( Boolean( needsToAdapt ) );
            } );
        } );

        exports.registerWatch( conditionStates, dataCtxNode, conditionName, watchQueryAdaptInfo.watchers, conditionExpressions, watchQueryAdaptInfo.queries,
            watchQueryAdaptInfo.adapt, true, multiAttributeANDExpression );
    } else {
        // process expressions, queries and adaptExpressions array
        var dynamicValueResolvedQueries = queries.map( function( query ) {
            return expressionParserUtils.updateDynamicValues( query, dataCtxNode );
        } );

        // revisitme Charu - add support for trackChanges
        processWatch( conditionStates, conditionName, dynamicValueResolvedQueries, dataCtxNode.expressions[ conditionName ], adaptExpressions, performAnd, conditionExpressions, dataCtxNode
            .declViewModelJson.conditions[
                conditionName ].trackValues, dataCtxNode.declViewModelJson._viewModelId );
    }
};

/**
 * Expand a string based expression to include nested conditions
 *
 * @param {String} expression - a string expression to evaluate
 * @param {Object} internalViewModel - the object containing other expressions
 * @returns {String} the new string expression
 */
export let getRealExpression = function( expression, internalViewModel ) {
    //Since getRealExpression() api operates on string expressions, object types should be filtered.
    if( _.isString( expression ) ) {
        var conditionIndex = expression.indexOf( 'conditions.' );
        if( conditionIndex > -1 ) {
            var substring = expression.substring( conditionIndex );
            var endConditionIndex = substring.search( '[^a-zA-Z0-9._]' );
            endConditionIndex = endConditionIndex > -1 ? conditionIndex + endConditionIndex : expression.length;
            var referenceCondition = expression.substring( conditionIndex, endConditionIndex );
            var evaluatedCondition = _.get( internalViewModel, referenceCondition ) || {};
            var returnExpression = null;
            if( _.isString( evaluatedCondition.expression ) ) {
                returnExpression = expression.replace( referenceCondition, '(' + evaluatedCondition.expression + ')' );
            } else {
                return evaluatedCondition.expression;
            }
            return getRealExpression( returnExpression, internalViewModel );
        }
        return expression;
    }
    return undefined;
};

exports = {
    parseExpression,
    registerWatch,
    evaluateCondition,
    evaluateConditionExpression,
    getRealExpression
};
export default exports;
