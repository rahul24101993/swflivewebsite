/* eslint-disable @swf/swf/no-react-usage */
/* global React */
import { render as reactRender, unmountComponentAtNode } from 'react-dom';
import { AppCtxComponent } from 'js/reactAppCtx';
import { act } from 'react-dom/test-utils';
import React from 'react';
import { render as rtlRender } from '@testing-library/react';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import { _dispatchCtx } from 'js/reactAppCtx';

export const render = async ( jsx, containerElement, isCoExistComponent ) => {
    const renderInAct = async ( jsx ) => {
        await act( async () => {
            reactRender( <AppCtxComponent>{jsx}</AppCtxComponent>, containerElement );
        } );
    };

    await renderInAct( jsx );

    // REVISITME: This is needed due to a bug in coexisted components. Ideally render should only
    // need to be called once just like any other component. Remove this once the bug is fixed.
    // Run render twice for coexist components to ensure componentWillReceiveProps hook is run
    if( isCoExistComponent ) {
        const cloneElement = React.cloneElement( jsx );
        await renderInAct( cloneElement );
    }
};

/**
 * Render a component with the fake ctx provided. Required to ensure one component using
 * ctx does not impact tests for other components
 *
 * @param {JSX} ui DOM to render
 * @param {Object} param1 The initialState of ctx, the store to use (will be created if not provided), and the other standard options for React.render
 * @returns {JSX} Rendered elements
 */
export const renderWithCtx = function(
    ui, {
        initialState,
        store = createStore( _dispatchCtx, initialState ),
        ...renderOptions
    } = {}
) {
    // eslint-disable-next-line require-jsdoc
    function Wrapper( { children } ) {
        return <Provider store={store}>{children}</Provider>;
    }
    return rtlRender( ui, { wrapper: Wrapper, ...renderOptions } );
};

export const destroy = ( containerElement ) => {
    unmountComponentAtNode( containerElement );
    containerElement.parentElement.removeChild( containerElement );
};
