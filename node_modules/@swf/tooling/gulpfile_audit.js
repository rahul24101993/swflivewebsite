// Copyright (c) 2021 Siemens
/* eslint-env amd, es6, node */
/* eslint-disable no-await-in-loop */

const { copy, pathExists } = require( 'fs-extra' );
const { basename } = require( 'path' );
const gulp = global.gulp;

const logger = require( './js/logger' );
const util = require( './js/util' );

/**
 * This function does all of the actual work of auditing modules.
 *
 * @param {String} filePath - file path to module.json
 * @return {Promise} promise
 */
global.runAudits = async filePath => {
    await preAudit();

    const moduleJson = global.cache.filePath2moduleJson[ filePath ];
    if( moduleJson.auditPromise ) { return moduleJson.auditPromise; }
    moduleJson.auditPromise = new Promise( resolve => { moduleJson.auditResolve = resolve; } );

    const staticCodeAnalysis = require( './js/staticCodeAnalysis' );
    const eslint = require( 'gulp-eslint' );

    let srcSCA = [
        moduleJson.moduleDir + '/commandsViewModel.json',
        moduleJson.moduleDir + '/syncStrategy.json',
        moduleJson.moduleDir + '/states.json',
        moduleJson.moduleDir + '/workspace*.json',
        moduleJson.moduleDir + '/actionTemplateDefs.json',
        moduleJson.moduleDir + '/paste.json',
        moduleJson.moduleDir + '/nodeDefs.json',
        moduleJson.moduleDir + '/dragAndDrop.json',
        moduleJson.moduleDir + '/secondaryWorkareaTabs.json',
        moduleJson.moduleDir + '/decorators.json',
        moduleJson.moduleDir + '/propertyRendererTemplates.json'
    ];

    if( moduleJson.type.includes( 'cucumber' ) ) {
        srcSCA.push( moduleJson.moduleDir + '/featureFiles/**/*.feature' );
    }

    if( moduleJson.type.includes( 'java' ) ) {
        srcSCA = srcSCA.concat( [
            moduleJson.srcDir + '/**/*.java'
        ] );
    }
    const transpilers = global.cache.buildJson ? global.cache.buildJson.transpilers : null;
    if( transpilers ) {
        for( const [ key, transpiler ] of Object.entries( transpilers ) ) {
            if( moduleJson.type.includes( key ) ) {
                const intermidiateOutput = transpiler.outputDirectory ? transpiler.outputDirectory : 'out/transpile';
                const outputDir = util.normalizePath( `${process.cwd()}/${intermidiateOutput}` );
                if( moduleJson.transpileDir ) {
                    return util.normalizePath( moduleJson.transpileDir ).includes( outputDir );
                }
            }
        }
    }
    const srcESLint = [];
    let srcSCSSLint = [
        '!**/main.scss'
    ];
    if( moduleJson.srcDir ) {
        srcSCA = srcSCA.concat( [
            moduleJson.srcDir + '/*.@(css|scss)',
            moduleJson.srcDir + '/**/*.@(html|js|json|xml)'
        ] );
        srcESLint.push( moduleJson.srcDir + '/**/*.js' );
        srcSCSSLint.push( moduleJson.srcDir + '/*.@(css|scss)' );
    }

    if( moduleJson.testDir ) {
        srcSCA.push( moduleJson.testDir + '/**/*.js' );
        srcESLint.push( moduleJson.testDir + '/**/*.js' );
    }

    const promises = [];
    const gulpSrcSCA = gulp.src( srcSCA, { allowEmpty: true } )
        .pipe( staticCodeAnalysis( moduleJson.name, global.cache ) );
    promises.push( util.stream2Promise( gulpSrcSCA ) );

    // Very basic JSON validation
    const gulpSrcJSON = gulp.src( `${filePath}/**/*.json`, { allowEmpty: true } )
        .pipe( util.tapBlock( file => {
            try {
                JSON.parse( file.contents );
            } catch ( err ) {
                logger.error( 'Unable to parse ' + util.shortenPath( file.path ) + '\n' + err, 'audit: ' );
                throw new Error();
            }
        } ) );
    promises.push( util.stream2Promise( gulpSrcJSON ) );

    if( srcSCSSLint.length > 1 ) {
        try {
            // https://github.com/olegskl/gulp-stylelint
            // https://github.com/stylelint/stylelint
            // https://stylelint.io/
            const gulpStylelint = require( 'gulp-stylelint' );
            srcSCSSLint = srcSCSSLint.sort( a => /^!/.test( a ) ? 1 : 0 ); // do all negates at the end
            const gulpSrcSCSSLint = gulp.src( srcSCSSLint, { allowEmpty: true } )
                .pipe( gulpStylelint( {
                    reporters: [
                        { formatter: 'string', console: true }
                    ]
                } ) )
                .pipe( util.tapBlock( () => {
                    // Add the following to handle the scenario where no source is found & end event isn't emitted.
                } ) );
            promises.push( util.stream2Promise( gulpSrcSCSSLint ) );
        } catch ( err ) {
            // ignore error
        }
    }

    if( srcESLint.length > 0 ) {
        const gulpSrcESLint = gulp.src( srcESLint, { allowEmpty: true } )
            // eslint() attaches the lint output to the "eslint" property
            // of the file object so it can be used by other modules.
            .pipe( eslint( { quiet: true } ) )
            // eslint.format() outputs the lint results to the console.
            // Alternatively use eslint.formatEach() (see Docs).
            .pipe( eslint.formatEach( 'stylish', logger.warn ) )
            // To have the process exit with an error code (1) on
            // lint error, return the stream and pipe to failAfterError last.
            .pipe( eslint.failOnError() )
            .pipe( util.tapBlock( () => {
                // Add the following to handle the scenario where no source is found & end event isn't emitted.
            } ) );
        promises.push( util.stream2Promise( gulpSrcESLint ) );
    }

    await Promise.all( promises ).catch( err => {
        logger.error( err, 'audit: ' );
        logger.pipeErrorHandler( new Error( util.cliString( `${moduleJson.name}_audit` ) ) );
    } );

    moduleJson.auditResolve();
};

/**
 * This gulp task is for checking the non-module base code (src\image) for audit conditions.
 */
gulp.task( 'auditNonModule_images', () => {
    const staticCodeAnalysis = require( __dirname + '/js/staticCodeAnalysis' );
    const through = require( 'through2' );
    const icons = [];
    const { buildCache } = require( './js/staticCodeAnalysis' );
    const scaCache = buildCache();
    return gulp.src( [
        'src/**/image/*.svg',
        'src/image/**/*.svg',
        'node_modules/@swf/core/src/image/**/*.svg'
    ], { cwd: process.cwd(), allowEmpty: true } )
        .pipe( through.obj( function( file, ignore, cbTransform ) {
            const iconName = file.basename.replace( /[0-9]*\.svg/, '' );
            icons.push( {
                name: iconName,
                path: file.path
            } );
            cbTransform();
        }, function( cbFlush ) {
            const { groupBy } = require( 'lodash' );
            const groupedIcons = groupBy( icons, 'name' );
            const duplicateIcons = Object.keys( groupedIcons ).filter( k => groupedIcons[ k ].length > 1 ).sort();
            if( duplicateIcons.length > 1 ) {
                const formatIconError = k => `    ${logger.nameColor( k )}:\n${groupedIcons[k].map( x => `      ${logger.pathColor( x.path )}` ).join( '\n' )}`;
                const error = `Duplicate icons detected. Only one size of icon is currently supported.
${duplicateIcons.map( formatIconError ).join( '\n' )}`;
                logger.warn( error );
                const newDuplicates = duplicateIcons.filter( x => scaCache.duplicateIconIds && !scaCache.duplicateIconIds.includes( x ) );
                if( newDuplicates.length > 0 ) {
                    throw new Error( `New duplicate icons: ${newDuplicates.join( ',' )}` );
                }
            }
            cbFlush();
        } ) )
        .pipe( staticCodeAnalysis( 'nonModule', global.cache ) )
        .on( 'error', logger.pipeErrorHandler );
} );

gulp.task( 'auditNonModule_directives', async() => {
    await preAudit();

    const staticCodeAnalysis = require( __dirname + '/js/staticCodeAnalysis' );
    const srcDirPaths = [];
    for( const moduleJson of Object.values( global.cache.name2moduleJson ) ) {
        if( moduleJson.srcDir ) {
            srcDirPaths.push( moduleJson.srcDir + '/js/*.directive.js' );
        }
    }
    global.cache.audit.elems.sort();
    global.cache.audit.attrs.sort();
    srcDirPaths.sort();
    await util.stream2Promise( gulp.src( srcDirPaths )
        .pipe( util.tapBlock( file => {
            staticCodeAnalysis.checkDeps( global.cache, file );
        } ) ) );
} );

gulp.task( 'auditNonModule_SCA', () => {
    const staticCodeAnalysis = require( __dirname + '/js/staticCodeAnalysis' );
    const srcDirPaths = [];
    for( const moduleJson of Object.values( global.cache.name2moduleJson ) ) {
        if( moduleJson.srcDir ) {
            srcDirPaths.push( moduleJson.srcDir + '/**' );
        }
    }
    srcDirPaths.sort();
    const java = [];
    const js = [];
    const html = [];
    return gulp.src( srcDirPaths, { allowEmpty: true } )
        .pipe( util.tapBlock( file => {
            if( /\.java$/.test( file.path ) ) {
                java.push( basename( file.path ) );
            } else if( /\.js$/.test( file.path ) ) {
                js.push( basename( file.path ) );
            } else if( /\.html$/.test( file.path ) ) {
                html.push( basename( file.path ) );
            }
        } ) )
        .on( 'error', logger.pipeErrorHandler )
        .on( 'end', () => {
            const scaCache = staticCodeAnalysis.buildCache( global.cache );

            for( const key of [
                'cssReferences',
                'ngDirectiveReferences'
            ] ) {
                for( const value of scaCache.viewFileWhiteList[ key ] ) {
                    if( html.indexOf( value ) === -1 &&
                        html.indexOf( value + '.html' ) === -1 ) {
                        logger.error( 'Invalid reference in viewFileWhiteList.' + key + ' ' + value, 'auditNonModule_SCA: ' );
                    }
                }
            }

            for( const key of [
                'intermediateObjectUids'
            ] ) {
                for( const value of scaCache.DCPWhiteList[ key ] ) {
                    if( js.indexOf( value ) === -1 &&
                        js.indexOf( value + '.js' ) === -1 ) {
                        logger.error( 'Invalid reference in DCPWhiteList.' + key + ' ' + value, 'auditNonModule_SCA: ' );
                    }
                }
            }
        } );
} );

/**
 * This gulp task is to validate the non-module base code (src\kit.json) for audit of imageRepositoryConfiguration.
 */
gulp.task( 'auditNonModule_validateRepositoryConfigurations', async() => {
    await preAudit();

    const staticCodeAnalysis = require( __dirname + '/js/staticCodeAnalysis' );
    const kitJsons = [];
    for( const kitJson of Object.values( global.cache.filePath2kitJson ) ) {
        if( kitJson.solutionDef ) {
            kitJsons.push( kitJson.kitDir + '/kit.json' );
        }
    }
    await util.stream2Promise( gulp.src( kitJsons, { cwd: '.' } )
        .pipe( staticCodeAnalysis( 'nonModule', global.cache ) ) );
} );

/**
 * This gulp task is to validate the non-module base code (src\kit.json) for audit of imageRepositoryConfiguration.
 */
gulp.task( 'auditNonModule_dependencies', async() => {
    await global.cacheLoaded();
    const { getMissingKitDeps, getModuleInformation, getKitInformation } = require( './js/dependencyCheck' );
    const { ensureDir, writeJson } = require( 'fs-extra' );
    const { groupBy, sortBy } = require( 'lodash' );
    await ensureDir( `${process.cwd()}/out/audit` );
    const moduleInfoList = await Promise.all( Object.values( global.cache.name2moduleJson )
        .map( async moduleJson => {
            const moduleInfo = await getModuleInformation( moduleJson );
            if( process.env.LOG_LEVEL === 'DEBUG' ) {
                await writeJson( `${process.cwd()}/out/audit/${moduleJson.name}_module_deps.json`, moduleInfo, {
                    spaces: 2
                } );
            }
            return {
                module: moduleJson,
                info: moduleInfo
            };
        } ) );
    const kitInfoList = await Promise.all( Object.values( global.cache.name2kitJson )
        .map( async kitJson => {
            const kitInfo = getKitInformation( kitJson, moduleInfoList );
            if( process.env.LOG_LEVEL === 'DEBUG' ) {
                await writeJson( `${process.cwd()}/out/audit/${kitJson.name}_kit_deps.json`, kitInfo, {
                    spaces: 2
                } );
            }
            return {
                kit: kitJson,
                info: kitInfo
            };
        } ) );
    const kitNameToInfo = kitInfoList
        .reduce( ( acc, { kit, info } ) => {
            acc[ kit.name ] = info;
            return acc;
        }, {} );
    const dependencyErrors = sortBy( kitInfoList
        .map( kitInfo => getMissingKitDeps( kitInfo, kitNameToInfo, global.cache.name2kitJson ) )
        .reduce( ( acc, nxt ) => [ ...acc, ...nxt ] ), 'kit' );
    const {
        createHash
    } = require( 'crypto' );
    const ansiRegex = require( 'ansi-regex' ); //provided through "chalk"
    const hashError = ( { sample, kit, type, name } ) => {
        let hash = createHash( 'sha256' );
        hash.update( sample.replace( ansiRegex(), '' ) );
        hash.update( kit );
        hash.update( type );
        hash.update( name );
        return hash.digest( 'hex' );
    };
    for( const de of dependencyErrors ) {
        de.id = hashError( de );
    }
    await writeJson( `${process.cwd()}/out/audit/missingdeps.json`, dependencyErrors, {
        spaces: 2
    } );
    const groupedByKit = groupBy( dependencyErrors, 'kit' );
    for( const kitName of Object.keys( groupedByKit ) ) {
        logger.warn( `${logger.nameColor.underline( kitName )} kit has invalid dependencies` );
        for( const { type, name, sourceKit, sourceModule, file, sample, id } of groupedByKit[ kitName ] ) {
            const missingError = logger.errorColor( 'Does not exist' );
            // eslint-disable-next-line no-console
            console.log( `  Audit ID: ${logger.nameColor( id )}
  Type: ${logger.nameColor( type )}
  Dependency name: ${logger.nameColor( name )}
  Kit containing dependency: ${sourceKit ? logger.nameColor( sourceKit ) : missingError}
  Module containing dependency: ${sourceModule ? logger.nameColor( sourceModule ) : missingError}
  Kit with invalid dependency: ${logger.nameColor( kitName )}
  File: ${logger.pathColor( file )}
  Sample:
  """
  ${sample.replace( /\n/g, '\n  ' )}
  """
` );
        }
    }
    if( dependencyErrors.length > 0 ) {
        logger.warn( `Dependency audit failed with ${dependencyErrors.length} invalid dependencies` );
        // Disabled until AW violations are resolved
        // throw new Error( `Dependency audit failed with ${dependencyErrors.length} invalid dependencies` );
    }
    const { buildCache } = require( './js/staticCodeAnalysis' );
    const scaCache = buildCache();
    const knownErrors = scaCache.invalidDependencyIDs || [];
    const newErrors = dependencyErrors.filter( x => !knownErrors.includes( x.id ) );
    if( newErrors.length > 0 ) {
        throw new Error( `Dependency audit failed with ${newErrors.length} new invalid dependencies:\n${newErrors.map( x => x.id ).join( '\n' )}` );
    }
} );

/**
 * This gulp task is for checking the non-module cucumber code for audit conditions.
 */
gulp.task( 'auditNonModule_cucumber', () => {
    const eslint = require( 'gulp-eslint' );
    let eslintFiles = [];
    // Default path for where to put automation code
    if( pathExists( 'test/cucumber/**/*.js' ) ) {
        eslintFiles.push( 'test/cucumber/**/*.js' );
    }
    // Path for AW automation code
    if( pathExists( 'src/test/cucumber/**/*.js' ) ) {
        eslintFiles.push( 'src/test/cucumber/**/*.js' );
    }
    if( eslintFiles.length > 0 ) {
        return gulp.src( eslintFiles, { allowEmpty: true } )
            .pipe( eslint( { quiet: true } ) )
            .pipe( eslint.failOnError() )
            .pipe( util.tapBlock( () => {} ) );
    }
} );

/**
 * Run the generator and do a build to ensure the generated content compiles correctly
 *
 * Note: This will only work in AFX not AW because generator will not detect anything within node_modules
 */
gulp.task( 'generatorTest', async() => {
    await global.cacheLoaded();

    const generator = require( './js/generator' );
    await generator.run( [
        '-t', 'theme',
        '-module', 'test-module',
        '-n', 'Red',
        '-color', '#FF0000'
    ] );

    await new Promise( ( resolve, reject ) => {
        // Start tasks and resolve when complete
        let siteFilePath;
        for( const [ filePath, siteJson ] of Object.entries( global.cache.filePath2siteJson ) ) {
            if( siteJson.name === 'test' ) {
                siteFilePath = filePath;
            }
        }
        global.buildSite( siteFilePath ).then( resolve ).catch( reject );
    } );

    // // Cleanup after running
    await util.del( [
        './test/generator/commandsViewModel.json',
        './test/generator/**/ui-Red.scss',
        './test/generator/**/test-moduleMessages.json'
    ] );
} );

gulp.task( 'auditNonModule', gulp.parallel(
    'auditNonModule_images',
    'auditNonModule_directives',
    'auditNonModule_validateRepositoryConfigurations',
    'auditNonModule_dependencies',
    'auditNonModule_cucumber'
) );

let preAuditPromise;
let preAuditResolve;

/**
 */
async function preAudit() {
    // Ensure this is run only once
    if( preAuditPromise ) { return preAuditPromise; }
    preAuditPromise = new Promise( resolve => { preAuditResolve = resolve; } );

    await global.cacheLoaded();

    const done = await util.queue( 'siteBuild', 1 );

    // Ensure audit files exists in current directory. If not, seed from Apollo module.
    for( const filename of [
        '.eslintrc.js',
        '.stylelintrc.json'
    ] ) {
        if( !await pathExists( filename ) ) {
            await copy( `${__dirname}/${filename}`, filename );
        }
    }

    await require( './js/preAuditPrep.js' )( global.cache );

    const staticCodeAnalysis = require( __dirname + '/js/staticCodeAnalysis' );
    const xml2js = require( 'xml2js' );

    const srcDirPaths1 = [];
    const srcDirPaths2 = [];
    const srcDirPaths3 = [];
    for( const moduleJson of Object.values( global.cache.name2moduleJson ) ) {
        if( moduleJson.srcDir ) {
            srcDirPaths1.push( moduleJson.srcDir + '/schema/**/*.xsd' );
            srcDirPaths2.push( moduleJson.srcDir + '/js/*.directive.js' );
            srcDirPaths3.push( moduleJson.srcDir + '/i18n/*Messages.json' );
            srcDirPaths3.push( moduleJson.srcDir + '/i18n/*Constants.json' );
        }
    }
    srcDirPaths1.sort();
    srcDirPaths2.sort();
    srcDirPaths3.sort();
    global.cache.audit.xsd = {};
    global.cache.audit.i18n = {};
    return Promise.all( [
        util.stream2Promise( gulp.src( srcDirPaths1, { allowEmpty: true } )
            .pipe( util.tapBlock( file => {
                if( file.contents ) {
                    const filename = basename( file.path, '.xsd' );
                    const parser = new xml2js.Parser();
                    parser.parseString( file.contents.toString(), ( err, results ) => {
                        if( err ) {
                            logger.error( `Error parsing ${filename}\n${err}`, 'pre-audit: ' );
                        } else if( !results[ 'declUI:schema' ] || Object.keys( results ).length !== 1 ) {
                            logger.error( `Invalid schema for ${file.path}`, 'pre-audit: ' );
                        } else {
                            global.cache.audit.xsd[ filename ] = results[ 'declUI:schema' ];
                        }
                    } );
                }
            } ) ) ),
        util.stream2Promise(
            gulp.src( srcDirPaths2, { allowEmpty: true } )
                .pipe( util.tapBlock( file => {
                    staticCodeAnalysis.checkDepsPrep( global.cache, file );
                } ) )
        ),
        util.stream2Promise( gulp.src( srcDirPaths3, { allowEmpty: true } )
            .pipe( util.tapBlock( file => {
                if( file.contents ) {
                    const filename = basename( file.path, '.json' );
                    const contents = JSON.parse( file.contents.toString() );
                    global.cache.audit.i18n[ filename ] = Object.keys( contents );
                }
            } ) )
        )
    ] ).then( done ).then( preAuditResolve ).catch( logger.pipeErrorHandler );
}

gulp.task( 'test_audit', async() => {
    await preAudit();
    const moduleJson = global.cache.name2moduleJson.audittestdata;
    if( !moduleJson ) {
        logger.error( 'No audittestdata module found!', 'test_audit: ' );
    } else {
        await global.runAudits( moduleJson.moduleDir );
    }
} );
