#!/usr/bin/env node
/* eslint-disable max-lines */
/* eslint-disable complexity */
/* eslint-disable sonarjs/cognitive-complexity */

/* eslint-env amd, es6, node */

// This script is used to inspect source code in preparation for service conversion as part of reducing angularJS dependency
// When script is run with --assessComponents flag, script will analyze source code to highlight impact of removing angularJS dependencies and help with componentization.
// This script should be located in STAGE_DIR/node_modules/afx/build/js
// node ./build/js/sourceInspect.js --sourcePath=src/**/* --destPath=./out
// node node_modules/afx/build/js/sourceInspect.js --sourcePath=node_modules/afx/src/**/*,src/**/* --destPath=./out
// node ../afx/build/js/sourceInspect.js --sourcePath=../afx/src/**/*,src/**/* --destPath=./out
// node .\build\js\sourceInspect.js --sourcePath D:/udu/shah_aw60/src/**/*,D:/udu/shah_spond_afx_next_react/@swf/core/src/**/* --destPath D:\udu\shah_afx_new\afx\sourceInspect

const gulp = require( 'gulp' );
const util = require( './util' );
const logger = require( './logger' );
const acorn = require( 'acorn' );
const acornClassFields = require( 'acorn-class-fields' );
const acornJSX = require( 'acorn-jsx' );
const walk = require( 'acorn-walk' );
const _ = require( 'lodash' );
const fs = require( 'fs' );

const allHtmlTags = [ 'div', 'img', 'h3', 'label', 'span', 'strong', 'br', 'h6', 'h1', 'ul', 'li', 'b', 'p', 'hr', 'a', 'h2', 'svg', 'defs', 'rect', 'path', 'use', 'g', 'line', 'circle', 'table', 'tr',
    'td', 'input', '6"', 'button', 'iframe', 'h5', 'textarea', 'pre', 'H1', 'h4', 'header', 'main', 'nav', 'em', 'code'
];

let verbose = false;

let depsNotFound = {};

let assessComponents = false;

let result = {
    directive: [],
    controller: [],
    service: [],
    module: [],
    constant: [],
    external: {},
    test: [],
    viewModel: [],
    functions: [],
    angularism: [],
    dommanipu: [],
    ctxmutations: [],
    awAdd: [],
    awXrt: [],
    allCommandBars: [],
    commandBarsWithServerConditions: [],
    stateJsonEntries: [],
    allStats: {},
    allCommandsList: [],
    commandsWithCommandPanel: new Set(),
    breadcrumbs: [],
    commandSubPanels: [],
    allComponents: [],
    jsStats: {},
    htmlStats: {},
    locSubLocStats: {},
    apiUsage: [],
    serviceModuleMap: {}
};

const es6ServiceRegistartionRegex = /app.factory\([\s\S]*,[\s]*\(\)[\s]*=>/gm;
const es5ServiceRegistrationRegex = /app.(factory|service)\([\s]*'[\S\S]*',[\s]*(function|\[)/gm;
const cwdPathLen = process.cwd().length + 1;
let sourcePathLen = {};
const angularismTokens = [ '$scope', '$watch', '$digest', '$on', '$broadcast', '$compile', '$timeout',
    '$destroy', '$injector', '$evalAsync', '$parent', '$applyAsync', ' ng-',
    // Wrapper services
    'AwRootScopeService', 'AwCompileService', 'AwInjectorService', 'AwSceService'
];
const domManipTokens = [
    //JQuery
    '$.', '$(',
    //Dom manipulations
    '.createElement', '.append', '.setAttribute', '.getElement', '.querySelector'
];
const pathToModuleJSONMapping = {};
const jsonDepsMap = {};
const jsFunctionsMap = {};
const commandAnalysisMap = {
    commandPlacementToCommandsList: {},
    commandConditionsMap: {},
    serverConditions: new Set(),
    conditionsWithSubConditions: {}
};

// needed because we are converting the few of the services
const ngClassBasedServices = {
    $q: 'awPromiseService',
    $injector: 'awInjectorService',
    $http: 'awHttpService',
    $state: 'awStateService',
    $filter: 'awFilterService',
    $locale: 'awLocaleService',
    $rootScope: 'awRootScopeService',
    $timeout: 'awTimeoutService',
    $sce: 'awSceService',
    $parse: 'awParseService',
    $window: 'awWindowService',
    $location: 'awLocationService',
    $interpolate: 'awInterpolateService',
    $templateCache: 'awTemplateCacheService',
    $cacheFactory: 'awCacheFactoryService',
    $compile: 'awCompileService',
    $document: 'awDocumentService',
    $log: 'awLogService',
    $animate: 'awAnimateService',
    $element: 'awElementService',
    $interval: 'awIntervalService',
    $$rAF: 'awRAFService'
};
/**
 * Extract the relative path to the current working directory.
 *
 * @param {Object} file - file
 * @return {String} relative file path
 */
function getRelativePath( file ) {
    return file.path.substring( cwdPathLen, file.path.length ).replace( /\\/g, '/' );
}

/**
 * Find relative path
 *
 * @param {Object} file - file
 * @return {String} relative file path
 */
function getRelativePathFromSourcePath( file ) {
    let modulePathLen = 0;
    for( const modulePath in sourcePathLen ) {
        if( file.path.replace( /\\/g, '/' ).startsWith( modulePath ) ) {
            modulePathLen = sourcePathLen[ modulePath ];
            break;
        }
    }
    return file.path.substring( modulePathLen, file.path.length ).replace( /\\/g, '/' );
}

/**
 * Find Return Exports - walk a subset of the AST tree to find the return exports statement
 *
 * @param {object} astNode - A node the the AST Tree from a parsed .js file
 * @returns {boolean} true if has init code
 */
function guessHasInit( astNode ) {
    let hasInit = false;

    if( astNode && astNode.body && astNode.body.body ) {
        _.forEach( astNode.body.body, function( b ) {
            if( b.type === 'ExpressionStatement' && b.expression.type === 'CallExpression' ) {
                hasInit = true;
            }
        } );
    }
    return hasInit;
}

/**
 * Parse return for directive
 * @param {string} contents file contents
 * @param {object} astNode - A node the the AST Tree from a parsed .js file
 * @returns {JSON} key properties from directive
 */
function getDirectiveFeature( contents, astNode ) {
    const res = {};
    _.forEach( astNode.body.body, function( node ) {
        if( node.type === 'ReturnStatement' && node.argument ) {
            //console.log( JSON.stringify( returnNode.argument ) );
            //console.log( getContentsFromNode( contents, returnNode.argument ) );
            // Assume it is ObjectExpression, no more check
            const directiveObj = node.argument;
            _.forEach( directiveObj.properties, prop => {
                if( prop.key.name === 'scope' ) {
                    // do something special
                    const objBindingVars = [];
                    _.forEach( prop.value.properties, scopeProp => {
                        if( /^=/.test( scopeProp.value.value ) ) {
                            objBindingVars.push( scopeProp.key.name );
                        }
                    } );
                    res.scope = objBindingVars.join( ',' );
                } else if( prop.key.name === 'templateUrl' ) {
                    res.templateUrl = getContentsFromNode( contents, prop.value ).replace( /[\n\r]/g, '' );
                } else {
                    if( prop.value.type === 'Literal' ) {
                        res[ prop.key.name ] = prop.value.value;
                    } else if( prop.value.type === 'Identifier' ) {
                        res[ prop.key.name ] = prop.value.name;
                    } else {
                        res[ prop.key.name ] = prop.value.type;
                    }
                }
            } );
            return false;
        }
    } );
    return res;
}

/**
 * get test info from file
 * @param {Object} file javascript file
 * @returns {Array} test Info as array
 */
function getUnitTestDefs( file ) {
    let res = {
        name: file.path.match( /(\/|\\)([^\\\/]*)\.js$/i )[ 2 ],
        path: getRelativePath( file ),
        cases: []
    };

    let ast;
    var acornJ = acorn.Parser.extend( acornJSX() );
    try {
        ast = acornJ.parse( file.contents.toString(), {
            allowReturnOutsideFunction: true,
            sourceType: 'module',
            ecmaVersion: 11
        } );
    } catch ( err ) {
        if ( verbose ) {
            logger.error( `Unable to parse unit test ${util.normalizePath( file.path )}\n${err}` );
        }
        return [];
    }

    walk.simple( ast, {
        CallExpression: callNode => {
            const callee = callNode.callee;
            if( callee.type === 'Identifier' &&
                callee.name === 'it' ) {
                // res.push( aaa );
                let caseName = callNode.arguments && callNode.arguments[ 0 ] ? callNode.arguments[ 0 ].value : undefined;
                res.cases.push( caseName ? caseName : 'undefined' );
            }
        }
    }, {
        ...walk.base,
        JSXElement: () => {},
        JSXFragment: () => {}
    } );
    return res;
}

const getContentsFromNode = function( contents, node ) {
    return contents.substring( node.start, node.end );
};

/**
 * get OOTB ng service name ($state, $http)
 * @param {Object} file javascript file
 * @returns {String} service name
 */
function getOOTBNgServiceName( file ) {
    const filePath = util.normalizePath( file.path );
    const contents = file.contents.toString();
    let moduleName = getModuleName( file );
    let serviceName;
    let ast;
    //check ng services wrappers
    _.forEach( ngClassBasedServices, ( val, key ) => {
        if( moduleName.includes( val ) ) {
            serviceName = key;
        }
    } );
    if( serviceName ) {
        return serviceName;
    }
    var acornJ = acorn.Parser.extend( acornJSX() );
    try {
        ast = acornJ.parse( file.contents.toString(), {
            allowReturnOutsideFunction: true,
            sourceType: 'module',
            ecmaVersion: 11
        } );
    } catch ( err ) {
        // If the JS file has JSX, let's replace all instances and parse again
        let fileContent = contents.replace( /return\s+\([^]*\);/g, '' );
        try {
            ast = acorn.parse( fileContent, {
                allowReturnOutsideFunction: true,
                sourceType: 'module',
                ecmaVersion: 11
            } );
        } catch ( err ) {
            if ( verbose ) {
                logger.error( `Unable to parse NG service ${filePath}\n${err}` );
            }
            return serviceName;
        }
    }
    walk.simple( ast, {
        AssignmentExpression: callNode => {
            if( getContentsFromNode( contents, callNode ).includes( '.serviceName' ) ) {
                if( callNode.right ) {
                    serviceName = callNode.right.value;
                }
            }
        }
    }, {
        ...walk.base,
        JSXElement: () => {},
        JSXFragment: () => {}
    } );
    return serviceName;
}

/**
 * get ngModule info from file
 * @param {Object} file javascript file
 * @param {String} contents Content of the file
 * @param {String} relativePath Relative path
 * @param {String} moduleName Module name
 * @returns {Array} ngModule info as array
 */
function getFileFunctionMapping( file, contents, relativePath, moduleName ) {
    let jsModuleName = getModuleName( file );
    const filePath = util.normalizePath( file.path );
    const fileInfo = {
        filePath: filePath,
        deps: [],
        ngModules: [], // Defined NG modules
        publishedJsMethods: [],
        test: /\/(test|nodejs)\//.test( filePath )
    };
    const functionsList = [];

    if( !jsModuleName ) {
        let relativePath = getRelativePathFromSourcePath( file );
        const splitFromSrcJs = relativePath.split( '/' );
        if( splitFromSrcJs.length ) {
            jsModuleName = 'js/' + splitFromSrcJs[ splitFromSrcJs.length - 1].replace( '.js', '' );
        }
    }
    result.serviceModuleMap[ jsModuleName ] = moduleName;

    let ast;
    var acornCF = acorn.Parser.extend( acornClassFields );
    try {
        ast = acornCF.parse( contents, {
            allowReturnOutsideFunction: true,
            sourceType: 'module',
            ecmaVersion: 11
        } );
    } catch ( err ) {
        // If the JS file has JSX, let's replace all instances and parse again
        // let fileContent = contents.replace( /return\s\([^]*\);/g, '' );
        var acornJ = acorn.Parser.extend( acornJSX() );
        try {
            ast = acornJ.parse( contents, {
                allowReturnOutsideFunction: true,
                sourceType: 'module',
                ecmaVersion: 11
            } );
        } catch ( err ) {
            if ( verbose ) {
                logger.error( `Unable to parse File function mapping ${filePath}\n${err}` );
            }
            return fileInfo;
        }
    }

    walk.simple( ast, {
        ImportDeclaration: importNode => {
            if( importNode.source && importNode.source.value &&
                ( importNode.source.value.startsWith( 'js/' ) || importNode.source.value.startsWith( 'soa/' ) ) ) {
                if( importNode.specifiers && importNode.specifiers.length ) {
                    // TODO: Do we need only 0th element? Find out and fix more than 1 array values
                    const variableName = importNode.specifiers[0].local ? importNode.specifiers[0].local.name : '';

                    const regExprStr = '(' + variableName + '\\.)[\\.\\w]+(\\()';
                    const regExpr = new RegExp( regExprStr, 'gi' );
                    const variableMatches = contents.match( regExpr );
                    if( variableMatches && variableMatches.length > 0 ) {
                        const methodFreqMap = variableMatches.reduce( ( freqMap, methodName ) => {
                            freqMap[methodName] = freqMap[methodName] ? freqMap[methodName] + 1 : 1;
                            return freqMap;
                        }, {} );

                        for( const invocationInst in methodFreqMap ) {
                            const methodName = invocationInst.replace( variableName + '.', '' ).replace( '(', '' );
                            result.apiUsage.push( {
                                'Consuming Module': moduleName,
                                'Consuming File': relativePath,
                                'Provider Service': importNode.source.value,
                                'Provider API': methodName,
                                'Provider Module': 'NA',
                                'Call Count': methodFreqMap[invocationInst]
                            } );
                        }
                    }
                } else {
                    // TODO: Let's see who hits this
                }
            }
        },
        VariableDeclaration: varNode => {
            let varDeclaration = _.get( varNode, 'declarations[0]' );
            if( varDeclaration && varDeclaration.id && varDeclaration.id.type === 'Identifier' &&
                varDeclaration.init && varDeclaration.init.type === 'FunctionExpression' ) {
                if( varDeclaration.init.params.length ) {
                    const params = varDeclaration.init.params.map( param => param.name );
                    if( params.length ) {
                        const paramAssignmentCount = {};
                        let functionComplexityLoc = 0;
                        const startChar = varDeclaration.init.body.start;
                        const endChar = varDeclaration.init.body.end;
                        const funBody = contents.substring( startChar, endChar );
                        for( const param of params ) {
                            let count = 0;
                            const rows = funBody.split( '\n' );
                            for( const row of rows ) {
                                if( row.includes( ' = ' ) ) {
                                    var assignmentLeftSide = row.split( ' = ', 1 );
                                    if( assignmentLeftSide[ 0 ].includes( param ) ) {
                                        count++;
                                    }
                                }
                            }
                            functionComplexityLoc = rows.length;
                            if( count ) {
                                paramAssignmentCount[ param ] = count;
                            }
                        }
                        if( Object.keys( paramAssignmentCount ).length ) {
                            let mutationFrequency = '';
                            for( const [ variable, count ] of Object.entries( paramAssignmentCount ) ) {
                                mutationFrequency += variable + ': ' + count + ', ';
                            }
                            mutationFrequency = mutationFrequency.slice( 0, -2 );
                            const mutationFunc = {
                                'Module Name': moduleName,
                                File: relativePath,
                                Function: varDeclaration.id.name,
                                'Function Complexity (In LOC)': functionComplexityLoc,
                                'Mutation Frequency': mutationFrequency
                            };
                            functionsList.push( mutationFunc );
                            if( jsModuleName ) {
                                if( !jsFunctionsMap[ jsModuleName ] ) {
                                    jsFunctionsMap[ jsModuleName ] = {};
                                }
                                jsFunctionsMap[ jsModuleName ][ varDeclaration.id.name ] = mutationFunc;
                            }
                        }
                    }
                }
            }
        },
        ExportNamedDeclaration: exportNode => {
            let exportDeclaration = _.get( exportNode, 'declaration.declarations[0]' );
            if( exportDeclaration && exportDeclaration.id && exportDeclaration.id.type === 'Identifier' &&
                exportDeclaration.init && exportDeclaration.init.type === 'FunctionExpression' ) {
                // Moved the code to variables section
            }
        },
        // eslint-disable-next-line complexity
        CallExpression: callNode => {
            // If this statement defines an NG module the name will be captured
            // If this statement only references NG module then only the dependencies are listed
            // This statement may also define an NG module which depends on other modules
        },
        ExportDefaultDeclaration: exportDefultNode => {
            // Do we need anything here?
        }
    }, {
        ...walk.base,
        JSXElement: () => {},
        JSXFragment: () => {}
    } );
    return functionsList;
}

/**
 * Populate commands
 * @param {Object} actions List of actions
 */
function populateCommandsWithCommandPanel( actions ) {
    for( const actionName in actions ) {
        const actionObj = actions[ actionName ];
        if( actionObj.method && actionObj.method === 'activateCommandPanel' &&
            actionObj.inputData && actionObj.inputData.commandId ||
            actionObj.actionType === 'activateCommandPanel' && actionObj.inputData &&
            actionObj.inputData.commandId ) {
            result.commandsWithCommandPanel.add( actionObj.inputData.commandId );
        }
    }
}

/**
 * get ngModule info from file
 * @param {Object} file javascript file
 * @param {String} fileContents file content
 * @returns {Array} ngModule info as array
 */
function populateViewModelJSFuncDetails( file, fileContents ) {
    const allJsDeps = new Set();
    for( const actionName in fileContents.actions ) {
        const actionObj = fileContents.actions[ actionName ];

        let relativePath = getRelativePathFromSourcePath( file );
        if( actionObj.actionType === 'JSFunction' || actionObj.actionType === 'JSFunctionAsync' ||
            actionObj.actionType === 'popup' || actionObj.actionType === 'syncFunction' ) {
            // const splitFromSrcJs = relativePath.split('/src/viewmodel');
            // const prefix = splitFromSrcJs.length === 1 ? relativePath.split('/src')[0] : splitFromSrcJs[0];
            // const moduleJsonName = pathToModuleJSONMapping[prefix];

            // functionsList.push( { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', 'File': relativePath, 'Action Name': actionName, 'Deps': actionObj.deps } );
            if( actionObj.deps ) {
                if( !jsonDepsMap[ actionObj.deps ] ) {
                    jsonDepsMap[ actionObj.deps ] = {};
                }
                if( !jsonDepsMap[ actionObj.deps ][ actionObj.method ] ) {
                    jsonDepsMap[ actionObj.deps ][ actionObj.method ] = [];
                }
                jsonDepsMap[ actionObj.deps ][ actionObj.method ].push( relativePath );
                allJsDeps.add( actionObj.deps );
            }
        } else if( actionObj.deps ) {
            // TODO: Processing of Functions block
            const actionObjStr = JSON.stringify( actionObj );
            const splActionObj = actionObjStr.split( '{{function:' );
            if( splActionObj.length > 1 ) {
                for( let id = 1; id < splActionObj.length; id++ ) {
                    const funcName = splActionObj[ id ].split( '}}' )[ 0 ];
                    if( funcName ) {
                        if( !jsonDepsMap[ actionObj.deps ] ) {
                            jsonDepsMap[ actionObj.deps ] = {};
                        }
                        if( !jsonDepsMap[ actionObj.deps ][ funcName ] ) {
                            jsonDepsMap[ actionObj.deps ][ funcName ] = [];
                        }
                        jsonDepsMap[ actionObj.deps ][ funcName ].push( relativePath );
                    } else {
                        logger.error( 'Code should never reach here' );
                    }
                }
            } else {
                if( !actionObj.actionType === 'TcSoaService' && !actionObj.actionType === 'Event' && verbose ) {
                    logger.error( `Something is wrong ${relativePath}, ${actionObj.deps}, ${actionObj.actionType}, ${actionObj.method}` );
                }
            }
            allJsDeps.add( actionObj.deps );
        }
    }
    return allJsDeps;
}

/**
 * Collect component details like Has JSX, 1st level JS Deps, other component deps etc
 * @param {String} moduleJsonName Module name
 * @param {String} relativePath Relative path
 * @param {String} jsonContent JSON content
 * @param {String} firstLevelJsDeps List of first level JS
 */
function collectComponentDetails( moduleJsonName, relativePath, jsonContent, firstLevelJsDeps ) {
    let renderDep = '';
    if( jsonContent.lifecycleHooks && jsonContent.lifecycleHooks.render ) {
        const actionDef = jsonContent.actions[ jsonContent.lifecycleHooks.render ];
        if( actionDef ) {
            const splitDep = actionDef.deps.split( /\//g );
            renderDep = splitDep[ splitDep.length - 1 ];
        } else {
            if ( verbose ) {
                logger.error( `Render action not found in ${relativePath} for ${actionDef}` );
            }
        }
    }
    let category = '';
    if( jsonContent.props && jsonContent.props.prop ) {
        category = 'Property';
    }
    const viewModelObject = {
        'Module Name': moduleJsonName ? moduleJsonName : 'NA',
        File: relativePath,
        'Has JSX': jsonContent.lifecycleHooks && jsonContent.lifecycleHooks.render ? 'Yes' : 'No',
        'Component Name': '',
        Category: category,
        'First level Service Count': firstLevelJsDeps.size,
        'First level Service LOC': 0,
        'First level Service Dependencies': [ ...firstLevelJsDeps ],
        'Other Component Deps Count': 0,
        'Other Component Deps': [],
        renderDep
    };
    result.allComponents.push( viewModelObject );
}

/**
 * get ngModule info from file
 * @param {Object} file javascript file
 * @returns {Array} ngModule info as array
 */
function getNgModuleDefs( file ) {
    let res = [];
    const filePath = util.normalizePath( file.path );
    const moduleName = getModuleName( file );
    const fileInfo = {
        filePath: filePath,
        deps: [],
        ngModules: [], // Defined NG modules
        publishedJsMethods: [],
        test: /\/(test|nodejs)\//.test( filePath )
    };
    const identifiers = [];

    let ast;
    const contents = file.contents.toString();
    var acornJ = acorn.Parser.extend( acornJSX() );
    try {
        ast = acornJ.parse( contents, {
            allowReturnOutsideFunction: true,
            sourceType: 'module',
            ecmaVersion: 11
        } );
    } catch ( err ) {
        // If the JS file has JSX, let's replace all instances and parse again
        let fileContent = contents.replace( /return\s+\([^]*\);/g, '' );
        try {
            ast = acorn.parse( fileContent, {
                allowReturnOutsideFunction: true,
                sourceType: 'module',
                ecmaVersion: 11
            } );
        } catch ( err ) {
            if ( verbose ) {
                logger.error( `Unable to parse Ng module def ${filePath}\n${err}` );
            }
            return fileInfo;
        }
    }

    let relativePath = getRelativePath( file );

    walk.simple( ast, {
        VariableDeclaration: varNode => {
            let varDeclaration = _.get( varNode, 'declarations[0]' );
            if( varDeclaration && varDeclaration.id && varDeclaration.id.type === 'Identifier' &&
                varDeclaration.init && varDeclaration.init.type === 'Literal' ) {
                identifiers.push( { name: varDeclaration.id.name, value: varDeclaration.init.value } );
            }
        },
        ExportNamedDeclaration: exportNode => {
            let exportDeclaration = _.get( exportNode, 'declaration.declarations[0]' );
            if( exportDeclaration && exportDeclaration.id && exportDeclaration.id.type === 'Identifier' &&
                exportDeclaration.init && exportDeclaration.init.type === 'Literal' ) {
                identifiers.push( { name: exportDeclaration.id.name, value: exportDeclaration.init.value } );
            }
        },
        // eslint-disable-next-line complexity
        CallExpression: callNode => {
            // If this statement defines an NG module the name will be captured
            // If this statement only references NG module then only the dependencies are listed
            // This statement may also define an NG module which depends on other modules
            const ngModule = {
                name: undefined, // NG Module name
                path: relativePath,
                deps: [], // NG dependency list
                // functionParameters: [] // Module parameter list
                moduleName: moduleName
            };

            const callee = callNode.callee;
            if( callee.object && callee.property &&
                callNode.arguments.length === 2 &&
                ( callNode.arguments[ 0 ].type === 'Literal' ||
                    callNode.arguments[ 0 ].type === 'Identifier' ) &&
                // callee.object.name === 'app' && // avoid unnecessary assumption
                callee.object.type === 'Identifier' &&
                callee.property.name &&
                /^(controller|directive|factory|service|constant)$/.test( callee.property.name ) ) {
                if( callNode.arguments[ 0 ].type === 'Identifier' ) {
                    const identifierName = callNode.arguments[ 0 ].name;
                    //Search identifierName in the identifiers array
                    const found = _.find( identifiers, ident => ident.name === identifierName );
                    if( found ) {
                        ngModule.name = found.value;
                    }
                } else {
                    ngModule.name = callNode.arguments[ 0 ].value;
                }
                ngModule.type = callee.property.name;
                if( ngModule.type === 'service' || ngModule.type === 'factory' ) {
                    ngModule.appServiceType = callee.property.name;
                    ngModule.hasInit = false;
                }
                ngModule.type = ngModule.type === 'factory' ? 'service' : ngModule.type;
                ngModule.exported = false;

                // findReturnExports( callNode, fileInfo );

                /*
                if( callee.property.name === 'directive' ) {
                    ngModule.name += 'Directive';
                }
                */

                // handle pattern -- app.controller( 'myNgService', [ 'otherNgService',  function(){} )
                // handle pattern -- app.directive( 'myNgService', [ 'otherNgService',  function(){} )
                // handle pattern -- app.factory( 'myNgService', [ 'otherNgService',  function(){} )
                // handle pattern -- app.service( 'myNgService', [ 'otherNgService',  function(){} )
                if( callNode.arguments[ 1 ].type === 'ArrayExpression' ) {
                    let hasFunctionExpression = false;
                    for( const element of callNode.arguments[ 1 ].elements ) {
                        switch ( element.type ) {
                            case 'Literal':
                                ngModule.deps.push( element.value );
                                break;
                            case 'Identifier':
                                // if( /service|factory/.test( callee.property.name ) ) {
                                ngModule.deps.push( element.name );
                                // }
                                break;
                            case 'FunctionExpression':
                                if( /(service|factory)/.test( callee.property.name ) ) {
                                    hasFunctionExpression = true;
                                    ngModule.hasInit = guessHasInit( element );
                                } else if( /directive/.test( callee.property.name ) ) {
                                    // do nothing
                                    Object.assign( ngModule, getDirectiveFeature( contents, element ) );
                                }
                                break;
                        }
                    }

                    if( !hasFunctionExpression ) {
                        ngModule.deps.pop();
                    }
                } else if( callNode.arguments[ 1 ].type === 'FunctionExpression' ) {
                    if( /(service|factory)/.test( callee.property.name ) ) {
                        ngModule.hasInit = guessHasInit( callNode.arguments[ 1 ] );
                    } else if( /directive/.test( callee.property.name ) ) {
                        // do nothing
                        Object.assign( ngModule, getDirectiveFeature( contents, callNode.arguments[ 1 ] ) );
                    }
                } else if( callNode.arguments[ 1 ].type === 'Identifier' ) {
                    // fileInfo.returnExportsFound = true;
                }
                if( ngModule.name ) {
                    res.push( ngModule );
                }
            }
        },
        ExportDefaultDeclaration: exportDefultNode => {
            if( exportDefultNode.declaration.properties || exportDefultNode.declaration.right ) {
                // Audit for DECL View  Model in ES6 Module
                let exportAstProps = exportDefultNode.declaration.properties ||
                    exportDefultNode.declaration.right && exportDefultNode.declaration.right.properties || [];
                _.forEach( exportAstProps, function( prop ) {
                    if( !fileInfo.publishedJsMethods ) {
                        fileInfo.publishedJsMethods = [];
                    }
                    fileInfo.publishedJsMethods.push( prop.key.name );
                } );
            } else if( exportDefultNode.declaration.body && exportDefultNode.declaration.body.type === 'ClassBody' &&
                exportDefultNode.declaration.body.body ) {
                // Audit for DECL View Model in ES6 Class
                _.forEach( exportDefultNode.declaration.body.body, ( prop ) => {
                    if( !prop.static && prop.type === 'MethodDefinition' && prop.kind === 'method' ) {
                        if( !fileInfo.publishedJsMethods ) {
                            fileInfo.publishedJsMethods = [];
                        }
                        fileInfo.publishedJsMethods.push( prop.key.name );
                    }
                } );
            }
        }
    }, {
        ...walk.base,
        JSXElement: () => {},
        JSXFragment: () => {}
    } );

    // If only one ngModule, and we have the export default setup, assume it has been coverted to module
    if( res.length === 1 && fileInfo.publishedJsMethods.length > 0 && !new RegExp( es5ServiceRegistrationRegex ).test( file.contents.toString() ) ) {
        res[ 0 ].exported = true;
    } else if( new RegExp( es6ServiceRegistartionRegex ).test( file.contents.toString() ) ) {
        //If we are using new arrow pattern for service registration mean all modules are exported.
        res.forEach( ( m ) => {
            m.exported = true;
        } );
    }

    return res;
}

const getModuleName = function( file ) {
    // Extract the actual @module name
    let contents = file.contents.toString();
    let moduleName;
    const ndx = contents.search( /@module / );
    if( ndx > -1 ) {
        let atModuleName = contents.substring( ndx + 8 );
        atModuleName = atModuleName.substring( 0, atModuleName.search( /[\n\r]/ ) );
        moduleName = atModuleName.replace( /["']/g, '' );
    }
    return moduleName;
};

/**
 * Has class
 *
 * @argument {Object} file file object
 * @returns {boolean} has class
 */
function hasClass( file ) {
    let hasClass = file.contents.toString().includes( 'export default class' );
    let moduleName = getModuleName( file );

    //let's check services wrapper
    if( !hasClass ) {
        //check ng services abstraction
        _.forEach( ngClassBasedServices, ( value, key ) => {
            if( moduleName.includes( value ) ) {
                hasClass = true;
            }
        } );
    }
    return hasClass;
}
/**
 * Convert AMD java script file contents to ES6 contents.
 *
 * @argument {Object} file file object
 */
function analyzeFile( file ) {
    if( file.path.match( /js[\/|\\]\S*\.js$/i ) ) {
        const filePath = util.normalizePath( file.path );
        if( filePath.includes( '/test/' ) || filePath.includes( '/repo/' ) || filePath.includes( '/build/' ) || filePath.includes( '/repoDev/' ) ) {
            // Do nothing. We don't worry about mutations done in test files
        } else if ( assessComponents ) {
            const contents = file.contents.toString();
            let relativePath = getRelativePathFromSourcePath( file );
            const splitFromSrcJs = relativePath.split( '/src/js' );
            const prefix = splitFromSrcJs.length === 1 ? relativePath.split( '/src' )[ 0 ] : splitFromSrcJs[ 0 ];
            const moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';
            if( !result.allStats[ moduleJsonName ] ) {
                result.allStats[ moduleJsonName ] = {};
            }
            let loc = !result.allStats[ moduleJsonName ].totalJsLoc ? 0 : result.allStats[ moduleJsonName ].totalJsLoc;
            let jsFileLoc = contents.match( /\n/g ) ? contents.match( /\n/g ).length : 1;
            result.allStats[ moduleJsonName ].totalJsLoc = loc += jsFileLoc;
            let functionsList = getFileFunctionMapping( file, contents, relativePath, moduleJsonName ? moduleJsonName : 'NA' );
            Array.prototype.push.apply( result.functions, functionsList );

            const splitViewMFileName = filePath.split( /\//g );
            const componentName = splitViewMFileName[ splitViewMFileName.length - 1 ].replace( '.js', '' );

            if( contents.includes( '.directive(' ) ) {
                const directiveObject = {
                    'Module Name': moduleJsonName ? moduleJsonName : 'NA',
                    File: relativePath,
                    'Has JSX': 'No',
                    'Component Name': componentName,
                    Category: 'Directive'
                };
                result.allComponents.push( directiveObject );
            }

            // Remove the if check if we want numbers for directive and controllers
            if( !filePath.includes( 'directive' ) && !filePath.includes( 'controller' ) ) {
                const angAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                let totalCount = 0;
                for( const angularToken of angularismTokens ) {
                    const tokenCount = contents.split( angularToken ).length - 1;
                    totalCount += tokenCount;
                    angAnalysisObject[ angularToken ] = tokenCount;
                }
                if( totalCount > 0 ) {
                    angAnalysisObject[ 'Total Count' ] = totalCount;
                    result.angularism.push( angAnalysisObject );
                }

                const domManipObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                totalCount = 0;
                for( const domManipToken of domManipTokens ) {
                    const tokenCount = contents.split( domManipToken ).length - 1;
                    totalCount += tokenCount;
                    domManipObject[ domManipToken ] = tokenCount;
                }
                if( totalCount > 0 ) {
                    domManipObject[ 'Total Count' ] = totalCount;
                    result.dommanipu.push( domManipObject );
                }

                const ctxInstances = contents.match( /(ctx.)[.a-z,A-Z,0-9,_, ]+=[.a-z,A-Z,0-9,_, ]+/gi );
                if( ctxInstances && ctxInstances.length > 0 ) {
                    result.ctxmutations.push( { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, 'Mutation Frequency': ctxInstances.length } );
                }

                // Processing for awPanel.navigate
                const cSubPanelCount = contents.split( 'awPanel.navigate' ).length - 1;
                if( cSubPanelCount > 0 ) {
                    const cSubPanelObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Keyword: 'awPanel.navigate', Count: cSubPanelCount };
                    result.commandSubPanels.push( cSubPanelObject );
                }

                // Calculate other component dependency list
                let otherCompDeps = contents.split( 'from viewmodel/' );
                const otherCompDepList = [];
                if( otherCompDeps.length - 1 > 0 ) {
                    otherCompDeps.splice( 0, 1 );
                    for( const otherCompKey in otherCompDeps ) {
                        otherCompDepList.push( otherCompDeps[ otherCompKey ].split( '\';' )[ 0 ] );
                    }
                }

                let name = file.path.match( /(\/|\\)([^\\\/]*)\.js$/i )[ 2 ];
                // Add to the JS stats only if it doesn't exist. If there are multiple services with the same name,
                // capture the one with highest dependency (Ideally it should never go in else block)
                if( !result.jsStats[ name ] ||
                    otherCompDepList.length > result.jsStats[ name ].otherCompDepList.length ) {
                    result.jsStats[ name ] = { jsFileLoc, otherCompDepList };
                }
            }
        }

        let moduleName = getModuleName( file );
        if( !moduleName ) {
            if ( verbose ) {
                // logger.error( `${file.path} file doesn't have @module definition and will not be considered for sourceInspect` );
            }
            return;
        }
        let ngModules = getNgModuleDefs( file );
        let containsClassDef = hasClass( file );
        let ngServiceName = getOOTBNgServiceName( file );
        if( ngModules.length > 0 ) {
            ngModules.forEach( ( m ) => {
                m.hasClass = containsClassDef;
                result[ m.type ].push( m );
            } );
        } else {
            let name = file.path.match( /(\/|\\)([^\\\/]*)\.js$/i )[ 2 ];
            result.module.push( {
                name: name,
                path: getRelativePath( file ),
                hasClass: containsClassDef,
                OOTBNgServiceName: ngServiceName,
                moduleName: moduleName
            } );
        }
    } else if( file.path.match( /test[\/|\\]\S*Test\.js$/i ) ) {
        result.test.push( getUnitTestDefs( file ) );
    } else if( file.path.match( /viewmodel[\/|\\]\S*\.json$/i ) ) {
        // result.jsonCount++;
        const filePath = util.normalizePath( file.path );
        if ( filePath.includes( '/test/' ) || filePath.includes( '/repo/' ) || filePath.includes( '/build/' ) || filePath.includes( '/repoDev/' ) ) {
            // Do nothing. We don't worry about mutations done in test files
        } else {
            let name = file.path.match( /(\/|\\)([^\\\/]*)\.json$/i )[ 2 ];
            result.viewModel.push( {
                name: name,
                path: getRelativePath( file )
            } );
            if ( assessComponents ) {
                const relativePath = getRelativePathFromSourcePath( file );
                const splitFromSrcJs = relativePath.split( '/src/viewmodel' );
                const prefix = splitFromSrcJs.length === 1 ? relativePath.split( '/src' )[ 0 ] : splitFromSrcJs[ 0 ];
                const moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';
                const jsonContent = JSON.parse( file.contents );
                let allJsDeps = new Set();
                if( jsonContent.actions ) {
                    allJsDeps = populateViewModelJSFuncDetails( file, jsonContent );
                    populateCommandsWithCommandPanel( jsonContent.actions );
                }
                if( jsonContent.dataProviders ) {
                    for( const dpKey in jsonContent.dataProviders ) {
                        if( jsonContent.dataProviders[ dpKey ].commandsAnchor ) {
                            const cbAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                            cbAnalysisObject.Anchor = jsonContent.dataProviders[ dpKey ].commandsAnchor;
                            result.allCommandBars.push( cbAnalysisObject );
                        }
                    }
                }
                // Processing for awPanel.navigate
                const cSubPanelCount = file.contents.toString().split( 'awPanel.navigate' ).length - 1;
                if( cSubPanelCount > 0 ) {
                    const cSubPanelObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Keyword: 'awPanel.navigate', Count: cSubPanelCount };
                    result.commandSubPanels.push( cSubPanelObject );
                }
                // Total JSON count
                if( !result.allStats[ moduleJsonName ] ) {
                    result.allStats[ moduleJsonName ] = {};
                }
                if( !relativePath.includes( '/i18n' ) && !relativePath.includes( 'soa/json' ) && !relativePath.includes( '/policies' ) &&
                    !relativePath.includes( '/policy' ) && !relativePath.includes( '/schema' ) ) {
                    let loc = !result.allStats[ moduleJsonName ].totalJsonLoc ? 0 : result.allStats[ moduleJsonName ].totalJsonLoc;
                    result.allStats[ moduleJsonName ].totalJsonLoc = loc += file.contents.toString().match( /\n/g ) ? file.contents.toString().match( /\n/g ).length : 1;
                }
                collectComponentDetails( moduleJsonName, relativePath, jsonContent, allJsDeps );
            }
        }
    } else if( file.path.match( /html[\/|\\]\S*\.html$/i ) && assessComponents ) {
        const filePath = util.normalizePath( file.path );
        if ( filePath.includes( '/test/' ) || filePath.includes( '/repo/' ) || filePath.includes( '/build/' ) || filePath.includes( '/repoDev/' ) ) {
            // Do nothing. We don't worry about mutations done in test files
        } else {
            const contents = file.contents.toString();
            let relativePath = getRelativePathFromSourcePath( file );
            const prefix = relativePath.split( '/src/html' )[ 0 ];
            const moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';
            if( !filePath.includes( 'directive' ) ) {
                const angAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                let totalCount = 0;
                for( const angularToken of angularismTokens ) {
                    const tokenCount = contents.split( angularToken ).length - 1;
                    totalCount += tokenCount;
                    angAnalysisObject[ angularToken ] = tokenCount;
                }
                if( totalCount > 0 ) {
                    angAnalysisObject[ 'Total Count' ] = totalCount;
                    result.angularism.push( angAnalysisObject );
                }

                const domManipObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                totalCount = 0;
                for( const domManipToken of domManipTokens ) {
                    const tokenCount = contents.split( domManipToken ).length - 1;
                    totalCount += tokenCount;
                    domManipObject[ domManipToken ] = tokenCount;
                }
                if( totalCount > 0 ) {
                    domManipObject[ 'Total Count' ] = totalCount;
                    result.dommanipu.push( domManipObject );
                }

                if( !result.allStats[ moduleJsonName ] ) {
                    result.allStats[ moduleJsonName ] = {};
                }
                if( !result.allStats[ moduleJsonName ].viewHtmls ) {
                    result.allStats[ moduleJsonName ].viewHtmls = [];
                }
                result.allStats[ moduleJsonName ].viewHtmls.push( relativePath );
            }
            // Processing for aw-xrt
            const xrtCount = contents.split( '<aw-xrt ' ).length - 1;
            if( xrtCount > 0 ) {
                const xrtAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                const xrtTokens = contents.split( '<aw-xrt ' );
                for( const xrtToken of xrtTokens ) {
                    if( xrtToken.includes( '</aw-xrt>' ) ) {
                        const xrtLine = xrtToken.split( '</aw-xrt>' )[ 0 ];
                        const xrtLineTokens = xrtLine.split( ' ' );
                        for( const xrtAttr of xrtLineTokens ) {
                            if( xrtAttr.startsWith( 'type' ) ) {
                                let xrtType = xrtAttr.split( '=' )[ 1 ];
                                xrtType = xrtType.trim();
                                xrtType = xrtType.replace( /"/g, '' );
                                xrtType = xrtType.replace( /'/g, '' );
                                xrtAnalysisObject.Type = xrtType;
                            }
                        }
                    }
                }
                xrtAnalysisObject.Count = xrtCount;
                result.awXrt.push( xrtAnalysisObject );
            }
            // Processing for aw-add
            const awAddCount = contents.split( '<aw-add ' ).length - 1;
            if( awAddCount > 0 ) {
                const awAddAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                awAddAnalysisObject.Count = awAddCount;
                result.awAdd.push( awAddAnalysisObject );
            }
            // Processing for aw-command-bar
            const commandBarCount = contents.split( '<aw-command-bar ' ).length - 1;
            if( commandBarCount > 0 ) {
                const cbTokens = contents.split( '<aw-command-bar ' );
                for( const cbToken of cbTokens ) {
                    if( cbToken.includes( '</aw-command-bar>' ) ) {
                        const cbAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                        const cbLine = cbToken.split( '></aw-command-bar>' )[ 0 ];
                        const cbLineTokens = cbLine.split( ' ' );
                        for( const cbAttr of cbLineTokens ) {
                            if( cbAttr.startsWith( 'anchor' ) ) {
                                let cbAnchor = cbAttr.split( '=' )[ 1 ];
                                cbAnchor = cbAnchor.trim();
                                cbAnchor = cbAnchor.replace( /"/g, '' );
                                cbAnchor = cbAnchor.replace( /'/g, '' );
                                cbAnalysisObject.Anchor = cbAnchor;
                            }
                        }
                        result.allCommandBars.push( cbAnalysisObject );
                    }
                }
            }
            // Processing for aw-toolbar
            const toolbarBarCount = contents.split( '<aw-toolbar ' ).length - 1;
            if( toolbarBarCount > 0 ) {
                const toolbarTokens = contents.split( '<aw-toolbar ' );
                for( const toolbarToken of toolbarTokens ) {
                    if( toolbarToken.includes( '</aw-toolbar>' ) ) {
                        const toolbarAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath };
                        const toolbarLine = toolbarToken.split( '></aw-toolbar>' )[ 0 ];
                        const toolbarLineTokens = toolbarLine.split( ' ' );
                        for( const toolbarAttr of toolbarLineTokens ) {
                            if( toolbarAttr.startsWith( 'first-anchor' ) || toolbarAttr.startsWith( 'second-anchor' ) ) {
                                let toolbarAnchor = toolbarAttr.split( '=' )[ 1 ];
                                toolbarAnchor = toolbarAnchor.trim();
                                toolbarAnchor = toolbarAnchor.replace( /"/g, '' );
                                toolbarAnchor = toolbarAnchor.replace( /'/g, '' );
                                toolbarAnalysisObject.Anchor = toolbarAnchor;
                            }
                        }
                        result.allCommandBars.push( toolbarAnalysisObject );
                    }
                }
            }
            // Processing for aw-navigate-breadcrumb
            let breadcrumbCount = contents.split( '<aw-navigate-breadcrumb ' ).length - 1;
            if( breadcrumbCount > 0 ) {
                const breadcrumbAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Type: 'navigate' };
                result.breadcrumbs.push( breadcrumbAnalysisObject );
            }
            // Processing for aw-navigate-breadcrumb
            breadcrumbCount = contents.split( '<aw-search-breadcrumb ' ).length - 1;
            if( breadcrumbCount > 0 ) {
                const breadcrumbAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Type: 'search' };
                result.breadcrumbs.push( breadcrumbAnalysisObject );
            }
            // Processing for aw-command-sub-panel
            const cSubPanelCount = contents.split( '<aw-command-sub-panel' ).length - 1;
            if( cSubPanelCount > 0 ) {
                const cSubPanelObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Keyword: 'aw-command-sub-panel', Count: cSubPanelCount };
                result.commandSubPanels.push( cSubPanelObject );
            }
            // Total HTML count
            if( !result.allStats[ moduleJsonName ] ) {
                result.allStats[ moduleJsonName ] = {};
            }
            let loc = !result.allStats[ moduleJsonName ].totalHtmlLoc ? 0 : result.allStats[ moduleJsonName ].totalHtmlLoc;
            result.allStats[ moduleJsonName ].totalHtmlLoc = loc += contents.match( /\n/g ) ? contents.match( /\n/g ).length : 1;

            if( relativePath.endsWith( 'View.html' ) ) {
                const tagList = contents.match( /<.+?>/gs );
                if( tagList ) {
                    const otherComponentDeps = new Set();
                    const splitPath = relativePath.split( /\//g );
                    const htmlName = splitPath[ splitPath.length - 1 ].replace( 'View.html', '' );
                    for( const eachTag of tagList ) {
                        if( !eachTag.startsWith( '<!' ) && !eachTag.startsWith( '</' ) &&
                            !eachTag.startsWith( '<%' ) && !eachTag.startsWith( '<=' ) ) {
                            const splitTag = eachTag.split( /\s|\n/g );
                            let actTag = splitTag[ 0 ].replace( /<|>|\//g, '' );
                            if( actTag && !allHtmlTags.includes( actTag ) ) {
                                if( actTag === 'aw-include' ) {
                                    let depViewName = '';
                                    for( const attr of splitTag ) {
                                        if( attr.startsWith( 'name' ) ) {
                                            depViewName = attr.replace( /name|=|\s|\'|\"|<|>|\//g, '' );
                                        }
                                    }
                                    if( !depViewName && verbose ) {
                                        logger.error( `No name found for included component - ${relativePath}` );
                                    }
                                    actTag = actTag + '::' + depViewName;
                                }
                                otherComponentDeps.add( actTag );
                            }
                        }
                    }
                    result.htmlStats[ htmlName ] = { otherComponentDeps: Array.from( otherComponentDeps ) };
                } else if ( verbose ) {
                    logger.error( `HTML file doesn't have any tag in ${relativePath}` );
                }
            }
        }
    } else if( file.path.match( /src[\/|\\]\S*\.json$/i ) && assessComponents ) {
        const jsonContent = JSON.parse( file.contents );
        let allJsDeps = new Set();
        if( jsonContent.actions ) {
            allJsDeps = populateViewModelJSFuncDetails( file, jsonContent );
            populateCommandsWithCommandPanel( jsonContent.actions );
        }
        const relativePath = getRelativePathFromSourcePath( file );
        let prefix;
        let moduleJsonName;

        if( file.path.includes( 'commandsViewModel' ) ) {
            // Populate command placement to commands list
            for( const placementKey in jsonContent.commandPlacements ) {
                const placement = jsonContent.commandPlacements[ placementKey ];
                if( !commandAnalysisMap.commandPlacementToCommandsList[ placement.uiAnchor ] ) {
                    commandAnalysisMap.commandPlacementToCommandsList[ placement.uiAnchor ] = new Set();
                }
                commandAnalysisMap.commandPlacementToCommandsList[ placement.uiAnchor ].add( placement.id );
            }

            // For each command handler, check each condition and create command id to list (or rather set) of
            // commands map
            for( const handlerKey in jsonContent.commandHandlers ) {
                const handler = jsonContent.commandHandlers[ handlerKey ];
                let conditionList = [];
                if( handler.visibleWhen && handler.visibleWhen.condition ) {
                    conditionList = conditionList.concat( parseCondition( handler.visibleWhen.condition ) );
                }
                if( handler.activeWhen && handler.activeWhen.condition ) {
                    conditionList = conditionList.concat( parseCondition( handler.activeWhen.condition ) );
                }
                if( handler.enableWhen && handler.enableWhen.condition ) {
                    conditionList = conditionList.concat( parseCondition( handler.enableWhen.condition ) );
                }
                if( conditionList.length ) {
                    if( !commandAnalysisMap.commandConditionsMap[ handler.id ] ) {
                        commandAnalysisMap.commandConditionsMap[ handler.id ] = new Set();
                    }
                    conditionList.forEach( condition => commandAnalysisMap.commandConditionsMap[ handler.id ].add( condition ) );
                }
            }

            // For each condition, check if
            //  1) Condition has 'visibleServerCommands', then put it in server conditions list
            //  2) Condition has sub conditions, put it in 'conditions with sub conditions' map
            for( const conditionKey in jsonContent.conditions ) {
                const condition = jsonContent.conditions[ conditionKey ];
                const strCondition = JSON.stringify( condition );
                if( strCondition.includes( 'visibleServerCommands' ) ) {
                    commandAnalysisMap.serverConditions.add( conditionKey );
                } else if( strCondition.includes( 'conditions.' ) ) {
                    const conditionList = parseCondition( strCondition );
                    if( conditionList.length ) {
                        commandAnalysisMap.conditionsWithSubConditions[ conditionKey ] = conditionList;
                    }
                }
            }

            prefix = relativePath.split( '/commandsViewModel.json' )[ 0 ];
            moduleJsonName = pathToModuleJSONMapping[ prefix ];
            // if( !result.commandsList[moduleJsonName] ) {
            //     result.commandsList[moduleJsonName] = [];
            // }
            // result.commandsList[moduleJsonName] = result.commandsList[moduleJsonName].concat( Object.keys(jsonContent.commands) );
            result.allCommandsList = result.allCommandsList.concat( Object.keys( jsonContent.commands || {} ) );

            // Processing for awPanel.navigate
            const cSubPanelCount = file.contents.toString().split( 'awPanel.navigate' ).length - 1;
            if( cSubPanelCount > 0 ) {
                const cSubPanelObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Keyword: 'awPanel.navigate', Count: cSubPanelCount };
                result.commandSubPanels.push( cSubPanelObject );
            }
        } else if( file.path.includes( 'states.json' ) ) {
            prefix = relativePath.split( '/states.json' )[ 0 ];
            moduleJsonName = pathToModuleJSONMapping[ prefix ];
            const cfxViews = [ 'commonLocation', 'CommonLocation', 'tcLocation', 'CommonRoot', 'AppComponent', 'AwGatewayLocation', 'AwShowObjectLocation' ];
            const cfxControllers = [ 'NativeSubLocationCtrl', 'BaseSubLocationCtrl' ];
            const cfxTemplates = [ '/html/aw.native.sublocation.html', '/html/aw-xrteditor-xrtEditor.directive.html',
                '/html/aw-hostView.directive.html', '/html/aw.error.sublocation.html'
            ];

            for( const stateJsonEntry in jsonContent ) {
                const stateObject = jsonContent[ stateJsonEntry ];

                // Populate user readable type
                let userReadableType = stateObject.type ? stateObject.type.charAt( 0 ).toUpperCase() + stateObject.type.slice( 1 ) : '';
                userReadableType = userReadableType === 'SubLocation' ? 'Sub Location' : userReadableType;
                userReadableType = !stateObject.type && stateObject.url ? 'Sub Location' : userReadableType;
                userReadableType = !stateObject.type && !stateObject.url ? 'Custom' : userReadableType;
                userReadableType = stateObject.type === 'parameter' ? 'Sub Location' : userReadableType;
                userReadableType = !stateObject.type && !stateObject.url && cfxViews.includes( stateObject.view ) ? 'Location' : userReadableType;

                // Populate category
                let category = '';
                if( stateObject.view && !cfxViews.includes( stateObject.view ) ||
                    stateObject.templateUrl && !cfxTemplates.includes( stateObject.templateUrl ) ) {
                    category += 'Custom View';
                } else {
                    category += 'Fx View';
                }
                if( userReadableType !== 'Location' ) {
                    if( !stateObject.controller || cfxControllers.includes( stateObject.controller ) ) {
                        category += ' + Fx Controller';
                    } else {
                        category += ' + Custom Controller';
                    }
                }

                // Populate based on
                let basedOn = userReadableType === 'Location' ? 'NA' : 'Search';
                if( stateObject.params ) {
                    for( const paramKey in stateObject.params ) {
                        if( paramKey.includes( 'uid' ) ) {
                            basedOn = 'Show Object';
                            break;
                        }
                    }
                }

                const printObject = {
                    'Module Name': moduleJsonName ? moduleJsonName : 'NA',
                    File: relativePath,
                    'State Name': stateJsonEntry,
                    Type: userReadableType,
                    Category: category,
                    'Based On': basedOn,
                    Parent: stateObject.parent,
                    URL: stateObject.url,
                    Controller: stateObject.controller,
                    'Template URL': stateObject.templateUrl,
                    View: stateObject.view,
                    'Internal Type': stateObject.type
                };
                result.stateJsonEntries.push( printObject );
                if( stateObject.view && userReadableType !== 'Custom' ) {
                    result.locSubLocStats[ stateObject.view ] = userReadableType;
                }

                // Populate breadcrumb config
                if( stateObject.data && stateObject.data.breadcrumbConfig ) {
                    const breadcrumbAnalysisObject = { 'Module Name': moduleJsonName ? moduleJsonName : 'NA', File: relativePath, Type: stateObject.data.breadcrumbConfig.type };
                    result.breadcrumbs.push( breadcrumbAnalysisObject );
                }
            }
        }

        const filePath = util.normalizePath( file.path );
        if( filePath.includes( '/test' ) || filePath.includes( '/repo' ) || filePath.includes( '/build' ) || filePath.includes( '/repoDev' ) ) {
            // Do nothing. We don't need any stats
        } else {
            if( !moduleJsonName ) {
                let tokens = relativePath.split( /\// );
                if( tokens.length > 1 ) {
                    tokens.pop();
                }
                prefix = tokens.join( '/' );
                moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';
            }
            // Total JSON count
            if( !result.allStats[ moduleJsonName ] ) {
                result.allStats[ moduleJsonName ] = {};
            }
            const contents = file.contents.toString();
            if( !relativePath.includes( '/i18n' ) && !relativePath.includes( 'soa/json' ) && !relativePath.includes( '/policies' ) &&
                !relativePath.includes( '/policy' ) && !relativePath.includes( '/schema' ) ) {
                let loc = !result.allStats[ moduleJsonName ].totalJsonLoc ? 0 : result.allStats[ moduleJsonName ].totalJsonLoc;
                result.allStats[ moduleJsonName ].totalJsonLoc = loc += contents.match( /\n/g ) ? contents.match( /\n/g ).length : 1;

                if( !relativePath.includes( 'commandsViewModel' ) && relativePath.includes( 'ViewModel' ) ) {
                    collectComponentDetails( moduleJsonName, relativePath, jsonContent, allJsDeps );
                }
            }
        }
    } else if( file.path.match( /src[\/|\\]\S*\.scss$/i ) && assessComponents ) {
        const filePath = util.normalizePath( file.path );
        if( filePath.includes( '/test' ) || filePath.includes( '/repo' ) || filePath.includes( '/build' ) || filePath.includes( '/repoDev' ) ) {
            // Do nothing. We don't need any stats
        } else {
            let relativePath = getRelativePathFromSourcePath( file );
            const prefix = relativePath.split( '/src' )[ 0 ];
            const moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';

            // Total CSS count
            if( !result.allStats[ moduleJsonName ] ) {
                result.allStats[ moduleJsonName ] = {};
            }
            const contents = file.contents.toString();
            let loc = !result.allStats[ moduleJsonName ].totalCssLoc ? 0 : result.allStats[ moduleJsonName ].totalCssLoc;
            result.allStats[ moduleJsonName ].totalCssLoc = loc += contents.match( /\n/g ) ? contents.match( /\n/g ).length : 1;
        }
    }
}

/**
 * Parse condition
 * @param {Object} condition string
 * @returns {Array} result as string array ( line per object )
 */
function parseCondition( condition ) {
    const conditionList = [];
    if( typeof condition === 'string' ) {
        const strTokens = condition.split( /[:,!\"\'\s\(\)]/g );
        for( const token of strTokens ) {
            if( token.includes( 'conditions.' ) ) {
                conditionList.push( token.replace( 'conditions.', '' ) );
            }
        }
    } else if ( verbose ) {
        logger.error( 'Non string command condition - ' + condition );
    }
    return conditionList;
}

/**
 * Populate all server conditions
 */
function populateAllServerConditions() {
    let totalFound = 0;
    for( const conditionKey in commandAnalysisMap.conditionsWithSubConditions ) {
        const conditionList = commandAnalysisMap.conditionsWithSubConditions[ conditionKey ];
        const hasServerCondition = conditionList.reduce( ( isServerCondition, condition ) =>
            isServerCondition === true ? isServerCondition : commandAnalysisMap.serverConditions.has( condition ), false );
        if( hasServerCondition === true ) {
            delete commandAnalysisMap.conditionsWithSubConditions[ conditionKey ];
            commandAnalysisMap.serverConditions.add( conditionKey );
            totalFound++;
        }
    }
    if( totalFound !== 0 ) {
        populateAllServerConditions();
    }
}

/**
 * Find intersection between two sets
 * @param {Object} setA Set 1
 * @param {Object} setB Set 2
 * @returns {Object} A set containing intersection
 */
function intersection( setA, setB ) {
    let _intersection = new Set();
    for( let elem of setB ) {
        if( setA.has( elem ) ) {
            _intersection.add( elem );
        }
    }
    return _intersection;
}

/**
 * Find command anchors with server conditions
 * @returns {Object} An array contianing command bar anchors
 */
function getCommandAnchorsWithServerConditions() {
    populateAllServerConditions();
    const commandsWithServerConditions = new Set();
    const commandBarAnchors = [];
    const commandBarAnchorsWithServerConditions = {};
    for( const commandId in commandAnalysisMap.commandConditionsMap ) {
        const intersectionSet = intersection( commandAnalysisMap.serverConditions,
            commandAnalysisMap.commandConditionsMap[ commandId ] );
        if( intersectionSet.size ) {
            commandsWithServerConditions.add( commandId );
        }
    }
    for( const placementUiAnchor in commandAnalysisMap.commandPlacementToCommandsList ) {
        const intersectionSet = intersection( commandsWithServerConditions, commandAnalysisMap.commandPlacementToCommandsList[ placementUiAnchor ] );
        if( intersectionSet.size ) {
            commandBarAnchors.push( {
                'UI Anchor': placementUiAnchor,
                'Commands With Server Condition': JSON.stringify( Array.from( intersectionSet ) )
            } );
            commandBarAnchorsWithServerConditions[ placementUiAnchor ] = intersectionSet;
        }
    }
    for( const commandBarObj of result.allCommandBars ) {
        if( Object.keys( commandBarAnchorsWithServerConditions ).includes( commandBarObj.Anchor ) ) {
            commandBarObj[ 'Commands With Server Condition' ] = JSON.stringify( Array.from( commandBarAnchorsWithServerConditions[ commandBarObj.Anchor ] ) );
            result.commandBarsWithServerConditions.push( commandBarObj );
        }
    }

    return commandBarAnchors;
}

/**
 * print indent as prefix
 * @param {Number} level the level of indent ( 2 space per level )
 * @returns {String} prefix as string
 */
function printIndent( level ) {
    let res = '';
    for( let i = 0; i < level; i++ ) {
        res += '  ';
    }
    return res;
}

let refs = {};

/**
 * print service dependency tree as string
 * @param {Object} ngModule ngModule object
 * @param {Number} serviceMap Service map
 * @param {Number} level the level of indent
 * @returns {Array} result as string array ( line per object )
 */
function printTree( ngModule, serviceMap, level = 0 ) {
    let res = [];

    let subLevel = 0;

    let m = serviceMap[ ngModule.name ];
    if( level === 0 ) {
        m.refCount = ( m.refCount ? m.refCount : 0 ) + ( refs[ ngModule.name ] ? refs[ ngModule.name ] : 0 );
    }

    res.push( printIndent( level ) + ngModule.name + ( level === 0 ? '(' + m.refCount + ')' : '' ) );

    _.forEach( ngModule.deps, ( str ) => {
        let subM = serviceMap[ str ];
        if( subM ) {
            let subRes = printTree( subM, serviceMap, level + 1 );
            subLevel = subLevel > subM.level + 1 ? subLevel : subM.level + 1;
            res = res.concat( subRes );
        } else {
            result.external[ str ] = result.external[ str ] ? result.external[ str ] : {};
            result.external[ str ][ ngModule.name ] = true;
        }
    } );

    m.level = subLevel;
    return res;
}

/**
 * Generate service list to a CSV
 * @param {Array} serviceArray service description as array
 * @returns {Array} header string array
 */
function generateCsvHeader( serviceArray ) {
    return Object.keys( _.reduce( serviceArray, ( res, o ) => {
        return Object.assign( res, o );
    }, {} ) );
}

/**
 * Generate service list to a CSV
 * @param {Array} serviceArray service description as array
 * @returns {string} file contents
 */
function generateCsvTable( serviceArray ) {
    if( serviceArray && serviceArray.length > 0 ) {
        let res = [];
        res.push( 'sep=|' );
        let headers = generateCsvHeader( serviceArray );
        res.push( headers.join( '|' ) );
        return res.concat( _.map( serviceArray, ( o ) => {
            // return _.values( o ).join( '|' );
            return _.map( headers, ( h ) => {
                return o[ h ];
            } ).join( '|' );
        } ) ).join( '\n' );
    }
    return '';
}

/**
 * post process analysis result
 * @param {Object} result analysis result
 * @param {Object} destPath destination path
 */
function postProcess( result, destPath ) {
    // Record ref count
    _.forEach( result.service, ( m ) => {
        _.forEach( m.deps, ( str ) => {
            refs[ str ] = refs[ str ] ? refs[ str ] + 1 : 1;
        } );
    } );

    // Process dependency tree
    let serviceMap = {};
    _.forEach( result.service, ( m ) => {
        serviceMap[ m.name ] = m;
    } );

    _.forEach( result.constant, ( m ) => {
        serviceMap[ m.name ] = m;
    } );

    let serviceDepTrees = [];
    _.forEach( result.service, ( m ) => {
        serviceDepTrees.push( printTree( m, serviceMap ) );
    } );

    serviceDepTrees = _.map( serviceDepTrees.sort( ( a, b ) => a.length - b.length ), ( t ) => {
        return t.join( '\n' );
    } );

    // Sort service after refCount and level is ready
    result.service = result.service.sort( ( a, b ) => a.level - b.level || a.refCount - b.refCount );

    // Generate summary
    result.summary = {
        directive: _.size( result.directive ),
        controller: _.size( result.controller ),
        service: _.size( result.service ),
        module: _.size( result.module ),
        constant: _.size( result.constant ),
        external: _.size( result.external ),
        viewModel: _.size( result.viewModel ),
        test: _.reduce( result.test, function( sum, obj ) {
            return sum + _.size( obj );
        }, 0 )
    };

    // Collect angular services
    // TODO: move this logic to template generation code later
    let angularServices = {};
    let structuresToLoop = [ 'service' ];
    let defaultServiceNameMapping = { $q: 'Promise' };
    _.forEach( result, ( artifactTypeObj ) => {
        _.forEach( artifactTypeObj, ( actualArtifactObj ) => {
            if( actualArtifactObj.deps ) {
                for( var individualDep of actualArtifactObj.deps ) {
                    if( individualDep.startsWith( '$' ) && ![ '$scope', '$controller' ].includes( individualDep ) && !angularServices[ individualDep ] ) {
                        let individualDepSvcName = defaultServiceNameMapping[ individualDep ];
                        if( individualDepSvcName === undefined ) {
                            individualDepSvcName = individualDep.replace( '$', '' );
                            individualDepSvcName = individualDepSvcName.replace( '$', '' );
                            individualDepSvcName = individualDepSvcName.charAt( 0 ).toUpperCase() + individualDepSvcName.substring( 1 );
                        }
                        angularServices[ individualDep ] = individualDepSvcName;
                    }
                }
            }
        } );
    } );

    if ( !assessComponents ) {
        fs.writeFile( destPath + '/serviceDeps.txt', serviceDepTrees.join( '\n\n' ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/sourceInspect.json', JSON.stringify( result ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/angularServices.json', JSON.stringify( angularServices ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/services.csv', generateCsvTable( result.service ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/directives.csv', generateCsvTable( result.directive ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );
    } else {
        fs.writeFile( destPath + '/AllDataMutationsInFunctions.csv', generateCsvTable( result.functions ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/AngularJSReferences.csv', generateCsvTable( result.angularism ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/DirectDOMManipulations.csv', generateCsvTable( result.dommanipu ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/DirectCtxAssignments.csv', generateCsvTable( result.ctxmutations ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        const jsIntersection = [];
        for( const jsDep in jsFunctionsMap ) {
            const jsonJsDep = jsonDepsMap[ jsDep ];
            if( jsonJsDep ) {
                for( const jsFunc in jsFunctionsMap[ jsDep ] ) {
                    const jsObj = jsFunctionsMap[ jsDep ][ jsFunc ];
                    const jsonList = jsonJsDep[ jsFunc ];
                    if( jsonList && jsonList.length ) {
                        jsIntersection.push( { ...jsObj, 'JSON Count': jsonList.length, 'JSON List': jsonList.join() } );
                    }
                }
            }
        }

        fs.writeFile( destPath + '/DataMutationsFromJSON.csv', generateCsvTable( jsIntersection ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/AwXRT.csv', generateCsvTable( result.awXrt ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/AwAdd.csv', generateCsvTable( result.awAdd ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        const commandBarAnchors = getCommandAnchorsWithServerConditions();

        fs.writeFile( destPath + '/CommandBarAnchorsWithServerConditions.csv', generateCsvTable( commandBarAnchors ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/CommandBarAnchorsWithServerConditionsAndUsage.csv', generateCsvTable( result.commandBarsWithServerConditions ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/StateJson.csv', generateCsvTable( result.stateJsonEntries ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        const viewHtmlSummary = [];
        for( const moduleJsonName in result.allStats ) {
            if( result.allStats[ moduleJsonName ].viewHtmls ) {
                for( const viewRelPah of result.allStats[ moduleJsonName ].viewHtmls ) {
                    if( !result.allStats[ moduleJsonName ].commandPanels ) {
                        result.allStats[ moduleJsonName ].commandPanels = [];
                    }
                    if( !result.allStats[ moduleJsonName ].commandsWithView ) {
                        result.allStats[ moduleJsonName ].commandsWithView = [];
                    }
                    const tokens = viewRelPah.split( /\// );
                    const commandId = tokens[ tokens.length - 1 ].replace( 'View.html', '' );
                    if( result.commandsWithCommandPanel.has( commandId ) ) {
                        result.allStats[ moduleJsonName ].commandPanels.push( viewRelPah );
                    }
                    if( result.allCommandsList.includes( commandId ) ) {
                        result.allStats[ moduleJsonName ].commandsWithView.push( viewRelPah );
                    }
                }
            } else {
                result.allStats[ moduleJsonName ].viewHtmls = [];
                result.allStats[ moduleJsonName ].commandPanels = [];
                result.allStats[ moduleJsonName ].commandsWithView = [];
            }
            viewHtmlSummary.push( {
                'Module Name': moduleJsonName ? moduleJsonName : 'NA',
                'View Files Count': result.allStats[ moduleJsonName ].viewHtmls.length,
                'Command Panels Count': result.allStats[ moduleJsonName ].commandPanels.length,
                'JS Line Count': result.allStats[ moduleJsonName ].totalJsLoc || 0,
                'JSON Line Count': result.allStats[ moduleJsonName ].totalJsonLoc || 0,
                'HTML Line Count': result.allStats[ moduleJsonName ].totalHtmlLoc || 0,
                'CSS Line Count': result.allStats[ moduleJsonName ].totalCssLoc || 0,
                'View Files': JSON.stringify( result.allStats[ moduleJsonName ].viewHtmls ),
                'Command Panel Files': JSON.stringify( result.allStats[ moduleJsonName ].commandPanels ),
                'Commands With View Count': result.allStats[ moduleJsonName ].commandsWithView.length,
                'Command With View Files': JSON.stringify( result.allStats[ moduleJsonName ].commandsWithView )
            } );
        }

        fs.writeFile( destPath + '/ModuleComplexity.csv', generateCsvTable( viewHtmlSummary ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/Breadcrumbs.csv', generateCsvTable( result.breadcrumbs ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        fs.writeFile( destPath + '/CommandSubPanels.csv', generateCsvTable( result.commandSubPanels ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        for( const component of result.allComponents ) {
            if( component.Category !== 'Directive' ) {
                // Get the stats for all other dependent components
                let otherComponentDeps = [];

                const splitViewMFileName = component.File.split( /\//g );
                const componentName = splitViewMFileName[ splitViewMFileName.length - 1 ].replace( 'ViewModel.json', '' );
                component[ 'Component Name' ] = componentName;

                // Populate component category
                let compCategory = component.Category;
                if( result.commandsWithCommandPanel.has( componentName ) ||
                    result.allCommandsList.includes( componentName ) ) {
                    compCategory = 'Command Panel';
                } else if( result.locSubLocStats[ componentName ] ) {
                    compCategory = result.locSubLocStats[ componentName ];
                } else if( component[ 'Has JSX' ] === 'No' ) {
                    compCategory = 'Organizational';
                }

                if( !compCategory ) {
                    compCategory = 'Re-usable Component';
                }
                component.Category = compCategory;

                if( component.renderDep ) {
                    otherComponentDeps = result.jsStats[ component.renderDep ].otherCompDepList.map( comp => comp.replace( 'ViewModel', '' ) );
                } else {
                    if( result.htmlStats[ componentName ] ) {
                        const kebabCaseToPascalCase = name =>
                            name.replace( /^./, name[ 0 ].toUpperCase() ).replace( /-(.)/g, ( fullMatch, firstMatch ) => firstMatch.toUpperCase() );

                        otherComponentDeps = result.htmlStats[ componentName ].otherComponentDeps.map( comp => kebabCaseToPascalCase( comp.toLowerCase() ) );
                    }
                }
                delete component.renderDep;
                component[ 'Other Component Deps Count' ] = otherComponentDeps.length;
                component[ 'Other Component Deps' ] = otherComponentDeps.join( ',' );

                // Get the stats for first level services
                let locs = 0;
                const deps = component[ 'First level Service Dependencies' ];
                for( const dep of deps ) {
                    if( dep ) {
                        const splitDep = dep.split( /\//g );
                        const jsStat = result.jsStats[ splitDep[ splitDep.length - 1 ] ];
                        if( jsStat ) {
                            locs += jsStat.jsFileLoc;
                        } else if ( verbose && !depsNotFound[dep] ) {
                            logger.error( `Dependent service ${dep} not found` );
                            depsNotFound[dep] = true;
                        }
                    }
                }
                component[ 'First level Service LOC' ] = locs;
                component[ 'First level Service Dependencies' ] = deps.join( ',' );
            }
        }

        fs.writeFile( destPath + '/ComponentTracker.csv', generateCsvTable( result.allComponents ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );

        for( const apiRow of result.apiUsage ) {
            let providerModule = result.serviceModuleMap[ apiRow[ 'Provider Service' ] ];
            if( !providerModule && apiRow[ 'Provider Service' ].match( /(graph)/gi ) ) {
                providerModule = 'afx-graph';
            }
            apiRow[ 'Provider Module' ] = providerModule;
        }
        for( const jsServiceName in jsonDepsMap ) {
            const jsMethodMap = jsonDepsMap[ jsServiceName ];
            for( const jsMethodName in jsMethodMap ) {
                const jsUsageArray = jsMethodMap[ jsMethodName ];
                const jsUsageMap = jsUsageArray.reduce( ( freqMap, fileName ) => {
                    freqMap[fileName] = freqMap[fileName] ? freqMap[fileName] + 1 : 1;
                    return freqMap;
                }, {} );

                for( const jsUsage in jsUsageMap ) {
                    if( !jsUsage.includes( '/test/viewmodel' ) ) {
                        const splitFromSrcJs = jsUsage.split( '/src/viewmodel' );
                        const prefix = splitFromSrcJs.length === 1 ? jsUsage.split( /(\/)\w+(.json)/ )[ 0 ] : splitFromSrcJs[ 0 ];
                        const moduleJsonName = pathToModuleJSONMapping[ prefix ] ? pathToModuleJSONMapping[ prefix ] : 'NA';

                        let providerModule = result.serviceModuleMap[ jsServiceName ];
                        if( !providerModule && jsServiceName.match( /(graph)/gi ) ) {
                            providerModule = 'afx-graph';
                        }

                        result.apiUsage.push( {
                            'Consuming Module': moduleJsonName,
                            'Consuming File': jsUsage,
                            'Provider Service': jsServiceName,
                            'Provider API': jsMethodName,
                            'Provider Module': providerModule,
                            'Call Count': jsUsageMap[ jsUsage ]
                        } );
                    }
                }
            }
        }
        fs.writeFile( destPath + '/ExportedApiUsage.csv', generateCsvTable( result.apiUsage ), function( err ) {
            if( err && verbose ) {
                logger.error( err );
            }
        } );
    }
}

/**
 * Convert AMD js to ES6 JS
 *
 * @param {Object} argv input options (--sourcePath)
 */
async function main( argv ) {
    verbose = argv.verbose;
    assessComponents = argv.assessComponents;
    const filePath = argv.sourcePath;
    if( !filePath ) {
        var errorMsg = `Pass sourcePath option to script, see following example you can pass single file relative path or multiple glob paths by comma separated.
         Example: node ./build/js/sourceInspect.js --sourcePath %AWC_STAGE_DIR%/src/**/*,%SOME_OTHER_DIR%/src/**/* --destPath D:/code_stats/sourceInspect/`;
        throw new Error( errorMsg );
    }

    // setup result structure
    let refFile = argv.extRef;
    if( refFile && fs.existsSync( refFile ) ) {
        let output = fs.readFileSync( refFile );
        result = JSON.parse( output );
    }

    const sourcepaths = [];
    const moduleJsonPaths = [];
    const modulePaths = filePath.split( ',' );
    for( var modulePath in modulePaths ) {
        modulePath = modulePaths[ modulePath ].trim();
        if ( assessComponents ) {
            const modulePathLen = modulePath.length - '**/*'.length;
            sourcePathLen[ modulePath.substring( 0, modulePathLen ) ] = modulePathLen;
            moduleJsonPaths.push( modulePath + '/**/module.json' );
        }
        sourcepaths.push( modulePath );
    }

    if ( assessComponents ) {
        gulp.src( moduleJsonPaths, { allowEmpty: true } )
            .pipe( util.tapBlock( file => {
                const moduleContent = JSON.parse( file.contents );
                let relativePath = getRelativePathFromSourcePath( file );
                relativePath = relativePath.replace( '/module.json', '' );
                pathToModuleJSONMapping[ relativePath ] = moduleContent.name;
            } ) );
    }

    const gulpSrc = gulp.src( sourcepaths, { base: './' } )
        .pipe( util.tapBlock( file => {
            analyzeFile( file );
        } ) );

    await util.stream2Promise( gulpSrc );

    postProcess( result, argv.destPath ? argv.destPath : '.' );
}
if( require.main === module ) {
    const argv = require( 'yargs' )
        .demandCommand( 0 )
        .usage( 'Usage: node $0 [options]' )
        .example( 'node $0 --sourcePath %AWC_STAGE_DIR%/src/**/*,%SOME_OTHER_DIR%/src/**/* --destPath D:/code_stats/sourceInspect/' )
        .options( {
            verbose: {
                description: 'Flag to show and print error messages',
                alias: 'v',
                type: 'boolean',
                demand: false,
                default: false
            },
            assessComponents: {
                description: 'Flag to analyze source code to highlight impact of removing angularJS dependencies and help with componentization',
                type: 'boolean',
                demand: false,
                default: false
            },
            sourcePath: {
                description: 'Relative source path/glob path of code to files to analyze. Can provide multiple paths separated by commas.',
                alias: 'src',
                demand: true
            },
            destPath: {
                description: 'Relative destination path to save output',
                alias: 'dst',
                demand: true
            }
        } )
        .help()
        .argv;
    main( argv ).catch( logger.error );
}
module.exports = main;
