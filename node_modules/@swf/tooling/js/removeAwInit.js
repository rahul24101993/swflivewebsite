const yargs = require('yargs');
const gulp = require( 'gulp' );
const util = require('./util');
const tap = require('gulp-tap');
const logger = require( './logger' );
const chmod  = require('gulp-chmod');

let viewFileEmpty = [];
let viewModelIsEmpty = [];
let viewModelConverted = [];
let multipleAwInitInFile = [];

let getComponentName = ( filePath ) => {
    let splittedString = filePath.split('\\');
    return splittedString[ splittedString.length - 1 ].replace( 'ViewModel.json', '' );
};

let getDirectiveName = ( filePath ) => {
    let splittedString = filePath.split('\\');
    return splittedString[ splittedString.length - 1 ].replace( 'View.html', '' );
}

let printFileInfo = ( fileNames, msg ) => {
    fileNames.length ? logger.error( `${msg} [${fileNames.length}]`, '', true ) : null;
    fileNames.forEach( ( fileName ) => {
        logger.info( fileName, '', true );
    } );
}

let logSummary = ( viewNameAndComponentMap ) => {
    printFileInfo( viewFileEmpty, 'Following view files are empty' );
    printFileInfo( viewModelIsEmpty, 'Following view model files are' );
    printFileInfo( multipleAwInitInFile, 'Following files have multiple aw-init instances' );
    let viewModelNamesAbsent = [];
    let mapIterator = viewNameAndComponentMap.keys();
    while( !mapIterator.next().done ) {
        viewModelNamesAbsent.push( mapIterator.next().value );
    }
    printFileInfo( viewModelNamesAbsent, 'Following view files have no view models associated' )
    logger.info( `${viewModelConverted.length} files are converted`, '', true );
    viewModelConverted.forEach( ( fileName ) => {
        logger.info( fileName, '', true );
    } );
};

let removeAwInitInstance = ( fileContents ) => {
    return fileContents.replace( /(aw-init(\s)*=(\s)*"(.*?)"(\s)*)/g, '' )
};

let checkoutFilesIfProcessingAW = () => {
    return new Promise( ( resolve, reject ) => {
        if( argv.awc ) {
            util.spawn( 'jt.cmd', [ 'co', 'src/.../*ViewModel.json' ] )
            .then(
                util.spawn( 'jt.cmd', [ 'co', 'src/.../*View.html' ] ) 
                .then( () => { resolve(); } )
                .catch( ( e ) => {
                    logger.error( e );
                    reject();
                } )
            )
            .catch( ( e ) => {
                logger.error( e );
                reject();
            } );
        } else {
            resolve();
        }
    } );
};

let getVMNamesHavingAwInitAndRemoveIt = ( path ) => {
    let viewNameAndComponentMap = new Map();
    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( `${path}/**/*View.html` )
            .pipe(
                tap( file => {
                    try{
                        let comopnentName = getDirectiveName( file.path );
                        let contents = ( file.contents ).toString( 'utf8' );
                        if( contents.length ) {
                            // match aw-init="data.activeNow='*'"
                            let awInitExp = contents.match( /(aw-init(\s)*=(\s)*"data.activeView=(.*?)")/g );
                            if( awInitExp && awInitExp.length === 1 ) {
                                awInitExp.forEach( ( eachExp ) => {
                                    //retrive view name used with aw-init
                                    let viewNameForAwInit = eachExp.replace( /(aw-init(\s)*=)/g, '' );
                                    viewNameForAwInit = viewNameForAwInit.slice(1,viewNameForAwInit.length - 2);
                                    viewNameForAwInit = viewNameForAwInit.replace( /(data.activeView=')/g, '' );
                                    viewNameAndComponentMap.set( comopnentName, viewNameForAwInit );
                                    contents = removeAwInitInstance( contents );
                                } );
                                if( argv._.includes( 'run' ) ) {
                                    file.contents = Buffer.from( contents );
                                }
                            }
                            else if ( awInitExp && awInitExp.length > 1 ) {
                                multipleAwInitInFile.push( file.path );
                            }
                        } else {
                            viewFileEmpty.push( comopnentName );
                        }
                    } catch( e ) {
                        logger.error( e );
                        logger.info( file.path );
                    }
                } )    
            ).pipe( gulp.dest( path ) )
        ).then( () => {
            resolve( viewNameAndComponentMap );
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit(1);
        } )
    } );
}

let putActiveViewInViewModel = ( path, viewNameAndComponentMap ) => {
    let filesPath = `${path}/**/*ViewModel.json`
    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( filesPath, { base: './', ignore: [`${path}/node_modules/**/*`] } )
            .pipe(
                tap( file => {
                    try{
                        let fileName = getComponentName( file.path );
                        let viewModelUpdateRequired = false;
                        if( viewNameAndComponentMap.has( fileName ) ) {
                            let fileContents = ( file.contents ).toString( 'utf8' );
                            if( fileContents.length ) {
                                let fileContentsObject = JSON.parse( fileContents );
                                fileContentsObject.hasOwnProperty( 'data' ) ? null : fileContentsObject[ 'data' ] = {};
                                let dataSection = fileContentsObject.data;
                                if( !dataSection.hasOwnProperty( 'activeView' ) ) {
                                    dataSection[ 'activeView' ] = viewNameAndComponentMap.get( fileName );
                                    viewModelUpdateRequired === false ? viewModelUpdateRequired = true : null;
                                }
                                if( viewModelUpdateRequired && argv._.includes( 'run' ) ) {
                                    let modifiedContents = JSON.stringify( fileContentsObject, null, 4 );
                                    file.contents = Buffer.from( modifiedContents );
                                } 
                                viewModelConverted.push( fileName );
                            } else {
                                viewModelIsEmpty.push( fileName );
                            }
                            viewNameAndComponentMap.delete( fileName );
                        }
                    } catch( e ) {
                        logger.error( e );
                        process.exit(1);
                    }
                } ) 
            ).pipe( chmod( 0o777 ) )
            .pipe( gulp.dest( '.' ) )
        ).then( () => {
            resolve();
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit(1);
        } ); 
    } );
};

let removeAwInitAndConvertVM = async ( pathOfProject ) => {
    const stopwatch = new logger.Stopwatch();
    await checkoutFilesIfProcessingAW();
    let viewNameAndComponentMap = await getVMNamesHavingAwInitAndRemoveIt( pathOfProject );
    await putActiveViewInViewModel( pathOfProject ,viewNameAndComponentMap );
    logSummary( viewNameAndComponentMap );
    logger.verbose( `Conversion is complete ${stopwatch.end()}` );
};

const argv = yargs
    .command( 'run' ,'Put props section in view model files of the specified module', {} )
    .command( 'dryRun','List all files which will be updated', {} )
    .options( {
        codePath: {
            alias: 'p',
            description: 'Dir path of project',
            demandOption: true,
            type: 'string'
        },
        awc: {
            alias: 'a',
            description: 'Specify if processing AW client code',
            type: 'boolean'
        }
    } )
    .help()
    .demandCommand( 1, 'Please provide either run or dryRun command' )
    .alias( 'help', 'h')
    .argv;

( async () => {
    removeAwInitAndConvertVM( argv.codePath );
} )();