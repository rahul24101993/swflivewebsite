/* eslint-env node */
const gulp = require( 'gulp' );
const tap = require( 'gulp-tap' );
const { stream2Promise } = require( './util' );
const logger = require( './logger' );
gulp.task( 'testReport', () => {
    return new Promise( async ( resolve, reject ) => {
        try {
            const parse = require( 'lcov-parse' );
            const stream = gulp.src( `${process.cwd()}/coverage/lcov.info`, { allowEmpty: true } )
                .pipe( tap( file => {
                    // trace( 'testReport', file.path );
                    const contents = file.contents.toString();
                    if( contents ) {
                        parse( file.contents.toString(), ( err, data ) => {
                            if( err ) {
                                // trace( 'testReport', file.path, err, data );
                                return reject( err );
                            }
                            const lineInfo = data.map( x => {
                                return x;
                            } ).reduce( ( a, b ) => {
                                return a.concat( b );
                            }, [] ).map( x => {
                                return x.lines;
                            } );

                            const lineHitCount = lineInfo.map( x => {
                                return x.hit;
                            } ).reduce( ( a, b ) => {
                                return a + b;
                            }, 0 );

                            const lineFoundCount = lineInfo.map( x => {
                                return x.found;
                            } ).reduce( ( a, b ) => {
                                return a + b;
                            }, 0 );

                            logger.info( `Lines hit: ${lineHitCount}` );
                            logger.info( `Lines found: ${lineFoundCount}` );
                            logger.info( `Code coverage: ${( lineHitCount / lineFoundCount * 100 ).toFixed( 2 )}%` );
                            return resolve();
                        } );
                    } else {
                        logger.error( `${file.path} is empty!` );
                        return resolve();
                    }
                } ) );
            await stream2Promise( stream );
        } catch ( err ) {
            logger.pipeErrorHandler( err );
            return reject( err );
        }
    } );
} );
