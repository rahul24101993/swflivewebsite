const yargs = require('yargs');
const gulp = require( 'gulp' );
const { pascalCaseToKebabCase, kebabCaseToPascalCase } = require('../rewired/utils');
const util = require('./util');
const tap = require('gulp-tap');
const logger = require( './logger' );
const chmod  = require('gulp-chmod');

let ngFilesNotPresent = [];
let noScopeObjectInNgFile = [];
let ngFileEmpty = [];
let reactViewModelIsEmpty = [];
let reactViewModelConverted = [];

let convertFileNamesToKebabCase = ( fileNames ) => {
    fileNames = fileNames.map( fileName => pascalCaseToKebabCase ( fileName.replace( 'ViewModel.json', '' ) ) );
    return fileNames;
};

let getComponentName = ( filePath ) => {
    let splittedString = filePath.split('\\');
    return splittedString[ splittedString.length - 1 ].replace( 'ViewModel.json', '' );
};

let getDirectiveName = ( filePath ) => {
    let splittedString = filePath.split('\\');
    return splittedString[ splittedString.length - 1 ].replace( '.directive.js', '' );
}

let printFileInfo = ( fileNames, msg ) => {
    fileNames.length ? logger.error( `${msg} [${fileNames.length}]`, '', true ) : null;
    fileNames.forEach( ( fileName ) => {
        logger.info( fileName, '', true );
    } );
}

let logSummary = ( noOfReactVMToProcess, noOfReactVMConverted ) => {
    console.log( "*********Summary*********" );

    printFileInfo( ngFilesNotPresent, 'Following directives were not found in ng code' );
    printFileInfo( ngFileEmpty, 'Following directives are empty in ng code' );
    printFileInfo( noScopeObjectInNgFile, 'Following directives have no "scope" object declared' );
    printFileInfo( reactViewModelIsEmpty, 'Following viewmodels are empty in React code');

    let directivesNotFound =    noOfReactVMToProcess.filter( vmName => !noOfReactVMConverted.includes( vmName ) )
                                                    .filter( vmName => !reactViewModelIsEmpty.includes( vmName ) )
                                                    .filter( vmName => !ngFileEmpty.includes( pascalCaseToKebabCase( vmName ) ) ) 
                                                    .filter( vmName => !noScopeObjectInNgFile.includes( pascalCaseToKebabCase( vmName ) ) );

    printFileInfo( directivesNotFound, 'Following components Either do not need to be coverted Or were not found in ng code' );
    printFileInfo( noOfReactVMConverted, 'Following components were converted' );

    console.log('\n');
    console.log(`# components processed : ${noOfReactVMToProcess.length}`);
    console.log(`# components converted : ${noOfReactVMConverted.length}`);
    console.log('\n');
    console.log( "*************************" );
};

let removeComments = ( scopeObjectString ) => {
    return scopeObjectString.replace(/\/\/[^\n\r]+/g, '');
};

let convertToJSON = ( scopeObjectString ) => {
    scopeObjectString = removeComments( scopeObjectString );
    let result =  scopeObjectString.match( /[a-zA-Z]+/g );
    result.forEach( ( val ) => {    
        scopeObjectString = scopeObjectString.replace( val, `"${val}"` );
    } );
    scopeObjectString = scopeObjectString.replace( /'/g, '"' );
    return scopeObjectString;
};

let checkoutVMIfProcessingAW = () => {
    return new Promise( ( resolve, reject ) => {
        if( argv.awc ) {
            util.spawn( 'jt.cmd', [ 'co', '*ViewModel.json' ] )
            .then( () => { resolve(); } )
            .catch( ( e ) => {
                logger.error( e );
                reject();
            } )
        } else {
            resolve();
        }
    } );
};

let getVMNamesInsideReactCode = ( path, moduleName ) => {
    let vmInsideModule = [];
    let filesPath = moduleName ? `${path}/**/${moduleName}/**/*ViewModel.json` : `${path}/**/*ViewModel.json`
    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( filesPath, { base: './', ignore: [`${path}/node_modules/**/*`] } )
            .pipe(
                tap( file => {
                    try{
                        let componentName = getComponentName( file.path ); 
                        vmInsideModule.push( componentName ); 
                    } catch( e ) {
                        logger.error( e );
                        logger.info( file.path );
                    }
                } ) 
            ).pipe( gulp.dest( '.' ) ) 
        ).then( () => {
            resolve( vmInsideModule )
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit(1);
        } ); 
    } ); 
};

let getScopeObjectFromNGCode = ( path, fileNames ) => {
    let propsInFiles = {};
    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( `${path}/**/*.directive.js`, { ignore: [`${path}/node_modules/**/*`] } )
            .pipe(
                tap( file => {
                    try{
                        let directiveName = getDirectiveName( file.path );
                        if( fileNames.includes( directiveName ) ) {
                            let contents = ( file.contents ).toString( 'utf8' );
                            if( contents.length ) {
                                // match scope:{*} OR scope :{*} OR scope : {*}
                                let regEx = new RegExp( /(scope(\s)*:(\s)*{(.*?)})/, 's' );
                                let fileNameInCamelCase = kebabCaseToPascalCase( directiveName );
                                if( regEx.test( contents ) ) {
                                    let scopeObjectMatches = regEx.exec( contents );
                                    // remove 'scope:' from the matched string
                                    let scopeObjectInString = scopeObjectMatches[0].replace( /(scope(\s)*:(\s)*)/g, '' )
                                    let scopeObject = convertToJSON( scopeObjectInString );
                                    propsInFiles[ fileNameInCamelCase ] = JSON.parse( scopeObject );
                                } else {
                                    noScopeObjectInNgFile.push( directiveName );
                                }
                            } else {
                                ngFileEmpty.push( directiveName );
                            }
                        }
                    } catch( e ) {
                        logger.error( e );
                        logger.info( file.path );
                    }
                } )    
            ).pipe( gulp.dest( path ) )
        ).then( () => {
            resolve( propsInFiles );
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit(1);
        } )
    } );
}

let putPropsInViewModel = ( path, moduleName, vmNameAndScopeMap ) => {
    let filesPath = moduleName ? `${path}/**/${moduleName}/**/*ViewModel.json` : `${path}/**/*ViewModel.json`
    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( filesPath, { base: './', ignore: [`${path}/node_modules/**/*`] } )
            .pipe(
                tap( file => {
                    try{
                        let fileName =  getComponentName( file.path );
                        let viewModelUpdateRequired = false;
                        if( vmNameAndScopeMap.hasOwnProperty( fileName ) ) {
                            let fileContents = ( file.contents ).toString( 'utf8' );
                            if( fileContents.length ) {
                                let fileContentsObject = JSON.parse( fileContents );
                                fileContentsObject.hasOwnProperty( 'props' ) ? null : fileContentsObject[ 'props' ] = {};
                                let propsSection = fileContentsObject.props;
                                for( let [ attibute, type ] of Object.entries( vmNameAndScopeMap[ fileName ] ) ) {
                                    let prop = pascalCaseToKebabCase( attibute );
                                    if( !propsSection.hasOwnProperty( prop ) ) {
                                        propsSection[ prop ] = { 
                                            ['type']: 'object'
                                        };
                                        viewModelUpdateRequired === false ? viewModelUpdateRequired = true : null;
                                    }
                                }
                                if( viewModelUpdateRequired && argv._.includes( 'run' ) ) {
                                    let modifiedContents = JSON.stringify( fileContentsObject, null, 4 );
                                    file.contents = Buffer.from( modifiedContents );
                                } 
                                reactViewModelConverted.push( fileName );
                            } else {
                                reactViewModelIsEmpty.push( fileName );
                            }
                        }
                    } catch( e ) {
                        logger.error( e );
                        process.exit(1);
                    }
                } ) 
            ).pipe( chmod( 0o777 ) )
            .pipe( gulp.dest( '.' ) )
        ).then( () => {
            resolve( reactViewModelConverted );
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit(1);
        } ); 
    } );
};

let getScopeObjectAndPutPropsInVM = async ( moduleName, srcPathOfOldProject, destPathOfNewProject ) => {
    const stopwatch = new logger.Stopwatch();
    await checkoutVMIfProcessingAW();
    let vmNamesToBeProcessed = await getVMNamesInsideReactCode( destPathOfNewProject, moduleName );
    let vmNamesInKebabCase = convertFileNamesToKebabCase( vmNamesToBeProcessed );
    let vmNameAndScopeMap = await getScopeObjectFromNGCode( srcPathOfOldProject, vmNamesInKebabCase );
    let reactViewModelConverted = await putPropsInViewModel( destPathOfNewProject ,moduleName, vmNameAndScopeMap );
    logSummary( vmNamesToBeProcessed, reactViewModelConverted );
    logger.verbose( `Conversion is complete ${stopwatch.end()}` );
};

const argv = yargs
    .command( 'run' ,'Put props section in view model files of the specified module', {} )
    .command( 'dryRun','List all files which will be updated', {} )
    .options( {
        ngCode: {
            alias: 'n',
            description: 'Dir path of angular project',
            demandOption: true,
            type: 'string'
        },
        reactCode: {
            alias: 'r',
            description: 'Dir path of react project',
            demandOption: true,
            type: 'string'
        },
        modulename: {
            alias: 'm',
            description: 'Name of the module to be processed in the current directory',
            type: 'string' 
        },
        awc: {
            alias: 'a',
            description: 'Specify if processing AW client code',
            type: 'boolean'
        }
    } )
    .help()
    .demandCommand( 1, 'Please provide either run or dryRun command' )
    .alias( 'help', 'h')
    .argv;

( async () => {
    getScopeObjectAndPutPropsInVM( argv.modulename, argv.ngCode, argv.reactCode );
} )();