/* eslint-disable require-jsdoc */
/* eslint-disable no-multi-assign */
/* eslint-disable no-implicit-globals */

const _ = require( 'lodash' );
const { access, appendFileSync, constants, ensureDir, ensureDirSync, ensureSymlink, existsSync, outputFile, pathExists, readFile, readdir, readdirSync, remove, writeFileSync, writeJson } = require(
    'fs-extra' );
const gulp = require( 'gulp' );
const { basename, extname, dirname, sep } = require( 'path' );
const through = require( 'through2' );
const svgr = require( '@svgr/core' ).default;

const logger = require( './logger' );

/**
 * The API returns first level empty sub directories of an directory.
 * @param {String} dirPath - The Path of directory which needs to be scanned
 * @return {Array} Array of empty sub directories.
 */
module.exports.getFirstLevelEmptySubDirs = function getFirstLevelEmptySubDirs( dirPath ) {
    const firstLevelDirs = readdirSync( dirPath, { withFileTypes: true } ).filter( dirent => dirent.isDirectory() ).map( dirent => dirent.name );
    let emptyDirArray = [];
    firstLevelDirs.forEach( dirName => {
        const files = readdirSync( dirPath + '/' + dirName );
        if( !files.length ) {
            emptyDirArray.push( dirPath + '/' + dirName );
        }
    } );
    return emptyDirArray;
};

/**
 * simple no-operation for gulp
 * @return {Stream} stream
 */
module.exports.noop = function() {
    // just pass-through anything
    return through.obj();
};

/**
 * Tap the stream but wait until all files are transformed before ending the stream.
 *
 * Since gulp-tap ends the stream prematurely if there's not something else in the stream, we need our own.
 *
 * @param {Function} func - function to be called per transform
 * @return {Stream} stream
 */
module.exports.tapBlock = func => {
    const files = [];
    const stream = through.obj( transform, flush );
    return stream;

    /**
     * This method is called for each file in the stream.
     *
     * @param {Object} file - file
     * @param {*} ignore - ignored
     * @param {Function} cbTransform - transform callback function
     */
    function transform( file, ignore, cbTransform ) {
        func( file );
        files.push( file );
        cbTransform();
    }

    /**
     * This method is called after all files have been passed to the transform function.
     *
     * @param {Function} cb - callback function
     */
    function flush( cb ) {
        for( const file of files ) { stream.push( file ); }
        stream.emit( 'end' );
        cb();
    }
};

const traceDel = logger.createTrace( __filename, ':del' );

/**
 * Wrapper to file system delete to support trace logging.
 *
 * @param {String|Array} patterns - patterns to delete
 * @param {Object} options - options
 * @returns {Array} deleted files
 */
module.exports.del = async function del() {
    const patterns = arguments[ 0 ];
    let options = {
        force: true
    };
    if( arguments.length > 1 && _.isObject( arguments[ 1 ] ) ) {
        module.exports.merge( options, arguments[ 1 ] );
    }
    const cwd = options.hasOwnProperty( 'cwd' ) ? options.cwd : process.cwd();

    traceDel( 'Deleting', cwd, options, patterns );

    return require( 'del' ).apply( this, [ patterns, options ] );
};

const traceWriteFile = logger.createTrace( __filename, ':writeFile' );

/**
 * Asynchronous file write.
 *
 * @param {String} fileName - file to write
 * @param {String} content - file content
 */
module.exports.writeFile = async function( fileName, content ) {
    await mkdir( dirname( fileName ) );
    traceWriteFile( 'Writing', fileName );
    await outputFile( fileName, content );
};

/**
 * Asynchronous file write.
 *
 * https: //github.com/jprichardson/node-fs-extra/blob/master/docs/writeJson.md
 *
 * @param {String} fileName - file to write
 * @param {String} content - file content
 * @param {Object|null} options - options
 */
module.exports.writeJson = async function( fileName, content, options ) {
    await mkdir( dirname( fileName ) );
    traceWriteFile( 'Writing', fileName );
    await writeJson( fileName, content, options );
};

/**
 * Asynchronous file read.
 *
 * @param {String} path - file to read
 * @param {Object|String} options - read options
 * @return {String} file content or null if not read
 */
module.exports.readFile = async function( path, options ) {
    if( await pathExists( path ) ) {
        return readFile( path, options || 'utf-8' );
    }
};

const traceWriteFileSync = logger.createTrace( __filename, ':writeFileSync' );

/**
 * Synchronous file write. Use writeFile (Asynchronous) whenever possible.
 *
 * @param {String} fileName - file to write
 * @param {String} content - file content
 */
module.exports.writeFileSync = function( fileName, content ) {
    const parentDir = dirname( fileName );
    mkdir( parentDir, true );
    traceWriteFileSync( 'Writing', fileName );
    writeFileSync( fileName, content );
};

/**
 * Replace all instances of a given string within a larger string.
 *
 * @param {String} input - input string to replace content
 * @param {String} toFind - string to locate
 * @param {String} toReplace - string to replace
 * @return {String} modified string
 */
const replaceAll = module.exports.replaceAll = function( input, toFind, toReplace ) {
    let output = input;
    if( output.indexOf( toFind ) > -1 ) {
        output = output.split( toFind ).join( toReplace );
    }
    return output;
};

/**
 * Normalize the path by using forward slashes instead of back slashes.
 *
 * @param {String} inputPath - input file path
 * @return {String} normalized file path
 */
const normalizePath = module.exports.normalizePath = function( inputPath ) {
    return replaceAll( inputPath, sep, '/' );
};

/**
 * Replace all environment variables within the file path & normalize it.
 *
 * @param {String} filePath - input file  Can be multiple paths in the same string.
 * @return {String} file path with all environment variables replaced
 */
module.exports.replaceEnvVar = function replaceEnvVar( filePath ) {
    if( filePath && filePath.constructor === Array ) {
        filePath.forEach( ( filePathLp, ii ) => {
            filePath[ ii ] = replaceEnvVar( filePathLp );
        } );
        return filePath;
    }
    if( filePath ) {
        filePath = normalizePath( filePath );
        const pathComponents = filePath.split( '/' );
        const supportedEnvVars = [
            'COMMONS_LOGGING_HOME',
            'GSON_HOME',
            'GWT_HOME',
            'HAMCREST_HOME',
            'JAVA_HOME',
            'ROOT'
        ];
        pathComponents.forEach( ( pathComponent, ii ) => {
            if( supportedEnvVars.includes( pathComponent ) ) {
                pathComponents[ ii ] = process.env[ pathComponent ];
            }
        } );

        return normalizePath( pathComponents.join( '/' ) );
    }
    logger.error( 'Empty filePath provided!' );
    return null;
};

/**
 * Replaces the path parameters with environment variables where applicable.
 *
 * @param {String} filePath - the path to shorten
 * @return {String} shorten file path
 */
const shortenPath = module.exports.shortenPath = function( filePath ) {
    if( !filePath ) {
        logger.error( 'Empty filePath provided!' );
        return null;
    }

    filePath = replaceAll( normalizePath( filePath ), normalizePath( process.cwd() ) + '/', '' );

    // TODO Linux support - Is the max path on linux also 8191?
    // TODO Not sure what we should do in case of command line too long. Just post an error for now.
    if( filePath.length > 8191 ) {
        logger.error( 'Command line arguments too long. Need to shorten path to UDU unit.' );
    }

    return filePath;
};

/**
 * Add element if it doesn't already exist in the array & sort array if added.
 *
 * @param {Array} array - array to conditionally add element
 * @param {Object} element - element to consider adding to array
 * @param {Boolean} noSort - disables sorting of the array
 */
module.exports.addUnique = function addUnique( array, element, noSort ) {
    if( !_.isArray( array ) ) {
        logger.error( 'Input not an array! - ' + array );
        return;
    }
    if( _.isArray( element ) ) {
        for( let elementLp of element ) {
            addUnique( array, elementLp, noSort );
        }
    } else if( !array.includes( element ) ) {
        array.push( element );
        if( !noSort ) {
            array.sort();
        }
    }
};

const traceMkDir = logger.createTrace( __filename, ':mkdir' );

/**
 * Make directory.
 *
 * @param {String} directory - directory to create
 * @param {Boolean|null} sync - execute synchronously & don't return promise
 */
const mkdir = module.exports.mkdir = async function mkdir( directory, sync ) {
    traceMkDir( 'Creating directory', directory );
    if( sync ) {
        ensureDirSync( directory );
    } else {
        await ensureDir( directory );
    }
};

/**
 * Inserts a string at indexports.
 *
 * @param {String} input - the string we're inserting into.
 * @param {String} stringToInsert - the string we're inserting.
 * @param {Number} index - the index of string that we're inserting insertString into.
 * @return {String} processed string
 */
module.exports.insertString = function( input, stringToInsert, index ) {
    return input.substr( 0, index ) + stringToInsert + input.substr( index );
};

const traceSymLink = logger.createTrace( __filename, ':symLink' );

/**
 * Create directory junction.
 *
 * @param {String} linkDir - link directory
 * @param {String} srcDir - source directory
 */
module.exports.symLink = async function symLink( linkDir, srcDir ) {
    if( await pathExists( linkDir ) ) {
        traceSymLink( 'unlinking', linkDir );
        await remove( linkDir );
    }
    logger.info( ' ... linked ' + logger.pathColor( shortenPath( srcDir ) ) + ' to ' + logger.pathColor( shortenPath( normalizePath( linkDir ) ) ) );
    await ensureSymlink( srcDir, linkDir, 'junction' );
};

const traceExecute = logger.createTrace( __filename, ':execute' );

/**
 * Wrapper around child_process to enable echoing output to console in real time.
 *
 * @param {String} name - name of function
 * @param {Function} func - function to call
 * @param {String} cmd - command string
 * @param {Array|null} args - array of argument strings
 * @param {Object|null} options - options to be passed to child_process.spawn/fork
 * @param {String|null} logFile - log file
 * @param {Function|null} filter - function called per line of output with boolean response if the line should be filtered from console output
 * @param {String|null} msgPrefix - message prefix for output; '\n' indicates no prefix
 * @return {Promise} promise w/ value of error code
 */
async function execute( name, func, cmd, args, options, logFile, filter, msgPrefix ) {
    args = args || [];
    options = options || {};
    filter = filter || function() {
        return false;
    };
    msgPrefix = msgPrefix || '  ' + name + '/' + logger.nameColor( basename( cmd ) ) + ': ';
    if( msgPrefix === '\n' ) { msgPrefix = ''; }

    return new Promise( ( resolve, reject ) => {
        if( logFile ) {
            // delete previous log file so as don't append to it
            module.exports.del( logFile ).then( () => {
                return mkdir( dirname( logFile ) );
            } );
        }

        traceExecute( cmd );
        if( args ) {
            for( let arg of args ) {
                if( /;/.test( arg ) ) {
                    for( let elem of arg.split( ';' ) ) {
                        traceExecute( '\t\t' + elem + ';' );
                    }
                } else {
                    traceExecute( '\t' + arg );
                }
            }
        }

        if( !options.hasOwnProperty( 'env' ) ) {
            options.env = process.env;
        }

        if( name === 'spawn' ) {
            options.setsid = false;
        } else if( name === 'fork' ) {
            options.silent = true; // required to support handling stdout & stderr

            if( !options.execArgv ) {
                // https://github.com/nodejs/node/issues/8495
                // This allows debugging build scripts
                options.execArgv = [];
            }
        }

        const childProcess = func( cmd, args, options );

        if( options && options.setChildProcess ) {
            options.setChildProcess( childProcess );
            delete options.setChildProcess;
        }

        let buffer = '';
        let lastLogFunc;

        const regExError = /^ERROR - .* - .* - (.*)/;

        function flushBuffer( logFunc ) {
            lastLogFunc = logFunc || lastLogFunc || logger.info;
            if( buffer ) {
                for( let line of logger.extractLines( buffer ) ) {
                    let out = lastLogFunc;

                    if( /^{.*}$/.test( line ) ) {
                        // Support formatting JSON output better
                        try {
                            const xxx = JSON.parse( line );
                            // && !logger.isSillyEnabled()
                            if( xxx.exception ) { delete xxx.exception; }
                            line = xxx.message || JSON.stringify( xxx, null, 2 ).replace( /\\\bn\b/g, '\n' );
                            switch ( xxx.level ) {
                                case 'ERROR':
                                    out = logger.error;
                                    break;
                                case 'WARN':
                                    out = logger.warn;
                                    break;
                                case 'INFO':
                                    out = logger.info;
                                    break;
                            }
                        } catch ( err ) {
                            // ignore
                        }
                    }

                    // Adjust output for special case that we can search for
                    if( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*error.*: /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.error;
                    } else if( regExError.test( line ) ) {
                        // if( !logger.isSillyEnabled() ) { line = regExError.exec( line )[ 1 ]; }
                        line = regExError.exec( line )[ 1 ];
                        out = logger.error;
                    } else if( /^(\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*warn.*|warning: ): /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.warn;
                    } else if( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*info.*: /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.info;
                    } else if( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*verbose.*: /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.verbose;
                    } else if( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*debug.*: /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.debug;
                    } else if( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] .*silly.*: /.test( line ) ) {
                        line = line.substring( line.indexOf( ': ' ) + 2 );
                        out = logger.silly;
                    }

                    // Remove any duplicate timestamps
                    line = line.replace( /\[.*[0-9][0-9]:[0-9][0-9]:[0-9][0-9].*\] /, '' ); // strip timestamps out

                    if( !filter || !filter( line ) ) {
                        out( line, msgPrefix );
                    } else {
                        traceExecute( line );
                    }
                }
                buffer = '';
            }
        }

        function stdOutError( data, logFunc ) {
            if( logFile ) {
                // always append the output to the log file
                appendFileSync( logFile, data );
            }

            // convert to a string & strip the trailing newline from the data
            buffer += data.toString();
            if( /\r?\n$/.test( buffer ) ) {
                // remove trailing newline character which is added automatically
                buffer = buffer.replace( /\r?\n$/, '' );
                flushBuffer( logFunc );
            }
        }

        childProcess.stdout.on( 'data', data => stdOutError( data, logger.info ) );

        childProcess.stderr.on( 'data', data => stdOutError( data, logger.error ) );

        // It's not clear if this is a valid/typical event for the function
        childProcess.on( 'error', err => {
            flushBuffer( logger.error ); // ideally, buffer should already be flushed
            reject( err );
        } );

        childProcess.on( 'exit', code => {
            flushBuffer(); // ideally, buffer should already be flushed

            if( code ) {
                traceExecute( 'FAILED(', code, ')', cmd );
            }
            resolve( code );
        } );
    } );
}

/**
 * Wrapper around spawn() to enable echoing output to console in real time.
 *
 * @param {String} cmd - command string
 * @param {Array|null} args - array of argument strings
 * @param {Object|null} options - options to be passed to child_process.spawn
 * @param {String|null} logFile - log file
 * @param {Function|null} filter - function called per line of output with boolean response if the line should be filtered from console output
 * @param {String|null} msgPrefix - message prefix for output
 * @return { Promise } promise w / value of error code
 */
module.exports.spawn = async function spawn( cmd, args, options, logFile, filter, msgPrefix ) {
    return execute( 'spawn', require( 'child_process' ).spawn, cmd, args, options, logFile, filter, msgPrefix );
};

/**
 * Wrapper around fork() to enable echoing output to console in real time.
 *
 * @param {String} cmd - command string
 * @param {Array|null} args - array of argument strings
 * @param {Object|null} options - options to be passed to child_process.fork
 * @param {String|null} logFile - log file
 * @param {Function|null} filter - function called per line of output with boolean response if the line should be filtered from console output
 * @param {String|null} msgPrefix - message prefix for output
 * @return { Promise } promise w / value of error code
 */
module.exports.fork = async function fork( cmd, args, options, logFile, filter, msgPrefix ) {
    return execute( 'fork', require( 'child_process' ).fork, cmd, args, options, logFile, filter, msgPrefix );
};

/**
 * Copies a file. Async.
 *
 * @param {String} src - path to the source file
 * @param {String} dest - path to the destination directory
 */
module.exports.copyFile = async function copyFile( src, dest ) {
    const chmod = require( 'gulp-chmod' );
    const changed = require( 'gulp-changed' );
    await module.exports.stream2Promise( gulp.src( src, { dot: true, follow: true } )
        .pipe( changed( dest ) )
        .pipe( chmod( 0o777 ) )
        .pipe( gulp.dest( dest ) ) );
    logger.debug( `File copy from ${logger.pathColor( src )} to ${logger.pathColor( shortenPath( dest ) )} successful.` );
};

/**
 * @param {Object} objValue - destination object
 * @param {Object} srcValue source object
 * @return {Object|undefined} modified destination object
 */
function mergeCustomizer( objValue, srcValue ) {
    if( _.isArray( objValue ) ) {
        return objValue.concat( srcValue );
    }
}

/**
 * @param {Object} obj1 object 1
 * @param {Object} obj2 object 2
 * @param {Object|null} check - optional checker object
 * @param {Number|null} depth - depth of merge
 * @type {module.exports.merge}
 */
module.exports.merge = ( obj1, obj2, check, depth ) => {
    if( !depth ) { depth = 1; }
    if( _.isNull( obj2 ) ) {
        // nothing to merge
    } else if( _.isNull( obj1 ) ) {
        logger.error( 'Null object to merge!' );
    } else if( _.isArray( obj1 ) && _.isArray( obj2 ) ) {
        for( let element of obj2 ) {
            // If there was a 'identity' test for the elements, we might be able to merge objects in the array.
            if( !obj1.includes( element ) ) {
                obj1.push( _.cloneDeep( element ) );
            }
        }
    } else if( _.isObject( obj1 ) && _.isObject( obj2 ) ) {
        if( !check ) {
            _.mergeWith( obj1, obj2, mergeCustomizer );
        } else {
            for( const [ key, field ] of Object.entries( obj2 ) ) {
                if( obj1.hasOwnProperty( key ) ) {
                    if( check ) {
                        check.path.push( key );
                        if( check.uniqueDepth !== undefined &&
                            check.uniqueDepth === depth &&
                            !check.path.includes( 'i18n' ) ) {
                            throw new Error( 'Name conflict in ' + check.file + '.json path=' + check.path.join( '.' ) + ' for module ' + check.moduleName + ' (2nd occurrence)!' );
                        }
                    }
                    module.exports.merge( obj1[ key ], field, check, depth + 1 );
                    if( check ) { check.path.pop(); }
                } else {
                    obj1[ key ] = _.cloneDeep( field );
                }
            }
        }
    } else if( _.isArray( obj1 ) || _.isArray( obj2 ) ) {
        throw new Error( 'Invalid array merge!' );
    } else if( _.isObject( obj1 ) || _.isObject( obj2 ) ) {
        throw new Error( 'Invalid object merge!' );
    }
};

/**
 * @param {Stream} stream - stream
 */
module.exports.stream2Promise = async function stream2Promise( stream ) {
    await new Promise( ( resolve, reject ) => stream.on( 'error', reject ).on( 'end', resolve ).on( 'close', resolve ) );
};

/**
 * Sort key fields of object.
 *
 * @param {Object} obj - Object to sort keys
 * @returns {Object} input object w/ sorted keys
 */
module.exports.orderKeys = function( obj ) {
    const keys = Object.keys( obj ).sort( function keyOrder( k1, k2 ) {
        return k1 < k2 ? -1 : k1 > k2 ? +1 : 0;
    } );

    const after = {};

    for( let key of keys ) {
        after[ key ] = obj[ key ];
        delete obj[ key ];
    }

    for( let key of keys ) { obj[ key ] = after[ key ]; }

    return obj;
};

module.exports.isEnvFlagEnabled = function( envVarName, defaultValue ) {
    let value = process.env[ envVarName ];
    if( value ) {
        value = String( value ).toLowerCase();
        return value === 'true';
    }
    return defaultValue;
};

/**
 * This function checks if passed file is a js file having import constructs.
 *
 * @param {*} file - the file on which Import syntax needs to be checked
 * @return {boolean} boolean
 */
module.exports.isES6ImportJS = function( file ) {
    const filePath = normalizePath( file.path );
    const isJSFile = extname( filePath ) === '.js';
    if( isJSFile ) {
        const contents = file.contents.toString();
        return contents.match( /^(import\s*\S*\s*(as|from|('|")))|^(\s*export default)/gm );
    }
    return false;
};

/**
 * This function checks if passed file is a javascript file or not.
 *
 * @param {*} file - The file needs to be checked is js or not.
 * @return {boolean} boolean
 */
module.exports.isJsFile = function( file ) {
    const filePath = normalizePath( file.path );
    return extname( filePath ) === '.js';
};

/**
 * Check the contents of a directory against a given BOM specified in JSON format:
 * {
 *     "": {
 *         "contents": [
 *             "file1.txt",
 *             "file2.cmd",
 *             "subDir1",
 *         ]
 *     },
 *     "/subDir1": {
 *         "contents": [
 *             "file3.js",
 *             "file4.xml",
 *             "subDir2"
 *         ]
 *     },
 *     "/subDir1/subDir2": {
 *        "exhaustive": false,
 *         "contents": [
 *             "file5.html",
 *             "file6.json"
 *         ]
 *     }
 * }
 * The 'contents' are assumed to be 'exhaustive', i.e. a reverse check will be done for presence of
 * any extra file or directory. If the reverse check is not desired, then use 'exhaustive': 'false'.
 *
 * @param {String} dir - the directory to check
 * @param {String} dirContentsJson - path to the json file
 */
module.exports.compareDirContents = async function( dir, dirContentsJson ) {
    const promises = [];
    const dirContents = require( dirContentsJson );
    _.forOwn( dirContents, ( rhs, path ) => {
        promises.push( new Promise( ( resolve, reject ) => {
            const masterContents = rhs.contents;
            const dirToCheck = dir + path;

            access( dirToCheck, constants.R_OK, error => {
                if( error ) {
                    const err = '    Cannot read ' + dirToCheck + '; error = ' + error.code;
                    reject( err );
                }

                readdir( dirToCheck, ( error, actualContents ) => {
                    if( error ) {
                        const err = '    Error reading ' + dirToCheck + '; error = ' + error.code;
                        reject( err );
                    }

                    for( let name of masterContents ) {
                        if( !actualContents.includes( name ) ) {
                            const err = '    "' + name + '" not found in ' + dirToCheck;
                            reject( err );
                        }
                    }

                    if( rhs.exhaustive !== false ) {
                        for( let name of actualContents ) {
                            if( !masterContents.includes( name ) ) {
                                const err = '    Extra "' + name + '" found in ' + dirToCheck;
                                reject( err );
                            }
                        }
                    }

                    resolve();
                } );
            } );
        } ) );
    } );

    await Promise.all( promises );
};

/**
 * Run a series of promises sequentially. Each function will be called with the result of the previous function.
 *
 * @param {List<Function>} funcs List of functions to bind
 * @returns {Promise} Promise resolved with list of resolves from promises
 */
module.exports.bindSequential = async funcs =>
    funcs.reduce( ( promise, func ) =>
        promise.then( r =>
            func( r.slice( -1 ) ).then( Array.prototype.concat.bind( r ) ) ),
    Promise.resolve( [] ) );

/** queue */
const _queue = {};

/**
 * @param {String} name - queue name
 */
function processQueue( name ) {
    const queue = _queue[ name ];
    if( queue && queue.length > 0 ) {
        // Find first non running entry & start it
        for( const entry of queue ) {
            if( !entry.isRunning ) {
                entry.isRunning = true;
                entry.resolve( entry.done );
                break; // we only start the first one
            }
        }
    }
}

/**
 * @param {String} name - queue name
 * @param {Number} length - queue length
 * @return {Function} callback
 */
module.exports.queue = async( name, length ) => {
    // Get the queue from the cache
    let queue = _queue[ name ];
    if( !queue ) {
        // Since the cache doesn't have a queue of this name, add it
        queue = [];
        _queue[ name ] = queue;
    }
    const entry = {
        /**
         * This is the function to be called by processQueue once the queue entry has been processed.
         */
        done: () => {
            // Remove this entry from the queue
            queue.splice( queue.indexOf( entry ), 1 );
            // Process the next availabe entry in the queue
            processQueue( name );
        }
    };
    // Add it to the queue
    queue.push( entry );
    return new Promise( resolve => {
        // store the resolve function
        entry.resolve = resolve;
        // check queue length & process if we can
        if( queue.length <= length ) {
            processQueue( name );
        }
    } );
};

/**
 * @param { String } args1 - command line arguments
 * @param { String } args2 - command line arguments (if using npm, you need to pass parameters after '--')
 * @return {String} CLI string
 */
module.exports.cliString = function( args1, args2 ) {
    if( existsSync( `${process.cwd()}/src/build/tools/gulp.CMD` ) ) {
        return `FAILED in gulp ${args1} ${args2}`;
    }
    return `FAILED in npm run build ${args1} -- ${args2}`;
};

/**
 * Method to get the line number of the specific attribute string
 *
 * @param {String} contents - the file contents
 * @param {String} attrStr - the specific attribute string
 * @param {Number} reLineNumber - line number
 */
module.exports.getLineNumber = function( contents, attrStr, reLineNumber ) {
    let lineNumber = 0;
    for( const line of logger.extractLines( contents ) ) {
        lineNumber++;
        if( line.indexOf( attrStr ) > -1 ) {
            reLineNumber = lineNumber;
        }
    }
    return reLineNumber;
};

module.exports.compileSVGToReactComponent = async function( stringSVG, filePath ) {
    const iconName = filePath.replace( /.*[\\/]([^\\/]*).svg$/, '$1' ).replace( /[^a-zA-Z0-9]/g, '$1' );
    let contents = stringSVG.toString().trim();
    contents = contents.replace( / id="(Layer_[0-9]+|Artwork)"/, '' );
    contents = replaceAll( contents, ' version="1.1"', '' );
    contents = replaceAll( contents, ' x="0px" y="0px"', '' );
    contents = replaceAll( contents, ' data-name="Layer 1"', '' );
    contents = contents.replace( / enable-background="new [0-9]+ [0-9]+ [0-9]+ [0-9]+"/g, '' );
    contents = replaceAll( contents, 'Dark_Blue_Grad', 'DRGID_' + iconName );
    contents = replaceAll( contents, 'front_', 'FID_' + iconName + '_' );
    contents = replaceAll( contents, 'Layer_', 'Layer_' + iconName + '_' );
    contents = replaceAll( contents, 'Light_Blue_Grad', 'LBGID_' + iconName );
    contents = replaceAll( contents, 'linear-gradient', 'LGID_' + iconName );
    contents = replaceAll( contents, 'paper_gradient', 'PGID_' + iconName );
    contents = replaceAll( contents, 'New_Gradient_Swatch', 'NGSID_' + iconName );
    contents = replaceAll( contents, 'SVGID_', 'SVGID_' + iconName + '_' );
    contents = replaceAll( contents, 'XMLID_', 'XMLID_' + iconName + '_' );
    const stringContent = replaceAll( contents, '\'', '\\\'' );
    try {
        let svgComp = await svgr( contents, {
            plugins: [ '@svgr/plugin-svgo', '@svgr/plugin-jsx' ],
            icon: true,
            dimensions: false,
            svgoConfig: {
                plugins: [ { 'preset-default': false }, { cleanupIDs: false }, { removeMetadata: true }, { removeEditorsNSData: true }, { removeUnusedNS: true }, { prefixIds: false } ]
            }
        }, { componentName: 'SvgComp' } );
        svgComp = svgComp.replace( /export default[\s\S]*/g, '' ).trim();
        // logger.info( svgComp );
        return `${svgComp}
        export const svgString = '${stringContent.replace( /([\r\n]+)/g, '' )}';
        export const SvgComponent = React.memo(SvgComp);
    `;
    } catch ( error ) {
        throw new Error( error.toString() );
    }
};
