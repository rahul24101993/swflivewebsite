// Copyright (c) 2021 Siemens

const { join, basename } = require( 'path' );
const logger = require( './logger' );
const { spawn, stream2Promise, tapBlock } = require( './util' );
const { existsSync } = require( 'fs-extra' );
const _ = require( 'lodash' );
const gulp = require( 'gulp' );
const xml2js = require( 'xml2js' );
const preAuditPrep = require( './preAuditPrep' );
const staticCodeAnalysis = require( './staticCodeAnalysis' );

const cmdSuffix = process.platform === 'win32' && '.cmd' || ''; // path.join( process.env.NODEJS_HOME, 'npm.cmd' );
const msgPrefix = '+ ';
const npmCmd = process.platform === 'win32' && 'npm.cmd' || 'npm'; // path.join( process.env.NODEJS_HOME, 'npm.cmd' );

const stopwatchAll = new logger.Stopwatch();

( async function() {
    const eslintArgs = [
        '--quiet',
        '--no-error-on-unmatched-pattern',
        join( process.cwd(), '*.js' ),
        // TODO need to fix eslint errors in build/public and enable
        // join( process.cwd(), 'build/**/*.js' ),
        // join( process.cwd(), 'public/**/*.js' ),
        join( process.cwd(), 'src/**/*.js' ),
        join( process.cwd(), 'test/**/*.js' ),
        join( process.cwd(), 'src/**/*ViewModel.json' ),
        join( process.cwd(), 'src/**/states.json' ),
        join( process.cwd(), 'src/**/html/*View.html' )
    ];
    for( let ndx = 2; ndx < process.argv.length; ndx++ ) {
        eslintArgs.push( process.argv[ ndx ] );
    }

    await eslintAudit( eslintArgs );

    await staticCodeAudit();

    logger.success( `Successful${stopwatchAll.end()}` );
} )().catch( err => {
    logger.error( `${JSON.stringify( err, null, 2 )}\nFailure${stopwatchAll.end()}` );
    process.exit( 1 );
} );

/**
 * Eslint Function
 *
 * @param {Array} args array of arguments
 */
async function eslintAudit( args ) {
    const stopwatchEslint = new logger.Stopwatch();
    let count = 0;
    const cwdRegEx = new RegExp( `^${process.cwd().replace( /\\/g, '\\\\' )}` );
    const eslint = join( process.cwd(), `node_modules/.bin/eslint${cmdSuffix}` );
    const code = await spawn( eslint, args, null, null, line => {
        if( cwdRegEx.test( line ) ) {
            count++;
        }
    }, msgPrefix );
    if( count > 0 ) {
        logger.info( `${count} files with issues.` );
    }
    if( code !== 0 ) {
        logger.error( `FAILED! Exit code = ${code}${stopwatchEslint.end()}` );
        process.exit( code );
    } else {
        logger.success( `Eslint Successful${stopwatchEslint.end()}` );
    }
}

/**
 * Static Code Analysis Audit
 */
async function staticCodeAudit() {
    //Load all module.json files
    const stopwatchPreAudit = new logger.Stopwatch();

    await preGulp();

    const cacheJsonPath = `${process.cwd()}/out/cache.json`;
    const cache = existsSync( cacheJsonPath ) && require( cacheJsonPath ) || {};

    //Static Code Analysis
    cache.name2moduleJson = {};
    _.forEach( cache.filePath2moduleJson, ( moduleJson ) => {
        cache.name2moduleJson[ moduleJson.name ] = moduleJson;
    } );

    cache.name2kitJson = {};
    _.forEach( cache.filePath2kitJson, ( kitJson ) => {
        cache.name2kitJson[ kitJson.name ] = kitJson;
    } );
    await preAuditPrep( cache );
    logger.success( `PreAuditPrep Successful${stopwatchPreAudit.end()}` );

    const stopwatchStaticCodeAnalysis = new logger.Stopwatch();
    _.forEach( cache.filePath2moduleJson, async( moduleJson, filePath ) => {
        if( /\/node_modules\//.test( filePath ) ||
            moduleJson.type.includes( 'repo' ) ||
            moduleJson.type.includes( 'selenium' ) ||
            moduleJson.excludeFromAuditDeps ||
            moduleJson.skipAudit ) {
            return; // continue
        }

        moduleJson.auditPromise = new Promise( resolve => { { moduleJson.auditResolve = resolve; } } );
        let srcSCA = [
            moduleJson.moduleDir + '/commandsViewModel.json',
            moduleJson.moduleDir + '/syncStrategy.json',
            moduleJson.moduleDir + '/states.json',
            moduleJson.moduleDir + '/workspace*.json',
            moduleJson.moduleDir + '/actionTemplateDefs.json',
            moduleJson.moduleDir + '/paste.json',
            moduleJson.moduleDir + '/nodeDefs.json',
            moduleJson.moduleDir + '/dragAndDrop.json',
            moduleJson.moduleDir + '/secondaryWorkareaTabs.json',
            moduleJson.moduleDir + '/decorators.json',
            moduleJson.moduleDir + '/propertyRendererTemplates.json'

        ];

        if( moduleJson.type.includes( 'java' ) ) {
            srcSCA = srcSCA.concat( [
                moduleJson.srcDir + '/**/*.java'
            ] );
        }

        if( moduleJson.srcDir ) {
            srcSCA = srcSCA.concat( [
                moduleJson.srcDir + '/*.@(css|scss)',
                moduleJson.srcDir + '/**/*.@(html|js|json|xml)'
            ] );
        }

        if( moduleJson.testDir ) {
            srcSCA.push( moduleJson.testDir + '/**/*.js' );
        }

        const srcDirPathsXsd = [];
        const srcDirPathsI18n = [];
        for( const moduleJson2 of Object.values( cache.name2moduleJson ) ) {
            if( moduleJson2.srcDir ) {
                srcDirPathsXsd.push( moduleJson2.srcDir + '/schema/**/*.xsd' );
                srcDirPathsI18n.push( moduleJson2.srcDir + '/i18n/*Messages.json' );
                srcDirPathsI18n.push( moduleJson2.srcDir + '/i18n/*Constants.json' );
            }
        }
        srcDirPathsXsd.sort();
        srcDirPathsI18n.sort();
        cache.audit.xsd = {};
        cache.audit.i18n = {};

        const i18nSCA = stream2Promise( gulp.src( srcDirPathsI18n, { allowEmpty: true } )
            .pipe( tapBlock( file => {
                if( file.contents ) {
                    const filename = basename( file.path, '.json' );
                    const contents = JSON.parse( file.contents.toString() );
                    cache.audit.i18n[ filename ] = Object.keys( contents );
                }
            } ) )
        );
        const xsdSCA = stream2Promise( gulp.src( srcDirPathsXsd, { allowEmpty: true } )
            .pipe( tapBlock( file => {
                if( file.contents ) {
                    const filename = basename( file.path, '.xsd' );
                    const parser = new xml2js.Parser();
                    parser.parseString( file.contents.toString(), ( err, results ) => {
                        if( err ) {
                            logger.error( `Error parsing ${filename}\n${err}`, 'pre-audit: ' );
                        } else if( !results[ 'declUI:schema' ] || Object.keys( results ).length !== 1 ) {
                            logger.error( `Invalid schema for ${file.path}`, 'pre-audit: ' );
                        } else {
                            cache.audit.xsd[ filename ] = results[ 'declUI:schema' ];
                        }
                    } );
                }
            } ) ) );

        const prePromises = [];
        prePromises.push( i18nSCA );
        prePromises.push( xsdSCA );
        await Promise.all( prePromises ).catch( err => {
            logger.error( err, 'pre-audit: ' );
            logger.pipeErrorHandler( new Error( `Module ${moduleJson.name} failed audit!` ) );
        } );

        const promises = [];
        const gulpSrcSCA = gulp.src( srcSCA, { allowEmpty: true } )
            .pipe( staticCodeAnalysis( moduleJson.name, cache ) );

        promises.push( stream2Promise( gulpSrcSCA ) );
        await Promise.all( promises ).catch( err => {
            logger.error( err, 'audit: ' );
            logger.pipeErrorHandler( new Error( `Module ${moduleJson.name} failed audit!` ) );
        } );
    } );
    logger.success( `StaticCodeAnalysis Successful${stopwatchStaticCodeAnalysis.end()}` );
}

/**
 * Wrapper function to run `npm run pregulp`
 */
async function preGulp() {
    const code = await spawn( npmCmd, [ 'run', 'pregulp' ], null, null, null, msgPrefix );
    if( code !== 0 ) {
        logger.error( `PreGulp FAILED! Exit code = ${code}` );
        process.exit( code );
    }
}

process.on( 'SIGINT', () => {
    logger.warn( 'SIGINT' );
    logger.verbose( `Runtime${stopwatchAll.end()}` );
    process.exit( 2 );
} );
