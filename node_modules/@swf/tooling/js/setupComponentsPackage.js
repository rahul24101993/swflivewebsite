/* eslint-env node */

const ROOT = process.env.LERNA_ROOT_PATH;
const CORE_DIR = `${ROOT}/core`;
const fse = require( 'fs-extra' );
const gulp = require( 'gulp' );
const { stream2Promise } = require( './util' );
const { getSelectedSite, getBuildJson, getAliasMap } = require( '../rewired/utils' );
const declLoader = require( '../rewired/declLoader' );
const through = require( 'through2' );
const rename = require( 'gulp-rename' );
const path = require( 'path' );
const { transformSync } = require( "@babel/core" );
const lookupMap = {};
//Setup Components project
const setupProject = async () => {
    const projectPath = `${ROOT}/components`;
    //Create Images folder
    await fse.ensureDir( projectPath );
    //Copy .npmIgnore and .npmrc files from @swf/core
    await fse.copyFile( `${ROOT}/core/.npmrc`, `${projectPath}/.npmrc` );
    await fse.copyFile( `${ROOT}/core/.npmignore`, `${projectPath}/.npmignore` );
    await fse.ensureDir( `${projectPath}/viewmodel` );
    //Read core package.json to get version and other configs
    const coreJson = await fse.readJson( `${ROOT}/core/package.json` );
    const packageJsonContent = {
        name: "@swf/components",
        version: coreJson.version,
        description: "This repo conteins compiled Components from @swf/core",
        publishConfig: coreJson.publishConfig,
        author: coreJson.author,
        license: coreJson.license
    };
    await fse.writeJson( `${projectPath}/package.json`, packageJsonContent, { spaces: 4 } );
}

//Setup environment to compile components
//We need to Run this script from any application as we want to make sure aliasMap is loaded
const setupEnv = async () => {
    process.env.SITE = 'site_showcase';
    getSelectedSite();
    getAliasMap( [ "node_modules/@swf/core/src" ], true );
}

//Compile SVG images
const compileComponents = async () => {
    const gulpSrc = gulp.src( `${CORE_DIR}/src/**/viewmodel/*ViewModel.json` )
        .pipe( through.obj( ( file, encoding, callback ) => {
            let fileContents = ( file.contents ).toString( encoding );
            const filePath = file.path;
            if( !/[\\/]gaps[\\/]/.test( filePath ) ) {
                const lookupKey = `viewmodel/${path.basename( filePath,'.json' )}`;
                lookupMap[ lookupKey ] = `./viewmodel/${path.basename( filePath, '.json' )}.js`;
            } else {
                console.log( `excluded gaps module ${filePath}` );
            }
            const content = `
            import React from 'react';
            ${declLoader( fileContents, filePath )}`;
            const response = transformSync( content, {
                babelrc: false,
                configFile: false,
                code: true,
                presets: [
                    [
                        require.resolve( '@babel/preset-react' )
                    ]
                ]
            } )
            file.path = path.join( `${ROOT}/components/viewmodel`, `${path.basename(file.path,'.json')}.js` )
            file.contents = Buffer.from( response.code );
            return callback( null, file );
        } ) )
        .pipe( gulp.dest( `${ROOT}/components/viewmodel` ) );
    return stream2Promise( gulpSrc );
};

const createLookupJson = async () => {
    await fse.writeJson( `${ROOT}/components/lookup.json`, lookupMap );
};

const updateLernaConfig = async () => {
    const lernaJson = await fse.readJson( `${ROOT}/lerna.json` );
    lernaJson.packages.push( 'components' );
    await fse.writeJson( `${ROOT}/lerna.json`, lernaJson, { spaces: 4 } );
};

( async () => {
    await setupProject();
    await setupEnv();
    await compileComponents();
    await createLookupJson();
    await updateLernaConfig();
} )().catch( err => {
    console.log( err );
} );
