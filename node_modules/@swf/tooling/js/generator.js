const fs = require( 'fs' );
const fse = require( 'fs-extra' );
const path = require( 'path' );
const readline = require( 'readline' );
const glob = require( 'glob' );
const _ = require( 'lodash' );

const logger = require( './logger' );
const util = require( './util' );

const localVars = {
    MSG_PREFIX: '  generator: ',
    rootDir: process.env.ROOT || process.env.AWC_STAGE_DIR || process.cwd()
};

const separateFileBuildProperties = {
    module: [ 'authenticator', 'states', 'commandsViewModel', 'aliasRegistry' ],
    kit: []
};

// The config which this generator works on.
exports.config = {
    rootDir: localVars.rootDir,
    generatorSources: [
        localVars.rootDir + '/src/generator/generators/*.js',
        localVars.rootDir + '/components/activeworkspace/src/generator/generators/*.js',
        localVars.rootDir + '/conf/generator/generators/*.js',
        localVars.rootDir + '/conf/generator/generators/*.js',
        localVars.rootDir + '/components/activeworkspace/conf/generator/generators/*.js',
        localVars.rootDir + '/node_modules/@swf/tooling/src/generator/generators/*.js',
        localVars.rootDir + '/node_modules/@swf/tooling/conf/generator/generators/*.js'
    ],
    templateDirectory: [
        __dirname + '/../conf/generator/templates',
        localVars.rootDir + '/components/activeworkspace/conf/generator/templates',
        localVars.rootDir + '/src/generator/templates',
        localVars.rootDir + '/components/activeworkspace/src/generator/templates',
        localVars.rootDir + '/node_modules/@swf/tooling/src/generator/templates'
    ],
    allModuleJSONs: '*/module.json',
    generators: {},
    validators: {}
};

/**
 * The arguments currently relevant to the generator.
 */
let activeArguments = process.argv.map( x => {
    return x;
} );

/**
 * Write the messages for the given module
 *
 * @param {Object} module - The module.json
 * @param {Object} messages - The message json
 */
async function writeModuleMessages( module, messages ) {
    const fileName = `${path.dirname( module.__src )}/src/i18n/${module.name}Messages.json`;
    await util.writeFile( fileName, JSON.stringify( messages, null, 4 ) );
}

/**
 * Get the existing message json or a new empty object
 *
 * @param {Object} module - The module to get the messages
 * @return {Object} module messages read from file
 */
async function getModuleMessages( module ) {
    const fileName = `${path.dirname( module.__src )}/src/i18n/${module.name}Messages.json`;
    if( await fse.pathExists( fileName ) ) {
        return fse.readJson( fileName, { throws: false } );
    }
    return {};
}

/**
 * Gets the template file from template directory
 *
 * @param {String} templateFile The template file
 * @param {Boolean} isUtf8 Is utf8 file
 * @return {*} The loaded file
 */
const getTemplateFile = function( templateFile, isUtf8 ) {
    let output = null;
    for( let dir in exports.config.templateDirectory ) {
        let templateDir = exports.config.templateDirectory[ dir ];
        let file = templateDir + '/' + templateFile;
        if( fs.existsSync( file ) ) {
            if( isUtf8 ) {
                output = fs.readFileSync( file, 'utf8' );
            } else {
                output = fs.readFileSync( file );
            }
            break;
        }
    }
    return output;
};

/**
 * @param {*} input todo
 * @param {*} placeholder2Value todo
 * @return {*} todo
 */
const replacePlaceholders = function( input, placeholder2Value ) {
    for( const placeholder in placeholder2Value ) {
        const value = placeholder2Value[ placeholder ];
        input = util.replaceAll( input, placeholder, value );
    }
    return input;
};

const getSourceFile = ( pathRegex ) => {
    return new Promise( ( resolve, reject ) => {
        glob( pathRegex, { cwd: localVars.rootDir }, ( err, files ) => {
            if( err ) {
                return reject( err );
            }
            return resolve( files );
        } );
    } );
};

/**
 * Get all available generators
 *
 * @returns {Object} generators
 */
async function getGenerators() {
    const generatorPaths = await Promise.all( _.map( exports.config.generatorSources, source => getSourceFile( source ) ) );
    const output = {};
    const generators = {};
    generatorPaths.reduce( ( accumulator, files ) => {
        _.forEach( files, filePath => {
            const generatorModule = require( filePath );
            generators[ generatorModule.name ] = generatorModule;
        } );
    }, output );
    return generators;
}

/**
 * Get argument from cli. If argument is provided multiple times the last value is used.
 *
 * @param {String} cliArgId Argument id
 * @returns {String} Argument value
 */
const getCliArg = function( cliArgId ) {
    let argValue = null;
    activeArguments.forEach( ( val, idx ) => {
        if( val === cliArgId ) {
            argValue = activeArguments[ idx + 1 ];
        }
    } );
    return argValue;
};

/**
 * Get the mssage for selecting type
 *
 * @param {GeneratorMap} generators The generators to create message for
 * @returns {String} The message
 */
function getTypeSelectorMessage( generators ) {
    let initMsg = logger.infoColor( '[Info] ' ) + 'Select a type to generate. Available types are:\n\n';
    let msg = Object.keys( generators )
        .sort()
        .map( generatorName => {
            return `${logger.nameColor( generatorName )}: ${logger.infoColor( generators[generatorName].description )}\n`;
        } ).reduce( ( a, b ) => {
            return a + '\n' + b;
        } );
    let endMsg = '\nEnter type to generate: ';
    return initMsg + msg + endMsg;
}

/**
 * Get the build json file to modify.
 *
 * If there is no existing file of the type this will automatically create one and return it.
 * If there is a single existing file of the type it will be returned.
 * If there is more than one existing file of the type it will prompt user to choose which module to modify.
 *
 * @param {String} whatToGet - Name of the build json file to get
 * @returns {Object}  the module.json to modify
 */
async function getOrCreateBuildJson( whatToGet ) {
    let buildJson;
    if( fs.existsSync( `${process.cwd()}/build.json` ) ) {
        buildJson = require( `${process.cwd()}/build.json` );
    } else if( fs.existsSync( `${process.cwd()}/src/build.json` ) ) {
        buildJson = require( `${process.cwd()}/src/build.json` );
    }
    const srcDirs = [];
    if( buildJson && buildJson.srcPaths ) {
        for( const srcPath of buildJson.srcPaths ) {
            srcDirs.push( `${srcPath}/**/${whatToGet}.json` );
        }
    } else {
        srcDirs.push( `src/**/${whatToGet}.json` );
    }
    srcDirs.push( '!src/generator/**' ); // Add negations at the end of the array
    const getName = x => {
        return x.name;
    };
    const moduleMap = await exports.loadAllJson( srcDirs, getName );
    return exports.selectJson( moduleMap, whatToGet );
}

exports.selectJson = async function( moduleMap, whatToGet ) {
    /**
     * @param {String} moduleToLoad - module to load
     * @return {*} *
     */
    function loadModule( moduleToLoad ) {
        return moduleMap[ moduleToLoad ];
    }

    const modules = Object.keys( moduleMap );
    if( modules.length === 0 ) {
        logger.info( `No ${whatToGet} located. Creating a new ${whatToGet}.` );
        return exports.run( [ '-t', whatToGet, '-n', `mysample${whatToGet}` ] ).then( () => {
            return exports.getModule();
        } );
    }
    if( modules.length === 1 ) {
        logger.info( `Selected ${whatToGet} ${logger.nameColor( modules[ 0 ] )} for modification.` );
        return loadModule( modules[ 0 ] );
    }
    const toNameColor = x => {
        return logger.nameColor( x );
    };
    const msg =
        `Multiple ${whatToGet}s available: ${modules.map( toNameColor ).join( ',' )}
Select a ${whatToGet} to modify: `;
    const isLoadedModule = function( input ) {
        return moduleMap[ input ];
    };
    const userInput = await exports.getUserInput( `-${whatToGet}`, msg, isLoadedModule );
    return loadModule( userInput );
};

/**
 * Get icon name to actually use. Ex typeStation48.svg -> typeStation
 *
 * @param {*} iconFileName File name to parse
 * @returns {String} Simplified icon name
 */
function getIconName( iconFileName ) {
    const base = iconFileName.split( '.' )[ 0 ];
    return base.substring( 0, base.length - 2 );
}

/**
 * Load a module json and include in external json files
 *
 * @param {Object} moduleJson The module json to load
 * @returns {Object} The updated module json (same instance, modified in place)
 */
exports.loadModule = function( moduleJson ) {
    const moduleDir = path.dirname( moduleJson.__src );
    // Read in the files next to the module.json
    fs.readdirSync( moduleDir ).forEach( fileName => {
        if( !/\.json$/.test( fileName ) ||
            /^(kit|module|war_.*|site_.*)\.json$/.test( fileName ) ||
            // file name (without file extension) should be present in separateFileBuildProperties array, if not then skip
            !separateFileBuildProperties.module.includes( fileName.substr( 0, fileName.lastIndexOf( '.' ) ) ) ) {
            // skip
            return;
        }
        // Only allow [ 'authenticator', 'states', 'commandsViewModel', 'aliasRegistry' ] sibling files.

        let jsonFilePath = path.join( localVars.rootDir, moduleDir, fileName );
        try {
            let data = require( jsonFilePath );
            if( /^workspace.*\.json$/.test( fileName ) ) {
                if( !moduleJson.hasOwnProperty( 'workspace' ) ) {
                    moduleJson.workspace = {};
                }
                moduleJson.workspace[ data.workspaceId ] = data;
            } else {
                fileName = fileName.replace( /\.json$/i, '' );
                moduleJson[ fileName ] = data;
            }
        } catch ( e ) {
            logger.warn( 'Unable to parse: ' + jsonFilePath );
        }
    } );
    return moduleJson;
};

/**
 * Get the list of available icons
 *
 * @returns {Promise} Promise resolved with icon list
 */
exports.getAvailableIcons = async function() {
    const iconNameList = [];
    const sources = [
        'src/image/*.svg',
        'src/**/image/*.svg',
        'node_modules/@swf/core/src/image/*.svg',
        'node_modules/@swf/core/src/**/image/*.svg'
    ];
    const generatedSourcePaths = await Promise.all( _.map( sources, source => getSourceFile( source ) ) );
    const output = {};
    generatedSourcePaths.reduce( ( accumulator, files ) => {
        _.forEach( files, filePath => {
            iconNameList.push( getIconName( path.basename( filePath ) ) );
        } );
    }, output );
    return iconNameList;
};

/**
 * Create files from their templates
 *
 * @param {Object} targetModuleJson Module to create the modules in
 * @param {Object} filesToCreate Files to create
 * @param {Object} placeholder2Value Template map
 */
exports.createFiles = function( targetModuleJson, filesToCreate, placeholder2Value ) {
    const dir = path.dirname( targetModuleJson.__src );
    for( let templateFile in filesToCreate ) {
        let template = filesToCreate[ templateFile ];
        let output;
        output = getTemplateFile( templateFile, true );
        output = replacePlaceholders( output, placeholder2Value );

        let fileName = replacePlaceholders( templateFile, placeholder2Value );
        // If the template dir contains env variables use those instead of current dir
        const fileDir = template.dir.indexOf( '%' ) === -1 ?
            dir + '/' + template.dir + fileName :
            ( template.dir + fileName ).replace( /%([^%]+)%/g, ( _, n ) => {
                return process.env[ n ];
            } );
        // File may not be in current folder so print path
        if( template.dir.indexOf( '%' ) !== -1 ) {
            logger.info( 'Creating ' + fileDir );
        }
        util.writeFileSync( fileDir, output );
        logger.info( 'Created ' + fileName );
    }
};

/**
 * Update the messages for the given module
 *
 * @param {Object} module - The module to get the messages
 * @param {Object} newMessages - The new messages to add
 * @param {Object} placeholder2Value - The placeholder to value map
 */
exports.updateModuleMessages = async function( module, newMessages, placeholder2Value = {} ) {
    const messages = await getModuleMessages( module );
    for( const i in newMessages ) {
        const actualKey = replacePlaceholders( i, placeholder2Value );
        const actualValue = replacePlaceholders( newMessages[ i ], placeholder2Value );
        if( messages[ actualKey ] && messages[ actualKey ] !== actualValue ) {
            logger.warn( 'Changing %s to %s', actualKey, actualValue );
        }
        messages[ actualKey ] = actualValue;
    }
    await writeModuleMessages( module, messages );
};

/**
 * Get input from user if the command line arg has not already been provided.
 * Will not resolve promise until user input is valid.
 *
 * @param {String} cliArgId - Command line arg to check
 * @param {String} userMessage - Message to display to the user
 * @param {Function} validator - Validator for the user input
 * @param {Function} defaultValue - Default Value to be used, if user doesn't enters anything i.e. just presses enter
 * @returns {Promise} promise w/ valid user input
 */
exports.getUserInput = function( cliArgId, userMessage, validator, defaultValue ) {
    validator = validator || function( x ) {
        return x;
    };
    return new Promise( resolve => {
        const cliArg = getCliArg( cliArgId );
        if( validator( cliArg ) ) {
            resolve( cliArg );
        } else {
            // Readline prompt has problems with multiline strings
            // So log all lines but the first normally and only use prompt for final string
            let lines = userMessage.split( '\n' );
            let out = lines.slice( 0, lines.length - 1 ).join( '\n' );
            let msg = lines.slice( -1 );
            let rl = readline.createInterface( process.stdin, process.stdout );
            /* eslint-disable-next-line no-console */
            console.log( out );
            rl.question( msg[0], input => {
                rl.close();
                // Check if input is valid OR ( no-input received, so choose defaultValue, but provided it is valid too )
                // For easy 'readability' of following if condition code, we need extra parenthesis, thus
                /* eslint-disable-next-line no-extra-parens */
                if( validator( input ) || ( !input && defaultValue && validator( defaultValue ) ) ) {
                    if( validator( input ) ) {
                        resolve( input );
                    } else {
                        resolve( defaultValue );
                    }
                } else {
                    logger.warn( `${input} is not a valid value` );
                    exports.getUserInput( cliArgId, userMessage, validator, defaultValue ).then( resolve );
                }
            } );
        }
    } );
};

/**
 * Load some json files into map based on identifier.
 *
 * @param {String[]} srcDirs - Directories to search
 * @param {Function} identifier - Identifier function
 * @return {Object} all JSON
 */
exports.loadAllJson = async function( srcDirs, identifier ) {
    const sourcePaths = await Promise.all( _.map( srcDirs, source => getSourceFile( source ) ) );
    const output = {};
    const allJson = {};
    sourcePaths.reduce( ( accumulator, files ) => {
        _.forEach( files, filePath => {
            if( fs.existsSync( filePath ) ) {
                let contentsObj = fs.readFileSync( filePath );
                let contents = JSON.parse( contentsObj.toString() );
                allJson[ identifier( contents ) ] = contents;
                contents.__src = filePath;
                if( path.basename( filePath ) === 'module.json' ) {
                    exports.loadModule( contents );
                }
            }
        } );
    }, output );
    return allJson;
};

/**
 * Get the module to modify.
 *
 * If there is no existing modules this will automatically create one and return it.
 * If there is a single existing module it will be returned.
 * If there is more than one existing module it will prompt user to choose which module to modify.
 *
 * @returns {Object} the module.json to modify
 */
exports.getModule = async function() {
    return getOrCreateBuildJson( 'module' );
};

/**
 * Get the kit to modify.
 *
 * If there is no existing modules this will automatically create one and return it.
 * If there is a single existing module it will be returned.
 * If there is more than one existing module it will prompt user to choose which module to modify.
 *
 * @returns {Object} the module.json to modify
 */
exports.getKit = async function() {
    return getOrCreateBuildJson( 'kit' );
};

/**
 * Write the the updated module.json to file system.
 *
 * @param {Object} buildJson - The build json data
 */
exports.writeBuildJson = async function( buildJson ) {
    let src = buildJson.__src;
    let type = path.basename( src, '.json' );
    // Don't write src back to OS
    let dataToWrite = _.clone( buildJson );
    delete dataToWrite.__src;
    // Move specific properties into separate files
    const configPromises = separateFileBuildProperties[ type ].map( propertyToMove => {
        let output = dataToWrite[ propertyToMove ];
        delete dataToWrite[ propertyToMove ];
        if( output ) {
            let fileName = `${path.dirname( src )}/${propertyToMove}.json`;
            return util.writeFile( fileName, JSON.stringify( output, null, 4 ) );
        }
        return Promise.resolve();
    } );
    configPromises.push( util.writeFile( src, JSON.stringify( dataToWrite, null, 4 ) ) );
    await Promise.all( configPromises );
};

/**
 * Run the generator
 *
 * @param {String[]} cliArgs Extra cli args
 */
exports.run = async function( cliArgs ) {
    const originalArgs = activeArguments;
    activeArguments = cliArgs;
    const generators = await getGenerators();
    const checkValidGeneratorType = type => {
        return generators[ type ];
    };

    const type = await exports.getUserInput( '-t', getTypeSelectorMessage( generators ), checkValidGeneratorType );

    logger.info( `Starting the ${logger.nameColor( type )} generator` );
    await generators[ type ].execute();

    // Reset args
    activeArguments = originalArgs; // eslint-disable-line require-atomic-updates

    // Useful to loop generator?
    // const shouldRepeat = await exports.getUserInput( '-q', '\nWould you like to run the generator again? [y/n]\n' );
    // if( shouldRepeat === 'y' ) {
    //     // activeArguments = []; //Removing would reset CLI args (decide if desired later)
    //     return exports.run();
    // }
};

// Run the generator only if it has been invoked from command line
if( require.main === module ) {
    exports.run( process.argv );
}
