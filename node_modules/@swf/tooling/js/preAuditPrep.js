// Copyright (c) 2021 Siemens
/* eslint-disable complexity */
/* eslint-disable no-await-in-loop */

// Pre Audit Prep
//
// Gulp task processes .js and JSON files to build lists of module and kit
// dependencies for audit tasks.  These dependencies are listed in a File
// Info structure for each file.  References to file info are added to cache.audit.
// The cache.audit property contains the following three lookup tables and array:
//  File Path to File Info
//  Module Name to File Info
//  NG Name to File Info
//  moduleNames - Array used to test for duplicate module names
//
// The File Info structure contains the following:
// filePath - the normaized path to the accociated file (refered to below as "this file")
// name - identifier for file level module defined by this file
//        For correct JS files this will be the name given in the @module comment
//        (not to be confused with the Build module name found in JSON module)
//        but may also reference the file's path for JSON files or ill formed JS files
// type - file type "js" or "json"
// deps - array listing all modules that the file depends on
// returnFunctionNames - for JS files array of NG module names returned for module services to inject (may be undefined)
// exportedJsMethods - for JS file methods exposed via the factory method (may be undefined)
// publishedJsMethods - for JS file methods published via Angular factory/service (may be undefined)
// jsFunctions - for JSON View Models the actions that are implemented with JS Functions (may be undefined)
// returnExportsFound - boolean True if an NG factory is returning the exports list (may be undefined)
// ngModules - array listing the NG modules that this file defines or references
//             ngModules is an array of the following structures:
//               name - NG module name for an NG module defined by this file
//                      May be underfined when the statement only defined dependencies such as an inject statement
//                      The named NG modules are AngularJS: controller, directive, factory or service
//               deps - array of NG Module Names that this file references (depends on)
//               functionParameters - array of parameters for the function that implements the NG module or underfined
// test - boolean flag to indicate test or nodejs modules
// actualAtModuleName - name extracted from @module comment (undefined for JSON files)
// targetAtModuleName - the standard name expected in the @module comment (undefined for JSON files)
// moduleJson - reference to the Module JSON object for the JSON module that contains this file
//
// This proces also adds the following information to the Module JSON objects.
//   moduleJson.audit.kits - list of kit JSON objects for the kits that this module belongs to
//                           The build module should only belong to one kit but a list is created to
//                           catch the error case of a module belonging to multiple kits
//   moduleJson.audit.filePath2FileInfo - A lookup table for all files processes for the build module

const _ = require( 'lodash' );
const { pathExists, existsSync } = require( 'fs-extra' );
const gulp = require( 'gulp' );
const pathParse = require( 'path-parse' );

const logger = require( './logger' );
const util = require( './util' );
const i18nUtils = require( './i18n/i18nUtils' );

const acorn = require( 'acorn' );
const acornJsx = require( 'acorn-jsx' );
const walk = require( 'acorn-walk' );
const acornJsxParser = acorn.Parser.extend( acornJsx() );
const { extend } = require( 'acorn-jsx-walk' );
extend( walk.base );
const MSG_PREFIX = 'preAudit: ';

/**
 * @param {Object} cache - cache
 */
module.exports = async function preAuditPrep( cache ) {
    // Add lookup tables to cache to access the file info structure
    // created for each file processed by pre audit prep
    cache.audit = {
        filePath2fileInfo: {},
        dep2fileInfo: {},
        ngName2fileInfo: {},
        customSchema: {},
        declarativeDef: {
            servicesDef: {},
            elementsDef: {}
        },
        moduleNames: [],
        elems: [],
        attrs: []
    };

    const counts = {
        numKits: 0,
        numModules: 0,
        numFilesJS: 0,
        numFilesJSON: 0
    };

    // Add kit JSON references to Model JSON - there should be just one but a list
    // is created to catch error case: where a module is included in multiple kits
    // Also add a module name to Model JSON lookup table to all kit JSON objects
    for( const kitJson of Object.values( cache.filePath2kitJson ) ) {
        counts.numKits++;
        if( !kitJson.i18nFiles ) {
            kitJson.i18nFiles = [];
        }
        for( const moduleName of kitJson.modules ) {
            const moduleJson = cache.name2moduleJson[ moduleName ];
            if( !moduleJson ) {
                logger.error( 'Kit "' + kitJson.name + '" references undefined module: ' + moduleName, MSG_PREFIX );
                continue;
            }
            if( !moduleJson.audit ) {
                moduleJson.audit = {
                    kits: [],
                    filePath2FileInfo: {}
                };
            }
            moduleJson.audit.kits.push( kitJson );
            kitJson.i18nFiles.push( ...await i18nUtils.geti18nFiles( `${moduleJson.moduleDir}` ) );
            const customSchemaFilePath = moduleJson.moduleDir + '/src/schema/declarativeCustomActionTemplateDefsSchema.json';
            if( await pathExists( customSchemaFilePath ) ) {
                const customSchemaFile = require( customSchemaFilePath );

                if( _.isEmpty( cache.audit.customSchema ) ) {
                    cache.audit.customSchema = customSchemaFile;
                } else {
                    // merge the custom schemas
                    const existingActionList = _.cloneDeep( cache.audit.customSchema.definitions.actionDef.oneOf );
                    const newActionList = _.cloneDeep( customSchemaFile.definitions.actionDef.oneOf );

                    if( isCustomActionTemplateMergeable( customSchemaFile, cache.audit.customSchema ) ) {
                        _.merge( cache.audit.customSchema, customSchemaFile );
                        cache.audit.customSchema.definitions.actionDef.oneOf = _.union( newActionList, existingActionList );
                    } else {
                        process.exit( 1 );
                    }
                }
            }
        } // End for each module in this kit
    } // End for each kit
    const isApollo = existsSync( `${process.cwd()}/package.json` ) ? require( `${process.cwd()}/package.json` ).name === '@swf/core' : false;
    i18nUtils.calculateDuplicateI18N( cache ).then( duplicatesCount => {
        if( isApollo ) {
            if( duplicatesCount > 0 ) {
                logger.silly( 'There were ' + duplicatesCount + ' duplicate i18n strings found in afx\n' +
                    'Consider viewing i18nStringDuplicates.json and resolving these duplicates', MSG_PREFIX );
            }
        } else {
            if( duplicatesCount > 0 ) {
                logger.silly( 'There were ' + duplicatesCount + ' duplicate i18n strings found in AW\n' +
                    'Consider viewing i18nStringDuplicates.json and resolving these duplicates', MSG_PREFIX );
            }
        }
    } );

    // Build list of gulp promises to process all files used by a JSON module
    const promiseList = buildPromiseList( counts );

    // Execute all promises and process all module files
    await Promise.all( promiseList ).then( () => {
        logger.info( 'Pre-Audit Prep Processed\n' + counts.numKits + ' kits\n' +
            counts.numModules + ' modules\n' +
            counts.numFilesJS + ' JS files\n' +
            counts.numFilesJSON + ' JSON files\n' +
            _.size( cache.audit.ngName2fileInfo ) + ' NG modules', MSG_PREFIX );
    } );

    /**
     * Validate the custom action template over existing schema
     *
     * @param {Object} newCustomActionTemplateSchema -  new custom actionTemplate schema object
     * @param {Object} existingCustomActionSchema - schema object
     * @return {Boolean} true/false
     */
    function isCustomActionTemplateMergeable( newCustomActionTemplateSchema, existingCustomActionSchema ) {
        // check whether it's mergeable or not
        let isMergeable = true;

        const existingActionList = existingCustomActionSchema.definitions.actionDef.oneOf;
        const newActionList = newCustomActionTemplateSchema.definitions.actionDef.oneOf;

        let commonActions = _.intersection( existingActionList.map( action => {
            return action.if.properties.actionType.const;
        } ), newActionList.map( action => {
            return action.if.properties.actionType.const;
        } ) );

        if( commonActions && commonActions.length ) {
            logger.error( 'Error in custom action schema : Overriding existing Custom ActionType Name !!  ' + commonActions, MSG_PREFIX );
            return false;
        }

        // check whether the definition of custom actionType is conflicting with Apollo's actionType
        _.forIn( newCustomActionTemplateSchema.definitions, ( value, key ) => {
            if( existingCustomActionSchema.definitions[ key ] && key !== 'actionDef' ) {
                isMergeable = false;
                return false;
            }
        } );

        if( !isMergeable ) {
            logger.error( 'Error in custom action schema : Overriding custom ActionType Definitions !!', MSG_PREFIX );
            return false;
        }
        return true;
    }

    /**
     * Build Promise List
     *
     * @param {Object} counts - structure of various counts for file types being processed by pre audit prep
     * @returns {Object} promiseList - List of promises to execute a gulp process for a set of files/folder
     */
    function buildPromiseList( counts ) {
        const promiseList = [];

        // For each module build a list of files for gulp to process
        _.forEach( cache.filePath2moduleJson, moduleJson => {
            counts.numModules++;
            if( !moduleJson.audit ) {
                moduleJson.audit = {
                    kits: [],
                    filePath2FileInfo: {}
                };
            }

            if( moduleJson.type.includes( 'repo' ) ||
                moduleJson.excludeFromAuditDeps ) {
                return; // continue
            }

            // List of files to process for this module
            const srcPath = [
                moduleJson.moduleDir + '/commandsViewModel.json',
                moduleJson.moduleDir + '/dragAndDrop.json',
                moduleJson.moduleDir + '/paste.json',
                moduleJson.moduleDir + '/states.json',
                moduleJson.moduleDir + '/services.json',
                moduleJson.moduleDir + '/elements.json'
            ];

            if( moduleJson.testDir ) {
                srcPath.push( moduleJson.testDir + '/**/*.js' );
            }

            if( moduleJson.srcDir ) {
                // console.log( 'Processing ' + nativeRoot );
                srcPath.push( moduleJson.srcDir + '/**/*.js' );
                srcPath.push( moduleJson.srcDir + '/**/*ViewModel.json' );
            }

            // Build a Promise to Run Gulp to process the listed sets of files/folders
            // and push the promise onto a list for later processing
            const gulpSrc = gulp.src( srcPath, { cwd: 'src', allowEmpty: true } )
                .pipe( util.tapBlock( file => {
                    processFileFromGulp( file, moduleJson, counts );
                } ) );

            promiseList.push( util.stream2Promise( gulpSrc ) );
        } ); // End for each module JSON

        return promiseList;
    }

    /**
     * Process Files From Gulp - this function will build the file info object add refereces to it to cache.audit
     *
     * @param {file} file - File processed by gulp
     * @param {Object} moduleJson - the Module JSON object associated with the given file
     * @param {Object} counts - structure of various counts for file types being processed by pre audit prep
     */
    function processFileFromGulp( file, moduleJson, counts ) {
        // console.log( 'Processing ' + file.path );
        let fileInfo;
        const contents = file.contents.toString();

        const fileNameInfo = pathParse( file.path );
        const filePath = util.normalizePath( file.path );
        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();

        if( fileNameInfo.ext === '.js' ) {
            counts.numFilesJS++;
            try {
                fileInfo = processAST( file );
                fileInfo.type = 'js';

                const endIndex = fileName.lastIndexOf( '.' );
                const fileNameNoExt = fileName.substring( 0, endIndex );
                fileInfo.name = 'js/' + fileNameNoExt; // Name it as a module identifier
            } catch ( err ) {
                logger.error( `Unable to parse ${filePath}`, MSG_PREFIX );
            }
        } else if( fileNameInfo.ext === '.json' ) {
            counts.numFilesJSON++;
            fileInfo = {
                name: filePath,
                type: 'json',
                deps: [],
                jsFunctions: []
            };
            try {
                const data = JSON.parse( contents );
                // added data to declarative cache
                if( fileNameInfo.name === 'services' ) {
                    _.merge( cache.audit.declarativeDef.servicesDef, data );
                } else if( fileNameInfo.name === 'elements' ) {
                    _.merge( cache.audit.declarativeDef.elementsDef, data );
                }
                walkJSON( 'root', data, fileInfo );
            } catch ( err ) {
                logger.error( `Unable to parse ${filePath}`, MSG_PREFIX );
                throw err;
            }
        }

        // Complete any fileInfo objects that were create for JS or JSON files
        if( fileInfo ) {
            fileInfo.name = filePath; // May be replaced with @module name
            fileInfo.filePath = filePath;
            fileInfo.moduleJson = moduleJson;
            moduleJson.audit.filePath2FileInfo[ filePath ] = fileInfo;

            // Capture target @module name (relative to native root or test dir)
            // And extract actual @module name found in the JS file
            // Ignore all files in /lib/ or /src/components/ or /nodejs/ directories
            let rootPath = undefined;
            fileInfo.targetAtModuleName = undefined;
            fileInfo.actualAtModuleName = undefined;

            if( fileInfo.type === 'js' &&
                !/\/(lib|nodejs)\//.test( filePath ) ) {
                if( moduleJson.srcDir ) {
                    rootPath = moduleJson.srcDir;
                }
                if( moduleJson.testDir && filePath.search( moduleJson.testDir ) > -1 ) {
                    rootPath = moduleJson.testDir;
                }
            }

            if( rootPath ) {
                // Construct the expected @module name
                fileInfo.targetAtModuleName = filePath.substring( rootPath.length + 1 )
                    .replace( /(^assets\/|\.js$)/g, '' );

                // Extract the actual @module name
                const ndx = contents.search( /@module / );
                if( ndx > -1 ) {
                    let atModuleName = contents.substring( ndx + 8 );
                    atModuleName = atModuleName.substring( 0, atModuleName.search( /[\n\r]/ ) );
                    fileInfo.actualAtModuleName = atModuleName.replace( /["']/g, '' );
                    // Some module names may be wrapped in quotes in order to be processed properly by JSDoc
                    // Remove such quotes if present in the retrieved module name.
                    fileInfo.name = atModuleName.replace( /["']/g, '' );
                } else {
                    fileInfo.actualAtModuleName = fileInfo.targetAtModuleName; // missing module name default to target name
                    fileInfo.name = fileInfo.actualAtModuleName;
                }
            }

            // Build lookup table from NG names to their associated file info object
            _.forEach( fileInfo.ngModules, ngModule => {
                if( ngModule.name ) {
                    cache.audit.ngName2fileInfo[ ngModule.name ] = fileInfo;
                }
            } );

            // check for duplicate files
            cache.audit.filePath2fileInfo[ filePath ] = fileInfo;
            if( !cache.audit.dep2fileInfo[ fileInfo.name ] ) {
                cache.audit.dep2fileInfo[ fileInfo.name ] = [];
            } else if ( !/test/.test( fileInfo.filePath ) &&  !/test/.test( cache.audit.dep2fileInfo[ fileInfo.name ][ 0 ].filePath ) ) {
                logger.error( `Duplicate entry found for ${fileInfo.name} at - ${fileInfo.filePath} <=> ${cache.audit.dep2fileInfo[ fileInfo.name ][ 0 ].filePath}` );
            }
            cache.audit.dep2fileInfo[ fileInfo.name ].push( fileInfo );
        }
    }

    /**
     * Process AST
     *
     * @param {file} file - AST Tree from a parsed .js file
     * @returns {Object} fileInfo - file information for the current module
     */
    function processAST( file ) {
        const filePath = util.normalizePath( file.path );
        const fileInfo = {
            filePath: filePath,
            deps: [],
            ngModules: [], // Defined NG modules
            testDescribeInfo: [],
            test: /\/(test|nodejs)\//.test( filePath )
        };
        let identifiers = [];

        let ast;
        try {
            ast = acornJsxParser.parse( file.contents.toString(), {
                allowReturnOutsideFunction: true,
                sourceType: 'module',
                ecmaVersion: 11
            } );
        } catch ( err ) {
            logger.error( `Unable to parse ${filePath}\n${err}`, MSG_PREFIX );
            return fileInfo;
        }

        walk.simple( ast, {
            ImportDeclaration: importNode => {
                // handle pattern -- import 'serviceName/directiveName/controllerName'
                // handle pattern -- import defaultSpecifier from 'serviceName/directiveName/controllerName'
                if( importNode.source.type === 'Literal' && importNode.source.value && !fileInfo.deps.includes( importNode.source.value ) ) {
                    fileInfo.deps.push( importNode.source.value );
                }
            },
            VariableDeclaration: varNode => {
                let varDeclaration = _.get( varNode, 'declarations[0]' );
                if( varDeclaration && varDeclaration.id && varDeclaration.id.type === 'Identifier' &&
                    varDeclaration.init && varDeclaration.init.type === 'Literal' ) {
                    identifiers.push( { name: varDeclaration.id.name, value: varDeclaration.init.value } );
                }
            },
            ExportNamedDeclaration: exportNode => {
                let exportDeclaration = _.get( exportNode, 'declaration.declarations[0]' );
                if( exportDeclaration && exportDeclaration.id && exportDeclaration.init && exportDeclaration.id.type === 'Identifier' ) {
                    if( exportDeclaration.init.type === 'Literal' ) {
                        identifiers.push( { name: exportDeclaration.id.name, value: exportDeclaration.init.value } );
                    } else if( exportDeclaration.init.type === 'ArrowFunctionExpression' || exportDeclaration.init.type === 'FunctionExpression' || exportDeclaration.init.type === 'FunctionDeclaration' ) {
                        if( exportDeclaration.init.async === false ) {
                            if( !fileInfo.publishedJsMethods ) {
                                fileInfo.publishedJsMethods = [];
                            }
                            fileInfo.publishedJsMethods.push( exportDeclaration.id.name );
                        } else if( exportDeclaration.init.async === true ) {
                            if( !fileInfo.asyncJSMethods ) {
                                fileInfo.asyncJSMethods = [];
                            }
                            fileInfo.asyncJSMethods.push( exportDeclaration.id.name );
                        }
                    }
                } else {
                    exportDeclaration = _.get( exportNode, 'declaration' );
                    if( exportDeclaration && exportDeclaration.type === 'FunctionDeclaration' ) {
                        if( exportDeclaration.async === false ) {
                            if( !fileInfo.publishedJsMethods ) {
                                fileInfo.publishedJsMethods = [];
                            }
                            fileInfo.publishedJsMethods.push( exportDeclaration.id.name );
                        } else if( exportDeclaration.async === true ) {
                            if( !fileInfo.asyncJSMethods ) {
                                fileInfo.asyncJSMethods = [];
                            }
                            fileInfo.asyncJSMethods.push( exportDeclaration.id.name );
                        }
                    }
                }
            },
            ExportDefaultDeclaration: exportDefaultNode => {
                if( exportDefaultNode.declaration.properties || exportDefaultNode.declaration.right ) {
                    // Audit for DECL View  Model in ES6 Module
                    // Eg. export default = {} and export default exports = {}
                    let exportAstProps = exportDefaultNode.declaration.properties || ( exportDefaultNode.declaration.right ? exportDefaultNode.declaration.right.properties : [] ) || [];
                    _.forEach( exportAstProps, function( prop ) {
                        if( !fileInfo.publishedJsMethods ) {
                            fileInfo.publishedJsMethods = [];
                        }
                        fileInfo.publishedJsMethods.push( prop.key.name );
                    } );
                } else if( exportDefaultNode.declaration.type === 'Identifier' ) {
                    // Audit for DECL View  Model in ES6 Module
                    // Eg. export default exports;
                    let exportedName = exportDefaultNode.declaration.name;
                    // Find named export in variable declaration
                    ast.body.forEach( ( node ) => {
                        /*
                            parse syntax as
                            const exports = {
                                funcA, funcB
                            }
                        */
                        if( node.type === 'VariableDeclaration' && node.declarations ) {
                            let variableDeclaratorNode = node.declarations[ 0 ];
                            if( variableDeclaratorNode.id && variableDeclaratorNode.init && variableDeclaratorNode.id.name === exportedName ) {
                                let exportAstProps = variableDeclaratorNode.init.properties ? variableDeclaratorNode.init.properties : [];
                                _.forEach( exportAstProps, function( prop ) {
                                    if( !fileInfo.publishedJsMethods ) {
                                        fileInfo.publishedJsMethods = [];
                                    }
                                    fileInfo.publishedJsMethods.push( prop.key.name );
                                } );
                            }
                        }
                        /*
                            parse syntax as
                            const exports;
                            ...
                            exports = {
                                funcA, funcB
                            }
                        */
                        if( node.type === 'ExpressionStatement' &&
                            node.expression &&
                            node.expression.left &&
                            node.expression.right &&
                            node.expression.left.name === exportedName ) {
                            let currNode = node.expression.right;
                            if( currNode.type === 'ObjectExpression' && currNode.properties.length > 0 ) {
                                currNode.properties.forEach( ( prop ) => {
                                    if( !fileInfo.publishedJsMethods ) {
                                        fileInfo.publishedJsMethods = [];
                                    }
                                    fileInfo.publishedJsMethods.push( prop.key.name );
                                    return 0;
                                } );
                            }
                        }
                    } );
                } else if( exportDefaultNode.declaration.body && exportDefaultNode.declaration.body.type === 'ClassBody' &&
                    exportDefaultNode.declaration.body.body ) {
                    // Audit for DECL View Model in ES6 Class
                    _.forEach( exportDefaultNode.declaration.body.body, ( prop ) => {
                        if( !prop.static && prop.type === 'MethodDefinition' && prop.kind === 'method' ) {
                            if( !fileInfo.publishedJsMethods ) {
                                fileInfo.publishedJsMethods = [];
                            }
                            fileInfo.publishedJsMethods.push( prop.key.name );
                        }
                    } );
                }
            },
            AssignmentExpression: assignmentNode => {
                if( assignmentNode.left.object ) {
                    if( assignmentNode.left.object.name === 'exports' &&
                        ( assignmentNode.right.type === 'FunctionExpression' ||
                            assignmentNode.right.type === 'CallExpression' &&
                            assignmentNode.right.callee.type === 'MemberExpression' &&
                            assignmentNode.right.callee.object.type === 'Identifier' ) ) {
                        if( !fileInfo.exportedJsMethods ) {
                            fileInfo.exportedJsMethods = [];
                        }
                        fileInfo.exportedJsMethods.push( assignmentNode.left.property.name );
                    } else if( assignmentNode.left.object.type === 'ThisExpression' && assignmentNode.right.type === 'FunctionExpression' ) {
                        if( !fileInfo.publishedJsMethods ) {
                            fileInfo.publishedJsMethods = [];
                        }
                        fileInfo.publishedJsMethods.push( assignmentNode.left.property.name );
                    } else if( assignmentNode.left.object.name === 'self' && assignmentNode.left.type === 'MemberExpression' &&
                        assignmentNode.right.type === 'FunctionExpression' ) {
                        if( !fileInfo.publishedJsMethods ) {
                            fileInfo.publishedJsMethods = [];
                        }
                        fileInfo.publishedJsMethods.push( assignmentNode.left.property.name );
                    }
                    if( assignmentNode.right && assignmentNode.right.async === true ) {
                        if( !fileInfo.asyncJSMethods ) {
                            fileInfo.asyncJSMethods = [];
                        }
                        fileInfo.asyncJSMethods.push( assignmentNode.left.property.name );
                    }
                }
            },
            ExpressionStatement: expressionNode => {
                if( expressionNode.type && expressionNode.type === 'ExpressionStatement' && expressionNode.expression ) {
                    let expression = expressionNode.expression;
                    if( expression.type && expression.type === 'AssignmentExpression' && expression.left && expression.right ) {
                        let left = expression.left;
                        let right = expression.right;
                        if( left.type && right.type && left.type === 'MemberExpression' && ( right.type === 'FunctionExpression' || right.type === 'ArrowFunctionExpression' ) ) {
                            if( left.object && left.object.type && left.object.type === 'Identifier' && left.object.name === 'exports' &&
                                left.property && left.property.type && left.property.type === 'Identifier' ) {
                                if( right.async === false ) {
                                    if( !fileInfo.publishedJsMethods ) {
                                        fileInfo.publishedJsMethods = [];
                                    }
                                    fileInfo.publishedJsMethods.push( left.property.name );
                                } else if( right.async === true ) {
                                    if( !fileInfo.asyncJSMethods ) {
                                        fileInfo.asyncJSMethods = [];
                                    }
                                    fileInfo.asyncJSMethods.push( left.property.name );
                                }
                            }
                        }
                    }
                }
            },
            CallExpression: callNode => {
                // If this statement defines an NG module the name will be captured
                // If this statement only references NG module then only the dependencies are listed
                // This statement may also define an NG module which depends on other modules
                const ngModule = {
                    name: undefined, // NG Module name
                    deps: [], // NG dependency list
                    functionParameters: [] // Module parameter list
                };

                const callee = callNode.callee;
                if( callee.name && /define/.test( callee.name ) ) {
                    findReturnExports( callNode, fileInfo );
                }
                if( /test(\/|\\)\S*Test\.js$/.test( file.path ) && callee.type === 'Identifier' && callee.name === 'describe' ) {
                    let describeInfo = {
                        describeName: callNode.arguments[ 0 ].value
                    };
                    fileInfo.testDescribeInfo.push( describeInfo );
                }
                if( callee.name === 'inject' &&
                    callNode.arguments.length === 1 &&
                    callNode.arguments[ 0 ].type === 'FunctionExpression' ) {
                    // handle pattern -- inject( function( ngServiceName ) { } ) );
                    for( const param of callNode.arguments[ 0 ].params ) {
                        if( param.type === 'Identifier' ) {
                            ngModule.deps.push( param.name.replace( /^_/, '' ).replace( /_$/, '' ) );
                        }
                    }
                } else if( callee.object && callee.object.callee && callee.object.callee.property &&
                    callee.object.callee.property.name === 'getInjector' &&
                    callee.property && callee.property.name === 'get' &&
                    callNode.arguments[ 0 ].type === 'Literal' ) {
                    // handle pattern -- app.getInjector().get( 'myNgModuleName' );
                    ngModule.deps.push( callNode.arguments[ 0 ].value );
                    // TODO report if using an injector unnecessarily, i.e. use standard inject
                } else if( callee.object && callee.property &&
                    callNode.arguments.length === 2 &&
                    ( callNode.arguments[ 0 ].type === 'Literal' ||
                        callNode.arguments[ 0 ].type === 'Identifier' ) &&
                    // callee.object.name === 'app' && // avoid unnecessary assumption
                    callee.object.type === 'Identifier' &&
                    callee.property.name &&
                    /^(controller|directive|factory|service|constant)$/.test( callee.property.name ) ) {
                    findReturnExports( callNode, fileInfo );
                    if( callNode.arguments[ 0 ].type === 'Identifier' ) {
                        const identifierName = callNode.arguments[ 0 ].name;
                        //Search identifierName in the identifiers array
                        const found = _.find( identifiers, ident => ident.name === identifierName );
                        if( found ) {
                            ngModule.name = found.value;
                        }
                    } else {
                        ngModule.name = callNode.arguments[ 0 ].value;
                    }

                    if( callee.property.name === 'directive' ) {
                        ngModule.name += 'Directive';
                    }

                    // handle pattern -- app.controller( 'myNgService', [ 'otherNgService',  function(){} )
                    // handle pattern -- app.directive( 'myNgService', [ 'otherNgService',  function(){} )
                    // handle pattern -- app.factory( 'myNgService', [ 'otherNgService',  function(){} )
                    // handle pattern -- app.service( 'myNgService', [ 'otherNgService',  function(){} )
                    if( callNode.arguments[ 1 ].type === 'ArrayExpression' ) {
                        let hasFunctionExpression = false;
                        for( const element of callNode.arguments[ 1 ].elements ) {
                            switch ( element.type ) {
                                case 'Literal':
                                    ngModule.deps.push( element.value );
                                    break;
                                case 'Identifier':
                                    if( /factory/.test( callee.property.name ) ) {
                                        ngModule.deps.push( element.name );
                                    }
                                    break;
                                case 'FunctionExpression':
                                    hasFunctionExpression = true;
                                    for( const param of element.params ) { ngModule.functionParameters.push( param.name ); }
                                    if( /factory/.test( callee.property.name ) ) {
                                        findReturnExports( element, fileInfo );
                                    }
                                    break;
                            }
                        }

                        if( !hasFunctionExpression ) {
                            ngModule.deps.pop();
                        }
                    } else if( callNode.arguments[ 1 ].type === 'FunctionExpression' &&
                        /factory/.test( callee.property.name ) ) {
                        findReturnExports( callNode.arguments[ 1 ], fileInfo );
                    } else if( callNode.arguments[ 1 ].type === 'Identifier' ) {
                        fileInfo.returnExportsFound = true;
                    }
                }

                // Capture any NG module that was defined by this statment
                if( ngModule.name || ngModule.deps.length > 0 ) {
                    fileInfo.ngModules.push( ngModule );
                }
            },
            ReturnStatement: returnNode => {
                if( returnNode.argument &&
                    returnNode.argument.type === 'ObjectExpression' &&
                    !fileInfo.test ) {
                    for( const property of returnNode.argument.properties ) {
                        if( property.key && property.key.name === 'moduleServiceNameToInject' ) {
                            if( !fileInfo.returnFunctionNames ) {
                                fileInfo.returnFunctionNames = [];
                            }
                            fileInfo.returnFunctionNames.push( property.value.value );
                        }
                    }
                }
            }
        }, {
            ...walk.base,
            JSXElement: () => {}
        } ); // End AST Walk

        return fileInfo;
    }

    /**
     * Find Return Exports - walk a subset of the AST tree to find the return exports statement
     *
     * @param {object} astNode - A node the the AST Tree from a parsed .js file
     * @param {Object} fileInfo - file information for the current module
     */
    function findReturnExports( astNode, fileInfo ) {
        walk.simple( astNode, {
            ReturnStatement: returnNode => {
                if( returnNode.argument && returnNode.argument.type === 'Identifier' &&
                    returnNode.argument.name === 'exports' ) {
                    fileInfo.returnExportsFound = true;
                }
            }
        }, {
            ...walk.base
        } );
    }

    /**
     * Walk JSON
     *
     * @param {String} key - key for the JSON Tree node ("root" for first node)
     * @param {Object} data - Parsed JSON Tree
     * @param {Object} fileInfo - File Info being built for the current module
     */
    function walkJSON( key, data, fileInfo ) {
        // Capture view model JS Function dependencies
        if( data.actionType ) {
            if( data.actionType === 'JSFunction' || data.actionType === 'JSFunctionAsync' || data.actionType === 'syncFunction' ) {
                const jsDep = {
                    actionName: key,
                    actionType: data.actionType,
                    moduleName: data.deps,
                    method: data.method
                };
                fileInfo.jsFunctions.push( jsDep );
            }
        }

        if( data.lifecycleHooks?.render && data.actions && data.actions[data.lifecycleHooks.render] ) {
            const renderDeps = data.actions[data.lifecycleHooks.render].deps;
            const renderMethod = data.actions[data.lifecycleHooks.render].method;
            const jsDep = {
                actionName: data.lifecycleHooks.render,
                actionType: 'render',
                moduleName: renderDeps,
                method: renderMethod
            };
            fileInfo.jsFunctions.push( jsDep );
        }

        if( data.ctx ) {
            for ( const key in data.ctx ) {
                if( data.ctx[key] && data.ctx[key].parser ) {
                    const deps = data.ctx[key].parser.deps;
                    const method = data.ctx[key].parser.method;

                    const jsDep = {
                        actionName: key,
                        actionType: 'ctxParser',
                        moduleName: deps,
                        method: method
                    };
                    fileInfo.jsFunctions.push( jsDep );
                }
            }
        }


        // Capture all dependencies
        _.forEach( data, ( value, key ) => {
            if( _.isString( key ) &&
                /^(deps|dependencies|imports)$/.test( key ) ) {
                if( _.isArray( value ) ) {
                    fileInfo.deps = fileInfo.deps.concat( value );
                } else if( _.isString( value ) ) {
                    fileInfo.deps.push( value );
                }
            }
            if( key && value ) {
                // Only continue if the value is another JSON node
                if( !_.isString( value ) && key !== 'ctx' ) {
                    walkJSON( key, value, fileInfo );
                }
            }
        } );
    }
};
