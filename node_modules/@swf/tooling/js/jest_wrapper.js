// Copyright (c) 2022 Siemens

/**
 * This script wraps the react-app-rewired test command to allow for extra processing to test against our kit/module structure
 * in an attempt to separate the 'build' wrapper and the 'test' wrapper
 *
 * Since jest does not take extra cli parameters outside of its own defined CLI this file is needed to support the custom CLI.
 * The CLI accepts --kitName=<> and --moduleName=<> to allow for testing againt a specific kit or module.
 */

const logger = require( './logger' );
const { queue, spawn } = require( './util' );
const { pathExists } = require( 'fs-extra' );
const _ = require( 'lodash' );

const cmdSuffix = process.platform === 'win32' && '.cmd' || ''; // path.join( process.env.NODEJS_HOME, 'npm.cmd' );
const msgPrefix = '+ ';
const npmCmd = process.platform === 'win32' && 'npm.cmd' || 'npm'; // path.join( process.env.NODEJS_HOME, 'npm.cmd' );

const stopwatchAll = new logger.Stopwatch();
let logLevel = 1;

let passFlag = false;
let failFlag = false;
let endFlag = false;
let summaryFlag = false;
const failedTests = [];
let passCount = 0;

/**
 * Main function resposible for processing command line args
 */
( async function() {
    let moduleName;
    let kitName;
    let allTests = false;
    const options = { env: { ...process.env } };
    const args = [];
    for( let ndx = 2; ndx < process.argv.length; ndx++ ) {
        if( process.argv[ ndx ].includes( '--moduleName=' ) ) {
            moduleName = process.argv[ ndx ].split( '=' )[ 1 ];
            options.env.TESTED_MODULE = moduleName;
        } else if( process.argv[ ndx ].includes( '--kitName=' ) ) {
            kitName = process.argv[ ndx ].split( '=' )[ 1 ];
            options.env.TESTED_KIT = kitName;
        } else if( process.argv[ ndx ] === '--all' ) {
            allTests = true;
        } else if( process.argv[ ndx ].includes( '--logLevel=' ) ) {
            logLevel = parseInt( process.argv[ ndx ].split( '=' )[ 1 ] );
        } else {
            args.push( process.argv[ ndx ] );
        }
    }

    if( allTests ) {
        await runAllTests( args );
    } else {
        const code = await spawn( `react-app-rewired${cmdSuffix}`, args, options, null, filter, msgPrefix );
        if( code !== 0 ) {
            process.exitCode = code;
            throw new Error();
        }
    }
    // delay output to allow async logger output to finish
    setTimeout( () => {
        if( passCount ) {
            logger.info( `${passCount} passing tests` );
        }
        logger.success( `Successful${stopwatchAll.end()}` );
    }, 1 );
} )().catch( err => {
    // delay output to allow async logger output to finish
    setTimeout( () => {
        logger.debug( err );
        if( passCount ) {
            logger.info( `${passCount} passing tests` );
        }
        if( failedTests ) {
            failedTests.sort();
            logger.error( `${failedTests.length} failed test(s):\n\t${ failedTests.join( '\n\t' )}` );
        }
        process.exitCode = process.exitCode || 1;
        logger.error( `FAILED! Exit code = ${process.exitCode}${stopwatchAll.end()}` );
    }, 1 );
} );

/**
 * @param {String} line - line input
 * @returns {Boolean} true to filter
 */
function filter( line ) {
    if( /^\bPASS\b/.test( line ) && !summaryFlag ) {
        logger.info( line, msgPrefix );
        passCount++;
        failFlag = false;
        passFlag = true;
    } else if( /^\bFAIL\b/.test( line ) && !summaryFlag ) {
        failedTests.push( line.split( ' ' )[ 1 ] );
        failFlag = true;
        passFlag = false;
    } else if( /Summary of all failing tests/.test( line ) ) {
        summaryFlag = true;
    } else if( /config-overrides:/.test( line ) ) {
        return false;
    } else if( /Test Suites:/.test( line ) ) {
        logger.info( line, msgPrefix );
        endFlag = true;
        failFlag = false;
        passFlag = false;
    }

    if( failFlag ) {
        return false;
    } else if( passFlag && logLevel === 1 || summaryFlag || endFlag ) {
        logger.info( line, msgPrefix );
    }
    return true;
}

/**
 * Run all the tests separating by kit
 * @param {Array} args array of arguments
 */
async function runAllTests( args ) {
    //Get cache object or generate it.
    const cacheJsonPath = `${process.cwd()}/out/cache.json`;
    if( !await pathExists( cacheJsonPath ) ) {
        await preGulp();
    }
    const cache = await pathExists( cacheJsonPath ) && require( cacheJsonPath ) || {};
    const testPromises = [];
    cache.name2moduleJson = {};
    _.forEach( cache.filePath2moduleJson, ( moduleJson ) => {
        cache.name2moduleJson[ moduleJson.name ] = moduleJson;
    } );
    _.forEach( cache.filePath2kitJson, ( kitJson, filePath ) => {
        kitJson.testDirs = [];
        if( kitJson.modules && !filePath.includes( 'node_modules' ) ) {
            for( const moduleName of kitJson.modules ) {
                if( cache.name2moduleJson[ moduleName ] && cache.name2moduleJson[ moduleName ].testDir ) {
                    kitJson.testDirs.push( cache.name2moduleJson[ moduleName ].testDir );
                }
            }
            if( kitJson.testDirs.length > 0 ) {
                const kitArgs = [ ...args, ...kitJson.testDirs ];
                const options = { env: { ...process.env, TESTED_KIT: kitJson.name } };
                testPromises.push( runKitTest( kitArgs, options ) );
            }
        }
    } );

    await Promise.all( testPromises );
}

/**
 * Generate kit test runs
 * @param {Array} kitArgs - arguments to be passed to each kit run
 * @param {Object} options - env options to be passed to spawn command
 */
async function runKitTest( kitArgs, options ) {
    const done = await queue( 'jest', 2 );
    const code = await spawn( `react-app-rewired${cmdSuffix}`, kitArgs, options, null, filter, msgPrefix );
    if( code ) {
        process.exitCode = code;
        throw new Error();
    }
    done();
}

/**
 * Wrapper function to run `npm run pregulp`
 */
async function preGulp() {
    const code = await spawn( npmCmd, [ 'run', 'pregulp' ], null, null, null, msgPrefix );
    if( code !== 0 ) {
        process.exitCode = code;
        throw new Error( 'PreGulp FAILED!' );
    }
}
